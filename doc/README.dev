=====================[ README.dev                         ]=====================

---------------------( CONSIDERED RISKY                   )---------------------
Zeshy suffers from more than a few dewy gotchas, deriving from its underlying
dependence on Zsh. These are:

* Variable declaration. *DO NOT DEFINE VARIABLES WHEN DECLARING VARIABLES*.
  Rather, separate variable declaration and definition into two separate
  statements: e.g.,

      # Bad. Baaaad. Never do this, even if the Zeshy codebase sometimes does.
      # If get_first_file() throws an exception in the event of finding neither
      # "/rache" or "/bartmoss", the definition of ${brainware_blowout} still
      # silently succeeds. (Wut.)
      >>> string brainware_blowout="$(get_first_file /rache /bartmoss)"

      # Good. Goood. Always do this. ("Always" means somewhat more than never.)
      # If get_first_file() throws such an exception, the definition of
      # ${brainware_blowout} fails with an exception. Which is good.
      >>> string brainware_blowout
      >>> brainware_blowout="$(get_first_file /rache /bartmoss)"

  Certainly, the former form appears preferable. It's more concise. It's what
  high-level languages admit. It's what Zsh *SUPERFICIALLY* admits. Alas, the
  former suffers critical defects in the event of unexpected exceptions, errors,
  or other fatal conundra.

  In Zsh, syntactically correct declarations succeed with zero exit status even
  if some definition(s) in such declarations fail. Reread that sentence. It
  doesn't particularly make intuitive sense, does it? Declarations whose
  definitions fail should also fail. But they do not. Declarations effectively
  never fail. Which is why you should *NEVER* mix declarations and definitions
  -- at least, not declarations and definitions subject to possible failure.

  The line between safe and unsafe mixing is subtle, blurry, and best left to
  the capricious whimsy of Zeshy developers. Please, for the sake of scripted
  sanity, avoid mixing declarations and definitions. Establish good habits. (Not
  like us. We revel in bad habits...and, ooh, do we pay for it.)

* Integer variable declaration. *DO NOT DECLARE FUNCTION PARAMETERS TO BE
  "integer" WITHOUT PRIOR VERIFICATION*. Zsh erroneously converts "integer"
  values to integers, even for values with no reasonable conversion: e.g.,

      >>> integer bad_int="oio_ooo_oio_ooo"
      >>> print ${bad_int}
      0

  Zsh fails to provide an option for implicitly failing rather than converting
  erroneous integer values. Function parameters cannot be safely trusted to be
  integral and hence must be explicitly checked prior to assignment: e.g.,

      # A function accepting one integer parameter and dying otherwise.
      >>> sturgeon_surge() {
      ...   die_unless_integer "${1}"
      ...   integer good_int=${1}
      ...   print ${good_int}
      ... }
      >>> sturgeon_surge "oio_ooo_oio_ooo"
      sturgeon_surge: "oio_ooo_oio_ooo" not an integer

* Pass by reference. No shell, including Zsh, currently provides pass by
  reference function semantics. This implies, in particular, that arrays may
  neither be directly passed to or returned from functions as a single
  argument. Nevertheless, there is a simple mechanism for passing *ONE* array as
  a list of arguments to a function: e.g.,

      # void apple_of_my_eye(int scalar1, char *scalar2, int *array)
      #
      # A function accepting two scalars followed by an array, called like so:
      #     SHEA=( "The Eye of the Pyramid" "Swift Kick Inc." )
      #     apple_of_my_eye 1776 "The Man Who Murdered God" "${SHEA[@]}"
      apple_of_my_eye() {
          local scalar1=$1; shift
          local scalar2=$2; shift
          local -A array
          set -A array "$@"   # or equivalently...
          array=( "$@" )      # ...is perhaps more readable
      }

  An alternative mechanism for passing multiple arrays requires the caller
  instead pass the names of locally or globally declared arrays, which the
  function then accesses via the "(P)" parameter expansion: e.g.,

      # void fire_of_my_loins(int *array1, char **array2)
      #
      # A function accepting two arrays, called like so:
      #     ROBERT=( "The Man Who Murdered God" )
      #     WILSON=( "Walpurgisnacht Rock" "Leviathan" )
      #     fire_of_my_loins 1976 ROBERT WILSON
      fire_of_my_loins() {
          local -A array1; set -A array1 "${(P)1}"
          local -A array2; set -A array2 "${(P)2}"
      }

  Unfortunately, there exists no comparable mechanism for returning arrays by
  value due to quoting issues. The best approximation is a terrible hack: e.g.,

      # char **light_of_my_life(void)
      #
      # A function returning an array of strings, called like so:
      #     DOG=$(light_of_my_life)     # the return value as a scalar...
      #     GOD=( "${(Q@)${(z)DOG}}" )  # ...parsed into this array
      light_of_my_life() {
          local -A array
          array=( "Heute die Welt" "Morgens das Sonnensystem!" )
          echo "${${(@qqkv)array}[@]}"    # yes, this is bad. not the good kind.
      }

  The above actually works in the general sense, but could (at best) be called
  one step from code apoptosism. The only sensible alternative is to require the
  user pass the name of an array to be set by this function as above.

  For alternative (not necessarily cleverer) hacks, see:
  http://www.zsh.org/mla/users/2004/msg01096.html

