#!/usr/bin/env zsh
# ====================[ zeshy                              ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# If passed no arguments, run Zeshy as an interactive shell under the current
# terminal; otherwise, run the passed command line or shell script under Zeshy.
#
# --------------------( OPTIONS                            )--------------------
# Zeshy accepts most command-line options accepted by zsh.
#
# --------------------( SCRIPTS                            )--------------------
# Zeshy scripts may load Zeshy by adding a shebang line to the first line of
# such files. For cross-platform portability, consider the following line:
#
#     #!/usr/bin/env zeshy
#
# Zeshy accepts most shell scripts accepted by zsh. However, several strategic
# design differences between Zeshy and zsh preclude perfect backward
# compatibility. The largest difference is strictness: Zeshy always throws an
# exception on any alias, command, or function returning non-zero exit status;
# zsh, on the other hand, ignores non-zero exit status where not explicitly
# handled (e.g., by appending "|| { print 'command failed' 1>&2; exit 1 }" to
# commands expected to fail).
#
# --------------------( TODO                               )--------------------
# * Document somewhere that setting Zeshy as a user's default "/etc/passwd"
#   shell requires adding "zeshy-login" to "/etc/shells" under Linux and
#   "zeshy-login" as the corresponding shell field.
# * The fact that zsh squelches "-" prefixes on ${argv[0]} is a clue that we
#   probably want to reimplement this script in POSIX C. (Could be quite fun,
#   actually, aside from the fact that it'll require a substantially smarter
#   Zeshy makefile.) Shouldn't be a terribly large file; everything we're doing
#   here *SHOULD* have a direct C analogue. The potential startup speedup makes
#   this a particularly worthwhile improvement.
#print "[${0}] starting zeshy wrapper"

# ....................{ SHELL                              }....................
# Enable shell strictness. While Zeshy replaces such crude options with
# considerably more robust error handling (e.g., printing stack traces and help
# documentation on errors), this certainly beats the default do-nothing logic.
#
# Enable extended glob expressions for use in option checking.
setopt err_return no_unset warn_create_global extended_glob

# ....................{ PATHS                              }....................
#FIXME: The "install" script *MUST* absolutely globally replace all instances of
#  @ZESHY_HOME@ in this script. (There should only be one such instance,
#  but... *shrug*.) The at sign "@" is particularly helpful for this
#  purpose, as it appears to have no current reserved uses in zsh.

# Absolute path of the main Zeshy overlay (i.e., topmost Zeshy directory).
# Zeshy's installation script defaults such path to that passed to that script.
# Export such path for reuse by Zeshy component "main", sourced below.
export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"

# If such path has not been replaced, the user failed to install Zeshy (e.g.,
# due to legitimately running Zeshy under a cloned "git" repository). Detect
# this and attempt to respond rationally.
if [[ "${ZESHY_HOME}" == '@ZESHY_HOME@' ]]; then
    # Absolute path of the the current script. Since the following statement
    # erroneously interprets a trailing "(:A)" as a literal string rather than
    # shell word modifier, embed the trailing "(:A)" in a command substitution:
    # e.g.,
    #
    #     # This utterly fails. (Thanks, zsh.)
    #     >>> zeshy_filename="${0}"(:A) && print ${zeshy_filename}
    #     /usr/bin/zeshy(:A)
    local zeshy_filename; zeshy_filename="$(print -- "${0}"(:A))" &>/dev/null || {
        print "zeshy: current script \"${0}\" not found" 1>&2
        exit 1
    }
    #print "zeshy_filename: ${zeshy_filename}"

    # Absolute path of the directory containing this script.
    local zeshy_bin_dir="${zeshy_filename:h}"

    # Absolute path of the main Zeshy overlay, given such paths.
    ZESHY_HOME="$(print -- "${zeshy_bin_dir}/../src"(:A))" &>/dev/null || {
        print "zeshy: main overlay \"${zeshy_bin_dir}/../src\" not found" 1>&2
        print "zeshy: current script \"${0}\" not installed or installed incorrectly" 1>&2
        exit 1
    }
# If such path is not found, fail with error.
elif ! [[ -d "${ZESHY_HOME}" ]]; then
    print "zeshy: main overlay \"${ZESHY_HOME}\" not found" 1>&2
    exit 1
fi
#print "ZESHY_HOME: ${ZESHY_HOME}"

# Absolute path of the root Zeshy overlay's startup script, which when sourced
# loads all Zeshy aliases, functions, and globals specific to the current user.
#
# Export such path for reuse by Zeshy dot directory scripts implicitly sourced
# below, when opening interactive and login zsh shells.
export ZESHY_HOME_SCRIPT="${ZESHY_HOME}/main"

# If such path is not found, fail with error.
[[ -f "${ZESHY_HOME_SCRIPT}" ]] || {
    print "zeshy: main script \"${ZESHY_HOME_SCRIPT}\" not found" 1>&2
    exit 1
}

# ....................{ OPTIONS                            }....................
# If called as "zeshy-login", prepend option "-l" to the passed arguments.
# Ideally, this script would itself ascertain whether or not it was run as a
# login shell by a process running "login". Such process reliably prefixes the
# ${argv[0]} string identifying the name of this process with "-", thus
# signifying this shell to be a login shell. Unfortunately, zsh squelches such
# "-" unless explicitly running this script under "zsh" rather than an implicit
# shebang line (e.g., as "- zsh /usr/bin/zeshy" rather than "- /usr/bin/zeshy").
#
# While replacing this script with a customary C-based binary would rectify such
# issue, "the best laid schemes of mice and men/often go awry."
[[ "${0:t}" == 'zeshy-login' ]] && set -- -l "${@}"

# If passed no arguments specifying a course of action, default to opening an
# interactive shell by prepending option "-i" *AFTER* testing whether we were
# called as a login shell. Dismantled, this is:
#
# * "${@[(i)...]}", expanding to the 1-based index of the first passed argument
#   matching such glob or to the number of such arguments plus 1 if no argument
#   matches such glob:
#   * "[^-]*", matching a non-option argument if passed. In Zeshy's case, such
#     argument *ALWAYS* signifies a script to be sourced.
#   * "-[a-z]#[chilv][a-z]#", matching a string of short arguments containing at
#     least one of options "-c", "-h", "-i", "-l", or "-v". See "zeshy -h" for
#     further details.
# * "#", expanding to the number of such arguments.
(( ${@[(i)([^-]*|-[a-z]#[chilv][a-z]#|--(command=*|help|interactive|login|version))]} <= # )) || {
#   print 'passed no other action; defaulting to interactive (i.e., "-i")'
    # If standard input to the current shell is attached to a terminal, drop the
    # caller into an interactive Zeshy shell.
    if [[ -t 0 ]]
    then set -- -i "${@}"
    # Otherwise, drop the caller off the Tarabithian bridge.
    else die 'expected at least one argument when called non-interactively'
    fi
}

# Load module "zutil", defining zparseargs() and other core builtins.
zmodload zsh/zutil

# Parse passed options specific to this script, propagating all other arguments
# to the main Zeshy script. If such parsing fails, print the help string to
# standard error and exit with non-zero status. See parse_arg_options() for
# further details. While it *SHOULD* be theoretically infeasible for parsing of
# such simple options to fail, one just never knows.
#
# Map long- to short-form options (e.g., "--interactive" to "-i") rather than
# the other way around to simplify zsh interaction below. If such options were
# passed, we in turn pass such options to zsh. Since zsh may or may not expect
# long-form options depending on platform or version, prefer short-form options.
local -A arg_options
zparseopts -M -D -E -A arg_options -- i l -interactive=i -login=l || {
    print -- "zeshy: passed invalid or unknown options" 1>&2
    exit 1
}

# ....................{ MAIN                               }....................
# If passed either "-l" or "-i", replace the current process with a new process
# running zsh under such options. Since changing such options changes zsh's
# startup behavior, such options cannot be changed at runtime but must be
# explicitly passed to the "zsh" command. Since login shells are implicitly
# interactive, "-l" subsumes "-i". Hence, test the latter before the former.
if (( ${#arg_options} )); then
#   print "[${0}] sourcing interactively ${ZESHY_HOME_SCRIPT} ${*}"
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Order of globals is important here. In particular, declaring ${ZDOTDIR}
    #prior to ${ZESHY_ZDOTDIR_USER} results in the latter copying the former,
    #resulting in infinite recursion. (Yes, it's a dangerous world we live in.)
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Replace the non-interactive zsh process sourcing this script with an
    # interactive zsh process sourcing Zeshy-specific dot files ".zprofile",
    # ".zshrc", and ".zlogin" implicitly sourcing the current user's zsh-
    # specific analogues of the same scripts *AND* the main Zeshy script.
    # Run such process with access to the following globals, subsequently
    # referenced by Zeshy's ".zshrc":
    #
    # * ${ZESHY_ZDOTDIR_USER}, the absolute path of the current user's zsh-
    #   specific dot directory, defaulting to such user's home directory.
    # * ${ZESHY_ARGS}, the list of all arguments passed to this script,
    #   losslessly converted into a string for subsequent conversion back to a
    #   list. Export for subsequent importation by Zeshy's ".zshrc". See
    #   convert_list_to_string() for further details on such conversion.
    #   Separate such export's declaration and definition to avoid errors
    #   resembling
    #   "/usr/bin/zeshy:export:179: not valid in this context: '--version'".
    # * ${ZDOTDIR}. See "man zshparam".
    #
    # Dismantled, this is:
    #
    # * "(k)", listing all map keys and thus options "-l" and/or "-i" if passed.
    ZESHY_ZDOTDIR_USER="${ZDOTDIR:-${HOME}}"\
    ZESHY_ARGS="${(qq)@}"\
    ZDOTDIR="${ZESHY_HOME}"\
        exec zsh ${(k)arg_options}
# Else source the main Zeshy script with the passed arguments under the current
# zsh process.
else
#   print "[${0}] sourcing non-interactively ${ZESHY_HOME_SCRIPT} ${*}"
    source -- "${ZESHY_HOME_SCRIPT}" "${@}"
fi

# --------------------( WASTELANDS                         )--------------------
#   export ZESHY_ZDOTDIR_USER="${ZDOTDIR:-${HOME}}"

    # List of all arguments passed to this script, losslessly converted into a
    # string for subsequent conversion back to a list. Export for subsequent
    # importation by Zeshy's ".zshrc". See convert_list_to_string() for further
    # details on such conversion. Separate such export's declaration and
    # definition to avoid errors resembling
    # "/usr/bin/zeshy:export:179: not valid in this context: '--version'".
#   export ZESHY_ARGS; ZESHY_ARGS="${(qq)@}"

#FUXME: Not right. Revise this test (and only this test, I believe) to test for
#whether the caller passed either "-c", "-i", "-l", or a non-"-"-prefixed
#option. If any is the case, do *NOT* prepend "-i" to the argument list;
#otherwise, do. Since we prefer "||"-style testing, this should be fairly
#straightforward to test in the positive statement above.
#[[ -n "${@:#([^-]*|-([^-]|)[a-z]#[cil][a-z]#)}" ]]
#(( # )) || print 'zeshy: no runnable args passed!'

# by the current system or user during Zeshy installation.
#   export -a ZESHY_ARGS; ZESHY_ARGS=( "${@}" )
    # Absolute path of the system-wide Zeshy-specific dot directory.
#   local ZESHY_ZDOTDIR
#   ZESHY_ZDOTDIR="$(print -- "${ZESHY_HOME}/../etc"(:A))" &>/dev/null || {
#       print "zeshy: dot directory \"${ZESHY_HOME}/../etc\" not found" 1>&2
#       exit 1
#   }

    #FUXME: Move all files under "etc/" to "src/"; no reason to have a separate
    #directory, really. Especially now that they're dot files!
    #FUXME: Great! Unfortunately, this discards ${@}. Due to the insanity of the
    #redirection below, we'll need to store the current argument list in a Zeshy
    #global: how about simply ${ZESHY_ARGS}? "etc/zshrc" will then need to pass
    #such list when sourcing ${ZESHY_HOME_SCRIPT}. Easy; just willfully tedious.

    # If the default value for ${ZESHY_HOME} was not replaced, the Zeshy
    # installation script was probably not run. (Kindly notify the user.)
#   [[ "${ZESHY_HOME}" == '@ZESHY_HOME@' ]] && {
#       print 'zeshy: "@"-style substitution not substituted' 1>&2
#       print 'zeshy: not installed or installed incorrectly' 1>&2
#   }

    # If such path is not found, fail with error.
#   [[ -d "${ZESHY_ZDOTDIR}" ]] || {
#       print "zeshy: dot directory \"${ZESHY_ZDOTDIR}\" not found" 1>&2
#       exit 1
#   }

#   local ZESHY_ZDOTDIR
#   (( ${+ZDOTDIR} )) && ZDOTDIR_old="${ZDOTDIR}"

#then exec zsh ${(k)arg_options} -s -- "${ZESHY_HOME_SCRIPT}" "${@}"
#then exec zsh ${(k)arg_options} -- "${@}"

# To avoid reloading Zeshy if already loaded by startup zsh logic, pass an
# option to the main Zeshy script instructing such script to avoid doing so.
# Since only the current script should ever pass such option, avoid publicly
# documenting such option in the above help text. For details, see corresponding
# comments in the main Zeshy script.
#set -- "${@}" --no-zeshy-reload-by-same-process

#passed unexpected or invalid options
#elif (( ${+arg_options[-i]} ))
#then exec zsh -i -- "${ZESHY_HOME_SCRIPT}" "${@}"

# string print_zeshy_help_usage(void)
#
# Print a human-readable synopsis of all command-line options accepted by the
# "zeshy" wrapper script.
#function print_zeshy_help_usage() {
#    die_if_args
#    output_string <<'EOHD'
#Usage: zeshy [OPTION]... [FILE [ARGUMENT]...]
#
#Open a Zeshy-fortified zsh shell under the passed OPTIONs. Source the optionally
#passed FILE as a Zeshy script passed the passed ARGUMENTs.
#
#Main options:
#  -i, --interactive      open an interactive non-login zsh shell
#  -l, --login            open an interactive login zsh shell
#  -, --                  stop parsing options
#
#Help options:
#  -h, --help             print this help string and exit
#  -v, --version          print a version string and exit
#
#Complex options:
#  -c COMMAND,            run the passed zeshy shell command (\"-c 'is_dir /'\")
#     --command=COMMAND
#  -o OPTION,             enable the passed zsh shell option (\"man zshoptions\")
#     --option=OPTION
#
#Startup options:
#  --no-digest            load zeshy by recursively sourcing the zeshy codebase
#                            rather than autoloading a (re)compiled digest file
#EOHD
#}

# If passed a help option, ignore all other options, print the help string to
# standard output, and exit with zero status.
#(( ${+arg_options[-h]} )) && {
#    print -- "${help_message}"
#    exit 0
#}

# If passed a version option, behave similarly.
#(( ${+arg_options[-v]} )) && {
#    print -- "Zeshy @ZESHY_VERSION@"
#    exit 0
#}

#   h i l v -help=h -interactive=i -login=l -version=v || {
#   print -- "${help_message}" 1>&2
#FUXME: Don't forget @ZESHY_VERSION@, too!
#FUXME: Add a canonical "-v, --version" option, which should probably print an
#"@"-embedded version string replaced by the install script. Wait; scratch that.
#The install script runs Zeshy and Zeshy exposes a get_zeshy_version() function.
#Given that, couldn't we just define a new print_zeshy_version() function and
#convert

#                           by default, zeshy prefers the former for load-time efficiency
# --no-digest            do not load zeshy from a digest file, but by sourcing
#                           relevant zeshy scripts; by default, zeshy prefers the
#                           former for efficiency when reloaded

# --no-reload            do not load Zeshy if previously loaded by the current
#                           shell; by default, Zeshy prefers to always reload
#                           itself to account for configuration changes

#FUXME: Note that this will play poorly with our current method of sourcing
#Zeshy in "/etc/zsh/zshrc". We'll be loading Zeshy twice -- first by
#"/etc/zsh/zshrc" and second by the passed parameter to "zsh". Clearly, the
#latter should immediately return if having already been loaded by
#"/etc/zsh/zshrc". How to test... Ah! What if we run zsh from such driver script
#as: 'zsh "${ZESHY_HOME}" 1 "${@}"'. Passing "1" notifies the "src/main" Zeshy
#script that it is being loaded from the driver; if such argument is passed and
#Zeshy has already been loaded, silently avoid reloading Zeshy. Or some such...
#Hmmm. It still doesn't feel quite right, though. Running "/usr/bin/zeshy"
#should reload Zeshy in *ALL* cases *EXCEPT* where a dot-file has already loaded
#Zeshy *IN THE SAME PROCESS*. I suppose we could have Zeshy set the ID of the
#zsh process from which it was originally loaded; then, on subsequently
#detecting that Zeshy is being reloaded, do so *UNLESS* the current process ID...
#Hmm. No. Subtle issues abound, clearly. Hmmmm.
#FUXME: I reckon we'd need to explicitly check in Zeshy for being loaded from
#both a dot-file (as evidenced by the current call stack -- just see if the
#topmost entry of the call stack is a path prefixed by either "/etc/zsh" or
#"$ZDOTDIR" -- wait; no, "/etc/zsh" is non-portable; O.K.; how about this: ...is
#a path matching glob "*/(.|)(zprofile|zshrc)" -- coolio!) and the driver script
#(as evidenced by canonical zsh global ${PPID}, which can be used to examine the
#process list or, I suppose, just "/proc/${PPID}/cmdline" for now). Should be
#quite an efficient test, in any case. If the test matches, return immediately
#from Zeshy -- since zsh will be sourcing Zeshy immediately anyway from the
#passed argument. This implies that sourcing Zeshy from "/etc/zsh/zshrc" is only
#of use in forcing all login and interactive zsh shells to also source Zeshy.
#Not terribly helpful, really, since "/usr/bin/zeshy" already provides such a
#shell. In any case, implement the above heuristic -- and, for debugging purposes,
#print out a warning that we'll probably squelch in some later version.
#FUXME: The above heuristic is a helpful first approximation. Unfortunately,
#testing "/proc/${PPID}/cmdline" isn't terribly cross-platform portable. For
#efficiency reasons, I'd also rather not call external commands (e.g., "ps").
#Consequently, perhaps we'd rather try the following in "src/main":
#
#* Set ${ZESHY_PID} as a global export in "src/main" to the current process ID.
#* Immediately before setting such global export, test whether or not:
#  [[ "${ZESHY_PID-}" -eq "${PPID}" ]]
#  If such test is true, Zeshy has already been loaded by the parent process and
#  hence (hopefully) inherited by the current process. Return immediately.
#
#Seems a bit risky -- but I can't see any inherent flaws, at the moment. Hmm;
#actually, that's pretty shoddy. Zeshy would then behave differently when running
#scripts directly under a Zeshy shell versus running scripts under other scripts.
#Silly. O.K.; how about something more specific to zsh startup flow:
#
#* If [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PPID}" ]], then:
#  * Zeshy has already been loaded by the parent process and hence (hopefully)
#    inherited by the current process. Return immediately.
#* If [[ "${funcstack[1]}" == "*/(.|)(zprofile|zshrc)" ]], then:
#  * Set ${ZESHY_PID_IF_ZSH_STARTUP} as a global export in "src/main" ala:
#    typeset -igx ZESHY_PID_IF_ZSH_STARTUP="${PID}"
#
#Looks good. Only, note that Zeshy *MAY* (and should, really) execute passed
#scripts in the current shell process. Actually, it'd better. Be stupid to spawn
#a new subshell, right? In that case, the test is simply:
#
#  [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PID}" ]]
#
#Well, test which, anyway.
#
#Oh, and if such test succeeds, "unset ZESHY_PID_IF_ZSH_STARTUP". No more reason
#to keep such global around at that point -- just clutters things up.

#, if such Zeshy script has not already been sourced by the current
# zsh process (e.g., due to a zsh dotfile sourcing such script on zsh startup)

# --no-digest-or-source  do not load Zeshy at all; only handle passed arguments
    # If Zeshy has already been loaded by the current process, avoid doing so
    # again by passing the appropriate option to Zeshy, below.
#   [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq ${$} ]] &&
#       set -- --no-digest-or-source "${@}"

# --no-digest            do not load Zeshy from a digest file but by sourcing
#                           relevant Zeshy scripts (warning: this is slow)
# --no-digest-or-source  do not load Zeshy; only handle passed arguments
    # Process ID of the current process.
#   export -i ZESHY_PID_IF_ZSH_STARTUP

#if (( ${+arg_options[-i]} + ${+arg_options[-l]} ))
#then exec zsh "${arg_options[@]}" -- "${ZESHY_HOME_SCRIPT}" "${@}"

#FUXME: Merge "zeshy.dev" here. Yes, just do it. This will allow users to test
#Zeshy from a cloned git repository without necessarily installing it, which is
#*VERY* nice and polite and such.
# Run Zeshy from an in-development "git" rather than installed directory tree.
# This script sets ${ZESHY_HOME} to conform to "git" directory tree structure
# and otherwise operates similar to the main "zeshy" command.

# Find the index of the first passed argument either equal to "-c" or not
# prefixed by "-", signifying the first Zeshy-specific argument.
#integer zsh_nonoption_first_index="${@[(i)(-c|([^-])*)]}"
#integer zsh_option_last_index=$(( zsh_nonoption_first_index - 1))

# Split passed arguments into zsh-specific options and Zeshy-specific arguments.
# The former include all passed arguments prefixed by "-" excluding "-c", while
# the latter include all remaining passed arguments.
#local -a zsh_options zeshy_args
#zsh_options=( "${@[1,${zsh_option_last_index}]}" )
#zeshy_args=( "${@[${zsh_nonoption_first_index},-1]}" )
#print "options: ${zsh_options[@]}"
#print "nonoptions: ${zeshy_args[@]}"

#FUXME: O.K.; Linux login precedents are, frankly, bizarre. Here's out it works:
#
#* All (or nearly all) shells check $argv[0] to see whether or not the name they
#  were run as is prefixed with a hyphen (e.g., "-bash", "-zsh"). If so, this
#  indicates such shell should run as a login shell.
#* If not prefixed with a hyphen, some shells additionally check for a passed
#  option "-l" indicating the same thing (e.g., "bash -l", "zsh -l"). What's
#  particularly crazy here is that "man zsh" does not explicitly list "-l" in
#  the options it claims to accept -- even though it actually does! *sigh*
#
#In any case, the latter method of passing "-l" should suffice in the above
#driver script. We'll need to test ${0} for a "-" prefix in such script, as
#that's presumably what the "login" process will run such script as. (Crazy.)
#FUXME: Weaksauce. Linux's "/etc/passwd" shell field supports no passed
#arguments. *sigh* We'll need to create a secondary "/usr/bin/zeshy-login"
#script -- probably just a symbolic link to this script. We can then check
#whether or not this script was invoked as "zeshy-login"; if so, obviously
#prepend "-l" to the passed argument list as follows:
#FUXME: If neither "-l" or "-i" were passed, we needn't "exec" a new zsh process.
# For efficiently sensible process trees, replace the process running the
# current shell with a new process running Zeshy under a new zsh shell.
#if [[ -n "${(M)zsh_options:#-[a-z]#[il]*}" ]]

#FUXME: O.K.; we should probably be testing here whether or not we were run with
#a "-"-prepended $argv[0] string and hence as a login shell. Unfortunately, I'm
#not entirely sure how to accomplish that cross-platform portably. zsh appears
#to provide no access to such string, as verified by printing such variables
#below. However, there is a way. You won't like it, but...
#"/proc/${$}/cmdline" *DOES* provide efficient access under Linux to the null-
#delimited argv string. That's probably the only way, unfortunately.
#FUXME: Uh-oh. Problem. zsh appears to squelch the prefixing "-" unless the
#script is explicitly called as follows: "- zsh /usr/bin/zeshy".
#"- /usr/bin/zeshy" has no effect. Lame! I suppose zsh thought it "knew" best
#and decided to simply hide such prefix. O.K.; that implies that we *NEED* "-l"
#to be explicitly passed to this script on login. We can...

#print "argv: ${argv[@]}"
#print "0: ${0}"

#FUXME: Fix. Document. Oh, Christ.
#[[ -o interactive ]] && {
#    print "already an interactive shell; unsure how to proceed, so dying" 1>&2
#    return 1
#}

#FUXME: Extend to support options -- particularly, "-c", which should definitely
#be the first option we implement support for, and "-", implying a login shell.
#Supporting the latter option is essential for masquerading Zeshy as a proper
#shell (and in particular allowing use of Zeshy in "/etc/passwd").
#FUXME: O.K.; this script pretty much has to be rewritten as a basic Bourne
#shell script. I know, I know; but there's really no other way. Such script
#should combine the contents of this and "zeshy.dev" into a single driver
#script invoking zsh with desired options (e.g., "-"). After careful thought, I
#can't help but conclude that the only sane means of loading Zeshy when manually
#invoking zsh is by passing the path to ${ZESHY_HOME} as the first argument to
#"zsh" and all other arguments passed to such script as subsequent arguments to
#"zsh". According to "man zsh", "zsh -i ${ZESHY_HOME}" *SHOULD* have the desired
#effect of running "zsh" interactively after sourcing the passed zsh script.
# Map long to short options.
#(( ${+arg_options[--hello]} )) && arg_options[-h]=
#(( ${+arg_options[--login]} )) && arg_options[-l]=
#(( ${+arg_options[--interactive]} )) && arg_options[-i]=

# --                     halt parsing options
# --                     stop parsing options
#FUXME: [[ "${0:t}" == 'zeshy-login' ]] should do the trick more optimally.
#[[ "${0}" == (|*/)zeshy-login ]] && set -- -l "${@}"

#FUXME: No reason to leave this as a zsh script, really. "sh" is considerably
#lighter weight, and seems inherently much more appropriate for this sort-o'-
#thing. Consider switching. Hard. Well... actually, we *DO* benefit from zsh-
#specific functionality below -- particularly, for list element matching. I'm
#unconvinced that switching to "sh" nets us anything but headaches, really.
#FUXME: Not quite right, of course. Option "-c" and following arguments must be
#passed to Zeshy as is and hence treated as non-options. How about:
#  integer nonoption_first_index="${@[(i)([^-]|-c)*]}"
#Simple, no? Don't worry about valid zsh options passed after the argument
#following "-c": they'll be passed to Zeshy as arguments, and if the user
#doesn't like that... well, they can just reorder them then!

#(( nonoption_first_index > # )) && nonoption_first_index=0
#options="${(M)@:#-*}"
# arguments="${@:#-*}"
#for arg ("${@}") {

#for ((i = 1; i <= "${#}"; i++)) {
#    [[ "${@[${i}]}" == '-'* ]] or break
#    zeshy_options+="${@[${i}]}"
#}

# If the caller passed arguments, interpret the first argument as the absolute
# path to the Zeshy script to be "executed" and remaining arguments as the
# arguments to be passed such script. Certainly, this is always the case when
# this wrapper script is indirectly invoked by a shebang script header (e.g.,
# "#!/usr/bin/env zeshy").
#if is_args
#then source_shell_script "${@}"
# If the caller passed no arguments and standard input for the current shell is
# attached to a terminal, drop the caller into a new interactive zsh shell
# inheriting current Zeshy settings. For efficiency, replace the process running
# the current shell with the process running the new shell.
#
# Avoid calling is_shell_interactive() to test such condition. Since the current
# script is a file rather than standard input, zsh is not currently reading
# commands from standard input and hence disables shell option "interactive".
#elif [[ -t 0 ]]
#then exec zsh -i "${ZESHY_HOME_SCRIPT}" "${@}"
# Otherwise, drop the caller off the Tarabithian bridge.
#else die 'expected at least one argument when called non-interactively'
#fi

#exec zsh -i "${ZESHY_HOME_SCRIPT}" "${@}"

# Load Zeshy.
#source "${ZESHY_HOME_SCRIPT}"

#FUXME: This only works because our "/etc/zsh/zshrc" explicitly sources Zeshy. In
#most cases, this will not have the desired effect. See above for possible
#solutions.
#
# If the caller passed no arguments and the current shell is a login shell, we
# are already done. Zeshy startup has already detected being a login shell and
# responded accordingly (e.g., by setting the current ${PATH}).
#elif is_shell_login
#   [[ -o interactive ]] or print 'uh-oh: non-interactive!'
#FUXME: Call a safer Zeshy wrapper around source(). Doesn't
#source_shell_script() suffice?
#elif [[ -t 0 ]]
#Does this run "src/always/shell/profile" or do we need to add additional
#options or function calls to do so?
# Ensure "${ZESHY_HOME}" is defined and, if not, try doing so.
#[[ -n "${ZESHY_HOME}" ]] || {
    #FUXME: "/etc/env.d" is Gentoo-specific. Since Debian-based distros provide
    #no equivalent directory, I'm afraid this simply doesn't scale. Replace
    #such functionality with the following approach:
    #
    #* Add a new "zeshy.dev" script, to be run by Zeshy developers. This script
    #  guarantees ZESHY_HOME to be set to the "../src" directory relative to
    #  this directory via the current "readlink"-based solution in
    #  "../src/main". After doing so, that script immediately sources this
    #  script -- and that's it.
    #* This script should, perhaps, replace this entire block with:
    #
    #  export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"
#    if [[ -r    '/etc/env.d/%%zeshy' ]]
#    then source '/etc/env.d/%%zeshy'
#    else export ZESHY_HOME='/usr/share/zeshy'
#    fi
#}

# Zeshy scripts are encouraged to load Zeshy by replacing the first line of such
# files with a cross-platform portable shebang: e.g.,
#
# Third-party scripts requiring one or more Zeshy components are encouraged to
# replace any existing shebang line at the top of each such file with:
#
#     #!/usr/bin/env zeshy
#
# This invokes this script on each such file, which:
#
# * Sources "zeshy/core", the core Zeshy module providing (among other base
#   functionality) the import() function with which third-party scripts may
#   optionally import all other Zeshy modules in a platform portable manner.
# * Runs "zsh" on the passed file.
#
# Third-party scripts requiring one or more Zeshy components but not declaring
# the above shebang line should manually source the main Zeshy script at the top of each
# such file with:
#
#     #!/usr/bin/env zsh
#     source 
#
# Note that this script performs additional checks for path and platform sanity;
# thus, the above approach is strongly discouraged.
# Main Zeshy script. This Zeshy-specific zsh shell script replaces the
# "#!/usr/bin/env zsh" shebang command, which invokes zsh on the file, with a
# "#!/usr/bin/env zeshy" shebang command, which invokes Zeshy-capable zsh on the
# same file.
#
# Here, "Zeshy-capable zsh" means a zsh shell process having available:
#
# * All functions, aliases, and variables exported by Zeshy Core.
# * No functions or aliases exported by other Zeshy components.
# * But possibly variables exported by other Zeshy components, if inherited from the
#   caller's environment. In other words, do not rely on this.
#
#FUXME: Rename to ZESHY_HOME_SCRIPT and set above immediately after setting
#ZESHY_HOME.

# The shebang line above implicitly runs this script under "zsh" by prepending
# the argument list passed to this script with the absolute path to this script.
# Shift off such path from such list.
#shift_one_arg

    # Ensure this Zeshy script receives the expected arguments by popping off
    # the absolute path to this script from the argument list, thus leaving only
    # the script-specific arguments the caller passed.
    #FUXME: Hmmm; what was the idea here, again? Does the simple statement below
    #work, instead? Ah! I get it. We're running "zeshy" under "zsh" by virtue of
    #the shebang above. Right.
#   list arguments; arguments=( "${@}" )
#   source "${arguments}"
#   shift_one_arg

#   source "${ZESHY_HOME_SCRIPT}"
#   exec zsh -i "${ZESHY_HOME_SCRIPT}"
#   zsh -ic "source '${ZESHY_HOME_SCRIPT}'"
#elif [[ -o interactive ]]; then
#FUXME: There's no way this works as is. (It'd be nice, though...) First, I
#doubt is_interactive() ever returns true in this context. Hence, this should
#probably test whether standard input and/or output are attached to a terminal
#device: e.g.,
#elif is_terminal; then
#Second, I highly doubt the invoked "zsh" subshell actually inherits the Zeshy
#functions initialized above. Hence, the above "source" statement should be
#shifted under the above "if is_args; then" and then also executed here as
#something resembling (note the prefixing "exec"):
#   exec zsh -c "source '${ZESHY_HOME}/src/main'"
#But even that may not quite be right. Does this run "src/always/shell/profile"
#or do we need to add additional options or function calls to do so?

