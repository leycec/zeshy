#!/usr/bin/env sh
# ====================[ zeshy                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# If passed neither arguments or standard input, run zeshy as an interactive
# shell under the current terminal; else, run such arguments and/or standard
# input under zeshy.
#
# --------------------( OPTIONS                            )--------------------
# zeshy accepts most command-line options accepted by zsh.
#
# --------------------( SCRIPTS                            )--------------------
# zeshy scripts may load zeshy by adding a shebang line to the first line of
# such files. For cross-platform portability, consider the following line:
#
#     #!/usr/bin/env zeshy
#
# zeshy accepts most shell scripts accepted by zsh. However, several strategic
# design differences between zeshy and zsh preclude perfect backward
# compatibility. The largest difference is strictness: zeshy always throws an
# exception on any alias, command, or function returning non-zero exit status;
# zsh, on the other hand, ignores non-zero exit status where not explicitly
# handled (e.g., by appending "|| { print 'command failed' 1>&2; exit 1 }" to
# commands expected to fail).

#FIXME: Document somewhere that setting zeshy as a user's default "/etc/passwd"
#shell requires adding "zeshy-login" to "/etc/shells" under Linux and
#"zeshy-login" as the corresponding shell field.
#FIXME: Hmm; this should be a part of "zeshy" installation, no? What does "zsh"
#do? (Surely, not attempt to patch "/etc/shells"? If not, perhaps the best we
#can do is inform the user in ebuild post-installation messages of the need to
#manually edit "/bin/zeshy-login" into "/etc/shells". Since such file *ONLY*
#lists login shells, "/bin/zeshy" needn't be added.)
#FIXME: This also highlights the need to install both "zeshy" and "zeshy-login"
#to "/bin", in accordance with other similar shells.

#FIXME: The fact that zsh squelches "-" prefixes on ${argv[0]} is a clue that we
#probably want to reimplement this script in POSIX C. (Could be quite fun,
#actually, aside from the fact that it'll require a substantially smarter zeshy
#makefile.) Shouldn't be a terribly large file; everything we're doing here has
#a direct C analogue. The potential startup speedup makes this a particularly
#worthwhile improvement.
#FIXME: O.K.; make this happen. The refactoring suggested below strongly implies
#we should go this road. Naturally, contemplate a CMake makefile.
#FIXME: O.K., O.K.! This *HAS* to happen. Why? Because we *NEED* to pass option
#"NO_RCS" to zsh to prevent recursion. (Which we currently do avoid with boolean
#global ${ZESHY_PID_LAST_LOADED_BY}, though such solution is highly fragile,
#extremely difficult to debug and hence maintain, and likely to fail
#inexplicably.) Unfortunately, however, Linux does not perform word splitting on
#arguments passed to "!/usr/bin/env" shebang lines, meaning we can't modify the
#above shebang to:
#
#    !/usr/bin/env zsh -o no_rcs
#
#Indeed, to do so reliably, we'd need to convert "bin/zeshy" into a Bourne shell
#script execing the true zsh driver script "bin/zeshy.zsh" with option "NO_RCS".
#Since this rapidly becomes patently absurd, however, with shell interpreter
#spawning shell interpreter after shell interpreter, the only sensible solution
#is to reimplement this script as a precompiled C frontend.
#FIXME: The only difficult aspect of doing so will be reimplementing the
#parameter expansion "${(qq)@}" in C. Not a pretty thought, actually. Wait!
#Actually, since zsh itself is C, such implementation would be trivial. Ya!

# void set_zsh_wrapper_script[stdin: zsh_script]
#
# Set string global ${ZESHY_ZSH_WRAPPER} to the zsh shell script passed on
# standard input (e.g., as a here-document). Defining such script as a here-
# document permits such script to be defined significantly more naturally than
# were such script defined with customary single or double quotes.

# Unlike zsh, Bourne shell prohibits arbitrary code blocks from accepting here-
# documents (or any redirections, for that matter). Like zsh, however, Bourne
# shell does permit function calls from accepting here-documents. Hence, the
# following logic is equivalent in intent to the following zeshy command:
#
#     { ZESHY_ZSH_WRAPPER="$(get_stdin)" } <<'/---'
#     ...
#     /---
set_zsh_wrapper_script () {
    ZESHY_ZSH_WRAPPER="$(cat /dev/stdin)"
}

# Set such variable.
set_zsh_wrapper_script <<'/---'
# Wrap such script in a function context, confining all local variables
# declared below to such context.
() {
# print "[${0}] starting zeshy wrapper"

# ....................{ OPTIONS                            }....................
# Enable:
#
# * Shell strictness. While zeshy replaces such crude options with
#   considerably more robust error handling (e.g., printing stack traces and
#   help documentation on errors), this beats zsh's default laxity.
# * Extended glob expressions (e.g., to match options).
setopt err_return no_unset warn_create_global extended_glob

# ....................{ GLOBALS                            }....................
# Globally export such variables for subsequent expansion by the zeshy
# codebase. Exporting such variables preserves such variables between calls to
# builtin exec() (e.g., if replacing the current non-interactive zsh process
# with an interactive zsh process below). While such variables may also be
# preserved by explicitly passing such variables to such calls, unconditionally
# exporting such variables here remains both simpler and safer.
typeset -gx ZESHY_HOME ZESHY_MAIN_SCRIPT

# ....................{ PATHS                              }....................
#FIXME: The "install" script *MUST* absolutely globally replace all instances
#of #@ZESHY_HOME@ in this script. (There should only be one such instance,
#but... *shrug*.) The at sign "@" is particularly helpful for this #purpose, as
#it appears to have no current reserved uses in zsh.
#FIXME: Such script *MUST* also globally prefix all single quotes in such path
#with another such quote (e.g., replacing "'" with "''"), to avoid syntax
#errors with edge-case paths.

# Absolute path of the main zeshy overlay (i.e., topmost zeshy directory).
# zeshy's installation script defaults such path to that passed to that script.
# Globalize such path for reuse by zeshy parcels sourced below.
ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"

# If such path has not been replaced, the user failed to install zeshy (e.g.,
# due to legitimately running zeshy under a cloned "git" repository). Detect
# this and attempt to respond rationally.
if [[ "${ZESHY_HOME}" == '@ZESHY_HOME@' ]] {
    local zeshy_wrapper_filename zeshy_bin_dir
    local -a placeholder_list

    # Absolute or relative path of the Bourne script wrapping the current zsh
    # script. To prevent syntax errors in the event such path contains either
    # single or double quotes, localize such path ala :set_string_to_string().
    # Technically, such assignment can still fail with syntax errors in the
    # event such path contains a "}" character.  Since this is substantially
    # less likely than such path containing quote characters, however, we
    # currently ignore such edge case.
    zeshy_wrapper_filename="${ZESHY_BOURNE_WRAPPER_FILENAME}"

    # If such path is relative to the current working directory of the wrapping
    # Bourne script, prepend such path with such directory.
    [[ "${zeshy_wrapper_filename}" == '/'* ]] ||
        : "${zeshy_wrapper_filename::=${ZESHY_BOURNE_PWD}/${ZESHY_BOURNE_WRAPPER_FILENAME}}"

    # If such script does not exist, fail. (This should never happen.)
    [[ -f "${zeshy_wrapper_filename}" ]] || {
        print 'zeshy: Wrapper script "'${zeshy_wrapper_filename}'" not found or not a file.' 1>&2
        exit 1
    }

    # Canonicalize such path (i.e., resolve all intermediate symbolic links).
    # See :convert_path_to_parcel() for further details.
    placeholder_list=( "${zeshy_wrapper_filename}"(:A) )
    zeshy_wrapper_filename="${placeholder_list[1]}"
    # print "zeshy_wrapper_filename: ${zeshy_wrapper_filename}"

    # Absolute path of the directory containing such script. See
    # :set_string_to_path_dirname() for further details.
    zeshy_bin_dir="${zeshy_wrapper_filename:h}"

    # Absolute path of the main zeshy overlay directory, given such paths.
    placeholder_list=( "${zeshy_bin_dir}/../src"(:A) )
    ZESHY_HOME="${placeholder_list[1]}"
}

# Absolute path of zeshy's entry script, conditionally compiling and
# autoloading the zeshy codebase into the current digest file.
ZESHY_MAIN_SCRIPT="${ZESHY_HOME}/.main"

# If such directory does not exist, fail.
[[ -d "${ZESHY_HOME}" ]] || {
    print 'zeshy: Main overlay "'${ZESHY_HOME}'" not found or not a directory.' 1>&2
    exit 1
}
#print "ZESHY_HOME: ${ZESHY_HOME}"

# If such script does not exist, fail.
[[ -f "${ZESHY_MAIN_SCRIPT}" ]] || {
    print 'zeshy: Main script "'${ZESHY_MAIN_SCRIPT}'" not found or not a file.' 1>&2
    exit 1
}

# ....................{ OPTIONS                            }....................
# If called as "zeshy-login", prepend option "-l" to the passed arguments.
# Ideally, this script would itself ascertain whether or not it was run as a
# login shell by a process running "login". Such process reliably prefixes the
# ${argv[0]} string identifying the name of this process with "-", thus
# signifying this shell to be a login shell. Unfortunately, zsh squelches such
# "-" unless explicitly running this script under "zsh" rather than an implicit
# shebang line (e.g., as "- zsh /usr/bin/zeshy" rather than "- /usr/bin/zeshy").
#
# While replacing this script with a customary C-based binary would rectify such
# issue, "the best laid schemes of mice and men/often go awry."
if [[ "${ZESHY_BOURNE_WRAPPER_FILENAME:t}" == 'zeshy-login' ]] {
    # print -r "zeshy: called as zeshy-login"
    set -- -l "${@}"
}

# If passed no arguments specifying a course of action, default to opening an
# interactive shell by prepending option "-i" *AFTER* testing whether we were
# called as a login shell. Dismantled, this is:
#
# * "${@[(i)...]}", expanding to the 1-based index of the first passed argument
#   matching such glob or to the number of such arguments plus 1 if no argument
#   matches such glob:
#   * "[^-]*", matching a non-option argument if passed. In zeshy's case, such
#     argument *ALWAYS* signifies a script to be sourced.
#   * "-[a-z]#[chilv][a-z]#", matching a string of short arguments containing at
#     least one of options "-c", "-h", "-i", "-l", or "-v". See "zeshy -h" for
#     further details.
# * "#", expanding to the number of such arguments.
(( ${@[(i)([^-]*|-[a-z]#[chilv][a-z]#|--(command=*|help|interactive|login|version))]} <= # )) || {
#   print 'passed no other action; defaulting to interactive (i.e., "-i")'
    # If standard input to the current shell is attached to a terminal, drop the
    # caller into an interactive zeshy shell.
    if [[ -t 0 ]] {
        set -- -i "${@}"
    # Else, drop the caller off the Tarabithian bridge. (Spoiler alert.)
    } else {
        print "zeshy: Expected at least one argument when called non-interactively." 1>&2
        exit 1
    }
}

# Load module "zutil", defining zparseargs() and other core builtins.
zmodload zsh/zutil

# Parse passed options specific to this script, propagating all other arguments
# to the main zeshy script. If such parsing fails, print the help string to
# standard error and exit with non-zero status. See parse_arg_options() for
# further details. While it *SHOULD* be theoretically infeasible for parsing of
# such simple options to fail, one just never knows.
#
# Map long- to short-form options (e.g., "--interactive" to "-i") rather than
# the other way around to simplify zsh interaction below. If such options were
# passed, we in turn pass such options to zsh. Since zsh may or may not expect
# long-form options depending on platform or version, prefer short-form options.
local -A arg_options
zparseopts -M -D -E -A arg_options -- i l -interactive=i -login=l || {
    print -- "zeshy: Passed invalid or unknown options." 1>&2
    exit 1
}

# ....................{ MAIN                               }....................
# If passed either "-l" or "-i", replace the current process with a new process
# running zsh under such options. Since changing such options changes zsh's
# startup behavior, such options cannot be changed at runtime but must be
# explicitly passed to the "zsh" command. Since login shells are implicitly
# interactive, "-l" subsumes "-i". Hence, test the latter before the former.
if (( ${#arg_options} )) {
#   print "[${0}] sourcing interactively ${ZESHY_MAIN_SCRIPT} ${*}"

    # Globally export the following variables for subsequent expansion by
    # zeshy's ".zshrc" dotfile:
    #
    # * ${ZESHY_ARGS}, the list of all arguments passed to this script
    #   losslessly flattened into a string for subsequent conversion back into
    #   a list. See :convert_list_to_string() for further details.
    # * ${ZDOTDIR}, the absolute path of the directory containing zeshy's
    #   dotfiles -- in this case, only ".zshrc". Since "zsh" cannot be passed
    #   both option "-i" enabling interactivity *AND* a non-interactive script
    #   to be run on zsh startup, zeshy slyly subverts such constraints by
    #   running such non-interactive script on zsh startup from within a zeshy-
    #   specific dotfile run only on such startup.
    typeset -gx ZESHY_ARGS="${(qq)@}" ZDOTDIR="${ZESHY_HOME}"

    # Replace the current non-interactive zsh process with an
    # interactive zsh process sourcing zeshy's ".zshrc" dotfile, itself
    # sourcing zeshy's "main" entry script. Such replacement ensures the
    # following order of sourced scripts on running the current script:
    #
    # 1. "bin/zeshy", zeshy's wrapper script.
    # 2. "src/.zshrc", zeshy's startup dotfile.
    # 3. "src/main", zeshy's entry script.
    #
    # Dismantled, this is:
    #
    # * "-o no_global_rcs", preventing such process from sourcing system-wide
    #   zsh dotfiles (e.g., "/etc/zsh/zshrc"). To ensure such process sources
    #   zeshy's startup dotfile, disable option "global_rcs" rather than "rcs".
    # * "(@k)", expanding to all passed options (e.g., "-l", "-i").
    exec zsh -o no_global_rcs "${(@k)arg_options}"
# Else source the main zeshy script with the passed arguments under the current
# zsh process.
} else {
#   print "[${0}] sourcing non-interactively ${ZESHY_MAIN_SCRIPT} ${*}"
    source -- "${ZESHY_MAIN_SCRIPT}" "${@}"
}
}
/---

# Replace the current Bourne shell process with a zsh shell process running the
# zsh shell script passed on standard input (e.g., as a here-document).  To
# preserve standard input, do so external to the prior function call.
#
# While such script could theoretically be implemented in pure Bourne shell,
# doing so in a reliable, cross-platform portable manner is complicated by the
# non-trivial logic such script performs (e.g., path canonicalization and
# quote-protected list-to-string conversion). Unfortunately, doing so replaces
# the path the current script was run as (i.e., "${0}") with "zsh", preventing
# such script from locating either itself or the zeshy codebase. To circumvent
# this, pass such path and the current working directory to such process as
# zeshy-specific string globals.
#
# For robustness, prevent zsh from sourcing either system- or user-specific zsh
# dotfiles on startup by enabling shell option "NO_RCS".  While zeshy is both
# implemented in and runs on zsh, the family resemblance ends there. zsh
# dotfiles typically contain code either breaking subsequent zeshy code or
# which subsequent zeshy code will break. In either case, code is breaking.
#
# System administrators and/or users attempting to incorporate existing zsh
# dotfile functionality into zeshy must thus manually port such functionality
# into system- and/or user-specific zeshy overlays (e.g., "~/.zeshy/overlay").
ZESHY_BOURNE_WRAPPER_FILENAME="${0}" \
ZESHY_BOURNE_PWD="${PWD}" \
    exec zsh -o no_rcs -c "${ZESHY_ZSH_WRAPPER}"

# --------------------( WASTELANDS                         )--------------------
# -o err_return -o no_unset -o warn_create_global -o extended_glob 
    # ZESHY_MAIN_SCRIPT="${ZESHY_MAIN_SCRIPT}"\

 # Since we require such process Unlike above, we
    #    user-specific zsh dotfiles (e.g., "${ZDOTDIR}/.zshrc").
    #   Avoid passing
    #   "-o no_rcs", 
    # Run such process with access to the following globals, subsequently
    # referenced by zeshy's ".zshrc":

    # Replace the non-interactive zsh process sourcing this script with an
    # interactive zsh process sourcing zeshy-specific dot files ".zprofile",
    # ".zshrc", and ".zlogin" implicitly sourcing the current user's zsh-
    # specific analogues of the same scripts *AND* the main zeshy script.

    #FUXME: There may be a slightly different means of implementing this.
    #Consider refactoring "src/.zshrc" to establish a pre-command prompt hook
    #undefining itself and sourcing the zeshy codebase: e.g.,
    #
    #    function precmd() {
    #        unfunction precmd
    #        source -- "${ZESHY_MAIN_SCRIPT}" "${(Qz)ZESHY_ARGS}"
    #    }
    #
    #Such indirection ensures that zeshy will be sourced *AFTER* zsh startup,
    #which may be the only means of enabling TRAPZERR() during zeshy startup.
    #More investigation is probably warranted.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Order of globals is important here. In particular, declaring ${ZDOTDIR}
    #prior to ${ZESHY_ZDOTDIR_USER} results in the latter copying the former,
    #resulting in infinite recursion. (Aye, 'tis a dangerous world we live in.)
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # * ${ZESHY_ZDOTDIR_USER}, the absolute path of the current user's zsh-
    #   specific dot directory, defaulting to such user's home directory.

    #FUXME: We almost certainly no longer require ${ZESHY_ZDOTDIR_USER}. Since
    #we don't intend to source system and/or user dotfiles, there's little point
    #in defining such variable below.
    #FUXME: Removing such variable effectively reduces "src/.zprofile" and
    #"src/.zlogin" to the empty string, suggesting we remove such files as well.
    #That said, the following are almost certainly still necessary:
    #
    #* ${ZESHY_ARGS}, as there appears to be no other way of passing an
    #  interactive "zsh" interpreters arguments.
    #* ${ZDOTDIR}, for the above reason.
    #* "src/.zshrc", for the above reason.
    #FUXME: O.K.; due to the *ABSOLUTE* need to pass option "no_rcs" to the zsh
    #interpreter interpreting this script, this script must be refactored into
    #the contents of a here-document string (...we know; we know) as follows:
    #
    #    #!/usr/bin/env zsh
    #    exec zsh -o no_rcs <<'/---'
    #    #FUXME: Nice. So, just replace this with the current contents of this
    #    #script. What could possibly go wrong, are we right?
    #    command ls /tmp
    #    print ok
    #    /---
    #
    #Yes, this actually works. (It also incurs between one to two exec() calls
    #and hence process replacements of "zsh" with *ITSELF*, which is sheer
    #nonsense. But, without effectively writing a new C shell wrapper, this is
    #what we're left. Anywaaaay, focus: this actually works. So let's go!)
    #FUXME: Actually, Bourne shell already supports pretty much everything we
    #need in the thin outer wrapper above (e.g., here-documents). If "zsh" is
    #installed, it's effectively guaranteed that so is Bourne shell. So,
    #rewrite the shebang line to read:
    #
    #    #!/usr/bin/env sh
    #
    #Nothing else should require modification, eh?

    # ZESHY_ZDOTDIR_USER="${ZDOTDIR:-${HOME}}"\

# ls -l "/dev/stdin"
# ls -l /proc/self/fd/0
# print "file: ${ZESHY_BOURNE_WRAPPER_FILENAME}"
# print "pwd:  ${ZESHY_BOURNE_PWD}"

#FUXME: Since "zsh" itself accepts and evaluates standard input in the
#above manner, "zeshy" should as well. Consider inlining the contents of
#:is_stdin_noninteractive() *BEFORE* running the above "exec zsh"; if such
#test reports success, we'll probably want to capture the entirety of
#standard input into a script-local variable (e.g., by inlining
#"$(get_stdin)") and then pass such variable to "zeshy" with the existing
#option "-c". (Yes, this is *HARDLY* the ideal implementation. But it
#should work reliably enough to see us through until, again, we refactor
#this script into a proper C wrapper.)
#FUXME: This suggests we should probably be preserving standard input rather
#than replacing such input by the here-document defined below. While trivially
#easy in zsh, how does one assign a variable to the contents of a here-document
#in Bourne? Google us up. Hopefully, something resembling:
#
#    { ZESHY_ZSH_WRAPPER="$(cat /dev/stdin)" } <</---
#    ...
#    /---
#FUXME: Right. Close! This'll do it:
#
#    ZESHY_ZSH_WRAPPER="$(cat <</---
#    uhmu uhmuhum ou
#    oeu ouhou
#    /---
#    )"
#
#    exec zsh -c "${ZESHY_ZSH_WRAPPER}"
        # </dev/stdin 1>/dev/stdout 2>/dev/stderr
# Unfortunately, doing so also replaces the path the current script was called
# as with simply "zsh", preventing the zsh script below from locating the zeshy
# codebase. To circumvent this, we interpolate variables in the current script
# into such zsh script by *NOT* quoting the given here-document delimiter.
# Unfortunately, this has the negative consequence of requiring all variable
# expansions specific to such zsh script be explicitly escaped. (Classic
# techno-fix escalation. Yes, this needs to be rewritten in C.)

# Replace the current Bourne shell process with a zsh shell process running the
# zsh shell script passed to such process on standard input as a here-document.

#)"  # vim-specific obfuscation to assist syntax highlighting

    # zsh script to be run by the zsh process replacing the current process.
# Define integer local ${ZESHY_IS_INTERACTIVE} to either:
#
# * Boolean true (i.e., 1) if standard input to the current Bourne shell is
#   attached to a terminal and hence interactive.
# * Boolean false (i.e., 0) otherwise.
#
# We interpolate such local into the zsh script below to inform such script 
# Such local must be defined *BEFORE*
# if [ -t 0 ]
# then ZESHY_IS_INTERACTIVE=1
# else ZESHY_IS_INTERACTIVE=0
# fi

# loads all zeshy aliases, functions, and globals specific to the current user.
# echo "pwd: ${PWD}"

    # Absolute path of the main zeshy overlay, given such paths.
#     ZESHY_HOME="\$(print -r -- "\${zeshy_bin_dir}/../src"(:A))" &>/dev/null || {
#         print 'zeshy: Main overlay "'\${zeshy_bin_dir}'/../src" not found.' 1>&2
#         exit 1
#     }
# }
# 
# # If such path is not found, fail with error.
# } elif [[ ! -d "\${ZESHY_HOME}" ]] {
#     print 'zeshy: Main overlay "'\${ZESHY_HOME}'" not found.' 1>&2
#     exit 1
# }

    #FUXME: Inefficient. Subshells are horrible! This is readily implementable
    #without subshells with a list-based approach: e.g.,
    #
    #    local -a placeholder_list
    #    placeholder_list=( "\${0}"(:A) )
    #    zeshy_filename="\${placeholder_list[1]}"
    #
    #The only quandry with such method, of course, is how to detect failure.
    #Perhaps follow such expansion with a test: e.g.,
    #
    #    [[ -f "\${zeshy_filename}" ]] || ...

    # Absolute path of the current script. 
    # Since the following statement
    # erroneously interprets a trailing "(:A)" as a literal string rather than
    # shell word modifier, embed the trailing "(:A)" in a command substitution:
    # e.g.,
    #
    #     # This utterly fails. (Thanks, zsh.)
    #     >>> zeshy_filename="\${0}"(:A) && print "\${zeshy_filename}"
    #     /usr/bin/zeshy(:A)
    # zeshy_filename="\$(print -r -- "\${0}"(:A))" &>/dev/null || {
    #     print 'zeshy: Current script "'\${0}'" not found.' 1>&2
    #     exit 1
    # }

    #FUXME: *OH, BOY*. I'm sure this all *SEEMED* like a good idea at the time,
    #but it's simply overkill now. Like, *WAY* overkill. And also probably the
    #completely wrong thing to do. For one thing, we absolutely do *NOT* want
    #either system or user dotfiles to be sourced prior to sourcing zeshy. While
    #zeshy is implemented in and runs on zsh, the family resemblance ends there.
    #System and/or user dotfiles almost certainly contain code that will either
    #break subsequently autoloaded zeshy code or which subsequently autoloaded
    #zeshy code will break. In either case, code is breaking. If system
    #administrators and/or users would like to incorporate existing zsh dotfile
    #functionality into zeshy, we're afraid they'll simply have to port such
    #functionality into zeshy manually (e.g., by adding arbitrary files and code
    #to "~/.zeshy/overlay"). There's no reasonable alternative, given zeshy's
    #increasingly divergent codebase.
    #
    #Given this, we *REALLY* need to ensure the following:
    #
    #1. That option "NO_RCS" is enabled on the zsh interpreter interpreting the
    #   current script *BEFORE* such interpreter's startup. Can we pass such
    #   option in the shebang line? No idea. If not, that's one more compelling
    #   reason to reimplement this entire script as a C frontend. (This is
    #   becoming an increasingly enticing thought.)
    #2. That option "NO_RCS" is passed to the zsh interpreter forked below.
    #   While this is essential, how can we ensure zsh still respects and loads
    #   files in our custom \${ZDOTDIR}?

# Export for subsequent importation by zeshy's ".zshrc". 
#     #   Separate such export's declaration and definition to avoid errors like
    #   "/usr/bin/zeshy:export:179: not valid in this context: '--version'".
    #FUXME: Uhm; *WHAT* local? To genuinely define locals, we need a function
    #context, which implies we need to wrap this entire script within an
    #anonymous function block (e.g., "() { ... }").

# echo "0: ${0}"
        # exec zsh -o err_return ${(k)arg_options}
#FUXME: Document me.

# Given zeshy's divergent codebase, there's little sane alternative.
# print "zeshy: driver script \"${0}\" uninstalled or installed incorrectly" 1>&2
# Export such path for reuse by zeshy dot directory scripts implicitly sourced
# below, when opening interactive and login zsh shells.
#   export ZESHY_ZDOTDIR_USER="${ZDOTDIR:-${HOME}}"

    # List of all arguments passed to this script, losslessly converted into a
    # string for subsequent conversion back to a list. Export for subsequent
    # importation by zeshy's ".zshrc". See convert_list_to_string() for further
    # details on such conversion. Separate such export's declaration and
    # definition to avoid errors resembling
    # "/usr/bin/zeshy:export:179: not valid in this context: '--version'".
#   export ZESHY_ARGS; ZESHY_ARGS="${(qq)@}"

#FUXME: Not right. Revise this test (and only this test, I believe) to test for
#whether the caller passed either "-c", "-i", "-l", or a non-"-"-prefixed
#option. If any is the case, do *NOT* prepend "-i" to the argument list;
#otherwise, do. Since we prefer "||"-style testing, this should be fairly
#straightforward to test in the positive statement above.
#[[ -n "${@:#([^-]*|-([^-]|)[a-z]#[cil][a-z]#)}" ]]
#(( # )) || print 'zeshy: no runnable args passed!'

# by the current system or user during zeshy installation.
#   export -a ZESHY_ARGS; ZESHY_ARGS=( "${@}" )
    # Absolute path of the system-wide zeshy-specific dot directory.
#   local ZESHY_ZDOTDIR
#   ZESHY_ZDOTDIR="$(print -- "${ZESHY_HOME}/../etc"(:A))" &>/dev/null || {
#       print "zeshy: dot directory \"${ZESHY_HOME}/../etc\" not found" 1>&2
#       exit 1
#   }

    #FUXME: Move all files under "etc/" to "src/"; no reason to have a separate
    #directory, really. Especially now that they're dot files!
    #FUXME: Great! Unfortunately, this discards ${@}. Due to the insanity of the
    #redirection below, we'll need to store the current argument list in a zeshy
    #global: how about simply ${ZESHY_ARGS}? "etc/zshrc" will then need to pass
    #such list when sourcing ${ZESHY_MAIN_SCRIPT}. Easy; just willfully tedious.

    # If the default value for ${ZESHY_HOME} was not replaced, the zeshy
    # installation script was probably not run. (Kindly notify the user.)
#   [[ "${ZESHY_HOME}" == '@ZESHY_HOME@' ]] && {
#       print 'zeshy: "@"-style substitution not substituted' 1>&2
#       print 'zeshy: not installed or installed incorrectly' 1>&2
#   }

    # If such path is not found, fail with error.
#   [[ -d "${ZESHY_ZDOTDIR}" ]] || {
#       print "zeshy: dot directory \"${ZESHY_ZDOTDIR}\" not found" 1>&2
#       exit 1
#   }

#   local ZESHY_ZDOTDIR
#   (( ${+ZDOTDIR} )) && ZDOTDIR_old="${ZDOTDIR}"

#then exec zsh ${(k)arg_options} -s -- "${ZESHY_MAIN_SCRIPT}" "${@}"
#then exec zsh ${(k)arg_options} -- "${@}"

# To avoid reloading zeshy if already loaded by startup zsh logic, pass an
# option to the main zeshy script instructing such script to avoid doing so.
# Since only the current script should ever pass such option, avoid publicly
# documenting such option in the above help text. For details, see corresponding
# comments in the main zeshy script.
#set -- "${@}" --no-zeshy-reload-by-same-process

#passed unexpected or invalid options
#elif (( ${+arg_options[-i]} ))
#then exec zsh -i -- "${ZESHY_MAIN_SCRIPT}" "${@}"

# string print_zeshy_help_usage(void)
#
# Print a human-readable synopsis of all command-line options accepted by the
# "zeshy" wrapper script.
#function print_zeshy_help_usage() {
#    die_if_args
#    output_string <<'EOHD'
#Usage: zeshy [OPTION]... [FILE [ARGUMENT]...]
#
#Open a zeshy-fortified zsh shell under the passed OPTIONs. Source the optionally
#passed FILE as a zeshy script passed the passed ARGUMENTs.
#
#Main options:
#  -i, --interactive      open an interactive non-login zsh shell
#  -l, --login            open an interactive login zsh shell
#  -, --                  stop parsing options
#
#Help options:
#  -h, --help             print this help string and exit
#  -v, --version          print a version string and exit
#
#Complex options:
#  -c COMMAND,            run the passed zeshy shell command (\"-c 'is_dir /'\")
#     --command=COMMAND
#  -o OPTION,             enable the passed zsh shell option (\"man zshoptions\")
#     --option=OPTION
#
#Startup options:
#  --no-digest            load zeshy by recursively sourcing the zeshy codebase
#                            rather than autoloading a (re)compiled digest file
#EOHD
#}

# If passed a help option, ignore all other options, print the help string to
# standard output, and exit with zero status.
#(( ${+arg_options[-h]} )) && {
#    print -- "${help_message}"
#    exit 0
#}

# If passed a version option, behave similarly.
#(( ${+arg_options[-v]} )) && {
#    print -- "zeshy @ZESHY_VERSION@"
#    exit 0
#}

#   h i l v -help=h -interactive=i -login=l -version=v || {
#   print -- "${help_message}" 1>&2
#FUXME: Don't forget @ZESHY_VERSION@, too!
#FUXME: Add a canonical "-v, --version" option, which should probably print an
#"@"-embedded version string replaced by the install script. Wait; scratch that.
#The install script runs zeshy and zeshy exposes a get_zeshy_version() function.
#Given that, couldn't we just define a new print_zeshy_version() function and
#convert

#                           by default, zeshy prefers the former for load-time efficiency
# --no-digest            do not load zeshy from a digest file, but by sourcing
#                           relevant zeshy scripts; by default, zeshy prefers the
#                           former for efficiency when reloaded

# --no-reload            do not load zeshy if previously loaded by the current
#                           shell; by default, zeshy prefers to always reload
#                           itself to account for configuration changes

#FUXME: Note that this will play poorly with our current method of sourcing
#zeshy in "/etc/zsh/zshrc". We'll be loading zeshy twice -- first by
#"/etc/zsh/zshrc" and second by the passed parameter to "zsh". Clearly, the
#latter should immediately return if having already been loaded by
#"/etc/zsh/zshrc". How to test... Ah! What if we run zsh from such driver script
#as: 'zsh "${ZESHY_HOME}" 1 "${@}"'. Passing "1" notifies the "src/main" zeshy
#script that it is being loaded from the driver; if such argument is passed and
#zeshy has already been loaded, silently avoid reloading zeshy. Or some such...
#Hmmm. It still doesn't feel quite right, though. Running "/usr/bin/zeshy"
#should reload zeshy in *ALL* cases *EXCEPT* where a dot-file has already loaded
#zeshy *IN THE SAME PROCESS*. I suppose we could have zeshy set the ID of the
#zsh process from which it was originally loaded; then, on subsequently
#detecting that zeshy is being reloaded, do so *UNLESS* the current process ID...
#Hmm. No. Subtle issues abound, clearly. Hmmmm.
#FUXME: I reckon we'd need to explicitly check in zeshy for being loaded from
#both a dot-file (as evidenced by the current call stack -- just see if the
#topmost entry of the call stack is a path prefixed by either "/etc/zsh" or
#"$ZDOTDIR" -- wait; no, "/etc/zsh" is non-portable; O.K.; how about this: ...is
#a path matching glob "*/(.|)(zprofile|zshrc)" -- coolio!) and the driver script
#(as evidenced by canonical zsh global ${PPID}, which can be used to examine the
#process list or, I suppose, just "/proc/${PPID}/cmdline" for now). Should be
#quite an efficient test, in any case. If the test matches, return immediately
#from zeshy -- since zsh will be sourcing zeshy immediately anyway from the
#passed argument. This implies that sourcing zeshy from "/etc/zsh/zshrc" is only
#of use in forcing all login and interactive zsh shells to also source zeshy.
#Not terribly helpful, really, since "/usr/bin/zeshy" already provides such a
#shell. In any case, implement the above heuristic -- and, for debugging purposes,
#print out a warning that we'll probably squelch in some later version.
#FUXME: The above heuristic is a helpful first approximation. Unfortunately,
#testing "/proc/${PPID}/cmdline" isn't terribly cross-platform portable. For
#efficiency reasons, I'd also rather not call external commands (e.g., "ps").
#Consequently, perhaps we'd rather try the following in "src/main":
#
#* Set ${ZESHY_PID} as a global export in "src/main" to the current process ID.
#* Immediately before setting such global export, test whether or not:
#  [[ "${ZESHY_PID-}" -eq "${PPID}" ]]
#  If such test is true, zeshy has already been loaded by the parent process and
#  hence (hopefully) inherited by the current process. Return immediately.
#
#Seems a bit risky -- but I can't see any inherent flaws, at the moment. Hmm;
#actually, that's pretty shoddy. zeshy would then behave differently when running
#scripts directly under a zeshy shell versus running scripts under other scripts.
#Silly. O.K.; how about something more specific to zsh startup flow:
#
#* If [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PPID}" ]], then:
#  * zeshy has already been loaded by the parent process and hence (hopefully)
#    inherited by the current process. Return immediately.
#* If [[ "${funcstack[1]}" == "*/(.|)(zprofile|zshrc)" ]], then:
#  * Set ${ZESHY_PID_IF_ZSH_STARTUP} as a global export in "src/main" ala:
#    typeset -igx ZESHY_PID_IF_ZSH_STARTUP="${PID}"
#
#Looks good. Only, note that zeshy *MAY* (and should, really) execute passed
#scripts in the current shell process. Actually, it'd better. Be stupid to spawn
#a new subshell, right? In that case, the test is simply:
#
#  [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PID}" ]]
#
#Well, test which, anyway.
#
#Oh, and if such test succeeds, "unset ZESHY_PID_IF_ZSH_STARTUP". No more reason
#to keep such global around at that point -- just clutters things up.

#, if such zeshy script has not already been sourced by the current
# zsh process (e.g., due to a zsh dotfile sourcing such script on zsh startup)

# --no-digest-or-source  do not load zeshy at all; only handle passed arguments
    # If zeshy has already been loaded by the current process, avoid doing so
    # again by passing the appropriate option to zeshy, below.
#   [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq ${$} ]] &&
#       set -- --no-digest-or-source "${@}"

# --no-digest            do not load zeshy from a digest file but by sourcing
#                           relevant zeshy scripts (warning: this is slow)
# --no-digest-or-source  do not load zeshy; only handle passed arguments
    # Process ID of the current process.
#   export -i ZESHY_PID_IF_ZSH_STARTUP

#if (( ${+arg_options[-i]} + ${+arg_options[-l]} ))
#then exec zsh "${arg_options[@]}" -- "${ZESHY_MAIN_SCRIPT}" "${@}"

#FUXME: Merge "zeshy.dev" here. Yes, just do it. This will allow users to test
#zeshy from a cloned git repository without necessarily installing it, which is
#*VERY* nice and polite and such.
# Run zeshy from an in-development "git" rather than installed directory tree.
# This script sets ${ZESHY_HOME} to conform to "git" directory tree structure
# and otherwise operates similar to the main "zeshy" command.

# Find the index of the first passed argument either equal to "-c" or not
# prefixed by "-", signifying the first zeshy-specific argument.
#integer zsh_nonoption_first_index="${@[(i)(-c|([^-])*)]}"
#integer zsh_option_last_index=$(( zsh_nonoption_first_index - 1))

# Split passed arguments into zsh-specific options and zeshy-specific arguments.
# The former include all passed arguments prefixed by "-" excluding "-c", while
# the latter include all remaining passed arguments.
#local -a zsh_options zeshy_args
#zsh_options=( "${@[1,${zsh_option_last_index}]}" )
#zeshy_args=( "${@[${zsh_nonoption_first_index},-1]}" )
#print "options: ${zsh_options[@]}"
#print "nonoptions: ${zeshy_args[@]}"

#FUXME: O.K.; Linux login precedents are, frankly, bizarre. Here's out it works:
#
#* All (or nearly all) shells check $argv[0] to see whether or not the name they
#  were run as is prefixed with a hyphen (e.g., "-bash", "-zsh"). If so, this
#  indicates such shell should run as a login shell.
#* If not prefixed with a hyphen, some shells additionally check for a passed
#  option "-l" indicating the same thing (e.g., "bash -l", "zsh -l"). What's
#  particularly crazy here is that "man zsh" does not explicitly list "-l" in
#  the options it claims to accept -- even though it actually does! *sigh*
#
#In any case, the latter method of passing "-l" should suffice in the above
#driver script. We'll need to test ${0} for a "-" prefix in such script, as
#that's presumably what the "login" process will run such script as. (Crazy.)
#FUXME: Weaksauce. Linux's "/etc/passwd" shell field supports no passed
#arguments. *sigh* We'll need to create a secondary "/usr/bin/zeshy-login"
#script -- probably just a symbolic link to this script. We can then check
#whether or not this script was invoked as "zeshy-login"; if so, obviously
#prepend "-l" to the passed argument list as follows:
#FUXME: If neither "-l" or "-i" were passed, we needn't "exec" a new zsh process.
# For efficiently sensible process trees, replace the process running the
# current shell with a new process running zeshy under a new zsh shell.
#if [[ -n "${(M)zsh_options:#-[a-z]#[il]*}" ]]

#FUXME: O.K.; we should probably be testing here whether or not we were run with
#a "-"-prepended $argv[0] string and hence as a login shell. Unfortunately, I'm
#not entirely sure how to accomplish that cross-platform portably. zsh appears
#to provide no access to such string, as verified by printing such variables
#below. However, there is a way. You won't like it, but...
#"/proc/${$}/cmdline" *DOES* provide efficient access under Linux to the null-
#delimited argv string. That's probably the only way, unfortunately.
#FUXME: Uh-oh. Problem. zsh appears to squelch the prefixing "-" unless the
#script is explicitly called as follows: "- zsh /usr/bin/zeshy".
#"- /usr/bin/zeshy" has no effect. Lame! I suppose zsh thought it "knew" best
#and decided to simply hide such prefix. O.K.; that implies that we *NEED* "-l"
#to be explicitly passed to this script on login. We can...

#print "argv: ${argv[@]}"
#print "0: ${0}"

#FUXME: Fix. Document. Oh, Christ.
#[[ -o interactive ]] && {
#    print "already an interactive shell; unsure how to proceed, so dying" 1>&2
#    return 1
#}

#FUXME: Extend to support options -- particularly, "-c", which should definitely
#be the first option we implement support for, and "-", implying a login shell.
#Supporting the latter option is essential for masquerading zeshy as a proper
#shell (and in particular allowing use of zeshy in "/etc/passwd").
#FUXME: O.K.; this script pretty much has to be rewritten as a basic Bourne
#shell script. I know, I know; but there's really no other way. Such script
#should combine the contents of this and "zeshy.dev" into a single driver
#script invoking zsh with desired options (e.g., "-"). After careful thought, I
#can't help but conclude that the only sane means of loading zeshy when manually
#invoking zsh is by passing the path to ${ZESHY_HOME} as the first argument to
#"zsh" and all other arguments passed to such script as subsequent arguments to
#"zsh". According to "man zsh", "zsh -i ${ZESHY_HOME}" *SHOULD* have the desired
#effect of running "zsh" interactively after sourcing the passed zsh script.
# Map long to short options.
#(( ${+arg_options[--hello]} )) && arg_options[-h]=
#(( ${+arg_options[--login]} )) && arg_options[-l]=
#(( ${+arg_options[--interactive]} )) && arg_options[-i]=

# --                     halt parsing options
# --                     stop parsing options
#FUXME: [[ "${0:t}" == 'zeshy-login' ]] should do the trick more optimally.
#[[ "${0}" == (|*/)zeshy-login ]] && set -- -l "${@}"

#FUXME: No reason to leave this as a zsh script, really. "sh" is considerably
#lighter weight, and seems inherently much more appropriate for this sort-o'-
#thing. Consider switching. Hard. Well... actually, we *DO* benefit from zsh-
#specific functionality below -- particularly, for list element matching. I'm
#unconvinced that switching to "sh" nets us anything but headaches, really.
#FUXME: Not quite right, of course. Option "-c" and following arguments must be
#passed to zeshy as is and hence treated as non-options. How about:
#  integer nonoption_first_index="${@[(i)([^-]|-c)*]}"
#Simple, no? Don't worry about valid zsh options passed after the argument
#following "-c": they'll be passed to zeshy as arguments, and if the user
#doesn't like that... well, they can just reorder them then!

#(( nonoption_first_index > # )) && nonoption_first_index=0
#options="${(M)@:#-*}"
# arguments="${@:#-*}"
#for arg ("${@}") {

#for ((i = 1; i <= "${#}"; i++)) {
#    [[ "${@[${i}]}" == '-'* ]] or break
#    zeshy_options+="${@[${i}]}"
#}

# If the caller passed arguments, interpret the first argument as the absolute
# path to the zeshy script to be "executed" and remaining arguments as the
# arguments to be passed such script. Certainly, this is always the case when
# this wrapper script is indirectly invoked by a shebang script header (e.g.,
# "#!/usr/bin/env zeshy").
#if is_args
#then source_shell_script "${@}"
# If the caller passed no arguments and standard input for the current shell is
# attached to a terminal, drop the caller into a new interactive zsh shell
# inheriting current zeshy settings. For efficiency, replace the process running
# the current shell with the process running the new shell.
#
# Avoid calling is_shell_interactive() to test such condition. Since the current
# script is a file rather than standard input, zsh is not currently reading
# commands from standard input and hence disables shell option "interactive".
#elif [[ -t 0 ]]
#then exec zsh -i "${ZESHY_MAIN_SCRIPT}" "${@}"
# Otherwise, drop the caller off the Tarabithian bridge.
#else die 'expected at least one argument when called non-interactively'
#fi

#exec zsh -i "${ZESHY_MAIN_SCRIPT}" "${@}"

# Load zeshy.
#source "${ZESHY_MAIN_SCRIPT}"

#FUXME: This only works because our "/etc/zsh/zshrc" explicitly sources zeshy. In
#most cases, this will not have the desired effect. See above for possible
#solutions.
#
# If the caller passed no arguments and the current shell is a login shell, we
# are already done. zeshy startup has already detected being a login shell and
# responded accordingly (e.g., by setting the current ${PATH}).
#elif is_shell_login
#   [[ -o interactive ]] or print 'uh-oh: non-interactive!'
#FUXME: Call a safer zeshy wrapper around source(). Doesn't
#source_shell_script() suffice?
#elif [[ -t 0 ]]
#Does this run "src/always/shell/profile" or do we need to add additional
#options or function calls to do so?
# Ensure "${ZESHY_HOME}" is defined and, if not, try doing so.
#[[ -n "${ZESHY_HOME}" ]] || {
    #FUXME: "/etc/env.d" is Gentoo-specific. Since Debian-based distros provide
    #no equivalent directory, I'm afraid this simply doesn't scale. Replace
    #such functionality with the following approach:
    #
    #* Add a new "zeshy.dev" script, to be run by zeshy developers. This script
    #  guarantees ZESHY_HOME to be set to the "../src" directory relative to
    #  this directory via the current "readlink"-based solution in
    #  "../src/main". After doing so, that script immediately sources this
    #  script -- and that's it.
    #* This script should, perhaps, replace this entire block with:
    #
    #  export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"
#    if [[ -r    '/etc/env.d/%%zeshy' ]]
#    then source '/etc/env.d/%%zeshy'
#    else export ZESHY_HOME='/usr/share/zeshy'
#    fi
#}

# zeshy scripts are encouraged to load zeshy by replacing the first line of such
# files with a cross-platform portable shebang: e.g.,
#
# Third-party scripts requiring one or more zeshy components are encouraged to
# replace any existing shebang line at the top of each such file with:
#
#     #!/usr/bin/env zeshy
#
# This invokes this script on each such file, which:
#
# * Sources "zeshy/core", the core zeshy module providing (among other base
#   functionality) the import() function with which third-party scripts may
#   optionally import all other zeshy modules in a platform portable manner.
# * Runs "zsh" on the passed file.
#
# Third-party scripts requiring one or more zeshy components but not declaring
# the above shebang line should manually source the main zeshy script at the top of each
# such file with:
#
#     #!/usr/bin/env zsh
#     source 
#
# Note that this script performs additional checks for path and platform sanity;
# thus, the above approach is strongly discouraged.
# Main zeshy script. This zeshy-specific zsh shell script replaces the
# "#!/usr/bin/env zsh" shebang command, which invokes zsh on the file, with a
# "#!/usr/bin/env zeshy" shebang command, which invokes zeshy-capable zsh on the
# same file.
#
# Here, "zeshy-capable zsh" means a zsh shell process having available:
#
# * All functions, aliases, and variables exported by zeshy Core.
# * No functions or aliases exported by other zeshy components.
# * But possibly variables exported by other zeshy components, if inherited from the
#   caller's environment. In other words, do not rely on this.
#
#FUXME: Rename to ZESHY_MAIN_SCRIPT and set above immediately after setting
#ZESHY_HOME.

# The shebang line above implicitly runs this script under "zsh" by prepending
# the argument list passed to this script with the absolute path to this script.
# Shift off such path from such list.
#shift_one_arg

    # Ensure this zeshy script receives the expected arguments by popping off
    # the absolute path to this script from the argument list, thus leaving only
    # the script-specific arguments the caller passed.
    #FUXME: Hmmm; what was the idea here, again? Does the simple statement below
    #work, instead? Ah! I get it. We're running "zeshy" under "zsh" by virtue of
    #the shebang above. Right.
#   list arguments; arguments=( "${@}" )
#   source "${arguments}"
#   shift_one_arg

#   source "${ZESHY_MAIN_SCRIPT}"
#   exec zsh -i "${ZESHY_MAIN_SCRIPT}"
#   zsh -ic "source '${ZESHY_MAIN_SCRIPT}'"
#elif [[ -o interactive ]]; then
#FUXME: There's no way this works as is. (It'd be nice, though...) First, I
#doubt is_interactive() ever returns true in this context. Hence, this should
#probably test whether standard input and/or output are attached to a terminal
#device: e.g.,
#elif is_terminal; then
#Second, I highly doubt the invoked "zsh" subshell actually inherits the zeshy
#functions initialized above. Hence, the above "source" statement should be
#shifted under the above "if is_args; then" and then also executed here as
#something resembling (note the prefixing "exec"):
#   exec zsh -c "source '${ZESHY_HOME}/src/main'"
#But even that may not quite be right. Does this run "src/always/shell/profile"
#or do we need to add additional options or function calls to do so?

