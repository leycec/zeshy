#!/usr/bin/env zsh
# ====================[ zeshy                              ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# If passed no arguments, run Zeshy as an interactive shell under the current
# terminal; otherwise, run the passed command line or shell script under Zeshy.
#
# --------------------( OPTIONS                            )--------------------
# Zeshy accepts most command-line options accepted by zsh.
#
# --------------------( SCRIPTS                            )--------------------
# Zeshy scripts may load Zeshy by adding a shebang line to the first line of
# such files. For cross-platform portability, consider the following line:
#
#     #!/usr/bin/env zeshy
#
# Zeshy accepts most shell scripts accepted by zsh. However, several strategic
# design differences between Zeshy and zsh preclude perfect backward
# compatibility. The largest difference is strictness: Zeshy always throws an
# exception on any alias, command, or function returning non-zero exit status;
# zsh, on the other hand, ignores non-zero exit status where not explicitly
# handled (e.g., by appending "|| { print 'command failed' 1>&2; exit 1 }" to
# commands expected to fail).

# ....................{ PATHS                              }....................
#FIXME: The "install" script *MUST* absolutely globally replace all instances of
#  @ZESHY_HOME@ in this script. (There should only be one such instance,
#  but... *shrug*.) The at sign "@" is particularly helpful for this
#  purpose, as it appears to have no current reserved uses in Zsh.

# Absolute path of the root Zeshy overlay (i.e., topmost Zeshy directory). The
# Zeshy installation script defaults this path to the corresponding path passed
# to such script by the current system or user during Zeshy installation.
export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"

# Absolute path of the root Zeshy overlay's startup script, which when sourced
# loads all Zeshy aliases, functions, and globals specific to the current user.
export ZESHY_HOME_SCRIPT="${ZESHY_HOME}/main"

# If either such path is not found, fail with error.
[[ -d "${ZESHY_HOME}" ]] || {
    print "zeshy: main overlay \"${ZESHY_HOME}\" not found" 1>&2

    # If the default value for ${ZESHY_HOME} was not replaced, the Zeshy
    # installation script was probably not run. (Kindly notify the user.)
    [[ "${ZESHY_HOME}" == '@ZESHY_HOME_HOME@' ]] && {
        print 'zeshy: "@"-style substitution not substituted' 1>&2
        print 'zeshy: not installed or installed incorrectly' 1>&2
    }

    exit 1
}
[[ -f "${ZESHY_HOME_SCRIPT}" ]] || {
    print "zeshy: main script \"${ZESHY_HOME_SCRIPT}\" not found" 1>&2
    exit 1
}

# ....................{ MAIN                               }....................
# Load Zeshy.
source "${ZESHY_HOME_SCRIPT}"

#FIXME: Extend to support options -- particularly, "-c", which should definitely
#be the first option we implement support for, and "-", implying a login shell.
#Supporting the latter option is essential for masquerading Zeshy as a proper
#shell (and in particular allowing use of Zeshy in "/etc/passwd").

# If the caller passed arguments, interpret the first argument as the absolute
# path to the Zeshy script to be "executed" and remaining arguments as the
# arguments to be passed such script. Certainly, this is always the case when
# this wrapper script is indirectly invoked by a shebang script header (e.g.,
# "#!/usr/bin/env zeshy").
if is_args
then source_shell_script "${@}"
# If the caller passed no arguments and the current shell is a login shell, we
# are already done. Zeshy startup has already detected being a login shell and
# responded accordingly (e.g., by setting the current ${PATH}).
elif is_shell_login
then noop
# If the caller passed no arguments and standard input for the current shell is
# attached to a terminal, drop the caller into a new interactive Zsh shell
# inheriting current Zeshy settings. For efficiency, replace the process running
# the current shell with the process running the new shell.
#
# Avoid calling is_shell_interactive() to test such condition. Since the current
# script is a file rather than standard input, Zsh is not currently reading
# commands from standard input and hence disables shell option "interactive".
elif is_standard_input_terminal
then exec zsh
# Otherwise, drop the caller off the Tarabithian bridge.
else die 'expected at least one argument when called non-interactively'
fi

# --------------------( WASTELANDS                         )--------------------
#   [[ -o interactive ]] or print 'uh-oh: non-interactive!'
#FUXME: Call a safer Zeshy wrapper around source(). Doesn't
#source_shell_script() suffice?
#elif [[ -t 0 ]]
#Does this run "src/always/shell/profile" or do we need to add additional
#options or function calls to do so?
# Ensure "${ZESHY_HOME}" is defined and, if not, try doing so.
#[[ -n "${ZESHY_HOME}" ]] || {
    #FUXME: "/etc/env.d" is Gentoo-specific. Since Debian-based distros provide
    #no equivalent directory, I'm afraid this simply doesn't scale. Replace
    #such functionality with the following approach:
    #
    #* Add a new "zeshy.dev" script, to be run by Zeshy developers. This script
    #  guarantees ZESHY_HOME to be set to the "../src" directory relative to
    #  this directory via the current "readlink"-based solution in
    #  "../src/main". After doing so, that script immediately sources this
    #  script -- and that's it.
    #* This script should, perhaps, replace this entire block with:
    #
    #  export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"
#    if [[ -r    '/etc/env.d/%%zeshy' ]]
#    then source '/etc/env.d/%%zeshy'
#    else export ZESHY_HOME='/usr/share/zeshy'
#    fi
#}

# Zeshy scripts are encouraged to load Zeshy by replacing the first line of such
# files with a cross-platform portable shebang: e.g.,
#
# Third-party scripts requiring one or more Zeshy components are encouraged to
# replace any existing shebang line at the top of each such file with:
#
#     #!/usr/bin/env zeshy
#
# This invokes this script on each such file, which:
#
# * Sources "zeshy/core", the core Zeshy module providing (among other base
#   functionality) the import() function with which third-party scripts may
#   optionally import all other Zeshy modules in a platform portable manner.
# * Runs "zsh" on the passed file.
#
# Third-party scripts requiring one or more Zeshy components but not declaring
# the above shebang line should manually source the main Zeshy script at the top of each
# such file with:
#
#     #!/usr/bin/env zsh
#     source 
#
# Note that this script performs additional checks for path and platform sanity;
# thus, the above approach is strongly discouraged.
# Main Zeshy script. This Zeshy-specific Zsh shell script replaces the
# "#!/usr/bin/env zsh" shebang command, which invokes Zsh on the file, with a
# "#!/usr/bin/env zeshy" shebang command, which invokes Zeshy-capable Zsh on the
# same file.
#
# Here, "Zeshy-capable Zsh" means a Zsh shell process having available:
#
# * All functions, aliases, and variables exported by Zeshy Core.
# * No functions or aliases exported by other Zeshy components.
# * But possibly variables exported by other Zeshy components, if inherited from the
#   caller's environment. In other words, do not rely on this.
#
#FUXME: Rename to ZESHY_HOME_SCRIPT and set above immediately after setting
#ZESHY_HOME.

# The shebang line above implicitly runs this script under "zsh" by prepending
# the argument list passed to this script with the absolute path to this script.
# Shift off such path from such list.
#shift_one_arg

    # Ensure this Zeshy script receives the expected arguments by popping off
    # the absolute path to this script from the argument list, thus leaving only
    # the script-specific arguments the caller passed.
    #FUXME: Hmmm; what was the idea here, again? Does the simple statement below
    #work, instead? Ah! I get it. We're running "zeshy" under "zsh" by virtue of
    #the shebang above. Right.
#   list arguments; arguments=( "${@}" )
#   source "${arguments}"
#   shift_one_arg

#   source "${ZESHY_HOME_SCRIPT}"
#   exec zsh -i "${ZESHY_HOME_SCRIPT}"
#   zsh -ic "source '${ZESHY_HOME_SCRIPT}'"
#elif [[ -o interactive ]]; then
#FUXME: There's no way this works as is. (It'd be nice, though...) First, I
#doubt is_interactive() ever returns true in this context. Hence, this should
#probably test whether standard input and/or output are attached to a terminal
#device: e.g.,
#elif is_terminal; then
#Second, I highly doubt the invoked "zsh" subshell actually inherits the Zeshy
#functions initialized above. Hence, the above "source" statement should be
#shifted under the above "if is_args; then" and then also executed here as
#something resembling (note the prefixing "exec"):
#   exec zsh -c "source '${ZESHY_HOME}/src/main'"
#But even that may not quite be right. Does this run "src/always/shell/profile"
#or do we need to add additional options or function calls to do so?

