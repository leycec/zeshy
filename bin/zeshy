#!/usr/bin/env zsh
# ====================[ zeshy                              ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# If passed no arguments, run Zeshy as an interactive shell under the current
# terminal; otherwise, run the passed command line or shell script under Zeshy.
#
# --------------------( OPTIONS                            )--------------------
# Zeshy accepts most command-line options accepted by zsh.
#
# --------------------( SCRIPTS                            )--------------------
# Zeshy scripts may load Zeshy by adding a shebang line to the first line of
# such files. For cross-platform portability, consider the following line:
#
#     #!/usr/bin/env zeshy
#
# Zeshy accepts most shell scripts accepted by zsh. However, several strategic
# design differences between Zeshy and zsh preclude perfect backward
# compatibility. The largest difference is strictness: Zeshy always throws an
# exception on any alias, command, or function returning non-zero exit status;
# zsh, on the other hand, ignores non-zero exit status where not explicitly
# handled (e.g., by appending "|| { print 'command failed' 1>&2; exit 1 }" to
# commands expected to fail).
#
# --------------------( TODO                               )--------------------
# * Document somewhere that setting Zeshy as a user's default "/etc/passwd"
#   shell requires adding "zeshy-login" to "/etc/shells" under Linux and
#   "zeshy-login" as the corresponding shell field.
# * The fact that Zsh squelches "-" prefixes on ${argv[0]} is a clue that we
#   probably want to reimplement this script in POSIX C. (Could be quite fun,
#   actually, aside from the fact that it'll require a substantially smarter
#   Zeshy makefile.) Shouldn't be a terribly large file; everything we're doing
#   here *SHOULD* have a direct C analogue. The potential startup speedup makes
#   this a particularly worthwhile improvement.

# ....................{ PATHS                              }....................
#FIXME: The "install" script *MUST* absolutely globally replace all instances of
#  @ZESHY_HOME@ in this script. (There should only be one such instance,
#  but... *shrug*.) The at sign "@" is particularly helpful for this
#  purpose, as it appears to have no current reserved uses in Zsh.

# Absolute path of the root Zeshy overlay (i.e., topmost Zeshy directory). The
# Zeshy installation script defaults this path to the corresponding path passed
# to such script by the current system or user during Zeshy installation.
export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"

# Absolute path of the root Zeshy overlay's startup script, which when sourced
# loads all Zeshy aliases, functions, and globals specific to the current user.
export ZESHY_HOME_SCRIPT="${ZESHY_HOME}/main"

# If either such path is not found, fail with error.
[[ -d "${ZESHY_HOME}" ]] || {
    print "zeshy: main overlay \"${ZESHY_HOME}\" not found" 1>&2

    # If the default value for ${ZESHY_HOME} was not replaced, the Zeshy
    # installation script was probably not run. (Kindly notify the user.)
    [[ "${ZESHY_HOME}" == '@ZESHY_HOME_HOME@' ]] && {
        print 'zeshy: "@"-style substitution not substituted' 1>&2
        print 'zeshy: not installed or installed incorrectly' 1>&2
    }

    exit 1
}
[[ -f "${ZESHY_HOME_SCRIPT}" ]] || {
    print "zeshy: main script \"${ZESHY_HOME_SCRIPT}\" not found" 1>&2
    exit 1
}

# ....................{ MAIN                               }....................
#FIXME: Extend to support options -- particularly, "-c", which should definitely
#be the first option we implement support for, and "-", implying a login shell.
#Supporting the latter option is essential for masquerading Zeshy as a proper
#shell (and in particular allowing use of Zeshy in "/etc/passwd").
#FIXME: O.K.; this script pretty much has to be rewritten as a basic Bourne
#shell script. I know, I know; but there's really no other way. Such script
#should combine the contents of this and "zeshy.dev" into a single driver
#script invoking zsh with desired options (e.g., "-"). After careful thought, I
#can't help but conclude that the only sane means of loading Zeshy when manually
#invoking zsh is by passing the path to ${ZESHY_HOME} as the first argument to
#"zsh" and all other arguments passed to such script as subsequent arguments to
#"zsh". According to "man zsh", "zsh -i ${ZESHY_HOME}" *SHOULD* have the desired
#effect of running "zsh" interactively after sourcing the passed Zsh script.
#FIXME: Note that this will play poorly with our current method of sourcing
#Zeshy in "/etc/zsh/zshrc". We'll be loading Zeshy twice -- first by
#"/etc/zsh/zshrc" and second by the passed parameter to "zsh". Clearly, the
#latter should immediately return if having already been loaded by
#"/etc/zsh/zshrc". How to test... Ah! What if we run zsh from such driver script
#as: 'zsh "${ZESHY_HOME}" 1 "${@}"'. Passing "1" notifies the "src/main" Zeshy
#script that it is being loaded from the driver; if such argument is passed and
#Zeshy has already been loaded, silently avoid reloading Zeshy. Or some such...
#Hmmm. It still doesn't feel quite right, though. Running "/usr/bin/zeshy"
#should reload Zeshy in *ALL* cases *EXCEPT* where a dot-file has already loaded
#Zeshy *IN THE SAME PROCESS*. I suppose we could have Zeshy set the ID of the
#Zsh process from which it was originally loaded; then, on subsequently
#detecting that Zeshy is being reloaded, do so *UNLESS* the current process ID...
#Hmm. No. Subtle issues abound, clearly. Hmmmm.
#FIXME: I reckon we'd need to explicitly check in Zeshy for being loaded from
#both a dot-file (as evidenced by the current call stack -- just see if the
#topmost entry of the call stack is a path prefixed by either "/etc/zsh" or
#"$ZDOTDIR" -- wait; no, "/etc/zsh" is non-portable; O.K.; how about this: ...is
#a path matching glob "*/(.|)(zprofile|zshrc)" -- coolio!) and the driver script
#(as evidenced by canonical Zsh global ${PPID}, which can be used to examine the
#process list or, I suppose, just "/proc/${PPID}/cmdline" for now). Should be
#quite an efficient test, in any case. If the test matches, return immediately
#from Zeshy -- since Zsh will be sourcing Zeshy immediately anyway from the
#passed argument. This implies that sourcing Zeshy from "/etc/zsh/zshrc" is only
#of use in forcing all login and interactive Zsh shells to also source Zeshy.
#Not terribly helpful, really, since "/usr/bin/zeshy" already provides such a
#shell. In any case, implement the above heuristic -- and, for debugging purposes,
#print out a warning that we'll probably squelch in some later version.
#FIXME: The above heuristic is a helpful first approximation. Unfortunately,
#testing "/proc/${PPID}/cmdline" isn't terribly cross-platform portable. For
#efficiency reasons, I'd also rather not call external commands (e.g., "ps").
#Consequently, perhaps we'd rather try the following in "src/main":
#
#* Set ${ZESHY_PID} as a global export in "src/main" to the current process ID.
#* Immediately before setting such global export, test whether or not:
#  [[ "${ZESHY_PID-}" -eq "${PPID}" ]]
#  If such test is true, Zeshy has already been loaded by the parent process and
#  hence (hopefully) inherited by the current process. Return immediately.
#
#Seems a bit risky -- but I can't see any inherent flaws, at the moment. Hmm;
#actually, that's pretty shoddy. Zeshy would then behave differently when running
#scripts directly under a Zeshy shell versus running scripts under other scripts.
#Silly. O.K.; how about something more specific to Zsh startup flow:
#
#* If [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PPID}" ]], then:
#  * Zeshy has already been loaded by the parent process and hence (hopefully)
#    inherited by the current process. Return immediately.
#* If [[ "${funcstack[1]}" == "*/(.|)(zprofile|zshrc)" ]], then:
#  * Set ${ZESHY_PID_IF_ZSH_STARTUP} as a global export in "src/main" ala:
#    typeset -igx ZESHY_PID_IF_ZSH_STARTUP="${PID}"
#
#Looks good. Only, note that Zeshy *MAY* (and should, really) execute passed
#scripts in the current shell process. Actually, it'd better. Be stupid to spawn
#a new subshell, right? In that case, the test is simply:
#
#  [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PID}" ]]
#
#Well, test which, anyway.
#
#Oh, and if such test succeeds, "unset ZESHY_PID_IF_ZSH_STARTUP". No more reason
#to keep such global around at that point -- just clutters things up.
#FIXME: O.K.; Linux login precedents are, frankly, bizarre. Here's out it works:
#
#* All (or nearly all) shells check $argv[0] to see whether or not the name they
#  were run as is prefixed with a hyphen (e.g., "-bash", "-zsh"). If so, this
#  indicates such shell should run as a login shell.
#* If not prefixed with a hyphen, some shells additionally check for a passed
#  option "-l" indicating the same thing (e.g., "bash -l", "zsh -l"). What's
#  particularly crazy here is that "man zsh" does not explicitly list "-l" in
#  the options it claims to accept -- even though it actually does! *sigh*
#
#In any case, the latter method of passing "-l" should suffice in the above
#driver script. We'll need to test ${0} for a "-" prefix in such script, as
#that's presumably what the "login" process will run such script as. (Crazy.)
#FIXME: Weaksauce. Linux's "/etc/passwd" shell field supports no passed
#arguments. *sigh* We'll need to create a secondary "/usr/bin/zeshy-login"
#script -- probably just a symbolic link to this script. We can then check
#whether or not this script was invoked as "zeshy-login"; if so, obviously
#prepend "-l" to the passed argument list as follows:
[[ "${0}" == (|*/)zeshy-login ]] && set -- -l "${@}"

#FIXME: Fix. Document. Oh, Christ.
[[ -o interactive ]] && {
    print "already an interactive shell; unsure how to respond, frankly" 1>&2
    return 1
}

#FIXME: O.K.; we should probably be testing here whether or not we were run with
#a "-"-prepended $argv[0] string and hence as a login shell. Unfortunately, I'm
#not entirely sure how to accomplish that cross-platform portably. Zsh appears
#to provide no access to such string, as verified by printing such variables
#below. However, there is a way. You won't like it, but...
#"/proc/${$}/cmdline" *DOES* provide efficient access under Linux to the null-
#delimited argv string. That's probably the only way, unfortunately.
#FIXME: Uh-oh. Problem. Zsh appears to squelch the prefixing "-" unless the
#script is explicitly called as follows: "- zsh /usr/bin/zeshy".
#"- /usr/bin/zeshy" has no effect. Lame! I suppose Zsh thought it "knew" best
#and decided to simply hide such prefix. O.K.; that implies that we *NEED* "-l"
#to be explicitly passed to this script on login. We can 

#print "argv: ${argv[@]}"
#print "0: ${0}"

# If the caller passed no arguments and...
[[ ${#} -eq 0 ]] &&
    # If standard input to the current shell is attached to a terminal, drop the
    # caller into an interactive Zeshy shell.
    if [[ -t 0 ]]
    then set -- -i
    # Otherwise, drop the caller off the Tarabithian bridge.
    else die 'expected at least one argument when called non-interactively'
    fi

# Find the index of the first passed argument either equal to "-c" or not
# prefixed by "-", signifying the first Zeshy-specific argument.
integer zsh_nonoption_first_index="${@[(i)(-c|([^-])*)]}"
integer zsh_option_last_index=$(( zsh_nonoption_first_index - 1))

# Split passed arguments into Zsh-specific options and Zeshy-specific arguments.
# The former include all passed arguments prefixed by "-" excluding "-c", while
# the latter include all remaining passed arguments.
local -a zsh_options zeshy_args
zsh_options=( "${@[1,${zsh_option_last_index}]}" )
zeshy_args=( "${@[${zsh_nonoption_first_index},-1]}" )
#print "options: ${zsh_options[@]}"
#print "nonoptions: ${zeshy_args[@]}"

# For efficiently sensible process trees, replace the process running the
# current shell with a new process running Zeshy under a new Zsh shell.
exec zsh "${zsh_options[@]}" --\
    "${ZESHY_HOME_SCRIPT}" "${zeshy_args[@]}"

# --------------------( WASTELANDS                         )--------------------
#FUXME: No reason to leave this as a Zsh script, really. "sh" is considerably
#lighter weight, and seems inherently much more appropriate for this sort-o'-
#thing. Consider switching. Hard. Well... actually, we *DO* benefit from Zsh-
#specific functionality below -- particularly, for list element matching. I'm
#unconvinced that switching to "sh" nets us anything but headaches, really.
#FUXME: Not quite right, of course. Option "-c" and following arguments must be
#passed to Zeshy as is and hence treated as non-options. How about:
#  integer nonoption_first_index="${@[(i)([^-]|-c)*]}"
#Simple, no? Don't worry about valid Zsh options passed after the argument
#following "-c": they'll be passed to Zeshy as arguments, and if the user
#doesn't like that... well, they can just reorder them then!

#(( nonoption_first_index > # )) && nonoption_first_index=0
#options="${(M)@:#-*}"
# arguments="${@:#-*}"
#for arg ("${@}") {

#for ((i = 1; i <= "${#}"; i++)) {
#    [[ "${@[${i}]}" == '-'* ]] or break
#    zeshy_options+="${@[${i}]}"
#}

# If the caller passed arguments, interpret the first argument as the absolute
# path to the Zeshy script to be "executed" and remaining arguments as the
# arguments to be passed such script. Certainly, this is always the case when
# this wrapper script is indirectly invoked by a shebang script header (e.g.,
# "#!/usr/bin/env zeshy").
#if is_args
#then source_shell_script "${@}"
# If the caller passed no arguments and standard input for the current shell is
# attached to a terminal, drop the caller into a new interactive Zsh shell
# inheriting current Zeshy settings. For efficiency, replace the process running
# the current shell with the process running the new shell.
#
# Avoid calling is_shell_interactive() to test such condition. Since the current
# script is a file rather than standard input, Zsh is not currently reading
# commands from standard input and hence disables shell option "interactive".
#elif [[ -t 0 ]]
#then exec zsh -i "${ZESHY_HOME_SCRIPT}" "${@}"
# Otherwise, drop the caller off the Tarabithian bridge.
#else die 'expected at least one argument when called non-interactively'
#fi

#exec zsh -i "${ZESHY_HOME_SCRIPT}" "${@}"

# Load Zeshy.
#source "${ZESHY_HOME_SCRIPT}"

#FUXME: This only works because our "/etc/zsh/zshrc" explicitly sources Zeshy. In
#most cases, this will not have the desired effect. See above for possible
#solutions.
#
# If the caller passed no arguments and the current shell is a login shell, we
# are already done. Zeshy startup has already detected being a login shell and
# responded accordingly (e.g., by setting the current ${PATH}).
#elif is_shell_login
#   [[ -o interactive ]] or print 'uh-oh: non-interactive!'
#FUXME: Call a safer Zeshy wrapper around source(). Doesn't
#source_shell_script() suffice?
#elif [[ -t 0 ]]
#Does this run "src/always/shell/profile" or do we need to add additional
#options or function calls to do so?
# Ensure "${ZESHY_HOME}" is defined and, if not, try doing so.
#[[ -n "${ZESHY_HOME}" ]] || {
    #FUXME: "/etc/env.d" is Gentoo-specific. Since Debian-based distros provide
    #no equivalent directory, I'm afraid this simply doesn't scale. Replace
    #such functionality with the following approach:
    #
    #* Add a new "zeshy.dev" script, to be run by Zeshy developers. This script
    #  guarantees ZESHY_HOME to be set to the "../src" directory relative to
    #  this directory via the current "readlink"-based solution in
    #  "../src/main". After doing so, that script immediately sources this
    #  script -- and that's it.
    #* This script should, perhaps, replace this entire block with:
    #
    #  export ZESHY_HOME="${ZESHY_HOME:-@ZESHY_HOME@}"
#    if [[ -r    '/etc/env.d/%%zeshy' ]]
#    then source '/etc/env.d/%%zeshy'
#    else export ZESHY_HOME='/usr/share/zeshy'
#    fi
#}

# Zeshy scripts are encouraged to load Zeshy by replacing the first line of such
# files with a cross-platform portable shebang: e.g.,
#
# Third-party scripts requiring one or more Zeshy components are encouraged to
# replace any existing shebang line at the top of each such file with:
#
#     #!/usr/bin/env zeshy
#
# This invokes this script on each such file, which:
#
# * Sources "zeshy/core", the core Zeshy module providing (among other base
#   functionality) the import() function with which third-party scripts may
#   optionally import all other Zeshy modules in a platform portable manner.
# * Runs "zsh" on the passed file.
#
# Third-party scripts requiring one or more Zeshy components but not declaring
# the above shebang line should manually source the main Zeshy script at the top of each
# such file with:
#
#     #!/usr/bin/env zsh
#     source 
#
# Note that this script performs additional checks for path and platform sanity;
# thus, the above approach is strongly discouraged.
# Main Zeshy script. This Zeshy-specific Zsh shell script replaces the
# "#!/usr/bin/env zsh" shebang command, which invokes Zsh on the file, with a
# "#!/usr/bin/env zeshy" shebang command, which invokes Zeshy-capable Zsh on the
# same file.
#
# Here, "Zeshy-capable Zsh" means a Zsh shell process having available:
#
# * All functions, aliases, and variables exported by Zeshy Core.
# * No functions or aliases exported by other Zeshy components.
# * But possibly variables exported by other Zeshy components, if inherited from the
#   caller's environment. In other words, do not rely on this.
#
#FUXME: Rename to ZESHY_HOME_SCRIPT and set above immediately after setting
#ZESHY_HOME.

# The shebang line above implicitly runs this script under "zsh" by prepending
# the argument list passed to this script with the absolute path to this script.
# Shift off such path from such list.
#shift_one_arg

    # Ensure this Zeshy script receives the expected arguments by popping off
    # the absolute path to this script from the argument list, thus leaving only
    # the script-specific arguments the caller passed.
    #FUXME: Hmmm; what was the idea here, again? Does the simple statement below
    #work, instead? Ah! I get it. We're running "zeshy" under "zsh" by virtue of
    #the shebang above. Right.
#   list arguments; arguments=( "${@}" )
#   source "${arguments}"
#   shift_one_arg

#   source "${ZESHY_HOME_SCRIPT}"
#   exec zsh -i "${ZESHY_HOME_SCRIPT}"
#   zsh -ic "source '${ZESHY_HOME_SCRIPT}'"
#elif [[ -o interactive ]]; then
#FUXME: There's no way this works as is. (It'd be nice, though...) First, I
#doubt is_interactive() ever returns true in this context. Hence, this should
#probably test whether standard input and/or output are attached to a terminal
#device: e.g.,
#elif is_terminal; then
#Second, I highly doubt the invoked "zsh" subshell actually inherits the Zeshy
#functions initialized above. Hence, the above "source" statement should be
#shifted under the above "if is_args; then" and then also executed here as
#something resembling (note the prefixing "exec"):
#   exec zsh -c "source '${ZESHY_HOME}/src/main'"
#But even that may not quite be right. Does this run "src/always/shell/profile"
#or do we need to add additional options or function calls to do so?

