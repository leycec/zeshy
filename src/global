#!/usr/bin/env zsh
# ====================[ globals                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Declare universally applicable Zeshy variables.
#
# --------------------( TODO                               )--------------------
# * Right. I'm noticing an escalating trend with --exclude options in
#   "if_config/posix". Instead, we should probably define a Zeshy-wide exclusion
#   file listing commonly excludable patterns. Simpler. Reduces redundancy.

#FIXME: This file should only contain non-configurable constants. Perhaps rename
#to "magic"?
#FIXME: You know... after making all of the recommended changes below, this file
#basically just sets a few global paths. No reason not to shift such settings
#into "main", as far as I can see. Excise us up this file, please.

# ....................{ DECLARATIONS                       }....................
# For readability, declare global variables prior to their definition below.
global_integer ZESHY_STDIN ZESHY_STDOUT ZESHY_STDERR
global_map ZESHY_MAP_SHELL_NAME_TO_EMULATABLE_SHELL_NAME
global_string\
    ZESHY_CHARACTER_NEWLINE\
    ZESHY_CHARACTER_TAB\
    ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY\
    ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY

# ....................{ INTEGERS ~ file descriptors        }....................
#FIXME: Rename to ${ZESHY_FILE_DESCRIPTOR_STANDARD_INPUT}, etc.
# POSIX-prescribed file descriptors (i.e., integers identifying open files).
ZESHY_STDIN=0
ZESHY_STDOUT=1
ZESHY_STDERR=2

# ....................{ CHARACTERS                         }....................
# Character constants to be interpolated into unprinted strings (e.g., globs,
# regular expressions). Zsh interprets escaped characters such as \n (newline)
# and \t (tab) as "special" only when passed to the echo() or print() builtins;
# in all other cases, Zsh passes such characters as is (i.e., without
# interpretation) through to the underlying builtins. Embedding such characters
# in $'...'-style quotes (as below) circumvents this, inducing Zsh to interpret
# such characters regardless of which builtin finally receives them.
ZESHY_CHARACTER_NEWLINE=$'\n'
ZESHY_CHARACTER_TAB=$'\t'

# ....................{ GLOBS                              }....................
# Glob matching all shells explicitly emulatable by Zsh (i.e., by "emulate").
ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY='zsh|sh|ksh|csh'

# Glob matching all shells implicitly emulatable by Zsh and hence sourceable
# by source_shell_script().
ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY='zeshy|(|a|ba|c|da|k|mk|pdk|re|tc|z)sh'

# ....................{ MAPS                               }....................
# Map from shell name to the name of the Zsh-emulatable shell closest in
# ancestry and hence operation to the former shell if a sufficiently close shell
# exists. Zsh-emulatable shells are those explicitly accepted by the emulate()
# builtin: at present, only "sh", "csh", "ksh", and "zsh".
ZESHY_MAP_SHELL_NAME_TO_EMULATABLE_SHELL_NAME=(
    # Bourne shell emulatable.
    'a'  'sh'
    'ba' 'sh'
    'da' 'sh'
    're' 'sh'
    'sh' 'sh'

    # csh emulatable.
    'csh'  'csh'
    'tcsh' 'csh'

    # ksh emulatable.
    'ksh'   'ksh'
    'mksh'  'ksh'
    'pdksh' 'ksh'

    # zsh emulatable.
    'zsh' 'zsh'
)

# ....................{ INTEGERS ~ priority                }....................
#FIXME: No reason to have here. Copy to the "nice" and "ionice" sections of
#"if_config/posix".

# "nice"-specific highest and lowest priority for CPU scheduling of processes.
global_integer ZESHY_NICE_PRIORITY_HIGH=-20 ZESHY_NICE_PRIORITY_LOW=19

# "ionice"-specific highest and lowest priority pairs consisting of class and
# ioniceness for I/O scheduling of processes. Processes assigned to class 3
# signify "idle-only" processes to be scheduled only when no other process
# performs I/O. Since such processes are likely to suffer scheduling starvation,
# we omit class 3 from consideration.
global_integer\
    ZESHY_IONICE_CLASS_HIGH=1 ZESHY_IONICE_CLASS_LOW=2\
    ZESHY_IONICE_CLASS_PRIORITY_HIGH=0 ZESHY_IONICE_CLASS_PRIORITY_LOW=7

# ....................{ COMMANDS                           }....................
#FIXME: No reason to have here. Copy to the "less" section of
#"if_config/posix".

# "less"-specific options, as required by commands calling "less" (e.g., "man").
global_string LESS="${LESS:--R}"

# ....................{ I18N                               }....................
#FIXME: No reason to have here. Copy to the top of "if_config/posix", into a new
#"I18N" section.

#FIXME: Is this globally safe? This should be safe assuming no terminal device.
#If this shell is attached to a terminal device, however, we should probably
#only accept UTF-8 output under terminal devices accepting such input. Perhaps
#the terminfo database publishes such details? Investigate.
# Enable Unicode support, if not already enabled.
global_string LANG="${LANG:-en_US.utf8}" LC_ALL="${LC_ALL:-en_US.utf8}"

# ....................{ PATHS                              }....................
#FIXME: Copy to "if_config/zeshy" with the same section name.

# User-specific Zeshy dot directory basename.
global_string ZESHY_DOT_DIR_BASENAME='.zeshy'

# User-specific Zeshy dot directory. If ${HOME} is the root directory, this is
# probably a cronjob, in which case this directory resides under "/var".
if is "${HOME}" == '/' si
then global_string ZESHY_DOT_DIR='/var/cache/zeshy'
else global_string ZESHY_DOT_DIR="${HOME}/${ZESHY_DOT_DIR_BASENAME}"
fi

# Directory from which Zeshy reads user configuration files.
global_string ZESHY_USER_CONFIG_DIR="${ZESHY_DOT_DIR}/config"

# Directory from which Zeshy reads user themes, plugins, etc.
global_string ZESHY_USER_OVERLAY_ROOT="${ZESHY_DOT_DIR}/src"

# File to which compinit() caches its configuration.
global_string ZESHY_USER_COMPINIT_FILE="${ZESHY_DOT_DIR}/compinit"

# Directory to which Zsh caches completions.
global_string ZESHY_USER_COMPLETION_DIR="${ZESHY_DOT_DIR}/completion"

# Directory to which Zeshy compiles itself. Since such compilation necessarily
# depends on user-specific configuration (e.g., theme selection, command $PATH),
# Zeshy recompiles itself under each user.
global_string ZESHY_USER_DIGEST_FILE="${ZESHY_DOT_DIR}/digest.zwc"

# Directory to which Zsh caches process IDs.
global_string ZESHY_USER_PID_DIR="${ZESHY_DOT_DIR}/run"

# File to which Zeshy caches its version specifier (e.g., to detect upgrades).
global_string ZESHY_USER_VERSION_FILE="${ZESHY_DOT_DIR}/version"

# ....................{ PATHS ~ history                    }....................
#FIXME: Shift into "config/zsh". Users might reasonably want to configure these
#and they don't really fit here, I'm afraid. Hmm. Actually, these and the above
#globals don't really fit in "config/main" either, as they'd have to be prefixed
#by "global_string" and "global_integer" (unlike customary globals in
#"config/main"). We probably want a new "config/zsh" file for Zsh-specific
#globals and a "config/system" file for the globals above.

# Maximum number of lines of Zsh command-line history to persist.
global_integer HISTSIZE="${HISTSIZE:-1024}"

# Maximum number of lines of Zsh command-line history to retain between logins.
global_integer SAVEHIST="${SAVEHIST:-1024}"

# File to which Zsh persists command-line history.
global_string HISTFILE="${HISTFILE:-${ZESHY_DOT_DIR}/history}"

# ....................{ CONFIGURATION                      }....................
# Zeshy configuration settings, set on sourcing the system- and user-specific
# Zeshy configuration file below.

# --------------------( WASTELANDS                         )--------------------
# ....................{ MAGIC                              }....................
#FIXME: Copy to "if_config/magic", a new configuration file containing only
#magic numbers which should *NEVER* be changed. Wait. That's not exactly a
#configuration file then, is it? These should probably be sh ZESHY_

#globals of universal applicability to other
# Zeshy components and scripts.
# File from which Zeshy reads globals declared under "CONFIGURATION", below.
#global_string ZESHY_USER_CONFIG_FILE="${ZESHY_USER_CONFIG_DIR}/main"

# Hmmmmm; or, perhaps
#all we need is a function global_integer_if_unset(). That would permit us to
#include all of the above globals in the same manner as in "config/main", which
#is nice. Dead simple implementation: just test if the passed name is a global
#variable using... (hm what, exactly? Google.) ...and, if not, declare. I wonder
#if there's some parameter to be passed to typeset to disable the default
#"display variable if already defined" behavior, which is quite onerous, really.
#Oh, nmind. Uh. "global_string z" works... *sigh* Cut all of the nonsense above.
# ....................{ PATHS                              }....................
# Directory hosting Zeshy scripts only conditionally needed during bootstrap.
#global_string ZESHY_AUXILIARY_DIR="${ZESHY_OVERLAY_ROOT}/if_needed"

#FIXME: Excise me.
# Directory hosting Zeshy scripts whose functions are autoloadable.
#global_string ZESHY_AUTOLOAD_DIR="${ZESHY_OVERLAY_ROOT}/autoload"
#global_string\
#    ZESHY_AUTOLOAD_CORE_DIR="${ZESHY_AUTOLOAD_DIR}/always"\
#    ZESHY_AUTOLOAD_COMMAND_DIR="${ZESHY_AUTOLOAD_DIR}/if_installed"\
#    ZESHY_AUTOLOAD_DISTRO_DIR="${ZESHY_AUTOLOAD_DIR}/if_distro"\
#    ZESHY_AUTOLOAD_THEME_DIR="${ZESHY_AUTOLOAD_DIR}/if_theme"

# Zeshy script setting the globals defined under "CONFIGURATION", below.
#global_string ZESHY_USER_CONFIG_FILE="${ZESHY_USER_CONFIG_DIR}/main"

    # Load the default and user-specific Zeshy configuration files, the former
    # ensuring all globals at least have some default value and the latter
    # replacing such value with user-specific settings.
    # Make user-specific Zeshy directories, if needed.
    # Copy the default to a user-specific Zeshy configuration file, if the
    # latter is not found.
    #FIXME: Nice try; but there's a new game in town. See Zeshy Core. The

    #specific problem with this is that it's slow. The config file is
    #increasingly large. We don't want to source it twice. But we also don't
    #want an empty or small user config file, since that renders the upgrade
    #process opaque (and also makes debugging by the user quite troublesome:
    #where is that global being set again and why?). The user can *CHOOSE* to
    #have a small local config, if they like; but that's a choice. This isn't.

#   source "${ZESHY_USER_CONFIG_FILE_DEFAULT}"
# ....................{ BOOLEANS                           }....................
# If non-empty, the current process is running as a cronjob. (Set below.)
#global_bool ZESHY_IS_CRONJOB

# Directory to which Zeshy mounts media.
#global_string ZESHY_MOUNT_HOME='/media'

# Directory to which Zeshy mounts ISOs.
#global_string ZESHY_MOUNT_ISO_PATH="${ZESHY_MOUNT_HOME}/iso"

# ....................{ STRINGS                            }....................
#FIXME: Erhm; I suspect the following global to be largely obsolete, now. (Or,
#at best, only applicable to Zeshy scripts requiring require().)
# Basename for all "main" Zeshy scripts. These are scripts Zeshy looks for when
# a caller attempts to import a path rather than a file: e.g.,
#
#     # Actually imports "zeshy/${ZESHY_MAIN_SCRIPT_BASENAME}", instead.
#     >>> zimport zeshy
#global_string ZESHY_MAIN_SCRIPT_BASENAME='.main'

#is_empty "${ZESHY_SCRIPT_NAME}" and
# Human-readable name of the current script. This is used only for output.
# Scripts are welcome to redefine it globally; likewise, functions are welcome
# to redefine it locally. (Set below.)
#global_string ZESHY_SCRIPT_NAME

# Directory to which Zeshy caches scripts implicitly compiled by zimport().
#global_string ZESHY_CACHE_COMPILATION_DIR="${ZESHY_DOT_DIR}/compilation"
