#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *argument count exception handlers* (i.e., runnables throwing exceptions
unless the number of arguments passed to the current functions or script
satisifies one or more conditions).
/---

#FIXME: I don't quite understand why we aren't expanding the corresponding
#testers (e.g., :args.count.==() in :args.count.die_unless_==()) below, but we
#absolutely should. Inlining them is code duplication and hence bad. Glow away!

# ....................{ EXCEPTIONS ~ count                 }....................
# Since argument counts are always nonnegative, defining hypothetical functions
# die_unless_args_at_most() and is_args_at_most() would be unhelpful; functions
# :args.count.die_unless_>=<() and :args.count.">=<"() with the first passed
# argument 0 already implement such functionality.

:alias_command ':void ":args.count.die_unless_=="(:int arg_count)'\
    '::args.count.die_unless_== ${#}' <<'/---'
Throw an exception unless the caller passed the passed number of arguments to
the current runnable.
/---
function ::args.count.die_unless_==() {
    die_unless_args_2 'Expected one argument count.'
    :int.== "${@[1,2]}" :or {
        :str arg_count=${2}
        :die "${arg_count} arguments expected."
    }
}

:alias_command ':void ":args.count.die_unless_>="(:int arg_count)'\
    '::args.count.die_unless_">=" ${#}' <<'/---'
Throw an exception unless the caller passed at least the passed number of
arguments to the current runnable.
/---
function ::args.count.die_unless_'>='() {
    die_unless_args_2 'Expected one argument count.'
    :int.'>=' "${@[1,2]}" :or {
        :str arg_count=${2}
        :die "At least ${arg_count} arguments expected."
    }
}

:alias_command ':void ":args.count.die_unless_>=<"(
    :int min_arg_count :int max_arg_count)'\
    '::args.count.die_unless_">=<" ${#}' <<'/---'
Throw an exception unless the caller passed a number of arguments in the passed
range to the current runnable.

== See Also ==

* :args.count.">=<"().
/---
function ::args.count.die_unless_'>=<'() {
    die_unless_args_3 'Expected one minimum and one maximum count.'
    :int.">=<" "${@[1,3]}" :or {
        :str arg_count_min=${2} arg_count_max=${3}
        :die "Between [${arg_count_min}, ${arg_count_max}] arguments expected."
    }
}

# ....................{ EXCEPTIONS ~ count : parity        }....................
:alias_command 'void :args.count.die_unless_even()'\
    '::args.count.die_unless_even ${#}' <<'/---'
Throw an exception unless the caller passed an even number of arguments to the
current runnable.

== See Also ==

* ::args.count.is_even().
/---
function ::args.count.die_unless_even() {
    die_unless_arg 'Expected no arguments.'
    :is_int_even "${1}" :or {
        :str arg_count=${1}
        :die "Even argument count expected, but ${arg_count} arguments received."
    }
}

# ....................{ EXCEPTIONS ~ index                 }....................
:alias_command ':void :args.index.die_unless(:int arg_index)'\
    '::args.index.die_unless ${#}' <<'/---'
Throw an exception unless the passed integer is a valid index into the list of
arguments passed to the current runnable.

== See Also ==

* :args.index.is().
/---
function ::args.index.die_unless() {
    die_unless_args_2 'Expected one argument index.'
    :str arg_count=${1} arg_index=${2}
    :int.">=<" "${arg_index}" 1 "${arg_count}" :or :die\
        "Argument index ${arg_index} invalid (i.e., not in [1, ${arg_count}])."
}

# ....................{ EXCEPTIONS ~ match                 }....................
:alias_command ':void :arg.die_unless_==(:str text)'\
    '::arg.die_unless_== "${@}"' <<'/---'
Throw an exception unless the caller passed at least one argument equal to the
passed string.

== See Also ==

* :arg.==().
/---
function ::arg.die_unless_==() {
    die_unless_args 'Expected zero or more arguments and one string.'
    :str text=${@[-1]}
    pop_arg

    # Find such argument or throw an exception. See :arg.==() further
    # details and :arg.die_unless_^=() for further discussion.
    (( ${@[(ie)${text}]} <= ${#} )) :or :die "Argument \"${text}\" expected."
}

#FIXME: Replace low-level "noglob" with high-level prototype tag "<globbable>",
#once we enable alias support for that tag.

:alias_command ':void :arg.die_unless_^=(:str glob)'\
    'noglob ::arg.die_unless_^= "${@}"' <<'/---'
Throw an exception with a stock message unless the caller passed at least one
argument matching the passed glob.

== See Also ==

* :arg.^=().
/---
function ::arg.die_unless_^=() {
    die_unless_args 'Expected zero or more arguments and one glob.'
    :str glob=${@[-1]}
    pop_arg

    # Match such glob or throw an exception. Since :arg.^=() is an
    # alias that has yet to be defined, such alias cannot be expanded here.
    # While this could be corrected by defining such alias before this function,
    # such alias is simplistic enough that redefining it here is no burden. See
    # such alias for further details.
    (( ${@[(i)${~glob}]} <= ${#} )) :or
        :die "Argument matching \"${glob}\" expected."
}
