#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *string globbers* (i.e., functions matching strings against extended glob
expressions).
/---

#FIXME: This parcel is excessively inefficient. The core issue are the
#subshells, which should be supplanted for equivalent setters *QUICKLY*. No,
#really. These functions are called *ALL OVER THE PLACE*, including in large-
#scale iteration for defining CLI aliases. Heaps. Heaps! So optimize that.

# ....................{ EXCEPTIONS                         }....................
:func_ '<globbable> :void :die_unless_string_matches_glob(
    :str text,
    :str glob,
    :str error_message =
        "String \"${text}\" unmatched by glob \"${glob}\".")' :func{
    :str text=${1} glob=${2}
    :is_string_matches_glob "${text}" "${glob}" :or :die\
        "${3-String \"$(truncate_string_readable: "${text}")\" unmatched by glob \"${glob}\".}"
#   :stdout.echo $'\n'"glob: ${glob}"
}:func <<'/---'
Throw an exception with the passed message unless the passed string matches the
passed glob. See :is_string_matches_glob() for further details.
/---

:func_ '<globbable> void :die_unless_string_matches_glob_grouped(
    :str text,
    :str glob,
    :str error_message =
        "String \"${text}\" unmatched by glob \"${glob}\".")' :func{
    :str text=${1} glob=${2}
    :is_string_matches_glob_grouped "${text}" "${glob}" :or :die\
        "${3-String \"$(truncate_string_readable: "${text}")\" unmatched by glob \"${glob}\".}"
#   :stdout.echo "glob: ${glob}"
}:func <<'/---'
Throw an exception with the passed message unless the passed string matches the
passed glob. If such string matches such glob, set match globals ${MATCH},
${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and ${mend}. See
:is_string_matches_glob_grouped() for further details.
/---

# ....................{ TESTERS                            }....................
:func_ '
<globbable> [status = :bool] :is_string_matches_glob(
    :str text, :str glob)' :func{
    # Localize arguments.
    :str text="${1}" glob="${2}"
#   :stderr.echo "glob: ${glob}"

    # Set scalar globals on successful matches (e.g., ${MATCH}).
    :glob.enable_capturing_ungrouped glob

    # Perform such test. If such glob is syntactically invalid, zsh emits a
    # nonfatal warning to standard error and reports failure; if such glob is
    # syntactically valid but such test fails, zsh reports failure without
    # printing to standard error. In the former case, this function converts
    # such nonfatal warning to a fatal exception; in the latter case, this
    # function merely reports failure.
    #
    # If such test fails, distinguish the two cases by capturing and testing
    # standard error produced by such test.
    #
    # If such test succeeds, such glob *MUST* be syntactically valid. In such
    # case, report success.
    { :is ${text} == ${~glob} :si } :silent_stderr :or {
        # Repeat such test, capturing standard error if any and ignoring the
        # expected failure. For efficiency, capture such error *ONLY* if such
        # test fails. Subshells are non-negligibly inefficient!
        :str error; error=$(
            { { :is ${text} == ${~glob} :si } =stdout } =failure.ignore)

        # If such error is nonempty, such glob *MUST* be syntactically invalid.
        # Convert such nonfatal error into a fatal exception.
        if :is -n ${error} :si {
            # If such error is prefixed by "zsh: ", remove such prefix.
            remove_string_prefix error 'zsh: '
            :die 'Glob "'${glob}'" invalid:'${ZY_ASCII_NEWLINE}${error}
        # Else, such glob is syntactically valid but such test failed. In such
        # case, report failure.
        } else {
            :failure.report
        }
    }
}:func <<'/---'
Report success if the passed string matches the passed glob. If such glob is
syntactically invalid (e.g., `[^]]`), an exception is thrown. If such string
matches such glob, scalar globals ${MATCH}, ${MBEGIN}, and ${MEND} will be set
to their customary values. For both efficiency and safety, this function does
_not_ set nonscalar globals ${match}, ${mbegin}, or ${mend} unless such glob
contains ${ZY__GLOB_ENABLE_CAPTURING_GROUPED} (i.e., `(#b)`). Alternately, consider
calling :is_string_matches_glob_grouped() to have such globals set: e.g.,

.:is_string_matches_glob()
==========================================
[source]
------------------------------------------
>>> :str on_law=\
...    "If you reason instead of repeating what is taught you; if you analyze
...     the law and strip off those cloudy fictions with which it has been
...     draped in order to conceal its real origin, which is the right of the
...     stronger, and its substance, which has ever been the consecration of
...     all the tyrannies handed down to mankind through its long and bloody
...     history; when you have comprehended this, your contempt for the law will
...     be profound indeed. You will understand that to remain the servant of
...     the written law is to place yourself every day in opposition to the law
...     of conscience, and to make a bargain on the wrong side; and, since this
...     struggle cannot go on forever, you will either silence your conscience
...     and become a scoundrel, or you will break with tradition, and you will
...     work with us for the utter destruction of all this injustice, economic,
...     social and political."
>>> :is_string_matches_glob "${on_law}" ut(#c2,)?r*d?str?ct??n and\
...    :stdout.echo\
...    "Men lived thousands of years before the first States were constituted."
Men lived thousands of years before the first States were constituted.
------------------------------------------
==========================================

== Motivation ==

Enabling *ungrouped capturing* (i.e., setting ${MATCH}, ${MBEGIN}, and ${MEND}
on successful matches) costs little while yielding measurable benefit. To
quote `zsh` documentation:

[quote, `man zshexpn`]
____________________________________________________________________
Unlike backreferences _(i.e., captured groups)_, there is no speed penalty for
using match references _(i.e., captured ungrouped substrings)_.
____________________________________________________________________

Since ungrouped capturing should arguably be enabled by default (and is for the
comparable PCRE-based match operator `=~`), this and all similar string
globbers implicitly enable such capturing.
/---

:func_ '[status=:bool] :is_string_matches_glob_grouped(
    :str text :str/:glob glob)' :func{
    # Set nonscalar globals on successful matches (e.g., ${match}).
    :glob.enable_capturing_grouped glob

    # Test such string.
    :is_string_matches_glob "${text}" "${glob}"
}:func <<'/---'
Report success if the passed string matches the passed glob.

If this glob is syntactically invalid (e.g., `[^]]`), an exception is thrown. If
this string matches this glob, the ${MATCH}, ${MBEGIN}, ${MEND}, ${match},
${mbegin}, and ${mend} globals will be set to their customary values.

If capturing only one match group, consider calling
get_string_match_group_first() or get_string_match_group_first_if_found()
instead.

== See Also ==

* :glob.enable_capturing_grouped().

== Examples ==

==========================================
[source]
------------------------------------------
>>> :str match_group glob='crazy, ([[:alpha:]]##)' on_awareness=\
...    "The first characteristic is a slowing down of time, a concentration in
...     the present. One's normally compulsive concern for the future decreases,
...     and one becomes aware of the enormous importance and interest of what is
...     happening at the moment. Other people, going about their business on the
...     streets, seem to be slightly crazy, failing to realize that the whole
...     point of life is to be fully aware of it as it happens. One therefore
...     relaxes, almost luxuriously, into studying the colors in a glass of
...     water, or in listening to the now highly articulate vibration of every
...     note played on an oboe or sung by a voice."
>>> :is_string_matches_glob_grouped "${on_awareness}" "${glob}"
>>> :stdout.echo "${match[1]}"
failing
>>> :str.^=.Group_if_found "${on_awareness}" "${glob}" match_group 1
>>> :stdout.echo "${match_group}"
failing
------------------------------------------
==========================================
/---

#FIXME: In lieu of unit tests...
#function unia() {
#    string text="$(get_locale_pcre_yes)" glob="*\\[([^\\]]#)\\]*" stderr
#    eval 'is "${text}" == ${~glob} si' and print 'ok' or print 'ko'
#    match=()
#    :is_string_matches_glob_grouped 'End the entrails.' 'Swift the river' and
#        print 'ok' or print 'ko'
#    :is_string_matches_glob_grouped "$(get_locale_pcre_yes)" '*\[([^\]]#)\]*' and
#        print "group: ${match[1]}" or print 'ko'
#}

# ....................{ GETTERS                            }....................
#FIXME: Refactor into a setter :set_int_to_string_text_matching_glob_count().
:func_ '<globbable> :int get_string_text_matching_glob_count(
    :str text, :str glob)' :func{
    :int match_count=0
    for_string_matches_glob "${@}" 'match_count+=1'
    :stdout.echo ${match_count}

#FIXME: Ridiculously awesome example, but overlong. Split in twain.
}:func <<'/---'
Get the number of substrings in the passed string matching the passed glob.

== Examples ==

==========================================
[source]
------------------------------------------
>>> :str on_sufficiency=\
...    "No man can serve two masters: for either he will hate the one, and love
...     the other; or else he will hold to the one, and despise the other. Ye
...     cannot serve God and Mammon.
...     Therefore I say unto you, Take no thought for your life, what ye shall
...     eat, or what ye shall drink; nor yet for your body, what ye shall put
...     on. Is not the life more than meat, and the body than raiment?
...     Behold the fowls of the air: for they sow not, neither do they reap, nor
...     gather into barns; yet your heavenly Father feedeth them. Are ye not
...     much better than they?
...     Which of you by taking thought can add one cubit unto his stature?
...     And why take ye thought for raiment? Consider the lilies of the field,
...     how they grow; they toil not, neither do they spin:
...     and yet I say unto you, That even Solomon in all his glory
...     was not arrayed like one of these.
...     Wherefore, if God so clothe the grass of the field, which today is, and
...     tomorrow is cast into the oven, shall he not much more clothe you, O ye
...     of little faith?
...     Therefore take no thought, saying, What shall we eat? or, What shall we
...     drink? or, Wherewithal shall we be clothed?
...     Take therefore no thought for the morrow: for the morrow shall take
...     thought for the things of itself. Sufficient unto the day is the evil
...     thereof."
>>> get_string_text_matching_glob_count\
...    "${on_sufficiency}" ('field'|'raiament')
4
------------------------------------------
==========================================
/---

# ....................{ GETTERS ~ group                    }....................
:func_ '[status=:bool] :str.^=.Group(
    :str text :str/:glob glob :Str group_name :int group_index=1) <
    is_args_unhandled>' :func{
    :str.^=.Group_if_found "${@}" :or
        :die_unless_string_matches_glob "${@[1,2]}"
}:func <<'/---'
Set the string variable with the passed name to the match group with the passed
1-based index (defaulting to the first group) captured by matching the passed
text with the passed glob _or_ throw an exception otherwise (i.e., if this match
fails or no such group exists).

== Examples ==

==========================================
[source]
------------------------------------------
>>> :str match_group on_fellowship=\
...    "I came to the conclusion long ago, after prayerful search and study and
...     discussion with as many people as I could meet, that all religions were
...     true and also that all had some error in them, and that whilst I hold by
...     my own, I should hold others as dear as Hinduism, from which it
...     logically follows that we should hold all as dear as our nearest kith
...     and kin and that we should make no distinction between them. So we can
...     only pray, if we are Hindus, not that a Christian should become a Hindu,
...     or if we are Mussalmans, not that a Hindu or a Christian should become a
...     Mussalman, nor should we even secretely pray that anyone should be
...     converted, but our inmost prayer should be that a Hindu should be a
...     better Hindu, a Muslim a better Muslim, a Christian a better Christian.
...     That is the fundamental truth of fellowship."
>>> :str.^=.Group_if_found "${on_fellowship}" *('Mus'[^ ]##)* match_group 1
>>> :stdout.echo "${match_group}"
Mussalmans
------------------------------------------
==========================================
/---

:func_ '[status=:bool] :str.^=.Group_if_found(
    :str text :str/:glob glob :Str group_name :int group_index=1) <
    var_name_suffix="__sgGif">' :func{
    if { :is_string_matches_glob_grouped "${text__sgGif}" "${glob__sgGif}" } {
        :Str.set "${group_name__sgGif}" "${match[${group_index__sgGif}]}"
    } else {
        :failure.report
    }
}:func <<'/---'
Set the string variable with the passed name to the match group with the passed
1-based index (defaulting to the first group) captured by matching the passed
text with the passed glob _or_ report failure otherwise (i.e., if this match
fails or no such group exists).

== Examples ==

==========================================
[source]
------------------------------------------
>>> :str match_group on_warranties=\
...    "[Along with the standard computer warranty agreement which said that if
...     the machine 1) didn't work, 2) didn't do what the expensive
...     advertisements said, 3) electrocuted the immediate neighborhood, 4) and
...     in fact failed entirely to be inside the expensive box when you opened
...     it, this was expressly, absolutely, implicitly and in no event the fault
...     or responsibility of the manufacturer, that the purchaser should
...     consider himself lucky to be allowed to give his money to the
...     manufacturer, and that any attempt to treat what had just been paid for
...     as the purchaser's own property would result in the attentions of
...     serious men with menacing briefcases and very thin watches. Crowley had
...     been extremely impressed with the warranties offered by the computer
...     industry, and had in fact sent a bundle Below to the department that
...     drew up the Immortal Soul agreements, with a yellow memo form attached
...     just saying: \"Learn, guys . . .\"]"
>>> :str.^=.Group_if_found\
...     "${on_warranties}" *([[:digit:]]') ')([[:graph:]]##)* match_group 2
>>> :stdout.echo "${match_group}"
didn't
------------------------------------------
==========================================
/---
