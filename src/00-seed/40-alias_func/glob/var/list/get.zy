#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
*Globbable list getters* (i.e., functions getting list items and indices by
matching such items against glob expressions).
/---

#FIXME: Refactor all getters to setters.

# ....................{ GETTERS                            }....................
:func_ ':str :List.item.^=.First(
    :List list_name :str/:glob glob :Str list_item_name) [
    var_name_suffix="__LigF"]' :func{
    :List.item.^=.First.if_found "${@}" :or
        :die "List \${${list_name____LigF}} item matching \"\${glob__LigF}\" not found."

#FIXME: Overlong example; split us up, please! Thunder ravens ride the wind!
}:func <<'/---'
Set the string variable with the passed name to the first item matching the
passed glob in the list with the passed name _or_ throw an exception otherwise
(i.e., if this list contains no such item).

== Examples ==

==========================================
[source]
------------------------------------------
>>> :str list_item
>>> :list on_sectarianism; on_sectarianism=(
...    "Nevertheless this business of legislating religious beliefs into law"
...    "has never been more than sporadically successful in this country –"
...    "Sunday closing laws here and there, birth control legislation in spots,"
...    "the Prohibition experiment, temporary enclaves of theocracy such as"
...    "Voliva's Zion, Smith's Nauvoo, a few others. The country is split up"
...    "into such a variety of faiths and sects that a degree of uneasy"
...    "tolerance now exists from expedient compromise; the minorities"
...    "constitute a majority of opposition against each other. Could it be"
...    "otherwise here? Could any one sect obtain a working majority at the"
...    "polls and take over the country? Perhaps not – but a combination of a"
...    "dynamic evangelist, television, enough money, and modern techniques of"
...    "advertising and propaganda might make Billy Sunday's efforts look like"
...    "a corner store compared to Sears Roebuck. Throw in a depression for"
...    "good measure, promise a material heaven here on earth, add a dash of"
...    "anti-Semitism, anti-Catholicism, anti-Negroism, and a good large dose"
...    "of anti-\"furriners\" in general and anti-intellectuals here at home"
...    "and the result might be something quite frightening – particularly when"
...    "one recalls that our voting system is such that a minority distributed"
...    "as pluralities in enough states can constitute a working majority in"
...    "Washington... The capacity of the human mind for swallowing nonsense"
...    "and spewing it forth in violent and repressive action has never yet"
...    "been plumbed." )
>>> :List.item.^=.First on_sectarianism *'anti-'[[:WORD:]]* list_item
>>> :stdout.echo "${list_item}"
anti-Semitism, anti-Catholicism, anti-Negroism, and a good large dose
------------------------------------------
==========================================
/---

:func_ '[status=:bool] :List.item.^=.First.if_found(
    :List list_name :str/:glob glob :Str list_item_name) [
    var_name_suffix="__LigFif"]' :func{
    # This implementation intentionally avoids use of array subscript flag
    # "(r)", which expands to the first list item matching the passed glob.
    # Unfortunately, this flag ambiguously expands to the empty string on
    # unsuccessful matches and hence is indistinguishable from successful
    # matches of the empty string (e.g., "*"). For safety, this flag must *NOT*
    # be used in general-purpose list matching.
    :int list_item_index__LigFif
    list_item_index__LigFif=$(get_list_index_first_matching_glob_if_found "${@}") :and
        :Str.set\
            "${list_item_name__LigFif}"\
            "${${(@P)list_name__LigFif}[${list_item_index__LigFif}]}"
}:func <<'/---'
Set the string variable with the passed name to the first item matching the
passed glob in the list with the passed name _or_ report failure otherwise
(i.e., if this list contains no such item).

== Examples ==

==========================================
[source]
------------------------------------------
>>> :str list_item
>>> :list on_testimony; :on_testimony=(
...    "In the Twentieth Century of my trespass on earth,"
...    "having exterminated one billion heathens,"
...    "heretics, Jews, Moslems, witches, mystical seekers,"
...    "black men, Asians, and Christian brothers,"
...    "every one of them for his own good,"
...    ""
...    "a whole continent of red men for living in unnatural community"
...    "and at the same time having relations with the land,"
...    "one billion species of animals for being sub-human,"
...    "and ready to take on the bloodthirsty creatures from the other planets,"
...    "I, Christian man, groan out this testament of my last will." )
>>> :List.item.^=.First.if_found on_testimony ?p?c?l?ps? list_item :or
...     :stdout.echo "We shall not all sleep, but we shall be changed . . ."
We shall not all sleep, but we shall be changed . . .
------------------------------------------
==========================================
/---

# ....................{ GETTERS ~ index                    }....................
#FIXME: Indominitable examples, but a tad overlang. Shift half of each elsewhere
#-- ideally into the corresponding setters.

:func_ ':int get_list_index_first_matching_glob(
    :List list_name :str/:glob glob) [
    var_name_suffix="__Lfig"]' :func{
    # Get such index if found or throw an exception.
    :str index__LFig
    :List.First_index.^= "${list_name__LFig}" index__LFig "${glob__LFig}"
    :stdout.echo "${index__LFig}"
}:func <<'/---'
Get the 1-based index of the first item in the passed list matching the passed
glob expression or throw an exception if no such item matches: e.g.,

.get_list_index_first_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_tumescence; :on_tumescence=(
...     "I give my blood fifty parts polystyrene,"
...     "twenty-five parts benzene, twenty-five parts good old gasoline,"
...     "to the last bomber pilot aloft, that there shall be one acre"
...     "in the dull world where the kissing flower may bloom,"
...     "which kisses you so long your bones explode under its lips."
...     ""
...     "My tongue goes to the Secretary of the Dead"
...     'to tell the corpses, "I'm sorry, fellows,'
...     "the killing was just one of those things"
...     "difficult to pre-visualize — like a cow,"
...     'say, getting blown up by lightning."'
...     ""
...     "My stomach, which has digested"
...     "four hundred treaties giving the Indians"
...     "eternal right to their land, I give to the Indians,"
...     "I throw in my lungs full of tumors, from faithfully"
...     "smoking the peace pipe before every massacre."
...     ""
...     "My soul I leave to the bee"
...     "that he may sting it and :die, my brain"
...     "to the fly, his back the hysterical green color of slime,"
...     "that he may suck on it and :die, my flesh to the advertising man,"
...     "the anti-prostitute, who loathes human flesh for money." )
>>> get_list_index_first_matching_glob on_tumescence *'to the'[[:blank:]]*
3
------------------------------------------
==========================================
/---

:func_ '[stdout=:int status=:bool] get_list_index_first_matching_glob_if_found(
    :List list_name :str/:glob glob) [
    var_name_suffix="__Lfigif"]' :func{
    # Get such index if found or report failure.
    :str index__Lfigif
    :List.First_index.^=_if_found\
        "${list_name__LFigif}" index__LFig "${glob__LFigif}" :and
        :stdout.echo "${index__Lfigif}"
}:func <<'/---'
Get the 1-based index of the first item in the passed list matching the passed
glob expression or report failure if no such item matches: e.g.,

.get_list_index_first_matching_glob_if_found()
==========================================
[source]
------------------------------------------
>>> :list on_madness; :on_madness=(
...     "I assign my crooked backbone"
...     "to the dice maker, to chop up into dice,"
...     "for casting lots as to who shall see his own blood"
...     "on his shirt front and who his brother's,"
...     "for the race isn't to the swift but to the crooked."
...     ""
...     "To the last man surviving on earth"
...     "I give my eyelids worn out by fear, to wear"
...     "in his long nights of radiation and silence,"
...     "so that his eyes can't close, for regret"
...     "is like tears seeping through closed eyelids."
...     "
...     "I give the emptiness my hand: the pinkie picks no more noses,"
...     "slag clings to the black stick of the ring finger,"
...     "a bit of flame jets from the tip of the fuck-you finger,"
...     "the first finger accuses the heart, which has vanished,"
...     "on the thumb stump wisps of smoke ask a ride into the emptiness."
...     ""
...     "In the Twentieth Century of my nightmare"
...     "on earth, I swear on my chromium testicles"
...     "to this testament"
...     "and last will"
...     "of my iron will, my fear of love, my itch for money, and my madness." )
>>> get_list_index_first_matching_glob_if_found on_madness *'on_sanity'* or
...     :stdout.echo "Lieutanant! This corpse will not stop burning!"
Lieutanant! This corpse will not stop burning!
------------------------------------------
==========================================
/---

#FIXME: Add examples.
:func_ '<globbable> [stdout = :int, status = :bool]
    get_list_index_first_matching_glob_after_index_if_found(
        :str:list? list_name, :str glob, :int? start_index)' :func{
    # Validate sanity.
    :str\
        list_name__glmifafif="${1}"\
        glob__glmifafif="${2}"\
        index_start__glmifafif="${3}"\
        list_size__glmifafif
    :int index__glmifafif
    :list list_copy__glmifafify
    die_unless_list_index "${list_name__glmifafif}" "${index_start__glmifafif}"

    # Begin searching at the next such index. Since zsh supplies no builtin
    # means of finding from some index (subscript flag "(i)" always matches from
    # index 1), consider the following clever alternative:
    #
    # * Copy the *ENTIRE* subset of such list after such index into a new list.
    # * Search such list with subscript flag "(i)".
    # * Offset the matching index if found by the passed index.
    #
    # In the worst case, this copy duplicates such list. While unfortunate, this
    # is considerably faster (if memory intensive) than manual iteration.
    list_copy__glmifafif=(
        "${${(@P)list_name__glmifafif}[$(( index_start__glmifafif + 1 )),]}" )

    # Get such index if found or report failure.
    index__glmifafif=$(get_list_index_first_matching_glob_if_found\
        list_copy__glmifafif "${glob__glmifafif}") :and
        :stdout.echo $(( index__glmifafif + index_start__glmifafif ))
}:func <<'/---'
Get the 1-based index of the first item in the passed list matching the
passed glob _after_ the passed index or report failure if no such item matches.
/---
