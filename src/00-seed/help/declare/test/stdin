#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Document all globals, functions, and aliases declared by ={*-test/stdin}.
/---

# ....................{ EXCEPTIONS                         }....................
:func.doc <<'/---'
:void :stdin.die_unless_nonempty()

Throw an exception unless standard input to the current context is non-empty.
See :stdin.is_nonempty().
/---

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status = :bool] :stdin.is_nonempty()

Report success if standard input to the current context is *non-empty* (i.e.,
provides at least one readable byte) and hence readable without blocking (i.e.,
without silently, indefinitely waiting for such input to become available).
Since reading from standard input via conventional techniques (e.g., `<
/dev/stdin`, `zsh` builtin read(), `zeshy` alias :stdin()) typically blocks
or behaves erratically if no such input has been written, consider polling this
function before attempting to read from standard input.

== Caveats ==

*This function is inherently unreliable without iterative polling.* Only call
this function as the test of an indefinite wait or for loop: e.g.,

.:stdin.is_nonempty() Called Properly
==========================================
[source]
------------------------------------------
>>> :str on_perfect_security=\
...     "There is a contradiction in wanting to be perfectly secure in a
...      universe whose very nature is momentariness and fluidity."
>>> :stdout.echo "${on_perfect_security}" | {
...     :stdout.echo "Waiting for input."
...     while { not :stdin.is_nonempty } {
...         :stdout.echo_sans_newline "."
...     }
...     :stdout.echo "Received input: $(:stdin)"
... }
Waiting for input.....
Received input: There is a contradiction in wanting to be perfectly secure in a
universe whose very nature is momentariness and fluidity.
------------------------------------------
==========================================

*Never call this function as a non-iterative test* (e.g., modifying the line
reading `while { not :stdin.is_nonempty } {` in the prior example
to `if { not :stdin.is_nonempty } {`). Preparing to write and then
writing to standard input requires a non-deterministic and hence non-computable
amount of wall clock time regardless of the underlying mechanism used to do so
(e.g., pipe, process substitution, here-string, here-document). Indeed,
establishing pipes requires forking one asynchronous subshell for each pipe
subcommand excluding the last -- an extremely computationally expensive task.
Given such expense, there exists no guarantee that the source of standard input
will have provided such input by the time of a non-iterative call to this
function. Moreover, given such non-determinism, whether such call succeeds or
not depends principally on current system load! To demonstrate this, consider
the following output from calling this function non-iteratively:

.:stdin.is_nonempty() Called Improperly
==========================================
[source]
------------------------------------------
>>> :int count
>>> for  count ({0..7}) {
...     :stdout.echo_newline | {
...         :stdin.is_nonempty and
...             :stdout.echo "Input available." or
...             :stdout.echo "No input available."
...     }
... }
No input available.
Input available.
No input available.
No input available.
Input available.
No input available.
Input available.
------------------------------------------
==========================================

In cases where iterative polling is inappropriate, consider calling
:is_stdin_pipe_or_file_simple() instead. Such function typically only reports
success when standard input is readable without blocking, and does so without
requiring iterative polling.
/---

# --------------------( WASTELANDS                         )--------------------
