#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle `zeshy` startup in a manner analogous to `zsh` startup (e.g., `.zshenv`).
/---

# ....................{ GLOBALS                            }....................
:list_global ZESHY_HOOKS_RUN_ON_STARTUP <<'/---'
List of code to be run unconditionally on `zeshy` startup. See
run_hook_on_zeshy_startup() for further details.
/---

:list_global ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE <<'/---'
List of code to be run on `zeshy` startup under interactive shells. See
run_hook_on_zeshy_startup_if_interactive() for further details.
/---

:list_global ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN <<'/---'
List of code to be run on `zeshy` startup under login shells. See
run_hook_on_zeshy_startup_if_login() for further details.
/---

# ....................{ SETTERS                            }....................
:func.document <<'/---'
void ::munge_hook_zeshy_startup(string string_name)

Modify the passed string variable containing hook code with user-friendly
concessions to both debuggability and usability.
/---
function ::munge_hook_zeshy_startup() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :string string_name__mhzs="${1}" munged_hook

    # If debugging, prepend verbose debug logic to such code.
    #
    # Avoid calling print_message() or other high-level functions transitively
    # referencing aliases and globals undefined until *AFTER* zeshy starts up.
    #
    # While we would ideally call :line.run_if_debug() here, such function
    # assumes only a single line of output. This function accepts an arbitrary
    # string and hence cannot guarantee such assumption. In practice, since the
    # amount of startup code is fairly constrained *AND* since this function is
    # only called during digest compilation, such inefficiency is acceptable.
    if { :debug.is } {
        # This is considerably simpler to implement by assigning the result to a
        # temporary string. See :string.set() for further details.
        munged_hook=':string.output_if_debug "Calling '${(P)string_name__mhzs}'()..."'$'\n'${(P)string_name__mhzs}
        : ${(P)string_name__mhzs::=${munged_hook}}
        # print "${string_name__mhzs}:catch${(P)string_name__mhzs}"
    }
}

# ....................{ RUNNERS                            }....................
:func.document <<'/---'
void run_hook_on_zeshy_startup(string code)

Run the passed code immediately after `zeshy` startup autoloads the user digest
and hence on _every_ such startup.
/---
function run_hook_on_zeshy_startup() {
    # Validate sanity.
    die_unless_arg 'Expected one code string.'
    :string code="${1}"
    ::munge_hook_zeshy_startup code

    # Register such hook.
    ZESHY_HOOKS_RUN_ON_STARTUP+="${code}"
}

:func.document <<'/---'
void run_hook_on_zeshy_startup_if_interactive(string code)

Run the passed code immediately after `zeshy` startup autoloads the user digest
file under interactive shells. See is_shell_interactive() for further details.
/---
function run_hook_on_zeshy_startup_if_interactive() {
    # See above for further details.
    die_unless_arg 'Expected one code string.'
    :string code="${1}"
    ::munge_hook_zeshy_startup code
    ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE+="${code}"
}

:func.document <<'/---'
void run_hook_on_zeshy_startup_if_login(string code)

Run the passed code immediately after `zeshy` startup autoloads the user digest
file under login shells. See is_shell_login() for further details.
/---
function run_hook_on_zeshy_startup_if_login() {
    # See above for further details.
    die_unless_arg 'Expected one code string.'
    :string code="${1}"
    ::munge_hook_zeshy_startup code
    ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN+="${code}"
}

# ....................{ RUNNERS ~ first                    }....................
:func.document <<'/---'
void run_hook_on_zeshy_startup_first(string code)

Run the passed code immediately after `zeshy` startup autoloads the user digest
file _before_ running all other startup logic. Specifically, prepend the passed
code to the beginning of the definition of startup_zeshy().
/---
function run_hook_on_zeshy_startup_first() {
    # Avoid calling prepend_list(), which has yet to be defined.
    die_unless_arg 'Expected one code string.'
    :string code="${1}"
    ::munge_hook_zeshy_startup code
    ZESHY_HOOKS_RUN_ON_STARTUP=( "${code}" "${ZESHY_HOOKS_RUN_ON_STARTUP[@]}" )
}

# --------------------( WASTELANDS                         )--------------------
#       munged_hook='print -r -- "Calling '${(P)string_name__mhzs}'()..."'$'\n'${(P)string_name__mhzs}
        # eval ${string_name__mhzs}'=''print -r -- \"Calling '${(P)string_name__mhzs}'()...\"$'\n'${(P)string_name__mhzs}"'
        # eval ${string_name__mhzs}'=''print -r -- \"Calling '${(P)string_name__mhzs}'()...\"$'\n'${(P)string_name__mhzs}"'
#       : ${(P)string_name__mhzs::=print -r -- "Calling ${(P)string_name__mhzs}()..."$'\n'${(P)string_name__mhzs}}

        # eval ${string_name__mhzs}'=''print -r -- \"Calling '${(P)string_name__mhzs}'()...\"$'\n'${(P)string_name__mhzs}"'
        # print "${string_name__mhzs}:catch${(P)string_name__mhzs}"
#       : ${(P)string_name__mhzs::=print -r -- "Calling ${(P)string_name__mhzs}()..."$'\n'${(P)string_name__mhzs}}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with functions below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If printing verbose debug messages, do so. Avoid calling print_message()
    # or similar high-level printer functions, as such functions transitively
    # reference aliases and globals which have yet to be defined until *AFTER*
    # zeshy fully starts up.
    # :line.run_if_debug code=":string.output_if_debug 'Calling ${code}()...'$'\n'${code}"

    # :line.run_if_debug :string.set "${string_name__ssthzs}" ":string.output_if_debug 'Calling ${(P)string_name__ssthzs}()...'$'\n'${(P)string_name__ssthzs}"

# ....................{ PRECOMPILERS                       }....................
#:func.document <<'/---'
#void precompile_zeshy_functions_startup()
#
#Dynamically synthesize the following hook-based functions:
#
#* startup_zeshy(), running all hooks in global list
#  ${ZESHY_HOOKS_RUN_ON_STARTUP}.
#* startup_zeshy_if_shell_interactive(), running all hooks in global list
#  ${ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE}.
#* startup_zeshy_if_shell_login(), running all hooks in global list
#  ${ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN}.
#
#`zeshy` only calls this function after sourcing all `zeshy` scripts applicable
#to the current user when (re)compiling `zeshy`\'s digest file for such user.
#/---
#function precompile_zeshy_functions_startup() {
#    # Validate sanity.
#    die_if_args
#
#    # Make such functions, joining such list elements on newline.
#    eval "function startup_zeshy() {
#    $(:output_strings_newlined "${ZESHY_HOOKS_RUN_ON_STARTUP[@]}")
#    is_shell_interactive and startup_zeshy_if_shell_interactive
#    is_shell_login       and startup_zeshy_if_shell_login
#}"
#    eval "function startup_zeshy_if_shell_interactive() {
#    $(:output_strings_newlined "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE[@]}")
#}"
#    eval "function startup_zeshy_if_shell_login() {
#    $(:output_strings_newlined "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN[@]}")
#}"
#}

# See
    # join_list_on_newline() for further details.
# function. Consider calling run_hook_on_zeshy_startup()
#instead, unless convinced you know what you''re doing.
#Append the passed code to the end of the definition of the startup_zeshy()
#function. Zeshy calls such function and hence command on each execution, as
#with ".zshenv" under zsh.
#Append the passed code to the end of the definition of the
#startup_zeshy_if_shell_interactive() function. Zeshy calls such function and
#hence command on each execution under an interactive shell, as with ".zshrc"
#under zsh.
#Append the passed code to the end of the definition of the
#startup_zeshy_if_shell_login() function. Zeshy calls such function and hence
#command on each execution under a login shell, as with ".zprofile" under zsh.
    #FUXME: Hmm; why not just define prepend_list() before this?
#declare_function '
#void run_hook_on_zeshy_startup_first_if_shell_interactive(string command)
#
#Prepend the passed code to the beginning of the definition of the
#startup_zeshy_if_shell_interactive() function. Consider calling
#run_hook_on_zeshy_startup_if_interactive() instead, unless convinced
#you know what you''re doing.
#'
#function run_hook_on_zeshy_startup_first_if_shell_interactive() {
#    # Avoid calling prepend_list(), which has yet to be defined.
#    die_unless_arg 'expected one command'
#    ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE=(
#        "${1}" "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE[@]}" )
#}
#
#declare_function '
#void run_hook_on_zeshy_startup_first_if_shell_login(string command)
#
#Prepend the passed code to the beginning of the definition of the
#startup_zeshy_if_shell_login() function. Consider calling
#run_hook_on_zeshy_startup_if_login() instead, unless convinced
#you know what you''re doing.
#'
#function run_hook_on_zeshy_startup_first_if_shell_login() {
#    # Avoid calling prepend_list(), which has yet to be defined.
#    die_unless_arg 'expected one command'
#    ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN=(
#        "${1}" "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN[@]}" )
#}

#FUXME: Rename to append_zeshy_startup_command(). Much more natural (...the
#most important "precompile_zeshy" part comes first) and in keeping with nomenclature
#elsewhere.
#listset_global_export ZESHY_HOOKS_RUN_ON_STARTUP
#listset_global_export ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE
#listset_global_export ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN

# void precompile_zeshy_functions_to_startup_zeshy()
#function precompile_zeshy_functions_to_startup_zeshy() {

#FUXME: Rename to ZESHY_COMMANDS_RUN_ON_STARTUP.
#ZESHY_COMMANDS_RUN_AFTER_STARTUP
#ZESHY_COMMANDS_RUN_AFTER_COMPILING
#ZESHY_RUN_COMMANDS_AFTER_STARTUP
#ZESHY_RUN_COMMANDS_AFTER_COMPILING
#ZESHY_RUN_ON_STARTUP
#ZESHY_RUN_ON_COMPILING
#ZESHY_COMMANDS_RUN_ON_STARTUP
#ZESHY_COMMANDS_RUN_ON_COMPILING

#   listset_global_export ZESHY_HOOKS_RUN_ON_STARTUP
#   listset_global_export ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE
    # Convert global lists of commands to be run on startup into newline-
    # delimited strings to be interpolated into the functions created below.
#   string startup_zeshy_commands startup_zeshy_commands_if_shell_interactive
#   startup_zeshy_commands="$(join_list_on_newline\
#       ZESHY_HOOKS_RUN_ON_STARTUP)"
#   startup_zeshy_commands_if_shell_interactive="$(join_list_on_newline\
#       ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE)"

#   prepend_list ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE "${1}"
#   ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE=(
#       "${1}" "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE[@]}"
#   )
#FUXME: Call from "src/compile". Yes... excellent. Obviously, this needs to
#happen *AFTER* sourcing all scripts but prior to creating the digest.
# void add_command_to_zeshy_shutdown(string command)
#
# Run the passed code on Zeshy shutdown in the current shell, triggered on
# receiving any of the following signals: ABRT, ALRM, HUP, INT, QUIT, or TERM.
#function add_command_to_zeshy_shutdown() {
#    :die 'implement me'
#}

#function run_code_on_zeshy_startup() {
#function startup_zeshy_by_running() {
# void make_functions_for_zeshy_startup()
# void precompile_zeshy_startup()
