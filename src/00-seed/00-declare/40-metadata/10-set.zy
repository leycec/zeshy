#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under ={help} in the main codebase.

# ....................{ SETTERS ~ func                     }....................
# Define this function *BEFORE*:
#
# * Documenting this function, as :func.document() transitively calls this
#   function. Yes, this is fragile. No, there exists no simpler means.
# * Defining and documenting all subsequent functions -- for the same reason.

function ::operable,type.set_setter_of_metadata_type() {
    (( # == 4 )) || :die\
        'Expected one operable name, one operable type, one string name, and one metadata type.'
    local\
        operable_name=${1}\
        operable_type=${2}\
        setter_name=${3}\
        metadata_type=${4}
    (( ${#operable_name} )) || :die 'Operable name empty.'
    (( ${#operable_type} )) || :die 'Operable type empty.'
    (( ${#setter_name} )) || :die 'Setter name empty.'
    (( ${#metadata_type} )) || :die 'Metadata type empty.'
    :string.set "${3}" "::${2}.set_${4}:${1}"
}
:func.document <<'/---'
:void ::operable,type.set_setter_of_metadata_type(
    :string operable_name
    :string operable_type
    ^:string setter_name
    :string metadata_type)

Set the passed string variable to the name of the function setting a passed
string variable to the metadata of the passed type of the passed operable of
the passed type (e.g., `::func.set_prototype:string.set()` for the prototype
for function :string.set()).

Try saying that several times fast. Double-dog dare you!

== Motivation ==

This function serves as an ad-hoc means of persisting static *RTTI* (run-time
type information) on arbitrary *operables* (i.e., aliases, functions, globals).
By dynamically associating such operables with typed metadata in the guise of
global string constants, this function is at the core of several other `zeshy`
subsystems requiring run-time metadata -- in particular, the help subsystem.

== Types ==

If such metadata type is:

* `prototype`, such function sets such variable to such operable's prototype.
* `asciidoc`, such function sets such variable to such operable's AsciiDoc.

If such operable type is:

* `alias_command`, such function sets such variable to such simple alias'
  metadata.
* `alias_general`, such function sets such variable to such global alias'
  metadata.
* `alias_suffix`, such function sets such variable to such suffix alias'
  metadata.
* `func`, such function sets such variable to such function's metadata.
* `global`, such function sets such variable to such global's metadata.
/---

# ....................{ SETTERS ~ func                     }....................
:func.document <<'/---'
:void :func.set_asciidoc(:string/func func_name, ^:string asciidoc_name)

Set the passed string variable to all previously declared AsciiDoc-formatted
documentation for the passed function.
/---
function :func.set_asciidoc() {
    (( # == 2 )) || :die 'Expected one function name and one string name.'
    ::operable,type.set_metadata_of_type "${1}" 'func' "${2}" 'asciidoc'
}

:func.document <<'/---'
:void :func.set_prototype(:string/func func_name, ^:string prototype_name)

Set the passed string variable to the previously declared prototype for the
passed function.
/---
function :func.set_prototype() {
    (( # == 2 )) || :die 'Expected one function name and one string name.'
    ::operable,type.set_metadata_of_type "${1}" 'func' "${2}" 'prototype'
}

# ....................{ SETTERS ~ operable                 }....................
:func.document <<'/---'
:void ::operable,type.set_metadata_of_type(
    :string operable_name,
    :string operable_type,
    ^:string metadata_name,
    :string metadata_type)

Annotate the passed operable of the passed type with the passed metadata of the
passed type, subsequently retrievable by calling
::operable,type.set_setter_of_metadata_type(). See such function.
/---
function ::operable,type.set_metadata_of_type() {
    # Validate sanity.
    (( # == 4 )) || :die\
        'Expected one operable name, one operable type, one string name, and one metadata type.'
    local\
        operable_name__ootsmot="${1}"\
        operable_type__ootsmot="${2}"\
        metadata_name__ootsmot="${3}"\
        metadata_type__ootsmot="${4}"\
        metadata_setter__ootsmot

    # Name of such setter function.
    ::operable,type.set_setter_of_metadata_type\
        "${operable_name__ootsmot}"\
        "${operable_type__ootsmot}"\
        metadata_setter__ootsmot\
        "${metadata_type__ootsmot}"

    # Set such string.
    :func.die_unless "${metadata_setter__ootsmot}"
    "${metadata_setter__ootsmot}" "${metadata_name__ootsmot}"
}

# --------------------( WASTELANDS                         )--------------------
# :func.document <<'/---'
# :void :func.set_prototype_indented(
#     :string/func func_name, ^:string prototype_name)
# 
# Set the passed string variable to the previously declared prototype for the
# passed function, each line indented for readability.
# /---
# function :func.set_prototype_indented() {
#     # Validate sanity.
#     (( # == 2 )) || :die 'Expected one function name and one string name.'
#     local prototype_name=${2}
# 
#     # Set such prototype.
#     :func.set_prototype "${@}"
# 
#     # Indent such prototype.
#     :string.set ${prototype_name} '    '${(P)prototype_name//$'\n'/$'\n'    }
# }

# ....................{ OBSOLETE                           }....................
#FUXME: Excise all functionality below.
#FUXME: Document me.

# ....................{ SETTERS ~ func                     }....................
#FUXME: Document me.

# :void :func.set_prototype(
#     :string/func func_name, ^:string string_name)
# function :func.set_prototype() {
#     (( # == 2 )) || :die 'Expected one function name and one string name.'
#     ::operable.set_prototype_of_type "${@}" 'func'
# }

# ....................{ SETTERS ~ operable                 }....................
#FUXME: Implement ::set_string_to_operable_type_asciidoc() along similar lines.
#FUXME: Document me.

# # :void ::operable.set_prototype_of_type(
# #     :string/func operable_name,
# #     ^:string string_name,
# #     :string operable_type)
# function ::operable.set_prototype_of_type() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one operable name, one string name, and one operable type.'
#     local\
#         operable_name__sstrtp="${1}"\
#         string_name__sstrtp="${2}"\
#         operable_type__sstrtp="${3}"\
#         prototype_setter_name__sstrtp
# 
#     #FUXME: Nonsense. Call ::operable.set_prototype_setter_of_type() instead.
# 
#     # Name of the function setting such string to such operable's prototype.
#     # See ::operable.document_prototype,asciidoc_of_type() for such
#     # function's definition.
#     prototype_setter_name__sstrtp="::set_string_to_${operable_type__sstrtp}_prototype:${operable_name__sstrtp}"
#     :func.die_unless "${prototype_setter_name__sstrtp}"
#     "${prototype_setter_name__sstrtp}" "${string_name__sstrtp}"
# }
# 
# # :void ::operable.set_prototype_of_type(
# #     :string operable_name,
# #     ^:string prototype_name,
# #     :string operable_type)
# :func.document <<'/---'
# :void ::operable.set_asciidoc_setter_of_type(
#     :string operable_name,
#     ^:string setter_name,
#     :string operable_type)
# 
# Set the passed string variable to the name of the function setting a passed
# string variable to the AsciiDoc of the passed operable of the passed type
# (e.g., `::func.set_asciidoc:string.set()` for function string.set()).
# /---
# 
# function ::operable.set_prototype_of_type() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one operable name, one string name, and one operable type.'
#     local\
#         operable_name__sstrtp="${1}"\
#         string_name__sstrtp="${2}"\
#         operable_type__sstrtp="${3}"\
#         prototype_setter_name__sstrtp
# 
#     #FUXME: Nonsense. Call ::operable.set_prototype_setter_of_type() instead.
# 
#     # Name of the function setting such string to such operable's prototype.
#     # See ::operable.document_prototype,asciidoc_of_type() for such
#     # function's definition.
#     prototype_setter_name__sstrtp="::set_string_to_${operable_type__sstrtp}_prototype:${operable_name__sstrtp}"
#     :func.die_unless "${prototype_setter_name__sstrtp}"
#     "${prototype_setter_name__sstrtp}" "${string_name__sstrtp}"
# }

    # ::operable.set_prototype_of_type "${@}" 'func'
    # local\
    #     operable_name__osmotmt="${1}"\
    #     string_name__osmotmt="${2}"\
    #     operable_type__osmotmt="${3}"\
    #     metadata_type__osmotmt="${4}"\
    #     metadata_setter__osmotmt

    # # Name of such setter function.
    # ::operable.set_setter_of_type,metadata_type\
    #     "${operable_name__osmotmt}"\
    #     metadata_setter__osmotmt\
    #     "${operable_type__osmotmt}"\
    #     "${metadata_type__osmotmt}"

    # # Set such string.
    # :func.die_unless "${prototype_setter_name__osmotmt}"
    # "${metadata_setter__osmotmt}" "${string_name__osmotmt}"

#FUXME: Generalize for all possible metadata by refactoring into:
#FUXME: Implement ::set_string_to_operable_type_asciidoc() along similar lines.

# :func.document <<'/---'
# :void ::operable.set_prototype_setter_of_type(
#     :string operable_name,
#     ^:string setter_name,
#     :string operable_type)
# 
# Set the passed string variable to the name of the function setting a passed
# string variable to the prototype of the passed operable of the passed type
# (e.g., `::func.set_prototype:string.set()` for the prototype for function string.set()).
# /---
# function ::operable.set_prototype_setter_of_type() {
#     (( # == 3 )) || :die\
#         'Expected one operable name, one string name, and one operable type.'
#     :string.set "${2}" "::${3}.set_prototype:${1}"
# }

#FUXME: This could really benefit from an example.
    # local\
    #     operable_name__ospsot="${1}"\
    #     prototype_setter_name__ospsot="${2}"\
    #     operable_type__ospsot="${3}"
