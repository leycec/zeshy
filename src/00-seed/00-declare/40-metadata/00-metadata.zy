#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under ={help} in the main codebase.

#FIXME: Shift all functions declared below to ={10-set} that can reasonably be
#shifted to such parcel. (Perhaps no such functions remain?)

#FIXME: We *ABSOLUTELY* need to declare this parcel earlier -- at least before
#={15-set}. Assuming we need to call any functions from such parcel, we'll have
#to split ={15-set} into two new trees -- say, ={15-set} defining only the
#small subset of setters required by this parcel and ={25-set} defining the
#remainder. How large of a subset is this, anyway?

#FIXME: For efficiency, declaration functions in this and other parcels should
#only define help functions when actually compiling help documentation and
#hence utilizing such functions. (Or do we *ALWAYS* compile such
#documentation?) Contemplate.

#FIXME: Document the fact that global values may actually be delimited by an
#arbiratry number of "=" delimiters, in which case this function defines *ALL*
#such globals to be synonyms of each other assigned the same initial value.
#Required elsewhere. Sweet, eh?

#FIXME: We're certain we've documented this elsewhere, but the correct approach
#to documentation is to segregate *EACH* bit of documentation into its own
#setter function setting a passed string variable to the documentation for the
#desired object: e.g.,
#
#    # Set such string variable to the help string for function
#    # ::define_func().
#    void ::set_string_to_help:func::define_func(void string_name)
#
#Naturally, *ALL* such setters should be compiled into a *NEW, SEPARATE* digest
#file (e.g., "~/.zeshy/cache/digest/help.zwc"), which doesn't depend on whether
#or not this is a debug or release build of zeshy and hence applies to *ALL*
#possible main zeshy digests.
#
#How does segregating such setters to such digest help us? Simple. By default,
#such digest is *NOT* listed in the function path ${fpath}. In fact, *ONLY* low-
#level helper functions (e.g., :print_help_function()) internally and only
#temporarily prepend such digest to a local shadowing of ${fpath}. Indeed, such
#functions should probably temporarily reduce ${fpath} to *ONLY* such digest.
#
#Such technique provides a memorable means of implementing highly efficient
#pure-zeshy read-only key-value stores, as I believe we've remarked elsewhere.

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

# ....................{ SETTERS                            }....................
#FIXME: Document me.

# :void ::Doc.from_stdin[
#     args=( :Str doc_name),
#     stdin=(:str doc)]
function ::Doc.from_stdin() {
    (( # == 1 )) || :die 'Expected one string name.'

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception; else, set the passed string to such input.
    :Str.from_stdin_if_nonempty "${1}" || :die\
        'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'
}

#FIXME: Document me.

# :void ::doc.Prototype_Asciidoc(
#     :str doc
#     :Str prototype_name
#     :Str asciidoc_name)
function ::doc.Prototype_Asciidoc() {
    (( # == 3 )) || :die\
        'Expected one help string, one prototype string, and one AsciiDoc string name.'
    local\
        help__ssthp=${1}\
        prototype_name__ssthp=${2}\
        asciidoc_name__ssthp=${3}
    # print -r "help string: ${help__ssthp}"

    # If such documentation contains a blank line (i.e., "\n\n"), assume the
    # substring preceding such line to be the expected prototype. Else, throw
    # an exception.
    [[ ${help__ssthp} == ${~ZESHY_HELP_GLOB} ]] || :die\
        'Documentation invalid (i.e., contains no blank line separating prototype from AsciiDoc):'$'\n\n'${help__ssthp}

    # Set such strings.
    :Str.set "${prototype_name__ssthp}" "${match[1]}"
    :Str.set "${asciidoc_name__ssthp}"  "${match[2]}"
}

# ....................{ DOCUMENTERS ~ alias                }....................
#FIXME: Document me.

# :void :alias_command.doc[stdin=(:str doc)]
function :alias_command.doc() {
    (( ! # )) || :die 'Expected no arguments.'
    ::callable.doc 'alias_command' 'Command alias'
}

#FIXME: Document me.

# :void :alias_command_filetype.doc[stdin=(:str doc)]
function :alias_command_filetype.doc() {
    (( ! # )) || :die 'Expected no arguments.'
    ::callable.doc 'alias_suffix' 'Suffix alias'
}

#FIXME: Document me.

# :void :alias_word.doc[stdin=(:str doc)]
function :alias_word.doc() {
    (( ! # )) || :die 'Expected no arguments.'
    ::callable.doc 'alias_general' 'General alias'
}

#FIXME: Document me.

# :void ::alias.doc_prototype_from_stdin_if_nonempty[
#     args=(+:str/alias alias_names
#            :str alias_type
#            :str alias_prototype)
#     stdin=(:str alias_asciidoc)]
function ::alias.doc_prototype_from_stdin_if_nonempty() {
    (( # >= 3 )) || :die\
        'Expected one or more alias names, one alias type, and one alias prototype.'
    local alias_type=${@[-2]} alias_prototype=${@[-1]}

    # If such type is unrecognized, throw an exception.
    [[ ${alias_type} == ('command'|'command_filetype'|'word') ]] || :die\
        'Alias type "'${alias_type}'" unrecognized (i.e., neither "command", "command_filetype", or "word").'

    # If such documentation was passed, document such aliases.
    ::operable.doc_prototype_from_stdin_if_nonempty\
        "${@[1,-3]}" "alias_${alias_type}" "${alias_prototype}"
}

# ....................{ DOCUMENTERS ~ func                 }....................
#FIXME: Document me.

# :void :func.doc[stdin=(:str func_help)]
function :func.doc() {
    (( ! # )) || :die 'Expected no arguments.'
    ::callable.doc 'func' 'Function'
}

#FIXME: Document me.

# :void ::func.doc_prototype_from_stdin_if_nonempty[
#    args=(+:str/func func_names
#           :str func_prototype)
#    stdin=(:str func_asciidoc)]
function ::func.doc_prototype_from_stdin_if_nonempty() {
    (( # >= 2 )) || :die\
        'Expected one or more function names and one function prototype.'
    ::operable.doc_prototype_from_stdin_if_nonempty\
        "${@[1,-2]}" 'func' "${@[-1]}"
}

# ....................{ DOCUMENTERS ~ global               }....................
#FIXME: Document me.

# :void :global.doc[stdin=(:str doc)]
function :global.doc() {
    (( ! # )) || :die 'Expected no arguments.'
    local global_help__dg global_prototype__dg global_asciidoc__dg
    local -a global_names__dg

    # Documentation passed on standard input.
    ::Doc.from_stdin global_help__dg

    # Split such documentation into prototype and non-prototype portions.
    ::doc.Prototype_Asciidoc\
        "${global_help__dg}" global_prototype__dg global_asciidoc__dg

    # Global name declared by such documentation's prototype.
    ::global_prototype.Names "${global_prototype__dg}" global_names__dg 

    # Document such names.
    ::operable.doc\
        "${global_names__dg[@]}"\
        'global'\
        "${global_prototype__dg}"\
        "${global_asciidoc__dg}"
}

#FIXME: Document me.

# :void ::global.doc_prototype_from_stdin_if_nonempty[
#    args=(+:str/global global_names
#           :str global_prototype)
#    stdin=(:str global_asciidoc)]
function ::global.doc_prototype_from_stdin_if_nonempty() {
    (( # >= 2 )) || :die\
        'Expected one or more globaltion names and one globaltion prototype.'
    ::operable.doc_prototype_from_stdin_if_nonempty\
        "${@[1,-2]}" 'global' "${@[-1]}"
}

# ....................{ DOCUMENTERS ~ callable             }....................
#FIXME: Document me.

# :void ::callable.doc[
#     args=( :str callable_type :str callable_label)
#     stdin=(:str callable_help)]
function ::callable.doc() {
    (( # == 2 )) || :die 'Expected one callable type and one callable label.'
    local\
        callable_type=${1}\
        callable_label=${2}\
        callable_help\
        callable_prototype\
        callable_asciidoc
    local -a callable_names

    # Documentation passed on standard input.
    ::Doc.from_stdin callable_help

    # Split such documentation into prototype and non-prototype portions.
    ::doc.Prototype_Asciidoc\
         "${callable_help}" callable_prototype callable_asciidoc

    # List of all callable names declared by such documentation's prototype.
    ::callable_prototype.Names\
        "${callable_prototype}" callable_names "${callable_label}"

    # Document such names.
    ::operable.doc\
        "${callable_names[@]}"\
        "${callable_type}"\
        "${callable_prototype}"\
        "${callable_asciidoc}"
}

# ....................{ DOCUMENTERS ~ operable             }....................
#FIXME: Document me.

# :void ::operable.doc_prototype_from_stdin_if_nonempty[
#     args=(+:str operable_names
#            :str operable_type
#            :str operable_prototype)
#     stdin=(:str operable_help)]
function ::operable.doc_prototype_from_stdin_if_nonempty() {
    (( # >= 3 )) || :die\
        'Expected one or more operable names, one operable type, and one operable prototype.'
    local operable_asciidoc__dotpwsifon

    # If documentation was passed on standard input, document such operables
    # with such documentation.
    if { :Str.from_stdin_if_nonempty operable_asciidoc__dotpwsifon } {
        ::operable.doc\
            "${@}" "${operable_asciidoc__dotpwsifon}"
    }
}

#FIXME: Document me.

# :void ::operable.doc(
#    +:str operable_names
#     :str operable_type
#     :str operable_prototype
#     :str operable_docstring)
function ::operable.doc() {
    # Validate sanity. Since globals are operables and hence must *NOT* be
    # shadowed by locals declared below, mangle the names of such locals.
    (( # >= 4 )) || :die\
        'Expected one or more operable names, one prototype, one docstring, and one operable type.'
    local\
        operable_type__odpaot=${@[-3]}\
        prototype__odpaot=${@[-2]}\
        docstring__odpaot=${@[-1]}\
        prototype_setter__odpaot\
        docstring_setter__odpaot

    # For each such operable name, define:
    #
    # * A setter setting a passed string variable to such prototype.
    # * A setter setting a passed string variable to such AsciiDoc.
    #
    # To avoid quoting issues with reserved characters in such documentation,
    # set such variable via a here-document.
    local operable_name__odpaot
    for   operable_name__odpaot ("${@[1,-4]}") {
        # Name of the prototype setter function defined below.
        ::operable.Metadata_setter\
            "${operable_name__odpaot}"\
            "${operable_type__odpaot}"\
            prototype_setter__odpaot\
            'prototype'

        # Name of the AsciiDoc setter function defined below.
        ::operable.Metadata_setter\
            "${operable_name__odpaot}"\
            "${operable_type__odpaot}"\
            docstring_setter__odpaot\
            'docstring'

        # If either such function is already defined, throw an exception.
        :func.die_if "${prototype_setter__odpaot}" "${docstring_setter__odpaot}"

        # Define such functions.
        functions[${prototype_setter__odpaot}]='
    (( # == 1 )) || :die "Expected one string name."
    :Str.set "${1}" '${(qq)prototype__odpaot}
        functions[${docstring_setter__odpaot}]='
    (( # == 1 )) || :die "Expected one string name."
    :Str.set "${1}" '${(qq)docstring__odpaot}
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to ::alias.document_prototype,stdin_if_nonempty_or_noop_of_type().

# function ::operable.doc() {
#     # Validate sanity. Since globals are operables and hence must *NOT* be
#     # shadowed by locals declared below, mangle the names of such locals.
#     (( # >= 4 )) || :die\
#         'Expected one or more operable names, one prototype string, one asciidoc string, and one operable type.'
#     local\
#         operable_type__odpaot="${@[-3]}"\
#         prototype__odpaot="${@[-2]}"\
#         asciidoc__odpaot="${@[-1]}"\
#         heredoc_delimiter__odpaot='/---/---/---'\
#         prototype_setter__odpaot\
#         asciidoc_setter__odpaot
# 
#     # Pop such arguments from the argument list. See pop_args_3() for further
#     # details.
#     argv[-3,-1]=()
# 
#     #FUXME: Reimplement as a multiline PCRE, which *SHOULD* prove dramatically
#     #more efficient.
# 
#     # If either such prototype or AsciiDoc contains a line equal to the
#     # here-doc delimiter delimiting such strings below, throw an exception.
#     [[ "${prototype__odpaot}"$'\n'"${asciidoc__odpaot}" != (|*$'\n')"${heredoc_delimiter__odpaot}"(|$'\n'*) ]] || :die\
#         'Documentation contains here-doc delimiter "'${heredoc_delimiter__odpaot}'" reserved for internal zeshy use only.'
# 
#     # For each such operable name, define:
#     #
#     # * A setter setting a passed string variable to such prototype.
#     # * A setter setting a passed string variable to such AsciiDoc.
#     #
#     # To avoid quoting issues with reserved characters in such documentation,
#     # set such variable via a here-document.
#     local operable_name__odpaot
#     for   operable_name__odpaot ("${@}") {
#         # Name of the prototype setter function defined below.
#         ::operable.Metadata_setter\
#             "${operable_name__odpaot}"\
#             "${operable_type__odpaot}"\
#             prototype_setter\
#             'prototype'
# 
#         # Name of the AsciiDoc setter function defined below.
#         ::operable.Metadata_setter\
#             "${operable_name__odpaot}"\
#             "${operable_type__odpaot}"\
#             asciidoc_setter\
#             'asciidoc'
# 
#         # If either such function is already defined, throw an exception.
#         :func.die_if "${prototype_setter}" "${asciidoc_setter}"
# 
#         # Define such functions.
#         functions[${prototype_setter__odpaot}]='
#     (( # == 1 )) || :die "Expected one string name."
#     :Str.set "${1}" '${(qq)prototype__odpaot}'
#     <<'''${heredoc_delimiter__odpaot}'''
# '${prototype__odpaot}'
# '${heredoc_delimiter__odpaot}
#         functions[${asciidoc_setter__odpaot}]='
#     (( # == 1 )) || :die "Expected one string name."
#     :Str.from_stdin "${1}" <<'''${heredoc_delimiter__odpaot}'''
# '${asciidoc__odpaot}'
# '${heredoc_delimiter__odpaot}
#     }
# }

#         functions[${prototype_setter__odpaot}]='
#     (( # == 1 )) || :die "Expected one string name."
#     :Str.from_stdin "${1}" <<'''${heredoc_delimiter__odpaot}'''
# '${prototype__odpaot}'
# '${heredoc_delimiter__odpaot}
#         functions[${asciidoc_setter__odpaot}]='
#     (( # == 1 )) || :die "Expected one string name."
#     :Str.from_stdin "${1}" <<'''${heredoc_delimiter__odpaot}'''
# '${asciidoc__odpaot}'
# '${heredoc_delimiter__odpaot}

#FUXME: Rename to ::func.document_prototype,stdin_if_nonempty_or_noop().

        #FUXME: We'll need to shift :Str.from_stdin() to ={*-set} for
        #reliability with early-defined functions (e.g., :declare_alias()).

        #FUXME: Actually, just eliminate such error-prone redundancy by
        #defining two new setters
        #::operable.set_prototype_setter_of_type() and
        #::operable.set_asciidoc_setter_of_type(), called like so:
        #
        #    local prototype asciidoc
        #    ::operable.set_prototype_setter_of_type\
        #        ':my_func' prototype 'func'
        #    ::operable.set_asciidoc_setter_of_type\
        #        ':my_func' asciidoc 'func'
        #FUXME: Incidentally, neither ::set_string_to_operable_type_prototype()
        #or ::set_string_to_operable_type_asciidoc() appear to exist anymore!
        #Grep the codebase for "::set_string_to_" to help uncover where they
        #lackadaisically tripped off to.
        #FUXME: O.K.; we've now defined general-purpose metadata setter
        #::operable.set_setter_of_type,metadata_type(). Call below. Yay!
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize changes to such names with
        # ::set_string_to_operable_type_prototype() and
        # ::set_string_to_operable_type_asciidoc().
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # # Names of such functions to be defined.
        # prototype_setter="::set_string_to_${operable_type__odpaot}_prototype:${operable_name__odpaot}"
        # asciidoc_setter="::set_string_to_${operable_type__odpaot}_asciidoc:${operable_name__odpaot}"

#FUXME: Refactor into
#::operable.document_prototype,stdin_if_nonempty_or_noop_of_type().

        #FUXME: Use of heredoc delimiters is, frankly, overly fragile. (After
        #all, what if such prototype or documentation inexplicably contains
        #such 

#FUXME: Suffix all locals with "__dotwpa", as globals are operables too.

#FUXME: It'd be great to support specification of whether a function or alias
#argument is actually mandatory or optional in variadic lists. For example, in
#the following function prototype, all arguments except the first menu name are
#actually optional -- but we have no way of indicating that at the moment:
#
#    string show_info_menu_with_options(
#        string info_option1, string info_option2, ...,
#        string menu_name1, string menu_name2, ...)
#
#I propose a simple suffix "?" on all optional variadic arguments: e.g.,
#
#    string show_info_menu_with_options(
#        string info_option1?, string info_option2?, ...,
#        string menu_name1, string menu_name2?, ...)
#
#Fairly simple *AND* legible, yes?

#FUXME: I'm unsure if I've documented it anywhere... so, it had might as well be
#here. The nomenclature for synthesized help function names should be:
#
#* For aliases, "::set_string_to_help:alias:${alias_name}".
#* For functions, "::set_string_to_help:function:${function_name}".
#* For globals, "::set_string_to_help:global:${global_name}".
#
#Simple. Note that in the case of normal ":"-suffixed aliases and functions,
#the corresponding help function names will also be suffixed by ":" -- which is,
#of course, perfect. Lookin good, eh?

# ....................{ GLOBALS                            }....................
# typeset -g ZESHY_HELP_SETTER_NAME_PREFIX=':set_string_to_'

#FUXME: Document me.
# typeset -g ZESHY_OPERABLE_PROTOTYPE_SETTER_NAME_PREFIX=':set_string_to_prototype_'

#FUXME: Obsolete. Excise everywhere!

#FUXME: Replace with a new function ::func.document_with_type,prototype,stdin_if_nonempty_or_noop() implemented as above.

# void ::func.document_with_prototype,asciidoc(
#     args: (
#         string alias_name1, ...,
#         string alias_type,
#         string alias_prototype),
#     stdin: string runnable_documentation]
# function ::func.document_with_prototype,asciidoc() {
#     (( # >= 3 )) || :die\
#         'Expected one or more function names, one function prototype, and one asciidoc string.'
#     ::operable.document_prototype,asciidoc_of_type\
#         "${@[1,-3]}" 'func' "${@[-2]}" "${@[-1]}"
# }

    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, silently report
    # succes. See ::Doc.from_stdin() for further details.
    # read -t 0 || return 0
    # print 'stdin exists!'
    # if { read -t 0 } {
    #     print 'stdin exists.'
    #     if { read -t 0 } {
    #         print 'stdin still exists.'
    #     }
    # } else {
    #     print 'stdin doesn''t exist!'
    #     return 0
    # }

    # Documentation passed on standard input.
    # ::Doc.from_stdin operable_asciidoc__dotpwsifon

    # # Document such names.
    # ::operable.document_prototype,asciidoc_of_type\
    #     "${@[1,-3]}"\
    #     "${operable_type__dotpwsifon}"\
    #     "${operable_prototype__dotpwsifon}"\
    #     "${operable_asciidoc__dotpwsifon}"

        # operable_type__dotpwsifon="${@[-2]}"\
        # operable_prototype__dotpwsifon="${@[-1]}"\

#FUXME: Use of "typed" rather than "type" nomenclature is somewhat awkward.
#Contemplate a global rename from the former to the latter.
#FUXME: Indeed, rename to simply ::document_alias_type_prototype,asciidoc().
#FUXME: Actually, rename to
#::document_stdin_with_alias_type,prototype,asciidoc_if_found_or_noop() and
#refactor to internally call ::callable.document_stdin_of_type,label() instead.
#FUXME: Excise this.
#FUXME: Document me.
# void ::document_alias_typed_with_prototype,asciidoc(
#     string alias_name1, ...,
#     string alias_type,
#     string alias_prototype,
#     string alias_asciidoc)
# function ::document_alias_typed_with_prototype,asciidoc() {
#     # Validate sanity.
#     (( # >= 4 )) || :die\
#         'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
#     local alias_type="${@[-3]}"
# 
#     # If such type is unrecognized, throw an exception.
#     [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
#         'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'
# 
#     # Document such alias.
#     ::operable.document_prototype,asciidoc_of_type\
#         "${@[1,-4]}" "alias_${alias_type}" "${@[-2]}" "${@[-1]}"
# }

    # Shift such arguments off. See shift_arg_2() for further details.
    # argv[1,2]=()

    # (( # == 3 )) || :die\
    #     'Expected one alias type, one alias prototype, and one asciidoc string.'
#FUXME: Rename to ::func.document_prototype,asciidoc().
    #FUXME: Define such setter!

    # # Validate sanity.
    # (( # >= 4 )) || :die\
    #     'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
    # local\
    #     alias_type="${@[-3]}"\
    #     prototype="${@[-2]}"\
    #     asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_3() for further
    # # details.
    # argv[-3,-1]=()

    # # If such type is unrecognized, throw an exception.
    # [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
    #     'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # # Document such alias.
    # ::operable.document_prototype,asciidoc_of_type\
    #     "${@}" "alias_${alias_type}" "${prototype}" "${asciidoc}"

    # # Validate sanity.
    # (( # >= 3 )) || :die\
    #     'Expected one or more function names, one function prototype, and one asciidoc string.'
    # local prototype="${@[-2]}" asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_2() for further
    # # details.
    # argv[-2,-1]=()

    # # Document such function.
    # ::operable.document_prototype,asciidoc_of_type\
    #     "${@}" 'func' "${prototype}" "${asciidoc}"

#FUXME: Rename to ::operable.document_prototype,asciidoc_of_type().
#FUXME: Actually, rename to ::document_operable_with_prototype,asciidoc().

 # IMPORTANT: Note in such documentation that neither such
#prototype or AsciiDoc may contain
#FUXME: Arguably, such functions pertain to a new parcel -- say, @{20-document}.
