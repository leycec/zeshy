#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *alias declarer exception handlers* (i.e., functions throwing exceptions
resulting from alias declarers).
/---

# ....................{ EXCEPTIONS                         }....................
# Manually handle arguments passed to such function, as the aliases defining the
# types of such arguments (e.g., :string()) have yet to be defined.
:func_ '<is_args_unhandled> :void ::alias.die(:string exception_message)' :func{
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ::func.die().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    local exception_message
    exception_message=$(::alias.label)${1}

    # If such prototype has been declared, append such prototype.
    if (( ${#ZESHY__ALIAS_PROTOTYPE-} )) {
        local alias_prototype=${ZESHY__ALIAS_PROTOTYPE} alias_type

        # For readability, indent such prototype and capitalize such type.
        ::String.indent alias_prototype
        ::alias_current.Type_capitalized alias_type

        # Such suffix.
        exception_message+=$'\n\n'${alias_type}' alias prototype:'$'\n'${alias_prototype}
    }

    # Throw such exception.
    :die ${exception_message}
}:func <<'/---'
Throw an exception with the passed message, presumably detailing a syntactic or
semantic error in the currently declared alias prototype. This private
exception handler is intended to be called _only_ by ::alias().

== Message Format ==

The passed message should be formatted as a lowercase sentence fragment (e.g.,
`prototype invalid`), which this function then:

* Prefixes by `Parcel ={parcel_name} alias ${alias_name}() `, where:
** `${parcel_name}` is the name of the parcel containing such alias.
** `${alias_name}` is the first alias name such prototype declares. (For
   simplicity, any subsequent alias name such prototype declares is ignored.)
* Suffixes by such prototype.
/---

:func_ '<is_args_unhandled> :void ::alias.die_of_prototype()' :func{
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ::func.die_of_prototype().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (( ! # )) || :die 'Expected no arguments.'
    ::pcre.die_of_subject_not_matching\
        "${ZESHY__CALLABLE_PROTOTYPE_PCRE}"\
        "${ZESHY__ALIAS_PROTOTYPE}"\
        "$(::alias.label)prototype "
}:func <<'/---'
Throw an exception detailing a syntactic error in the currently declared
alias prototype.

This private exception handler is intended to be called _only_ by :alias().
/---

#FIXME: Create a similar ::func.die_of_redefinition() in zy://*-func/die.zy.

:func_ '<is_args_unhandled> :void ::alias.die_of_redefinition(
    :string alias_expansion)' :func{
    local alias_expansion=${1} alias_type alias_definition

    # Such type, capitalized for readability.
    ::alias_current.Type_capitalized alias_type

    # Such expansion, indented for readability.
    ::String.indent alias_expansion

    # Throw such exception.
    ::alias.die\
        'already defined.'$'\n\n'${alias_type}' alias definition:'$'\n'${alias_expansion}
}:func <<'/---'
Throw an exception resulting from the currently declared alias erroneously
redefining an existing alias with the passed expansion.

This private exception handler is intended to be called _only_ by ::alias().
/---

# ....................{ GETTERS                            }....................
:func_ '<is_args_unhandled> :string ::alias.label()' :func{
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ::func.label().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    local alias_label
    alias_label=$(:parcel.label)'alias '

    # If such prototype declares one name, prepend this label by this name.
    if (( ${#ZESHY__ALIAS_NAMES-} == 1 )) {
        alias_label+=${ZESHY__ALIAS_NAMES[1]}'() '
    # Else if such prototype declares multiple names, prepend this label by all
    # such names.
    } elif (( ${#ZESHY__ALIAS_NAMES-} > 1 )) {
        alias_label+='{'${ZESHY__ALIAS_NAMES[*]}'}() '
    # Else, such prototype has not yet been parsed. Ignore such names.
    }

    # Get such label.
    print -r -- "${alias_label}"
}:func <<'/---'
Get a human-readable string describing the alias being currently defined.
/---

# ....................{ LETTERS                            }....................
:func.document <<'/---'
<is_args_unhandled> :void ::alias_current.Type_capitalized(
    :String type_capitalized_name)

Set the passed string variable to the human-readable capitalized type of the
currently declared alias (e.g., `Command`, `Command Filetype`, `Word`).

This private setter is intended to be called _only_ by exception handlers called
by ::alias().
/---
function ::alias_current.Type_capitalized() {
    (( # == 1 )) || :die 'Expected one string name.'
    :string.set "${1}" "${(C)ZESHY__ALIAS_TYPE[1]-}${ZESHY__ALIAS_TYPE[2,-1]-}"
}

# --------------------( WASTELANDS                         )--------------------
    # # String prefixing such exception message.
    # exception_prefix=$(:parcel.label)${ZESHY__ALIAS_TYPE-}' alias '
    #
    # # If at least one alias name has been matched from such prototype, prepend
    # # such exception by the first such name.
    # (( ! ${#ZESHY__ALIAS_NAMES[1]-} )) ||
    #     exception_prefix+=${ZESHY__ALIAS_NAMES[1]-}'() '

    # If such prototype has been declared, suffix such exception by such
    # prototype, indented for readability.
    # if [[ -n ${ZESHY__ALIAS_PROTOTYPE-} ]] {
    #     exception_suffix=$'\n\n''Alias prototype:'$'\n''    '${ZESHY__ALIAS_PROTOTYPE//$'\n'/$'\n'    }
    # }

    # If such alias was declared in a parcel, prefix such exception message
    # by such parsel.
    # if [[ -n ${exception_prefix} ]] {
    #     exception_prefix+='alias '
    # } else {
    #     exception_prefix+='Alias '
    # }
