#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *alias declarer exception handlers* (i.e., functions throwing exceptions
resulting from alias declarers).
/---

# ....................{ EXCEPTIONS                         }....................
# Manually handle arguments passed to such function, as the aliases defining the
# types of such arguments (e.g., :string()) have yet to be defined.
:func_ '<is_args_unhandled> :void ::alias.die(:string exception_message)' :func{
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ::func.die().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    local exception_message=${1} exception_prefix exception_suffix 

    # String prefixing such exception message.
    exception_prefix=$(:parcel.label)${ZESHY__ALIAS_TYPE-}' alias '

    # If at least one alias name has been matched from such prototype, prepend
    # such exception by the first such name.
    (( ! ${#ZESHY__ALIAS_NAMES[1]-} )) ||
        exception_prefix+=${ZESHY__ALIAS_NAMES[1]-}'() '

    # If such prototype has been declared, suffix such exception by such
    # prototype.
    if (( ${#ZESHY__ALIAS_PROTOTYPE-} )) {
        # Such alias' type, capitalized for readability.
        local alias_type
        ::alias_current.Type_capitalized alias_type

        # Such alias' prototype, indented for readability.
        local alias_prototype=${ZESHY__ALIAS_PROTOTYPE}
        ::String.indent alias_prototype

        # Such suffix.
        exception_suffix=$'\n\n'${alias_type}' alias prototype:'$'\n'${alias_prototype}
    }

    # Throw such exception.
    :die ${exception_prefix}${exception_message}${exception_suffix}
}:func <<'/---'
Throw an exception with the passed message, presumably detailing a syntactic or
semantic error in the currently declared alias prototype. This private
exception handler is intended to be called _only_ by ::alias().

== Message Format ==

The passed message should be formatted as a lowercase sentence fragment (e.g.,
`prototype invalid`), which this function then:

* Prefixes by `Parcel ={parcel_name} alias ${alias_name}() `, where:
** `${parcel_name}` is the name of the parcel containing such alias.
** `${alias_name}` is the first alias name such prototype declares. (For
   simplicity, any subsequent alias name such prototype declares is ignored.)
* Suffixes by such prototype.
/---

# ....................{ EXCEPTIONS                         }....................
#FIXME: Create a similar ::func.die_of_redefinition() in ={*-func/die}.

:func_ '<is_args_unhandled> :void ::alias.die_of_redefinition(
    :string alias_expansion)' :func{
    local alias_expansion=${1} alias_type alias_definition

    # Such type, capitalized for readability.
    ::alias_current.Type_capitalized alias_type

    # Such expansion, indented for readability.
    ::String.indent alias_expansion

    # Throw such exception.
    ::alias.die\
        'already defined.'$'\n\n'${alias_type}' alias definition:'$'\n'${alias_expansion}
}:func <<'/---'
Throw an exception resulting from the currently declared alias erroneously
redefining an existing alias with the passed expansion.

This private exception handler is intended to be called _only_ by ::alias().
/---

# ....................{ SETTERS                            }....................
:func.document <<'/---'
<is_args_unhandled> :void ::alias_current.Type_capitalized(
    ^:string type_capitalized_name)

Set the passed string variable to the human-readable capitalized type of the
currently declared alias (e.g., `Command`, `Command Filetype`, `Word`).

This private setter is intended to be called _only_ by exception handlers called
by ::alias().
/---
function ::alias_current.Type_capitalized() {
    (( # == 1 )) || :die 'Expected one string name.'
    :string.set "${1}" "${(C)ZESHY__ALIAS_TYPE[1]-}${ZESHY__ALIAS_TYPE[2,-1]-}"
}

# --------------------( WASTELANDS                         )--------------------
    # If such prototype has been declared, suffix such exception by such
    # prototype, indented for readability.
    # if [[ -n ${ZESHY__ALIAS_PROTOTYPE-} ]] {
    #     exception_suffix=$'\n\n''Alias prototype:'$'\n''    '${ZESHY__ALIAS_PROTOTYPE//$'\n'/$'\n'    }
    # }

    # If such alias was declared in a parcel, prefix such exception message
    # by such parsel.
    # if [[ -n ${exception_prefix} ]] {
    #     exception_prefix+='alias '
    # } else {
    #     exception_prefix+='Alias '
    # }
