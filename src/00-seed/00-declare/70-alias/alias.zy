#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *untyped alias declarers* (i.e., functions declaring aliases of
arbitrary type).
/---

#FIXME: Alias expansions containing macro expansions pose a slight issue,
#though certainly solvable. Consider a macro :some_macro and alias :some_alias
#expanding as follows:
#
#    alias ":some_alias"=":some_macro"
#
#Simple, right? Right. Unfortunately, the current approach expands macros
#*BEFORE* evaluating the result and hence expands such macro. Thus, such
#approach fails to preprocess macros embedded in aliases. Fortunately, there
#exists a simple alternative:
#
#* Before preprocessing, define a temporary singleton function (e.g.,
#  ::preprocess.code()) whose body is *EXACTLY* the code to be preprocessed:
#  e.g.,
#     functions[::preprocess.code]=${preprocessed_code}
#* After definition, such function's body is such code with all aliases expanded
#  to their results.
#* Preprocess such function's body rather than the original code: e.g.,
#     ::preprocess ${functions[::preprocess.code]}
#* Undefine such function to avoid unexpected side effects.
#
#Inefficient? Yes. But, again, *ALL* digest compilations except the first will
#be backgrounded. Hence, we generally don't care *TOO* much about compilation
#times -- so long as they're not apallingly horrific, anyway.
#FIXME: There's only one (minor) issue with the above approach: shadowing
#order. Namely, macros are supposed to shadow aliases, which shadow functions;
#given the above approach... Actually, the above approach fundamentally falls
#down. Valid zeshy code is expressly *NOT* valid zsh code, and is frequently
#blatantly invalid zsh code; attempting to unconditionally interpret the former
#as the latter is guaranteed to fail (very horribly).
#
#Consider instead expanding macros in alias expansions at alias definition
#time. Such an approach is trivial to implement given current preprocessor
#design *AND* equitably supports macro expansions in aliases without the
#syntactic conflicts or extreme inefficiencies of the above approach. There's
#pretty much no other way to do it, anyway.
#
#This shouldn't be terribly ardous. We'll want to simply ignore macro expansions
#in low-level zsh-specific alias definers (e.g., the alias() builtin), which is
#an acceptable tradeoff for our purposes. It's then transparently simple to
#support macro expansion in alias expansions: simply define our high-level alias
#definers (e.g., :alias_command()) in the same exact way that we do our
#high-level function definer :func(). That is to say, our alias definers should
#all accept an alias prototype as their first argument and a "{"- and "}"-
#delimited block of code as their second argument. Given that, the zeshy
#preprocessor will simply preprocess such code much as it does function code.
#Done, and without maximal laziness on our part.

# ....................{ GLOBALS ~ private                  }....................
:global.document <<'/---'
:string ZESHY__ALIAS_TO_EXPANSION_NAME

Name of the canonical map global mapping from enabled aliases of the currently
declared alias' type (i.e., command, general, suffix) to the strings such
aliases expand to for such alias, parsed from such alias' prototype. This
private global is intended to be referenced _only_ by ::alias(). 

== Valid Values ==

Such name _must_ be either:

* `alias`, signifying a command alias.
* `galias`, signifying a general alias.
* `salias`, signifying a suffix alias.
/---
typeset -g ZESHY__ALIAS_TO_EXPANSION_NAME

:global.document <<'/---'
:string ZESHY__ALIAS_TO_EXPANSION_NAME_KEY

Name of the canonical map global mapping from enabled aliases of the currently
declared alias' type (i.e., command, general, suffix) to the strings such
aliases expand to for such alias, indexed by the name of the currently parsed
alias. Dynamically expanding this global under parameter expansion flag `(P)`
yields the expansion of the currently parsed alias if any. This private global
is intended to be referenced _only_ by ::alias().
/---
typeset -g ZESHY__ALIAS_TO_EXPANSION_NAME_KEY

:global.document <<'/---'
:string ZESHY__ALIAS_TYPE

Type of the currently declared alias. This private global is intended to be
referenced _only_ by ::alias().

== Valid Types ==

Such type _must_ be one of the following enumeration-style string literals:

* `command`, signifying a command alias.
* `general`, signifying a general alias.
* `suffix`, signifying a suffix alias.
/---
typeset -g ZESHY__ALIAS_TYPE

:global.document <<'/---'
:string ZESHY__ALIAS_PROTOTYPE

Prototype for the currently declared alias. This private global is intended to
be referenced _only_ by ::alias().
/---
typeset -g ZESHY__ALIAS_PROTOTYPE

:global.document <<'/---'
:string ZESHY__ALIAS_EXPANSION

Expansion for the currently declared alias. This private global is intended to
be referenced _only_ by ::alias().
/---
typeset -g ZESHY__ALIAS_EXPANSION

:global.document <<'/---'
:list ZESHY__ALIAS_NAMES

List of all function names for the currently declared alias, parsed from such
alias' prototype. This private global is intended to be referenced _only_ by
::alias().
/---
typeset -ga ZESHY__ALIAS_NAMES

:global.document <<'/---'
:string ZESHY__ALIAS_NAME

Current name for the currently declared alias, parsed from such alias'
prototype. This private global is intended to be referenced _only_ by
::alias().
/---
typeset -g ZESHY__ALIAS_NAME

# ....................{ DECLARERS ~ private                }....................
# Manually handle arguments passed to such function, as the aliases defining the
# types of such arguments (e.g., :string()) have yet to be defined.
:func_ '<is_args_unhandled> :void ::alias[
    args=( :string alias_type
           ^:map aliases_name
           :string alias_prototype
           :string alias_expansion)
    stdin=(:string alias_doc)]' :func{
# :func_ '<is_args_unhandled> :void ::alias(
#     :string alias_type="yamo"
#            ^:map aliases_name
#            :string alias_prototype
#            :string alias_expansion) stdin)' :func{
    # Localize arguments. Since
    # ::alias.document_prototype,stdin_of_type_if_found_or_noop() already
    # validates such type, avoid doing so here.
    ZESHY__ALIAS_TYPE="${1}"
    ZESHY__ALIAS_TO_EXPANSION_NAME="${2}"
    ZESHY__ALIAS_PROTOTYPE="${3}"
    ZESHY__ALIAS_EXPANSION="${4}"

    # If such aliases map is *NOT* a canonical zsh-specific map global, throw
    # an exception.
    [[ ${ZESHY__ALIAS_TO_EXPANSION_NAME} == ([gs]|)'aliases' ]] || :die\
        'Aliases map ${'${ZESHY__ALIAS_TO_EXPANSION_NAME}'} unrecognized (i.e., neither "aliases", "galiases", nor "saliases").'

    # If such prototype is syntactically invalid, throw an exception.
    [[ ${ZESHY__ALIAS_PROTOTYPE} =~\
       ${ZESHY_CALLABLE_PROTOTYPE_NAMES_PCRE} ]] ||\
       ::alias.die 'prototype invalid.'

    # If such prototype only declares one name, set such list to such name.
    if [[ -n ${match[1]-} ]] {
        # Set such list. See :list.set_to_string().
        ZESHY__ALIAS_NAMES=( "${match[1]}" )
    # Else, such prototype declares multiple comma-delimited names. Since
    # single- and double-quoted alias names may contain commas, such names must
    # be iteratively matched with a PCRE rather than split on commas.
    } else {
        # If such match failed to capture such names, throw an exception.
        (( ${#match} == 2 )) || ::alias.die 'names unparsable from prototype.'

        # Cache such names *BEFORE* pcre_match() overwrites ${match}. For
        # abject laziness, reuse existing string global ${ZESHY__ALIAS_NAME}
        # for such purposes.
        ZESHY__ALIAS_NAME="${match[2]}"

        # Clear such list.
        ZESHY__ALIAS_NAMES=()

        # Compile such PCRE. See above for further details.
        pcre_compile -- "${ZESHY_CALLABLE_PROTOTYPE_NAMES_NEXT_PCRE}"

        # Canonical string global ${ZPCRE_OP}, localized to avoid overwriting
        # either global or caller-specific versions of such variable.
        local ZPCRE_OP='0 0'

        # Match all names, appending each to such list.
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY__ALIAS_NAME}" } {
            ZESHY__ALIAS_NAMES+="${match[1]}"
        }
    }

    # For each such alias...
    for ZESHY__ALIAS_NAME ("${ZESHY__ALIAS_NAMES[@]}") {
        # Such aliases map keyed by such alias name (e.g., "aliases[:string]"),
        # escaping all map-reserved characters in such name (i.e., "[", "]").
        # Dismantled, this is:
        #
        # * "(#m)", capturing each matched "[" and "]" character to ${MATCH}.
        ZESHY__ALIAS_TO_EXPANSION_NAME_KEY=${ZESHY__ALIAS_TO_EXPANSION_NAME}'['${ZESHY__ALIAS_NAME//(#m)[\[\]]/\\${MATCH}}']'

        #FIXME: Arguably, we should also check the canonical list global of the
        #same name prefixed by "dis_" (e.g., ${dis_galiases}). However, this
        #requires redefining ${ZESHY__ALIAS_TO_EXPANSION_NAME_KEY}; since we
        #need to reuse the current value of such string, we should probably
        #define ${ZESHY__ALIAS_TO_EXPANSION_NAME_KEY} to the "dis_"-prefixed
        #version of such map key and test such key *BEFORE* redefining such
        #string to its intended map key as above. Currently, laziness previals.

        # If such alias already exists, throw an exception. See :map.is_key().
        (( ${(P)+ZESHY__ALIAS_TO_EXPANSION_NAME_KEY} == 0 )) ||
            ::alias.die_of_redefinition ${(P)ZESHY__ALIAS_TO_EXPANSION_NAME_KEY}

        # Declare such alias by assigning to the appropriate key of such map.
        # See :string.set().
        #
        # Since aliases are unconditionally expanded at their point of use,
        # such declaration performs no parsing or syntactic validation of such
        # expansion and hence *ALWAYS* succeed.  Since *ALL* assignments
        # succeed and hence ignore errors incurred during such assignment, this
        # is a good thing. (For the same reason, functions *CANNOT* be reliably
        # declared by assigning to the appropriate key of canonical map global
        # ${functions}. Why? Because function declaration only succeeds on the
        # condition such function contains no syntactic errors, implying such
        # assignment to ignore erroneous function declarations.)
        : "${(P)ZESHY__ALIAS_TO_EXPANSION_NAME_KEY::=${ZESHY__ALIAS_EXPANSION}}"

        #FIXME: This is fairly lame. For one, such function fails to
        #distinguish between alias types; for another, a new function
        #:add_parcel_current_alias_command() should probably be defined passing
        #canonical global "${ZESHY_PARCEL_NAME}" to a new function
        #:add_parcel_alias_command().

        # Append such alias to the current parcel *AFTER* defining such alias.
        :parcel.add_alias_command "${ZESHY_PARCEL_NAME}" "${ZESHY__ALIAS_NAME}"
    }

    #FIXME: Optimize this away by inlining such logic above.

    # Document such aliases with such documentation *AFTER* successfully
    # defining such aliases above.
    ::alias,type.document_prototype_with_stdin_if_nonempty_or_noop\
        "${ZESHY__ALIAS_NAMES[@]}"\
        "${ZESHY__ALIAS_TYPE}"\
        "${ZESHY__ALIAS_PROTOTYPE}"

    # Clear globals declared above. Since clearing *ALL* such globals would be
    # needlessly inefficient, clear only that subset of globals inviting issues
    # elsewhere when left uncleared. See ::func_.stop() for similar logic.
    ZESHY__ALIAS_NAMES=()
    ZESHY__ALIAS_PROTOTYPE=

#FIXME: Update hideously obsolete documentation.
#FIXME: Add immediate example.
}:func <<'/---'
Declare all aliases specified by the passed alias prototype, documented by
http://asciidoc.org[AsciiDoc]-formatted standard input if passed or
undocumented otherwise. For convenience, consider passing such documentation as
a single- or double-quoted here-document: e.g.,

== Caveats ==

This function is a low-level helper intended to be called only by high-level
alias declarators (e.g., :alias_command.define()). For forwards compatibility
with future revisions, call such functions rather than this function.

== Aliases Map ==

The passed name of the canonical map global mapping aliases of the desired type
_must_ be one of the following strings:

* `aliases`, mapping command aliases. See :alias_command().
* `galiases`, declaring general aliases. See :alias_word()
* `saliases`, declaring suffix aliases. See :alias_command_filetype().

=== Builtin Alternatives ===

Technically, alias declaration is also implementable by calling the alias()
builtin rather than setting keys of canonical map globals. Indeed, global
declaration is implemented by calling the export(), float(), integer(), and
typeset() builtins as needed.

However, builtin-based alias declaration is both less efficient _and_ more
fragile than the map-based approach taken here. The former requires _all_
*alias-reserved characters* (i.e., characters reserved for use in `=`-delimited
alias declarations, including `"`, `=`, and whitespace) in alias names to be
explicitly escaped: e.g.,

.Alias-reserved Character Escaping
==========================================
[source]
------------------------------------------
>>> :string on_surety='ONLY[THE"MADMAN=IS"ABSOLUTELY]SURE.'
>>> on_surety="${on_surety//(#m)([\"=[:space:]])/\\${MATCH}}"
>>> alias -- "${on_surety}"=':string.output\
...     "I don't believe anything, but I have many suspicions."'
>>> 'ONLY[THE"MADMAN=IS"ABSOLUTELY]SURE.'
I don't believe anything, but I have many suspicions.
------------------------------------------
==========================================

== Alias Type ==

The passed type _must_ be one of the following strings:

* `command`, declaring command aliases. See :alias_command().
* `general`, declaring general aliases. See :alias_word()
* `suffix`, declaring suffix aliases. See :alias_command_filetype().

== Alias Name ==

The name(s) for such alias is parsed from (in order):

* If an optional prototype is passed, such prototype (e.g., the `:la_ss_az` in
  `:void :la_ss_az(:string lsz)`).
* Else if a prototype prefixes the passed non-optional documentation, such
  prototype (e.g., the `:5_meo_dmt` in
  `:void :5_meo_dmt(:string dmt)
  +
  Among the many mysteries and insults presented by DMT, it offers a final
  mockery of our drug laws: Not only have we criminalized naturally occurring
  substances, like cannabis; we have criminalized one of our own
  neurotransmitters.`).
* Else, an exception is thrown.

=== Alias Synonyms ===

As with function prototypes, such prototype may declare one or more names for
such alias (e.g., the `:ska_maria_pastora` and `:hojas_de_maria` in
`string {:ska_maria_pastora,:hojas_de_maria}()`)). If an optional expansion
is passed, all such names will be synonymously defined as aliases of the passed
type expanding to such expansion.

== Alias Documentation ==

The passed documentation consists of:

. An optional *alias prototype* in `zeshy`-specific C-like syntax consisting of
  one or more alias return types, one alias name, and zero or more alias
  arguments (e.g.,
  `string parable_of_the_box(integer derrick, character jensen)`), if such
  prototype was _not_ passed as an argument already.
. An *alias description* in http://asciidoc.org[AsciiDoc] syntax, augmented with
  `zeshy`-specific markup for cross-referencing other `zeshy` documentation
  (e.g., `The *box* is +full+ of salmon, and a *man* sits +atop+ the box.`).
  Since single- and double-quoted `zsh` string syntax conflicts with such syntax,
  consider passing such description to :alias_command() as a
  here-document on standard input instead.

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)].
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., ReturnTypes, Whitespace):

.Alias Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| AliasDocumentation    | <- | AliasPrototype Whitespace+ AsciiDoc
| AliasPrototype        | <- | Whitespace* ReturnTypes
                               Whitespace+ AliasName
                               Whitespace* AliasArgs
| AliasName             | <- | AlphanumericString
| AliasArgs             | <- | ArgumentList | ArgumentChannels
| AliasArgChannels      | <- | ``['' Whitespace* ( AliasArgChannel Whitespace*
                               ``,'' Whitespace*)* AliasArgChannel Whitespace*
                               ``]''
| AliasArgChannel       | <- | AliasArgChannelName Whitespace* ``:'' Whitespace*
                               (Argument | ArgumentList)
| AliasArgChannelName   | <- | ``args'' | ``argstring'' | ``stdin''
|===============================================================================

== Alias Prototypes and AsciiDoc ==

With only minor exception, alias prototypes and AsciiDoc support the same
syntax as that supported by function prototypes and AsciiDoc. See
:func_() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
# Declare an alias of the passed type residing in the current parcel with
# prototype and hence name parsed from the passed alias prototype _or_
# the non-optional documentation passed on standard input (e.g., as a
# here-document or -string), defined to expand to the passed optional expansion.
# If such expansion is _not_ passed, such alias must be manually defined (e.g.,
# by subsequently calling :alias_command()).

        #     # Such type, capitalized for readability.
        #     local alias_type=${(C)ZESHY__ALIAS_TYPE[1]}${ZESHY__ALIAS_TYPE[2,-1]}

        #     # Such alias' current definition, indented for readability.
        #     local alias_definition=${(P)ZESHY__ALIAS_TO_EXPANSION_NAME_KEY}
        #     ::string.indent alias_definition

        #     # Throw such exception.
        #     ::alias.die_of_definition ${(P)ZESHY__ALIAS_TO_EXPANSION_NAME_KEY}\
        #         ${ZESHY__ALIAS_NAME}'() already defined.'$'\n\n'${alias_type}' alias definition:'$'\n'${alias_definition}
        # }

            #FUXME: Actually do so! See ={*-func/die} for related logic.

    #FUXME: Generalize such exception handling into a new function
    #::alias.die_of_cause() defined in a new parcel ={die}.

        #FUXME: Sadly, this *STILL* isn't quite general enough. We'll probably
        #need to manually escape "]" characters in such alias name, at least.

        #FUXME: Arguably inefficient. Instead, we could simply have the callers
        #of this function pass the requisite zsh-specific builtin with optional
        #arguments as a single string argument (e.g., "alias -s"), and then
        #simply call such builtin. Significantly simpler, faster, and stabler.
        #No need for ensuring function existence or for calling such chain of
        #functions, for example.
        #
        #For related logic, see ={*-global}.
        #FUXME: When implementing such change, convert :alias_command() and
        #relatives to aliases, as in ={*-global/export}.

        # Function defining such alias.
        # alias_definer=":alias_${ZESHY__ALIAS_TYPE}.define"
        # :func.die_unless "${alias_definer}"

        # # Define such alias.
        # "${alias_definer}"\
        #     "${ZESHY__ALIAS_NAME}"\
        #     "${ZESHY__ALIAS_EXPANSION}"

        # Note such redefinition to also be implementable with the following
        # less efficient and considerably more fragile alternative, requiring
        # characters reserved for use in alias definitions (e.g., "=") to be
        # explicitly escaped rather than merely double- or single-quoted:
        #
        #    alias_name="${alias_name//(#m)([\"=[:space:]])/\\${MATCH}}"
        #    alias -- "${alias_name}"="${alias_code}"

        #FUXME: Generalize to support arbitrary map names. See ={*-set/prototype}
        #for the logic.

    #FUXME: Test for whether such alias has already been declared. To do so,
    #note that we actually can efficiently test map key existence *WITHOUT*
    #eval statements as follows:
    #
    #    >>> :map simo; simo=( 'kkb' 'zjzj' )
    #    >>> :string sri
    #    >>> sri='simo[kkb]'
    #    >>> print $(( ${(P)+sri} ))
    #    1
    #    >>> sri='simo[kki]'
    #    >>> print $(( ${(P)+sri} ))
    #    0
    #FUXME: Astonishing! Given that, we may now refactor :map.is_key() for
    #dramatically higher efficiency. Ya!

#FUXME: Optimize in a similar fashion to that of :func_() and ::global().

# :func_ ':void :alias_command[
#     args =  (`:string `alias_prototype,
#              `:string `alias_expansion),
#     stdin = (`:string `alias_asciidoc)]' :func{
#     ::alias 'command' "${@}"
# }:func <<'/---'
# /---

# :func_ ':void :alias_word[
#      args =  (`:string `alias_prototype,
#               `:string `alias_expansion),
#      stdin = (`:string `alias_asciidoc)]' :func{
#     ::alias 'general' "${@}"
# }:func <<'/---'

# :func_ ':void :alias_command_filetype[
#     args =  (`:string `alias_prototype,
#              `:string `alias_expansion),
#     stdin = (`:string `alias_asciidoc)]' :func{
#     ::alias 'suffix' "${@}"
# }:func <<'/---'

# :global.document <<'/---'
# :string ZESHY__ALIAS_NAMES_STRING
# 
# Comma-delimited string of all function names for the currently declared alias,
# parsed from such alias' prototype. This private global is intended to be
# referenced _only_ by ::alias().
# /---
# typeset -g ZESHY__ALIAS_NAMES_STRING

    #FUXME: While the codebase contains considerably fewer aliases than
    #functions, it still contains a great many aliases. In other words,
    #consider inlining such logic as done for functions.

    # # List of all alias names declared by such prototype.
    # :alias_prototype.set_attrs,names\
    #     "${alias_prototype}" alias_attrs alias_names

# ....................{ GLOBALS                            }....................
# Due to a chicken-and-the-egg problem, all such globals are subsequently
# documented under @{help} in the main codebase.

#FUXME: This has become non-orthogonal. We declare functions with merely
#:func() but aliases with :alias_command(); clearly, the latter should
#be renamed to merely :alias_command(). Note, however, that we already have a
#rudimentary low-level alias :alias_command() effectively equivalent to
#:alias_command.define(). Hence, perhaps we should (in order):
#
#* Rename :alias_command() to :alias_command.define().
#* Rename :alias_command() to :alias_command().

#FUXME: Refactor so as to pass ${alias_type} as the last rather than first
#argument.

    # Localize arguments. Since ::document_alias_typed_with_prototype,asciidoc()
    # already validates such type, do *NOT* bother doing so here.
    # local alias_type="${1}" alias_prototype="${2}" alias_code="${3}" alias_args

    # (( # == 3 )) || :die\
    #     'Expected one alias type, one alias prototype, and one alias expansion.'
    # (( # == 2 )) || :die\
    #     'Expected one alias prototype and one alias expansion.'

# [[ -n "${alias_name}" ]] || :die 'Alias name empty.'
    # (( # == 2 )) || :die 'Expected one alias name and one alias expansion.'
# one
# minor and one major exception. See declare_function() for all other details.
# 
# === Minor Exception ===
# 
# Function prototypes permit multiple names. Alias prototypes permit only one.
# 
# === Major Exception ===
# 
# #FUXME: *major sigh* None of this applies anymore, despite the intensity of the
# #effort devoted to its documentation. Thanks to dynamic block aliases, such
# #bereft nonesense as compacting all arguments into a single string argument.
# 
# Function prototypes permit only two argument channel names: `args` and `stdin`.
# Alias prototypes permit a third argument channel specific to herestring-driven
# aliases: `argstring`.
# 
# By design, zsh aliases are expanded inline and hence cannot accept arbitrary
# arguments not accepted by the commands such aliases expand to. As example, the
# alias `l` declared by `alias l=ls` accepts only the arguments accepted by
# command `ls` -- no more, no less.
# 
# Herestring-driven aliases circumvent such constraints by accepting a single
# herestring argument embedding one or more ``real'' arguments to be passed such
# alias. Since such aliases _always_ accept a single herestring, declaring a
# single-string argument list conveys no meaningful information. Rather, such
# aliases should declare a herestring-specific argument channel `argstring`
# accepting the argument list embedded in such herestring. For clarity, consider
# optionally suffixing aliases defined in this way with `_from': e.g.,
# 
# .Herestring-driven Alias
# ==========================================
# [source]
# ------------------------------------------
# declare_alias '
# void set_args_to_string_split_on_words_from[
#     argstring: (string text1, string text2, ...)]
# 
# Set the current argument list to the passed strings split on shell words: e.g.,
# 
#     >>> string on_relations=\
#     ...    "All fixed, fast-frozen relations, with their train of ancient and
#     ...     venerable prejudices and opinions, are swept away, all new-formed
#     ...     ones become antiquated before they can ossify. All that is solid
#     ...     melts into air, all that is holy is profaned, and man is at last
#     ...     compelled to face with sober senses his real conditions of life, and
#     ...     his relations with his kind."
#     >>> set_args_to_string_split_on_words_from "${on_relations}"
#     >>> :string.output ${3}
#     fast-frozen
# '
# alias set_args_to_string_split_on_words_from='
# {
#     # Validate passed arguments.
#     list args__sltssowf
#     set_list_to_stdin_words args__sltssowf
#     (( ${#args__sltssowf} >= 1 )) or :die 'expected at least one string'
# 
#     # Temporary list to split such strings into.
#     list words__sltssowf
# 
#     # Split such strings.
#     set_list_to_string_words words__sltssowf "${args__sltssowf[@]}"
# 
#     # Set the current argument list to such words.
#     :args.set "${words__sltssowf[@]}"
# 
#     # Delete such temporary list.
#     undefine_variable words__sltssowf
# } <<<'
# ------------------------------------------
# ==========================================

    # Documentation passed on standard input.
    # ::help.set_to_stdin alias_asciidoc

#FUXME: Excise!
# Map each alias name to the help string documenting such alias.
# typeset -Ag ZESHY_ALIAS_NAME_TO_HELP

#FUXME: Excise!
# Map each alias name to the first name declared for such alias.
# typeset -Ag ZESHY_ALIAS_NAME_TO_ALIAS_NAME_FIRST

    # If such type is unrecognized, throw an exception.
    # [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
    #     'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

# function ::alias() {
#     # Validate sanity.
#     (( 1 <= # && # <= 3 )) || :die\
#         'Expected one alias type, optional alias prototype, and optional alias expansion.'
#     local\
#         alias_type="${1}"\
#         alias_prototype="${2-}"\
#         alias_expansion="${3-}"\
#         alias_help
#     local -a alias_help_match alias_names
# 
#     # If such type is unrecognized, throw an exception.
#     [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
#         'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'
# 
#     # Documentation passed on standard input.
#     ::help.set_to_stdin alias_help
# 
#     ::document_alias_typed_with_prototype,asciidoc
# 
#     #FUXME: Horrible. Refactor in terms of the following predefined setters:
#     #
#     #    :set_string_to_help_prototype()
#     #    :set_list_to_runnable_prototype_names()
#     #    :document_alias,type()
# 
#     # If passed a prototype, prefix such documentation with such prototype.
#     if (( # )) {
#         alias_help="${alias_prototype}"$'\n\n'"${alias_help}"
#     }
# 
#     # Match the alias name from the prototype prefixing such documentation or
#     # throw an exception if such match fails.
#     [[ "${alias_help}" =~ "${ZESHY_CALLABLE_PROTOTYPE_NAMES_PCRE}" ]] || :die\
#         'Alias prototype "'${alias_help}'" invalid.'
# 
#     # List of substrings captured by the prior match. The PCRE-based iteration
#     # performed by set_lists_to_runnable_prototype_name_or_names:() below
#     # overwrites ${match}, necessitating we preserve it here.
#     alias_help_match=( "${match[@]}" )
# 
#     # List of alias names declared by such prototype.
#     set_list_and_map_to_runnable_prototype_name_or_names:\
#         alias_names\
#         ZESHY_ALIAS_NAME_TO_ALIAS_NAME_FIRST\
#         "${alias_help_match[1]-}"\
#         "${alias_help_match[2]-}"
# 
#     # For each such name...
#     local alias_name
#     for   alias_name ("${alias_names[@]}") {
#         # If an expansion was passed for such alias, define such alias.
#         if [[ -n "${alias_expansion}" ]] {
#             # Function defining such alias.
#             local alias_definer=":define_alias_${alias_type}"
# 
#             # If such function does *NOT* exist, throw an exception. See
#             # :func.die_unless() for further details.
#             (( ${+functions[${alias_definer}]} )) || :die\
#                 'Function '${alias_definer}'() undefined.'
# 
#             # Define such alias.
#             "${alias_definer}" "${alias_name}" "${alias_expansion}"
#         }
# 
#         # Add such alias to the current parcel.
#         :parcel.add_alias_command "${ZESHY_PARCEL_NAME}" "${alias_name}"
#     }
# 
#     # Map the first such name to such documentation. See declare_function()
#     # for further details.
#     ZESHY_ALIAS_NAME_TO_HELP[${alias_names[1]}]="${alias_help}"
# }

#FUXME: Rename to ::alias,type_type().

#FUXME: Optional arguments are terrible. Require passed prototypes *AND*
#expansions. (If the caller only wants to document an existing alias, they can
#very well call :document_alias() -- which, of course, is how we should have
#designed such functionality originally. *sigh*)

#FUXME: Optional arguments are terrible. Require a passed prototype and *AND*
#expansion. See above.

# Declare a *suffix alias* (i.e., alias expanded when a file of such filetype is
# in command position) residing in the current parcel with prototype and hence
# name parsed from either the passed optional prototype _or_ the non-optional
# documentation passed on standard input (e.g., as a here-document or -string),
# defined to expand to the passed optional expansion. If such expansion is _not_
# passed, such alias must be manually defined (e.g., by subsequently calling
# :alias_command_filetype()). See ::alias() for further details: e.g,

# Declare a *global alias* (i.e., alias expanded in any position of a command)
# residing in the current parcel with prototype and hence name parsed from either
# the passed optional prototype _or_ the non-optional documentation passed on
# standard input (e.g., as a here-document or -string), defined to expand to the
# passed optional expansion. If such expansion is _not_ passed, such alias must
# be manually defined (e.g., by subsequently calling :alias_word()). See
# ::alias() for further details: e.g,

# Declare a *simple alias* (i.e., alias expanded only in command position)
# residing in the current parcel with prototype and hence name parsed from either
# the passed optional prototype _or_ the non-optional documentation passed on
# standard input (e.g., as a here-document or -string), defined to expand to the
# passed optional expansion. If such expansion is _not_ passed, such alias must
# be manually defined (e.g., by subsequently calling :alias_command()). See
# ::alias() for further details: e.g,

    #FUXME: Glob ${ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE} is insufficient.
    #Due to apparent laziness, such glob validates only the return type and
    #alias name but *NOT* alias arguments accepted by such argument. While
    #such validation isn't (yet) critical to operation, it could certainly
    #stand to be improved.

#FUXME: Create a new parcel tree @{*-define/*-alias} containing subparces
#@{simple}, @{global}, and @{suffix}, each providing declarators and definers
#specific to that alias type.
#FUXME: To readily create such parcels, define a new low-level helper
#::alias(). Such function should be called by high-level alias
#declarators (e.g., :alias_command()). The current implementation of
#:alias_command() should basically be shifted wholesale into
#::alias(). But how will ::alias() know which alias type to
#declare and define? Simple: it inspects the call stack, a method guaranteed to
#work both reliably and efficiently. This then reduces us to:
#
#function :alias_command() {
#    ::alias "${@}"
#}
#
#Pretty intense, eh?
#FUXME: Since this reduces such high-level declarators to effectively nothing,
#rename this parcel back to @{*-declare/*-alias} and define all such
#declarators in this parcel.

# names containing such characters requires explicitly escaping such characters
# and hence is neither intuitive or safe. This function amends this: e.g.,

    # If private variable ${zeshy_alias_type__} is undefined or not defined as
    # a string, the caller is *NOT* a high-level alias declarator as expected.
    # In such case, throw an exception. See :var.die_unless_type_string() for further
    # details.
    # [[ "${(t)zeshy_alias_type__-}" == 'scalar'* ]] || :die\
    #     'Variable ${zeshy_alias_type__} undefined or not a string, as not called by high-level alias declarator (e.g., :alias_command()).'

 # See :var.die_unless() for further
 #    # details.
 #    (( ${+zeshy_alias_type__} )) || :die\
    #FUXME: Support alias name synonyms.

    # If passed at least a prototype, handle such string. Since this is the
    # common case, test such condition first.
    # if (( # )) {
        # Localize such prototype and optional passed expansion.
        # alias_prototype__da="${1}"
        # alias_expansion__da="${2-}"

        # Match the alias name from such prototype prefixing such string or
        # throw an exception if such match fails.
#         [[ "${alias_prototype__da}" =~\
#            "${ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE}" ]] ||
#             die_for_declarator_type_with_help 'alias' "${help__da}"
# #       print -r -- "defined alias ${alias_name__da}:catch\"${alias_expansion__da}\""
#     # Else, only a help string was passed.
#     } else {

        # If also passed an expansion, handle such string.
        # if (( # == 2 )) {
        # }

# If such prototype is _not_ passed and such documentation is prefixed by no such
# prototype, an exception is thrown.
# 
# Declare the specified alias to be contained by the current parcel and documented
# by the passed help string, where such alias is specified by either:
# 
# * The passed alias prototype, if such argument is passed.
# * The alias prototype prefixing the passed help string, otherwise.
# 
# If an alias expansion is passed, define such alias to expand to such string;
# else, such alias must be subsequently defined: e.g,

    #FUXME: This function should also accept only two arguments (i.e., the same
    #as three arguments with an empty help string).

    # Validate sanity.
    # (( # == 1 || # == 3 )) || :die\
    #     'Expected either one help string or one alias prototype, one alias expansion, and one help string.'
    # local\
    #     help__da="${@[-1]}"\
    #     alias_prototype__da\
    #     alias_expansion__da\
    #     alias_name__da
    # local -a help_match__da alias_names__da

# :func.document <<'/---'
# void :alias_command[
#     args: (string alias_prototype = "",
#            string alias_expansion = ""),
#     stdin: string alias_asciidoc]
# 
# Declare the specified alias to be contained by the current parcel and documented
# by the passed help string, where such alias is specified as under
# declare_alias(). See :func.document() for further details.
# /---
# function :alias_command() {
#     run_runnable_with_stdin declare_alias "${@}"
# }

    #    # Sanitize such name, escaping all alias-reserved characters. Unlike
    #    # functions, merely double quoting alias names does *NOT* suffice.
    # Sanitize such name, escaping all alias-reserved characters. Unlike
    # functions, merely double quoting alias names does *NOT* suffice.
    # alias_name__dfa="${1//(#m)([\"=[:space:]])/\\${MATCH}}"
#   if [[ "${alias_name__dfa}" == *':'* ]] { print -r -- "colon alias: \"${alias_name__dfa}\"=\"${alias_expansion__dfa}\"" }

    #FUXME: Not fond of this approach. Just perform the following equivalent,
    #simpler, more efficient test:
    #
    #    if (( ${+aliases[${alias_name__dfa}]} )) {
    #
    #Do *NOT* adjust is_alias_nonsuffix() accordingly. Such function accepts
    #multiple arguments, which the above approach does not accomodate. (Note
    #this.)
    #FUXME: Incidentally, given the syntactic difficulties imposed by the
    #alias() builtin for defining alias names containing reserved characters,
    #it's probably *MUCH* simpler to define aliases dynamically be setting
    #the corresponding keys of map global ${aliases}: e.g.,
    #
    #    aliases[${alias_name__dfa}]="${alias_expansion__dfa}"
    #
    #That shouldn't require *ANY* of the above escaping, right? Test it out.
    # Technically, the following less
    # efficient alternative also suffices to implement such test:
    #
    #    if (( ${+aliases[${alias_name__dfa}]} +\
    #          ${+galiases[${alias_name__dfa}]} +\
    #          ${+dis_aliases[${alias_name__dfa}]} +\
    #          ${+dis_galiases[${alias_name__dfa}]} )) { ... }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :alias_command.redefine().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Sanitize such name, escaping all alias-reserved characters. Unlike
    # functions, merely double quoting alias names does *NOT* suffice.
    # alias_name__dfa="${1//(#m)([\"=[:space:]])/\\${MATCH}}"
#   if [[ "${alias_name__dfa}" == *':'* ]] { print -r -- "colon alias: \"${alias_name__dfa}\"=\"${alias_expansion__dfa}\"" }

    #FUXME: Not fond of this approach. Just perform the following equivalent,
    #simpler, more efficient test:
    #
    #    if (( ${+aliases[${alias_name__dfa}]} )) {
    #
    #Do *NOT* adjust is_alias_nonsuffix() accordingly. Such function accepts
    #multiple arguments, which the above approach does not accomodate. (Note
    #this.)
    #FUXME: Incidentally, given the syntactic difficulties imposed by the
    #alias() builtin for defining alias names containing reserved characters,
    #it's probably *MUCH* simpler to define aliases dynamically be setting
    #the corresponding keys of map global ${aliases}: e.g.,
    #
    #    aliases[${alias_name__dfa}]="${alias_expansion__dfa}"
    #
    #That shouldn't require *ANY* of the above escaping, right? Test it out.

    # If such alias already exists, throw an exception. See
    # is_alias_nonsuffix() for further details.
#     if { alias -- "${alias_name__dfa}" &>/dev/null } {
#         :die "Alias ${alias_name__dfa}() already exists:
# $(alias -- "${alias_name__dfa}")"
#     }

    # Map such alias to such help string.
#    ZESHY_ALIAS_NAME_TO_HELP[${alias_name__da}]="${help__da}"
#
#    # Add such alias to the current parcel.
#    :parcel.add_alias_command "${ZESHY_PARCEL_NAME}" "${alias_name__da}"

    # If such alias has already been declared, print a warning.
#    if (( ${+ZESHY_ALIAS_NAME_TO_HELP[${alias_name__da}]} )) {
#        print "zeshy: alias ${alias_name__da}() in parcel @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
#    }

# Global map from alias names to the help strings documenting such aliases. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.

#   if [[ "${alias_name__dfa}" == *':'* ]] { print -r -- "colon alias (before): \"${alias_name__dfa}\"=\"${alias_expansion__dfa}\"" }
#   if [[ "${alias_name__dfa}" == *'"'* ]] { print -r -- "quoted alias: ${alias_name__dfa}" }
#   print "define alias name: ${alias_name__dfa}"

#FUXME: It'd be great to support an optional suffixing argument to
#declare_alias(): the alias expansion to expand such alias to. This eliminates
#the unctuous duplication inherent in the current approach, while still
#admitting such approach. The resulting prototype would resemble:
#
#   void declare_alias(string alias_asciidoc, string expansion = "")
#
#Note this cannot be scaled to functions without stupid and extreme hardship
#(i.e., single- or double-quoting the entire function body *OR* escaping all
#shell-reserved characters in such body, which is equally absurd).
#FUXME: Actually, the above should be revised. Since alias prototype syntax is
#basically guaranteed *NOT* to conflict with zsh syntax, we want to change
#declare_alias() to support the following argument signature:
#
#void declare_alias(
#    string alias_prototype = "",
#    string alias_expansion = "",
#    string alias_asciidoc)
#
#For example, rather than:
#
#   :alias_command <<'/---'
#   [status: true] report_success()
#
#   Return from the current runnable with *success* (i.e., zero exit status).
#   /---
#   alias report_success="return ${ZESHY_STATUS_SUCCESS}"
#
#We would have:
#
#   :alias_command\
#       '[status: true] report_success()'\
#       "return ${ZESHY_STATUS_SUCCESS}" <<'/---'
#   Return from the current runnable with *success* (i.e., zero exit status).
#   /---
#
#Pretty awesome, no? At that point, we've basically invented a zsh prototyping
#language with real-world effects. *ALL* aliases should really be migrated to
#the above definition, to reduce codebase redundancy. (That said, we should
#continue to support the single-argument version for orthogonality with
#declare_function().)
#
#Note that this isn't simply to reduce redundancy, however. Consider deprecating
#aliases, which we'll certainly want to do at some point. To support alias
#depcrecation, declare_alias() requires the alias expansion, which it then
#prepends with a statement printing the desired deprecation message. Critical!

#Set the documentation for the alias named by the variable declaration prefixing
#standard input to such input. Consider calling this rather than declare_alias(),
#which requires passing a string argument rather than standard input. See
#:func.document() for further details.
        #FUXME: This could probably be generalized to support "="-delimited
        #assignment, but I have doubts as to whether that'd be widely useful.

    # Unless such string matches the function help PCRE, throw an exception.
#   [[ "${help__da}" =~\
#      "${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}" ]] ||
#       die_for_declarator_type_with_help 'alias' "${help__da}"
#   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
#       print "match ${match_index}: ${match[${match_index}]}"
#   }

#Set the documentation for the alias named by the alias prototype prefixing the
#passed string to such string. 
#by association with 
#only at the end of
#expressions, typically for filetypes).

    #FUXME: Fixup! We don't have to do much parsing here. Aliases can't be
    #globbable (as that's how we make things globbable in the first place) and
    #can't have synonyms, so we just need to parse the straightup alias name.
    #That still requires a bit of work, but by leveraging the above regular
    #expressions shouldn't be *TOO* terribly convoluted.
    #FUXME: O.K.; match similarly to declare_function() below, but using the
    #following PCRE instead: ${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}.
