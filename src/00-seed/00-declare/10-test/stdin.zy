#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under ={help} in the main codebase.

# ....................{ EXCEPTIONS                         }....................
# :void :stdin.die_unless_nonempty()
function :stdin.die_unless_nonempty() {
    die_if_args
    :stdin.is_nonempty :or :die 'Standard input unreadable without blocking.'
}

# ....................{ TESTERS                            }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# CAUTION: Ideally, a hypothetical :stdin.is_nonempty() function
# non-destructively testing whether at least one byte of standard input is
# readable in a non-blocking manner would be implemented here and then called
# widely throughout the codebase. Sadly, doing so deterministically and hence
# reliably is infeasible in *ALL* languages. This includes zsh. Why? Because of
# the following conflicting requirements:
#
# * Non-blocking testing requires immediacy.
# * Deterministic testing requires delaying indefinitely until the context on
#   the left-hand side of the pipe writing bytes to standard input has done. On
#   a system under:
#   * No load, this write typically consumes (0, 1] seconds.
#   * Heavy load, this write *COULD* consume (1, 10] seconds.
#
# Technically, there appears to be an edge-case exception to this
# non-deterministic behaviour: if standard input derives from a here-document or
# here-string, then zsh appears to synchronously and hence deterministically
# write the entirety of this input *BEFORE* running the context reading this
# input. In particular, the following code snippet *ALWAYS* succeeds in a
# deterministic, non-blocking, and non-destructive manner:
#
#     >>> { read -t 0 -k 1 -u 0 && print 'stdin: '$(:stdin) } <<< 'I am stdin.' 
#     stdin: I am stdin.
#
# Unfortunately, this fails to scale to standard input from any other source.
# Even if it did, the "-k 1" option destructively reads and hence consumes a
# character for all sources *EXCEPT* here-documents and here-strings.
#
# The only sane alternative is to simply test whether standard input is
# non-interactive and assume that, if this is the case, at least one byte of
# standard input is readable in a non-blocking manner.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#FIXME: Refactor this function as follows:
#
#* Switch the :is_stdin_noninteractive() function from
#  "00-seed/20-alias/io/standard.zy" to here. Do *NOT* shift any other functions
#  here. Ergo, that function must be refactored to be insular (i.e., reference
#  no external functions or globals). Maybe? I sure do dislike DRY. But I also
#  dislike the current separation between early-time functions and
#  documentation. We *REALLY* need to find a way to declare early-time
#  documentation in a sane manner. Do this, please.
#* Switch this function to "00-seed/20-alias/io/standard.zy", which remains
#  useful.
#* Shift this function's documentation from "help" into the same parcel. On
#  doing so, note that this function is safely callable *ONLY* iteratively.
#* Replace *ALL* calls to :stdin.is_nonempty() in the codebase  with calls to
#  :is_stdin_noninteractive() instead.
#* Rename :is_stdin_noninteractive() to :stdin.is_noninteractive().

# [status=:bool] :stdin.is_nonempty()
function :stdin.is_nonempty() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # Given the criticality and commonality of this test, one would assume there
    # to exist builtins or commands for accomplishing it. One would be wrong.
    # Testing whether this file descriptor and hence input is readable without
    # blocking requires calling the commonly available kernel function select().
    # Ideally, this test would elegantly reduce to the following:
    #
    #     read -t 0 -k 0
    #
    # Dismantled, this is:
    #
    # * "-t 0", testing whether standard input is readable without blocking and
    #   returning immediately if not.
    # * "-k 0", reading 0 bytes from standard input if this input is readable.
    #
    # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
    # bash, in which "read -t 0 -N 0" conditionally returns success when one
    # expects it to. Hence, this test defers to select() instead.
    #
    # Since zselect() (the zsh select() wrapper) returns failure with exit
    # status 2 when the underlying OS fails to provide a select() function,
    # capture and test this status rather than implicitly returning this status
    # as this function's exit status.
    #
    # Dismantled, this is:
    #
    # * "-r ...", testing standard input's canonical file descriptor for
    #   nonempty readability.
    # * "-t 0", reporting whether input bytes exist in a non-blacking manner
    #   (where "0" signifies 0 hundredths of a second wait time).
    # * "-a ...", setting this list to contain a string resembling either
    #   "-r 0" if standard input is nonempty or "" if standard input is empty.
    #   Since zselect() defaults this list to ${reply} if unpassed *AND* since
    #   this list is commonly used by callers and should *NOT* be overwritten by
    #   such a low-level function as this, explicitly specify this list. Since
    #   this function never references this list, our specifying it here is
    #   simply to avoid overwriting ${reply}. (Frankly, this "unique" choice of
    #   API design is one of the more eclectic that we've ever seen. And we were
    #   proficient in ML... once.)
    #
    # Thus doth another feeble mind break. (O^o)
    :list zselect_status
    zselect -r 0 -t 0 -a zselect_status :or {
        # Preserve the exit status reported by this builtin.
        :int exit_status=${status}

        # If this status indicates the current OS kernel to *NOT* provide this
        # function, throw an exception.
        if (( exit_status == 2 )) {
            :die 'Kernel function select() undefined.'
        }

        # Else, report this status. Technically, zselect() reports 0 if *ANY*
        # passed file descriptor is non-blockably readable and 1 otherwise.
        # Since this function tests only standard input, this status exactly
        # coincides with what the caller expects. (Scoooooore!)
        return ${exit_status}
    }
}

# ....................{ MAIN                               }....................
# Load module "zselect", providing builtin zselect() required by standard
# input-specific setters above (e.g., ::Doc.from_stdin()).
zmodload zsh/zselect
