#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *unexported global variable declarers* (i.e., functions declaring global
variables _not_ exported to the parent shell or script).
/---

#FIXME: Rename each alias declared below by replacing the "_" prefixing each
#"global" in such alias name by ".": e.g.,
#
#* Rename ":float_global" to ":float.global".
#* Rename ":listset_global" to ":listset.global".

#FIXME: *UGH*. Permitting multiple "="-delimited global variable names to be
#assigned the same value is syntax is silly. While feasible, it's fundamentally
#non-orthogonal with core zsh syntax for declaring local variable names and
#hence rather bad. Global variables should follow the exact same syntax as local
#variables; these sorts of syntactic disparities are to no one's benefit.
#Simplify, please.

# ....................{ DECLARERS                          }....................
:alias_command ':void :float_global(:string float_names_and_value)'\
    "::global :float 'typeset -Fg --'" <<'/---'
Globally declare all passed `=`-delimited float variables, initialized to the
`=`-prefixed value suffixing such string if any or 0 otherwise. See :float()
and :string_global().
/---

:alias_command ':void :int_global(:string int_names_and_value)'\
    "::global :int 'integer -g --'" <<'/---'
Globally declare all passed `=`-delimited integer variables, initialized to the
`=`-prefixed value suffixing such string if any or 0 otherwise. See :int() and
:string_global().
/---

:alias_command ':void :map_global(:string map_names)'\
    "::global :map 'typeset -gA --'" <<'/---'
Globally declare all passed `=`-delimited map variables, initialized to the
empty map. See :map() and :string_global().
/---

:alias_command ':void :string_global(:string string_names_and_value)'\
    "::global :string 'typeset -g --'" <<'/---'
Globally declare all passed `=`-delimited string variables, initialized 
to the `=`-prefixed *value* (i.e., float, integer, or single- or double-quoted
string) suffixing such string if any or the empty string otherwise: e.g.,

.:string_global()
==========================================
[source]
------------------------------------------
>>> :string_global ON_DEBATE=ON_DISSIDENCE=\
... "The smart way to keep people passive and obedient is to strictly limit the
...  spectrum of acceptable opinion, but allow very lively debate within that
...  spectrum â€“ even encourage the more critical and dissident views." <<'//---'
... That gives people the sense that there's free thinking going on, while all
... the time the presuppositions of the system are being reinforced by the
... limits put on the range of the debate.
... //---
>>> :string.is_equals "${ON_DEBATE}" "${ON_DISSIDENCE}" :and :string.output\
...     "Those who are able to see beyond the shadows and lies of their
...      culture will never be understood, let alone believed, by the masses."
Those who are able to see beyond the shadows and lies of their
culture will never be understood, let alone believed, by the masses.
------------------------------------------
==========================================
/---

# ....................{ DECLARERS ~ list                   }....................
:alias_command ':void :list_global(:string list_names)'\
    "::global :list 'typeset -ga --'" <<'/---'
Globally declare all passed `=`-delimited list variables, initialized to the
empty list.

See :list() and :string_global().
/---

#FIXME: Redefine such alias in terms of ::global() or a new function similar to
#::global() specific to tied variables. For now, the following suffices.

:alias_command ':void :string_global,list_global_tied_on_char(
    :string string_name_and_value
    :string list_name
    :char separator=":")'\
    'typeset -Tg --' <<'/---'
Globally declare the passed string and list variables ``tied'' on the passed
separating character (defaulting to `:`), overwriting any prior values for
either variables if previously declared. See :string,list_tied_on_char() and :string_global().
/---

# ....................{ DECLARERS ~ listset                }....................
#FIXME: Define equivalent :string_global,listset_global_tied_on_char()
#declarers. As :{compile} demonstrates, "typeset -gTU --" actually works (i.e.,
#the "-U" properly applies to the list but not string).

:alias_command ':void :listset_global(:string var_names)'\
    "::global :list 'typeset -gaU --'" <<'/---'
Globally declare all passed `=`-delimited listset variables, initialized to the
empty list. See :listset() and :string_global().
/---

# ....................{ DECLARERS ~ sub                    }....................
:alias_command ':void :char_global(:string var_names_and_value)'\
    "::global :char 'typeset -g --'" <<'/---'
Globally declare all passed `=`-delimited character variables, initialized to
the `=`-prefixed value suffixing such string if any or ${false} otherwise. See
:char() and :string_global().
/---

:alias_command ':void :bool_global(:string var_names_and_value)'\
    "::global :bool 'integer -g --'" <<'/---'
Globally declare all passed `=`-delimited boolean variables, initialized to the
`=`-prefixed value suffixing such string if any or ${false} otherwise. See
:bool() and :string_global().
/---

:alias_command ':void :file_descriptor_global(
    :string var_names_and_value)'\
    "::global :file_descriptor 'integer -g --'" <<'/---'
Globally declare all passed `=`-delimited file descriptor variables,
initialized to the `=`-prefixed value suffixing such string if any or 0
otherwise. See :file_descriptor() and :string_global().
/---

# --------------------( WASTELANDS                         )--------------------
# == Caveats ==
# 
# Unlike scalar globals, map globals are nonscalar and hence _cannot_ be
# initialized at declaration time (e.g., by suffixing the passed `=`-delimited
# variable names by a `=`-prefixed value). See :map().

# == Caveats ==
# 
# Unlike scalar globals, list globals are nonscalar and hence _cannot_ be
# initialized at declaration time (e.g., by suffixing the passed `=`-delimited
# variable names by a `=`-prefixed value). See :list().
