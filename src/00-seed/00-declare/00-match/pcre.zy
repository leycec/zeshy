#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by alias, function, and global declarers.

#FIXME: Add support for "-"-prefixed *NEGATIVE* argument type validations (i.e.,
#testers validating an argument to *NOT* be of a certain type): e.g.,
#
#    # This prototype validates the first argument to *NOT* be the name of an
#    # existing function.
#    :void :func.define(:str-:func.is func_name :str func_body)
#
#Currently, we only support "+"-prefixed *POSITIVE* argument type validations
#(i.e., testers validating an argument to be of a certain type): e.g.,
#
#    # This prototype validates the first argument to be the name of an
#    # existing function.
#    :void :func.redefine(:str++:func.is func_name :str func_body)

#FIXME: We need to support disjunctive prototypes. Consider this function,
#which can be called in at least two fundamentally distinct ways. To permit
#this, I suggest extending our "{...,...}" syntax yet again as follows:
#
#    {
#        :void :global.declare(
#            :str global_type
#            :str global_name_with_optional_value
#            :str documentation
#        )
#        :void :global.declare(:str documentation)
#    }
#
#We *REALLY* don't want to have to implement a non-regular context-free parser.
#Fortunately, we won't have to. Simply hard-code an outermost "(...|...)"-style
#PCRE, where the first sub-PCRE in such PCRE matches the conventional singular
#prototype (i.e., lacking exterior "{" and "}" delimeters) and the final
#sub-PCRE in such PCRE matches the above plural prototype (i.e., with exterior
#"{" and "}" delimeters).

# ....................{ GLOBALS                            }....................
#FIXME: All such globals are private and hence should be renamed (e.g., from
#${ZY_GLOBAL_PROTOTYPE_PCRE} to ${ZY__GLOBAL_PROTOTYPE_PCRE}).
#FIXME: Document all remaining globals.

# PCREs matching prototype syntax.
typeset -g\
    ZY_GLOBAL_PROTOTYPE_PCRE\
    ZY__CALLABLE_PROTOTYPE_PCRE\
    ZY_GLOBAL_HELP_PROTOTYPE_NAMES_PCRE\
    ZY_CALLABLE_PROTOTYPE_ATTRS_NAMES_PCRE\
    ZY_CALLABLE_PROTOTYPE_NAME_PCRE\
    ZY_CALLABLE_PROTOTYPE_NAME_SUFFIXED_PREFIXED_PCRE\
    ZY_CALLABLE_PROTOTYPE_NAMES_PCRE

# Globs matching prototype syntax.
typeset -g\
    ZY__CALLABLE_PROTOTYPE_ARG_DEFAULTABLE_GLOB\
    ZY__CALLABLE_PROTOTYPE_ARG_OPTIONAL_GLOB\
    ZY__CALLABLE_PROTOTYPE_ARG_OPTIONAL_SCALAR_GLOB\
    ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_GLOB

# Characters comprising prototype syntax.
typeset -g\
    ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_MANDATORY_PREFIX\
    ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_OPTIONAL_PREFIX\
    ZY__CALLABLE_PROTOTYPE_ARG_SCALAR_OPTIONAL_PREFIX\
    ZY__CALLABLE_PROTOTYPE_ARG_SUBTYPE_MAJOR_PREFIX\
    ZY__CALLABLE_PROTOTYPE_ARG_SUBTYPE_MINOR_PREFIX\
    ZY__CALLABLE_PROTOTYPE_ARG_SUBNAME_PARAM_PREFIX

# ....................{ MAIN                               }....................
# Define such PCREs in an anonymous block, allowing definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
   #FIXME: Iterative PCREs (e.g., ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE})
   #should *ALWAYS* start with "\G", anchoring such PCREs to the first
   #character following the last character of the prior match. This isn't
   #merely an efficiency concern (though it is that): it's essential to avoid
   #matching erroneously. See ${pcre_options_anchored} in preprocessor PCREs.

    # ..................{ CORE                               }..................
    # PCRE options. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   tiresome default, "." matches all characters excluding newline.)
    local pcre_options='(?s)'

    # Empty string, captured as a group. Since libpcre already captures the
    # empty string to unmatched groups (excluding trailing unmatched groups,
    # which are detectable with ${#match}), this PCRE is typically only needed
    # to align group indices in a list of "(?|"-driven alternatives.
    local pcre_empty_group='()'

    # ..................{ CLASS                              }..................
    # Character class bodies intended to be embedded *ONLY* in positive
    # character classes (i.e., *NOT* prefixed by "^").

    # ..................{ CLASS ~ space                      }..................
    # Character class matching horizontal ASCII whitespace characters.
    local char_space_horizontal=' \t'

    # Character class matching vertical ASCII whitespace characters.
    local char_space_vertical='\r\n'

    # Character class matching ASCII whitespace characters.
    local char_space=${char_space_horizontal}${char_space_vertical}

    # ..................{ NOT                                }..................
    # Character class bodies intended to be embedded *ONLY* in negative
    # character classes (i.e., prefixed by "^"). Since escaped characters must
    # be explicitly matched and hence *NOT* implicitly matched by these
    # classes, these classes *MUST* contain the character escape "\".
    #
    # This is significant enough to warrant repeating, in bold plaintext:
    # *ALL NEGATIVE CHARACTER CLASSES OPERATING ON ZSH CODE MUST CONTAIN "\".*

    # ..................{ NOT ~ callable                     }..................
    # Character class matching invalid characters in unquoted callable names,
    # comprising only those characters explicitly conflicting with either
    # zeshy's callable prototype syntax or zsh's core syntax.
    local char_not_callable_name_unquoted='\\''"(){}[\]<>'${char_space}'$#|&*?;`!'

    # ..................{ SPACE                              }..................
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Note: All of the following whitespace-specific regular expressions have
    # been copied as is from the corresponding expressions for macro parsing.
    # Avoid changing these expressions; change those and copy again, please.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Horizontal or vertical whitespace ASCII character. Although the builtin
    # character type "\s" already matches both ASCII and non-ASCII whitespace,
    # the latter are inapplicable here. Since zsh lexes only ASCII whitespace
    # characters as whitespace *AND* since there exist substantially more
    # non-ASCII than ASCII whitespace characters, such characters are best
    # matched with explicit character classes instead.
    local pcre_space='['${char_space}']'

    # Horizontal ASCII whitespace character (i.e., space or tab). For
    # efficiency, omit non-ASCII horizontal whitespace characters and hence the
    # generic character type "\h". Since PCRE provides an option for preventing
    # "\R" but *NOT* "\h" from matching UTF-8-encoded characters, we have
    # little choice but to manually define such character class. See subsection
    # "Generic character types" at: http://www.pcre.org/pcre.txt
    local pcre_space_horizontal='['${char_space_horizontal}']'

    # One or two vertical ASCII whitespace characters. Specifically, either:
    #
    # * Unix-specific linefeed (i.e., "\n").
    # * Windows-specific carriage return followed by linefeed (i.e., "\r\n").
    local pcre_space_vertical='\R'
    # local pcre_space_vertical_grouped='('${pcre_space_vertical}')'

    # One or more horizontal or vertical whitespace ASCII characters.
    local pcre_spaces=${pcre_space}'++'

    # Zero or more horizontal or vertical whitespace ASCII characters.
    local pcre_spaces_optional=${pcre_space}'*+'

    # One or more horizontal whitespace characters.
    local pcre_spaces_horizontal=${pcre_space_horizontal}'++'

    # Zero or more horizontal whitespace characters.
    local pcre_spaces_horizontal_optional=${pcre_space_horizontal}'*+'

    # Any character other than a vertical whitespace character. While PCRE
    # provides no inverse of "\R" as it does with most other generic types
    # (e.g., "\S", "\H", "\V"), a customary negative character class suffices.
    local pcre_char_sans_space_vertical='[^'${char_space_vertical}']'

    # One or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments, single-quoted strings).
    local pcre_chars_sans_space_vertical=${pcre_char_sans_space_vertical}'++'

    # Zero or more characters other than vertical whitespace characters.
    local pcre_chars_sans_space_vertical_optional=${pcre_char_sans_space_vertical}'*+'

    # ..................{ SPACE ~ continuation               }..................
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Note: All of the following whitespace-specific regular expressions have
    # been copied as is from the corresponding expressions for macro parsing.
    # Avoid changing these expressions; change those and copy again, please.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Line continuation (i.e., an unescaped backslash followed by a newline),
    # continuing the command corresponding to the current line to the next
    # line. As discussed above, newlines preceded by two backslashes are *NOT*
    # line continuations and must *NOT* be matched as such.
    local pcre_continuation='\\'${pcre_space_vertical}

    # Line continuation followed by optional whitespace.
    local pcre_continuation_spaceable=${pcre_continuation}${pcre_spaces_optional}

    # Line continuation followed by optional horizontal whitespace.
    local pcre_continuation_spaceable_horizontal=${pcre_continuation}${pcre_spaces_horizontal_optional}

    # One or more line continuations.
    local pcre_continuations='(?>'${pcre_continuation}')++'

    # Zero or more line continuations.
    local pcre_continuations_optional='(?>'${pcre_continuation}')*+'

    # One or more line continuations, each followed by optional whitespace.
    local pcre_continuations_spaceable='(?>'${pcre_continuation_spaceable}')++'

    # Zero or more line continuations, each followed by optional whitespace.
    local pcre_continuations_spaceable_optional='(?>'${pcre_continuation_spaceable}')*+'

    # One or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_continuations_spaceable_horizontal='(?>'${pcre_continuation_spaceable_horizontal}')++'

    # Zero or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_continuations_spaceable_horizontal_optional='(?>'${pcre_continuation_spaceable_horizontal}')*+'

    # ..................{ SPACE ~ continuable                }..................
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Note: All of the following whitespace-specific regular expressions have
    # been copied as is from the corresponding expressions for macro parsing.
    # Avoid changing these expressions; change those and copy again, please.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # One or more whitespace characters *NOT* preceded by line continuations,
    # optionally interspersed by line continuations.
    local pcre_spaces_continuable=${pcre_spaces}${pcre_continuations_spaceable_optional}

    # One or more horizontal whitespace characters *NOT* preceded by line
    # continuations, optionally interspersed by line continuations.
    local pcre_spaces_horizontal_continuable=${pcre_spaces_horizontal}${pcre_continuations_spaceable_horizontal_optional}

    # Zero or more line continuations followed by one whitespace character,
    # principally intended for use in lookahead and lookbehind.
    local pcre_continuable_space=${pcre_continuations_optional}${pcre_space}

    # Positive lookahead requiring at least one whitespace character
    # (optionally preceded by line continuations) to match.
    local pcre_is_continuable_space='(?='${pcre_continuable_space}')'

    # Negative lookahead preventing any whitespace characters (optionally
    # preceded by line continuations) from matching.
    local pcre_not_continuable_space='(?!'${pcre_continuable_space}')'

    # Zero or more line continuations followed by one horizontal whitespace
    # character, principally intended for use in lookahead and lookbehind.
    local pcre_continuable_space_horizontal=${pcre_continuations_optional}${pcre_space_horizontal}

    # One or more whitespace characters optionally interspersed by line
    # continuations.
    local pcre_continuable_spaces=${pcre_continuations_optional}${pcre_spaces_continuable}

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations, comprising all whitespace delimiting one shell word
    # from another within a command.
    #
    # *THIS IS THE BIG ONE, FOLKS.*
    local pcre_continuable_spaces_horizontal=${pcre_continuations_optional}${pcre_spaces_horizontal_continuable}
    local pcre_continuable_spaces_horizontal_grouped='('${pcre_continuable_spaces_horizontal}')'

    # Zero or more whitespace characters *OR* line continuations.
    local pcre_continuable_spaces_optional='(?>'${pcre_spaces}'|'${pcre_continuation}')*+'

    # Zero or more horizontal whitespace characters *OR* line continuations.
    local pcre_continuable_spaces_horizontal_optional='(?>'${pcre_spaces_horizontal}'|'${pcre_continuation}')*+'
    local pcre_continuable_spaces_horizontal_optional_grouped='('${pcre_continuable_spaces_horizontal_optional}')'

    # ..................{ CHAR ~ literal                     }..................
    # Asterisk.
    local pcre_asterisk='\*'
    local pcre_asterisk_grouped='('${pcre_asterisk}')'

    # Equals sign preceded and followed by optional whitespace.
    local pcre_equals='='

    # Eroteme (i.e., question mark).
    local pcre_eroteme='\?'
    local pcre_eroteme_grouped='('${pcre_eroteme}')'

    # Plus sign preceded and followed by optional whitespace.
    local pcre_plus='\+'
    local pcre_plus_grouped='('${pcre_plus}')'

    # Forward slash preceded and followed by optional whitespace.
    local pcre_slash='/'

    # ..................{ CHAR ~ brace                       }..................
    # Left curly brace.
    local pcre_brace_left='\{'

    # Right curly brace.
    local pcre_brace_right='\}'

    # ..................{ CHAR ~ bracket                       }..................
    # Left square bracket.
    local pcre_bracket_left='\['

    # Right square bracket.
    local pcre_bracket_right='\]'

    # ..................{ CHAR ~ paren                        }..................
    # Left paren.
    local pcre_paren_left='\('

    # Right paren.
    local pcre_paren_right='\)'

    # ..................{ SEQUENCE                           }..................
    # Integer or float (i.e., real number).
    local pcre_number='-?+\d++(?>\.\d++)?+'

    # Escaped character (i.e., "\"-prefixed character). By matching all escaped
    # characters, this PCRE solves numerous issues commonly related to such
    # characters:
    #
    # * Escaped backslashes (i.e., "\\") must be matched before matching
    #   subsequent escaped characters, as the former effectively disable
    #   escaping (e.g., "\\n", an escaped backslash preceding the character "n"
    #   rather than an escaped newline).
    # * Line continuations (i.e., "\
    #   ") must be matched as insignificant unquoted characters rather than
    #   significant vertical whitespace.
    local pcre_char_escaped_prefix='\\'
    local pcre_char_escaped=${pcre_char_escaped_prefix}'.'

    # ..................{ QUOTES                             }..................
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/if_compile/*-macro/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local          pcre_quotes_single="'(?>[^']++|'')*+'"

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    local          pcre_quotes_double='"(?>[^"\\]++|'${pcre_char_escaped}')*+"'

    #FIXME: Theoretically, command substitutions can themselves contain command
    #substitutions. Clearly, matching such syntax will require context-free
    #matching leveraging PCRE subroutines. Happily, we've already authored such
    #subroutines for macro preprocessing; it seems unlikely that we'll be able
    #to perfectly reuse such PCREs here (due to substantial structural
    #differences between function prototypes and general-purpose zsh), but
    #perhaps we can? At the least, we should be able to repurpose such PCREs for
    #our specific needs here. *sigh*
    #FIXME: Since this is hardly pressing, just wait until we unify this parcel
    #with @{-macro}.

    # Double-quoted string in the above format, optionally containing command
    # substitutions themselves containing double-quoted strings (e.g.,
    # "We're $(on "a ladder to") God").
    local pcre_quotes_double_with_substitutions='"(?>\$\([^)]*+\)|[^"\\]++|'${pcre_char_escaped}')*+"'

    #FIXME: Unused, but preserved for its helpful documentation, which should
    #be moved to formal AsciiDoc.
    # Pseudo-type signifying such callable to return a maximal amount of data,
    # equivalent to explicitly specifying the return channel list
    # "[stdout = :str, stderr = :str, status = :int]".
    # local pcre_full=':full'

    #FIXME: Unused, but preserved for its helpful documentation, which should
    #be moved to formal AsciiDoc.
    # Pseudo-type signifying such callable to return a minimal amount of data,
    # equivalent to explicitly specifying the return channel list
    # "[stdout = :void, stderr = :void, status = :true]".
    #
    # Since the empty argument list "()" more orthogonally, concisely, and
    # readably signifies a callable to accept no arguments than the C-style
    # argument list "()", this pseudo-type only applies to return types.
    # local pcre_void=':void'

    # ..................{ CALLABLE                           }..................
    # One or more unescaped characters in a callable name (i.e., consecutive
    # run of characters *NOT* prefixed by "\" and hence unescaped).
    local pcre_callable_chars_unescaped='[^'${char_not_callable_name_unquoted}']++'

    # Callable name.
    local pcre_callable_name_unquoted='(?>'${pcre_callable_chars_unescaped}'|'${pcre_char_escaped}')++'

    # ..................{ OPERABLE ~ type                    }..................
    # Operable (i.e., alias, function, variable) type. Note that this PCRE is
    # *NOT* intended to match the actual zsh syntax for operable types --
    # which, since zeshy defines such types by simple aliases, technically
    # include single- and double-quoted strings. Rather, this PCRE only matches
    # the subset of characters zeshy names such types with (i.e., alphanumeric
    # letters, underscore, hyphen, and colon).
    local pcre_operable_type='[a-zA-Z0-9-_:]++'
    local pcre_operable_type_grouped='('${pcre_operable_type}')'

    # Operable type prefixed by a forward slash.
    local         pcre_operable_type_slash_optional='(?>'${pcre_slash}${pcre_operable_type}')?+'
    local pcre_operable_type_slash_optional_grouped='(?>'${pcre_slash}${pcre_operable_type_grouped}')?+'

    # Operable type prefixed by an at sign.
    local         pcre_operable_type_at_optional='(?>'${pcre_plus}${pcre_operable_type}')?+'
    local pcre_operable_type_at_optional_grouped='(?>'${pcre_plus}${pcre_operable_type_grouped}')?+'

    # ..................{ OPERABLE ~ name                    }..................
    # Operable name, principally callable argument names. This PCRE matches all
    # characters matched by ${pcre_operable_type} excluding colon, as argument
    # names (hypothetically) correspond to local variable names and hence
    # prohibit colons. As above, this PCRE is *NOT* intended to match the full
    # gamut of actual zsh syntax. See ${pcre_global_name} below.
    local pcre_operable_name='[a-zA-Z0-9-_]++'
    local pcre_operable_name_grouped='('${pcre_operable_name}')'

    # Operable name prefixed by a forward slash.
    local         pcre_operable_name_slash_optional='(?>'${pcre_slash}${pcre_operable_name}')?+'
    local pcre_operable_name_slash_optional_grouped='(?>'${pcre_slash}${pcre_operable_name_grouped}')?+'

    # Operable name prefixed by an at sign.
    local         pcre_operable_name_at_optional='(?>'${pcre_plus}${pcre_operable_name}')?+'
    local pcre_operable_name_at_optional_grouped='(?>'${pcre_plus}${pcre_operable_name_grouped}')?+'

    # ..................{ GLOBAL                             }..................
    # Global variable. Such syntax mimics conventional "="-delimited variable
    # assignments in zsh and hence prohibits whitespace. Note that such
    # assignments accept either:
    #
    # * Single-quoted strings.
    # * Double-quoted strings.
    # * Unquoted strings containing no whitespace, including but *NOT* limited
    #   to integers and floats. Variable assignment syntax thus differs from
    #   that of default argument syntax.

    # Global variable names.
    local pcre_global_type=${pcre_operable_type}
    local pcre_global_type_grouped='('${pcre_global_type}')'

    # Global variable names.
    local pcre_global_name=${ZY_VAR_NAME_PCRE}
    local pcre_global_name_grouped='('${pcre_global_name}')'

    #FIXME: This is probably terrible. Excise, please.
    #FIXME: At the very least, we only want to match a list of global names.
    #Premature optimization is premature. (No more complexity, please.)

    # One or more global variable names.
    local pcre_global_names_grouped='((?>'${pcre_global_name}${pcre_equals}')*+'${pcre_global_name}')'
    local pcre_global_name_or_names_grouped='(?>'${pcre_global_name_grouped}'|'${pcre_global_names_grouped}')'

    #FIXME: This is probably terrible. Excise, please.

    # Global variable value.
    local       pcre_global_value_optional='(?>'${pcre_equals}'(?>'${pcre_quotes_double}'|'${pcre_quotes_single}'|\S++))?+'
    local pcre_global_value_optional_grouped='(?>'${pcre_equals}'('${pcre_quotes_double}'|'${pcre_quotes_single}'|\S++))?+'

    # ..................{ RETURN ~ type                      }..................
    # Return type. Zeshy currently prohibits single- and double-quoted
    # return types, simplifying matching.
    local            pcre_return_type=${pcre_operable_type}
    local pcre_return_type_grouped='('${pcre_operable_type}')'

    # ..................{ RETURN ~ channel                   }..................
    # Return channel name (e.g., ":stdout").
    local            pcre_return_channel_name=${pcre_operable_name}
    local pcre_return_channel_name_grouped='('${pcre_operable_name}')'

    # Return channel.
    local         pcre_return_channel=${pcre_return_channel_name}${pcre_equals}${pcre_return_type}
    local pcre_return_channel_grouped=${pcre_return_channel_name_grouped}${pcre_equals}${pcre_return_type_grouped}

    # Return channel list prefix.
    local pcre_return_channel_list_prefix=${pcre_bracket_left}${pcre_spaces_optional}

    # Return channel list suffix.
    local pcre_return_channel_list_suffix=${pcre_spaces_optional}${pcre_bracket_right}

    # Return channel list.
    local pcre_return_channel_list=${pcre_return_channel}'(?>'${pcre_spaces}${pcre_return_channel}')*+'
    local pcre_return_channel_list_grouped='('${pcre_return_channel_list}')'

    # Return channels.
    local         pcre_return_channels=${pcre_return_channel_list_prefix}${pcre_return_channel_list}${pcre_return_channel_list_suffix}
    local pcre_return_channels_grouped=${pcre_return_channel_list_prefix}${pcre_return_channel_list_grouped}${pcre_return_channel_list_suffix}

    # ..................{ RETURN                             }..................
    # Return type or channel.
    local         pcre_return_type_or_channels='(?>'${pcre_return_type}'|'${pcre_return_channels}')'${pcre_continuable_spaces_horizontal}
    local pcre_return_type_or_channels_grouped='(?>'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')'${pcre_continuable_spaces_horizontal}

    # ..................{ NAME                               }..................
    # While zsh permits zeshy unquoted alias and function names to contain a
    # surprisingly wide array of characters, zeshy constrains these names so as
    # to avoid conflict with other prototype syntax. Since zsh permits single-
    # and double-quoted alias and function names to contain arbitrary and hence
    # all possible characters, matching these names requires more than merely
    # class negation.
    #
    # While zsh only supports synonymous functions (e.g.,
    # "function name1 name2() { ... }"), there exists no reason *NOT* to extend
    # such support to aliases as well. (So, we do.)

    # Name.
    local         pcre_callable_name='(?>'${pcre_callable_name_unquoted}'|'${pcre_quotes_double}'|'${pcre_quotes_single}')'
    local   pcre_callable_name_grouped='('${pcre_callable_name_unquoted}'|'${pcre_quotes_double}'|'${pcre_quotes_single}')'

    # Name list prefix.
    local pcre_callable_name_list_prefix=${pcre_brace_left}${pcre_spaces_optional}

    # Name list suffix.
    local pcre_callable_name_list_suffix=${pcre_spaces_optional}${pcre_brace_right}

    # Name list.
    local pcre_callable_name_list=${pcre_callable_name}'(?>'${pcre_spaces}${pcre_callable_name}')*+'
    local pcre_callable_name_list_grouped='('${pcre_callable_name_list}')'

    # Names.
    local pcre_callable_names_grouped=${pcre_callable_name_list_prefix}${pcre_callable_name_list_grouped}${pcre_callable_name_list_suffix}

    # Name or names. Since the former is *NOT* brace-delimited and the latter
    # is, both must be explicitly and independently matched.
    local pcre_callable_name_or_names_grouped='(?>'${pcre_callable_name_grouped}'|'${pcre_callable_names_grouped}')'${pcre_continuable_spaces_horizontal_optional}

    # ..................{ ARG ~ subtype                      }..................
    # Character prefixing argument major subtypes.
    ZY__CALLABLE_PROTOTYPE_ARG_SUBTYPE_MAJOR_PREFIX=${pcre_slash}

    # Character prefixing argument minor subtypes.
    ZY__CALLABLE_PROTOTYPE_ARG_SUBTYPE_MINOR_PREFIX=${pcre_plus}

    # Mandatory local argument subtype, signifying the type of the local
    # variable to which this argument's value will be assigned in this
    # function's preamble.
    local pcre_arg_subtype_local=${pcre_operable_type}
    local pcre_arg_subtype_local_grouped=${pcre_operable_type_grouped}

    # Optional major argument subtype, signifying the ".is_"-suffixed prefix of
    # the name of the function validating this argument's value (e.g., the
    # ":int" in :int.is_positive()). Defaults to this argument's local subtype.
    local pcre_arg_subtype_major_optional=${pcre_operable_type_slash_optional}
    local pcre_arg_subtype_major_optional_grouped=${pcre_operable_type_slash_optional_grouped}

    # Optional minor argument subtype, signifying the ".is_"-prefixed suffix of
    # the name of the function validating this argument's value (e.g., the
    # ":positive" in :int.is_positive()). Defaults to the empty string.
    local pcre_arg_subtype_minor_optional=${pcre_operable_type_at_optional}
    local pcre_arg_subtype_minor_optional_grouped=${pcre_operable_type_at_optional_grouped}

    # Argument subtypes. For example, an argument with a subtypes substring
    # ":str/:int@positive" would:
    #
    # * Localize that argument as a local ":str" variable.
    # * Validate that argument by calling the :int.is_positive() function.
    local          pcre_arg_subtypes=${pcre_arg_subtype_local}${pcre_arg_subtype_major_optional}${pcre_arg_subtype_minor_optional}
    local pcre_arg_subtypes_grouped=${pcre_arg_subtype_local_grouped}${pcre_arg_subtype_major_optional_grouped}${pcre_arg_subtype_minor_optional_grouped}

    # ..................{ ARG ~ type                         }..................
    # Mandatory variadic pseudo-argument modifier. If specified and this
    # pseudo-argument's subtype is:
    #
    # * ":list", such argument comprises one or more passed scalar arguments.
    #   "+:list" has no equivalent in most high-level languages.
    # * ":map", such argument comprises one or more passed keyword arguments.
    #   "+:map" has no equivalent in most high-level languages.
    # * Anything else, an exception is thrown.
    ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_MANDATORY_PREFIX='+'
    local pcre_arg_variadic_mandatory_grouped=${pcre_plus_grouped}

    # Missable variadic pseudo-argument modifier. If specified and such
    # pseudo-argument's subtype is:
    #
    # * ":list", such argument comprises zero or more passed scalar arguments.
    #   "*:list" is equivalent to Python's pseudo-argument "*args".
    # * ":map", such argument comprises zero or more passed keyword arguments.
    #   "*:map" is equivalent to Python's pseudo-argument "**kwargs".
    # * Anything else, an exception is thrown.
    ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_OPTIONAL_PREFIX='*'
    local pcre_arg_variadic_missable_grouped=${pcre_asterisk_grouped}

    # Missable argument, signifying such argument to be both optional *AND*
    # assigned no default value if unpassed.
    ZY__CALLABLE_PROTOTYPE_ARG_SCALAR_OPTIONAL_PREFIX='?'
    local pcre_arg_nonvariadic_missable_grouped=${pcre_eroteme_grouped}

    # Argument type prefix.
    #
    # Note that the "^" prefix signifying indirect argument types is optionally
    # matched *AFTER* matching this prefix, permitting such types to be
    # modified by this prefix (e.g., "*^:int int_names", an optional variadic
    # list of integer variable names).
    local pcre_arg_type_prefix='['${ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_MANDATORY_PREFIX}${ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_OPTIONAL_PREFIX}${ZY__CALLABLE_PROTOTYPE_ARG_SCALAR_OPTIONAL_PREFIX}']'
    local pcre_arg_type_prefix_grouped='(?>'${pcre_arg_variadic_mandatory_grouped}'|'${pcre_arg_variadic_missable_grouped}'|'${pcre_arg_nonvariadic_missable_grouped}')'

    # Optional argument type prefix followed by optional whitespace.
    local         pcre_arg_type_prefix_optional=${pcre_arg_type_prefix}'?+'
    local pcre_arg_type_prefix_optional_grouped=${pcre_arg_type_prefix_grouped}'?+'

    # Argument type.
    local         pcre_arg_type=${pcre_arg_type_prefix_optional}${pcre_arg_subtypes}
    local pcre_arg_type_grouped=${pcre_arg_type_prefix_optional_grouped}${pcre_arg_subtypes_grouped}

    # ..................{ ARG ~ name                         }..................
    # Character prefixing argument parameter subnames.
    ZY__CALLABLE_PROTOTYPE_ARG_SUBNAME_PARAM_PREFIX=${pcre_slash}

    # Mandatory local argument subname, signifying the name of the local
    # variable this argument will be declared as in this function's preamble.
    local pcre_arg_name_local=${pcre_operable_name}
    local pcre_arg_name_local_grouped=${pcre_operable_name_grouped}
    
    # Optional parameter argument subname, signifying the name of the external
    # parameter this argument will be documented as in user documentation.
    local pcre_arg_name_param_optional=${pcre_operable_name_slash_optional}
    local pcre_arg_name_param_optional_grouped=${pcre_operable_name_slash_optional_grouped}

    # Argument name.
    local                 pcre_arg_name=${pcre_arg_name_local}${pcre_arg_name_param_optional}
    local pcre_arg_name_grouped=${pcre_arg_name_local_grouped}${pcre_arg_name_param_optional_grouped}

    # ..................{ ARG ~ default                      }..................
    # Default argument value literal.
    local       pcre_arg_default_value='(?>'${pcre_quotes_double_with_substitutions}'|'${pcre_quotes_single}'|'${pcre_number}')'
    local pcre_arg_default_value_grouped='('${pcre_quotes_double_with_substitutions}'|'${pcre_quotes_single}'|'${pcre_number}')'

    # Default argument value.
    local         pcre_arg_default=${pcre_equals}${pcre_arg_default_value}
    local pcre_arg_default_grouped=${pcre_equals}${pcre_arg_default_value_grouped}

    # Optional default argument value.
    local         pcre_arg_default_optional='(?>'${pcre_arg_default}')?+'
    local pcre_arg_default_optional_grouped='(?>'${pcre_arg_default_grouped}')?+'

    # ..................{ ARG                                }..................
    # Argument.
    local         pcre_arg=${pcre_arg_type}${pcre_spaces}${pcre_arg_name}${pcre_arg_default_optional}
    local pcre_arg_grouped=${pcre_arg_type_grouped}${pcre_spaces}${pcre_arg_name_grouped}${pcre_arg_default_optional_grouped}

    # ..................{ ARGS ~ list                        }..................
    # Argument list prefix.
    local pcre_arg_list_prefix=${pcre_paren_left}${pcre_spaces_optional}

    # Argument list suffix.
    local pcre_arg_list_suffix=${pcre_spaces_optional}${pcre_paren_right}

    # Argument list of one or more arguments. To permit reuse of the same PCRE
    # for capturing both entire argument lists and first arguments in such
    # lists, the first argument is captured here.
    local               pcre_arg_list=${pcre_arg}'(?>'${pcre_spaces}${pcre_arg}')*+'
    local pcre_arg_list_grouped_first=${pcre_arg_grouped}'(?>'${pcre_spaces}${pcre_arg}')*+'

    # Argument list of zero or more arguments.
    local             pcre_arg_list_optional='(?>'${pcre_arg_list}')?+'
    local       pcre_arg_list_optional_grouped='('${pcre_arg_list}')?+'
    local pcre_arg_list_optional_grouped_first='('${pcre_arg_list_grouped_first}')?+'

    # Arguments.
    local               pcre_args=${pcre_arg_list_prefix}${pcre_arg_list_optional}${pcre_arg_list_suffix}
    local       pcre_args_grouped=${pcre_arg_list_prefix}${pcre_arg_list_optional_grouped}${pcre_arg_list_suffix}
    local pcre_args_grouped_first=${pcre_arg_list_prefix}${pcre_arg_list_optional_grouped_first}${pcre_arg_list_suffix}
    # print -r 'args PCRE: '${pcre_args_grouped}$'\n'

    # ..................{ ARGS ~ channel                     }..................
    # Argument channel.
    local         pcre_arg_channel=${pcre_operable_name}${pcre_equals}${pcre_args}
    local pcre_arg_channel_grouped=${pcre_operable_name_grouped}${pcre_equals}${pcre_args_grouped}

    # Argument channel list prefix.
    local pcre_arg_channel_list_prefix=${pcre_bracket_left}${pcre_spaces_optional}

    # Argument channel list prefix.
    local pcre_arg_channel_list_suffix=${pcre_spaces_optional}${pcre_bracket_right}

    # Argument channel list of one or more channels.
    local         pcre_arg_channel_list=${pcre_arg_channel}'(?>'${pcre_spaces}${pcre_arg_channel}')?+'
    local pcre_arg_channel_list_grouped=${pcre_arg_channel_grouped}'(?>'${pcre_spaces}${pcre_arg_channel_grouped}')?+'

    # Argument channel list of zero or more channels.
    local         pcre_arg_channel_list_optional='(?>'${pcre_arg_channel_list}')?+'
    local pcre_arg_channel_list_optional_grouped='(?>'${pcre_arg_channel_list_grouped}')?+'

    # Argument channels.
    local         pcre_arg_channels=${pcre_arg_channel_list_prefix}${pcre_arg_channel_list_optional}${pcre_arg_channel_list_suffix}
    local pcre_arg_channels_grouped=${pcre_arg_channel_list_prefix}${pcre_arg_channel_list_optional_grouped}${pcre_arg_channel_list_suffix}

    # ..................{ ARGS                               }..................
    # Arguments or argument channels.
    local         pcre_args_or_channels='(?>'${pcre_args}'|'${pcre_arg_channels}')'
    local pcre_args_or_channels_grouped='(?>'${pcre_args_grouped_first}'|'${pcre_arg_channels_grouped}')'
    # print -r 'arg channels PCRE: '${pcre_arg_channels_grouped}$'\n'
    # print -r 'args or channels PCRE: '${pcre_args_or_channels_grouped}$'\n'

    # ..................{ ATTR                               }..................
    # Attribute name.
    local pcre_attr_name=${pcre_operable_name}

    # Mandatory attribute value.
    local pcre_attr_value=${pcre_equals}'(?>'${pcre_quotes_double}'|'${pcre_quotes_single}')'

    # Optional attribute value.
    local pcre_attr_value_optional='(?>'${pcre_attr_value}')?+'

    # Attribute, comprising a mandatory name and optional value.
    local pcre_attr=${pcre_attr_name}${pcre_attr_value_optional}

    # Attribute list.
    local pcre_attr_list=${pcre_attr}'(?>'${pcre_spaces}${pcre_attr}')*+'
    local pcre_attr_list_grouped='('${pcre_attr_list}')'

    # Attribute list prefix.
    local pcre_attr_list_prefix=${pcre_bracket_left}${pcre_spaces_optional}

    # Attribute list suffix.
    local pcre_attr_list_suffix=${pcre_spaces_optional}${pcre_bracket_right}

    # Attributes.
    local         pcre_attrs_optional='(?>'${pcre_continuable_spaces_horizontal}${pcre_attr_list_prefix}${pcre_attr_list}${pcre_attr_list_suffix}')?+'
    local pcre_attrs_optional_grouped='(?>'${pcre_continuable_spaces_horizontal}${pcre_attr_list_prefix}${pcre_attr_list_grouped}${pcre_attr_list_suffix}')?+'

    # ..................{ PCRE                               }..................
    # Note that there currently exists no ${pcre_end}, due to callable
    # prototypes being embedded at the start of callable documentation and
    # hence *NOT* anchorable to the end of such strings.

    # Callable prototype start, enabling PCRE options, matching only at the
    # start of such string, and optionally matching leading whitespace.
    local pcre_start=${pcre_options}'\G'${pcre_continuable_spaces_horizontal_optional}

    # ..................{ PCRE ~ global                      }..................
    #FIXME: This is probably terrible. Excise, please. To do so:
    #
    #1. Resurrect ${ZY_VAR_NAME_GLOB} from the wastelands.
    #2. Redefine this global in terms of the existing
    #   ${ZY__VAR_NAME_CLASS_FIRST} and ${ZY__VAR_NAME_CLASS_REST} globals.
    #3. Add this glob to "glob.zy" in this directory.
    #4. Refactor *-global/global.zy to use ${ZY_VAR_NAME_GLOB} instead.

    # PCRE capturing all names and optional value in global prototypes.
    ZY_GLOBAL_PROTOTYPE_PCRE=${pcre_global_name_or_names_grouped}${pcre_global_value_optional_grouped}

    # PCRE capturing all names in documentation-specific global prototypes
    # prefixed by a zeshy-style variable type and suffixed by *NO* optional
    # initial value.
    ZY_GLOBAL_HELP_PROTOTYPE_NAMES_PCRE=${pcre_operable_type}${pcre_spaces}${pcre_global_name_or_names_grouped}

    # ..................{ PCRE ~ callable                    }..................
    #FIXME: What? Why? Do we still need this?

    # PCRE capturing a single name in callable prototypes declaring only one
    # such name.
    ZY_CALLABLE_PROTOTYPE_NAME_PCRE=${pcre_start}${pcre_return_type_or_channels}${pcre_callable_name_grouped}${pcre_args_or_channels}${pcre_attrs_optional}

    #FIXME: What? Why? Do we still need this? This is almost certainly broken
    #now, thanks to rearrangement of capturing groups..

    # PCRE capturing a single name in callable prototypes declaring only one
    # such name *AND* the substrings prefixing and suffixing such name. To
    # assist subsequent substitutions, preserve otherwise negligible syntax and
    # whitespace in such prefix and suffix by expanding ungrouped rather than
    # grouped PCREs. (The latter discard all negligible syntax and whitespace.)
    ZY_CALLABLE_PROTOTYPE_NAME_SUFFIXED_PREFIXED_PCRE=${pcre_start}'('${pcre_return_type_or_channels}')'${pcre_callable_name_grouped}'('${pcre_args_or_channels}')'${pcre_attrs_optional}

    #FIXME: What? Why? Do we still need this? This is terrible. Just use
    #${ZY__CALLABLE_PROTOTYPE_PCRE} instead.

    # PCRE capturing all names in callable prototypes.
    ZY_CALLABLE_PROTOTYPE_NAMES_PCRE=${pcre_start}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels}${pcre_attrs_optional}

    #FIXME: What? Why? Do we still need this? This is terrible. Just use
    #${ZY__CALLABLE_PROTOTYPE_PCRE} instead.

    # PCRE capturing all attributes and names in callable prototypes.
    ZY_CALLABLE_PROTOTYPE_ATTRS_NAMES_PCRE=${pcre_start}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels}${pcre_attrs_optional_grouped}

    # PCRE capturing all relevant metadata from callable prototypes.
    ZY__CALLABLE_PROTOTYPE_PCRE=${pcre_start}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels_grouped}${pcre_attrs_optional_grouped}
    # print -r 'callable prototype PCRE: '$'\n'${ZY__CALLABLE_PROTOTYPE_PCRE}$'\n'

    # ..................{ GLOB ~ callable                    }..................
    # Glob matching all arguments assigned default values. Since equals signs
    # are prohibited in argument types but not names *AND* since the existence
    # of any equals sign anywhere in an argument type implies that argument to
    # be assigned a default value, this glob reduces to matching any equals
    # sign anywhere in both argument types and names. Note that this holds even
    # for arguments whose default values containing one or more equals signs
    # (e.g., ":str waaaaat='= omfg ='"). Simplicity === efficiency.
    ZY__CALLABLE_PROTOTYPE_ARG_DEFAULTABLE_GLOB='*'${pcre_equals}'*'

    # Glob matching all optional scalar argument types.
    ZY__CALLABLE_PROTOTYPE_ARG_OPTIONAL_SCALAR_GLOB='\'${ZY__CALLABLE_PROTOTYPE_ARG_SCALAR_OPTIONAL_PREFIX}'*'

    # Glob matching all optional scalar and variadic argument types.
    ZY__CALLABLE_PROTOTYPE_ARG_OPTIONAL_GLOB='['${ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_OPTIONAL_PREFIX}${ZY__CALLABLE_PROTOTYPE_ARG_SCALAR_OPTIONAL_PREFIX}']*'

    # Glob matching all variadic argument types.
    ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_GLOB='['${ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_OPTIONAL_PREFIX}${ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_MANDATORY_PREFIX}']*'

    # ..................{ INDEX                              }..................
    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support global constants. *sigh*

    # For each match group captured by each PCRE global declared above
    # capturing four or more such groups, declare one human-readable integer
    # global expanding to such group's 1-based index. For robustness, declare
    # such globals iteratively rather than manually.
    local match_index_name
    integer match_index

    # Declare indices matched by ${ZY__CALLABLE_PROTOTYPE_PCRE}.
    match_index=1
    for match_index_name (
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAME # 1
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES # 2
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARGS_RAW # 3
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_MANDATORY # 4
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_OPTIONAL # 5
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_SCALAR_OPTIONAL # 6
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_LOCAL # 7
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR # 8
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR # 9
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_LOCAL # 10
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_PARAM # 11
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE # 12
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_NAME # 13
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_ARGS # 14
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_NAME # 15
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_ARGS # 16
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS # 17
    ) {
        integer -g ${match_index_name}=$(( match_index++ ))
        # print -r ${match_index_name}': '${(P)match_index_name}
    }
}
