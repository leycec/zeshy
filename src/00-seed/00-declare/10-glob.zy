#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Globally modify the parcel prefix from "={" to "+{" everywhere. zish
#already leverages "=", both as a syntactic construct prefix (e.g., for "=("-
#and ")"-delimited process substitutions) *AND* as a dirname alias prefix.

#FIXME: *UGH*. Clearly, there's no need for such globs and hence this parcel at 
#all. This parcel derives from a significantly earlier design specification in
#which *ALL* help strings were formatted as a blank line-delimited pair of
#prototype and non-prototype portions. Since prototypes are now formally
#recognized in an unquoted manner, there exists *NO* demonstrable reason for the
#prior logic to exist at all. Excise this and comment out and/or refactor all
#other parcel code leveraging globals defined below.
#
#Note that early-time functionality (e.g., after the definition of core
#documentation functions but before the definition of macro :func() and hence
#unquoted function prototypes) will still need some trivial mechanism for
#associating function prototypes with documentation. Fortunately, this is indeed
#trivial and requires *NO* PCREs or globs: simply define a help function
#resembling:
#
#    void :func.doc[
#        args = (:str func_prototype),
#        stdin = (:str func_documentation)]
#
#We're fairly certain such a function already exists. In either case, simply
#call such function from early-time functionality to document functions. Yay!

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define documentation-specific globs.

# ....................{ GLOBALS                            }....................
# Glob globals defined below.
typeset -g ZESHY_HELP_GLOB

# ....................{ MAIN                               }....................
# Define such globs in an anonymous block to permit definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
    # Glob matching a blank line (i.e., two consecutive newlines optionally
    # delimited by zero or more tab or space characters).
    local blank_line_glob=$'\n''[ '$'\t'']#'$'\n'

    # Glob capturing the prototype and non-prototype portions of documentation.
    # Dismantled, this is:
    #
    ZESHY_HELP_GLOB='[[:space:]]#(#b)(^(#B)(*'${blank_line_glob}'*))'${blank_line_glob}'(#b)(*)'
}

#FIXME: In lieu of unit tests...
# function zuzu() {
#     local yamy='
# [status: int] TRAPZERR(int signal_number = SIGZERR)
# 
# Trap SIGZERR, a `zsh`-specific signal triggered by `zsh` on any.
# 
# Command reporting *unhandled failure* (i.e., nonzero exit status _not_.
# 
# '
#     if [[ "${yamy}" == ${~ZESHY_HELP_GLOB} ]] {
#         print "match[1]: ${match[1]}"
#         print "match[2]: ${match[2]}"
#     } else {
#         print 'Ugh!'
#     }
# }

# --------------------( WASTELANDS                         )--------------------
#FUXME: Shift to +{..-seed/help/pcre.zy}.
# PCRE capturing the prototype and non-prototype portions of help strings.
# typeset -g ZESHY__HELP_PCRE
    # ..................{ SPACE                              }..................
    #FUXME: Since both this and +{macro.zy} leverage such PCREs, globalize such
    #PCREs (e.g., as ${ZESHY__PCRE_SPACE_VERTICAL}) and shift to +{pcre.zy}.

    # # Character class matching horizontal ASCII whitespace characters.
    # local char_space_horizontal=' \t'
    #
    # # Horizontal ASCII whitespace character (i.e., space or tab).
    # local pcre_space_horizontal='['${char_space_horizontal}']'
    #
    # # Zero or more horizontal whitespace characters.
    # local pcre_spaces_horizontal_optional=${pcre_space_horizontal}'*+'
    #
    # # One or two vertical ASCII whitespace characters. Specifically, either:
    # #
    # # * Unix-specific linefeed (i.e., "\n").
    # # * Windows-specific carriage return followed by linefeed (i.e., "\r\n").
    # local pcre_space_vertical='\R'
    # local pcre_space_vertical_optional=${pcre_space_vertical}'?+'
    #
    # # Any character other than a vertical whitespace character. While PCRE
    # # provides no inverse of "\R" as it does with most other generic types
    # # (e.g., "\S", "\H", "\V"), a customary negative character class suffices.
    # local pcre_char_sans_space_vertical='[^'${char_space_vertical}']'
    #
    # # One or more characters other than vertical whitespace characters.
    # local pcre_chars_sans_space_vertical=${pcre_char_sans_space_vertical}'++'
    #
    # # Blank line (i.e., two consecutive vertical whitespace characters).
    # local pcre_line_blank=${pcre_space_vertical}${pcre_space_vertical}
    #
    # # ..................{ HELP                               }..................
    # # Optional ignorable whitespace prefixing such prototype.
    # local pcre_help_prototype_prefix='\s*+'
    #
    # # Prototype, capturing all characters up to the first blank line or end of
    # # such documentation. While such simplistic matching improperly matches
    # # blank lines embedded in prototype strings as prototype terminators, this
    # # PCRE is only applied to early-time functionality with no such prototypes.
    # local pcre_help_prototype='(?:'${pcre_space_vertical_optional}${pcre_chars_sans_space_vertical}')++'
    # local pcre_help_prototype_grouped='('${pcre_help_prototype_body}')'
    #
    # # Optional help string, capturing all characters following such blank line.
    # local pcre_help_string_optional_grouped='(?>'${pcre_line_blank}'(.++))?+'
    #
    # # ..................{ GLOBAL                             }..................
    # # PCRE capturing the prototype and non-prototype portions of help strings.
    # ZESHY__HELP_PCRE=${pcre_help_prefix}${pcre_help_prototype_grouped}${pcre_help_string_optional_grouped}

    # Blank line (i.e., two consecutive newlines optionally delimited by zero or
    # more whitespace characters).
    # local pcre_line_blank=${pcre_space_vertical}${pcre_spaces_horizontal_optional}${pcre_space_vertical}

# #FUXME: Actually, globs are typically less efficient than comparable PCREs --
# #and this is particularly the case for multiline globs. Hence, convert all
# #globs below to PCREs and excise this parcel.
#
# # ....................{ GLOBALS                            }....................
# #FUXME: Document me.
# # Glob globals defined below.
# typeset -g ZESHY_HELP_GLOB
#
# # Define such globs in an anonymous block to permit definition of locals. Since
# # subsequent locals often depend on prior locals, only define one local a line.
# () {
#     # Glob matching a blank line (i.e., two consecutive newlines optionally
#     # delimited by zero or more tab or space characters).
#     local blank_line_glob=$'\n''[ '$'\t'']#'$'\n'
#
#     # Glob capturing the prototype and non-prototype portions of documentation.
#     # Dismantled, this is:
#     #
#     ZESHY_HELP_GLOB='[[:space:]]#(#b)(^(#B)(*'${blank_line_glob}'*))'${blank_line_glob}'(#b)(*)'
# }
