#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under ={string} in the main codebase.

# ....................{ SETTERS                            }....................
# :void :Str.set(:Str str_name +:str strs)
function :Str.set() {
    (( # >= 2 )) || :die 'Expected one string name and one or more strings.'
    local str_name__Ss=${1}
    :Str.die_unless "${str_name__Ss}"

    # If only one such string was passed, no concatenation is required. In this
    # case, set this variable via assignment indirection.
    if (( # == 2 )) {
        : "${(P)str_name__Ss::=${2}}"
    # Else, two or more such strings were passed, in which case concatenation
    # is required. Set this variable to the undelimited concatenation of all
    # such strings.
    } else {
        # Locally clear canonical string global ${IFS} (i.e., the internal
        # field separator). Since zsh implicitly delimits strings concatenated
        # with "*" by this global's value, clearing this global guarantees
        # undelimited concatenation. This incantation was surprisingly arduous
        # to unearth. In particular, note that if "*" is *NOT* double-quoted,
        # zsh ignores the value of ${IFS} during concatenation and hence
        # delimits these strings by single spaces. (Ugh.)
        local IFS=

        # Set this string with undelimited concatenation.
        : "${(P)str_name__Ss::=${*[2,-1]}}"
    }
}

# ....................{ SETTERS ~ stdin                    }....................
# :void :Str.from_stdin[
#     args=( :Str str_name)
#     stdin=(:str str)]
function :Str.from_stdin() {
    :Str.from_stdin_if_nonempty "${@}" || :die 'Standard input empty.'
}


#FIXME: Rename to :Str.from_stdin_if_noninteractive().
# [status=:bool] :Str.from_stdin_if_nonempty[
#     args=( :Str str_name)
#     stdin=(:str str)]
function :Str.from_stdin_if_nonempty() {
    (( # == 1 )) || :die 'Expected one string name.'

    # If standard input is readable without blocking, set this string to all
    # such input. Ideally, this would be implementable as follows:
    #
    #    IFS= read -r -t 0 -d '' "${1}"
    #
    # Unfortunately, option "-d" requires a nonempty character, implying read()
    # to only read in an explicitly delimited manner. Hence, we defer to the
    # more convoluted logic of :stdin.is_nonempty() instead.
    :stdin.is_nonempty && :Str.set "${1}" "$(< /dev/stdin)"
}

# ....................{ SETTERS ~ stdin                    }....................
# :void ::Str.indent(:Str str_name)
function ::Str.indent() {
    (( # == 1 )) || :die 'Expected one string name.'
    local str_name__si=${1}
    :Str.die_unless ${str_name__si}

    # Indent this string.
    :Str.set ${str_name__si} '    '${(P)str_name__si//$'\n'/$'\n'    }
}
