#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under ={string} in the main codebase.

# ....................{ SETTERS                            }....................
# :void :string.set(^:string string_name, :string... strings)
function :string.set() {
    # Validate sanity.
    (( # >= 2 )) || :die 'Expected one string name and one or more strings.'
    local string_name__ssts="${1}"
    :var.die_unless_type_string "${string_name__ssts}"

    # If only one such string was passed, no concatenation is required. In such
    # case, set such variable via assignment indirection.
    if (( # == 2 )) {
        : "${(P)string_name__ssts::=${2}}"
    # Else, two or more such strings were passed, in which case concatenation
    # is required. Set such variable to the undelimited concatenation of all
    # such strings.
    } else {
        # Locally clear canonical string global ${IFS} (i.e., the internal
        # field separator). Since zsh implicitly delimits strings concatenated
        # with "*" by such global's value, clearing such global guarantees
        # undelimited concatenation. This incantation was surprisingly arduous
        # to unearth. In particular, note that if "*" is *NOT* double-quoted,
        # zsh ignores the value of ${IFS} during concatenation and hence
        # delimits such strings by single spaces. (Ugh.)
        local IFS=

        # Set such string with undelimited concatenation.
        : "${(P)string_name__ssts::=${*[2,-1]}}"
    }
}

# ....................{ SETTERS ~ stdin                    }....................
# :void :string.set_to_stdin[
#     args = (^:string string_name),
#     stdin = (:string input)]
function :string.set_to_stdin() {
    :string.set_to_stdin_if_nonempty || :die 'Standard input empty.'
}

# [status = :bool] :string.set_to_stdin_if_nonempty[
#     args = (^:string string_name),
#     stdin = (:string input)]
function :string.set_to_stdin_if_nonempty() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'

    # If standard input is readable without blocking, set such string to all
    # such input. Ideally, this would be implementable as follows:
    #
    #    IFS= read -r -t 0 -d '' "${1}"
    #
    # Unfortunately, option "-d" requires a nonempty character, implying read()
    # to only read in an explicitly delimited manner. Hence, we defer to the
    # somewhat convolute logic of :stdin.is_nonempty() instead.
    :stdin.is_nonempty && :string.set "${1}" "$(< /dev/stdin)"
}

# ....................{ SETTERS ~ stdin                    }....................
# :void ::string.indent(^:string string_name)
function ::string.indent() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'
    local string_name__si=${1}
    :var.die_unless_type_string ${string_name__si}

    # Indent such string.
    :string.set\
        ${string_name__si}\
        '    '${(P)string_name__si//$'\n'/$'\n'    }
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ SETTERS ~ int                      }....................
#FUXME: Arguably a bad idea, due to the need to have :int.die_unless() defined
#here. Shift such functionality back to the main codebase and simply inline
#such functionality.
#FUXME: Document me.

# :void :int.set(^:int int_name, :int number)
# function :int.set() {
#     # Validate sanity.
#     (( # == 2 )) || :die 'Expected one integer name and one integer value.'
#     local int_name__siti="${1}" int__siti="${2}"
#     :var.die_unless_type_int "${int_name__siti}"
# 
#     #FUXME: Define such handler. (Ugh.)
#     :int.die_unless "${int__siti}"
# 
#     # Set such integer via assignment indirection.
#     : "${(P)int_name__siti::=${int__siti}}"
# }

# ....................{ SETTERS ~ list                     }....................
#FUXME: Silly. This is sufficiently simple that inlining it incurs no hardship
#-- particularly as we already do so for clearing of list and map, whose
#underlying implementation similarly calls "set -A".

# # :void :list.set_to_string(^:list list_name, :string text1, ...)
# function :list.set_to_string() {
#     # Validate sanity.
#     (( # >= 2 )) || :die 'Expected one list name and one or more strings.'
#     local list_name__slts="${1}"
#     :var.die_unless_type_list "${list_name__slts}"
# 
#     # Set such list to such strings.
#     set -A "${list_name__slts}" "${@[2,-1]}"
# }

#FUXME: Rename to :list.set(). (Yes, this coincides with all other variable
#setters, whose arguments excluding the first are all scalar types; moreover,
#this renders the nomenclature for string splitters substantially more terse
#than that for list-to-list setters. Since there exist far more of the former
#*AND* since we expect the former to be more commonly called, string splitters
#*SHOULD* have terser names.)

#FUXME: Do we still require this as early-time functionality? We reckon not.
#O.K.! On examining the codebase, it's clear we only call this twice in
#early-time functionality -- both times from ={*-set/prototype}. 

    #FUXME: Actually, this function should just defer to calling
    #:string.set_to_stdin_if_nonempty(), defined substantially earlier.
#     die_unless_arg 'Expected one string name.'
#     :string string_name__ssts="${1}"
#     :var.die_unless_type_string "${string_name__ssts}"
#     :set_var_to_stdin "${string_name__ssts}"

#FUXME: Refactor to:
# :void :string.set(
#     *:string string_name,
#     :string text1, ...)
