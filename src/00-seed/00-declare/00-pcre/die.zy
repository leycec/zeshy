#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# **PCRE exception handlers** (i.e., functions throwing exceptions resulting
# from PCRE-specific errors).

# ....................{ EXCEPTIONS                         }....................
#FIXME: Convert into function documentation.
# :void ::pcre.die_of_subject_not_matching(
#     :string pcre :string subject :string label)
#
# Throw an exception stating the passed subject string to _not_ match the passed
# PCRE of the passed human-readable type (e.g., "function prototype").
#
# If zeshy is currently being debugged *AND* the external "pcretest" command is
# in the current ${PATH}, this output of this command will be grafted onto this
# exception's message for PCRE debugging. Since this command is installed along
# with the "libpcre" dependency required by zsh's "zsh/pcre" module, this
# command will almost always be available.
function ::pcre.die_of_subject_not_matching() {
    (( # == 3 )) ||
        :die 'Expected one PCRE, one subject string, and one label.'
    local\
        pcre=${1}\
        subject=${2}\
        label=${3}\
        message

    # Sanitize such label. Dismantled, this is:
    #
    # * "${(U)...}", capitalizing the first character of such label.
    # * "${...%% #}, stripping all trailing spaces from such label.
    label=${(U)label[1]}${label[2,-1]%% #}

    # If the ::string.indent() function exists, indent such subject string.
    typeset -f ::string.indent &>/dev/null && ::string.indent subject

    # Exception message to be thrown.
    message=${label}' invalid:'$'\n\n'${subject}

    #FIXME: Excise this "if false &&" placeholder line *AFTER* adding a new
    #${ZESHY_IS_EXCEPTIONS_PCRE_DEBUG} boolean global defaulting to false. For
    #now, such debugging is far too verbose to be enabled by default.

    # if true &&
    if false &&
    # If the "pcretest" command is in the current path, append the output of
    # running such command passed such PCRE and subject string. Dismantled, this
    # is:
    #
    # * "${:-...}", expanding to the string "pcretest".
    # * "${...:c}", expanding to the absolute path of "pcretest" if in the
    #   current $PATH or only "pcretest" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "pcretest", this
    #   returns true only if ":c" expanded to an absolute path.
         :is_debugging && [[ -x "${${:-pcretest}:c}" ]] {
    # if :is_debugging && [[ -x "${${:-pcretest}:c}" ]] {
        # Unfortunately, this command was designed with interactive rather than
        # non-interactive use in mind. While this makes interactive PCRE testing
        # trivial, this also makes non-interactive PCRE testing non-trivial.
        # Complications include:
        #
        # * While "pcretest" does accept input from stdin, such input is
        #   interleaved with output and hence expected to be interactive.
        #   Instead, a temporary file containing such input must be written,
        #   passed to "pcretest", and then deleted.
        # * "pcretest" requires such file to contain both such PCRE *AND*
        #   subject string.
        # * Such PCRE must be delimited by any arbitrary ASCII characters
        #   excluding "\" (e.g., "/"). Any such character in such PCRE must be
        #   explicitly escaped (e.g., "\/"). Unlike the subject string, such
        #   PCRE may span multiple lines without issue.
        # * Such subject string must span only a single line. To support
        #   multiline subject strings, all newlines in such string must be 
        #   explicitly converted from true newline characters to the
        #   corresponding PCRE-specific substring matching such characters. For
        #   sanity, all newlines in the subject string are assumed to be Unix
        #   rather than Windows newlines. In this case, all Unix newlines in
        #   such string must be explicitly converted to "\n" substrings.
        #
        # While this is mildly horrible, there appears to exist no CLI-based
        # alternative to "pcretest". (All comparable utilities are GUI-based.)

        # Contents of the temporary file to be passed to "pcretest" below.
        # Dismantled, this is:
        #
        # * "!", an arbitrary character delimiting such PCRE from subject
        #   string. While any character would do, "!" is fairly rare punctuation
        #   _not_ reserved by PCRE syntax and hence unlikely to appear in such
        #   PCRE. The suffixing "!" delimiter is followed by the following PCRE
        #   compilation options:
        #   * "+", printing the unmatched remainder of the subject string.
        #   * "C", printing a trace of the matching process.
        #   * "I", printing additional metadata about such PCRE.
        # * "${pcre...}", escaping all delimiter characters in such PCRE.
        # * "${subject...}", converting all Unix newlines in such subject string
        #   to literal "\n" substrings.
        local pcretest_input='!'${pcre//!/\\!}'!+CI'$'\n'${subject//$'\n'/\\n}
        # print -r '"pcretest" input: '$'\n'${pcretest_input}

        # Create this temporary file with these contents by passing the absolute
        # path of the temporary file created by a "=("-prefixed process
        # substitution to an anonymous function, which guarantees such file to
        # be deleted on such function returning. While obscure, this is well-
        # known to be the most robust means of cross-portably writing a string
        # to a temporary file. To quote the official zsh news:
        # 
        #    "=(<<<...) is optimised to eliminate the need for an external
        #     process. It writes the given string to a file and substitutes the
        #     name on the command line."
        # 
        # Moreover:
        # 
        #    "A general workaround to ensure a process substitution endures for
        #     an appropriate length of time is to pass it as a parameter to an
        #     anonymous shell function (a piece of shell code that is run
        #     immediately with function scope)... The temporary file created by
        #     the process substitution will be deleted when the function exits."
        () {
            # Absolute path of the temporary file created by the "=("-prefixed
            # process substitution passed to this anonymous function.
            local pcretest_input_filename=${1}
            # print '"pcretest" input file:'$'\n'; cat "${pcretest_input_filename}"

            # Append "pcretest" output to the exception message to be thrown.
            # Dismantled, this is:
            #
            # * "-q", quietly suppressing the current version of this command.
            message+=$'\n\n''PCRE match failure trace:'$'\n\n'$(
                command pcretest -q "${pcretest_input_filename}")
        } =(<<<${pcretest_input})
    }

    # Throw such exception.
    :die "${message}"
}

return 0
# --------------------( WASTELANDS                         )--------------------
    #FUXME: Consider indenting such subject with ::string.indent(). Sadly, that
    #function has yet to be defined at this point. *shrug*

        # local pcretest_input='!'${:-${pcre//!/\\!}//\\/\\\\}'!+CI'$'\n'${subject//$'\n'/\\n}
        # local pcretest_input='!'${pcre//\\/\\\\}'!+CI'$'\n'${subject//$'\n'/\\n}
        # local pcretest_input='!'${pcre//!/\\!}'!+CI'$'\n'${subject//$'\n'/\\n}
        # print 'pcre: '$'\n'${pcre}
    # Human-readable type of such PCRE and subject string. For readability,
    # capitalize the first character of such type.
    # label=${(U)label[1]}${label[2,-1]}
    #FUXME: Currently disabled, for safety. Remove "false &&" when working. 
    # if false &&

        # * "-s", studying (i.e., optimizing) the passed PCRE.
    # Prefix such exception message by the name of the current parcel.
    # exception=$(:parcel.label)
