#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by alias, function, and global declarers.

#FIXME: We may have succumbed to premature design overkill by permitting all
#callable prototype argument syntax to be prefixed by a relaxant (e.g.,
#":void :func(!:str !relaxed)"). In general, it's unclear whether such
#additional complexity actually gains us anything over the significantly
#simpler "<is_args_unhandled>" callable prototype attribute automatically
#declaring *ALL* arguments to be relaxed.
#
#Contemplate eliminating all relaxant syntax both here and in :{stop}.

#FIXME: We need to support disjunctive prototypes. Consider this function,
#which can be called in at least two fundamentally distinct ways. To permit
#this, I suggest extending our "{...,...}" syntax yet again as follows:
#
#    {
#        :void :global.declare(
#            :str global_type
#            :str global_name_with_optional_value
#            :str documentation
#        )
#        :void :global.declare(:str documentation)
#    }
#
#We *REALLY* don't want to have to implement a non-regular context-free parser.
#Fortunately, we won't have to. Simply hard-code an outermost "(...|...)"-style
#PCRE, where the first sub-PCRE in such PCRE matches the conventional singular
#prototype (i.e., lacking exterior "{" and "}" delimeters) and the final
#sub-PCRE in such PCRE matches the above plural prototype (i.e., with exterior
#"{" and "}" delimeters).

# ....................{ GLOBALS                            }....................
#FIXME: All such globals are private and hence should be renamed (e.g., from
#${ZY_GLOBAL_PROTOTYPE_PCRE} to ${ZY__GLOBAL_PROTOTYPE_PCRE}).
#FIXME: Document all remaining globals.

# PCREs matching prototype syntax.
typeset -g\
    ZY_GLOBAL_PROTOTYPE_PCRE\
    ZY__CALLABLE_PROTOTYPE_PCRE\
    ZY_GLOBAL_HELP_PROTOTYPE_NAMES_PCRE\
    ZY_CALLABLE_PROTOTYPE_ATTRS_NAMES_PCRE\
    ZY_CALLABLE_PROTOTYPE_NAME_PCRE\
    ZY_CALLABLE_PROTOTYPE_NAME_SUFFIXED_PREFIXED_PCRE\
    ZY_CALLABLE_PROTOTYPE_NAMES_PCRE

# Globs matching prototype syntax.
typeset -g\
    ZY__CALLABLE_PROTOTYPE_ARG_TYPE_OPTIONAL_GLOB

# ....................{ MAIN                               }....................
# Define such PCREs in an anonymous block, allowing definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
   #FIXME: Iterative PCREs (e.g., ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE})
   #should *ALWAYS* start with "\G", anchoring such PCREs to the first
   #character following the last character of the prior match. This isn't
   #merely an efficiency concern (though it is that): it's essential to avoid
   #matching erroneously. See ${pcre_options_anchored} in preprocessor PCREs.

    # ..................{ CORE                               }..................
    # PCRE options. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   tiresome default, "." matches all characters excluding newline.)
    local pcre_options='(?s)'

    # Empty string, captured as a group. Since libpcre already captures the
    # empty string to unmatched groups (excluding trailing unmatched groups,
    # which are detectable with ${#match}), this PCRE is typically only needed
    # to align group indices in a list of "(?|"-driven alternatives.
    local pcre_empty_group='()'

    # ..................{ CLASS                              }..................
    # Character class bodies intended to be embedded *ONLY* in positive
    # character classes (i.e., *NOT* prefixed by "^").

    # ..................{ CLASS ~ space                      }..................
    # Character class matching horizontal ASCII whitespace characters.
    local char_space_horizontal=' \t'

    # Character class matching vertical ASCII whitespace characters.
    local char_space_vertical='\r\n'

    # Character class matching ASCII whitespace characters.
    local char_space=${char_space_horizontal}${char_space_vertical}

    # ..................{ NOT                                }..................
    # Character class bodies intended to be embedded *ONLY* in negative
    # character classes (i.e., prefixed by "^"). Since escaped characters must
    # be explicitly matched and hence *NOT* implicitly matched by such classes,
    # such classes must *ALWAYS* contain the character escape "\".
    #
    # This is significant enough to warrant repeating, in bold plaintext:
    # *ALL NEGATIVE CHARACTER CLASSES OPERATING ON ZSH CODE MUST CONTAIN "\".*

    # ..................{ NOT ~ callable                     }..................
    # Character class matching invalid characters in unquoted callable names,
    # comprising only those characters explicitly conflicting with callable
    # prototype and/or core zsh syntax.
    local char_not_callable_name_unquoted="'"'"\(){}[\]<>'${char_space}'$#|&*?;`!'

    # ..................{ SPACE                              }..................
    # One or more ASCII whitespace characters.
    local pcre_spaces='['${char_space}']++'

    # Zero or more ASCII whitespace characters.
    local pcre_spaces_optional='['${char_space}']*+'

    # ..................{ CHAR ~ literal                     }..................
    # Asterisk.
    local pcre_asterisk='\*'
    local pcre_asterisk_grouped='('${pcre_asterisk}')'

    # Bang (i.e., exclamation point).
    local pcre_bang='!'
    local pcre_bang_optional=${pcre_bang}'?+'
    local pcre_bang_optional_grouped='('${pcre_bang}')?+'

    # Equals sign preceded and followed by optional whitespace.
    local pcre_equals='='

    # Eroteme (i.e., question mark).
    local pcre_eroteme='\?'
    local pcre_eroteme_grouped='('${pcre_eroteme}')'

    # Greater-than sign.
    local pcre_greater_than='\>'

    # Less-than sign.
    local pcre_less_than='\<'

    # Plus sign preceded and followed by optional whitespace.
    local pcre_plus='\+'
    local pcre_plus_grouped='('${pcre_plus}')'

    # Forward slash preceded and followed by optional whitespace.
    local pcre_slash='/'

    # ..................{ CHAR ~ brace                       }..................
    # Left curly brace.
    local pcre_brace_left='\{'

    # Right curly brace.
    local pcre_brace_right='\}'

    # ..................{ CHAR ~ bracket                       }..................
    # Left square bracket.
    local pcre_bracket_left='\['

    # Right square bracket.
    local pcre_bracket_right='\]'

    # ..................{ CHAR ~ paren                        }..................
    # Left paren.
    local pcre_paren_left='\('

    # Right paren.
    local pcre_paren_right='\)'

    # ..................{ SEQUENCE                           }..................
    # Integer or float (i.e., real number).
    local pcre_number='-?+\d++(?>\.\d++)?+'

    # Escaped character (i.e., "\"-prefixed character). By matching all escaped
    # characters, this PCRE solves numerous issues commonly related to such
    # characters:
    #
    # * Escaped backslashes (i.e., "\\") must be matched before matching
    #   subsequent escaped characters, as the former effectively disable
    #   escaping (e.g., "\\n", an escaped backslash preceding the character "n"
    #   rather than an escaped newline).
    # * Line continuations (i.e., "\
    #   ") must be matched as insignificant unquoted characters rather than
    #   significant vertical whitespace.
    local pcre_char_escaped_prefix='\\'
    local pcre_char_escaped=${pcre_char_escaped_prefix}'.'

    # ..................{ QUOTES                             }..................
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/if_compile/*-macro/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local          pcre_quotes_single="'(?>[^']++|'')*+'"

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    local          pcre_quotes_double='"(?>[^"\\]++|'${pcre_char_escaped}')*+"'

    #FIXME: Theoretically, command substitutions can themselves contain command
    #substitutions. Clearly, matching such syntax will require context-free
    #matching leveraging PCRE subroutines. Happily, we've already authored such
    #subroutines for macro preprocessing; it seems unlikely that we'll be able
    #to perfectly reuse such PCREs here (due to substantial structural
    #differences between function prototypes and general-purpose zsh), but
    #perhaps we can? At the least, we should be able to repurpose such PCREs for
    #our specific needs here. *sigh*
    #FIXME: Since this is hardly pressing, just wait until we unify this parcel
    #with @{-macro}.

    # Double-quoted string in the above format, optionally containing command
    # substitutions themselves containing double-quoted strings (e.g.,
    # "We're $(on "a ladder to") God").
    local pcre_quotes_double_with_substitutions='"(?>\$\([^)]*+\)|[^"\\]++|'${pcre_char_escaped}')*+"'

    #FIXME: Unused, but preserved for its helpful documentation, which should
    #be moved to formal AsciiDoc.
    # Pseudo-type signifying such callable to return a maximal amount of data,
    # equivalent to explicitly specifying the return channel list
    # "[stdout = :str, stderr = :str, status = :int]".
    # local pcre_full=':full'

    #FIXME: Unused, but preserved for its helpful documentation, which should
    #be moved to formal AsciiDoc.
    # Pseudo-type signifying such callable to return a minimal amount of data,
    # equivalent to explicitly specifying the return channel list
    # "[stdout = :void, stderr = :void, status = :true]".
    #
    # Since the empty argument list "()" more orthogonally, concisely, and
    # readably signifies a callable to accept no arguments than the C-style
    # argument list "()", this pseudo-type only applies to return types.
    # local pcre_void=':void'

    # ..................{ CALLABLE                           }..................
    # One or more unescaped characters in a callable name (i.e., consecutive
    # run of characters *NOT* prefixed by "\" and hence unescaped).
    local pcre_callable_chars_unescaped='[^'${char_not_callable_name_unquoted}']++'

    # Callable name.
    local pcre_callable_name_unquoted='(?>'${pcre_callable_chars_unescaped}'|'${pcre_char_escaped}')++'

    # ..................{ OPERABLE ~ type                    }..................
    # Operable (i.e., alias, function, variable) type. Note that this PCRE is
    # *NOT* intended to match the actual zsh syntax for operable types --
    # which, since zeshy defines such types by simple aliases, technically
    # include single- and double-quoted strings. Rather, this PCRE only matches
    # the subset of characters zeshy names such types with (i.e., alphanumeric
    # letters, underscore, hyphen, and colon).
    local pcre_operable_type='[a-zA-Z0-9-_:]++'
    local pcre_operable_type_grouped='('${pcre_operable_type}')'

    # Operable type prefixed by a forward slash.
    local         pcre_operable_type_slashed_optional='(?>'${pcre_slash}${pcre_operable_type}')?+'
    local pcre_operable_type_slashed_optional_grouped='(?>'${pcre_slash}${pcre_operable_type_grouped}')?+'

    # Operable type prefixed by a plus sign.
    local         pcre_operable_type_plussed_optional='(?>'${pcre_plus}${pcre_operable_type}')?+'
    local pcre_operable_type_plussed_optional_grouped='(?>'${pcre_plus}${pcre_operable_type_grouped}')?+'

    # ..................{ OPERABLE ~ name                    }..................
    # Operable name, principally callable argument names. This PCRE matches all
    # characters matched by ${pcre_operable_type} excluding colon, as argument
    # names (hypothetically) correspond to local variable names and hence
    # prohibit colons. As above, this PCRE is *NOT* intended to match the full
    # gamut of actual zsh syntax. See ${pcre_global_name} below.
    local pcre_operable_name='[a-zA-Z0-9-_]++'
    local pcre_operable_name_grouped='('${pcre_operable_name}')'

    # Operable name prefixed by a forward slash.
    local         pcre_operable_name_slashed_optional='(?>'${pcre_slash}${pcre_operable_name}')?+'
    local pcre_operable_name_slashed_optional_grouped='(?>'${pcre_slash}${pcre_operable_name_grouped}')?+'

    # Operable name prefixed by a plus sign.
    local         pcre_operable_name_plussed_optional='(?>'${pcre_plus}${pcre_operable_name}')?+'
    local pcre_operable_name_plussed_optional_grouped='(?>'${pcre_plus}${pcre_operable_name_grouped}')?+'

    # ..................{ GLOBAL                             }..................
    # Global variable. Such syntax mimics conventional "="-delimited variable
    # assignments in zsh and hence prohibits whitespace. Note that such
    # assignments accept either:
    #
    # * Single-quoted strings.
    # * Double-quoted strings.
    # * Unquoted strings containing no whitespace, including but *NOT* limited
    #   to integers and floats. Variable assignment syntax thus differs from
    #   that of default argument syntax.

    # Global variable names.
    local pcre_global_type=${pcre_operable_type}
    local pcre_global_type_grouped='('${pcre_global_type}')'

    # Global variable names.
    local pcre_global_name=${ZY_VAR_NAME_PCRE}
    local pcre_global_name_grouped='('${pcre_global_name}')'

    #FIXME: This is probably terrible. Excise, please.
    #FIXME: At the very least, we only want to match a list of global names.
    #Premature optimization is premature. (No more complexity, please.)

    # One or more global variable names.
    local pcre_global_names_grouped='((?>'${pcre_global_name}${pcre_equals}')*+'${pcre_global_name}')'
    local pcre_global_name_or_names_grouped='(?>'${pcre_global_name_grouped}'|'${pcre_global_names_grouped}')'

    #FIXME: This is probably terrible. Excise, please.

    # Global variable value.
    local       pcre_global_value_optional='(?>'${pcre_equals}'(?>'${pcre_quotes_double}'|'${pcre_quotes_single}'|\S++))?+'
    local pcre_global_value_optional_grouped='(?>'${pcre_equals}'('${pcre_quotes_double}'|'${pcre_quotes_single}'|\S++))?+'

    # ..................{ ATTRIBUTE                          }..................
    # Attribute name.
    local pcre_attr_name=${pcre_operable_name}

    # Mandatory attribute value.
    local         pcre_attr_value=${pcre_equals}'(?>'${pcre_quotes_double}'|'${pcre_quotes_single}')'

    # Optional attribute value.
    local         pcre_attr_value_optional='(?>'${pcre_attr_value}')?+'

    # Attribute, comprising a mandatory name and optional value.
    local                 pcre_attr=${pcre_attr_name}${pcre_attr_value_optional}

    # Attribute list prefix.
    local pcre_attr_list_prefix='(?>'${pcre_less_than}${pcre_spaces_optional}

    # Attribute list suffix.
    local pcre_attr_list_suffix=${pcre_spaces_optional}${pcre_greater_than}${pcre_spaces}')?+'

    # Attribute list.
    local pcre_attr_list=${pcre_attr}'(?>'${pcre_spaces}${pcre_attr}')*+'
    local pcre_attr_list_grouped='('${pcre_attr_list}')'

    # Attributes.
    local         pcre_attrs_optional=${pcre_attr_list_prefix}${pcre_attr_list}${pcre_attr_list_suffix}
    local pcre_attrs_optional_grouped=${pcre_attr_list_prefix}${pcre_attr_list_grouped}${pcre_attr_list_suffix}

    # ..................{ RETURN ~ type                      }..................
    # Return type. Zeshy currently prohibits single- and double-quoted
    # return types, simplifying matching.
    local            pcre_return_type=${pcre_operable_type}
    local pcre_return_type_grouped='('${pcre_operable_type}')'

    # ..................{ RETURN ~ channel                   }..................
    # Return channel name (e.g., ":stdout").
    local            pcre_return_channel_name=${pcre_operable_name}
    local pcre_return_channel_name_grouped='('${pcre_operable_name}')'

    # Return channel.
    local         pcre_return_channel=${pcre_return_channel_name}${pcre_equals}${pcre_return_type}
    local pcre_return_channel_grouped=${pcre_return_channel_name_grouped}${pcre_equals}${pcre_return_type_grouped}

    # Return channel list prefix.
    local pcre_return_channel_list_prefix=${pcre_bracket_left}${pcre_spaces_optional}

    # Return channel list suffix.
    local pcre_return_channel_list_suffix=${pcre_spaces_optional}${pcre_bracket_right}

    # Return channel list.
    local pcre_return_channel_list=${pcre_return_channel}'(?>'${pcre_spaces}${pcre_return_channel}')*+'
    local pcre_return_channel_list_grouped='('${pcre_return_channel_list}')'

    # Return channels.
    local         pcre_return_channels=${pcre_return_channel_list_prefix}${pcre_return_channel_list}${pcre_return_channel_list_suffix}
    local pcre_return_channels_grouped=${pcre_return_channel_list_prefix}${pcre_return_channel_list_grouped}${pcre_return_channel_list_suffix}

    # ..................{ RETURN                             }..................
    # Return type or channel.
    local         pcre_return_type_or_channels='(?>'${pcre_return_type}'|'${pcre_return_channels}')'${pcre_spaces}
    local pcre_return_type_or_channels_grouped='(?>'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')'${pcre_spaces}

    # ..................{ NAME                               }..................
    # While zsh permits zeshy unquoted alias and function names to contain a
    # surprisingly wide array of characters, zeshy constrains these names so as
    # to avoid conflict with other prototype syntax. Since zsh permits single-
    # and double-quoted alias and function names to contain arbitrary and hence
    # all possible characters, matching these names requires more than merely
    # class negation.
    #
    # While zsh only supports synonymous functions (e.g.,
    # "function name1 name2() { ... }"), there exists no reason *NOT* to extend
    # such support to aliases as well. (So, we do.)

    # Name.
    local         pcre_callable_name='(?>'${pcre_callable_name_unquoted}'|'${pcre_quotes_double}'|'${pcre_quotes_single}')'
    local   pcre_callable_name_grouped='('${pcre_callable_name_unquoted}'|'${pcre_quotes_double}'|'${pcre_quotes_single}')'

    # Name list prefix.
    local pcre_callable_name_list_prefix=${pcre_brace_left}${pcre_spaces_optional}

    # Name list suffix.
    local pcre_callable_name_list_suffix=${pcre_spaces_optional}${pcre_brace_right}

    # Name list.
    local pcre_callable_name_list=${pcre_callable_name}'(?>'${pcre_spaces}${pcre_callable_name}')*+'
    local pcre_callable_name_list_grouped='('${pcre_callable_name_list}')'

    # Names.
    local pcre_callable_names_grouped=${pcre_callable_name_list_prefix}${pcre_callable_name_list_grouped}${pcre_callable_name_list_suffix}

    # Name or names. Since the former is *NOT* brace-delimited and the latter
    # is, both must be explicitly and independently matched.
    local pcre_callable_name_or_names_grouped='(?>'${pcre_callable_name_grouped}'|'${pcre_callable_names_grouped}')'${pcre_spaces_optional}

    # ..................{ ARG ~ subtype                      }..................
    # Mandatory local argument subtype, signifying the type of the local
    # variable to which such argument's value will be assigned in such
    # function's body.
    local pcre_arg_subtype_local=${pcre_operable_type}
    local pcre_arg_subtype_local_grouped=${pcre_operable_type_grouped}

    # Optional major argument subtype, signifying the ".is_"-suffixed prefix of
    # the name of the function validating such argument's value (e.g., the
    # ":int" in function name :int.is_positive()). Such subtype defaults to
    # such argument's local subtype if unspecified.
    local pcre_arg_subtype_major_optional=${pcre_operable_type_slashed_optional}
    local pcre_arg_subtype_major_optional_grouped=${pcre_operable_type_slashed_optional_grouped}

    # Optional minor argument subtype, signifying the ".is_"-prefixed suffix of
    # the name of the function validating such argument's value (e.g., the
    # ":positive" in function name :int.is_positive()). Such subtype defaults
    # to the empty string if unspecified.
    local pcre_arg_subtype_minor_optional=${pcre_operable_type_plussed_optional}
    local pcre_arg_subtype_minor_optional_grouped=${pcre_operable_type_plussed_optional_grouped}

    # Argument subtypes.
    local          pcre_arg_subtypes=${pcre_arg_subtype_local}${pcre_arg_subtype_major_optional}${pcre_arg_subtype_minor_optional}
    local pcre_arg_subtypes_grouped=${pcre_arg_subtype_local_grouped}${pcre_arg_subtype_major_optional_grouped}${pcre_arg_subtype_minor_optional_grouped}

    # ..................{ ARG ~ type                         }..................
    # Mandatory variadic pseudo-argument modifier. If specified and such
    # pseudo-argument's subtype is:
    #
    # * ":list", such argument comprises one or more passed scalar arguments.
    #   "+:list" has no equivalent in most high-level languages.
    # * ":map", such argument comprises one or more passed keyword arguments.
    #   "+:map" has no equivalent in most high-level languages.
    # * Anything else, an exception is thrown.
    local char_arg_variadic_mandatory='+'
    local pcre_arg_variadic_mandatory_grouped=${pcre_plus_grouped}

    # Missable variadic pseudo-argument modifier. If specified and such
    # pseudo-argument's subtype is:
    #
    # * ":list", such argument comprises zero or more passed scalar arguments.
    #   "*:list" is equivalent to Python's pseudo-argument "*args".
    # * ":map", such argument comprises zero or more passed keyword arguments.
    #   "*:map" is equivalent to Python's pseudo-argument "**kwargs".
    # * Anything else, an exception is thrown.
    local char_arg_variadic_missable='*'
    local pcre_arg_variadic_missable_grouped=${pcre_asterisk_grouped}

    # Missable argument, signifying such argument to be both optional *AND*
    # assigned no default value if unpassed.
    local char_arg_nonvariadic_missable='?'
    local pcre_arg_nonvariadic_missable_grouped=${pcre_eroteme_grouped}

    # Argument type prefix.
    #
    # Note that the "^" prefix signifying indirect argument types is optionally
    # matched *AFTER* matching this prefix, permitting such types to be
    # modified by this prefix (e.g., "*^:int int_names", an optional variadic
    # list of integer variable names).
    local pcre_arg_type_prefix='['${char_arg_variadic_mandatory}${char_arg_variadic_missable}${char_arg_nonvariadic_missable}']'
    local pcre_arg_type_prefix_grouped='(?>'${pcre_arg_variadic_mandatory_grouped}'|'${pcre_arg_variadic_missable_grouped}'|'${pcre_arg_nonvariadic_missable_grouped}')'

    # Optional argument type prefix followed by optional whitespace.
    local         pcre_arg_type_prefix_optional=${pcre_arg_type_prefix}'?+'
    local pcre_arg_type_prefix_optional_grouped=${pcre_arg_type_prefix_grouped}'?+'

    # Argument type.
    local         pcre_arg_type=${pcre_bang_optional}${pcre_arg_type_prefix_optional}${pcre_arg_subtypes}
    local pcre_arg_type_grouped=${pcre_bang_optional_grouped}${pcre_arg_type_prefix_optional_grouped}${pcre_arg_subtypes_grouped}

    # ..................{ ARG ~ name                         }..................
    #FIXME: For maintainability, split the following monolithic PCRE into its
    #constituent components. What, in particular, do the "/"- and "+"-prefixed
    #portions signify here?

    # Argument name.
    local         pcre_arg_name=${pcre_bang_optional}${pcre_operable_name}${pcre_operable_name_slashed_optional}${pcre_operable_name_plussed_optional}
    local pcre_arg_name_grouped=${pcre_bang_optional_grouped}${pcre_operable_name_grouped}${pcre_operable_name_slashed_optional_grouped}${pcre_operable_name_plussed_optional_grouped}

    # ..................{ ARG ~ default                      }..................
    # Default argument value literal.
    local       pcre_arg_default_value='(?>'${pcre_quotes_double_with_substitutions}'|'${pcre_quotes_single}'|'${pcre_number}')'
    local pcre_arg_default_value_grouped='('${pcre_quotes_double_with_substitutions}'|'${pcre_quotes_single}'|'${pcre_number}')'

    # Default argument value.
    local         pcre_arg_default=${pcre_bang_optional}${pcre_equals}${pcre_arg_default_value}
    local pcre_arg_default_grouped=${pcre_bang_optional_grouped}${pcre_equals}${pcre_arg_default_value_grouped}

    # Optional default argument value.
    local         pcre_arg_default_optional='(?>'${pcre_arg_default}')?+'
    local pcre_arg_default_optional_grouped='(?>'${pcre_arg_default_grouped}')?+'

    # ..................{ ARG                                }..................
    # Argument.
    local         pcre_arg=${pcre_arg_type}${pcre_spaces}${pcre_arg_name}${pcre_arg_default_optional}
    local pcre_arg_grouped=${pcre_arg_type_grouped}${pcre_spaces}${pcre_arg_name_grouped}${pcre_arg_default_optional_grouped}

    # ..................{ ARGS ~ list                        }..................
    # Argument list prefix.
    local pcre_arg_list_prefix=${pcre_paren_left}${pcre_spaces_optional}

    # Argument list suffix.
    local pcre_arg_list_suffix=${pcre_spaces_optional}${pcre_paren_right}

    # Argument list of one or more arguments. To permit reuse of the same PCRE
    # for capturing both entire argument lists and first arguments in such
    # lists, the first argument is captured here.
    local               pcre_arg_list=${pcre_arg}'(?>'${pcre_spaces}${pcre_arg}')*+'
    local pcre_arg_list_grouped_first=${pcre_arg_grouped}'(?>'${pcre_spaces}${pcre_arg}')*+'

    # Argument list of zero or more arguments.
    local             pcre_arg_list_optional='(?>'${pcre_arg_list}')?+'
    local       pcre_arg_list_optional_grouped='('${pcre_arg_list}')?+'
    local pcre_arg_list_optional_grouped_first='('${pcre_arg_list_grouped_first}')?+'

    # Arguments.
    local               pcre_args=${pcre_arg_list_prefix}${pcre_arg_list_optional}${pcre_arg_list_suffix}
    local       pcre_args_grouped=${pcre_arg_list_prefix}${pcre_arg_list_optional_grouped}${pcre_arg_list_suffix}
    local pcre_args_grouped_first=${pcre_arg_list_prefix}${pcre_arg_list_optional_grouped_first}${pcre_arg_list_suffix}
    # print -r 'args PCRE: '${pcre_args_grouped}$'\n'

    # ..................{ ARGS ~ channel                     }..................
    # Argument channel.
    local         pcre_arg_channel=${pcre_operable_name}${pcre_equals}${pcre_args}
    local pcre_arg_channel_grouped=${pcre_operable_name_grouped}${pcre_equals}${pcre_args_grouped}

    # Argument channel list prefix.
    local pcre_arg_channel_list_prefix=${pcre_bracket_left}${pcre_spaces_optional}

    # Argument channel list prefix.
    local pcre_arg_channel_list_suffix=${pcre_spaces_optional}${pcre_bracket_right}

    # Argument channel list of one or more channels.
    local         pcre_arg_channel_list=${pcre_arg_channel}'(?>'${pcre_spaces}${pcre_arg_channel}')?+'
    local pcre_arg_channel_list_grouped=${pcre_arg_channel_grouped}'(?>'${pcre_spaces}${pcre_arg_channel_grouped}')?+'

    # Argument channel list of zero or more channels.
    local         pcre_arg_channel_list_optional='(?>'${pcre_arg_channel_list}')?+'
    local pcre_arg_channel_list_optional_grouped='(?>'${pcre_arg_channel_list_grouped}')?+'

    # Argument channels.
    local         pcre_arg_channels=${pcre_arg_channel_list_prefix}${pcre_arg_channel_list_optional}${pcre_arg_channel_list_suffix}
    local pcre_arg_channels_grouped=${pcre_arg_channel_list_prefix}${pcre_arg_channel_list_optional_grouped}${pcre_arg_channel_list_suffix}

    # ..................{ ARGS                               }..................
    # Arguments or argument channels.
    local         pcre_args_or_channels='(?>'${pcre_args}'|'${pcre_arg_channels}')'
    local pcre_args_or_channels_grouped='(?>'${pcre_args_grouped_first}'|'${pcre_arg_channels_grouped}')'
    # print -r 'arg channels PCRE: '${pcre_arg_channels_grouped}$'\n'
    # print -r 'args or channels PCRE: '${pcre_args_or_channels_grouped}$'\n'

    # ..................{ PCRE                               }..................
    # Note that there currently exists no ${pcre_end}, due to callable
    # prototypes being embedded at the start of callable documentation and
    # hence *NOT* anchorable to the end of such strings.

    # Callable prototype start, enabling PCRE options, matching only at the
    # start of such string, and optionally matching leading whitespace.
    local pcre_start=${pcre_options}'\G'${pcre_spaces_optional}

    # ..................{ PCRE ~ global                      }..................
    #FIXME: This is probably terrible. Excise, please.

    # PCRE capturing all names and optional value in global prototypes.
    ZY_GLOBAL_PROTOTYPE_PCRE=${pcre_global_name_or_names_grouped}${pcre_global_value_optional_grouped}

    # PCRE capturing all names in documentation-specific global prototypes
    # prefixed by a zeshy-style variable type and suffixed by *NO* optional
    # initial value.
    ZY_GLOBAL_HELP_PROTOTYPE_NAMES_PCRE=${pcre_operable_type}${pcre_spaces}${pcre_global_name_or_names_grouped}

    # ..................{ PCRE ~ callable                    }..................
    #FIXME: What? Why? Do we still need this?

    # PCRE capturing a single name in callable prototypes declaring only one
    # such name.
    ZY_CALLABLE_PROTOTYPE_NAME_PCRE=${pcre_start}${pcre_attrs_optional}${pcre_return_type_or_channels}${pcre_callable_name_grouped}${pcre_args_or_channels}

    #FIXME: What? Why? Do we still need this?

    # PCRE capturing a single name in callable prototypes declaring only one
    # such name *AND* the substrings prefixing and suffixing such name. To
    # assist subsequent substitutions, preserve otherwise negligible syntax and
    # whitespace in such prefix and suffix by expanding ungrouped rather than
    # grouped PCREs. (The latter discard all negligible syntax and whitespace.)
    ZY_CALLABLE_PROTOTYPE_NAME_SUFFIXED_PREFIXED_PCRE=${pcre_start}'('${pcre_attrs_optional}${pcre_return_type_or_channels}')'${pcre_callable_name_grouped}'('${pcre_args_or_channels}')'

    #FIXME: What? Why? Do we still need this? This is terrible. Just use
    #${ZY__CALLABLE_PROTOTYPE_PCRE} instead.

    # PCRE capturing all names in callable prototypes.
    ZY_CALLABLE_PROTOTYPE_NAMES_PCRE=${pcre_start}${pcre_attrs_optional}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels}

    #FIXME: What? Why? Do we still need this? This is terrible. Just use
    #${ZY__CALLABLE_PROTOTYPE_PCRE} instead.

    # PCRE capturing all attributes and names in callable prototypes.
    ZY_CALLABLE_PROTOTYPE_ATTRS_NAMES_PCRE=${pcre_start}${pcre_attrs_optional_grouped}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels}

    # PCRE capturing all attributes, names, and arguments in callable
    # prototypes.
    ZY__CALLABLE_PROTOTYPE_PCRE=${pcre_start}${pcre_attrs_optional_grouped}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels_grouped}
    # print -r 'callable prototype PCRE: '$'\n'${ZY__CALLABLE_PROTOTYPE_PCRE}$'\n'

    # ..................{ GLOB ~ callable                    }..................
    # Glob matching all optional argument types.
    ZY__CALLABLE_PROTOTYPE_ARG_TYPE_OPTIONAL_GLOB='['${char_arg_variadic_missable}${char_arg_nonvariadic_missable}']*'

    # ..................{ INDEX                              }..................
    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support global constants. *sigh*

    # For each match group captured by each PCRE global declared above
    # capturing four or more such groups, declare one human-readable integer
    # global expanding to such group's 1-based index. For robustness, declare
    # such globals iteratively rather than manually.
    local match_index_name
    integer match_index

    # Declare indices matched by ${ZY__CALLABLE_PROTOTYPE_PCRE}.
    match_index=1
    for match_index_name (
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS # 1
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAME # 2
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES # 3
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARGS_BASIC # 4
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_RELAXED # 5
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_MANDATORY # 6
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_MISSABLE # 7
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_NONVARIADIC_MISSABLE # 8
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_LOCAL # 11
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR # 12
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR # 13
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME_IS_RELAXED # 14
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_HELP # 15
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_MAJOR # 16
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_MINOR # 17
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED # 18
        ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE # 19
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_NAME # 20
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_ARGS # 21
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_NAME # 22
        ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_ARGS # 23
    ) {
        integer -g ${match_index_name}=$(( match_index++ ))
        # print -r ${match_index_name}': '${(P)match_index_name}
    }
}

return 0
# --------------------( WASTELANDS                         )--------------------
    # local pcre_arg_subtypes_grouped='('${pcre_arg_subtype_local_grouped}${pcre_arg_subtype_major_optional_grouped}${pcre_arg_subtype_minor_optional_grouped}')'
        # ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPES # 10

    # Mandatory local argument subtype for direct argument subtypes, signifying
    # the type of the local variable to which such argument's value will be
    # assigned in such function's body.

    # Optional major argument subtype for direct argument subtypes, signifying
    # the ".is_"-suffixed prefix of the name of the function validating such
    # argument's value (e.g., the ":int" in function name :int.is_positive()).
    # Such subtype defaults to such argument's local subtype if unspecified.

    # Optional minor argument subtype for both direct and indirect argument
    # subtypes, signifying the ".is_"-prefixed suffix of the name of the
    # function validating such argument's value (e.g., the ":positive" in
    # function name :int.is_positive()). Such subtype defaults to the empty
    # string if unspecified.

    # # Mandatory major argument subtype for indirect argument subtypes,
    # # signifying the ".is_"-suffixed prefix of the name of the function
    # # validating the value of the variable to which such argument refers.
    # local pcre_arg_subtype_major=${pcre_operable_type}
    # local pcre_arg_subtype_major_grouped=${pcre_operable_type_grouped}

        # ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT # 9

    # # ..................{ ARG ~ subtypes                     }..................
    # # Direct argument subtypes, signifying the type of a direct argument (i.e.,
    # # argument whose value does *NOT* refer to the name of another variable).
    # #
    # # Since the minor argument subtype is matched in an identical manner for
    # # both direct and indirect arguments, such subtype is matched below.
    # local                            pcre_arg_subtypes_direct=${pcre_arg_subtype_local}${pcre_arg_subtype_major_optional}
    # local pcre_arg_subtypes_direct_grouped=${pcre_empty_group}'('${pcre_arg_subtype_local_grouped}${pcre_arg_subtype_major_optional_grouped}')'
    #
    # # Indirect argument subtypes, signifying the type of an indirect argument
    # # (i.e., argument whose value refers to the name of another variable).
    # #
    # # Since such argument's value is a name, such argument's local subtype is
    # # necessarily ":str" and hence need *NEVER* be explicitly specified here.
    # # Instead, an empty group is matched for such argument's local subtype
    # # required by uncaretted subtypes.
    # #
    # # Since no local subtype is specified, such argument's major subtype need
    # # *NOT* be prefixed by a character uniquely delimiting such subtype from
    # # such argument's local subtype. Such argument's major subtype is matched
    # # optionally for uncaretted subtypes but manditorily for caretted subtypes.
    # #
    # # Thankfully, such argument's minor subtype is matched in the same manner
    # # for both direct and indirect subtypes.
    # local         pcre_arg_subtypes_indirect=${pcre_caret}${pcre_arg_subtype_major}
    # local pcre_arg_subtypes_indirect_grouped=${pcre_caret_grouped}'('${pcre_empty_group}${pcre_arg_subtype_major_grouped}')'
    #
    # # Argument subtypes. Since the "^" prefixing indirect subtypes is matched
    # # non-optionally and hence efficiently, such subtypes are matched *BEFORE*
    # # direct subtypes.
    # local          pcre_arg_subtypes='(?>'${pcre_arg_subtypes_indirect}'|'${pcre_arg_subtypes_direct}')'${pcre_arg_subtype_minor_optional}
    # local pcre_arg_subtypes_grouped='(?|'${pcre_arg_subtypes_indirect_grouped}'|'${pcre_arg_subtypes_direct_grouped}')'${pcre_arg_subtype_minor_optional_grouped}

    # # Caret.
    # local pcre_caret='\^'
    # local pcre_caret_grouped='('${pcre_caret}')'

#FUXME: There appears to be little point to supporting minor argument subtypes,
#as such substring could simply be suffixed onto the major argument subtype
#instead: e.g.,
#
#    # Instead of this...
#    :void :funcem(:str+nonempty)
#    :void :funcem(:str/:func)
#
#    # ...just do this.
#    :void :funcem(:str/:str.is_nonempty)
#    :void :funcem(:str/:func.is)

    #FUXME: Something clearly isn't right here. For one, we appear to have removed all reference to ${pcre_bang} above -- which
    #  is bad. To just get the codebase working as expected again, add
    #  ${pcre_bang} and ${pcre_bang_grouped} references above as required.
    #* We 

    # local pcre_callable_name_grouped='(?|'${pcre_callable_name_unquoted_grouped}'|'${pcre_quotes_double_grouped}'|'${pcre_quotes_single_grouped}')'
    # local pcre_quotes_single_grouped="'((?>[^']++|'')*+)'"
    # local pcre_quotes_double_grouped='"((?>[^"\\]++|'${pcre_char_escaped}')*+)"'
    # local pcre_callable_name_unquoted_grouped='('${pcre_callable_name_unquoted}')'

#  To permit reuse of the same PCRE
    # for capturing both entire argument lists and first arguments in such
    # lists, both such substrings are captured here.
#     # Declare indices matched by ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE}.
#     match_index=1
#     for match_index_name (
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_RELAXED
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_MANDATORY
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_MISSABLE
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_NONVARIADIC_MISSABLE
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPES
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_LOCAL
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME_IS_RELAXED
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_HELP
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_MAJOR
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_MINOR
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED
#         ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE
#     ) {
#         integer -g ${match_index_name}=$(( match_index++ ))
#     }
# }

    # ZY__CALLABLE_PROTOTYPE_ARG_MODIFIER_NONVARIADIC_MISSABLE=${char_arg_nonvariadic_missable}
    # ZY__CALLABLE_PROTOTYPE_ARG_MODIFIER_VARIADIC_MANDATORY=${char_arg_variadic_mandatory}
    # ZY__CALLABLE_PROTOTYPE_ARG_MODIFIER_VARIADIC_MISSABLE=${char_arg_variadic_missable}
#FUXME: Do we still need these?

# Argument type modifiers.
# typeset -g\
#     ZY__CALLABLE_PROTOTYPE_ARG_MODIFIER_VARIADIC_MANDATORY\
#     ZY__CALLABLE_PROTOTYPE_ARG_MODIFIER_VARIADIC_MISSABLE\
#     ZY__CALLABLE_PROTOTYPE_ARG_MODIFIER_NONVARIADIC_MISSABLE

    #FUXME: Ugh. Excise me post-haste.

    # PCRE capturing the next argument in a comma-delimited list of such
    # arguments, presumably captured from a callable prototype.
    # ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE=${pcre_arg_grouped}${pcre_spaces_optional}
    # print -r "arg pcre: ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE}"

    # ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE
    #FUXME: Terrible. Eliminate these post-haste. We retain these *ONLY* as a
    #temporary expedient to get the globals declared below working. That said,
    #we really shouldn't need any of these anymore.
    # ZY_CALLABLE_PROTOTYPE_NAMES_PCRE=${pcre_start}${pcre_attrs_optional}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels}
    # ZY_CALLABLE_PROTOTYPE_ATTRS_NAMES_PCRE=${pcre_start}${pcre_attrs_optional_grouped}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels}
    # ZY__CALLABLE_PROTOTYPE_PCRE=${pcre_start}${pcre_attrs_optional_grouped}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels_grouped}

    # ZY_CALLABLE_PROTOTYPE_ATTRS_NEXT_PCRE\
    # ZY_CALLABLE_PROTOTYPE_NAMES_NEXT_PCRE\

    # local pcre_attr_name_grouped='('${pcre_attr_name}')'
    # local pcre_attr_value_grouped=${pcre_equals}'(?|'${pcre_quotes_double_grouped}'|'${pcre_quotes_single_grouped}')'
    # local pcre_attr_value_optional_grouped='(?>'${pcre_attr_value_grouped}')?+'
    # local pcre_attr_grouped=${pcre_attr_name_grouped}${pcre_attr_value_optional_grouped}

    #FUXME: Ugh. Excise me post-haste.

    # PCRE capturing the next name in a comma-delimited list of such names,
    # presumably captured from a callable prototype.
    # ZY_CALLABLE_PROTOTYPE_NAMES_NEXT_PCRE=${pcre_callable_name_grouped}${pcre_spaces_optional}

    #FUXME: Ugh. Excise me post-haste.

    # PCRE capturing the next attribute in a comma-delimited list of such
    # attributes, presumably captured from a callable prototype.
    # ZY_CALLABLE_PROTOTYPE_ATTRS_NEXT_PCRE=${pcre_attr_grouped}${pcre_spaces_optional}

    #FUXME: This should probably be the *ONLY* (or at least default) PCRE
    #matching callable prototypes. Everything above seems... well, superfluous.

    # Callable prototype end, matching only at the end of such string.
    # local pcre_end='$'

    # ..................{ CHAR ~ tilde                       }..................
    # Tilde.
    # local pcre_tilde='~'
    # local pcre_tilde_optional=${pcre_tilde}'?+'
    # local pcre_tilde_optional_grouped='('${pcre_tilde}')?+'

    # local pcre_quotes_double_with_substitutions='"(?>\\"|\$\([^)]*+\)|[^"])*+"'
    # local         pcre_arg_subtypes_direct=${pcre_arg_subtype_local}${pcre_arg_subtype_major_optional}${pcre_arg_subtype_minor_optional}
    # local pcre_arg_subtypes_direct_grouped=${pcre_empty_group}${pcre_arg_subtype_local_grouped}${pcre_arg_subtype_major_optional_grouped}${pcre_arg_subtype_minor_optional_grouped}
    #
    # # Indirect argument subtypes, signifying the type of an indirect argument
    # # (i.e., argument whose value refers to the name of another variable).
    # #
    # # Since such argument's value is a name, such argument's local subtype is
    # # necessarily ":str" and hence need *NEVER* be explicitly specified here.
    # # Instead, an empty group is matched for such argument's local subtype
    # # required by uncaretted subtypes.
    # #
    # # Since no local subtype is specified, such argument's major subtype need
    # # *NOT* be prefixed by a character uniquely delimiting such subtype from
    # # such argument's local subtype. Such argument's major subtype is matched
    # # optionally for uncaretted subtypes but manditorily for caretted subtypes.
    # #
    # # Thankfully, such argument's minor subtype is matched in the same manner
    # # for both direct and indirect subtypes.
    # local         pcre_arg_subtypes_indirect=${pcre_caret}${pcre_arg_subtype_major}${pcre_arg_subtype_minor_optional}
    # local pcre_arg_subtypes_indirect_grouped=${pcre_caret_grouped}${pcre_empty_group}${pcre_arg_subtype_major_grouped}${pcre_arg_subtype_minor_optional_grouped}

    # the variable whose name is the value of such argument.
    # Direct argument subtypes (i.e., string concatenation of argument
    # subtypes *NOT* prefixed by a "^" character), signifying the type of a
    # Optional argument type prefix followed by optional whitespace.
    # local         pcre_arg_type_prefix_optional='(?>'${pcre_arg_type_prefix}${pcre_spaces_optional}')?+'
    # local pcre_arg_type_prefix_optional_grouped='(?>'${pcre_arg_type_prefix_grouped}${pcre_spaces_optional}')?+'

    #FUXME: For efficiency, only match ASCII whitespace as in @{*-macro}. Since
    #this is hardly pressing, just wait until we unify this parcel with that.

    # # One or more ASCII whitespace characters.
    # local pcre_spaces='\s++'
    #
    # # Zero or more ASCII whitespace characters.
    # local pcre_spaces_optional='\s*+'

# To preferentially match "\\" as an escaped character,
    # escaped characters are matched *BEFORE* unescaped characters.
    # Unquoted name. See above for the full definition.
    # Escaped character in a callable name (i.e., prefixed by "\").
    # local pcre_callable_char_escaped='\\'${char_not_callable_name_unquoted}']++'

    # Human-readable callable name (i.e., function or alias name). Such PCRE
    # matches all characters matched by ${pcre_operable_type} as well as
    # punctuation *NOT* conflicting with callable prototype syntax.
    # local pcre_callable_name_unquoted='[a-zA-Z0-9-_:.,]++'

# *AND* commonly present in zeshy nomenclature. at the moment, only periods
#FUXME: We have a serious syntax issue. The currently defined callable
#prototype syntax does *NOT* comply with standard zsh syntax. Specifically:
#
#* Prototype syntax is comma-delimited. Zsh syntax is whitespace-delimited,
#  excluding a few ignorable outliers (e.g., "{"- and "}"-bounded comma-
#  delimited filename generation alternatives).
#* Prototype syntax assignments permit equals signs to be optionally
#  whitespace-delimited. Zsh syntax prohibits equals signs from being
#  whitespace-delimited.
#
#We're afraid we need to fix this. It's quite important that our callable
#prototype syntax be orthogonal with standard zsh syntax.

    # # PCRE capturing the next attribute in a comma-delimited list of such
    # # attributes, presumably captured from a callable prototype.
    # ZY_CALLABLE_PROTOTYPE_ATTRS_NEXT_PCRE=${pcre_attr_grouped}${pcre_comma_spaced_optional}
    #
    # # PCRE capturing the next name in a comma-delimited list of such names,
    # # presumably captured from a callable prototype.
    # ZY_CALLABLE_PROTOTYPE_NAMES_NEXT_PCRE=${pcre_callable_name_grouped}${pcre_comma_spaced_optional}
    #
    # # PCRE capturing the next argument in a comma-delimited list of such
    # # arguments, presumably captured from a callable prototype.
    # ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE=${pcre_arg_grouped}${pcre_comma_spaced_optional}

    # local         pcre_arg_channel_list_optional='(?>'${pcre_arg_channel}'(?>'${pcre_comma_spaced}${pcre_arg_channel}')?+)?+'
    # local pcre_arg_channel_list_optional_grouped='(?>'${pcre_arg_channel_grouped}'(?>'${pcre_comma_spaced}${pcre_arg_channel_grouped}')?+)?+'

    # One or more comma-delimited arguments.
    # local pcre_arg_list='(?>'${pcre_arg}${pcre_comma_spaced}')*+'${pcre_arg}
# [stdout=:str stderr=:int] :die(*:str exception_messages)
    #FUXME: Hmm; no reason to redeclare such PCREs twice. Let's declare global
    #PCREs matching such strings and then reuse both here and elsewhere.

    # # Tilde followed by optional whitespace.
    # local pcre_tilde_spaced_optional='(?>'${pcre_tilde}${pcre_spaces_optional}')?+'
    # local pcre_tilde_spaced_optional_grouped='('${pcre_tilde}${pcre_spaces_optional}')?+'

    # local pcre_plus_spaced=${pcre_spaces_optional}${pcre_plus}${pcre_spaces_optional}
    # local pcre_slash_spaced=${pcre_spaces_optional}${pcre_slash}${pcre_spaces_optional}

    # # At sign.
    # local pcre_at='@'
    # local       pcre_at_spaced_optional='(?>'${pcre_at}${pcre_spaces_optional}')?+'
    # local pcre_at_spaced_optional_grouped='('${pcre_at}${pcre_spaces_optional}')?+'

    # local pcre_equals_spaced=${pcre_spaces_optional}${pcre_equals}${pcre_spaces_optional}
    # local pcre_caret_spaced_grouped='('${pcre_caret_spaced}')'
    # local pcre_caret_spaced=${pcre_caret}${pcre_spaces_optional}
    # local pcre_caret_spaced_grouped='('${pcre_caret_spaced}')'
    # local pcre_eroteme_grouped='('${pcre_eroteme}')'

    # local pcre_callable_names_suffix=${pcre_comma_spaced_optional_spaces}${pcre_brace_right}
    #
    # # Name list.
    # local pcre_callable_names_list='(?>'${pcre_callable_name}${pcre_comma_spaced}')*+'${pcre_callable_name}

    # local pcre_return_channel_list_suffix=${pcre_comma_spaced_optional_spaces}'\]'

    # Return channel list.
    # local pcre_return_channel_list='(?>'${pcre_return_channel}${pcre_comma_spaced}')*+'${pcre_return_channel}

    # local pcre_attr_list_suffix=${pcre_comma_spaced_optional_spaces}${pcre_greater_than}${pcre_spaces}')?+'
    #
    # # Attribute list.
    # local pcre_attr_list='(?>'${pcre_attr}${pcre_comma_spaced}')*+'${pcre_attr}
    # ..................{ CHAR ~ comma                       }..................
    # Comma.
    # local pcre_comma=','
    #
    # # Comma preceded and followed by optional whitespace.
    # local pcre_comma_spaced=${pcre_spaces_optional}${pcre_comma}${pcre_spaces_optional}
    # local pcre_comma_spaced_optional='(?>'${pcre_comma_spaced}')?+'
    #
    # # Comma preceded by optional whitespace, followed by optional whitespace
    # # regardless of whether such comma matched.
    # local pcre_comma_spaced_optional_spaces='(?>'${pcre_spaces_optional}${pcre_comma}')?+'${pcre_spaces_optional}

#:void :die(:int yumyum='2' ^:str yowzo *:str exception_messages)
#:void :die(:int yumyum='2', ^:str yowzo, *:str exception_messages)
    # Argument type prefix.
    #
    # Note that the "^" prefix signifying caretted argument types is optionally
    # matched *AFTER* matching this prefix, permitting caretted argument types
    # to be modified by this prefix (e.g., "*^:int int_names", an optional
    # variadic list of integer variable names).
    # local pcre_arg_type_prefix='['${pcre_arg_variadic_missable}${pcre_arg_variadic_mandatory}${pcre_arg_missable}']'
    # local       pcre_arg_type_prefix_optional='(?>'${pcre_arg_type_prefix}${pcre_spaces_optional}')?+'
    # local pcre_arg_type_prefix_optional_grouped='('${pcre_arg_type_prefix}${pcre_spaces_optional}')?+'

    # ZY__CALLABLE_PROTOTYPE_ARG_TYPE_VARIADIC_MANDATORY\
    # ZY__CALLABLE_PROTOTYPE_ARG_TYPE_VARIADIC_MISSABLE\
    # ZY__CALLABLE_PROTOTYPE_ARG_TYPE_MISSABLE\
    # Argument list contents comprising zero or more comma-delimited arguments.
    # local       pcre_arg_list_optional='(?>(?>'${pcre_arg}${pcre_comma_spaced}')*+'${pcre_arg}')?+'
    # local pcre_arg_list_optional_grouped='((?>'${pcre_arg}${pcre_comma_spaced}')*+'${pcre_arg}')?+'
    # Missable or default argument value but *NOT* both, as the one necessarily
    # excludes the other. Such argument is mandatory if both are unspecified.
    # local         pcre_arg_missable_or_default_optional=${pcre_spaces_optional}'(?>'${pcre_arg_missable}'|'${pcre_arg_default}')?+'
    # local pcre_arg_missable_or_default_optional_grouped=${pcre_spaces_optional}'(?>'${pcre_arg_missable_grouped}'|'${pcre_arg_default_grouped}')?+'

    # local pcre_arg_type_modifier='(?>'${pcre_arg_variadic_asterisk}'|'${pcre_arg_variadic_plus}'|'${pcre_arg_missable}')'
    # Missable argument, signifying such argument to be both optional *AND*
    # assigned no default value if unpassed.
    # local pcre_arg_missable=${pcre_eroteme}
    # local pcre_arg_missable_grouped=${pcre_eroteme_grouped}

    # Variadic pseudo-argument.
    # local pcre_arg_variadic='(?>'${pcre_arg_variadic_asterisk}'|'${pcre_arg_variadic_plus}')'
    # local       pcre_arg_variadic_missable='(?>'${pcre_arg_variadic}${pcre_spaces_optional}')?+'
    # local pcre_arg_variadic_missable_grouped='('${pcre_arg_variadic}${pcre_spaces_optional}')?+'

    # local       pcre_asterisk_spaced_optional='(?>'${pcre_asterisk}${pcre_spaces_optional}')?+'
    # local pcre_asterisk_spaced_optional_grouped='('${pcre_asterisk}${pcre_spaces_optional}')?+'
    # local       pcre_plus_spaced_optional='(?>'${pcre_plus}${pcre_spaces_optional}')?+'
    # local pcre_plus_spaced_optional_grouped='('${pcre_plus}${pcre_spaces_optional}')?+'

    # Variadic pseudo-argument. If specified and such pseudo-argument's
    # subtypes are:
    #
    # * ":list", such "argument" comprises one or more passed scalar arguments.
    #   Hence, "@:list" is equivalent to Python's pseudo-argument "*args".
    # * ":map", such "argument" comprises one or more passed keyword arguments.
    #   Hence, "@:map" is equivalent to Python's pseudo-argument "**kwargs".
    # * Anything else, an exception is thrown.
    # local pcre_arg_variadic_missable=${pcre_at_spaced_optional}
    # local pcre_arg_variadic_missable_grouped=${pcre_at_spaced_optional_grouped}

#FUXME: We may have erred with respect to variadic argument list syntax. The
#reason why is that we *REALLY* want to generalize such syntax to support
#Python-style keyword argument lists as well. However, there's no clear means
#of extrapolating the "..." operator to do so. Consider the following:
#
#* Replacing the variadic argument list operator "..." by ":list": e.g.,
#    # Rather than this...
#    :void some_func(:str... args)
#    # ...just do this.
#    :void some_func(:str:list args)
#* Defining a new keyword argument list operator ":map": e.g.,
#    :void some_func(:str:map kwargs)
#
#Sweet!
#FUXME: O.K.; we're quite happy with that as well. We now match ":list"
#wherever we matched "..." before here, but will need to rewrite *ALL* function
#prototypes elsewhere accordingly. Whatever! Pain is best endured early, again.
#FUXME: Hmmm; actually, ":str:list"-style variadic syntax is *NOT*
#necessarily the best, for the obvious reason that ":str:list" is a valid
#alias name and hence valid zeshy-specific type name. Perhaps more importantly
#from a practical day-to-day perspective, ":str:list" is overly verbose for
#such frequently used syntax. Instead, let's adopt the last available character
#as a new prefix: "@": e.g.,
#
#    :void some_func(@:list args, @:map kwargs)
#
#O.K.; that's definitely the one. "@:list" literally reads "at list", which
#makes perfect human-readable sense for an "exploded" argument list. It's
#concise; it doesn't conflict with existing zsh or function prototype syntax.

#FUXME: Ugh. The "`" character was, perhaps, not the ideal choice of syntax
#to signify "disable this." After all, "`" already has a *VERY* distinct
#(albeit deprecated) meaning in shell languages. Overloading such prefix to
#mean something completely dissimilar strikes us as a terrible move. Before
#matters get to irrevocably hairy, we'd really better supplant that by more
#appropriate syntax *NOT* already reserved by zsh itself or used elsewhere
#in function prototype syntax. We only appear to have three available
#choices: "+", "@", and "~". "@" reads "at," which has nothing to do with
#disabling anything and hence is right out. "+" and "~" appear to be equally
#applicable, with "~" perhaps getting the nod (due to reading "approximate"
#in science).
#FUXME: O.K.; we're quite happy with "~". We now match "~" wherever we matched
#"`" before here, but will need to rewrite *ALL* function prototypes elsewhere
#accordingly. Whatever! Pain is best endured early than late.

    # if such argument's subtypes are ":list".
    # * Keyword arguments if such argument's subtypes are ":list".
    # or keyword arguments. In the former case, such arguments will be assigned
    # to a local list 
    #
    # to be a nonscalar list or map
    # assigned all remaining:
    #
    # * Scalar arguments in the former case (i.e., if such argument is a list).
    # * Keyword arguments in the latter case (i.e., if such argument is a map).
    # local pcre_arg_default=${pcre_tilde_spaced_optional}'='${pcre_spaces_optional}${pcre_arg_default_value}
    # local pcre_arg_default_grouped=${pcre_tilde_spaced_optional_grouped}'='${pcre_spaces_optional}${pcre_arg_default_value_grouped}
    #FUXME: For maintainability, this *REALLY* requires additional documentation
    #and splitting into smaller PCREs. For example:
    #
    #    # This...
    #    ${pcre_tilde_spaced_optional}'='${pcre_spaces_optional}
    #
    #    # ...should really be matched as this...
    #    ${pcre_tilde_spaced}${pcre_equals_spaced}
    #
    #    # ...where should be defined above as follows.
    #    local pcre_equals='='
    #    local pcre_equals_spaced=${pcre_spaces_optional}${pcre_equals}${pcre_spaces_optional}

    #FUXME: @{*-macro/pcre} already defines the same variable PCRE. Unify,
    #probably with a new PCRE global ${ZY_VAR_NAME_PCRE}.
    # See ${ZY_VAR_NAME_GLOB}.
    #FUXME; Add ${pcre_at_spaced} support both here and below.

# whose value
    # is *NOT* referring to an external variable
    # At sign or caret, prefixing argument types.
    # local pcre_caret_spaced='\^'${pcre_spaces_optional}
    # local pcre_caret_spaced_grouped='('${pcre_caret_spaced}')'

    # Ellipse (i.e., three consective periods) preceded by optional whitespace.
    # local pcre_ellipse_spaced_optional='(?>'${pcre_spaces_optional}'\.\.\.)?'
    # local pcre_ellipse_spaced_optional_grouped='('${pcre_spaces_optional}'\.\.\.)?'

    # Grave accent (i.e., backtick) followed by optional whitespace.
    # local pcre_tilde_spaced_optional='(?>`'${pcre_spaces_optional}')?'
    # local pcre_tilde_spaced_optional_grouped='(`'${pcre_spaces_optional}')?'

    #FUXME: For maintainability, we probably want to use embedded named
    #references everywhere we currently use zsh variable embedding below.
    #Argument lists and channels are probably the worst offenders here.

    # period, as
    # callable names are internally delimited by one such character under zeshy
    # nomenclature. Avoid 

    # Since empty argument lists signify meaningful
    # semantics, the prior PCREs permit empty argument lists. While permitting
    # empty argument channels would be similarly feasible and signify the same
    # semantics, doing so would significantly complicate parsing. If both
    # argument lists *AND* channels were permitted to be empty, there would
    # exist no trivial means of d
    #
    # (e.g., ":void
    # :empty()"), 

 # To distinguish empty from unspecified argument
    # lists, capture the ")" suffixing such list. Since the "(" prefixing such
    # list may be suffixed by whitespace *NOT* matched by
    # ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE}, do *NOT* capture such "(".
    # While this requires the caller to explicitly discard the ")" suffixing
    # such match, this is ultimately a negligible price to pay.
#FUXME: If, after rigorously eyeballing this, we're still unable to decpiher
#the issue, paste into a "pcretest" session (the library underlying "libpcre").
#Failing that, consider the following URLs:
#
#* http://regex101.com/, a RegexBuddy alternative specific to "libpcre". Yay!
#* https://stackoverflow.com/questions/2348694/how-do-you-debug-a-regex,
#  exhaustive discussion of all alternatives.

#FUXME: The current approach to PCRE design guarantees quite a bit of
#backtracking under typical callable prototypes. Why? Because we permit
#optional whitespace preceding pretty much *EVERY* element of argument list
#syntax (e.g., the "/" in ":void :yum(:str/alias alias_name)".

#${pcre_global_value_optional}
    # local pcre_global_value_grouped='(?:=('${pcre_quotes_double}'|'${pcre_quotes_single}'|'${pcre_number}'))?'

    #FUXME: Sweet. This is effectively complete. Now, we just need to actually
    #*USE* ${ZY_GLOBAL_PROTOTYPE_PCRE} (and hence ${pcre_global_grouped}).
    #To do so, the first incremental step will probably be to implement a new
    #setter ::global_prototype.Names() in @{*-set}.

# String globals referenced in such PCRE globals below as well as elsewhere.
# typeset -g ZY_HEREDOC_DELIMITER '/---/---/---'

#FUXME: Can we excise ${ZY_PROTOTYPE_FUNC_SANS_ATTRS_AND_NAMES_PCRE}? This
#is some obscure stuff.
#FUXME: Consider excising ${ZY_GLOBAL_PROTOTYPE_NAMES_NEXT_PCRE}, which
#*SHOULD* now be obsoleted by simpler string splitting.

    #FUXME: Actually, this is fairly silly. It's more efficient to simply match
    #the following:
    #
    # local pcre_arg_channels_grouped=${pcre_arg_channels_prefix}${pcre_arg_channel_grouped}'(?:'${pcre_comma_spaced}${pcre_arg_channel_grouped}')?)'${pcre_arg_channels_suffix}
    #
    #Then do the following:
    #
    #* Define new match indices for such PCRE.
    #* Adjust the match index constants below accordingly.
    #* Refactor ${pcre_arg_channels} to match similarly.
    #* Refactor the setter parsing such syntax to assign such channel
    #  substrings to one of two passed string variables, depending on such
    #  channel's name. Specifically, if the latter is:
    #  * "args", set the passed args variable to such channel substring.
    #  * "stdin", set the passed stdin variable to such channel substring.
    #  * Neither, throw an exception.

    # ZY_CALLABLE_PROTOTYPE_NAMES_PCRE\
    # ZY_GLOBAL_PROTOTYPE_NAMES_NEXT_PCRE\

    # PCRE capturing the next name in a "="-delimited list of such names,
    # presumably captured from a global prototype.
    # ZY_GLOBAL_PROTOTYPE_NAMES_NEXT_PCRE=${pcre_global_name_grouped}'='

    # PCRE matching all names in callable prototypes.
    # ZY_CALLABLE_PROTOTYPE_NAMES_PCRE=${pcre_start}${pcre_attrs}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}

    # local pcre_arg_list_grouped='('${pcre_arg_list}')'

    # local pcre_arg_list='(?:'${pcre_arg}${pcre_comma_spaced}')*'${pcre_arg}
    # local       pcre_arg_list_optional='(?:'${pcre_arg_list}')?'
    # local pcre_arg_list_optional_grouped='('${pcre_arg_list}')?'
    # local pcre_args_prefix='\('${pcre_spaces_optional}
    # local pcre_args_suffix=${pcre_comma_spaced_optional_spaces}'\)'

#${pcre_args_or_channels}

# typeset -g ZY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE
    # PCRE matching all attributes and names in function prototypes.
    # ZY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE=${pcre_start}${pcre_attrs_grouped}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}

#FUXME: Excise ${ZY_CALLABLE_PROTOTYPE_NAMES_PCRE},
#${ZY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE}, and
#${ZY_PROTOTYPE_FUNC_SANS_ATTRS_AND_NAMES_PCRE}. (Yay!)

    #FUXME: Document such indices.

    # For each such group, define a human-readable global expanding to such
    # group's match index. See ={help/declare/pcre} for related documentation.

    # for each such group.
    # Such PCRE matches a veritably
    # obscene number of groups, necessitating some measure of human-
    # readability. (This is it.)

    # Current PCRE match index for groups matched by
    # ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE}. Such PCRE matches a veritably
    # obscene number of groups, necessitating some measure of human-
    # readability. (This is it.)

# ....................{ GLOBALS ~ int                      }....................
#FUXME: Rename ${ZY__CALLABLE_PROTOTYPE_PCRE} to
#${ZY__CALLABLE_PROTOTYPE_PCRE}.
#FUXME: There should exist *NO* tangible syntactic differences between alias
#and function prototypes, implying all use of "_ALIAS" and "_FUNC" in
#nomenclature below should be flattened to merely "_RUNNABLE".
    #FUXME: We probably want 

    # local         pcre_arg_channel=${pcre_operable_name}${pcre_equals_spaced}${pcre_args}
    # local pcre_arg_channel_grouped=${pcre_operable_name_grouped}${pcre_equals_spaced}${pcre_args_grouped}
    # local pcre_arg_channel_args_grouped='args'${pcre_equals_spaced}${pcre_args_grouped}
    # local pcre_arg_channel_stdin_grouped='stdin'${pcre_equals_spaced}${pcre_args_grouped}
    # local pcre_arg_channel_list='(?:'${pcre_arg_channel}${pcre_comma_spaced}')*'${pcre_arg_channel}
    # local pcre_arg_channel_list_grouped='('${pcre_arg_channel_list}')'
    # local pcre_arg_channels_prefix='\['${pcre_spaces_optional}
    # local pcre_arg_channels_suffix=${pcre_comma_spaced_optional_spaces}'\]'
    # local pcre_arg_channels=${pcre_arg_channels_prefix}${pcre_arg_channel_list}${pcre_arg_channels_suffix}
    # local pcre_arg_channels_grouped=${pcre_arg_channels_prefix}'(?|'${pcre_arg_channel_args_grouped}'(?:'${pcre_comma_spaced}${pcre_arg_channel_stdin}')?|'${pcre_arg_channel_stdin}'(?:'${pcre_comma_spaced}${pcre_arg_channel_args_grouped}')?)'${pcre_arg_channels_suffix}
    # local pcre_args_or_channels='(?:'${pcre_args}'|'${pcre_arg_channels}')'
    # local pcre_args_or_channels_grouped='(?|'${pcre_args_grouped}'|'${pcre_arg_channels_grouped}')'

# local pcre_arg_channels_grouped=${pcre_arg_channels_prefix}${pcre_arg_channel_list_grouped}${pcre_arg_channels_suffix}
# local pcre_args_or_channels_grouped='(?:'${pcre_args_grouped}'|'${pcre_arg_channels_grouped}')'
#${pcre_empty_group}${pcre_arg_channel_stdin}'|

#FUXME: We may want to reconsider our current variadic argument syntax. Why?
#Quite simply, because other languages do it rather differently:
#
#    # C.
#    double average(int count, ...) { }
#
#    # Java.
#    double average(int count, int... numbers) { }
#
#    # Python.
#    def average(count, *numbers):
#        nil
#
#    # Ruby.
#    def obj.average(count, *numbers); end
#
#    # C++11 templates.
#    template<typename... Values> class tuple;
#
#So, there exist two fundamental different sorts of syntax. In summary:
#
#* "..." suffixing the variadic argument type.
#* "*" prefixing the variadic argument name.
#
#Either case is considerably more terse than our current approach. Hence, ditch
#the current ", ..." syntax in favor of either of the above. Consider:
#
#    :func ':void :yum(:str hello, :int... nums)' { ... }
#    :func ':void :yum(:str hello, :int *nums)' { ... }
#
#To determine which to choose, note we already have a type prefix "^" but no
#type suffix. When combining "^" with both of the two above, we receive:
#
#    :func ':void :yum(:str hello, ^:int... nums)' { ... }
#    :func ':void :yum(:str hello, ^:int *nums)' { ... }
#
#While "..." combines somewhat more readably with "^" than "*" does, the *REAL*
#issue is the use of "*" to signifier pointers in C and C++. Hence, shall we
#not go with type suffix "..." to denote variadicity? Minor changes required,
#of course, but hopefully nothing *TOO* inauspicious.
#
#Oh, and let's not bother contemplating a name suffix "...", as that results in
#not entirely sensible syntax. After all, variadicity arguably applies more to
#the argument type than name (as it results in a list rather than scalar
#variable with such name). Hence, avoid this:
#
#    :func ':void :yum(:str hello, ^:int nums...)' { ... }

    #FUXME: Permit arbitrary whitespace surrounding such syntax; then, rename
    #such locals accordingly. Note, however, that doing so introduces runtime
    #inefficiencies; hence, we'll probably want to extract the prefixing
    #${pcre_spaces_optional} into all PCREs interpolating ${pcre_plus_spaced}.

    #FUXME: For more efficient matching, extract the ${pcre_spaces_optional}
    #out of this match; since "=" may also be prefixed by optional spaces,
    #match ${pcre_spaces_optional} before either "?" or "=".

    # Colon preceded by optional whitespace followed by mandatory whitespace.
    # local pcre_colon_spaced='\s*+:\s++'

    #FUXME: Shouldn't need the trailing "\s*+". Examine everywhere we expand
    #such PCRE below and (ideally) excise such suffix.

    #FUXME: Permit arbitrary whitespace surrounding such syntax; then, rename
    #such locals accordingly.

    # local pcre_number='-?\d++\.\d++|-?\d++'

    # integer -g\
    #     ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_RELAXED=$(( match_index++ ))\
    #     ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT=$(( match_index++ ))\
    #     ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_LOCAL=$(( match_index++ ))\
    #     ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR=$(( match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR=$(( match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME_IS_RELAXED=$((
    #     match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME_SUFFIX=$(( match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME=$(( match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_IS_ABSENTABLE=$((
    #     match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED=$((
    #     match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE=$((
    #     match_index++ ))

    # integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC=$((
    #     match_index++ ))

    # Asterisk (i.e., star).
    # local pcre_star='\*'
    # local pcre_star_optional=${pcre_star}'?'
    # local pcre_star_optional_grouped='('${pcre_star}')?'

#     :global.doc <<'/---'
# :int ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPES
# 
# When parsing callable prototype arguments with
# ${ZY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE}, the ${match} index for the
# currently parsed argument's mandatory *type* (i.e., concatenation of such
# argument's type indirective, local subtype, major subtype, and minor subtype).
# Such string is unparsed and hence intended _only_ for expansion in human-
# readable exception messages.
# /---
#     integer -g ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPES=$((
#         match_index++ ))

# While specifying a default value for such argument _also_ signifies such
# argument to be optional, missable implies such argument to have _no_ value
# rather than simply a default value if unpassed if unpassed. Hence, while
# similarly optional, optionalized arguments and defaulted arguments signify
# differing semantics requiring syntactic distinction.

# == Comparison to Defaulted Arguments ==
    # ${pcre_star_optional}${pcre_operable_type}${pcre_operable_name_slashed_optional}${pcre_operable_name_plussed_optional}
 # rather than an argument of such type
 
#, where `${subtype_major}`
# is such subtype
#, implying such argument to be validated by a call to function
# `${type}.die_unless`
# suffixing the name of the
# function validating such argument in the body of such callable).

    # Variable value.
    # local pcre_value_quoted_single=${pcre_quotes_single}

    # local pcre_plus_spaced_grouped='('${pcre_plus_spaced}')'
    # local pcre_plus_spaced_optional='(?:'${pcre_plus_spaced}')?'
    # local pcre_plus_spaced_optional_grouped='('${pcre_plus_spaced}')?'

# local pcre_eroteme_grouped='('${pcre_eroteme}')'
    # local          pcre_channel_value='(?:'${pcre_arg}'|'${pcre_args}')'
    # local pcre_channel_value_grouped='(?|('${pcre_arg}')|'${pcre_args_grouped}')'

    # local pcre_arg_channel_sans_args_name='(?!args)'${pcre_arg_channel_name}
    # local pcre_arg_channel_sans_args=${pcre_arg_channel_sans_args_name}${pcre_equals_spaced}${pcre_arg_or_args}
    # local pcre_arg_channel_sans_args_list='(?:'${pcre_arg_channel_sans_args}${pcre_comma_spaced}')*'
    # local pcre_arg_channels_with_args_grouped=${pcre_arg_channels_prefix}${pcre_arg_channel_sans_args_list}${pcre_arg_channel_with_args_grouped}${pcre_arg_channel_list}${pcre_arg_channels_suffix}

    #FUXME: Need a negative assertion preventing the first
    #${pcre_arg_channel_list} from matching "args = " -- perhaps a new
    #${pcre_arg_channel_sans_args_list}.

    # Pseudo-type signifying such callable to either return or accept nothing,
    # inspired by standard high-level language usage. Unlike pseudo-type ":full"
    # applying only to return values, this pseudo-type applies to both return
    # values and argument lists.
    #
    # Note that, for the latter purpose, an empty argument list also suffices
    # to convey the same purpose. However,
    # ":void my_func[args: ()]"  Technically, callable prototypes need *NOT*
    #
    # Note that, for the latter purpose, explicitly
    # specifying ":void" is equivalent to specifying no arguments 
    # local pcre_void=':void'

    # local         pcre_args='\(\s*+(?:'${pcre_void}'|'${pcre_args_list}')?\s*+\)'
    # local pcre_args_grouped='\(\s*+(?:'${pcre_void}'|'${pcre_args_list_grouped}')?\s*+\)'

    # Callable argument channels.
    # local          pcre_arg_or_args='(?:'${pcre_void}'|'${pcre_arg}'|'${pcre_args}')'
    # local pcre_arg_or_args_grouped='(?:('${pcre_void}'|'${pcre_arg}')|('${pcre_args}'))'

    # local         pcre_return_type='(?:'${pcre_full}'|'${pcre_void}'|'${pcre_operable_type}')'
    # local pcre_return_type_grouped='(?:'${pcre_void}'|('${pcre_operable_type}'))'

    # local pcre_return_type=${pcre_operable_type}
    # local pcre_return_type_grouped='(?:'${pcre_void}'|('${pcre_return_type}'))'
    # local         pcre_return_channels='\[\s*+[^]]*+\]'
    # local pcre_return_channels_grouped='\[\s*+([^]]*+)\]'

    #FUXME: Exclude attributes and names.
    # PCRE matching all semantic substrings in function prototypes, excluding
    # attributes and names. This includes return types, arguments, and AsciiDoc.
    # ZY_PROTOTYPE_FUNC_SANS_ATTRS_AND_NAMES_PCRE="${pcre_start}${pcre_attrs_grouped}${pcre_return_type_or_channels_grouped}${pcre_callable_name_or_names_grouped}${pcre_args_or_channels_grouped}${pcre_asciidoc}"'()$'

    # local pcre_global_grouped=${pcre_global_type_grouped}'\s++'${pcre_global_name_or_names_grouped}${pcre_global_value_grouped}

    # PCRE capturing the type, names, and optional value in global prototypes.
    # ZY_GLOBAL_PROTOTYPE_TYPE_NAMES_VALUE_PCRE=${pcre_global_grouped}

    # PCRE matching the next "="-suffixed global name in "="-delimited global
    # definitions. Such syntax mimics conventional "="-delimited variable
    # assignments in zsh and hence prohibits whitespace.

    # local pcre_attr_name=${pcre_operable_name}
    # local pcre_attr_name_grouped='('${pcre_attr_name}')'
    # local pcre_attr_value_unquoted=${pcre_operable_name}
    # local pcre_attr_value_unquoted_grouped='('${pcre_attr_value_unquoted}')'
    # local         pcre_attr_value=${pcre_colon_spaced}'(?:'${pcre_quotes_double}'|'${pcre_quotes_single}'|'${pcre_attr_value_unquoted}')'
    # local pcre_attr_value_grouped=${pcre_colon_spaced}'(?|'${pcre_quotes_double_grouped}'|'${pcre_quotes_single_grouped}'|'${pcre_attr_value_unquoted_grouped}')'

    # Abstract identifier used *ONLY* for descriptive purposes (e.g., function
    # argument names) and hence defined in a fairly crude but efficient manner.
    # Such PCRE is *NOT* intended to match actual zsh syntax (e.g., global
    # names). See ${ZY_DECLARATOR_PCRE_GLOBAL_NAME} below, in particular.

 # for such types
    # Since
    # all operable types defined by zeshy are unquoted, such PCRE matches only
    # the exact subset of characters used for such types.

    # However, since such support is a superficial convenience, there exists no
    # reason *NOT* to extend such support to alias syntax as well. So, we do.
    # Unquoted callable name. While quoted callable names may contain all
    # possible characters, unquoted callable names are constrained so as *NOT*
    # to conflict with prototype syntax. For simplicity, extend
    # ${pcre_operable_name} with punctuation guaranteed to avoid such conflict.
 # While reliably quoting
    # alias names is non-trivial (unlike functions), it *IS* feasible. See
    # :alias_command.define() for further details.
    #FUXME: Incorrect. We'll want to support quoted attribute values containing
    #arbitrary characters and hence possibly ">" or ",", requiring more
    #sophisticated parsing here.

    # local pcre_arg_value_content=${pcre_arg_value_quoted_double}'|'${pcre_arg_value_quoted_single}'|'${pcre_arg_value_number}
    # local       pcre_arg_value=${pcre_equals_spaced}'(?:'${pcre_arg_value_content}')'
    # local pcre_arg_value_grouped=${pcre_equals_spaced}'('${pcre_arg_value_content}')'

    # Equals sign preceded and followed by optional whitespace.
    # local pcre_equals_spaced='\s*+=\s*+'

    # local pcre_callable_names_grouped='\{\s*+((?:'${pcre_callable_name}'(?:'${pcre_comma_spaced}'|\s++))*'${pcre_callable_name}')(?:'${pcre_comma_spaced}')?\s*+\}'

    # Callable attributes. zeshy currently prohibits single- and double-quoted
    # attribute values, thus simplifying matching.
    # local         pcre_attrs='(?:<\s*+[^>]++>\s++)?'
    # local pcre_attrs_grouped='(?:<\s*+([^>]++)>\s++)?'

    #FUXME: Add support for variadic arguments.

    # local             pcre_arg=${pcre_operable_name}'\s++'${pcre_operable_name}'(?:'${pcre_arg_value}')?'
    # local pcre_arg_grouped='('${pcre_operable_name}')\s++('${pcre_operable_name}')(?:'${pcre_arg_value_grouped}')?'

    #FUXME: Correct me. *sigh*
    # local          pcre_args_list='(?:'${pcre_arg}${pcre_comma_spaced}'(?:\.\.\.'${pcre_comma_spaced}')?)*'${pcre_arg}'(?:'${pcre_comma_spaced}')?'
    # local          pcre_args_list='(?:'${pcre_arg}${pcre_comma_spaced}'(?:\.\.\.)?)*'${pcre_arg}'(?:'${pcre_comma_spaced}')?'

    # ZY_PROTOTYPE_ALIAS_NAMES_PCRE\
    # ZY_PROTOTYPE_ALIAS_NAMES_PCRE="${pcre_start}${pcre_return_type_or_channels}${pcre_callable_name_or_names_grouped}"

#FUXME: Rename ${ZY_PROTOTYPE_ALIAS_NAMES_PCRE} to
#${ZY_PROTOTYPE_ALIAS_NAMES_PCRE} and similarly for all other globals below
#containing "_PROTOTYPE". The focus is not the help string; the focus is the
#declarator itself. The help string is only optionally along for the ride, now.

    # PCRE matching all global names preceding the value to initialize such
    # namess to in "="-delimited global definitions. Such syntax mimics
    # conventional "="-delimited variable assignments in zsh and hence prohibits
    # whitespace.
#    ZY_DECLARATION_PCRE_GLOBAL_NAMES='((?:'${pcre_global_name}'=)+)(.*)'
#
#    # PCRE matching the next "="-suffixed global name in such definitions.
#    ZY_DECLARATION_PCRE_GLOBAL_NAME='('${pcre_global_name}')='

# This PCRE is *ONLY* used to validate such syntax and hence
    # captures no substrings.
    # PCRE matching the next "="-suffixed global name in a "="-delimited global
    # definition optionally followed by the final "="-prefixed global value.
    # Such syntax mimics conventional "="-delimited zsh variable assignments in
    # zsh and hence prohibits whitespace.

    # PCRE matching all global names preceding the value to initialize such
    # names to in "="-delimited global definitions. Such syntax mimics
    # conventional "="-delimited variable assignments in zsh and hence prohibits
    # whitespace.
#   ZY_DECLARATOR_PCRE_GLOBAL_NAMES='((?:'${pcre_global_name_ungrouped}'=)+)'
    # PCRE matching the next global name in a list of such names.

    # Function names. Since functions but *NOT* aliases support synonyms,
    # function and alias name syntax must be handled distinctly.
#   local pcre_function_name_grouped='('${pcre_callable_name_content}')'
#   local       pcre_function_name='(?:'${pcre_callable_name_content}')'
#   local pcre_function_names='\{\s*+((?:'${pcre_callable_name}'(?:'${pcre_comma_spaced}'|\s++))*'${pcre_callable_name}')(?:'${pcre_comma_spaced}')?\s*+\}'
#   local pcre_function_name_or_names='(?:'${pcre_callable_name_grouped}'|'${pcre_function_names}')\s*+'

    # Alias names. Since zsh permits single- and double-quoted alias names,
    # matching requires more than class negation. While quoting alias names is
    # is non-trivial (unlike functions), it *IS* feasible. See :alias_command.define()
    # for further details.
#   local pcre_alias_name_grouped='('${pcre_callable_name_content}')'
