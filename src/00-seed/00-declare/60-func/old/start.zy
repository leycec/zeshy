#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *function declarers* (i.e., callables declaring and hence necessarily
defining functions).
/---

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under zy://help in the main codebase.

#FIXME: Remove all reference to {prepend,append,set}_args_with_stdin() from the
#zeshy codebase, excluding set_args_with_stdin() where called from herestring-
#style aliases. In all other cases, such calls are highly dangerous and should
#be eliminated.
#FIXME: Wait. I believe we *MIGHT* be able to resuscitate such function *IF* we
#can augment them as follows (...no idea if this works, but it seems worth a
#try):
#
#* If standard input is an open pipe *AND* if list global ${pipestatus} is of
#  size larger than one, then doesn't that definitively suggest the current
#  function is directly piped standard input? Naturally, we should extensively
#  test this in vanilla zsh before running around like a mad badger attempting
#  to implement this in zeshy. Ah; perhaps not. For example, for the first
#  function called in such a pipe, wouldn't ${pipestatus} be the empty list?

# ....................{ ALIASES                            }....................
#FIXME: Document me.
alias -g ':func{'='
    [[ -n ${ZESHY__FUNC_NAMES-} ]] || :die\
        ''":func{" not preceded by ":func_" (i.e., ${ZESHY__FUNC_NAMES} undefined or empty).''
    function "${ZESHY__FUNC_NAMES[@]}" () {'

#FIXME: Document me.
alias '}:func'='}
    ::func_.stop'

# ....................{ DECLARERS                          }....................
# :void {:func_ ::func_.start}(:string func_prototype)
function :func_ ::func_.start() {
    (( # == 1 )) || :die 'Expected one function prototype.'

    # For efficiency, validate only the ${ZESHY__FUNC_PROTOTYPE} string global
    # to both exist and be set to the empty string. While the remaining globals
    # declared in :{globals} could also be validated, orthogonality would then
    # demand we also validate all globals declared by both this parcel and
    # :{stop} -- clearly exceeding the threshold of sanity. Since
    # ${ZESHY__FUNC_PROTOTYPE} is arguably the most significant of such
    # globals, that global is validated as a proxy for the remainder.
    [[ -z ${ZESHY__FUNC_PROTOTYPE-x} ]] || :die\
        '":func_" not preceded by "}:func" (i.e., ${ZESHY__FUNC_PROTOTYPE} undefined or non-empty).'
    ZESHY__FUNC_PROTOTYPE="${1}"
    # print -r 'prototype: '${ZESHY__FUNC_PROTOTYPE}

    # ..................{ INITIALIZATION                     }..................
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # For efficiency, captured match groups are expanded directly from the
    # canonical ${match} list global. Hence, this global must be preserved for
    # the duration of function prototype parsing. To ensure this, the following
    # *MUST* be avoided:
    #
    # * Calls to pcre_match() or use of the "=~" test operator, except where
    #   explicitly designed to avoid unintended consequences (e.g., function
    #   prototype argument parsing).
    # * Globs containing the "(b)" specifier enabling match group capturing.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Compile the PCRE matching all callable prototype syntax.
    :pcre.compile "${ZESHY__CALLABLE_PROTOTYPE_PCRE}"

    #FIXME: Completely insufficient. In any reasonable language, the specific
    #cause of such invalidity would be printed. "prototype invalid" does *NOT*
    #suffice. Unfortunately, printing finer-grained errors will require
    #finer-grained parsing specific to such errors. While we *COULD* implement
    #a full-bore generalized prototype parser for such purpose, such parser
    #would clearly be overkill. Instead, we believe the following to be a
    #middle-ground leveraging prior PCRE work:
    #
    #* In ={*-pcre}, define PCRE globals incrementally matching each prototype
    #  component in left-to-right fashion: e.g.,
    #    ZESHY_CALLABLE_PROTOTYPE_ERROR_ATTRS_PCRE=${pcre_start}${pcre_attrs}
    #    ZESHY_CALLABLE_PROTOTYPE_ERROR_RETURN_PCRE=${ZESHY_CALLABLE_PROTOTYPE_ERROR_ATTRS_PCRE}${pcre_return_type_or_channels}
    #    ZESHY_CALLABLE_PROTOTYPE_ERROR_NAMES_PCRE=${ZESHY_CALLABLE_PROTOTYPE_ERROR_RETURN_PCRE}${pcre_runnable_name_or_names}
    #  ...and so on, until matching all prototype components.
    #* Define a new function in ={die} iteratively attempting to match
    #  ${ZESHY__FUNC_PROTOTYPE} by each of the above such PCREs in the above
    #  order until one fails to match. The PCRE that fails to match clearly
    #  identifies the erroneous syntactic component.
    #* Given such component, we could then iterate the subcomponents of such
    #  component (e.g., attributes of the attribute list, names of the name
    #  list) until identifying the specific erroneous subcomponent.
    #
    #In other words, it's all quite feasible. So, please make it so.
    #FIXME: Alternately, consider the following integrated approach:
    #dramatically reduce ${ZESHY__CALLABLE_PROTOTYPE_PCRE} to the absolute
    #minimum required for matching such syntactic constructs; at the moment,
    #such PCRE does that as well as validate the entirety of callable prototype
    #syntax. It's the latter part we'd luck to cut. And while doing so is
    #certainly feasible and would certainly improve matching efficiency, doing
    #so would also require we perform validation elsewhere. Is this feasible?
    #Probably, but we'll need to look into it in greater detail.
    #
    #Before we consider an example, however, we should note that extracting
    #validation out of such PCRE has the extreme benefit of permitting us to
    #print human-readable parse errors. At the moment, all we can do is print a
    #single unhelpful blanket message (e.g., "zeshy: Function prototype
    #invalid:"). Since that's essentially unacceptable, we'll need to extract
    #such validation out *ANYWAY*. It *WILL* happen.
    #FIXME: As example of how one might do so, consider validation of "<"- and
    #">"-delimited runnable attributes. Since this function iteratively matches
    #each such attribute, we would need such iteration to *ALSO* perform
    #validation. But this should be no terrible burden; simply keep track of the
    #current match indices and throw an exception if the start index for the
    #current match is *NOT* one character after the end index for the prior match.
    #Additionally, after matching, throw an exception if the the end index for the
    #prior match is *NOT* the last character of such attributes string.
    #
    #And that's it. Since this is clearly efficiently implementable and clearly
    #improves both efficiency and exception readability, we have the green light.

    # Match such prototype into the canonical ${match} list global, containing
    # all groups captured from such prototype by such PCRE. If such prototype
    # is syntactically invalid, throw an exception.
    pcre_match -- "${ZESHY__FUNC_PROTOTYPE}" || ::func.die_of_prototype
    print -r 'prototype: '${ZESHY__FUNC_PROTOTYPE}
    integer match_index; for match_index ({1..${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_ARGS}}) { print -r 'match '${match_index}': '${match[${match_index}]-} }

    # If such match failed to capture such callable's attributes, names, or
    # arguments, throw an exception. While this should *NEVER* happen, human-
    # readable exceptions demand we ensure this.
    (( ${#match} >= ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARGS )) ||
        ::func.die 'attributes, names, and/or arguments unparsable.'

    # ..................{ PARSE ~ attrs                      }..................
    # Map from attribute name to value parsed from such prototype below.
    ZESHY__FUNC_ATTRS=()

    # If such prototype declares at least one attribute...
    if (( ${#match[
        ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS}]} )) {
        # For each attribute split on shell words from the matched substring of
        # all attributes, map such attribute's name to such attribute's value
        # if any or the empty string otherwise.
        #
        # By PCRE design, attribute syntax corresponds to shell word syntax.
        # Hence, attributes are efficiently matchable with built-in shell word
        # splitting rather than more costly and complex alternatives (e.g.,
        # PCRE- or glob-based matching). Dismantled, this is:
        #
        # * "${(Z~n~)...}", splitting shell words in a manner treating unquoted
        #   newlines as equivalent to unquoted spaces. By default, the "(z)"
        #   flag splits shell words in a manner converting unquoted newlines to
        #   semicolons -- which, while sensible for actual shell code, is *NOT*
        #   at all what we want. See "Z:opts:" in "man zshexpn" for details.
        for ZESHY__FUNC_MATCH ("${(Z~n~)match[
            ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS}]}") {
            # Split such attribute into its name and "="-prefixed value if any
            # (excluding such "="). Dismantled, this is:
            #
            # * "%%=*", removing everything after the first "=".
            # * "#*=", removing everything before the first "=".
            #
            # See set_strings_to_string_split_on_string() for details.
            ZESHY__FUNC_ATTRS[${ZESHY__FUNC_MATCH%%=*}]=${ZESHY__FUNC_MATCH#*=}
        }
    }
    print -r 'attrs: '${ZESHY__FUNC_ATTRS}

    # ..................{ PARSE ~ names                      }..................
    # Callable name matched from such prototype for prototypes declaring only
    # one such name. Since this is the common case, this name is localized.
    ZESHY__FUNC_MATCH=${match[
        ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAME}]-}

    # If such prototype declares only one name, set such list to this name
    # *AFTER* stripping both single- and double-quotes from this name. If this
    # name is unquoted, note that flag "(Q)" safely reduces to a noop.
    if (( ${#ZESHY__FUNC_MATCH} )) {
        ZESHY__FUNC_NAMES=( "${(Q)ZESHY__FUNC_MATCH}" )
    # Else, such prototype declares multiple names. In such case, set such list
    # to all shell words split from the substring of these names. By PCRE
    # design, name syntax corresponds to shell word syntax.
    } else {
        ZESHY__FUNC_NAMES=( "${(QZ~n~)match[
            ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES}]-}" )
    }
    print -r 'names: '${ZESHY__FUNC_NAMES}

    # ..................{ PARSE ~ args                       }..................
    #FIXME: For efficiency:
    #
    #* Inline the body of the :func.die_if() function here.
    #* Shift such function back to the main codebase.

    # If any such function already exists, throw an exception.
    :func.die_if "${ZESHY__FUNC_NAMES[@]}"

    # Clear such standard input argument list. Since both branches of the
    # conditional below set the standard argument list, we avoid doing so here.
    ZESHY__FUNC_ARGS_STDIN=()

    # If such prototype declared no first argument channel, such prototype
    # either declared:
    #
    # * An empty argument channel list (e.g., ":void :empty_channels[]").
    # * An empty argument list (e.g., ":void :empty_args()").
    # * A non-empty argument list (e.g., ":void :nonempty_args(:string here)").
    #
    # While syntactically different, the former two cases signify the same
    # semantics of empty standard and stdin argument lists. In either case, the
    # stdin argument list is empty. While the latter case differs both
    # syntactically and semantically, such case also implies the stdin argument
    # list to be empty. All three cases may be efficiently handled by setting
    # the possibly non-empty standard list -- ignoring the empty stdin list.
    #
    # By PCRE design, argument syntax are whitespace-delimited and hence
    # efficiently matchable with built-in shell word splitting.
    if (( ! ${#match[
        ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_ARGS}]-} )) {
        ZESHY__FUNC_ARGS_BASIC=( "${(Z~n~)match[
            ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARGS_BASIC}]-}" )
    # Else, such prototype declared one or two argument channels. Parse the
    # argument lists for the first such channel and the following optional
    # second such channel into the corresponding globals.
    } else {
        # For each match index of the name of the first and second channels...
        for ZESHY__FUNC_MATCH_INDEX (
            ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_NAME}
            ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_NAME}
        ) {
            # If such channel is either the customary or standard
            # input-specific argument list, set the corresponding string.
            case ${match[${ZESHY__FUNC_MATCH_INDEX}]-} {
            ('args')
                ZESHY__FUNC_ARGS_BASIC=( "${(Z~n~)match[
                    $(( ZESHY__FUNC_MATCH_INDEX + 1 ))]}" )
                ;;
            ('stdin')
                ZESHY__FUNC_ARGS_STDIN=( "${(Z~n~)match[
                    $(( ZESHY__FUNC_MATCH_INDEX + 1 ))]}" )
                ;;
            # Else if such channel name is empty, such channel *MUST* be an
            # unspecified second channel. Since such channel is optional, this
            # is *NOT* an error. (Simply ignore this.)
            ('') ;;
            # Else, such channel is unrecognized. Throw an exception!
            (*)
                ::func.die\
                    'argument channel '${match[
                        ${ZESHY__FUNC_MATCH_INDEX}]}' unrecognized.'
            }
        }
    }
    # print -r 'arg list (origi): '${match[${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_ARGS}]}
    print -r 'arg list (split): '${ZESHY__FUNC_ARGS_BASIC}
    # print -r 'arg list 1: '${ZESHY__FUNC_ARGS_BASIC[1]}
    # print -r 'arg list 2: '${ZESHY__FUNC_ARGS_BASIC[2]}
    # print -r 'arg list 3: '${ZESHY__FUNC_ARGS_BASIC[3]}
}

#FIXME: In lieu of unit tests...
# :func_ 'string :sami(string yimlo = "hello")'
# :func{
#     local yimlo="${1}"
#     print -r "yolo: ${yimlo}"
# }:func <<'/---'
# Sami says, "Yimlo!"
# /---
# () {
#     :sami 'YumYumEugh'
# }

# --------------------( WASTELANDS                         )--------------------
# ....................{ OBSOLETE                           }....................
#FUXME: Don't neglect to delete such map immediately after use in
#precompilation!
#FUXME: Actually, when we replace such map entirely with equivalent dynamically
#synthesized functions, this (clearly) ceases to become an issue. Make it so;
#then, excise or at least heavily refactor such map.

# Map each function name to the help string documenting such function.
# typeset -Ag ZESHY_FUNCTION_NAME_TO_HELP

#FUXME: This map can probably go away too. I'm unconvinced that recording alias,
#function, and global synonyms is genuinely worth the effort. After all, when we
#migrate to a function- rather than map-based help system, we *CAN* and probably
#should just define equivalent functions for all such synonyms and then entirely
#forget about the fact that they were synonyms in the first place. (This
#obviously applies to alias and global synonyms, as well.) Doing is both simpler
#and more efficient, since these three maps need no longer be compiled into or
#loaded from the digest file.
#FUXME: The only legitimate use of this map was checking whether or not such
#function had been previously declared. But that will *STILL* be easy to check
#when we migrate to a function-based help system, since in that case we simply
#test for the existence of such help function, in which case we know whether
#such function had been previously declared or not. Since such test is both
#simple and efficient, there truly exists no compelling reason at all to keep
#these maps around. Excise! Excise!

# Map each function name to the first name declared for such function.
# typeset -Agx ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST

    # Preserve such matches *BEFORE* attempting attribute matching, which
    # unavoidably overwrites the canonical ${match} list global.
    # match=( "${match[@]}" )

    # # Canonical globals, localized to avoid overwriting existing global and/or
    # # caller versions of such variables.
    # local MATCH ZPCRE_OP
    # local -a match

                # ZESHY__FUNC_STDIN=${match[
                #     $(( ZESHY__FUNC_MATCH_INDEX + 1 ))]}
                # ZESHY__FUNC_ARGS=${match[
                #     $(( ZESHY__FUNC_MATCH_INDEX + 1 ))]}
        # # Clear such list.
        # ZESHY__FUNC_NAMES=()
        # print -r 'names detected: '${match[
        #     ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES}]}
        #
        # # For each name split on shell words from such string, append such name
        # # to such list. By PCRE design, name syntax corresponds to shell word
        # # syntax. Hence, such names are efficiently matchable with shell word
        # # splitting (as above).
        # for ZESHY__FUNC_MATCH ("${(z)match[
        #     ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES}]-}") {
        #     print -r 'name: '${ZESHY__FUNC_MATCH}
        #     ZESHY__FUNC_NAMES+="${ZESHY__FUNC_MATCH}"
        # }

    # # List of all function names parsed from such prototype below.
    # ZESHY__FUNC_NAMES=()
    #
    # # If such prototype contains no name, throw an exception. While this should
    # # *NEVER* happen, safe is better than sorry.
    # (( ${#ZESHY__FUNC_MATCH} )) || ::func.die 'names unparsable.'
    #
    # # For each name split on shell words from such string, append such name to
    # # such list. By PCRE design, name syntax corresponds to shell word syntax.
    # # Hence, such names are efficiently matchable with shell word splitting.
    # # For efficiency, the ${ZESHY__FUNC_MATCH} string global is very abused.
    # for ZESHY__FUNC_MATCH ("${ZESHY__FUNC_MATCH}") {
    #     ZESHY__FUNC_NAMES+="${ZESHY__FUNC_MATCH}"
    # }

    # # If such prototype only declares one name, set such list to such name.
    # if (( ${#match[
    #     ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAME}]} )) {
    #     ZESHY__FUNC_NAMES=( "${match[
    #         ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAME}]}" )
    # # Else, such prototype declares multiple comma-delimited names. Since
    # # single- and double-quoted callable names may contain commas, such names
    # # must be iteratively matched with a PCRE rather than split on commas.
    # } else {
    #     # Clear such list.
    #     ZESHY__FUNC_NAMES=()
    #
    #     #FIXME: Excrutiatingly inefficient. This absolutely *MUST* be replaced
    #     #by an efficient alternative. Since the syntax for prototype names is
    #     #almost a proper subset of the syntax for zsh shell words, the
    #     #following approach based an shell word parsing should suffice:
    #     #
    #     #* Shell-word split the
    #     #  ${match[${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES}]}
    #     #  string of all comma-delimited prototype names on both whitespace
    #     #  and commas. If memory serves, setting the canonical ${IFS} global
    #     #  should suffice for this purpose. If not, ${(s~...~)...} just might.
    #
    #     # Compile such PCRE. See above for further details.
    #     pcre_compile -- "${ZESHY_CALLABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
    #
    #     # Match all names, appending each to such list.
    #     ZPCRE_OP='0 0'
    #     while {
    #         pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
    #             "${match[${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_NAMES}]}"
    #     } {
    #         ZESHY__FUNC_NAMES+="${match[1]}"
    #     }
    # }

#, match their names and optional suffixing values into such map.
            # Split such attribute into its name and "="-prefixed value if any
            # excluding such "=". For efficiency, do so "in-place". Hereafter,
            # ${ZESHY__FUNC_MATCH} contains such name and ${match[1]} such
            # value if any or the empty string otherwise. Dismantled, this is:
            #
            # * "%%", greedily removing all text after...
            # * "=", such attribute's first "=" delimiter.
            # * "(#b)", enabling group capturing.
            # * "(*)", capturing such attribute's value into ${match[1]}.
            # ZESHY__FUNC_MATCH=${ZESHY__FUNC_MATCH%%=(#b)(*)}
            # ZESHY__FUNC_ATTRS[${ZESHY__FUNC_MATCH}]=${match[1]-}

            # ZESHY__FUNC_ATTR_NAME="${ZESHY__FUNC_MATCH}"
            # ZESHY__FUNC_ATTR_VALUE="${ZESHY__FUNC_MATCH}"
    #FUXME: Is this still required? Possibly for argument parsing. Possibly.
    #However, at that point, won't we have already stripped everything we need
    #out of ${match}? In such case, couldn't we simply reference ${match} as is
    #below and excise ${match}? Contemplate.

    # # If such prototype specifies at least one attribute, match their names and
    # # optional suffixing values into such map. Since single- and double-quoted
    # # values may contain commas, such attributes must be iteratively matched
    # # with a PCRE rather than split on commas.
    # if (( ${#match[
    #     ${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS}]} )) {
    #     #FUXME: Excrutiatingly inefficient. While shell word splitting could
    #     #probably be used here, we probably instead want to use the clever new
    #     #approach we discovered. Basically, reuse the already compiled PCRE
    #     #matching entire function prototypes by iteratively matching the *LAST*
    #     #attribute from the attribute list defined by the current prototype,
    #     #removing that attribute from that list, and rematching until all
    #     #attributes have been matched. See @{stop} for similar logic.
    #
    #     # Compile such PCRE.
    #     pcre_compile -- "${ZESHY_CALLABLE_PROTOTYPE_ATTRS_NEXT_PCRE}"
    #
    #     # Match all attributes, mapping each to the colon-prefixed value
    #     # suffixing such attribute if such attribute is suffixed by such a
    #     # value or to the empty string otherwise.
    #     ZPCRE_OP='0 0'
    #     while {
    #         pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
    #             "${match[${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS}]}"
    #     } {
    #         ZESHY__FUNC_ATTRS[${match[1]}]="${match[2]-}"
    #     }
    # }

    # Clear such map. Ordinarily, orthogonality would suggest also clearing
    # such list here. Unlike such map, however, such list need only be
    # conditionally cleared. It's complicated. And boring. (Be gone!)
    # ZESHY__FUNC_ATTRS=()

    # [[ ${ZESHY__FUNC_PROTOTYPE} =~ ${ZESHY__CALLABLE_PROTOTYPE_PCRE} ]] ||
    #     ::func.die_of_prototype
    # Compile the PCRE matching all callable prototype syntax. For efficiency,
    # such compilation is optimized.
    # pcre_compile -- "${ZESHY__CALLABLE_PROTOTYPE_PCRE}"
    # pcre_study

# ....................{ DECLARERS                          }....................
#FUXME: Obsolete. Replace with calls to :declare_func-().

# function declare_function() {
#     # Validate sanity.
#     (( # == 1 )) || :die 'Expected one help string.'
#     local help__df="${1}" function_name__df
#     local -a function_names__df help_match__df
#
#     #FUXME: Most function prototypes passed to this function are now *BROKEN*
#     #by recent syntactic improvements. Since permitting this function to
#     #attempt to parse such prototypes below would induce unhelpful and largely
#     #ignoreable exceptions, avoid doing so by returning immediately. Yes, this
#     #effectively reduces all calls to this and :func.document() to
#     #noops -- implying we *REALLY* need to excise them.
#     return 0
#
#     # Unless such string matches the function help PCRE, throw an exception.
#     [[ "${help__df}" =~\
#        "${ZESHY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE}" ]] || :die\
#         'Function prototype "'${help__df}'" invalid.'
# #   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
# #       print "match ${match_index}: ${match[${match_index}]}"
# #   }
#
#     # List of substrings captured by the prior match. The PCRE-based iteration
#     # performed by set_lists_to_runnable_prototype_name_or_names:() below
#     # overwrites ${match}, necessitating we preserve it here.
#     help_match__df=( "${match[@]}" )
#
#     # List of function names declared by such prototype.
#     set_list_and_map_to_runnable_prototype_name_or_names:\
#         function_names__df\
#         ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST\
#         "${help_match__df[2]-}"\
#         "${help_match__df[3]-}"
#
#     # If such function has attributes, match such attributes.
#     if [[ -n "${help_match__df[1]}" ]] {
#         # List of function attributes split from such string. Split on commas
#         # after truncating:
#         #
#         # * Optional whitespace surrounding commas (e.g., from " , " to ",").
#         # * Optional trailing commas and/or whitespace.
#         local -a attributes__df; attributes__df=(
#             "${(s:,:)${help_match__df[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]#,#[[:space:]]#}"
#         )
# #       for ((match_index=1; match_index <= ${#attrs}; ++match_index)) {
# #           print "attr ${match_index}: ${attrs[${match_index}]}"
# #       }
#
#         # If such attributes include "globbable," disable filename globbing for
#         # all arguments passed to such function names. See is_list_contains()
#         # for further details.
#         if (( ${attributes__df[(i)globbable]} <= ${#attributes__df} )) {
#             #FUXME: For efficiency, this and the following loop should be
#             #centralized into a single loop. This will become increasingly vital
#             #as the number of such loops in this function inevitably
#             #proliferates.
#             for function_name__df ("${function_names__df[@]}") {
#                 # For safety (in the event of function names containing alias-
#                 # reserved characters), call :alias_command.define() rather than manually
#                 # defining such alias.
#                 :alias_command.define\
#                     "${function_name__df}" "noglob ${(q)function_name__df}"
#             }
#         }
#     }
#
#     # Map the first function name to such help string. Note the choice of
#     # mapping function name synonyms to the first function name in
#     # set_list_and_map_to_runnable_prototype_name_or_names:, as well; this is
#     # *NOT* a coincidence, as could be inferred.
#     ZESHY_FUNCTION_NAME_TO_HELP[${function_names__df[1]}]="${help__df}"
#
#     # Add all such functions to the current parcel.
#     for function_name__df ("${function_names__df[@]}") {
#         :parcel.add_function "${ZESHY_PARCEL_NAME}" "${function_name__df}"
#     }
# }
#
# #FUXME: Obsolete. Replace with calls to :declare_func().
# function :func.document() {
#     run_runnable_with_stdin declare_function
# }

    #FUXME: Actually, while everything above certainly applies, the
    #long-hanging fruit is simply to print the tracing output of "pcretest" on
    #this prototype. While certainly not the most readable of approaches, it's
    #a heck of a lot more helpful than the current approach. It also requires
    #essentially no work, as the ::pcre.die_of_subject_not_matching() function
    #already implements this. Something is better than nothing, right?
    # [[ ${ZESHY__FUNC_PROTOTYPE} =~\
    #    ${ZESHY__CALLABLE_PROTOTYPE_PCRE} ]] || ::func.die 'prototype invalid.'

        # Compile such PCRE. For efficiency, avoid optionally optimizing such
        # PCRE by calling pcre_study(). (Ad-hoc profiling suggests such
        # optimization to consume more time than it saves.) See
        # for_string_text_matching_pcre:() for further details.
        # pcre_compile -- "${ZESHY_CALLABLE_PROTOTYPE_ATTRS_NEXT_PCRE}"

#FUXME: Rename to ::func_.begin() and ::func_.stop() to ::func_.end(). Possily.
#Contemplate, in any case.
#FUXME: Document me.

# (e.g., for boolean attributes).
    #FUXME: If nonempty, we need to excise the last character of such match,
    #which we should validate to *ALWAYS* be ")". Similar logic applies to
    #argument channels below, as well.
    #FUXME: Actually, honestly, such logic seems an increasingly poor idea.
    #Excise all such suffixing ")" tomfoolery and revert us back to sanity.

#FUXME: I'm beginning to question the wisdom of maintaining separate
#"_with_stdin" versions. Since AsciiDoc syntax *FUNDAMENTALLY* conflicts with
#single- and double-quoted string syntax, I see little point in continuing to
#maintain such versions. The work involved has been a headache from the start.
#It also renders the codebase less readable than it should be. Ideally,
#everything should resemble:
#
#    declare_function <<'/---'
#    ...
#    /---
#
#Rather than:
#
#    :func.document <<'/---'
#    ...
#    /---
#
#To synopsize:
#
#* Change declare_function() to require documentation passed as stdin. (Indeed,
#  such documentation should be optional for aliases and globals but *NOT*
#  functions; in the former case, the alias or global to be declared can be
#  specified entirely in separate arguments. Since this is *NOT* the case for
#  functions, require stdin.)
#* Inline the run_runnable_with_stdin() implementation in each such function,
#  for both simplicity and efficiency. (It's not terribly complex, really.)
#* Replace all existing calls to :func.document() with
#  declare_function().
#FUXME: This largely obsoletes the run_runnable_with_stdin() function, which,
#due to its still usefulness, should be shifted into "runnable/command/command"
#(or a similar parcel nearby).

 # If such argument list
    # is indeed empty, setting such string simply clears such string; else, setting such string 
 # both the 
    # necessarily declared a standard argument list.
    # # If such prototype declared a standard argument list, munge such string.
    # if [[ -n ${ZESHY__FUNC_ARGS} ]] {
    #     # If the last character of such list is *NOT* ")", throw an exception.
    #     # By PCRE design, such list terminates on such otherwise ignorable
    #     # delimiter, efficiently ensuring this branch succeeds even on empty
    #     # argument lists (i.e., "()"). (While this exception should *NEVER*
    #     # trigger, its preservation guards against unseemly regressions.)
    #     [[ ${ZESHY__FUNC_ARGS[-1]} == ')' ]] || ::func.die\
    #         'standard argument list terminator not ")" in prototype'

    #     # Set such string, excising such terminating ")".
    #     ZESHY__FUNC_ARGS=${ZESHY__FUNC_ARGS[1,-2]}
    # }

    # Such conventional argument list. 
    # ZESHY__FUNC_ARGS=${match[${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARGS}]}
    # print -r 'arg list (before): '${ZESHY__FUNC_ARGS}

        # If such match failed to capture such channels, throw an exception.
        # (( ${#match} >=\
        #    ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_ARGS )) ||
        #     ::func.die 'argument channels unparsable from prototype'

    # no standard argument list, such prototype
    # declared either one or two argument channels. Parse the argument lists
    # for such channels into the corresponding strings.

#-z ${ZESHY__FUNC_ARGS} && 
 # Since both branches of the
    # conditional below set such customary argument list, avoid doing so here.
    # # If such prototype declared a customary argument list, set such string.
    # if [[ -n ${ZESHY__FUNC_ARGS} ]] {
    #     # If the last character of such list is *NOT* ")", throw an exception.
    #     # By PCRE design, such list terminates on such otherwise ignorable
    #     # delimiter, efficiently ensuring this branch succeeds even on empty
    #     # argument lists (i.e., "()"). (While this exception should *NEVER*
    #     # trigger, its preservation guards against unseemly regressions.)
    #     [[ ${ZESHY__FUNC_ARGS[-1]} == ')' ]] || ::func.die\
    #         'argument list terminator not ")" in prototype'

    #     # Set such string, excising such terminating ")".
    #     ZESHY__FUNC_ARGS=${ZESHY__FUNC_ARGS[1,-2]}

                # Discard the ")" suffixing such match. See ={*-pcre}.
                # Discard the ")" suffixing such match. See ={*-pcre}.

# By PCRE design, such character is guaranteed to be , which should validate to *ALWAYS* be ")".
    # Such conventional argument list.
    # ZESHY__FUNC_ARGS=${match[${ZESHY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARGS}]}

    # If such prototype did *NOT* specify a conventional argument list, such
    # prototype specified either one or two argument channels. Parse the
    # argument lists for such channels into the corresponding strings.
    # if [[ -z ${ZESHY__FUNC_ARGS} ]] {

#_not_ 
# :map_global ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST <<'/---'
# Map each function name to the first function name declared for such function.
# Since all first function names map to themselves, this map contains the
# *identity map* (i.e., for each map key, there exists a key-value pair mapping
# such key to the same value): e.g.,
# 
# .ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST()
# ==========================================
# [source]
# ------------------------------------------
# >>> string on_duty=\
# ...    "It is the fundamental duty of the citizen to resist and to restrain the
# ...     violence of the state. Those who choose to disregard this responsibility
# ...     can justly be accused of complicity in war crimes, which is itself
# ...     designated as 'a crime under international law' in the principles of the
# ...     Charter of Nuremberg."
# >>> function war_crimes tribunal on_vietnam() { :string.output "${on_duty}" }
# >>> :string.output\
# ...    "war_crimes: ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST[war_crimes]}
# ...     tribunal:   ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST[tribunal]}
# ...     on_vietnam: ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST[on_vietnam]}"
# war_crimes: war_crimes
# tribunal:   war_crimes
# on_vietnam: war_crimes
# ------------------------------------------
# ==========================================
# /---

# :string_global ZESHY__FUNC_PROTOTYPE__ <<'/---'
# Function prototype passed to the prior call to :declare_func(). This global is
# intended to be referenced _only_ by the subsequent call to ::declare_func() by
# the expansion of alias }:func() -- typically to:
# 
# * Identify the name(s) of the current function to be declared.
# * Document such function.
# /---

    # Clear such conventional and standard input-specific argument lists.
    # ZESHY__FUNC_ARGS=
    # ZESHY__FUNC_STDIN=

# See ={parse} for function declaration terminator :func_.stop() -- arguably
# the most complex, essential, and fragile function in the zeshy ouvre.

        #FUXME: Globalize.

#         # Index of the current non-existent list item to be appended.
#         ZESHY__FUNC_NAME_INDEX=1
# 
# :global.document <<'/---'
# :int ZESHY__FUNC_NAME_INDEX
# 
# 1-based index of the current name in the current name list. This private global
# is intended to be referenced _only_ by ::func_.start().
# /---
# integer -g ZESHY__FUNC_NAME_INDEX

# :global.document <<'/---'
# :string ZESHY__FUNC_LHS
# 
# String expanding to an assignable *left-hand side* (LHS) (e.g.,
# `ZESHY__FUNC_NAMES[1]`). This optimization-specific private global is intended
# to be referenced _only_ by :func_() and cohorts.
# /---
# typeset -g ZESHY__FUNC_LHS

    #FUXME: Globalize such locals.
    # local -a match

    #FUXME: This function and hence all functions such function transitively
    #calls (particularly, ::callable_prototype.set_attrs,names,args_of_label())
    #should be optimized in a similar manner to that of :func_.stop().
    #Specifically:
    #
    #* All locals declared by
    #  ::callable_prototype.set_attrs,names,args_of_label() should be
    #  globalized. (Since such function declares many such locals in a
    #  conditional manner, this is actually quite a few locals -- including,
    #  significantly, at least one non-scalar variable.)
    #* Internal function calls should be avoided. Specifically:
    #  * Inline the call to :list.set_to_string(), implying we may no longer
    #    require such function at such an early time. (Hopefully!)
    #  * Inline the call to :string.set(). Since such function *ALREADY*
    #    inlines similar calls for setting map and list items, this is no great
    #    obstacle to well-written progress.
    #FUXME: Do we actually call :func_prototype.set_attrs,names,args() from
    #elsewhere? If not, it probably makes most sense to embed such
    #functionality directly here -- which will also simplify optimization.
    #Thereafter:
    #
    #* Excise :func_prototype.set_attrs,names,args().
    #* Rename this parcel to ={start}.
    #* Rename ={parse} to ={stop}.

    # Parse the map of function attributes and list of function names declared
    # from such prototype.
    # :func_prototype.set_attrs,names,args,stdin\
    #     "${ZESHY__FUNC_PROTOTYPE}"\
    #     ZESHY__FUNC_ATTRS\
    #     ZESHY__FUNC_NAMES\
    #     ZESHY__FUNC_ARGS\
    #     ZESHY__FUNC_STDIN
    # print -r "args: ${ZESHY__FUNC_ARGS}"

    #FUXME: Globalize such string local.
    #FUXME: Actually use such string local.
    # local ZESHY__FUNC_STDIN

    #such function (and arguably shift this entire function to
    #={parse}.

#FUXME: Consider implementing a:
#
#* New return pseudo-type ":full". We're increasingly tired of repeating the
#  return channel list "[stdout = :string, stderr = :string, status = :int]"
#  for runnables running arbitrary commands. Note this will require us to
#  differentiate between pseudo-types ":full" and ":void", necessitating a
#  minor change to PCRE group capturing (but probably *NOT* to parsing, as I
#  believe we currently don't parse return types or channels). And -- yes,
#  we've extensively searched for adequate synonyms of full, and none suffice.
#  In the end, the two most compelling reasons for full are:
#  * It reads as equally well as an adjective as void (e.g., "full function",
#    "void function").
#  * It's the obvious antonym of void and equally as many characters, sufficing
#    for the pendant in all of us.

#FUXME: As an aside, it *IS* feasible to reliably localize strings indirectly
#referring to variable names. Just employ a new "{"- and "}"-delimited syntax,
#inspired by CLI aliases: e.g.,
#
#    :void my_func(`:string my_string{__mf}, `:int my_int{__mf})
#
#This results in the following localization within such function body:
#
#    :string my_string__mf="${1}" my_int__mf="${2}"
#
#...but in the following function prototype when presented to external users:
#
#    :void my_func(:string my_string, :int my_int)
#
#For readability, external prototypes omit all compilation-specific syntactic
#directives. Nice, eh?
#FUXME: Actually, employing "{"- and "}"-delimited syntax here is overly
#cumbersome (both to write and to parse), as we only genuinely require a single
#delimiting character for such purposes -- say, "^" or "+": e.g.,
#
#    :void my_func(`:string:string string_name+__mf, `:int int+__mf)
#    :void my_func(`:string:string string_name/__mf, `:int int/__mf)
#    :void my_func(`:string:string string_name#__mf, `:int int#__mf)
#    :void my_func(`:string:string string_name%__mf, `:int int%__mf)
#    :void my_func(`:string:string string_name|__mf, `:int int|__mf)
#    :void my_func(`:string:string string_name^__mf, `:int int^__mf)
#    :void my_func(`:string:string string_name*__mf, `:int int*__mf)
#    :void my_func(`:string:string string_name~__mf, `:int int~__mf)
#    :void my_func(`:string:string string_name.__mf, `:int int.__mf)
#    :void my_func(`:string:string string_name;__mf, `:int int;__mf)
#
#Right. So, "/" is pretty clearly the winner here. Such character implies an
#either-or conditional, which is indeed semantically the case here, as well as
#not overtly conflicting with existing syntax (e.g., unlike "#"). That said,
#"+" remains a compelling choice as well (for patently clear reasons).
#
#    :void func(`:string+glob glob+__mf, `:int+positive int+__mf)
#    :void func(`:string/glob glob/__mf, `:int/positive int/__mf)
#    :void func(`:string/glob glob+__mf, `:int/positive int+__mf)
#
#Oh, my. "+" is *CLEARLY* the superior choice here.
#FUXME: As the prior example demonstrates, we need to support "+" delimitation
#in both argument types *AND* names. In the former case, such "+" delimits the
#argument type to be declared during localization (e.g., ":string") from the
#stricter suffix of the validating exception handler (e.g., ":string_glob"); in
#the latter case, such "+" delimits the argument name to be externally
#published (e.g., "glob") from the argument name to be internally declared
#during localization (e.g., "glob__mf").
#FUXME: Wait. As the prior explanation suggests, "+" would literally imply
#opposite semantics under such syntax! Which is bad. To correct this, note that
#we (probably) want to separate argument types for localization purposes from
#argument types for validation purposes. Since the two need not have anything
#to do with one another, consider this:
#
#    :void func(
#        `:string/:string_glob glob+__mf,
#        `:int/:int_positive int+__mf)
#    :void func(
#        `:string/glob glob+__mf,
#        `:int/positive int+__mf)
#
#Somewhat more verbose, of course, but substantially more generalizable. Hmm;
#since most cases *WILL* duplicate the argument type for localization  in the
#argument type for validation, however, perhaps we might provide a shorthand
#abbreviation for doing so? Consider:
#
#    :void func(`:string+_glob glob+__mf, `:int+_positive int+__mf)
#
#Uh; right. You know, that looks good. Let's just dispense with this kludgy "/"
#business. If the two argument types differ that substantially, the function
#body should just manually call the desired exception handler.
#
#It *IS* odd, however, that the above example would be localized as
#":string glob__mf" and validated as ":string.die_unless_glob glob__mf".
#Oh; nevermind. That makes perfectly consistent internal sense, as well. O.K.;
#O.K.; "+" it is for both. Yay!
#FUXME: Hmm; there exists an interesting edge case suggesting "+" may *NOT*
#necessarily be the most appropriate signifier. Ideally, it would be nice to
#permit not merely the type but value of the variable to which indirect
#arguments refer to be validated; "+" syntax, however, only supports the
#latter. Consider:
#
#    :void :func.set_string_to_orthonormal_prefix(
#        :string:int+negative int_name+__mf,
#        `:string+glob glob+__mf,
#        `:int+positive int+__mf)
#
#So, the variable referred to by the first argument above would have its type
#validated by calling :Int.is() and its value validated by calling
#:int.is_negative(). Actually, that works perfectly with "+" syntax, which is
#mildly pleasing to the rain-besought ego.

#FUXME: The "_DECLARE" is silly, here. Given the "__" suffix, globally drop
#such "_DECLARE" from global names: e.g., rename
#${ZESHY__FUNC_PROTOTYPE} to
#${ZESHY_FUNC_PROTOTYPE}.

#FUXME: Replace the current "<globbable>" attribute by a new argument
#pseudo-type ":glob", which function parsing should then internally detect and
#set a local boolean if at least one argument has such type: e.g.,
#
#    # Shift from this...
#    <globbable> [status = :bool] :is_string_matches_glob(
#        :string text, :string glob)
#
#    # ...to this.
#    [status = :bool] :is_string_matches_glob(:string text, :glob glob)
#
#I think we can all agree the latter to be demonstrably superior.
#FUXME: Actually, for readability (and orthogonality with existing subtypes
#like ":int_positive"), such subtype should really be ":string_glob": e.g.,
#
#    [status = :bool] :is_string_matches_glob(:string text, :string_glob glob)
#
#We'll need to globally replace everywhere we previously wrote ":glob", sadly.

#FUXME: It could also be nice to concoct opt-in syntax for having zeshy
#automatically synthesize argument localization on behalf of declared
#functions. This should absolutely *NOT* happen by default (...just consider
#functions accepting variable names, for example), necessitating we devise no
#syntax. Since such syntax should apply to the *ENTIRE* argument list (i.e.,
#either zeshy localizes *ALL* passed arguments or it localizes none), there
#exist a number of approaches:
#
#1. A new runnable attribute "<localize>" (e.g.,
#   "<localize> :void :my_func(:string my_arg)").
#
#O.K.; forget the other approaches. The above is pretty awesome. It's a wee
#verbose, yes: but given the import, this doesn't seem horribly out of place.
#Indeed, we could then provide a second related attribute for localizing
#attributes suffixed by a function name-derived acronym. Wait; that's actually
#*VERY* bad, as functions defined by such a function would silently alter their
#definition (thus almost certainly breaking) on mere function renames, which is
#horrible. So *NEVER, EVER* go down that road. (Thanks.)
#
#Anyway: the above approach fairly rocks. So, hey-ho: let's go.
#FUXME: Wait. Rather than having a function-wide localization attribute, it'd
#probably be significantly more helpful going forward to have an
#argument-specific syntax -- ideally, only a single character prefixing or
#suffixing such argument's type. For example:
#
#    # In this case, the string but *NOT* integer would be localized.
#    :void my_func(:=string my_string, :int my_int)
#
#    # Alternative syntax to the above:
#    :void my_func(`:string my_string, :int my_int)
#    :void my_func(^:string my_string, :int my_int)
#    :void my_func(&:string my_string, :int my_int)
#    :void my_func(|:string my_string, :int my_int)
#    :void my_func(\:string my_string, :int my_int)
#    :void my_func(/:string my_string, :int my_int)
#    :void my_func(@:string my_string, :int my_int)
#    :void my_func(>:string my_string, :int my_int)
#    :void my_func(<:string my_string, :int my_int)
#    :void my_func(v:string my_string, :int my_int)
#    :void my_func(+:string my_string, :int my_int)
#    :void my_func(~:string my_string, :int my_int)
#    :void my_func(#:string my_string, :int my_int)
#    :void my_func(*:string my_string, :int my_int)
#    :void my_func(!:string my_string, :int my_int)
#    :void my_func(:string= my_string, :int my_int)
#    :void my_func($:string my_string, :int my_int)
#    :void my_func(:string $my_string, :int my_int)
#
#The above example suggests either a "^" or "@" prefixing such argument's type
#to be appropriate syntax here. We're currently partial towards "^". given
#zsh's current usage of such character prefixing variable names in parameter
#expansions... Hmm; perhaps those two usages have nothing in common, after all.
#Indeed, given that "@" signifies the passed argument list, perhaps a "@"
#prefix is the more appropriate, here. It reads a bit awkwardly, though; the
#"@" sign is so aesthetically strong as to compell the eye away from the
#remainder of the prototype, when such sign is arguably semantically
#insignificant by compare to the remainder of such prototype.
#
#We're currently partial towards either "^" prefixing the argument type *OR*
#"$" prefixing the argument name. The latter is reasonably interesting,
#directly implying such argument to be expandable as that name within the
#function body, whereas the former is more indicative of "copying" the
#following argument declaration into the head of the function body. Either way,
#we probably can't go *TOO* wrong here.
#FUXME: Actually, "$" is horrible, for a variety of obvious reasons -- chief of
#which is that it implies :func_() internally expands "$"-prefixed
#variable names embedded in function prototypes *BEFORE* parsing such
#prototypes, which is *NOT* at all the case. Given that, we're currently
#trending towards either "`" or "^". And we have to say, "`" appears
#surprisingly attractive. Consider:
#
#* "`" is semantically "free." zeshy currently avoids all internal use of "`",
#  unlike "^". "`" has no implicit meaning in a zeshy context and hence may be
#  repurposed with alternative semantics.
#* "`" is a conventional delimiting prefix in many languages.
#" "`" is syntactically and aesthetically "quiet" (i.e., visually unobtrusive).
#
#Honestly, I say we go with "`".
#FUXME: That said, "^" *DOES* get the idea across a bit more intuitively. Hmm;
#or *DOES* it, really? "`" *DOES* quite remind one of the use of single quotes
#in math jargon to denote derivative variables, which localized variables
#arguably are. Wow! There's a fairly compelling justification, if ever we heard
#one. And we've heard a few now.
#FUXME: After deep and reasonably lengthy contemplation, we've decided upon a
#syntactic technique hereafter referred to as "relaxation directives" --
#each consisting of the same single character and prefixing the syntactic
#element they "relax." What do we mean "relax"? Simple: they instruct our
#parser to relax what it would customarily do and *NOT* do that thing. To
#prevent semantic ambiguity and simplify lexical parsing (e.g., with the "?"
#suffixing argument names), all relaxation directives *PREFUX* their syntactic
#element. Horever, we haven't quite fixed upon a character; examples include:
#
#    :void my_func(`:string `my_string `= 'yumyum', :int my_int)
#    :void my_func(^:string ^my_string ^= 'yumyum', :int my_int)
#    :void my_func(*:string *my_string *= 'yumyum', :int my_int)
#    :void my_func(?:string ?my_string ?= 'yumyum', :int my_int)
#    :void my_func(/:string /my_string /= 'yumyum', :int my_int)
#    :void my_func(|:string |my_string |= 'yumyum', :int my_int)
#    :void my_func(%:string %my_string %= 'yumyum', :int my_int)
#    :void my_func(#:string #my_string #= 'yumyum', :int my_int)
#    :void my_func(~:string ~my_string ~= 'yumyum', :int my_int)
#    :void my_func(!:string !my_string != 'yumyum', :int my_int)
#
#While "!" is nice, when used with "!=", it implies a negative constraint
#(e.g., that such function throws an exception if such argument equals such
#string). Hence, prefer something else.
#
#O.K.; "*" is probably the most compelling prefix character. In PCREs, such
#character implies "0 or more"; here, it simply implies "0". Hmmm... Right.
#That's not quite aligned at all, is it?
#
#O.K.; "`" really remains an extraordinarily compelling choice here. A few
#meager reasons why:
#
#* It's probably the most aesthetically unobtrusive choice. Which is exactly
#  what we we want in this case, since relaxation directives are more-or-less
#  internal optimization concerns of negligible concern to end users.
#* It's also the most syntactically unobtrusive choice. We don't use "`"
#  anywhere within the codebase, leaving such character free for use here.
#* It's an appropriate prefix.
#
#And there you have it.
#
#That said, "^" remains a compelling choice as well, for similar reasons and
#due to implying "not" or "negation" somewhat more clearly than "`" due to its
#association with binary XOR operations. (Actually, that clearly has nothing to
#do with negation, so ignore that one.)
#
#Hmm. Nah; "^" is somewhat too loud and already used extensively in the
#codebase for alternative purposes. Let's run with "`"!
#FUXME: Implementing the above change requires another run-through the
#codebase, replacing existing usage of "?" with "`". Not a significant concern,
#of course, so we'll need to run-through anyway to implement delocalization.
#So, when we're at the point where we're ready to delocalize, also implement
#the above. Yeah: yay!
#FUXME: Actually, even the above is a bit... amiss. The default should be to
#localize, as that's what end users rightfully expect of reasonably high-level
#languages. They can elect to localize manually, of course, but that could
#simply be regarded as an optimization, which we syntactically denote with "?".
#Then, the following syntax serves to disable localization enabled by default:
#
#    :void my_func(?:string my_string{__mf}, ?:int my_int{__mf})
#
#Quite readable, we trust.

#FUXME: We can do *CONSIDERABLY* more with :func_(). Given the
#acquisition of function prototypes prior to their definitions, we can
#automatically synthesize function argument validation! Specifically:
#
#* If the current digest file is *NOT* an optimized build:
#  * Prepend an expression resembling
#    '$(( # == ${num_args_expected} )) || :die\
#        "Function ${func_name}() expects ${num_args_expected} rather than ${#} arguments:"$'\n'${func_prototype}
#  * For all arguments of type ":string" either prefixed or suffixed by a
#    string matching glob "(bool|float|int|list|map|string)_name", append the
#    previously prepended expression with a call to function
#    "die_unless_var_${var_type}", passing such call the numbered argument
#    corresponding to such variable name.
#    *ACTUALLY*, we probably want a new syntax for specifying the type of the
#    variable a pointer variable points to: e.g.,
#
#    :void :set_list_to_cthulhu(:string:list list_name)
#
#    Then, we simply perform such validation in a deterministic manner
#    dependenly *ONLY* on such type. Much more sensible. Make it so!
#
#There's probably a great deal more we could accomplish as well, but that
#certainly seems a respectable starting place. The helpful aspect of this whole
#thing isn't necessarily the code savings in reduced verbosity (though that's
#excellent as well, of course): it's the fact that this is pretty much the
#*ONLY* way to reliably elide such validation out of optimized builds.
#Pretty awesome, honestly.
#FUXME: Also consider implementing the following prototype validation features:
#
#* Optional type validation. It's easy to conceive of functions that (typically
#  for efficiency) depend on downstream functions to validate types. Indeed, in
#  a chain of such functions, it's often unnecessary for any functions except
#  the deepest in the call stack (e.g., :string.set()) to validate
#  the types of passed variables. Hence, we'll want a new syntactic construct
#  to permit callers to selectively disable such validation on a per-argument
#  basis. Fortunately, we already have a similar syntax for arguments
#  themselves: the eroteme. For example:
#
#    # Given this prototype, zeshy validates the type of the first argument.
#    [status = :bool] :set_int_to_arg_index_first_equaling_if_found(
#        :string:int int_name, :string arg)
#
#    # Given this prototype, however, zeshy does *NOT* validate the type of the
#    first argument.
#    [status = :bool] :set_int_to_arg_index_first_equaling_if_found(
#        :string:int? int_name, :string arg)
#
#  The only difference between the two, of course, is the "?" suffixing the
#  type of the first argument. Simple, no?
#
#* Argument subtypes. The typical example here are, say, positive integers:
#
#    [status = :bool] :get_arg_index(:int_positive arg_index)
#
#  Subtypes should be readily generalizable as follows:
#
#  * If there exists a runnable with name ":die_unless_${arg_subtype_local#:}", pass
#    such argument to such runnable in the preamble for such function.
#  * Of course, subtypes should be subject to suffixing erotemes as well.
#
#* Default value assignment. By default, argument names suffixed by a "="-
#  prefixed default value should *NOT* be programmatically assigned such value;
#  leave that to the implementation of such function. That said, there are
#  numerous cases (particularly exception handlers) where it'd be absurdly
#  convenient to have some means of :func_() assigning such argument
#  such value if unpassed. So, here's how: argument names suffixed by a ":="-
#  prefixed default value should be programmatically assigned such value.
#  What's nice about such syntax is that it leverages existing zsh syntax for
#  an orthogonal purpose. Here's a typical use:
#
#    :func_ '<globbable> :void :die_unless_string_matches_glob(
#        :string text,
#        :string glob,
#        :string error_message :=
#            "String \"${text}\" unmatched by glob \"${glob}\".")'
#
#  As such example demonstrates, default string (but *NOT* integer or float,
#  clearly) values should be assigned under parameter expansion flag "(e)",
#  ensuring expansion of expansions embedded in such values (as above).

    # To safeguard against (accidental or intentional) deletion of globals
    # referenced below and elsewhere, forcefully redeclare such globals.
    # typeset -g  ZESHY__FUNC_PROTOTYPE ZESHY__FUNC_ARGS
    # typeset -gA ZESHY__FUNC_ATTRS
    # typeset -ga ZESHY__FUNC_NAMES

        # ''List ${ZESHY__FUNC_NAMES} empty (e.g., as :func_() not previously called).''

    # :List.die_unless ZESHY__FUNC_NAMES

    #FUXME: Implement support for the following two function attributes,
    #documented by example:
    #
    #    <callback = on_zeshy_precompile, default_args_if = :context.is_cli_function>
    #
    #For the moment, don't bother extending the "hook" attribute to support
    #multiple hooks; we can certainly do so transparently later, if required.
    #
    #While the "callback" attribute is best handled in this function, the
    #"default_args_if" attribute is best handled in ::func_.parse_args().

    # Define integer locals declared above by parsing each argument in the
    # argument list embedded in such function's prototype.
    # ::func_.parse_args

#FUXME: Document me. For up-to-date commentary, see the implementation of
#::func_.stop().
#FUXME: Implement support for validating variable types (e.g.,
#":string:list", ":int").
#FUXME: Implement support for default argument handling. Since arguments
#can be directly set by index (e.g., "argv[1]='ok'"), this should be more
#than feasible. It will, however, require us to reexamine *ALL* current
#prototypes for valid default value definitions. (Ugh; we know.) Or, I
#suppose we could just defer such examination until the inevitable bugs
#crop up. Yah. Probably the latter.

    # Code to be prepended onto such function's body, set by the call to
    # ::func_.parse_args() below. Depending on such function's prototype, such
    # code localizes and/or validates function arguments.

                        #FUXME: We also need to set ${arg_name_expansion} to
                        #such argument's name -- which, presumably, will
                        #require a bit of refactoring below. (Again, only do
                        #this if we actually appended to
                        #${args_definitions_default} above).

                # Localize such argument.
                # cannot be reliably indexed by its positive
                # index (i.e., relative to the start of such argument list).
                # Since such argument can, however, be reliably indexed by its
                # negative index (i.e., relative to the end of such argument
                # list), replace the former with the latter. Happily, such
                # conversion applies regardless of whether such variadic
                # argument was optional or mandatory.

    # *NOT* contain such
    # argument, as in the case of defaulted arguments.

# , typically but *NOT*
    # necessarily such argument's positive or negative index in the current
    # argument list. Possible values include
                        #FUXME: Actually, if one considers it, such boolean is
                        #superfluous. Instead, simply test:
                        #
                        #    (( ${#args_definitions_default} ))
                        #
                        #Hence, excise such boolean here, above, and below.

                        # Note such fact.
        #                 arg_was_defaulted=1
        # arg_was_defaulted=0

    #FUXME: Can we not excise this somehow? A tab cumbersome.

    # 1 if a prior argument was assigned a default value under the current
    # argument count and 0 otherwise.
    # integer arg_was_defaulted

                    # Else such argument is optional but passed and hence both
                    # localizable and validatable without modification.
                    # } else {

                    #FUXME: This could probably be efficiently refactored in light
                    #of the above commentary. Or perhaps not: such logic must be
                    #performed regardless of whether such default value is relaxed.

                    # If such argument is defaulted rather than optionalized
                    # (regardless of whether such default value is relaxed), note
                    # such fact.
                    # if [[ -n "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE}]-}" ]] {
                    #     arg_was_defaulted=1
                    # }

                    # Else, such argument is either defaultable or optional
                    # *AND* variadic. In the former case, 

                    #FUXME: Insufficient. Before skipping to the next argument, 
                    #instead:
                    #
                    #* Test whether the current optional argument was assigned a
                    #  default value.
                    #* If so, append:
                    #  * An assignment of such argument to such value...
                    #  * To a (possibly new?) string or map local.
                    #
                    #The antler-mantled devil is the details, however. First, we
                    #need to resolve the order in which we perform such defaulting:
                    #do we default unpassed arguments *BEFORE* performing
                    #localization and validation? That would certainly seem to be
                    #the simplest implementation, but arguably *NOT* the most
                    #efficient. Why? Because that order implies we need to perform
                    #in-place modification of ${argv} list items. Now, when the
                    #optional arguments to be defaulted are the absolute last
                    #arguments, such modification simply appends to such list and
                    #hence is arguably inefficient; in all other cases, however,
                    #we'd need to either:
                    #
                    #* Shift all arguments following such unpassed arguments to the
                    #  right in ${argv} -- which is neither simple *OR* efficient.
                    #* Call set(), replacing the current argument list entirely.
                    #  While considerably simpler, it's that much less efficient.
                    #
                    #The alternative, of course, is to:
                    #
                    #* Append an appropriate entry to map
                    #  ${arg_declarers_to_definitions}, assigning such local to such
                    #  default value (rather than the customary indexed argument
                    #  expansion performed below).
                    #
                    #O.K.; that's pretty much the obvious thing to do. It's both
                    #simple and efficient, requiring no modification to either
                    #${argv} or logic below.
                    #FUXME: Wait. No, merely appending to
                    #${arg_declarers_to_definitions} fails. Why? Because:
                    #
                    #* The assignments implied by such map are performed *AFTER*
                    #  validating argument values. But we *REALLY* want default
                    #  values to be validated (particularly if such values embed
                    #  command substitutions).
                    #* Which brings us to... command substitutions. For simplicity,
                    #  ${arg_declarers_to_definitions} assumes all assignments
                    #  implied by key-value pairs *ALWAYS* succeed -- which, of
                    #  course, will *NOT* be the case for default values embedding
                    #  command substitutions.
                    #
                    #Hmm. Honestly, the set() approach *DOES* seem to be the
                    #simplest, when one takes into account both localization and
                    #validation. Perhaps more importantly, adopting such approach
                    #should reduce the amount of preamble code output for functions
                    #accepting defaulted arguments. Why? Because, under such
                    #approach, we need to no longer treat defaulted arguments as
                    #optional, thus reducing the number of possible argument
                    #counts. Indeed, under such approach, only optionalized
                    #arguments increase such number, reducing if conditional
                    #fan-out below.
                    #
                    #Hmm; or perhaps not? If one considers it, the set() approach
                    #really does introduce considerably more complexity than it
                    #erases. We *REALLY* want a
                    #${arg_declarers_to_definitions}-style approach. Now, we *CAN*
                    #reuse such map to safely *DECLARE* defaulted arguments; we
                    #just can't use such map to safely *DEFINE* defaulted
                    #arguments. To accomplish the latter, we'll simply need to
                    #append to a new newline-delimited *STRING* local
                    #${arg_defaults}. Sweet, no?
                    #FUXME: We've given this a meager amount of thought. The above
                    #is absolutely correct. It seems increasingly clear we also
                    #want to invert the order in which we perform
                    #declarations+definitions and validations: e.g.,
                    #
                    #    # Instead of this... (which obviously doesn't work!)
                    #    :string.die_unless_nonempty "${1}" "${2}" "${3}"
                    #    :string arg1="${1}" arg2="${2}" arg3
                    #    arg3="default"
                    #
                    #    # ...we want this.
                    #    :string arg1="${1}" arg2="${2}" arg3
                    #    arg3="default"
                    #    :string.die_unless_nonempty "${1}" "${2}" "${arg3}"
                    #FUXME: Wait. The above doesn't quite work either, if such
                    #defaulted argument is either an integer or float. Hmm. We
                    #*REALLY* want something resembling:
                    #
                    #    # ...we want this.
                    #    :int arg1="${1}" arg2="${2}" arg3
                    #    arg3="default"
                    #    :int.die_unless_nonzero "${1}" "${2}" "${arg3}"
                    #
                    #Oh, wait. That *DOES* work; we just need to be careful. If
                    #all function arguments are strings, we *COULD* safely pass
                    #such validation tester arguments expanded by name rather than
                    #value: e.g.,
                    #
                    #    :int.die_unless_nonzero "${arg1}" "${arg2}" "${arg3}"
                    #
                    #In all other cases, however, the *ONLY* arguments that may be
                    #safely expanded by name are those explicitly defaulted.
                    #If such argument is merely defaulted (whether in a relaxed
                    #manner or not), we'll need to soldier on and:
                    #
                    #* If validating such argument, expand such argument by name.

                    # If specified, assign such argument a default value.

                    # If such argument is absentable *AND* non-variadic, such
                    # argument must *NOT* exist and hence be neither localized
                    # or validated. To ensure this, skip to the next argument
                    # *AFTER* decrementing subsequent indices above. For
                    # efficiency, we prefer subtle logic equivalent to the
                    # following test:
                    #
                    #    if (( arg_is_absentable && ! arg_is_variadic )) {
                    #         continue
                    #    }
                    #FUXME: Hmm; we've refactored this a bit, below. Correct
                    #the commentary above. Perhaps shift to just above the call
                    #to continue(), below.
                    # (( arg_is_variadic + ${#arg_default_value} )) ||
                    #      continue

                    # # If such argument is variadic...
                    # if (( arg_is_variadic )) {
                    #     # ...and defaultable, throw an exception. While we may
                    #     # support variadiac defaultable arguments in the
                    #     # future, doing so now would impose additional
                    #     # complexities and inefficiencies for little gain.
                    #     (( ! ${#arg_default_value} )) || ::func.die\
                    #         'variadic argument ${'${arg_name}'} assigned a default value; consider either eliminating such assignment or refactoring such argument to be non-variadic'
                    # # Else if such argument is defaultable...
                    # } elif (( ${#arg_default_value} )) {
                    #     # Append an assignment of such argument to such default
                    #     # value to the newline-delimited string of such
                    #     # assignments.
                    #     args_definitions_default+=${code_indentation_outer}${arg_name}'='${arg_default_value}
                    # # Else such argument is neither variadic or defaultable.
                    # # Since the above conditional guarantees such argument to
                    # # be unpassed and either absentable *OR* defaultable, such
                    # # argument must be unpassed, absentable, and non-variadic.
                    # # Hence, such argument must *NOT* exist and hence be neither localized or validated.
                    # # To guarantee this, skip to the next argument entirely.

            # declarations and assignments must *NOT* be combined.

            # should report failure
            # and hence implicitly throw an exception. 
            #
            # However, combining declarations and assignments only behaves as
            # expected when *NO* assigned values are strings embedding process
            # substitutions subject to failure (e.g., 'something="$(false)"').
            # Ideally, attempting to assign such a string should report failure
            # and hence implicitly throw an exception. 
            #
            # If at least one such value is a string embedding at least one
            # such substitution, 
            #
            # The latter statement, however, d
            # Since
            # such values may contain process substitutions subject to failure
            # (e.g., "$(false)") *AND* since declarations *ALWAYS* succeed
            # under zsh (e.g., ":string dogma="$(false)" successfully declares
            # ${dogma} to be the empty string, despite

            #    :string arg1="${1}" arg2="${2}" arg3
            #    arg3="default"
            #    :string.die_unless_nonempty "${1}" "${2}" "${arg3}"

            # subsequent iteration validates such arguments.
        #FUXME: Compress the following two conditionals together.

        # # If such function only conditionally defaults arguments (e.g., only
        # # when called directly from the command line), ensure this.
        # if (( ${+ZESHY__FUNC_ATTRS[default_args_if]} )) {
        #     # Name of the alias or function reporting success when such
        #     # function accepts default arguments.
        #     args_is_defaultable_tester=${ZESHY__FUNC_ATTRS[default_args_if]}
        #     (( ${+aliases[${args_is_defaultable_tester}]} + 
        #        ${+functions[${args_is_defaultable_tester}]} )) ||
        #        ::func.die 'attribute "default_args_if" alias or function '${args_is_defaultable_tester}'() undefined'
        # }

    # Non-positive integer (i.e., strictly less than or equal to 0) by which to
    # offset the current argument index below. If such function accepts no
    # optional arguments, this integer remains 0; else, this integer is
    # decremented once for each optional argument rejected by the current
    # argument count. (See below for gritty details.)
    # integer arg_index_offset
    #     arg_index_offset=0

                    #FUXME: Doesn't this seem... well, redundant? After all,
                    #why can't we just offset such index directly: e.g.,
                    #    arg_index+=-1

                    # Since such argument is unpassed and hence has no assigned
                    # index at function call time, decrement all subsequent
                    # argument indices by one.
                    # arg_index_offset+=-1

            # Decrement such argument index by such offset. See above!
            # arg_index+=${arg_index_offset}

                    # Skip to the next argument.
                    # continue

                    #FUXME: If such argument is absentable *AND* non-variadic,
                    #continuing to the next argument appears to be the most
                    #appropriate approach here. Since we test variadicity below,
                    #we'd thus need to shift such continuation below such
                    #variadicity logic below -- say, something resembling:
                    #
                    #    if (( ! arg_count_optional && arg_is_optionalized && ! arg_is_variadic )) {
                    #         continue
                    #    }
                    #
                    #Nevermind. ${arg_is_variadic} is available *HERE*, implying
                    #such conditional be implemented here as simply:
                    #
                    #    if (( ! arg_count_optional && arg_is_optionalized )) {
                    #         continue
                    #    }
                    #
                    #Naturally, we'll need to declare two new booleans above (in a
                    #manner approximating that of ${arg_is_variadic} above):
                    #
                    #* ${arg_is_default}.
                    #* ${arg_is_optionalized}. Actually, this is silly; indeed, the
                    #  phrase "optionalized" is fairly *TERRIBLE*. This should
                    #  really be renamed to an adjective much more indicative of
                    #  such semantics -- say, ${arg_is_absent}, where "absent"
                    #  coincides nicely with "default".
                    #
                    #In such case, if the current argument count doesn't support
                    #such argument, such argument will be neither localized or
                    #validated, which seems not merely appropriate but necessary.

            # # If such argument is neither absentable or defaultable, such
            # # argument is non-optional and hence mandatory. Note such fact.
            # if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_IS_ABSENTABLE}]-}${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE}]-}" ]] {
            #     #FUXME: Right. Excise this conditional branch.
            #     true

            #FUXME: Probably replace with just ${arg_default_value}.

    # 1 if the current argument is defaultable and 0 otherwise.
    # integer arg_is_defaultable

    #FUXME: Since "(( arg_is_absentable || arg_is_defaultable ))"
    #deterministically implies ${arg_is_optional}, perhaps all tests of the
    #latter can simply be supplanted by the former, in which case the latter
    #could be excised entirely. Examine further.
    #FUXME: Indeed! Close examination suggests we only ever test such condition
    #once, suggesting such replacement to be a modestly wise approach.

    # 1 if the current argument is optional and 0 otherwise.
    # integer arg_is_optional

                # arg_is_optional=0
                # # Note such fact.
                # arg_is_optional=1

            #FUXME: For efficiency, shift "arg_was_variadic=1" immediately
            #above.
            # if (( arg_is_variadic )) { arg_was_variadic=1 }

    # 1 if the current argument count accepts at least one default argument and
    # 0 otherwise.

 # (While we could just as well invert such
                    # logic, such logic is optimized for the presumably common
                    # case of the caller *NOT* passing optional arguments.)
                    # # If passed the minimum number of arguments, start such if
                    # # conditional. (While we could just as well invert such logic,
                    # # such logic is optimized for the presumably common case of the
                    # # caller *NOT* passing optional arguments.)
                    # if (( arg_count == arg_count_min )) {
                    #         code_args_local_or_valid+='if (( # == '${arg_count}' )) {'
                    #     # Else such function only conditionally accepts default
                    #     # arguments *AND* the current argument count accepts
                    #     # exactly one such argument. In such case, test both such
                    #     # argument count *AND* the runnable reporting success if
                    #     # the current function call accepts default arguments.
                    #     } else {
                    #         code_args_local_or_valid+='if (( # == '${arg_count}' )) && { '${args_is_defaultable_tester}' } {'
                    #     }

    # Code reporting success if the current function call allows default
    # arguments, as specified by function attribute "default_args_if". If such
    # attribute is unspecified, such arguments are *ALWAYS* allowed; hence,
    # such code defaults to the empty string, implying unconditional success.
            # Delimit such alias expansion or function call by "{" and "}", as
            # such string will be embedded in an if conditional test below.
            # args_is_defaultable_tester='{ 'args_is_defaultable_tester' }'

                # If the current argument count accepts at least one default
                # argument *AND* such function unconditionally accepts such
                # arguments (the default), pretend such argument count accepts
                # no such arguments. Why? Because doing so simplifies logic
                # below.
                # if (( arg_was_defaulted &&\
                #       ! ${#args_is_defaultable_tester} )) {
                # }

#FUXME: It'd be great to add an additional runnable attribute -- this time,
#applicable to both aliases and functions. You may have noted extreme repetition
#in declaring hooks: e.g.,
#
#  :run_hook_on_zeshy_precompile precompile_zeshy_terminal_colors
#
#  :func.document <<'/---'
#  void precompile_zeshy_terminal_colors()
#
#  Define terminal color globals to be compiled into zeshy's user digest file.
#  /---
#  function precompile_zeshy_terminal_colors() { ... }
#
#To reduce such redundancy, support a new attribute "hooks: ...", where "..." is
#either the name of a single hook function or a list of such names. This reduces
#the above example to simply:
#
#  :func.document <<'/---'
#  <hooks: on_zeshy_precompile> void precompile_zeshy_terminal_colors()
#
#  Define terminal color globals to be compiled into zeshy's user digest file.
#  /---
#  function precompile_zeshy_terminal_colors() { ... }
#
#If such function also needed to be run on, say, zeshy startup, this could be
#expanded to:
#
#  :func.document <<'/---'
#  <hooks: (on_zeshy_precompile, on_zeshy_startup)>
#       void precompile_zeshy_terminal_colors()
#
#  Define terminal color globals to be compiled into zeshy's user digest file.
#  /---
#  function precompile_zeshy_terminal_colors() { ... }
#
#Alias and function prototype parsing should then parse such list (e.g., by
#"borrowing" the similar parsing we've already implemented for argument lists)
#and for each such string, prefix such string with "run_hook_on_", throw an
#exception if the result is not an existing function, and otherwise run such
#function with all such alias and function names.

    # Code indentation prefixes. If at least one argument is optional, all
    # localization and validation code will be embedded within if conditionals
    # rather than directly within the function body; in such case, indent such
    # code by one additional level of indentation.

                # Name of the hook function registering such callback.
    #FUXME: Actually, supplant such "hook" nomenclature with "event" instead.

# If 1,
    # all calls to such function must be prefixed by "noglob" to prevent zsh
    # from expanding such arguments as file globs.
        # # If such prototype declared attributes, handle such attributes.
        # if (( ${#ZESHY__FUNC_ATTRS} )) {
        #     # If such attributes include "globbable," disable filename globbing
        #     # for all arguments passed to such function by defining a simple
        #     # alias of the same name shadowing such function. See
        #     # is_list_contains() for further details.
        #     #
        #     # For safety (in the event of function names containing alias-
        #     # reserved characters), call :alias_command.define() rather than
        #     # attempting to manually define such alias.
        #     if (( ${ZESHY__FUNC_ATTRS[(i)globbable]} <=\
        #          ${#ZESHY__FUNC_ATTRS} )) {
        #         :alias_command.define "${func_name}" "noglob ${(q)func_name}"
        #     }
        # }

            #FUXME: Condense the conditional below here.

#  Only strings may reasonably refer to variables.
                # If such argument indirectly refers to another variable,
                # validate such variable's value as described above.
                # Since subsequent logic *WILL* validate such variable's
                # type, avoid doing so here.
                #FUXME: Wait. We nearly fell down the rabbit hole. Actually,
                #O.K.; we kind of already did. Here's the trick, you see: we
                #don't *CARE* about longhand indirection (e.g.,
                #":string/var+int") after performing the above validation. The
                #logic below *ONLY* applies to shorthand indirection, since
                #only shorthand syntax permits such variable's value to be
                #validated as well. *sigh* Right. Well, what can you do, eh?
                #Excise everything *NOT* related to "(( arg_is_indirect ))"
                #below.

                # If such argument is *NOT* indirect but such major subtype is
                # "var", such argument is actually indirect. While indirection
                # is typically specified with the type indirective "*", the
                # type prefix ":string/var" also suffices to imply indirection.
                # In such case, convert the latter to the former.
                # if (( ! arg_is_indirect )) &&
                #    [[ "${arg_subtype_major}" == 'var' &&
                #       -n "${arg_subtype_minor}" ]] {
                #     # If such argument is *NOT* locally declared as a string,
                #     # throw an exception. While integer arguments could
                #     # technically refer to variables whose names are integers,
                #     # such edge-case seems equally implausible and fragile.
                #     # (Only strings may reasonably refer to variables.)
                #     [[ "${arg_subtype_local}" == ':string' ]] ||
                #         ::func.die_of_arg_type_direct\
                #             'refers to variables by name but not locally declared as a string'
                # }

                #FUXME: Everything below requires substantial simplification.
                # if [[ -n "${arg_subtype_minor}" ]] {
                #     #FUXME: Incorrect. Invert this by shifting such logic
                #     #below. Then excise this entire conditional. (Yes!)

                #     # Convert the current type to the equivalent shorthand
                #     # for variable indirection (e.g., from
                #     # ":string/var+int" to "*:int"), parsed below. As such
                #     # shorthand is considerably more common than such
                #     # longhand, the latter defers to the former.
                #     arg_subtype_major=${arg_subtype_minor}
                #     arg_subtype_minor=
                #     arg_is_indirect=1
                # }

                    # Having validated such variable's value above, prepare
                    # to validate such variable's type below by rewriting
                    # the current shorthand type
                    #
                    # Convert the current shorthand type to the equivalent shorthand
                    # for variable indirection (e.g., from
                    # ":string/var+int" to "*:int"), parsed below. As such
                    # shorthand is considerably more common than such
                    # longhand, the latter defers to the former.
                    # arg_subtype_major=${arg_subtype_minor}
                    # arg_subtype_minor=
                    # match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT}]='*'

                # name by such subtype.
#by setting such major subtype to "var" and such minor
                    # subtype to such major subtype 
                    #FUXME: Totally and horribly awry. We actually need to
                    #*ALWAYS* set arg_subtype_major='var' when
                    #"(( arg_is_indirect ))"; clearly, however, that overwrites
                    #the current major subtype. *sigh*
                    #
                    #While there are any number of reasonable solutions here,
                    #the simplest at the moment appears to be:
                    #
                    #* Revise such PCREs as follows:
                    #
                    #  local pcre_arg_type_unstarred_grouped=${pcre_empty_group}${pcre_operable_type_grouped}${pcre_operable_name_slashed_optional_grouped}${pcre_operable_name_plussed_optional_grouped}${pcre_empty_group}
                    #  local pcre_arg_type_starred_grouped=${pcre_star_optional_grouped}${pcre_empty_group}${pcre_empty_group}${pcre_operable_type_grouped}${pcre_operable_name_plussed_optional_grouped}
                    #* We've added yet another index above, as you might
                    #  notice. For direct arguments, we add an empty trailing
                    #  group; for indirect arguments, such group will be set
                    #  to, say, the "positive" in indirect argument type
                    #  "*:string+positive".
                    #* In @{*-pcre}, define a new match index corresponding to
                    #  such trailing group -- say,
                    #  ${arg_subtype_minor_indirect} or some such?
                    #* Such logic *SHOULD* vastly simplify things here. In
                    #  particular, defaulting arg_subtype_major='var' as we do
                    #  below then becomes safe.
                    #FUXME: Actually, while the above *DOES* technically work,
                    #it's a bit heavy-handed. Well, really; we've already
                    #defined so many capture groups; it's not entirely clear
                    #that yet another demonstrably improves matters. Instead,
                    #just note that
                    #${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]
                    #*ALWAYS* retains the current major subtype. So, it doesn't
                    #particularly matter if we overwrite ${arg_subtype_major}
                    #here. That said, it is still somewhat silly. We probably
                    #do want to revert this to the prior order, in which case
                    #overwriting ${arg_subtype_major} is perfectly acceptable.
                    #*HOWEVER*, note that since we forcibly set...
                    #FUXME: O.K.; this *SHOULD* be reasonably worky now.

                # arg_tester=${arg_subtype_major}'.is'

                # #FUXME: Something went awry here. *sigh*
                # # Name of the function validating such argument values. For
                # # simplicity, use the same string local as above to do so.
                # # To avoid complications, redefine such local *AFTER*
                # # possibly defining such local above.
                # arg_tester=':var.is_type_'${arg_subtype_local[9,-1]}

                # # Such argument's major subtype, defaulting to such argument's
                # # type if unspecified.
                # arg_subtype_major=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}

                # # Such argument's minor subtype, defaulting to the empty string
                # # if unspecified.
                # arg_subtype_minor=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}

                # } elif [[ -z "${arg_subtype_major}" ]] {
                # a string referring to a variable by name
                # via the longhand ":string/var" rather than equivalent
                # shorthand "*", convert the former to the latter.

                #FUXME: Actually, this is incorrect too. Why? Indirection, as
                #always! We need to validate a type "*:char+ascii" first with
                #:Char.die_unless() and then with :char.die_unless_ascii().
                #One begins to suspect that the prior order *WAS* superior.
                #*sigh*

                #FUXME: Optimize me.
                # If such argument is a string referring to another variable's name,
                # validate the latter to exist *AND* be of the expected type.
                # To implement the latter, validate such argument by calling a
                # function :string.${arg_subtype_major}.
                # } elif [[ "${arg_subtype_major}" == 'var' ]] {
                #     # If such argument type is *NOT* ":string", throw an
                #     # exception. While integer arguments could technically
                #     # refer to variables whose names are themselves integers,
                #     # such edge-case seems both implausible and error-prone. In
                #     # practice, only strings refer to other variables.
                #     [[ "${arg_subtype_local}" == ':string' ]] ||
                #         ::func.die_of_arg_type\
                #             'not a string but indirectly refers to variables by name; consider prefixing such type by "*" or ":string/var" instead'
                # }

                        # # Else, such argument has no minor subtype declaring
                        # # the type of the variable referred to. Since
                        # # indirection requires such type and hence is
                        # # inapplicable here, throw an exception encouraging
                        # # such argument's to merely be rewritten.
                        # } else {
                        #     ::func.die_of_arg_type\
                        #         'refers to variables by name but not locally declared as a string; consider revising such argument into a string referring to a '${arg_subtype_local#:}' (e.g., from "'${arg_type}'" to "'${arg_type_target}'")'
                        # }

                #FUXME: The "(e.g.," below is rather silly. To be genuinely
                #explanatory, such parenthesis should explicitly state the
                #*ENTIRE* source and target types -- not simply their prefixes.
                #See a similar example below; grep for:
                #
                #    [[ "${arg_subtype_local}" == ':string' ]] || {
                #FUXME: Indeed, given the similarity between the two messages,
                #we arguably want a new ::func.die_of_arg_direct()
                #exception handler called in both instances.
                            # ::func.die_of_arg_type_direct\
                            #     'refers to variables by name but not locally declared as a string; consider revising such argument into a string referring to a '${arg_subtype_local#:}' by prefixing such type by "*" (e.g., from "'${arg_type}'" to "'${arg_type_target}'")'

                # If such argument has a major subtype implying such argument
                # to be a string referring to a variable by name *AND* any
                # minor subtype, validate such variable to exist *AND* be of the
                # expected type. If such argument satisfies the first but not
                # second condition, rely on subsequent function testing to
                # ensure such variable 

# To implement the latter, validate such
                # argument by calling a function :string.${arg_subtype_major}.
#or ":string/var" instead
            # Else, such argument is direct.
            #
            # If such argument's  is and hence locally declared as its
            # local subtype. If such subtype is nonscalar (i.e., list or map),
            # throw an exception. By zsh mandate, arguments are *ALWAYS* passed
            # as untyped strings and hence cannot encapsulate nonscalar data.

                # if [[ -n "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT}]}" ]] {
#match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT}]='*'
                #FUXME: Cursory examination of the code below suggests we
                #probably no longer need ${arg_subtype_major} or
                #${arg_subtype_minor} -- at least, not here. Optimize away.

                # Such argument's major subtype, defaulting to such argument's
                # type if unspecified.
                # arg_subtype_major=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}

                # # If unspecified, default such subtype...
                # if [[ -z "${arg_subtype_major}" ]] {
                #     # ...if such argument is indirect, to "var".
                #     if (( arg_is_indirect )) {
                #         arg_subtype_major='var'
                #     # ...else, to such local subtype stripped of prefixing ":".
                #     } else {
                #         arg_subtype_major=${arg_subtype_local#:}
                #     }
                # }

                # # Such argument's minor subtype, defaulting to the empty string
                # # if unspecified.
                # arg_subtype_minor=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}

                # # Name of the function validating such argument.
                # arg_tester=${arg_subtype_major}'.is'

                # # If such argument has a minor subtype, suffix such function
                # # name by such subtype.
                # if [[ -n "${arg_subtype_minor}" ]] {
                #     arg_tester+='_'${arg_subtype_minor}
                # }

                # arg_subtype_major=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]-${arg_subtype_local}}
                #FUXME: Document me. A bit hackish, frankly. We should probably
                #just initialize ${arg_subtype_major} above.
                # match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]='var'

                # # If unspecified, default such subtype to such local subtype.
                # if [[ -z "${arg_subtype_major}" ]] {
                #     arg_subtype_major=${arg_subtype_local}
                # # Else, such subtype was specified. If such type was prefixed
                # # by a type indirective (i.e., "*"),  throw an exception
                # }

                        # 'unrecognized, requiring undefined function '${arg_tester}'() to validate such argument'
                                # 'unrecognized, requiring undefined function '${arg_tester}'() to validate the variable such argument refers to'
                # # Name of the alias locally declaring such argument.
                # arg_declarer=${arg_subtype_local}

                # # If such type is *NOT* the name of an existing alias, throw an
                # # exception. See :alias_command.is() for details.
                # (( ${+aliases[${arg_declarer}]} )) || 
                #     ::func.die_of_arg_type\
                #         'unrecognized, requiring undefined alias '${arg_declarer}'() to locally declare such argument'

                # # Map such alias name to such argument definition.
                # arg_declarer_to_declarations[${arg_declarer}]+=' '${arg_name}'="${'${arg_index}'}"'

            #FUXME: Ugh. The logic becomes fairly convoluted fairly quickly.
            #Honestly, we probably want to handwave all such subtleties away by
            #refining the PCRE to capture match groups much more strictly here.

            #     # If such argument indirectly refers to a variable by name,
            #     # locally declare such argument as a string.
            #     if (( arg_is_indirect )) {
            #         arg_subtype_local
            #     }

                #FUXME: If both "*" and a major subtype are specified, throw an
                #exception. That is to say, prohibit the second argument here:
                #
                #    :void ::handle(:int number, *:char/var char_name+__h)

            # unrelaxed and unequal to ":string"), note such fact by appending
            # an expansion of such argument to the appropriate type-specific
            # string. Technically, *ALL* function arguments are untyped scalars
#append an initialization of such name to such value
            # to the appropriate type-specific string.
            # Convert the string length of the corresponding matched metadata to a boolean.  
            #FUXME: Localize above.
            # arg_subtype_major=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}
            # arg_subtype_minor=${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}

                # Note such fact.
                # arg_is_variadic=1

            # if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC}]-}" ]] {
            #     # Note such fact.
            #     arg_is_variadic=0

                # # If such argument is a string referring to another variable's name,
                # # localize such argument merely as a string.
                # if [[ "${arg_subtype_local}" == ':string:'* ]] {
                #     arg_declarer=':string'
                # # Else, such argument is a scalar value. Localize such value to
                # # be of such type.
                # } else {

            #FUXME: Obsolete by refactored logic below. Excise entirely.
                # # Format such exception message in terms of such argument's
                # # current type and name. See above for further details.
                # local\
                #     arg_type_target='*:list'\
                #     arg_name_target=${arg_name%%<->##}
                # if (( arg_is_optional )) {
                #     arg_type_target+='+nonempty'
                # }

                # # Throw such exception.
                # ::func.die\
                #     'accepts both optional and variadic arguments; consider converting the variadic argument list starting with argument ${'${arg_name}'} into a string indirectly referring to a list (e.g., from "'${arg_type}' '${arg_name}', ..." to "'${arg_type_target}' '${arg_name_target}'"'

                # Format such exception message in terms of such argument's
                # current type and name.

                # Argument type and name to recommend such argument be
                # refactored as, stripping all suffixing digits from such name.
                # Dismantled, this is:
                #
                # * "%%", greedily removing the longest matching suffix.
                # * "<->##", matching one or more digits.
                # local\
                #     arg_type_target='*:list'\
                #     arg_name_target=${arg_name%%<->##}

                # # If such argument is *NOT* optional, constrain such list to
                # # contain at least one item.
                # if (( arg_is_optional )) {
                #     arg_type_target+='+nonempty'
                # }

                # # Throw such exception.
                # ::func.die\
                #     'accepts two or more variadic arguments; consider converting the variadic argument list beginning with argument ${'${arg_name}'} into a string indirectly referring to a list (e.g., from "'${arg_type}' '${arg_name}', ..." to "'${arg_type_target}' '${arg_name_target}'"'

                # ::func.die\
                #     'accepts two or more variadic arguments'

            #FUXME: Rename:
            #
            #* ${arg_subtype_local} to ${arg_subtype_local}.
            #* ${arg_type_full} to ${arg_type}.

            #FUXME: Define a new exception handler
            #::func.die_of_argument_type() and call such handler
            #everywhere below in place of the current logic.

                    # 'nonscalar, but zsh only supports scalar argument types; consider converting such type to "*'${arg_subtype_local}'"'
# (e.g., `:bool`, `:char`, `:float`, `:int`, `:string`)

            # [[ "${arg_subtype_local}" != ':'('list'|'map')('_'*|) ]] ||
                    # 'nonscalar, but zsh only supports scalar argument types (e.g., `:bool`, `:char`, `:float`, `:int`, `:string`)'

                #FUXME: As expected, "+"-style subtypes are insufficient.
                #Consider how one would validate a string argument referring to
                #a function. In such case, ":string/func" fails, as there
                #exists no function :string.is_func(). We thus require a new
                #syntactic element implying function :func.is() instead. And
                #for that, "/" clearly applies: e.g.,
                #
                #    :void ::var.die_unless_passes_tester(
                #        :string/var var_name1, ...,
                #        :string/func tester_name,
                #        :string/alias_command alias_name)
                #
                #Given that we now have two validation-specific "types",
                #abandon the current "subtype" nomenclature in favor of:
                #
                #* The "/"-prefixed major type. If unspecified, such type
                #  defaults to the portion of such type preceding the "+" if
                #  any (e.g., the ":string" in ":string+glob").
                #* The "+"-prefixed minor type.
                #
                #What's awesome about this is that major and minor types can be
                #elegantly combined in the expected way: e.g.,
                #
                #    :void ::test(:string/var+nonempty var_name)
                #
                #Hence, "/" and "+" are both essential syntax. Neither
                #obsoletes or obviates the other. Make it so, please!
                #FUXME: Hey, it gets even better! The above syntax clearly
                #obsoletes our existing (and frankly rather kludgy) handling of
                #variable indirection. Specifically, arguments of type
                #":string/var+${var_type}" clearly obsolete prior type
                #":string:${var_type}". Hence, do away with *ALL* ":string:"
                #handling below. However, note that repeating ":string/var+"
                #everywhere in list- and map-centric function prototypes will
                #get old fairly quickly. We might consider a new argument type
                #prefix: ":*", shorthand for ":string/var+". Hence, the
                #following prototypes are equivalent:
                #
                #    :void ::handle(:string/var+char char_name+__h)
                #    :void ::handle(:*char char_name+__h)
                #    :void ::handle(*:char char_name+__h)
                #    :void ::handle(:char *char_name+__h)
                #
                #Well, three choices anyway. Contemplate a bit further.
                #FUXME: O.K.; C adopted "char *p" syntax to imply that "*p" is
                #the manner with which you access the data such pointer refers
                #to. In zeshy, however, we have no pointers, so that doesn't
                #apply; moreover, we've always thought such syntax to be
                #inherently irrational, in that the "*" modifies the type of
                #such variable and hence should be associated with such type
                #rather than such pointer name. Hence, either ":*char" or
                #"*:char" would be appropriate here. Indeed, for the same
                #reason, "*:char" is probably the most appropriate choice.
                #(Adopting C syntax would also be in poor taste here, as that
                #would tacitly imply zeshy to support pointers, which it
                #clearly does not.)
                #
                #However, "*:char" has one additional advantage over ":*char":
                #the former supports custom user-defined types leveraging a
                #user-specific prefix (e.g., "*@bytes"), whereas the latter
                #obstructs such use. Right then! We shay go with:
                #
                #    :void ::handle(*:char char_name+__h)

                        #FUXME: Right. Now that we've properly implemented major
                        #and minor subtypes, we no longer need to special-case
                        #this. Consider the following:
                        #
                        #* Replace the entire following block of logic with
                        #  simply the following:
                        #
                        # # Convert the current type to the equivalent
                        # # shorthand for variable indirection (e.g., from
                        # # ":string/var+int" to "*:int"), parsed below. Since
                        # # such shorthand is considerably more common than
                        # # such longhand, the latter defers to the former.
                        # arg_subtype_major=${arg_subtype_minor}
                        # arg_subtype_minor=
                        # match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT}]='*'
                        #
                        #* Shift the entire following block of logic into a new
                        #  if conditional performed *AFTER* the current
                        #  if conditional, resembling:
                        #
                        # if [[ -n "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT}]}" ]] {
                        #     ...
                        # }

                        #FUXME: Erroneous. Yay!
                    # Since such variable's type
                    # must also be 

                # Major and minor argument subtypes, localized for efficient
                # reuse below.
                    # ::func.die\
                    # 'argument ${'${arg_name}'} type '${arg_subtype_local}$([[ -z "${arg_subtype}" ]] || print -r -- '+'${arg_subtype})' unrecognized (i.e., function '${arg_tester}'() undefined)'
                            # 'argument ${'${arg_name}'} type '${arg_subtype_local[9,-1]}$([[ -z "${arg_subtype}" ]] || print -r -- '+'${arg_subtype})' unrecognized (i.e., function '${arg_tester}'() undefined)'

                    #FUXME: Ugh. Need a new argument exception handler.
            #FUXME: If such type is nonscalar (e.g., prefixed by either ":list"
            #or ":map"), we need to throw an exception. Argument values are, by
            #definition, *ONLY* scalar.

                # If such argument is a string referring to another variable's name,
                # validate the latter to exist *AND* be of the expected type. For
                # efficiency, obtain such type with raw string indices rather
                # than globbed match groups (e.g., ':string:'(#b)(*)).
                # if [[ "${arg_subtype_local}" == ':string:'* ]] {

    #FUXME: Correct comment in line with ${arg_declarer_to_declarations}.
    # Map from argument variable type (i.e., the type of the variable referred
    # to by an argument) to space-delimited string of the indices of all
    # arguments of such type to be programmatically validated. Since the

# -- aside from the observation that we
                #no longer want to skip straightaway to the next argument. Oh,
                #we?
                # Decrement the argument index offset. Prior iteration
                # assigned each argument an index under the assumption that
                # all optional arguments are passed. However, the current
                # argument count implies the current optional argument to
                # *NOT* be passed, implying all subsequent argument indices
                # to be one larger than previously assumed. Correct this!

            # In
            # such case,  or
            # otherwise ignore such argument.

                    #FUXME: Insufficient. Before applying parameter expansion
                    #flag "(P"), we *MUST* guarantee such argument to refer to
                    #a valid variable. Since simply appending to
                    #${arg_tester_to_values} does *NOT* guarantee this, we
                    #require yet another map local:
                    #${arg_var_tester_to_expansions}. This, in turn, implies we
                    #should rename "arg_tester" everywhere here to
                    #"arg_tester".
                    #FUXME: Actually, even that fails to suffice. We clearly
                    #*CANNOT* combine "(P)" with ranged indices (e.g.,
                    #"${@[2,-2]}"). Experimental use suggests that, in such
                    #cases, zsh fails to print an error or report failure, but
                    #instead simply returns the value of the variable referred
                    #to by the first such index. Clearly, this is terrible. To
                    #avoid such edge cases, prohibit function arguments
                    #satisfying all of the following edge case constraints:
                    #indirect, subtyped, variadic arguments: e.g.,
                    #
                    #    :void err(:string:int+positive my_int1, ...)
                    #
                    #Such arguments are fairly edge case, anyway. Technically,
                    #we *COULD* programmatically validate such variables by
                    #manually iterating such arguments...
                    #FUXME: Wait. We've just devised an efficient workaround,
                    #which is fairly awesome:
                    #
                    #* For all indirect, subtyped, variadic arguments (i.e.,
                    #  just test "(( arg_is_variadic ))" here, suffix
                    #  ${arg_index} by '//(#m)*/${(P)MATCH}', ensuring such
                    #  argument indices are expanded as follows:
                    #    "${@[2,-2]//(#m)*/${(P)MATCH}}"
                    #
                    #Excrutiatingly clever. Huzzah!

        #FUXME: O.K.; so, we still need to handle default values. Lookin' good
        #on pretty much everything else, but the time already invested in this
        #*DOES* somewhat astonish the rabid-eyed mind.

    # Space-delimited string of all expansions of arguments to be localized.
    # local arg_definitions

            #FUXME: Replicate such logic for both ${arg_declarer_to_declarations}
            #and ${arg_var_tester_to_values}, iterating ${arg_tester_to_values}
            #*BEFORE* ${arg_var_tester_to_values} *BEFORE*
            #${arg_declarer_to_declarations}. Order is quite important here.

 # Hence,
            # perform only attempt
            # to expand such variables here *AFTER* performing such iteration.
                #FUXME: Indentation is conditional here. The current
                #indentation is appropriate *ONLY* if the current argument
                #count requires a wrapping if conditional; else, such
                #indendation is too much. We probably want a new string local
                #${code_indentation_inner} to correct this. Given the above changes,
                #boolean ${args_is_optional} indicates whether or not we
                #require one or two levels of indentation *BEFORE* iterating
                #anything, implying ${code_indentation_inner} may be set as a
                #string constant *BEFORE* such iteration *AFTER* setting such
                #boolean ala:
                #
                #     code_indentation_inner=$'\n''    '
                #     if (( args_is_optional )) {
                #         code_indentation_outer=${code_indentation_inner}
                #         code_indentation_inner+='    '
                #     }
                #
                #Elegant, no? Note that new string local
                #${code_indentation_outer} is only ever expanded by functions
                #accepting optional arguments, justifying the logic above.
                #
                #Then replace the current code below with:
                #
                #     code_args_local_or_valid+=${code_indentation_inner}${arg_tester}${args_expansions}' || ::func.die_unless_arg_values_pass_tester "${@}" '''${args_expansions}''' '${(q)arg_tester}

            #FUXME: Erroneous test. During the first iteration of argument
            #counts for functions accepting optional arguments, no optional
            #arguments will be enabled, in which case the conditional below
            #fails when it *SHOULD* succeed. What we *REALLY* want to test is
            #just "(( arg_count_min != arg_count_max ))" instead. That said, to
            #avoid repetitious tests, we really want to encapsulate such
            #outcome in a new boolean local declared and defined far above as
            #follows:
            #
            #    integer args_is_optional=$(( arg_count_min != arg_count_max ))
            #
            #Then, test such integer here and below as follows:
            #
            #    if (( args_is_optional )) {

        #FUXME: Inefficient. Surely a simpler test presents itself?
        # if (( ${#arg_declarer_to_declarations} +\
        #       ${#arg_tester_to_values} +\
        #       ${#arg_var_tester_to_values} )) {

            #FUXME: Given such changes, we will only be testing existing
            #boolean ${arg_was_optional} in *ONE* place. Is there no better
            #way?

                    #FUXME: Note such assignment must be performed *AFTER*
                    #performing the above. Performing such assignment in the
                    #opposite order overwrites such function name.

                        #FUXME: Differentiate exception message from that thrown
                        #below.

                        #FUXME: The type printed should be the ORIGINAL type as
                        #specified in such prototype -- not our munged type.
                        #Happily, this is achievable without modification of
                        #existing logic by expanding ${match} indices instead
                        #here (and for orthogonality, below as well).

    #FUXME: Correct comment in line with ${arg_declarer_to_declarations}.
    # Map from argument type to space-delimited string of the indices of all
    # arguments of such type to be programmatically validated.

                    #FUXME: Document me.
                    # arg_subtype_local=${arg_subtype_local[9,-1]}

                    #FUXME: Insufficient. Such argument must be expanded with
                    #parameter expansion flag "(P)" below, implying we require
                    #a new string local ${arg_expansion_flag} initialized here
                    #and expanded below. However, don't neglect to initialize
                    #such local to the empty string in all other cases! Since
                    #this is mildly annoying, a better approach might simply be
                    #to define a new string local ${arg_index_prefix}
                    #initialized immediately prior to this if conditional above
                    #as:
                    #
                    #    arg_index_prefix=...
                    #FUXME: Wait. That's fairly silly; what we *REALLY* want to
                    #do is munge ${arg_index} before this and the prior if
                    #conditionals such that:
                    #
                    #* if [[ "${arg_index}" == *','* ]] ||
                    #     (( arg_index < 0 )) {
                    #     arg_index='@['${arg_index}']'
                    #  }
                    #
                    #Not terribly efficient, but you get the topical idea. It's
                    #critical, as well, *NOT* to delimit ${arg_index} by "${"
                    #and "}" (although the latter would technically be O.K.),
                    #due to the need to conditionally embed parameter expansion
                    #flags (e.g., "(P)") between such "${" and the subsequent
                    #index below.
                    #FUXME: Document me. In particular, note that use of "(P)"
                    #below requires such logic differ from that below.

                #FUXME: We've just recalled that it's inefficient to
                #perform list expansions resembling "${@[1]}" when merely
                #"${1}" suffices. Hence, we'll want to be a bit more
                #thorough here. Since this applies to the prior conditional
                #as well, refactor as follows:
                #
                #* Hmm; need to think a bit more about this...

                    #FUXME: Wait. We obviously need to perform *TWO*
                    #validations in such case and hence must duplicate the
                    #appending to map local ${arg_tester_to_values} below
                    #with a separate (but similar) appending to such local with
                    #such subtype here, validating such variable's value rather
                    #than type.

                        #FUXME: Suspiciously similar to the function name set
                        #below. Hmm...

        #FUXME: This has become ludicrously trivial. Moreover, such triviality
        #exposes a minor (perhaps, major?) flaw: .
            #FUXME: Reinterpreting "$'\n''    '" each iteration presumably
            #entails a cost. Supplant all such substrings below by a new string
            #local constant declared and defined above and expanded here:

            # Begin such validation by calling such function with such argument
            # values. Ideally, such validation would pass such exception message
            # directly to the appropriate exception handler (e.g.,
            # :die_unless_var_int_of_cause()). In practice, however, such message
            # depends on which argument failed such validation and hence can only be
            # constructed *AFTER* finding such argument.

            #FUXME: Fairly inefficient and horribly kludgy. Happily, we can
            #dispense with this entirely by:
            #
            #* Shift the conditional constructing ${arg_tester} to the
            #  iteration above where we currently map
            #  ${arg_tester_to_values}.
            #* Rename map ${arg_tester_to_values} to
            #  ${arg_tester_to_indices_valid}.
            #* Key such map with ${arg_tester} rather than ${arg_subtype_local}.
            #* Revise this iteration accordingly.
            #
            #We'll probably want to shift the test of whether such function
            #exists above as well. While slightly less efficient, doing so
            #allows us to construct considerably more useful exception
            #messages. (Or perhaps not? We *COULD* theoretically "de-parse"
            #${arg_tester} into what the corresponding
            #"${arg_subtype_local}+${arg_subtype} would have been above. But that does
            #seem rather... well, fragile. Probably avoid that for now, we
            #should think.)

            # # If such type contains a null character, split such type on such
            # # character into such argument's actual type and subtype.
            # if [[ "${arg_subtype_local}" == (#b)(*)$'\0'(*) ]] {
            #     arg_subtype_local="${match[1]}"
            #     arg_subtype="${match[2]}"
            # # Else, such type is already such argument's actual type.
            # } else {
            #     arg_subtype=
            # }

            #FUXME: No such testers currently exist. We'll need to perform
            #global search and replacements across the entire codebase. *sigh*

            # # If such argument is a string referring to another variable's name,
            # # validate the latter to exist *AND* be of the expected type. For
            # # efficiency, match such type with hard-coded character indices rather
            # # than match groups (e.g., via ':string:'(#b)(*)).
            # if [[ "${arg_subtype_local}" == ':string:'* ]] {
            #     arg_tester=':'${arg_subtype_local[9,-1]}':is'
            # # Else, such argument is a scalar value. Assuming such type to be
            # # prefixed by ":", validate such argument to be of such type
            # # stripped of such prefix.
            # } else {
            #     arg_tester=':'${arg_subtype_local[2,-1]}'.is'
            # }

            # # If such argument is subtyped, suffix such tester by such subtype.
            # if [[ -n "${arg_subtype}" ]] {
            #     arg_tester+='_'${arg_subtype}
            # }

            # # If such function does *NOT* exist, throw a custom exception.
            # :func.is "${arg_tester}" || ::func.die\
            #     'argument type '${arg_subtype_local}' unrecognized (i.e., function '${arg_tester}'() undefined)'

                #FUXME: Not quite. We need to test for argument types matching
                #":string:"* and reduce such types to merely ":string". Simple,
                #but will probably require the return of string local
                #${arg_declarer} and what not. *sigh*

#, the latter specific to validation
                # Name of the alias localizing such argument.
                # arg_declarer=${arg_subtype_local}
    # Name of the alias localizing the current argument.
    # local arg_declarer

# Assuming such type to be
                # prefixed by ":", validate such argument to be of such type
                # stripped of such prefix.

    #FUXME: How many of the variables below are still requisite?

    # Substring prefixing argument variable type-specific exception messages.
    # local die_arg_var_type_prefix

                #FUXME: No such testers currently exist. We'll need to perform
                #global search and replacements across the entire codebase. *sigh*

                # # If such argument has a validation-specific subtype, map such
                # # expansion to such type and subtype. For generality, delimit
                # # the two by a null character.
                # if [[ -n "${arg_subtype}" ]] {
                #     arg_tester_to_values[${arg_subtype_local}$'\0'${arg_subtype}]+=' "${@['${arg_index}']}"'
                # # Else, such argument only has a type. Map such expansion to
                # # only such type.
                # } else {
                #     arg_tester_to_values[${arg_subtype_local}]+=' "${@['${arg_index}']}"'
                # }

                # # If such argument is subtyped, suffix such tester by such subtype.
                # if [[ -n "${arg_subtype}" ]] {
                #     arg_tester+='_'${arg_subtype}
                # }

                #FUXME: We need to actually handle such null-delimited types
                #below.

                # # If such argument has a validation-specific subtype, map such
                # # expansion to such type and subtype. For generality, delimit
                # # the two by a null character.
                # if [[ -n "${arg_subtype}" ]] {
                #     arg_tester_to_values[${arg_subtype_local}$'\0'${arg_subtype}]+=' "${@['${arg_index}']}"'
                # # Else, such argument only has a type. Map such expansion to
                # # only such type.
                # } else {
                #     arg_tester_to_values[${arg_subtype_local}]+=' "${@['${arg_index}']}"'
                # }

            # } elif [[ "${arg_subtype_local}" == ':'${~operable_name_char_class} ]] {
            #     arg_tester=':'${arg_subtype_local[2,-1]}'.is'
            # # Else, validate such argument to be of such type.
            # } else {
            #     arg_tester=':'${arg_subtype_local}'.is'
            # }

                # [[ -z "${arg_subtype}" ]] || ::func.die\
                #     'argument type '${arg_subtype_local}'+'${arg_subtype}' '

        # validate all such arguments to be of such type.
            # note such fact by appending
            # such argument index to the parameter expansion-delimited string
            # of all indices of such type.

            #FUXME: Replicate such logic for ${arg_declarer_to_declarations}.
            #Naturally, prefix such argument expansions below by something
            #resembling " ${arg_name}=" rather than merely " ".

            #FUXME: Define a new code-specific string local ${localize_args}
            #above and append to such local here. Such local should probably be
            #reverted at the beginning of iteration above to the empty string,
            #and then interpolated into existing code-specific string local
            #${code_args_local_or_valid} (implying such string should perhaps be
            #renamed) *AFTER* appending all validation code to such string and
            #hence *AFTER* the following for loop, but *BEFORE* terminating the
            #current if conditional in ${code_args_local_or_valid}.
            #FUXME: Wait; for efficiency, we want to aggregate such
            #localizations based on type (much as we currently do with
            #validation code), suggesting we should instead:
            #
            #* Declare a new map local ${arg_tester_to_values_local} above.
            #* Append to such map local here (if unrelaxed, of course).
            #* Rename ${arg_tester_to_values} to ${arg_tester_to_values_valid}.
            #* For efficiency, localize the current argument type here: e.g.,
            #  arg_subtype_local="${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"

#FUXME: Redeclare as global constants, once we fix @{compile} (...or was it @{wain}?)
#to support global constants again: e.g.,
#
# # Something resembling...
# integer -gr\
#     ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPES=1\
#     ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_RELAXED=2\
#     ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME=3\
#     ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_IS_ABSENTABLE=4\
#     ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE=5\
#     ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC=6

    #FUXME: Replace with the equivalent globals declared above.

    # # Human-readable names of canonical list global ${match} indices. While
    # # such indices are both unnecessary and slightly inefficient, their use
    # # dramatically improves the readability and stability of argument parsing.
    # # Likewise, declaring such integer locals as globals would slightly
    # # mitigate such inefficiency at a cost of harming such stability (as such
    # # globals could be externally unset at any time). In the end, the current
    # # implementation seems a sensible tradeoff on all fronts.

    # # Current argument's optional type relaxant, signifying such type to *NOT*
    # # require validation (i.e., throwing an exception if the passed argument's
    # # value violates such type). If absent, such type will be validated below;
    # # else, such function must manually validate such argument if desired.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_unvalidated=1

    # # Current argument's mandatory type.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type=2

    # # Current argument's optional name relaxant, signifying such argument to
    # # *NOT* require localization (i.e., copied into a local variable of the
    # # same name). If absent, such argument will be localized below; else, such
    # # function must manually localize such argument if desired..
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_unlocalized=3

    # # Current argument's mandatory name.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name=4

    # # Current argument's optional eroteme (i.e., "?"), signifying such
    # # argument to be optional. If unspecified, such argument is mandatory.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_optional=5

    # # Current argument's optional default value relaxant, signifying such value
    # # to *NOT* require setting (i.e., setting such argument when unpassed to
    # # such value *BEFORE* possibly localizing such argument). If absent, such
    # # argument will be localized below; else, such function must manually
    # # default such argument to such value if desired.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_value_is_undefaulted=6

    # # Current argument's optional default value.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_value=7

    # # Current argument's optional ellipse (i.e., "..."), signifying such
    # # argument and hence function to be variadic.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_variadic=8

            #FUXME: Since most arguments will be at least localized or
            #validated, localize such type here: e.g.,
            #
            # arg_subtype_local="${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"

                #FUXME: Obsolete.
                # # Note such function to accept one variadic argument list.
                # args_is_variadic=1

            #FUXME: Obsolete.
            # } elif (( args_is_variadic && ! arg_is_variadic )) {
                #FUXME: Obsolete.
                # Note such function to accept at least one optional argument.
                # args_is_optional=1

        #FUXME: Reverting these strikes us as... overkill. Contemplate
        #excising both.
        #FUXME: Obsolete.
        # Technically, ${args_is_optional} need *NOT* be reverted here; since
        # ${args_is_variadic} must be, however, revert both for orthogonality.
        # ${args_is_variadic} must be reverted as such boolean tracks whether a
        # prior argument was variadic rather than merely whether such function
        # accepts a variadic argument list.
        # args_is_optional=0
        # args_is_variadic=0

    #FUXME: Unconvinced we still require these, given the greater utility of
    #${arg_was_optional} and ${arg_was_variadic}. Contemplate excising.

    # # 1 if such function accepts at least one optional argument and 0
    # # otherwise.
    # integer args_is_optional

    # # 1 if such function accepts one variadic argument list and 0 otherwise.
    # integer args_is_variadic

            #FUXME: This condition no longer behaves as expected, as the first
            #conditional above sets ${args_is_variadic} if the *CURRENT*
            #argument is variadic (not merely if a prior argument is variadic).
            #While we could hack about this with an additional boolean local,
            #what's really called for here is to:
            #
            #* Replace the immediately prior "if (( arg_is_variadic )) {"
            #  conditional with the variadic conditional far above, which
            #  seamlessly corrects such issue in the proper manner. However,
            #  doing so also complicates validation (e.g., to prevent functions
            #  from accepting both variadic and optional arguments).
            #* The solution then is to cease performing such validation within
            #  this loop but far above outside *ALL* iteration. Can we actually
            #  efficiently do this? The answer, of course, is yes.
            #  Specifically:
            #  * Set ${args_is_optional} in the manner shown above.
            #  * Set ${args_is_variadic} by globbing ${func_args_sans_quotes},
            #    which already provides us the quoteless argument list, for:
            #    *(#b)('? '#|)', '#'...'. Wait. Globs don't work here, alas, as
            #    we require a nongreedy match. Instead, match
            #    ${func_args_sans_quotes} against the PCRE:
            #    '^.*?(\?\s*+)?,\s*+\.\.\..*$'. O.K.; that definitely works. If
            #    such PCRE matches, then:
            #    * Set ${args_is_variadic} to 1.
            #    * Additionally, if "(( ! ${#match} ))", then such function
            #      erroneously accepts at least one optional argument and one
            #      non-optional variadic argument. In such case, throw an
            #      exception. (Excised from similar logic above.)
            #FUXME: Or perhaps not? While that *WOULD* work, we're somewhat
            #wary about yet another parse pass over the argument list. Instead,
            #perhaps we should contemplate the changes required to make this
            #work as is. Oh; right. Just restore ${arg_was_variadic}. We note
            #that we'd need to do that *ANYWAY*, so... no loss.

    #FUXME: Unsure whether we still desire this. Contemplate.
    # If the minimum and maximum number of arguments such function accepts
    # differ, such function accepts at least one optional argument. Note this.
    # if (( arg_count_min != arg_count_max )) {
    #     args_is_optional=1
    # }

            #FUXME: Actually, such test is unnecessary. Simply modify such PCRE
            #to match *EITHER* an eroteme *OR* equals sign suffixing an
            #argument name but not both. This is trivially simple, thankfully.

            # Else, such argument is optional.
            #
            # If such argument is suffixed by both an eroteme *AND* default
            # value, throw an exception. While either implies such argument to
            # be optional, each implies distinct, conflicting semantics.
            # } elif [[\
            #     -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_optional}]-}" ||
            #     -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_value}]-}" ]] ||\
            #     ::func.die\
            #         'argument '${match[ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name]}' suffixed by both "?" and "="'

            #FUXME: This and the following test, as well as the setting of
            #${args_is_variadic}, 

            #FUXME: Generalize to support localization as well. Since
            #localization and validation share the same ultimate desires here
            #(namely, appending to list ${args_index_type_optional_variadic}),
            #this would probably be simplified by logic resembling:
            #
            #    arg_type_is_validated=$((
            #        1 - ${#match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_unvalidated}]} ))
            #    arg_is_localized=$((
            #        1 - ${#match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_unlocalized}]} ))
            #
            #    if (( arg_type_is_validated || arg_is_localized )) {
            #        args_metadata+=(
            #            "${arg_count_max}"
            #            "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name}]}"
            #            "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"
            #            "${arg_is_optional}"
            #            "${arg_is_variadic}"
            #            "${arg_is_localized}"
            #            "${arg_type_is_validated}"
            #        )
            #    }
            #
            #As the above example implies, rename such list local to simply
            #${args_metadata}. (Judicious.)
            #
            #Reasonably clever; no extraneous if conditionals required. Wait;
            #the first doesn't quite work, as we need to prevent validation of
            #":string" types. So:
            #
            #    if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_unvalidated}]}" &&
            #             "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}" != ':string' ]] {
            #        arg_type_is_validated=1
            #    } else {
            #        arg_type_is_validated=0
            #    }
            #FUXME: Actually, ${args_index_type_optional_variadic} is hideous.
            #We can obviate both such list *AND* the following iteration
            #requiring such list by instead appending directly to keys of map
            #${arg_tester_to_values} here. To do so sanely, however, we *NEED*
            #to know the maximum number of arguments. We can accomplish this by
            #parsing such argument list twice: once without grouping and
            #optimized so as to match only unquoted "," as significant for
            #argument counting purposes, and the second actually parsing each
            #argument. However, to conform to the algorithm implemented below,
            #we would need to reperform such second round of argument parsing
            #a number of times equal to the number of optional arguments
            #accepted by such function.
            #
            #While such reparsing would be nonideal if the common case in zeshy
            #were functions accepting numerous optional arguments, the actual
            #common case in zeshy is the opposite: functions accepting at most
            #one (and typically no) optional arguments. Given that, there will
            #be *NO* reparsing in the common case. Indeed, such an approach
            #should dramatically improve the efficiency of the common case by
            #eliminating the need both to append an excrutiating number of
            #strings to list ${args_index_type_optional_variadic} *AND* to
            #iterate over such list.
            #
            #Note as well that the first parse can be dramatically optimized by
            #matching with a different (and hopefully much simplified) PCRE:
            #one performing no grouping and effectively matching only single-
            #and double-quoted strings (to ignore the nonsignificant commas
            #embedded in such strings) *AND* commas outside of such strings.
            #Actually, that's not quite true: we need to match commas,
            #erotemes, and equals signs, the latter two of which help us
            #calculate the minimum argument count, which we also need under
            #such refactoring. That said, such PCRE needn't actually match any
            #real argument syntax or structure, since the subsequent parse pass
            #will do so already.
            #
            #But it's *NOT* simply efficiency, though that is a dreaded
            #concern: it's elegance, or the lack thereof. The current approach
            #is horribly inelegant, requiring ever more strings be continually
            #appended to and parsed from such list. Let's do away with too fell
            #birds by one bright stone, shall we?
            #FUXME: Wooh. Just realized we don't even need to use PCRE matching
            #to count character instances in a string; we should be able to use
            #glob-driven global string replacement ala:
            #
            #    # Argument list with all single- and double-quoted strings
            #    # removed, preventing subsequent parsing from erroneously
            #    # counting ignorable ",", "?", and "=" characters
            #    # embedded in single- and double-quoted strings.
            #    local func_args_sans_quotes="${ZESHY__FUNC_ARGS//('([^']|'')#'|\"([^\"]|\\\")#\")}"
            #
            #    # Argument list reduced to all remaining "," characters, whose
            #    # string length plus one offers the maximum number of arguments
            #    # such function accepts.
            #    local func_args_commas="${func_args_sans_quotes//[^,]##}"
            #
            #    # Argument list reduced to all remaining "?" and "=" characters,
            #    # whose string length subtracted from such maximum number 
            #    # offers the minimum number of arguments such function accepts.
            #    local func_args_equals="${func_args_sans_quotes//[^?=]##}"
            #    # Minimum and maximum number of arguments such function accepts.
            #    arg_count_max=$(( ${#func_args_commas} + 1 ))
            #    arg_count_min=$(( arg_count_max - ${#func_args_equals} ))
            #
            #Good Lord. Not a single instance of explicit iteration to be
            #found. Go, go, go!

    #FUXME: Such condition is already implied by ${args_is_variadic},
    #suggesting we should simply excise this boolean in favor of that.
    # 1 if a prior argument was variadic and 0 otherwise.
    # integer arg_was_variadic

    #FUXME: Arguably shift everything below to a separate function.

    # Compile such PCRE. For efficiency, avoid optionally optimizing such
    # PCRE by calling pcre_study(). (Ad-hoc profiling suggests such
    # optimization to consume more time than it saves.) See
    # for_string_text_matching_pcre:() for further details.
    # pcre_compile -- "${ZESHY_CALLABLE_PROTOTYPE_ARGS_NEXT_PCRE}"

    # Parse each such argument into canonical list global ${match}, whose
    # indices we localize as human-readable integers above.
    # local ZPCRE_OP='0 0'
    # while {
    #     pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY__FUNC_ARGS}"
    # } {
    #     # Since the current argument may (but not necessarily) be passed,
    #     # increment the maximum argument count.
    #     arg_count_max+=1

    #     # If such argument is *NOT* variadic (i.e., was *NOT* suffixed by
    #     # an ellipse), note such fact. Test this condition *BEFORE* testing
    #     # whether such argument is optional, to prevent the latter's
    #     # enabling of boolean ${args_is_optional} when such argument is
    #     # both variadic and optional from triggering an exception here.
    #     if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_variadic}]-}" ]] {
    #         arg_is_variadic=0
    #     # Else, such argument is variadic.
    #     #
    #     # If a prior argument is optional, throw an exception. Such case
    #     # implies such function to accept one or more optional arguments
    #     # *AND* one or more variadic argument lists of arbitrary count,
    #     # implying there exists no general means of deciding which such
    #     # argument a passed string was intended to correspond to.
    #     } elif (( args_is_optional )) {
    #         ::func.die\
    #             'accepts both optional and variadic arguments'
    #     # If a prior argument is also variadic, throw an exception.  Such
    #     # case implies such function to accept two or more variadic
    #     # argument lists of arbitrary count, implying there exists no
    #     # general means of deciding which such list a passed string was
    #     # intended to belong to.
    #     } elif (( args_is_variadic )) {
    #         ::func.die\
    #             'accepts two or more variadic argument lists'
    #     # Else, such argument is validly variadic. Note such fact and such
    #     # function to accept one variadic argument list.
    #     } else {
    #         arg_is_variadic=1
    #         args_is_variadic=1
    #     }

    #     # If such argument is mandatory (i.e., was neither suffixed by an
    #     # eroteme *OR* a default value), note such fact and increment the
    #     # minimum argument count.
    #     if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_optional}]-}${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_value}]-}" ]] {
    #         arg_is_optional=0
    #         arg_count_min+=1
    #     # Else, such argument is optional.
    #     #
    #     # If such argument is suffixed by both an eroteme *AND* default
    #     # value, throw an exception. While either implies such argument to
    #     # be optional, each implies distinct, conflicting semantics.
    #     } elif [[\
    #         -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_optional}]-}" ||
    #         -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_value}]-}" ]] ||\
    #        ::func.die\
    #            'argument '${match[ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name]}' suffixed by both "?" and "="'
    #     # If a prior argument is also variadic, throw an exception,
    #     # explicitly ignoring the valid case that the current argument is
    #     # both variadic and optional. See above for further details.
    #     } elif (( args_is_variadic && ! arg_is_variadic )) {
    #         ::func.die\
    #             'accepts both optional and variadic arguments'
    #     # Else, such argument is validly optional. Note such fac and such
    #     # function to accept at least one optional argument.
    #     } else {
    #         arg_is_optional=1
    #         args_is_optional=1
    #     }

    #     #FUXME: Generalize to support localization as well. Since
    #     #localization and validation share the same ultimate desires here
    #     #(namely, appending to list ${args_index_type_optional_variadic}),
    #     #this would probably be simplified by logic resembling:
    #     #
    #     #    arg_type_is_validated=$((
    #     #        ${#match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_unvalidated}]} ))
    #     #    arg_is_localized=$((
    #     #        1 - ${#match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_is_unlocalized}]} ))
    #     #
    #     #    if (( arg_type_is_validated || arg_is_localized )) {
    #     #        args_metadata+=(
    #     #            "${arg_count_max}"
    #     #            "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name}]}"
    #     #            "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"
    #     #            "${arg_is_optional}"
    #     #            "${arg_is_variadic}"
    #     #            "${arg_is_localized}"
    #     #            "${arg_type_is_validated}"
    #     #        )
    #     #    }
    #     #
    #     #As the above example implies, rename such list local to simply
    #     #${args_metadata}. (Judicious.)
    #     #
    #     #Reasonably clever; no extraneous if conditionals required. Wait;
    #     #the first doesn't quite work, as we need to prevent validation of
    #     #":string" types. So:
    #     #
    #     #    if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_unvalidated}]}" &&
    #     #             "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}" != ':string' ]] {
    #     #        arg_type_is_validated=1
    #     #    } else {
    #     #        arg_type_is_validated=0
    #     #    }
    #     #FUXME: Actually, ${args_index_type_optional_variadic} is hideous.
    #     #We can obviate both such list *AND* the following iteration
    #     #requiring such list by instead appending directly to keys of map
    #     #${arg_tester_to_values} here. To do so sanely, however, we *NEED*
    #     #to know the maximum number of arguments. We can accomplish this by
    #     #parsing such argument list twice: once without grouping and
    #     #optimized so as to match only unquoted "," as significant for
    #     #argument counting purposes, and the second actually parsing each
    #     #argument. However, to conform to the algorithm implemented below,
    #     #we would need to reperform such second round of argument parsing
    #     #a number of times equal to the number of optional arguments
    #     #accepted by such function.
    #     #
    #     #While such reparsing would be nonideal if the common case in zeshy
    #     #were functions accepting numerous optional arguments, the actual
    #     #common case in zeshy is the opposite: functions accepting at most
    #     #one (and typically no) optional arguments. Given that, there will
    #     #be *NO* reparsing in the common case. Indeed, such an approach
    #     #should dramatically improve the efficiency of the common case by
    #     #eliminating the need both to append an excrutiating number of
    #     #strings to list ${args_index_type_optional_variadic} *AND* to
    #     #iterate over such list.
    #     #
    #     #Note as well that the first parse can be dramatically optimized by
    #     #matching with a different (and hopefully much simplified) PCRE:
    #     #one performing no grouping and effectively matching only single-
    #     #and double-quoted strings (to ignore the nonsignificant commas
    #     #embedded in such strings) *AND* commas outside of such strings.
    #     #Actually, that's not quite true: we need to match commas,
    #     #erotemes, and equals signs, the latter two of which help us
    #     #calculate the minimum argument count, which we also need under
    #     #such refactoring. That said, such PCRE needn't actually match any
    #     #real argument syntax or structure, since the subsequent parse pass
    #     #will do so already.
    #     #
    #     #But it's *NOT* simply efficiency, though that is a dreaded
    #     #concern: it's elegance, or the lack thereof. The current approach
    #     #is horribly inelegant, requiring ever more strings be continually
    #     #appended to and parsed from such list. Let's do away with too fell
    #     #birds by one bright stone, shall we?
    #     #FUXME: Wooh. Just realized we don't even need to use PCRE matching
    #     #to count character instances in a string; we should be able to use
    #     #glob-driven global string replacement ala:
    #     #
    #     #    # Argument list with all single- and double-quoted strings
    #     #    # removed, preventing subsequent parsing from erroneously
    #     #    # counting ignorable ",", "?", and "=" characters
    #     #    # embedded in single- and double-quoted strings.
    #     #    local func_args_sans_quotes="${ZESHY__FUNC_ARGS//('([^']|'')#'|\"([^\"]|\\\")#\")}"
    #     #
    #     #    # Argument list reduced to all remaining "," characters, whose
    #     #    # string length plus one offers the maximum number of arguments
    #     #    # such function accepts.
    #     #    local func_args_commas="${func_args_sans_quotes//[^,]##}"
    #     #
    #     #    # Argument list reduced to all remaining "?" and "=" characters,
    #     #    # whose string length subtracted from such maximum number 
    #     #    # offers the minimum number of arguments such function accepts.
    #     #    local func_args_equals="${func_args_sans_quotes//[^?=]##}"
    #     #    # Minimum and maximum number of arguments such function accepts.
    #     #    arg_count_max=$(( ${#func_args_commas} + 1 ))
    #     #    arg_count_min=$(( arg_count_max - ${#func_args_equals} ))
    #     #
    #     #Good Lord. Not a single instance of explicit iteration to be
    #     #found. Go, go, go!

    #     # If such argument's type is *NOT* to be ignored (i.e., is to be
    #     # validated), validate such type. To avoid overriding canonical
    #     # list global ${match} with matches captured below, do so *AFTER*
    #     # performing all other argument parsing above.
    #     if [[ -z "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_unvalidated}]}" ]] {
    #         # If such type is *NOT* ":string", validate such type. (Since
    #         # all arguments are untyped scalars from the low-level zsh
    #         # perspective, there exists no validation to be performed for
    #         # arguments of type ":string".)
    #         [[ "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}" == ':string' ]] || 
    #             args_index_type_optional_variadic+=(
    #                 "${arg_count_max}"
    #                 "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"
    #                 "${arg_is_optional}"
    #                 "${arg_is_variadic}" )
    #     }
    # }

    # #FUXME: Arguably shift everything below to a separate function.
    # #FUXME: How many of the variables below are still requisite?

    # # Code validating the number of arguments passed to such function.
    # local code_arg_count
    # 
    # # Code validating the types of arguments passed to such function.
    # local code_args_local_or_valid

    # # Name of the function validating the current argument type.
    # local arg_tester

    # # Substring prefixing argument variable type-specific exception messages.
    # local die_arg_var_type_prefix

    # # Number of optional arguments required by the current argument count
    # # below. If such function accepts no optional arguments, this number
    # # remains 0; else, this number varies between the maximum and minimum
    # # number of arguments such function accepts.
    # integer arg_count_optional

    # # Non-positive integer (i.e., strictly less than or equal to 0) by which to
    # # offset the current argument index below. If such function accepts no
    # # optional arguments, this integer remains 0; else, this integer is
    # # decremented once for each optional argument rejected by the current
    # # argument count. (See below for gritty details.)
    # integer arg_index_offset

    # # 1 if a prior argument was variadic and 0 otherwise.
    # integer arg_was_variadic

    # # For each possible number of arguments between the minimum and maximum
    # # established above, define code validating the types of all passed
    # # arguments when the caller passes that number of arguments.
    # integer arg_count
    # for     arg_count ({${arg_count_min}..${arg_count_max}}) {
    #     # Clear such map. See ::map.clear() for further details.
    #     set -A arg_tester_to_values

    #     # Revert local variables declared above specific to the following loop.
    #     arg_count_optional=$(( arg_count - arg_count_min ))
    #     arg_index_offset=0
    #     arg_was_variadic=0

    #     # Define such map by parsing the previously defined 4-tuple list of all
    #     # relevant argument metadata.
    #     local arg_index
    #     for   arg_index arg_subtype_local arg_is_optional arg_is_variadic (
    #         "${args_index_type_optional_variadic[@]}") {

    #         # If such argument is optional, ...
    #         if (( arg_is_optional )) {
    #             # If the current argument count permits no additional optional
    #             # arguments. ignore such argument.
    #             (( arg_count_optional )) || {
    #                 # Decrement the argument index offset. Prior iteration
    #                 # assigned each argument an index under the assumption that
    #                 # all optional arguments are passed. However, the current
    #                 # argument count implies the current optional argument to
    #                 # *NOT* be passed, implying all subsequent argument indices
    #                 # to be one larger than previously assumed. Correct this!
    #                 arg_index_offset+=-1

    #                 # Skip to the next argument.
    #                 continue
    #             }

    #             # Else, such argument count supports such argument. Decrement
    #             # such count, implying such count to now support one less
    #             # subsequent optional argument. (The current optional argument
    #             # "consumes" one of the available optional argument "slots"
    #             # permitted by such count.)
    #             arg_count_optional+=-1
    #         }

    #         # Decrement such argument index by such offset. See above!
    #         arg_index+=${arg_index_offset}

    #         # If such argument is variadic, index such argument and all
    #         # subsequent optional variadic arguments with an argument range
    #         # starting at the current positive index and ending at the negative
    #         # index of the last such argument. See below for related logic.
    #         if (( arg_is_variadic )) {
    #             arg_index=${arg_index}','$(( arg_index - arg_count_max - 1 ))

    #             # Note such fact for testing by subsequent iteration.
    #             arg_was_variadic=1
    #         # Else if such argument follows a variadic argument, such argument
    #         # cannot be reliably indexed by its positive index (i.e., relative
    #         # to the start of such argument list). Since such argument can,
    #         # however, be reliably indexed by its negative index (i.e.,
    #         # relative to the end of such argument list), replace the former
    #         # with the latter.
    #         #
    #         # Since the negative sign "-" conflicts with parameter expansion
    #         # syntax, negative indices may only be referenced by indexing canonical
    #         # list global ${@} or ${argv} with such index.
    #         #
    #         # Happily, such conversion applies equally well regardless of whether
    #         # such variadic argument was optional or mandatory.
    #         } elif (( arg_was_variadic )) {
    #             arg_index=$(( arg_index - arg_count_max - 1 ))
    #         # Else such argument precedes a variadic argument if any, In such
    #         # case, such argument is reliably indexable by its positive index
    #         # and hence requires no adjustment,
    #         }

    #         # Append such index to the space-separated and parameter expansion-
    #         # delimited string of all indices of such argument's type.
    #         arg_tester_to_values[${arg_subtype_local}]+=' "${@['${arg_index}']}"'
    #     }

    # integer arg_count_min=0 arg_count_max=0

    # List of argument-specific metadata for all arguments whose types are to
    # be programmatically validated (excluding of type ":string", requiring no
    # such validation). Such validation typically depends on the maximum number
    # of arguments accepted by such function, a quantity available only *AFTER*
    # parsing all such arguments. Such parsing thus appends this list by such
    # metadata, which post-parsing then converts into such validation. Such
    # metadata comprises a conceptual 4-tuple
    # (${arg_index} ${arg_subtype_local} ${arg_is_optional} ${arg_is_variadic}).
    # local -a args_index_type_optional_variadic

    # decide how
    # best to index optional and variadic arguments 
    #
    # , runnable
    # argument parsing requires.
    #
    #FUXME: Obsolete.
    # If such argument string is *NOT* the empty string, such function accepts
    # at least one argument. In such case, parse such arguments.
    # if [[ -n "${ZESHY__FUNC_ARGS}" ]] {

    # Current argument type's optional eroteme (i.e., "?"), signifying that
    # such function's definition should *NOT* be prefixed by a call to an
    # exception handler throwing an exception if such argument violates the
    # constraints of such type (e.g., a non-numeric string passed where an
    # integer was expected). If unspecified, such definition is prefixed by
    # such a call.
    # integer -r ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type_is_ignorable=2

    # such function's definition should *NOT* be prefixed by a call to an
    # exception handler throwing an exception if such argument violates the
    # constraints of such type (e.g., a non-numeric string passed where an
    # integer was expected). If unspecified, such definition is prefixed by
    # such a call.

#FUXME: This file grows exceedingly long. While such exceptions *COULD* be
#shifted to @{*-test}, doing so would prohibit their documentation there,
#further complicating matters. Instead, contemplate concocting a new
#@{40-func/} parcel tree, shifting this parcel there as @{func}, concocting
#a new parcel @{die} there as well, and shifting all exception handlers below
#to the latter parcel.

    # Pop such argument off such list. See pop_arg() for further details.
    # argv[-1]=()

    #FUXME: Excissively verbose, particularly when replicated across
    #*EVERY* single zeshy function. See above for further details.

    # # Validate the number of arguments passed to such function.
    # #
    # # If such function is variadic, such function accepts a countably
    # # infinite number of arguments only bounded below by such minimum.
    # if (( args_is_variadic )) {
    #     code_arg_count='(( # >= '${arg_count_min}' ))'${die_arg_count_prefix}'at least '${arg_count_min}' arguments but received only ${#}'${die_arg_count_suffix}
    # # Else, such function is non-variadic, in which case such function
    # # accepts a number of arguments bounded by such minimum and maximum.
    # #
    # # If such minimum and maximum are equal, simplify such test as such.
    # } elif (( arg_count_min == arg_count_max )) {
    #     code_arg_count='(( # == '${arg_count_min}' ))'${die_arg_count_prefix}${arg_count_min}' arguments but received ${#}'${die_arg_count_suffix}
    # # Else, such minimum and maximum are unequal.
    # } else {
    #     code_arg_count='(( '${arg_count_min}' <= # && # <= '${arg_count_max}' ))'${die_arg_count_prefix}'between '${arg_count_min}' and '${arg_count_max}' arguments but received ${#}'${die_arg_count_suffix}
    # }

    # (( ${#funcstack} >= 2 )) || :die 'Called directly from the command line.'
    # Shift and pop such arguments off. See shift_arg() and pop_args_2() for
    # further details.
    # argv[1]=()
    # argv[-2,-1]=()

    #         # List of all argument indices to be tested. Unlike
    #         # ${arg_values_string}, such list consists only of integers.
    #         local -a args_expansions

    #         # Convert the passed list of 

    #         # Iterate arguments by index until finding the first failing argument.
    #         # Such indices encompass both index ranges (e.g., "@[3,-1]") and
    #         # negative indices (e.g., "@[-1]" and hence are *NOT* strictly
    #         # integers.
    #         local arg_index
    #         for   arg_index ('${args_expansions}') {
    #             # Strip "@[" and "]" delimiters, if found.
    #             arg_index="${${arg_index#@\[}%]}"

    #             # If such index is comma-separated, split such index into two
    #             # indices signifying an index range and iteratively test all
    #             # arguments in such range.
    #             if [[ "${arg_index}" == (#b)([^,]##),(*) ]] {
    #                 for arg_index ({${match[1]}..${match[2]}}) {
    #                     .
    #                 }
    #             # Else, such index is a single integer. Test such argument.
    #             } else {
    #                 '${arg_tester}' "${@[${arg_index}]}" || '
    #         
    #         # If such tester tests variable rather than value types, tailor such
    #         # exception message to variable types. There exist two cases to
    #         # distinguish here:
    #         #
    #         # 1. Such variable does not exist.
    #         # 2. Such variable does exist but is of a different type.
    #         if (( arg_type_is_var_type )) {
    #             die_arg_var_type_prefix=':die "Function ${funcstack[1]}() expected argument ${arg_index} referencing variable of type '${arg_subtype_local[8,-1]}' but variable \$\{${@[${arg_index}]}\} '

    #             #FUXME: The type printed above is a high-level zeshy-specific type;
    #             #The type printed below is a low-level zsh-specific type.
    #             #Naturally, the latter should be converted to the former.

    #             code_args_local_or_valid+='{
    #                 if { :Var.is } {
    #                     '${die_arg_var_type_prefix}'has type ${(tP)@[${arg_index}]} and value:"$''\n''"${@[${arg_index}]}"
    #                 } else {
    #                     '${die_arg_var_type_prefix}'not found."
    #                 }
    #             }'
    #         # Else, tailor such exception message to value types.
    #         } else {
    #             code_args_local_or_valid+=':die "Function ${funcstack[1]}() expected argument ${arg_index} of type '${arg_subtype_local}' but received:"$''\n''"${@[${arg_index}]}"'
    #         }

    #         # End such exception message and such validation.
    #         code_args_local_or_valid+='$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY__FUNC_PROTOTYPE}'
    #     }
    # }'
    #     }

    #     #FUXME: Document me.
    #     if (( args_is_optional )) {
    #         code_args_local_or_valid+='
    # }'
    #     }

            # Delimit each such index by '"${' and '}"' (e.g., convert "1 3 4" to
            # '"${1}" "${3}" "${4}"). Such operation must *NOT* be double-quoted.
            # See "README.dev" for further details. Dismantled, this is:
            #
            # * "=", splitting such indices on whitespace.
            # * "(#m)*", capturing the current index to string global ${MATCH}.

            #FUXME: Excissively verbose, particularly when replicated across
            #*EVERY* single zeshy function. Encapsulate all functionality following
            #the first "||" below with new exception handlers resembling
            #::func.die(). However, such handlers should accept
            #function names rather than prototypes; given the former, such handlers
            #may losslessly obtain the latter by calling the corresponding setter.
            #FUXME: O.K.; we've now drafted
            #::func.die_unless_arg_values_pass_tester() below. Call
            #such function here.
            #FUXME: If you consider it, there's no genuine reason not to simply
            #delimit such indices by "${" and "}" in the prior iteration above
            #at the point where such indices are appended to such key value.
            #Doing so should improve efficiency here by quite a bit, not to
            #mention simplifying everything a tad.

            # } else {
            #     arg_index='${'${arg_index}'}'
            # }

    # Name of the function or script calling this function. See get_caller()
    # for further details.
    # caller_name="${funcstack[2]}"

        # Ensure such argument index actually is.
                # There exist two
                # cases to distinguish here:
                #
                # 1. Such 
                # 2. Such variable does exist but is of a different type.

        # Strip "@[" and "]" delimiters, if found.
        # arg_index="${${arg_index#@\[}%]}"

        # # If such index is comma-separated, split such index into two
        # # indices signifying an index range and iteratively test all
        # # arguments in such range.
        # if [[ "${arg_index}" == (#b)([^,]##),(*) ]] {
        #     for arg_index ({${match[1]}..${match[2]}}) {
        #         .
        #     }
        # # Else, such index is a single integer. Test such argument.
        # } else {

    #FUXME: Definitely non-ideal. Such low-level details should be handled by a
    #new setter managing such effluvia for us -- say,
    #:func.Prototype(),
    #:set_string_to_global_prototype(), and so on. For now, just implement the
    #former function. Should be readily doable, based on the logic below.
    # local func_prototype_setter_name="${ZESHY_HELP_SETTER_NAME_PREFUX}func_prototype:${func_name}"
    # :func.die_unless "${func_prototype_setter_name}"
    # "${func_prototype_setter_name}" func_prototype

        #     code_args_local_or_valid+='
        # '${arg_tester}' '${${=args_expansions}//(#m)*/\"\${${MATCH}}\"}' || {

 # enabling such validation only if the caller passed the
        # current number of arguments.
    # 1 if the current argument type is a variable type (i.e., the type of the
    # variable to which such argument's value refers, such as ":string:int")
    # and 0 if such type is a value type (i.e., the type of such argument's
    # value, such as ":int_positive"). The former are the zsh equivalent of
    # pointer indirection; the latter are customary arguments.
    # integer arg_type_is_var_type
    #             arg_type_is_var_type=0
    #             arg_type_is_var_type=1

# } elif (( arg_index > arg_index_variadic_first )) {
# the number of optional arguments required by the current
        # argument count *AND* argument index offset to their initial values.
        #FUXME: Arguably, all interior logic here could be shifted into a new
        #private utility function.
        #
        # {optional argument}
        # arg_count_max = 4
        # arg_count_min = 2
        # arg_count     = 2
        # arg_count_optional = arg_count - arg_count_min = 0
        # 1 [2] 3 [4] (fake indices here)
        # 1     2     (desired indices to be rewritten to)
        # 0 -1 -1 -1  (value of ${arg_index_offset} after parsing)
        #
        # arg_count_max = 6
        # arg_count_min = 3
        # arg_count     = 3
        # arg_count_optional = arg_count - arg_count_min = 0
        # 1 [2 3] 4 [5] 6 (fake indices here)
        # 1       2     3 (desired indices to be rewritten to)
        # 0 -1-2 -2 -3 -3 (value of ${arg_index_offset} after parsing)
        # 0  0 0  0  0  0 (value of ${arg_count_optional} after parsing)
        #
        # arg_count_max = 6
        # arg_count_min = 3
        # arg_count     = 4
        # arg_count_optional = arg_count - arg_count_min = 1
        # 1 [2 3] 4 [5] 6 (fake indices here)
        # 1  2    3     4 (desired indices to be rewritten to)
        # 0  0-1 -1 -2 -2 (value of ${arg_index_offset} after parsing)
        # 1  1 0  0  0  0 (value of ${arg_count_optional} after parsing)
        #
        #We could probably relate ${arg_index_offset} and
        #${arg_count_optional}, but it hardly seems worth it. O.K.; so, integer
        #local ${arg_count_optional} suggests the following algorithm:
        #
        #* Define such integer above.
        #* Set such integer as above here.
        #* If the current argument is optional in the iteration below *AND*
        #  such integer is positive, decrement such integer by 1, signifying
        #  such iteration to have handled an additional optional argument
        #  admitted by the current argument count.
        #* Else, continue (literally) to the next argument in such iteration.
        #
        #And... that's it! Surprisingly straightforward.

            #FUXME: How to implement optional and variadic argument indices? Hmm.
            #
            # [optiona]
            # arg_min_count = 2
            # arg_max_count = 4
            # arg_optional_count = 2 = arg_max_count - arg_min_count
            #
            #   ? ?
            # 1 2 3 4
            # to check 2, this suffices: "(( # >= 3 ))"
            # to check 3, this suffices: "(( # == 4 ))"
            #
            # [optiona]
            # arg_min_count = 5
            # arg_max_count = 5
            # arg_optional_count = 0 = arg_max_count - arg_min_count
            #
            # {non-optional case}
            # arg_max_count = 5
            # #             = 9
            # 1 2  3 4 5 6 7   8  9 (true indices in reality)
            # 1 2  3           4  5 (fake indices here)
            # 1 2 [3 4 5 ...] -2 -1 (desired indices to be rewritten to)
            # 3-5-1=-3
            #
            # {optional case}
            # arg_max_count = 5
            # 1 2  3           4  5
            # 1 2 [3 4 5 ...] -2 -1
            # ...hmm; looks the same as above, eh?
            #
            #If a variadic argument is present, all indices following such
            #argument should be negative rather than positive. However, this
            #can only be achieved *AFTER* parsing such arguments. To do so,
            #we'll need to preserve the index of the variadic argument in the
            #iteration above -- say, as ${arg_index_variadic_first}. Easily
            #done, at least. Seems sensible, no?
            #
            #Of course, the above assumes such variadic argument to be nonoptional.
            #If optional, things change somewhat -- not substantially, but they
            #*DO* change. Contemplate.
            #FUXME: Right. Optional arguments are best handled by dynamically
            #declaring argument count-specific variants of map
            #${arg_tester_to_values}: e.g.,
            #
            # if (( arg_is_optional )) {
            #     local args_list_name="arg_tester_to_values_if_args_${arg_index}_or_more"
            #     local -A ${args_list_name}
            #     ...
            # }
            #
            #Actually, such lists should be declared by the prior iteration. Then
            #test here whether "(( args_is_optional ))", implying at least one
            #optional argument to exist. If this is the case, then *ALL*
            #non-optional arguments preceding the first optional argument need to
            #be appended to the appropriate key values of *ALL* such lists (since,
            #of course, such non-optional arguments must be unconditionally
            #validated regardless of how many arguments were passed).

                # Note the index of the first variadic argument.
                # arg_index_variadic_first="${arg_count_max}"

    # Index of the first variadic argument. Defaulting such index to an
    # arbitrarily large value ensures that tests of whether or not the current
    # argument index follows that of a variadic argument fail below unless this
    # function actually accepts such a variadic argument.
    # integer arg_index_variadic_first=32768

            # Else, such argument is mandatory.
                #FUXME: Obsolete?
                # # If such argument is also variadic, ...
                # if (( arg_is_variadic )) {
                # # Else, such argument is non-variadic.
                # } else {
                # }

                    # the caller
                    # default to the value 
                    #
                    # ensuring subsequent
                    # argument indices are 

        # 1     2     (true indices in reality)
                # for    such
                # iteration to have handled an additional optional argument
                # admitted by the current argument count.

            # # If such argument is optional, ...
            # if (( arg_is_optional )) {
            #     true
            # # Else if such argument is variadic, ...
            # } elif (( arg_is_variadic )) {
            #     # If such argument is mandatory, index all arguments in the range
            #     # of such variadic argument list, beginning with such positive
            #     # index and ending with the negative index of the last argument in
            #     # such list. See below for related logic.
            #     if ! (( arg_is_optional )) {
            #         arg_index="@[${arg_index},"$(( arg_index - arg_count_max - 1 ))']'
            #     # Else, such argument is optional.
            #     } else {
            #         true
            #     }
            # # Else, such argument is mandatory.
            # #
            # } elif (( arg_index > arg_index_variadic_first )) {
            #     arg_index='@['$(( arg_index - arg_count_max - 1 ))']'
            # }

# Construct code validation of such type to the string of all
        # validation for such function.

    #FUXME: Huzzah! We've uncovered an elegant way of implementing optional
    #arguments: simply wrap *EVERYTHING* relating to argument type validation
    #below in an outer loop resembling:
    #
    #integer arg_count
    #for     arg_count ({${arg_count_min}..${arg_count_max}}) {
    #    ...
    #}
    #
    #*NOTHING* else changes. Given such structure, we intuit that there should
    #be no need for dynamically declared map variables and such. Retaining the
    #current logic and variables *SHOULD* suffice. "Hey, ho! Off and away we go."

            # if (( args_is_variadic && arg_count_min != arg_count_max )) {
            #     ::func.die 'accepts both optional and variadic arguments'
            # }

# and increment the minimum argument
            # count as well
                    #FUXME: Document me.
                    # args_map_name="arg_tester_to_values_if_args_${arg_count_max}_or_more"
                    # local -A ${args_map_name}

    #FUXME: Document me, if still used.
    # local args_map_name

    #FUXME: Actually, the following iteration appears to be unnecessary. We can
    #probably embed the following statement in the prior iteration:
    #
    #    arg_tester_to_values[${arg_subtype_local}]+=" ${arg_index}"
    #
    #However, to support optional and variadic arguments, we'll probably want
    #to embed delimiting characters indicating the current argument index in
    #the above string value to be either optional and variadic. For example,
    #optional argument indices could be indicated as follows:
    #
    #    arg_tester_to_values[${arg_subtype_local}]+=" ${arg_index}?"
    #
    #Variadic argument indices could be indicated as follows:
    #
    #    arg_tester_to_values[${arg_subtype_local}]+=" ${arg_index}."
    #
    #Dead simple. Both time- and space-efficient to parse. So, let's do that.

    #FUXME: Implement me as commented above. We'll likely want to:
    #
    #* Append all such code to string local ${func_preamble},
    #  defined by the caller.
    #* If such type:
    #  * Matches glob ":string:(#b)([a-zA-Z0-9-_])", call
    #    :die_unless_var_${match[1]}_of_cause().
    #  * Matches glob ":(#b)([a-zA-Z0-9-_])", call
    #    :die_unless_${match[1]}_of_cause(). Throw an exception
    #    here if such exception handler does not exist.
    #* How do we handle optional arguments? Right. By the above
    #  guarantee, an argument list cannot contain both optional
    #  and variadic arguments. Given that, if the current
    #  argument is optional, simply assume no variadicity (on
    #  good faith) and... What? Hmm; right. For now, since the
    #  function will almost certainly be setting such optional
    #  value to its default if unpassed, we'll probably want
    #  to (within such appended code, of course):
    #  * Test whether such argument was passed by checking the
    #    number of passed arguments. That's easily enough
    #    tested for functions with only one optional argument,
    #    of course, but for functions accepting more than one,
    #    the algorithm becomes a bit more complex. In any case,
    #    we won't know the maximum number of arguments until
    #    *AFTER* parsing, suggesting we'll probably want to
    #    append to a list local for each optional argument
    #    type (to be handled after iteration). Say, append the
    #    name, type, and index of such argument as three
    #    separate list items, then iterate such list
    #    three-at-a-time? Seems tolerable enough.
    #  * In any case, if such test implies such argument to
    #    have been passed, validate such argument's type; else,
    #    assume the default value the function itself supplies
    #    to be of the correct type. (Sane assumption, in most
    #    cases. Yay!)
    #* Don't forget to handle variadic arguments! (Ugh.)
    #  We'll probably only be able to handle type validation
    #  for such arguments *AFTER* parsing all arguments and
    #  hence determining how many (if any) arguments follow
    #  such variadic list. Unctuous, but not infeasible. See
    #  the discussion above for optional arguments. Probably a
    #  similar post-iteration implementation, we should think.
    #FUXME: Actually, for efficiency, perform low-level raw
    #string indexing with hard-coded indices rather than
    #capturing match groups with "(#b)" above. Happily, this
    #also has the beneficial side-effect of preserving
    #${match}, which may prove essential later.

                    #FUXME: Obsolete.
                    # # if such argument is variadic, note such fact.
                    # if (( arg_is_variadic )) {
                    #     args_index_type_optional_variadic+=( "${arg_max_count}" 1 0 )
                    # # Else if such argument is optional, note such fact.
                    # } elif (( arg_is_optional )) {
                    #     args_index_type_optional_variadic+=( "${arg_max_count}" 0 1 )
                    # }

            # If such argument is optional, note such function to accept at
            # least one optional argument. Perform such test *AFTER* the
            # variadic-specific logic above possibly adjusts such boolean.
            # if (( arg_is_optional )) {
            #     args_is_optional=1
            # }

                # If such argument is both variadic *AND* optional, ignore the
                # latter fact. This barefaced kludge prevents validation below
                # from throwing an exception due to such function accepting
                # both variadic and optional arguments. In general, there
                # exists no reliable means of distinguishing such arguments
                # apart, constituting a fatal error. In this case, however,
                # assuming the variadic argument to also be the only optional
                # argument, there exists no conflict between the two, in which
                # case condition is genuinely ignorable.
                # if (( arg_is_optional )) {
                #     arg_is_optional=0
                # }

 # For
                # simplicity, print only the first function name in such
                # exception message.
    #FUXME: Utterly horrid. Good God; the hacks we employed both here and
    #above. Excise this away by returning to what we had before: just perform
    #such test twice, once when the current argument is variadic and  once when
    #the current argument is optional. Dramatically more elegant. *sigh*

    # If such function accepts both optional and variadic arguments, there
    # exists no general-purpose means of distinguishing the two for *ANY*
    # purposes (let alone for argument validation coded below). Since this
    # signifies a fatal error, throw an exception.
    #
    # We maintain booleans for tracking whether such function accepts variadic
    # but *NOT* optional arguments. Happily, testing whether the minimum and
    # maximum number of arguments such function accepts suffices to test
    # whether such function accepts optional arguments.
    #
    # While such test *COULD* be tested for above with multiple discrete tests
    # (e.g., if the current argument is optional, testing for prior variadic
    # arguments, and the inverse if the current argument is variadic), the
    # current approach is considerably more intelligible.
    # if (( args_is_variadic && arg_count_min != arg_count_max )) {
    #     ::func.die 'accepts both optional and variadic arguments'
    # }

# arg_index_start arg_index_end
            # Test such argument(s).

                # args_map_name="args_index_type_optional_variadic_if_args_${arg_count_max}_or_more"
    #FUXME: Documentation unsurprisingly obsolete, as is this list's name.
    #Resurrect the prior list's name and documentation from the wastelands.

    # Map from argument index to a character signifying optional metadata
    # associated with such argument:
    #
    # * "?", signifying such argument to be optional.
    # * ".", signifying such argument to be variadic.

#, each
    # item of whuch signifies the expected :
        #FUXME: Hmm; such operation works, but how and where? Well, we suppose
        #we'll need to shift back such map appending back here. *sigh*

            # if (( arg_count_max == arg_count_min )) {
            #     arg_index=$(( arg_index - arg_count_max - 1 ))
            # } else {
            #     arg_index=$(( arg_index - arg_count_max - 1 ))
            # }

        #FUXME: We need to strip "?" and "." characters optionally suffixing
        #such indices from such string of indices prior to munging it below.
        # args_index_type_optional_variadic.

    #FUXME: Obsolete.
    # List of argument-specific metadata for all arguments with types other
    # than simply ":string" to be validated. Such validation typically
    # depends on the maximum number of arguments accepted by such function, a
    # quantity available only *AFTER* parsing all such arguments. Such parsing
    # thus appends such metadata to this list, which post-parsing iteration
    # then converts into such validation.
    # local -a args_index_name_type_optional_variadic

    #FUXME: Document me.
    # local arg_index_suffix

    #FUXME: Document optional and variadic argument-specific suffixes.

                    #FUXME: Obsolete.
                    # args_index_name_type_optional_variadic+=(
                    #     "${arg_count_max}"
                    #     "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name}]}"
                    #     "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"
                    #     "${arg_is_optional}"
                    #     "${arg_is_variadic}"
                    # )

                    #FUXME: Arguably not the best way to do things. Wouldn't
                    #the following be preferable:
                    #
                    # if (( arg_is_optional )) {
                    #     args_index_type_optional_variadic[${arg_index}]='?'
                    # } elif (( arg_is_variadic )) {
                    #     args_index_type_optional_variadic[${arg_index}]='.'
                    # }
                    #
                    #Then, just efficiently check such list item below. That
                    #circumvents the need to unpack such suffixes, which does
                    #indeed appear to pose an undue burden on logic below.

                    # If such argument is optional, suffix such index by an
                    # arbitrary character indicating that fact.
                    # if (( arg_is_optional )) {
                    #     arg_index_suffix='?'
                    # # Else if such argument is variadic, suffix such index by
                    # # an arbitrary character indicating that fact.
                    # } elif (( arg_is_variadic )) {
                    #     arg_index_suffix='.'
                    # # Else, suffix such index by no such character.
                    # } else {
                    #     arg_index_suffix=
                    # }

                    # # Append such argument's index to the space-delimited
                    # # string of all indices with such argument's type.
                    # arg_tester_to_values[${arg_subtype_local}]+=" ${arg_index}${arg_index_suffix}"

    # against such prototype constraints parsed above.
    # Whitespace-delimited string of all argument expansions to be passed to
    # the current argument type validator (e.g., '"${1}" "${3}" "${4}").
    # local args_expansions

        #FUXME: Combine this and the subsequent assignment, ideally later.

        # Delimit each such index by '"${' and '}"' (e.g., convert "1 3 4" to
        # '"${1}" "${3}" "${4}"). Such assignment must *NOT* be double-quoted.
        # See "README.dev" for further details. Dismantled, this is:
        #
        # * "=", splitting such indices on whitespace.
        # * "(#m)*", capturing the current index to string global ${MATCH}.
        # args_expansions=${${=args_expansions}//(#m)*/\"\${${MATCH}}\"}

            # code_args_local_or_valid+='''Function ${funcstack[1]}() argument ${arg_index} references variable ${''${@[${arg_index}]}''} either not found or not of expected type '${arg_subtype_local[8,-1]}'.'''
        # "Function ${funcstack[1]}() expected argument ${arg_index} of type '${arg_subtype_local}' but received:"$''\n''"${@[${arg_index}]}"$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY__FUNC_PROTOTYPE}'
# '$''\n\n''"Argument ${arg_index}:"$''\n''"${@[${arg_index}]}"

#(i.e., rejected by function '${arg_tester}'())
        #FUXME: Ugh. This does *NOT* suffice, principally due to the horrid
        #ambiguity of the resulting exception messages. No, my good friends;
        #we'll need to manually call a tester instead and when such tester
        #fails manually iterate such arguments until finding the failing
        #argument.
        #FUXME: Ugh. Even *THAT* fails to suffice. Why? Because we've
        #wrongfully conflated the two sorts of validation performed here.
        #:die_unless_var_*() functions require a *COMPLETELY* different calling
        #convention: namely, they require such arguments to be localized and
        #the names of such local variables to be passed rather than their
        #indices. Regardless of the calling convention, however, we'll still
        #need to implement the prior FUXME comment in both cases. *sigh*
        #FUXME: Such localization would be greatly simplified by *ALWAYS*
        #unconditionally localizing non-variadic arguments. That said, the
        #inefficiency costs are (indeed) annoyingly cloying in that case.
        #FUXME: Wait. Nevermind. We convoluted ourselves here. Obviously, the
        #calling conventions are the same in both cases. So, just apply the
        #initial FUXME above. (My, what convolutions of an unwitty demagouge.)

        # :func.die_unless "${arg_tester}"
    #FUXME: Rename, as such variable is reused below in a different context.

    #FUXME: Should arguably be shifted to @{*-pcre} and converted into a string
    #global accessed both here and in that parcel.
    #FUXME: Actually, this is altogether silly. Excised!

    # Character class matching all permissible characters in operable names.
    # See @{*-pcre} for further details.
    # local operable_name_char_class='[a-zA-Z0-9-_]'

        #FUXME: This could absolutely benefit from a significantly more
        #informative message. This will probably happen *ALL* the time.

        # Name of the function performing such validation.
        # Delimit each such index by '"${' and '}"' (e.g., convert "1 3 4" to
        # '"${1}" "${3}" "${4}"). Such assignment must *NOT* be double-quoted.
        # See "README.dev" for further details. Dismantled, this is:
        #
        # * "=", splitting such indices on whitespace.
        # * "(#m)*", capturing the current index to string global ${MATCH}.
        # args_expansions=${${=args_expansions}//(#m)*/\"\${${MATCH}}\"}

        # Append code calling such function with each such arguments.
        # code_args_local_or_valid+=$'\n'${arg_type_checker}' '${args_expansions}

        #FUXME: Inefficient in the common case there exist multiple
        #arguments of the same type to be tested. Ideally, we want only a
        #single function call validating all such arguments together,
        #suggesting we probably need a new local map from... say,
        #"${check_func_name}" keys to "${arg_index1} ${arg_index2} ..."
        #values. Not terribly arduous to maintain or parse, happily.

    # Map from function names validating variable types to space-delimited
    # strings listing the indices of all arguments to be validated by such
    # function.
    # local -A var_type_checker_to_arg_values

        # arg_name\
        # arg_subtype_local\
            #FUXME: Do we still require ${arg_is_optional}?

                #FUXME: Nonsensical hack. Just add a new boolean
                #${args_is_optional} above, defaulting to 0.

                # If such argument is both variadic *AND* optional, reduce the
                # total number of maximum arguments by one. This barefaced
                # kludge prevents validation below from throwing an exception
                # due to such function accepting both variadic and optional
                # arguments. In general, there exists no reliable means of
                # distinguishing such arguments apart, constituting a fatal
                # error. In this case, however, assuming the variadic argument
                # to also be the only optional argument, there exists no
                # conflict between the two.
                #
                # Since variadic functions accept a countably infinite number
                # of arguments and hence have no maximum argument count,
                # decrement such count rather than incrementing the minimum
                # argument count. While either suffices to squelch such
                # validation below, the latter erroneously renders such
                # argument non-optional. (In any event, we trudge onward.)
                # if (( arg_is_optional )) {
                #     arg_count_max+=-1
                # }

    #FUXME: Hmm; why don't we also define ${args_is_variadic} here too?

                # # arg_subtype_local="${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}"

                # # If such type is *NOT* ":string", validate such type. (Since
                # # all arguments are untyped scalars from the low-level zsh
                # # perspective, there exists no validation to be performed for
                # # arguments of type ":string".)
                # if [[ "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}" != ':string' ]] {
                # # if [[ "${arg_subtype_local}" != ':string' ]] {
                #     arg_names_types+=(
                #         "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name}]}"
                #         "${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_type}]}" )
                #     arg_name="${match[${ZESHY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_name}]}"

                #     # If such argument is optional, ...
                #     if (( arg_is_optional )) {
                #         true
                #     # Else, such argument is mandatory.
                #     } else {
                #         # If such argument is a string referring to another
                #         # variable's name, validate that such variable exists
                #         # *AND* is of the expected type.
                #         if [[ "${arg_subtype_local}" ==\
                #             ':string:'${~operable_name_char_class} ]] {
                #             # Name of the function performing such tests.
                #             test_func_name=":die_unless_var_${arg_subtype_local[9,-1]}_of_cause"
                #             :func.die_unless "${test_func_name}"

                #             # test_arg_types+=""
                #         }
                #     }

    # # Total number of optional arguments for such function.
    # integer arg_count_optional=0

    # See
    # :func.die_unless() and :define_function() for further details.
    # { typeset -f -- "${ZESHY__FUNC_NAMES[@]}" } 1>/dev/null || {
    #     local func_name
    #     for   func_name ("${ZESHY__FUNC_NAMES[@]}") {
    #         if (( ${+functions[${func_name}]} )) {
    #             :die "Function ${func_name}() already exists:"$'\n'"$(which -- "${func_name}")"
    #         }
    #     }
    # }

                            # If such function does *NOT* exist, throw an
                            # exception.

            #FUXME: If there exists at least one optional argument *FOLLOWING*
            #a variadic argument list, throw an exception, as there exists no
            #means of distinguishing the two. 

            # # If such argument follows a variadic argument list, throw an
            # # exception, as there exists no means of distinguishing the two.
            # } elif (( args_is_variadic )) {
            #     #FUXME: Insufficient. We *ALSO* need to throw an exception if
            #     #optional arguments precede variadic arguments. Given that,
            #     #we'll probably want to validate this constraint *AFTER*
            #     #parsing all arguments. Then simply perform the following test
            #     #below after iteration and excise this conditional here:
            #     #
            #     #if (( args_is_variadic && arg_count_min != arg_count_max )) {
            #     #    :die '...'
            #     #}
            #     #
            #     #No need to add or track a new boolean, which is nice.

            #     ::func.die:die ${(e)error_prefix}' accepts both optional and variadic arguments:'${(e)error_suffix}

            # If such argument is suffixed by both an eroteme *AND* default
            # value, print a nonfatal warning. While redundant, such edge case
            # does *NOT* warrant a fatal exception.

# error_prefix error_suffix
    #FUXME: Nonsense. Just concoct a new private exception handler -- say,
    # :void ::func.die(:string exception_message)

    # Substrings prefixing and suffixing all exception messages thrown below.
    # For efficiency, require such strings be expanded below with parameter
    # expansion flag "(e)", delaying the cost of forking a subshell until
    # necessary. For readability, list only the first function name declared by
    # such prototype.
    # error_prefix='Function ${ZESHY__FUNC_NAMES[1]}()$(:parcel.label)'
    # error_suffix='$''\n\n''${ZESHY__FUNC_PROTOTYPE}'

        #FUXME: Insufficient. We *ALSO* need to throw an exception if
        #optional arguments precede variadic arguments. Given that,
        #we'll probably want to validate this constraint *AFTER*
        #parsing all arguments. Then simply perform the following test
        #below after iteration and excise this conditional here:
        #
        #if (( args_is_variadic && arg_count_min != arg_count_max )) {
        #    :die '...'
        #}
        #
        #No need to add or track a new boolean, which is nice.

                #FUXME: $(::parcel.get_preposition_if_found_or_noop) is
                #horrible, isn't it? ${ZESHY_PARCEL_NAME} should *ALWAYS* be
                #set to a non-empty string, implying we should just excise such
                #function and expand such low-level string global here and
                #everywhere similar else.
                #FUXME: Hmm; define a new string local above:
                #   #  For simplicity, print only the first function name in such message.
                #   local error_message_prefix='Function '${ZESHY__FUNC_NAMES[1]}'() in parcel '${ZESHY_PARCEL_NAME-(undefined)}

    #FUXME: Terrifically silly. We can simply rewrite this to read:
    #    die_arg_count_prefix=' || :die "Function ${funcstack[1]}() expects '
    #
    #Obvious, if moderately clever. Given that, shift this and the
    #following if conditional to the very end of
    #::func_.parse_args(). (Yes!)

        # functions[${func_name}]="${functions[${func_name}]}"
    #FUXME: Getting a bit old, honestly. Just declare appropriate type testers
    #and exception handlers in @{*-test}. Sadly, this implies pretty much
    #shifting the *ENTIRETY* of @{var/type} into @{*-test} -- but it's
    #difficult to see an alternative. Repetition of the code below is simply
    #horrible, and nseds to cease sooner than later.

        #FUXME: Technically, such function name could contain double quotes. In
        #such case, we'll need to prefix such quotes by "\" to prevent errors
        #when throwing exceptions below. Define a new string local
        #${func_name_sanitized} here and then use such local in exception
        #messages below.
        #FUXME: Right; such function name could even contain command
        #substitutions (e.g., "$(...)"). So, we'll need to prefix all
        #characters with a special meaning in double quotes (e.g., "`", '"',
        #"$") *NOT* already prefixed by "\" by "\". We seem to recall already
        #implementing such functionality somewhere. Hmm... Oh, yes; doesn't
        #either "(qq)" or "(qqq)" achieve the desired effect?

#$'\n\n"'${(qq)ZESHY__FUNC_PROTOTYPE}.
# ${func_name} prototype: ${ZESHY__FUNC_PROTOTYPE}"$'\n\n'
    # [[ "${(t)ZESHY__FUNC_NAMES-}" == "array"* ]] || :die\
    #     ''List ${ZESHY__FUNC_NAMES} undefined or not a list (e.g., as :func_() not previously called).''

    # [[ "${(t)ZESHY__FUNC_ATTRS-}" == 'association'* ]] || :die\
    #     'Map ${ZESHY__FUNC_ATTRS} undefined or not a map.'
    # [[ "${(t)ZESHY__FUNC_NAMES-}" == 'array'* ]] || :die\
    #     'List ${ZESHY__FUNC_NAMES} undefined or not a list.'

    # [[ "${(t)ZESHY__FUNC_PROTOTYPE-}${(t)ZESHY__FUNC_ARGS-}" == 'scalar'*'scalar'* ]] || :die\
    #     'Strings ${ZESHY__FUNC_PROTOTYPE} and/or ${ZESHY__FUNC_ARGS} undefined or not strings (e.g., as :func_() not previously called).'

    #FUXME: O.K.; this is *GREAT* for parsing merely argument lists, but fails
    #to account for argument channels. We only care about the "args = "
    #argument channel, for obvious reasons. So, if such string is prefixed by
    #"[", we'll need to reparse the substring of such string following the "("
    #in "args = (" and preceding the corresponding ")" *BACK* into such string.
    #This sort-of implies we'll need to add a new PCRE string global to
    #@{*-pcre} to perform such matching. *sigh*
    #FUXME: Wait. *ACTUALLY*, why don't we just modify the existing PCRE string
    #global ${ZESHY__CALLABLE_PROTOTYPE_PCRE} to capture *ONLY*
    #the contents of the "args =" channel into such match group?  Indeed, using
    #"(?|...)"-style capturing, we should be able to ensure that such match
    #group contains the desired substring regardless of whether it was embedded
    #in a channel or not. Sweet, no?

 # the following indices of canonical list
        # global ${match}:
        #
        # * 1, such argument's mandatory type.
        # * 2, such argument type's optional eroteme (i.e., "?"), signifying
        #   that such function's definition should *NOT* be prefixed by a call
        #   to an exception handler throwing an exception if such argument
        #   violates the constraints of such type (e.g., a non-numeric string
        #   passed where an integer was expected). If unspecified, such
        #   definition is prefixed by such a call.
        # * 3, such argument's mandatory name.
        # * 4, such argument's optional eroteme (i.e., "?"), signifying such
        #   argument to be optional. If unspecified, such argument is mandatory.
        # * 5, such argument's optional default value.
        # * 6, such argument's optional ellipse (i.e., "..."), signifying such
        #   argument and hence function to be variadic.
#FUXME: Print nonfatal warnings for function prototypes containing two or more
#instances of the variadic specifier "...", as there typically exists no
#generally reliable means of differentiating which variadic list passed
#arguments belong to.

# initially validate the passed
    # argument list against the prototype constraints parsed above.
    # Redefine such function in terms of such prototype.
#     ::declare_func_redefinition
# 
# # :void ::declare_func_redefinition()
# function ::declare_func_redefinition() {
#     # Validate sanity.
#     (( # == 0 )) || :die 'Expected no arguments.'
# }

            # coerce the maximum argument count to a suitably small integer
            # effectively guaranteeing such count.
    # [[ "${(t)ZESHY__FUNC_PROTOTYPE-}${(t)ZESHY__FUNC_ARGS-}" == 'scalar'*'scalar'* ]] || :die\
    #     'Strings ${ZESHY__FUNC_PROTOTYPE} and/or ${ZESHY__FUNC_ARGS} undefined or not strings (e.g., as :func_() not previously called).'

#FUXME: Unfortunately, it's fairly evident we have an efficiency problem.
#Startup up time discernably scale linearly with function declarations, which
#isn't good. Ideally, such declarations should be negligible. We strongly
#suspect the culprits to be the gamut of eval() statements such declarations
#perform. So, one by one, we'll probably want to iteratively excise *ALL* such
#statements from both this and prior parcels -- and this function is a perfect
#place to start.

#FUXME: Document me. However, leave the comment below *HERE*.

# If ${ZESHY__FUNC_PROTOTYPE} is undefined or of an unexpected type,
# throw an exception.  Since ::declare_func_prototype,attrs,names()
# subsequently validates both ${ZESHY__FUNC_ATTRS} and
# ${ZESHY__FUNC_NAMES}, avoid doing so here. See :String.die_unless()
# for further details.

# alias '}:func'='}
#     [[ "${(t)ZESHY__FUNC_PROTOTYPE-}" == "scalar"* ]] || :die\
#         ''Variable ${ZESHY__FUNC_PROTOTYPE} undefined or not a string (e.g., as :func_() not previously called).''
#     ::declare_func_prototype,attrs,names\
#         "${ZESHY__FUNC_PROTOTYPE}"\
#            ZESHY__FUNC_ATTRS\
#            ZESHY__FUNC_NAMES'

# void ::declare_func_prototype,attrs,names[
#    args: (
#        string func_prototype,
#        string func_attrs_map_name,
#        string func_names_list_name),
#    stdin: string func_asciidoc]
# function ::declare_func_prototype,attrs,names() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one function prototype, one function attributes map name, and one function names list name.'
#     local\
#         func_prototype__dfwpban="${1}"\
#         func_attrs_map_name__dfwpban="${2}"\
#         func_names_list_name__dfwpban="${3}"
#     # print -r "${(@P)func_names_list_name__dfwpban}"
# 
#     # If any such variable is undefined or not of the expected type, throw an
#     # exception. See :List.die_unless() and :Map.die_unless() for further
#     # details.
#     [[ "${(tP)func_attrs_map_name__dfwpban-}" == "association"* ]] || :die\
#         'Map ${'${func_attrs_map_name__dfwpban}'} undefined or not a map.'
#     [[ "${(tP)func_names_list_name__dfwpban-}" == "array"* ]] || :die\
#         'List ${'${func_names_list_name__dfwpban}'} undefined or not a list.'
# 
#     # For each such function...
#     eval '
#     local func_name__dfwpban
#     for   func_name__dfwpban ("${'${func_names_list_name__dfwpban}'[@]}") {
#         # If such prototype declared attributes, handle such attributes.
#         if (( ${#'${func_attrs_map_name__dfwpban}'} )) {
#             # If such attributes include "globbable," disable filename globbing
#             # for all arguments passed to such function by defining a simple
#             # alias of the same name shadowing such function. See
#             # is_list_contains() for further details.
#             #
#             # For safety (in the event of function names containing alias-
#             # reserved characters), call :alias_command.define() rather than
#             # attempting to manually define such alias.
#             if (( ${'${func_attrs_map_name__dfwpban}'[(i)globbable]} <=\
#                  ${#'${func_attrs_map_name__dfwpban}'} )) {
#                 :alias_command.define\
#                     "${func_name__dfwpban}" "noglob ${(q)func_name__dfwpban}"
#             }
#         }
# 
#         #FUXME: This is fairly lame. See @{*-alias} for commentary.
# 
#         # Add such function to the current parcel.
#         :parcel.add_function "${ZESHY_PARCEL_NAME}" "${func_name__dfwpban}"
#     }'
# 
#     # Document such functions with such documentation *AFTER* successfully
#     # defining such functions above.
#     ::func.document_with_prototype,stdin_if_found_or_noop\
#         "${(@P)func_names_list_name__dfwpban}"\
#         "${func_prototype__dfwpban}"
# }

    #FUXME: Inefficient. Refactor to something resembling:
    #    { typeset -f -- "${@}" } :silent_stdout

    # # Documentation passed on standard input.
    # ::help.set_to_stdin func_asciidoc__dfwpban

    # # Document such functions with such documentation.
    # ::func.document_with_prototype,asciidoc\
    #     "${(@P)func_names_list_name__dfwpban}"\
    #     "${func_prototype__dfwpban}"\
    #     "${func_asciidoc__dfwpban}"

#FUXME: Document me.
# void ::func_.stop()
# function ::func_.stop() {
#     # Validate sanity.
#     (( # == 0 )) || :die 'Expected no arguments.'
# }

    # Declare all functions parsed from the previously passed prototype.

    # If string global ${ZESHY__FUNC_PROTOTYPE} (previously set by
    # :func_() to this function's prototype) is either *NOT* defined or
    # of the expected type, :func_() cannot have been previously
    # called; in such case, throw an exception. See :String.die_unless() for
    # further details.

#FUXME: O.K.; this is great, but there's a wee annoying flaw: syntax errors.
#They'll be reported as errors for a function named "::func", which isn't
#helpful in the least. Perhaps more importantly, they'll be largely unhelpful,
#as current syntax errors are. Fortunately, both are correctable by:
#
#* Embedding such definition in a :try{...}:catch{...}:catch block. Yes, this
#  *DOES* incur a slight performance penalty, but... *shrug* The demonstrable
#  gain in significantly more readable syntax errors than we currently receive
#  makes this an absolutely beneficial tradeoff.
#* Ah! Sweet. Great. So, the "catch" portion of that block will need to match
#  "${EXCEPTION}" against a glob matching only function definition errors.
#  Fortunately, that's *VERY* easy to match. How? Just check :redefine_func().
#  We already do it there.
#* So, we'll need to strip that glob out into a new string global -- say,
#  ${ZESHY_FUNC_ERROR_GLOB}.
#* If '"${EXCEPTION}" == ${~ZESHY_FUNC_ERROR_GLOB}', we'll need to:
#  * Catch such exception. Problem is, we haven't defined such functionality
#    yet! *Ugh.* On the bright side, such functionality *SHOULD* be fairly
#    simple to inline here. That said, do we *REALLY* want to walk that road?
#    We might need such catching elsewhere in @{*-declare}. In such case,
#    consider shifting such functionality to a new parcel here -- say,
#    @{15-catch}.
#  * Throw a new exception describing such error. Unfortunately, since the
#    function failed to be defined, we can't reuse the core of :redefine_func()
#    printing the function line of such syntax error. Well, shucks. We *COULD*
#    conceivably get around that by examining the current call stack and
#    manually parsing such file for such function definition. We'll probably
#    have to end up doing that. But it's a bit overkill for the moment. For
#    now, just replace the "::func" in such error message with the actual
#    function name and clean the message up a bit (e.g., capitalizing such
#    message), as :redefine_func() currently does. Nice!
#FUXME: Actually, while the above *WOULD* work, it's also rather inefficient. A
#substantially more efficient approach leverages a mechanism we technically
#don't yet support but readily could (and indeed *SHOULD*): TRAPZERR() hooks.
#We've intended to add them for some time, and now we have a demonstrable
#justification for doing so. Specifically:
#
#* In a new parcel here -- say, @{*-start/*-declare/15-trap} -- define:
#  * A new list global ${ZESHY_TRAP_ZERR_HOOKS}.
#  * A new function :add_trap_zerr_hook().
#* Modify the existing TRAPZERR() in @{main} to:
#  * Test whether list global ${ZESHY_TRAP_ZERR_HOOKS} exists *AFTER* storing
#    such exception.
#  * If such test succeeds, evaluate each item of such list.
#* Define a new function ::munge_...
#* Call :add_trap_zerr_hook here from the top-level, passing such function a
#FUXME: Wait. All of the above assumes we can actually obtain the error message
#from within TRAPZERR() -- which, of course, we can't. So, we *WILL* have wrap
#this in a :try{...}:catch{...}:catch block temporarily redirecting or
#capturing standard error. *Ugh*. As we will know, such capturing will probably
#prove obscenely impossible, particularly at this early stage. Hmm.
#FUXME: We see, now. The core issue is that we're defining such function with a
#temporary name. But if you consider it, we *DON'T* have to do that. Why?
#Because the following *ACTUALLY* works (...I know, right!):
#
#    >>> :string yim='simpo'
#    >>> function "${yim}" "yohimbo" () { print ok }
#    >>> simpo; yohimbo
#    ok
#    ok
#
#What this implies, in turn, is that we can significantly improve both the
#efficiency and error reporting of :func_() and cohorts. Specifically:
#
#* Define new map global ${ZESHY__FUNC_ATTRS}.
#* Define new list global ${ZESHY__FUNC_NAMES}.
#* Refactor :func_() to call:
#     :set_map,list_to_runnable_prototype_attrs,names\
#          ZESHY__FUNC_ATTRS\
#          ZESHY__FUNC_NAMES\
#          "${func_prototype}"
#* Redefine :func{() like so:
#    alias ':func{'='
#        [[ "${(tP)ZESHY__FUNC_NAMES-}" == "array"* ]] || :die\
#            ''List ${ZESHY__FUNC_NAMES} undefined or not a list (i.e., :func_() not previously called).''
#        (( ${#ZESHY__FUNC_NAMES} )) || :die\
#            ''List ${ZESHY__FUNC_NAMES} empty.''
#        function "${ZESHY__FUNC_NAMES[@]}" () {'
#* Define new function ::declare_func_prototype,attrs,names().
#* Refactor both ::declare_func() and :declare_func() to internally call
#  ::declare_func_prototype,attrs,names(). Hence, ::declare_func() should
#  no longer call :declare_func() and :declare_func() should no longer call
#  :set_map,list_to_runnable_prototype_attrs,names().
#* Rename @{*-start/*-func/prototype} to @{*-start/*-func/func}.
#* Shift :declare_func() to @{*-start/*-func/func}. It's no longer required
#  here, but *IS* required elsewhere by early-time functionality.
#* Throw exceptions on attempting to redefine previously defined functions.
#  (Note we should be doing the same with aliases as well, which we believe we
#  currently no longer do.) Such exception should probably be thrown by
#  :func_() *BEFORE* the redefinition of such function even takes place.
#
#Awesome, no? Not terribly arduous. Note this implies we no longer need to
#redefine all functions twice -- which, while certainly nice, does imply we'll
#need to redefine all functions for reduction purposes during precompilation.

#FUXME: Ugh! Given the refactoring described above, this is somewhat nonsense.
#In particular, we needn't define such function here (since it's already
#defined, of course!) and hence needn't pass such body. I believe the remainder
#is still essential, however.
#FUXME: Indeed, this clearly implies both :define_func() and :redefine_func()
#should be shifted back to @{*-func/func}. *sigh*

    # If string global ${ZESHY__FUNC_PROTOTYPE} (previously set by
    # :func_() to this function's prototype) is either *NOT* defined or
    # of the expected type, :func_() cannot have been previously
    # called; in such case, throw an exception. See :String.die_unless() for
    # further details.

    # [[ "${(t)ZESHY__FUNC_PROTOTYPE-}${(t)ZESHY__FUNC_ATTRS-}${(t)ZESHY__FUNC_NAMES-}" ==\
    #     'scalar'*'association'*'array'* ]] || :die\
    #     'Variables ${ZESHY__FUNC_PROTOTYPE}, ${ZESHY__FUNC_ATTRS}, and/or ${ZESHY__FUNC_NAMES} undefined or not of the expected type (e.g., as :func_() not previously called).'

    # If function ::func() (previously defined by :func{() to this
    # function's body) is *NOT* defined, :func{() cannot have been
    # previously called; in such case, throw an exception. See
    # :func.die_unless() for further details.
    # (( ${+functions[::func]} )) || :die\
    #     'Function ::func() undefined (i.e., :func{() not previously called).'

    # Undefine such placeholder function, ensuring exceptions on subsequent
    # calls to this function *NOT* preceded by calls to :func{().
    # unfunction ::func

 # Probably the most interesting documentation to be included
#is the commentary below beginning:
#   "# Technically, doing so redefines such function at least twice:"
    # If function ::func() (previously defined by :func{() to this
    # function's body) is *NOT* defined, :func{() cannot have been
    # previously called; in such case, throw an exception. See
    # :func.die_unless() for further details.
    # (( ${+functions[::func]} )) || :die\
    #     'Function ::func() undefined (i.e., :func{() not previously called).'

    # Undefine such placeholder function, ensuring exceptions on subsequent
    # calls to this function *NOT* preceded by calls to :func{().
    # unfunction ::func

 # *AFTER* successfully
    # defining such functions above
        #FUXME: Absurdly inefficient. Instead, this function should accept an
        #additional argument providing the name of a function to be called here
        #defining such function. Consider defining a function ::define_func().

        # print -r "func name: ${func_name__dfwpban}"
        # Define such function.
        # :define_func "${func_name__dfwpban}" "${func_body__dfwpban}"

    # Documentation passed on standard input.
    # ::help.set_to_stdin func_asciidoc

    # # For each such function...
    # local func_name
    # for   func_name ("${func_names[@]}") {
    #     # Define such function.
    #     :define_func "${func_name}" "${func_body}"

    #     # If such prototype declared attributes, handle such attributes.
    #     if (( ${#func_attrs} )) {
    #         # If such attributes include "globbable," disable filename globbing
    #         # for all arguments passed to such function by defining a simple
    #         # alias of the same name shadowing such function. See
    #         # is_list_contains() for further details.
    #         #
    #         # For safety (in the event of function names containing alias-
    #         # reserved characters), call :alias_command.define() rather than
    #         # attempting to manually define such alias.
    #         if (( ${func_attrs[(i)globbable]} <= ${#func_attrs} )) {
    #             :alias_command.define\
    #                 "${func_name}" "noglob ${(q)func_name}"
    #         }
    #     }

    #     #FUXME: This is fairly lame. See @{*-alias} for commentary.

    #     # Add such function to the current parcel.
    #     :parcel.add_function "${ZESHY_PARCEL_NAME}" "${func_name}"
    # }

        # # If such exception handler exists, defer to such handler.
        # if (( ${+functions[::die_with_func_error]} )) {
        #     ::die_with_func_error "${func}"
        # # Else, redefine such function again. Since the prior exception handler
        # # *SHOULD* always exist, this fallback will probably never see the
        # # light of day. Which is good, because the output is terrible.
        # } else {
        #     eval "${func}"
        # }

        #FUXME: O.K.; we'll need to shift such functionality here. This is
        #fairly important, as such functionality performs several nice safety
        #checks on our behalf (e.g., ensuring such function isn't currently
        #defined and such).

    # Such
    # correlation allows a raft of , including .

    #FUXME: Horrible. Refactor in terms of the following predefined setters:
    #
    #    ::help.set_to_stdin()
    #    :set_string_to_help_prototype()
    #    :set_list_to_runnable_prototype_names()

    # [[ -n "${ZESHY__FUNC_PROTOTYPE}" ]] || :die\
    #     'Function prototype empty.'
#FUXME: Given the previously defined documenters -- namely, :func.document(),
#we can (and *SHOULD*) now shift documentation back here from below.

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

#FUXME: Matching function prototypes is feasible with one or possibly more PCREs
#but *NOT* globs, due to the need to match arbitrarily many function names and
#argument specifiers. This is essential, since:
#
#* If AsciiDoc is installed, function prototypes should be dynamically marked up
#  with AsciiDoc-specific notation, which I believe even supports colors.
#* Else, function prototypes should be styled with conventional color styles.

#     # For each such name, define a setter setting a passed string variable to
#     # such documentation. To avoid quoting issues with reserved characters in
#     # such documentation, set such variable via a here-document.
#     local runnable_name
#     for   runnable_name ("${runnable_names[@]}") {
#         setter_name=":set_string_to_"${runnable_type}"_help:${runnable_name}"
#         functions[${setter_name}]='
#     die_unless_arg "Expected one string name."
#     :string.set_to_stdin "${1}" <<''/---''
# '${runnable_help}'
# /---'
#     }

# function ::define_func_setting_string_to_string() {
# function ::document_operable() {
# function ::document_operable_type_names_with_help() {

#FUXME: Hmm. Probably just forego this function, yes? Inline it above.

    #FUXME: O.K.; we need a function here parsing all prototype names from such
    #documentation. Ugh.

#FUXME: Documentation functions should continue working after zeshy startup. To
#make this work, we'll need to redefine them in a precompile_zeshy_() function
#to ensure that the digest file contains the redefinition. Honestly, I'm not
#entirely convinced we want to serialize such documentation to disk; of course,
#we *DO*. But that invokes a few not-so-subtle issues. For now, just retain
#documentation in memory until it becomes a demonstrable problem.
#FUXME: After having performed a great deal of online research, "gzip" appears
#to be the canonical go-to for small text file compression.
#FUXME: Hmmmm. No. Scratch that. We really need a filesystem-based approach.
#O.K.; so, here's the idea:
#
#* Shift the definitions of set_alias_documentation(), etc. to this component,
#  replacing all current calls to such functions with hard-coded additions to
#  such map globals. *DO IT.* Trust me. This is needed to ensure that such
#  functions are compiled into Zeshy's digest file.
#* *DON'T* redefine declare_alias(), declare_function(), or declare_global().
#  Instead redefine set_alias_documentation(), etc. to write to disk rather to
#  such map globals in the precompile_zeshy_*() function defined below, thus
#  ensuring the redefinition of such functions is compiled into Zeshy's digest.
#
#Bam. Nice one, eh?

#FUXME: Rename the ${ZESHY_HELP_GLOBALS}, etc. globals to
#${ZESHY_CORE_HELP_GLOBALS}, etc. Such globals, *DISTINCT* from the above, now
#apply *ONLY* to top-level components (e.g., src/{main,compile,...}). For
#efficiency (and simplicity), retain the current approach of simply appending to
#such lists. Then during zeshy precompilation (as implemented by
#"always/zsh/help/precompile"), simply iterate over each such list and for each
#help string simply call declare_global(), etc. Ultra-simple and efficient.
#After doing so, all documentation resides in the
#${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals as desired.

#FUXME: We'll probably need to generalize out function prototype parsing into a
#new setter function, to be called by both :declare_function() and
#:declare_function_if_pathable().

#FUXME: Rename to :set_list_and_map_to_runnable_prototype_name_or_names().
#This function *WILL* be generalized to support parsing of global name synonyms,
#as well.
#FUXME: Actually call such function above *AND* in declare_alias().
#FUXME: Actually document such function.
    #FUXME: Abstract retrieval of runnable names to a helper function for reuse
    #under aliases.

#FUXME: Rename to ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}. Now that we're
#eliminating ${ZESHY_FUNCTION_NAME_TO_HELP}, such map had might as well include
#all declared function names.

# Map all names (including the first) for functions with multiple names to the
# first names declared for such functions.
# See ${ZESHY_PARCEL_NAME_TO_HELP} for further details.

#    # List of function names matched from such string.
#    local -a function_names__df
#
#    # Current function name iterated in such list.
#    local function_name__df
#
#    # If such function only has one name, match such name.
#    function_name__df="${help_match__df[2]-}"
#    if [[ -n "${function_name__df}" ]] {
#        function_names__df=( "${function_name__df}" )
#
#        # If such function has already been declared, print a warning.
#        if (( ${+ZESHY_FUNCTION_NAME_TO_HELP[${function_name__df}]} )) {
#            print "zeshy: function ${function_name__df}() in parcel @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
#        }
#    # Else, such function has multiple names. Since single- and double-quoted
#    # function names may contain commas, such names cannot be split on commas as
#    # with function attributes above. Rather, match such names with iteration.
#    } else {
#        # Prepare to match such names.
#        pcre_compile -- "${ZESHY_CALLABLE_PROTOTYPE_NAME_NEXT_PCRE}"
#        pcre_study
#
#        # Match such names, recording each to be a synonym of the first such
#        # name matched above. See for_string_text_matching_pcre:() for further details.
#        local ZPCRE_OP='0 0'
#        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match__df[3]}" } {
#            function_name__df="${match[1]}"
#            function_names__df+="${function_name__df}"
#            ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST[${function_name__df}]="${function_names__df[1]}"
#
#            # If such function has already been declared, print a warning.
#            if (( ${+ZESHY_FUNCTION_NAME_TO_HELP[${function_name__df}]} )) {
#                print "zeshy: function ${function_name__df}() in parcel @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
#            }
#        }
#    }

#   for ((match_index=1; match_index <= ${#names}; ++match_index)) {
#       print "name ${match_index}: ${names[${match_index}]}"
#   }

#`zsh` already provides intuitive syntax for defining functions (even those
#with names containing shell-reserved characters), this function is largely
#useful only for defining functions dynamically: e.g.,

        # * "read -t 0", reading standard input only if such input is nonempty.
        #   See :stdin.is_nonempty() for further details.
#   }" |& { read -t 0 && IFS='' read -r -d '' function_error__rf }
#    eval "function \"\${function_name__rf}\" () {
#    ${function_body__rf}
#}" || {
    # Technically, shifting this conditional into the prior block would slightly
    # improve efficiency -- while also r
#requires 
#The syntax for cross-referencing another `zeshy` entity depends on the type of
#such entity, typically in a human-readable manner corresponding to underlying
#`zsh` syntax.
#; such parcel names are the absolute path of the existing `zeshy` script
#declaring such parcel.
#
#paths (i.e., prefixed and internally delimited by
#the directory separator '/' and ). Since parcels
#are only abstractions, such paths need _not_ exist. Assuming the customary
#<<parcel.relations.1to1,one-to-one relationship>> between parcels and scripts,
#however, each parcel name is customarily the absolute path of the existing shell
#script declaring such parcel.

# See :func.document() for further details.
# instead rather than single- or double-
#quoted string function arguments 

#Parcel help strings are *pure-AsciiDoc*. Unlike alias, global, and function help
#strings, parcel help strings support no `zeshy`-specific prefixing declarations
#or prototypes. After all, given the abstract nature of parcels, what _exactly_
#would be declared or prototyped?
#FUXME: Add declare_component() and declare_component_with_stdin() functions.
#It bears considering how we'll actually associate components with aliases,
#functions, and globals, considering that zsh does not support nested data
#structures. I suppose we'll need to pack everything into a map. How about
#${ZESHY_COMPONENT_NAME_TO_ALIAS_NAME} (and so forth for globals and functions),
#with structure resembling:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'declare' 'declare_alias:declare_function:global'
#  )
#
#Hence, values are ":"-delimited function names. For globals, this clearly
#suffices, as global names are sufficiently constrained. For aliases and
#functions, however, we'll need to support double-quoted strings. Just double-
#quoted, to make things *MOSTLY* simple. The only complexity there is
#remembering to quote-protect embedded '"' characters in alias and function
#names.
#FUXME: Wait. Component names *MUST* also include internal structure --
#subdirectories (i.e., parent components), in this case. The above should be:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'always/00-startup/00-declare/declare'
#          'declare_alias:declare_function:global'
#  )
#
#The reason why, of course, is that component names are only unique within such
#subdirectories.
#FUXME: Actually, avoid double-quoting strings containing colons. The far
#simpler solution is to prefix colons in alias and function names with "\". Such
#list is then splittable with a slightly more efficient PCRE matching colon
#separators with negative lookahead: e.g., "(?!\\):". Since there's no character
#alias and function names *CANNOT* contain, it's doubtful there's a more
#efficient approach. (Actually, I suppose we could try to find a UTF-8 character
#in the range 127 to 255 guaranteed... ah; forget it. Way too much bit hackery.)
#In any case, "(?!\\):" should certainly be efficient enough for *MOST* cases.
#FUXME: To minimize the number of characters that need to be escaped, why don't
#we just use null instead of colon? That then raises the obvious question: why
#don't we just stipulate that zeshy-specific alias and function names *CANNOT*
#contain nulls? To be fair, though, this single use probably doesn't warrant
#prohibiting nulls entirely. Just use a PCRE resembling "(?!\\)\0". (Yes, I've
#checked the PCRE documentation: a lone "\0" does indeed refer to binary zero.)
#Bam!

#FUXME: On calling declare_component(), we'll need to set a global caching the
#current component name (complete with subdirectories) -- say,
#${ZESHY_COMPONENT_NAME_CURRENT}. There's no need to persist such global after
#sourcing all zeshy components, so we should probably undefine it after that.

#FUXME: The above globals raise the obvious question: should we keep them in
#memory or serialize them to disk? For the most, I strongly suspect they're
#sufficiently small to impose no burden in memory. If this ever changes, we
#simply offload them to disk with a KVS-based implementation. Simple, no?

#* `zsh` global, prefix such name with `${` and suffix such name with `}` (e.g.,
#  `${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}`).
#* `zsh` alias or function, suffix such alias or function name with `()` (e.g.,
#  `declare_function()`). If both an alias _and_ function share such name, the
#  cross-reference refers only to the alias (in keeping with zsh behavior). For
#  genericity, this is generally preferable to the next two disambiguations.
#* `zsh` alias unambiguously (if a function of the same name also exists), prefix
#  such name with `alias:` and suffix such name with `()` (e.g., `alias:die()`).
#* `zsh` function unambiguously (if an alias of the same name also exists),
#  prefix such name with `function:` and suffix such name with `()` (e.g.,
#  `function:die()`).

#Cross-referencing by ambiguous suffix rather than unambiguous name induces a
#depth-first search for the first parcel name with such suffix of:
#
#. All `zeshy` overlays in the following order (thus giving official parcels
#  precedent over third-party parcels):
#.. `zeshy://`, the system-wide overlay of official parcels.
#.. `zeshy.user://`, the user-specific overlay of third-party parcels.
#. All overlay subdirectories in lexicographic order.
#
#of all overlays and subdirectories thereof for
#  the first parcel suffixed by a directory separator `/` followed by such
#  suffix, as discussed below. 
#
#starting with the system-wide `zeshy`
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#For convenience, parcels may also be cross-referenced by implicitly performing a
#depth-first search of all `zeshy` overlays starting with the system-wide `zeshy`
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#To cross-reference a parcel by implicitly searching all overlays for the
#first matching parcel, delimit such parcel's name (truncated as above) by `@{`
#and `}` (e.g., `@{/if_pathable/cataclysm}`). Omitting an explicit overlay label
#thus prompts `zeshy` to iteratively search every overlay for such parcel in the
#following order:
#
#. `zeshy`, thus giving highest precedent to core parcels bundled by default with
#  `zeshy`.
#. `party`.
#
#  of all `zeshy` overlays beginning at the system-
#  wide overlay `zeshy://` and proceeding to the user-specific overlay `zeshy.user://`)
#  then the system-wide `zeshy`
#
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#See convert_path_to_parcel() for further details on parcel names.
#
#For convenience, parcels may be cross-referenced either by explicitly declaring
#such parcel's name or implicitly searching all overlays for the
#first matching parcel. In either case, parcel names should omit the absolute
#path of the overlay containing such parcel (e.g., for the parcel declared by the
#script with absolute path `/usr/share/zeshy/always/variable/type`, reference
#such parcel as `/always/variable/type` rather than the full absolute path).
#
#===== By Explicit Declaration =====
#
#To cross-reference a parcel by explicitly declaring the overlay containing such
#parcel, delimit such parcel's name (truncated as above) by either:
#
#To cross-reference a documented parcel, delimit such parcel's name by `@{` and
#`}`. Assuming such parcel to have been declared by :parcel.declare_to_path()
#(as is always the case for all official `zeshy` parcels), the name of such
#parcel is the absolute path of the corresponding `zeshy` script with the overlay
#directory name prefixing such path replaced with `zeshy://` for official scripts
#and `zeshy.user://` for third-party scripts (e.g.,
#`@{zeshy://always/zeshy/zeshy}` cross-refences the parcel declared by script
#`/usr/share/zeshy/always/zeshy/zeshy`).
#
#To obtain the parcel name for any script, simply pass the path of such script to
#convert_path_to_parcel(); the output is the corresponding parcel name.
#
#===== By Implicit Searching =====
#
#For convenience, parcels may also be cross-referenced by implicitly performing a
#depth-first search of all `zeshy` overlays starting with the system-wide `zeshy`
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#To cross-reference a parcel by implicitly searching all overlays for the
#first matching parcel, delimit such parcel's name (truncated as above) by `@{`
#and `}` (e.g., `@{/if_pathable/cataclysm}`). Omitting an explicit overlay label
#thus prompts `zeshy` to iteratively search every overlay for such parcel in the
#following order:
#
#. `zeshy`, thus giving highest precedent to core parcels bundled by default with
#  `zeshy`.
#. `party`.
#
#
##=== Cross-referencing Parcels ===
##
##Due to the context-dependent nature of parcel names, cross-referencing parcels
#entails somewhat more effort than cross-referencing aliases, functions, and
#globals. While alias, function, and global names are necessarily unique in their
#respective namespaces and hence unambiguously cross-referenceable, parcel names
#are unique only in their ``full'' form as system- and user-specific absolute
#paths -- and hence _not_ unambiguously cross-referenceable cross-system or
#-user. Which is slightly bad.
#
#To rectify this, note that all `zeshy` scripts and hence parcels reside under
#one of two root *overlays* (i.e., top-level directories
#
#* The system-wide overlay (e.g., `/usr/share/zeshy`). Such scripts are bundled
#  by default with all `zeshy` installations and hence form the portable core of
#  `zeshy` guaranteed to exist wherever `zeshy` exists.
#* The user-specific overlay (e.g., `/home/leycec/.zeshy/overlay`). Such scripts
#  are _not_ bundled by default with `zeshy` and hence constitute non-portable
#  (if exceptionally neato) third-party addons, extensions, plugins, and so on.
#
#Since the absolute paths of such overlays are necessarily system- and user-
#specific, `zeshy` currently recognizes only the following system- and user-
#agnostic labels:
#
#* `zeshy`, for parcels residing in the system-wide overlay.
#* `party`, for parcels residing in the user-specific overlay.
#
#To rectify this, `zeshy` assigns each *overlay* (i.e., top-level directory
#containing `zeshy` scripts to be compiled into `zeshy`\'s user digest file) a
#path-agnostically human-readable label. Since all cross-referencable `zeshy`
#scripts reside in exactly one overlay (ignoring hard and soft link shenanigans),
#the replacement of the absolute path of the overlay containing a parcel in such
#parcel's name with the corresponding label
#the combination of such a label _and_ the fragment of a parcel's name following
#the absolute path of the overlay containing such parcel uniquely identifies such
#parcel cross-system and -user.
#
#==== Overlay Labels ====
#
#All `zeshy` scripts and hence parcels reside in one of two overlays:
#
#* The system-wide overlay (e.g., `/usr/share/zeshy`). Such scripts are bundled
#  by default with all `zeshy` installations and hence form the portable core of
#  `zeshy` guaranteed to exist wherever `zeshy` exists.
#* The user-specific overlay (e.g., `/home/leycec/.zeshy/overlay`). Such scripts
#  are _not_ bundled by default with `zeshy` and hence constitute non-portable
#  (if exceptionally neato) third-party addons, extensions, plugins, and so on.
#
#Since the absolute paths of such overlays are necessarily system- and user-
#specific, `zeshy` currently recognizes only the following system- and user-
#agnostic labels:
#
#* `zeshy`, for parcels residing in the system-wide overlay.
#* `party`, for parcels residing in the user-specific overlay.
#
#==== Parcel Cross-reference Syntax ====
#
#For convenience, parcels may be cross-referenced either by explicitly declaring
#the overlay containing such parcel or implicitly searching all overlays for the
#first matching parcel. In either case, parcel names should omit the absolute
#path of the overlay containing such parcel (e.g., for the parcel declared by the
#script with absolute path `/usr/share/zeshy/always/variable/type`, reference
#such parcel as `/always/variable/type` rather than the full absolute path).
#
#===== By Explicit Declaration =====
#
#To cross-reference a parcel by explicitly declaring the overlay containing such
#parcel, delimit such parcel's name (truncated as above) by either:
#
#* `@zeshy{` and `}`, for parcels residing in the system-wide overlay (e.g.,
#  `@zeshy{/always/variable/type}`).
#* `@party{` and `}`, for parcels residing in the user-specific overlay (e.g.,
#  `@party{/if_pathable/sushi}`).
#
#===== By Implicit Searching =====
#
#To cross-reference a parcel by implicitly searching all overlays for the
#first matching parcel, delimit such parcel's name (truncated as above) by `@{`
#and `}` (e.g., `@{/if_pathable/cataclysm}`). Omitting an explicit overlay label
#thus prompts `zeshy` to iteratively search every overlay for such parcel in the
#following order:
#
#. `zeshy`, thus giving highest precedent to core parcels bundled by default with
#  `zeshy`.
#. `party`.
#
#
##Set the documentation for the function named by the function prototype prefixing
#the passed string to such string. 
#FUXME: As expected, '/---' is a fairly
#ridiculous heredoc delimiter. I'd like to transition to something either
#Pythonic or zshish: namely, either: "'''" (i.e., three single quotes) or
#"```". O.K.; so, "'''" and variants thereof (e.g., "''''") doesn't work, as
#AsciiDoc already arrogates such string to itself. "```", however, is
#particularly zshish and *NOT* already arrogated by AsciiDoc. Sadly, however,
#vim refuses to syntax highlight it. O.K.; bloody hell. It's astonishingly
#difficult to invent a delimiter satisfying readability, vim parsability, and
#non-AsciiDoc parsability. How about either '-"-' or '_"_'? Actually, those
#still require a bit too much typing (and are awkward to type on most
#keyboards). How about simply "-=-"? Ah, hell. I really like '-"-'! So, there it
#is. Globally replace heredoc delimiters with '-"-', as above. Hmm; O.K., the
#typability constraint is rather important. I'd rather not have to rely on vim
#registers, again. So, perhaps '-=-', yes? It's hardly inspiring, but suffices.
#Nice, I actually like having "/" in there for vertical emphasis. That leaves us
#with "/---", which is also free in AsciiDoc. What say you? I like it. It hits all
#the right boxes: readily typeable (at least on Dvorak and Kinesis), non-
#conflicting with AsciiDoc, parsed by vim, and moderately zsh-ish. (Moderately.)
#It even moderately resembles the upper half of a face: e.g.,
#   /---  /---
#    o    -
#...which could have iconography implications later. Say:
#
#      /--- /---
#      z=esh=y
#
#      /---
# zeshy = zsh
#
#O.K., they're hardly impressive. Well, to be pondered in any case! Right. Don't
#bother trying to connect "/---" into an icon. This, however, could prove useful:
#
#   z sh
#   | ||
#   zeshy

#FUXME: Not terribly fond of the noun "component", to be honest. It's rather
#lengthy. Conceivable alternatives:
#
#* "bundle". Decent, but I rather prefer "parcel".
#* "container". Non-ideal. Containers are lists and maps.
#* "capsule". Nice!
#* "parcel". Nice!
#* "package". Non-ideal. Packages are a larger-scale abstraction.
#* "unit". Possibly nice? A bit too terse and ambiguous, perhaps.
#
#Right. "parcel" really strikes me as the ideal candidate, at the moment. Shall
#we run with it?
#'@' followed by the label of such
#
#either:
#
##FUXME: Not quite right. Let's use such syntax to incrementally search in the
##following overlays (in order) for such parcel: `zeshy`, `user`.
#* `@{` and `}`, for parcels residing in the system-wide `zeshy` overlay and
#  hence bundled by default with all `zeshy` installations (e.g.,
#  `/usr/share/zeshy`).
#
#* `@${overlay_name}{` and `}`, for parcels residing in the named overlay. For
#  portability, only the following overlay names are currently recognized:
#** `zeshy`, if such parcel resides in the system-wide `zeshy` overlay (e.g.,
#   `/usr/share/zeshy`).
#** `home`, if such parcel resides in the user-specific `zeshy` overlay (e.g.,
#   `/home/leycec/.zeshy/overlay`).
#
#For example:
#
#, a human-readable 
#different overlay from
#  the current parcel, where `${overlay_name}` is either:
#
#same overlay as the current parcel.
#
#While alias, function, and global names are necessarily unique in their
#respective namespaces and hence unambiguously cross-referenceable, parcel names
#are unique only in their "full" form as system- and user-specific absolute
#paths -- and hence _not_ unambiguously cross-referenceable cross-system.
#Fortunately, rectifying this is simple: 
#
#To cross-reference a documented parcel, delimit such parcel's name -- omitting
#the absolute path of the overlay root containing the parcel -- by `@{` and `}`.
#
#Hence,
#parcel names should 
#
#`zeshy` rectifies this by .
#Consequently, 
#
#either:
#
#* As an absolute path relative to and hence omitting the system-specific
#  directory of the overlay root (e.g., `@{/always/variable/type}`, rather than
#  `@{/usr/share/zeshy/always/variable/type}`). Since 
##** `path`, to reference such parcel with a system- and user-specific path
##   despite  (e.g.,
#   `/home/leycec/.zeshy/overlay`).
#Declare the passed `zeshy` script (defaulting to the currently sourced script)
#to be a new parcel, documented with standard input. Consider calling this rather
#than :parcel.declare_to_path(), which requires passing an AsciiDoc-incompatible
#string argument rather than AsciiDoc-compatible standard input. See
#:func.document() for further details.

#Since 
#Calling this function is generally preferable to
#calling :parcel.declare_to_path(), which requires passing an AsciiDoc-incompatible
#string argument rather than AsciiDoc-compatible standard input. 
#At the moment, this means: *``parcels structure `zeshy` documentation.''* And
#that's it. At such time as `zsh` adds native support for declaring package-
#like abstractions, however, this could conceivably change.

#parcels will (of course) cleanly extended with such support.
# Thus, the necessity of a
#`zeshy`-specific abstraction allowing for such compilation.
#Record the passed parcel (defaulting to the current parcel) as containing the
#passed function.
#Add the passed alias to the passed parcel. Since parcels are only abstractions,
#``add'' in this case only means recording such parcel as containing such alias.
# share a one-to-one relationship with their owner scripts.
#Hence, a
#single script declares such parcel's
#name is the absolute path of
#such script. All other scripts in such passel refer to such parcel by such path.

#In this case,
#such parcel is declared by a single such script but defined
#one such script declares such parcel and 
#That is, for the single
#, there exists a corresponding parcel whose name is the
#absolute path of such script. 

#In this case, there
#typically exists 

#However, this is hardly the only possible type of relationship between parcels and scripts.
#, though _not_
#necessarily referring to extant files or directories.
    # Add each such function to the current parcel. For efficiency, inline such
    # iteration. See :parcel.add_alias_command() for further details.
#   for function_name__df ("${function_names__df[@]}") {
#       ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${ZESHY_PARCEL_NAME}]+=$'\0'"${2//$'\0'/\\$'\0'}"
#   }

#Handle *parcel* (i.e., `zeshy`-specific abstractions containing aliases,
#parcels, and functions) declarers.
#FUXME: Actually call this in such functions.
#FUXME: So what should component documentation contain? It's fairly simple, I
#think: *ALL* component documentation should be AsciiDoc. We could support a
#prefixing prototype, but I fail to see how that's helpful. The current
#component name is perfectly inferrable from the current path -- no need to
#duplicate it unnecessarily. Great!
#FUXME: Rename to run_function_passed_stdin() or run_runnable_with_stdin().
#FUXME: A bit discontent with the current structure. Shift this and
#:func.document() to a new component "00-function". Rename this
#component to "declare", retaining all existing functions. Shift "define" and
#"document" here. Last, shift declare_function*() documentation to
#"00-function". I know, I know. But it's worth it.
#FUXME: O.K.; the above is essentially correct. What we specifically want,
#however, are the following three subcomponents with the expected content:
#"00-function", "alias", and "global". Simple. Elegant. Go-go!

# Component "document" declares and documents all other pertinent globals (e.g.,
# ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}).
#FUXME: I submit we should define a syntax for embedding function attributes in
#function documentation and having declare_function() itself parse and handle
#such attributes. For the moment, I can only think of one such attribute:
#"globbable". Define such attribute like so:
#
#   <globbable> void happy_go_lucky()
#
#Dead simple, yes? What's great about this is that it formally associates the
#attribute with the function's documentation, which we can later highlight
#accordingly.
#       # Function prototype prefixing such help string.
#       string help_prototype

#       # If such string contains a blank line (i.e., "\n\n"), crudely match the
#       # substring preceding such line as the function prototype.
#       if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
#           help_prototype="${match[1]}"
#       # Else if such string contains a newline (i.e., "\n"), crudely match the
#       # substring preceding such newline as the function prototype.
#       } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
#       # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       :die 'function help string invalid (see "print_help declare_function" for details):
#'"${help_prototype}"

                #FUXME: If such function name contains spaces or other awkward
                #characters, this is likely to fail -- probably silently!
                #Command-line experimentation suggests that creating such an
                #alias requires *EXTREME* quoting and quote-protection of such
                #quotes. Since this is fairly odd, it's conceivable it's a bug.
                #Here's what the horrid syntax looks like:
                #
                #  >>> alias \"hm\ mm\"="print ik"
                #  >>> "hm mm"
                #  ik
                #
                #So, both the prefixing and suffixing '"' as well as internal
                #whitespace have to be explicitly escaped. Certainly doable;
                #it's just... annoying! I suspect the "=" character also needs
                #be escaped. Anything else? *sigh*
                #FUXME: Given the complexity, we might want to define a function
                #accepting a desired alias name and expansion as two separate
                #parameters and defining such alias -- say, :alias_command.define()?

    #FUXME: Leveraging the above regular expressions, parse function name
    #synonyms and attributes. See above for the algorithm.

    # Store such documentation for subsequent parsing.
#   ZESHY_HELP_GLOBAL+="${1}"

    #FUXME: This is incorrect, as it fails to declare globals if a local of the
    #same name exists. See :is_var_global() for a solution.
    #FUXME: If such global has been declared, we should probably print a
    #warning to standard error if its declared type differs from the
    #documentation-declared type. The implementation is a bit tedious,
    #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
    #dynamically constructed from its converse for performing efficient
    #lookups. Clearly, not a priority for the moment.
    # If such global has not yet been declared, do so. See :Var.is() for
    # further details.
#   [[ -n "${(P)global_name__dg+x}" ]] || {

#FUXME: Restore the ${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals back to this
#component. Use such globals rather than ${ZESHY_HELP_GLOBALS}, etc. in
#function implementations below.
#FUXME: Consequently, declare_function() should immediately parse the passed
#help string's function prototype for only the following bits of metadata:
#
#* The list of all function attributes.
#* The list of all function names.
#
#Given the latter, set ${ZESHY_FUNCTION_NAME_TO_HELP} with the *FIRST* such
#function name and set ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST} as
#discussed below from all such function names to the first such function name.
#
#Then, given the former, if such attributes contain "globbable", define one
#"noglob" alias for each function name. Awesomeness!
#FUXME: Honestly, I don't see why we shouldn't support the same syntax for
#aliases. Hence, both functions should call an underlying function passed the
#names of the maps to... Ah, wait. No, no. Aliases don't genuinely support
#synonyms. We could fake it, I suppose. But I'm unsure whether there's any
#value in that. For now, confine such parsing to functions.

#FUXME: How should function synonyms be handled? For proper HTML construction,
#the fact that one function is a synonym of another *REALLY* needs to be
#embedded in either this data structure or another. How about a map
#${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}? Given the following
#function declaration:
#
#  function func1 func2 func3() { ... }
#
#...we would populate such map as follows:
#
#  ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST=(
#      'func1' 'func1'
#      'func2' 'func1'
#      'func3' 'func1'
#  )
#
#Hence, given a function name, it's (largely) trivial and reasonably efficient
#to find all synonyms of such function. We arbitrarily choose the first function
#name to be the "source" to which all synonyms refer, including such function
#name itself. Note that functions with no synonyms should *NOT* be defined by
#such map. We could certainly admit that, but it serves no purpose and
#(potentially) squanders quite a bit of safe.
#   print "attrs: ${attrs[@]}"
#   print "names: ${names[@]}"
    #FUXME: Right. We don't actually need the list of names, due to our helpful
    #choice of global data structure. Instead, we only need to record the
    #*FIRST* function name in a string local.

        # Match the first such name, which by the definition of such PCRE is
        # guaranteed to exist. See for_string_text_matching_pcre:() for further details.
#       pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names_string}"
#       function_names+="${match[1]}"

        #FUXME: Rather than append to such list, do the following:
        #
        #* Set the above string local to the first match.
        #* For all subsequent matches, map from such match to such string local
        #  in global ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}.
        #
        #To do so simply (and efficiently!), do something resembling:
        #
        # This should be guaranteed to match and hence always return success.
#       while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match[3]}" } {
#           names+="${match[1]}"
#       }

        # Such names as a raw string. Since iteration overwrites list global
        # ${match}, copy such string before overwriting it below.
#       local names_string="${help_match[3]}"

    #FUXME: We'll clearly need to convert a few of the locals below into globals
    #above. Let's cross that tepid bridge when we trip into it.

        #FUXME: Actually, only print the first line of such documentation. Also, use
        #a different color for such line; say, regular red or cyan?
        #FUXME: Actually, print as follows:
        #
        #* If such prototype contains a blank line (i.e., "\n\n\n"), print from the
        #  first line of such prototype up to the next line that comes first of
        #  either such blank line or 5. (This avoids inevitable problems with
        #  pathological documentation.)
        #* Else, print only the first line of such documentation. This is only an
        #  unlikely edge case, so it needn't be too fancy; pretty much everyone will
        #  follow zeshy precedent of a blank line, I reckon.

    #string pcre_return_type=${pcre_ident}
        #string pcre_function_name_list='\{\s*+([^}]*?)(?:'${pcre_comma}')?\}'
#FUXME: Actually, defer such definition to the same precompilation function
#iterating and serializing all documentation to disk. The reason? Simplicity,
#centralizing all function prototype parsing into a single function. Such
#parsing is rapidly becoming too complex to duplicate between multiple
#functions.
#FUXME: Function name synonyms should be implemented as symbolic links in the
#documentation directory. Consequently, no parsing of function name synonyms is
#desirable in declare_function() itself. In fact, we can reduce the current
#temporary maps ZESHY_ALIAS_NAME_TO_DOCUMENTATION and so on to corresponding
#lists ZESHY_USER_HELP_ALIASES and so on. Just append each passed
#documentation string as is to the desired list.
#FUXME: Define a new declare_function_glob() or
#declare_function_sans_filename_globbing() or
#declare_function_and_disable_filename_globbing(). Yes, the latter. While
#verbose, that's not necessarily a bad thing in this case, as such function
#dramatically alters function parsing. In any case, such function should
#define a new alias of the same name expanding as follows:
#
#    alias ${function_name}:catch"noglob ${function_name}"
#
#Test if such alias already exists before doing so, in which case throw an
#exception or perhaps merely print a warning. (Nah, exception!)

    #FUXME: Actually define set_string_with_stdin(). Simplicity incarnate.
    # Document such input. See set_string_with_stdin() for further details.
#Prefer globals
    # "${match[1]}" and "${match[2]}" to human-readable local variables to
    # avoid polluting the local shell environment any further. 
#FUXME: I'm unclear why this needs to be an alias. If we were declaring such
#variable locally, I could see it, but... yeah; I think I slightly erred in
#implementing this as an alias. Convert to a function and reap the rewards of
#simplicity.

# ....................{ SETTERS                            }....................
#function set_alias_documentation() {
#    (( # == 1 )) || :die 'expected one documentation string'
#    ZESHY_CORE_HELP_ALIASES+="${1}"
#}

#function set_function_documentation() {
#    (( # == 1 )) || :die 'expected one documentation string'
#    ZESHY_HELP_FUNCTION+="${1}"
#}

#function set_global_documentation() {
#    (( # == 1 )) || :die 'expected one documentation string'
#    ZESHY_HELP_GLOBAL+="${1}"
#}

    # If such documentation is prefixed by an alias prototype, match the
    # relevant alias name from such prototype. While zsh permissively allows
    # alias name declarations to be quoted and hence contain arbitrary
    # characters as with functions, such aliases are not runnable: e.g.,
    #
    #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
    #   >>> o\ w\ s
    #   zsh: command not found: o w s
    #
    # For simplicity, use a similar glob expression as declare_function().
#   if [[ "${documentation}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
#   then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else :die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
#   fi

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
        # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else :die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi
#FUXME: declare_function() is arguably a bit more than mere documentation, now.
#Ditto for declare_global(). Perhaps we should contemplate a nomenclature
#change -- say, to prototype_function() or declare_function(). Yes, "declare"
#strikes me as the proper verb here. It applies to globals as well!
#FUXME: O.K., O.K. Stop the "<>" nonsense with aliases. It's useful for
#referencing aliases to distinguish them from functions but completely unuseful
#for prototyping aliases. Alias prototype syntax should be a proper subset of
#function prototype syntax. (Note this is really the only way to do the PEG, as
#well; can you imagine duplicating the bloody function PEG for aliases with only
#ignorable differences?)

#FUXME: Ensure this is performed in, say, "main":
#
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
# ....................{ DOCUMENTATION                      }....................
# Map from Zeshy-specific alias name to documentation for such alias.
#local -A ZESHY_ALIAS_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific function name to documentation for such function.
#local -A ZESHY_FUNCTION_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific global name to documentation for such global.
#local -A ZESHY_GLOBAL_NAME_TO_DOCUMENTATION

# Avoid documenting the following three functions, subsequently undefined during
# Zeshy startup and hence inaccessible to callers.

# void set_alias_documentation(string alias_name, string documentation)
#
# Document the passed alias with the passed string.
#function set_alias_documentation() {
#    (( # == 2 )) || :die 'expected one alias name and one help string'
#    ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_function_documentation(string function_name, string documentation)
#
# Document the passed function with the passed string.
#function set_function_documentation() {
#    (( # == 2 )) || :die 'expected one function name and one help string'
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_global_documentation(string global_name, string documentation)
#
# Document the passed global with the passed string.
#function set_global_documentation() {
#    (( # == 2 )) || :die 'expected one global name and one help string'
#    ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#       # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else :die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi

#names following the `(`- and `)`-bracketed argument list or `[`- and `]`-
#bracketed argument channel list signifies such function to be annotated by such

#:func.document <<'/---'
#void declare_function_with_stdin_and_disable_filename_globbing[
#    stdin: string documentation]
#
#Set the documentation for the function named by the function prototype prefixing
#standard input to such input and disable filename globbing on all arguments
#callers subsequently pass to such function. While the latter admittedly has
#little to do with function documentation, bundling the two together simplifies
#life. See :func.document() and
#disable_function_filename_globbing() for further details.
#/---

#FUXME: Actually, no one'll ever call this function. Rename to
#declare_function_with_stdin_and_disable_function_filename_globbing() and
#implement accordingly. Yes, this is an obscenely long function name. No, in
#this particular instance, I don't particularly care. There's no reasonable
#abbreviation permitting the function name and heredoc declaration to reside on
#the same line, so such function is called like so:
#
#    declare_function_with_stdin_and_disable_function_filename_globbing\
#        <<'/---'
#    ...
#    /---
#FUXME: Document :func.document() as well. In the documentation,
#note the reason for needing :func.document() to be the fact that
#both single- and double-quoted strings interface poorly with AsciiDoc syntax.
#Specifically, AsciiDoc's frequent use of:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.
#
#Fortunately, zsh supplies a third alternative: here-documents. Since zsh
#writes here-documents to standard input, this function expects non-empty
#standard input. See declare_function() for further details.

#While function documentation can be passed as a
#conventional string argument to declare_function() rather than as standard
#input to this function, such documentation adheres to 
#http://asciidoc.org[AsciiDoc] syntax containing syntactic constructs
#containing characters conflicting with
#conventional single- or double-quoted zsh strings:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.

#Set the documentation for the globally exported variable named by the variable
#declaration prefixing the passed string to such string. Documentation consists
#of a variable declaration in Zeshy-specific C-like syntax and a variable
#description in http://asciidoc.org[AsciiDoc].
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.

#Set the documentation for the function named by the function prototype prefixing
#the passed string to such string. Documentation consists of a function prototype
#in Zeshy-specific C-like syntax and a function description in
#http://asciidoc.org[AsciiDoc].
#Function documentation consists of a function prototype and description
#delimited by mandatory whitespace. A function prototype consists of one or more
#return types, one or more function names, and zero or more function arguments;
#a function description consists of arbitrary http://asciidoc.org[AsciiDoc] with
#additional support for conveniently cross-referencing other Zeshy documentation.

#Alias documentation consists of an alias prototype and description delimited by
#mandatory whitespace. An alias prototype consists of one or more return types,
#one alias name, and zero or more arguments; an alias description consists of
#arbitrary http://asciidoc.org[AsciiDoc] with additional support for conveniently
#cross-referencing other Zeshy documentation.

#== Alias Prototypes ==
#
#Alias prototypes follow a C-like syntax supporting zsh features not commonly
#found in conventional high-level languages: return and argument channels. Since
#zsh does _not_ currently support alias prototypes, we cannot coerce zsh to
#respect or enforce such prototypes at runtime. Zeshy can, however, convert such
#prototypes to syntax-highlighted, contextually-linked specifications in end-
#consumer documentation.

#Since zsh expands aliases inline, aliases cannot accept arbitrary arguments not
#accepted by the command such alias expands to.

#FUXME: Obscenely out-of-date. Significantly expand, noting that the alias
#documentation PEG is effectively the proper subset of the function
#documentation PEG excluding function name synonyms and replacing "(" and ")"
#with "<" and ">".
#While all function implementations remain free to
#dynamically redefine their signatures and hence deviate from such static
#documentation, developers should question the cognitive cost of such functions!

#FUXME: There is one other matter, of course: standard input. And
#come to think, this is also a concern for function documentation as well.
#How do we document whether a function accepts standard input and, when it does
#so, where it places such input in relation to other accepted arguments if any?
#*UGH*. Super annoying that I neglected to account for stdin. *sigh*
#FUXME: O.K.; I think I have a working syntax. The idea is simple: zsh
#extensions to C-like function prototype syntax are "["- and "]"-delimited.
#Since herestring-driven aliases unpack stdin into customary arguments, we have
#an stdin argument syntax resembling:
#
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#
#What's nice is that, as a function, it would simply be written as:
#
#[stdout: float] ukigumo(string dirname, integer mtime)
#
#Simple, concise, and consistent. Excellent. The above syntax naturally extends
#to support standard input being assigned to only one argument, like so:
#
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Ugh. So, that works, but doesn't really coincide with above. How about:
#
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Right. That works. It's obviously tempting to reduce every "[" and "]" to a
#"(" and ")" at this point, but that reduces the resulting prototype to a
#slightly less readable mish-a-mash ala LISP (*shudder*):
#
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#Hmm. Is that *REALLY* less readable? Frankly, it seems *MORE* readable. Right.
#O.K.; so, in this instance only, contemplate LISP-ish syntax. I can't believe
#I'm muttering that, but... well, it is much easier to remember and hence to
#write, and reads quite well as well. So, there you are!
#
#Right. There's just one final thing: input pipes. Quite a few functions only
#expect piped standard input, not just any ol' standard input. So, we'll need to
#also support something resembling:
#
#(stdout: float) ukigumo(piped stdin: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin-pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(piped: string dirname, integer mtime)
#
#The latter, I should think. "piped" implies "stdin" and more, so prefixing with
#or otherwise explicitly stating "stdin" is unnecessary. Well! That should do it,
#no? We'll need to slightly revise both the PEG and examples below, but better
#now that after we've begun using this syntax everywhere, eh? :}
#
#Ah, right: one final thing. The ":" implies mandatory and, in most cases, piped
#standard input is optional. How about a new "?" suffix for optional input, ala:
#
#(stdout: float) ukigumo(piped? string dirname, integer mtime)
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#BRILLIANT. Bravo, senior Cecil. Bravo.
#
#Note, however, that optional piped input is probably unhelpful and should
#arguably be eliminated from the Zeshy codebase. Hence, for now, just document
#the "stdin:"-style syntax.
#FUXME: O.K.; so, the above syntax isn't *QUITE* right. Since we're *NEVER*
#passing in standard input as an optional argument, any standard input passed is
#always as a second "channel" completely outside the scope of sanity.
#Also note that *_from()-style aliases *APPEAR* to the caller to accept a single
#string rather than standard input, suggesting an additional "string:" channel.
#Revert to "["-style syntax, for clarity. This suggests the following syntax:
#
#    # A function accepting a string *AND* standard input.
#    [stdout: void] set_string_to_stdin_pipe[
#       args: string string_name, stdin: string input]
#
#    # A function accepting one or more integers on standard input.
#    [stdout: string] get_stdin_integers[
#       args: void, stdin: (integer int1, ...)]
#
#    # Equivalent to the prior prototype.
#    [stdout: string] get_stdin_integers[stdin: (integer int1, ...)]
#
#    # A herestring-style alias.
#    [stdout: float] ukigumo[string: (string dirname, integer mtime)]
#
#So, the fundamental idea is that "args:" and "stdin:" both default to "void",
#as for return types. Either or neither may be specified, with predictable
#consequences in any case. Beautiful, no? (Well, certainly *LOGICAL*!)

#Tester functions returning only boolean exit status and no standard output or
#error may thus map return types `[status: boolean]` (e.g.,
#`[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).

#Being unprototyped, zsh function argument order and type is not
#statically predefined at function declaration time but may conditionally
#dynamically depend on local, global, and/or external state. For example,
#While perfectly documenting all possible function argument dynamics is both unfeasible and undesirable,
#conditionally depend and hence arguably more involved
#(though not necessarily beneficially) than those of conventional high-level languages.

#Documenting all possible function prototype dynamics is both unfeasible and
#undesirable. For sanity, function documentation assumes function signatures to
#be statically predefined at function declaration time as in normal high-level languages. Function implementations remain
#free to dynamically redefine and hence stray from such documentation as
#necessary, although this is generally discouraged.

#For brevity, functions may specify a single return type as in conventional
#high-level languages (e.g., `integer`).
# Zeshy documents such values in one of two ways:
#With a single type as in conventional high-level languages (e.g., `integer`),
#signifying such function to return a string of standard output convertible
#without error to such type, an empty string of standard error, and zero exit
#status (i.e., success). Since most functions only write to standard output and
#throw exceptions rather than return non-zero exit status on error, this
#shorthand notation simplifies most functions'' documentation.

#| Digit                 | <- | ``0'' | DigitNonZero
#| DigitNonZero          | <- | ``1'' | ``2'' | ``3'' | ``4'' | ``5'' | ``6'' |
#                               ``7'' | ``8'' | ``9''
#| Integer               | <- | ``-''? (``0'' | DigitNonZero Digit*)

#FUXME: I've performed an obscene amount of research on lightweight
#documentation formats and the winner *HANDS DOWN* is AsciiDoc. The syntax
#absolutely rocks, is near infinitely extendable with "pluginname:string"-style
#syntax and third-party plugins, exports beautiful HTML, LaTeX, PDF, man pages,
#DocBook, and so on. All Git documentation is written in AsciiDoc (which should
#absolutely tell you something: this is Linus' Git, after all). Markdown and
#Textile are rather outdated at this point. The only genuine competitor is the
#official Python documentation language, RestructuredText (reST). I'll admit:
#reST is powerful. Probably nearly as or even slightly more powerful than
#AsciiDoc. But in the end, that doesn't really matter... because the syntax is
#absolute shite. I mean, *LOOK AT THAT SYNTAX*. What the bloody hell were they
#thinking? They could have simply adopted the de facto e-mail-style markup
#syntax from which AsciiDoc (and Markdown and Textile and pretty much every
#other lightweight documentation language) is descended. But *NO*, they had to
#reinvent the friggin' wheel. And they failed. They thoroughly failed. Thank the
#Nordic Gods, then, for AsciiDoc.

#[stdout: float] ukigumo(stdin -> [string dirname, integer mtime])
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(string dirname, integer mtime) <- stdin
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#[stdout: float] ukigumo(stdin -> string dirname, integer mtime)

#FUXME: set_function_documentation() will need to detect whether passed standard
#input and, if so, ... Hmm. Actually, we should probably just do so in the high-
#level functions themselves (e.g., declare_function()). That necessitates
#pushing such documentation to the end of this file, but... *shrug*. That's
#fine, and arguably even preferred here (since it centralizes all documentation
#in one place). Arguably, we should then provide distinct high-level functions
#entitled declare_function_from_stdin() and so forth. The issue with
#trying to make a single "smart" declare_function() implicitly detecting open
#standard input is that such functions will be called from the top-level during
#Zeshy startup and hence cannot distinguish external from internal standard
#input. Subvert such confusion with distinct functions only accepting standard
#input.

#set_alias_documentation declare_global '
#void declare_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
#alias declare_global='
#{
#    # Localize the passed herestring.
#    local documentation__dg="$(< /dev/stdin)"
#...
#} <<<'

#Document the function named in the function prototype prefixing the passed
#documentation, which consists of a function prototype in C-like syntax
#followed by function description in AsciiDoc.
#
#whose syntax supports zsh features not commonly found in
#conventional high-level languages (e.g., function name synonyms, tristate return
#values). For completeness, we specify such syntax with a Parser Expression
#Grammar (PEG):
#
#Such types should correspond to the actual variable type (if
#any) the function implementation copies such argument into.
#
#values are *NEVER* evaluated by Zeshy and hence may contain executable code that
#could, whenever evaluated, have dangerous side-effects. 
#
#assigning each argument a
#mandatory name and type and optional default value.
#
#While argument names need
#not correspond to the variable name (if any) the function implementation copies
#such argument into, argument types and optional default value should, of course.
#
#(e.g., "function name synonym pseudonym nom_de_guerre nom_de_plume() { true }",
#a function callable as either name(), synonym(), pseudonym(), nom_de_guerre(),
#or nom_de_plume()).
#
#by listing all such names in whitespace-
#delimited fashion (e.g., .
#at least one name  also arbi:
#a
#Most function names as in conventional high-level languages (e.g., "integer"),
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#
#For functions with only one name, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#For functions with multiple names, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME_1 [or] FUNCTION_NAME_2 [or] ... FUNCTION_NAME_N(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME_1 FUNCTION_NAME_2 ... FUNCTION_NAME_N() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#Capitalized strings above denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  FUXME: Rewrite this section after implementing the above additions. It gets a
#  bit complicated, but... heck, it''ll definitely be worth it.
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.
#* "FUNCTION_NAME_2", the second name for such function. While most functions have
#
#  As in C-like languages, type "void" signifies such function to return no
#  standard output and/or error.
#
#Function prototypes follow the familiar "RETURN_TYPE FUNCTION_NAME 
#
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#While zsh does not support function prototypes, this function
#adopts conventional high-level language function prototype syntax for documentation-specific purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#named by the C-style function prototype of the passed
#documentation string. Since zsh permits no function prototyping, this function
#adopts conventional high-level language function prototype syntax for documentation purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#syntax does *NOT* constitute 
#While such syntax does *NOT* constitute an enforcable
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#, which must thus be prefixed  with such documentation. 
#
#This function is deleted by Zeshy immediately before compiling its user digest
#file and hence only callable from the global context of Zeshy components.

#FUXME: It'd be great to support a distinction between standard output and
#error return values in function prototypes. How about something resembling:
#
#    # Function returning a string of standard output and no standard error.
#    [string, void] do_something()
#
#    # Or perhaps the more verbose:
#    [stdout: string, stderr: void] do_something()
#
#    # Actually, we could support both (obviously), which we should do. Ah;
#    # actually, we should probably just add such "stdout:" and "stderr:"
#    # labels on printing human-readable documentation to users, yes? Ah;
#    # perhaps not. It'd certainly be more intelligible to developers browsing
#    # the code to see "[stdout: string, stderr: void]" versus the former.
#    # The more verbose version also lends itself well to specifying exit
#    # status, as below.
#
#Since most functions return no standard error, retain support for shorthand:
#
#    # Same as above, shorthand.
#    string do_something()
#
#While most functions return 0 exit status, some do not. How about this:
#
#    # Function returning a string of standard output and no standard error
#    # and non-zero exit status on failure.
#    [string, void, boolean] do_something()
#
#    # Or, again:
#    [stdout: string, stderr: void, status: boolean] do_something()
#
#Status may either be "void" (i.e., always returns 0), "boolean" (i.e.,
#either returns 0 or 1), or "integer" (i.e., returns a variety of statuses.
#
#Ah! Another way in which the labels are demonstrably superior: in may cases,
#we'll want to specify "stdout" and "status" but not "stderr". So, that's just:
#
#    [stdout: string, status: boolean] do_something()
#
#Naturally, order no longer matters. Sweet! I'm thinking we *ABSOLUTELY*
#shouldn't support the abbreviated "[stdout, void, boolean]" style, yes? Far too
#much ambiguity and head-scratching.
#FUXME: The specification below has become sufficiently complex to warrant a BNF.
#I know, I know. But we'll make it simple and concise, with adequate commenting.
#There's really no better way.

# ....................{ GLOBALS                            }....................
#FUXME: This is terrible. Eliminate such global entirely; instead, simply
#attempt to run a dynamically constructed command
#${variable_type}_global_export().

#set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#map ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#
#Map variable type to the declarator (i.e., command prefix) declaring and
#exporting globals of such type.
#'
#typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#    # String types.
#    string    'export'
#    boolean   'export'
#    character 'export'

    # Integer types.
#    integer         'export -i'
#    file_descriptor 'export -i'
#
    # Float types.
#    float 'export -F'
#
#    # List types.
#    list     'export -a'
#    listset 'export -Ua'
#
#    # While "export -a" succeeds (as above), "export -A" fails with error.
#    # Hence, revert to builtin typeset().
#    map 'typeset -Agx'
#)

        # If such global''s type is not a Zeshy-specific type, throw an
        # exception. See :map.is_key() for implementation details.
#       (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#           :die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
#       ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

# ....................{ MAIN                               }....................
#FUXME: Not quite right. We also want to undefine all of the above aliases and
#functions before Zeshy digest compilation, suggesting we create a new
#precompilation hook performing all such undefinitions. I can't imagine that
#order matters, there; so, just add a customary precompilation hook here.

#:run_hook_on_zeshy_precompile precompile_zeshy_documentation_undefine

#declare_function '
#void precompile_zeshy_documentation_undefine()
#
#Undefine all documentation-defining runnables (e.g., set_alias_documentation(),
#declare_global()) *AFTER* sourcing all Zeshy components calling such runnables
#and hence having defined all available documentation. To  Zeshy caches 
#The documentation such runnables
#'
#function precompile_zeshy_documentation_undefine() {
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
#}

#FUXME: Rename "[or]" to "[or]" everywhere. Avoid simply "or", as that isn't
#subject to global replacement.
# For simplicity, this function ignores 
# such low-level distinctions, accepts
# (e.g., "boolean", "list", "string"). If 
#
#While most functions have only one name, zsh does permit additional names to be
#declared in function declarations with the above whitespace-delimited syntax.
#
#Capitalized strings denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific type of variable returned by such function
#  (e.g., "boolean", "list", "string").
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.

# *BEFORE* compiling Zeshy''s user digest file
# (i.e., at the top level of Zeshy components and in precompilation hooks).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Define declare_function() before declare_alias(), which documents itself
# with the former function.
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias declare_alias=':' declare_function=':' declare_global=':'

# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)
