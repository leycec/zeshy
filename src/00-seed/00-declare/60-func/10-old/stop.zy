#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *function prototype parsers* (i.e., functions parsing function
prototypes, typically as a prerequisite to processing function declarations).
/---

#FIXME: The code below generates quite a bit of duplication in function
#preambles. Why? Because we relocalize and revalidate all mandatory arguments
#for all possible argument counts for each function. There probably exist
#specific cases in which it would be safe to condense such duplication.

#FIXME: If compiling an optimized zeshy build, disable argument count and
#argument validation below. Do *NOT* disable argument defaulting or
#localization, for obvious reasons.

#FIXME: Support both localization and validation of standard input-driven
#arguments. This is more than feasible, and we regrettably neglected it in our
#first-draft implementation. Contemplate:
#
#    :void :localize_and_validate_stdin[
#       stdin=(:str+nonempty alias_asciidoc)]
#
#Given such example, one might example a function preamble resembling:
#
#    :stdin.die_unless_nonempty
#    :str alias_asciidoc
#    alias_asciidoc=$(< /dev/stdin)
#
#Naturally, this will require some measure of additional work. Contemplate
#getting localization to work right, as that will doubtless require the most
#effort *AND* yield the most tangible benefit.

# ....................{ GLOBALS                            }....................
# For maintainability, see zy:?/global.zy for all globals specific to this
# parcel -- including exhaustive documentation for each.

# ....................{ PARSERS                            }....................
#FIXME: Complete such documentation. Oh, cripes -- does this function need it.

:func.doc <<'/---'
:void ::func_.stop[stdin=(:str func_asciidoc)]

Terminate the current function declaration, documenting such function with the
passed AsciiDoc-formatted help string. Specifically:

* Prefix such function's body by autogenerated code defaulting, localizing,
  and/or validating such function's arguments. This function generates such
  code by iteratively parsing every argument in the argument list specified by
  such function's prototype, previously declared by :func_().
/---
function ::func_.stop() {
    (( ! # )) || :die 'Expected no arguments.'
    [[ -n ${ZY__FUNC_PROTOTYPE-} ]] || :die\
        '"}:func" not preceded by ":func_" or ":func{" (i.e., ${ZY__FUNC_PROTOTYPE} undefined or empty).'

    # ..................{ PARSE                              }..................
    # Zsh code defaulting, localizing, and/or validating function arguments.
    ZY__FUNC_PREAMBLE=

    # Parse all arguments declared by this function's prototype into zsh code
    # defaulting, localizing, and/or validating those arguments.
    ::func_prototype.parse_args

    # ..................{ DEFINE                             }..................
    #FIXME: Awesome commentary. So awesome, in fact, that it absolutely belongs
    #in the formal documentation for this function. Please shift us there.

    # Declare and redefine each such function to begin with this preamble.
    # Alias :func{() previously defined such function, internally stored by zsh
    # in pre-parsed form (i.e., *NOT* stripped of all ignorable lexical
    # constructs including comments and negligible whitespace). Hence, such
    # definitions preserve comments and negligible whitespace. As we shall see,
    # this is *NOT* a good thing.
    #
    # Redefining such function here reduces such function to its post-parsed
    # form (i.e., stripped of all ignorable lexical constructs).
    #
    # Hence, functions defined by :func_() fundamentally differ to
    # those defined by builtin function(). The former omits all ignorable
    # lexical constructs internally preserved by the latter, a seemingly
    # trivial fact that nonetheless provokes non-trivial side effects: e.g.,
    #
    # * While the pre- and post-parsed definitions for functions defined by
    #   builtin function() almost always differ, the pre- and post-parsed
    #   definitions for functions defined by this function are guaranteed to
    #   *NEVER* differ.
    # * Canonical integer global ${LINENO} corresponds to the current line
    #   number of the current function or script's pre-parsed definition.
    # * Similarly, line numbers suffixing canonical list global ${functrace}
    #   correspond to the line number of the listed function or script's
    #   pre-parsed definition on which the "next" function or script in the
    #   call stack was called.
    # * There currently exists no generally reliably means of accessing the
    #   pre-parsed definition of *ANY* function or script -- particularly if
    #   such function derives from a digest file, as all zeshy functions do.
    # * The prior observations directly imply that the definitions of functions
    #   defined by this function (but *NOT* by builtin function()) may be
    #   correlated with line numbers: both the current line number and the line
    #   numbers recorded on the call stack (e.g., due to thrown exceptions).
    # * The prior implication itself implies that functions defined by this
    #   function (but *NOT* by builtin function()) may support otherwise
    #   unsupportable functionality, including:
    #   * On detecting an uncaught exception, printing the lines of the
    #     function responsible for initially throwing such exception.
    for ZY__FUNC_NAME ("${ZY__FUNC_NAMES[@]}") {
        # Redefine this function in a manner preserving post-parsed form (i.e.,
        # containing no comments or negligible whitespace) *AND* emitting
        # human-readable errors.
        :func.redefine\
            "${ZY__FUNC_NAME}"\
            "${ZY__FUNC_PREAMBLE}${functions[${ZY__FUNC_NAME}]}"

        #FIXME: Document this alias with this function's documentation if any,
        #perhaps suffixed or prefixed by a note indicating this alias to only
        #exist to disable globbing for the corresponding function.

        # If this function accepts at least one string glob argument, prefix
        # all calls to this function by "noglob" to prevent zsh from expanding
        # these arguments as pathname globs. To do so, a command alias of the
        # same name shadowing all calls to this function is defined.
        (( ! ZY__FUNC_ARGS_IS_GLOB )) || :alias_command\
            "${ZY__FUNC_PROTOTYPE}" 'noglob '${(q)ZY__FUNC_NAME}

        #FIXME: Fairly lame. See zy:?/*-alias.zy for commentary.

        # Add this function to the current parcel.
        :parcel.add_function "${ZY_PARCEL_NAME}" "${ZY__FUNC_NAME}"
    }

    # If this function is to be called back (i.e., called on some subsequent
    # event), register this callback with this function's first name.
    if (( ${+ZY__FUNC_ATTRS[callback]} )) {
        ZY__FUNC_CALLABLE_NAME='func.callback_'${ZY__FUNC_ATTRS[callback]}
        :func.die_unless "${ZY__FUNC_CALLABLE_NAME}"
        "${ZY__FUNC_CALLABLE_NAME}" "${ZY__FUNC_NAMES[1]}"
    }

    #FIXME: Can the following function benefit from similar optimization? The
    #answer is almost certainly *YES*.

    # Document such functions with such documentation *AFTER* successfully
    # defining such functions above.
    ::func.doc_prototype_from_stdin_if_nonempty\
        "${ZY__FUNC_NAMES[@]}" "${ZY__FUNC_PROTOTYPE}"

    # Clear globals declared by ={start}. Since clearing *ALL* such globals
    # would be needlessly inefficient, clear only that subset of globals
    # inviting issues elsewhere when left uncleared. This includes:
    #
    # * ${ZY__FUNC_NAMES}, ensuring that exception messages occuring after a
    #   subsequent call to :func_.start() but before such function successfully
    #   parses such function prototype and hence names omit such names.
    # * ${ZY__FUNC_PROTOTYPE}, ensuring that subsequent calls to this
    #   function *NOT* preceded by calls to :func_.start() throw an exception.
    ZY__FUNC_NAMES=()
    ZY__FUNC_PROTOTYPE=
}

# ....................{ PARSERS ~ preamble                 }....................
# ::func_prototype.parse_args()
#
# Parse all arguments declared by this function's prototype into zsh code
# defaulting, localizing, and/or validating those arguments.
function ::func_prototype.parse_args() {
    (( ! # )) || :die 'Expected no arguments.'

    # If this function requests no argument automation, silently noop.
    (( ! ${+ZY__FUNC_ATTRS[is_args_unhandled]} )) || return

    # ..................{ INIT                               }..................
    # Reset all globals specific to argument parsing declared by zy:./global.zy
    # which are independent of subsequent iteration.
    ZY__FUNC_ARGS_IS_GLOB=0
    ZY__FUNC_ARGS_CODE_DEFAULT=
    ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE=

    # Suffix for all local variable names declared by this function's preamble,
    ZY__FUNC_VAR_NAME_SUFFIX=${ZY__FUNC_ATTRS[var_name_suffix]-}

    # ..................{ INIT ~ arg count                   }..................
    # Parse the minimum and maximum number of arguments this function accepts
    # *BEFORE* parsing these arguments. All reasonably sane implementations of
    # argument parsing require these numbers (e.g., to reliably index and
    # expand missable arguments and arguments following such arguments).
    #
    # Superficially, this appears to necessitate two parse passes over the
    # argument list: the first pass obtaining such numbers and the second pass
    # actually parsing such arguments. In practice, however, careful choices in
    # callable prototype syntax reduce the first pass to efficient string
    # munging operations requiring *NO* explicit iteration. Indeed, note that:
    #
    # * Excluding single- and double-quoted strings, each substring of
    #   consecutive whitespace in an argument list implies such function to
    #   accept one additional mandatory argument.
    # * Excluding single- and double-quoted strings, each optional argument
    #   type modifier (e.g., "?", "*") in an argument list implies such
    #   function to accept one additional optional argument.
    # * Each mandatory argument increases the maximum number of arguments such
    #   function accepts by one.
    # * Each optional argument decreases the minimum number of arguments such
    #   function accepts by one.
    #
    # Efficiently calculating these numbers thus reduces to counting the number
    # of argument types preceded by optional type modifiers (e.g., "?", "*").
    # While this calculation is efficient, conforming to the algorithm
    # implemented below requires reparsing the argument list once for each
    # optional argument such function accepts. (So sad.) Why? Because each
    # optional argument implies this function to accept one additional possible
    # number of arguments -- or, equivalently, that the set of all possible
    # numbers of arguments accepted by this function increases by one in size.
    #
    # Each such number requires distinct validation and hence detection here.
    # Unfortunately, eliminating this reparsing would require persisting a list
    # of argument metadata during the first and only pass for subsequent lookup
    # (as detailed below), itself imposing non-negligible inefficiencies. The
    # question then reduces to: which is less efficient, reparsing each
    # argument multiple times or parsing these arguments into a list only once?
    #
    # To answer this question, consider the common case. If most or even many
    # zeshy functions accepted optional arguments and hence required this
    # reparsing, this reparsing would indeed be non-ideal. In practice, few
    # zeshy functions accept optional arguments (due to readability and
    # writability concerns associated with such arguments). Since the common
    # case imposes no argument reparsing, reparsing poses no huge imposition.
    #
    # Note that the above two parse passes are technically invertable by
    # parsing all arguments into a list of all argument in the first pass and
    # iterating over such list in the second. In practice, the infrastructure
    # required by such iteration imposes significant space and time costs --
    # which is bad. For example, consider an "inverted" implementation such as:
    #
    #    local -a args_metadata
    #    while {
    #        pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZY__FUNC_ARGS}"
    #    } {
    #        ...
    #        args_metadata+=(
    #            "${ZY__FUNC_ARG_COUNT_MAX}"
    #            "${match[${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPES}]}"
    #            "${match[${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_IS_MISSABLE}]}"
    #            "${ZY__FUNC_ARG_IS_VARIADIC}" )
    #    }
    #
    #    for ZY__FUNC_ARG_COUNT_CUR ({${ZY__FUNC_ARG_COUNT_MIN}..${ZY__FUNC_ARG_COUNT_MAX}}) {
    #        ...
    #        for ZY__FUNC_ARG_INDEX\
    #            ZY__FUNC_ARG_SUBTYPE_LOCAL\
    #            ZY__FUNC_ARG_IS_OPTIONAL\
    #            ZY__FUNC_ARG_IS_VARIADIC (
    #            "${args_metadata[@]}") {
    #            ...
    #        }
    #        ...
    #    }

    # Maximum argument count. Since ${ZY__FUNC_ARGS_RAW} contains both the
    # type and name of each argument as distinct list items, the size of this
    # list is the number of argument types and names. Hence, halving this size
    # reveals the number of arguments.
    ZY__FUNC_ARG_COUNT_MAX=$(( ${#ZY__FUNC_ARGS_RAW} / 2 ))

    #FIXME: Inefficient. This needn't be globalized. We currently only use this
    #count to define one count below. It's also tested once towards the end of
    #preamble generation, but that's trivially replaced with this easy test:
    #
    #    # Replace this...
    #    if (( ! ZY__FUNC_ARG_COUNT_OPTIONAL )) {
    #
    #    # ...with this.
    #    if (( ZY__FUNC_ARG_COUNT_MIN != ZY__FUNC_ARG_COUNT_MAX )) {

    # Number of optional arguments, both scalar and variadic. Dismantled, this
    # is:
    #
    # * "${(M)...:#...}", removing all mandatory arguments from the list of all
    #   argument types and names. Since argument names are variable names and
    #   hence prohibited by zsh from containing any character signifying an
    #   argument type, this is guaranteed to remove all argument names.
    # * "${...#...}", counting the number of remaining arguments.
    ZY__FUNC_ARG_COUNT_OPTIONAL=${(M)#ZY__FUNC_ARGS_RAW:#${~ZY__CALLABLE_PROTOTYPE_ARG_OPTIONAL_GLOB}}

    #FIXME: Inefficient. We currently only define both
    #${ZY__FUNC_ARG_COUNT_OPTIONAL_SCALAR} and
    #${ZY__FUNC_ARG_COUNT_DEFAULTABLE} (which both require linear character
    #searches through the entire prototype argument list) to ensure that default
    #values are only accepted for optional scalar arguments. This is awfulness!
    #The appropriate place for syntax validation is in the regex itself with an
    #"(?ifthen|else)" PCRE construct ensuring that default value syntax is
    #matched *ONLY* if the current argument type of "?" previously matched.

    # Number of optional scalar arguments.
    ZY__FUNC_ARG_COUNT_OPTIONAL_SCALAR=${(M)#ZY__FUNC_ARGS_RAW:#${~ZY__CALLABLE_PROTOTYPE_ARG_OPTIONAL_SCALAR_GLOB}}

    # Number of defaultable scalar arguments.
    ZY__FUNC_ARG_COUNT_DEFAULTABLE=${(M)#ZY__FUNC_ARGS_RAW:#${~ZY__CALLABLE_PROTOTYPE_ARG_DEFAULTABLE_GLOB}}

    # Number of variadic arguments, both mandatory and optional.
    ZY__FUNC_ARG_COUNT_VARIADIC=${(M)#ZY__FUNC_ARGS_RAW:#${~ZY__CALLABLE_PROTOTYPE_ARG_VARIADIC_GLOB}}

    # Minimum argument count.
    ZY__FUNC_ARG_COUNT_MIN=$((
        ZY__FUNC_ARG_COUNT_MAX - ZY__FUNC_ARG_COUNT_OPTIONAL ))

    print -r 'arg count max: '${ZY__FUNC_ARG_COUNT_MAX}
    print -r 'arg count min: '${ZY__FUNC_ARG_COUNT_MIN}
    print -r 'arg count optional: '${ZY__FUNC_ARG_COUNT_OPTIONAL}
    print -r 'arg count optional (scalar): '${ZY__FUNC_ARG_COUNT_OPTIONAL_SCALAR}
    print -r 'arg count variadic: '${ZY__FUNC_ARG_COUNT_VARIADIC}

    # ..................{ CHECK                              }..................
    # If two or more arguments are variadic, throw an exception. Since two or
    # more argument sublists of arbitrary count are accepted, there exists no
    # means of deciding which sublist any passed argument should be added to.
    (( ZY__FUNC_ARG_COUNT_VARIADIC < 2 )) ||
        ::func.die_of_variadicity 'accepts two or more variadic arguments.'

    #FIXME: Excellent, but shift into a ::func.die_of_*() exception handler (to
    #ensure human-readable exception messages) after refactoring this validation
    #directly into the callable prototype regex.

    # If one or more defaultable arguments (i.e., arguments assigned a default
    # value) are non-optional (i.e., *NOT* prefixed by the type specifier for
    # optional scalar arguments), throw an exception. For readability, all
    # defaultable arguments are required to be explicitly optional.
    (( ZY__FUNC_ARG_COUNT_DEFAULTABLE <=
       ZY__FUNC_ARG_COUNT_OPTIONAL_SCALAR )) || ::func.die\
       'accepts '${ZY__FUNC_ARG_COUNT_DEFAULTABLE}' default arguments but only '${ZY__FUNC_ARG_COUNT_OPTIONAL_SCALAR}' optional scalar arguments. Consider prefixing all default arguments by the optional scalar specifier "'${ZY__CALLABLE_PROTOTYPE_ARG_SCALAR_OPTIONAL_PREFIX}'".'

    # ..................{ PREP                               }..................
    # Compile the PCRE matching all callable prototype argument syntax. Since
    # this is the PCRE matching all callable prototype syntax as well, this
    # PCRE *SHOULD* already be compiled. Due to PCRE caching performed by this
    # function call, guaranteeing this to be the case incurs no penalties.
    :pcre.compile "${ZY__CALLABLE_PROTOTYPE_PCRE}"

    # ..................{ PARSE                              }..................
    # For each possible number of arguments between the number of optional
    # arguments and the maximum number of arguments inclusively, dynamically
    # define function preamble code to:
    #
    # * Default all unpassed defaultable arguments. (All unpassed undefaultable
    #   arguments will, of course, simply be unset.)
    # * Both localize and validating all passed arguments when the caller passes
    #   that number of arguments.
    #
    # By design, iterate starting at the number of optional arguments rather
    # than the minimum number of arguments. Why? In a word: defaults. Unpassed
    # defaultable arguments will be assigned default values in the function
    # preamble by prepending and/or appending these values to this function's
    # current argument list and thus possibly increasing this function's
    # current argument count *BEFORE* any subsequent argument handling
    # conditionally dependent on that count is performed (e.g., localization,
    # validation). Hence, each iteration of this outermost loop adds a new
    # conditional branch to the function preamble performing all handling
    # conditionally dependent on that count *AFTER* that initial assignment of
    # default values. Given this logic, attempting to iterate starting at the
    # minimum number of arguments would erroneously result in unused argument
    # handling being added to the function preamble. Why? Simple. The number of
    # optional arguments is strictly greater than or equal to the minimum number
    # of number of arguments plus the number of defaultable arguments. Unlike
    # undefaultable arguments, defaultable arguments require no conditional
    # handling *AFTER* their initial assignment of default values and are thus
    # ignorable for purposes of defining conditional argument handling.
    #
    # By design, iterate from the number of optional arguments to the maximum
    # number of arguments rather than the converse. Why? Again: defaults.
    # Unpassed defaultable arguments must be assigned default values in a
    # rightmost manner. Thus, the rightmost defaultable argument in a function
    # prototype must be defaulted first, then the next rightmost defaultable
    # argument, and so on until all unpassed defaultable arguments have been
    # defaulted. By iterating from a smaller to larger number of arguments, we
    # permit the algorithm below to iteratively "mark" leftmost defaultable
    # arguments as passed until the current argument count indicates all such
    # arguments to have been passed, at which point all remaining defaultable
    # arguments are unpassed and hence assigned defaults in a rightmost manner.
    #
    # By PCRE design, argument syntax corresponds to shell word syntax. Hence,
    # arguments are efficiently matchable with built-in shell word splitting
    # rather than more costly and complex alternatives. While it is technically
    # feasible to iteratively match arguments in reverse order via the
    # previously compiled ${ZY__CALLABLE_PROTOTYPE_PCRE} PCRE, doing so incurs
    # non-trivial complications *NOT* incurred by simple word splitting.
    for ZY__FUNC_ARG_COUNT_CUR (
        {${ZY__FUNC_ARG_COUNT_MIN}..${ZY__FUNC_ARG_COUNT_MAX}}) {
        # Reset all globals specific to this loop declared by zy:./global.zy.
        ZY__FUNC_ARG_COUNT_CUR_DEFAULTED=0
        ZY__FUNC_ARG_WAS_VARIADIC=0
        ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE=
        ZY__FUNC_ARG_CODE_VARIADIC=

        # 1-based index of the current argument in the current argument list.
        # This will be incremented by 1 to 1 in the first loop iteration below.
        ZY__FUNC_ARG_INDEX=0

        # 1-based index of the current argument type in the
        # ${ZY__FUNC_ARGS_RAW} list of all argument types and names. This will
        # be incremented by 2 to 1 in the first loop iteration below.
        ZY__FUNC_ARG_TYPE_INDEX=-1

        # Clear map globals declared by "global.zy" specific to this loop. See
        # ::map.clear() for further details.
        set -A ZY__FUNC_ARG_DECLARER_TO_DECLARATIONS
        set -A ZY__FUNC_ARG_TESTER_TO_EXPANSIONS

        # Passed optional argument count (i.e., the number of remaining
        # optional arguments treated as passed by the current argument count),
        # defined as the difference of the current argument count and the
        # number of mandatory arguments this function accepts.
        #
        # This count is decremented by 1 for each optional argument parsed for
        # the current argument count; on decrementing this count to 0, all
        # subsequent optional arguments will be treated as unpassed for the
        # current argument count. If this function accepts no optional
        # arguments, this count is 0.
        ZY__FUNC_ARG_COUNT_CUR_OPTIONAL_PASSED=$((
            ZY__FUNC_ARG_COUNT_CUR - ZY__FUNC_ARG_COUNT_MIN ))
        print -r 'arg count current: '${ZY__FUNC_ARG_COUNT_CUR}
        print -r 'arg count current unoptioned: '${ZY__FUNC_ARG_COUNT_CUR_OPTIONAL_PASSED}

        # While unparsed arguments remain, parse the next argument.
        while { true } {
            # Increment the current argument index. While this could be
            # incremented as the last rather than first loop statement, doing
            # so would complicate the use of the "continue" built-in below.
            # Why? Because using that built-in would skip this incrementation!
            ZY__FUNC_ARG_INDEX+=1
            # print -r 'arg index handled: '${ZY__FUNC_ARG_INDEX}

            # Increment the current argument type index. Since each argument
            # type is followed by a corresponding argument name in the
            # ${ZY__FUNC_ARGS_RAW} list global, this index must be incremented
            # past both the current argument type and name.
            ZY__FUNC_ARG_TYPE_INDEX+=2

            # If no unparsed arguments remain, cease parsing arguments.
            (( ZY__FUNC_ARG_TYPE_INDEX < ${#ZY__FUNC_ARGS_RAW} )) || break

            # Parse the current argument.
            #
            # Since all arguments have already been parsed by the initial
            # pcre_match() call, this parse should always succeed. For sanity,
            # we nonetheless guarantee this by throwing exceptions on failure.
            #
            # For both efficiency and simplicity, the previously compiled PCRE
            # matching function prototype syntax is reused to match function
            # prototype argument syntax as well. To do so, a "fake" function
            # prototype containing only the current argument to be parsed is
            # dynamically fabricated "on the fly" and passed to PCRE matching
            # machinery. All captured match groups except those pertaining to
            # the current argument will be ignored.
            #
            # For example, if the current argument is ":str UBI", the fake
            # prototype "x x(:str UBI)" will be fabricated.
            #
            # For both efficiency and readability, captured match groups
            # expanded multiple times below are localized to string variables.
            #
            # For function prototypes declaring *NO* argument channels (i.e.,
            # only declaring an argument list), the initial pcre_match() call
            # already parsed the first argument into the canonical ${match}
            # list global. While we could attempt to avoid reparsing that
            # argument, doing so would require retesting a condition for each
            # argument and hence arguably save no time (and could indeed cost
            # more time for long argument lists). Avoid premature optimization!
            #
            # For obscure reasons relating to zsh parsing, double- rather than
            # single-quotes *MUST* be used here.
            pcre_match --\
                "x x(${ZY__FUNC_ARGS_RAW[
                    ${ZY__FUNC_ARG_TYPE_INDEX},
                    $(( ZY__FUNC_ARG_TYPE_INDEX + 1 ))]})" ||  # double-quotes!
                ::func.die 'argument at index '$((
                    (ZY__FUNC_ARG_TYPE_INDEX + 1) / 2 ))' unparsable.'
            print -r 'argument type index: '${ZY__FUNC_ARG_TYPE_INDEX}
            integer match_index; for match_index ({1..${ZY__CALLABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_ARGS}}) { print -r 'match '${match_index}': '${match[${match_index}]-} }

            #FIXME: While we do require ${ZY__FUNC_ARG_IS_VARIADIC_OPTIONAL} to
            #be globalized, we do *NOT* require
            #${ZY__FUNC_ARG_IS_VARIADIC_MANDATORY} to be globalized.
            #Unglobalize, please.

            # 1 if this argument is a mandatory variadic argument or 0
            # otherwise.
            ZY__FUNC_ARG_IS_VARIADIC_MANDATORY=${#match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_MANDATORY}]-}

            # 1 if this argument is an optional variadic argument or 0
            # otherwise.
            ZY__FUNC_ARG_IS_VARIADIC_OPTIONAL=${#match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_VARIADIC_OPTIONAL}]-}

            # 1 if this argument is variadic or 0 otherwise.
            ZY__FUNC_ARG_IS_VARIADIC=$((
                ZY__FUNC_ARG_IS_VARIADIC_MANDATORY +
                ZY__FUNC_ARG_IS_VARIADIC_OPTIONAL ))

            # 1 if this argument is optional or 0 otherwise. By definition,
            # both optional variadic and non-variadic arguments are optional.
            # Since those two conditions are mutually exclusive, adding them
            # suffices to obtain the desired boolean.
            ZY__FUNC_ARG_IS_OPTIONAL=$((
                ZY__FUNC_ARG_IS_VARIADIC_OPTIONAL + ${#match[
                    ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_SCALAR_OPTIONAL}]-}
            ))

            # This argument's default value is any or the empty string.
            ZY__FUNC_DEFAULT_VALUE=${match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_DEFAULT_VALUE}]-}

            #FIXME: Ideally, the order of the following two top-level
            #conditionals would be reversed. Doing so would optimize things
            #quite a bit, as the latter of these conditionals currently "undoes"
            #assignments performed by the former. Avoiding that would be nice,
            #if somewhat non-essential.

            # ..............{ VARIADIC                           }..............
            # Define ${ZY__FUNC_ARG_PARAM}, the string with which to expand
            # this argument if expandable or the empty string otherwise.
            #
            # If this argument is *NOT* variadic...
            if (( ! ZY__FUNC_ARG_IS_VARIADIC )) {
                # If this argument does *NOT* follow a variadic argument, this
                # argument is only reliably expandable by its positive index
                # (i.e., relative to the beginning of the current argument
                # list). Attempting to index this argument by its negative index
                # will fail if this argument is followed by a variadic argument.
                if (( ! ZY__FUNC_ARG_WAS_VARIADIC )) {
                    ZY__FUNC_ARG_PARAM=${ZY__FUNC_ARG_INDEX}
                # Else this argument follows a variadic argument and hence a
                # countably infinite number of arguments. In this case,
                # this argument is only reliably expandable by its negative
                # index (i.e., relative to the end of the current argument
                # list). Happily, the same index applies regardless of whether
                # this variadic argument was mandatory or optional.
                #
                # Since a negative sign "-" conflicts with parameter expansion
                # syntax, negative indices may only be referenced by indexing
                # canonical list global ${@} or ${argv} with this index. For
                # brevity, we prefer the former. Since subsequent logic may
                # conditionally prefix this string with parameter expansion
                # flags (e.g., "(P)"), avoid delimiting this string with "${"
                # and "}" until *AFTER* performing such logic below.
                } else {
                    ZY__FUNC_ARG_PARAM='@['$((
                        ZY__FUNC_ARG_INDEX - ZY__FUNC_ARG_COUNT_MAX - 1 ))']'
                }
            # Else this argument is variadic.
            } else {
                # Notify subsequent parse iterations of this fact.
                ZY__FUNC_ARG_WAS_VARIADIC=1

                # Expand this argument and all subsequent optional variadic
                # arguments with an argument range starting at the current
                # positive index and ending at the negative index of the last
                # such argument. See above for related logic.
                ZY__FUNC_ARG_PARAM='@['${ZY__FUNC_ARG_INDEX}','$((
                    ZY__FUNC_ARG_INDEX - ZY__FUNC_ARG_COUNT_MAX - 1 ))']'
            }

            # ..............{ DEFAULT                            }..............
            # If this argument is optional...
            if (( ZY__FUNC_ARG_IS_OPTIONAL )) {
                # ...and passed rather than unpassed for the current argument
                # count (as implied by the existence of one or more remaining
                # optional arguments treated as passed by the current argument
                # count), modify the current argument count to accept one less
                # optional argument. This optional argument "consumes" one
                # optional argument "slot" for the current argument count.
                if (( ZY__FUNC_ARG_COUNT_CUR_OPTIONAL_PASSED )) {
                      ZY__FUNC_ARG_COUNT_CUR_OPTIONAL_PASSED+=-1
                # Else, this optional argument is unpassed.
                #
                # If this unpassed argument is variadic, instruct subsequent
                # localization to default this argument to the empty list by
                # clearing the string with which to expand this argument.
                } elif (( ZY__FUNC_ARG_IS_VARIADIC )) {
                    print -r 'defaulting unpassed optional variadic argument '${ZY__FUNC_ARG_INDEX}
                    ZY__FUNC_ARG_PARAM=
                # If this unpassed argument is defaultable, do so. By PCRE
                # design, this is testable by testing whether this argument's
                # default value is non-empty. Since this value is guaranteed to
                # be scalar (i.e., either a single- or double-quoted string,
                # integer, or float) *AND* since the length of this value is
                # thus non-zero if defined and zero otherwise, this length
                # suffices to indicate whether a default value was specified.
                # Hence, no boolean ${arg_is_defaulted} is required.
                } elif (( ${#ZY__FUNC_DEFAULT_VALUE} )) {
                    print -r 'arg current default value: '${ZY__FUNC_DEFAULT_VALUE}

                    # If this is the first argument to be defaulted for the
                    # current argument count, prefix this default by an if
                    # conditional applying this default only under this count.
                    if (( ! ZY__FUNC_ARG_COUNT_CUR_DEFAULTED )) {
                        # If no arguments have been defaulted for a prior
                        # argument count, this is the first argument to be
                        # defaulted for any count. Create the first branch of a
                        # new conditional specific to the current count.
                        if (( ! ${#ZY__FUNC_ARGS_CODE_DEFAULT} )) {
                            ZY__FUNC_ARGS_CODE_DEFAULT+=${ZY__FUNC_LINE_PREFIX}'if (( # == '${ZY__FUNC_ARG_COUNT_CUR}' )) {'
                        # Else, one or more arguments have been defaulted for a
                        # prior argument count, in which case an if conditional
                        # for doing so exists. Continue that conditional with a
                        # new branch specific to the current count.
                        } else {
                            ZY__FUNC_ARGS_CODE_DEFAULT+=' elif (( # == '${ZY__FUNC_ARG_COUNT_CUR}' )) {'
                        }
                    }

                    # Increment the current defaulted argument count *AFTER*
                    # testing this count above.
                    ZY__FUNC_ARG_COUNT_CUR_DEFAULTED+=1

                    # If this argument is the last explicit argument this
                    # function accepts (ignoring all subsequent optional
                    # variadic list arguments), append this argument's default
                    # value to the current argument list.
                    if (( ZY__FUNC_ARG_INDEX == ZY__FUNC_ARG_COUNT_MAX )) {
                        ZY__FUNC_ARGS_CODE_DEFAULT+=${ZY__FUNC_LINE_PREFIX}'argv+='${ZY__FUNC_DEFAULT_VALUE}
                    # Else if this argument is the first explicit argument this
                    # function accepts, inefficiently replace the current
                    # argument list with one in which the indices of all other
                    # explicit arguments are increased by 1 and the first index
                    # of this list is set to such argument's default value.
                    } elif (( ZY__FUNC_ARG_INDEX == 1 )) {
                        ZY__FUNC_ARGS_CODE_DEFAULT+=${ZY__FUNC_LINE_PREFIX}'argv=( '${ZY__FUNC_DEFAULT_VALUE}' "${@}" )'
                    # Else this argument is neither the first nor last explicit
                    # argument this function accepts and hence is both preceded
                    # *AND* succeeded by one or more other such arguments. In
                    # this case, an efficient alternative to replacing the
                    # current argument list presents itself: append this
                    # argument's default value to the prior argument's index in
                    # the current argument list. (Yes, this actually works.)
                    } else {
                        ZY__FUNC_ARGS_CODE_DEFAULT+=${ZY__FUNC_LINE_PREFIX}'argv['$((
                            ZY__FUNC_ARG_INDEX - 1 ))']+=( '${ZY__FUNC_DEFAULT_VALUE}' )'
                    }
                # Else, this unpassed and undefaulted argument is missing. In
                # this case, skip to the next argument. Note that this
                # implicitly prevents the current argument index from being
                # incremented below, thus preserving this index for the next
                # argument as desired. (Missing arguments are *NOT* in the
                # current argument list and hence cannot be indexed.)
                } else {
                    print -r 'skipping unpassed undefaulted argument '${ZY__FUNC_ARG_INDEX}
                    continue
                }
            }

            # ..............{ LOCALIZE                           }..............
            # Name of the local variable to which this argument is bound.
            ZY__FUNC_ARG_NAME=${match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBNAME_LOCAL}]-}${ZY__FUNC_VAR_NAME_SUFFIX}
            # print 'local var name: '${ZY__FUNC_ARG_NAME}

            # If this argument is scalar, localize this argument to a local
            # scalar variable.
            if (( ! ZY__FUNC_ARG_IS_VARIADIC )) {
                # Argument local subtype.
                ZY__FUNC_ARG_SUBTYPE_LOCAL=${match[
                    ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_LOCAL}]}

                # If this subtype is nonscalar (e.g., ":list", ":map"),
                # throw an exception. By zsh design, arguments are
                # *ALWAYS* passed as untyped strings and hence cannot
                # encapsulate nonscalar data without variable indirection.
                [[ ${ZY__FUNC_ARG_SUBTYPE_LOCAL} != ':'('list'|'map') ]] ||
                    #FIXME: Somewhat of a silly function, isn't it? Its
                    #implementation strikes us as overly complex. Given
                    #that such function is only ever called here,
                    #contemplate supplanting it by the simpler
                    #::func.die_of_arg_type().
                    ::func.die_of_arg_type_direct\
                        'nonscalar, but only scalar argument types supported.'

                # Note that if this argument is indirect, prior logic
                # ensured this argument's local subtype to be ":str".
                #
                # If this subtype is *NOT* the name of an enabled alias,
                # throw an exception. See :alias_command.is().
                (( ${+aliases[${ZY__FUNC_ARG_SUBTYPE_LOCAL}]} )) ||
                    ::func.die_of_arg\
                        'local subtype '${ZY__FUNC_ARG_SUBTYPE_LOCAL}' unrecognized (i.e., alias '${ZY__FUNC_ARG_SUBTYPE_LOCAL}'() undefined).'

                # Map this subtype to a definition assigning this argument
                # value to a local variable of the same name.
                ZY__FUNC_ARG_DECLARER_TO_DECLARATIONS[${ZY__FUNC_ARG_SUBTYPE_LOCAL}]+=' '${ZY__FUNC_ARG_NAME}'="${'${ZY__FUNC_ARG_PARAM}'}"'
            # Else this argument is variadic and hence comprises an
            # arbitrary number of passed strings. Since these strings are
            # unavailable until function call time and hence *NOT*
            # localizable at function definition time (i.e., now) as a
            # hardcoded set of local scalar variables, these strings are
            # localized into a local list variable instead.
            #
            # If this argument name is neither "@" or "argv" (both of which
            # signify the current argument list), this argument is
            # localized by declaring a new list local with this argument
            # name defined to contain the desired passed strings.
            } elif [[ ${ZY__FUNC_ARG_NAME} != ('@'|'argv') ]] {
                # Map the local list type ":list" to this argument's
                # declaration, but *NOT* definition. Due to zsh design,
                # lists cannot be defined at declaration time.
                ZY__FUNC_ARG_DECLARER_TO_DECLARATIONS[:list]+=' '${ZY__FUNC_ARG_NAME}

                # Define this variadic argument as a list.
                ZY__FUNC_ARG_CODE_VARIADIC+=${ZY__FUNC_LINE_PREFIX}${ZY__FUNC_ARG_NAME}'=( '

                # If this variadic argument is passed, initialize this list
                # to the desired passed strings.
                if (( ${#ZY__FUNC_ARG_PARAM} )) {
                    ZY__FUNC_ARG_CODE_VARIADIC+='"${'${ZY__FUNC_ARG_PARAM}'}" )'
                # Else, this variadic argument is unpassed. Clear this list.
                } else {
                    ZY__FUNC_ARG_CODE_VARIADIC+=')'
                }
            # Else, this argument name is either "@" or "argv". Reduce the
            # current argument list to only variadic arguments.
            } else {
                # If this variadic argument is passed, initialize this list
                # to the desired passed strings.
                if (( ${#ZY__FUNC_ARG_PARAM} )) {
                    # If this argument is *NOT* the first argument, remove
                    # all prior arguments from this argument list. Since
                    # zsh offers a simple builtin for removing prefixing
                    # but *NOT* suffixing arguments, this code is more
                    # efficient than that below.
                    (( ZY__FUNC_ARG_INDEX == 1 )) ||
                        ZY__FUNC_ARG_CODE_VARIADIC+=${ZY__FUNC_LINE_PREFIX}'shift '$((
                            ZY__FUNC_ARG_INDEX - 1 ))

                    # If this argument is *NOT* the last argument, remove
                    # all subsequent arguments from this argument list.
                    if (( ZY__FUNC_ARG_INDEX !=
                          ZY__FUNC_ARG_COUNT_MAX )) {
                        # If this argument is the second-to-last argument,
                        # remove only the last argument. See :args.pop().
                        if (( ZY__FUNC_ARG_INDEX ==
                              ZY__FUNC_ARG_COUNT_MAX - 1 )) {
                            ZY__FUNC_ARG_CODE_VARIADIC+=${ZY__FUNC_LINE_PREFIX}'argv[-1]=()'
                        # Else, this argument precedes the second-to-last
                        # argument. Remove all subsequent arguments with
                        # ranged indices. See :args.shift().
                        } else {
                            ZY__FUNC_ARG_CODE_VARIADIC+=${ZY__FUNC_LINE_PREFIX}'argv['$((
                                ZY__FUNC_ARG_INDEX -
                                ZY__FUNC_ARG_COUNT_MAX ))',-1]=()'
                        }
                    }
                # Else, this variadic argument is unpassed. Clear this
                # list. See :args.clear().
                } else {
                    ZY__FUNC_ARG_CODE_VARIADIC+=${ZY__FUNC_LINE_PREFIX}'argv=()'
                }
            }

            # ..............{ VALIDATE                           }..............
            # Argument major subtype, defaulting to the local subtype.
            ZY__FUNC_ARG_SUBTYPE_MAJOR=${match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]:-${match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_LOCAL}]}}

            # Argument minor subtype, defaulting to the empty string.
            ZY__FUNC_ARG_SUBTYPE_MINOR=${match[
                ${ZY__CALLABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]-}

            # If the concatenation of this argument's major and minor
            # subtypes is *NOT* ":str", validate this argument. If this
            # concatenation is ":str", this argument need *NOT* be
            # validated. Since all arguments are passed as untyped scalars
            # and hence strings by POSIX calling conventions, string
            # arguments are always inherently valid.
            if [[ ${ZY__FUNC_ARG_SUBTYPE_MAJOR}${ZY__CALLABLE_PROTOTYPE_ARG_SUBTYPE_MINOR_PREFIX}${ZY__FUNC_ARG_SUBTYPE_MINOR} !=\
                  ':str'${ZY__CALLABLE_PROTOTYPE_ARG_SUBTYPE_MINOR_PREFIX} ]] {
                # If this argument is a glob, note this for later testing.
                [[ ${ZY__FUNC_ARG_SUBTYPE_MAJOR} != ':glob' ]] ||
                    ZY__FUNC_ARGS_IS_GLOB=1

                # Name of the function validating this argument's value
                # (e.g., :Int.is() for arguments of type ":Int"). Note that:
                #
                # * zy:../*-test/var.zy defines private validators for all
                #   default indirect types (e.g., ::Int.is()).
                # * zy://*-root//var/type.zy defines public validators for
                #   all default indirect types (e.g., :Int.is()).
                ZY__FUNC_CALLABLE_NAME=${ZY__FUNC_ARG_SUBTYPE_MAJOR}'.is'

                # If this argument has a minor subtype, suffix this
                # function name by this subtype delimited by "_".
                if (( ! ${#ZY__FUNC_ARG_SUBTYPE_MINOR} )) ||
                    ZY__FUNC_CALLABLE_NAME+='_'${ZY__FUNC_ARG_SUBTYPE_MINOR}

                # If this tester has a private variant (e.g., ::Int.is()),
                # prefer that to its public variant (e.g., :Int.is()). The
                # former are optimized specifically for use and hence
                # preferable in function preambles: namely, by deferring
                # explicit validation of variable existence to subsequent
                # exception handlers.
                if (( ${+functions[:${ZY__FUNC_CALLABLE_NAME}]} )) {
                    ZY__FUNC_CALLABLE_NAME=':'${ZY__FUNC_CALLABLE_NAME}
                # Else if this tester's public variant does *NOT* exist either,
                # throw an exception.
                } elif (( ! ${+functions[${ZY__FUNC_CALLABLE_NAME}]} )) {
                    ::func.die_of_arg_type\
                        'unrecognized (i.e., functions '${ZY__FUNC_CALLABLE_NAME}'() and :'${ZY__FUNC_CALLABLE_NAME}'() undefined)'
                }

                # Map such function name to such argument's expansion.
                ZY__FUNC_ARG_TESTER_TO_EXPANSIONS[${ZY__FUNC_CALLABLE_NAME}]+=' "${'${ZY__FUNC_ARG_PARAM}'}"'
            }

            #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            # NOTE: To permit the use of the "continue" built-in above, the
            # remainder of this block should remain empty. Any commands run here
            # will *NOT* be run when "continue" is called above.
            #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        }

        # If the current argument count defaulted one or more unpassed
        # arguments, terminate the if conditional doing so.
        (( ! ZY__FUNC_ARG_COUNT_CUR_DEFAULTED )) ||
            ZY__FUNC_ARGS_CODE_DEFAULT+=${ZY__FUNC_LINE_PREFIX}'}'

        # For each name of a variable tester function and corresponding string
        # expanding all arguments to be validated by this function, do so.
        for ZY__FUNC_CALLABLE_NAME ZY__FUNC_ARGS_EXPANSIONS (
            "${(kv@)ZY__FUNC_ARG_TESTER_TO_EXPANSIONS}") {
            ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE+=${ZY__FUNC_LINE_PREFIX}${ZY__FUNC_CALLABLE_NAME}${ZY__FUNC_ARGS_EXPANSIONS}' || ::func.die_unless_args_pass_tester "${@}" '''${ZY__FUNC_ARGS_EXPANSIONS}''' '${(q)ZY__FUNC_CALLABLE_NAME}
        }

        # For each name of a variable declaration alias and corresponding
        # string declaring all arguments to be localized by this alias, do so.
        # By design, these declarations consist only of simple string
        # assignments unconditionally succeeding and hence requiring no
        # exception handling (e.g., 'my_var="${1}"'). For efficiency, iterate
        # only by keys (rather than by both keys and values).
        for ZY__FUNC_CALLABLE_NAME (
            "${(k@)ZY__FUNC_ARG_DECLARER_TO_DECLARATIONS}") {
            ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE+=${ZY__FUNC_LINE_PREFIX}${ZY__FUNC_CALLABLE_NAME}${ZY__FUNC_ARG_DECLARER_TO_DECLARATIONS[${ZY__FUNC_CALLABLE_NAME}]}
        }

        # If localizing one or more variadic arguments, do so *AFTER*
        # localizing all non-variadic arguments. If any variadic argument is
        # localized to the current argument list ${@}, doing so has removed all
        # non-variadic arguments from that list and thus must be deferred until
        # *AFTER* these arguments have been localized from that list.
        (( ! ${#ZY__FUNC_ARG_CODE_VARIADIC} )) ||
            ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE+=${ZY__FUNC_ARG_CODE_VARIADIC}

        # If localizing and/or validating one or more scalar arguments, do so.
        if (( ${#ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE} )) {
            # If this function accepts no optional arguments, the outermost
            # loop of this iteration will only be run once -- implying this
            # function to accept only one argument count (following the initial
            # assignment of default values for unpassed defaultable arguments).
            # Hence, this code should *NOT* be embedded in an if conditional
            # testing the current argument count.
            if (( ! ZY__FUNC_ARG_COUNT_OPTIONAL )) {
                # print -r 'Spitting out code unconditionally!'
                ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE+=${ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE}
            # Else this function accepts one or more optional arguments and
            # hence a variable number of arguments. Embed this code in an if
            # conditional testing the current argument count.
            } else {
                # Number of passed arguments plus the number of unpassed
                # arguments defaulted for the current argument count.
                # Defaulting one or more unpassed arguments above inserted the
                # default values for those arguments into the current argument
                # list and hence increased the size of that list. The current
                # argument count ${ZY__FUNC_ARG_COUNT_CUR} no longer accurately
                # reflects that list's size and must *NOT* be tested as is.
                ZY__FUNC_ARG_COUNT_CUR_DEFAULTED+=${ZY__FUNC_ARG_COUNT_CUR}

                # If this count is the maximum, terminate the current if
                # conditional with a final branch. Since the prior branch of
                # this conditional already ended on "}", omit that prefix here.
                if (( ZY__FUNC_ARG_COUNT_CUR_DEFAULTED ==
                      ZY__FUNC_ARG_COUNT_MAX )) {
                    ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE+=' else'
                # Else the current argument count is less than the maximum.
                } else {
                    # If the current argument count is the minimum, initiate a
                    # new if conditional. Curiously, note that such test
                    # implicitly accounts for variadicity. Why? Consider. If
                    # one argument is variadic, then by the prior constraints
                    # such argument must also be the *ONLY* optional argument
                    # such function accepts. There then exist only two cases
                    # with respect to the number of arguments such function
                    # accepts. Either such function is passed:
                    #
                    # 1. The minimum number of arguments and hence *NOT* passed
                    #    such optional variadic argument, which the branch
                    #    below suffices to test.
                    # 2. The maximum number of non-variadic arguments and hence
                    #    passed at least such optional variadic argument, which
                    #    the branch above suffices to test.
                    if (( ZY__FUNC_ARG_COUNT_CUR_DEFAULTED ==
                          ZY__FUNC_ARG_COUNT_MIN )) {
                        ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE+=${ZY__FUNC_LINE_PREFIX}
                    # Else the current argument count is more than the minimum.
                    # Continue the current if conditional with a new branch.
                    } else {
                        ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE+=' el'
                    }

                    # Test this branch.
                    ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE+='if (( # == '${ZY__FUNC_ARG_COUNT_CUR_DEFAULTED}' ))'
                }

                # Implement this branch's body.
                ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE+=' {'${ZY__FUNC_ARG_CODE_VALIDATE_LOCALIZE}${ZY__FUNC_LINE_PREFIX}'}'
            }
        }
    }

    # ..................{ PREAMBLE ~ default                 }..................
    # If defaulting any arguments, customize this code for interpolation below.
    if (( ${#ZY__FUNC_ARGS_CODE_DEFAULT} )) {
        # Name of the alias or function testing at runtime whether the current
        # function call conditionally accepts unpassed defaultable arguments
        # (e.g., only when called directly from the command line) or the empty
        # string if this function *ALWAYS* accepts such arguments.
        ZY__FUNC_CALLABLE_NAME=${ZY__FUNC_ATTRS[is_args_defaultable_if]-}

        # If only conditionally accepting these arguments, do so only when that
        # function call reports success at runtime.
        if (( ${#ZY__FUNC_CALLABLE_NAME} )) {
            # If such alias or function does *NOT* exist, throw an exception.
            # See :alias_command.is() and :func.is().
            (( ${+aliases[${ZY__FUNC_CALLABLE_NAME}]} +
               ${+functions[${ZY__FUNC_CALLABLE_NAME}]} )) ||
               ::func.die 'attribute "default_args_if" alias or function '${ZY__FUNC_CALLABLE_NAME}'() undefined'

            # Default these arguments only if this call succeeds.
            ZY__FUNC_ARGS_CODE_DEFAULT='if { '${ZY__FUNC_CALLABLE_NAME}' } {'${ZY__FUNC_LINE_PREFIX}${ZY__FUNC_ARGS_CODE_DEFAULT}${ZY__FUNC_LINE_PREFIX}'}'
        }

        # Prepend this function's body by such defaults.
        ZY__FUNC_PREAMBLE=${ZY__FUNC_ARGS_CODE_DEFAULT}
    }

    # ..................{ PREAMBLE ~ count                   }..................
    # Validate the number of arguments passed to this function.
    #
    # If this function is variadic, this function accepts a countably infinite
    # number of arguments only bounded below by the minimum number of arguments.
    if (( ZY__FUNC_ARG_WAS_VARIADIC )) {
        ZY__FUNC_PREAMBLE+=${ZY__FUNC_LINE_PREFIX}'(( # >= '${ZY__FUNC_ARG_COUNT_MIN}' )) || ::func.die_of_arg_count_''<'' "${@}" '${ZY__FUNC_ARG_COUNT_MIN}
    # Else, this function is non-variadic, in which case this function accepts
    # a number of arguments strictly bounded by the minimum and maximum number
    # of arguments.
    #
    # If this minimum and maximum are equal, simplify this test as such.
    } elif (( ZY__FUNC_ARG_COUNT_MIN == ZY__FUNC_ARG_COUNT_MAX )) {
        ZY__FUNC_PREAMBLE+=${ZY__FUNC_LINE_PREFIX}'(( # == '${ZY__FUNC_ARG_COUNT_MIN}' )) || ::func.die_of_arg_count_''!='' "${@}" '${ZY__FUNC_ARG_COUNT_MIN}
    # Else, this minimum and maximum are unequal.
    } else {
        ZY__FUNC_PREAMBLE+=${ZY__FUNC_LINE_PREFIX}'(( '${ZY__FUNC_ARG_COUNT_MIN}' <= # && # <= '${ZY__FUNC_ARG_COUNT_MAX}' )) || ::func.die_of_arg_count_''<>'' "${@}" '${ZY__FUNC_ARG_COUNT_MIN}' '${ZY__FUNC_ARG_COUNT_MAX}
    }

    # ..................{ PREAMBLE ~ localize, validate      }..................
    # If localizing and/or validating any arguments, do so.
    (( ! ${#ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE} )) ||
        ZY__FUNC_PREAMBLE+=${ZY__FUNC_ARGS_CODE_VALIDATE_LOCALIZE}

    # ..................{ PREAMBLE                           }..................
    # If a preamble was defined for this function above, delimit this preamble
    # from subsequent user-defined code.
    (( ! ${#ZY__FUNC_PREAMBLE} )) || ZY__FUNC_PREAMBLE+=${ZY__FUNC_LINE_PREFIX}
    print -r "${ZY__FUNC_NAMES[1]} preamble: ${ZY__FUNC_PREAMBLE}"$'\n\n'

}
