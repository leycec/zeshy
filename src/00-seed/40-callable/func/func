#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *function declarers and definers* (i.e., functions declaring and
defining functions with bodies passed as arbitrary strings).
/---

# ....................{ DECLARERS                          }....................
#FIXME: Rename to :func_prototype.declare_body().
#FIXME: Add examples.

:func_ ':void :declare_func[
   args =  (:string func_prototype, :string func_body),
   stdin = (:string `func_asciidoc)]' :func{
    # Parse such prototype into corresponding globals.
    ::func_.start "${func_prototype}"

    #FIXME: Silly. Instead, generalize :define_func() and hence
    #:redefine_func() to accept a variadic list of function names rather than
    #merely one function name. Then excise such iteration here.

    # Define such functions.
    :string func_name
    for     func_name ("${ZESHY__FUNC_NAMES__[@]}") {
        :define_func "${func_name}" "${func_body}"
    }

    # Declare such functions *AFTER* successfully defining such functions.
    ::func_.stop
}:func <<'/---'
Declare one or more functions identified by the passed function prototype,
defined to the passed function body and documented by the help string passed on
standard input (e.g., as a here-document or -string). If any such function has
already been declared or defined, an exception is thrown.
/---

# ....................{ DEFINERS                           }....................
#FIXME: Rename to :func.define_body().

:func_ ':void :define_func(:string `func_name, :string `func_body)' :func{
    :func.die_if "${1}"
    :redefine_func "${@}"
}:func <<'/---'
Define the passed function as the passed *function body* (i.e., such function's
implementation excluding `function ${function_name} () {` prefix and `}`
suffix). If such function has already been declared, an exception is thrown:
e.g.,

.:define_func()
==========================================
[source]
------------------------------------------
>>> :define_func "moral = choice" ':string.output\
...    "With the myth of the State out of the way, the real mutuality and
...     reciprocity of society and individual became clear. Sacrifice might be
...     demanded of the individual, but never compromise: for though only the
...     society could give security and stability, only the individual, the
...     person, had the power of moral choiceâ€”the power of change, the essential
...     function of life. The Odonian society was conceived as a permanent
...     revolution, and revolution begins in the thinking mind."
>>> get_string_line $("moral = choice") 1
With the myth of the State out of the way, the real mutuality and
------------------------------------------
==========================================

== Motivation ==

This function is principally useful for defining functions with *dynamic
implementations* (i.e., function bodies dynamically synthesized at runtime).

Since `zsh` allows functions with names containing shell-reserved characters to
be defined by double-quoting such names (e.g.,
`function "Fisheye Placebo"() { ::string.output "You are free." }`), this
function does _not_ need to be called to define functions with such names.
Interestingly, this differs from the case of defining aliases with such names;
due to undocumented subtleties, ::alias_command.define() should always be called to
define such aliases.
/---

#FIXME: Rename to :func.redefine_body().
:func_ ':void :redefine_func(:string+nonempty func_name, :string func_body)'
:func{
    local func_declaration
#   :string.output_if_debug "zeshy: defining ${func_name}()..."

    # Function to be redefined. For obscure error handling reasons, we
    # interpolate such function into several eval() calls below. Dismantled,
    # this is:
    #
    # * "(q)", quote protecting the name of such function. Since zsh permits
    #   such name to contain arbitrary shell-reserved characters (e.g., "("),
    #   such protection avoids obscure errors on names with such characters.
    #
    # Technically, such redefinition is also implementable with the following
    # efficient alternative avoiding such eval() statements:
    #
    #    { unfunction "${func_name}" } :silent_stderr or ignore_failure
    #    { functions[${func_name}]="${func_body}" } :silent_stderr
    #    (( ${+functions[${func_name}]} )) or {
    #         :string func_error; func_error="$({
    #             functions[${func_name}]="${func_body}"
    #         } :to_stdout)"
    #
    # Such alternative *DOES* work but omits line numbers in parse errors,
    # preventing zeshy from throwing human-readable parse exceptions (e.g.,
    # on syntactic errors, the above alternative prints errors resembling
    # "zsh: parse error near `}'" rather than
    # "(eval):2: parse error near `}'"). Since human-readability of exception
    # messages is considerably more important than simplicity of implementation,
    # we retain the current eval()-based approach.
    func_declaration='function '${(q)func_name}' () {'$'\n'${func_body}$'\n''}'

    # Redefine such function. If such redefinition fails, zsh emits an error to
    # standard error and reports failure, inducing zeshy to throw an exception
    # resembling "(eval):2: parse error near `]]'". For readability, capture
    # and convert such error into a human-readable exception message.
    { eval "${func_declaration}" } 2>/dev/null || {
        local func_error

        # Temporarily enable shell option "EVAL_LINENO", ensuring the line
        # number zsh embeds in the error captured below will be relative to
        # such function body rather than to this function redefine_error(). See
        # :enable_option_local() for further details.
        setopt -- local_options eval_lineno

        # Capture such output, ignoring the expected failure.
        func_error="$({ eval "${func_declaration}" } 1>2 || true)"
        # :string.output_to_stderr "error: ${func_error}"

        # If such error message is in canonical zsh format (e.g.,
        # "(eval):244: parse error near `()'"), convert such message to
        # human-readable form. In particular, append the actual line of code in
        # such function body inducing such error. Dismantled, this is:
        #
        # * "(#b)", enabling match group capturing.
        # * "(<->##)", matching such line as one or more digits into
        #   ${match[1]}. See :is_int() for further details.
        # * "(*)", matching the actual error message into ${match[2]}.
        if [[ ${func_error} == (#b)'(eval):'(<->##)': '(*) ]] {
            integer line_number line_number_start line_number_stop
            local func_error_message func_context
            local -a func_lines

            # Line number of such error.
            line_number="${match[1]}"

            # Parse error emitted by zsh, stripped of delimiting whitespace.
            func_error_message="${${match[2]##[[:space:]]##}%%[[:space:]]##}"

            # Capitalize the first character of such error. (Unfortunately,
            # parameter expansion flag "(C)" capitalizes the first character of all
            # words of such parameter.)
            func_error_message[1]="${(C)func_error_message[1]}"

            # Line number of the second lines preceding and succeeding such error,
            # for textual context.
            line_number_start=$(( line_number - 2 ))
            line_number_stop=$((  line_number + 2 ))

            # List of function definition lines. See set_list_to_string_lines() for
            # further details.
            func_lines=( "${(@f)func}" )

            # Constrain such numbers to [1, ${max_line_number}], where
            # ${max_line_number} is the number of lines in such function body.
            if (( line_number_start < 1 )) {
                  line_number_start=1
            }
            if (( line_number_stop > ${#func_lines} )) {
                  line_number_stop=${#func_lines}
            }

            # Constrain such start to be less than or equal to such stop.  While
            # this shouldn't be necessary, a wee caution never hurts.
            if (( line_number_start > line_number_stop )) {
                  line_number_start=${line_number_stop}
            }

            #FIXME: Hardly an ideal implementation. Ideally, we should implement
            #a function leveraging color styles printing such textual context
            #with decent aesthetics. To do so, we'll need test here whether such
            #function exists; if it does, call it, passing such call
            #"${func_body}" and the desired function line; else, defer
            #to the default implementation below. (Actually, don't we have an
            #existing function for numbering arbitrary code lines? I recall such
            #function requiring a bit of touch-up, as well...)

            # Append each such line prefixed by its line number to such string.
            # print 'ok'
            # print "line_number: ${line_number}"
            # print "line_number_start: ${line_number_start}"
            # print "line_number_stop: ${line_number_stop}"
            # print "#func_lines: ${#func_lines}"
            # print "func:"
            # :string.output "${func}" | command nl
            integer line_number
            for     line_number ({${line_number_start}..${line_number_stop}}) {
                # print "i: ${i}"
                func_context+="${ZESHY_ASCII_NEWLINE} [${line_number}]  ${func_lines[${line_number}]}"
            }
            # print 'ko'

            # Set such error message.
            func_error="${func_error_message} on line ${line_number} of function ${func_name}():${ZESHY_ASCII_NEWLINE}${func_context}"
        }

        # Throw such exception.
        :die "${func_error}"
    }
#    print -r -- "function \"${func_name}\" () {
#    ${func_body}
#}"

    #FIXME: Such logic should be optimized away under optimized builds.

    # If prior logic succeeded but such function remains undefined, throw a
    # custom exception. Technically, this should never happen. Since it
    # occasionally does, avoid silent regressions with efficient precautions.
    :func.is "${func_name}" :or :die\
        'Function '${func_name}'() undefinable:'$'\n\n'${func_body}
}:func <<'/---'
(Re)define the passed function as the passed function body, regardless of
whether such function has been previously defined. See :define_func() for
further details: e.g.,

.:redefine_func()
==========================================
[source]
------------------------------------------
>>> :redefine_func "The Age of Decreasing Numbers" ':string.output\
...    "Civilization is a subset of nature even if we're not aware of it, and
...     the dark side of our recent increase was a decrease in topsoil and
...     forests and fossil fuels and the Earth's capacity to absorb industrial
...     waste without catastrophic change. Now these things have decreased so
...     far that our habit of increase can no longer feed itself."'
>>> get_string_line $("The Age of Decreasing Numbers") 1
Civilization is a subset of nature even if we're not aware of it, and
>>> :redefine_func "The Age of Decreasing Numbers" ':string.output\
...    "With the housing crash, the falling dollar, and the decline in middle
...     class income, we're already tasting the coming age of numbers getting
...     smaller. Next: the stock market, easy credit, the GNP, energy
...     production, energy consumption, and human population."
>>> get_string_line $("The Age of Decreasing Numbers") 1
With the housing crash, the falling dollar, and the decline in middle
------------------------------------------
==========================================
/---

# ....................{ RENAMERS                           }....................
#FIXME: Rename to :callable.rename_prototype() and shift to a new callable
#parcel -- say, ={../callable}.

:func_ ':void :rename_runnable_prototype(
    ^:string prototype_name+__rrp, :string+nonempty runnable_name+__rrp)' :func{
    :string prototype__rrp

    # Value of such variable, hopefully signifying a runnable prototype.
    prototype__rrp="${(P)string_name__rrp}"

    # If such prototype is syntactically invalid, throw an exception.
    :is ${prototype__rrp} =~\
        ${ZESHY_CALLABLE_PROTOTYPE_NAME_SUFFIXED_PREFIXED_PCRE} :si :or :die\
        "Runnable prototype invalid or declares two or more runnable names:${ZESHY_ASCII_NEWLINE}${prototype__rrp}"

    # If either such name or prefixing and suffixing substrings were *NOT*
    # captured, throw an exception.
    (( ${#match} >= 3 )) :or :die\
        "Runnable name unparsable from prototype:${ZESHY_ASCII_NEWLINE}${prototype__rrp}"

    # Rename such prototype.
    :string.set\
        "${string_name__rrp}"\
        "${match[1]}${runnable_name__rrp}${match[3]}"
}:func <<'/---'
Rename the single runnable name declared by the value (i.e., runnable
prototype) of the passed string variable to the passed name. If such prototype
declares two or more names (e.g., via `{...,...}` syntax), an exception is
thrown. See :set_string_to_runnable_prototype_name() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
 # (e.g., due to zeshy regressions)
    # Localize arguments.
    # local func_name="${1}" func_body="${2}" func

    # Localize arguments.
    # :string func_prototype="${1}" func_body="${2}"

#FUXME: Define via ::func_.start() instead, as above.
#FUXME: Actually, this is a fairly horrid function. Excise entirely, replacing
#all current calls to such function with calls to :declare_func() instead..

    # die_unless_args_2 'Expected one string name and one runnable name.'
    # :is -n "${runnable_name__rrp}" :si or :die 'Runnable name empty.'

    # # If such variable is not a string, throw an exception. See
    # # :String.die_unless() for further details.
    # :is "${(tP)string_name__rrp-}" == 'scalar'* :si or :die\
    #     'String ${'${string_name__rrp}'} undefined or not a string.'

    # (( # == 2 )) || :die 'Expected one function name and one function body.'
    # [[ -n "${func_name}" ]] || :die 'Function name empty.'

    # :map func_attrs
    # :list func_names

    # # Parse the map of function attributes and list of function names declared
    # # from such prototype.
    # ::func_.start
    # :set_map,list_to_func_prototype_attrs,names\
    #     func_attrs func_names "${func_prototype}"

    # Declare such functions *AFTER* successfully defining such functions.
    # Since ::func_.stop() expects globals with the same name as
    # (presumably) previously defined by ::func_.start(), 
    # ::declare_func_prototype,attrs,names\
    #     "${func_prototype}" func_attrs func_names
    # print -r "func names: ${func_names[*]}"
    # print -r "func name: ${func_name__dfwpban}"

#FUXME: Wierd. Frankly, we should probably just shift such functionality to the
#prior prototype parcel at @{*-declare/*-set}; then, excise this parcel.
#FUXME: After excising this parcel, this entire tree @{*-func} should be
#renamed so as to be sourced *AFTER* all alias trees (e.g., after
#@{*-alias_block_dynamic}.

# Handle *runnable prototypes* (i.e., strings documenting function and alias
# signatures -- including attributes, return types, names, and argument types and
# order -- in a machine-readable format resembling that of conventional C
# function prototypes).

    # Rename such prototype. See :string.set() for further details.
    # :noop "${(P)string_name__rrp::=${match[1]}${runnable_name__rrp}${match[3]}}"

# ....................{ SETTERS                            }....................
# :func.document <<'/---'
# void :set_string_to_runnable_prototype_name(
#     string string_name, string runnable_prototype)
# 
# Set the passed string variable to the single runnable name declared by the
# passed *runnable prototype* (i.e., string documenting a function or alias
# signature -- including attributes, return types, names, and argument types and
# order -- in a machine-readable format resembling that of conventional C
# function prototypes). If such prototype declares two or more names (e.g., via
# `{...,...}` syntax), an exception is thrown.
# /---
# function :set_string_to_runnable_prototype_name() {
#     # Validate sanity.
#     die_unless_args_2 'Expected one string name and one runnable prototype.'
#     :string string_name__sstrpn="${1}" prototype__sstrpn="${2}"
#     :is -n "${prototype__sstrpn}" :si or :die 'Runnable prototype empty.'
# 
#     # If such variable is not a string, throw an exception. See
#     # :String.die_unless() for further details.
#     :is "${(tP)string_name__sstrpn-}" == 'scalar'* :si or :die\
#         'Variable ${'${string_name__sstrpn}'} undefined or not a string.'
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     :is "${prototype__sstrpn}" =~\
#         "${ZESHY_CALLABLE_PROTOTYPE_NAME_PCRE}" :si or :die\
#         'Runnable prototype "'${prototype__sstrpn}'" invalid or declares two or more runnable names.'
# 
#     # If such name was *NOT* captured into ${match[1]}, throw an exception.
#     (( ${#match} )) or :die\
#         'Runnable prototype "'${prototype__sstrpn}'" name uncaptured.'
# 
#     # If such name was captured but is empty, throw an exception. (While this
#     # *SHOULD* always be the case, forcibly guaranteeing this guards against
#     # silent-but-deadly PCRE regressions.)
#     :is -n "${match[1]}" :si or :die\
#         'Runnable prototype "'${prototype__sstrpn}'" name empty.'
# 
#     # Set such string to such name. See :string.set() for further
#     # details.
#     :noop "${(P)string_name__sstrpn::=${match[1]}}"
# }

# Set the passed string variable to the single runnable name matched with the
# passed PCRE from the passed *runnable prototype* (i.e., string documenting a
# 
# == Prototype PCRE ==
# 
# Such PCRE must capture only a single runnable name into the first match group
# (i.e., `${match[1]}`). While such PCRE may optionally match and capture
# additional prototype syntax, this function ignores all but such name.

    # die_unless_args_3\
    #     'Expected one string name, one runnable prototype, and one runnable prototype PCRE.'
    # :string\
    #     string_name__sstrpn="${1}"\
    #     prototype__sstrpn="${2}"\
    #     prototype_pcre__sstrpn="${3}"
    # :is -n "${prototype__sstrpn}" :si or :die\
    #     'Runnable prototype empty.'
    # :is -n "${prototype_pcre__sstrpn}" :si or :die\
    #     'Runnable prototype PCRE empty.'

#FUXME: Implement :func.set_prototype_name().
#FUXME: Implement :alias_prototype.set_name().
#, string runnable_prototype_pcre

# Else, capture such name.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :func.set_prototype_name().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
