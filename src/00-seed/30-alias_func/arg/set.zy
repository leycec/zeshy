#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *argument option setters* (i.e., functions setting variables
corresponding to `-`-prefixed arguments passed to functions and scripts).
/---

#FIXME: Declare all functions defined below with :func_() syntax.
#Function documentation should simply refer to the corresponding alias.

# ....................{ SETTERS                            }....................
#FIXME: Add example.

:alias_command ':void :args.set(*:str args)'\
    'set --' <<'/---'
Set the current argument list to the list of zero or more passed arguments.

If no arguments are passed, the current argument list will be cleared; in that
case, note that :args.clear() more readably achieves the same effect.

== Examples ==

.:args.set()
==========================================
[source]
------------------------------------------
>>> :str on_superiority1=\
... "Your Honor, years ago I recognized my kinship with all living beings, and"
>>> :str on_superiority2=\
... "I made up my mind that I was not one bit better than the meanest on earth."
>>> :str on_commonality1=\
... "I said then, and I say now, that while there is a lower class, I am in it,"
>>> :str on_commonality2=\
... "and while there is a criminal element I am of it, and while there is a
...  soul in prison, I am not free."
>>> :func_ ':void :args.munge()' :func{
...     :str.output "${2}"
...     :args.set "${on_commonality1}" "${on_commonality2}"
...     :str.output "${2}"
... }:func
>>> :args.munge "${on_superiority1}" "${on_superiority2}"
I made up my mind that I was not one bit better than the meanest on earth.
and while there is a criminal element I am of it, and while there is a
soul in prison, I am not free.
------------------------------------------
==========================================
/---

#FIXME: Add example.
:alias_command ':void :args.clear()'\
    'argv=()' <<'/---'
Clear the current argument list.
/---

# ....................{ SETTERS ~ index                    }....................
:alias_command ':void ":Arg_index.==_first"(
    :Int int_name :str arg)'\
    '::Arg_index.==_first "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) equaling the passed
string if any _or_ throw an exception otherwise (i.e., if no such argument was
passed by the caller).
/---

:alias_command '[status=:bool] ":Arg_index.==_first_if_found"(
    :Int int_name :str arg)'\
    '::Arg_index.==_first_if_found "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) equaling the passed
string if any _or_ report failure otherwise (i.e., if no such argument was
passed by the caller).
/---

:func_ '<var_name_suffix="__aief"> :void "::Arg_index.==_first"(
    *:str args :Int Int_name :str arg)' :func{
    :List_index.^=_first "${Int_name__aief}" args__aief "${arg__aief}"
}:func <<'/---'
Set the passed integer variable to the 1-based index of the first argument in
the passed argument list equaling the passed string if any or throw an
exception otherwise (i.e., if no such argument exists).

This private setter is intended to be called _only_ by :Arg_index.==_first().
/---

:func_ '<var_name_suffix="__aiefif">
    [status=:bool] ::Arg_index.==_first_if_found(
        *:str args :Int Int_name :str arg)' :func{
    :List_index.^=_first_if_found\
        "${Int_name__aiefif}" args__aiefif "${arg__aiefif}"
}:func <<'/---'
Set the passed integer variable to the 1-based index of the first argument in
the passed argument list equaling the passed string if any or report failure
otherwise (i.e., if no such argument exists).

This private setter is intended to be called _only_ by
:Arg_index.==_first_if_found().
/---

# ....................{ ALIASES ~ glob                     }....................
# Declare aliases for corresponding functions declared below *BEFORE* defining
# such functions, ensuring such aliases exist at function definition time. Do
# so only for the subset of such functions incestuously calling each other.
#
# Declare aliases for corresponding glob functions declared below (and hence
# prefixed by "noglob" here) *BEFORE* defining such functions, as above.

#FIXME: Add examples.
:alias_command ':void :Arg_index.^=_first(:Int int_name :str/:glob glob)'\
    'noglob :Arg_index.^=_first "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) matching the passed
glob if any _or_ throw an exception otherwise (i.e., if no such argument
matches).

== See Also ==

* :Arg_index.^=_first_if_found().
/---

function :Arg_index.^=_first() {
    # Ideally, this function would simply defer to function
    # :Arg_index.^=_first_if_found(). Unfortunately,
    # since zsh expands aliases prior to calling functions, doing so would
    # require temporarily disabling the alias of the same name before calling
    # such function, calling such function, and then reenabling such alias.
    #
    # In short, it's more unreliable trouble than its worth. Instead, simply
    # reimplement :Arg_index.^=_first_if_found().
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one glob.'
    :str int_name__sitaifmg=${@[-2]} glob__sitaifmg=${@[-1]}
    :list args__sitaifmg
    pop_args_2
          arg_index__sitaifmg=${@[(i)${~glob__sitaifmg}]}
    if (( arg_index__sitaifmg <= ${#} )) {
        :Int.set "${int_name__sitaifmg}" "${arg_index__sitaifmg}"
    #FIXME: Should probably simply call a new function
    #:arg.die_unless_matches_glob().
    # See die_unless_list_item_matches_glob().
    } else {
        :die 'Argument list item matching "'${glob}'" not found.'
    }
}

:alias_command '[status=:bool] :Arg_index.^=_first_if_found(
    :Int int_name :str/:glob glob)'\
    'noglob :Arg_index.^=_first_if_found "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) matching the passed
glob if any or report failure otherwise (i.e., if no such argument matches).
/---

function :Arg_index.^=_first_if_found() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :Arg_index.^=_first().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one glob.'
    :str int_name__sitaifmg=${@[-2]} glob__sitaifmg=${@[-1]}
    :int arg_index__sitaifmg
    pop_args_2

    # Set such index if found or report failure. Ideally, we would simply call
    # :List_index.^=_first_if_found() here.
    # Unfortunately, since all functions implicitly locally define lists ${@}
    # and ${argv}, neither such list may be passed to such function as is.
    # Instead, we would need to explicitly copy either such list into a list
    # local guaranteed to be unique to this function (e.g.,
    # 'args__sitaifmg=( "${@}" )'). Since such copy imposes undue overhead in
    # the event of both large argument lists and arguments, avoid such copy by
    # implementing such function locally. See such function for further details.
       arg_index__sitaifmg="${@[(i)${~glob__sitaifmg}]}"
    (( arg_index__sitaifmg <= ${#} )) and :Int.set\
        "${int_name__sitaifmg}" "${arg_index__sitaifmg}"
}

# ....................{ ALIASES ~ option                   }....................
:alias_command ':void :Arg_option_last_index(:Int int_name)'\
    ':Arg_option_last_index "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the last *option
argument* (i.e., argument prefixed by `-`) the caller passed or 0 if no such
argument was passed.  See :Arg_nonoption_first_index() for
further details.
/---

function :Arg_option_last_index() {
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :str int_name___sitaoil="${@[-1]}"
    :int nonoption_index_first__sitaoil placeholder__sitaoil
    :Int.die_unless "${int_name__sitaoil}"
    pop_arg

    # Get the index of the first non-option argument. See
    # :Arg_nonoption_count() for further details.
    :Arg_nonoption_count,first_index\
        placeholder__sitaoil nonoption_index_first__sitaoil

    # Set the index of the last option argument.
    :Int.set "${int_name__sitaoil}" $(( nonoption_index_first__sitaoil - 1 ))
}

# ....................{ ALIASES ~ nonoption                }....................
:alias_command ':void :Arg_nonoption_count(:Int int_name)'\
    ':Arg_nonoption_count "${@}"' <<'/---'
Set the passed integer variable to the number of *non-options arguments* (i.e.,
arguments _not_ prefixed by `-`) the caller passed. See
:Arg_nonoption_first_index() for further details.
/---

function :Arg_nonoption_count() {
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :str int_name__sitanc="${@[-1]}"
    :int placeholder__sitanc
    :Int.die_unless "${int_name__sitanc}"
    pop_arg

    # Defer to the function below, discarding the value of the second integer
    # variable passed to such function. Since the implementation of such
    # function is somewhat nontrivial, this provides a somewhat "cleaner"
    # solution than reimplementing such function.
    :Arg_nonoption_count,first_index\
        "${int_name__sitanc}" placeholder__sitanc
}

:alias_command ':void :Arg_nonoption_first_index(:Int int_name)'\
    ':Arg_nonoption_first_index "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first *non-option
argument* (i.e., argument _not_ prefixed by `-`) the caller passed.

== Implementation ==

Specifically, set such variable to:

* If the caller passed an argument equal to `-` or `--`, one greater than the
  index of such argument. By POSIX design, such arguments prematurely terminate
  option arguments.
* Else if the caller passed at least one argument _not_ prefixed by `-`, the
  index of the first such argument.
* Else, one greater than the number of arguments the caller passed. This
  corresponds to default `zsh` behavior for builtin list index modifiers `(i)`
  and `(I)`.
/---

function :Arg_nonoption_first_index() {
    # See :Arg_nonoption_count().
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :str int_name__sitanif="${@[-1]}"
    :int placeholder__sitanif
    :Int.die_unless "${int_name__sitanif}"
    pop_arg
    :Arg_nonoption_count,first_index\
        placeholder__sitanif "${int_name__sitanif}"
}

:alias_command ':void :Arg_nonoption_count,first_index(
    :Int int_name_count :Int int_name_index_first)'\
    ':Arg_nonoption_count,first_index "${@}"' <<'/---'
Set the first passed integer variable to the number of *non-option arguments*
(i.e., arguments _not_ prefixed by `-`) the caller passed and the second passed
integer to the 1-based index of the first such argument.

== See Also ==

* :Arg_nonoption_count().
* :Arg_nonoption_first_index().
/---

function :Arg_nonoption_count,first_index() {
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one argument count integer name, and one argument index integer name.'
    :str\
        int_name_count__sitancaif="${@[-2]}"\
        int_name_index_first__sitancaif="${@[-1]}"
    :int index_first__sitancaif
#   print "count: ${int_name_count__sitancaif}\nindex_first: ${int_name_index_first__sitancaif}"
    pop_args_2

    # If such arguments contain "-" or "--", such index is one after the index
    # of such argument.
    index_first__sitancaif="${@[(i)-|--]}"
    if (( index_first__sitancaif <= # )) {
          index_first__sitancaif+=1
    # Else, such index is the index of the first argument *NOT* prefixed by "-"
    # if such argument exists or the number of such arguments otherwise.
    } else {
        index_first__sitancaif="${@[(i)[^-]*]}"
    }

    # Set such integers.
    :Int.set "${int_name_count__sitancaif}"\
        $(( # - index_first__sitancaif + 1 ))
    :Int.set "${int_name_index_first__sitancaif}" ${index_first__sitancaif}
#   print "arg count: ${#}"
#   print "arg nonoption first index \"${int_name_index__sitancaif}\": ${(P)int_name_index__sitancaif}"
#   print "arg nonoption count: $(( # - ${(P)int_name_index__sitancaif} + 1 ))"
#   print "count integer name: ${int_name_count__sitancaif}"
}

#FIXME: In lieu of unit tests...
#function tyam() {
#    integer count index_first index_last
#    :Arg_nonoption_count,first_index count index_first
#    :Arg_option_last_index index_last
#    print "args: ${*}\narg nonoption count: ${count}\narg nonoption first index: ${index_first}\narg option last index: ${index_last}\n"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}

# ....................{ SETTERS ~ map                      }....................
#FIXME: zparseopts() documentation is rather... dense. It'd be helpful to
#synopsize the most commonly used option specifications syntax in documentation
#below.
#FIXME: Fix example below.
#FIXME: *UGH!* Passing a placeholder argument was utterly stupid. No, really.
#It's exceptionally fragile and totally unneeded. Why? Because we *KNOW*
#exactly how many arguments were passed in that alias. So, guess what? Just
#pass that number as the first argument *BEFORE* passing the actual arguments:
#
#    ':Arg_options,nonoptions.parse_specs_or_warn ${#} "${@}"'
#
#Yes, folks. It *REALLY* was that easy. Refactor this, please. *sigh*

# Function :Arg_options,nonoptions.parse_specs_or_warn() accepts a variable
# number of both arguments and options specifications. Differentiating between
# the two requires the alias expanding such function append a placeholder after
# the passed arguments, which such function then searches for. 

:alias_command '[stdout=:str status=:bool]
    :Arg_options,nonoptions.parse_specs_or_warn(
        :Map arg_options_map_name
        :List arg_nonoptions_list_name
        +:str option_specs
        :str help_message)'\
    ':Arg_options,nonoptions.parse_specs_or_warn "${@}" "${ZY_ASCII_PLACEHOLDER}"' <<'/---'
Set the passed map to all *options* (i.e., arguments prefixed by `-`) in the
current argument list and the passed list to all *non-options* (i.e., arguments
_not_ prefixed by `-`) in the current argument list if all options are valid
for the passed zparseopts()-formatted options specifications _or_ print the
passed help message and report failure otherwise.

For safety, the current argument list remains unmodified.

== Map Options ==

For each unique option in the current argument list (e.g.,
`--thoughtcrime="is death"`), this function adds a corresponding key-value pair
to the passed map such that such key is the option name including `-` or `--`
prefix (e.g., `--thoughtcrime`) and such value the option value excluding
separating `=` or whitespace if the caller defined such a value or the empty
string otherwise.

For convenience, this function silently defines zparseopts()-formatted options
specifications for options `-h` and `--help` if _not_ defined by the passed
specifications.

== See Also ==

* `info zsh[i][zparseopts]` for further details on options specifications.

== Examples ==

.:Arg_options,nonoptions.parse_specs_or_warn()
==========================================
[source]
------------------------------------------
# Set command-line arguments.
>>> :args.set -d --ad --alive 42 "glass_arm.shattering"

# Parse such arguments.
>>> map arg_options
>>> set_map_to_arg_options_with_help_from 'arg_options d e -ad -or: -alive:: "
Usage: doa [OPTION]... [FILE]...

Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.

Options:
  -h, --help          print this help text and exit
  -d                  return non-zero exit status if such files fail to run
  -e                  evaluate rather than run the passed files
  --ad                switch from a Julian to Gregorian calendar
  --or DEATHS         set the maximum number of DEATHS
  --alive [LIVES]     set the starting number of LIVES (default: 3)
"'

# Check parsed options.
>>> :str.output "option \"--alive\": ${arg_options[--alive]}"
option "--alive": 42
>>> :map.is_key arg_options "-d" and print "option \"-d\": enabled"
option "-d": enabled
------------------------------------------
==========================================

/---
function :Arg_options,nonoptions.parse_specs_or_warn() {
    # Validate sanity.
    die_unless_args_4_or_more\
        "Expected zero or more arguments, one map name, one list name, one or more option specifiers, and one help string."
    :str\
        map_name__smtaowhf\
        list_name__smtaowhf\
        help_message__smtaowhf\
    :int index_arg_last_plus_one__smtaowhf
    :list option_specs__smtaowhf

    # Index one after that of the last argument in the caller's argument list.
    set_integer_to_arg_index_first_equaling\
        index_arg_last_plus_one__smtaowhf "${ZY_ASCII_PLACEHOLDER}"

    # Localize all passed variables following such index.
    map_name__smtaowhf="${@[      index_arg_last_plus_one__smtaowhf + 1]}"
    list_name__smtaowhf="${@[     index_arg_last_plus_one__smtaowhf + 2]}"
    option_specs__smtaowhf=( "${@[index_arg_last_plus_one__smtaowhf + 3,-2]}" )
    help_message__smtaowhf="${@[-1]}"

    # Validate such variables.
    :Map.die_unless "${map_name__smtaowhf}"
    :List.die_unless "${list_name__smtaowhf}"

    # Reduce the current argument list to the caller's argument list. See
    # :args.pop() for further details.
    argv[${index_arg_last_plus_one__smtaowhf},-1]=()

    #FIXME: Actually test whether or not such specifications are already passed.

    # Add options specifications for options `-h` and `--help` if *NOT* defined
    # by the passed specifications.
    option_specs__smtaowhf+=( 'h' '-help=h' )

    #FIXME: We should probably also pass option "-K":
    #
    # -K
    #     With this option, the arrays specified with the -a and -A
    #     options and with the `=ARRAY' forms are kept unchanged when
    #     none of the SPECS for them is used.  This allows assignment
    #     of default values to them before calling zparseopts.

    # Set such map by parsing options via the passed (and canonical help) option
    # specifications, preserving unparsed options for subsequent parsing by the
    # caller. If such parsing fails, print the passed help text and return from
    # the caller or script with non-zero exit status. Dismantled, this is:
    #
    # * "-D", removing *ONLY* parsed options from the current argument list.
    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
    #   option specification, thus ignoring all unspecified options.
    # * "-M", parsing "="-prefixed substrings in option specifications as the
    #   map key to parse such option into (e.g., "-help=h" parses long option
    #   "--help" into map key ${arg_options[-h]} rather than
    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
    #   target list or map name to parse such option into.
    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
    #   either the option values if passed or the empty string if not passed.
    zparseopts -M -D -E -A "${map_name__smtaowhf}" --\
        "${option_specs__smtaowhf[@]}" :or {
        #FIXME: Unsurprisingly, this looks completely awkward. Contemplate.
        print_warning 'Invalid command-line argument(s).'
        :str.output "${help_message__smtaowhf}"
        :failure.report
    }

    # Set the list to all unparsed arguments.
    list_name__smtaowhf=( "${@}" )
}
