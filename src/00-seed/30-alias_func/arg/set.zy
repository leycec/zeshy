#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *argument option setters* (i.e., functions setting variables
corresponding to `-`-prefixed arguments passed to functions and scripts).
/---

#FIXME: Declare all functions defined below with :func_() syntax.
#Function documentation should simply refer to the corresponding alias.

# ....................{ SETTERS                            }....................
#FIXME: Add example.

:alias_command ':void :args.set(*:str args)'\
    'set --' <<'/---'
Set the current argument list to the list of zero or more passed arguments.

If no arguments are passed, the current argument list will be cleared; in that
case, note that :args.clear() more readably achieves the same effect.

== Examples ==

.:args.set()
==========================================
[source]
------------------------------------------
>>> :str on_superiority1=\
... "Your Honor, years ago I recognized my kinship with all living beings, and"
>>> :str on_superiority2=\
... "I made up my mind that I was not one bit better than the meanest on earth."
>>> :str on_commonality1=\
... "I said then, and I say now, that while there is a lower class, I am in it,"
>>> :str on_commonality2=\
... "and while there is a criminal element I am of it, and while there is a
...  soul in prison, I am not free."
>>> :func_ ':void :args.munge()' :func{
...     :str.output "${2}"
...     :args.set "${on_commonality1}" "${on_commonality2}"
...     :str.output "${2}"
... }:func
>>> :args.munge "${on_superiority1}" "${on_superiority2}"
I made up my mind that I was not one bit better than the meanest on earth.
and while there is a criminal element I am of it, and while there is a
soul in prison, I am not free.
------------------------------------------
==========================================
/---

#FIXME: Add example.
:alias_command ':void :args.clear()'\
    'argv=()' <<'/---'
Clear the current argument list.
/---

# ....................{ SETTERS ~ index                    }....................
:alias_command ':void ":Arg_index.==_first"(
    :Int int_name :str arg)'\
    '::Arg_index.==_first "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) equaling the passed
string if any _or_ throw an exception otherwise (i.e., if no such argument was
passed by the caller).
/---

:alias_command '[status=:bool] ":Arg_index.==_first_if_found"(
    :Int int_name :str arg)'\
    '::Arg_index.==_first_if_found "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) equaling the passed
string if any _or_ report failure otherwise (i.e., if no such argument was
passed by the caller).
/---

:func_ '<var_name_suffix="__aief"> :void "::Arg_index.==_first"(
    *:str args :Int Int_name :str arg)' :func{
    set_integer_to_list_index_first_matching_glob\
        "${Int_name__aief}" args__aief "${arg__aief}"
}:func <<'/---'
Set the passed integer variable to the 1-based index of the first argument in
the passed argument list equaling the passed string if any or throw an
exception otherwise (i.e., if no such argument exists).

This private setter is intended to be called _only_ by :Arg_index.==_first().
/---

:func_ '<var_name_suffix="__aiefif">
    [status=:bool] ::Arg_index.==_first_if_found(
        *:str args :Int Int_name :str arg)' :func{
    set_integer_to_list_index_first_matching_glob_if_found\
        "${Int_name__aiefif}" args__aiefif "${arg__aiefif}"
}:func <<'/---'
Set the passed integer variable to the 1-based index of the first argument in
the passed argument list equaling the passed string if any or report failure
otherwise (i.e., if no such argument exists).

This private setter is intended to be called _only_ by
:Arg_index.==_first_if_found().
/---

# ....................{ ALIASES ~ glob                     }....................
# Declare aliases for corresponding functions declared below *BEFORE* defining
# such functions, ensuring such aliases exist at function definition time. Do
# so only for the subset of such functions incestuously calling each other.
#
# Declare aliases for corresponding glob functions declared below (and hence
# prefixed by "noglob" here) *BEFORE* defining such functions, as above.

#FIXME: Add examples.
:alias_command ':void set_integer_to_arg_index_first_matching_glob(
    ^:int int_name, :str/glob glob)'\
    'noglob set_integer_to_arg_index_first_matching_glob "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) matching the passed
glob if any or throw an exception otherwise (i.e., if no such argument
matches). See set_integer_to_arg_index_first_matching_glob_if_found().
/---

:alias_command '[status = :bool] set_integer_to_arg_index_first_matching_glob_if_found(
    ^:int int_name, :str/glob glob)'\
    'noglob set_integer_to_arg_index_first_matching_glob_if_found "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first argument
passed by the caller (to the current function or script) matching the passed
glob if any or report failure otherwise (i.e., if no such argument matches).
/---

# ....................{ ALIASES ~ option                   }....................
:alias_command ':void set_integer_to_arg_option_index_last(
    :str:int int_name)'\
    'set_integer_to_arg_option_index_last "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the last *option
argument* (i.e., argument prefixed by `-`) the caller passed or 0 if no such
argument was passed.  See set_integer_to_arg_nonoption_index_first() for
further details.
/---

# ....................{ ALIASES ~ nonoption                }....................
:alias_command ':void :Arg_count_nonoption(
    :str:int int_name)'\
    ':Arg_count_nonoption "${@}"' <<'/---'
Set the passed integer variable to the number of *non-options arguments* (i.e.,
arguments _not_ prefixed by `-`) the caller passed. See
set_integer_to_arg_nonoption_index_first() for further details.
/---

:alias_command ':void set_integer_to_arg_nonoption_index_first(
    :str:int int_name)'\
    'set_integer_to_arg_nonoption_index_first "${@}"' <<'/---'
Set the passed integer variable to the 1-based index of the first *non-option
argument* (i.e., argument _not_ prefixed by `-`) the caller passed.

== Implementation ==

Specifically, set such variable to:

* If the caller passed an argument equal to `-` or `--`, one greater than the
  index of such argument. By POSIX design, such arguments prematurely terminate
  option arguments.
* Else if the caller passed at least one argument _not_ prefixed by `-`, the
  index of the first such argument.
* Else, one greater than the number of arguments the caller passed. This
  corresponds to default `zsh` behavior for builtin list index modifiers `(i)`
  and `(I)`.
/---

:alias_command ':void set_integers_to_arg_nonoption_count_and_index_first(
    :str:int int_name_count,
    :str:int int_name_index_first)'\
    'set_integers_to_arg_nonoption_count_and_index_first "${@}"' <<'/---'
Set the first passed integer variable to the number of *non-option arguments*
(i.e., arguments _not_ prefixed by `-`) the caller passed and the second passed
integer to the 1-based index of the first such argument. See
:Arg_count_nonoption() and
set_integer_to_arg_nonoption_index_first() for further details.
/---

# ....................{ SETTERS ~ glob                     }....................
function set_integer_to_arg_index_first_matching_glob() {
    # Ideally, this function would simply defer to function
    # set_integer_to_arg_index_first_matching_glob_if_found(). Unfortunately,
    # since zsh expands aliases prior to calling functions, doing so would
    # require temporarily disabling the alias of the same name before calling
    # such function, calling such function, and then reenabling such alias.
    #
    # In short, it's more unreliable trouble than its worth. Instead, simply
    # reimplement set_integer_to_arg_index_first_matching_glob_if_found().
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one glob.'
    :str int_name__sitaifmg="${@[-2]}" glob__sitaifmg="${@[-1]}"
    :list args__sitaifmg
    pop_args_2
          arg_index__sitaifmg="${@[(i)${~glob__sitaifmg}]}"
    if (( arg_index__sitaifmg <= ${#} )) {
        :Int.set\
            "${int_name__sitaifmg}" "${arg_index__sitaifmg}"
    #FIXME: Should probably simply call a new function
    #:arg.die_unless_matches_glob().
    # See die_unless_list_item_matches_glob().
    } else {
        :die 'Argument list item matching "'${glob}'" not found.'
    }
}

function set_integer_to_arg_index_first_matching_glob_if_found() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_integer_to_arg_index_first_matching_glob().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one glob.'
    :str int_name__sitaifmg="${@[-2]}" glob__sitaifmg="${@[-1]}"
    :int arg_index__sitaifmg
    pop_args_2

    # Set such index if found or report failure. Ideally, we would simply call
    # set_integer_to_list_index_first_matching_glob_if_found() here.
    # Unfortunately, since all functions implicitly locally define lists ${@}
    # and ${argv}, neither such list may be passed to such function as is.
    # Instead, we would need to explicitly copy either such list into a list
    # local guaranteed to be unique to this function (e.g.,
    # 'args__sitaifmg=( "${@}" )'). Since such copy imposes undue overhead in
    # the event of both large argument lists and arguments, avoid such copy by
    # implementing such function locally. See such function for further details.
       arg_index__sitaifmg="${@[(i)${~glob__sitaifmg}]}"
    (( arg_index__sitaifmg <= ${#} )) and :Int.set\
        "${int_name__sitaifmg}" "${arg_index__sitaifmg}"
}

# ....................{ SETTERS ~ option                   }....................
function set_integer_to_arg_option_index_last() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :str int_name___sitaoil="${@[-1]}"
    :int nonoption_index_first__sitaoil placeholder__sitaoil
    :Int.die_unless "${int_name__sitaoil}"
    pop_arg

    # Get the index of the first non-option argument. See
    # :Arg_count_nonoption() for further details.
    set_integers_to_arg_nonoption_count_and_index_first\
        placeholder__sitaoil nonoption_index_first__sitaoil

    # Set the index of the last option argument.
    :Int.set "${int_name__sitaoil}"\
        $(( nonoption_index_first__sitaoil - 1 ))
}

# ....................{ SETTERS ~ nonoption                }....................
function :Arg_count_nonoption() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :str int_name__sitanc="${@[-1]}"
    :int placeholder__sitanc
    :Int.die_unless "${int_name__sitanc}"
    pop_arg

    # Defer to the function below, discarding the value of the second integer
    # variable passed to such function. Since the implementation of such
    # function is somewhat nontrivial, this provides a somewhat "cleaner"
    # solution than reimplementing such function.
    set_integers_to_arg_nonoption_count_and_index_first\
        "${int_name__sitanc}" placeholder__sitanc
}

function set_integer_to_arg_nonoption_index_first() {
    # See :Arg_count_nonoption() for further details.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :str int_name__sitanif="${@[-1]}"
    :int placeholder__sitanif
    :Int.die_unless "${int_name__sitanif}"
    pop_arg
    set_integers_to_arg_nonoption_count_and_index_first\
        placeholder__sitanif "${int_name__sitanif}"
}

function set_integers_to_arg_nonoption_count_and_index_first() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one argument count integer name, and one argument index integer name.'
    :str\
        int_name_count__sitancaif="${@[-2]}"\
        int_name_index_first__sitancaif="${@[-1]}"
    :int index_first__sitancaif
#   print "count: ${int_name_count__sitancaif}\nindex_first: ${int_name_index_first__sitancaif}"
    pop_args_2

    # If such arguments contain "-" or "--", such index is one after the index
    # of such argument.
    index_first__sitancaif="${@[(i)-|--]}"
    if (( index_first__sitancaif <= # )) {
          index_first__sitancaif+=1
    # Else, such index is the index of the first argument *NOT* prefixed by "-"
    # if such argument exists or the number of such arguments otherwise.
    } else {
        index_first__sitancaif="${@[(i)[^-]*]}"
    }

    # Set such integers.
    :Int.set "${int_name_count__sitancaif}"\
        $(( # - index_first__sitancaif + 1 ))
    :Int.set "${int_name_index_first__sitancaif}"\
        ${index_first__sitancaif}
#   print "arg count: ${#}"
#   print "arg nonoption first index \"${int_name_index__sitancaif}\": ${(P)int_name_index__sitancaif}"
#   print "arg nonoption count: $(( # - ${(P)int_name_index__sitancaif} + 1 ))"
#   print "count integer name: ${int_name_count__sitancaif}"
}

#FIXME: In lieu of unit tests...
#function tyam() {
#    integer count index_first index_last
#    set_integers_to_arg_nonoption_count_and_index_first count index_first
#    set_integer_to_arg_option_index_last index_last
#    print "args: ${*}\narg nonoption count: ${count}\narg nonoption first index: ${index_first}\narg option last index: ${index_last}\n"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}

# ....................{ SETTERS ~ map                      }....................
#FIXME: zparseopts() documentation is rather... dense. It'd be helpful to
#synopsize the most commonly used option specifications syntax in documentation
#below.
#FIXME: Fix example below.
#FIXME: *UGH!* Passing a placeholder argument was utterly stupid. No, really.
#It's exceptionally fragile and totally unneeded. Why? Because we *KNOW*
#exactly how many arguments were passed in such alias. So, guess what? Just
#pass such number as the first argument *BEFORE* passing such actual arguments:
#
#    'set_map_list_to_arg_options_nonoptions_with_help ${#} "${@}"'
#
#Yes, folks. It *REALLY* was that easy. Refactor this, please. *sigh*

# Function set_map_list_to_arg_options_nonoptions_with_help() accepts a variable
# number of both arguments and options specifications. Differentiating between
# the two requires the alias expanding such function append a placeholder after
# the passed arguments, which such function then searches for. 

:alias_command '[stdout = :str, status = :bool]
    set_map_list_to_arg_options_nonoptions_with_help(
        :str:map arg_options_map_name,
        :str:list arg_nonoptions_list_name,
        :str option_spec1, ...,
        :str help_message)'\
    'set_map_list_to_arg_options_nonoptions_with_help "${@}" "${ZY_ASCII_PLACEHOLDER}"' <<'/---'
Set the passed map to all *options* (i.e., arguments prefixed by `-`) in the
current argument list and the passed list to all *non-options* (i.e., arguments
_not_ prefixed by `-`) in the current argument list if such options are valid
under the passed zparseopts()-formatted options specifications _or_ print the
print the passed help message and report failure otherwise. For safety, the
current argument list remains unmodified. See `info zsh[i][zparseopts]` for
further details on options specifications: e.g.,

.set_map_list_to_arg_options_nonoptions_with_help()
==========================================
[source]
------------------------------------------
# Set command-line arguments.
>>> :args.set -d --ad --alive 42 "glass_arm.shattering"

# Parse such arguments.
>>> map arg_options
>>> set_map_to_arg_options_with_help_from 'arg_options d e -ad -or: -alive:: "
Usage: doa [OPTION]... [FILE]...

Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.

Options:
  -h, --help          print this help text and exit
  -d                  return non-zero exit status if such files fail to run
  -e                  evaluate rather than run the passed files
  --ad                switch from a Julian to Gregorian calendar
  --or DEATHS         set the maximum number of DEATHS
  --alive [LIVES]     set the starting number of LIVES (default: 3)
"'

# Check parsed options.
>>> :str.output "option \"--alive\": ${arg_options[--alive]}"
option "--alive": 42
>>> :map.is_key arg_options "-d" and print "option \"-d\": enabled"
option "-d": enabled
------------------------------------------
==========================================

== Map Options ==

For each unique option in the current argument list (e.g.,
`--thoughtcrime="is death"`), this function adds a corresponding key-value pair
to the passed map such that such key is the option name including `-` or `--`
prefix (e.g., `--thoughtcrime`) and such value the option value excluding
separating `=` or whitespace if the caller defined such a value or the empty
string otherwise.

For convenience, this function silently defines zparseopts()-formatted options
specifications for options `-h` and `--help` if _not_ defined by the passed
specifications.
/---
function set_map_list_to_arg_options_nonoptions_with_help() {
    # Validate sanity.
    die_unless_args_4_or_more\
        "Expected zero or more arguments, one map name, one list name, one or more option specifiers, and one help string."
    :str\
        map_name__smtaowhf\
        list_name__smtaowhf\
        help_message__smtaowhf\
    :int index_arg_last_plus_one__smtaowhf
    :list option_specs__smtaowhf

    # Index one after that of the last argument in the caller's argument list.
    set_integer_to_arg_index_first_equaling\
        index_arg_last_plus_one__smtaowhf "${ZY_ASCII_PLACEHOLDER}"

    # Localize all passed variables following such index.
    map_name__smtaowhf="${@[      index_arg_last_plus_one__smtaowhf + 1]}"
    list_name__smtaowhf="${@[     index_arg_last_plus_one__smtaowhf + 2]}"
    option_specs__smtaowhf=( "${@[index_arg_last_plus_one__smtaowhf + 3,-2]}" )
    help_message__smtaowhf="${@[-1]}"

    # Validate such variables.
    :Map.die_unless "${map_name__smtaowhf}"
    :List.die_unless "${list_name__smtaowhf}"

    # Reduce the current argument list to the caller's argument list. See
    # :args.pop() for further details.
    argv[${index_arg_last_plus_one__smtaowhf},-1]=()

    #FIXME: Actually test whether or not such specifications are already passed.

    # Add options specifications for options `-h` and `--help` if *NOT* defined
    # by the passed specifications.
    option_specs__smtaowhf+=( 'h' '-help=h' )

    #FIXME: We should probably also pass option "-K":
    #
    # -K
    #     With this option, the arrays specified with the -a and -A
    #     options and with the `=ARRAY' forms are kept unchanged when
    #     none of the SPECS for them is used.  This allows assignment
    #     of default values to them before calling zparseopts.

    # Set such map by parsing options via the passed (and canonical help) option
    # specifications, preserving unparsed options for subsequent parsing by the
    # caller. If such parsing fails, print the passed help text and return from
    # the caller or script with non-zero exit status. Dismantled, this is:
    #
    # * "-D", removing *ONLY* parsed options from the current argument list.
    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
    #   option specification, thus ignoring all unspecified options.
    # * "-M", parsing "="-prefixed substrings in option specifications as the
    #   map key to parse such option into (e.g., "-help=h" parses long option
    #   "--help" into map key ${arg_options[-h]} rather than
    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
    #   target list or map name to parse such option into.
    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
    #   either the option values if passed or the empty string if not passed.
    zparseopts -M -D -E -A "${map_name__smtaowhf}" --\
        "${option_specs__smtaowhf[@]}" or {
        #FIXME: Unsurprisingly, this looks completely awkward. Contemplate.
        print_warning 'Invalid command-line argument(s).'
        :str.output "${help_message__smtaowhf}"
        :failure.report
    }

    # Set such list to all unparsed arguments.
    list_name__smtaowhf=( "${@}" )
}

# --------------------( WASTELANDS                         )--------------------
# function set_integer_to_arg_index_first_equaling_if_found() {
#     die_unless_args_2_or_more\
#         'Expected zero or more arguments, one integer name, and one string.'
#     #FUXME: Clearly broken. Correct, please!
#     set_integer_to_list_index_first_matching_glob_if_found\
#         "${@[-2]}" args__sitaifeif "${@[-1]}"
# }

# <is_args_unhandled> 

#FUXME: Correct me!
# :alias_command ':void set_integer_to_arg_index_first_equaling_item(
#     :str arg, ^:int int_name)'\
#     'set_integer_to_arg_index_first_equaling_item "${@}"' <<'/---'
# Document me.
# /---

# :alias_command '[status = :bool] :arg.set_index_to_first_if_found(
#     :str arg, ^:int int_name)'\
#     'set_integer_to_arg_index_first_equaling_item "${@}"' <<'/---'

#FUXME: Uhm; *WHAT* alias? There appears to be *NO* such alias defined below.
#What's going on here? Fairly certain the alias defined below should be
#refactored to fit the alias prototype declared here.

#FUXME: Terrible. Refactor using the standard method above of passing the entire
#argument list to a function of the same. In this case, however, doing so will
#somewhat change the calling semantics. Rather than this alias removing all
#parsed arguments from the current argument list, such list will be unchanged.
#Arguably, the latter behavior coincides much better with "setter_"
#nomenclature. If removing all parsed arguments from the current argument list
#is still desired, callers may do so by simply differencing the...
#FUXME: O.K.; perhaps not. To preserve such functionality, this function should
#probably be refactored as follows:
#
#    void set_map_list_to_arg_options_nonoptions_with_help(
#        string arg_options_map_name,
#        string arg_nonoptions_list_name,
#        string option_spec1?, ...,
#        string help_message)
#
#Hence, such function sets a passed map to argument options and a passed list to
#argument non-options. It does so by simply copying the current argument list to
#the latter list *AFTER* calling zparseopts(). Tada!

    #FUXME: To implement this, we'll need to pass something highly unlikely will
    #ever be passed as a real argument -- say,
    #"${ZY_ASCII_PLACEHOLDER}" -- and then parse
    #that below, denoting the end of the passed argument list. *shrug*

#    list args__sitaifmg
#    pop_args_2
#
#    #FUXME: Absurdly inefficient, though it works. Optimize sanely.
#    # Copy the passed argument list into a local list. The function below
#    # requires a list name *NOT* conflicting with local variable names.
#    args__sitaifmg=( "${@}" )
#
#    # Set such integer.
#    set_integer_to_list_index_first_matching_glob_if_found\
#        "${int_name__sitaifmg}" args__sitaifmg "${glob__sitaifmg}"

# Note: the corresponding aliases are declared above.

#FUXME: As the nomenclature below demonstrates, suffixing alias names by "_for"
#rather than "_from" for aliases accepting multiple arguments in a single string
#produces a more legible calling convention. Change "_from" to "_for"
#everywhere, please.

    #FUXME: Clearly, this no longer works. As this function is now (rightly!) a
    #function, the caller must implement such functionality. Which is probably a
    #good thing, honestly. Correct documentation above, if necessary.
# If the current argument list contains either such option (i.e.,
#the caller passed such options), this function prints the passed help message
#and reports success: e.g.,

    # If passed a help option, ignore all other options, print the passed help
    # text, and return from the caller function or script.
#   if { :map.is_key "${map_name__smtaowhf}" "-h" } {
#       :str.output "${args__smtaowhf}"
#   }

#FUXME: O.K.; all of the below are fairly horrible. Reimplement as proper
#functions by passing the argument list from an alias to function of the same
#name. This should also allow us to eliminate the absurd "_from" syntax below,
#which is *ABSOLUTELY ESSENTIAL* (because it's horrible). Look: any function
#incurring the cost of expanding such aliases can certainly afford the
#negligible cost of passing their argument list to another function for testing.
#Make it so, please.

#:alias_command <<'/---'
#void set_map_to_arg_options_with_help_from(
#    string map_name,
#    string option_spec1, ...,
#    string help_message)
#
#Parse and remove `-`-prefixed options from the current argument list via the
#passed zparseopts()-formatted options specifications into the passed map.
#Preserve all other arguments in the current argument list for subsequent parsing
#by the caller. Due to `zsh` constraints, arguments must be passed
#whitespace-delimited in a single shell word (e.g., single- or double-quoted
#string). See `info zsh[i][zparseopts]` for further details on the format for
#options specifications.
#
#Parse options `-h` and `--help` by printing the passed help message and
#returning from the caller function or script with zero exit status. If parsing
#fails, also print such message but return with nonzero exit status: e.g.,
#
#.set_map_to_arg_options_with_help_from()
#==========================================
#[source]
#------------------------------------------
## Set command-line arguments.
#>>> :args.set -d --ad --alive 42 "glass_arm.shattering"
#
## Parse such arguments.
#>>> map arg_options
#>>> set_map_to_arg_options_with_help_from 'arg_options d e -ad -or: -alive:: "
#Usage: doa [OPTION]... [FILE]...
#
#Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.
#
#Options:
#  -h, --help          print this help text and exit
#  -d                  return non-zero exit status if such files fail to run
#  -e                  evaluate rather than run the passed files
#  --ad                switch from a Julian to Gregorian calendar
#  --or DEATHS         set the maximum number of DEATHS
#  --alive [LIVES]     set the starting number of LIVES (default: 3)
#"'
#
## Check parsed options.
#>>> :str.output "option \"--alive\": ${arg_options[--alive]}"
#option "--alive": 42
#>>> :map.is_key arg_options "-d" and print "option \"-d\": enabled"
#option "-d": enabled
#------------------------------------------
#==========================================
#/---
#alias set_map_to_arg_options_with_help_from='{
#    # Validate sanity.
#    list  args__smtaowhf; set_list_to_stdin_words args__smtaowhf
#    (( ${#args__smtaowhf} >= 3 )) ||
#        :die "Expected one map name, one or more option specifiers, and one help string."
#    string\
#        map_name__smtaowhf="${args__smtaowhf[1]}"\
#        help_message__smtaowhf="${args__smtaowhf[-1]}"
#    :Map.die_unless "${map_name__smtaowhf}"
#
#    # Remove the first and last passed argument having parsed such arguments.
#    shift_list args__smtaowhf
#    pop_list   args__smtaowhf
#
#    # Parse options under the passed (and canonical help) option specifications,
#    # preserving unparsed options for subsequent parsing by the caller. If such
#    # parsing fails, print the passed help text and return from the caller or
#    # script with non-zero exit status. Dismantled, this is:
#    #
#    # * "-D", removing *ONLY* parsed options from the current argument list.
#    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
#    #   option specification, thus preserving all unspecified options.
#    # * "-M", parsing "="-prefixed substrings in option specifications as the
#    #   map key to parse such option into (e.g., "-help=h" parses long option
#    #   "--help" into map key ${arg_options[-h]} rather than
#    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
#    #   target list or map name to parse such option into.
#    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
#    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
#    #   either the option values if passed or the empty string if not passed.
#    if { not zparseopts -M -D -E -A "${map_name__smtaowhf}" --\
#        "${args__smtaowhf[@]}" h -help=h } {
#        print_warning "Invalid command-line argument(s)."
#        :str.output "${help_message__smtaowhf}"
#        :failure.report
#    }
#
#    # If passed a help option, ignore all other options, print the passed help
#    # text, and return from the caller function or script.
#    if { :map.is_key "${map_name__smtaowhf}" "-h" } {
#        :str.return "${args__smtaowhf}"
#    }
#} <<<'

#   :die_unless_vars_integer\
#       "${int_name_count__sitancaif}"\
#       "${int_name_index_first__sitancaif}"
# For efficiency, inline such implementations. See
    # :Int.set() for further details.
#    noop ${(P)int_name_count__sitancaif::=$(( # - index_first__sitancaif + 1 ))}
#    noop ${(P)int_name_index_first__sitancaif::=${index_first__sitancaif}}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_integer_to_arg_nonoption_index_first() and
    # set_integer_to_arg_option_index_last().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#function set_integer_to_arg_nonoption_index_first() {
#    # Validate sanity.
#    die_unless_args 'Expected zero or more arguments and one integer name.'
#    string int_name__sitanif="${@[-1]}"
#    integer arg_nonoption_index_first__sitanif
#    pop_arg
#
#    # If such arguments contain "-" or "--", such index is one after the index
#    # of such argument.
#    arg_nonoption_index_first__sitanif="${@[(i)-|--]}"
#    if (( arg_nonoption_index_first__sitanif <= # )) {
#          arg_nonoption_index_first__sitanif+=1
#    # Else, such index is the index of the first argument *NOT* prefixed by "-"
#    # if such argument exists or the number of such arguments otherwise.
#    } else {
#        arg_nonoption_index_first__sitanif="${@[(i)[^-]*]}"
#    }
#
#    # Set such integer.
#    :Int.set "${int_name__sitanif}"\
#        "${arg_nonoption_index_first__sitanif}"
#}

    # Set the index of the first non-option argument.
#    :Int.set "${int_name_index__sitancaif}"\
#        "${arg_nonoption_index_first__sitancaif}"
#
#    # Set the number of such arguments.
#    :Int.set "${int_name_count__sitancaif}"\
#        $(( # - ${(P)int_name_index__sitancaif} + 1 ))

#, parsing arguments `-` and `--` as ending option arguments.

#FUXME: Also, our creation of local variables on the caller's behalf if not
#already declared is amusing, but highly incongruous. Consider it: when can a
#caller reasonably expect a setter to declare a variable for itself? Solipsistic
#answer: when such setter is an alias. But this is turn requires the caller to
#somehow know whether a setter is an alias or function, an implementation detail
#the caller should *NEVER* be knowledgable of. In other words, declaring local
#variables on the caller's behalf is breaking bad and should be desisted.
#Instead, just throw an exception if such variable does not exist (as usual).

#    # Validate sanity.
#    list args__seitancafif; set_list_to_stdin_words args__seitancafif
#    (( ${#args__seitancafif} == 2 )) or :die "expected two integer names"
#    string\
#        count_int_name__seitancafif="${args__seitancafif[1]}"\
#        index_int_name__seitancafif="${args__seitancafif[2]}"
#
#    # Get the index of the first non-option argument.
#    set_integer_to_arg_nonoption_index_first\
#        "${index_int_name__seitancafif}"
##   print "arg count: ${#}"
##   print "arg nonoption first index \"${index_int_name__seitancafif}\": ${(P)index_int_name__seitancafif}"
##   print "arg nonoption count: $(( # - ${(P)index_int_name__seitancafif} + 1 ))"
#
#    # Set such integer.
##   print "count integer name: ${count_int_name__seitancafif}"
#    :Var.is "${count_int_name__seitancafif}" or
#        integer "${count_int_name__seitancafif}"
#    :Int.set "${count_int_name__seitancafif}"\
#        $(( # - ${(P)index_int_name__seitancafif} + 1 ))
#} <<<'

# Due to `zsh` constraints,
#integer names must be passed whitespace-delimited in a single shell word (e.g.,
#single- or double-quoted string).

#   :int.die_unless "${int_name__sitanc}"
#== Premature Denotation ==
#
#By precedent, the first passed argument equal to `-` or `--` prematurely
#terminates option arguments. If such an argument was passed, the passed integer
#will be set to one greater than the index of such argument rather than the index
#of the first passed non-option argument.

    #FUXME: Replace implementation with a single expansion of
    #set_integers_to_arg_nonoption_count_and_index_first().

#alias set_integer_to_arg_nonoption_index_first='{
#    #FUXME: Replace implementation with a single expansion of
#    #set_integers_to_arg_nonoption_count_and_index_first().
#
#    # Validate sanity.
#    list args__seitanfi
#    set_list_to_stdin_words args__seitanfi
#    (( ${#args__seitanfi} == 1 )) or :die "expected one integer name"
#    string int_name__seitanfi="${args__seitanfi[1]}"
#    integer arg_nonoption_index_first__seitanfi
#
#    # If sanity.contain "-" or "--", the index of the first non-option
#    # in such arguments is one after the index of such "-" or "--".
#    arg_nonoption_index_first__seitanfi=${@[(i)-|--]}
#    if (( arg_nonoption_index_first__seitanfi <= # )) {
#        noop $(( ++arg_nonoption_index_first__seitanfi ))
#    # Otherwise, the index of the first non-option in such arguments is the
#    # index of the argument *NOT* prefixed by "-" or the number of such
#    # arguments if all arguments are prefixed by "-" or no arguments are passed.
#    } else {
#        arg_nonoption_index_first__seitanfi=${@[(i)[^-]*]}
#    }
#
#    # Set such integer.
#    :Var.is "${int_name__seitanfi}" or
#        integer "${int_name__seitanfi}"
#    :Int.set "${int_name__seitanfi}"\
#        "${arg_nonoption_index_first__seitanfi}"
#} <<<'

#alias :Arg_count_nonoption='
#{
#    # Validate sanity.
#    list args__seitanc; set_list_to_stdin_words args__seitanc
#    (( ${#args__seitanc} == 1 )) or :die "expected one integer name"
#
#    # Defer to the above alias with a placeholder first index integer name.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        "${args__seitanc[1]} index_int_name__seitanc"
##   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
#} <<<'

#FUXME: Globally rename "_arg_nonoption_index_first" to
#"_arg_nonoption_index_first".

#:alias_command <<'/---'
#void :Arg_count_nonoption(string int_name)
#
#Set the passed integer to the number of *non-options arguments* the caller
#passed (i.e., arguments not prefixed by `-`). Parse arguments `-` and `--` as
#ending option arguments.
#/---
#alias :Arg_count_nonoption='
#{
#    # Validate sanity.
#    list args__seitanc; set_list_to_stdin_words args__seitanc
#    (( ${#args__seitanc} == 1 )) or :die "expected one integer name"
#
#    # Defer to the above alias with a placeholder first index integer name.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        "${args__seitanc[1]} index_int_name__seitanc"
##   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
#} <<<'

    # Validate sanity.
#   list args__seitanc; set_list_to_stdin_words args__seitanc
#   (( ${#args__seitanc} == 1 )) or :die "expected one integer name"
#   string int_name__seitanc="${args__seitanc[1]}"

    # Get the index of the first non-option argument.
#   set_integer_to_arg_nonoption_index_first arg_nonoption_index_first__seitanc
#   print "arg count: ${#}"
#   print "arg nonoption first index: ${arg_nonoption_index_first__seitanc}"
#   print "arg nonoption count: $(( # - arg_nonoption_index_first__seitanc + 1 ))"

    # Set such integer.
#    :is_var_integer "${int_name__seitanc}" or integer "${int_name__seitanc}"
#   :Int.set "${int_name__seitanc}"\
#       $(( # - arg_nonoption_index_first__seitanc + 1 ))

#FUXME: Rename to set_list_to_arg_options_with_help_from() and accept the first
#passed argument as a list name. In other words, stop assuming a list name of
#${arg_options} as we currently do.

#boolean is_arg_nonoptions_1_to_3{void}
#boolean is_arg_nonoptions_1_to_3<void>
#Return true if the number of non-options in the current argument list (i.e.,
#arguments not prefixed by "-") is . This alias parses arguments "-" and "--"
#as the last options in such list.

#:Arg_count_nonoption __nonoptions__ and
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#'
#alias is_arg_nonoptions_1_to_3='
#{
#    integer __nonoptions__; :Arg_count_nonoption __nonoptions__
#    print "non-option count: ${__nonoptions__}"
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#}
#'
#function tyam() {
#   :Arg_count_nonoption y
#   print "arg nonoption count: $y"
#    is_arg_nonoptions_1_to_3 and print "...between 1 to 3"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}
    #FUXME: Such functionality, duplicated above, should arguably be
    #encapsulated into a single function -- perhaps, print_message set_integer_locally()
    #or set_integer_declaratively(). Hmm; how about
    #set_integer_declared_locally_unless_found() or
    #set_integer_and_localize_unless_declared() or
    #set_integer_localized_if_unset()? Yes; the latter, I should think. Ah; wait.
    #The syntax is rather ugly, requiring a composite herestring. *shrug*

#   :Int.set "${int_name_seitanfi}" $(( arg_nonoption_index_first_seitanfi ))
#   list __args__; __args__=( ${(z)"$(< /dev/stdin)"} )
# Get the number of non-options passed (i.e., non-"-"-prefixed arguments).
    #FUXME: Be nice to extract this into a new set_integer_to_evaluation().
    #Actually, how about a more general set_scalar_to_evaluation()? Right. That
    #seems perfect.

#   noop ${(P)__int_name__::=$(( __arg_nonoption_index_first__ ))}
#   noop ${(P)__int_name__::=$(( # - __arg_nonoption_index_first__ + 1 ))}
        # Else, if at least one sanity.is not prefixed by "-", such
        # argument is the first non-option in such arguments.
        # Otherwise, set such index to the size of such list plus one.
#       (( __arg_option_last_index__ <= # )) or 
#           (( __arg_option_last_index__ <= # )) or 
#       then noop ${(P)__int_name__::=$(( __arg_option_last_index__ ))}
#       else 
#       fi

#   noop  ${(P)__int_name__::=${@[(i)-|--]}}
#   if (( ${(P)__int_name__} <= # ))

#FUXME: Completely unrelated to this component, but we can now actually create
#sensible :str.return()-style aliases! Oh, man; pretty sweet. Finally found
#it.

    #FUXME: Validate the passed argument is a single argument. Just revert to
    #the traditional argument parsing to do so.
    # Validate sanity.
#   string __int_name__; __int_name__="$(get_stdin_piped)"
