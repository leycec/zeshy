#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *globbable list setters* (i.e., functions setting lists and list items by
matching such items against glob expressions).
/---

#FIXME: Use parameter expansion flag "(X)" to force errors on glob errors.

# ....................{ SETTERS                            }....................
:func_ '<globbable> :void set_list_to_list_items_matching_glob(
    :str:list target_list_name, :str:list source_list_name, string glob)'
:func{
    # Localize arguments.
    :str\
        list_name_target__sltlimg="${1}"\
        list_name_source__sltlimg="${2}"\
        glob__sltlimg="${3}"

    # Remove non-matching items. Dismantled, this is:
    #
    # * "(M)" and ":#", removing all such source list items not matching...
    # * "${~glob__sltlimg}", such glob as a glob rather than literal.
    eval ${list_name_target__sltlimg}'=(
        "${(M)'${list_name_source__sltlimg}'[@]:#${~glob__sltlimg}}" )'
}:func <<'/---'
Set the passed target list to all items in the passed source list matching the
passed glob: e.g.,

.set_list_to_list_items_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_linearity on_cyclicity; on_cyclicity=(
...    "Catch! calls the Once-ler."
...    "He lets something fall."
...    "It's a Truffula Seed."
...    "It's the last one of all!"
...    "You're in charge of the last of the Truffula Seeds."
...    "And Truffula Trees are what everyone needs."
...    "Plant a new Truffula. Treat it with care."
...    "Give it clean water. And feed it fresh air."
...    "Grow a forest. Protect it from axes that hack."
...    "Then the Lorax"
...    "and all of his friends"
...    "may come back." )
>>> set_list_to_list_items_matching_glob on_linearity on_cyclicity *'last*'
>>> print_list on_linearity
1: It's the last one of all!
2: You're in charge of the last of the Truffula Seeds.
------------------------------------------
==========================================
/---

:func_ '<globbable> :void set_list_to_list_items_not_matching_glob(
    :str:list target_list_name, :str:list source_list_name, :str glob)'
:func{
    # Localize arguments.
    :str\
        list_name_target__sltling="${1}"\
        list_name_source__sltling="${2}"\
        glob__sltling="${3}"

    # Remove non-matching items. Dismantled, this is:
    #
    # * ":#", removing all such source list items matching...
    # * "${~glob__sltling}", such glob as a glob rather than literal.
    eval ${list_name_target__sltling}'=(
        "${'${list_name_source__sltling}'[@]:#${~glob__sltling}}" )'
}:func <<'/---'
Set the passed target list to all items in the passed source list _not_ matching
the passed glob: e.g.,

.set_list_to_list_items_not_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_profit on_medicine; on_medicine=(
...    "When at last we are sure"
...    "You've been properly pilled,"
...    "Then a few paper forms"
...    "Must be properly filled"
...    "So that you and your heirs"
...    "May be properly billed." )
>>> set_list_to_list_items_not_matching_glob on_profit on_medicine *'o'*
>>> print_list on_profit
1: When at last we are sure
------------------------------------------
==========================================
/---

# ....................{ SETTERS ~ range                    }....................
:func_\
    '<globbable> :void set_list_to_list_items_after_item_matching_glob(
        :str:list? target_list_name,
        :str:list? source_list_name,
        :str glob)'
:func{
    # Localize arguments.
    :str\
        list_name_target__sltliaimg="${1}"\
        list_name_source__sltliaimg="${2}"\
        glob__sltliaimg="${3}"
    :int list_index__sltliaimg

    #FIXME: Horrible! Replace with a comparable setter.

    # Get the first matching index.
    list_index__sltliaimg="$(get_list_index_first_matching_glob\
        "${list_name_source__sltliaimg}" "${glob__sltliaimg}")"

    # Set such list to all items after and including such index.
    set_list_to_evaluation\
        "${list_name_target__sltliaimg}"\
        '"${'${list_name_source__sltliaimg}'[${list_index__sltliaimg},]}"'
}:func <<'/---'
Set the passed target list to all items of the passed source list after and
including the first item matching the passed glob or throw an exception if no
such item matches.
/---

:func_\
    '<globbable> :void set_list_to_list_items_between_items_matching_globs(
        :str:list? target_list_name,
        :str:list? source_list_name,
        :str start_glob,
        :str end_glob)' :func{
    # Localize arguments.
    :str\
        list_name_target__sltlibimg="${1}"\
        list_name_source__sltlibimg="${2}"\
        glob_start__sltlibimg="${3}"\
        glob_end__sltlibimg="${4}"
    :int index_start__sltlibimg index_next__sltlibimg

    #FIXME: Horrible! Replace with comparable setters both here and below.

    # Get the first matching index.
    index_start__sltlibimg=$(get_list_index_first_matching_glob\
        "${list_name_source__sltlibimg}" "${glob_start__sltlibimg}")

    # Get the next matching index if found.
    if { index_end__sltlibimg=$(\
        get_list_index_first_matching_glob_after_index_if_found\
        "${list_name_source__sltlibimg}"\
        "${glob_start__sltlibimg}"\
        "${index_start__sltlibimg}")
    } {
    # Else, default to the last index.
    } else {
        index_end__sltlibimg=$(get_list_size "${list_name_source__sltlibimg}")
    }

    # Set such list to all items between and including such indices.
    set_list_to_evaluation\
        "${list_name_target__sltlibimg}"\
        '"${'${list_name_source__sltlibimg}'[${index_start__sltlibimg},${index_end__sltlibimg}]}"'
}:func <<'/---'
Set the passed target list to all items of the passed source list that:

* Follow the first item matching the first passed glob, including such item. If
  no such item matches, throw an exception.
* Precede the next item matching the second passed glob, including such item. If
  no such item matches, include all remaining items, thus mimicking
  set_list_to_list_items_after_item_matching_glob().
/---

# ....................{ SETTERS ~ index                    }....................
#FIXME: Add examples.
:func_ ':void :List.First_index.^=(
    :List list_name :Int int_name :str/:glob glob) [
    var_name_suffix="__LFig"]' :func{
    :List.First_index.^=_if_found "${@}" :or
        die_unless_list_item_matches_glob "${list_name__LFig}" "${glob__LFig}"
}:func <<'/---'
Set the passed integer to the 1-based index of the first argument the caller
passed matching the passed glob _or_ throw an exception if no such argument
matches.

== See Also ==

* :List.First_index.^=_if_found().
/---

:func_ '[status=:bool] :List.First_index.^=_if_found(
    :List list_name :Int int_name :str/:glob glob) [
    var_name_suffix="__LFigif"]' :func{
    :int list_index__LFigif list_size__LFigif

    # 1-based index of the first matching item. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'i', expanding to the index of the matching first item.
    # * "${~glob__LFigif}", treating such glob as a glob rather than a raw
    #   string literal.
    list_index__LFigif=${${(@P)list_name__LFigif}[(i)${~glob__LFigif}]}

    # Size of such list.
    :set_int_to_list_size list_size__LFigif "${list_name__LFigif}"

    # Set such index if found or report failure.
    (( list_index__LFigif <= list_size__LFigif )) :and
        :Int.set "${int_name__LFigif}" "${list_index__LFigif}"
}:func <<'/---'
Set the passed integer to the 1-based index of the first argument the caller
passed matching the passed glob _or_ report failure if no such argument
matches.
/---
