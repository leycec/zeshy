#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *file globs* (i.e., glob expressions matching existing files).
/---

#FIXME: Refactor all getters to setters.

# ....................{ GETTERS                            }....................
:func_ '<globbable> [stdout = :str, status = :bool]
    get_file_globbed_first_if_found(:str glob)' :func{
    get_path_globbed_matching_qualifier_first_if_found "${1}" '-.'
}:func <<'/---'
Get the first passed file that exists _and_ matches the passed glob after
resolving symbolic links or return failure if no such file exists. See
get_path_globbed_matching_qualifier_first_if_found() for further details: e.g.,

.get_file_globbed_first_if_found()
==========================================
[source]
------------------------------------------
>>> get_file_globbed_first_if_found /bin/ch[a-z]## *
/bin/mkdir
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Nonsense. Shift the core getters to @{qualifier} and all remaining
#getters to the corresponding parcels.

#   get_path_matching_glob_qualifier_first "${@}" '-.' 'a file' 'files'
#   get_path_matching_glob_qualifier_first "${@}" '-/' 'a directory' 'directories'
#FUXME: Rename to get_path_matching_qualifier_first().
#FUXME: Alter function signature to:
#
#string get_path_matching_qualifier_first(
#    string pathname1, string pathname2, ...,
#    string glob_qualifier)
#
#Clearly, I didn't quite grok filename generation when I first concocted this
#function. The above approach is quite a bit more sensible. Just drop the
#trailing exception message-specific labels altogether. *WAY* overkill. (If you
#really want super-hyper-turbo human-readable exceptions, call
#get_path_matching_qualifier_first_if_found() instead and perform an
#explicit :die() -- which incidentally produces much cleaner code.) Call it like
#so:
#
#>>> get_path_matching_glob_qualifier_first "imprimi_potest/"* 'w/'
#
#The resulting exception message (if no path matches) should simply resemble:
#
#    no path matches glob "'imprimi_potest/'*(#q'w/')"
#FUXME: Actually, just eliminate this. No one benefits from unreadable exceptions.

#:func.doc <<'/---'
#string get_path_matching_glob_qualifier_first(
#    string pathname1, string pathname2, ...,
#    string glob_qualifiers,
#    string label_if_singular, string label_if_plural)
#
#Get the first passed path matching the passed glob qualifier or throw an
#exception if no such path matches such qualifier, in which case embed the passed
#human-readable singular or plural label into the resulting exception message
#(depending on whether one or more than one paths were passed): e.g.,
#
#.get_path_matching_glob_qualifier_first()
#==========================================
#[source]
#------------------------------------------
## Get the first owner-writable subdirectory of a newly created directory.
#>>> make_dir "imprimi_potest/{imprimatur,censorship}"
#>>> get_path_matching_glob_qualifier_first "imprimi_potest/"* "w/"\
#...     "an owner-writable directory" "owner-writable directories"
#imprimatur
#------------------------------------------
#==========================================
#/---
#function get_path_matching_glob_qualifier_first() {
#    # Validate passed arguments.
#    die_unless_args_4_or_more\
#        'expected at least one pathname, one glob, one singular label, and one plural label'
#    string\
#        label_if_singular="${@[-2]}" label_if_plural="${@[-1]}" pathname
#    pop_args_2
#
#    # If at least one argument matches such glob qualifiers, return the first.
#    if { pathname="$(get_path_matching_qualifier_first_if_found "${@}")" } {
#        :str.return "${pathname}"
#    # Else, throw an exception.
#    } else {
#        # For list indexing convenience, pop off the passed glob.
#        pop_arg
#
#        #FUXME: Whatever gettext() interface we support will certainly include
#        #support for plurality. See @{io/locale} for further discussion.
#
#        # Throw a differing error message depending on argument plurality.
#        if { is_arg } {
#            :die "\"${1}\" not found or not ${label_if_singular}"
#        } else {
#            :die "$(join_strings_readable: "${@}") not found or not ${label_if_plural}"
#        }
#    }
#}

## Get the first owner-writable subdirectory of a newly created directory.
#>>> make_dir "imprimi_potest/{imprimatur,censorship}"
#>>> get_path_matching_qualifier_first_if_found "imprimi_potest/"* "w/" or :die\
#...     "an owner-writable directory" "owner-writable directories"
#imprimatur

#...     So long as men worship the Caesars and Napoleons, Caesars and Napoleons
#...     will duly rise and make them miserable."
#   get_path_matching_glob_qualifier_first\
#       "${@}" '-e{[[ -d $REPLY && -w $REPLY ]]}'\
#       'a writable directory' 'writable directories'

    # Get the first such pathname.

    # Convert such qualifier to a proper qualifier, if not already.
#   glob_qualifier="$(convert_string_to_glob_qualifier "${glob_qualifier}")"

    # If at least one path matches, return the first; else, fail.
#   pathname_match=( "${^@}"${~glob_qualifier} ) or =failure.ignore
#   if { is_list_nonempty pathname_match } {
#       :str.return "${pathname_match[1]}"
#   } else {
#       :failure.report
#   }

#FUXME: Generalize to accept any glob as under :is_glob_qualified_path(). This
#requires wrapping current arguments in "()". Just call
#convert_string_to_glob_qualifier(), in other words.

#    string glob,
#    string glob_qualifier1, string glob_qualifier2, ...)

#FUXME: Rename to get_path_matching_glob_qualifier_first(). Honestly, this is a
#bit heavyweight. Contemplate usage elsewhere.
#FUXME: We arguably want a new "glob" directory and a new "first" component in
#such directory containing such functionality. It's a bit much for just a core
#"glob" component.
