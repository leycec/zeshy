#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle aliases printing strings to standard output.
/---

# ....................{ OUTPUTTERS                         }....................
# For efficiency, implement low-level outputters as aliases and not functions.
# While implementing such ouputters as functions is trivial, doing so reduces
# the efficiency of numerous functions expanding such aliases.

:alias_command ':string :string.output(:string text1 = "", ...)'\
    'print -r --' <<'/---'
Output the passed strings (defaulting to the empty string) to standard output
suffixed by a newline. This low-level alias is principally intended for non-
interactive use (e.g., returning strings from getter functions called from
process substitutions). Consider calling higher-level function :string.output()
instead for interactive uses (e.g., printing strings to the current terminal).
Such function properly maintains `zeshy` globals monitoring interactive output;
this alias does not.

== Comparisons ==

Unlike builtins echo() and print(), this alias prints embedded escape sequences
as is rather than converting such sequences to the corresponding characters
(e.g., `\n` sequences to newlines). While convenient, such conversions silently
mangle arbitrary strings and hence are _not_ general-purpose. Consider calling
unescape_string() instead to convert such sequences.

Avoid calling such builtins, which behave unsafely when passed arbitrary and
hence possibly hyphen-prefixed strings: e.g.,

.:string.output() versus print()
==========================================
[source]
------------------------------------------
>>> string lammoth="-z" morgoth="rm -rf *"

# Bad! Never do this, unless guaranteed no hyphens prefix such string.
# If hyphens do prefix such string, zsh treats the first word of such
# string as options to print(). This can be extremely unsafe, as this
# example demonstrates. Do *NOT* try this example at home. We mean it.
>>> print "${lammoth}" "${morgoth}"
>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

# Good. Always do this, instead.
>>> :string.output "${lammoth}" "${morgoth}"
-z rm -rf *    # That's more like it.
------------------------------------------
==========================================
/---

:alias_command\
    '[stderr = :string] :output_string_to_stderr(:string text)'\
    '{
        print -r -- "$(:stdin.get)"\
            '${ZESHY_STDOUT_FILE_DESCRIPTOR}'>&'${ZESHY_STDERR_FILE_DESCRIPTOR}'
    } <<<' <<'/---'
Output the passed string to standard error suffixed by a newline. Unlike
:string.output() and related aliases, this alias accepts only one mandatory
argument _not_ defaulting to the empty string. See such alias for further
details.
/---

# ....................{ OUTPUTTERS ~ newline               }....................
:alias_command ':string :output_newline()'\
    "print -- ''" <<'/---'
Output a blank line to standard output.
/---

:alias_command\
    ':string :output_strings_newlined(:string text1 = "", ...)'\
    'print -lr --' <<'/---'
Output the passed strings (defaulting to the empty string) to standard output,
delimiting each by a trailing newline. See :string.output() for further details.
/---

:alias_command\
    ':string :output_string_sans_newline(:string text1 = "", ...)'\
    'print -nr --' <<'/---'
Output the passed strings (defaulting to the empty string) to standard output
suffixed by _no_ newline. See :string.output() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
# Ideally, the expansion for this alias would defer to
# :output_string_to_stderr(). However, such alias is implemented with the here-
# document technique and hence accepts at most one argument, preventing this
# alias from prepending such argument by the desired warning prefix. Thus, this
# alias necessarily reimplements such alias.

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Synchronize with :output_string_to_stderr().
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# :alias_command\
#     '[stderr: string] :warning.output(string text)'\
#     '{
#         print -r -- "zeshy: $(:stdin.get)"\
#             '${ZESHY_STDOUT_FILE_DESCRIPTOR}'>&'${ZESHY_STDERR_FILE_DESCRIPTOR}'
#     } <<<' <<'/---'
# Output the passed warning to standard error suffixed by a newline. Unlike
# :string.output() and related aliases, this alias accepts only one mandatory
# argument _not_ defaulting to the empty string. Unlike the similar alias
# :output_string_to_stderr(), this alias prefixes the passed string with a warning-
# specific indicator (e.g., `zeshy: `). See such aliases for further details.
# /---

#FUXME: To highlight the fact that such functions accept string values rather
#than variable names, consider renaming such functions from ":string.output" to
#"output_value". Indeed, we should probably use "value" throughout the zeshy
#codebase to mean any scalar value regardless of type.

 # See also:
#
# * "output/output", wrapping such outputters in high-level functions.
# * "string/join", calling builtin print() to efficiently join strings.

# ....................{ OUTPUTTERS ~ redirect              }....................
#FUXME: We need to manually crawl through the codebase, replacing every instance
#of "print --" (which is dangerous and *WRONG*) and "print -r --" with expansion
#of this alias. You know the drudgery, by now.
