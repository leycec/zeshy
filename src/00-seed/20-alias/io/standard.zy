#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *standard file descriptors* (i.e., standard input, output, and error)
aliases.
/---

#FIXME: Refactor most getters -- excluding those for which efficiently elides
#away such subshells (e.g., :stdin()) -- into setters.

# ....................{ GETTERS                            }....................
:alias_command ':str :stdin[stdin=(:str input)]'\
    '< "'${ZESHY_STDIN_PATH}'"' <<'/---'
Get all standard input to the current context if such input exists or block
indefinitely and silently until such input is written to such context. Since
such blocking is strongly undesirable, this alias should _always_ be preceded by
tests ensuring such input exists (e.g., :stdin.is_nonempty(),
die_unless_stdin_readable_sans_blocking()). Due to `zsh` optimization, this
alias behaves as expected even when expanded via command substitution (e.g.,
`$(:stdin)`).

.:stdin()
==========================================
[source]
------------------------------------------
>>> :str on_propaganda=\
...    "All war propaganda consists, in the last resort, in substituting
...     diabolical abstractions for human beings. Similarly, those who defend
...     war have invented a pleasant sounding vocabulary of abstractions in
...     which to describe the process of mass murder."
>>> { get_string_line "$(:stdin)" -1 } <<<"${on_propaganda}"
which to describe the process of mass murder.
------------------------------------------
==========================================
/---

# ....................{ GETTERS                            }....................
# On Linux, prefer canonicalizing ${ZESHY_STDIN_FILE_DESCRIPTOR_PATH} to
# ${ZESHY_STDIN_PATH}; the former tends to be a direct symbolic link to the
# desired device file, while the latter tends to only indirectly link to such
# file. While both would suffice here, canonicalizing the former should prove
# (marginally) more efficient.
#
# To ensure such canonicalization is performed in the current shell, avoid
# calling :path.canonicalize() or any other zeshy functions here. See
# :stdout.Mtime() for further details.
:alias_command ':str :stdin.path()'\
    ':str.output "'${ZESHY_STDIN_FILE_DESCRIPTOR_PATH}'"(:A)' <<'/---'
Get the canonicalized absolute path of the device file associated with standard
input (e.g., `/dev/pts/6`).
/---

:alias_command ':str :stdout.path()'\
    ':str.output "'${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}'"(:A)' <<'/---'
Get the canonicalized absolute path of the device file associated with standard
output (e.g., `/dev/pts/9`).
/---

:alias_command ':str :stderr.path()'\
    ':str.output "'${ZESHY_STDERR_FILE_DESCRIPTOR_PATH}'"(:A)' <<'/---'
Get the canonicalized absolute path of the device file associated with standard
error (e.g., `/dev/pts/7`).
/---

# ....................{ SETTERS                            }....................
# Sadly, the only safe means of canonicalizing these paths is as below.
# Replacing the first pipeline subcommand with a call to :path.canonicalize()
# uselessly returns "/dev/fd/0" without resolving the desired path. Likewise,
# replacing the second pipeline subcommand with a process substitution has the
# same effect.  While such results are odd, their underlying reasons are simple:
# in both cases, zsh performs such canonicalization in a subshell attached to a
# different standard input file descriptor. Mercifully, zsh appears to perform
# pipeline subcommands consisting of only low-level builtin print() and history
# modifier "(:A)" in the current shell, ensuring as expected that the standard
# input file descriptor for the current shell is canonicalized.
#
# Since such feature is obscurely undocumented, this could change at any
# time. If it does, another (perhaps more reliable) method remains:
# coprocesses. In theory, we could redirect the result of such output to the
# identity coprocess and then copy such result from such coprocess into such
# variable. In fact, this is precisely how we currently capture standard
# output and error from commands evaluated by the current shell.
:alias_command ':void :stdin.Path(:Str path_name)'\
    ':stdin.path | :Str.from_stdin' <<'/---'
Set the passed string variable to the canonicalized absolute path of the device
file associated with standard input. See :stdin.path() for further details.
/---

:alias_command ':void :stdout.Path(:Str path_name)'\
    ':stdout.path | :Str.from_stdin' <<'/---'
Set the passed string variable to the canonicalized absolute path of the device
file associated with standard output. See :stdout.path() for further details.
/---

:alias_command ':void :stderr.Path(:Str path_name)'\
    ':stderr.path | :Str.from_stdin' <<'/---'
Set the passed string variable to the canonicalized absolute path of the device
file associated with standard error. See :stderr.path() for further details.
/---

# ....................{ SETTERS ~ float                    }....................
#FIXME: We need to note that, for security purposes (e.g., to discourage
#password brute-forcing by malicious users), the Linux kernel annoyingly munges
#these times in reasonably unpredictable ways. Hence, they're somewhat useless.

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Synchronize with :stderr.Mtime().
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
:alias_command ':void :stdout.Mtime(:Float mtime_name)' '{
    # Validate sanity. Avoid calling :Float.die_unless(), as
    # :stdin.Float() already does so below.
    :str float_name__sftom stdout_filename__sftom
    float_name__sftom="$(:stdin)"

    # Get the canonicalized absolute path of the standard output device file.
    # Assuming the current shell to be a pseudo-terminal, this file is usually a
    # symbolic link to the device file for such terminal (e.g., "/dev/pts/7").
    # Referring to standard output by such resolved rather than symbolic
    # path is essential; we run the command getting standard output''s mtime
    # from a pipeline subcommand and hence subshell in which such symbolic link
    # refers to a pipeline rather than the expected pseudo-terminal. While we
    # work around such issue by piping :path.mtime() output to an identity
    # coprocess, this is dramatically simpler (and probably more efficient).
    :stdout.Path stdout_filename__sftom

    #FIXME: Silly. We should just define a new :path.Mtime() function
    #implementing this on our behalf.

    # Set such float to such path''s mtime.
    :path.mtime "${stdout_filename__sftom}" |
        :stdin.Float "${float_name__sftom}"
#   :str.output_to_stderr "stdout: ${stdout_filename__sftom}; mtime: ${(P)float_name__sftom}"
} <<<' <<'/---'
Set the passed float variable to the *mtime* (i.e., modification time) in high-
resolution fractional seconds since the Unix epoch of the most recent write to
standard output by the current shell. See get_time() for further details.
/---

# See :stdout.Mtime() above.
:alias_command ':void :stderr.Mtime(:Float mtime_name)' '{
    :str float_name__sftem stderr_filename__sftem
    float_name__sftem="$(:stdin)"
    :stderr.Path stderr_filename__sftem
    :path.mtime "${stderr_filename__sftem}" |
        :stdin.Float "${float_name__sftem}"
} <<<' <<'/---'
Set the passed float variable to the *mtime* (i.e., modification time) in high-
resolution fractional seconds since the Unix epoch of the most recent write to
standard error by the current shell. See get_time() for further details.
/---

# ....................{ CLOSERS                            }....................
:alias_command ':void :stdin.close()'\
    "exec ${ZESHY_STDIN_FILE_DESCRIPTOR}<&-" <<'/---'
Close the standard input file descriptor (i.e., 0) and corresponding named pipe
(i.e., `/dev/stdin`).
/---

:alias_command ':void :stdout.close()'\
    "exec ${ZESHY_STDOUT_FILE_DESCRIPTOR}>&-" <<'/---'
Close the standard output file descriptor (i.e., 1) and corresponding named pipe
(i.e., `/dev/stdout`).
/---

:alias_command ':void :stderr.close()'\
    "exec ${ZESHY_STDERR_FILE_DESCRIPTOR}>&-" <<'/---'
Close the standard error file descriptor (i.e., 2) and corresponding named pipe
(i.e., `/dev/stderr`).
/---

# --------------------( WASTELANDS                         )--------------------
#   :stdout.path | :Str.from_stdin stdout_filename__sftom
# See set_float_to_float() for further details.

#FUXME: Document the fact that this alias blocks if standard input is empty and
#hence should *ONLY* be expanded where standard input is guaranteed to be
#nonempty.

#This is a low-level alias. _
#
#By design, this alias performs _no_ safety checks (e.g.,
#to ensure standard input is open and nonempty) and hence should only be
#expanded by functions performing such checks (e.g., set_string_to_stdin_pipe()):
#e.g.,

#   :str.output_to_stderr ok
#   :str.output_to_stderr ko
#   :str.output "stdout: ${stdout_filename__sftom}"

# ....................{ OUTPUTTERS                         }....................
#FUXME: Actually, what the heck was the original intention here? This is never
#called anywhere and is consequently "going away." (I mean, I sort of get it:
#but where, honestly, would we ever use this? At the least, it needs to be
#renamed.)
#FUXME: This would probably be more appropriate as a function. Is there any
#compelling reason for this to be an alias instead? (I can't fathom one.)
#:alias_command 'string output_stdin[stdin: string input]'\
#   '{
#        die_unless_stdin_readable_sans_blocking
#        :stdin
#        :stdin.close
#    }'  <<'/---'
#Print standard input to the current shell. This alias is especially helpful for
#printing here-documents: e.g.,
#
#.output_stdin()
#==========================================
#[source]
#------------------------------------------
#>>> function on_acts_of_subversion() {
#...     output_stdin <<'/ooo'
#... Why are ecologists and environmentalists so feared and hated? This is
#... because in part what they have to say is new to the general public, and the
#... new is always alarming. Moreover, the practical recommendations deduced from
#... ecological principles threaten the vested interests of commerce; it is
#... hardly surprising that the financial and political power created by these
#... investments should be used sometimes to suppress environmental impact
#... studies. However, I think the major opposition to ecology has deeper roots
#... than mere economics; ecology threatens widely held values so fundamental
#... that they must be called religious. An attack on values is inevitably seen
#... as an act of subversion.
#... /ooo
#... }
#>>> get_string_line "$(on_acts_of_subversion)" 1
#Why are ecologists and environmentalists so feared and hated? This is
#------------------------------------------
#==========================================
#/---

#thematically resembles other aliases defined by this parcel 

# ....................{ RUNNERS                            }....................
#FUXME: Terribly name, as this isn't a runner in the expected sense. Instead:
#
#* Rename this alias to print_stdin().
#* Drop the suffixing "|", which most callers would find unexpected.
#* Replace existing expansions of this alias with "print_stdin |".
#:alias_command\
#    'string run_code_with_stdin_piped(
#        string command_name, string command_arg1, string command_arg2, ...)'\
#    "{
#        < \"${ZESHY_STDIN_PATH}\"
#        :stdin.close
#    } |" <<'/---'
#Run the passed command by piping the standard input piped to the current
#function or script to such command. Typically, this alias is used in concert
#with the :is_stdin_pipe() function to propagate piped input: e.g.,
#
#.run_code_with_stdin_piped()
#==========================================
#[source]
#------------------------------------------
#>>> function salvia() {
#...     if { :is_stdin_pipe } {
#...         run_code_with_stdin_piped cat
#...     } else {
#...         :str.output "${@}"
#...     }
#... }
#>>> :str.output divinorum | salvia
#divinorum
#>>> salvia divinorum
#divinorum
#------------------------------------------
#==========================================
#/---

#   :Float.die_unless "${float_name__sftso}"
#FUXME: Rename to ZESHY_STDIN_FILE_DESCRIPTOR and define a new
#ZESHY_STDIN_DEVICE_FILE (or perhaps simply ZESHY_STDIN_FILE, I should think)
#global expanding to "/dev/stdin". Then replace all instances of /dev/stdin with
#"${ZESHY_STDIN_DEVICE_FILE}".
#FUXME: Do so similarly for OUTPUT and ERROR globals, below.
