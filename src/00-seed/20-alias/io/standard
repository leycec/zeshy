#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *standard file descriptors* (i.e., standard input, output, and error)
aliases.
/---

#FIXME: Refactor most getters -- excluding those for which efficiently elides
#away such subshells (e.g., :stdin.get()) -- into setters.

# ....................{ GETTERS                            }....................
#FIXME: Rename to simply :stdin(). Neat, huh?

:alias_command\
    ':string :stdin.get[stdin = (:string input)]'\
    '< "'${ZESHY_STDIN_PATH}'"' <<'/---'
Get all standard input to the current context if such input exists or block
indefinitely and silently until such input is written to such context. Since
such blocking is strongly undesirable, this alias should _always_ be preceded by
tests ensuring such input exists (e.g., :stdin.is_nonempty(),
die_unless_stdin_readable_sans_blocking()). Due to `zsh` optimization, this
alias behaves as expected even when expanded via command substitution (e.g.,
`$(:stdin.get)`).

.:stdin.get()
==========================================
[source]
------------------------------------------
>>> :string on_propaganda=\
...    "All war propaganda consists, in the last resort, in substituting
...     diabolical abstractions for human beings. Similarly, those who defend
...     war have invented a pleasant sounding vocabulary of abstractions in
...     which to describe the process of mass murder."
>>> { get_string_line "$(:stdin.get)" -1 } <<<"${on_propaganda}"
which to describe the process of mass murder.
------------------------------------------
==========================================
/---

# ....................{ GETTERS                            }....................
# On Linux, prefer canonicalizing ${ZESHY_STDIN_FILE_DESCRIPTOR_PATH} to
# ${ZESHY_STDIN_PATH}; the former tends to be a direct symbolic link to the
# desired device file, while the latter tends to only indirectly link to such
# file. While both would suffice here, canonicalizing the former should prove
# (marginally) more efficient.
#
# To ensure such canonicalization is performed in the current shell, avoid
# calling :canonicalize_path() or any other zeshy functions here. See
# set_float_to_stdout_mtime() for further details.
:alias_command ':string get_stdin_path()'\
    ':string.output "'${ZESHY_STDIN_FILE_DESCRIPTOR_PATH}'"(:A)' <<'/---'
Get the canonicalized absolute path of the device file associated with standard
input (e.g., `/dev/pts/6`).
/---

:alias_command ':string get_stdout_path()'\
    ':string.output "'${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}'"(:A)' <<'/---'
Get the canonicalized absolute path of the device file associated with standard
output (e.g., `/dev/pts/9`).
/---

:alias_command ':string get_stderr_path()'\
    ':string.output "'${ZESHY_STDERR_FILE_DESCRIPTOR_PATH}'"(:A)' <<'/---'
Get the canonicalized absolute path of the device file associated with standard
error (e.g., `/dev/pts/7`).
/---

# ....................{ SETTERS                            }....................
# Sadly, the only safe means of canonicalizing such path is as below. Replacing
# the first pipeline subcommand with a call to :canonicalize_path() uselessly
# returns "/dev/fd/0" without resolving such path. Likewise, replacing the
# second pipeline subcommand with a process substitution has the same effect.
# While such results are odd, their underlying reasons are simple: in both
# cases, zsh performs such canonicalization in a subshell attached to a
# different standard input file descriptor. Mercifully, zsh appears to perform
# pipeline subcommands consisting of only low-level builtin print() and history
# modifier "(:A)" in the current shell, ensuring as expected that the standard
# input file descriptor for the current shell is canonicalized.
#
# Since such feature is obscurely undocumented, this could change at any
# time. If it does, another (perhaps more reliable) method remains:
# coprocesses. In theory, we could redirect the result of such output to the
# identity coprocess and then copy such result from such coprocess into such
# variable. In fact, this is precisely how we currently capture standard
# output and error from commands evaluated by the current shell.
:alias_command ':void :set_string_to_stdin_file(:string string_name)'\
    'get_stdin_path | :string.set_to_stdin' <<'/---'
Set the passed string variable to the canonicalized absolute path of the device
file associated with standard input. See get_stdin_path() for further details.
/---

:alias_command ':void :set_string_to_stdout_file(:string string_name)'\
    'get_stdout_path | :string.set_to_stdin' <<'/---'
Set the passed string variable to the canonicalized absolute path of the device
file associated with standard output. See get_stdout_path() for further details.
/---

:alias_command ':void :set_string_to_stderr_file(:string string_name)'\
    'get_stderr_path | :string.set_to_stdin' <<'/---'
Set the passed string variable to the canonicalized absolute path of the device
file associated with standard error. See get_stderr_path() for further details.
/---

# ....................{ SETTERS ~ float                    }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Synchronize with set_float_to_stderr_mtime().
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
:alias_command ':void set_float_to_stdout_mtime(:string float_name)' '{
    # Validate sanity. Avoid calling :Float.die_unless(), as
    # set_float_to_stdin() already does so below.
    string float_name__sftom stdout_filename__sftom
    float_name__sftom="$(:stdin.get)"

    # Get the canonicalized absolute path of the standard output device file.
    # Assuming the current shell to be a pseudo-terminal, such file is usually a
    # symbolic link to the device file for such terminal (e.g., "/dev/pts/7").
    # Referring to standard output by such resolved rather than symbolic
    # path is essential; we run the command getting standard output''s mtime
    # from a pipeline subcommand and hence subshell in which such symbolic link
    # refers to a pipeline rather than the expected pseudo-terminal. While we
    # work around such issue by piping get_path_mtime() output to an identity
    # coprocess, this is dramatically simpler (and probably more efficient).
    :set_string_to_stdout_file stdout_filename__sftom

    # Set such float to such path''s mtime.
    get_path_mtime "${stdout_filename__sftom}" |
        set_float_to_stdin "${float_name__sftom}"
#   :output_string_to_stderr "stdout: ${stdout_filename__sftom}; mtime: ${(P)float_name__sftom}"
} <<<' <<'/---'
Set the passed float variable to the *mtime* (i.e., modification time) in high-
resolution fractional seconds since the Unix epoch of the most recent write to
standard output by the current shell. See get_time() for further details.
/---

# See set_float_to_stdout_mtime() above.
:alias_command ':void set_float_to_stderr_mtime(:string float_name)' '{
    string float_name__sftem stderr_filename__sftem
    float_name__sftem="$(:stdin.get)"
    :set_string_to_stderr_file stderr_filename__sftem
    get_path_mtime "${stderr_filename__sftem}" |
        set_float_to_stdin "${float_name__sftem}"
} <<<' <<'/---'
Set the passed float variable to the *mtime* (i.e., modification time) in high-
resolution fractional seconds since the Unix epoch of the most recent write to
standard error by the current shell. See get_time() for further details.
/---

# ....................{ CLOSERS                            }....................
:alias_command ':void close_stdin()'\
    "exec ${ZESHY_STDIN_FILE_DESCRIPTOR}<&-" <<'/---'
Close the standard input file descriptor (i.e., 0) and corresponding named pipe
(i.e., `/dev/stdin`).
/---

:alias_command ':void close_stdout()'\
    "exec ${ZESHY_STDOUT_FILE_DESCRIPTOR}>&-" <<'/---'
Close the standard output file descriptor (i.e., 1) and corresponding named pipe
(i.e., `/dev/stdout`).
/---

:alias_command ':void close_stderr()'\
    "exec ${ZESHY_STDERR_FILE_DESCRIPTOR}>&-" <<'/---'
Close the standard error file descriptor (i.e., 2) and corresponding named pipe
(i.e., `/dev/stderr`).
/---

# --------------------( WASTELANDS                         )--------------------
#   get_stdout_path | :string.set_to_stdin stdout_filename__sftom
# See set_float_to_float() for further details.

#FUXME: Document the fact that this alias blocks if standard input is empty and
#hence should *ONLY* be expanded where standard input is guaranteed to be
#nonempty.

#This is a low-level alias. _
#
#By design, this alias performs _no_ safety checks (e.g.,
#to ensure standard input is open and nonempty) and hence should only be
#expanded by functions performing such checks (e.g., set_string_to_stdin_pipe()):
#e.g.,

#   :output_string_to_stderr ok
#   :output_string_to_stderr ko
#   :string.output "stdout: ${stdout_filename__sftom}"

# ....................{ OUTPUTTERS                         }....................
#FUXME: Actually, what the heck was the original intention here? This is never
#called anywhere and is consequently "going away." (I mean, I sort of get it:
#but where, honestly, would we ever use this? At the least, it needs to be
#renamed.)
#FUXME: This would probably be more appropriate as a function. Is there any
#compelling reason for this to be an alias instead? (I can't fathom one.)
#:alias_command 'string output_stdin[stdin: string input]'\
#   '{
#        die_unless_stdin_readable_sans_blocking
#        :stdin.get
#        close_stdin
#    }'  <<'/---'
#Print standard input to the current shell. This alias is especially helpful for
#printing here-documents: e.g.,
#
#.output_stdin()
#==========================================
#[source]
#------------------------------------------
#>>> function on_acts_of_subversion() {
#...     output_stdin <<'/ooo'
#... Why are ecologists and environmentalists so feared and hated? This is
#... because in part what they have to say is new to the general public, and the
#... new is always alarming. Moreover, the practical recommendations deduced from
#... ecological principles threaten the vested interests of commerce; it is
#... hardly surprising that the financial and political power created by these
#... investments should be used sometimes to suppress environmental impact
#... studies. However, I think the major opposition to ecology has deeper roots
#... than mere economics; ecology threatens widely held values so fundamental
#... that they must be called religious. An attack on values is inevitably seen
#... as an act of subversion.
#... /ooo
#... }
#>>> get_string_line "$(on_acts_of_subversion)" 1
#Why are ecologists and environmentalists so feared and hated? This is
#------------------------------------------
#==========================================
#/---

#thematically resembles other aliases defined by this parcel 

# ....................{ RUNNERS                            }....................
#FUXME: Terribly name, as this isn't a runner in the expected sense. Instead:
#
#* Rename this alias to print_stdin().
#* Drop the suffixing "|", which most callers would find unexpected.
#* Replace existing expansions of this alias with "print_stdin |".
#:alias_command\
#    'string run_code_with_stdin_piped(
#        string command_name, string command_arg1, string command_arg2, ...)'\
#    "{
#        < \"${ZESHY_STDIN_PATH}\"
#        close_stdin
#    } |" <<'/---'
#Run the passed command by piping the standard input piped to the current
#function or script to such command. Typically, this alias is used in concert
#with the :is_stdin_pipe() function to propagate piped input: e.g.,
#
#.run_code_with_stdin_piped()
#==========================================
#[source]
#------------------------------------------
#>>> function salvia() {
#...     if { :is_stdin_pipe } {
#...         run_code_with_stdin_piped cat
#...     } else {
#...         :string.output "${@}"
#...     }
#... }
#>>> :string.output divinorum | salvia
#divinorum
#>>> salvia divinorum
#divinorum
#------------------------------------------
#==========================================
#/---

#   :Float.die_unless "${float_name__sftso}"
#FUXME: Rename to ZESHY_STDIN_FILE_DESCRIPTOR and define a new
#ZESHY_STDIN_DEVICE_FILE (or perhaps simply ZESHY_STDIN_FILE, I should think)
#global expanding to "/dev/stdin". Then replace all instances of /dev/stdin with
#"${ZESHY_STDIN_DEVICE_FILE}".
#FUXME: Do so similarly for OUTPUT and ERROR globals, below.
