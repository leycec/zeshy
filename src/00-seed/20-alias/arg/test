#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *argument count testers* (i.e., runnables testing the number of arguments
passed to the current functions or script).
/---

#FIXME: I'm increasingly disgruntled with this nomenclature. We ideally want to
#define a new alias :is_arg() reporting success if the caller passed an argument
#equal to the string following such alias. But we currently define is_arg() to
#report success if exactly one argument was passed! Clearly, as also entreated
#below, we need to rename all runnables operating on argument *COUNTS* rather
#than *CONTENTS* -- ideally suffixing "_arg" with "_count" in such runnables. A
#fairly large job, but the current approach is simply decrepit.
#FIXME: Nomenclature's not quite right at all, implying this function to return
#success if the passed string equals the concatenation of the current argument
#list -- which isn't at all what this function does. Consider renaming to, say,
#die_unless_arg_count_equals() and likewise below.
#FIXME: Right. Replace "args_" with "arg_count" in all other *GENERALIZED*
#functions below. Hence, die_unless_args_at_least() becomes
#die_unless_arg_count_at_least() but die_unless_args_2_to_3() should (at least
#for now) retain the current nomenclature.
#FIXME: *ACTUALLY*, the current nomenclature *IS* pretty hot. No, really.
#There's no reason to expand "args_" to "arg_count_" when simply the former
#suffices. For now, leave everything as is. (Indeed, rename all existing
#instances of "arg_count_" to simply "args_").
#FIXME: *ACTUALLY*, while terse, the current nomenclature does undeniably
#invite nomenclature confusion. Consider the following two aliases:
#
#* die_unless_args_equals(int count), throwing an exception unless the number
#  of arguments passed to the current runnable equals the passed integer.
#* die_unless_arg_equals(string text), throwing an exception unless at least
#  one argument passed to the current runnable equals the passed string.
#
#Semantically, those two handlers have little to nothing to do with one
#another. Syntactically, however, they read almost the exact same. Not good.
#The only reasonable solution is, indeed, to globally replace "args_" with
#"arg_count_". Just do it, and we'll all feel safer afterward.
#FIXME: That said, we *DO* have aliases like pop_args_2(), whose nomenclature
#absolutely makes sense. As ever, here's what we're reduced to conclude:
#
#* The current batch of (die_unless|is)_args_<-> functions (e.g., is_args_2())
#  are fine and require no change.
#* All other functions should be renamed from "args_" to "arg_count_".
#
#Simple.

# ....................{ TESTERS ~ count                    }....................
#FIXME: Add examples!
:alias_command '[status = :bool] is_args_equals(:int arg_count)'\
    ':is_int_equals ${#}' <<'/---'
Report success if the caller passed the passed number of arguments.
/---

:alias_command '[status = :bool] is_args_at_least(:int arg_count)'\
    ':is_int_at_least ${#}' <<'/---'
Report success if the caller passed at least the passed number of arguments.
/---

:alias_command '[status = :bool] is_args_in_range(
    :int minimum_arg_count, :int maximum_arg_count)'\
    ':is_int_in_range ${#}' <<'/---'
Report success if the caller passed a number of arguments in the passed range
(i.e., greater than or equal to the passed minimum and less than or equal to the
passed maximum).
/---

# ....................{ TESTERS ~ count : parity           }....................
:alias_command '[status = :bool] :is_arg_count_even()'\
    ':is_int_even ${#}' <<'/---'
Report success if the caller passed an even number of arguments to the current
function or script.
/---

:alias_command '[status = :bool] :is_arg_count_odd()'\
    ':is_int_odd ${#}' <<'/---'
Report success if the caller passed an odd number of arguments to the current
function or script.
/---

# ....................{ TESTERS ~ index                    }....................
#FIXME: Uhm; *DOES* this actually account for negative indices? It certainly
#should, as the nomenclature implies.
#FIXME: Declare such function with :func_().

:alias_command '[status = :bool] is_arg_index(:int arg_index)'\
    'is_arg_index ${#}' <<'/---'
Report success if the passed integer is a valid index into the current argument
list (i.e., is in the range `[1, ${#}]`).
/---
# Such implementation may appear inefficient but *IS* fairly reasonable, given
# the subtleties involved in accounting for negative indices.
function is_arg_index() {
    die_unless_args_2 'Expected one argument count and one argument index.'
    :is_int_in_range "${2}" 1 "${1}"
}

# ....................{ TESTERS ~ match                    }....................
:alias_command '[status = :bool] :is_arg_count_equals(:string arg)'\
    '{ (( ${@[(ie)$(:stdin.get)]} <= ${#} )) } <<<' <<'/---'
Report success if the caller passed the passed argument.
/---

:alias_command '[status = :bool] :is_arg_matches_glob(:string glob)'\
    '{ (( ${@[(i)$(:stdin.get)]} <= ${#} )) } <<<' <<'/---'
Report success if the caller passed an argument matching the passed glob.
/---

# ....................{ TESTERS ~ option                   }....................
#FIXME: Aliases below should be dynamically constructed rather than manually
#defined -- for both sanity and efficiency. Arguably, they should also inline
#such test rather than call a setter. Contemplate, in any case.
#FIXME: If *NOT* compiling a debug build, such aliases should *NOT* be reduced
#to noops -- unlike the comparable is_arg_*() aliases, which should be. In other
#words, no significant changes here.
#FIXME: Actually, we really want a single :arg_nonoptions_count.equals()
#function. *MUCH* simpler for callers to grok. Efficiency is largely
#irrelevant here.

:alias_command '[status = :bool] is_arg_nonoption()'\
    'is_arg_nonoptions_1' <<'/---'
Report success if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---

:alias_command '[status = :bool] is_arg_nonoptions()'\
    'is_arg_nonoptions_1_or_more' <<'/---'
Report success if the caller passed at least one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---

:alias_command '[status = :bool] is_arg_nonoptions_0()'\
    '{
        :int count__ian0; set_integer_to_arg_nonoption_count count__ian0
        (( count__ian0 == 0 ))
    }' <<'/---'
Report success if the caller passed no non-option arguments. See
set_integer_to_arg_nonoption_count() for further details.
/---

:alias_command '[status = :bool] is_arg_nonoptions_1()'\
    '{
        :int count__ian1; set_integer_to_arg_nonoption_count count__ian1
        (( count__ian1 == 1 ))
    }' <<'/---'
Report success if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---

:alias_command '[status = :bool] is_arg_nonoptions_1_or_more()'\
    '{
        :int count__ian1om; set_integer_to_arg_nonoption_count count__ian1om
        (( count__ian1om >= 1 ))
    }' <<'/---'
Report success if the caller passed at least one non-option arguments. See
set_integer_to_arg_nonoption_count() for further details.
/---

:alias_command '[status = :bool] is_arg_nonoptions_1_to_3()'\
    '{
        :int count__ian1t3; set_integer_to_arg_nonoption_count count__ian1t3
        (( 1 <= count__ian1t3 && count__ian1t3 <= 3 ))
    }' <<'/---'
Report success if the caller passed between one to three non-option arguments.
See set_integer_to_arg_nonoption_count() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
