#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *argument count testers* (i.e., runnables testing the number of arguments
passed to the current functions or script).
/---

# ....................{ TESTERS ~ count                    }....................
#FIXME: Add examples!
:alias_command '[status=:bool] ":arg_count.=="(:int arg_count)'\
    ':int.== ${#}' <<'/---'
Report success if the caller passed the passed number of arguments.
/---

:alias_command '[status=:bool] ":arg_count.>="(:int arg_count)'\
    ':int.">=" ${#}' <<'/---'
Report success if the caller passed at least the passed number of arguments.
/---

:alias_command '[status=:bool] ":arg_count.>=<"(
    :int minimum_arg_count :int maximum_arg_count)'\
    ':int.">=<" ${#}' <<'/---'
Report success if the caller passed a number of arguments in the passed range
(i.e., greater than or equal to the passed minimum and less than or equal to the
passed maximum).
/---

# ....................{ TESTERS ~ count : parity           }....................
:alias_command '[status=:bool] :arg_count.is_even()'\
    ':is_int_even ${#}' <<'/---'
Report success if the caller passed an even number of arguments to the current
function or script.
/---

:alias_command '[status=:bool] :arg_count.is_odd()'\
    ':is_int_odd ${#}' <<'/---'
Report success if the caller passed an odd number of arguments to the current
function or script.
/---

# ....................{ TESTERS ~ index                    }....................
#FIXME: This should account for negative indices, which it currently does *NOT*.

:alias_command '[status=:bool] :arg_index.is(:int arg_index)'\
    ':arg_index.is ${#}' <<'/---'
Report success if the passed integer is a valid index into the current argument
list (i.e., is in the range `[1, ${#}]`).
/---

:func.doc  <<'/---'
[status=:bool] :arg_index.is(:int arg_count :int arg_index)

See the :arg_index.is() alias.
/---
function :arg_index.is() {
    die_unless_args_2 'Expected one argument count and one argument index.'

    # This implementation may appear inefficient but *IS* fairly reasonable,
    # given the subtleties involved in accounting for negative indices.
    :int.'>=<' "${2}" 1 "${1}"
}

# ....................{ TESTERS ~ match                    }....................
:alias_command '[status=:bool] ":arg.=="(:str arg)'\
    '{ (( ${@[(ie)$(:stdin)]} <= ${#} )) } <<<' <<'/---'
Report success if the caller passed the passed argument.
/---

:alias_command '[status=:bool] :arg.matches_glob(:str glob)'\
    '{ (( ${@[(i)$(:stdin)]} <= ${#} )) } <<<' <<'/---'
Report success if the caller passed an argument matching the passed glob.
/---

# ....................{ TESTERS ~ option                   }....................
:alias_command '[status=:bool] ":arg_count_nonoptions.>=<"(
    :int minimum_arg_count :int maximum_arg_count)'\
    ':arg_count_nonoptions.">=<" "${@}"' <<'/---'
Report success if the caller passed a number of non-option arguments in the
passed range (i.e., greater than or equal to the passed minimum and less than or
equal to the passed maximum).

== See Also ==

* :Arg_count_nonoption().
/---

:func.doc  <<'/---'
[status=:bool] ":arg_count_nonoptions.>=<"(
    *:str args :int minimum_arg_count :int maximum_arg_count)
    
See the :arg_count_nonoptions.">=<"() alias.
/---
function :arg_count_nonoptions.'>=<'() {
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one minimum argument count, and one maximum argument count.'
    local\
        minimum_arg_count=${@[-2]}\
        maximum_arg_count=${@[-1]}\
        arg_nonoption_count

    # Reduce the current argument list to the argument list passed to the caller
    # alias expansion.
    :args.pop 2

    # Number of non-options passed to the caller alias expansion.
    :Arg_count_nonoption arg_nonoption_count

    # Test such number against the passed range.
    :int.'>=<'\
        ${arg_nonoption_count} ${minimum_arg_count} ${maximum_arg_count}
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Aliases below should be dynamically constructed rather than manually
#defined -- for both sanity and efficiency. Arguably, they should also inline
#such test rather than call a setter. Contemplate, in any case.
#
#If *NOT* compiling a debug build, such aliases should *NOT* be reduced to noops
#-- unlike the comparable is_arg_*() aliases, which should be. In other words,
#no significant changes here.
#FUXME: Actually, we really want a single :arg_nonoptions_count.equals()
#function. *MUCH* simpler for callers to grok. Efficiency is largely
#irrelevant here.
#FUXME: Right. Pretty much everything below is *TERRIBLE*. Instead, we want to:
#
#* Define a new :arg_count.is_nonoptions_equals() alias-function pair (i.e., an
#  alias and a function sharing that name).
#* Replace all uses of argument count-specific aliases defined below by
#  :arg_count.is_nonoptions_equals. Obviously, this *MUST* be done manually.
#* Excise all argument count-specific aliases defined below.

# :alias_command '[status=:bool] is_arg_nonoptions()'\
#     'is_arg_nonoptions_1_or_more' <<'/---'
# Report success if the caller passed at least one non-option argument. See
# :Arg_count_nonoption() for further details.
# /---
#
# :alias_command '[status=:bool] is_arg_nonoptions_0()'\
#     '{
#         :int count__ian0; :Arg_count_nonoption count__ian0
#         (( count__ian0 == 0 ))
#     }' <<'/---'
# Report success if the caller passed no non-option arguments. See
# :Arg_count_nonoption() for further details.
# /---
#
# :alias_command '[status = :bool] is_arg_nonoptions_1()'\
#     '{
#         :int count__ian1; :Arg_count_nonoption count__ian1
#         (( count__ian1 == 1 ))
#     }' <<'/---'
# Report success if the caller passed one non-option argument. See
# :Arg_count_nonoption() for further details.
# /---
#
# :alias_command '[status = :bool] is_arg_nonoptions_1_or_more()'\
#     '{
#         :int count__ian1om; :Arg_count_nonoption count__ian1om
#         (( count__ian1om >= 1 ))
#     }' <<'/---'
# Report success if the caller passed at least one non-option arguments. See
# :Arg_count_nonoption() for further details.
# /---
#
# :alias_command '[status = :bool] is_arg_nonoptions_1_to_3()'\
#     '{
#         :int count__ian1t3; :Arg_count_nonoption count__ian1t3
#         (( 1 <= count__ian1t3 && count__ian1t3 <= 3 ))
#     }' <<'/---'
# Report success if the caller passed between one to three non-option arguments.
# See :Arg_count_nonoption() for further details.
# /---

#FUXME: I'm increasingly disgruntled with this nomenclature. We ideally want to
#define a new alias :is_arg() reporting success if the caller passed an argument
#equal to the string following such alias. But we currently define is_arg() to
#report success if exactly one argument was passed! Clearly, as also entreated
#below, we need to rename all runnables operating on argument *COUNTS* rather
#than *CONTENTS* -- ideally suffixing "_arg" with "_count" in such runnables. A
#fairly large job, but the current approach is simply decrepit.
#FUXME: Nomenclature's not quite right at all, implying this function to return
#success if the passed string equals the concatenation of the current argument
#list -- which isn't at all what this function does. Consider renaming to, say,
#die_unless_arg_count_equals() and likewise below.
#FUXME: Right. Replace "args_" with "arg_count" in all other *GENERALIZED*
#functions below. Hence, :arg_count.die_unless_>=() becomes
#die_unless_arg_count_at_least() but die_unless_args_2_to_3() should (at least
#for now) retain the current nomenclature.
#FUXME: *ACTUALLY*, the current nomenclature *IS* pretty hot. No, really.
#There's no reason to expand "args_" to "arg_count_" when simply the former
#suffices. For now, leave everything as is. (Indeed, rename all existing
#instances of "arg_count_" to simply "args_").
#FUXME: *ACTUALLY*, while terse, the current nomenclature does undeniably
#invite nomenclature confusion. Consider the following two aliases:
#
#* :arg_count.die_unless_==(int count), throwing an exception unless the number
#  of arguments passed to the current runnable equals the passed integer.
#* :arg.die_unless_==(string text), throwing an exception unless at least
#  one argument passed to the current runnable equals the passed string.
#
#Semantically, those two handlers have little to nothing to do with one
#another. Syntactically, however, they read almost the exact same. Not good.
#The only reasonable solution is, indeed, to globally replace "args_" with
#"arg_count_". Just do it, and we'll all feel safer afterward.
#FUXME: That said, we *DO* have aliases like pop_args_2(), whose nomenclature
#absolutely makes sense. As ever, here's what we're reduced to conclude:
#
#* The current batch of (die_unless|is)_args_<-> functions (e.g., is_args_2())
#  are fine and require no change.
#* All other functions should be renamed from "args_" to "arg_count_".
#
#Simple.
