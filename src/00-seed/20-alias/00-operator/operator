#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *operators* (i.e., syntactic constructs semantically resembling but
syntactically differing from conventional functions).
/---

# Since `zsh` expands aliases in function definitions at the time of such
# definitions (rather than the time of calls to such functions), all aliases
# referenced by function definitions in the official `zeshy` codebase must be
# defined before such functions.

# ....................{ DEPRECATED                         }....................
#FIXME: Excise me *AFTER* the codebase has (more or less) entirely been excised
#of such raggle-taggle riffraff.
() {
    local operator_name
    for   operator_name (is si noop not or and) {
        alias -g ${operator_name}=$'\n'':die "Deprecated operator '${operator_name}'() referenced."'
    }
}

# ....................{ OPERATORS                          }....................
:alias_command '[status = :int] :noop(:string... args?)' ':' <<'/---'
Perform parameter expansion on the passed arguments but otherwise ignore such
arguments.

== Exit Status ==

Since this alias explicitly runs no commands, success is typically reported.
Since this alias can implicitly run commands (e.g., for arguments subject to
parameter expansion flag `(e)`), however, failure can be reported under obscure
edge cases.
/---

# ....................{ OPERATORS ~ bool                   }....................
#FIXME: Actually, wouldn't defining such alias as a simple alias suffice?

:alias_word '[status = :bool] :is(:string... tests)' '[[' <<'/---'
Report success if all passed test operators succeed. Due to `zsh` constraints,
the last argument _must_ be :si(): e.g.,

.is()
==========================================
[source]
------------------------------------------
>>> :string on_the_people=\
...     "Vimes had spent his life on the streets, and had met decent men and
...      fools and people who'd steal a penny from a blind beggar and people who
...      performed silent miracles or desperate crimes every day behind the
...      grubby windows of little houses, but he'd never met The People. People
...      on the side of The People always ended up disappointed, in any case.
...      They found that The People tended not to be grateful or appreciative or
...      forward-thinking or obedient. The People tended to be small-minded and
...      conservative and not very clever and were even distrustful of
...      cleverness. And so the children of the revolution were faced with the
...      age-old problem: it wasn't that you had the wrong kind of government,
...      which was obvious, but that you had the wrong kind of people. As soon
...      as you saw people as things to be measured, they didn't measure up."
>>> is "${on_the_people}" == *things* si and :string.output\
...     "Stories of imagination tend to upset those without one."
Stories of imagination tend to upset those without one.
------------------------------------------
==========================================
/---

:alias_word ':void :si()' ']]' <<'/---'
Terminate the prior expansion of :is(). This alias _must_ be the last argument
passed to such alias. See :is() for further details.
/---

#FIXME: Add scrumptuous examples, both here and below.
:alias_word\
    '[status = :bool] :not(:string command_name, :string... command_args?)'\
    '!' <<'/---'
Report success if the passed command fails.
/---

:alias_word\
    '[status = :bool] :or(:string command_name, :string... command_args?)'\
    '||' <<'/---'
Report success if the either the passed or preceding commands succeed. If this
alias is _not_ preceded by a command, an exception is thrown.
/---

:alias_word\
    '[status = :bool] :and(:string command_name, :string... command_args?)'\
    '&&' <<'/---'
Report success if the both the passed and preceding commands succeed. If this
alias is _not_ preceded by a command, an exception is thrown.
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Excise is() after switching to :is() everywhere. *sigh*
#FUXME: Excise si() after switching to :si() everywhere. *sigh*
#FUXME: Excise noop() after switching to :noop() everywhere.
#FUXME: Excise and() after switching to :and() everywhere. *sigh*
#FUXME: Excise or() after switching to :or() everywhere. *sigh*

#FUXME: All such aliases should be declared with :alias_word() rather
#than the current improper usage of :alias_command().

# Handle *global aliases* (i.e., aliases expanded in any position rather than
# merely in command position).

# :alias_command '[status: true] noop(string arg1?, ...)' ':' <<'/---'
# Excise me.
# /---

# :alias_word <<'/---'
# [status: bool] and(string command_name, string command_arg1?, ...)
# 
# Human-readable synonym for `&&`, syntactic sugar conjunctively ANDing the exit
# statuses of the preceding and following commands.
# /---
# :alias_word and='&&'

# Human-readable synonym for `||`, syntactic sugar disjunctively ORing the exit
# statuses of the preceding and following commands.

# Human-readable synonym for `!`, syntactic sugar negating the exit status of the
# following command.

# Human-readable synonym for `]]`, syntactic sugar suffixing boolean tests. See
# is() for further details.

# residing between this and the subsequent
# expansion of :si() on the same lexical line succeed: e.g.,
# .  Human-readable synonym for `[[`, syntactic sugar prefixing boolean tests

#>>> is "PatGoD" == *GoD si and :string.output "Piper methysticum"
#Piper methysticum

# ....................{ RUNNERS                            }....................
#FUXME: Excise! We really shouldn't be using this anywhere, anymore.
#:alias_command <<'/---'
#string interactively(
#    string command_name, string command_arg1, string command_arg2, ...)
#
#Run the passed command only if the current shell is interactive. See
#is_shell_interactive() for further details.
#/---
#alias interactively='is_shell_interactive and'

#Define _all_ aliases subsequently expanded by functions definitions.
# Syntactic sugar signifying the delimiting suffix for a boolean test.
# [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
#Since Zeshy is function autoload-based and aliases
# cannot be autoloaded, Zeshy confines alias definitions to only this file.

#FUXME: Shift entire file as is to "always/00-startup/00-alias". This isn't
#simply "because we can, now"; it's actually subtly essential:
#
#1. It guarantees such aliases to be registered in the global list
#   ${ZESHY_ALIAS_NAMES} and hence unaliases on restarting Zeshy.
#2. It's also more efficient. Compiling aliases into a function eliminates
#   excess whitespace and documentation.
#
#On the other hand, doing so necessitates a slight rewrite of "compile".
#Nothing too big, but the occasional bug may crop up...

#FUXME: Rename global_*() to *_global() everywhere: e.g., from
#string_global() to string_global() and from
#string_global_constant() to string_global_constant(). Helpful to be consistent.

# ....................{ VARIABLES                          }....................
# void freeze_variable(string variable_name)
#
# Render the passed variable read-only (e.g., "const", "final").
#alias freeze_variable='typeset -r'

# void list_global_constant(list variable_name)
#
# Globally declare a list constant.
#alias list_global_constant='typeset -axr'

# void listset_global_constant(list variable_name)
#
# Globally declare a list set constant (i.e., a list ignoring duplicate values).
#alias listset_global_constant='typeset -Uaxr'

# void map_global_constant(map variable_name)
#
# Globally declare a map constant.
#alias map_global_constant='typeset -Axr'

# Success code, as returned by successful processes on process completion.
# value  tends to be the conventional choice.
# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
# void remove_first_arg()
#alias get_one_arg_shifted='output "${1}"; shift_arg'
#alias get_one_arg_popped='output "${@[-1]}"; pop_arg'

# Delete the temporary function used to construct the above aliases.
#unfunction make_die_unless_alias

# For convenience, "-h" and
# "--help" are always parsed as valid argument options# void set_first_arg_to_piped_input()
#alias parse_args='zparseopts -D -E -A ARGS -- h -help'

# void prepend_piped_input_to_args()
# void append_piped_input_to_args()
# void append_args_with_stdin_if_piped()

# For clarity, Zeshy uses the verbs "shift" and "pop" in the Perl sense.

#FUXME: What does "ignoring duplicate values" even mean in the context of a map?
# void map_set(string variable_name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
#alias map_set='typeset -UA'

# void map_global_set(string variable_name)
#
# Globally declare a map set (i.e., a map ignoring duplicate values).
#alias map_global_set='typeset -UAx'

#FUXME: Not quite right. Should technically read "#funcstack == 1". We
#temporarily permit one additional layer of function calls to permit calls by
#interactive aliases to be considered as "directly." While we should certainly
#revert this back to "#funcstack == 1", doing so requires we leverage function
#aliases rather than interactive aliases: e.g., rather than this
#
#    alias_cli cd='change_path'
#    change_path() { ... }
#
#we do this:
#
#    change_path cd() { ... }
#
#It's more or less fine for now, but should be looked at.
#FUXME: Actually, this is pretty terrible, and should be excised everywhere
#currently called (which shouldn't be terribly many, by now).

# string is_interactive_directly(string command_name, string option1, string option2, ...)
#
# Return true if:
#
# * The current function was not called by another function (i.e., was called
#   directly by the current user from the command-line interface).
# * The current shell is attached to a terminal device and interactively reading
#   commands from standard input.
#alias is_interactive_directly='(( ${#funcstack} <= 2 )) and is_interactive'

#alias set_args_to_stdin_if_piped=':is_stdin_pipe and :args.set "$(get_stdin_piped)"'
#FUXME: !!!!!DEPRECATED!!!!! This alias has **SEVERE** fatal errors.
#Necessarily use set_to_piped_input() instead.
# string get_stdin_piped()
#
# Get the standard input piped to the current function or script as a string.
# This is typically used with :is_stdin_pipe(): e.g.,
#
#     >>> ska_maria() {
#     ...     if :is_stdin_pipe
#     ...     then print -- "$(get_stdin_piped)"
#     ...     else print -- "${@}"
#     ...     fi
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#alias get_stdin_piped='die "this function should be calling set_to_piped_input(), instead!"'

#FUXME: Sweet; these can *ALL* be made functions. Switch! Awesome.
# boolean die_unless_stdin_pipe()
#
# Return true if standard input to the current function or script is a pipe.
#alias :is_stdin_pipe='is -p /dev/stdin si'

# boolean :is_stdin_pipe()
#
# Return true if standard input to the current function or script is a pipe.
#alias :is_stdin_pipe='is -p /dev/stdin si'

#alias get_stdin_piped='< /dev/stdin'
#alias get_stdin_piped='< /dev/stdin && exec 0<&-'

#string output
#output :string.output | set_to_piped_input
#set_to_piped_input output
#alias 'piped_input_string
#alias set_to_piped_input='
#    is -n "${__print__+x}" si or string __print__;
#    __print__="$(< /dev/stdin)";
#    exec 0<&-'

#alias set_print_to_piped_input='
#    is -n "${output+x}" si or string output;
#    output="$(< /dev/stdin)";
#    exec 0<&-'

# ....................{ TYPES ~ interactive aliases        }....................
# Defer defining the following functions until having defined all prior aliases.

#FUXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

#FUXME: Clean up documentation everywhere below.
#FUXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FUXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> alias_cli_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing callable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> alias_cli_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> alias_cli_substitution {m}k{d}ir='mkdir -v --'
#    >>> alias_cli_substitution {mkd}ir='mkdir -v --'
#    >>> alias_cli_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing alias_cli_abbreviation() or alias_cli() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#function alias_cli_substitution() {
#    (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or report_success
#    string ALIAS_TYPE='substitution'
#    alias_cli "${@}"
#}

# void alias_cli_abbreviation(string alias_specification)
#
# If the current user has enabled the configuration global
# ${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}, define an interactive
# abbreviation according to the passed "="-delimited alias specification: e.g.,
#
#     >>> alias_cli_abbreviation p="print Thunnus maccoyii"
#     >>> p
#     Thunnus maccoyii
#     >>> () { p }
#     p: interactive abbreviation "p" cannot be called non-interactively
#     print_stack_trace: "p" failed with exit status 1.
#
# Interactive abbreviations are interactive aliases (and hence intended to be
# called only directly from the command line), such that:
#
# * If the passed alias name has the same name as some existing callable (e.g.,
#   builtin, command), print a warning and return without defining such alias.
#
# Interactive abbreviations *NEVER* replace existing callables, but are
# otherwise identical to interactive aliases.
#function alias_cli_abbreviation() {
#    (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or report_success
#    string ALIAS_TYPE='abbreviation'
#    alias_cli "${@}"
#}

#FUXME: This still isn't quite right. The reason is subtle:
#    alias_cli ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

# void alias_cli(string alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See
# alias_cli_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> alias_cli print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
#function alias_cli() {
    # Validate passed arguments, splitting the "="-delimited alias name and
    # expansion split from all passed strings. Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
#    die_unless_args
#    string\
#        alias_name="${*%%[[:space:]]#\=*}"\
#        alias_expansion="${*#*\=[[:space:]]#}"\
#        alias_name_type command_name\
#        alias_expansion_if_interactive alias_expansion_if_non_interactive\
#        alias_logic_if_interactive alias_logic_if_non_interactive
#   print "args: ${*%%=*}"

    # Type of interactive alias to be defined, defaulting to "alias" if not
    # already set by the caller. Recognized types include:
    #
    # * "substitution", only set by alias_cli_substitution().
    # * "abbreviation", only set by alias_cli_abbreviation().
    # * "alias", only set by this function.
#    string ALIAS_TYPE="${ALIAS_TYPE:-alias}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "alias type: ${ALIAS_TYPE}\nalias name: ${alias_name}\nalias expansion: ${alias_expansion}" 1>&2

    # Validate passed arguments.
#    is "${ALIAS_TYPE}" == (substitution|abbreviation|alias) si or
#        :die "interactive alias type \"${ALIAS_TYPE}\" unrecognized"
#    is "${alias_name}" == "${alias_expansion}" si and
#        :die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '=' delimiter"
#    (( ${#alias_name} )) or
#        :die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
#    (( ${#alias_expansion} )) or
#        :die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

    # If such alias name contains at least one "{"- and "}"-delimited substring,
    # concatenating all such substrings provides the abbreviation name embedded
    # in such alias name (e.g., abbreviation "ichy" in alias "l{ich}mumm{y}").
    # Parse and possibly define such abbreviation.
#    is "${alias_name}" == *'{'*'}'* si and
#        _parse_embedded_alias_cli_abbreviation

    # If such alias name is already a declared...
#    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # ...zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
#        if is "${alias_name_type}" == 'function' si and
#        then :die "interactive ${ALIAS_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"
        # ...any other callable (e.g., alias, builtin, command) and this is an
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
#        elif is "${ALIAS_TYPE}" == 'abbreviation' si; then
#            print_warning "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#            report_success
#        # Otherwise, silently wrap such callable in the passed alias.
#        fi
    # If such alias name is *NOT* already a declared callable and this is an
    # interactive substitution alias, there exists nothing to be substituted.
    # Throw an exception.
#    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#        :die "interactive substitution \"${alias_name}\" not a defined command or builtin"
    # Otherwise, declare such callable as the the passed alias.
#    fi
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # If the command (i.e., the first word) the alias expands to is the same as
    # the alias name but is not an existing callable, assume the caller is
    # attempting to interactively alias a function of the same name: e.g.,
    #
    #  alias_cli recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "alias_cli recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
#    command_name="${alias_expansion[(w)1]}"
#    is "${alias_name}" == "${command_name}" si and
#        not whence -- "${command_name}" 1>/dev/null 2>&1 and
#        :die "interactive alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # Interactive logic to be performed by the function definition below.
#    alias_expansion_if_interactive="${alias_expansion} \"\${@}\""
#    alias_logic_if_interactive="
#    if :is_stdin_pipe
#    then run_code_with_stdin_piped ${alias_expansion_if_interactive}
#    else ${alias_expansion_if_interactive}
#    fi"

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing callable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
#    if is "${alias_name_type}" == 'none' si
#    then alias_logic_if_non_interactive="die 'interactive ${ALIAS_TYPE} \"${alias_name}\" cannot be called non-interactively'"
#    else
#        alias_expansion_if_non_interactive="${alias_name} \"\${@}\""
#        alias_logic_if_non_interactive="
#    if :is_stdin_pipe
#    then run_code_with_stdin_piped ${alias_expansion_if_non_interactive}
#    else ${alias_expansion_if_non_interactive}
#    fi"
#    fi

    # Define the desired alias as a function of the same name to:
    #
    # * Temporarily disable this function to prevent infinite recursion on
    #   subsequently calling an alias, builtin, or command of the same name.
    # * If:
    #   * This shell is interactive, thus excluding non-interactive scripts.
    #   * Standard :string.output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
    #   * This "alias" was called directly from the command line, thus
    #     excluding non-interactive calls from functions.
    #   * Then run the passed alias expansion.
    # * Else, run the desired non-interactive expansion.
    # * Regardless of whether such run throws an exception, always re-enable
    #   this function for subsequent calling.
#    eval "function ${alias_name}() {
#    {
#        disable -f ${alias_name}
#        if [[ -o interactive && -t ${ZESHY_STDOUT_FILE_DESCRIPTOR} && \${#funcstack} -eq 1 ]]
#        then ${alias_logic_if_interactive}
#        else ${alias_logic_if_non_interactive}
#        fi
#    } always {
#        enable -f ${alias_name}
#    }
#}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2
#}

# void _parse_embedded_alias_cli_abbreviation()
#
# Parse "{"- and "}"-delimited substrings from the current interactive alias
# name of the current type ("substitution" or "abbreviation") expanding to the
# current alias expansion. Concatenating such substrings gives the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing callables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
#
# This function is a helper intended to be called only by alias_cli(),
# thus accepting no arguments and returning no values.
#_parse_embedded_alias_cli_abbreviation() {
    # Validate sanity.
#    die_if_args

    # If such abbreviation is invalid, throw an exception.
#    is "${ALIAS_TYPE-}" == 'alias' si and
#        :die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a \"{...}\" but is neither an abbreviation or substitution"
#    is "${alias_name}" == \{[^\{\}]#\} si and
#        :die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a full \"{...}\""
#    is "${alias_name}" == *\{\}* si and
#        :die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an empty \"{}\""
#    is "${alias_name}" == *\{[^\}]# si and
###        :die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an unclosed '{'"

    # Copy of the passed alias name.
#    string alias_name_copy="${alias_name}"

    # Abbreviation name parsed from ${alias_name_copy}.
#    string abbre_name

    # Character succeeding the leftmost "}" in ${alias_name_copy}.
#    string abbre_next_char

    # 1-based indices of the characters immediately preceding and succeeding
    # the leftmost "}" in ${alias_name_copy}.
#    integer\
#        abbre_last_char_index\
#        abbre_next_char_index abbre_next_next_char_index

    # Iteratively shift the leftmost "}" in ${alias_name_copy} right one
    # character until either finding an abbreviation name claimed by no
    # existing callable or reaching the end of ${alias_name_copy}.
#    while true; do
#        abbre_name="${alias_name_copy//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       print_string_with_escapes "abbreviation: ${abbre_name}"
        #FUXME: Reenable!
#        whence -- "${abbre_name}" 1>/dev/null 2>&1 or break

        # Find the index of the leftmost "}" in ${alias_name_copy} by
        # matching the first "{..}" in such copy. Dismantled, this is:
        #
        # * "#", matching from the beginning of ${alias_name_copy}.
        # * "(#m)", setting global integer ${MEND}, the 1-based index of
        #   the last character matched -- in this case, the leftmost "{".
#        noop "${alias_name_copy#(#m)[^\{\}]#\{[^\{\}]##\}}"

        # If the index of the leftmost "}" is the last character in
        # ${alias_name_copy}, the prior iteration shifted such "}" to the
        # end of such copy and hence exhausted all characters. Return!
#        (( abbre_next_char_index = MEND + 1 ))
#        (( abbre_next_char_index < ${#alias_name_copy} )) or break

        # Otherwise, get the character succeeding the leftmost "}".
#        (( abbre_last_char_index = MEND - 1 ))
#       :string.output "abbre_next_char_index: ${abbre_next_char_index}"
#        abbre_next_char="${alias_name_copy[${abbre_next_char_index}]}"

        # Shift the leftmost "}" in ${alias_name_copy} right one character.
        #
        # If the character succeeding the leftmost "}" is a "{", there exist
        # two adjacent "{..}" expressions (e.g., "{mk}{d}ir"). Do not shift
        # the "}" to the right of the "{" (e.g., "{mk{}d}ir"); rather, merge
        # the two expressions (e.g., "{mkd}ir").
#        if is "${abbre_next_char}" == '{' si; then
#            (( ++abbre_next_char_index ))
#            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${alias_name_copy[${abbre_next_char_index},-1]}"
        # Otherwise, simply shift the leftmost "}" right one character.
#        else
#            (( abbre_next_next_char_index = abbre_next_char_index + 1 ))
#            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${abbre_next_char}}${alias_name_copy[${abbre_next_next_char_index},-1]}"
#        fi
#       :string.output "new alias name: ${alias_name_copy}"
#    done

    # If all possible abbreviation names have already been claimed by
    # existing callables and:
    #
    # * This is an interactive substitution, print a warning and define no
    #   such abbreviation.
    # * This is an interactive abbreviation, do nothing (i.e., attempt to
    #   use the entire alias name stripped of "{" and "}" characters as the
    #   abbreviation name).
#    if (( abbre_next_char_index == ${#alias_name_copy} )); then
#        if is "${ALIAS_TYPE}" == 'substitution' si; then
#            string abbre_name_type
#            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#            abbre_name_type="${$(whence -w -- "${abbre_name}")##*: }"
#            print_warning "abbreviation \"${abbre_name}\" in interactive substitution \"${alias_name}\" already a defined ${abbre_name_type}:\n$(which "${abbre_name}")"
#        fi
    # If this is an interactive substitution, define an interactive
    # abbreviation of the above abbreviation name and same expansion as this
    # substitution. While this does recursively call alias_cli(), such
    # call *NEVER* performs another recursive call. (Why? Listen closely: such
    # abbreviation name contains no "{" or "}" characters and hence no embedded
    # abbreviation. Since such recursive call never calls this function, the
    # recursion is guaranteed to "bottom out" after the first recursion.)
#    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#       print "abbreviating embedded ${abbre_name}:catch\"${alias_expansion}\"" 1>&2
#        alias_cli_abbreviation ${abbre_name}:catch"${alias_expansion}"
    # If this is an interactive abbreviation, set the alias name to be returned
    # to the above abbreviation name.
#    else alias_name="${abbre_name}"
#    fi

    # Strip "{" and "}" characters from the alias name to be returned.
#    alias_name="${alias_name//[\{\}]}"
#}
