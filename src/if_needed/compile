#!/usr/bin/env zsh
# ====================[ compile                            ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Compile, handling Zeshy digest recompilation.

# ....................{ MAIN                               }....................
() {
    utter "recompiling \"${ZESHY_DIGEST_FILE}\"..."

    #FIXME: See "gwydden/output" for "TODO" comments on substantially
    #improving the theme support.
    # List of directories recursively containing files containing
    # autoloadable functions with which to populate the digest directory.
    list autoload_dirnames; autoload_dirnames=(
        "${ZESHY_AUTOLOAD_CORE_DIR}"
        "${ZESHY_AUTOLOAD_THEME_DIR}/${ZESHY_THEME}"
    )

    # List of files containing autoloadable functions with which to populate
    # the digest directory. For each file in Zeshy's command directory whose
    # filename is the name of an executable command in the $PATH, append the
    # filename to the list. Dismantled, this is:
    #
    # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
    #   command directory.
    # * "(e{[[ ... ]]})", excluding files failing the following test:
    #   * "$REPLY", the current file.
    #   * ":t", the basename of such file.
    #   * ":c", the absolute path to a command in the $PATH with such name.
    #   * "== /*", true only when ":c" succeeds in finding such a command.
    # * "or true", ignoring failure (if ":c" fails finding such a command).
    list autoload_filenames; autoload_filenames=(
        "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*(e{'[[ $REPLY:t:c == /* ]]'})
    ) or true

    # If "lsb_release" is installed, run it to obtain the distro name of the
    # current operating system. Most modern distros provide such executable
    # for exactly this purpose. While crude alternatives to "lsb_release" do
    # exist (e.g., globbing for filenames matching /etc/*release), it hardly
    # seems worth the buggy effort so early in the bootstrap process.
    # Dismantled, this is:
    #
    # * "${distro_command:c}", expanding to the absolute path of
    #   "lsb_release" if installed or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    string distro_command='lsb_release'
    if is -x "${distro_command:c}" si; then
        # Lowercase the distro name for dirname comparison.
        string distro_name autoload_distro_dir
        distro_name="${(L)$(lsb_release -si)}"
        autoload_distro_dir="${ZESHY_AUTOLOAD_DISTRO_DIR}/${distro_name}"
#           print "autoload_distro_dir: ${autoload_distro_dir}"

        # If Zeshy provides distro-specific components, append distro-
        # specific dirnames and filenames to the corresponding lists.
        if is -d "${autoload_distro_dir}" si; then
            autoload_dirnames+="${autoload_distro_dir}/always"
            autoload_filenames+=(
                "${autoload_distro_dir}/if_installed/"*(e{'[[ $REPLY:t:c == /* ]]'})
            )
        fi
    fi

    # List set of autoloadable function names defined in such listed files.
    list_set autoload_function_names
#   utter "recursively sourcing \"${ZESHY_SOURCE_DIR}\"..."

    # Load "mapfile", a core Zsh module mapping file contents to map values.
    # It's both brilliant and efficient, an unhappily rare combination. It's
    # also remarkably dangerous, since accidentally unsetting keys from this
    # map deletes the corresponding files. Hence, we immediately unload this
    # module after use.
    zmodload zsh/mapfile

    #FIXME: Terrible! Utterly. When enabled, this sporadically fails with an
    #inscrutible error resembling:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent Zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#       typeset -r mapfile
#       print ${mapfile[/tmp/config]}
#       print -rl -- ${(f)mapfile[/usr/share/zeshy/src/autoload/if_installed/7z]}

    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file. Dismantled, this is:
    #
    # * "${^autoload_dirnames[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file of this directory.
    # * "~*.swp", excluding temporary files.
    # * "(.L+0)", including only non-empty plain files. "mapfile" currently
    #   fails with error on attempting to expand an empty plain file,
    #   arguably a bug. Nonetheless, respect its wishes.
    for autoload_function_filename (
        "${^autoload_dirnames[@]}"/**/*~*.swp(.L+0)
        "${autoload_filenames[@]}"
    ) {
        # Load the functions this file defines for subsequent compilation.
#           utter "sourcing \"${autoload_function_filename}\"..."
        source "${autoload_function_filename}"

        # Append to the list of autoloadable functions all:
        #
        # * Explicitly defined functions of form "${function_name}() {".
        # * Implicitly defined interactive aliases of form
        #   "interactive_alias ${alias_name}=${alias_expansion}".
        #
        # Dismantled, this is:
        #
        # * "${(f)mapfile[...]}", expanding to each line of this file.
        # * "${(M)", ":#", and "}", excluding lines not matching the
        #   following extended glob expression:
        #   * "\(\) \{", followed by "() {", signifying a function.
        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
        #     more alphanumeric, underscore, and hyphen characters.
        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
        # * "=?*", greedily matching "=" followed by one or more characters.
        #
        # Note: *DO NOT QUOTE THIS EXPRESSION*. Doing so silently expands
        # this expression to the empty string, though we have no idea why!
        # Also, do not quote the expansion of ${autoload_function_file} in
        # this expression. Doing so causes "mapfile" to interpret such
        # quotes as prefixing and suffixing such filename, thus raising an
        # exception on not finding such "munged" filename.
        autoload_function_names+=(
            ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%[(=]*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%[(=]*}
        )
#           utter "sourced \"${autoload_function_filename}\"."
    }

    # Unload "mapfile", for safety.
    zmodload -u zsh/mapfile

    # Recompile all such loaded function definitions into the digest file.
#       print "autoload function names: ${autoload_function_names[@]}"
#       utter "compiling \"${ZESHY_DIGEST_FILE}\"..."
    zcompile -c "${ZESHY_DIGEST_FILE}" "${autoload_function_names[@]}"

    # Set the mtime of the compiled script to that of the uncompiled
    # script to ensure the above conditional fails on future imports.
    touch -m --date=@"${zeshy_mtime}" "${ZESHY_DIGEST_FILE}"
#       sleep 5
}

# ....................{ WASTELANDS                         }....................
        #FIXME: This should be a "list_set" rather than "list", for a slight
        #efficiency (and clarity (and stability!)) improvement.
#
        # For clarity, temporarily set the script name to Zeshy.
#       string ZESHY_SCRIPT_NAME='zeshy'

#       zcompile "${ZESHY_DIGEST_FILE}" "${ZESHY_DIGEST_DIR}"/**/*(@)
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%( \(|\=)*}
            #FIXME: I believe these two mappings can be condensed into one.
#               ${(f)mapfile[/usr/share/zeshy/src/autoload/if_installed/7z]}
#               ${(f)mapfile[${autoload_function_filename}]}
#               ${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|interactive_alias [[:alnum:]_-]##=?)*}#interactive_alias }%%( \(|=)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#interactive_alias [[:alnum:]_-]##=?*}#interactive_alias }%%\=*}
#               ${${(M)${(f)mapfile[${autoload_function_filename}]}:#[[:alnum:]_-]##\(\) \{}%%\(*}
#               ${${${(M)${(f)mapfile[/usr/share/zeshy/src/autoload/if_installed/7z]}:#interactive_alias [[:alnum:]_-]##=?*}#interactive_alias }%%\=*}
#           print "interactive_aliases:"
#           print -rl -- ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#interactive_alias [[:alnum:]_-]##=*}#interactive_alias }%%\=*}

# --------------------( TODO                               )--------------------
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#       
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
# * Ugh. Current symlink technique doesn't quite work. It's quite close, though.
#   A working system either:
#   * Harvests the set of all function names using the current technique *AND*
#     manually recursively sources all Zeshy files (easy) *AND* uses the "-c"
#     flag to zcompile to compile all such function names into the digest
#     (easy). This isn't quite perfect, but it seems pretty darn close.
#   * Alternatively, create new temporary files in "~/.zeshy/digest/" defining
#     each such function separately by matching out the definition of such
#     functions from the existing files. This is somewhat more work, and
#     demonstrably of no greater benefit than the prior method. I reck'n it'd
#     work, but I'd rather try to pick the prior low-hanging fruit, first.


    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"

    # Automatically recompile all compiled files in function path "${FPATH}" whose
    # corresponding uncompiled files have since changed.
    #autoload -U zrecompile
#   zrecompile -p

        # Make the digest directory, if needed.
#       utter "composing \"${ZESHY_DIGEST_DIR}\"..."
#       mkdir -p "${ZESHY_DIGEST_DIR}"

        # Remove all existing symbolic links in the digest directory, if needed.
#       list digest_symlinks; digest_symlinks=( "${ZESHY_DIGEST_DIR}/"*(@) )
#       is -n "${digest_symlinks}" si and rm "${digest_symlinks[@]}"


#           print "autoload_function_file=${autoload_function_file}"
#           for autoload_function_name\
#               ( ${${(M)${(f)mapfile[${autoload_function_file}]}:#[[:alnum:]_-]##\(\) \{}%%\(*} ) {
#               ln -s\
#                   "${autoload_function_file}"\
#                   "${ZESHY_DIGEST_DIR}/${autoload_function_name}"
#           }

#       is_shell_terminal and print 'Yum!'
#       zcompile -c "${ZESHY_DIGEST_FILE}" is_shell_terminal

#   zstat +mtime "${1}"
    # Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
#   zstat +mtime "${pathname}"/**/*(om[1])

#   touch -m --date=@"${mtime}" "${pathname}"

# void _populate_zeshy_digest_dir_with(char *dirname)
#
# Populate Zeshy's digest directory with one symbolic link for each autoloadable
# function in each file of the passed directory, recursively.
#_populate_zeshy_digest_dir_with() {
#    die_unless_one_arg 'expected exactly one dirname'
#
#    # For each function declared in each file in the passed directory and
#    # subdirectories of that directory, make a symbolical link in the digest
#    # directory with that function name to that file. Dismantled, this is:
#    #
#    # * "/**/*", recursively expanding to each file and subdirectory of the
#    #   passed directory.
#    # * "~*.(swp)", excluding temporary files.
#    # * "(.)", including only plain files.
#    for autoload_function_file\
#        ( "${ZESHY_AUTOLOAD_ALWAYS_DIR}"/**/*~*.(swp)(.) ) {
#        # Dismantled, this is:
#        #
#        # * "${(f)mapfile["${autoload_function_file}"]}", iteratively
#        #   expanding to each line of this file.
#        # * "${(M)", ":#", and "}", excluding lines not matching the
#        #   following extended glob expression:
#        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
#        #     more alphanumeric, underscore, and hyphen characters.
#        #   * "\(\) \{", followed by "() {", signifying a function.
#        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
#        for autoload_function_name\
#            ( "${${(M)${(f)mapfile["${autoload_function_file}"]}:#[[:alnum:]_-]##\(\) \{}%%\(*}" ) {
#            ln -s\
#                "${autoload_function_file}"\
#                "${ZESHY_DIGEST_DIR}/${autoload_function_name}"
#        }
#    }
#}

#       for autoload_command_filename\
#           ( "${ZESHY_COMMAND_DIR}/"*(e{'[[ $REPLY:t:c == /* ]]'}) ) {
#           autoload_filenames+=( "${autoload_command_filename}" )
#       }

        #FIXME: Replace with an "rm -rf" once confident this works.
#           mv "${ZESHY_DIGEST_DIR}" "${ZESHY_DOTDIR}/tmp/$(date +'%N')"

#_zeshy_autoload_digest_old() {
    #FIXME: This only applies to developer systems. In production, Zeshy
    #requires only one initial compilation, thus eliminating the cost of such
    #recompilation. Ah; I wonder. Wouldn't a "zrecompile -p" immediately after
    #declaring the "fpath" do this, assuming we'd first compiled all necessary
    #digests? If so, that would suggest we'd only need a simple test for
    #
    #    if not is_file "${ZESHY_DIGEST_FILE}"; then
    #       # Compile everything anew here! Don't bother checking mtimes.
    #    fi
    #
    #Then, a zrecompile should handle the rest, yes? That would be considerably
    #more efficient, given Zsh's C-backed implementation. Ah; O.K., it gets even
    #better. We can entirely reduce this if-conditional to a zrecompile() call
    #resembling the given example:
    #
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"
#    utter "detecting \"${ZESHY_DIGEST_FILE}\"..."
#    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")
#    if not is_file "${ZESHY_DIGEST_FILE}" or
#        (( zeshy_mtime != $(get_path_mtime "${ZESHY_DIGEST_FILE}") )); then
#        utter "compiling \"${ZESHY_DIGEST_FILE}\"..."
#        # ...the "-." matches all files and symbolic links to files.
#        zcompile "${ZESHY_DIGEST_FILE}" "${ZESHY_SRC_HOME}"/**/*~*.(swp|zwc)(-.)

#        # Set the mtime of the compiled script to that of the uncompiled
#        # script to ensure the above conditional fails on future imports.
#        set_path_mtime "${ZESHY_DIGEST_FILE}" "${zeshy_mtime}"
#    fi

    # Declare all functions provided by the digest file to be autoloadable.
#    autoload -w "${ZESHY_DIGEST_FILE}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring Zsh
    # searches such file for the definition of such functions first. Oddly, Zsh
    # has no means of directly associating the two.
#    fpath=( "${ZESHY_DIGEST_FILE}" "${fpath[@]}" )
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
