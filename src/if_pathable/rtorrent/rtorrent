#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle `rtorrent`, a CLI BitTorrent client.
By default, rtorrent has no formal support for:

* Daemonization and hence cannot be "detached" from its parent terminal and
  attached to a new terminal.
* Backgrounding and hence requires a dedicated parent terminal *ALWAYS*
  running "rtorrent".

Hence, rtorrent behavior fundamentally differs from that of most command line-
oriented system and user services. Enter stage left: the canonical terminal
multiplexer "screen" and derivatives (e.g., "tmux"). Multiplexers decouple
command from terminal lifecycle by allowing commands to be detached from
parent terminals and subsequently reattached to new terminals, thus rectifying
all deficiencies in rtorrent itself.
/---

#FIXME: Support alternative screen muxers (e.g., "tmux" and "dtach", in that
#order).
#FIXME: Consider enabling the "multiuser" screen option rather than using
#ZY_RTORRENT_USERNAME-style sudoing. That has several benefits, of which one
#is the ability to allow other users to open the deattached rtorrent session.
#FIXME: Perform automatic logging to a file when operating as a cronjob.

# ....................{ ALIASES                            }....................
alias_cli_substitution {rt}orrent='screenify rtorrent'

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status: boolean] is_rtorrent_screen_session_running()

Return success if `screen` maintains at least one rtorrent session for the
passed user.
/---
function is_rtorrent_screen_session_running() {
    die_if_args
    (( $(get_rtorrent_process_count) ))
}

# ....................{ GETTERS                            }....................
:func.doc <<'/---'
integer get_rtorrent_screen_session_count()

Get the number of rtorrent sessions and hence processes maintained by `screen`.
/---
function get_rtorrent_screen_session_count() {
    die_if_args
    get_screen_session_count "${ZY_RTORRENT_SCREEN_SESSION_NAME}"
}

# ....................{ RUNNERS                            }....................
#FIXME: Documentation woefully outdated.
:func.doc <<'/---'
void start_rtorrent()

Daemonize `rtorrent` under the passed user (defaulting to
${ZY_RTORRENT_USERNAME} if such user exists or the current user otherwise).
${ZY_RTORRENT_USERNAME} defaults to "rtorrent", a hypothetical user
unlikely to exist on the current machine. Consider either passing or defining
${ZY_RTORRENT_USERNAME} to the non-root user you intend to run the
`rtorrent` daemon and hence actively manage torrents as. Also see the
`rtorrent` file in Zeshy''s configuration directory (e.g., `~/.zeshy/config`).

Foreground a started `rtorrent` daemon by running `rtorrent` as this user.
Background a foregrounded `rtorrent` daemon by typing the key combination
specific to the terminal multiplexer daemonizing `rtorrent`:

* If screen, <Ctrl-a d>. `Ctrl-a` is a screen-specific prefix for entering
  screen commands and `d` the screen command for detaching (i.e.,
  backgrounding) the rtorrent screen session. (C''est simple, non?)

Stop a started `rtorrent` daemon by either calling stop_rtorrent(), passing
the same user, or typing <Ctrl-q> from a foregrounded `rtorrent` daemon.
/---
function start_rtorrent() {
    # Validate passed arguments.
    die_if_args

    # Stop all "rtorrent" processes running under the requested user. To avoid
    # false positives, first remove zombie screen sessions.
    remove_screen_sessions_dead
    if { is_rtorrent_screen_session_running } {
        stop_rtorrent
    }
    print_message_item 'Starting rtorrent...'

    # If there are other rtorrent screen sessions running, warn and press on.
    if { is_rtorrent_screen_session_running } {
        print_warning\
            "$(get_rtorrent_screen_session_count) rtorrent screen session(s) already started."
    }

    # Start rtorrent as a screen session. Note that screen's argument passing
    # engine is fragile... Order is important in its list of arguments.
    command screen -d -m -fa -U -S "${SCREEN_SESSION}" "${RTORRENT}"
#       or die_from_rtorrent_start_error

    #FIXME: Convert to pure zsh.
    # Grep the PID of the screen process corresponding to the now-detached
    # rtorrent session by asking screen itself.
    string screen_pid
    screen_pid="$(screen -list |\
        grep --max-count=1 "\.${SCREEN_SESSION}[[:space:]]" |\
        sed "s/^[[:space:]]*\([0-9][0-9]*\)\.${SCREEN_SESSION}[[:space:]].*$/\1/" -)"

    #FIXME: Convert to a simple glob match.
    # If "screen" lists no such rtorrent session for this user, fail.
    is_string_matches_pcre "${screen_pid}" '^[[:space:]]*$' or
        :die "\"screen\" lists no rtorrent sessions."
##   if :stdout.echo "${screen_pid}" | is_string_matches_pcre '^[[:space:]]*$'; then
#       print_warning "\"screen\" lists no rtorrent sessions"
#       die_from_rtorrent_start_error
#   fi

    #FIXME: This is generally useful. Shift into a @{process} parcel.

    # Unfortunately, ${screen_pid} gives the process ID of the screen process
    # hosting this rtorrent process rather than that rtorrent process itself. As
    # halting this rtorrent process requires we have its ID rather than screen's
    # ID, we now grep for that.
    #
    # Note, however, that this rtorrent process may not yet have actually started
    # up. Therefore, wait a sensible number of seconds for it to start up; if it
    # fails to do so, fail.
    integer start_time close_time rtorrent_pid
    (( close_time = $(get_time) + 8 ))
    while (( $(get_time) <= close_time )) {
        # If rtorrent is now running, break.
        rtorrent_pid=$(command pgrep -P "${screen_pid}" -fx "${RTORRENT}" 2>/dev/null)\
            and break

        # Else, sleep and try again.
        sleep_seconds 1
    }

    # If rtorrent is still not running, fail.
    die_unless_string_nonempty "${rtorrent_pid}"\
        "No rtorrent process running under \"screen\" PID ${screen_pid}."

    string pid_filename; pid_filename="${ZY_USER_PID_DIR}/rtorrent"
    write_file_with_string "${pid_filename}" ${rtorrent_pid}

    print_message "Detached rtorrent PID ${rtorrent_pid} to screen PID ${screen_pid}."
}

:func.doc <<'/---'
void stop_rtorrent()

Kill the "rtorrent" daemon running under the current user. See start_rtorrent()
for further details.
/---
function stop_rtorrent() {
    :die 'unimplemented'
}

# ....................{ UTILITIES                          }....................
#FIXME: Integrates poorly with TRAPZERR(), I'm assuming. Excise?
:func.doc <<'/---'
void die_from_rtorrent_start_error()

If rtorrent failed to run for any reason other than it is already running
under an existing "screen" session, then print this reason by re-running
rtorrent as the target user.
/---
function die_from_rtorrent_start_error() {
    # If no rtorrent process has been screened, run rtorrent to emit an error.
    if { is_rtorrent_running } {
        if { is_string_nonempty "${screen_pid}" } {
            print_warning "rtorrent startup error for user ${ZY_RTORRENT_USERNAME} under screen PID ${screen_pid}."
        } else {
            print_warning "rtorrent startup error for user ${ZY_RTORRENT_USERNAME}."
        }

        run_code_as_user "${ZY_RTORRENT_USERNAME}" "${RTORRENT}"
    }

    #FIXME: Hmm.
#   exit_with_failure
}

# --------------------( WASTELANDS                         )--------------------
#rtorrent is "...a BitTorrent client for ncrys, using the libtorrent library.
#The client and library is written in C++ with emphasis on speed and
#efficiency, while delivering equivalent features to those found in GUI-based
#clients in an ncrys client."

    #FUXME: Rename make_dir_safely() to make_dir_if_not_found(). Also, add new
    #write_file_with_string() and append_file_with_string() functions to
    #"file/contents/text".
    #FUXME: Implement me. Perhaps we want a new "os/process/pid_file" component
    #for managing PID files?
#declare_global '
#string ZY_RTORRENT_USERNAME
#
#User under which Zeshy runs "rtorrent".
#'
#ZY_RTORRENT_USERNAME='rtorrent'

#   die_unless_args_0_to_1 'expected optional username'
#   string username; username="${1:-${ZY_RTORRENT_USERNAME}}"
#   is_user "${username}" or {
#       username="$(get_username)"
#       print_warning "\"${ZY_RTORRENT_USERNAME}\" not a user; defaulting to \"${username}\""
#   }

    # Stop all "rtorrent" processes running under the requested user. To avoid
    # false positives, first remove zombie screen sessions.
#   remove_screen_sessions_dead "${username}"
#   is_rtorrent_screen_session_running and stop_rtorrent "${username}"

#void start_rtorrent(string username = "${ZY_RTORRENT_USERNAME}")
#
#Daemonize "rtorrent" under the passed user (defaulting to
#${ZY_RTORRENT_USERNAME} if such user exists or the current user otherwise).
#${ZY_RTORRENT_USERNAME} defaults to "rtorrent", a hypothetical user
#unlikely to exist on the current machine. Consider either passing or defining
#${ZY_RTORRENT_USERNAME} to the non-root user you intend to run the
#"rtorrent" daemon and hence actively manage torrents as. Also see the
#"rtorrent" file in Zeshy''s configuration directory (e.g., "~/.zeshy/config").

#   integer rtorrent_process_count
#   rtorrent_process_count="$(get_rtorrent_process_count)"
#   (( rtorrent_process_count == 0 )) or
#       print_warning "${rtorrent_process_count} rtorrent screen session(s) already started"
    #FUXME: Not quite ideal. We probably want to preserve errors returned by the
    #underlying "su" or "sudo" command but not by "screen -wipe" itself. How?
#   die_unless_pathable rtorrent
#   run_code_as_user "${ZY_RTORRENT_USERNAME}" 'screen -list' |\
#       get_string_pcre_multiline_match_count "^\.${SCREEN_SESSION}[[:space:]]"
    # Store its PID into an external file for later use in shutting it down.
#   make_dir_safely "$(get_path_dirname "${pid_file}")"
# After calling this function, foreground the daemonized rtorrent process by
# simply running "rtorrent" as the passed user.
# (if somewhat antiquated)
# As much as one might love rtorrent's murkily ASCII glimmerings, its inability
# to release
# under whichbackgrounded or foregrounded to and from the command line.
# Once you start it, it's always there: consuming one virtual terminal
# (console) with its murky glimmerings.
#
# rtorrent, therefore, cannot be run as a background daemon on system startup.
# Unless we apply some external trickery! # The external applications "screen" and
# "dtach" are two such external trickeries. Both allow applications to be
# detached from the terminal from which they were run and then later
# reattached to any terminal elsewhere. "dtach" is significantly smaller and
# simpler than "screen"; however, "screen" is significantly more commonplace
# and tends to come installed (and pre-configured) on more machines. In the
# pragmatic interest of minimizing script prerequisites, therefore, this script
# leverages "screen".
#   if is_superuser "${username}"; then
#       string pid_file_dir
#       pid_file_dir="$(get_dir_writable_first '/run' '/var/run')"
#       :stdout.echo "${pid_file_dir}/${command_name}"
#   else
#       :stdout.echo "${ZY_USER_PID_DIR}/${command_name}"
#   fi

    # Get Zeshy's dot directory.
#   string home zeshy_dot_dir
#   home="$(get_user_home "${username}")"
#   zeshy_dot_dir="${home}/${ZY_DOT_DIR_BASENAME}"

    # Return such directory, if found.
#   die_unless_dir_writable "${zeshy_dot_dir}"
#   :stdout.echo "${zeshy_dot_dir}"
# Absolute path of the file persisting the running "rtorrent" process ID (PID).
#FUXME: This looks good. But we need to implement it, first! Which means,
#transitively, we need a die_unless_user() function. Here's the trivial
#awk-based implementation:
#
#  awk -F":" '{ print $1 }' /etc/passwd
#
#Of course, we then need a get_users_file() function. And then, since we'd
#rather implement a pure-zsh solution, we'd like to implement a function:
#
#string split_columns_from_lines(string text, string column_separator)
#
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which zsh *SHOULD* apply to each list member. If we can't
#do this and instead have...

#string_global_export ZY_RTORRENT_PID_FILE="$(get_pid_file "${ZY_RTORRENT_USERNAME}" rtorrent)"

#if is "${ZY_RTORRENT_USERNAME}" == root si
#then ZY_pid_file="/var/run/rtorrent.pid"
#else ZY_pid_file="/home/${ZY_RTORRENT_USERNAME}/.rtorrent.pid"
#fi
