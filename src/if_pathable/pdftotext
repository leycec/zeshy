#!/usr/bin/env zsh
# ====================[ pdftotext                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handling "pdftotext", converting PDF files to plaintext.

# ....................{ CONVERTERS                         }....................
#FIXME: "pdftotext" takes a large number of arguments. Add a new configuration
#file with such options and run "pdftotext" here under run_command_with_options().
#FIXME: If passed two arguments and the second such argument ends in anything
#other than ".pdf", interpret the latter as the target of a single conversion
#rather than a second PDF file to be converted.
#FIXME: After implementing all such improvements, enable:
#interactive_substitution {pdf}to{t}ext='convert_pdf_to_file_text'

document_function '
void convert_file_pdf_to_text(void) [or]
void convert_file_pdf_to_text(string pathname1, string pathname2, ...)

Convert the passed PDF files (defaulting to all PDF files in the current
directory) to plaintext files containing a facsimile of PDF text content. If
such path is a:

* File, convert such PDF file to plaintext.
* Directory, convert all PDF files in such directory to plaintext.
'
function convert_file_pdf_to_text() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # Convert such arguments.
    for filename ("${@}") {
        die_unless_file_type "${filename}" pdf
        die_unless_file "${filename}"
        pdftotext "${filename}"
    }
}

# ....................{ GREP                               }....................
#FIXME: It'd be great to incorporate such functionality into the grep_path_*()
#family of functions. Ideally, such functions would implicitly *TEMPORARILY*
#convert all passed binary files to plaintext prior to grepping. (Naturally,
#this is probably a bad idea when operating recursively. Or perhaps not? I mean,
#as long as we output grep progress in real-time, it's hard to see any
#complaints.)

document_function '
void grep_path_pdf(string pattern, string pathname1, string pathname2, ...)

Grep the passed paths for PDF files with text matching the passed extended
grep pattern.
'
function grep_path_pdf() {
    # Validate passed arguments.
    die_unless_args 'expected one grep expression and zero or more filenames'
    string pattern="${1}"
    shift_arg

    # Default such arguments to all PDF files in the current directory.
    is_args or set_args *.pdf

    #FIXME: Ugh. Not quite right. If passed directories, we want to non-
    #recursively search such directories for PDF files. *sigh* This suggests a
    #preliminary loop initializing a "list filenames" with such files prior to
    #actually grepping such files here.

    string basename
    for pathname ("${@}") {
        # Silently skip non-PDF files.
        is "${filename}" == *.pdf si or continue

        #FIXME: Not right. It'd be much more helpful to colorfully prefix "grep"
        #output with the PDF filename, mimicing actual "grep" print_string on files.
        basename="$(get_path_basename "${filename}")"
        say_next_section "${basename}"

        # Grep this PDF file for the passed pattern.
        pdftotext "${filename}" - | grep_path "${pattern}"
    } | page_string
}

# --------------------( WASTELANDS                         )--------------------
#   list filenames; filenames=( "${@}" )
#   is_string_nonempty "${filenames[@]}" or filenames=( *.pdf )
#   echo "files: ${filenames[@]}"
        #FIXME: I'm fairly sure "pdftotext" outputs to a file in the current
        #directory rather than the parent directory as the passed file. If so,
        #default to:
        #
        #* If the parent directory of the passed file is writable, print_string to a
        #  file with the same basename excluding ".pdf" under such directory.
        #* Else, omit the second argument as we currently do.
#grep_pdf_page() {
#    page grep_pdf "${@}"
#}

#       print_hard_rule #"==============================================================================="
#       print_message "grepping \"${filename:t}\"..."
#   string pathname; pathname="${1:-$(get_current_dir)}"
#   if is_file "${pathname}"
#   then pdftotext "${pathname}"
    #FIXME: This is demonstrably horrible. Zeshify.
#   else  # if is_dir "${pathname}"
#       interactively print_message "converting PDF files to plaintext in \"${dirname}\"..."
#       pushd "${dirname}"
#       find -iname '*.pdf' -exec pdftotext {} \;
#       popd
#   fi

#       interactively print_message "converting PDF files to plaintext in \"${dirname}\"..."
#       pushd "${dirname}"
#       find -iname '*.pdf' -exec pdftotext {} \;
#       popd

# ....................{ ALIASES                            }....................
#FIXME: It'd be far more elegant to rewrite grep_recursively() to manually
#reprint_warning over files rather than leverage the "--recry" option and, for each
#found PDF file, to call pdftotext() prior to calling grep on that file.
#Somewhat more work than I'm willing to invest in at the moment, however.
#alias grpdf="grep_pdf_page"

#   echo "grepping: ${filenames[@]}"
#FIXME: Obsolete.
#die "\"${filename}\" not a PDF file" #| "${PAGER}"
