#!/usr/bin/env zsh
# ====================[ X                                  ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle X11 and all forks thereof:
#       X.org, we're winking at you.

# ....................{ GETTERS                            }....................
declare_function '
string get_xset_status_of_type(string status_type)

Get all "xset -q" output matching the passed status type, a string exactly
matching one of following headings:

* "Keyboard Control", describing current keyboard settings.
* "Pointer Control", describing current pointer (e.g., mouse) settings.
* "Screen Saver", describing current screen saver settings.
* "Colors", describing current color settings.
* "Font Path", describing current font cache settings.
* "DPMS (Energy Star)", describing current screen dimming settings.
'
function get_xset_status_of_type() {
    # Validate passed arguments.
    die_unless_arg 'expected one heading'
    die_unless_pathable xset
    string status_type="${1}"

    # Get such output.
    xset -q | get_string_match_first_until_next "${status_type}:" '[^ ]*'
}

# ....................{ PRINTERS                           }....................
declare_function '
string print_x(void)

Print a human-readable synopsis of current X11 settings.
'
function print_x() {
    die_if_args
    print_x_keyboard
    print_x_screen
}

declare_function '
string print_x_keyboard(void)

Print a human-readable synopsis of current X11 keyboard settings.
'
function print_x_keyboard() {
    # Validate sanity.
    die_if_args

    # Print all "setxkbmap" information, as even the most verbose of the
    # information output by this utility is informatively brief.
    is_pathable setxkbmap and {
        print_message_heading 'setxkbmap'
        setxkbmap -print -verbose 10
    }

    # Print all display-specific "xset" information.
    print_message_heading 'xset'
    get_xset_status_of_type 'Keyboard Control'
}

declare_function '
string print_x_screen(void)

Print a human-readable synopsis of current X11 display settings, including:

* Current resolution.
* Dots per inch (DPI).
'
function print_x_screen() {
    # Validate sanity.
    die_if_args

    # Print a subset of all "xdpyinfo" information, as most of the information
    # output by this utility is considerably more verbose than usually desired.
    print_message_heading 'xdpyinfo'

    # Copy the print_string of "xdpyinfo" into a local variable.
    string display_info; display_info="$(xdpyinfo)"

    # Grep this variable for relevant lines.
    match_first_line ' *dimensions: ' "${display_info}"
    match_first_line ' *resolution: ' "${display_info}"
    match_first_line ' *depth of root window: ' "${display_info}"

    # Print all "xrandr" information, as most of the information output by this
    # utility is informatively brief enough to be of general use.
    print_message_heading 'xrandr'
    xrandr

    # Print all display-specific "xset" information.
    print_message_heading 'xset'
    _print_x_dpms
    get_xset_status_of_type 'Colors'
}

# ....................{ STARTERS                           }....................
declare_function '
void start_x(string startx_option1, string startx_option2, ...)

Start the X11 server and a client session connecting to such server under
the passed "startx" options. This function is a helper wrapping the "startx"
command, itself a helper wrapping the "xinit" command, supporting:

* Implicit logging of X11 standard output and error to ${ZESHY_X_LOG_FILENAME}
  (e.g., "~/.xsession"), silently overwriting prior output.
'
function start_x() {
    #FIXME: Rather than printing output on startup failure, it probably makes
    #more sense to simply tee output to such failure while retaining standard
    #output and error (i.e., stop squelching terminal output). How? Shouldn't
    #be terribly hard, perhaps leveraging zsh multios behavior.
    run_code_silent_and_write_file_with_output startx "${@}" "${ZESHY_X_LOG_FILENAME}" or {
        print_error 'X not started, since:'
        print_file_text "${ZESHY_X_LOG_FILENAME}"
        return_failure
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Uhm.
#   xset -q | grep '^Colors:$' --after-context=1
    #FUXME: Extract this filename into an X-specific config file, reverting back
    #to "${HOME}/.xsession".
#   string ZESHY_X_LOG_FILENAME="${HOME}/.xsession"
    #FUXME: Rewrite as a pipe.
#   xset -q | get_string_match_first_until_next 'Keyboard Control:' '[^ ]*'
#   xset -q | grep '^Keyboard Control:$' --after-context=13
# ....................{ STARTUP                            }....................
#FUXME: Interesting, but not terribly relevant to most people. Still, it'd be
#nice to integrate... Right; just shift into a new "X"-specific config file.
#Done! I'm not convinced we need to create such directory if not found but such
#global is set, so just excise this function.

#declare_function '
#void setup_x(void)
#
#Initialize Zeshy-specific X11 integration.
#'
#function setup_x() {
#    #FUXME: "XAPPLRESDIR" now obsoleted by "XUSERFILESEARCHPATH". Delete the
#    #former; retain the latter, after upgrading X11.
#    # Absolute path of the user-specific directory with Xt-driven (e.g., Xaw,
#    # Motif) configuration files containing application resources.
#    string_global_export\
#        XAPPLRESDIR\
#        XUSERFILESEARCHPATH
#
#    #FUXME: What's the *REAL* canonical name for such dir?
#    XAPPLRESDIR="${HOME}/.Xt"
#    XUSERFILESEARCHPATH="${XUSERFILESEARCHPATH:-${XAPPLRESDIR}/%N}"
##   make_dir_if_not_found "$(get_path_dirname "${XUSERFILESEARCHPATH}")"
#}

# ....................{ ALIASES                            }....................
#alias_cli_substitution {s}tart{x}='start_x'

#   list xset_status_lines
    # Split "xset" status print_string into lines.
#   set_list_to_string_lines xset_status_lines "$(xset -q)"
    # Remove all lines preceding such heading.
#   for line ("${xset_status_lines[@]}") {
#   }
#function get_xset_status_print_with_heading() {
#FUXME: Hmm; this really belongs in Fluviol, not here. By the time a shell has
#started up in X, you're already long past the point where you would have needed
    #FUXME: Be nice to encapsulate this functionality in a function.
    # ">!" truncates the log prior to writing.
#   run_code_to_stdout startx "${@}" >! "${HOME}/.xsession"
#   string_global\
#       XUSERFILESEARCHPATH="${XUSERFILESEARCHPATH:-${HOME}/.Xt/%N}"
