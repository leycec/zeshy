#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle `git`, the CLI for the distributed SCM of the same name.
/---

#FIXME: Implement risky commands by simply confirming such operations
#beforehand: e.g.,
#
#   # Revert the repository to the remote master. The user had better confirm!
#   >>> git reset --hard origin/master

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_dir_current_in_repository_git:(
    string error_message = "\"$(get_dir)\" not under git control.")

Throw an exception unless the current directory resides in a `git` repository. See
is_path_in_repository_git:() for further details.
/---
function die_unless_dir_current_in_repository_git:() {
    die_unless_args_0_to_1 'Expected optional error message.'
    string dirname; dirname="$(get_dir)"
    die_unless_dir_current_in_repository_git: "${dirname}"\
        "${1-\"${dirname}\" not under git control.}"
}

declare_function_with_stdin <<'/---'
void die_unless_path_in_repository_git:(
    string pathname,
    string error_message = "\"${pathname}\" not under git control.")

Throw an exception unless the passed path resides in a `git` repository. See
is_path_in_repository_git:() for further details.
/---
function die_unless_path_in_repository_git:() {
    die_unless_args_1_to_2 'Expected one pathname and optional error message.'
    string pathname="${1}"
    #FIXME: Implement me, kthx.
    is_path_in_repository_git: "${pathname}" or
        die "${2-\"${pathname}\" not under git control.}"
}

# ....................{ GETTERS                            }....................
#FIXME: Silly. Extract into a new git-specific config file.
#FIXME: Wait. Does "git" already provide a means of defining such options?

declare_function_with_stdin <<'/---'
string get_git_grep_options:(void)

Get default options to be passed to `git grep`.
/---
function get_git_grep_options:() {
    die_if_args

    #FIXME: Everything except "--ignore-case" seems sensible. We'll want a
    #separate grep_git_caseless() for that.
    output_string '--extended-regexp --ignore-case -n -C 1'
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_git_differences:(string git_revision)

Print all differences between the current and passed revision in
https://en.wikipedia.org/wiki/Diff#Unified_format[*unified `diff` format*]
(e.g., `y_u_no.c`, "HEAD^^^^:i/c_u.no").
/---
function print_git_differences:() {
    die_unless_arg 'Expected one git revision.'
    die_unless_dir_current_in_repository_git:
    command git show -- "${1}"
}

# ....................{ FINDERS                            }....................
#FIXME: Good God, but these need revision.
function grep_git_repository_from_dir_current:() {
    die_unless_arg 'Expected one grep expression.'
    print_message "Grepping \"${PWD}\" for ${@}..."
    command git grep $(get_git_grep_options) "${@}"
}

function grep_git_repository_from_dir_root:() {
    # Validate sanity.
    die_unless_arg 'Expected one grep expression.'

    ::set_git_globals:
    print_message "Grepping \"${GIT_ROOT}\" for ${@}..."

    if { is_string_empty "${IS_GIT_ROOT_PWD}" } {
        pushd "${GIT_ROOT}"
    }

    command git grep $(get_git_grep_options) "${@}"

    if { is_string_empty "${IS_GIT_ROOT_PWD}" } {
        popd
    }
}

# ....................{ PATCHES                            }....................
#FIXME: All quite old-style. Revise for nebulous profit and fun.

declare_function_with_stdin <<'/---'
void apply_patch_uri_to_repository_git:(string uri1, ...)

Temporarily download the passed URIs to local patch files, apply such files to
the local git repository containing the current directory, and remove all such
files that successfully applied to such repository. For verification, all such
files that failed to apply to such repository will be locally preseved.
/---
function apply_patch_uri_to_repository_git:() {
    # Validate sanity.
    die_unless_args 'Expected one or more patch URIs.'
    string patch_dirname patch_filename

    ::set_git_globals:
    print_message "Applying remote patches to \"${GIT_ROOT}\"..."

    # Temporary directory to which such patches will be downloaded to.
    patch_dirname="$(make_dir_temporary)"

    try {
        string patch_uri
        for    patch_uri ("${@}") {
            # If such URI is prefixed by an unsupported protocol, throw an
            # exception.
            is "${patch_uri}" == ('http'|'https'|'ftp')'://'* si or
                die 'Patch URI "'${patch_uri}'" protocol unsupported (i.e., neither "http://", "https://", or "ftp://").'

            # If such URI is suffixed by a backslash, remove such character.
            patch_uri="$(remove_string_suffix "${patch_uri}" '/')"

            # Temporary file to which such patch will be downloaded to.
            patch_filename="${patch_dirname}/$(get_path_basename "${patch_uri}")"

            # Retrieve such URI to such file.
            download_url_to_file: "${patch_uri}" "${patch_filename}"

            # Apply such patch.
            print_message "Applying \"${patch_filename}\"..."
            if { command git am "${patch_filename}" } {
                print_message "Removing \"${patch_filename}\"..."
                remove_file "${patch_filename}"
            }
        }
    } always :{
        # Remove such temporary directory and patch files.
        remove_path_recursive "${patch_dirname}"
    :}
}

# ....................{ PRIVATE                            }....................
#FIXME: O.K.; this is the culprit. Basically, this script is rather egregrious;
#it defines a die() function, which naturally conflicts with ours when we
#"source" the script. The solution is to pretty much rip out our calling of an
#external script, and instead integrate Git at the zsh level. Fortunately, this
#has already been done for us by the "zsh-git" project at:
#
#   https://github.com/jcorbin/zsh-git/blob/master/functions/zgitinit
#   https://github.com/jcorbin/zsh-git/blob/master/functions/prompt_wunjo_setup
#
#The former is the most important file; it defines all of the path handling to
#determine whether or not the current path is a git repository. The latter
#integrates that information into the prompt. For now, just get integration with
#the former to work, yo-yo?
#
#O.K.; this is officially broken, under strictness. Forget it. Incorporate the
#above logic, when time permits.
#FIXME: That said, ::set_git_globals: *DOES* seem a bit silly. After all, to
#display proper metadata on whether or not the current directory resides in a
#git repository at the prompt, an equivalent to such globals has to be
#maintained by the SCM completion module, right? Though, of course, that
#wouldn't be synchronized in the event of a non-interactive script. Oh, very
#well; we suppose there's no getting around this. Continue onward, stalwart
#hero (or tin soldier?).

declare_function_with_stdin <<'/---'
void ::set_git_globals:(void)

Set Git-specific global variables by running "/usr/libexec/git/git-sh-setup".
This locates the root of the git repository corresponding to the current
working directory, among other useful things.

Specifically, this function sets:

* ${GIT_DIR}, the absolute path to this Git repository's ".git/" directory.
* ${GIT_ROOT}, the absolute path to the parent of ${GIT_DIR}.
* ${IS_GIT_ROOT_PWD}, set if and only if ${GIT_ROOT} is the current working
  directory.
/---
function ::set_git_globals:() {
    # Validate sanity.
    die_if_args

    print_message "Looking for parent git repository..."
    SUBDIRECTORY_OK=1 source_shell_script "$(git --exec-path)/git-sh-setup"

    #FIXME: Prefix such globals by "ZESHY_".
    #FIXME: Actually declare such globals as such. Why didn't we? How could this
    #*EVER* have worked?

    # Resolve symlinks so as to permit comparison of this path against other
    # resolved, canonical paths.
#   print "GIT_DIR: ${GIT_DIR[1]%/*}"
    string GIT_ROOT="$(readlink -e "${GIT_DIR%/*}")"
    string GIT_PWD="$(readlink -e "${PWD}")"
#   print "GIT_ROOT=${GIT_ROOT}"
#   print "GIT_PWD=${GIT_PWD}"

    if is "${GIT_ROOT}" == "${GIT_PWD}" si {
        IS_GIT_ROOT_PWD=1
    } else {
        unset IS_GIT_ROOT_PWD
    }
}

# --------------------( WASTELANDS                         )--------------------
#git-apply-remote-patches http://paste.pocoo.org/raw/2408/

#FUXME: Uhm...
#function git-format-patch() {
#    local COMMITS="${1}"
#    [[ -n "${COMMITS}" ]] || COMMITS="origin/master"
#    git format-patch -M -C "${COMMITS}"
#}
#
#function git-format-patch-stdout() {
#    local COMMITS="${1}"
#    [[ -n "${COMMITS}" ]] || COMMITS="origin/master"
#    git format-patch --stdout -M -C "${COMMITS}"
#}

            #FUXME: Terrible. Call a new function -- say, download_url_to_file() --
            #implementing such functionality.
#           print_message "Getting \"${patch_uri}\" to \"${patch_filename}\".."
#           command wget --quiet --output-document="${patch_filename}" "${patch_uri}"

            # Download such URI to such file to a temporary file having the same
            # prefix as the basename of the remote file. (This should ensure
            # filename uniqueness, to a reasonable degree.)
#(which_temporary_file "${patch_uri##*/}")"

#== Riskiness ==
#
#Additional commands, for which this script provides no aliases or functions
#due to innate riskiness, include:
#
#.get_string_ansiless_length_printable()
#==========================================
#[source]
#------------------------------------------
## Revert the repository to the remote master. *DANGEROUS*, but helpful.
#>>> git reset --hard origin/master
#------------------------------------------
#==========================================

# ....................{ ALIASES                            }....................
#FUXME: Shift to new config file.
#alias_cli gita='git add'
#alias_cli gitaa='git add --all'
#alias_cli gitd='git diff'
#alias_cli gitl='git log'
#alias_cli gitc='git commit'
#alias_cli gitca='git commit --all'
#alias_cli gitcaa='git commit --all --amend'
#alias_cli gitgr='git_grep'
#alias_cli gitgrr='git_grep_root'
#alias_cli gitrei='git rebase --interactive'
#alias_cli gitrec='git rebase --continue'
#alias_cli gitp='git push'
#alias_cli gits='git status'

# Eliminate "Merged from..." commits git implicitly produces from a non-
# conflicting merge. (Rather helpful.)
#alias_cli gitreo='git rebase origin'

# Interactively rebase all commits committed since the last push to the remote
# repository. (This is the common case.)
#alias_cli gitreio='gitrei origin/master'

