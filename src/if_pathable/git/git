#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle `git`, the official CLI for the distributed version control system (DVCS)
of the same name.
/---

# For maintainability, only :die_unless_path_git(), :is_path_git(), and
# :set_string_to_path_git_dir_root_if_found() may accept the path of the file or
# directory residing in the git repository to be operated on. All other
# functions must assume the git repository containing the current directory, in
# accordance with git usage.

#FIXME: Add functionality for the following sweet git commands:
#
#* git history grepping, also referred to as the "git pickaxe":
#
#  # Search *ALL* project history for the passed search substring.
#  >>> git log -S${search_substring}
#FIXME: Implement risky commands by simply confirming such operations
#beforehand: e.g.,
#
#   # Revert the repository to the remote master. The user had better confirm!
#   >>> git reset --hard origin/master

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void :die_unless_git(
    string error_message =
        "Current directory \"$(get_dir)\" not under git control.")

Throw an exception unless the current directory resides in a `git` repository.
See :is_git() for further details.
/---
function :die_unless_git() {
    die_unless_args_0_to_1 'Expected optional error message.'
    :is_git or {
        :string dirname; dirname="$(get_dir)"
        die "${1-Current directory \"${dirname}\" not under git control.}"
    }
}

declare_function_with_stdin <<'/---'
void :die_unless_path_git(
    string pathname,
    string error_message = "Path \"${pathname}\" not under git control.")

Throw an exception unless the passed path resides in a `git` repository. See
:is_path_git() for further details.
/---
function :die_unless_path_git() {
    die_unless_args_1_to_2 'Expected one pathname and optional error message.'
    :string pathname="${1}"
    :is_path_git "${pathname}" or
        die "${2-Path \"${pathname}\" not under git control.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_git(void)

Report success if the current directory resides in a `git` repository. See
:is_path_git() for further details.
/---
function :is_git() {
    # Yes, this *IS* the most expedient means of testing such condition.
    die_if_args
    { command git rev-parse } silent:
}

declare_function_with_stdin <<'/---'
[status: bool] :is_path_git(string pathname)

Report success if the passed path resides in a `git` repository (i.e., if
either such directory or some parent of such directory contains either a
directory `.git` containing a valid git tree or file `.git` containing the
pathname of such tree).
/---
function :is_path_git() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    :string pathname="${1}" dirname_git_top

    # Test such path. While this is also implementable by changing the current
    # directory to such path and calling :is_git(), the
    # possibility such path is a file rather than directory complicates doing
    # so. The following implementation is simpler.
    :set_string_to_path_git_dir_root_if_found\
        dirname_git_top "${pathname}"
}

# ....................{ SETTERS ~ root                     }....................
declare_function_with_stdin <<'/---'
void :set_string_to_git_dir_root(string string_name)

Set the passed string variable to the absolute path of the top-level directory
for the `git` repository containing the current directory.
/---
function :set_string_to_git_dir_root() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :die_unless_git

    # Set such string to such directory.
    :set_string_to_string "${1}" "$(command git rev-parse --show-toplevel)"
}

declare_function_with_stdin <<'/---'
[status: bool] :set_string_to_path_git_dir_root_if_found(
    string string_name, string pathname)

Set the passed string variable to the absolute path of the top-level directory
for the `git` repository containing the passed path if such path resides in such
a repository or report failure otherwise.
/---
function :set_string_to_path_git_dir_root_if_found() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one pathname.'
    :string\
        string_name__sstprgdtif="${1}"\
        pathname__sstprgdtif="${2}"\
        dirname_git_dir__sstprgdtif
    die_unless_path "${pathname__sstprgdtif}"
    :die_unless_var_string "${string_name__sstprgdtif}"

    # Get the absolute path of the ".git" directory for the git repository
    # containing such path if such path resides in such a repository or report
    # failure otherwise. While this is also implementable by changing the
    # current directory to such path and running "command git rev-parse
    # --show-toplevel", the possibility such path is a file rather than
    # directory complicates doing so. The following implementation is simpler.
    dirname_git_dir__sstprgdtif="$(
        {
            command git rev-parse --resolve-git-dir "${pathname__sstprgdtif}"
        } silent_stderr:)" or report_failure

    # Strip the suffixing "/.git" from such directory, if found.
    :remove_string_suffix dirname_git_dir__sstprgdtif '/.git'

    # Set such string to such directory.
    :set_string_to_string\
        "${string_name__sstprgdtif}" "${dirname_git_dir__sstprgdtif}"
}

# ....................{ SETTERS ~ branch                   }....................
declare_function_with_stdin <<'/---'
void :set_string_to_git_branch(string string_name)

Set the passed string variable to the current branch of the `git` working tree
containing the current directory.
/---
function :set_string_to_git_branch() {
    die_unless_arg 'Expected one string name.'
    :die_unless_git
    :set_string_to_string "${1}" "$(command git symbolic-ref --short HEAD)"
}

# ....................{ STORERS                            }....................
declare_function_with_stdin <<'/---'
void :store_git_dir_root(void)

Change the current directory to the top-level directory for the `git` repository
containing the current directory and push such directory to the top of the
directory stack. See :store_dir() for further details.
/---
function :store_git_dir_root() {
    # Validate sanity.
    die_if_args
    :die_unless_git
    :string git_dir_root

    # Store such directory.
    :set_string_to_git_dir_root git_dir_root
    store_dir "${git_dir_root}"
}

# ....................{ DIFFERENCERS                       }....................
declare_function_with_stdin <<'/---'
string :difference_git_from_revision(string git_revision)

Print all differences between the current and passed revision for the `git`
repository containing the current directory in
https://en.wikipedia.org/wiki/Diff#Unified_format[*unified `diff` format*]
(e.g., `y_u_no.c`, "HEAD^^^^:i/c_u.no").
/---
function :difference_git_from_revision() {
    die_unless_arg 'Expected one git revision.'
    :die_unless_git
    command git show -- "${1}"
}

# ....................{ GREPPERS                           }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: bool] :grep_git_with_options(
    string git_grep_option1?, ...,
    string pattern,
    string glob1?, ...)

Grep all files matching the passed glob expressions in the current directory and
all subdirectories of such directory in the `git` repository containing such
directory for files with lines matching the passed pattern with both the passed
and currently configured `git grep`-specific options (e.g.,
${ZESHY_OPTIONS_GIT_GREP}).

== Caveats ==

When only one argument is passed, this function implicitly interprets such
argument as a pattern by passing option `-e` prior to such pattern. When passing
multiple arguments, the caller _must_ explicitly pass such option prior to all
passed patterns.
/---
function :grep_git_with_options() {
    # Validate sanity.
    die_unless_args\
        'Expected optional "git grep" options, one pattern, and optional globs.'

    # If only one argument was passed, interpret such argument as a pattern.
    if { is_arg } {
        prepend_arg '-e'
    }

    # Grep such files.
    run_code_with_options_configured\
        'run_code_paged command git grep' ZESHY_OPTIONS_GIT_GREP "${(q)@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: bool] :grep_git_root_with_options(
    string git_grep_option1?, ...,
    string pattern,
    string glob1?, ...)

Grep all files matching the passed glob expressions in the `git` repository
containing the current directory for files with lines matching the passed
pattern with both the passed and currently configured `git grep`-specific
options (e.g., ${ZESHY_OPTIONS_GIT_GREP}). See :grep_git_with_options() for
further details.
/---
function :grep_git_root_with_options() {
    # Validate sanity.
    die_unless_args\
        'Expected optional "git grep" options, one pattern, and optional globs.'

    # Grep such files.
    :store_git_dir_root
    :try {
        :grep_git_with_options "${@}"
    } always :{
        restore_dir
    }:
}

# ....................{ PATCHES                            }....................
#FIXME: Hideously old-style. Revise for nebulous profit and fun.

declare_function_with_stdin <<'/---'
void apply_patch_uri_to_repository_git:(string uri1, ...)

Temporarily download the passed URIs to local patch files, apply such files to
the local git repository containing the current directory, and remove all such
files that successfully applied to such repository. For verification, all such
files that failed to apply to such repository will be locally preseved.
/---
function apply_patch_uri_to_repository_git:() {
    # Validate sanity.
    die_unless_args 'Expected one or more patch URIs.'
    :string patch_dirname patch_filename

    ::set_git_globals:
    print_message "Applying remote patches to \"${GIT_ROOT}\"..."

    # Temporary directory to which such patches will be downloaded to.
    patch_dirname="$(make_dir_temporary)"

    :try {
        :string patch_uri
        for     patch_uri ("${@}") {
            # If such URI is prefixed by an unsupported protocol, throw an
            # exception.
            is "${patch_uri}" == ('http'|'https'|'ftp')'://'* si or
                die 'Patch URI "'${patch_uri}'" protocol unsupported (i.e., neither "http://", "https://", or "ftp://").'

            # If such URI is suffixed by a backslash, remove such character.
            remove_string_suffix patch_uri '/'

            # Temporary file to which such patch will be downloaded to.
            patch_filename="${patch_dirname}/$(get_path_basename "${patch_uri}")"

            # Retrieve such URI to such file.
            download_url_to_file: "${patch_uri}" "${patch_filename}"

            # Apply such patch.
            print_message "Applying \"${patch_filename}\"..."
            if { command git am "${patch_filename}" } {
                print_message "Removing \"${patch_filename}\"..."
                remove_file "${patch_filename}"
            }
        }
    } always :{
        # Remove such temporary directory and patch files.
        remove_path_recursive "${patch_dirname}"
    }:
}

# --------------------( WASTELANDS                         )--------------------
 # Ideally, calling "git rev-parse --show-cdup" would
 #    # suffice to provide such directory. Unfortunately, such command outputs the
 #    # empty string if already in the root directory.

# declare_function_with_stdin <<'/---'
# void :set_string_to_path_git_branch(string string_name, string pathname)
# 
# Set the passed string variable to the current branch of the `git` working tree
# containing the passed path if such path resides in such a tree or throw an
# exception otherwise.
# /---
# function :set_string_to_path_git_branch() {
#     # Validate sanity.
#     die_unless_args_2 'Expected one string name and one pathname.'
#     :string string_name__sstpgb="${1}" pathname__sstpgb="${2}"
# 
#     # Set such string to such branch. Since "git symbolic-ref" operates on the
#     # git repository containing the current directory, temporarily change such
#     # directory to such path.
#     :store_dir_if_dir_or_dir_parent "${pathname__sstpgb}"
#     :try {
#         :set_string_to_string\
#             "${string_name__sstpgb}"\
#             "$(command git symbolic-ref --short HEAD)"
#     } always :{
#         restore_dir
#     }:
# }

    # Validate sanity.
    # die_unless_arg 'Expected one grep expression.'

    # ::set_git_globals:
    # print_message "Grepping \"${GIT_ROOT}\" for ${@}..."

    # if { is_string_empty "${IS_GIT_ROOT_PWD}" } {
    #     pushd "${GIT_ROOT}"
    # }

    # command git grep $(get_git_grep_options) "${@}"

    # if { is_string_empty "${IS_GIT_ROOT_PWD}" } {
    #     popd
    # }

# declare_function_with_stdin <<'/---'
# string :grep_git(string pattern, string glob?)
# 
# /---
# function :grep_git() {
#     die_unless_arg 'Expected one pattern.'
#     :grep_git_with_options -- "${@}"
# }

# ....................{ GETTERS                            }....................
#FUXME: Silly. Extract into a new git-specific config file.
#FUXME: Wait. Does "git" already provide a means of defining such options?
# declare_function_with_stdin <<'/---'
# string get_git_grep_options:(void)
# 
# Get default options to be passed to `git grep`.
# /---
# function get_git_grep_options:() {
#     die_if_args
# 
#     #FIXME: Everything except "--ignore-case" seems sensible. We'll want a
#     #separate grep_git_caseless() for that.
#     output_string '--extended-regexp --ignore-case -n -C 1'
# }

# ....................{ PRIVATE                            }....................
#FUXME: O.K.; this is the culprit. Basically, this script is rather egregrious;
#it defines a die() function, which naturally conflicts with ours when we
#"source" the script. The solution is to pretty much rip out our calling of an
#external script, and instead integrate Git at the zsh level. Fortunately, this
#has already been done for us by the "zsh-git" project at:
#
#   https://github.com/jcorbin/zsh-git/blob/master/functions/zgitinit
#   https://github.com/jcorbin/zsh-git/blob/master/functions/prompt_wunjo_setup
#
#The former is the most important file; it defines all of the path handling to
#determine whether or not the current path is a git repository. The latter
#integrates that information into the prompt. For now, just get integration with
#the former to work, yo-yo?
#
#O.K.; this is officially broken, under strictness. Forget it. Incorporate the
#above logic, when time permits.
#FUXME: That said, ::set_git_globals: *DOES* seem a bit silly. After all, to
#display proper metadata on whether or not the current directory resides in a
#git repository at the prompt, an equivalent to such globals has to be
#maintained by the SCM completion module, right? Though, of course, that
#wouldn't be synchronized in the event of a non-interactive script. Oh, very
#well; we suppose there's no getting around this. Continue onward, stalwart
#hero (or tin soldier?).
#FUXME: Ugh. To determine the git root directory, all we have to do is call:
#
#    >>> git rev-parse --show-toplevel
#    /home/leycec/zsh/zeshy
#
#From "man git-rev-parse", the most relevant options to such subcommand are:
#
#    --show-toplevel
#               Show the absolute path of the top-level directory.
#
#           --show-prefix
#               When the command is invoked from a subdirectory, show the path of the current directory
#               relative to the top-level directory.
#
#           --show-cdup
#               When the command is invoked from a subdirectory, show the path of the top-level
#               directory relative to the current directory (typically a sequence of "../", or an empty
#               string).
#
#           --git-dir
#               Show $GIT_DIR if defined. Otherwise show the path to the .git directory. The path shown,
#               when relative, is relative to the current working directory.
#
#               If $GIT_DIR is not defined and the current directory is not detected to lie in a Git
#               repository or work tree print a message to stderr and exit with nonzero status.
#
#           --is-inside-git-dir
#               When the current working directory is below the repository directory print "true",
#               otherwise "false".
#
#           --is-inside-work-tree
#               When the current working directory is inside the work tree of the repository print
#               "true", otherwise "false".
#
#           --is-bare-repository
#               When the repository is bare print "true", otherwise "false".
#
#           --local-env-vars
#               List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or
#               GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not
#               their value, even if they are set.
#
#Note, then, that parsing the *VERY* simply string output of
#"git rev-parse --is-inside-work-tree" should yield a maximally efficient
#implementation for :die_unless_git(), which we should
#probably reimplement accordingly.
#FUXME: Interesting. From the thread at
#http://stackoverflow.com/questions/2044574/determine-if-directory-is-under-git-control,
#the canonical (and most efficient!) means of testing whether or not the current
#directory is under revision control is to simply call:
#
#    { git rev-parse } silent:
#
#Such command succeeds if such directory is under revision control and fails
#otherwise.

# declare_function_with_stdin <<'/---'
# void ::set_git_globals:(void)
# 
# Set Git-specific global variables by running "/usr/libexec/git/git-sh-setup".
# This locates the root of the git repository corresponding to the current
# working directory, among other useful things.
# 
# Specifically, this function sets:
# 
# * ${GIT_DIR}, the absolute path to this Git repository's ".git/" directory.
# * ${GIT_ROOT}, the absolute path to the parent of ${GIT_DIR}.
# * ${IS_GIT_ROOT_PWD}, set if and only if ${GIT_ROOT} is the current working
#   directory.
# /---
# function ::set_git_globals:() {
#     # Validate sanity.
#     die_if_args
# 
#     print_message "Looking for parent git repository..."
#     SUBDIRECTORY_OK=1 :source_script "$(git --exec-path)/git-sh-setup"
# 
#     #FUXME: Prefix such globals by "ZESHY_".
#     #FUXME: Actually declare such globals as such. Why didn't we? How could this
#     #*EVER* have worked?
# 
#     # Resolve symlinks so as to permit comparison of this path against other
#     # resolved, canonical paths.
# #   print "GIT_DIR: ${GIT_DIR[1]%/*}"
#     string GIT_ROOT="$(readlink -e "${GIT_DIR%/*}")"
#     string GIT_PWD="$(readlink -e "${PWD}")"
# #   print "GIT_ROOT=${GIT_ROOT}"
# #   print "GIT_PWD=${GIT_PWD}"
# 
#     if is "${GIT_ROOT}" == "${GIT_PWD}" si {
#         IS_GIT_ROOT_PWD=1
#     } else {
#         unset IS_GIT_ROOT_PWD
#     }
# }

#     :string pathname="${1}" dirname
# 
#     die_unless_path "${pathname}"
# 
#     # If 
#     if { is_file "${pathname}" } {
#         dirname="${pathname}"
#     # 
#     # Else, such path is a file. reduce such path to its parent directory.
#     } else {
#         :set_string_to_path_dirname dirname "${pathname}"
#     }
# 
#     # Test such path.
#     store_dir "${dirname}"
#     :try {
#         :is_git
#     } always :{
#         restore_dir
#     }:
# }

    # :set_string_to_path_git_dir_root_if_found\
    #     dirname_git_top "${pathname}"

# declare_function_with_stdin <<'/---'
# [stdout: string, status: bool] :get_path_git_dir_root_if_found(
#     string pathname)
# 
# Get the absolute path of the top-level directory for the `git` repository
# containing the passed path if such path resides in such a repository or report
# failure otherwise.
# /---
# function :get_path_git_dir_root_if_found() {
#     # Validate sanity.
#     die_unless_arg 'Expected one pathname.'
#     :string pathname="${1}"
#     :die_unless_path "${pathname}"
# 
#     # Get such directory.
#     command git rev-parse --show-toplevel
# }

#git-apply-remote-patches http://paste.pocoo.org/raw/2408/

#FUXME: Uhm...
#function git-format-patch() {
#    local COMMITS="${1}"
#    [[ -n "${COMMITS}" ]] || COMMITS="origin/master"
#    git format-patch -M -C "${COMMITS}"
#}
#
#function git-format-patch-stdout() {
#    local COMMITS="${1}"
#    [[ -n "${COMMITS}" ]] || COMMITS="origin/master"
#    git format-patch --stdout -M -C "${COMMITS}"
#}

            #FUXME: Terrible. Call a new function -- say, download_url_to_file() --
            #implementing such functionality.
#           print_message "Getting \"${patch_uri}\" to \"${patch_filename}\".."
#           command wget --quiet --output-document="${patch_filename}" "${patch_uri}"

            # Download such URI to such file to a temporary file having the same
            # prefix as the basename of the remote file. (This should ensure
            # filename uniqueness, to a reasonable degree.)
#(which_temporary_file "${patch_uri##*/}")"

#== Riskiness ==
#
#Additional commands, for which this script provides no aliases or functions
#due to innate riskiness, include:
#
#.get_string_ansiless_length_printable()
#==========================================
#[source]
#------------------------------------------
## Revert the repository to the remote master. *DANGEROUS*, but helpful.
#>>> git reset --hard origin/master
#------------------------------------------
#==========================================

# ....................{ ALIASES                            }....................
#FUXME: Shift to new config file.
#alias_cli gita='git add'
#alias_cli gitaa='git add --all'
#alias_cli gitd='git diff'
#alias_cli gitl='git log'
#alias_cli gitc='git commit'
#alias_cli gitca='git commit --all'
#alias_cli gitcaa='git commit --all --amend'
#alias_cli gitgr='git_grep'
#alias_cli gitgrr='git_grep_root'
#alias_cli gitrei='git rebase --interactive'
#alias_cli gitrec='git rebase --continue'
#alias_cli gitp='git push'
#alias_cli gits='git status'

# Eliminate "Merged from..." commits git implicitly produces from a non-
# conflicting merge. (Rather helpful.)
#alias_cli gitreo='git rebase origin'

# Interactively rebase all commits committed since the last push to the remote
# repository. (This is the common case.)
#alias_cli gitreio='gitrei origin/master'

