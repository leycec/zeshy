#!/usr/bin/env zsh
# ====================[ git                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle "git", the CLI for the distributed SCM of the same name.
#
# --------------------( COMMANDS ~ risky                   )--------------------
# Additional commands, for which this script provides no aliases or functions
# due to innate riskiness, include:
#
#     # Revert the repository to the remote master.
#     git reset --hard origin/master

# ....................{ EXCEPTIONS                         }....................
#FIXME: Implement me, kthx.

document_function '
void die_unless_git_repository(
  string pathname,
  string error_message = "\"${pathname}\" not under git control")

Throw an exception unless the passed path (defaulting to the current
directory) resides in a "git" repository.
'
function die_unless_git_repository() {
    noop
}

# ....................{ GETTERS                            }....................
#FIXME: Silly. Extract into a new git-specific config file. Of course, we'll
#need sufficient config infrastructure for such file... *sigh*

document_function '
string get_git_grep_options(void)

Get default options to be passed to "git grep".
'
function get_git_grep_options() {
    die_if_args

    #FIXME: Everything except "--ignore-case" seems sensible. We'll want a
    #separate grep_git_caseless() for that.
    print -- --extended-regexp --ignore-case -n -C 1
}

# ....................{ PRINTERS                           }....................
document_function '
string print_git_differences(string git_revision)

Print a unified diff of all differences between the current and passed revision
(e.g., "y_u_no.c", "HEAD^^^^:i/c_u.no").
'
function print_git_differences() {
    die_unless_arg 'expected one git revision'
    die_unless_git_repository
    git show -- "${1}"
}

# ....................{ FINDERS                            }....................
#FIXME: Good God, but these need revision.
function grep_git() {
    die_unless_arg 'expected one grep expression'
    say "grepping \"${PWD}\" for ${@}..."
    git grep $(get_git_grep_options) "${@}"
}

function grep_git_root() {
    die_unless_arg 'expected exactly one grep expression'

    _zeshy_set_git_globals
    say "grepping \"${GIT_ROOT}\" for ${@}..."

    is_string_empty "${IS_GIT_ROOT_PWD}" and pushd "${GIT_ROOT}"
    git grep $(get_git_grep_options) "${@}"
    is_string_empty "${IS_GIT_ROOT_PWD}" and popd
}

# ....................{ PATCHES                            }....................
#FIXME: All quite old-style. Revise for nebulous profit and fun.
# void git-apply-remote-patches(string uri1, string uri2, ...)
#
# Get the passed URIs to local patch files and apply to the local git repository
# in the current working directory via "git am". Example:
# 
#     git-apply-remote-patches http://paste.pocoo.org/raw/2408/
function git-apply-remote-patches() {
    die_unless_args 'expected at least one patch URI'

    _zeshy_set_git_globals
    say "applying remote patches to \"${GIT_ROOT}\"..."

    string local_patch
    for remote_patch ("${@}") {
        # If the last character of the remote file is a '/', cut it. (This
        # preserves sanity, below.)
        remote_patch="${remote_patch%/}"

        if is "${remote_patch}" =~ ^(https?|ftp):// si then
            # Retrieve the remote path to a temporary file having the same
            # prefix as the basename of the remote file. (This should ensure
            # filename uniqueness, to a reasonable degree.)
            local_patch=$(which_temporary_file "${remote_patch##*/}")

            say "getting \"${remote_patch}\" to \"${local_patch}\".."
            try wget --quiet --output-document="${local_patch}" "${remote_patch}"

            say "applying \"${local_patch}\"..."
            if git am "${local_patch}"; then
                say "removing \"${local_patch}\"..."
                try rm -f "${local_patch}"
            fi
        else
            die "${remote_patch} not a supported fetch protocol"
        fi
    }
}

#FIXME: Uhm...
function git-format-patch() {
    local COMMITS="${1}"
    [[ -n "${COMMITS}" ]] || COMMITS="origin/master"
    git format-patch -M -C "${COMMITS}"
}

function git-format-patch-stdout() {
    local COMMITS="${1}"
    [[ -n "${COMMITS}" ]] || COMMITS="origin/master"
    git format-patch --stdout -M -C "${COMMITS}"
}

# ....................{ PRIVATE                            }....................
#FIXME: O.K.; this is the culprit. Basically, this script is rather egregrious;
#it defines a die() function, which naturally conflicts with ours when we
#"source" the script. The solution is to pretty much rip out our calling of an
#external script, and instead integrate Git at the zsh level. Fortunately, this
#has already been done for us by the "zsh-git" project at:
#
#   https://github.com/jcorbin/zsh-git/blob/master/functions/zgitinit
#   https://github.com/jcorbin/zsh-git/blob/master/functions/prompt_wunjo_setup
#
#The former is the most important file; it defines all of the path handling to
#determine whether or not the current path is a git repository. The latter
#integrates that information into the prompt. For now, just get integration with
#the former to work, yo-yo?
#
#O.K.; this is officially broken, under strictness. Forget it. Incorporate the
#above logic, when time permits.

# void _zeshy_set_git_globals(void)
#
# Set Git-specific global variables by running "/usr/libexec/git/git-sh-setup".
# This locates the root of the git repository corresponding to the current
# working directory, among other useful things.
#
# Specifically, this function sets:
#
# * ${GIT_DIR}, the absolute path to this Git repository's ".git/" directory.
# * ${GIT_ROOT}, the absolute path to the parent of ${GIT_DIR}.
# * ${IS_GIT_ROOT_PWD}, set if and only if ${GIT_ROOT} is the current working
#   directory.
function _zeshy_set_git_globals() {
    say "looking for current git repository..."
    SUBDIRECTORY_OK=1 source_shell_script "$(git --exec-path)/git-sh-setup"

    #FIXME: These should really be prefixed by "ZESHY_", for safety.
    # Resolve symlinks so as to permit comparison of this path against other
    # resolved, canonical paths.
#   print "GIT_DIR: ${GIT_DIR[1]%/*}"
    string GIT_ROOT="$(readlink -e "${GIT_DIR%/*}")"
    string GIT_PWD="$(readlink -e "${PWD}")"
    print "GIT_ROOT=${GIT_ROOT}"
    print "GIT_PWD=${GIT_PWD}"

    if is "${GIT_ROOT}" == "${GIT_PWD}" si
    then       IS_GIT_ROOT_PWD=1
    else unset IS_GIT_ROOT_PWD
    fi
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ ALIASES                            }....................
#FIXME: Shift to new config file.
#interactive_alias gita='git add'
#interactive_alias gitaa='git add --all'
#interactive_alias gitd='git diff'
#interactive_alias gitl='git log'
#interactive_alias gitc='git commit'
#interactive_alias gitca='git commit --all'
#interactive_alias gitcaa='git commit --all --amend'
#interactive_alias gitgr='git_grep'
#interactive_alias gitgrr='git_grep_root'
#interactive_alias gitrei='git rebase --interactive'
#interactive_alias gitrec='git rebase --continue'
#interactive_alias gitp='git push'
#interactive_alias gits='git status'

# Eliminate "Merged from..." commits git implicitly produces from a non-
# conflicting merge. (Rather helpful.)
#interactive_alias gitreo='git rebase origin'

# Interactively rebase all commits committed since the last push to the remote
# repository. (This is the common case.)
#interactive_alias gitreio='gitrei origin/master'

