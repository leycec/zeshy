#!/usr/bin/env zsh
# ====================[ ssh                                ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy SSH, implementing "scp" and "ssh"-specific functionality. See also
# Zeshy SSHfs, implementing SSH mounting with FUSE filesystems.
#
# --------------------( TODO                               )--------------------
# * Implement a "mosh" Zeshy component. Since "mosh" depends on "ssh", such
#   component should resemble the current "sshfs" component.

# ....................{ ALIASES                            }....................
#FIXME: We really want a configuration file-based alias calling a Zeshy
#function, here.
interactive_substitution scp='scp -Crv'

# ....................{ GETTERS                            }....................
#FIXME: It'd be nice to generalize such getters to accept an optional username.
# string get_ssh_dot_dir(void)
#
# Get the absolute path of the current user's SSH dot directory (e.g.,
# "~/.ssh/") regardless of whether such path exists.
function get_ssh_dot_dir() {
    die_if_args
    print_string "${HOME}/.ssh"
}

#FIXME: We probably want this function to throw an exception and another to
#return false if no such file exists. The latter function is of use in Zeshy
#Keychain and probably elsewhere.

# string get_ssh_public_key_file(void)
#
# Get the absolute path of the first public key in the current user's SSH dot
# directory or throw an exception if no such key exists. If multiple keys exist,
# prefer the first such key with basename:
#
# * Prefixed by "id_" and suffixed by ".pub" (i.e., protocol 2 public key).
# * Prefixed by "identity" and suffixed by ".pub" (i.e., protocol 1 public key).
# * Suffixed by ".pub".
function get_ssh_public_key_file() {
    #FIXME: Hmm; it'd be nice to generalize get_file_first() into a new function
    #accepting both a glob (e.g., "{id_,identity,}*.pub") and a glob qualifier
    #(e.g., "(-.)"). Consider it.
    # Glob the expected files in the expected order into a list.
    die_if_args
    list filenames; filenames=( "$(get_ssh_dot_dir)"/{id_,identity,}*.pub(-.) )

    # If some such file exists, return the first; otherwise, throw an exception.
    is_list_nonempty filenames and
        print_string "${filenames[1]}" or
        die "public key not found in \"$(get_ssh_dot_dir)\""
}

# ....................{ PRINTERS                           }....................
# string print_ssh_key_fingerprint(
#   string ssh_key_filename = "~/.ssh/id_rsa.pub")
#
# Print the fingerprint of the passed SSH public or private key file.
function print_ssh_key_fingerprint() {
    #FIXME: Hm; this function is clearly a tad... incomplete. Clean up, sir!
    # Validate passed arguments, defaulting such argument to the first SSH key
    # in the current user's SSH dot directory (in the following order):
    #
    # * public or
    # private key in the
    die_unless_args_0_to_1 'expected optional public key filename'

    #FIXME: Call which_files_nonfatal() to test any number of possible keys
    #(e.g., "id_dsa.pub"). Actually, just glob!
    string ssh_key_filename
    is_args_0 and {
        list ssh_key_filenames
        ssh_key_filenames=( "$(get_ssh_home)"/*.pub )
        
        #FIXME: Uhm; what!?!?!?!?!?
        die_unless_list_nonempty 
        ="${1:-${HOME}/.ssh/id_rsa.pub}"
    }
    die_unless_file "${ssh_key_filename}"

    # Print.
    ssh-keygen -lf  "${ssh_key_filename}"
}

# --------------------( WASTELANDS                         )--------------------
#interactive_alias ssh='TERM="xterm" ssh -v'
#alias ssh-secondary-control-master="ssh -o \"ControlPath ~/tmp/ssh_controlmaster2-%r@%h:%p\""

#FIXME: Sensible, but doesn't belong here. Hmm...
# ....................{ GLOBALS                            }--------------------
# If "cvs" is also installed, encrypt non-pserver CVS connections via "ssh".
#is_pathable cvs and string_global_export CVS_RSH=ssh
