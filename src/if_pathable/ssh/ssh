#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle `ssh` and bundled cohorts (e.g., `scp`).
-/-

#FIXME: Implement a "mosh" Zeshy component. Since "mosh" depends on "ssh", such
#component should resemble the current "sshfs" component.

# ....................{ ALIASES                            }....................
#FIXME: We really want a configuration file-based alias calling a Zeshy
#function, here.
alias_cli_substitution scp='scp -Crv'

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_ssh_dot_dir(void)

Get the absolute path of the current user's SSH dot directory (e.g., `~/.ssh/`),
regardless of whether such path exists.
/---
function get_ssh_dot_dir() {
    die_if_args
    return_string "${HOME}/.ssh"
}

#FIXME: Rename to get_ssh_key_public_file().
#FIXME: We probably want this function to throw an exception and another to
#return false if no such file exists. The latter function is of use in Zeshy
#Keychain and probably elsewhere.

declare_function_with_stdin <<'/---'
string get_ssh_public_key_file(void)

Get the absolute path of the first public key in the current user's SSH dot
directory or throw an exception if no such key exists. If multiple keys exist,
prefer the first such key with basename:

* Prefixed by `id_` and suffixed by `.pub` (i.e., protocol 2 public key).
* Prefixed by `identity` and suffixed by `.pub` (i.e., protocol 1 public key).
* Suffixed by `.pub`.
/---
function get_ssh_public_key_file() {
    #FIXME: Hmm; it'd be nice to generalize get_file_first() into a new function
    #accepting both a glob (e.g., "{id_,identity,}*.pub") and a glob qualifier
    #(e.g., "(-.)"). Consider it.

    # Validate sanity.
    die_if_args

    # Glob the expected files in the expected order into a list.
    list filenames; filenames=( "$(get_ssh_dot_dir)"/{id_,identity,}*.pub(-.) )

    # If some such file exists, return the first; otherwise, throw an exception.
    die_unless_list_nonempty filenames\
        "public key not found in \"$(get_ssh_dot_dir)\""
    return_string "${filenames[1]}"
}

declare_function_with_stdin <<'/---'
string get_ssh_key_fingerprint(
    string ssh_key_filename = "~/.ssh/id_rsa.pub")

Print the fingerprint of the passed SSH public or private key file.
/---
function get_ssh_key_fingerprint() {
    #FIXME: Hm; this function is clearly a tad... incomplete. Clean up, sir!
    # Validate passed arguments, defaulting such argument to the first SSH key
    # in the current user's SSH dot directory (in the following order):
    #
    # * public or
    # private key in the
    die_unless_args_0_to_1 'expected optional public key filename'
    string ssh_key_filename

    if { is_arg } {
        ssh_key_filename="${1}"
    } else {
        list ssh_key_filenames;  ssh_key_filenames=( "$(get_ssh_home)"/*.pub )
        die_unless_list_nonempty ssh_key_filenames
        ssh_key_filename="${ssh_key_filenames[1]}"
#       ="${1:-${HOME}/.ssh/id_rsa.pub}"
    }

    # Ensure such key exists.
    die_unless_file "${ssh_key_filename}"

    # Fingerprint such key.
    command ssh-keygen -lf -- "${ssh_key_filename}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: It'd be nice to generalize such getters to accept an optional username.

    #FUXME: Call which_files_nonfatal() to test any number of possible keys
    #(e.g., "id_dsa.pub"). Actually, just glob!

# Zeshy SSH, implementing -specific functionality. See also
# Zeshy SSHfs, implementing SSH mounting with FUSE filesystems.
#alias_cli ssh='TERM="xterm" ssh -v'
#alias ssh-secondary-control-master="ssh -o \"ControlPath ~/tmp/ssh_controlmaster2-%r@%h:%p\""

#FUXME: Sensible, but doesn't belong here. Hmm...
# ....................{ GLOBALS                            }--------------------
# If "cvs" is also installed, encrypt non-pserver CVS connections via "ssh".
#is_pathable cvs and string_global_export CVS_RSH=ssh
