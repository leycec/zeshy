#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle `ssh`, the canonical CLI for the cryptographic network protocol *SSH*
(Secure Shell).
-/-

#FIXME: Implement a "mosh" Zeshy component. Since "mosh" depends on "ssh", such
#component should resemble the current "sshfs" component.

# ....................{ ALIASES                            }....................
#FIXME: We really want a configuration file-based alias calling a Zeshy
#function, here.
alias_cli_substitution scp='scp -Crv'

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_ssh_dot_dir(void)

Get the absolute path of the top-level directory under the current user storing
SSH configuration files (e.g., `~/.ssh/`).
/---
function get_ssh_dot_dir() {
    die_if_args
    output_string "${HOME}/.ssh"
}

#FIXME: Rename to get_ssh_key_public_file().
#FIXME: We probably want this function to throw an exception and another to
#return false if no such file exists. The latter function is of use in Zeshy
#Keychain and probably elsewhere.

declare_function_with_stdin <<'/---'
string get_ssh_key_public_file_default(void)

Get the absolute path of the first public key in the current user's SSH dot
directory or throw an exception if no such key exists. If multiple such keys
exist, prefer the first such key with basename (in order):

* Matching `id_ecdsa.pub`, an SSH protocol 2 public key generated with the
  *Elliptic Curve Digital Signature Algorithm* (ECDSA). Such keys have keytype
  `ecdsa-sha2-nistp521`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp256`,
  depending on bit strength, and now constitute the SSH default.
* Matching `id_rsa.pub`, an SSH protocol 2 public key generated with the
  *Rivest, Shamir, and Adelman* algorithm (RSA). Such keys have keytype
  `ssh-rsa`, but have (largely) been superceded by keys generated with more
  recent algorithms.
* Matching `id_dsa.pub`, an SSH protocol 2 public key generated with the
  *Digital Signature Algorithm* (DSA). Such keys have keytype `ssh-dsa`, but
  have entirely been superceded by keys generated with more recent algorithms.
* Matching `identity.pub`, an SSH protocol 1 public key generated with the
  *Rivest, Shamir, and Adelman* algorithm (RSA), as above. Such protocol is
  increasingly uncommon in the networked wild.
* Suffixed by `.pub`, as a desperate fallback.
/---
function get_ssh_key_public_file_default() {
    #FIXME: Hmm; it'd be nice to generalize get_file_first() into a new function
    #accepting both a glob (e.g., "{id_,identity,}*.pub") and a glob qualifier
    #(e.g., "(-.)"). Consider it.

    # Validate sanity.
    die_if_args

    # Glob the expected files in the expected order into a list.
    list filenames; filenames=( "$(get_ssh_dot_dir)"/{id_,identity,}*.pub(-.) )

    # If some such file exists, return the first; otherwise, throw an exception.
    die_unless_list_nonempty filenames\
        "public key not found in \"$(get_ssh_dot_dir)\""
    output_string "${filenames[1]}"

    list ssh_key_filenames;  ssh_key_filenames=( "$(get_ssh_home)"/*.pub )
    die_unless_list_nonempty ssh_key_filenames
    ssh_key_filename="${ssh_key_filenames[1]}"
}

# ....................{ GETTERS ~ text                     }....................
declare_function_with_stdin <<'/---'
string get_ssh_key_fingerprint(
    string ssh_key_filename = "$(get_ssh_key_public_file_default)")

Print the fingerprint of the passed SSH (either public or private) key file.
/---
function get_ssh_key_fingerprint() {
    # Validate sanity.
    string ssh_key_filename
    if { is_context_cli } {
        die_unless_args_0_to_1 'expected optional key filename'
        ssh_key_filename="${1:-$(get_ssh_key_public_file_default)}"
    } else {
        die_unless_arg 'expected one key filename'
        ssh_key_filename="${1}"
    }
    die_unless_file_text "${ssh_key_filename}"

    # Fingerprint such key.
    command ssh-keygen -lf -- "${ssh_key_filename}"
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Ideally, keys should be checked for valid 
    #For a list of all keytypes, grep "man sshd" for a sentence resembling:
    #
    #   "For protocol version 2 the keytype is “ecdsa-sha2-nistp256”,
    #    “ecdsa-sha2-nistp384”, “ecdsa-sha2-nistp521”, “ssh-dss” or “ssh-rsa”."

#       if { is_arg } {
#       } else {
#           list ssh_key_filenames;  ssh_key_filenames=( "$(get_ssh_home)"/*.pub )
#           die_unless_list_nonempty ssh_key_filenames
#           ssh_key_filename="${ssh_key_filenames[1]}"
#   #       ="${1:-${HOME}/.ssh/id_rsa.pub}"
#       }

#*keytype* (i.e., the `-`-delimited word
#prefixing the text file contents of such key) matching (in order):
#
#* `ecdsa-sha2-nistp521`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp256`. Such
#  keys comply with the *Elliptic Curve Digital Signature Algorithm* (ECDSA).

#basename:
#
#* Prefixed by `id_ecdsa` and suffixed by `.pub` (i.e., protocol 2 public key).
#  *Elliptic Curve Digital Signature Algorithm* (ECDSA)
#* Prefixed by `id_` and suffixed by `.pub` (i.e., protocol 2 public key).
#* Prefixed by `identity` and suffixed by `.pub` (i.e., protocol 1 public key).
#* Suffixed by `.pub`.

#, regardless of whether such path exists.
#FUXME: It'd be nice to generalize such getters to accept an optional username.

    #FUXME: Call which_files_nonfatal() to test any number of possible keys
    #(e.g., "id_dsa.pub"). Actually, just glob!

# Zeshy SSH, implementing -specific functionality. See also
# Zeshy SSHfs, implementing SSH mounting with FUSE filesystems.
#alias_cli ssh='TERM="xterm" ssh -v'
#alias ssh-secondary-control-master="ssh -o \"ControlPath ~/tmp/ssh_controlmaster2-%r@%h:%p\""

#FUXME: Sensible, but doesn't belong here. Hmm...
# ....................{ GLOBALS                            }--------------------
# If "cvs" is also installed, encrypt non-pserver CVS connections via "ssh".
#is_pathable cvs and string_global_export CVS_RSH=ssh
