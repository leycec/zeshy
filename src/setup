#!/usr/bin/env zsh
# ====================[ setup                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Source the current user's Zeshy configuration files after defining aliases
# required by such files. For efficiency, defer defining all other aliases to
# Zeshy startup in the proper Zeshy codebase and hence compilation into the
# Zeshy digest file. Redefine aliases defined below with such other aliases,
# guaranteeing that:
#
# * Zeshy records all aliases defined below in global list ${ZESHY_ALIAS_NAMES},
#   to be subsequently undefined if recompiling Zeshy in the current shell or a
#   child of the current shell. (See "compile" for gruesome details.)
# * Zeshy retrieves documentation for all aliases defined below in the same
#   manner as such other aliases. (See "help" for miserable details.)

#FIXME: This snippet used to reside in "if_config/posix" until I found it
#sufficiently embarrassing. Frankly, we won't be implementing any functionality
#using this anytime soon. Nonetheless, store it here for the moment:
# ....................{ PREFERRED                          }....................
# Preferred terminal multiplexer. If commented, Zeshy selects the first such
# multiplexer installed on the current machine, if any.
#ZESHY_TERMINAL_MULTIPLEXER='tmux'
#ZESHY_TERMINAL_MULTIPLEXER='screen'
#ZESHY_TERMINAL_MULTIPLEXER='dtach'
#FIXME: This doesn't... seem quite right. Shouldn't this be uncommented. But,
#again, it's clearly incorrect. Another half-implemented feature, eh?
#ZESHY_TERMINAL_MULTIPLEXER="ZESHY_TERMINAL_MULTIPLEXER$(get_pathable_path_first tmux screen dtach)"

# ....................{ GLOBALS ~ boolean                  }....................
set_global_documentation ZESHY_BOOLEAN_TRUE '
boolean ZESHY_BOOLEAN_TRUE

An arbitrary non-empty string signifying a boolean true value. Since zsh
currently supports no boolean type, Zeshy emulates such type with strings.
'
set_global_documentation ZESHY_BOOLEAN_FALSE '
boolean ZESHY_BOOLEAN_FALSE

An arbitrary non-empty string signifying a boolean false value. Since zsh
currently supports no boolean type, Zeshy emulates such type with strings.
'
export ZESHY_BOOLEAN_TRUE=true ZESHY_BOOLEAN_FALSE=

# ....................{ GLOBALS ~ digest                   }....................
# Explicitly define such globals to default values. When not doing so, such
# globals erroneously inherit their default values from the parent shell,
# typically resulting in Zeshy recompiling its user digest file on each startup.

set_global_documentation ZESHY_DOT_DIGEST_FILE_IS_OUTDATED '
boolean ZESHY_DOT_DIGEST_FILE_IS_OUTDATED

If true, Zeshy''s user digest file was outdated at Zeshy startup. See
is_zeshy_digest_outdated() for further details.
'
export ZESHY_DOT_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_FALSE}

set_global_documentation\
    ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME '
integer ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME
If Zeshy''s user digest file was outdated at Zeshy startup, the modification
time of the newest path such file depends on; else 0.
'
export -i ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME=0

# ....................{ ALIASES ~ variable                 }....................
# Zeshy's user configuration files only export globals. While such files can
# declare locals and non-exported globals via traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Defer defining further aliases to Zeshy's codebase.
alias string_global_export='export'
alias boolean_global_export=string_global_export
alias character_global_export=string_global_export
alias integer_global_export='export -i'
alias float_global_export='export -F'
alias list_global_export='export -a'
alias list_set_global_export='export -Ua'

# "export -A" fails with error; "export -a", however, succeeds. *massive shrug*
alias map_global_export='typeset -Agx'

# ....................{ ALIASES ~ debug                    }....................
set_alias_documentation is_zeshy_debugging_and '
string is_zeshy_debugging_and<
  string command_name, string command_arg1, string command_arg2, ...>

If Zeshy''s user configuration enables debugging, run the passed command; else,
perform a no-op (i.e., return true without running anything).
'
# Conventional high-level language compilers and interpreters reduce debug
# statements to noops when targeting release builds, eliminating the otherwise
# non-negligible cost of such statements. While zsh provides no conventional
# debug-specific builtins (e.g., assert), it does offer a general-purpose,
# language-level mechanism for simulating such builtins: aliases.
#
# Defining alias is_zeshy_debugging_and<> to run the passed command if
# Zeshy's user configuration enables debugging and ignoring such command
# otherwise eliminates the non-negligible cost of testing global boolean
# ${ZESHY_IS_DEBUGGING} on each debug statement, thus simulating conventional
# debug statements.
#
# Default such alias to ignore the passed command. If Zeshy's user configuration
# files enable debugging, redefine such alias after sourcing such files to run
# the passed command instead.
alias is_zeshy_debugging_and='true ||'

# ....................{ ALIASES ~ document                 }....................
set_function_documentation document_alias '
void document_alias(string documentation)

If called when recompiling Zeshy''s user digest file, document the alias
prefixing the passed string with such string; else, do nothing.
'
#FIXME: Document prototype syntax, including "[OR]" delimiters.
set_function_documentation document_function '
void document_function(string documentation)

If called when recompiling Zeshy''s user digest file, document the function
prefixing the passed string with such string; else, do nothing.
'
set_alias_documentation document_global '
void document_global<string documentation>

If called when recompiling Zeshy''s user digest file, globally export the global
prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
prefixing the passed string *AND* document such global with such string; else,
do nothing.
'
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
alias document_alias=':'
alias document_function=':'
alias document_global=':'

# ....................{ CONFIGURERS                        }....................
set_function_documentation config_zeshy '
void config_zeshy(void)

Source all configuration files in Zeshy''s user configuration directory specific
to the current shell, creating such directory if needed. Such files include:

* All plain files in such directory.
* If the current shell is interactive, all plain files in subdirectory
  "if_shell_interactive" of such directory.
'
function config_zeshy() {
    # Validate sanity. Unless loading Zeshy's user directory and Zeshy's user
    # configuration directory exists, return silently.
    (( # == 0 )) || die 'expected no arguments'
    [[ -n "${ZESHY_DOT_DIR}" && -d "${ZESHY_DOT_CONFIG_DIR}" ]] || return 0

    # List of all scripts in such directory applicable to the current shell,
    # Dismantled, this is:
    #
    # * "*(-.)", matching all plain files after resolving symbolic links.
    local -a config_filenames; config_filenames=(
        "${ZESHY_DOT_CONFIG_DIR}/"*(-.) )
    [[ -o interactive ]] && config_filenames+=(
        "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

    # If at least one such script exists, source such scripts; else, avoid
    # calling source_zeshy_script() with no arguments throwing an exception.
    (( ${#config_filenames} )) && source_zeshy_script "${config_filenames[@]}"

    # If such scripts enable Zeshy debugging, redefine is_zeshy_debugging_and<>
    # defined at the top of this component to run the passed command instead.
    # (See above for further details.)
    [[ -n "${ZESHY_IS_DEBUGGING}" ]] && {
#       print 'enabling debugging'
        alias is_zeshy_debugging_and=''
#       alias is_zeshy_debugging_and='true &&'
    }
}

# ....................{ CONFIGURERS ~ main                 }....................
#FIXME: O.K.; because of this, it would seem prudent to split this component
#into two new components "config" and "digest": the former defining the above
#config-specific aliases, functions, and globals; the latter defining all
#remaining objects declared in this component. While I'm somewhat loathe to
#introduce yet another component into startup logic, the sheer inanity of this
#behavior suggests we could benefit from doing so. After all, we must admit
#that digest behavior is wholly separate from config file behavior.
#FIXME: If splitting as described, digest behavior could actually be readily
#merged into existing component "autoload". In such case, it could make sense
#to do the following, in which case no actual split need take case *WHICH IS
#ABSOLUTELY GREAT*:
#
#* Shift all digest behavior below to "autoload."
#* Shift all zsh module-specific behavior in "autoload" here.
#* Rename "autoload" to "digest" to better reflect its role.
#
#And that's it. *NO NEW TOPMOST COMPONENTS REQUIRED*, just a slight shuffling
#of existing functionality for improved understandability.
#FIXME: Yes. Make it so, I should think.

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#Apallingly, failing to call the function defining alias
#is_zeshy_debugging_and<> at the topmost level before calling functions
#expanding such alias below results in such alias temporarily reverting to its
#default definition only in such functions. (This is insanity, zsh.)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
config_zeshy

# ....................{ SETUP                              }....................
#FIXME: Rename to digest_zeshy() after shifting. (Yes, use "digest" as a verb.
#It's a well-established verb and much better explains the function's purpose.)
set_function_documentation setup_zeshy '
void setup_zeshy(void)

Prepare Zeshy for subsequent startup and possible user digest file compilation.
Specifically, ascertain whether such file requires compilation and source all
applicable user configuration files.
'
function setup_zeshy() {
    # Validate sanity. Do *NOT* return silently if ignoring Zeshy's user
    # directory, both as all functions called below already do so and as the
    # logic below defines core globals required in either case.
    (( # == 0 )) || die 'expected no arguments'

    # If Zeshy's user digest file is outdated, prepare for subsequent
    # recompilation of such file.
    is_zeshy_digest_outdated && {
        ZESHY_DOT_DIGEST_FILE_IS_OUTDATED=${ZESHY_BOOLEAN_TRUE}
        setup_zeshy_digest
    }

    # Undefine lower-level documentators, hereafter replaced by the previously
    # defined higher-level documentators.
    unfunction\
        set_alias_documentation\
        set_function_documentation\
        set_global_documentation
}

# ....................{ TESTERS                            }....................
#FIXME: Documentation outdated.
set_function_documentation is_zeshy_digest_outdated '
boolean is_zeshy_digest_outdated(void)

Return true if Zeshy''s user digest file is outdated and requires recompilation.
This is the case when such file either does not exist or does but is older than
the newest of:

* The main user-specific Zeshy configuration file. This file contains theme
  settings, which when edited require recompiling theme autoloads.
* The main system-wide command directories (e.g., "/bin", "/usr/bin").
  Installing or uninstalling commands requires recompiling command autoloads.

For convenience, set global
${ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME} to the modification
time of the newest path such digest depends upon.
'
function is_zeshy_digest_outdated() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    #FIXME: Add support for Zeshy upgrading: namely, if upgrading Zeshy,
    #immediately return 0 (i.e., true).

    # Unless loading Zeshy's user directory *AND* Zeshy's user digest file and
    # configuration directory both exist *AND* the latter contains at least one
    # directory or file (i.e., is non-empty), return such digest to be outdated.
    [[ -n "${ZESHY_DOT_DIR}" &&\
       -f "${ZESHY_DOT_DIGEST_FILE}" &&\
       -d "${ZESHY_DOT_CONFIG_DIR}" ]] && {
        local -a zeshy_dot_config_dir_if_nonempty
        zeshy_dot_config_dir_if_nonempty=( "${ZESHY_DOT_CONFIG_DIR}"(/F) )
        (( ${#zeshy_dot_config_dir_if_nonempty} ))
    } || {
        # Before returning, set global
        # ${ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME} as
        # required by this function's definition to the current time. This
        # guarantees the modification time for Zeshy's user digest file will be
        # coerced to the current time.
        ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME="$(date +'%s')"
        return 0
    }

    # List of modification times of paths on which Zeshy's digest depends,
    # initialized to contain .
    local -a zeshy_dependency_mtimes

    # Append the modification time of the following paths to such list:
    #
    # * Each directory in the current user's ${PATH}.
    # * Zeshy's user configuration file "zeshy".
    #
    # The former contain commands and the latter define globals on which Zeshy's
    # digest compilation depends. The current implementation is hardly ideal,
    # given that zsh provides builtin glob qualifier "(#qom[1])" expanding to
    # the newest path in the current filename list. Frustratingly, zsh ignores
    # such qualifier unless preceded by a "*" operator: e.g.,
    #
    #   # None of the following behave as expected.
    #   >>> print ${path}(#qom[1])
    #   >>> print ${path[@]}(#qom[1])
    #   >>> print ${^path}(#qom[1])
    #   >>> print (${~${(j:|:)${(q@)path}}})(#qom[1])
    #   zsh: bad pattern: (/opt/bin|...)(#qom[1])
    #
    # I attempted every reasonable permutation of such examples without success.
    # The last example *SHOULD* work. It works on files but not directories,
    # suggesting an internal zsh bug: e.g.,
    #
    #   # This behaves as expected.
    #   >>> list files; files=( ~/.zeshy/config/zeshy ~/.zeshy/config/zsh )
    #   >>> print (${~${(j:|:)${(q@)files}}})(#qom[1])
    #   /home/leycec/.zeshy/config/zeshy
    #
    # I tracked the culprit to a comment in "man zshall" reading:
    #
    #   "Note that grouping cannot extend over multiple directories: it is an
    #    error to have  a  `/'  within a group (this only applies for patterns
    #    used in filename generation)."
    #
    # Such comments suggests such functionality (or lack of, in this case) to be
    # intentional. I have no clear idea of the intention behind such
    # functionality, given that a "/" within a group is allowed when the target
    # is a file rather than directory. Even more bizarrely, creating a temporary
    # symbolic link to such directories and replacing such directories with such
    # symbolic links in such list and prefixing "-" to such glob qualifiers
    # produces the expected behavior: e.g.,
    #
    #   # Bizarrely, this behaves as expected.
    #   >>> ln -s /opt/bin t1
    #   >>> ln -s /usr/bin t2
    #   >>> touch /usr/bin
    #   >>> list files; files=( t1 t2 )
    #   >>> print (${~${(j:|:)${(q@)files}}})(#q-om[1])
    #   t2
    #
    # WHAT THE BLOODY HECK. It's hard to regard this as anything but a blatant
    # bug. I intuitively suspect that the zsh mailing list would not be
    # receptive to such arguments -- even given the obscene above symbolic link
    # example, exposing the inanity of such arbitrary constraints. Given that
    # example, we could circumvent the constraints by temporarily making and
    # then removing one symbolic link for each directory in the current ${path}.
    # This requires iteration and hence is likely to be no more efficient than
    # the current implementation... or not much more efficient, anyway.
    #
    # Until zsh support improves in this respect, this loop remains.
    for dependency_pathname ( "${path[@]}" "${ZESHY_DOT_CONFIG_DIR}/"{,zeshy}) {
#       say "adding mtime for dependency \"${dependency_pathname}\"..."
        [[ -e "${dependency_pathname}" ]] &&
            zeshy_dependency_mtimes+="$(zstat +mtime "${dependency_pathname}")"
    }

    # If the current user is a Zeshy developer, obtain the last modification
    # time of the Zeshy codebase by sorting the set of all last modification
    # times of all files and directories in this codebase and selecting the
    # largest such time. This is at best an O(n*lg(n)) operation, and hence
    # confined to developers. Dismantled, this is:
    #
    # * "${...}"/**/*, all files and directories of this codebase.
    # * "om", sorting such files and directories by descending mtime.
    # * "[1]", the first and hence newest such file or directory.
    is_zeshy_debugging_and {
#       say "adding Zeshy codebase \"${ZESHY_HOME}\" as a digest dependency..."
        zeshy_dependency_mtimes+="$(zstat +mtime "${ZESHY_HOME}"/**/*(om[1]))"
    }

    # The newest modification time of all dependencies of Zeshy's digest.
    # Technically, sorting such list is technically O(n lg(n)). Assuming a
    # sufficiently small ${PATH}, sorting is nearly O(n). Dismantled, this is:
    #
    # * "(nO@)", numerically sorting such list in descending order.
    # * "[1]", the first and hence newest such time.
    ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME="${${(nO@)zeshy_dependency_mtimes}[1]}"

    # The modification time of Zeshy's digest.
    integer zeshy_digest_mtime
    zeshy_digest_mtime="$(zstat +mtime "${ZESHY_DOT_DIGEST_FILE}")"

    # If Zeshy's digest is older than its newest dependency, signify such digest
    # to be outdated by returning true.
#   say "mtimes: ${dependency_mtimes[@]}"
#   say "newest: ${ZESHY_NEWEST_DEPENDENCY_MTIME}"
#   say "digest: ${zeshy_digest_mtime}"
#   say "digest file: \"${ZESHY_DOT_DIGEST_FILE}\""
    (( zeshy_digest_mtime <\
        ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME ))
}

# ....................{ SETUP ~ digest                     }....................
set_function_documentation setup_zeshy_digest '
void setup_zeshy_digest(void)

Assuming Zeshy''s user digest file to be outdated, implement aliases and
functions required only for compiling an outdated digest file.
'
function setup_zeshy_digest() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # If debugging Zeshy, print modification times for Zeshy's user digest file
    # and the newest path such file depends upon.
    is_zeshy_debugging_and {
        [[ -f "${ZESHY_DOT_DIGEST_FILE}" ]] &&
            say "digest mtime:                   $(zstat +mtime "${ZESHY_DOT_DIGEST_FILE}")"
            say "digest newest dependency mtime: ${ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME}"
    }

    # ------------------< FUNCTIONS                          >------------------
    # Define document_function() before document_alias(), which documents itself
    # with the former function.
    function document_function() {
        # Validate passed arguments.
        (( # == 1 )) || die 'expected one documentation string'
        local documentation="${1}" function_name
        local -a function_names

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "[^[:space:]]##", matching the function return type.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([^'(']##)", matching the function name into ${match[1]}.
        # * '(', matching the beginning of the function argument list.
        if [[ "${documentation}" ==\
            (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
            # Attempt to split such function name on " [OR] " delimiters.
            function_name="${match[1]}"
            function_names=( "${(s: [OR] :)function_name}" )

            # If such function name contains no such delimiters, document as is.
            if (( ${#function_names} == 1 ))
            then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name}]="${documentation}"
            # Else, such function name contains at least one such delimiter.
            # Document each split function name with such documentation.
            else
                for function_name_split ("${function_names[@]}") {
#                   print "function name split: ${function_name_split}"
                    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split}]="${documentation}"
                }
            fi
#           print "function name: ${match[1]}"
        # Else, throw an exception with a portion of such documentation.
        else die "help string \"${documentation[1,40]}...\" not prefixed by a function prototype"
        fi
    }

    # ------------------< ALIASES                            >------------------
    function document_alias() {
        # Validate passed arguments.
        (( # == 1 )) || die 'expected one documentation string'
        local documentation="${1}"

        # If such documentation is prefixed by an alias prototype, match the
        # relevant alias name from such prototype. While zsh permissively allows
        # alias name declarations to be quoted and hence contain arbitrary
        # characters as with functions, such aliases are not runnable: e.g.,
        #
        #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
        #   >>> o\ w\ s
        #   zsh: command not found: o w s
        #
        # For simplicity, use a similar glob expression as document_function().
        if [[ "${documentation}" ==\
            (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
        then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
        # Else, throw an exception with a portion of such documentation.
        else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
        fi
    }

    # ------------------< GLOBALS                            >------------------
    set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
map ZESHY_GLOBAL_TYPE_TO_DECLARATOR

Map variable type to the command prefix exporting globals of such type.
'
    typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
    ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
        # Scalar types.
        string   'export'
        boolean  'export'
        integer  'export -i'
        float    'export -F'

        # Non-scalar types.
        list     'export -a'
        list_set 'export -Ua'

        # While "export -a" succeeds (as above), "export -A" fails with error.
        # Hence, revert to builtin typeset().
        map 'typeset -Agx'
    )

    alias document_global='
    {
        # Localize the passed herestring.
        local documentation__dg="$(< /dev/stdin)"

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
        #
        # Else throw an exception with a portion of such documentation.
        [[ "${documentation__dg}" ==\
            (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
            die "help string \"${documentation__dg[1,40]}...\" not prefixed by a variable declaration"

        #FIXME: If such global has been declared, we should probably print a
        #warning to standard error if its declared type differs from the
        #documentation-declared type. The implementation is a bit tedious,
        #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
        #dynamically constructed from its converse for performing efficient
        #lookups. Clearly, not a priority for the moment.

        # If such global has not yet been declared, do so. Prefer globals
        # "${match[1]}" and "${match[2]}" to human-readable local variables to
        # avoid polluting the local shell environment any further. See
        # is_variable() for implementation details.
        [[ -n "${(P)match[2]+x}" ]] || {
            # If such global''s type is not a Zeshy-specific type, throw an
            # exception. See is_map_key() for implementation details.
            (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
                die "\"${match[1]}\" not a zeshy type"

            # Declare such global.
            ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"
        }

        # Document such global.
        ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${match[2]}]="${documentation__dg}"
    #   print "function name: ${match[1]}"
    } <<<'
}

# ....................{ MAIN                               }....................
setup_zeshy

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Many of the functions this function calls redundantly test
    #"[[ -n "${ZESHY_DOT_DIR}" ]]" as well. Eliminate that.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0
    # Source Zeshy's user configuration files here, as such files define global
    # ${ZESHY_IS_DEBUGGING} tested by functions called immediately below.
#   setup_zeshy_configuration
#   which is_zeshy_debugging_and
#   is_zeshy_debugging_and print 'ok'

#FUXME: If splitting as described, rename the above function to config_zeshy(),
#which is really a much more sensible name in any case.
#FUXME: Eliminate.
#set_function_documentation setup_zeshy_digest_uptodate '
#void setup_zeshy_digest_uptodate(void)
#
#Assuming Zeshy''s user digest file to be up-to-date, implement placeholders for
#aliases and functions required only for compiling an outdated digest file.
#'
#function setup_zeshy_digest_uptodate() {
#    # Validate sanity.
#    (( # == 0 )) || die 'expected no arguments'
#
#    # Implement placeholders with zsh builtin ":" (i.e., noop).
#    alias document_alias=':'
#    alias document_function=':'
#    alias document_global=':'
#}

#FUXME: O.K.; start using is_zeshy_debugging_and<> everywhere. Yum!

#Parse the passed documentation, associating the global name prefixing such
#documentation with such documentation and globally exporting such global as the
#Zeshy-specific type prefixing such documentation. Expand this alias only before
#compiling Zeshy''s user digest file.
#FUXME: Use is_zeshy_debugging_and<> instead. This requires we shift such
    #code to the very bottom of this component, but it makes everything nice and
    #orthogonal. So, go-go-go!
    #FUXME: This isn't right. Such configuration defines ${ZESHY_IS_DEBUGGING},
    #used *ABOVE*. Clearly, config files should be sourced *BEFORE* testing the
    #digest file, yes?

#FUXME: For both efficiency and readability, define a new alias resembling:
#
#  alias inquisitively='[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&'    # or perhaps...
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "if_zeshy_debugging" or
#"is_zeshy_debugging_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUGGING} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_debugging_and='true ||'
#
#Brilliant! This reduces such test to a (hopefully) maximally fast no-op while
#ensuring it evaluates to true and hence does not throw exceptions.
#FUXME: After defining such alias, fixup all current references to
#${ZESHY_IS_DEBUGGING} - particularly at the top level.
    # Replacing all prior instances of '[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&' in
    # the Zeshy codebase with 'is_zeshy_debugging_and'
    #
    # If such configuration enables Zeshy debugging, expand such alias to the
    # empty string, thus unconditionally running the passed command.
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "if_zeshy_debugging" or
#"is_zeshy_debugging_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUGGING} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_debugging_and='true ||'

#       say 'digest outdated!'
#   print "ZESHY_DOT_DIGEST_FILE_IS_OUTDATED: ${ZESHY_DOT_DIGEST_FILE_IS_OUTDATED}"
# non-zero only if such file was outdated at shell startup.
    #FUXME: Not quite right. We need to set
    #ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME to the current
    #time. Now how do we do that, again...?
#* The main user-specific Zeshy configuration file. This file contains theme
#  settings, which when edited require recompiling theme autoloads.
#* The main system-wide command directories (e.g., "/bin", "/usr/bin").
#  Installing or uninstalling commands requires recompiling command autoloads.

#           if [[ "${function_name}" == *'[OR]'* ]]; then
#FUXME: Shift is_zeshy_digest_outdated() here and cache the result into a global
#variable, as subsequent components will also need reference such result. Shift
#document_function() here as well. If Zeshy's digest file is outdated, define
#document_function() and document_global() as below (i.e., nest such function
#and alias definitions in a code or function block run only if outdated);
#otherwise, define both document_function() and document_global() to be aliases
#expanding to ":". Genius, no? This should ensure we incur no measurable
#overhead when sourcing configuration files and *NOT* recompiling such digest.

#Processes assigned to class 3 are idle-only processes scheduled when no other
#process performs I/O. Class 3 processes are likely to suffer scheduling
#starvation and hence appropriate only for background daemons.
#FUXME: Document all such globals.
#document_global '
#list ZESHY_IONICE_CLASS_HIGH
#
#"ionice"-specific highest and lowest priority pairs consisting of class and
#ioniceness for I/O scheduling of processes. Processes assigned to class 3
#signify "idle-only" processes to be scheduled only when no other process
#performs I/O. Since such processes are likely to suffer scheduling starvation,
#omit class 3 from consideration.
#; assigning class 2 to the default lowest priority class improves
#process responsiveness.
#'

#       '/bin' '/sbin' '/usr/bin' '/usr/sbin' "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
    #FUXME: We may need to explicitly unset ${documentation__dg} *ONCE* after
    #sourcing all configuration files. We'll know whether we need to do so based on
    #whether or not the current environment has become polluted with such variable
    #after entering a new Zeshy shell.

#FUXME: Should probably be pushed into "main". Ideally, this could allow us to
#obsolete the lower-level set_*_documentation() family of functions in favor of
#the higher-level document_*() family of functions. It will increase the size of
#"main", but probably not by quite as much as thought -- after all, we'd also be
#removing a sizable block of existing functionality: set_*_documentation().
#Naturally, this requires moving document_*() and all conditional logic defining
#such functions from here to "main".
#FUXME: Since we'd like to declare such functionality as "early" as possible, we
#should probably declare "set -e" at the top of "main" and then inject such code
#immediately after "setopt" calls (i.e., before defining die(), say(), and
#friends). This implies we should undo "set -e" immediately prior to defining
#die(). (I recall we do something similar; just double-check us up.)
#FUXME: Actually, the current method isn't terribly inappropriate. Steady as she
#goes, folks!

        # Nonetheless, reuse the same glob expression for simplicity.
        # Hence, this glob expression matches more strictly than the function
        # glob expression above. Dismantled, this is:

#FUXME: Hopefully superfluous, after implementing document_global() properly.
#Excise after excising from all config files.
    # If Zeshy's user digest file is up-to-date, define placeholders for
    # runnables required only for compiling an outdated digest file.

    # * Loading Zeshy's user directory and
#   [[ -n "${ZESHY_DOT_DIR}" &&\
#FUXME: This looks *EXTREMELY* heavyweight. I'm concerned about expanding such
#alias as much as we inevitably will be. Given that, I'm currently inclined to
#reconsider aliasing document_global=':' when the digest file is not outdated.
#This requires we retain variable declarations, which is probably a good idea.
#   [[ -n "${(k)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[(r)${match[1]}]-}" ]] ||
    #FUXME: Insufficient. document_global() needs to *AT LEAST* declare such
    #global based on the passed help string.
    #FUXME: In reflection, declaring such global is basically the entirety of
    #document_global(). We'd might as well just define the whole thing as is.
#   alias document_global=':'

    # Parse variable helpstring here. Since the first line is something like:
    #
    #     string ZESHY_ZSTRANGE
    #
    #     I''m a strange global. (But here I am.)
    #
    # ...this implementation can parse that line and produce the corresponding
    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
    # implementation uses a dictionary lookup on the first shell word of such
    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
    # See initial definition above.

#: e.g.,
  # Declare ${THIS_IS_A_MAP} to be a global map.
# >>> ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[map]} THIS_IS_A_MAP
#FUXME: Excise after converting all current configuration file global
#declarations to the aliases below.
#FUXME: Hmm; actually, we'll have to replicate the current document_function()
#function into a new document_global() function defined here. And since we're
#defining that function here, we'd might as well move document_function() from
#"compile" here as well for sanity. Shouldn't be terribly difficult. The tedious
#aspect will be in converting existing configuration files to call such
#function. Well... no time like the present, yes?
#FUXME: Ah; hmm. I note that we *COULD* define:
#alias document_global='
#{
#    # Parse variable helpstring here. Since the first line is something like:
#    #
#    #     string ZESHY_ZSTRANGE
#    #
#    #     I'm a strange global. (But here I am.)
#    #
#    # ...this implementation can parse that line and produce the corresponding
#    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
#    # implementation uses a dictionary lookup on the first shell word of such
#    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
#    # See initial definition above.
#} <<<'
#I am mildly concerned about the efficiency of sourcing configuration files with
#numerous such alias expansions. If efficiency becomes a problem, just
#implement a separate document_global() function. That then leaves us with code
#resembling:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#string_global_export ZESHY_ZSTRANGE='lululululuuuuuu"
#
#The above alternative leaves us with:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#ZESHY_ZSTRANGE='lululululuuuuuu"
#
#FUXME: O.K.; so, in either case, we have a document_global() runnable. The
#latter case is more concise and hence preferable, but somewhat less efficient
#due to parsing overhead. Let's see how much it costs us. Simple experiment:
#
#* Temporarily force is_zeshy_digest_outdated() to return_false.
#* Copy all of the existing config files to a new dir under "old/".
#* Migrate existing config files to call document_global().
#* Time startup under both! Hopefully, the overhead isn't hideously noticeable.
#FUXME: The following aliases *SHOULD* already exist under "always/00-setup".
#Ensure this to be the case; then, excise such aliases here.

#       set_global_documentation "${match[2]}" "${documentation}"
# print_function_documentation() to subsequently print such documentation.
#       then set_function_documentation "${match[1]}" "${documentation}"
# ....................{ EXPORTS                            }....................
# Zeshy configuration files declare only global exports. While such files can
# declare locals and non-exported globals with traditional Zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Delay defining all remaining Zeshy aliases to the
# main Zeshy codebase.

#is_zeshy_digest_outdated() returning true. Yes:
#this is somewhat hackier than we prefer, but the alternatives are uglier.
#   local -a path_plus_zeshy
#   path_plus_zeshy=( "${path[@]}" "${ZESHY_DOT_CONFIG_DIR}/zeshy" )
#   local path_plus_zeshy_glob="${(j~|~)${(q@)path_plus_zeshy}}"
#   zeshy_dependency_mtimes+="$(zstat +mtime "${path_plus_zeshy_glob}")"

    #FUXME: Definitely not right. We absolutely want to do this *AFTER*
    #"always/shell/profile" establishes the global list "path"; then, replace
    #the awkwardly hard-coded paths below with the following:
    #
    #    for dependency_pathname ("${path[@]}" "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
    #
    #Concise; awesome; and exactly what's needed. We'll probably just want to
    #extricate the setting of the ${PATH} currently performed by
    #"always/shell/profile" to somewhere directly under "src/" -- perhaps this
    #component? There's really no reason to perform such logic *ONLY* under a
    #login shell; ideally, the ${PATH} should always be "fixed up" on Zeshy
    #startup. After all, either the user or a script could destroy the ${PATH}
    #after login, in which case we really wouldn't want to trust its current
    #setting. So, fix it up to guarantee sane behavior.
    #FUXME: We can substantially optimize this, I believe. Cease appending
    #modification times to list ${dependency_mtimes}; instead, perform a single
    #call to $(zstat +mtime ...) with a single argument selecting the oldest
    #such path that exists:
    #
    # zstat +mtime (if_shell_interactive|posix)(e:'[[ -e $REPLY ]]':om[1])
    #
    #That works at the shell. Given that, how about a generalization:
    #
    # zstat +mtime (~dependency_pathname_glob)(e:'[[ -e $REPLY ]]':om[1])

#
    # Dismantled, this is:
    #
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
#   local dependency_pathname_glob
#   : ${dependency_pathname_glob::=\'${^path}\'}
#   dependency_pathname_glob="${path}|${ZESHY_DOT_CONFIG_DIR}/zeshy"
#   ="${path}|${ZESHY_DOT_CONFIG_DIR}/zeshy"

    #FUXME: Mostly right. Note that for safe generality, however, reserved glob
    #characters in pathnames should be prefixed by "\" to prevent usage as glob
    #characters. Fine for now, but of some importance later.
#   local -a path_quoted
#   path_quoted=( \'${^path}\' "${ZESHY_DOT_CONFIG_DIR}/zeshy" )
#   local path_quoted_glob="${(j:|:)path_quoted}"

    #FUXME: Rename "ZESHY_IS_DEBUGGING" to "ZESHY_IS_IN_DEVELOPMENT". :)
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
    # If either or configuration directory do not exist or
    # the latter exists but is empty, mark such file "outdated."
    # Ensure the current user's Zeshy configuration directory and all non-extant
    # parents of such directory exist.
#   command mkdir -p -- "${ZESHY_DOT_CONFIG_DIR}"

    # specifically including:
    #
    # * All plain files in such directory.
    # * If the current shell is interactive, all plain files in subdirectory
    #   "if_shell_interactive" of such directory.
    #
    # If the current shell is interactive and such directory contains a
    # subdirectory "if_shell_interactive" containing at least one Zeshy script,
    # source such scripts as above.
#   config_filenames=( "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

# Booleans are false if set to the empty string and otherwise true.
#
# For simplicity, disable or enable booleans by commenting or uncommenting the
# lines on which they appear (e.g., prefixing such lines with "#" or deleting
# such prefix).

    # subsequent logic
    # sources the default versions of such files.

#FUXME: All of the magic constants defined in "global" should be declared
#frozen, perhaps suggesting new "string_global_constant",
#"boolean_global_constant", and so on types in "alias".

#FUXME: I'm not terribly fond of enabling booleans by setting them to 1. Avoid
#such magic by defining the following magic in "global":
#
#string_global_constant ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=''
#
#Then use below: e.g.,
#ZESHY_IS_DEBUGGING=${ZESHY_BOOLEAN_TRUE}

# void string_global_export(string variable_name)
#
# Globally declare a string exported to the calling shell.
#alias string_global_export='export'

# void boolean_global_export(string variable_name)
#
# Globally declare a boolean exported to the calling shell.
#alias boolean_global_export='export'

# void integer_global_export(string variable_name)
#
# Globally declare an integer exported to the calling shell.
#alias integer_global_export='export -i'

# void float_global_export(string variable_name)
#
# Globally declare a float exported to the calling shell.
#alias float_global_export='export -F'

# void list_global_export(list variable_name)
#
# Globally declare a list exported to the calling shell.
#alias list_global_export='export -a'

# void map_global_export(map variable_name)
#
# Globally declare a map exported to the calling shell.
#alias map_global_export='typeset -Agx'   # "export -A" oddly fails with error;
                                          # "export -a" succeeds, however (!?!)
