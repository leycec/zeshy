#!/usr/bin/env zsh
# ====================[ setup                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Source the current user's Zeshy configuration files after defining aliases
# required by such files. For efficiency, defer defining all other aliases to
# Zeshy startup in the proper Zeshy codebase and hence compilation into the
# Zeshy digest file. Redefine aliases defined below with such other aliases,
# guaranteeing that:
#
# * Zeshy records all aliases defined below in global list ${ZESHY_ALIAS_NAMES},
#   to be subsequently undefined if recompiling Zeshy in the current shell or a
#   child of the current shell. (See "compile" for gruesome details.)
# * Zeshy retrieves documentation for all aliases defined below in the same
#   manner as such other aliases. (See "help" for miserable details.)

#FIXME: Shift is_zeshy_digest_outdated() here and cache the result into a global
#variable, as subsequent components will also need reference such result. Shift
#document_function() here as well. If Zeshy's digest file is outdated, define
#document_function() and document_global() as below (i.e., nest such function
#and alias definitions in a code or function block run only if outdated);
#otherwise, define both document_function() and document_global() to be aliases
#expanding to ":". Genius, no? This should ensure we incur no measurable
#overhead when sourcing configuration files and *NOT* recompiling such digest.

# ....................{ GLOBALS ~ boolean                  }....................
set_global_documentation ZESHY_BOOLEAN_TRUE '
boolean ZESHY_BOOLEAN_TRUE

An arbitrary non-empty string signifying a boolean true value. Since zsh
currently supports no boolean type, Zeshy emulates such type with strings.
'
set_global_documentation ZESHY_BOOLEAN_FALSE '
boolean ZESHY_BOOLEAN_FALSE

An arbitrary non-empty string signifying a boolean false value. Since zsh
currently supports no boolean type, Zeshy emulates such type with strings.
'
export ZESHY_BOOLEAN_TRUE=true ZESHY_BOOLEAN_FALSE=

# ....................{ GLOBALS ~ digest                   }....................
set_global_documentation ZESHY_DOT_DIGEST_FILE_IS_OUTDATED '
boolean ZESHY_DOT_DIGEST_FILE_IS_OUTDATED

If non-empty, Zeshy''s user digest file was outdated at shell startup. See
is_zeshy_digest_outdated() for further details.
'
export ZESHY_DOT_DIGEST_FILE_IS_OUTDATED

set_global_documentation ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME '
integer ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME

Modification time of the newest path Zeshy''s user digest file depends on, non-
zero only if such file was outdated at shell startup.
'
export -i ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME

# ....................{ ALIASES                            }....................
# Zeshy's user configuration files only export globals. While such files can
# declare locals and non-exported globals via traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Defer defining further aliases to Zeshy's codebase.
alias string_global_export='export'
alias boolean_global_export='export'
alias integer_global_export='export -i'
alias float_global_export='export -F'
alias list_global_export='export -a'
alias list_set_global_export='export -Ua'

# "export -A" fails with error; "export -a", however, succeeds. *massive shrug*
alias map_global_export='typeset -Agx'

# ....................{ TESTERS                            }....................
set_function_documentation is_zeshy_digest_outdated '
boolean is_zeshy_digest_outdated(void)

Return true if Zeshy''s digest file is outdated, thus requiring recompilation.
Return true specifically when such file does not exist or does but is older
than the newest of:

* The main user-specific Zeshy configuration file. This file contains theme
  settings, which when edited require recompiling theme autoloads.
* The main system-wide command directories (e.g., "/bin", "/usr/bin").
  Installing or uninstalling commands requires recompiling command autoloads.
'
function is_zeshy_digest_outdated() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    #FIXME: Add support for Zeshy upgrading: namely, if upgrading Zeshy,
    #immediately return 0 (i.e., true).

    # Unless:
    #
    # * Zeshy's user digest file exists under such directory and
    # * Zeshy's user configuration directory exists under such directory and is
    #   non-empty (i.e., contains at least one configuration file),
    #
    # Return such digest to be outdated.
    # * Loading Zeshy's user directory and
    [[ -f "${ZESHY_DOT_DIGEST_FILE}" && -d "${ZESHY_DOT_CONFIG_DIR}" ]] && {
        local -a zeshy_user_config_dir_if_nonempty
        zeshy_user_config_dir_if_nonempty=( "${ZESHY_DOT_CONFIG_DIR}"(/F) )
        (( #zeshy_user_config_dir_if_nonempty ))
    } || return 0

    # List of modification times of paths on which Zeshy's digest depends,
    # initialized to contain .
    local -a zeshy_dependency_mtimes

    # Append the modification time of the following paths to such list:
    #
    # * Each directory in the current user's ${PATH}.
    # * Zeshy's user configuration file "zeshy".
    #
    # The former contain commands and the latter define globals on which Zeshy's
    # digest compilation depends. The current implementation is hardly ideal,
    # given that zsh provides builtin glob qualifier "(#qom[1])" expanding to
    # the newest path in the current filename list. Frustratingly, zsh ignores
    # such qualifier unless preceded by a "*" operator: e.g.,
    #
    #   # None of the following behave as expected.
    #   >>> print ${path}(#qom[1])
    #   >>> print ${path[@]}(#qom[1])
    #   >>> print ${^path}(#qom[1])
    #   >>> print (${~${(j:|:)${(q@)path}}})(#qom[1])
    #   zsh: bad pattern: (/opt/bin|...)(#qom[1])
    #
    # I attempted every reasonable permutation of such examples without success.
    # The last example *SHOULD* work. It works on files but not directories,
    # suggesting an internal zsh bug: e.g.,
    #
    #   # This behaves as expected.
    #   >>> list files; files=( ~/.zeshy/config/zeshy ~/.zeshy/config/zsh )
    #   >>> print (${~${(j:|:)${(q@)files}}})(#qom[1])
    #   /home/leycec/.zeshy/config/zeshy
    #
    # I tracked the culprit to a comment in "man zshall" reading:
    #
    #   "Note that grouping cannot extend over multiple directories: it is an
    #    error to have  a  `/'  within a group (this only applies for patterns
    #    used in filename generation)."
    #
    # Such comments suggests such functionality (or lack of, in this case) to be
    # intentional. I have no clear idea of the intention behind such
    # functionality, given that a "/" within a group is allowed when the target
    # is a file rather than directory. Even more bizarrely, creating a temporary
    # symbolic link to such directories and replacing such directories with such
    # symbolic links in such list and prefixing "-" to such glob qualifiers
    # produces the expected behavior: e.g.,
    #
    #   # Bizarrely, this behaves as expected.
    #   >>> ln -s /opt/bin t1
    #   >>> ln -s /usr/bin t2
    #   >>> touch /usr/bin
    #   >>> list files; files=( t1 t2 )
    #   >>> print (${~${(j:|:)${(q@)files}}})(#q-om[1])
    #   t2
    #
    # WHAT THE BLOODY HECK. It's hard to regard this as anything but a blatant
    # bug. I intuitively suspect that the zsh mailing list would not be
    # receptive to such arguments -- even given the obscene above symbolic link
    # example, exposing the inanity of such arbitrary constraints. Given that
    # example, we could circumvent the constraints by temporarily making and
    # then removing one symbolic link for each directory in the current ${path}.
    # This requires iteration and hence is likely to be no more efficient than
    # the current implementation... or not much more efficient, anyway.
    #
    # Until zsh support improves in this respect, this loop remains.
    for dependency_pathname ("${path[@]}" "${ZESHY_DOT_CONFIG_DIR}/zeshy") {
#       '/bin' '/sbin' '/usr/bin' '/usr/sbin' "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
#       say "adding mtime for dependency \"${dependency_pathname}\"..."
        [[ -e "${dependency_pathname}" ]] &&
            zeshy_dependency_mtimes+="$(zstat +mtime "${dependency_pathname}")"
    }

    # If the current user is a Zeshy developer, obtain the last modification
    # time of the Zeshy codebase by sorting the set of all last modification
    # times of all files and directories in this codebase and selecting the
    # largest such time. This is at best an O(n*lg(n)) operation, and hence
    # confined to developers. Dismantled, this is:
    #
    # * "${...}"/**/*, all files and directories of this codebase.
    # * "om", sorting such files and directories by descending mtime.
    # * "[1]", the first and hence newest such file or directory.
    [[ -n "${ZESHY_IS_DEBUGGING-}" ]] && {
#       say "adding mtime for Zeshy codebase \"${ZESHY_HOME}\"..."
        zeshy_dependency_mtimes+="$(zstat +mtime "${ZESHY_HOME}"/**/*(om[1]))"
    }

    # The newest modification time of all dependencies of Zeshy's digest.
    # Technically, sorting such list is technically O(n lg(n)). Assuming a
    # sufficiently small ${PATH}, sorting is nearly O(n). Dismantled, this is:
    #
    # * "(nO@)", numerically sorting such list in descending order.
    # * "[1]", the first and hence newest such time.
    ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME="${${(nO@)zeshy_dependency_mtimes}[1]}"

    # The modification time of Zeshy's digest.
    integer zeshy_digest_mtime
    zeshy_digest_mtime="$(zstat +mtime "${ZESHY_DOT_DIGEST_FILE}")"

    # If Zeshy's digest is older than its newest dependency, signify such digest
    # to be outdated by returning true.
#   say "mtimes: ${dependency_mtimes[@]}"
#   say "newest: ${ZESHY_NEWEST_DEPENDENCY_MTIME}"
#   say "digest: ${zeshy_digest_mtime}"
#   say "digest file: \"${ZESHY_DOT_DIGEST_FILE}\""
    (( zeshy_digest_mtime <\
        ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME ))
}

# ....................{ SETUP                              }....................
set_function_documentation setup_zeshy '
void setup_zeshy(void)

Prepare Zeshy for subsequent startup and possible user digest file compilation.
Specifically, ascertain whether such file requires compilation and source all
applicable user configuration files.
'
function setup_zeshy() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Unless loading Zeshy's user directory, return silently.
    [[ -n "${ZESHY_DOT_DIR}" ]] || return 0

    # Record whether Zeshy's user digest file is outdated.
    is_zeshy_digest_outdated && ZESHY_DOT_DIGEST_FILE_IS_OUTDATED=true

    # Call the corresponding setup function.
    if [[ -z "${ZESHY_DOT_DIGEST_FILE_IS_OUTDATED}" ]]
    then setup_zeshy_digest_uptodate
    else setup_zeshy_digest_outdated
    fi

    # Undefine lower-level documentators, hereafter replaced by the previously
    # defined higher-level documentators.
    unfunction\
        set_alias_documentation\
        set_function_documentation\
        set_global_documentation

    # Source Zeshy's user configuration.
    setup_zeshy_configuration
}

# ....................{ SETUP ~ digest                     }....................
set_function_documentation setup_zeshy_digest_uptodate '
void setup_zeshy_digest_uptodate(void)

Assuming Zeshy''s user digest file to be up-to-date, implement placeholders for
aliases and functions required only for compiling an outdated digest file.
'
function setup_zeshy_digest_uptodate() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Implement placeholders with zsh builtin ":" (i.e., noop).
    alias document_alias=':'
    alias document_function=':'
    alias document_global=':'
}

set_function_documentation setup_zeshy_digest_outdated '
void setup_zeshy_digest_outdated(void)

Assuming Zeshy''s user digest file to be outdated, implement aliases and
functions required only for compiling an outdated digest file.
'
function setup_zeshy_digest_outdated() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # ------------------< FUNCTIONS                          >------------------
    # Define document_function() before document_alias(), which documents itself
    # with the former function.
    set_function_documentation document_function '
void document_function(string documentation)

Document the function prefixing the passed string with such string. Call this
function *BEFORE* compiling Zeshy''s user digest file.
'
    function document_function() {
        # Validate passed arguments.
        (( # == 1 )) || die 'expected one documentation string'
        local documentation="${1}"

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "[^[:space:]]##", matching the function return type.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([^'(']##)", matching the function name into ${match[1]}.
        # * '(', matching the beginning of the function argument list.
        if [[ "${documentation}" ==\
            (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]
        then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
        # Else throw an exception with a portion of such documentation.
        else die "help string \"${documentation[1,40]}...\" not prefixed by a function prototype"
        fi
    }

    # ------------------< ALIASES                            >------------------
    document_function '
void document_alias(string documentation)

Document the alias prefixing the passed string with such string. Call this
function *BEFORE* compiling Zeshy''s user digest file.
'
    function document_alias() {
        # Validate passed arguments.
        (( # == 1 )) || die 'expected one documentation string'
        local documentation="${1}"

        # If such documentation is prefixed by an alias prototype, match the
        # relevant alias name from such prototype. While zsh permissively allows
        # alias name declarations to be quoted and hence contain arbitrary
        # characters as with functions, such aliases are not runnable: e.g.,
        #
        #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
        #   >>> o\ w\ s
        #   zsh: command not found: o w s
        #
        # For simplicity, use a similar glob expression as document_function().
        if [[ "${documentation}" ==\
            (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
        then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
        # Else throw an exception with a portion of such documentation.
        else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
        fi
    }

    # ------------------< GLOBALS                            >------------------
    set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
map ZESHY_GLOBAL_TYPE_TO_DECLARATOR

Map variable type to the command prefix exporting globals of such type.
'
    typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR; ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
        # Scalar types.
        string   'export'
        boolean  'export'
        integer  'export -i'
        float    'export -F'

        # Non-scalar types.
        list     'export -a'
        list_set 'export -Ua'

        # While "export -a" succeeds (as above), "export -A" fails with error.
        # Hence, revert to builtin typeset().
        map 'typeset -Agx'
    )

    set_alias_documentation document_global '
void document_global(string documentation)

Parse the passed documentation, associating the global name prefixing such
documentation with such documentation and globally exporting such global as the
Zeshy-specific type prefixing such documentation. Expand this alias only before
compiling Zeshy''s user digest file.
'
    alias document_global='
    {
        # Localize the passed herestring.
        local documentation__dg="$(< /dev/stdin)"

        # If such documentation is prefixed by a function prototype, match the
        # relevant function name from such prototype. zsh permissively allows
        # function name declarations to be quoted and hence contain arbitrary
        # characters, necessitating a more lenient glob expression than liked.
        # Dismantled, this is:
        #
        # * "(#b)", capturing match groups into global list ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
        #
        # Else throw an exception with a portion of such documentation.
        [[ "${documentation__dg}" ==\
            (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
            die "help string \"${documentation__dg[1,40]}...\" not prefixed by a variable declaration"

        # If the matched variable type is not a Zeshy-specific type, throw an
        # exception. See is_map_key() for implementation details.
        #
        # Prefer "${match[1]}" and "${match[2]}" to human-readable local
        # variables to avoid polluting the local environment any further.
        (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
            die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
        ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

        # Document such global.
        ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${match[2]}]="${documentation__dg}"
    #   print "function name: ${match[1]}"
    } <<<'
}

# ....................{ SETUP ~ config                     }....................
set_function_documentation setup_zeshy_configuration '
void setup_zeshy_configuration(void)

Source all configuration files in Zeshy''s user configuration directory specific
to the current shell, creating such directory if needed. Such files include:

* All plain files in such directory.
* If the current shell is interactive, all plain files in subdirectory
  "if_shell_interactive" of such directory.
'
function setup_zeshy_configuration() {
    # Validate sanity. Unless loading Zeshy's user directory and Zeshy's user
    # configuration directory exists, return silently.
    (( # == 0 )) || die 'expected no arguments'
    [[ -n "${ZESHY_DOT_DIR}" && -d "${ZESHY_DOT_CONFIG_DIR}" ]] || return 0

    # List of all scripts in such directory applicable to the current shell,
    # Dismantled, this is:
    #
    # * "*(-.)", matching all plain files after resolving symbolic links.
    local -a config_filenames
    config_filenames=(
        "${ZESHY_DOT_CONFIG_DIR}/"*(-.) )
    [[ -o interactive ]] && config_filenames+=(
        "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

    # If at least one such script exists, source such scripts; else, avoid
    # calling source_zeshy_script() with no arguments throwing an exception.
    (( #config_filenames )) && source_zeshy_script "${config_filenames[@]}"
}

# ....................{ MAIN                               }....................
setup_zeshy

# --------------------( WASTELANDS                         )--------------------
    #FUXME: We may need to explicitly unset ${documentation__dg} *ONCE* after
    #sourcing all configuration files. We'll know whether we need to do so based on
    #whether or not the current environment has become polluted with such variable
    #after entering a new Zeshy shell.

#FUXME: Should probably be pushed into "main". Ideally, this could allow us to
#obsolete the lower-level set_*_documentation() family of functions in favor of
#the higher-level document_*() family of functions. It will increase the size of
#"main", but probably not by quite as much as thought -- after all, we'd also be
#removing a sizable block of existing functionality: set_*_documentation().
#Naturally, this requires moving document_*() and all conditional logic defining
#such functions from here to "main".
#FUXME: Since we'd like to declare such functionality as "early" as possible, we
#should probably declare "set -e" at the top of "main" and then inject such code
#immediately after "setopt" calls (i.e., before defining die(), say(), and
#friends). This implies we should undo "set -e" immediately prior to defining
#die(). (I recall we do something similar; just double-check us up.)
#FUXME: Actually, the current method isn't terribly inappropriate. Steady as she
#goes, folks!

        # Nonetheless, reuse the same glob expression for simplicity.
        # Hence, this glob expression matches more strictly than the function
        # glob expression above. Dismantled, this is:

#FIXME: Hopefully superfluous, after implementing document_global() properly.
#Excise after excising from all config files.
    # If Zeshy's user digest file is up-to-date, define placeholders for
    # runnables required only for compiling an outdated digest file.

    # * Loading Zeshy's user directory and
#   [[ -n "${ZESHY_DOT_DIR}" &&\
#FUXME: This looks *EXTREMELY* heavyweight. I'm concerned about expanding such
#alias as much as we inevitably will be. Given that, I'm currently inclined to
#reconsider aliasing document_global=':' when the digest file is not outdated.
#This requires we retain variable declarations, which is probably a good idea.
#   [[ -n "${(k)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[(r)${match[1]}]-}" ]] ||
    #FUXME: Insufficient. document_global() needs to *AT LEAST* declare such
    #global based on the passed help string.
    #FUXME: In reflection, declaring such global is basically the entirety of
    #document_global(). We'd might as well just define the whole thing as is.
#   alias document_global=':'

    # Parse variable helpstring here. Since the first line is something like:
    #
    #     string ZESHY_ZSTRANGE
    #
    #     I''m a strange global. (But here I am.)
    #
    # ...this implementation can parse that line and produce the corresponding
    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
    # implementation uses a dictionary lookup on the first shell word of such
    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
    # See initial definition above.

#: e.g.,
  # Declare ${THIS_IS_A_MAP} to be a global map.
# >>> ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[map]} THIS_IS_A_MAP
#FUXME: Excise after converting all current configuration file global
#declarations to the aliases below.
#FUXME: Hmm; actually, we'll have to replicate the current document_function()
#function into a new document_global() function defined here. And since we're
#defining that function here, we'd might as well move document_function() from
#"compile" here as well for sanity. Shouldn't be terribly difficult. The tedious
#aspect will be in converting existing configuration files to call such
#function. Well... no time like the present, yes?
#FUXME: Ah; hmm. I note that we *COULD* define:
#alias document_global='
#{
#    # Parse variable helpstring here. Since the first line is something like:
#    #
#    #     string ZESHY_ZSTRANGE
#    #
#    #     I'm a strange global. (But here I am.)
#    #
#    # ...this implementation can parse that line and produce the corresponding
#    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
#    # implementation uses a dictionary lookup on the first shell word of such
#    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
#    # See initial definition above.
#} <<<'
#I am mildly concerned about the efficiency of sourcing configuration files with
#numerous such alias expansions. If efficiency becomes a problem, just
#implement a separate document_global() function. That then leaves us with code
#resembling:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#string_global_export ZESHY_ZSTRANGE='lululululuuuuuu"
#
#The above alternative leaves us with:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#ZESHY_ZSTRANGE='lululululuuuuuu"
#
#FUXME: O.K.; so, in either case, we have a document_global() runnable. The
#latter case is more concise and hence preferable, but somewhat less efficient
#due to parsing overhead. Let's see how much it costs us. Simple experiment:
#
#* Temporarily force is_zeshy_digest_outdated() to return_false.
#* Copy all of the existing config files to a new dir under "old/".
#* Migrate existing config files to call document_global().
#* Time startup under both! Hopefully, the overhead isn't hideously noticeable.
#FUXME: The following aliases *SHOULD* already exist under "always/00-setup".
#Ensure this to be the case; then, excise such aliases here.

#       set_global_documentation "${match[2]}" "${documentation}"
# print_function_documentation() to subsequently print such documentation.
#       then set_function_documentation "${match[1]}" "${documentation}"
# ....................{ EXPORTS                            }....................
# Zeshy configuration files declare only global exports. While such files can
# declare locals and non-exported globals with traditional Zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Delay defining all remaining Zeshy aliases to the
# main Zeshy codebase.

#is_zeshy_digest_outdated() returning true. Yes:
#this is somewhat hackier than we prefer, but the alternatives are uglier.
#   local -a path_plus_zeshy
#   path_plus_zeshy=( "${path[@]}" "${ZESHY_DOT_CONFIG_DIR}/zeshy" )
#   local path_plus_zeshy_glob="${(j~|~)${(q@)path_plus_zeshy}}"
#   zeshy_dependency_mtimes+="$(zstat +mtime "${path_plus_zeshy_glob}")"

    #FUXME: Definitely not right. We absolutely want to do this *AFTER*
    #"always/shell/profile" establishes the global list "path"; then, replace
    #the awkwardly hard-coded paths below with the following:
    #
    #    for dependency_pathname ("${path[@]}" "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
    #
    #Concise; awesome; and exactly what's needed. We'll probably just want to
    #extricate the setting of the ${PATH} currently performed by
    #"always/shell/profile" to somewhere directly under "src/" -- perhaps this
    #component? There's really no reason to perform such logic *ONLY* under a
    #login shell; ideally, the ${PATH} should always be "fixed up" on Zeshy
    #startup. After all, either the user or a script could destroy the ${PATH}
    #after login, in which case we really wouldn't want to trust its current
    #setting. So, fix it up to guarantee sane behavior.
    #FUXME: We can substantially optimize this, I believe. Cease appending
    #modification times to list ${dependency_mtimes}; instead, perform a single
    #call to $(zstat +mtime ...) with a single argument selecting the oldest
    #such path that exists:
    #
    # zstat +mtime (if_shell_interactive|posix)(e:'[[ -e $REPLY ]]':om[1])
    #
    #That works at the shell. Given that, how about a generalization:
    #
    # zstat +mtime (~dependency_pathname_glob)(e:'[[ -e $REPLY ]]':om[1])

#
    # Dismantled, this is:
    #
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
#   local dependency_pathname_glob
#   : ${dependency_pathname_glob::=\'${^path}\'}
#   dependency_pathname_glob="${path}|${ZESHY_DOT_CONFIG_DIR}/zeshy"
#   ="${path}|${ZESHY_DOT_CONFIG_DIR}/zeshy"

    #FUXME: Mostly right. Note that for safe generality, however, reserved glob
    #characters in pathnames should be prefixed by "\" to prevent usage as glob
    #characters. Fine for now, but of some importance later.
#   local -a path_quoted
#   path_quoted=( \'${^path}\' "${ZESHY_DOT_CONFIG_DIR}/zeshy" )
#   local path_quoted_glob="${(j:|:)path_quoted}"

    #FUXME: Rename "ZESHY_IS_DEBUGGING" to "ZESHY_IS_IN_DEVELOPMENT". :)
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
    # If either or configuration directory do not exist or
    # the latter exists but is empty, mark such file "outdated."
    # Ensure the current user's Zeshy configuration directory and all non-extant
    # parents of such directory exist.
#   command mkdir -p -- "${ZESHY_DOT_CONFIG_DIR}"

    # specifically including:
    #
    # * All plain files in such directory.
    # * If the current shell is interactive, all plain files in subdirectory
    #   "if_shell_interactive" of such directory.
    #
    # If the current shell is interactive and such directory contains a
    # subdirectory "if_shell_interactive" containing at least one Zeshy script,
    # source such scripts as above.
#   config_filenames=( "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

# Booleans are false if set to the empty string and otherwise true.
#
# For simplicity, disable or enable booleans by commenting or uncommenting the
# lines on which they appear (e.g., prefixing such lines with "#" or deleting
# such prefix).

    # subsequent logic
    # sources the default versions of such files.

#FUXME: All of the magic constants defined in "global" should be declared
#frozen, perhaps suggesting new "string_global_constant",
#"boolean_global_constant", and so on types in "alias".

#FUXME: I'm not terribly fond of enabling booleans by setting them to 1. Avoid
#such magic by defining the following magic in "global":
#
#string_global_constant ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=''
#
#Then use below: e.g.,
#ZESHY_IS_DEBUGGING=${ZESHY_BOOLEAN_TRUE}

# void string_global_export(string variable_name)
#
# Globally declare a string exported to the calling shell.
#alias string_global_export='export'

# void boolean_global_export(string variable_name)
#
# Globally declare a boolean exported to the calling shell.
#alias boolean_global_export='export'

# void integer_global_export(string variable_name)
#
# Globally declare an integer exported to the calling shell.
#alias integer_global_export='export -i'

# void float_global_export(string variable_name)
#
# Globally declare a float exported to the calling shell.
#alias float_global_export='export -F'

# void list_global_export(list variable_name)
#
# Globally declare a list exported to the calling shell.
#alias list_global_export='export -a'

# void map_global_export(map variable_name)
#
# Globally declare a map exported to the calling shell.
#alias map_global_export='typeset -Agx'   # "export -A" oddly fails with error;
                                          # "export -a" succeeds, however (!?!)
