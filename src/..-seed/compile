#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# (Re)compile the `zeshy` codebase into the current user's `zeshy` digest file.
#
# --------------------( SYMBOLS                            )--------------------
# In most programming languages, the symbols that language exports for external
# use (e.g., packages, classes, functions, globals) do *NOT* vary with system or
# user configuration. The same version of the same language unconditionally
# exports the same symbols everywhere, forming the language "core".
#
# As expected, `zeshy` behaves different. Most symbols `zeshy` exports for external
# use at the command line and within scripts conditionally vary with system and
# user state, including:
#
# * The output of the system-specific "lsb_release" and/or "uname" commands.
# * The contents of the user-specific `zeshy` configuration at "~/.zeshy/config".
# * The contents of the user-specific ${PATH} (i.e., the set of currently
#   installed and accessible programs).
#
# zeshy monitors such content for changes -- silently, efficiently, and entirely
# automatically. On detecting changes, `zeshy` changes itself. As example:
#
# * On switching from a Linux to BSD operating system, `zeshy` supplants the
#   Linux-specific symbols it exports with those specific to BSD.
# * On installing a new program "rtorrent" into the system-wide "/bin" directory
#   in the ${PATH}, `zeshy` exports "rtorrent"-specific symbols.
#
# `zeshy` symbols comprise `zeshy`-specific zsh functions and, to a lesser extent,
# zsh aliases and globals. For efficiency, `zeshy` exports the former as a single
# zsh digest file (i.e., a binary file in a zsh-specific format functionally
# analogous to that of C and C++-style shared libraries).
#
# `zeshy` compiles *ONLY* that subset of itself specific to current system and
# user state into its digest file. Uncompiled code remains inaccessible until
# such state changes (e.g., installing "rtorrent" notifies `zeshy` to compile
# start_rtorrent() and stop_rtorrent() functions into its digest file). For end
# user purposes, `zeshy` *IS* its digest file.
#
# --------------------( OVERLAYS                           )--------------------
# To accomodate system- and user-specific `zeshy` add-ons (e.g., plugins, themes),
# `zeshy` divides itself into overlays: directories with the same structure as
# `zeshy`'s top-level "src" directory. `zeshy` ignores all files and directories in
# an overlay except those with the following `zeshy`-specific names:
#
# * `always`, a subdirectory recursively containing only:
#   * `zeshy` scripts, to be unconditionally compiled into `zeshy`\'s digest file.
#     These scripts may reside directly in the mandatory "always" directory
#     or under optional subdirectories. In either case, `zeshy` automatically
#     finds and compiles all zsh functions in all such files.
#   * Subdirectories with arbitrary names and nesting. (`zeshy` automatically
#     finds all scripts in such subdirectories. Subdirectory structure is
#     insignificant and hence only for optional organization.)
# * `if_config`, a subdirectory directly containing only:
#   * `zeshy` configuration files, to be unconditionally copied into the user-
#     specific `~/.zeshy/config` directory if not already found.
# * `if_pathable`, a subdirectory directly containing only:
#   * `zeshy` scripts, each conditionally compiled into `zeshy`\'s digest file
#     _only_ if an executable file of the same case-sensitive basename currently
#     exists in the user-specific ${PATH}.
#   * Subdirectories, each conditionally enabled as a `zeshy` overlay and hence
#     subject to recursive processing (e.g., for an `always` subdirectory) only
#     if an executable file of the same case-sensitive basename currently exists
#     in the user-specific ${PATH}.
# * `if_package_manager`, a subdirectory directly containing only:
#   * Subdirectories, each conditionally enabled as a `zeshy` overlay _only_ if
#     the corresponding package management system is currently available under
#     the current system.

#FIXME: Fantastic and fairly essential optimization uncovered. If this is *NOT*
#the first compilation of zeshy by this user (i.e., if a prior now-outdated
#digest file exists), do the following:
#
#* Source this script *UNDER AN OWNED, BACKGROUNDED SUBSHELL*. Oh, yes:
#
#    # Instead of this...
#    source compile
#
#    # ...do this!
#    ( source compile ) &
#* When complete, a pre-command line hook will be run immediately before
#  displaying the prompt at the next interactive command line. Assuming we
#  refactor such hook to reload the current digest file whenever changed (which
#  we absolutely should already do), this will have the extremely beneficial
#  end effect of permitting the user to continue interactively using zeshy
#  *BEFORE* compilation has even finished and then restarting zeshy once such
#  compilation finishes. Awesome, no?

#FIXME: So. We've more-or-less come to the definitive conclusion that the
#current configuration technique is... well, crud. Unpleasant crud. Due to the
#system-, user-, and configuration-specific nature of configuration files,
#zeshy *NEEDS* to be able to both safely create (on installation of new
#pathables), modify (on zeshy upgrade or downgrade), and delete (on
#uninstallation of existing pathables) such files at whim. Clearly, the current
#approach only permits the former.
#
#Migrating to a read-only symlink-based system permits all three. Hence, that's
#*ABSOLUTELY* what we're doing. It's so dramatically saner to do so. This has a
#number of significant benefits, including:
#
#* "~/.zeshy/config" will *ALWAYS* reflect current system, user, and zeshy
#  state.
#
#However, this has one obvious drawback:
#
#* "~/.zeshy/config" will no longer be editable.
#
#However, if one considers it, this isn't *NECESSARILY* a drawback; it's more a
#matter of cultural expectation. Hence, we modify the expectation by:
#
#* Appending a new message to the head of *EVERY* configuration file: e.g.,
#
# --------------------( EDITING                            )--------------------
# Avoid editing this file directly. Run ":config.help" for further details.
#
#O.K.; that's it! Then define function :config.help() to print the following
#terminal-wrapped help text:
#
# --------------------( SYNOPSIS                           )--------------------
# Configuration files are typically only symbolic links to read-only,
# system-wide files of the same basename (e.g.,
# "~/.zeshy/config/00-core/alias", symbolically linking to
# "/usr/share/zeshy/config/00-core/alias") and hence should *NEVER* be edited.
#
# Instead, store all configuration edits in one or more files of any basename
# in the current user-specific zeshy overlay (e.g.,
# "~/.zeshy/source/config.zeshy", storing all such edits for the current user).
#
# --------------------( EDITS                              )--------------------
# To edit the value of any configuration global of:
#
# * Type ":list", consider appending new items to such list in such file(s): e.g.,
#     SOME_ZESHY_LIST+=( "a new item" )
# * Type ":map", consider either:
#   * Appending new key-value pairs to such map in such file(s): e.g.,
#     SOME_ZESHY_MAP+=( "a new key" "a new value" )
#   * Modifying existing key-value pairs in such map in such file(s): e.g.,
#     SOME_ZESHY_MAP[an existing key]="a new value"
# * Any other type (e.g., ":bool", ":float", ":int", ":string"), simply
#   redefine such global in such file(s): e.g.,
#     SOME_ZESHY_INTEGER=373373
#     SOME_ZESHY_STRING="a new string value"
#
# --------------------( EXAMPLES                           )--------------------
# The following example creates
#
# #FIXME: Write a real-world example here!
# >>> :script.write_with_stdin ~/.zeshy/source/config.zeshy <<'/---'
# ... #!/usr/bin/env zeshy
# ... /---
#FIXME: Actually, the above example suggests we should eliminate any possible
#confusion by pre-populating "~/.zeshy/source/" with an initial zeshy script of
#basename "config.zy" containing the above documentation. This is great, since
#we then no longer need to create a new function :config.help().

#FIXME: Ugh. We appear to have introduced a critical error by migrating away
#from the precompilation hook approach to the @{src/zz-end} approach. While the
#latter *IS* demonstrably superior, it complicates something that simply worked
#before: external system and user overlays. We now appear to source
#@{src/zz-end} *BEFORE* system and user overlays, preventing such overlays from
#being properly precompiled. As solution, consider the following:
#
#* Create a new overlay directory @{src/yy-if_overlay} with structure:
#
#  src/
#    yy-if_overlay/
#      '00-${ZESHY_SYSTEM_OVERLAY_DIRNAME}'  # 0-byte file!
#      '10-${ZESHY_USER_OVERLAY_DIRNAME}'    # 0-byte file!
#
#Naturally, we'll need a corresponding function
#::compile_zeshy_suboverlay_if_overlay() handling @{src/yy-if_overlay}, which
#will need to:
#
#* Strip the "-"-suffixed digits prefixing each such filename in such
#  directory (e.g., from '10-${ZESHY_USER_OVERLAY_DIRNAME}' to
#  '${ZESHY_USER_OVERLAY_DIRNAME}').
#* Expand the result with parameter expansion flag "(e)", attempting to detect
#  zsh parse errors in the customary way.
#* If the result is an existing directory, *IMMEDIATELY* source such directory
#  as a top-level overlay. (Try to avoid pushing such directory onto the
#  overlay stack, unless it's onto the *TOP* of such stack preceding the
#  subsequently sourced suboverlay @{zz-end}.)
#
#We know what you're thinking: but isn't the above horribly complex? Yes, and
#know. We'd probably prefer to manually embed symlinks in such directory rather
#than the whole 0-byte-file-with-filename-embedding-zsh-global-expansions
#approach. Unfortunately, Windows doesn't support symlinks. Of course, Cygwin
#presumably does. But there's more to it than just cross-platform portability:
#the above approach, while complex, *IS* phenomally customizable. And consider
#it: raw symlinks don't work in the general case, since the current system and
#user overlay directory can be customized at runtime by passing CLI options to
#the "zeshy" wrapper script.
#
#User overlays can now themselves include a subdirectory "if_overlay"
#containing hard-coded directory names, which zeshy will then recurse into.
#Actually, in such case, we'd might as well permit symbolic links. Brilliant:
#
#  ~/.zeshy/overlay/
#    if_overlay/
#      awesome -> '~/zsh/zeshy-plugins/awesome'  # a symlink
#      toonice -> '~/zsh/zeshy-plugins/toonice'  # a symlink
#
#So, users have the flexibility to hard-code paths via symlinks, while zeshy
#has the flexibility to dynamically expand paths via zsh globals. Moreover,
#prefixing such paths by "-"-prefixed digits permits the order of such
#overlay's inclusion to be explicitly specified as well. We should also note
#that, too avoid any untoward (and possible insecure) global expansions, we
#could simplify the latter case as follows:
#
#* If a file in an @{if_overlay} parcel is *NOT* a symbolic link, treat such
#  filename *AFTER* stripping "-"-prefixed digits as the name of a global
#  variable whose value expands to the desired directory name: e.g.,
#
#  src/
#    yy-if_overlay/
#      '00-ZESHY_SYSTEM_OVERLAY_DIRNAME'  # 0-byte file!
#      '10-ZESHY_USER_OVERLAY_DIRNAME'    # 0-byte file!
#
#Right. That's probably the way to go. Simpler; safer; more efficient. Yay!
#FIXME: Right. So, obviously, we don't need to support symlinks in
#@{if_overlay} overlays, since users can already just embed the desired
#symlinks directly into the top overlay. Even simpler! Say: "Yay, yay."

#FIXME: Woops. Now that this parcel supports ordered suboverlays, there would
#appear to be little point to having precompilation hooks. Such hooks introduce
#unnecessary complexity, inefficiency, *AND* cannot be reasonably ordered,
#unlike directories. All such hooks should simply be called in-place in the
#parcels in which they're currently defined. Yikes. That was a bit of a
#contemptible cock up, eh?
#FIXME: Unless there exists any solid reason for there being precompilation
#hooks? Yes, sort of: they were declared as such because they can only be called
#*AFTER* the zeshy codebase has been sourced in entirety. But that's readily
#solved now with ordered suboverlays. Hence, such hooks should simply be shifted
#from their respective parcels to @{25-main_after}, which exists exactly for
#that purpose, and called in-place there. Bravo!

#FIXME: Document our established order of suboverlays in the main overlay,
#probably in parcel documentation. Relevant documentation culled elsewhere
#includes:
#
    # Source zeshy's user configuration files:
    #
    # * *AFTER* sourcing the main zeshy codebase, ensuring such files may expand
    #   standard aliases (e.g., string_export_global<>).
    #
    # The latter point is particularly important. Serializing configuration-
    # specific globals into the user digest suggests that the configuration need
    # *NOT* be sourced on every zeshy startup but only during recompilation, an
    # efficiency improvement.

#FIXME: O.K.; I conceived a simple, but critical, technique for improving
#zeshy's robustness on upgrades: namely, *ALWAYS* explicitly source *ALL*
#configuration files supplied by the current overlay on digest file recompilation
#(i.e., from the overlay itself before copying such files to "~/.zeshy/config/"),
#*BEFORE* resourcing configuration files from "~/.zeshy/config/". What does this
#achieve? Simple. It ensures that any globals that might be missing from the
#current user's configuration will simply be set to default zeshy settings. This
#is substantially better than the current approach, which basically ensures
#"zsh: ZESHY_EUEUEUBLAHBLAH not defined" errors on upgrades. Given how easy this
#is, there's really no (or only little) downside to ramming it through.
#FIXME: ::compile_zeshy_suboverlay_if_config() would be a nice place to add
#update handling for patching locally modified config files against zeshy-
#bundled config files on update.
#FIXME: Hmmmm; no, actually. We want to implement the upgrade process as
#a startup_zeshy_upgrade()-style function in the main zeshy codebase. Why?
#Firstly, such upgrade will inevitably become a bit heavyweight, with
#functionality conditionally depending on which "diff"-style merge commands
#are installed and available to the current user (e.g., "gdiff", "vimdiff").
#Secondly, it's simply cleaner to defer upgrading until *AFTER* zeshy
#has fully bootstrapped itself. Since we already expand config globals
#defensively (e.g., ${ZESHY_THEME:-vanilla}), this should pose no issues
#even if we were to subsequently, say, rename ${ZESHY_THEME} to
#${ZESHY_USER_THEME}.
#FIXME: I should note that upgrading user-specific configuration files
#requires some care. On each zeshy precompilation, we should cache MD5 sums for
#all *SOURCE* configuration files copied from a zeshy overlay to
#"${ZESHY_USER_CONFIG_DIRNAME}" as values of a new map global -- say,
#${ZESHY_CONFIG_FILE_TO_MD5_SUM}: e.g.,
#
#  ZESHY_CONFIG_FILE_TO_MD5_SUM[posix]='595f44fec1e92a71d3e9e77456ba80d2'
#
#Clearly, the filenames should be relative to "if_config/" subdirectories.
#
#Naturally, computing file hashes suggests a new function get_file_md5_sum().
#Such function's implementation is fairly straightforward: if "md5sum" is
#pathable (i.e., the typical Unix command), run such command; else if "md5"
#is pathable (i.e., the BSD equivalent), run such command; else :die. Since
#basically *ALL* OSes are guaranteed to supply one of the two commands, I
#don't see the harm in just shoving it in a new parcel "always/path/file/hash".
#For those very reasons, we probably won't have to bother supporting other
#hashing schemes as a backup (e.g., CRC, "sha256sum"): MD5 utilities are
#ubiquitous.
#
#In any case, why save MD5 sums of source config files? Simple. On upgrade,
#we compare the stored MD5 sums against:
#
#* The corresponding new upgraded config file in "/usr/share/zeshy". Files
#  *NOT* matching such sums were changed in the upgrade.
#* The corresponding config file in "~/.zeshy/config". Files *NOT* matching
#  such sums were changed by the user.
#
#For config files changed in the upgrade but *NOT* by the user, silently
#overwrite the corresponding config file in "~/.zeshy/config" with such upgraded
#config file. However, for config files changed in the upgrade *AND* by the
#user, request the user manually merge such changes -- ideally, by invoking a
#merge utility (e.g., "vimdiff").
#
#For config files *NOT* changed in the upgrade but by the user, silently ignore
#such files. That concludes all possible permutations.
#
#Sweet, no?
#FIXME: Incidentally, the above map should also be used to detect the deletion
#of config files from a zeshy "if_config/" directory. For such files, the user
#should be warned that the corresponding file in "~/.zeshy/config" is obsolete
#and should be moved aside or deleted altogether.
#FIXME: O.K.; the above update logic is great. But there's a somewhat larger
#issue: should we even *BE* auto-copying configuration files to
#"~/.zeshy/config"? The obvious answer is: no, probably not. Let's be honest.
#Such functionality has only ever obstructed us from the developer perspective,
#and it's unclear whether such functionality would be overly beneficial (given
#the upgrade complications) to actual users either. Now, what we *CAN* and
#certainly should do is offer the user some means of configuring zeshy. Hmm;
#but this *IS* all rather complicated, isn't it? The set of applicable
#configuration files depends on the current state of the system. Oh, bloody
#hell. To make configuration feasible *WITHOUT* auto-copying, we'd need to
#implement something resembling "eselect" logic, where we interactively present
#the user a list of all applicable configuration files and have them select
#which they want to copy over. Ugh. O.K.; so, here's what we should probably be
#doing:
#
#* If zeshy is running from a "git" repository (but *NOT* necessarily with option
#  "--debug", since config auto-copying is independent of whether or not we're
#  debugging), disable auto-copying. It's simply not beneficial. It obstructs.
#* Else, enable auto-copying.
#FIXME: Right. So, the above is all sensible -- particularly the caching of MD5
#sums for configuration files. However, we can do better. *MUCH* better. To do
#so, consider a fundamentally different approach. What if, when the user makes
#custom changes to zeshy configuration files, we could store the exact changes
#such user just made to a zsh script? If we could do that (which we demonstrate
#below we can), then we can smoothly automate the upgrade process such that *NO*
#manual user intervention should be required (unlike, say, Gentoo upgrades), as
#follows:
#
#* On detecting a change to the current version of zeshy and hence a probable
#  upgrade:
#  * Check whether the zsh script caching the user's prior changes to
#    configuration files exists. If not, print a warning and do *NOT* proceed
#    with the instructions below. (This implies that such script should always
#    be initialized to a 0-byte file, even when the user has made no changes, to
#    distinguish between the erroneous case that such file has been erroneously
#    deleted or moved and the non-erroneous case that no changes have been made.)
#  * Assuming such script exists, move the user's entire zeshy configuration
#    directory to "/tmp" (e.g., "mv ~/.zeshy/config /tmp"), thus preserving such
#    directory while getting it out of the way.
#  * Copy over all applicable configuration files for the current system from
#    the newly upgraded zeshy, as usual. (No changes here, clearly.)
#  * Now for the critical part: source or run the previously cached zsh script,
#    thus "replaying" all prior custom changes the user made to the old
#    configuration files to the in-memory copy of such globals.
#  * Great! But we're only halfway there, yet. We still need to serialize such
#    changes back to disk -- specifically, to the new configuration files. It's
#    not particularly difficult to write variables back to disk, of course, but
#    we'd love to preserve the original documentation in such file, too.
#    Frankly, the only sane way to do this will be as follows:
#    * Define a new function "string :output_parcel_declarer(string parcel_name)"
#      (or perhaps an equivalent setter, to avoid subshell inefficiency)
#      outputting out a string declaring documentation for the passed parcel.
#    * Define a similar function "string :output_global_declarer(string parcel_name)".
#      That's all we should need for configuration files, which should *NEVER*
#      define new aliases or functions.
#    * Then, programmatically reconstruct each modified configuration file by
#      first overwriting such file with (in order): the corresponding parcel
#      declaration and, for each global previously defined by such file, the
#      corresponding global declaration followed immediately by the new
#      definition of such global.
#
#Hmmm. The latter is particularly problematic, however; while that *WOULD* work,
#it would also completely discard beneficial formatting in modified
#configuration files, which is completely unhelpful.
#
#Before we get to reconsidering that, however, how exactly do we even write such
#script in the first place? First, note that it's trivial to determine which
#configuration files have been modified by simply comparing the mtime (we only
#care about changes to file *CONTENT* here and hence don't care about ctime) of
#each source zeshy configuration file with the mtime of the corresponding target
#user configuration file. There's probably a number of heuristics with which to
#optimize such comparison, but by far the simplest would be to simply
#recursively touch *ALL* target user configuration files (hence changing their
#mtimes to the current time) when copying *ANY* such file; this ensures that
#unchanged files *ALL* share the same mtime, which could readily be stored as a
#global integer to the digest compiled at the same mtime -- say,
#${ZESHY_USER_CONFIG_DIR_MTIME}. Finding changed configuration files thus
#reduces to a recursive list assignment resembling:
#
#    :int path_mtime
#    :list filenames_config_changed; filenames_config_changed=(
#        "${ZESHY_USER_CONFIG_DIRNAME}"/**/*(-.e^'\
#            :set_int_to_path_mtime path_mtime "${REPLY}";\
#            (( path_mtime > ZESHY_USER_CONFIG_DIR_MTIME ))\
#        '^)"
#    ) or ignore_failure
#
#Ah. Wait. While the above *WOULD* work, it's extreme overkill. We already have
#all the tools required to find changed configuration files without needing to
#touch files or maintain new globals. How? Simple: the digest file. Grab the
#mtime of the current digest file *BEFORE* it's recompiled, then use the above
#recursive list assignment technique to find all files newer than such mtime.
#Done. Solved. Simple. Moving on!
#
#So, we efficiently find all changed files. What then? Then we need to winnow
#down exactly what changed within such files: specifically, which globals were
#changed and how. We'll tackle this in two parts: first, how do we find which
#globals were changed? This part is quite simple, fortunately, thanks to the
#fact that *ALL* configuration globals should be declared with
#:declare_global(). Given the associative mappings between a parcel and all
#globals formally declared by that parcel, we know exactly which globals such
#file defines. Great! So here's how we find which changed. For each changed
#configuration file:
#
#=======================
#Wait. Everything below applies, but it's not quite as efficient as it could be.
#In particular, we should really:
#
#* For each such global, iteratively copy such global to a new global with
#  similar name (e.g., from ${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN} to
#  ${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN_new}).
#* Source the corresponding source configuration file, thus resetting all
#  globals to their original values.
#* For each such global, compare the stored new value for such global to the
#  current original value for such global.
#
#Fairly obvious, in hindsight. The approach below has us sourcing *TWO* files,
#while the approach above only one. *shrug*
#
#=======================
#
#* Source the corresponding source configuration file, thus resetting all
#  globals to their original values.
#* For each such global, iteratively copy such global to a new global with
#  similar name (e.g., from ${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN} to
#  ${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN_old}).
#* Source the corresponding target configuration file, thus returning all
#  globals to their changed values.
#* For each such global, compare the stored old value for such global to the
#  new value for such global. This trivially reduces to an "is ... == ..."
#  comparison for scalar globals, of course. For list globals, we *COULD*
#  attempt to flatten such globals to scalars and then perform a similar
#  comparison, but I'm unconvinced that would work reliably on edge cases. For
#  robustness, it'll be necessary to define a new :is_list_equals() function
#  efficiently comparing two lists as follows:
#
#  * If the size of such lists differs, such function can immediately report
#    failure without needing to check list contents.
#  * Else, we'll need to check list contents. To do so reliably necessarily
#    probably requires iteration of some sort. Wait! No, it doesn't. All we need
#    to do is obtain the asymmetric list difference between the two lists. Since
#    there exist two directions for such difference, we'll need to perform such
#    difference twice, resulting in two temporary lists: one from the difference
#    of such lists in one direction and the other from such difference in the
#    other direction. Hmm. Alternately, we could also take the *SYMMETRIC* list
#    intersection between the two lists. If the resulting list is the same size
#    as either input list, then such lists must necessarily be equal. Right? I
#    think so, but contemplate this a bit further. (And actually try it out, of
#    course.)
#
#  For map globals, I hope a similar approach as just delineated would suffice
#  for comparison. In any case, we *CAN* reliably, efficiently compare globals
#  regardless of type.
#* For each global that has been changed by the user, we want to produce one or
#  more lines of zsh code changing the default value for such to the user's
#  custom value for such global. For example, given a list global defaulting to:
#
#    ZESHY_LIST=( a b c d e f )
#
#  ...and a user's custom value for such global of:
#
#    ZESHY_LIST=( a b c d e g )
#
#  ...the required line of code is as follows:
#
#    ZESHY_LIST[6]='g'
#
#  So, how do we find the minimal lines of code effecting such changes? Simple:
#
#  * For scalars, simply forcefully reassign the entire scalar variable to the
#    new value. (We could split this apart into regular expression-based search
#    and replace expressions or some such, but... Well, that's crazy talk. Most
#    scalar configuration globals should be sufficiently short that simply
#    reassigning their values will suffice.)
#  * For lists, we'll need to determine *EXACTLY* which list items changed and
#    then produce a line of code as above reassigning such item. There's
#    probably no efficient means of implementing this aside from the obvious:
#    just iterate over all items and compare each with scalar comparisons. Given
#    that we're ultimately saving the user time by doing so, we reckon they can
#    afford to wait a bit for such process. Of course, this is complicated by
#    the fact that there exist three sorts of meaningful list operations:
#    * List additions (of new items).
#    * List deletions (of existing items).
#    * List item assignments (of existing items).
#    That said, while it *WOULD* be nice to detect additions and deletions and
#    we could theoretically do so, how exactly would one detect the situation of
#    *BOTH* a list addition and deletion? Indeed, the more changes the user
#    makes to a given list, the more it becomes clear that simply tracking all
#    list item assignments that need to made to convert from the source to
#    target lists not only suffices in the general case but is (arguably) the
#    optimal solution.
#  * For maps, identical reasoning holds.
#
#======================
#Actually, we ascertain below that we *REALLY* want to produce customizer
#functions tracking only scalar assignments and list and map item assignments:
#e.g.,
#
#      function "::customize_config_file_global:command/my_command:ZESHY_MAP"() {
#          # Need to pass an expected old value here, for safety checking.
#          :set_config_file_global_map_key_value_old_and_new\
#              "command/my_command" ZESHY_MAP 'my key' 'expected old value' 'desired new value'
#
#          # No need to pass an expected old value here, clearly.
#          :append_config_file_global_map_key_value\
#              "command/my_command" ZESHY_MAP 'my new key' 'desired new value'
#
#          # No need to pass *ANY* values here, clearly.
#          :delete_config_file_global_map_key\
#              "command/my_command" ZESHY_MAP 'my old key'
#      }
#
#It takes us a bit of thought wrangling to arrive at the above conclusion. But,
#there's the summation of it. Pretty sweet, eh?
#======================
#
#Ultimately, we'll have produced a number of lines resembling:
#
#    ZESHY_STRING='my new value'
#    ZESHY_LIST[6]='g'
#    ZESHY_MAP['my key']='my new value'
#    ZESHY_MAP['simloo']='gamjee'
#
#Now, what if we group such lines according to the global they act upon into
#small functions outputting such lines (in this example, for configuration file
#"~/.zeshy/config/command/my_command"): e.g.,
#
#    function "::customize_config_file_global::ZESHY_STRING"() {
#        output_string 'ZESHY_STRING="my new value"'
#    }
#    function "::customize_config_file_global:command/my_command:ZESHY_LIST"() {
#        output_string 'ZESHY_LIST[6]="g"'
#    }
#    function "::customize_config_file_global:command/my_command:ZESHY_MAP"() {
#        output_string '
#           ZESHY_MAP["my key"]="my new value"
#           ZESHY_MAP["simloo"]="gamjee"'
#    }
#
#Great! We're nearly there. We simply cache all such functions to a new digest
#(yup!) -- say "~/.zeshy/digest/config.zwc". We now have a perfectly recoverable
#record of all configuration file changes -- including the exact file, global,
#and code to effect such changes.
#
#What's left? We need to actually apply such changes in a meaningful manner,
#transforming default source zeshy configuration files to custom target user
#configuration files -- while preserving *ALL* original formatting in such files.
#Is this even feasible? The answer, of course, is yes: but we'll have to
#manually parse such files to do it. Fortunately, such files *WILL* adhere to a
#strict syntax. Ours. As currently defined. That's it. So, how do we effect such
#changes? For each such global:
#
#* First, we need to find the line such file defines such global on. This
#  *WOULD* be simple, except that we currently define scalar and nonscalar
#  globals in a slightly different manner, complicating parsing. But it's still
#  not *TOO* bad. Anyway, it's annoying, but very feasible.
#* If such global is a:
#  * Scalar, the prior parsing should probably simply be a direct search-and-
#    replace operation, replacing the current definition of such scalar with the
#    string output by the corresponding ::customize_config_file_global*()
#    function, as above.
#  * List, we could either append such list's definition with the string output
#    by the corresponding ::customize_config_file_global*() (easier, but
#    complicates future edits to such global by the user) *OR* ideally
#    dynamically construct a search-and-replace operation finding the nth item
#    of such list and replacing such item with the desired new value. Since the
#    former approach also requires perfect list parsing and produces a much less
#    desirable outcome, we should definitely aim for the latter approach. Ah!
#    Actually, there are three different type of list changes to consider:
#    * Changes to existing list items, which the above approach handles.
#    * Deletions of existing list items, recorded like so:
#      output_string 'ZESHY_LIST[5]=()'
#      Not terribly hard to handle. Just perform a search-and-replace where the
#      replacement string is the empty string. Done.
#    * Additions of new list items. We'll want to distinguish this from the case
#      of changing list items... Hmm. Right. I hereby suggest a new approach.
#      Rather than merely outputting code, instead have such functions *CALL*
#      the desired functions effecting such changes: e.g.,
#
#      function "::customize_config_file_global:command/my_command:ZESHY_MAP"() {
#          :set_config_file_global_map_key_value\
#              "command/my_command" ZESHY_MAP 'simloo' 'gamjee'
#          :append_config_file_global_map_key_value\
#              "command/my_command" ZESHY_MAP 'my key' 'my new value'
#          :remove_config_file_global_map_key_value\
#              "command/my_command" ZESHY_MAP 'unwanted key'
#      }
#
#      O.K.; that's pretty sweet.
#  * Map, pursue an identical approach as for lists.
#
#The inevitable question arises: what if attempting to automatically apply a
#change fails? This *WILL* happen all the time, though hopefully not in the
#common case. Consider, for example, a user customizing the value of a map key
#we remove in a subsequent version of zeshy. What's the right thing to do?
#Simple. Inform the user with a vivid warning on updating zeshy, and allow them
#to manually reapply such change in some fashion if they so desire. But in
#*MOST* cases, the above approach should suffice. I can't think of *ANY* other
#CLI software in existence going to such lengths. Nearly all simply ignore the
#issue. But it's not really ignorable, here.
#
#Actually, it's not necessarily clear that *ANY* changes will fail if we adopt
#the simplest approach of simply tracking low-level list and map item
#assignments (easy) rather than higher-level list and map item additions and
#deletions (*SIGNIFICANTLY* more difficult). In the former case, applying a
#simple list or map item assignment should *ALWAYS* succeed, suggesting we won't
#be able to reliably detect when such an assignment should actually fail. Hmmm;
#I see. Right. To detect failure states, we'll need to revise such customizer
#functions to store not only the desired new value for list and map items but
#the expected old value. Such functions should then ensure that such list or map
#actually contains the expected old value before applying the new value: e.g.,
#
#      function "::customize_config_file_global:command/my_command:ZESHY_MAP"() {
#          :set_config_file_global_map_key_value_old_and_new\
#              "command/my_command" ZESHY_MAP 'my key' 'expected old value' 'desired new value'
#      }
#
#O.K.; the prior example *IS* great, but we *WILL* need to track additions and
#deletions, for the obvious reason that deleted keys require no values to be
#passed while added keys require only the new value to be passed. A single
#:set_config_file_global_map_key_value_old_and_new() function, while great, does
#*NOT* suffice to describe map key additions and deletions. (Obvious in
#hindsight, we suppose.) So, we *WILL* need to detect and handle such
#situations. No way around, I'm afraid.
#
#Again, just emit warnings when expectations are not met rather than throwing
#fatal exceptions. (Obviously, don't go through with the change; just skip to
#the next customizer.)
#
#Naturally, this is all an incredible amount of work. We estimate about a
#month's worth. That's a huge investment. But it *WOULD* be worth it. And it
#would work. We're fully confident of that now.
#
#That said, we really want to pluck the low-hanging fruit by implementing MD5-
#based config file updating, first. Way easier and fairly essential to making
#zeshy updates at least moderately sane.

#FIXME: "if_distro" is fairly shoddy. Operation systems authored by the terrible
#twosome (i.e., Microsoft and Apple) provide no choice and hence no
#distributions; as such, "if_distro" should be renamed "if_os" and restructured
#as follows:
#
#if_os/
#  linux/
#  linux.arch/
#  linux.fedora/
#  linux.gentoo/
#  linux.ubuntu/
#  osx/
#  windows/
#
#So, the idea is to construct a dot-delimited topology of operating systems.
#(Avoid using underscores instead of dots here, as underscores typically
#supplant spaces rather than serving as internal structure.) Should be quite
#efficient to construct a function producing the string conforming to such
#topology specific to the current system. The function consuming such string
#should then split such string on "." and, for each matching prefix (e.g.,
#"linux" and "linux.arch" under Arch Linux), append such directory to the
#overlay stack.
#FIXME: O.K.; after a few months of contemplation, it's clear that, while novel
#and fun, the above concept isn't terribly scalable. For example, since both
#Linux and BSD (but neither OS X or Windows) support the concept of a compilable
#kernel, we probably want a shared parent directory of both: "if_os/unix",
#implying directory names "if_os/unix.linux" and "if_os/unix.bsd". But wait! OS
#X is, of course, derived from FreeBSD, implying directory name
#"if_os/unix.os_x". There goes that scheme, then.
#
#There's a larger issue at play, however. Contemplate needing to rename parent
#directory "unix". This would require renaming *ALL* directories prefixed by
#"unix.", as well. Hence, the aforementioned unscalability. Here's what we do
#instead:
#
#if_os/
#  00-common/
#    bsd/
#    linux/
#  bsd_free/
#    bsd/ --> ../00-common/bsd
#  bsd_net/
#    bsd/ --> ../00-common/bsd
#  linux_arch/
#    linux/ --> ../00-common/linux
#  linux_fedora/
#    linux/ --> ../00-common/linux
#  linux_gentoo/
#    linux/ --> ../00-common/linux
#  linux_ubuntu/
#    linux/ --> ../00-common/linux
#  os_x/
#  windows/
#
#Simple solution! In this case, since *NO* OS will ever be named "00-common" (by
#zeshy dictate, if nothing else), we appropriate such name for use in storing
#common OS components shared across multiple OSes. It's important we store such
#components here under "if_os", as their use and application is confined solely
#to such directory.
#
#This scheme has the benefit of *NOT* requiring additional functionality in
#"compile" aside from the following: a map global defined by such parcel named
#${ZESHY_OS_NAME_UNAME_TO_DIRNAME}, defined as follows:
#
#   ZESHY_OS_NAME_SYSTEM_TO_DIRNAME=(
#       'gnu/linux~gentoo' 'linux_gentoo'
#       ...
#   )
#
#And so on. In the case of Linux distros, the above system-derived OS name is
#dynamically queried as follows, assuming "lsb_release" to be a command in the
#current user's ${PATH}:
#
#   string os_name_system
#   os_name_system="${(L):-$(uname -o)~$(lsb_release -si)}"
#
#"~" was chosen as delimiter due to the unlikelihood of uname or lsb_release
#ever outputting a tilde. There's no sense at all in leaving things case-
#sensitive; so, coerce such output to lowercase.
#
#In Gentoo's case, "uname -o" outputs "GNU/Linux" and "lsb_release -si" outputs
#"Gentoo" -- which, when concatenated and lowercased, gives "gnu/linux~gentoo",
#matching the above key. Voila!
#
#There's really no simpler way, I'm afraid. (Or that I care to contemplate,
#anyway!) This is it, folks. It's not half bad, when it comes down to it...
#Really.
#FIXME: In the interests of iterative improvement, symbolic links are not a
#terribly robust road to begin walking down. Rather, adopt the following:
#
#if_os/
#  bsd/
#    if_distro/
#      netbsd/
#      freebsd/
#      openbsd/
#  linux/
#    if_distro/
#      arch/
#      gentoo/
#  darwin/
#  windows/
#
#It just makes sense, and you know it. So what if we nest subdirectories two
#levels deeper? This taxonomy is slightly more efficient and *MUCH* more
#rational. Also, no need for the silly map above. Just call the expected
#functions. Note that due to some distros existing under multiple OSes, it's
#insufficient to...
#FIXME: Wait. Precisely *BECAUSE* of that, flatten the above to simply:
#
#if_os/
#  bsd/
#  linux/
#  darwin/
#  windows/
#if_distro/
#  arch/
#  freebsd/
#  gentoo/
#  netbsd/
#  openbsd/
#
#Great! Best of all worlds. Since gentoo utilities should be the exact same under
#BSD (...I believe?), this simplifies a great deal. The inheritence is implicit,
#as it should be. No symlink or dirname nonsense, as before. Excellent!
#FIXME: Hmmm. At first blush, the prior idea is somewhat idealogically difficult
#to swallow: namely, our use of "if_distro" in the absence of a corresponding
#OS. In particular, can we *REALLY* treat distros as cross-platform-portable?
#Maybe. But maybe not. Hmm. O.K.; we get it. The idea *IS* fundamentally sound,
#for the simple reason that we can simply place all cross-platform-portable
#distro code under "40-if_distro" and then place non-cross-platform-portable
#distro code under the specific OS it applies to: e.g.,
#
#30-if_os/
#  bsd/
#    if_distro/
#      netbsd/
#      freebsd/
#      openbsd/
#  linux/
#    if_distro/
#      arch/
#      gentoo/
#  darwin/
#  windows/
#40-if_distro/
#  arch/
#  freebsd/
#  gentoo/
#  netbsd/
#  openbsd/
#
#Superb!
#FIXME: On a somewhat ancillary note, it's essential we avoid symlinks of any
#sort in zeshy. We know, we know. It'd be great to leverage them. *AVOID THAT
#COMPULSION*, however. Why? Simple: Windows. (Yeah; we know.) NTFS does actually
#support both file and directory symlinks (the latter referred to as
#"junctions", for some inane reason -- perhaps they're obsequious Final Fantasy
#fans?), but requires *ADMINISTRATOR* access to create them. What? This is sheer
#nonsense. Unfortunately, because of this core requirement, basically no one
#uses them. Certainly, git does *NOT* support symlink creation on repository
#clone, directly implying zeshy cannot leverage symlinks if it wants to run
#reliably on Windows. Which, belatedly, it does.
#FIXME: Ugh. We were belatedly under the misimpression that different flavors of
#BSD were also referred to as "BSD distributions." This is patently *NOT* the
#case; each BSD derivative is considered a distinct operating system. (A bit
#silly, honestly.) However, given the utility (and, indeed, necessity) of the
#above directory tree structure, we'd still like to consider the Gentoo/FreeBSD
#operating system as a Gentoo distribution running the FreeBSD kernel and
#supporting the *BSD toolchain. Whether or not this actually corresponds to
#official nomenclature in the BSD community is moot, for our purposes. Or...
#perhaps not? For cross-platform portable distributions (e.g., Debian, Gentoo),
#we should probably simply define corresponding testers :is_os_debian(),
#:is_os_gentoo(), and so on. Given that, we really *DON'T* want a top-level
#parcel @{40-if_distro}, as distros genuinely are Linux-specific. This leaves us
#with a tree resembling:
#
#30-if_os/
#  bsd/
#  darwin/
#  debian/
#  freebsd/
#  gentoo/
#  linux/
#    if_distro/
#      arch/
#      fedora/
#  netbsd/
#  openbsd/
#  windows/
#
#Simple. @{compile} then iteratively tests whether or not the current OS applies
#to each subdirectory "${os_name}/" of an "*-if_os/" overlay directory by
#calling the corresponding tester :is_os_${os_name}(): e.g., first :is_os_bsd(),
#then :is_os_darwin(), and so on. Of course, this could be optimized by:
#
#* Defining a new "(...|...)"-style string global ${ZESHY_OS_GLOB} delimiting
#  all applicable OS-specific "keywords" for the current OS by "|". For example:
#  * If the current OS is Gentoo Linux, set ZESHY_OS_ID="(linux|gnu|gentoo)".
#  * If the current OS is Gentoo FreeBSD, set ZESHY_OS_ID="(bsd|freebsd|gentoo)".
#* Use zsh pathname globbing to filter the basenames of all such subdirectories
#  in the above overlay with such glob. Extremely efficient, requiring no
#  iteration (unlike the initial, simplistic solution above).

#FIXME: The current digest file depends on both zeshy-specific state (e.g.,
#whether or not we're compiling a debug build) and system-specific state (e.g.,
#the current OS and windowing manager in use). The current configuration tree
#*NEEDS* to similarly depend on the system- but *NOT* zeshy-specific state. One
#configuration tree should suffice for all possible zeshy states; however, the
#same cannot be said of system states. Users should be able to seemlessly move
#their entire "~/.zeshy" directory between not only different machines running
#the same OS but between different machines running different OSes. To effect
#the latter, we'll need to specifically create an intermediary subdirectory
#directly under "~/.zeshy/config" named after all relevant system state: e.g.,
#
#    ~/.zeshy/
#        config/
#            current -> linux.gentoo.x11/
#            linux.gentoo.mir/
#                00-core/
#                command/
#            linux.gentoo.wayland/
#                00-core/
#                command/
#            linux.gentoo.x11/
#                00-core/
#                command/
#            darwin/
#                00-core/
#                command/
#            windows/
#                00-core/
#                command/
#
#Note the symbolic link "current", linking to configuration tree
#"linux.gentoo.x11/" in the above example. Such directory is both for user
#convenience and zeshy use. Indeed, setting such symlink in a reliable manner
#simplifies our selection of the configuration tree corresponding to the current
#OS and windowing manager. (That is, assuming we set such symlink reliably, *NO*
#existing code in this parcel needs to change to accommodate this improvement.)
#
#Parcel @{digest} should probably maintain such symlink, yes?

#FIXME: Preserve "src/if_pathable" and make a new "src/if_pathables" directory
#(...or perhaps just add support for such syntax to "src/if_pathable"?)
#containing pseudo-code resembling:
#
#* src/if_pathables/"sox or lame or mpg123"
#* src/if_pathables/"vlc and (sox or lame or mpg123)"
#
#For implementation purposes, there exist three possible cases for each subpath
#of such directory:
#
#* Such subpath matches glob "*(' or '*' and '|' and '*' or ')*", implying that
#  such subpath contains a mix of disjunction and conjunction operators. In such
#  case, it isn't really feasible for zeshy to manually parse such subpath and
#  perform the resulting implied test. (There are too many possible combinations
#  for a simple regex to suffice, implying the need for a non-regular CFL parser,
#  clearly outside the scope of even zeshy digest compilation.) Instead, perform
#  the following:
#  * If such subpath matches glob "*[^[:alnum:]-_ ()]*", such subpath contains a
#    shell-reserved character and hence must be rejected. *THROW AN EXCEPTION*.
#    This is critical. Since we "eval" such subpath below, unsafely evaluating
#    any arbitrary filename could have dramatic consequences. (Imagine a third-
#    party zeshy plugin installing "src/if_pathables/$(command rm -R ~/)").
#    * This *MAY* not actually be necessary. Examining the heuristics below, it
#      looks like we never evaluate such strings in a command context: we simply
#      expand ${MATCH} to the corresponding string without evaluating,
#      executing, or otherwise running such string. Right. No safety concerns
#      here, I believe. Don't bother testing or throwing exceptions. Sweet, no?
#  * Perform the following glob replacements on such subpath in order:
#    * "//[[:space:]]##or[[:space:]]##/ || ", replacing " or " with " || ".
#    * "//[[:space:]]##and[[:space:]]##/ && ", replacing " and " with " && ".
#    * "//(#m)[[:alnum:]-_]##/[[ ${MATCH:c} == '/'* ]]", replacing command names
#      with an efficient shell test for whether such command exists.
#  * The resulting expression should be a valid zsh test for whether such
#    commands exist. Evaluate such expression, squelching standard output and
#    error. If the result is true, source such file; otherwise, do not.
#* Else, such subpath contains only all " or " or all " and " operators. In
#  either case, perform a single, compact, safe, and efficient test, ideally in
#  a single zsh statement using lists, implementing the corresponding boolean
#  expression. Zing!
#FIXME: Actually, just *ALWAYS* do the first, more generalized approach above.
#Merely testing for whether to perform the optimized test reduces such
#optimization's efficiency. Given the short length of such strings, I can't see
#the harm is always electing to go the foolproof route, which still appears to
#be reasonably efficient. Yes!
#FIXME: Actually, just reduce the test of whether to adopt the generalized
#approach to matching *' '* (i.e., if such string contains whitespace, assume
#the use of conditional "or" and "and" operators). Such approach is expensive
#enough that we only want to do it if we have to.
#FIXME: :define_func_if_pathable() now implements this *EXACT* logic in low-
#level zsh code, suggesting we should abstract out that section of such
#function's implementation to a function defined... where, exactly? While we
#could certainly defining such function in this parcel, doing so would prevent
#its compilation into the current digest file. *sigh*

#FIXME: Compilation is currently a bit... fragile. If *ANYTHING* goes wrong
#during Zeshy codebase sourcing (particularly precompilation, which now performs
#quite a bit of functionality), the digest file is never created or created
#corrupted, which is arguably worse. We should
#probably be catching exceptions and somehow also printing stack traces (...ugh;
#I'm unsure that's possible, actually) when sourcing source and configuration
#files and when calling ::precompile_zeshy(). Convert exception messages into
#warning messages and try to silently continue. Ah; right. Stack traces *SHOULD*
#be printed by :die(), so we're good to go, yes? That's not necessarily how it
#works under conventional high-level languages, but... fuck it. That's how it
#works here.
#FIXME: It'd be awesomely inspiring to print an in-place rotating ANSI-fueled
#progress sequence (i.e., "\-/|\-/|") during script sourcing. Namely, after
#sourcing every ten or so scripts, rotate such sequence a single character.
#Naturally, confine such logic to VT100-capable terminals. It's essential to do
#so without importing any heavyweight zsh modules or scripts; should be quite
#doable, no? I wouldn't be terribly surprised if the exact sequences to be
#printed are already readily Googleable.
#FIXME: Indeed, digest compilation is decomposable into two segments:
#
#1. Overlay discovery, relatively fast. (Estimated 5% of time spent.)
#2. Script sourcing, relatively slow. (Estimated 95% of time spent.)
#
#Given this, an empty progress bar should be displayed immediately prior to
#overlay discovery, incremented to approximately 5% of the width of the screen
#during such discovery, and then incremented to the remaining screen width
#during such sourcing. Since we know *EXACTLY* how many scripts to be sourced
#before doing so, the latter is readily accomplished; the former, however, must
#be merely guestimated at. For example, we might estimate a maximum of 32
#discovered overlays, and then increment the progress bar accordingly.

# ....................{ DEPENDENCIES                       }....................
# Load all zsh modules required by this parcel or parcels this parcel sources.
# Since this only applies to digest file compilation, we still retain autoload
# declarations for all such modules in ={zsh/module}.

# Bind "libpcre" functions to zsh builtins, thus exposing Perl-compatible
# Regular Expression (PCRE) functionality during digest file compilation. In
# particular, alias and function declarations require such functionality for
# matching the admittedly obtuse prototype syntax prefixing help strings.
zmodload zsh/pcre

# ....................{ GLOBALS                            }....................
# Lists of all zeshy-specific aliases, functions, and globals. Defining such
# lists globally:
#
# * Implicitly exports such lists to child shells, which on receiving such
#   globals may use their contents to undefine aliases, functions, and other
#   globals imported from the parent shell.
# * Permits us to undefine such globals in a global context below. See the
#   tail of this file.
#
# zsh treats suffix aliases differently from normal and global aliases, so
# differentiate the former from the latter.
typeset -gaU\
    ZESHY__ALIAS_NAMES\
    ZESHY__ALIAS_SUFFIX_NAMES\
    ZESHY__FUNCTION_NAMES\
    ZESHY__GLOBAL_NAMES\
    ZESHY__HOOKS_RUN_ON_ZESHY_PRECOMPILE

typeset -g\
    ZESHY__SCRIPT_FILENAME_GLOB_EXCLUDE\
    ZESHY__SCRIPT_FILENAME_GLOB

#FIXME: After renaming *ALL* zeshy scripts to have filetype ".zy", excluding
#non-zeshy scripts will become both considerably simpler and more reliable.
#Indeed, one pleasant side effect of doing so is that we may then litter the
#codebase with plaintext "README" files intended for developer eyes only.
#FIXME: Document me.

# Avoid sourcing the following types of files as zeshy scripts:
#
# * "vim"-specific cache files.
ZESHY__SCRIPT_FILENAME_GLOB_EXCLUDE='~*.swp'
ZESHY__SCRIPT_FILENAME_GLOB='*'${ZESHY__SCRIPT_FILENAME_GLOB_EXCLUDE}'(-.)'

# ....................{ RUNNERS                            }....................
#FIXME: Excise such nonsensicality.

# void :run_hook_on_zeshy_precompile(string code)
function :run_hook_on_zeshy_precompile() {
    (( # == 1 )) || :die 'Expected one code string.'
    ZESHY__HOOKS_RUN_ON_ZESHY_PRECOMPILE+="${1}"
#   print "registering precompilation hook \"${1}\""
}

# ....................{ COMPILERS                          }....................
# void :compile_zeshy(void)
function :compile_zeshy() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # List of all currently declared aliases, functions, and globals declared
    # *BEFORE* sourcing and compiling zeshy. See ::compile_zeshy_setup().
    local -a\
        ZESHY__ALIAS_NAMES_OLD\
        ZESHY__ALIAS_SUFFIX_NAMES_OLD\
        ZESHY__FUNCTION_NAMES_OLD\
        ZESHY__GLOBAL_NAMES_OLD

    # List of all currently declared aliases, functions, and globals declared
    # *AFTER* sourcing and compiling zeshy. See ::precompile_zeshy_names().
    local -a\
        ZESHY__ALIAS_NAMES_NEW\
        ZESHY__ALIAS_SUFFIX_NAMES_NEW\
        ZESHY__FUNCTION_NAMES_NEW\
        ZESHY__GLOBAL_NAMES_NEW

    # Prepare to source the zeshy codebase.
    ::compile_zeshy_setup

    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Do *NOT* expand zeshy aliases sourced by this function in any
    # subsequently called functions defined by this component. Since zsh
    # expands aliases at function definition rather than call time, such
    # aliases will *NOT* be expanded and hence induce "command not found"
    # errors at call time. The devil is in the obscura.
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Source all zeshy scripts applicable to the current system and user.
    ::compile_zeshy_source

    # Finalize all zeshy-specific aliases, functions, and globals to be compiled
    # into zeshy's user digest file.
    ::precompile_zeshy

    # Compile all zeshy-specific functions (and hence aliases and globals) into
    # zeshy's user digest file *AFTER* the above finalization.
    ::compile_zeshy_digest
}

# void ::compile_zeshy_setup(void)
function ::compile_zeshy_setup() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    #FIXME: Technically, both alias and function names may contain newlines. If
    #even a single such alias or function exists, the line-splitting performed
    #below could fail spectacularly. It's unclear how to guard against this.
    #Perhaps calling "alias -m *$'\n'*" or some such and testing whether at
    #least one such alias or function exists before calling "alias +"?
    #FIXME: Forehead smacking time. Given canonical list global ${functions},
    #we can efficiently obtain the set of all newly defined functions by
    #capturing such list before sourcing the current script into a temporary
    #list, then differencing the current contents of ${functions} with such
    #temporary list after such sourcing. Super efficient! Indeed, such approach
    #can and should be used elsewhere in ={compile} to perform efficient names
    #differencing, and can and should be extended to both aliases and globals.

    # Record the names of all currently defined aliases, functions, and globals
    # *NOT* to be compiled into zeshy's user digest file. See
    # :set_list_to_aliases(), :set_list_to_functions(), and
    # :set_list_to_globals() for further details.
    ZESHY__ALIAS_NAMES_OLD=(        "${(@f)"$(alias +)"}" )
    ZESHY__ALIAS_SUFFIX_NAMES_OLD=( "${(@f)"$(alias +s)"}" )
    ZESHY__FUNCTION_NAMES_OLD=(     "${(@f)"$(typeset +f)"}" )
    ZESHY__GLOBAL_NAMES_OLD=(   ${${"${(@f)"$(typeset +g +)"}":#* local *}##* } )

    # Filter all non-zeshy-specific globals from such list. See
    # ::precompile_zeshy_names() for further details.
    ZESHY__GLOBAL_NAMES_OLD=( "${(M)ZESHY__GLOBAL_NAMES_OLD[@]:#ZESHY_*}" )
#   print -l "===ZESHY__GLOBAL_NAMES_OLD===" "${ZESHY__GLOBAL_NAMES_OLD[@]}"
#   { print 'old globals:'; typeset -g + } | less
}

# void ::precompile_zeshy_names(void)
function ::precompile_zeshy_names() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # Record the names of all currently defined aliases, functions, and globals.
    # See ::compile_zeshy_setup() for further details.
    ZESHY__ALIAS_NAMES_NEW=(        "${(@f)"$(alias +)"}" )
    ZESHY__ALIAS_SUFFIX_NAMES_NEW=( "${(@f)"$(alias +s)"}" )
    ZESHY__FUNCTION_NAMES_NEW=(     "${(@f)"$(typeset +f)"}" )
    ZESHY__GLOBAL_NAMES_NEW=(   ${${"${(@f)"$(typeset +g +)"}":#* local *}##* } )

    # Filter all non-zeshy-specific globals from such list (i.e., globals *NOT*
    # prefixed by "ZESHY_"). While such negative filtering is somewhat
    # overzealous, positively filtering the set of all non-zeshy-specific
    # globals remains both tedious and fragile. We would need to match the set of all:
    #
    # * Locals defined by functions calling this function, which are effectively
    #   indistinguishable from globals.
    # * Core zsh globals (e.g., ${MATCH}, ${match}).
    # * Module-specific zsh globals (e.g., ${errnos}, ${sysparams}).
    #
    # Note that such filtering dramatically reduces the size of such set but
    # does *NOT* eliminate the need to difference such set against the set of
    # all globals defined prior to sourcing the zeshy codebase. Why?  The
    # current environment could conceivably define globals prefixed by "ZESHY_"
    # *NOT* defined by the zeshy codebase, in which case such globals must be
    # ignored rather than compiled into the current digest file.
    #
    # See remove_list_items_not_matching_glob() for further details. (Since
    # there exists no guarantee such function was successfully declared by this
    # time, avoid calling such function.)
    ZESHY__GLOBAL_NAMES_NEW=( "${(M)ZESHY__GLOBAL_NAMES_NEW[@]:#ZESHY_*}" )

    # The lists of zeshy-specific aliases, functions, and globals are the
    # asymmetric differences of the old from new lists of zsh aliases,
    # functions, and globals. See set_list_to_list_difference() for further
    # details. (Again, avoid calling such function.)
    ZESHY__ALIAS_NAMES=(
        "${ZESHY__ALIAS_NAMES_NEW[@]:|ZESHY__ALIAS_NAMES_OLD}" )
    ZESHY__ALIAS_SUFFIX_NAMES=(
        "${ZESHY__ALIAS_SUFFIX_NAMES_NEW[@]:|ZESHY__ALIAS_SUFFIX_NAMES_OLD}" )
    ZESHY__FUNCTION_NAMES=(
        "${ZESHY__FUNCTION_NAMES_NEW[@]:|ZESHY__FUNCTION_NAMES_OLD}" )
    ZESHY__GLOBAL_NAMES=(
        "${ZESHY__GLOBAL_NAMES_NEW[@]:|ZESHY__GLOBAL_NAMES_OLD}" )
#   print -lr "===ZESHY__GLOBAL_NAMES_OLD===" "${ZESHY__GLOBAL_NAMES_OLD[@]}"
#   print -lr "===ZESHY__GLOBAL_NAMES_NEW===" "${ZESHY__GLOBAL_NAMES_NEW[@]}"
  # print -lr "===ZESHY__GLOBAL_NAMES==="     "${ZESHY__GLOBAL_NAMES[@]}"
#   print -lr "===ZESHY__FUNCTION_NAMES===" "${ZESHY__FUNCTION_NAMES[@]}"
#   print -lr "===ZESHY_STARTUP_RUNNABLES===" "${ZESHY_STARTUP_RUNNABLES[@]}"
#   print -rl -- "globals to be compiled:" "${ZESHY__GLOBAL_NAMES[@]}" | less
#   print "aliases: ${aliases}\nsuffix_aliases: ${suffix_aliases}"

    # If no zeshy-specific aliases, functions, or globals were defined, throw
    # an exception. Logic below and elsewhere implicitly assumes at least one
    # such alias, function, and global to exist. Indeed, if this is *NOT* the
    # case, something has gone *HORRIBLY* awry.
    #
    # Since the definition of zeshy-specific suffix aliases depends on the
    # existence of optional external files (e.g., "/etc/mailcap"), the non-
    # existence of such aliases does *NOT* constitute a fatal error. Moreover,
    # since no core zeshy functionality depends on such aliases, their non-
    # existence does *NOT* constitute grounds for even non-fatal warnings.
    #
    # Since die_unless_list_nonempty() may not have even been defined, test such
    # lists manually rather than calling such function.
    (( ${#ZESHY__ALIAS_NAMES} )) || :die\
        'No zeshy aliases defined (i.e., ${ZESHY__ALIAS_NAMES} empty).'
    (( ${#ZESHY__FUNCTION_NAMES} )) || :die\
        'No zeshy functions defined (i.e., ${ZESHY__FUNCTION_NAMES} empty).'
    (( ${#ZESHY__GLOBAL_NAMES} )) || :die\
        'No zeshy globals defined (i.e., ${ZESHY__GLOBAL_NAMES} empty).'
}

function ::compile_zeshy_source() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # Since function-based recursion is prohibitively expensive, implement such
    # iteration-based recursion as a depth-first search (DFS) of overlays
    # starting from the following standard roots (in order):
    #
    # * The system-wide zeshy root.
    # * The user-specific zeshy root, if found.
    ::compile_zeshy_overlay_root "${ZESHY_OVERLAY_DIR}"
    if [[ -d ${ZESHY_USER_OVERLAY_DIR} ]] {
        ::compile_zeshy_overlay_root "${ZESHY_USER_OVERLAY_DIR}"
    }
}

# void ::compile_zeshy_digest(void)
function ::compile_zeshy_digest() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'
    :output_line_if_debugging "Compiling \"${ZESHY_USER_DIGEST_FILENAME}\"."

    # Make the directory containing such digest file, if needed. See
    # :set_string_to_path_dirname() for further details.
    command mkdir -p -- "${ZESHY_USER_DIGEST_FILENAME:h}"

    # Compile zeshy's current user digest file.
    zcompile -c -- "${ZESHY_USER_DIGEST_FILENAME}" "${ZESHY__FUNCTION_NAMES[@]}"
}

# ....................{ COMPILERS ~ overlay                }....................
#FIXME: While zeshy implements no overlays as symbolic links (due both to the
#cross-platform incompatibility of such links *AND* to the fact that such links
#would generalize the codebase from what would otherwise be an directed acyclic
#graph (DAG) and hence tree into a directed, possibly cyclic graph and hence
#non-tree, which would require more robust and hence inefficient data structures
#to avoid infinite loops), individual users certainly could. The algorithm below
#should explicitly guard against such cyclicity -- ideally, by supporting rather
#than merely ignoring such symbolic links, which will unfortunately require
#additional bookkeeping as suggested above. That said, this shouldn't introduce
#*TOO* much inefficiency, due to the small number of suboverlays.
#
#Namely, we'll need to introduce a new map local
#${ZESHY_OVERLAY_DIRNAME_VISITED_TO_NIL} or some such, permitting efficient
#lookup of prospective new overlays to determine whether or not they've already
#been visited. Immediately before visiting a suboverlay (i.e., calling the
#corresponding ::compile_zeshy_suboverlay_*() function), perform the following:
#
#* If the absolute path of such suboverlay is already a key of such map, ignore
#  such suboverlay.
#* Else:
#  * Add such suboverlay as a key with value the empty string to such map.
#  * Call the corresponding ::compile_zeshy_suboverlay_*() function.

# void ::compile_zeshy_overlay_root(string overlay_dirname)
function ::compile_zeshy_overlay_root() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    local overlay_dirname suboverlay_compiler
    local -aU ZESHY__OVERLAY_DIRNAMES

    # FIFO stack of the absolute paths of all overlays applicable to the current
    # system, incrementally discovered by depth-first first search (DFS) of root
    # overlays. In zsh, adding and removing the last item of a list is
    # considerably more efficient than the same operation on any other list
    # items. Consequently, FIFO stacks are efficiently implemented in zsh by
    # pushing and popping onto and off the end of lists.
    #
    # This stack contains both overlays and suboverlays (i.e., immediate
    # subdirectories of overlays), each requiring distinct handling. Hence, we
    # distinguish the two by prefixing each of the former with the null
    # character. Since POSIX pathnames are guaranteed to *NOT* contain null
    # characters, using such characters to do so is inherently safe.
    #
    # Initialize such stack to the passed dirname, thus rooting such search to
    # such overlay.
    ZESHY__OVERLAY_DIRNAMES=( "${1}" )

    # Perform a depth-first search of all applicable overlays in such overlay.
    # While such stack is nonempty, pop the top overlay off such stack and
    # push all immediate subdirectories of such overlay satisfying any
    # conditional requirements of such overlay onto the top of such stack (e.g.,
    # only pushing subdirectories whose basenames match those of existing
    # pathables for "if_pathable" suboverlays).
    while (( ${#ZESHY__OVERLAY_DIRNAMES} )) {
        # Pop the top overlay off such stack. See pop_list() for further
        # details.
        overlay_dirname="${ZESHY__OVERLAY_DIRNAMES[-1]}"
        ZESHY__OVERLAY_DIRNAMES[-1]=()

        # If such overlay is prefixed by the null character, such overlay is a
        # suboverlay. Unlike overlays, suboverlays are typed according to their
        # directory names (e.g., suboverlays matching "*-if_pathable" are
        # pathable suboverlays). Parse such suboverlay's type from its name and
        # call the corresponding compiler function.
        if [[ ${overlay_dirname[1]} == $'\0' ]] {
            # Strip such prefix from such dirname.
            overlay_dirname="${overlay_dirname[2,-1]}"

            # If such suboverlay is a file, source such file. While files are
            # *NOT* suboverlays, ::compile_zeshy_overlay_container() blurs the
            # line between the two by pushing files onto the overlay stack.
            # Doing so permits files directly residing in overlays to order
            # themselves before or after suboverlays in the same overlay (e.g.,
            # an overlay with file "late" and suboverlay "00-early" will source
            # the latter *BEFORE* the former, due to lexicographic order).
            if [[ -f ${overlay_dirname} ]] {
                ::compile_zeshy_overlay_scripts "${overlay_dirname}"
            # Else, such suboverlay is a subdirectory as expected.
            } else {
                # Name of the function compiling such overlay if such overlay
                # requires special handling. Dismantled, this is:
                #
                # * ":t", reducing such directory to its basename.
                # * "##*-", reducing such basename to the substring following
                #   the last "-" in such basename, if found.
                suboverlay_compiler='::compile_zeshy_suboverlay_'${${overlay_dirname:t}##*-}

                # If such function does *NOT* exist, default such function to
                # the standard function compiling overlays requiring no special
                # handling. (Such function is guaranteed to exist.)
                (( ${+functions[${suboverlay_compiler}]} )) ||
                    suboverlay_compiler='::compile_zeshy_suboverlay_simple'

                # Compile such suboverlay.
                :output_line_if_debugging 'Searching suboverlay "'${overlay_dirname}'".'
                "${suboverlay_compiler}" "${overlay_dirname}"
            }
        # Else, such overlay is an actual overlay. Unlike suboverlays, overlays
        # are untyped and hence share the same compiler. Compile such overlay.
        } else {
            ::compile_zeshy_overlay_container "${overlay_dirname}"
        }
    }
}

# void ::compile_zeshy_overlay_container(string overlay_dirname)
function ::compile_zeshy_overlay_container() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    local overlay_dirname="${1}"
    local -a overlay_subdirnames
    [[ -d ${overlay_dirname} ]] ||
        :die 'Overlay "'${overlay_dirname}'" not found or not a directory.'
    :output_line_if_debugging 'Searching ...overlay "'${overlay_dirname}'".'

    # Avoid sourcing the following types of paths as zeshy overlays or scripts:
    #
    # * zeshy-specific hidden files and subdirectories (i.e., with "."-
    #   prefixed basenames).
    # * "vim"-specific cache files (i.e., with filetype "swp").
    local ZESHY__SCRIPT_PATHNAME_GLOB_EXCLUDE='~(*/.*|*.swp)'

    # List of all subdirectories in such overlay in reverse lexical order.
    # Such subdirectories are pushed onto the overlay stack below. Since
    # ::compile_zeshy_overlay_root() treats the last item on such stack as the
    # next directory to be visited, reversing their ordering here ensures such
    # function visits such subdirectories in the expected order. (Think reverse
    # Polish notation).
    #
    # Ideally, we would match both simple files and subdirectories with a glob
    # qualifier disjunction (i.e., a syntactic construct matching only paths
    # that are either simple files or subdirectories). Unfortunately, zsh only
    # currently supports glob qualifier conjunctions (e.g., "(-./)", matching
    # paths that are both simple files and directories and hence nothing).
    # However, since the set of all simple files and directories is exactly the
    # negation of the set of all non-special files (i.e., paths that are
    # neither sockets, named pipes, or device files), we negate the latter with
    # "^" to match the former. Dismantled, this is:
    #
    # * "-", transitively resolving all symbolic links.
    # * "On", reversing the order of such paths.
    # * "^=p%", excluding all special files.
    #
    # If such overlay is *NOT* the root overlay, also list and hence push all
    # scripts directly residing in such overlay onto the overlay stack. See ::compile_zeshy_overlay_root().
    if [[ ${overlay_dirname} != ${ZESHY_OVERLAY_DIR} ]] {
        overlay_subdirnames=(
            "${overlay_dirname}"/*${~ZESHY__SCRIPT_PATHNAME_GLOB_EXCLUDE}(-On^=p%)
        )
    # Else, such overlay is the root overlay. Since all scripts directly
    # residing in such overlay have already been sourced (including the current
    # script), avoid erroneously resourcing such scripts by listing only
    # overlay subdirectories. Dismantled, this is:
    #
    # * "-/", matching only subdirectories after resolving symbolic links.
    } else {
        overlay_subdirnames=( "${overlay_dirname}"/*${~ZESHY__SCRIPT_PATHNAME_GLOB_EXCLUDE}(-/On) )
    }

    # Compile all subdirectories in such overlay, prefixed by the null
    # character. See ::compile_zeshy_overlay_root() for further details.
    ::compile_zeshy_overlay_dirs $'\0'"${^overlay_subdirnames[@]}"
    # print -r -- "pushing: ${overlay_subdirnames[*]}"
}

# void ::compile_zeshy_overlay_scripts(string filename1?, ...)
#
# For flexibility, this function accepts any number of filenames.
function ::compile_zeshy_overlay_scripts() {
    # Source such scripts. Unfortunately, if sourcing such script throws an
    # exception, zsh immediately returns from such script with failure status
    # 126 (which is good) but fails to trigger TRAPZERR() and hence throw an
    # exception here (which is bad), resulting in such exception being blithely
    # ignored. Correct this by detecting failure and responding in kind. (This
    # probably constitutes a core zsh bug.)
    local script_filename
    for   script_filename ("${@}") {
        # print "sourcing \"${ZESHY_SCRIPT_FILENAME}\"..."
        ::script_zsh.source_or_unwind_call_stack "${script_filename}"
#       print "sourced \"${ZESHY_SCRIPT_FILENAME}\"."
    }
}

# void ::compile_zeshy_overlay_dirs(string dirname1?, ...)
function ::compile_zeshy_overlay_dirs() {
    # For flexibility, this function accepts any number of dirnames.
    ZESHY__OVERLAY_DIRNAMES+=( "${@}" )
}

# ....................{ COMPILERS ~ suboverlay             }....................
# void ::compile_zeshy_suboverlay_simple(string suboverlay_dirname)
function ::compile_zeshy_suboverlay_simple() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one suboverlay dirname.'
    local dirname_suboverlay="${1}"
    [[ -d "${dirname_suboverlay}" ]] ||
        :die "Suboverlay \"${dirname_suboverlay}\" not found or not a directory."

    # Compile all zeshy scripts in such directory.
    ::compile_zeshy_overlay_scripts\
        "${dirname_suboverlay}"/**/${~ZESHY__SCRIPT_FILENAME_GLOB}
}

# void ::compile_zeshy_suboverlay_if_config(string suboverlay_dirname)
function ::compile_zeshy_suboverlay_if_config() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one suboverlay dirname.'
    local dirname_suboverlay="${1}" filename_trg
    [[ -d "${dirname_suboverlay}" ]] ||
        :die "Suboverlay \"${dirname_suboverlay}\" not found or not a directory."

    # For each configuration file recursively globbed in such suboverlay...
    local filename_src
    for   filename_src (
        "${dirname_suboverlay}/"**/${~ZESHY__SCRIPT_FILENAME_GLOB}) {
        # Absolute path of the target configuration file in the current user's
        # zeshy dot directory (and hence stripped of the source directory).
        filename_trg="${ZESHY_USER_CONFIG_DIRNAME}/${filename_src#${dirname_suboverlay}/}"

        #FIXME: *NOT* necessarily. This is a subtle but important point, and we
        #absolutely need to tighten this up. Suppose the following two files:
        #
        #* "src/if_pathable/rsync/if_config/pathable/rsync".
        #* "src/if_pathable/vim/if_config/pathable/rsync".
        #
        #What happens in this case? Clearly, there's a fairly serious issue
        #here: @{rsync} has erroneously declared a configuration file of the
        #same name as @{vim}. Which wins? It's fairly arbitrary. Unfortunately,
        #given the overly simplistic and trusting conditional below, @{vim}
        #would silently fail to copy its configuration file over. @{rsync} wins,
        #with no one the wiser.
        #
        #Catching such errors will require us to declare a local map in
        #top-level function :compile_zeshy() (for efficient lookup) from
        #pathnames relative to "~/.zeshy/config" to the empty string: e.g.,
        #
        #    map ZESHY_OVERLAY_IF_CONFIG_FILENAMES
        #        ZESHY_OVERLAY_IF_CONFIG_FILENAMES=( 'pathable/rsync' )
        #
        #Naturally, such map should be initially empty. *BEFORE* performing the
        #conditional below, check whether or not such file has already been
        #copied by this loop, in which case an exception should be thrown.
        #Otherwise, after copying such file, add such file to this map.
        #
        #Simple. We just need to do it.

        # If such file has *NOT* already been copied into the current configuration
        # directory, do so.
        [[ -f "${filename_trg}" ]] || {
            :output_line_if_debugging 'Adding configuration "'${filename_trg}'".'

            # Make such file's parent directory, if needed.
            command mkdir -p -- "${filename_trg:h}"

            # Copy such file. Do *NOT* source such file: most configuration files
            # require aliases subsequently declared under the main zeshy codebase.
            command cp -- "${filename_src}" "${filename_trg}"
        }

        # Compile such zeshy script.
        ::compile_zeshy_overlay_scripts "${filename_trg}"
    }
}

# void ::compile_zeshy_suboverlay_if_pathable(string suboverlay_dirname)
function ::compile_zeshy_suboverlay_if_pathable() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one suboverlay dirname.'
    local dirname_suboverlay="${1}"
    local -a pathnames_pathable
    [[ -d "${dirname_suboverlay}" ]] ||
        :die "Suboverlay \"${dirname_suboverlay}\" not found or not a directory."

    # List of the absolute paths of all files and subdirectories of such
    # suboverlay whose basenames are also pathable. Dismantled, this is:
    #
    # * "${dirname_suboverlay}/"*, expanding to each such file or subdirectory.
    # * "(e^'(( ... ))'^)", excluding files and subdirectories failing such test
    #   (i.e., for which such test expands to 0):
    #   * "${REPLY:t}", the basename of such file or subdirectory.
    #   * "${+commands[...]}", expanding to 1 if such basename is pathable or to
    #     0 otherwise.
    # * "|| true", ignoring erroneous failure reported by zsh. (Curiously, zsh
    #   occasionally report failure from such list assignment. It shouldn't.)
    pathnames_pathable=(
        "${dirname_suboverlay}/"*(e^'(( ${+commands[${REPLY:t}]} ))'^)
    ) || true

    # Compile all zeshy scripts in such suboverlay.
    ::compile_zeshy_overlay_scripts "${^pathnames_pathable[@]}"(-.)

    # Compile all subdirectories in such suboverlay.
    ::compile_zeshy_overlay_dirs "${^pathnames_pathable[@]}"(-/)
}

# ....................{ COMPILERS ~ suboverlay : tester    }....................
# void ::compile_zeshy_suboverlay_if_display_server(string suboverlay_dirname)
function ::compile_zeshy_suboverlay_if_display_server() {
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    ::compile_zeshy_suboverlay_with_tester_prefix\
        "${1}" ':is_display_server'
}

# void ::compile_zeshy_suboverlay_if_package_manager(string suboverlay_dirname)
function ::compile_zeshy_suboverlay_if_package_manager() {
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    ::compile_zeshy_suboverlay_with_tester_prefix\
        "${1}" ':is_package_manager'
}

function ::compile_zeshy_suboverlay_with_tester_prefix() {
    # Validate sanity.
    (( # == 2 )) || :die\
        'Expected one suboverlay dirname and one tester prefix.'
    local\
        suboverlay_dirname="${1}"\
        tester_prefix="${2}"\
        tester_any\
        tester_any_dirname
    [[ -d "${suboverlay_dirname}" ]] || :die\
        'Suboverlay "'${suboverlay_dirname}'" not found or not a directory.'

    # If such suboverlay contains a subdirectory "any":
    #
    # * Call the tester whose name is exactly the passed prefix (e.g., tester
    #   :is_display_server() for suboverlay subdirectory
    #   "if_display_server/any").
    # * If such tester succeeds, compile such subdirectory. Ideally, this occurs
    #   if the current system provides at least one of the subject being tested.
    tester_any_dirname="${suboverlay_dirname}/any"
    if [[ -d "${tester_any_dirname}" ]] {
        # If such tester does *NOT* exist, throw an exception. See
        # :die_unless_function() for further details.
        tester_any="${tester_prefix}"
        (( ${+functions[${tester_any}]} )) || :die\
            'Overlay "'${tester_any_dirname}'" uncompileable (i.e., function '${tester_any}'() not found).'

        # Compile such subdirectory if such tester succeeds.
        if { "${tester_any}" } {
            ::compile_zeshy_overlay_dirs "${tester_any_dirname}"
        }
    }

    # If such suboverlay contains a subdirectory "name", perform the following
    # for all immediate subdirectories of such subdirectory:
    #
    # * Call the tester whose name is the basename of such immediate
    #   subdirectory prefixed by such prefix and "_" (e.g., tester
    #   :is_display_server_x() for suboverlay subdirectory
    #   "if_display_server/name/x").
    # * If such tester succeeds, compile such subdirectory. Ideally, this occurs
    #   if the current system provides the subject being tested.
    ::compile_zeshy_suboverlay_subdir_with_tester_prefix\
        "${suboverlay_dirname}/name" "${tester_prefix}_"

    # If such suboverlay contains a subdirectory "trait", perform the following
    # for all immediate subdirectories of such subdirectory:
    #
    # * Call the tester whose name is the basename of such immediate
    #   subdirectory prefixed by such prefix and "_trait" (e.g., tester
    #   :is_display_server_trait_x() for suboverlay subdirectory
    #   "if_display_server/trait/x").
    # * If such tester succeeds, compile such subdirectory. Ideally, this occurs
    #   if the current system provides at least one of the subject being tested
    #   having such trait.
    ::compile_zeshy_suboverlay_subdir_with_tester_prefix\
        "${suboverlay_dirname}/trait" "${tester_prefix}_trait_"
}

function ::compile_zeshy_suboverlay_subdir_with_tester_prefix() {
    # Validate sanity.
    (( # == 2 )) || :die\
        'Expected one suboverlay subdirectory dirname and one tester prefix.'
    local\
        suboverlay_subdirname="${1}"\
        tester_prefix="${2}"\
        tester\
        tester_basename

    # If such subdirectory does *NOT* exist, return silently. Since suboverlays
    # are *NOT* required to provide all or even any such subdirectories (e.g.,
    # "name/", "trait/"), this does *NOT* constitute an error condition.
    [[ -d "${suboverlay_dirname}" ]] || return 0

    # For all immediate subdirectories of such subdirectory for which the
    # tester whose name is the basename of such immediate subdirectory prefixed
    # by such prefix and "_trait", compile such immediate subdirectory.
    local tester_dirname
    for   tester_dirname ("${suboverlay_subdirname}/"*(-/)) {
        # Basename of such subdirectory. See :set_string_to_path_basename()
        # for further details.
        tester_basename="${tester_dirname:t}"

        # If such tester does *NOT* exist, throw an exception. See
        # :die_unless_function() for further details.
        tester="${tester_prefix}${tester_basename}"
        (( ${+functions[${tester}]} )) || :die\
            'Overlay "'${tester_dirname}'" uncompileable (i.e., function '${tester}'() not found).'

        # Compile such subdirectory if such tester succeeds.
        if { "${tester}" } {
            ::compile_zeshy_overlay_dirs "${tester_dirname}"
        }
    }
}

# ....................{ MAIN                               }....................
# Recompile zeshy's user digest file.
:compile_zeshy

# --------------------( WASTELANDS                         )--------------------
        # source -- "${ZESHY_SCRIPT_FILENAME}"
    # Note that ${ZESHY_SCRIPT_FILENAME} masquerades as a global and is frequently
    # expanded as such elsewhere in the codebase. See such variable's
    # documentation for further details.
    # local ZESHY_SCRIPT_FILENAME
    # for   ZESHY_SCRIPT_FILENAME ("${@}") {

#     ZESHY__SCRIPT_PATHNAME_GLOB_EXCLUDE\
# #FUXME: Document me.
# # Avoid sourcing the following types of paths as zeshy overlays or scripts:
# #
# # * zeshy-specific ignorable subdirectories (e.g., "!!-seed/").
# # * "vim"-specific cache files.
# ZESHY__SCRIPT_PATHNAME_GLOB_EXCLUDE='~(!!-*|*.swp)'

 # Such builtin currently appears to fail to signal TRAPZERR
#and hence induce exceptions on script failures, possibly due to the exit status
#reported by such scripts being 126. (No idea. Mere suppositions here.) Until
#the underlying issue is resolved, this function provides a reasonably suitable
#short-term solution.
# user-specific zeshy overlays (e.g., "~/.zeshy/source/config.zeshy"). The
# filenames of such files are irrelevant.

# --------------------( DONE                               )--------------------
#
#O.K.; that's it! Oh, and the following is quite nice too, but probably more
#appropriate for wiki details rather than inclusion in *EVERY* config file:

# * Non-scalar configuration variable (e.g., ":list", ":map"),  redefine such variable in your local overlay.

        #FUXME: Actually, this remains an issue *EVERYWHERE* else we source
        #scripts at the top-level. The simplest and most generalized means of
        #correcting this is to define a new ::source_script() function, which we
        #should *ABSOLUTELY* do. If you consider it, however, that will
        #probably provoke overly verbose output on failures in the main
        #codebase, since in such case at least three (or four?) stack traces
        #would be printed: one for the initial exception, one from this
        #exception, and one from a similar exception to be subsequently thrown
        #by @{digest}. That's a bit overkill. In fact, even the second such
        #exception is (arguably) overkill. This is readily correctible by
        #setting some private global -- say, ZESHY_IS_... Wait. An exception
        #will *ONLY* be thrown if we force one to be thrown. So, all we have to
        #do is define such function as follows... Wait. O.K.; to effect this,
        #such function needs to be an alias defined in @{main} -- which, of course, is no great worry:
        #
        ## Such alias should *ONLY* be expanded by top-level parcels and hence
        ## is marked private.
        #alias ::source_script_or_fail() {
        #}
        #FUXME: Oh, bloody hell. Unsure what we were contemplating above. We
        #have to unwind the current call stack, so we *DO* want to implement
        #such runnable as a function: e.g.,
        #
        #function ::source_script_quiet() {
        #    source -- "${ZESHY_SCRIPT_FILENAME}" || :unwind_call_stack
        #}
        #
        #So, what does :unwind_call_stack() do? Simple:
        #
        #function :unwind_call_stack() {
        #    :string zeshy___
        #}
        #
        #Such function sets a private global instructing
        #die() to *NOT* call ::store_exception_status().
        #FUXME: Wait. The above is *STILL* a bit nonsensical. Here's the ideal,
        #utterly awesome implementation:
        #
        #function :unwind_call_stack() {
        #    readonly THROW=
        #    THROW= 2>/dev/null
        #}
        #
        #Great! Then, we simple refactor :die() to call :unwind_call_stack()
        #where appropriate rather than the above. Err... that would require
        #testing for the existence of such function, defeating the purpose.
        #O.K.; how about this:
        #
        #alias :unwind_call_stack='{
        #    readonly THROW=
        #    THROW= 2>/dev/null
        #}'
        #
        #function ::script_zsh.source_or_unwind_call_stack() {
        #    source -- "${ZESHY_SCRIPT_FILENAME}" || :unwind_call_stack
        #}
        #
        #Sweet! As an alias, :unwind_call_stack() is perfectly safe to expand
        #in :die(). So, do so. Yay!
        # source -- "${ZESHY_SCRIPT_FILENAME}" || :die\
        #     'Script "'${ZESHY_SCRIPT_FILENAME}'" not sourceable.'

        #FUXME: Bizarre. Just what is going on here? source() fails when an
        #unhandled exception is thrown by the sourced script in a low-level
        #zsh test; so, why does this source() calls always ignore such
        #unhandled exceptions?

        # {
        #     source -- "${ZESHY_SCRIPT_FILENAME}" || {
        #         print "status: ${status}"
        #         print "EXCEPTION: ${EXCEPTION}"
        #         print 'Mukhkghghhgk.'
        #     }
        #     # source -- "${ZESHY_SCRIPT_FILENAME}" || return 1
        #     # source -- "${ZESHY_SCRIPT_FILENAME}"
        # } always {
        #     # if (( ${+EXCEPTION} )) || (( TRY_BLOCK_ERROR != 0 )) {
        #     if (( ${+EXCEPTION} )) {
        #         print "EXCEPTION: ${EXCEPTION}"
        #         print "TRY_BLOCK_ERROR: ${TRY_BLOCK_ERROR}"
        #     }
        # }

        # Source such script. If such script no longer exists, such call fails
        # and hence implicitly throws an exception (as expected).

 # Do *NOT* quote any of the
    # outermost expansions below. (Trust us.)
    # * "-./", matching both files and subdirectories after transitively
    #   resolving all symbolic links.
    # If such overlay is not zeshy's root, compile all zeshy scripts. zeshy's
    # root overlay contains the already sourced current script (among others),
    # which should never be resourced.
    # if [[ "${overlay_dirname}" != "${ZESHY_OVERLAY_DIR}" ]] {
    #     ::compile_zeshy_overlay_scripts\
    #         "${overlay_dirname}"/${~ZESHY__SCRIPT_FILENAME_GLOB}
    # }

    # List of all subdirectories in such overlay in reverse lexical order.
    # Such subdirectories are pushed onto the overlay stack below. Since
    # ::compile_zeshy_overlay_root() treats the last item on such stack as the
    # next directory to be visited, reversing their ordering here ensures such
    # function visits such subdirectories in the expected order. (Think reverse
    # Polish notation). Dismantled, this is:
    #
    # * "-/", matching only subdirectories after resolving symbolic links.
    # * "On", reversing the order of such subdirectories.
    # overlay_subdirnames=( "${overlay_dirname}"/*(-/On) )

#
    # Undefine all global aliases *AFTER* listing such aliases above.
    #FUXME: Wait. We actually only need to undefine all *GLOBAL* aliases,
    #and we only need to do so immediately prior to zeshy startup (which is to
    #say, much later than here). Implementing both corrections should
    #substantially improve matters, yes?

    #FUXME: O.K.; we now have :set_list_to_aliases_global(). Call such function
    #to obtain the set of global alias names and unalias *ONLY* such aliases.

    # Reduce such list to only zeshy-specific global alias names by
    # intersecting the prior list and list of all zeshy-specific alias names.
    # :intersect_lists aliases_global ZESHY__ALIAS_NAMES

    # Undefine all zeshy-specific aliases *AFTER* listing such aliases above.
    # The reasons why are, unsurprisingly, subtle. The subsequent definition of
    # startup_zeshy_globals() may attempt to declare nonscalar globals
    # containing unquoted elements equal to zeshy-specific global alias names
    # (e.g., "is", "or"), in which case such call will fail with an unhelpful
    # parse error if such global aliases exist. Undefining *ALL* aliases also
    # undefines such problematic global aliases, as desired.
    #
    # Undefining such aliases induces fatal errors and hence thrown exceptions
    # in zeshy functions expanding such aliases in subshells (e.g.,
    # "$(get_caller)", "$(get_stdin)"). Since zsh expands aliases in function
    # bodies at function definition definition rather than call time, *ONLY*
    # zeshy functions expanding such aliases directly in their function bodies
    # remain unaffected.
    #
    # Unfortunately, the print_exception() exception handler transitively calls
    # functions expanding such aliases in subshells, implying such handler to
    # be broken until such aliases are restored.
    # unalias -- "${ZESHY__ALIAS_NAMES[@]}"

    # subshells (as demonstrated by the
    # call to
    # :redefine_func() below).  *ALL* zeshy
    # functions may still be called without error despite such undefinition.

    #FUXME: The current implementation below literally makes no sense. In
    #particular, if no zeshy function was defined, then certainly
    #die_unless_list_nonempty() could not have been defined to be called below.
    #What we're trying to say is: implement this manually. See @{25-main_after}
    #for related logic doing so.

    # Remove canonical zsh globals from the list of zeshy-specific globals. See
    # remove_list_items_matching_glob() for further details. (Since there exists
    # no guarantee such function was successfully declared at this point, avoid
    # calling such function.)
    # ZESHY__GLOBAL_NAMES_NEW=(
    #     "${ZESHY__GLOBAL_NAMES_NEW[@]:#${~ZESHY_ZSH_GLOBAL_NAMES_GLOB}}"
    # )

#FUXME: Oh. Wait. Shouldn't *ALL* such set differencing be performed *AFTER*
#running all precompilation hooks, not merely after sourcing the zeshy codebase?
#After all, such hooks might attempt to dynamically create new aliases,
#functions, or globals, in which case we need to pick up on that. Right. Simple
#fix, anyway. Rename ::precompile_zeshy_names() to something more sensible and
#call such function *AFTER* completing precompilation. (Oh! There's an even more
#critical reason to do this: maps from alias, function, and global names to help
#strings should absolutely *NOT* be serialized to disk. Doing so significantly
#slows down shell startup and is simply a bad idea in general.)

    # :output_line_if_debugging 'Sourcing discovered scripts.'
#     # For all subdirectories in such suboverlay matching an available package
#     # manager, push such subdirectories onto the overlay stack.
#     local dirname_package_manager
#     for   dirname_package_manager ("${dirname_suboverlay}/"*(-/)) {
#         # Machine-readable ID of such package manager. See get_path_basename()
#         # for further details.
#         package_manager_id="${dirname_package_manager:t}"
# 
#         # Name of the function testing the availability of such package manager.
#         package_manager_tester=":is_package_manager_${package_manager_id}"
# 
#         # If such function does *NOT* exist, throw an exception. See
#         # :is_function() for further details.
#         (( ${+functions[${package_manager_tester}]} )) || :die\
#             'Package manager '${package_manager_id}' unrecognized (i.e., function '${package_manager_tester}'() not found).'
# 
#         # If calling such function succeeds, push the current subdirectory onto
#         # the overlay stack.
#         if { "${package_manager_tester}" } {
#             ZESHY__OVERLAY_DIRNAMES+=( "${dirname_package_manager}" )
#         }
#     }
# }

        # directory,
        # continue to the next file without sourcing the current file. zeshy's
        # sourcing of component "config" previously sourced such file, already.
        # Register such file for subsequent sourcing. Assuming no outside
        # intervention, subsequent logic guarantees such file to exist.
        # ::compile_zeshy_overlay_scripts "${filename_trg}"

    # dirname_overlay_main suboverlay_compiler
    # local -a dirnames_suboverlay
    # List of the absolute paths of all subdirectories and hence suboverlays of
    # such overlay in lexicographic order.
    # dirnames_suboverlay=( "${dirname_overlay}"/*(-/) )

    # Compile such suboverlays.
    # local dirname_suboverlay
    # for   dirname_suboverlay ("${dirnames_suboverlay[@]}") {
    #     # Name of the function compiling such overlay if such overlay requires
    #     # special handling. Dismantled, this is:
    #     #
    #     # * ":t", reducing such directory to its basename.
    #     # * "##*-", reducing such basename to the substring following the last
    #     #   "-" in such basename, if found.
    #     suboverlay_compiler="::compile_zeshy_suboverlay_${${dirname_suboverlay:t}##*-}"

    #     # If such function does *NOT* exist, default such function to the
    #     # standard function compiling overlays requiring no special handling.
    #     # Such function is guaranteed to exist.
    #     (( ${+functions[${suboverlay_compiler}]} )) ||
    #         suboverlay_compiler='::compile_zeshy_suboverlay_simple'

    #     # Compile such suboverlay.
    #     :output_line_if_debugging "Searching suboverlay \"${dirname_suboverlay}\"."
    #     "${suboverlay_compiler}" "${dirname_suboverlay}"
    # }

    # If only one script was passed, avoid iteration for efficiency.
    # if (( # == 1 )) {
    #     ZESHY_SCRIPT_FILENAME="${1}"
    #     source -- "${ZESHY_SCRIPT_FILENAME}"
    # # Else, manually iterate such scripts.
    # } else {

    # (( # )) || :die 'Expected one or more script filenames.'

    # excluding files in subdirectory "00-start". If such subdirectory exists,
    # all files in such subdirectory should be sourced *NOW*.
    # See below for further 

    # # List set of the absolute paths of all zsh scripts in such overlays, to be
    # # compiled into the current digest file.
    # local -Ua ZESHY_OVERLAY_FILENAMES

#     # Source all zsh scripts in all overlays applicable to the current system
#     # and user, thus defining all applicable aliases, functions, and globals.
#     #
#     # Note that ${ZESHY_SCRIPT_FILENAME} masquerades as a global and is frequently
#     # expanded as such elsewhere in the codebase. See such variable's
#     # documentation for further details.
#     :output_line_if_debugging 'Sourcing discovered scripts.'
#     local ZESHY_SCRIPT_FILENAME
#     for   ZESHY_SCRIPT_FILENAME ("${ZESHY_OVERLAY_FILENAMES[@]}") {
#         # Source such script. If such script no longer exists, such call fails
#         # and hence implicitly throws an exception (as expected).
# #       print "sourcing \"${ZESHY_SCRIPT_FILENAME}\"..."
#         source -- "${ZESHY_SCRIPT_FILENAME}"
# #       print "sourced \"${ZESHY_SCRIPT_FILENAME}\"."
#     }

    # Push all files in such directory onto the script stack.
    # ZESHY_OVERLAY_FILENAMES+=(
    #     "${dirname_suboverlay}"/**/${~ZESHY__SCRIPT_FILENAME_GLOB} )

    # If the current operating system is unrecognized, return silently.
    # [[ -n "${ZESHY_LINUX_DISTRO_NAME}" ]] || return 0

    # # If such overlay has a subdirectory with lowercase name such system,
    # # register such subdirectory as a suboverlay.
    # dirname_suboverlay+="/${(L)ZESHY_LINUX_DISTRO_NAME}"
    # if [[ -d "${dirname_suboverlay}" ]] {
    #     ZESHY__OVERLAY_DIRNAMES+="${dirname_suboverlay}"
    # }
    # print "distro dir: ${dirname_suboverlay}"

    #FUXME: Incorrect. We've implemented a breadth-first search here, actually.
    #Correct this by:
    #
    #* Iterating from the back rather than front of such stack.
    #
    #That should be it. Reimplement!

    # To do so safely, iterate dynamically (e.g., "for ((...))") rather than
    # statically (e.g., "for overlay_dir (...)").
    # integer index=1
    # for ((; index <= ${#ZESHY__OVERLAY_DIRNAMES}; index++ )) {
    #     ::compile_zeshy_overlay "${ZESHY__OVERLAY_DIRNAMES[index]}"
    # }

    # implemented as a list set
    # List set of the absolute paths of all zeshy overlays applicable to the
    # current user and system. Such paths are incrementally discovered by a
    # depth-first first search through all overlays reachable from root zeshy
    # overlays
    # .
    # Hence, such list comprises a FIFO stack of such paths in discovery order.
    #
    # Root such stack and hence search to the passed root overlay.

 # At most one such subdirectory matches; `zeshy` ignores the
#     remaining subdirectories.
 # This could probably be optimized, of course.
#For example, if the current OS is proprietary (e.g., Darwin or Windows),
#there's
#FUXME: We've finally uncovered the optimal means of conditionalizing
#configuration files based on current OS and window manager. The ultimate
#solution, while exceedingly clever and orthogonal, will necessitate quite a bit
#of legwork on our part -- including an implementation of a zsh preprocessor.
#That's right: a zsh preprocessor, naturally implemented in pure-zsh. Why?
#Consider what configuration files consist of: intermingled runtime
#documentation with global variable definitions and occasional code. Given that,
#there's no reasonable means by which we could produce two or more OS-specific
#versions of a configuration file. Specifically, how would we keep the
#documentation preceeding each global in synchronicity? And that documentation
#*DOES* need to preceed each global.
#
#So, we need a different approach. Rather than distribute redundant copies of
#configuration file documentation into multiple files, we centralize all such
#documentation into a single file as we currently do. But then how do we
#efficiently support multiple OSes? After all, we *REALLY* don't want runtime
#logic in configuration files resembling:
#
#    if { :is_os_linux and :is_wm_x11 } {
#        ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#            import scrot imlib2_grab 'xwd and xwdtopnm' )
#    elif { :is_os_darwin } {
#        ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=( apple_screenshotter )
#    }
#
#Why? Because that's *TERRIBLE*. The end user shouldn't be expected to know
#exactly what OS and windowing manager they're currently using *OR* to be able
#to parse the above zeshy code. (Who knows what "darwin" means, anyway?)
#
#Instead, when producing target configuration files, we want to perform
#in-memory filtering of *EVERYTHING* in the corresponding source configuration
#files that doesn't apply to the current OS and windowing system. Hence, if on
#X11 under Linux, we only want to produce the following two lines (rather than
#the complex conditional above):
#
#    ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#        import scrot imlib2_grab 'xwd and xwdtopnm' )
#
#How do we reliably achieve this? The answer, of course, is both positively
#insane and remotely clever: we dynamically transform in-memory each applicable
#source configuration file into a zsh script consisting principally of calls to
#:output_string(), where *ONLY* lines in the original source configuration file
#applicable to the current system are passed to such function. Specifically, for
#each line of such file:
#
#* If such line is prefixed by "#:", strip such prefix. Such lines constitute
#  actual zsh code to be executed "as is" in the current shell.
#* Else, force-quote the entire line (e.g., with "(qq)") and prefix such quotes
#  with ":output_string ". Such lines constitute raw string literal lines to be
#  output rather than executed as code.
#
#This produces a zsh script, which we then run as such (ideally, in the current
#shell by calling source(), though that's only for efficiency; since we're not
#running such script for the standard output it produces rather than for any
#side-effects in the current shell, we could technically run such script under a
#new zeshy interpreter -- though, again, that's silly). Redirect the standard
#output of such script to the desired target configuration file, and we're done.
#
#Oh-ho-ho. Wait. No need to produce a temporary zsh script file, of course. Just
#produce a temporary *IN-MEMORY STRING* whose contents are the code to be
#executed producing the contents of the desired target configuration file; then,
#just eval() such string and redirect the standard output of such eval() to the
#desired target configuration file. Done!
#
#So. What would such a source configuration file resemble? Consider:
#
#    #!/usr/bin/env zsh
#
#    declare_parcel_as_script_with_stdin <<'/---'
#    Configure *command alternatives* (i.e., lists of all possible external commands
#    providing similar functionality, listed in descending order of preference).
#    /---
#
#    # ....................{ ABBREVIATIONS                      }....................
#    declare_global_with_stdin list ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN <<'/---'
#    List of all possible commands which which to implement
#    :screenshot_screen_to_file(), in descending order of preference.
#    /---
#    #: if { :is_os_linux and :is_wm_x11 } {
#    ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#        import scrot imlib2_grab 'xwd and xwdtopnm' )
#    #: elif { :is_os_darwin } {
#    ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=( apple_screenshotter )
#    #: }
#
#*REGARDLESS* of which OS or windowing manager is currently being run, the
#*EXACT SAME* in-memory zsh script is always produced from the above source.
#Indeed, this suggests we could cache such intermediary scripts on-disk
#somewhere (...though, as ever, that gets into inevitable desynchronization
#issues). In any case, such in-memory script resembles:
#
#    :output_string '#!/usr/bin/env zsh
#
#    declare_parcel_as_script_with_stdin <<''/---''
#    Configure *command alternatives* (i.e., lists of all possible external commands
#    providing similar functionality, listed in descending order of preference).
#    /---
#
#    # ....................{ ABBREVIATIONS                      }....................
#    declare_global_with_stdin list ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN <<''/---''
#    List of all possible commands which which to implement
#    :screenshot_screen_to_file(), in descending order of preference.
#    /---'
#    if { :is_os_linux and :is_wm_x11 } {
#    :output_string 'ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#        import scrot imlib2_grab ''xwd and xwdtopnm'' )'
#    elif { :is_os_darwin } {
#    :output_string 'ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=( apple_screenshotter )'
#    }
#
#...which, as you'll notice, is valid zsh. When dynamically evaluated under a
#Linux distro running an X11 windowing manager, the following target
#configuration file is output as desired:
#
#    #!/usr/bin/env zsh
#
#    declare_parcel_as_script_with_stdin <<'/---'
#    Configure *command alternatives* (i.e., lists of all possible external commands
#    providing similar functionality, listed in descending order of preference).
#    /---
#
#    # ....................{ ABBREVIATIONS                      }....................
#    declare_global_with_stdin list ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN <<'/---'
#    List of all possible commands which which to implement
#    :screenshot_screen_to_file(), in descending order of preference.
#    /---
#    ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#        import scrot imlib2_grab 'xwd and xwdtopnm' )
#
#Woh! Vision of C preprocessor macros dance before my eyes. While not terribly
#fond of macro systems in general (M4, I'm harshly glaring at you), it's
#difficult to conceive of a more appropriate alternative in this instance. In
#fact, the above is fairly bloody sweet.
#FUXME: Of course, the approach described above of manually iterating source
#configuration file lines is fairly inefficient. Instead, we want to perform
#global string searching and replacement -- ideally glob-based, but PCRE if
#necessary. We repeatedly match *EITHER* (e.g., "(...|...)"):
#
#* All characters from the current character (starting at the first, of course)
#  *NOT* prefixed by substring "\n#:" up to but *NOT* including either the next
#  substring "\n#:" or the string end, captured into match group 1.
#* All characters from the current character prefixed by substring "\n#:" up to but
#  *NOT* including either the next substring "\n(?!#:)" (i.e., the next line *NOT*
#  prefixed by substring "\n#:") or the string end, captured into match group 2.
#
#Right. That's looking like PCRE-based iteration, which is fine. Then,
#conditionally depending on which match group is nonempty, we append such match
#appropriately transformed onto the in-memory string holding such temporary zsh
#script. Fairly simple, no?

#FUXME: Ugh. We were belatedly under the misimpression that different flavors of
#BSD were also referred to as "BSD distributions." This is patently *NOT* the
#case; each BSD derivative is considered a distinct operating system. (A bit
#silly, honestly.) 

    # Lowercase name of the current *nix distribution.
    # local ZESHY_DISTRO_NAME

#FUXME: O.K.! The above is *GREAT*, but not quite there. Consider the simple
#example of a user configuring the current prompt theme. Great! It works. Except
#the configuration only applies to the current system. While we could use
#symlinks to get around this, see above for why symlinks are a terrible idea.
#(Namely, we can't depend on them on non-POSIX platforms.) So, what do we do?
#Simple:
#
#* When first discovering an applicable source configuration file, this parcel
#  must perform a mapfile-based search for any line prefixed by "#:" in such
#  file. Yes, this *WILL* impose a reasonably significant time cost on *EVERY*
#  digest compilation -- but it's hard to see a way around that. Indeed, we
#  have to perform such search *ANYWAY*, to determine whether or not such file
#  contains preprocessor directives or not and hence whether we can simply
#  efficiently copy such file as is or not.
#* If such source file contains no preprocessor directives, efficiently copy
#  such file as is *DIRECTLY* into directory "~/.zeshy/config/".
#* Else:
#  * Preprocess such file as discussed above.
#  * Write the result into a new directory
#    "~/.zeshy/config/system/${SYSTEM_ID}".
#
#Why is this *AWESOME*? Because it ensures that configuration files containing
#no preprocessor directives are shared across all OSes without any manual
#intervention on the part of the user. Great! Here's what the corresponding
#directory tree will resemble:
#
#    ~/.zeshy/
#        config/
#            00-core/
#            command/
#            system/
#                current -> linux-gnu.gentoo.FVWM.FVWM/
#                linux-gnu.gentoo.Mir.Mir/
#                    00-core/
#                    command/
#                linux-gnu.gentoo.Wayland.Wayland/
#                    00-core/
#                    command/
#                linux-gnu.gentoo.FVWM.FVWM/
#                    00-core/
#                    command/
#                darwin.Quartz.Quartz/
#                    00-core/
#                    command/
#                windows.Windows.Windows/
#                    00-core/
#                    command/
#FUXME: Don't forget to maintain symlink "current"! Important for usability.
#FUXME: Ugh. In reflection, the ponderous majority of the above discussion on
#system-specific configuration files is skewed far afield from reality. No.
#Really. Absolutely atrocious concept, and we're overwhelmingly lucky not to
#have actually followed through with it. The core deficit in the whole concept
#is its disconnect between output lines and preprocessed code. In particular,
#consider the following problem using the underlying example of
#${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN}: when running under a virtual console
#(i.e., under no display server), :screenshot_screen_to_file() and hence
#${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN} should be *UNDEFINED*, as well as the
#corresponding documentation for each. Since both :screenshot_screen_to_file()
#and its documentation are defined in code, preventing either from being
#defined is readily feasible. But how exactly would we prevent documentation for
#${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN} from being defined? In two words: we
#wouldn't. It's infeasible given the prior preprocessing concept, which pretty
#much throws out all other arguments in favor of such preprocessing.
#
#So, what do we do instead? Simple:
#
#* Define a new top-level parcel @{src/25-if_config_system}.
#* Define a corresponding ::compile_zeshy_suboverlay_if_config_system() function
#  handling the contents of such overlay, which are source configuration scripts
#  whose output is intended to be redirected to the target configuration file
#  under "~/.zeshy/config/system":
#    source -- "${filename_src}" >! "${filename_trg}"
#  Each such source script is a simple zsh script containing *NONE* of the prior
#  proprocessing nonsense; instead, such scripts resemble:
#
#    #!/usr/bin/env zsh
#
#    () {
#        :output_stdin <<<'---/'
#        #!/usr/bin/env zsh
#
#        declare_parcel_as_script_with_stdin <<'/---'
#        Configure *command alternatives* (i.e., lists of all possible external commands
#        providing similar functionality, listed in descending order of preference).
#        /---
#
#        # ....................{ ABBREVIATIONS                      }....................
#        ---/
#
#        :string ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN_HELP='
#        List of all possible commands which which to implement
#        :screenshot_screen_to_file(), in descending order of preference.'
#        if { :is_os_linux and :is_wm_x11 } {
#            :output_stdin <<<'---/'
#            declare_global_with_stdin list ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN\
#                <<"${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN_HELP}"
#            ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=(
#                import scrot imlib2_grab 'xwd and xwdtopnm' )
#            ---/
#        elif { :is_os_darwin } {
#            :output_stdin <<<'---/'
#            declare_global_with_stdin list ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN\
#                <<"${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN_HELP}"
#            ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN=( apple_screenshotter )
#            ---/
#        }
#    }
#
#  Great! Simple; efficient; and certainly maintainable. And, of course, there's
#  the benefit of it actually working. In practice, of course, we'd probably
#  prefer to:
#
#  * *ALWAYS* unconditionally declare documentation, even if the corresponding
#    function or global is never defined. Keeps code maintainable and readable.
#  * Implement documentation printers (e.g., :print_help()) to pretend that no
#    documentation exists for undefined functions and globals. (Simple!)
#
#  Nonetheless, the fact that we even *CAN* leave documentation unconditionally
#  undefined with the above approach but *NOT* with the preprocessing approach
#  is the thing. At some point, we'll absolutely need such flexibility. So,
#  let's prepare for the longest road.
#* Unfortunately, we run into a bit of trouble here. ::compile_zeshy_source()
#  (the function sourcing zeshy scripts) is disconnected from
#  ::compile_zeshy_suboverlay_if_config_system() (the function registering such
#  scripts). At the moment, ::compile_zeshy_source() simply sources all scripts.
#  We'll need to generalize this such that:
#
#  * If the current script to be sourced by ::compile_zeshy_source() resides in
#    an "if_config_system" overlay, the output of doing so should be redirected
#    to the corresponding target configuration file:
#  * Else, such script should simply be sourced as is.
#
#Great. Now how do we efficiently accomplish this? We *DON'T* want to perform
#manual globbing of script paths to try to hackily determine whether such script
#is in an "if_config_system" overlay. And we'll need some means of associating
#such scripts with the target path to copy their output to.
#
#Hmm. We *COULD* embed such logic directly into the source script, which is
#probably the ideal route to take here. As we see it, there are fundamentally
#two ways of implementing such logic:
#
#1. By passing here-documents to an append function and then lastly calling a source
#   function: e.g.,
#
#    #!/usr/bin/env zsh
#    :source_file_config_system_start
#
#    :append_stdin_to_file_config_system <<'###-'
#    #!/usr/bin/env zsh
#
#    declare_parcel_as_script_with_stdin <<'/---'
#    Configure *command alternatives* (i.e., lists of all possible external commands
#    providing similar functionality, listed in descending order of preference).
#    /---
#
#    # ....................{ ABBREVIATIONS                      }....................
#    ###-
#
#    ...
#
#    :source_file_config_system_stop
#2. By redirecting subshell output to a single write-and-source function: e.g.,
#
#    #!/usr/bin/env zsh
#
#    :write_stdin_to_file_config_system_and_source <(
#    :output_stdin <<<'###-'
#    #!/usr/bin/env zsh
#
#    declare_parcel_as_script_with_stdin <<'/---'
#    Configure *command alternatives* (i.e., lists of all possible external commands
#    providing similar functionality, listed in descending order of preference).
#    /---
#
#    # ....................{ ABBREVIATIONS                      }....................
#    ###-
#
#    ...)
#
#   This has one distinct disadvantage: inefficiency. In general, this would
#   certainly be cause for concern. In this case, however, such script is *ONLY*
#   executed when the target configuration file does *NOT* already exist (i.e.,
#   on first installation) *AND* on subsequent upgrades -- which is to say,
#   hardly ever. And the advantages are numerous: a simplified interface
#   requiring only one new function
#   :write_stdin_to_file_config_system_and_source(), usage of any conventional
#   aliases and functions the source configuration file desires for constructing
#   such output (e.g., :output_stdin(), :output_string()), and no need for a
#   final cleanup call.
#FUXME: Actually, on a wee mote of reflection, we quite prefer the former
#method. Despite appearances, it's much more straightforward, requires no
#subshells, and only requires adherence to a *VERY* simple blackbox interface
#defined by the following three functions declared somewhere here in @{compile}
#(and then ideally undefined after sourcing the codebase but before digest
#compilation, to prevent their unwanted compilation into such digest):
#
#* :source_file_config_system_start(). This function ensures the target
#  configuration file does *NOT* exist and, if it does, removes it.
#* :append_stdin_to_file_config_system(). This function appends standard input
#  to such file.
#* :source_file_config_system_stop(). This function sources such file.
#
#Simple. We should note that the alternative solution above actually isn't
#terribly better, as we'd probably end up defining a new pair of aliases
#:write_stdin_to_file_config_system_and_source_start()
#:write_stdin_to_file_config_system_and_source_stop() to simplify and
#abstract away such details, in which case we really haven't gained anything
#over the more straightforward solution here.
#
#So. Such functions clearly require some means of mapping from source
#configuration scripts to the target configuration files such scripts intend
#output to be written to. How? Simple: as ever, a temporary map "global"
#${ZESHY_CONFIG_SYSTEM_SCRIPT_NAME_TO_FILENAME} (or some such) defined at the
#head of :compile_zeshy() and appended to within the body of
#::compile_zeshy_suboverlay_if_config_system(). Done!
#
#Right. We reckon that's it then: go the :append_stdin_to_file_config_system()
#route, define ${ZESHY_CONFIG_SYSTEM_SCRIPT_NAME_TO_FILENAME} as described, and
#have a buckethead full of elegant codey fun.
#FUXME: *PALM STRIKES FOREHEAD*. O.K.; obviously, given such a map "global"
#${ZESHY_CONFIG_SYSTEM_SCRIPT_NAME_TO_FILENAME}, all we have to do is manually
#test in each iteration of ::compile_zeshy_source() whether the current file is
#a key of ${ZESHY_CONFIG_SYSTEM_SCRIPT_NAME_TO_FILENAME} and to respond
#accordingly. Specifically, if so, just redirect the output of sourcing such
#script to the corresponding value of the same map. Simple! Hence, define such
#scripts to simply output to standard output. Done. Both efficient and (mostly)
#ludicrously trivial to implement. *sigh*
#FUXME: *PALM STRIKES FOREHEAD AGAIN*. O.K.! Jeeez. Honestly, what were we
#thinking with *ANY* of this absurd complexity. We *ALREADY* have a builtin
#means of conditionally differentiating between various configuration globals:
#by suffixing their names with the desired condition, in this case "_IF_X"
#(e.g., ${ZESHY_ALTERNATIVES_SCREENSHOT_SCREEN_IF_DISPLAY_SERVER_X}). OMFG. All
#of the above... what was it for? Absolutely void. *multiple redundant sigh*

#* Such parcel contains configuration file *SCRIPTS* rather than merely files.
#  Specif
    # For each overlay root, perform a stack-based depth-first search of the
    # subdirectories under such root for all zeshy scripts applicable to the
    # current user and system. Such roots commonly include:
    #
    # * The main system-wide zeshy overlay (e.g., "/usr/share/zeshy").
    # * The main user-specific zeshy overlay (e.g., "~/.zeshy/src").
    #
    # Such roots commonly contain additional overlays as subdirectories (e.g.,
    # "/usr/share/zeshy/if_pathable/X"). On finding such overlays, such searches
    # push such overlays onto the same stack of iterated overlays. To do so
    # safely, iterate dynamically (e.g., "for ((...))") rather than statically
    # (e.g., "for overlay_dir (...)").

#FUXME: We've hit upon a respectable path forward for specifying overlay order.
#Essentially, we retain the existing declarative-based method of naming overlays
#without respect to the order in which zeshy sources such overlays (e.g.,
#"always/", "if_pathable/") *AND* simply add a new procedural-based method of
#naming overlays explicitly specifying the order in which zeshy sources such
#overlays: unsurprisingly, by prefixing standard overlay names with "-"-suffixed
#two-digit integers (e.g., "00-preconfig", "10-config"). The way this should
#probably work is as follows:
#
#* Before looking for and sourcing if found unordered suboverlays in the current
#  overlay (e.g., "always/", "if_config/"), ::compile_zeshy_overlay() should first
#  glob and iterate all ordered suboverlays in such overlay in order: e.g.,
#
#    list suboverlay_dirnames_ordered
#    suboverlay_dirnames_ordered=( "${overlay_dirname}"/<->'-'?*(/) )
#
#    local suboverlay_dirname_ordered suboverlay_type
#    for   suboverlay_dirname_ordered ("${suboverlay_dirnames_ordered[@]}") {
#       # Strip the prefixing integer from such suboverlay basename.
#       suboverlay_type="${suboverlay_dirname_ordered:t#<->-}"
#
#       # Handle such suboverlay according to its type.
#       case "${suboverlay_type}" {
#       # Handle directories with special names in a special manner.
#       if_config) ...;;
#       if_pathable) ...;;
#       # Handle all other directories as "always"-type overlays (e.g., simply
#       # recursively source all files in such overlays).
#       *) ...;;
#       }
#    }
#
#Reasonably simple, fairly efficient, and probably the only lucid means of
#implementing ordered suboverlays. So. Why do we need ordered suboverlays?
#Simple: the top-level root overlay has computational needs somewhat too complex
#to be reasonably decided with the conventional declarative approach.
#Specifically, the order in which root suboverlays are sourced is beginning to
#require explicit specification. At the moment, we really want to implement the
#following changes:
#
#* Move "src/always/00-core" to "src/00-core".
#* Move "src/if_config" to "src/10-config". (Likewise, all "if_config"
#  subdirectories should be renamed to simply "config", corresponding to the
#  actual target user directory that zeshy creates from such subdirectories.
#  Hmmm... Actually, I *DO* like the "if_config" nomenclature, as it implies
#  such suboverlays are handled in a particular, peculiar manner, much like
#  "if_pathable". Right. Make this "10-if_config", then!)
#* Move "src/if_pathable" to "src/20-if_pathable". This ensures that "if_config"
#  subdirectories in such suboverlays are sourced *AFTER* the entirety of the
#  core configuration.
#* Move "src/always" to "src/30-main". The main codebase must be sourced *AFTER*
#  sourcing *ALL* system and user configuration, allowing the user to customize
#  digest compile-time behavior. At the moment, this principally means
#  customizable ordered lists of preferred commands (e.g.,
#  ":list ZESHY_PATHABLES_SCREENSHOT_SCREEN
#         ZESHY_PATHABLES_SCREENSHOT_SCREEN=( import scrot imlib2_grab xwd )"),
#  which zeshy then accesses at compile-time to decide which implementation of a
#  function to dynamically define. It's absolutely critical the user be allowed
#  to customize such lists and hence that "always/00-core" be split from
#  "always", as above. (Actually, we could make this "20-main" and
#  "30-if_pathable". The latter should probably *NEVER* provide files the former
#  depends upon.)

    #FUXME: There's actually a substantially more efficient means of testing
    #for whether a path is pathable or not, which we should clearly "export"
    #back into our proper is_pathable() function. Untested, but it should
    #theoretically work:
    #
    #pathnames_pathable=(
    #    "${overlay_command_dirname}/"*(e{'(( ${+commands[${REPLY:t}]} ))'})
    #) || true
    #
    #Pretty sweet, eh? Map global ${commands} is maintained by module
    #"zsh/parameter", and provides extremely efficient access to such paths.
    #At least, it *SHOULD* be more efficient. It's certainly more elegant;
    #since testing nonzeroness is must faster than matching string prefixes,
    #it's hard to see how this *COULDN'T* be faster than the approach below.
    #corresponding to a
    # currently installed executable file in the $PATH. Dismantled, this is:
    #
    # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
    #   command directory.
    # * "(e{[[ ... ]]})", excluding files failing the following test:
    #   * "$REPLY", the current file.
    #   * ":t", the basename of such file.
    #   * ":c", the absolute path to a command in the $PATH with such name.
    #   * "== /*", true only when ":c" succeeds in finding such a command.
    # * "or true", ignoring failure (if ":c" fails finding such a command).
    # pathnames_pathable=(
    #     "${dirname_suboverlay}/"*(e{'[[ $REPLY:t:c == /* ]]'})
    # ) || true

    # :output_line_if_debugging "Searching overlay \"${ZESHY_OVERLAY_DIR}\"."
    #FUXME: Excise everything below. *simpering sigh*

    # ~~~~~~~~~~~~~~~~< IMPORTANT ~ order is significant   >~~~~~~~~~~~~~~~~~~~~
    # Order of operation is significant below. Later paths assume precedence
    # over prior paths in corresponding lists.

    # # Absolute path of the main suboverlay.
    # dirname_overlay_main="${dirname_overlay}/always"

    # # If such suboverlay exists, register all `zsh` scripts in such directory
    # # and subdirectories of such directory.
    # if [[ -d "${dirname_overlay_main}" ]] {
    #     ZESHY_OVERLAY_FILENAMES+=(
    #         "${dirname_overlay_main}"/**/${~ZESHY__SCRIPT_FILENAME_GLOB} )
    # }

    # # Source all configuration files in such overlay's configuration directory.
    # # Do so prior to all other overlay logic depending on globals defined by
    # # such files.
    # ::compile_zeshy_suboverlay_if_config "${dirname_overlay}"

    # # Append such overlay's command directory to appropriate lists, if found.
    # ::compile_zeshy_suboverlay_if_pathable "${dirname_overlay}"

    # # Append the subdirectory of such overlay's distro directory matching the
    # # user's currently installed distro to the overlay stack, if found.
    # #
    # # Do this after all other overlay logic, allowing distro-specific
    # # redefinition of generic functionality.
    # ::compile_zeshy_suboverlay_if_distro "${dirname_overlay}"

    # If the current user is a zeshy developer and the current shell is
    # interactive, print such path to standard output.
#   print "overlaying \"${dirname_overlay}\"..."

        # # For efficiency in matching below, strip such directory of its parent
        # # directory and optional ordering prefix (e.g., "/usr/share/zeshy/00-").
        # magic_suboverlay="${suboverlay_dirname_ordered:t#<->-}"

        # # Handle such suboverlay according to its type.
        # case "${magic_suboverlay}" {
        # # Handle suboverlays suffixed by magic strings magically. For
        # # efficiency, match in descending order of real-world likelihood.
        # if_config)   ::compile_zeshy_suboverlay_if_config   "${dirname_suboverlay}";;
        # if_pathable) ::compile_zeshy_suboverlay_if_pathable "${dirname_suboverlay}";;
        # if_distro)   ::compile_zeshy_suboverlay_if_distro   "${dirname_suboverlay}";;
        # # Handle all other suboverlays non-magically (e.g., unconditionally
        # # register all zsh scripts in such suboverlays).
        # *) ::compile_zeshy_suboverlay_simple "${dirname_suboverlay}";;
        # }

    #FUXME: We can and should call remove_list_items_matching_glob() and
    #set_list_to_list_difference() below.

# ....................{ SOURCERS                           }....................
#FUXME: Nonsense. We're *SO* pleased to be finally refactoring this parcel,
#unearthing such demonstrably crusty gems as this function. Shift its contents
#directly to ::compile_zeshy_suboverlay_if_config(), where they originally
#resided before such brackish hackishness.
# ZESHY_CORE_HELP_FUNCTIONS+='
# void source_zeshy_configuration(void)
# 
# Source all configuration files in `zeshy`\''s user configuration directory,
# creating such directory if needed.
# '
# function source_zeshy_configuration() {
#     # Validate sanity. Unless loading zeshy's user directory and Zeshy's user
#     # configuration directory exists, return silently.
#     (( # )) && :die 'Expected no arguments.'
#     [[ -n "${ZESHY_DOT_DIR}" && -d "${ZESHY_USER_CONFIG_DIRNAME}" ]] || return 0
# 
#     # Source such files, localizing each to ${ZESHY_SCRIPT_FILENAME} to guarantee
#     # behavior elsewhere expecting such string variable to contain the currently
#     # sourced script name (e.g., declare_parcel_as_script()).
#     local ZESHY_SCRIPT_FILENAME
#     for   ZESHY_SCRIPT_FILENAME (
#         "${ZESHY_USER_CONFIG_DIRNAME}/"**/${~ZESHY__SCRIPT_FILENAME_GLOB}) {
#         :output_line_if_debugging "zeshy: conflating \"${ZESHY_SCRIPT_FILENAME}\"..."
#         source -- "${ZESHY_SCRIPT_FILENAME}"
#     }
# }

    # Declare startup_zeshy() and cohorts.

    #FUXME: We strongly suspect this will require additional generalization in
    #the future. In particular, our expansion of all files in
    #${ZESHY_AUTOLOAD_DIRNAMES} prior to all files in
    #${ZESHY_OVERLAY_FILENAMES} strikes us as terribly arbitrary. Clearly,
    #reversing the order of such expansion is no better solution. Individual
    #overlay registrars (e.g., ::compile_zeshy_suboverlay_if_pathable()) should
    #be able to precisely specify the order of inclusion regardless of whether
    #the path being included is a file or directory. At the moment, they can't.
    #
    #Correcting this is simple, of course: reduce these two list globals to a
    #single list global ${ZESHY_DIGEST_SOURCE_PATHNAMES} (...a significantly
    #better name, as well), then iterate such paths and:
    #
    #* If the current path is a file, source such file.
    #* Else, recursively source all files in such directory as below.
    #
    #While slightly less efficient, such reduction is unavoidable, we're afraid.
    #It's the only reasonable means of arbitrarily interleaving paths in a
    #manner retaining the order in which such paths are to be sourced.
    #FUXME: Since the implementation of the above approach is a bit awkward
    #(consider ${ZESHY_SCRIPT_FILENAME}), a slightly more elegant approach might be
    #to define a new utility function :append_zeshy_digest_source_dir():
    #
    #    function :append_zeshy_digest_source_dir() {
    #        ZESHY_OVERLAY_FILENAMES+=(
    #           "${1}"/**/${~ZESHY__SCRIPT_FILENAME_GLOB} )
    #    }
    #
    #Call such function everywhere we currently append to
    #${ZESHY_AUTOLOAD_DIRNAMES}. Note we then only need a single list global
    #${ZESHY_OVERLAY_FILENAMES}, which can be elegantly iterated over and
    #sourced here without need for the above conditional. Since function calls
    #*SHOULD* be considerably more efficient than filesystem tests, this
    #approach is likely to prove both the fastest and most elegant. Win!

# ....................{ APPENDERS                          }....................
# void :append_zeshy_digest_source_dir(string dirname)
# function :append_zeshy_digest_source_dir() {
#     (( # == 1 )) || :die 'Expected one dirname.'
#     ZESHY_OVERLAY_FILENAMES+=( "${1}"/**/${~ZESHY__SCRIPT_FILENAME_GLOB} )
# }

    # Recursively source all scripts in all overlays applicable to the current
    # system and user, thus defining all applicable zeshy-specific aliases,
    # functions, and globals. Dismantled, this is:
    #
    # * "${^...[@]}"/**/${~...}, recursively expanding to each script in each
    #   previously registered directory.
    #
    # Note that ${ZESHY_SCRIPT_FILENAME} masquerades as a global and is frequently
    # expanded as such elsewhere in the codebase. See such variable's
    # documentation for further details.
#     :output_line_if_debugging "zeshy: Sourcing \"${ZESHY_OVERLAY_DIR}\" scripts."
#     local ZESHY_SCRIPT_FILENAME
#     for   ZESHY_SCRIPT_FILENAME (
# #       "${ZESHY_OVERLAY_DIR}"/always/00-startup/**/${~ZESHY__SCRIPT_FILENAME_GLOB}
#         "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/${~ZESHY__SCRIPT_FILENAME_GLOB}
#         "${ZESHY_OVERLAY_FILENAMES[@]}"
#     ) {
#         # Source such script.
# #       print "sourcing \"${script_filename}\"..."
#         source -- "${ZESHY_SCRIPT_FILENAME}"
# #       print "sourced \"${autoload_function_filename}\"."
#     }

    # String lists of all zeshy-specific aliases, functions, and globals.
#   export ZESHY__GLOBAL_NAMES
#   print '===ZESHY__FUNCTION_NAMES==='
#   typeset -p ZESHY__FUNCTION_NAMES

    # # List of directories recursively containing zsh scripts containing
    # # autoloadable functions to be compiled into zeshy's digest file.
    # local -Ua ZESHY_AUTOLOAD_DIRNAMES

    # # List of zsh scripts containing autoloadable functions to be so compiled.
    # local -Ua ZESHY_OVERLAY_FILENAMES

    #   * "/**/*",  recursively expanding to each file in such directory.
    #   * "~*.swp", excluding temporary files.
    #   * "(.)", excluding non-plain files.

    # If loading zeshy's user directory, compile all zeshy functions excluding
    # those defined by top-level components (e.g., "main", "digest") into
    # zeshy's user digest file.
    # if [[ -n "${ZESHY_DOT_DIR}" ]] {

    # Inform the current user of such recompilation.
    # if [[ -o interactive ]] {
    #     if [[ -n "${ZESHY_DOT_DIR}" ]] {
    #         print "zeshy: recompiling \"${ZESHY_USER_DIGEST_FILENAME}\"..."
    #     } else {
    #         print "zeshy: sourcing \"${ZESHY_OVERLAY_DIR}\"..."
    #     }
    # }

# ZESHY_CORE_HELP_FUNCTIONS+='
# void source_zeshy_configuration(void)
# 
# Source all configuration files in `zeshy`\''s user configuration directory,
# creating such directory if needed.
# '
# function source_zeshy_configuration() {
#     # Validate sanity. Unless loading zeshy's user directory and Zeshy's user
#     # configuration directory exists, return silently.
#     (( # )) && :die 'Expected no arguments.'
#     [[ -n "${ZESHY_DOT_DIR}" && -d "${ZESHY_USER_CONFIG_DIRNAME}" ]] || return 0
# 
#     # Source such files, localizing each to ${ZESHY_SCRIPT_FILENAME} to guarantee
#     # behavior elsewhere expecting such string variable to contain the currently
#     # sourced script name (e.g., declare_parcel_as_script()).
#     local ZESHY_SCRIPT_FILENAME
#     for   ZESHY_SCRIPT_FILENAME (
#         "${ZESHY_USER_CONFIG_DIRNAME}/"**/${~ZESHY__SCRIPT_FILENAME_GLOB}) {
#         :output_line_if_debugging "zeshy: conflating \"${ZESHY_SCRIPT_FILENAME}\"..."
#         source -- "${ZESHY_SCRIPT_FILENAME}"
#     }
# }

#FUXME: Document, when time and love permit.

    # Source zeshy's user configuration files:
    #
    # * *AFTER* sourcing the main zeshy codebase, ensuring such files may expand
    #   standard aliases (e.g., string_export_global<>).
    #
    # The latter point is particularly important. Serializing configuration-
    # specific globals into the user digest suggests that the configuration need
    # *NOT* be sourced on every zeshy startup but only during recompilation, an
    # efficiency improvement.
#   which string_global_export
    # source_zeshy_configuration

    # Append the subdirectory of such overlay's distro directory matching the
    # user's currently installed distro to the overlay stack, if found.
    #
    # Do this after all other overlay logic, allowing distro-specific
    # redefinition of generic functionality.
    # ::compile_zeshy_suboverlay_if_distro "${dirname_overlay}"
    # if [[ -n "${ZESHY_DISTRO_NAME}" ]] {
    #     local dirname_suboverlay_distro="${dirname_overlay}/if_distro/${ZESHY_DISTRO_NAME}"
    #     if [[ -d "${dirname_suboverlay_distro}" ]] {
    #         ZESHY__OVERLAY_DIRNAMES+="${dirname_suboverlay_distro}"
    #     }
    # }

        # Strip off the prefixing overlay configuration directory (e.g., from
        # "/usr/share/zeshy/src/if_config/if_shell_interactive/00-alias" to.
        # "if_shell_interactive/00-alias").
        # filename_suffix="${filename_src#${dirname_suboverlay}/}"

        # # Set the target filename appended with such suffix.
        # filename_trg="${ZESHY_USER_CONFIG_DIRNAME}/${filename_suffix}"

    #FUXME: Nonsense. We *ALWAYS* require a dot directory.
    # If ignoring zeshy's user directory, source such files from such overlay
    # without copying such files to such directory.
    # if [[ -z "${ZESHY_DOT_DIR}" ]] {
    #     for filename_src (
    #         "${dirname_suboverlay}/"**/${~ZESHY__SCRIPT_FILENAME_GLOB}) {
    #         source -- "${filename_src}"
    #     }
    #     return 0
    # }

#       [[ "${suboverlay_dirname_ordered}" == <->'-'(#b)(?*) ]] || :die\
#           "Suboverlay \"${suboverlay_dirname_ordered}\" not integer-prefixed."
#       suboverlay_type="${match[1]}"

#   startup_zeshy_globals
#   startup_zeshy_aliases
#       "$(get_variable_binding "${ZESHY__GLOBAL_NAMES[@]}")"
    # Define functions declaring and defining all zeshy-specific aliases and
    # globals on zeshy startup. Since ::precompile_zeshy_names() previously
    # defined placeholder implementations for such functions, redefine rather
    # than define such functions.

    # Call functions compile_zeshy_startup_aliases_and_globals()
    # creates at the start of zeshy startup, initializing globals *BEFORE*
    # aliases. Order is insignificant, here. Initializing aliases defines global
    # aliases (e.g., "or", "is"). If globals were accidentally initialized after
    # aliases, then any list elements or map keys or values equal to such global
    # alias names would be silently expanded to such aliases' expansion.
    # Needless to say, that would be horribly bad.
    # Make such functions, joining such list elements on newline.

#   (( ${#ZESHY__ALIAS_NAMES} )) || :die\
#       'expected zeshy to define one or more aliases'
#   (( ${#ZESHY__FUNCTION_NAMES} )) || :die\
#       'expected zeshy to define one or more functions'
#   (( ${#ZESHY__GLOBAL_NAMES} )) || :die\
#       'expected zeshy to define one or more globals'

    #FUXME: Find and rename such function. It's awkward that such function is
    #defined elsewhere. Explain why.

    # List of all zeshy-specific global bindings. Unfortunately, defining such
    # list is complicated by deficiencies in the typeset() builtin. In
    # particular, "typeset -p" fails to annotate global variable declarations
    # with option "-g", thus localizing all such globals to
    # startup_zeshy_globals(). Of course, this constitutes a horrible zsh bug.
    # (Submit a report please.) In the meanwhile, forcefully add such option
    # immediately after any line output by "typeset -p" starting with "typeset".
    #
    # To do so, first split such output into lines and for each such line
    # perform such insertion with array glob replacement. Dismantled, this is:
    #
    # * "(f)", splitting such output on newline.
    # * "/", performing such replacement at most once for each output line.
    # * "(#s)", matching only at the start of each such line.
    #
    # Then join such lines on newline back into a string, avoiding quoting the
    # outermost expansion. See the following functions for further details:
    #
    # * get_variable_binding().
    # * set_list_to_string_lines().
    # * join_list_on_newline().

    #FUXME: Shift this to precompile_zeshy_functions_startup().
#   run_hook_on_zeshy_startup_first 
#   run_hook_on_zeshy_startup_first startup_zeshy_aliases

    #FUXME: Find and rename such function. It's awkward that such function is
    #defined elsewhere. Explain why.
    # Define top-level zeshy startup functions (e.g., startup_zeshy()).
#Subsequently synthesized function startup_zeshy() calls both such functions
#before calling all other startup functions.
#Create  and all remaining functions called by such function
#(e.g., , startup_zeshy_if_shell_login()).

# *BEFORE* compiling such file and prepending commands to
    # startup_zeshy(). The latter ensures startup_zeshy_aliases() and
    # startup_zeshy_globals() to *ALWAYS* be the first functions called by
    # startup_zeshy(), ensuring aliases and globals to always be defined at the
    # "start" of zeshy startup, ensuring subsequent functions may always safely
    # expand any zeshy alias or global
    # * *BEFORE* calling ::precompile_zeshy_names() obtaining the list of newly
    #   declared globals, ensuring serialization of globals such files defined
    #   into zeshy's user digest file.

    #FUXME: Rename this function. It's performed *AFTER* all precompilation, and
    #really doesn't deserve to be bundled with the rest.
    # Define mid-level zeshy startup functions startup_zeshy_aliases() and
    # startup_zeshy_globals() *AFTER* defining all other zeshy functions. The
    # latter function defines a global listing all zeshy functions and hence
    # must be the last function to define such functions. Subtle dragons lie.

    # Cache digest dependencies *AFTER* calling all customary precompilation
    # functions above. Such functions typically add such dependencies.

    # Serialize the lists of zeshy-specific aliases, suffix aliases, functions,
    # and globals to a zsh script in the current user's cache directory. Such
    # lists are both too resource consumptive and too infrequently accessed
    # post-compilation to warrant serialization into startup_zeshy_globals()
    # with customary zeshy globals.
    # See write_file_with_variable() for further details. Since
    # get_zsh_shebang_line() has yet to be defined, avoid writing a shebang
    # line. (Since only this parcel sources such script, this is acceptable.)

#FUXME: I'm fairly certain we don't need the ${alias_names_quoted} nonsense
#anymore. Testing whether this is the case is fairly simple: disable such block
#of code and append ZESHY_ALIAS_SUFFUX_NAMES to ZESHY__GLOBAL_NAMES earlier.
#FUXME: This function has become lengthy enough to warrant splitting into
#numerous subfunctions. See to it, young stalwart lad!

#   typeset -p -- ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES\
#       >!"${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}"

#FUXME: Compiling lists of alias, function, and global names into the digest is
#inherently silly. For one, we no longer need to do so, so it unnecessarily
#increases both compilation and startup time. It'd be a loss to simply unset
#such globals, however; ideally, they should simply be serialized to disk
#(e.g., "~/.zeshy/cache/names.zsh", a zsh script containing all such lists).
#This shouldn't be terribly difficult, so see to it.
#FUXME: I'm exceedingly tired of *ALL* of the rather stupid timing problems
#inherent in this function. One simple thing that can be done to eliminate such
#issues is to add placeholder calls to :define_func() for all functions to be
#newly defined as the *VERY* first thing this function does. Then shift the
#initialization of ZESHY__FUNCTION_NAMES to the sensible place. Naturally, such
#functions would need be redefined (as we currently do with one of them already).
#FUXME: Actually, shift :define_func() calls even earlier -- ideally, to the
#first line of ::precompile_zeshy_names(). Doing so then permits us to shift the
#initialization of ZESHY__FUNCTION_NAMES into such function as well. Do we create
#any other functions dynamically?

#   globals="$(print -lr -- ${${(f)"$(typeset -p --\
#       "${ZESHY__GLOBAL_NAMES[@]}")"}/(#s)typeset /typeset -g })"
    # List of all zeshy-specific global bindings. Unfortunately, defining such
    # list is complicated by deficiencies in the typeset() builtin. In
    # particular, "typeset -p" fails to annotate global variable declarations
    # with option "-g", thus localizing all such globals to
    # startup_zeshy_globals(). Of course, this constitutes a horrible zsh bug.
    # (Submit a report please.) In the meanwhile, forcefully add such option
    # immediately after any line output by "typeset -p" starting with "typeset".
    #
    # To do so, first split such output into lines and for each such line
    # perform such insertion with array glob replacement. Dismantled, this is:
    #
    # * "(f)", splitting such output on newline.
    # * "/", performing such replacement at most once for each output line.
    # * "(#s)", matching only at the start of each such line.
    #
    # Then join such lines on newline back into a string, avoiding quoting the
    # outermost expansion. See the following functions for further details:
    #
    # * get_variable_binding().
    # * set_list_to_string_lines().
    # * join_list_on_newline().
#   globals="$(print -lr -- ${${(f)"$(typeset -p --\
#       "${ZESHY__GLOBAL_NAMES[@]}")"}/(#s)typeset /typeset -g })"

    #FUXME: The following call dies with an unhelpful parse error if *ANY* list
    #element or map key or value in the string ${globals} equals a reserved
    #keyword (e.g., "&&"). Why? Because the above "typeset -p" command fails to
    #quote such elements, and there's currently no way to enforce such quoting.
    #Doing so manually is certainly feasible, but *EXTREMELY* inefficient and
    #hence effectively infeasible. Fortunately, a simpler (though still annoying
    #solution) presents itself. Run the following command at the *VERY* start of
    #the function body of startup_zeshy_globals():
    #
    #    disable -r --\
    #       do done esac then elif else fi for case if while function\
    #       repeat time until select coproc nocorrect foreach end ! [[ { }
    #
    #Naturally, we'd need to insert a corresponding "enable -r --" command at the
    #end of such function body -- perhaps in an "} always { ... }" block for
    #safety.
    #
    #Note this is only an imperfect solution, since "&&" and "||" (and possibly
    #other) reserved keywords cannot be disabled in this manner. Since
    #performing a global string substitution would be inherently unsafe and
    #since we can't reasonably implement a full-fledged zsh parser, there's
    #little else we can do. That said, the likelihood of such list elements
    #seems vanishingly small.
    # The list of zeshy-specific functions is the asymmetric difference of the
    # old from new list of functions.
#   ZESHY__FUNCTION_NAMES_NEW=( ${(f)"$(typeset +f)"} )
#   ZESHY__FUNCTION_NAMES=(
#       "${ZESHY__FUNCTION_NAMES_NEW[@]:|ZESHY__FUNCTION_NAMES_OLD}" )

#, which
    # ::precompile_zeshy() requires for synthesizing new functions. Delay
    # determining the list of zeshy-specific functions until doing so
    # Make such functions, making a placeholder empty definition for
    # startup_zeshy_globals() to be replaced below. The reasons, as ever, are
    # insidious. The set of all zeshy-specific globals includes list global
    # ${ZESHY__FUNCTION_NAMES}, which cannot be defined until after defining all
    # zeshy-specific functions. Naturally, startup_zeshy_globals() is such a
    # function. To break such circularity, define such function empty initially.
    #FUXME: Actually, why *DO* we defer recording function names to later?

# (though it is fairly unusual)
#   local -a alias_names_quoted
#   local -a global_declarations; global_declarations=(
#       ${${(f)"$(typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")"}/(#s)typeset /typeset -g }
#   )

    # Join such lines on newline back into a string. See join_list_on_newline()
    # for further details.
#   local globals; globals="$(print -lr -- "${global_declarations[@]}")"

    #FUXME: This function could use significant refactoring. *sigh*
    # Make the final zeshy function. (Phew!)

    # Make such functions, making a placeholder empty definition for
    # startup_zeshy_globals() to be replaced below. The reasons, as ever, are
    # insidious. The set of all zeshy-specific globals includes list global
    # ${ZESHY__FUNCTION_NAMES}, which cannot be defined until after defining all
    # zeshy-specific functions. Naturally, startup_zeshy_globals() is such a
    # function. To break such circularity, define such function empty initially.
#   :redefine_func startup_zeshy_aliases "${aliases}
#   ${suffix_aliases}"
#   :define_func startup_zeshy_globals ""

    # Manually add the definition of the list of zeshy-specific aliases to such
    # string of global definitions, quote-protecting global alias names from
    # accidental expansion (as insinuated above).
#   alias_names_quoted=( \"${^ZESHY__ALIAS_NAMES}\" )
#   globals+="
#typeset -ga ZESHY__ALIAS_NAMES
#ZESHY__ALIAS_NAMES=( ${alias_names_quoted[@]} )"
#   print -r -- "globals: ${globals}"|less

    # Save the lists of zeshy-specific suffix aliases, functions, and globals.
    # Subsequently recompiling zeshy's user digest file in either the current
    # shell or a child of such shell requires such lists for deciding which
    # suffix aliases, functions, and globals to undefine prior to sourcing the
    # zeshy codebase. See the "MAIN" section of this component below.
    #
    # Omit the list of zeshy-specific aliases, whose alias names we safely,
    # manually interpolate into the definition of startup_zeshy_aliases() below.
    # Why? The reason is, of course, exceedingly subtle. Alias names include
    # global alias names (e.g., "or"), which zsh expands into the corresponding
    # global alias expansion *ANYWHERE* such names appear unquoted.
    # Unfortunately, the "typeset -p ZESHY__ALIAS_NAMES" command called below
    # fails to quote such names; hence, the "eval" statement evaluated below
    # expands a string resembling this:
    #
    #     typeset -gax ZESHY__ALIAS_NAMES
    #     ZESHY__ALIAS_NAMES=( is si or and not ... )
    #
    # into a string resembling this:
    #
    #     typeset -gax ZESHY__ALIAS_NAMES
    #     ZESHY__ALIAS_NAMES=( [[ ]] || && ! ... )
    #
    # This is clearly invalid zsh syntax.
#   ZESHY__GLOBAL_NAMES+=(
#       ZESHY__ALIAS_SUFFIX_NAMES
#       ZESHY__FUNCTION_NAMES
#       ZESHY__GLOBAL_NAMES
#   )

#ZESHY_CORE_HELP_GLOBALS+='
#string ZESHY_USER_ENTITY_NAMES_DIR
#
#Absolute path of the user-specific directory caching `zsh` scripts declaring and
#defining list globals containing the names of all `zeshy` entities of a
#particular type (e.g., aliases, functions, globals).
#'
#typeset -g ZESHY_USER_ENTITY_NAMES_DIR="${ZESHY_USER_CACHE_DIR}/names"

#   local globals; globals="${"$(\
#       typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")"// #typeset /typeset -g }"
#       typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")"//typeset /typeset -g }"
#       typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")"/(#s)[[:space]]#typeset /$'\t'typeset -g }"
#       typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")}"
#       typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")/(#s)(#m)[[:space]]#typeset /${match[1]}-g }"
#       ${${(f)"$(typeset -p -- "${ZESHY__GLOBAL_NAMES[@]}")"}/(#s)(#m)[[:space]]#typeset /${match[1]}-g }

    # The "typeset -p" command fails to print the "-g" modifier for global
    # variables. Since "typeset -x" commands do not imply such modifier under
    # zsh option "no_global_export", failing to print such modifier effectively
    # localizes such globals to the startup_zeshy_globals() function. Of course,
    # this constitutes a zsh bug. (Submit a report please.) In the meanwhile,
    # forcefully add the "-g" modifier to all output "typeset" commands.
#   local globals; globals="${$(\
#       typeset -p "${ZESHY__GLOBAL_NAMES[@]}")//typeset /typeset -g}"

    #FUXME: Tie *ALL* of the prior aliases to strings like so:
    #
    #   export -T ZESHY__GLOBAL_NAMES_STRINGS ZESHY__GLOBAL_NAMES
    #
    #Then under the last section "MAIN" below, if each such string global
    #exists, tie such global back into a temporary local (which we delete
    #immediately after use, I should think). For simplicity, reuse the *SAME*
    #local for each such conditional, making sure to empty it after each use.
    #First just get this working for globals; then extend to the other types.
    #FUXME: Agh! I can hardly believe it, but zsh fails to escape colons
    #embedded in tied list elements, which means that list ties are pretty much
    #unusable for general purpose work. That's pretty shoddy, but... well, it is
    #what it is. It means we need to explicitly convert such lists to strings at
    #the latest possible point -- probably
    #compile_zeshy_startup_aliases_and_globals(), yes? Such strings
    #should of course be exported as below.
    #FUXME: After careful thought, I've come to the obvious conclusion that it's
    #*STUPID* to export globals by default. No, really: why? We don't need to,
    #at all, aside from the $(typeset +gx) issue. Which is a tangible issue,
    #but... well, it's not worth the other headaches. It's just not. Which means
    #we'll need to implement a new function (probably) setting a list to all
    #currently declared globals. Such function will need to parse
    #$(typeset +g +) output -- annoying, but *CERTAINLY* doable. How about:
    #
    #   ZESHY__GLOBAL_NAMES=( ${(f)"$(typeset +g +)"##* } )
    #
    #Actually, that looks pretty efficient to me. It's a one-liner, so no
    #function needed. We'll need to actually *TRY* it of course. But, so far...
    #looks good. Damn. Why didn't I do this initially?

# This component recompiles the zeshy digest file by sourcing all components
# defining zeshy-specific zsh objects (i.e., aliases, functions, and globals)
# specific to the current user and system and then compiling exactly such
# objects into such digest. To decide exactly which objects to compile, this
# component subtracts the set of all zsh objects defined *AFTER* sourcing such
# components from the set of all zsh objects defined *BEFORE* sourcing such
# components: the difference between the two sets is exactly the set of all
# zeshy-specific objects to be compiled.
#
# By design, this requires no such objects to be defined before sourcing such
# components. If some (or all) such objects were defined before sourcing such
# components, the difference between the above two sets and hence the recompiled
# zeshy digest file would be essentially empty. To avoid such issues, undefine
# zeshy-specific objects defined by parent shells before such recompilation.

#FUXME: By design, zeshy no longer exports globals. I'm fairly certain neither
#aliases or functions are inherited by child shells (as confirmed by a thorough
#Googling), so... Really, just cut this. It's cruft, and unwieldy cruft at that.
#That said, we'll need to test this first (of course). Simple way is to just
#start a new unzeshified zsh shell under a running zeshy shell. Nothing should
#be inherited. (Double check!)
#FUXME: If we do cut this, there's a similar block of logic in "main" that
#probably needs cutting as well. *shrug*

#FUXME: Woops! We need to "unalias -s" everything in global map
#${ZESHY_ALIAS_SUFFUX_NAMES}, too.

#if (( ${+ZESHY__ALIAS_NAMES} )) {
#    unalias -- "${ZESHY__ALIAS_NAMES[@]}"
#}
#if (( ${+ZESHY__FUNCTION_NAMES} )) {
#    unfunction -- "${ZESHY__FUNCTION_NAMES[@]}"
#}

#FUXME: O.K.; I've pretty much had it with this approach. It's simply *TOO*
#unreliable, and has caused untold difficult-to-debug suffering. Why the
#unreliability? Well, child shells appear to inherit exported scalar but *NOT*
#list or map globals, meaning that ${ZESHY__GLOBAL_NAMES} will not be accessible
#to children but other scalar globals will be. There are two alternatives:
#
#* The conservative (and probably better) solution is to tie a string global to
#  ${ZESHY__GLOBAL_NAMES} -- say, ${ZESHY__GLOBAL_NAMES_STRING}. Children will
#  inherit such global. Then use the latter global here rather than former.
#  We'll have to do a bit of string splitting, but that's no worry.
#
#O.K.; yeah. I won't even bother documenting the more heavy-handed approach.
#Give the above a try and see where that gets us, eh?
#FUXME: Right. We'll need to extend the same solution to aliases and functions,
#above. Efficiency shouldn't be a problem, given the string tying approach.

# String and list of all alias, function, and global names temporarily tied
# together below.
#local IMPORTED_NAMES
#local -a imported_names

# Undefine globals *AFTER* undefining all objects listed by the prior lists,
# which themselves are globals and hence undefined with the other globals here.
#
# Globals *MUST* be undefined in a global context to have meaningful effect.
# While aliases and functions may be meaningfully undefined in a local context,
# there seems little point in doing so elsewhere. Centralize all logic here.
# See undefine_variable() and unfreeze_variable() for details on undefining
# globals (namely, why we call typeset() prior to unset()).
#if [[ -n "${ZESHY__GLOBAL_NAMES-}" ]] {
#   print -l "===ZESHY__GLOBAL_NAMES===" "${ZESHY__GLOBAL_NAMES}"

    #FUXME: Hell, this is silly. For consistency, just do everything the same.

    # Split such string on colons by retying such string and list. By zsh
    # mandate, global names *CANNOT* contain colons, rendering tying
    #
    # While there
    # exist alternative implementations (e.g., ${IFS}-based string splitting as
    # under set_list_to_string_split_on_character()), such implementations are
    # complicated by the fact that alias and function names can contain. See
    # string_and_list_tied_on_character() for further details.
#   local -T IMPORTED_NAMES="${ZESHY__GLOBAL_NAMES}" imported_names

    # Undefine such globals.
#    typeset +r -- "${ZESHY__GLOBAL_NAMES[@]}"
#    unset      -- "${ZESHY__GLOBAL_NAMES[@]}"
#   typeset +r -- "${imported_names[@]}"
#   unset      -- "${imported_names[@]}"
#   typeset -p -m "${imported_names[@]}"
#}

# Undefine such locals.
#unset -- IMPORTED_NAMES imported_names

    # Remove canonical zsh globals from such list. See
    # set_list_to_list_nonmatches() for further details.
#   ZESHY__GLOBAL_NAMES=( "${ZESHY__GLOBAL_NAMES[@]:#(chpwd|preexec)_functions}" )

    # Dismantled, this is:
    #
    # * "+f", listing newline-delimited function names.
    # * "(f)", splitting such list on newlines.

    # Dismantled, this is:
    #
    # * "+gx", listing newline-delimited globally exported variable names.
    # * "(f)", splitting such list on newlines.
#   ZESHY__GLOBAL_NAMES_OLD=( ${(f)"$(typeset +gx)"} )

    # Split such string on colons by retying such string and list. While there
    # exist alternative implementations (e.g., ${IFS}-based string splitting as
    # under set_list_to_string_split_on_character()), such implementations are
    # complicated by the fact that alias and function names can contain. See
    # Split such string on colons by retying such string and list. Note that not
    # initializing such string to itself erroneously induces such declaration to
    # initialize such string to the empty string. (Oh, zsh.) See
    # string_and_list_tied_on_character() for further details.
#   local -T ZESHY__GLOBAL_NAMES="${ZESHY__GLOBAL_NAMES}" ZESHY__GLOBAL_NAMES
    # See set_list_to_string_split_on_character() for further details.
#   IFS=':' read -r -d '' -A "${list_name__sltssoc1om}" <<<"${text__sltssoc1om}"

#FUXME: While we can of course continue to serialize this list of names,
#Lists cannot be

# Such files include:
#
#* All plain files in such directory.
#* If the current shell is interactive, all plain files in subdirectory
#  `if_interactive` of such directory.

#FUXME: This brings to mind a related problem with the proposed idea of *ALWAYS*
#sourcing "if_config/" parcels, even if the corresponding "~/.zeshy/config/"
#parcel already exists: documentation duplication. We'll need
#to explicitly ignore documentation declarations in all "zeshy.user.config://"
#parcels *IF* such entity (e.g., alias, function) has already been declared.
#FUXME: Hmmm. Yes. The more I genuinely consider it, sourcing "if_config/"
#parcels, even if the corresponding "~/.zeshy/config/" parcel already exists,
#seems increasingly a terrible idea. They're named "if_config" for a reason.

#FUXME: This snippet used to reside in "if_config/posix" until I found it
#sufficiently embarrassing. Frankly, we won't be implementing any functionality
#using this anytime soon. Nonetheless, store it here for the moment:
# ....................{ PREFERRED                          }....................
# Preferred terminal multiplexer. If commented, Zeshy selects the first such
# multiplexer installed on the current machine, if any.
#ZESHY_TERMINAL_MULTIPLEXER='tmux'
#ZESHY_TERMINAL_MULTIPLEXER='screen'
#ZESHY_TERMINAL_MULTIPLEXER='dtach'
#FUXME: This doesn't... seem quite right. Shouldn't this be uncommented. But,
#again, it's clearly incorrect. Another half-implemented feature, eh?
#ZESHY_TERMINAL_MULTIPLEXER="ZESHY_TERMINAL_MULTIPLEXER$(get_pathable_path_first tmux screen dtach)"

#Append the passed command to the end of the definition of ::precompile_zeshy(), called
#immediately before compiling Zeshy''s user digest file.
#FUXME: Rename to run_hook_on_zeshy_compile() and similarly everwhere else.
#(Make is *FAR* too ambiguous a verb here, frankly. Compile is quite concise and
#much more explanatory.)
# Dismantled, this is:
    #
    # * "**/*(-.)", recursively matching all plain files after resolving
    #   symbolic links.

        # If ignoring Zeshy's user directory, source such file from such overlay
        # without copying such file to such directory.
#       [[ -n "${ZESHY_DOT_DIR}" ]] || {
#           source -- "${source_filename}"
#           continue
#       }

    # Append Zeshy functions defined at the top level but redefined by the main
    # codebase (e.g., say(), defined by "main" and "always/io/output/say/say")
    # to the list of Zeshy-specific functions, if not already present. Not doing
    # so prevents the redefinitions of such functions from being compiled into
    # Zeshy's user digest file, thus exposing only the original definit version of such functions
    # defined at the top level.
    #
    # Ideally, no functions defined at the top level should be redefined by the main
    # codebase. In practice, doing so 

    # List of all configuration files. Dismantled, this is:
    #
    # * "**/*(-.)", recursively matching all plain files after resolving
    #   symbolic links.
#   local -a config_filenames; config_filenames=(
#       "${ZESHY_USER_CONFIG_DIRNAME}/"**/*(-.) )
#   [[ -o interactive ]] && config_filenames+=(
#       "${ZESHY_USER_CONFIG_DIRNAME}/if_shell_interactive/"*(-.) )

    # If at least one such script exists, source such scripts; else, avoid
    # calling source_zeshy_script() with no arguments throwing an exception.
#   (( ${#config_filenames} )) &&
#       for config_filename ("${config_filenames[@]}") {
#           say "sourcing configuration file \"${config_filename}\"..."
#           source -- "${config_filename}"
#       }

#FUXME: *GENIUS*. I've been gradually shifting to the following realization, and
#unsure why it took me quite so long to glom: *SOURCE CONFIGURATION FILES !ONLY!
#DURING DIGEST RECOMPILATION*. This should dramatically improve runtime
#efficiency, effectively caching all config file globals to
#zeshy_startup_globals() for subsequent restoration. Man, *MAKE THIS HAPPEN*.

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#Apallingly, failing to call the function defining alias
#is_zeshy_debug_and<> at the topmost level before calling functions
#expanding such alias below results in such alias temporarily reverting to its
#default definition only in such functions. (This is insanity, zsh.)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# ....................{ ALIASES ~ variable                 }....................
# Zeshy's user configuration files only export globals. While such files can
# declare locals and non-exported globals via traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Defer defining further aliases and documentation for
# these specific aliases to the main Zeshy codebase.
#alias\
#    string_global_export='export'\
#    boolean_global_export=string_global_export\
#    character_global_export=string_global_export\
#    integer_global_export='export -i'\
#    float_global_export='export -F'\
#    list_global_export='export -a'\
#    list_set_global_export='export -Ua'\

# "export -A" fails with error; "export -a", however, succeeds. *massive shrug*
#alias map_global_export='typeset -Agx'
#FUXME: After doing so, I'm not necessarily convinced there 
#FUXME: Shift elsewhere, per lengthy discussion in "digest". Honestly, why don't
#we just rename this component to "config" and shift the autoload_zsh_modules()
#*INTO THE MAIN ZESHY CODEBASE*, *PREPENDED* (emphasis on prepended) to
#startup_zeshy(). We *NEVER* call any such module functions here at the topmost
#level -- and even if we did, we'd just replace such implicit autoload with an
#explicit load of such module. Faster, simpler. Bam! :)
# after defining aliases
# required by such files. For efficiency, defer defining all other aliases to
# Zeshy startup in the proper Zeshy codebase and hence compilation into the
# Zeshy digest file. Redefine aliases defined below with such other aliases,
# guaranteeing that:
#
# * Zeshy records all aliases defined below in global list ${ZESHY__ALIAS_NAMES},
#   to be subsequently undefined if recompiling Zeshy in the current shell or a
#   child of the current shell. (See "compile" for gruesome details.)
# * Zeshy retrieves documentation for all aliases defined below in the same
#   manner as such other aliases. (See "help" for miserable details.)#
    # This matches all basenames of immediate files of directories in the function
    # path. (Since this is also the set of all autoloadable function names,
    # autoloading such basenames autoloads all autoloadable functions.) Oh!
#       print 'enabling debugging'
#       alias is_zeshy_debug_and='true &&'
    # * "/*", each immediate file and subdirectory of such directory.
    # * "N", ignoring non-extant files and subdirectories.
# ....................{ CONFIGURERS ~ main                 }....................
#   for autoloadable_function_name in ${^fpath}/*(N.:t); do
#FUXME: O.K.; because of this, it would seem prudent to split this component
#into two new components "config" and "digest": the former defining the above
#config-specific aliases, functions, and globals; the latter defining all
#remaining objects declared in this component. While I'm somewhat loathe to
#introduce yet another component into startup logic, the sheer inanity of this
#behavior suggests we could benefit from doing so. After all, we must admit
#that digest behavior is wholly separate from config file behavior.
#FUXME: If splitting as described, digest behavior could actually be readily
#merged into existing component "autoload". In such case, it could make sense
#to do the following, in which case no actual split need take case *WHICH IS
#ABSOLUTELY GREAT*:
#
#* Shift all digest behavior below to "autoload."
#* Shift all zsh module-specific behavior in "autoload" here.
#* Rename "autoload" to "digest" to better reflect its role.
#
#And that's it. *NO NEW TOPMOST COMPONENTS REQUIRED*, just a slight shuffling
#of existing functionality for improved understandability.
#FUXME: Yes. Make it so, I should think.

    #FUXME: Many of the functions this function calls redundantly test
    #"[[ -n "${ZESHY_DOT_DIR}" ]]" as well. Eliminate that.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0
    # Source Zeshy's user configuration files here, as such files define global
    # ${ZESHY_IS_DEBUG} tested by functions called immediately below.
#   setup_zeshy_configuration
#   which is_zeshy_debug_and
#   :output_line_if_debugging 'ok'

#FUXME: If splitting as described, rename the above function to source_zeshy_configuration(),
#which is really a much more sensible name in any case.
#FUXME: Eliminate.
#set_function_documentation setup_zeshy_digest_uptodate '
#void setup_zeshy_digest_uptodate(void)
#
#Assuming Zeshy''s user digest file to be up-to-date, implement placeholders for
#aliases and functions required only for compiling an outdated digest file.
#'
#function setup_zeshy_digest_uptodate() {
#    # Validate sanity.
#    (( # == 0 )) || :die 'Expected no arguments.'
#
#    # Implement placeholders with zsh builtin ":" (i.e., noop).
#    alias document_alias=':'
#    alias document_function=':'
#    alias document_global=':'
#}

#FUXME: O.K.; start using is_zeshy_debug_and<> everywhere. Yum!

#Parse the passed documentation, associating the global name prefixing such
#documentation with such documentation and globally exporting such global as the
#Zeshy-specific type prefixing such documentation. Expand this alias only before
#compiling Zeshy''s user digest file.
#FUXME: Use is_zeshy_debug_and<> instead. This requires we shift such
    #code to the very bottom of this component, but it makes everything nice and
    #orthogonal. So, go-go-go!
    #FUXME: This isn't right. Such configuration defines ${ZESHY_IS_DEBUG},
    #used *ABOVE*. Clearly, config files should be sourced *BEFORE* testing the
    #digest file, yes?

#FUXME: For both efficiency and readability, define a new alias resembling:
#
#  alias inquisitively='[[ -n "${ZESHY_IS_DEBUG}" ]] &&'    # or perhaps...
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUG}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "is_zeshy_debug_andging" or
#"is_zeshy_debug_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUG} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_debug_and='true ||'
#
#Brilliant! This reduces such test to a (hopefully) maximally fast no-op while
#ensuring it evaluates to true and hence does not throw exceptions.
#FUXME: After defining such alias, fixup all current references to
#${ZESHY_IS_DEBUG} - particularly at the top level.
    # Replacing all prior instances of '[[ -n "${ZESHY_IS_DEBUG}" ]] &&' in
    # the Zeshy codebase with 'is_zeshy_debug_and'
    #
    # If such configuration enables Zeshy debugging, expand such alias to the
    # empty string, thus unconditionally running the passed command.
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUG}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "is_zeshy_debug_andging" or
#"is_zeshy_debug_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUG} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_debug_and='true ||'

#       say 'digest outdated!'
#   print "ZESHY_USER_DIGEST_FILE_IS_OUTDATED: ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED}"
# non-zero only if such file was outdated at shell startup.
    #FUXME: Not quite right. We need to set
    #ZESHY_USER_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME to the current
    #time. Now how do we do that, again...?
#* The main user-specific Zeshy configuration file. This file contains theme
#  settings, which when edited require recompiling theme autoloads.
#* The main system-wide command directories (e.g., "/bin", "/usr/bin").
#  Installing or uninstalling commands requires recompiling command autoloads.

#           if [[ "${function_name}" == *'[or]'* ]]; then
#FUXME: Shift :digest_zeshy.is_outdated() here and cache the result into a global
#variable, as subsequent components will also need reference such result. Shift
#document_function() here as well. If Zeshy's digest file is outdated, define
#document_function() and document_global() as below (i.e., nest such function
#and alias definitions in a code or function block run only if outdated);
#otherwise, define both document_function() and document_global() to be aliases
#expanding to ":". Genius, no? This should ensure we incur no measurable
#overhead when sourcing configuration files and *NOT* recompiling such digest.

#Processes assigned to class 3 are idle-only processes scheduled when no other
#process performs I/O. Class 3 processes are likely to suffer scheduling
#starvation and hence appropriate only for background daemons.
#FUXME: Document all such globals.
#document_global '
#list ZESHY_IONICE_CLASS_HIGH
#
#"ionice"-specific highest and lowest priority pairs consisting of class and
#ioniceness for I/O scheduling of processes. Processes assigned to class 3
#signify "idle-only" processes to be scheduled only when no other process
#performs I/O. Since such processes are likely to suffer scheduling starvation,
#omit class 3 from consideration.
#; assigning class 2 to the default lowest priority class improves
#process responsiveness.
#'

#       '/bin' '/sbin' '/usr/bin' '/usr/sbin' "${ZESHY_USER_CONFIG_DIRNAME}"/{,*}) {
    #FUXME: We may need to explicitly unset ${documentation__dg} *ONCE* after
    #sourcing all configuration files. We'll know whether we need to do so based on
    #whether or not the current environment has become polluted with such variable
    #after entering a new Zeshy shell.

#FUXME: Should probably be pushed into "main". Ideally, this could allow us to
#obsolete the lower-level set_*_documentation() family of functions in favor of
#the higher-level document_*() family of functions. It will increase the size of
#"main", but probably not by quite as much as thought -- after all, we'd also be
#removing a sizable block of existing functionality: set_*_documentation().
#Naturally, this requires moving document_*() and all conditional logic defining
#such functions from here to "main".
#FUXME: Since we'd like to declare such functionality as "early" as possible, we
#should probably declare "set -e" at the top of "main" and then inject such code
#immediately after "setopt" calls (i.e., before defining :die(), say(), and
#friends). This implies we should undo "set -e" immediately prior to defining
#die(). (I recall we do something similar; just double-check us up.)
#FUXME: Actually, the current method isn't terribly inappropriate. Steady as she
#goes, folks!

        # Nonetheless, reuse the same glob expression for simplicity.
        # Hence, this glob expression matches more strictly than the function
        # glob expression above. Dismantled, this is:

#FUXME: Hopefully superfluous, after implementing document_global() properly.
#Excise after excising from all config files.
    # If Zeshy's user digest file is up-to-date, define placeholders for
    # runnables required only for compiling an outdated digest file.

    # * Loading Zeshy's user directory and
#   [[ -n "${ZESHY_DOT_DIR}" &&\
#FUXME: This looks *EXTREMELY* heavyweight. I'm concerned about expanding such
#alias as much as we inevitably will be. Given that, I'm currently inclined to
#reconsider aliasing document_global=':' when the digest file is not outdated.
#This requires we retain variable declarations, which is probably a good idea.
#   [[ -n "${(k)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[(r)${match[1]}]-}" ]] ||
    #FUXME: Insufficient. document_global() needs to *AT LEAST* declare such
    #global based on the passed help string.
    #FUXME: In reflection, declaring such global is basically the entirety of
    #document_global(). We'd might as well just define the whole thing as is.
#   alias document_global=':'

    # Parse variable helpstring here. Since the first line is something like:
    #
    #     string ZESHY_ZSTRANGE
    #
    #     I''m a strange global. (But here I am.)
    #
    # ...this implementation can parse that line and produce the corresponding
    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
    # implementation uses a dictionary lookup on the first shell word of such
    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
    # See initial definition above.

#: e.g.,
  # Declare ${THIS_IS_A_MAP} to be a global map.
# >>> ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[map]} THIS_IS_A_MAP
#FUXME: Excise after converting all current configuration file global
#declarations to the aliases below.
#FUXME: Hmm; actually, we'll have to replicate the current document_function()
#function into a new document_global() function defined here. And since we're
#defining that function here, we'd might as well move document_function() from
#"compile" here as well for sanity. Shouldn't be terribly difficult. The tedious
#aspect will be in converting existing configuration files to call such
#function. Well... no time like the present, yes?
#FUXME: Ah; hmm. I note that we *COULD* define:
#alias document_global='
#{
#    # Parse variable helpstring here. Since the first line is something like:
#    #
#    #     string ZESHY_ZSTRANGE
#    #
#    #     I'm a strange global. (But here I am.)
#    #
#    # ...this implementation can parse that line and produce the corresponding
#    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
#    # implementation uses a dictionary lookup on the first shell word of such
#    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
#    # See initial definition above.
#} <<<'
#I am mildly concerned about the efficiency of sourcing configuration files with
#numerous such alias expansions. If efficiency becomes a problem, just
#implement a separate document_global() function. That then leaves us with code
#resembling:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#string_global_export ZESHY_ZSTRANGE='lululululuuuuuu"
#
#The above alternative leaves us with:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#ZESHY_ZSTRANGE='lululululuuuuuu"
#
#FUXME: O.K.; so, in either case, we have a document_global() runnable. The
#latter case is more concise and hence preferable, but somewhat less efficient
#due to parsing overhead. Let's see how much it costs us. Simple experiment:
#
#* Temporarily force :digest_zeshy.is_outdated() to return_false.
#* Copy all of the existing config files to a new dir under "old/".
#* Migrate existing config files to call document_global().
#* Time startup under both! Hopefully, the overhead isn't hideously noticeable.
#FUXME: The following aliases *SHOULD* already exist under "always/00-setup".
#Ensure this to be the case; then, excise such aliases here.

#       set_global_documentation "${match[2]}" "${documentation}"
# print_function_documentation() to subsequently print such documentation.
#       then set_function_documentation "${match[1]}" "${documentation}"
# ....................{ EXPORTS                            }....................
# Zeshy configuration files declare only global exports. While such files can
# declare locals and non-exported globals with traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Delay defining all remaining Zeshy aliases to the
# main Zeshy codebase.

#:digest_zeshy.is_outdated() returning true. Yes:
#this is somewhat hackier than we prefer, but the alternatives are uglier.
#   local -a path_plus_zeshy
#   path_plus_zeshy=( "${path[@]}" "${ZESHY_USER_CONFIG_DIRNAME}/zeshy" )
#   local path_plus_zeshy_glob="${(j~|~)${(q@)path_plus_zeshy}}"
#   zeshy_dependency_mtimes+="$(zstat +mtime "${path_plus_zeshy_glob}")"

    #FUXME: Definitely not right. We absolutely want to do this *AFTER*
    #"always/shell/profile" establishes the global list "path"; then, replace
    #the awkwardly hard-coded paths below with the following:
    #
    #    for dependency_pathname ("${path[@]}" "${ZESHY_USER_CONFIG_DIRNAME}"/{,*}) {
    #
    #Concise; awesome; and exactly what's needed. We'll probably just want to
    #extricate the setting of the ${PATH} currently performed by
    #"always/shell/profile" to somewhere directly under "src/" -- perhaps this
    #component? There's really no reason to perform such logic *ONLY* under a
    #login shell; ideally, the ${PATH} should always be "fixed up" on Zeshy
    #startup. After all, either the user or a script could destroy the ${PATH}
    #after login, in which case we really wouldn't want to trust its current
    #setting. So, fix it up to guarantee sane behavior.
    #FUXME: We can substantially optimize this, I believe. Cease appending
    #modification times to list ${dependency_mtimes}; instead, perform a single
    #call to $(zstat +mtime ...) with a single argument selecting the oldest
    #such path that exists:
    #
    # zstat +mtime (if_shell_interactive|posix)(e:'[[ -e $REPLY ]]':om[1])
    #
    #That works at the shell. Given that, how about a generalization:
    #
    # zstat +mtime (~dependency_pathname_glob)(e:'[[ -e $REPLY ]]':om[1])

#
    # Dismantled, this is:
    #
    # * "${ZESHY_USER_CONFIG_DIRNAME}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
#   local dependency_pathname_glob
#   : ${dependency_pathname_glob::=\'${^path}\'}
#   dependency_pathname_glob="${path}|${ZESHY_USER_CONFIG_DIRNAME}/zeshy"
#   ="${path}|${ZESHY_USER_CONFIG_DIRNAME}/zeshy"

    #FUXME: Mostly right. Note that for safe generality, however, reserved glob
    #characters in pathnames should be prefixed by "\" to prevent usage as glob
    #characters. Fine for now, but of some importance later.
#   local -a path_quoted
#   path_quoted=( \'${^path}\' "${ZESHY_USER_CONFIG_DIRNAME}/zeshy" )
#   local path_quoted_glob="${(j:|:)path_quoted}"

    #FUXME: Rename "ZESHY_IS_DEBUG" to "ZESHY_IS_IN_DEVELOPMENT". :)
    # * "${ZESHY_USER_CONFIG_DIRNAME}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
    # If either or configuration directory do not exist or
    # the latter exists but is empty, mark such file "outdated."
    # Ensure the current user's Zeshy configuration directory and all non-extant
    # parents of such directory exist.
#   command mkdir -p -- "${ZESHY_USER_CONFIG_DIRNAME}"

    # specifically including:
    #
    # * All plain files in such directory.
    # * If the current shell is interactive, all plain files in subdirectory
    #   "if_shell_interactive" of such directory.
    #
    # If the current shell is interactive and such directory contains a
    # subdirectory "if_shell_interactive" containing at least one Zeshy script,
    # source such scripts as above.
#   config_filenames=( "${ZESHY_USER_CONFIG_DIRNAME}/if_shell_interactive/"*(-.) )

# Booleans are false if set to the empty string and otherwise true.
#
# For simplicity, disable or enable booleans by commenting or uncommenting the
# lines on which they appear (e.g., prefixing such lines with "#" or deleting
# such prefix).

    # subsequent logic
    # sources the default versions of such files.

#FUXME: All of the magic constants defined in "global" should be declared
#frozen, perhaps suggesting new "string_global_constant",
#"boolean_global_constant", and so on types in "alias".

#FUXME: I'm not terribly fond of enabling booleans by setting them to 1. Avoid
#such magic by defining the following magic in "global":
#
#string_global_constant ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=''
#
#Then use below: e.g.,
#ZESHY_IS_DEBUG=${ZESHY_BOOLEAN_TRUE}

# void string_global_export(string variable_name)
#
# Globally declare a string exported to the calling shell.
#alias string_global_export='export'

# void boolean_global_export(string variable_name)
#
# Globally declare a boolean exported to the calling shell.
#alias boolean_global_export='export'

# void integer_global_export(string variable_name)
#
# Globally declare an integer exported to the calling shell.
#alias integer_global_export='export -i'

# void float_global_export(string variable_name)
#
# Globally declare a float exported to the calling shell.
#alias float_global_export='export -F'

# void list_global_export(list variable_name)
#
# Globally declare a list exported to the calling shell.
#alias list_global_export='export -a'

# void map_global_export(map variable_name)
#
# Globally declare a map exported to the calling shell.
#alias map_global_export='typeset -Agx'   # "export -A" oddly fails with error;
                                          # "export -a" succeeds, however (!?!)
        # Source such file.
#       say "sourcing \"${target_filename}\"..."
#       source -- "${target_filename}"
    #FUXME: Right. We can drastically reduce the size of the "config" component,
    #now that we've made the load order much more sensible. Doing so permits us
    #to shift that function here, which seems sensible. The fewer components the
    #better, I should think.
#   source -- "${ZESHY_HOME}/config"

#, a hard
    # requirement due to *THIS* function defining the global list of all Zeshy
    # functions. (Fugly, fugly, fugly. But there seem little sane alternatives.)
    # While order should *NOT* matter here, can we ever really know?
#, and source such files.
#   ZESHY__GLOBAL_NAMES_NEW=( ${${(f)"$(typeset +g +)"}##* } )
#FUXME: Add support for sourcing all files directly under an overlay *IF* such
#overlay is not the main overlay. An important user convenience, particularly for
#smaller overlays not requiring a tree structure.
    # Make startup_zeshy() and friends.
#   append_precompile_zeshy_command precompile_zeshy_functions_startup

    # Make startup_zeshy_aliases() and startup_zeshy_globals() *AFTER DEFINING
    # ALL OTHER ZESHY-SPECIFIC FUNCTIONS*. This is a hard requirement, as this
    # function necessarily defines the list of such functions. (Fugly, fugly,
    # fugly. But there seem little sane alternatives, in this case.)
#   append_precompile_zeshy_command\
#       compile_zeshy_startup_aliases_and_globals
# [[ && -o interactive ]] &&
# List of commands to be run immediately before compiling Zeshy's digest file.
#export -Ua ZESHY__HOOKS_RUN_ON_ZESHY_PRECOMPILE
#FUXME: Rename to append_precompile_zeshy_command(). Much more natural (...the
#most important "::precompile_zeshy" part comes first) and in keeping with nomenclature
#elsewhere.
    # If such overlay is *NOT* an overlay root (i.e., is neither the topmost
    # system-wide or user-specific overlays), append all scripts in such
    # overlay's directory.
#   [[ "${overlay_dir}" != ("${ZESHY_HOME}"|"${ZESHY_USER_OVERLAY_DIR}") ]] &&
#   for filename ("${overlay_dir}"/${~ZESHY__SCRIPT_FILENAME_GLOB}) {
#       print "autoload filename: ${filename}"
#   }
#FUXME: *UGH*. The ${ZESHY_UNIT_*} globals are no longer recorded as Zeshy
#globals. Hmm; I'm beginning to think we need, by default, to delete *ALL*
#globals matching ${ZESHY_*} *NOT* previously declared by "main", "config", or
#"autoload". Question is: how can we do this without incurring substantial
#complexity and/or fragility costs? You know, I think I'm happy to pay a slight
#efficiency cost here... but wait. You know, this is all symptomatic of a
#larger problem. If globals aren't being persisted correctly, it stands to
#reason neither are aliases or functions. Something subtly terrible is
#happening somewhere -- and we really need to fix it before releasing even an
#alpha version. To begin debugging, run "which startup_zeshy_globals"
#immediately after logging in (i.e., in a Zeshy login shell). What's the
#result? I half-guarantee it's substantially messed up. If that's *NOT* the
#case, then something may be going wrong during shell instantation and
#inheritance. Mmmhmmm.
# * On editing the "ZESHY_THEME" global in the "~/.zeshy/config/main"
#   configuration file from the default "vanilla" to, say, "cookiedough", Zeshy
#   supplants the default theme symbols it exports with those from the
#   "cookiedough" theme.
#       overlay_theme_dir="${overlay_dir}/if_theme/${ZESHY_THEME:-vanilla}"
    # Append the subdirectory of this overlay's theme directory matching the
    # user's currently configured theme to the overlay stack, if found.
#   [[ -d "${overlay_theme_dir}" ]] &&
#       ZESHY__OVERLAY_DIRNAMES+="${overlay_theme_dir}"

        # If Zeshy's user configuration directory does not already contain
        # such file, copy such file from such overlay to such directory.
#       [[ ! -f "${target_filename}" ]] && {
#to Zeshy's user-specific configuration directory
# Since upgrading occurs after digest
    #compilation but "~/.zeshy/config/zeshy" would already exist,
    #${ZESHY_USER_THEME} would not be found here, provoking a zsh error (e.g.,
    #"no such variable"). Simplest way to fix this:
    #
    #* Behave defensively. Never assume a global setting to exist (e.g., always
    #  append "-" to parameter expansions). This probably needs to happen
    #  anyway, for safety and robustness. Make it so!
#FUXME: It'd be nice to harmonize config dirs "/usr/share/zeshy/src/if_config"
#and "~/

#Prepare all user configuration files in the passed overlay directory. Namely:
#
#* Recursively copy all such files not found in Zeshy''s user-specific
#  configuration directory to such directory.
#* Source such files.
    #FUXME: Rather than print each overlay, it would be *MUCH* more concise and
    #hence reasonable to only print the set of all sourced overlays after the
    #fact. To do so, simply iterate local list ${ZESHY__OVERLAY_DIRNAMES} after
    #sourcing all such overlays. We never remove overlays from such stack, so
    #just iterate such stack after sourcing, ignoring the first two elements on
    #such stack (i.e., "/usr/share/zeshy/src" and "~/.zeshy/src"). For all other
    #elements:
    #
    #* Determine whether such overlay is a suboverlay of
    #  "/usr/share/zeshy/src" or "~/.zeshy/src".
    #* In either case, strip the prefixing 
    # "/usr/share/zeshy/src" or "~/.zeshy/src".
    #
    #FUXME: Nonsense. *WAY* too complex. O.K.; only spit this out if we're
    #debugging. There. DONE.
    #FUXME: Shift into a new function print_shell_variables().

    # Validate sanity.
    # Run each such command.
#Perform pre-compilation functionality subsequently defined in the main
#Zeshy overlay.

#document_function '
#void compile_zeshy_digest_to_precompile_zeshy(void)
#
#Perform last-minute functionality prior to compiling Zeshy''s digest file.
#In particular, make the final functions to be compiled into such file.
#'
#function compile_zeshy_digest_to_precompile_zeshy() {
#    # Validate sanity.
#    (( # == 0 )) || :die 'Expected no arguments.'
#}

    # Perform post-compilation functionality subsequently defined in the main
    # Zeshy overlay.
#   append_precompile_zeshy_command precompile_zeshy_functions

    # Perform last-minute functionality prior to compiling Zeshy's digest file.
    # In particular, make the final functions to be compiled into such file.

#Prepare the current shell environment for digest compilation.
#Perform initialization prior to compiling Zeshy''s digest file.
#Dynamically synthesize functions to be compiled into the Zeshy digest file.
    # Synthesize the final set of Zeshy-specific functions.
#   precompile_zeshy_functions

#FUXME: Define document_function() here to strip the function name from the
#passed documentation, ignoring all prefixing whitespace. See "zeshy/help/help"
#for existing globs to assist doing so.
#FUXME: Actually run such commands -- somewhere near the tail of this file, yes?

    # If such documentation is prefixed by optional whitespace followed by
    # non-optional function prototype consisting of non-empty return type, non-
    # empty whitespace, non-empty function name, and left parens "(", match the
    # Get the function name prefixing such documentation.
    # Glob matching any number of non-newline characters followed by a newline,
    # thus matching the rest of a line.
    # If such documentation begins with optional whitespace followed by a
    # mandatory function prototype, match the function name from such
    # prototype.
#   line_glob="[^${newline}]#${newline}"
    # Newline character, abbreviated for readability.
#   local newline=$'\n'
#   [^$'\n']#$'\n'

# ....................{ GLOBALS                            }....................
    # * Source such file.
    # * Copy such file to Zeshy's user configuration directory, if not already
    #   containing such file.
    # If the current shell is interactive and loading the Zeshy user directory,

    #FUXME: Need to explicitly persist such maps to the current digest file.
    # Maps from Zeshy-specific aliases, functions, and globals to the absolute
    # paths of the Zeshy components defining such objects. While this Zeshy
    # component requires no such maps, others -- especially, the Zeshy help
    # component, do. Hence, this component sets such maps on behalf of other
    # components.
#   export -A\
#       ZESHY_ALIAS_NAME_TO_FILENAME\
#       ZESHY_ALIAS_SUFFIX_NAME_TO_FILENAME\
#       ZESHY_FUNCTION_NAME_TO_FILENAME\
#       ZESHY_GLOBAL_NAME_TO_FILENAME

#       compile_zeshy_digest_source "${script_filename}"
    #FUXME: Hmm; the last iteration of the above for loop sets such lists
    #already. 'tis a minor optimization at best, but... *shrug*

# void compile_zeshy_digest_source(string script_filename)
#
# Source the passed script as contributing to the current compilation of Zeshy's
# digest file. In particular, record all aliases, functions, and globals newly
# defined by such script.
#function compile_zeshy_digest_source() {
#   ZESHY__ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY__ALIAS_SUFFIX_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY__GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Source such script.
#   say "sourcing \"${script_filename}\"..."
#   source "${script_filename}"
#   say "sourced \"${autoload_function_filename}\"."

#   ZESHY__ALIAS_NAMES_NEW=( ${(f)"$(alias +)"} )
#   ZESHY__ALIAS_SUFFIX_NAMES_NEW=( ${(f)"$(alias +s)"} )
#   ZESHY__GLOBAL_NAMES_NEW=( ${(f)"$(typeset +gx)"} )

    # Obtain all aliases, functions, and globals newly defined by such script.
#   ZESHY_SCRIPT_ALIAS_NAMES=(
#       "${ZESHY__ALIAS_NAMES_NEW[@]:|ZESHY__ALIAS_NAMES_OLD}" )
#   ZESHY_SCRIPT_SUFFIX_ALIAS_NAMES=(
#       "${ZESHY__ALIAS_SUFFIX_NAMES_NEW[@]:|ZESHY__ALIAS_SUFFIX_NAMES_OLD}" )
#   ZESHY__SCRIPT_FILENAME_GLOBAL_NAMES=(
#       "${ZESHY__GLOBAL_NAMES_NEW[@]:|ZESHY__GLOBAL_NAMES_OLD}" )

    # Filter canonical zsh globals from the list of Zeshy-specific globals.
#   ZESHY__SCRIPT_FILENAME_GLOBAL_NAMES=( "${ZESHY__GLOBAL_NAMES[@]:#${~ZSH_GLOBAL_NAMES_GLOB}}" )

#   ZESHY_FUNCTION_NAME_TO_FILENAME[
#}

        # Source such script.
#       say "sourcing \"${script_filename}\"..."
#       source "${script_filename}"
#       say "sourced \"${autoload_function_filename}\"."

#       ZESHY_FUNCTION_NAME_TO_FILENAME[
        # Load the functions this file defines for subsequent compilation.
    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file.
#FUXME: Add support for storing defined globals and aliases in a single
#startup_zeshy_globals() function. Naturally, do so prior to calling
#precompile_zeshy_functions_startup().

#   {
#       print -rl -- "================[old function names]================" "${ZESHY__FUNCTION_NAMES_OLD[@]}"
#       print -rl -- "================[new function names]================" "${ZESHY__FUNCTION_NAMES_NEW[@]}"
#       print -rl -- "================[dif function names]================" "${ZESHY__FUNCTION_NAMES_NEW[@]:|ZESHY__FUNCTION_NAMES_OLD}"
#   } | less
    # The alias() builtin lists only regular and global names with option "+"
    # and only suffix alias names with option "+s". Split the output of both on
    # newlines to get all regular, global, and suffix aliases.

    # Delete all Zeshy-specific globals defined by and imported from the parent
    # shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
    # delete such globals results in a subtle issue when compiling the Zeshy digest
    # file, which persists such globals to startup_zeshy_globals() by differencing
    # the lists of globals defined before and after such compilation. Failing to
    # delete such globals ensures the two lists to be effectively identical, thus
    # preventing persistence of Zeshy globals into the Zeshy digest file.
    #
    # See undefine_variable_matching() for details on variable deletion.
    #local zeshy_home="${ZESHY_HOME-}"

    #FUXME: Hmm; should use unexported globals by default, I think.
    #Unfortunately, getting a list of unexported globals appears to be somewhat
    #more difficult. The following should work, assuming globals without
    #whitespace (which I believe may be prohibited by POSIX, yes?):

    # Zeshy declares globals to be globally exported (e.g., "typeset -gx") rather
    # than merely as globals or exports (i.e., "typeset -g" or "typeset -x"). For
    # disambiguity, list only the former.
#   ZESHY__GLOBAL_NAMES_OLD=( ${(f)"$(typeset +x)"} )
# to the current user and then compiles only such 
# selects which such aliases, functions, and globals 
# recompiles all aliases, functions, and globals defined only *AFTER*
# sourcing befor
#
# determines which currently defined zsh aliases, functions, and globals to The
# difference of 
# Zeshy decides
#
# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
    #FUXME: Unsure this much matters, now.
    # Recompilation optimizations require Zeshy to *NOT* have been autoloaded at
    # this point... Throw an exception if Zeshy has been. While this should
    # never be the case, one can't be too careful in a bitwise world.
#   typeset -f get_zeshy_version &>/dev/null and
#       :die "get_zeshy_version() and hence Zeshy already autoloaded"

    # Undefine all globals defined by sourcing Zeshy. Why? The reason is subtle;
    # the logic flows like butter. Zeshy may (and usually does) declare some
    # such globals to be read-only. Understandably, zsh prints errors on
    # attempting to redefine such globals. However, Zeshy's subsequent calling
    # of startup_zeshy() and hence startup_zeshy_globals() attempts to do just
    # that! Undefining such globals here permits there subsequent redefinition.
    # ('tis all a tad silly, but so goes life in the tranche of code trenches.)
#   undefine_global "${ZESHY__GLOBAL_NAMES[@]}"
#   typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#   [[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and print 'hmmmmm'
    #FUXME: Fairly certain we don't want to export. No point, really. "main"
    #just blows away all imported Zeshy globals, anyway. Just revert to '+g' in
    #"alias", yes?

#   $(join_list_on_newline ZESHY__ALIAS_NAMES)
#   $(join_list_on_newline ZESHY__GLOBAL_NAMES)
    # Convert global lists of commands to be run on startup into newline-
    # delimited strings to be interpolated into the functions created below.
#   string startup_zeshy_aliases startup_zeshy_globals
#   startup_zeshy_aliases="$(join_list_on_newline ZESHY__ALIAS_NAMES)"
#   startup_zeshy_globals="$(join_list_on_newline ZESHY__GLOBAL_NAMES)"

    # Make such functions.
#   eval "function startup_zeshy_aliases() {
#   ${startup_zeshy_aliases}
#}"
#   eval "function startup_zeshy_globals() {
#   ${startup_zeshy_globals}
#}"

    # List of all currently declared aliases, functions, and exported variables
    # declared after sourcing and compiling the Zeshy codebase.
    # Synthesize additional functions after sourcing all Zeshy scripts
    # applicable to the current user (above) but before compiling the Zeshy
    # digest file (below). Such functions have dynamic definitions dependent on
    # global variables set while sourcing such scripts.
# (i.e., subsequent to
    # recursively sourcing Zeshy and hence declaring Zeshy functions)
#   is -d "${ZESHY_HOME}" si or
#       :die "Zeshy home \"${ZESHY_HOME}\" not found"

#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.)
    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with difference_lists_into() and
    #intersect_lists_into() functions accepting a third arg: the target list.

    # Append:
    #
    # * All subdirectories in this overlay's command directory matching commands
    #   in the user's current $PATH to the overlay stack.
    # * All files in this overlay's command directory matching such commands to
    #   the list of autoloadable files.
#   is -d "${overlay_command_dir}" si and {
        # List of all paths in this overlay's command directory corresponding to a
        # currently installed executable file in the $PATH. Dismantled, this is:
        #
        # * "${ZESHY_AUTOLOAD_COMMAND_DIR}/"*, listing each file in Zeshy's
        #   command directory.
        # * "(e{[[ ... ]]})", excluding files failing the following test:
        #   * "$REPLY", the current file.
        #   * ":t", the basename of such file.
        #   * ":c", the absolute path to a command in the $PATH with such name.
        #   * "== /*", true only when ":c" succeeds in finding such a command.
        # * "or true", ignoring failure (if ":c" fails finding such a command).
#       list overlay_command_paths; overlay_command_paths=(
#           "${overlay_command_dir}/"*(e{'[[ $REPLY:t:c == /* ]]'})
#       ) or true

#       # Append all files in this directory to the list of autoloadable files.
#       ZESHY_OVERLAY_FILENAMES+=( "${^overlay_command_paths[@]}"(.) )

#       # Append all directories in this directory to the overlay stack.
#       ZESHY__OVERLAY_DIRNAMES+=( "${^overlay_command_paths[@]}"(/) )
#   }

#FUXME: Sourcing configuration files *REALLY* needs to happen prior to
#compilation, for obvious reasons. O.K.; so, that's taken care of. But we need
#to also ensure that if we *DON'T* perform compilation we still source such files.
#Do:
#    source "${ZESHY_USER_CONFIG_DIRNAME}/"*

    # If "lsb_release" is installed, run it to obtain the distro name of the
    # current operating system. Most modern distros provide such executable
    # for exactly this purpose. While crude alternatives to "lsb_release" do
    # exist (e.g., globbing for filenames matching /etc/*release), it hardly
    # seems worth the buggy effort so early in the bootstrap process.
    # Dismantled, this is:
    #
    # * "${:-lsb_release}", expanding to the string "lsb_release".
    # * "${...:c}", expanding to the absolute path of "lsb_release" if installed
    #   in the current $PATH or only "lsb_release" otherwise.
    # * "-x", returning true if such path is executable and hence installed.
    #   Unless the current directory contains an executable "lsb_release", this
    #   returns true only if ":c" expanded to an absolute path.
#   if is -x "${${:-lsb_release}:c}" si; then
        # Lowercase the distro name for dirname comparison.
#       string distro_name autoload_distro_dir
#       distro_name="${(L)$(lsb_release -si)}"
#       autoload_distro_dir="${ZESHY_AUTOLOAD_DISTRO_DIR}/${distro_name}"
#       print "autoload_distro_dir: ${autoload_distro_dir}"

        # If Zeshy provides distro-specific components, append distro-
        # specific dirnames and filenames to the corresponding lists.
#       if is -d "${autoload_distro_dir}" si; then
#           ZESHY_AUTOLOAD_DIRNAMES+="${autoload_distro_dir}/always"
#           ZESHY_OVERLAY_FILENAMES+=(
#               "${autoload_distro_dir}/if_pathable/"*(e{'[[ $REPLY:t:c == /* ]]'})
#           ) or true
#       fi
#   fi
    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   ZESHY_AUTOLOAD_DIRNAMES+="${ZESHY_AUTOLOAD_CORE_DIR}"

#   string overlay_dir="${1}"
#   is -d "${overlay_dir}" si or
#       :die "\"${overlay_dir}\" not found or not a directory"
#   string source_filename="${1}" target_filename basename
#   is -f "${source_filename}" si or
#       :die "\"${source_filename}\" not found or not a file"
#   basename="$(basename "${source_filename}")"
#   target_filename="${ZESHY_USER_CONFIG_DIRNAME}/${basename}"

    # If not found, make the user-specific Zeshy configuration (and hence dot)
    # directory and file.
#   is -d "${ZESHY_USER_CONFIG_DIRNAME}" si or mkdir -p "${ZESHY_USER_CONFIG_DIRNAME}"
#   is -f "${target_filename}" si or {
#       say "fabricating \"${target_filename}\"..."
#       cp "${source_filename}" "${ZESHY_USER_CONFIG_DIRNAME}/"
#   }

    #FUXME: We need to do this in "src/import", instead. Probably just:
    #source "${ZESHY_USER_CONFIG_DIRNAME}/"*
    # Import such file, hopefully defining all globals declared above.
#   source "${target_filename}"
    # List of directories recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.
#   list ZESHY_OVERLAYS
#   ZESHY_OVERLAYS=( "${ZESHY_AUTOLOAD_CORE_DIR}" )

    # Recursively compile the Zeshy codebase specific to current system and user
    # state starting from (in order):
#compile_zeshy_theme() {
#}

    # List of Zeshy overlays (i.e., system- and user-specific directories
    # obeying the same structure as Zeshy's top-level "./src" directory). All
    # files and directories in a Zeshy overlay are ignored except those with the
    # following Zeshy-specific names:
    #
    # * "always", a directory recursively containing only:
    #   * Subdirectories with arbitrary names and nesting, purely for
    #     organizational purposes. (Optional.)
    #   * Zeshy scripts, to be unconditionally compiled into Zeshy's digest
    #     file. Scripts may reside directly in the top-level "always" directory
    #     or under optional subdirectories. In either case, Zeshy automatically
    #     finds and compiles all zsh functions in all such files.
    #
    # recursively containing zsh scripts containing
    # autoloadable functions to be compiled into Zeshy's digest file.

    #FUXME: O.K.; technically, this works -- but not here, as we have yet to
    #autoload Zeshy. This is a fairly complex operation. (Can we reduce it to
    #more efficient zsh builtins and ideally simply glob matching?)
    # Determine whether or not this process is running is a cronjob. This is
    # adapted from this itworld.com article, "Am I being run by cron?":
    #        http://www.itworld.com/Comp/3380/nls_unixcron041209/index.html
    #
    # Do this prior to saying imports, as the say() function requires this.
#    string cron_pids="$(pgrep -x cron)"
#    integer grandparent_pid="$(ps -eo ppid,pid= | grep " ${PPID}$" | awk '{print $1}')"
#    ZESHY_IS_CRONJOB="$(one_if match_multiline "^${cron_pids}$" "${grandparent_pid}")"
#   echo "cron: ${ZESHY_IS_CRONJOB}; cron_pids: ${cron_pids}; gpid: ${grandparent_pid}"

# All monitoring and modification is silent, efficient, and entirely automatic.
# to accomodate
# such changes. Such are silent, efficient, and entirely automatic.
# efficiently monitors such state for changes,      # * "${distro_command:c}", expanding to the absolute path of
    #   "lsb_release" if installed or only "lsb_release" otherwise.
#   string distro_command='lsb_release'
#   if is -x "${distro_command:c}" si; then
#FUXME: This is concise enough now to be merged back into "module", which should
#incidentally be renamed "load" (...I suppose).

    #FUXME: Test for pathological cases: namely, if there *IS* a Zeshy function
    #currently declared that shouldn't be (e.g., get_zeshy_version()). In such
    #case, I'm unsure what the proper response is. We currently th
    #FUXME: See "gwydden/output" for "TODO" comments on substantially
    #improving the theme support.

# ....................{ AUTOLOADS                          }....................
#FUXME: Keep the old method about, for a bit.
    # List set of autoloadable function names defined in such listed files.
#   list_set autoload_function_names
#   say "recursively sourcing \"${ZESHY_HOME}\"..."

    # Load "mapfile", a core zsh module mapping file contents to map values.
    # It's both brilliant and efficient, an unhappily rare combination. It's
    # also remarkably dangerous, since accidentally unsetting keys from this
    # map deletes the corresponding files. Hence, we immediately unload this
    # module after use.
#   zmodload zsh/mapfile

    #FUXME: Terrible! Utterly. When enabled, this sporadically fails with an
    #inscrutible error resembling:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#       typeset -r mapfile
#       print ${mapfile[/tmp/config]}
#       print -rl -- ${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}

    # For each function declared in each file in the passed directory and
    # subdirectories of that directory, make a symbolical link in the digest
    # directory with that function name to that file. Dismantled, this is:
    #
    # * "${^ZESHY_AUTOLOAD_DIRNAMES[@]}", expanding to each directory in the list.
    # * "/**/*",  recursively expanding to each file of this directory.
    # * "~*.swp", excluding temporary files.
    # * "(.L+0)", including only non-empty plain files. "mapfile" currently
    #   fails with error on attempting to expand an empty plain file,
    #   arguably a bug. Nonetheless, respect its wishes.
#   for autoload_function_filename (
#       "${^ZESHY_AUTOLOAD_DIRNAMES[@]}"/**/*~*.swp(.L+0)
#       "${ZESHY_OVERLAY_FILENAMES[@]}"
#   ) {
        # Load the functions this file defines for subsequent compilation.
#           say "sourcing \"${autoload_function_filename}\"..."
#       source "${autoload_function_filename}"

        # Append to the list of autoloadable functions all:
        #
        # * Explicitly defined functions of form "${function_name}() {".
        # * Implicitly defined interactive aliases of form
        #   "alias_cli ${alias_name}:always${alias_expansion}".
        #
        # Dismantled, this is:
        #
        # * "${(f)mapfile[...]}", expanding to each line of this file.
        # * "${(M)", ":#", and "}", excluding lines not matching the
        #   following extended glob expression:
        #   * "\(\) \{", followed by "() {", signifying a function.
        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
        #     more alphanumeric, underscore, and hyphen characters.
        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
        # * "=?*", greedily matching "=" followed by one or more characters.
        #
        # Note: *DO NOT QUOTE THIS EXPRESSION*. Doing so silently expands
        # this expression to the empty string, though we have no idea why!
        # Also, do not quote the expansion of ${autoload_function_file} in
        # this expression. Doing so causes "mapfile" to interpret such
        # quotes as prefixing and suffixing such filename, thus raising an
        # exception on not finding such "munged" filename.
#       autoload_function_names+=(
#           ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%[(=]*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%[(=]*}
#       )
#           say "sourced \"${autoload_function_filename}\"."
#   }

    # Unload "mapfile", for safety.
#   zmodload -u zsh/mapfile

    #FUXME: Not quite right. If the user disables
    #${ZESHY_IS_WRAPPING_CORE_RUNNABLES}, then some interactive aliases will not
    #actually be defined. zcompile() *FAILs* when fed non-extant function names.
    #To rectify this, we really want to make the prior loop sourcing each file
    #and matching "autoload_function_names" much, much smarter. First, stop
    #grepping file contents. If you consider it, all you really need to do is:
    #
    #* Before sourcing such file, stuff the set of all function names into a list.
    #* After! sourcing such file, diff! the set of all function names against
    #  such list. A new subtract_list_from_list() function would be of help,
    #  here. The resulting list is the set of all function names such file
    #  defined. This method may or may not be slower, depending on zsh. What's
    #  clear, however, is that it's *MUCH* more resilient and *MUCH* less hacky.
    #
    #Ah-ha! zsh 5.0 bundles a "${left_list:|right_list}" operator subtracting
    #the two lists. This implies a hard dependency.
#   is "$(whence -w -- "${1}")" == *': function' si
#   list ZESHY__FUNCTION_NAMES_OLD; ZESHY__FUNCTION_NAMES_OLD=( $(typeset -f +) )

    # Recompile all such loaded function definitions into the digest file.
#       print "autoload function names: ${autoload_function_names[@]}"
#       say "compiling \"${ZESHY_USER_DIGEST_FILENAME}\"..."
#   zcompile -c "${ZESHY_USER_DIGEST_FILENAME}" "${autoload_function_names[@]}"

# ....................{ WASTELANDS                         }....................
        #FUXME: This should be a "list_set" rather than "list", for a slight
        #efficiency (and clarity (and stability!)) improvement.
#
        # For clarity, temporarily set the script name to Zeshy.
#       string ZESHY_SCRIPT_FILENAME='zeshy'

#       zcompile "${ZESHY_USER_DIGEST_FILENAME}" "${ZESHY_USER_DIGEST_ROOT_DIRNAME}"/**/*(@)
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%( \(|\=)*}
            #FUXME: I believe these two mappings can be condensed into one.
#               ${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}
#               ${(f)mapfile[${autoload_function_filename}]}
#               ${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#([[:alnum:]_-]##\(\) \{|alias_cli [[:alnum:]_-]##=?)*}#alias_cli }%%( \(|=)*}
#               ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#alias_cli [[:alnum:]_-]##=?*}#alias_cli }%%\=*}
#               ${${(M)${(f)mapfile[${autoload_function_filename}]}:#[[:alnum:]_-]##\(\) \{}%%\(*}
#               ${${${(M)${(f)mapfile[/usr/share/zeshy/src/autoload/if_pathable/7z]}:#alias_cli [[:alnum:]_-]##=?*}#alias_cli }%%\=*}
#           print "alias_clies:"
#           print -rl -- ${${${(M)${(f)mapfile[${autoload_function_filename}]}:#alias_cli [[:alnum:]_-]##=*}#alias_cli }%%\=*}

# --------------------( TODO                               )--------------------
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#       
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
# * Ugh. Current symlink technique doesn't quite work. It's quite close, though.
#   A working system either:
#   * Harvests the set of all function names using the current technique *AND*
#     manually recursively sources all Zeshy files (easy) *AND* uses the "-c"
#     flag to zcompile to compile all such function names into the digest
#     (easy). This isn't quite perfect, but it seems pretty darn close.
#   * Alternatively, create new temporary files in "~/.zeshy/digest/" defining
#     each such function separately by matching out the definition of such
#     functions from the existing files. This is somewhat more work, and
#     demonstrably of no greater benefit than the prior method. I reck'n it'd
#     work, but I'd rather try to pick the prior low-hanging fruit, first.


    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"

    # Automatically recompile all compiled files in function path "${FPATH}" whose
    # corresponding uncompiled files have since changed.
    #autoload -U zrecompile
#   zrecompile -p

        # Make the digest directory, if needed.
#       say "composing \"${ZESHY_USER_DIGEST_ROOT_DIRNAME}\"..."
#       mkdir -p "${ZESHY_USER_DIGEST_ROOT_DIRNAME}"

        # Remove all existing symbolic links in the digest directory, if needed.
#       list digest_symlinks; digest_symlinks=( "${ZESHY_USER_DIGEST_ROOT_DIRNAME}/"*(@) )
#       is -n "${digest_symlinks}" si and rm "${digest_symlinks[@]}"


#           print "autoload_function_file=${autoload_function_file}"
#           for autoload_function_name\
#               ( ${${(M)${(f)mapfile[${autoload_function_file}]}:#[[:alnum:]_-]##\(\) \{}%%\(*} ) {
#               ln -s\
#                   "${autoload_function_file}"\
#                   "${ZESHY_USER_DIGEST_ROOT_DIRNAME}/${autoload_function_name}"
#           }

#       is_shell_terminal and print 'Yum!'
#       zcompile -c "${ZESHY_USER_DIGEST_FILENAME}" is_shell_terminal

#   zstat +mtime "${1}"
    # Dismantled, this is:
    #
    # * "${pathname}"/**/*, all files and subdirectories of this directory.
    # * "om", such files and subdirectories in ascending order by mtime.
    # * "[1]", the first and hence newest such file or subdirectory.
#   zstat +mtime "${pathname}"/**/*(om[1])

#   touch -m --date=@"${mtime}" "${pathname}"

# void _populate_zeshy_digest_dir_with(string dirname)
#
# Populate Zeshy's digest directory with one symbolic link for each autoloadable
# function in each file of the passed directory, recursively.
#_populate_zeshy_digest_dir_with() {
#    die_unless_one_arg 'expected exactly one dirname'
#
#    # For each function declared in each file in the passed directory and
#    # subdirectories of that directory, make a symbolical link in the digest
#    # directory with that function name to that file. Dismantled, this is:
#    #
#    # * "/**/*", recursively expanding to each file and subdirectory of the
#    #   passed directory.
#    # * "~*.(swp)", excluding temporary files.
#    # * "(.)", including only plain files.
#    for autoload_function_file\
#        ( "${ZESHY_AUTOLOAD_ALWAYS_DIR}"/**/*~*.(swp)(.) ) {
#        # Dismantled, this is:
#        #
#        # * "${(f)mapfile["${autoload_function_file}"]}", iteratively
#        #   expanding to each line of this file.
#        # * "${(M)", ":#", and "}", excluding lines not matching the
#        #   following extended glob expression:
#        #   * "[[:alnum:]_-]##", greedily matching a substring of one or
#        #     more alphanumeric, underscore, and hyphen characters.
#        #   * "\(\) \{", followed by "() {", signifying a function.
#        # * "${" and "%%\(*}", excluding the "() {" suffixing such lines.
#        for autoload_function_name\
#            ( "${${(M)${(f)mapfile["${autoload_function_file}"]}:#[[:alnum:]_-]##\(\) \{}%%\(*}" ) {
#            ln -s\
#                "${autoload_function_file}"\
#                "${ZESHY_USER_DIGEST_ROOT_DIRNAME}/${autoload_function_name}"
#        }
#    }
#}

#       for autoload_command_filename\
#           ( "${ZESHY_COMMAND_DIR}/"*(e{'[[ $REPLY:t:c == /* ]]'}) ) {
#           ZESHY_OVERLAY_FILENAMES+=( "${autoload_command_filename}" )
#       }

        #FUXME: Replace with an "rm -rf" once confident this works.
#           mv "${ZESHY_USER_DIGEST_ROOT_DIRNAME}" "${ZESHY_DOT_DIR}/tmp/$(date +'%N')"

#_zeshy_autoload_digest_old() {
    #FUXME: This only applies to developer systems. In production, Zeshy
    #requires only one initial compilation, thus eliminating the cost of such
    #recompilation. Ah; I wonder. Wouldn't a "zrecompile -p" immediately after
    #declaring the "fpath" do this, assuming we'd first compiled all necessary
    #digests? If so, that would suggest we'd only need a simple test for
    #
    #    if not is_file "${ZESHY_USER_DIGEST_FILENAME}"; then
    #       # Compile everything anew here! Don't bother checking mtimes.
    #    fi
    #
    #Then, a zrecompile should handle the rest, yes? That would be considerably
    #more efficient, given zsh's C-backed implementation. Ah; O.K., it gets even
    #better. We can entirely reduce this if-conditional to a zrecompile() call
    #resembling the given example:
    #
    #     zrecompile -p\
    #         -R ~/.zshrc --\
    #         -M ~/.zcompdump --\
    #         ~/zsh/comp.zwc ~/zsh/Completion/*/_*
    #
    #This does everything for us. Swag, no? Memory map everything, of course.
    #Oh, and the latter line is the one that applies to us. To quote: "re-create
    #the file ~/zsh/comp.zwc if any of the files matching the given pattern is
    #newer than it." We'll need to dynamically construct the arguments to be
    #passed for the command-specific directories. Shouldn't be hard:
    #
    #     list zrecompile_args
    #     zrecompile_args=( "${generic_dir}.zwc" "${generic_dir}"/**/*(.) )
    #     for command_dir in "src/auto/command"/*(/); do
    #         zrecompile_args+=( "${command_dir}.zwc" "${command_dir}"/**/*(.) )
    #     done
    #     print "za: ${zrecompile_args[@]}"
#    say "detecting \"${ZESHY_USER_DIGEST_FILENAME}\"..."
#    integer zeshy_mtime=$(get_path_mtime_recursive "${ZESHY_SRC_HOME}")
#    if not is_file "${ZESHY_USER_DIGEST_FILENAME}" or
#        (( zeshy_mtime != $(get_path_mtime "${ZESHY_USER_DIGEST_FILENAME}") )); then
#        say "compiling \"${ZESHY_USER_DIGEST_FILENAME}\"..."
#        # ...the "-." matches all files and symbolic links to files.
#        zcompile "${ZESHY_USER_DIGEST_FILENAME}" "${ZESHY_SRC_HOME}"/**/*~*.(swp|zwc)(-.)

#        # Set the mtime of the compiled script to that of the uncompiled
#        # script to ensure the above conditional fails on future imports.
#        set_path_mtime "${ZESHY_USER_DIGEST_FILENAME}" "${zeshy_mtime}"
#    fi

    # Declare all functions provided by the digest file to be autoloadable.
#    autoload -w "${ZESHY_USER_DIGEST_FILENAME}"

    # Prefix "${FPATH}" with the absolute path to the digest file, ensuring zsh
    # searches such file for the definition of such functions first. Oddly, zsh
    # has no means of directly associating the two.
#    fpath=( "${ZESHY_USER_DIGEST_FILENAME}" "${fpath[@]}" )
#}
