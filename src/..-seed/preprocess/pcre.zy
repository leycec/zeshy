#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by preprocessors.

#FIXME: ${ZESHY_MACRO_PCRE} should be generalized to explicitly match all
#ignorable code containing macro-like syntax (e.g., strings, variable
#expansions) preceding non-ignorable macros. However, this is also fraught with
#issues: for example, we'd actually like to expand macros embedded in process
#substitutions in double-quoted strings and variable expansions but *NOT* in
#all other content in double-quoted strings and variable expansions. Is this
#feasible? Perhaps not. In which case, perhaps the current approach is actually
#a bit more ideal than we first conceived.

# ....................{ GLOBALS                            }....................
# PCRE globals defined below.
typeset -g\
    ZESHY_MACRO_PCRE\
    ZESHY_MACRO_ARG_BLOCK_BODY_PCRE

# ....................{ CLEARERS                           }....................
#FIXME: Document me.
# :void ::preprocessor_pcres.clear()
function ::preprocessor_pcres.clear() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ZESHY_MACRO_PCRE=
}

# ....................{ MAKERS                             }....................
#FIXME: Document me.
# :void ::preprocessor_pcres.make_if_needed()
function ::preprocessor_pcres.make_if_needed() {
    (( # == 0 )) || :die 'Expected no arguments.'
    [[ -n ${ZESHY_MACRO_PCRE} ]] || ::preprocessor_pcres.make
}

#FIXME: Document me.
# :void ::preprocessor_pcres.make()
function ::preprocessor_pcres.make() {
    # Validate sanity. Since subsequent locals often depend on prior locals
    # locals, define one local per line below.
    (( # == 0 )) || :die 'Expected no arguments.'

    #FIXME: Fairly confident that we can further optimize such PCREs by
    #globally substituting non-atomic grouping syntax "(?:...)" for atomic
    #grouping syntax "(?>...)". The difference between the two is as follows:
    #
    #* If any alternative in the latter succeeds, such group will *NEVER* be
    #  backtracked into -- even if that results in a match failure.
    #* By contrast, the former is always backtracked into on subsequent match
    #  failures.
    #
    #We believe we've implicitly designed *ALL* alternation below to not
    #require backtracking. That being said, we really won't know until we get
    #the backtracking-capable version working first and then attempt to
    #optimize into the backtracking-incapable version.
    #FIXME: Similarly, most instances of "*" and "+" may be suffixed by "+".

    # PCRE options. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   vexsome default, "." matches all characters excluding newline.)
    # * "(?m)", inducing:
    #   * "^" to match either the string start *OR* newline. (By default, "^"
    #     matches only the former.)
    #   * "$" to match either the string end *OR* newline. (By default, "$"
    #     matches only the former.)
    local pcre_options='(?sm)'

    # PCRE options as above, as well as anchoring the current PCRE to the first
    # match point in the the substring currently being searched. For both
    # efficiency and consistency, iterative PCREs (i.e., PCREs iteratively
    # matching consecutive substrings in strings via pcre_match() and
    # ${ZPCRE_OP}) should *ALWAYS* be anchored, ensuring such PCREs only match
    # at the first byte following the last byte of the prior such match rather
    # than at any byte following such byte (the default).
    local pcre_options_anchored=${pcre_options}'\G'

    # Empty group, typically used to align group indices in a list of
    # "(?|"-driven alternatives.
    local pcre_empty_group='()'

    # All subroutines defined below, concatenated in a manner preventing such
    # definitions from matching. Such subroutines remain callable and hence are
    # defined only for recursion purposes. Since subroutine calls incur non-
    # negligible time and space costs (e.g., , For
    # further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html

    #
    # First, a bit of useful background. As in Perl but not Ruby, "libpcre"
    # subroutine calls (e.g., "(?&soma)") do *NOT* capture the substring
    # matched by such call. As in both Perl and Ruby, subroutine definitions
    # (e.g., "(?<soma>All the advantages of Christianity and alcohol; none of
    # their defects.)" capture the substring matched by such definition. For
    # further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is noxious. In
    # most cases, we would prefer such definitions to *NOT* capture.
    #
    # Happily, PCRE explicitly supports such behaviour via "(?(DEFINE)...)",
    # Perl- and PCRE-specific syntax defining all named and numbered capturing
    # groups in its embedded content but otherwise ignoring such content.
    local pcre_subroutines_prefix='(?(DEFINE)'
    local pcre_subroutines_suffix=')'
    local pcre_subroutines_body

    # ..................{ MACRO ~ space                      }..................
    # Note that escaped backslashes (i.e., "\\") should *ALWAYS* be match
    # before attempting to match other escaped characters, as escaped
    # backslashes are *NOT* escape characters (e.g., "\\n" is an escaped
    # backslash preceding the character "n" rather than an escaped newline).
    #
    # Note also that both syntactically valid and invalid constructs should be
    # matched. For example, ${} is a syntactically invalid variable expansion
    # but must still be matched as a variable expansion. This prevents
    # unmatched syntactically invalid constructs from being catastrophically
    # matched as syntactically valid delimiters.
    #
    # The PCRE matching double-quoted strings provides a minimum length example
    # correcting such issues:
    #
    #     local pcre_quotes_double='"(?:\\[\\"$`]|[^"$`]|(?&sub)|[^"])*"'
    #
    # Let's pick this apart. In order:
    #
    # 1. "\\[\\"$`]", matching any relevant escaped character, where the
    #    meaning of "relevant" depends on the current syntactic construct.  In
    #    the case of double-quoted strings, these are:
    #    * An escaped backslash, preventing such backslash from escaping the
    #      following character.
    #    * An escaped '"' delimiter, preventing such delimiter from terminating
    #      such match.
    #    * An escaped "$" or "`" character, preventing such character from
    #      initiating a variable expansion, arithmetic substitution, or process
    #      substitution (as matched by the following subroutine call).
    # 2. "[^"$`]", matching any irrelevant character, where the meaning of
    #    "irrelevant" is the inverse of the meaning of "relevant" above
    #    excluding backslashes. Since the prior alternative matched all
    #    relevant escaped characters, all remaining escaped characters and
    #    hence backslashes are irrelevant. Since the last alternative is a
    #    fallback matching all characters excluding '"' delimiters, this
    #    alternative is technically redundant. However, the following
    #    alternative is a PCRE subroutine call -- which, by definition, incurs
    #    non-negligible space and time costs. Since such call should be
    #    performed *ONLY* if necessary, this alternative matches all characters
    #    guaranteed *NOT* to be matched by such call.
    # 3. "(?&sub)", matching any variable expansion, arithmetic substitution,
    #    or process substitution. All such syntactic constructs are recursively
    #    nestable and hence matchable only with subroutine calls. (Since
    #    double-quoted strings are only indirectly recursively nestable, such
    #    call is replacable in this specific case by the contents of the
    #    corresponding PCRE ${pcre_substitutable}. In the general case,
    #    however, subroutine calls are typically required.)
    # 4. "[^"]", a fallback matching any unmatched character *NOT* the
    #    terminating '"' delimiter. Assuming the prior alternatives matched
    #    such syntactic construct correctly, this should be equivalent to
    #    matching any unescaped "$" or "`" character. For robustness, it's
    #    simplest to match any non-delimiter.
    #
    # Syntactic constructs delimited by substrings longer than a single
    # character require negative lookahead to properly match. Since such
    # lookahead is comparatively inefficient, defer such lookahead to the final
    # alternative in the PCRE matching such constructs: e.g.,
    #
    #     # Instead of this...
    #     local pcre_math_substitution_new='\$\(\((?:\\[\\)$`]|(?!\)\))(?:[^)$`]|(?&sub)|.))*\)\)'
    #
    #     # ...just do this.
    #     local pcre_math_substitution_new='\$\(\((?:\\[\\)$`]|[^)$`]|(?&sub)|(?!\)\)).)*\)\)'

    #FIXME: O.K.; so we're not necessarily convinced that lookbehinds are
    #sufficient to match line continuations. Consider:
    #
    #    # Not a line continuation, due to being commented out.
    #    >>> # \
    #
    #We need to closely examine where we're using such continuations.

    # Line continuation (i.e., an unescaped backslash followed by a newline),
    # continuing the command corresponding to the current line to the next
    # line. As discussed above, newlines preceded by two backslashes are *NOT*
    # line continuations and must *NOT* be matched as such.
    local pcre_line_continuation='(?<!\\)\\$'

    # Zero or more consecutive line continuations.
    local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\$)*)?'

    # One or more command-specific whitespace sequences (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # all whitespace except newlines *NOT* prefixed by "\". While "\"-prefixed
    # newlines are line continuations preserving the current command,
    # unprefixed newlines are effectively semicolons terminating such command.
    local pcre_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    local pcre_spaces=${pcre_line_continuations_optional}'\h'${pcre_spaces_optional}

    # ..................{ MACRO ~ string                     }..................
    # Character class matching shell-reserved characters.
    local char_class_reserved='''"$<>{}|`'

    # Unquoted shell word.
    local pcre_word_unquoted+='[^\s'${char_class_reserved}']++'

    # Unquoted inescapable shell word, comprising one or more arbitrary
    # characters excluding:
    #
    # * Whitespace characters.
    # * Shell-reserved characters.
    # * Escape prefix "\".
    local pcre_word_unquoted_literal='[^\s\\'${char_class_reserved}']++'
    local pcre_word_unquoted_literal_grouped='('${pcre_word_unquoted_literal}')'

    # Single-quoted string *NOT* supporting escaped single quotes (i.e., "''").
    local pcre_quotes_single_literal_body="[^']*+"
    local pcre_quotes_single_literal="'"${pcre_quotes_single_literal_body}"'"
    local pcre_quotes_single_literal_grouped="'("${pcre_quotes_single_literal_body}")'"

    # Double-quoted string containing no embedded constructs, including 
    # escape prefix "\", variable expansions, arithmetic substitutions, or
    # process substitutions.
    local pcre_quotes_double_literal_body='[^"\\$`]*+'
    local pcre_quotes_double_literal='"'${pcre_quotes_double_literal_body}'"'
    local pcre_quotes_double_literal_grouped='"('${pcre_quotes_double_literal_body}')"'

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local pcre_quotes_single="'(?>[^']|'')*'"

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    #
    # Since zsh appears to parse terminating '"' delimiters in a phase *BEFORE*
    # that of variable expansions, this PCRE can (and possibly should) avoid
    # matching such expansions here. Since such behaviour is arguably either
    # a bug or unreliable implementation detail, however, we match
    # substitutables embedded in double quotes in the same manner as that of
    # substitutables embedded in other syntax (e.g., arithmetic substitutions).
    local pcre_quotes_double_prefix='"(?:\\[\\"$`]|[^"$`]|'
    local pcre_quotes_double_suffix='|[^"])*"'
    local pcre_quotes_double=${pcre_quotes_double_prefix}'(?&sub)'${pcre_quotes_double_suffix}
    local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}'(?&varormath)'${pcre_quotes_double_suffix}

    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE.  Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    local pcre_here_doc_prefix_ignore='-?\s*+'
    local pcre_here_doc_prefix=${pcre_here_doc_prefix_ignore}'(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_unquoted_literal_grouped}')$'
    #FIXME: Excise this and ${pcre_here_doc_quotes}, when no longer required.
    local pcre_here_doc_quotes_prefix=${pcre_here_doc_prefix_ignore}'(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}')$'
    local pcre_here_doc_body='.*?'
    local pcre_here_doc_suffix='$(?-1)'
    local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}
    local pcre_here_doc_quotes=${pcre_here_doc_quotes_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    # Here-string prefix. Since here-strings are syntactically identical to
    # standard arguments (i.e., as one or more shell words) *AND* since
    # subsequent parsing presumably matches such arguments, such prefix is
    # ignorable for most preprocessing purposes. For simplicity, avoid matching
    # the here-string here. Subsequent parsing does so for us.
    local pcre_here_string_prefix='<\s*+'

    # Here-document in full or here-string prefix.
    local pcre_here_prefix='<<'
    local pcre_here_doc_or_string_prefix=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|'${pcre_here_doc}')'

    #FIXME: We're fairly certain that our comment prefix still isn't quite
    #right. Investigate: are comments immediately prefixed by line
    #continuations comments? We suspect not. That said, the zeshy codebase
    #doesn't currently contain any such monstrosities, so we can probably
    #neglect this.

    # Comment, necessarily prefixed by either one or more horizontal whitespace
    # characters *OR* the start of the current line. Note that the former
    # constraint implies that comments must be explicitly matched *BEFORE*
    # matching negative character classes implicitly matching whitespace.
    local pcre_comment_prefix='(?:\h++|^\h*+)'
    local pcre_comment_body='#[^\v]*+$'
    local pcre_comment_body_optional='(?:'${pcre_comment_body}')?+'
    local pcre_comment_optional=${pcre_comment_prefix}${pcre_comment_body_optional}

    #FIXME: And comments, please! Wait. Actually, comments probably have to be
    #embedded directly into PCREs below due to matching prefixing whitespace.
    #FIXME: Substitute me below for all instances of "(?&code)".

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing. Since unquoted shell words do *NOT* obstruct such
    # preprocessing, ignore such words.
    local pcre_code=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here}'|(?&sub)'

    # ..................{ MACRO ~ sub                        }..................
    # Possibly recursively nested variable expansion. While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    local pcre_var_expansion='\{(?:\\[\\}$`]|[^}$`]|(?&sub)|[^}])*\}'

    # Possibly recursively nested arithmetic substitution.
    local pcre_math_substitution_new='\((?:\\[\\)$`]|[^)$`]|(?&sub)|(?!\)\)).)*\)'
    local pcre_math_substitution_old='\[(?:\\[\\]$`]|[^]$`]|(?&sub)|[^]])*\]'

    #FIXME: The inefficient subroutine call "(?&code)" matches non-recursive
    #constructs (e.g., single-quoted strings, here-documents, here-strings).
    #Such constructs should simply be matched here with an embedded PCRE.

    # Possibly recursively nested process substitution.
    local pcre_process_substitution_recursive='(?:\\[\\\s)''"$<#`]|'${pcre_comment_optional}'|(?:[^)''"$<#`]|(?&code)|[^)]))*'

    # Possibly recursively nested arithmetic or process substitution.
    local pcre_parens_substitution='\((?:'${pcre_math_substitution_new}'|'${pcre_process_substitution_recursive}')\)'

    # Possibly recursively nested variable expansion or arithmetic or process
    # substitution.
    local pcre_dollar_substitution='\$(?:'${pcre_var_expansion}'|'${pcre_parens_substitution}'|'${pcre_math_substitution_old}')'

    # Non-recursive process substitution. Since the named group "<sub>" matches
    # non-recursive process substitution, such group *CANNOT* be referenced
    # here. (Doing so would permit such substitutions to be recursively
    # nested.) Instead, match all groups matched by such group excluding
    # non-recursive process substitution.
    local pcre_process_substitution_nonrecursive='`(?:\\[\\\s''"$<`]|'${pcre_comment_optional}'|(?!`)(?:[^''"$<`]|(?&code)|.))*`'

    #FIXME: Still require ${pcre_substitutable}?

    # Recursively substitutable or expandable syntactic construct. Since
    # arithmetic substitution syntax greedily overlaps that of process
    # substitution, the former *MUST* be matched prior to the latter.
    local pcre_substitutable=${pcre_dollar_substitution}'|'${pcre_process_substitution_nonrecursive}
    pcre_subroutines_body+='(?<sub>'${pcre_substitutable}')'

    # ..................{ MACRO ~ code                       }..................
    # Shell word excluding here-documents and -strings, comprising one of the
    # prior syntactic constructs. Ideally, this matches any standard argument
    # passable to a zsh command. Here-documents and -strings are *NOT* freely
    # mixable with standard arguments and hence unmatched here.
    #
    # Such PCRE interpolates the PCRE matching substitutables and hence must be
    # declared *AFTER* the latter rather than with
    local pcre_word_nonhere='(?:'${pcre_word_unquoted}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_substitutable}')'

    # One or more such words.
    local pcre_words_nonhere=${pcre_word_nonhere}'+'

    # Such word *OR* one or more horizontal whitespace characters.
    local pcre_word_nonhere_or_spaces='(?:'${pcre_word_nonhere}'|'${pcre_spaces}')'

    # One or more such words *OR* horizontal whitespace characters, the first
    # and last of which are also such words, thus permitting whitespace only
    # between such words.
    #
    # The latter condition prevents this PCRE from matching substrings ending
    # in a run of whitespace, ensuring such whitespace will be matched only as
    # the non-optional whitespace prefixing a subsequent block argument if any
    # or otherwise unmatched. In both zsh and zeshy, unquoted whitespace is
    # significant only for argument delimitation. Hence, trailing unmatched
    # whitespace is safely ignorable.
    local pcre_words_nonhere_with_spaces_optional=${pcre_word_nonhere}'(?:'${pcre_spaces_optional}${pcre_word_nonhere}')*'

    # One or more horizontal whitespace characters followed by zero or more
    # such words. If one or more such words match, such words must be suffixed
    # by one or more horizontal whitespace characters.
    local pcre_spaces_with_words_nonhere_optional=${pcre_spaces}'(?:'${pcre_word_nonhere}${pcre_spaces}')*'
    local pcre_spaces_with_words_nonhere_optional_grouped='('${pcre_spaces_with_words_nonhere_optional}')'

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing and hence parsing of unquoted "{" and "}" characters.
    # Unlike shell word matching, this does *NOT* include unquoted characters.

    #FIXME: Fixmeplz. Actually, we're fairly certain we can excise this now.

    pcre_subroutines_body+='(?<code>'${pcre_quotes_single}'|'${pcre_here}'|'${pcre_quotes_double}'|'${pcre_substitutable}')'

    # ..................{ MACRO ~ macro                      }..................
    #FIXME: Correct documentation.

    # Zero or more non-macro lines preceding a macro, ensuring macro-like lines
    # embedded in multi-line string contexts are ignored. Ideally, this would
    # comprise *ALL* such contexts, including double-quoted strings and
    # variable expansions. Unfortunately, both double-quoted strings and
    # variable expansions may embed process substitutions expanding non-
    # ignorable macros. Hence, this PCRE would need to distinguish between the
    # following edge cases:
    #
    #     >>> "The following macro is ignorable:
    #     ... :func :void :this_is_not_a_function_definition() {
    #     ... }"
    #     >>> "The following macro is *NOT* ignorable: $(
    #     ... :func :void :this_is_a_function_definition() {
    #     ... } )"
    #     >>> "The following macro is ignorable: $("
    #     ... :func :void :this_is_not_a_function_definition() {
    #     ... }")"
    #
    # Clearly, distinguishing such cases is non-trivial. Hence, we currently
    # only ignore macros in string contexts allowing no process substitutions:
    #
    # * Single-quoted strings.
    # * Single-quoted here-strings.
    # * Single- or double-quoted here-documents.
    #
    # While non-ideal, it's unclear whether we can readily do better.

    # Macro indentation. Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline *NOT* prefixed by an unescaped
    # backslash (i.e., line continuation).
    local pcre_macro_prefix='^\h*+'

    # Macro name, dynamically constructed from the current set of all declared
    # macro names. By macro design, such names are guaranteed to contain no
    # PCRE-reserved characters and hence require no escaping here. See :macro()
    # and :list.join_to_string_on_char().
    local pcre_macro_name=${(j:|:)ZESHY__MACRO_NAMES}
    local pcre_macro_name_grouped='('${pcre_macro_name}')'

    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros.
    #
    # Such "{" must be prefixed by at least one horizontal space. Since the
    # PCRE embedding this PCRE guarantees that, avoid matching such space here.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, avoid matching suffixing whitespace matched as prefixing
    # whitespace by the subsequent such block by merely asserting this
    # constraint with positive lookahead.
    local pcre_macro_arg_block_prefix='\{'
    local pcre_macro_arg_block_suffix_lookahead=${pcre_spaces}'|\Z'
    local pcre_macro_arg_block_suffix='\}(?='${pcre_macro_arg_block_suffix_lookahead}')'
    local pcre_macro_arg_block_or_comment_optional=${pcre_spaces}'(?:'${pcre_comment_body}'|'${pcre_macro_arg_block_prefix}'(?&block))?'
    local pcre_macro_arg_block_body='(?:\\[\\\h}''"$<`]|'${pcre_macro_arg_block_or_comment_optional}'|[^}''"$<`]|(?&code)|[^}]|\}(?!'${pcre_macro_arg_block_suffix_lookahead}'))*'
    local pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    pcre_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}')'

    # Zero or more arguments of any type. To assist the preprocessor in
    # differentating between syntactically valid macros accepting no arguments
    # and syntactically invalid macros accepting arguments, embed an empty
    # group at some arbitrary position in such PCRE. Differentiating such cases
    # then reduces to testing the length of canonical list global ${matches}.
    # While we could also effect this by capturing the entire substring matched
    # by such PCRE, doing so has no demonstrable benefit over the current
    # approach while incurring minor time and space costs. So, the current
    # approach reigns.
    local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_spaces}'(?:'${pcre_words_nonhere}'|'${pcre_macro_arg_block}'))*'

    # Here-string. While the here-string prefix "<<<" is ignorable for most
    # preprocessing purposes, here-strings suffixing macros *MUST* be matched
    # in full. Why? Because such here-strings *MUST* be passed on standard
    # input to such macros at expansion time.
    local pcre_here_string=${pcre_here_string_prefix}${pcre_words_nonhere}

    # Here-document or -string.
    local pcre_here=${pcre_here_prefix}'(?:'${pcre_here_doc}'|'${pcre_here_string}')'
    local pcre_spaces_optional_here_optional='(?:'${pcre_spaces_optional}${pcre_here}')?'

    # Macro, comprising such macro's name and all passed arguments. To
    # distinguish syntactically valid from invalid macros, all syntax following
    # such name *MUST* be optional. For efficiency, such macro's mandatory
    # prefixing newline is matched below.
    local pcre_macro_grouped=${pcre_macro_name_grouped}${pcre_macro_args_optional}${pcre_spaces_optional_here_optional}

    #FIXME: Actually, we *CAN* readily do better -- but doing so will require
    #quite a bit of work. Basically, we'll need to duplicate each syntactic
    #construct embedding other such constructs and prohibit embedding of
    #process substitutions of any type. This doesn't necessarily need to entail
    #PCRE duplication. It will, however, probably mean a doubling in the number
    #of PCREs. See ${pcre_quotes_double_noncode} for a sensible approach, after
    #we've completed an initial draft by the current approach.
    #FIXME: Not quite. We need to ignore everything after a comment prefix "#"
    #until the end of the line, as well. Unfortunately, differentiating such
    #prefix from "#" characters embedded in other contents (e.g., variable
    #expansions, unquoted globs) is *HIGHLY* non-trivial.
    #
    #Actually, it shouldn't be. zsh comments should *ALWAYS* unconditionally be
    #detectable by being prefixed by either the start of the line *OR*
    #non-empty horizontal whitespace (assuming strings to be properly matched,
    #anyway). That doesn't appear to be the case for all other uses of "#",
    #which appear to *ALWAYS* be prefixed by something other than what prefixes
    #a comment. Hopefully, there exist no exceptions to such heuristic.
    #
    #Actually, *DO* we need to match comments? Well, yes, technically. Consider
    #the following:
    #
    #    # If we ignore comments, then the " basically causes havoc.
    #    if :is uuugh == u##gh :si { # " uhoh
    #        :macro
    #    }
    #FIXME: The above implies that we need to prevent unquoted "#" characters
    #prefixed by blahblah from being matched into macro argument lists. Such
    #characters *MUST* terminate such lists.
    #FIXME: The above also implies that we *DO* need to ignore double-quoted
    #strings and such as well here, to ensure proper matching of single-quoted
    #strings. Failure to do this *WILL* cause extreme parsing havoc. While this
    #does currently prevent us from embedding macros in process substitutions,
    #it's difficult to conceive of a situation in which we'd want to do so. So,
    #let's do this, execrable though it may be.

    # Zero or more macros *OR* zsh syntax possibly containing macro-like
    # substrings. Sadly, disambiguating the two requires explicitly matching
    # both the former and latter.

    #FIXME: Shift such "\h++" up into a new comment prefix PCRE.

    local pcre_macro_or_comment_optional_grouped=${pcre_macro_prefix}'(?:'${pcre_comment_body}'|'${pcre_macro_grouped}')?|\h++(?:'${pcre_comment_body}')?'
    local pcre_macros_or_code_optional_grouped='\A(?:\\[\\\s''"$<`]|'${pcre_macro_or_comment_optional_grouped}'|[^''"$<`]|(?&code)|.)*\Z'

    # If *NO* macros were previously registered, clear the prior PCRE to
    # prevent spurious or scurrilous preprocessor behaviour.
    (( ZESHY__MACRO_NAMES )) || pcre_macros_or_code_optional_grouped=

    # ..................{ FUNCTION PROTOTYPE                 }..................
    #FIXME: Shift here from ={*-start/*-declare/*-pcre}.

    # ..................{ PCRE                               }..................
    # All subroutines defined above, concatenated in a manner preventing such
    # definitions from matching. See above.
    local pcre_subroutines=${pcre_subroutines_prefix}${pcre_subroutines_body}${pcre_subroutines_suffix}

    #FIXME: Repair documentation.

    # PCRE capturing the macro name and all block argument bodies in a
    # preprocessor macro. To distinguish syntactically valid from invalid
    # preprocessor macros, all syntax following the macro name is optional.
    ZESHY_MACRO_PCRE=${pcre_options}${pcre_zsh_grouped}${pcre_subroutines}

    # PCRE capturing the next block argument body in a macro argument list,
    # prefixed by one or more horizontal whitespace characters followed by zero
    # or more shell words. To assist user-defined macros accepting variadic
    # arguments in distinguishing standard from block arguments, capture the
    # entirety of such block including "{" and "}" delimiters.
    #
    # Such PCRE assists in finding the byte indices of the first and last
    # characters of the next block argument passed to the currently matched
    # macro. Unfortunately, unlike test operator "=~", pcre_match() sets
    # neither canonical integer globals ${MBEGIN} or ${MEND} nor list globals
    # ${mbegin} or ${mend}. Given such constraints, the only means of finding
    # such byte indices is to:
    #
    # * Capture the substring preceding such block argument, including
    #   otherwise ignorable whitespace.
    # * Add the byte length of such substring to the byte index of the last
    #   character of the prior block argument.
    ZESHY_MACRO_ARG_BLOCK_PCRE=${pcre_options_anchored}${pcre_spaces_with_words_nonhere_optional_grouped}${pcre_macro_arg_block}${pcre_subroutines}

    # ..................{ INDICES                            }..................
    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support constant globals. *sigh*

    # For each match group captured by each PCRE global declared above
    # capturing four or more such groups, declare one human-readable integer
    # global expanding to such group's 1-based index. For robustness, declare
    # such globals iteratively rather than manually.
    local match_index_name
    integer match_index

    #FIXME: Document such indices.

    # Declare indices matched by ${ZESHY_MACRO_PCRE}.
    match_index=;
    for match_index_name (
        ZESHY_MACRO_MATCH_INDEX_NAME
        ZESHY_MACRO_MATCH_INDEX_IS_VALID
    ) {
        integer -g ${match_index_name}=$(( match_index++ ))
        print -r ${match_index_name}': '${(P)match_index_name}
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Prefixing whitespace will need to be integrated with other PCREs.

    # local pcre_macros_or_code_optional_grouped='\A(?:\\[\v\\''<]|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|[^''<]|'${pcre_quotes_single}'|'${pcre_here_doc_quotes}'|.)*\Z'

    #FUXME: Not quite right. We don't need to confine 
    # local pcre_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_spaces=${pcre_line_continuations_optional}'\h'${pcre_spaces_optional}
    # local pcre_comment_optional='\h++'${pcre_comment_body}

    #FUXME: Comment support, please!
    # local pcre_macro_arg_block_nested=${pcre_spaces}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_spaces=${pcre_line_continuations_optional}'\h'${pcre_spaces_optional}
    # local pcre_comment_optional='\h++'${pcre_comment_body}

    # local pcre_macro_arg_block_nested=${pcre_spaces}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:\\[\\\h}''"$<`]|'${pcre_macro_arg_block_nested}'|[^}''"$<`]|(?&code)|[^}]|\}(?!'${pcre_macro_arg_block_suffix_lookahead}'))*'

    # local pcre_code_or_comment=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here}'|(?&sub)'

    #FUXME: Need to match and ignore comment lines. *sigh*
    #FUXME: Ugh; can't define this here. But we *DO* need to explicitly match
    #here strings. Ah! Right. Simple. All we do is match the "<" and let all
    #following text be matched by other means elsewhere.
    #FUXME: Wait. Not quite true. We match here strings for a variety of
    #purposes. We'll need to shift this below and come up with something else
    #here. New nomenclature would help.

    # local pcre_quotes_double_prefix='"(?:\\[\\"$`]|[^"$`]|'
    # local pcre_quotes_double_suffix='|[^"])*"'
    # local pcre_quotes_double=${pcre_quotes_double_prefix}${pcre_substitutable}${pcre_quotes_double_suffix}
    # local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}${pcre_substitutable_noncode}${pcre_quotes_double_suffix}

#  Unlike shell word matching, this does *NOT* include
    # unquoted characters.
#  and hence parsing of unquoted "{" and "}" characters
    # Single- or double-quoted string.
    # local pcre_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}

    #FUXME: Also omit embedded substitutions. For that reason, rename
    #"_literal" to "_literal" globally.

    #FUXME: O.K.; so, we mucked this up a bit. For both generality and
    #efficiency, replace *ALL* instances of "\R" (and ideally of "\v" as well,
    #though that naturally doesn't apply to negative character classes) by:
    #
    #* End-of-line assertion "$".
    #* Enable multiline mode with "(?m)" above.

    #FUXME: Slightly erroneous. We make the dangerous assumption in
    #::code.preprocess() that such PCRE matches only ASCII characters. Clearly,
    #however, both "\h" and "\R" match multibyte characters. To correct this
    #discrepancy, we'll want to match only the explicit ASCII characters
    #satisfying horizontal and vertical whitespace requirements in a
    #cross-platform portable manner (think Windows line endings) *AND* replace
    #all instances of "\h" and "\R" below by similar constructs.
    #
    #Unfortunately, "libpcre" documentation notes that:
    #
    #"The choice of newline convention does not affect the interpretation of
    # the \n or \r escape sequences or \R." This implies we'll need to:
    #
    # * Test the OS already detected by ={inspect}.
    # * Define a new string local ${pcre_newline} expanding to the OS-specific
    #   PCRE matching newlines.
    #
    # Annoying, but certainly feasible. For now, the current implementation
    # appears to be basically acceptable.

    #FUXME: A minor issue. If ${ZESHY__MACRO_NAMES} is empty, the resulting
    #PCRE will match in a fairly disastrous manner. Guard against such inept
    #edge cases, please.

    #FUXME: Incorrect. We want to ignore preceding newlines prefixed by "\"
    #(i.e., line continuations). Hence, explicitly match line continuations in
    #the PCRE immediately above.

    #FUXME: ${pcre_line_continuations_optional} is somewhat inefficient here.
    #By PCRE definition, we should't need to lookbehind. Or perhaps we do still
    #need lookbehind? It's either that or lookahead. Hm; honestly, cutting
    #${${pcre_line_continuations_optional}} *ENTIRELY* and then prefixing
    #${pcre_macro_prefix} by a negative lookbehind assertion ensuring such
    #newline to *NOT* be preceded by an unescaped backslash seems like the
    #somewhat simpler and hence more efficient implementation, yes?
#(?!'${pcre_macro_arg_block_suffix}')
# ${pcre_spaces}${pcre_macro_arg_block_prefix}'|'

#(?!<<)(?:
#'${pcre_line_continuations_optional}'|
    #FUXME: Implement me for use below.
    # local pcre_here_string_quotes_single='<\s*+'${pcre_words_nonhere}

    # local pcre_zsh_grouped='(?:'${pcre_line_continuations_optional}'|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|(?!<<)(?:[^'']|'${pcre_quotes_single}'|.))*'

# local pcre_line_continuations_optional='(?<!\\)(?:\\\R)*'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}')*'

    #FUXME: Improve similar negative lookahead assertions elsewhere.

    #FUXME: Honestly, "(?!<<)" seems a bit silly. Ideally, since neither
    #here-documents or strings are recursive, such substrings should be matched
    #by an embedded PCRE here rather than a subroutine call.

    # local pcre_math_substitution=${pcre_math_substitution_new}'|'${pcre_math_substitution_old}
    #FUXME: For efficiency, combine this with ${pcre_math_substitution_new}.

    #FUXME: Sadly, we're fairly confident we need to back out most subroutine
    #calls below. The reason, of course, is inefficiency. PCRE appears to treat
    #subroutines as genuine boundaries for certain purposes; in particular,
    #PCRE copies all match groups prior to a subroutine call and then restores
    #such groups after such call. Hence, while subroutines are a fantastic
    #means of enabling recursion *AND* isolating match groups, they should be
    #avoided for all other purposes. Since we extensively leverage recursion
    #below, we *DO* need to retain subroutine support -- but only for these
    #specific purposes.

#FUXME: We should probably augment such PCREs to also capture optional here-
#documents and -strings passed to such macros and then pass either sort of
#string to such macro function on standard input as a simple here-string. The
#current approach is rather kludgy, it should be admitted. It's also not
#terribly general; after all, macros should be able to modify their output
#based on whether or not they were passed standard input as well as the exact
#content of that input. (It's only sensible, and not terribly difficult to
#implement, given current here-document and -string syntax support.)

    #FUXME: Not right either here or below. All PCRE fragments of the form
    #"[^"$`]|(?&sub)" *NEED* to be switched to
    #"(?&sub)|[^"]". Simple, thankfully.
    #FUXME: Actually, we can achieve the best of both worlds as follows:
    #    [^"$`]|(?&sub)|[^"]

    # local pcre_macro_arg_block_prefix='\{'${pcre_spaces}''
    # local pcre_macro_arg_block_suffix=${pcre_spaces}'\}(?:'${pcre_spaces}'|\Z)'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')*'
    # local pcre_macro_arg_block_nested=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_nested_body}${pcre_macro_arg_block_suffix}
    # pcre_subroutines_body+='(?<block>'${pcre_macro_arg_block_nested}')'

    # pcre_subroutines_body+='(?<macro>'${(j:|:)ZESHY__MACRO_NAMES}')'

    # local pcre_math_substitution='(?:'${pcre_math_substitution_new}'|'${pcre_math_substitution_old}')'

    #FUXME: Pointless. Excise, please.

    # Non-recursive variable expansion *OR* a literal "$" character. To match
    # the latter, match zero or more such characters. See
    # ${ZESHY_VAR_NAME_GLOB}.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    # local pcre_var_expansion_nonrecursive='[a-zA-Z_][a-zA-Z0-9_]*+'

    # Variable expansion.
    # local pcre_var_expansion='(?:'${pcre_var_expansion_nonrecursive}'|'${pcre_var_expansion_recursive}')'

    #FUXME: We probably expand such locals above. Correct circularities.
    #FUXME: Shift back above, actually.

    # local pcre_here_unsubstitutable='(?:'${pcre_here_prefix}${pcre_here}')?'

    #FUXME: Fairly certain that, as currently defined, this will erroneously
    #match *ALL* block arguments in the current code rather than merely those
    #passed to the current macro. Why? Because we haven't anchored the start of
    #such PCRE to the end of the prior iterative match. While we can't quite
    #recall how to go about such anchoring, we suspect that PCRE documentation
    #for pcre_match() should lend some insight.

# '${pcre_quotes}'|'${pcre_here}'|

    #FUXME: Convert to a conventional PCRE variable.
    #FUXME: Actually, we no longer need this at all. We never did! Rather than
    #calling the "(?&dollar)" subroutine in
    #${pcre_process_substitution_nonrecursive}, simply call the conventional
    #"(?&sub)" subroutine preceded by negative lookahead preventing a backtick
    #from matching. Since this form of process substitution is heavily
    #discouraged anyway, efficiency is of little to no concern.

    # Any of the above "$"-prefixed syntactic constructs.
    # local pcre_dollar_substitution+=

    #FUXME: Woops. Wherever we match an escaped character (e.g., "\\[)]"), we
    #need to match a an escaped "\\" *BEFORE* matching such character. Why?
    #Consider "$(( \\))". This is (sort of, anyway!) a balanced arithmetic
    #expansion and must be treated as such.
    # local pcre_backslash_escaped='\\\\'

    # When applied in an iterative context,  
    # of the first
    # byte following the last byte of the prior match. 

    #    :func :void :outer1() {
    #         :func :void :mid1() {
    #         }
    #    }
    #
    #    :func :void :outer2() {
    #         :func :void :mid2() {
    #             :func :void :inner1() {
    #             }
    #         } {
    #             :func :void :inner2() {
    #             }
    #         } <<'/---
    #    /---
    #         :func :void :mid3() {
    #             :func :void :inner3() {
    #             }
    #         } {
    #             :func :void :inner4() {
    #             }
    #         } <<'/---
    #    /---
    #    } <<'/---
    #    /---

    #FUXME: Not quite right. Rather than ineptly trying to coerce
    #${pcre_words_nonhere_with_spaces_optional} and ${pcre_spaces} together, we probably
    #probably want a new PCRE adroitly aggregating both.
    # local pcre_spaces_words_nonhere_optional_grouped='('${pcre_spaces}'(?:'${pcre_words_nonhere_with_spaces_optional}${pcre_spaces}')?)'

    # local pcre_words_nonhere_with_spaces_optional=${pcre_word_nonhere}'(?:'$pcre_word_nonhere_or_spaces'*'${pcre_word_nonhere}')?'
    # local pcre_words_nonhere_with_spaces_optional='(?:'${pcre_word_nonhere}'(?:(?:'${pcre_word_nonhere}'|'${pcre_spaces}')*'${pcre_spaces}')?)?'

    # Such PCRE implicitly requires backtracking and hence cannot be optimized
    # with atomic grouping.
    # local pcre_spaces='(?:\h|\\\R)*\h(?:\h|\\\R)*'

        # ZESHY_MACRO_MATCH_INDEX_HERE_DOC_OR_STRING
    # local pcre_words_nonhere_with_spaces_optional='(?:'${pcre_word_nonhere}'|'${pcre_spaces}')*'${pcre_word_nonhere}

    #FUXME: We've mucked up, it would appear. Expansions of ${pcre_word_nonhere}
    #should have been expansions of this PCRE. (Ugh.)

    # local pcre_macro_args_optional_grouped='('${pcre_macro_args_optional}')'

    # To do so, append such definitions to ${pcre_subroutines_body}
    # and, after doing so, prefix and suffix ${pcre_subroutines_body} by the prefix
    # and suffix defined below below.  and then interpolate such string into a PCRE guaranteed to
    # never match and hence capture.

    # supports such behaviour by ignoring
    # all content aside from defining named and numbered capturing
    # groups in such content.

# efficiency and readability purposes.
    # pcre_subroutines_body+='(?<quote>'${pcre_quotes_single}'|'${pcre_quotes_double}')'

    # Declare indices matched by ${ZESHY_MACRO_PCRE}, ignoring match groups
    # required only for internal use in such PCRE -- including:
    #
    # * Match group 1, capturing prefixing indentation.
    # match_index=2

    #To do so, see the section "Newline conventions" in "man pcrepattern".
    #Specifically, to quote:
    #
    #"It is also possible to specify a newline convention by starting a  pat-
    # tern string with one of the following five sequences:
    #
    #    (*CR)        carriage return
    #    (*LF)        linefeed
    #    (*CRLF)      carriage return, followed by linefeed
    #    (*ANYCRLF)   any of the three above
    #    (*ANY)       all Unicode newline sequences"
    #prepend the appropriate pattern option to the PCRE globals we construct
    #below.

    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'

    #FUXME: Replace subroutine calls called in only one place with low-level
    #variable expansions.
    #FUXME: Compress PCREs together. For example, we don't benefit from
    #separate ${pcre_macro_arg} and ${pcre_macro_args} PCREs.

    #FUXME: Capture block arguments. 
    #FUXME: Define match index globals. This is going to considerably more
    #troublesome than it otherwise would, due to each named group being
    #unconditionally captured. We'll have to ignore all such groups in a sane
    #way -- probably by incrementing in integer local here immediately after
    #defining any ignorable named group (which will be most if not all of them).

    # ZESHY_MACRO_PCRE=${pcre_macro_indentation}${pcre_macro_name}${pcre_macro_args_optional_grouped}${pcre_subroutines}

    #FUXME: Convert ${pcre_macro_arg_block} into a subroutine.

    # Zero or more arguments of any type. Since we match a run of shell words
    # greedily, avoid matching consecutive runs of shell words for efficiency.

    # local pcre_macro_args_optional='(?:'${pcre_spaces}'(?:'${pcre_words_nonhere}'(?:(?&spaces)'${pcre_macro_arg_block}')?|'${pcre_macro_arg_block}'))*'

    #FUXME: This may be optimizable by noting that ${pcre_words_nonhere}
    #matches greedily and hence cannot by definition match consecutively.
    # local pcre_macro_args_optional_grouped='((?:'${pcre_spaces}'(?:'${pcre_words_nonhere}'|'${pcre_macro_arg_block}'))*)'

# local pcre_macro_args_optional_grouped='((?:'${pcre_spaces}'(?:'${pcre_macro_arg_block}'|'${pcre_words_nonhere}'(?&spaces))?'${pcre_macro_arg_block}'))*)'
    # Zero or more runs of whitespace or shells words ending in a shell word.
    # local pcre_words_nonhere_optional='(?:'${pcre_words_nonhere}')?'

    # Argument of any type prefixed by one or more horizontal whitespace
    # characters followed by zero or more shell words.
    # local         pcre_macro_arg=${pcre_macro_arg_block}
    # local pcre_macro_arg_grouped=''${pcre_spaces}''${pcre_words_nonhere_optional}${pcre_macro_arg_block_grouped}

#matched from a previously captured macro argument list
#''${pcre_spaces}''
    #FUXME: For efficiency, split the "'${pcre_spaces}'" prefixing each such PCRE out
    #into this PCRE instead.

    # local pcre_macro_arg_block_prefix=''${pcre_spaces}'\{(?&spaces)'
    # local    pcre_macro_arg_block_nested_prefix='\{'${pcre_spaces}''

    # local        pcre_macro_arg_block_suffix=''${pcre_spaces}'\}(?:(?&spaces)|\Z)'
    # local pcre_macro_arg_block_nested_suffix=''${pcre_spaces}'\}(?&spaces)'

    # local pcre_words_nonhere=''${pcre_spaces}'(?:'${pcre_word_nonhere}'|(?&spaces))*(?&word)'

    #FUXME: Define all remaining ${ZESHY_MACRO_MATCH_INDEX_ARG_*} globals.

        # ZESHY_MACRO_MATCH_INDEX_ARG_1
        # ZESHY_MACRO_MATCH_INDEX_ARG_2
        # ZESHY_MACRO_MATCH_INDEX_ARG_3

    # local        pcre_macro_arg_block_nested_body='(?<blockb>(?:'${pcre_spaces}'(?&block)?|\\[''"$`<]|(?!<<)[^''"$`]|(?&code))*'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')'

    # local        pcre_macro_arg_block_body='(?:'${pcre_spaces}'(?&block)?|\\[''"$`<]|(?!<<)[^)''"$`]|(?&code))*?'
    # local pcre_macro_arg_block_nested_body=${pcre_macro_arg_block_body}

 # While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    # Macro indentation. Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline.
    #
    # Since such indentation is guaranteed to be the first match group, we
    # match such indentation with numbered back references (e.g., "\g1").
    # local pcre_macro_indentation_grouped='(\R\h*+)'

    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros. Since such macros
    # are currently matched solely by prefixing indentation regardless of zsh
    # context (i.e., ignoring string literals, variable expansions, and other
    # syntactic constructs), the "}" delimiting such argument is also matched
    # solely by the same prefixing indentation.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, merely assert this constraint with positive lookahead.
    # local pcre_macro_arg_block_prefix=''${pcre_spaces}'\{(?&spaces)'
    # local pcre_macro_arg_block_body='.*?'
    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'
    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_spaces}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_spaces}'|\Z)'
    # local pcre_macro_arg_block_suffix_ahead='\g1\}(?='${pcre_spaces}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

#         ZESHY_MACRO_MATCH_INDEX_ARGS_END
# ${pcre_empty_group}
    # local pcre_macro_args_optional_grouped='(?:(?:'${pcre_words}'|'${pcre_macro_arg_block_grouped}')((?:'${pcre_words}'|'${pcre_macro_arg_block_grouped}')*))?'

        # ZESHY_MACRO_MATCH_INDEX_ARG_1
        # ZESHY_MACRO_MATCH_INDEX_ARGS_2_OR_MORE

    #FUXME: Not quote right. We require spaces after a macro name *AND* before
    #a "{", but we can only match such spaces once. How?

    # '(?:'${pcre_words}'|'${pcre_macro_arg_block_grouped}')*'
    # '(?:'${pcre_macro_args_optional_grouped}')?'${pcre_subroutines}
    # ZESHY_MACRO_PCRE=${pcre_macro_indentation_grouped}${pcre_macro_name}'(?:'${pcre_spaces}${pcre_macro_args_grouped}')?'${pcre_subroutines}

    # One or more runs of whitespace or shells words both initiating and
    # terminating in a shell word.
    #
    # The former condition is purely an optimization concern. The latter
    # condition, however, is not; it prevents this PCRE from matching
    # substrings ending in a run of whitespace, ensuring such whitespace will

    #FUXME: Such subroutines are embedded only in the following PCRE fragment:
    #    (?=\$)(?:(?&var)|(?&math)|(?&proc))
    #Hence, simplify this by refactoring this and the other subroutines into
    #PCREs and embedding them directly in a new subroutine <dollar>.

    #FUXME: Insufficient, as it currently fails to match multiple adjacent line
    #continuations. Hmmm.

    # pcre_subroutines_body+='(?<spaces>(?:\\\R)?(?:\h++(?:\\\R)?)+)'

    #FUXME: Such "}" must be matched as prefixed by a newline (\R) followed by
    #the same exact horizontal whitespace as the initial macro. We currently
    #match this as named group "(?&indent)" below. Such group *MUST* contain
    #such newline.

# (?=\$)(?:(?&var)|(?&math)|(?&proc))

    #FUXME: Match the same embedded constructs as above.
    #FUXME: Perhaps simpler to replicate the definition of
    #${pcre_process_sub_recursive} here, augmented with a negative lookahead
    #assertion to prevent matching of an unescaped "`". Ignore for now;
    #somewhat too much complexity, here!

    # local pcre_process_substitution_nonrecursive='`(?:\\[''"$`<]|(?!<<)[^''"$`]|(&squote)|(&dquote)|(&here)|(?=\$)(?:(?&var)|(?&math)|(?&proc)))*`'

    # Unquoted shell word.
    # pcre_subroutines_body+='(?<uword>[^\s'${char_class_reserved}']++)'

    # Character class matching shell-reserved characters.
    # local char_class_reserved='''"$<>{}|`'
    # local pcre_word_unquoted_literal='[^\s\\'${char_class_reserved}']++'

    #FUXME: For each named subroutine below, we need to directly embed the
    #definition of such subroutine somewhere in ${ZESHY_MACRO_PCRE} --
    #ideally, before the first call to such subroutine in such PCRE. (Yes, this
    #is somewhat annoying.)

    # Suffix suffixing all subroutines defined below, preventing such
    # subroutines from matching. Since such subroutines remain callable, To ensure this:
    #
    # * Suffix each subroutine definition by a suffix guaranteeing such
    #   definition to never match.

    # local pcre_subroutine_suffix='{0}'

    # As in Perl (but not Ruby), "libpcre" subroutine calls (e.g.,
    # "(?&soma)") do *NOT* capture the substring matched by such call if any.
    # As in both Perl and Ruby, subroutine definitions (e.g.,
    # "(?<soma>All the advantages of Christianity and alcohol; none of their defects.)"
    # capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is somewhat
    # noxious. In most cases, we would prefer such definitions to *NOT*
    # capture. Unfortunately, we have little alternative but to ignore the
    # groups captured by such matches.
    #
    # To facilitate this, increment ${match_count_ignore} (an integer local
    # counting the total number of ignorable match groups) after every
    # subroutine defined below.

    #FUXME: We had a reasonably clever idea. Will it work? Only CLI testing
    #will demonstrate the feasibility of the idea. If it *DOES* work, that'd be
    #reasonably awesome. So, what's the idea? Since subroutine definitions
    #implicitly capture *AND* since that's bad, shift all such definitions past
    #the valid end of the PCRE (e.g., "$") into a region guaranteed *NOT* to
    #match, reserved for only defining subroutines. Such subroutines would
    #never be matched as definitions but only called, avoiding all such
    #capturing issues.
    #FUXME: Sweet. Both of the following work as advertised:
    #
    #    >>> :is yum =~ '(?&yam)(?<yam>yum){0}' :si and print ok
    #    ok
    #    >>> :is yum =~ '(?<yam>yum){0}(?&yam)' :si and print ok
    #    ok
    #
    #Subroutine definitions suffixed by "{0}" are thus guaranteed to never
    #match and hence capture. Fairly awesome!

    #FUXME: Suffix all subroutines defined below by such PCRE fragment.

    # # Declare indices matched by ${ZESHY_MACRO_PCRE}.
    # match_index=1

    # #FUXME: Correct names.
    # # Declare indices preceding the first ignorable match group.
    # for match_index_name (
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_NAME
    # ) {
    #     integer -g ${match_index_name}=$(( match_index++ ))
    #     print -r ${match_index_name}': '${(P)match_index_name}
    # }

    # # Increment the index of the next ignorable match group past all
    # # intermediate match groups.
    # match_index+=${match_count_ignore}

    # #FUXME: Declare subsequent groups.

    # integer match_count_ignore=0
    # match_count_ignore+=1

 # Right? Wrong. There appears to be a bug in either
    #"libpcre" or zsh (...guess which, presumably?) forcing
    # local pcre_spaces='(?:\h|\\\R)++'

 # all macros (including names and block arguments) in
    # arbitrary code.

    #FUXME: Use of named references complicates match indexing. I beliewe we
    #can circumvent this, however, by leveraging named subroutines: that is,
    #declaring *ALL* named references at the very end of the regex.

    # # Argument of any type.
    # local pcre_macro_arg='(?:'${pcre_words}'|'${pcre_macro_arg_block}')'

    # # One or more arguments of any type.
    # local pcre_macro_args=${pcre_macro_arg}'+'

    #FUXME: This still used? Probably... not.

    # One or more arbitrary characters excluding shell-reserved characters.
    # local pcre_chars_unreserved='(?:\\\R|[^\v'${char_class_ureserved}'])++'

    # ZESHY__MACRO_NAMES_PCRE
    # ZESHY__MACRO_NAMES_PCRE=${}

    #FUXME: Excise me.

    # One or more whitespace-delimited shells words.
    # local pcre_words='(?:'${pcre_spaces}'|'${pcre_word}')+'

    #FUXME: Match only whitespace delimiting such words -- *NOT* prefixing such
    #words. This should simplify matching of block arguments a bit.
    # local pcre_words='(?:(?:'${pcre_word}'(?:\\\R)?\h++(?:\\\R)?))*'${pcre_word_nonhere}')?'

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

    #FUXME: This is actually used. ${pcre_spaces}, however, doesn't really
    #appear to be. Excise the latter and shift such documentation here.
    # local pcre_spaces='(?:\h|\\\R)+'

    # local pcre_macro_arg_block_prefix='(?:\h(?:\\\R)?|(?:\\\R)?\h)\{'

    #FUXME: Excise. This is wrong, anyway. Matching line continuations is
    #*USELESS*, if one considers. We don't care about line continuations. They
    #signify 

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

 # Hence, we
    #really can't match this outside of the full PCRE. *shrug* 
# '(?:'${pcre_macro_arg}')*(?&arg)'

    # Customary argument for zsh commands, comprising one or more of the prior
    # syntactic constructs.
    # local pcre_macro_arg_command='(&word)+'

# '(?<word>(&uword)|(&squote)|(&dquote)|(?&sub))'

# ${pcre_chars_unreserved}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_substitutable}'
    #FUXME: Correct me. Then just 
    # local pcre_code_sans_process_sub_nonrecursive='(?<codet>))'

    #FUXME: Erhm. Excise?
    # local pcre_codes='(?:\\[''")$`<]|(?!<<)[^''")$`]|(?&code))*'

    #FUXME: A non-recursive version (e.g., matching "$ughugh") needs to be
    #defined as well, and a new umbrella PCRE matching both recursive and non-
    #recursive variable expansions assigned the overarching group "<var>".

    # local pcre_quotes_single_grouped="'((?:[^']|'')*)'"
    # local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    #FUXME: Also match process substitutions (of both ilk).
    #
    #Since zsh appears to search for terminating '"' delimiters in a prior
    #phase to that of variable expansions, we do *NOT* need to match variable
    #expansion here. (Isn't that nice?)

    #FUXME: Embedding ${pcre_quotes_single} here clearly isn't quite right.
    #While we *DO* want to match single quotes, we want to do so in a
    #"(?qsingle)" manner. Moreover, we want to match considerably more than
    #simply that: double quotes, here-doc strings, and so forth. *sigh*

    #FUXME: Unify with ${pcre_word}, perhaps?
    #FUXME: Right. ${pcre_code} should subsume ${pcre_word}, adding support for
    #here-documents and -strings. (Anything else?)

    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE. Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    # local pcre_here_doc_prefix='<<-?\s*+(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_unquoted_literal_grouped}')\R'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\R(?-1)'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    # Here-string.
    # local pcre_here_string='<<<\s*+'${pcre_word_nonhere}''

    #FUXME: Excise the above? Shift documentation here!

    #FUXME: No longer required, seemingly. Now that we've merged such matching
    #into ${pcre_chars_unreserved}, excise such PCRE.

 # (Since this PCRE is principally used to match here
    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # cannot 
    #
    # we have no sane means of
    # matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string).
    #
    # Why? Character escapes.  We're inclined
    #to ignore this, at the moment.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Fairly sure we can simplify this quite a bit. We don't *NEED* to
    #match individual arguments on the initial match of the full macro string.
    #In fact, we're fairly sure we don't *EVER* need to match individual
    #arguments. Hence, we can probably generalize ${pcre_macro_arg_command} above
    #with whitespace as follows:
    #
    #    local pcre_macro_arg_command='(?:'${pcre_spaces}'|'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'
    #
    #Of course, that immediately suggests we combine ${pcre_spaces} and
    #${pcre_sans_quotes_spaces} -- probably by omitting "\s" from the
    #definition of the latter. (In any case, it's all for the morrow!)

    # "$"- or "`"-prefixed embedded substitutable.
    # local pcre_substitutable_embedded='(?=[$`])(?&sub)'

# (?>[$`])

    #FUXME: O.K.; we're not going to be able to substitute this below as is.
    #The reason why is the "[^$]". We're afraid that will need to be extended
    #on a case-by-case basis. After doing so, we'll probably want to excise
    #this local entirely.

    # Any character excluding "$" *OR* a "$"-prefixed substitutable.
    # local pcre_char_or_substitutable='\\$|[^$]|(?&sub)'

    #FUXME: Also match recursively nestable process substitution.

    # While we prefer *NOT* to explicitly
    # match arithmetic substitutions, matching only the latter would match one ")" delimiter
    # in arithmetic substitutions as terminating such substitutions -- which,
    # clearly, is not the case.

    #FUXME: For maintainability, we probably want to use embedded named
    #references everywhere we currently use zsh variable embedding below.

    # Arbitrary string of one or more characters excluding characters reserved
    # for strict zsh argument parsing. This includes:
    #
    # * Dollar signs.
    # * Single and double quotes.
    # * Whitespace.
    # local pcre_sans_quotes_spaces='[^\s''"$]++'

    # local pcre_macro_arg_command='(?:'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'

    #FUXME: Interestingly, this must be constructed at runtime, implying this
    #entire anonymous function should be converted into a named function
    #::preprocessor_pcres.make() called on *EACH* call to :macro(). Hmm. For
    #efficiency, perhaps:
    #
    #* :macro() should simply set ${ZESHY_MACRO_PCRE} to the empty string.
    #* :code.preprocess() should call ::preprocessor_pcres.make() if
    #  ${ZESHY_MACRO_PCRE} is the empty string.
    #
    #This permits multiple macros to be defined by a single parcel without
    #triggering multiple redundant PCRE compilations, which seems sensible.
    #FUXME: For usability, define a function ::preprocessor_pcres.clear() in
    #this parcel clearing such PCRE globals.

    # One or more such arguments.
    # Unquoted word in the strict zsh sense, comprising one or more characters
    # excluding whitespace and shell-reserved characters.
    # local pcre_word_unquoted='[^]'

    #FUXME: We *DO* need to match variables as well. Here's why:
    #
    #    >>> print ${:-
    #    ... :func
    #    ... }
    #
    #    :func
    #
    #Yes, that actually works. It's a hell of an edge case, but edge case
    #nonetheless. For robustness, we *MUST* account for all such cases.

    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # local pcre_here_doc_prefix='<<-?\s*+(?|'${ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE}'|'${ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE}'|(\S++)\n'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\g{-1}'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

#FUXME: Document me.
# # PCRE globals defined below.
# typeset -g\
#     ZESHY_SYNTAX_QUOTES_SINGLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE
# 
# # PCREs matching single-quoted strings in zsh format and hence supporting
# # escaped single quotes (i.e., "''").
#          ZESHY_SYNTAX_QUOTES_SINGLE_PCRE="'(?:[^']|'')*'"
# ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE="'((?:[^']|'')*)'"
# 
# # Double-quoted string in zsh format and hence supporting escaped double
# # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
# # matches "\" and hence must be matched *AFTER* matching the latter.
#          ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE='"(?:\\"|[^"])*"'
# ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE='"((?:\\"|[^"])*)"'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
