#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.
#
#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Preprocess zeshy-specific code into zsh-specific code.

#FIXME: Alias expansions containing macro expansions pove a slight issue,
#though certainly solvable. Consider a macro :macro and alias :alias expanding
#as follows:
#
#    alias ":alias"=":macro"
#
#Simple, right? Right. Unfortunately, the current approach expands macros
#*BEFORE* evaluating the result and hence expands such macro. Thus, such
#approach fails to preprocess alias-embedded macros. Fortunately, there exists
#a simple alternative:
#
#* Before preprocessing, define a temporary singleton function (e.g.,
#  ::preprocess.code()) whose body is *EXACTLY* the code to be preprocessed:
#  e.g.,
#     functions[::preprocess.code]={preprocessed_code}
#* After definition, since function's body is such code with all aliases
#  expanded to their results.
#* Preprocess such function's body rather than the original code: e.g.,
#     ::preprocess ${functions[::preprocess.code]}
#* Undefine such function to avoid unexpected side effects.
#
#Inefficient? Yes. But, again, *ALL* digest compilations except the first will
#be backgrounded. Hence, we generally don't care *TOO* much about compilation
#times -- so long as they're not apallingly horrific, anyway.

#FIXME: Once we get a working preprocessor up, it becomes trivial to implement
#support for eliding away debug-specific code under optimized builds. Simply
#define a new macro :build.if_debug() accepting one and only one block
#argument. Such macro behaves in the expected way:
#
#* If the current build is an optimized build, such macro unconditionally
#  expands to the empty string.
#* Else, such macro expands to the passed block argument verbatim.

#FIXME: We'd *LOVE* to add support for command-line option-based syntax
#checking (e.g., syntax checking scripts passed at the command-line when option
#"--syntax-check" or some such is passed). Unfortunately, due to both
#preprocessor macros and global aliases, getting from here to there will be
#highly non-trivial. That said, we do have a few ideas on how to approach this.
#
#The fundamental issue is that of mapping from the post-processed line
#numbers that zsh emits on syntax errors to the preprocessed line numbers
#corresponding to the original scripts accepted by zeshy. On the face of it,
#such issue would appear to be intractable -- until you conceive the crucial
#trick, that is! So here we go. In full:
#
#* Define new command line options "-n" and "--syntax-check" acting as synonyms
#  of each other. "-n" is the customary command-line option for syntax checking
#  in literally *ALL* popular shells and hence should be followed here.
#* On receiving either such option, do the following for each passed script (in
#  exact order):
#  . Prepreprocess such script's contents in a syntax validation-specific
#    manner. Specifically (in exact order):
#    . For each line of such contents *NOT* suffixed by the line continuation
#      substring, suffix such line by:
#      " # line ${line_number}", where ${line_number} is such line's number.
#      Such comments serve as the basis for our subsequent mapping. (Clever.)
#    . Prefix *ALL* such contents by the newline-delimited string list of
#      all general aliases defined within the currently compiled digest file.
#      We may also need to define *ALL* command aliases as well. Hopefully,
#      however, it doesn't come to that.
#  . Preprocess but do *NOT* evaluate such script's contents in the usual way.
#  . Write the resulting code to a temporary file.
#  . Syntax check such file by passing either option "-n" or "--no-exec"
#    to zsh.
#  . If zsh fails with nonzero exit status and reports an syntax error on
#    standard error, such error will assume the following form:
#    "${temporary_filename}:${line_number_plus_one}: ${error_message}"
#    No surprises there, except for the ${line_number_plus_one}. zsh appears
#    to emit a line number one greater than the actual line number of the
#    erroneous line, as can be verified with a simple erroneous zsh script.
#    So, we'll not only need to substract such line number by 1 but by the line
#    length of all preceding general alias definitions. (Simple.)
#  . In the event of a syntax error, examine the erroneous line of the
#    postprocessed code string still in memory. If all went according to dismal
#    plan, such line *SHOULD* be suffixed by a comment indicating the
#    corresponding line number in the preprocessed original zeshy script,
#    in which case we're done. If this is *NOT* the case, something went
#    horribly wrong, implying the current zeshy process should probably throw
#    a verbose exception.
#
#That actually doesn't seem terribly hard, now that we've purportedly uncovered
#the essential trick of suffixing preprocessed lines by " # line" comments.
#Give us a go, eh?

# ....................{ DEPENDENCIES                       }....................
::script_zsh.source_or_unwind_call_stack backend.zy pcre.zy

# ....................{ GLOBALS                            }....................
#FIXME: Document me.
# From from macro name to the name of the function expanding such macro.
typeset -gA\
    ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME\
    ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME

# ....................{ DECLARERS                          }....................
#FIXME: Implement macro documentation support. This implies, of course, that
#we'll need to shift early-time documentation functionality here. *sigh*
#FIXME: Document me.

#FIXME: *ALL* macro names should be suffixed by ":". Since macros are
#regrettably subject to constraints that conventional zsh builtins and
#functions and external commands are not, callers must have some immediate
#means of differentiating macros from non-macro callables. This is how. Given
#this convention, we should probably print non-fatal warnings when macros *NOT*
#suffixed by ":" are declared.
#FIXME: Actually, we've obviated most such constraints. Assuming we correct the
#well-documented issue of matching macros in process substitutions embedded in
#double-quoted strings (which certainly seems feasible), the only remaining
#discrepancy between zsh and zeshy parsing remains the matching of macros in
#"`"-delimited process substitutions -- which, honestly, is perfectly ignorable.
#In other words, for all intents and purposes, macros should indeed be
#expandable everywhere command aliases are and hence *NOT* require lexical
#differentiation by the above ":"-suffixed scheme. Contemplate, anyway.

#FIXME: Define a new :macro_in_reverse() declarer, declaring macros which the
#preprocessor "reverses" until bumping up against a preceding brace. Since such
#macros must *ALWAYS* be preceded by a brace, however, perhaps that should
#appear in the declarer name? How about:
#
#* :macro_reverse_until_right_brace().
#* :macro_brace_right(). (Yes, this seems the more appropriate choice.)

# :void :macro_command[
#     args =  (:string macro_name, :string func_name),
#     stdin = (:string macro_asciidoc)]
#
# Declare the passed macro as expanding to the passed function, documented by
# http://asciidoc.org[AsciiDoc]-formatted standard input if passed or
# undocumented otherwise. For convenience, consider passing such documentation
# as a single- or double-quoted here-document: e.g.,
#
# == Macro Name ==
#
# === Namespace ===
#
# Macros are `zeshy`-specific constructs and hence reside in an independent
# namespace from that of conventional aliases and functions. Since aliases and
# functions also reside in independent namespaces, macros, aliases, and
# functions may all share the same names without conflict. In such cases, the
# following precedence applies (in order):
#
# . Macros are expanded by the `zeshy` preprocessor into raw `zsh` code (at
#   `zeshy` script sourcing _and_ code evaluation time).
# . Aliases are expanded by the `zsh` interpreter into raw `zsh` code (at
#   `zsh` script sourcing, code evaluation, _and_ function definition time).
# . Functions are defined by the `zsh` interpreter (at `zsh` script sourcing,
#   code evaluation, _and_ function execution time).
#
# Equivalently, macro names take precedence over alias names take precedence
# over function names.
#  
# === Lexical Constraints ===
#
# For simplicity, macro names are constrained as follows:
#
# FIXME: Document me.
function :macro_command() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one macro name and one function name.'
    local macro_name=${1} func_name=${2}
    [[ -n ${macro_name} ]] || :die 'Macro name empty.'
    [[ -n ${func_name}  ]] || :die 'Function name empty.'

    # If such name is *NOT* a valid macro name, throw an exception.  While we
    # *COULD* allow *ANY* nonempty strings to be valid macro names (as is
    # the case with alias and function names), doing so would complicate:
    #
    # * PCRE generation. All "libpcre"-reserved characters in such name would
    #   need to be explicitly escaped.
    # * Code preprocessing. Since macro users would need to explicitly escape
    #   all shell-reserved characters in such name *AND* since there exist
    #   multiple means of escape such characters in zsh (e.g., "\"-prefixed
    #   escapes and single- and double-quoted strings), matching all
    #   permissible uses of such macro would require either:
    #   * Matching all possible means of escape such characters.
    #   * Matching only one such means, requiring macro users to only escape
    #     such characters by such means.
    #   * Matching *NO* such means, requiring macro users to *NEVER* escape
    #     such characters. Since such preprocessing is *NOT* a zsh-compliant
    #     parser, such requirement is implementable. Unfortunately, it also
    #     introduces syntactic non-orthogonalities between the zsh parser and
    #     zeshy preprocessor. In other words, it's highly problematic.
    #
    # The latter is, arguably, the greater concern. While correcting the former
    # issue is certainly (albeit annoyingly) feasible, correcting the latter
    # issue is considerably less feasible if not infeasible altogether. For the
    # moment, sidestep such issues by prohibiting such characters.
    [[ ${macro_name} =~ ${ZESHY__MACRO_NAME_VALID_PCRE} ]] || :die\
        'Macro name "'${macro_name}'" invalid (i.e., not matched by PCRE /'${ZESHY__MACRO_NAME_VALID_PCRE}'/).'

    # If such function does *NOT exist, throw an exception.
    (( ${+functions[${func_name}]} )) || :die\
        'Macro '${macro_name}'() function '${func_name}'() not found.'

    # If the first character of such macro is ":", declare such macro
    # accordingly. Since this is the case for all official zeshy macros and
    # hence most macros, this is an optimization specific to the common case.
    if [[ ${macro_name[1]} == ':' ]] {
        # If such macro already exists, throw an exception.
        (( ${+ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]} == 0 )) || :die\
            'Macro '${macro_name}'() already defined to be expanded by function '${ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]}'().'

        # Else, declare such macro. For simplicity elsewhere (e.g., when
        # subsequently joining all such names together), omit the prefixing ":".
        ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name[2,-1]}]=${func_name}
    # Else, the first character of such macro is any character *NOT* ":". Again,
    # declare such macro accordingly.
    } else {
        (( ${+ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]} == 0 )) || :die\
            'Macro '${macro_name}'() already defined to be expanded by function '${ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]}'().'
        ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]=${func_name}
    }

    # Clear all previously generated preprocessor PCREs, forcing their
    # regeneration on the next preprocessor call. Since such PCREs match and
    # hence depend on the set of all macro names, declaring such macro
    # invalidates such PCREs. (While we *COULD* do so here, deferring such
    # regeneration prevents redundant regeneration in the common case of
    # multiple adjacent macro declarations in a parcel.)
    ::preprocessor_pcres.clear
}

# ....................{ SOURCERS                           }....................
# :void :script.source(:string filename)
function :script.source() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one filename.'
    local script_filename=${1} script_code
    [[ -f ${script_filename} ]] || :die\
        'Script "'${script_filename}'" not found or not a file.'

    # To avoid modifying such script, localize such script's contents. For
    # efficiency, do so via zsh module "mapfile" rather than customary
    # alternatives (e.g., process substitution).
    {
        zmodload zsh/mapfile
        script_code=${mapfile[${script_filename}]}
    # Since such module is inherently unsafe, guarantee such module to be
    # unloaded immediately after such retrieval -- even in the event such
    # retrieval throws an exception.
    } always {
        zmodload -ui zsh/mapfile
    }

    #FIXME: Nontrivial. We'll need to refactor
    #get_shell_script_shebang_command_name_if_found() into a setter and shift
    #the resulting function into a new parcel at this level. *sigh*
    #
    #Actually, probably no. Just inline the corresponding code here.
    #FIXME: Strip the prefixing shebang line from such code. Such line does
    #*NOT* constitute interpretable zeshy code and must not be treated as such.
    #
    #Actually, probably no. Shebang lines are "#"-prefixed and hence already
    #implicitly ignored.

    # If the first line of such code is *NOT* a shebang referencing the "zeshy"
    # interpreter, print a nonfatal warning. Preprocessing and evaluating
    # arbitrary bytes as valid zeshy code could have painful consequences and
    # should be avoided at all costs.

    # Preprocess such code.
    local ZESHY__PREPROCESS_CODE=${script_code}
    ::code.preprocess

    # Execute such preprocessed code.
    eval "${ZESHY__PREPROCESS_CODE}"
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: For identical reasons, we need to also ensure on alias and function
    #declaration that there exists no macro of the same name. In other words,
    #macros should be considered to share the same namespace as callables, even
    #though they technically don't.
    #FUXME: Actually, this is nonsense. Aliases being able to shadow functions
    #is a *good* thing. There's no justification for prohibiting shadowing in
    #macro names as well.

    # If such macro is the name of an existing callable (i.e., alias or
    # function), throw an exception. Since macros and callables technically
    # reside in different namespaces, there exists no explicit conflict between
    # the two. Nonetheless, permitting macros to share the same names as
    # callables invites numerous issues both subtle and notable. For example,
    # permitting such sharing obscures otherwise clear errors when erroneously
    # interpreting unpreprocessed zeshy scripts under the zsh interpreter, as
    # in that case unpreprocessed macros will still be executable as the
    # corresponding callables of the same. In other words, it's a bad idea.
    # (( ${+functions[${macro_name}]} +\
    #    ${+aliases[${macro_name}]} +\
    #    ${+galiases[${macro_name}]} == 0 )) || :die\
    #     'Macro '${macro_name}'() already a defined callable:'$'\n\n'$(which -- "${macro_name}")

# In such cases, note
# that the `zeshy` preprocessor expands all applicable macros to raw `zsh` code
# _before_ evaluating such code under the `zsh` interpreter, the following
# precedence

# ==== Caveats ====
#
# While technically feasible, defining macros, aliases, and/or functions of the
# same names does invite subtle issues. Notably, erroneously interpreting
# unpreprocessed `zeshy` scripts under the `zsh` interpreter
# permitting such sharing obscures otherwise clear errors when erroneously
    # interpreting unpreprocessed zeshy scripts under the zsh interpreter, as
    # in that case unpreprocessed macros will still be executable as the
    # corresponding callables of the same.

        # 'Macro name "'${macro_name}'" invalid. Consider renaming such macro to match PCRE "'${ZESHY__MACRO_NAME_VALID_PCRE}'".'
#only contain characters in the character class 
    # [[ ${macro_name} == ${~ZESHY__MACRO_NAME_GLOB} ]] || :die\
#FUXME: Incidentally, this is overly restrictive. To support non-English
#locales, We really want to support UTF-8-encoded macro names. All we
#really need to prohibit are shell- *AND* PCRE-reserved characters. We
#already have a shell-reserved character class in ={pcre}, so just augment
#with PCRE-reserved characters (e.g., "+", "?", "*", "^", "$").

# Character class matching all permissible characters in macro names.
# typeset -g ZESHY__MACRO_NAME_CHAR_CLASS='a-zA-Z0-9-_:.'

# Glob matching syntactically valid macro names.
# typeset -g ZESHY__MACRO_NAME_GLOB='['${ZESHY__MACRO_NAME_CHAR_CLASS}']##'

    #FUXME: We require this character class elsewhere (e.g., for PCRE use);
    #hence, extract "a-zA-Z0-9-_:." out into a new string global
    #${ZESHY__MACRO_NAME_CHAR_CLASS}.

#letters and "_", "-", ".", and ":" characters
# 'Function '${func_name}'() not found for macro '${macro_name}'().'
