#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by preprocessors.

# ....................{ GLOBALS                            }....................
# PCRE globals defined below.
typeset -g\
    ZESHY__MACRO_PCRE

# ....................{ CLEARERS                           }....................
#FIXME: Document me.
# :void ::preprocessor_pcres.clear()
function ::preprocessor_pcres.clear() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ZESHY__MACRO_PCRE=
}

# ....................{ MAKERS                             }....................
#FIXME: Document me.
# :void ::preprocessor_pcres.make_if_needed()
function ::preprocessor_pcres.make_if_needed() {
    (( # == 0 )) || :die 'Expected no arguments.'
    [[ -n ${ZESHY__MACRO_PCRE} ]] || ::preprocessor_pcres.make
}

#FIXME: Document me.
# :void ::preprocessor_pcres.make()
function ::preprocessor_pcres.make() {
    #FIXME: Use of named references complicates match indexing. I beliewe we
    #can circumvent this, however, by leveraging named subroutines: that is,
    #declaring *ALL* named references at the very end of the regex.
    #FIXME: Compress PCREs together. For example, we don't benefit from
    #separate ${pcre_arg} and ${pcre_args} PCREs.

    # Validate sanity. Since subsequent locals often depend on prior locals
    # locals, define one local per line below.
    (( # == 0 )) || :die 'Expected no arguments.'

    # One or more command-specific whitespace sequences (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # all whitespace except newlines *NOT* prefixed by "\". While "\"-prefixed
    # newlines are line continuations preserving the current command,
    # unprefixed newlines are effectively semicolons terminating such command.
    local pcre_spaces='(?<spaces>(?:\\\R)?(?:\h++(?:\\\R)?)+)'

    # Character class matching non-shell-reserved characters.
    local char_class_ureserved='''"$<>{}|`'

    #FIXME: This still used? Probably... not.

    # One or more arbitrary characters excluding shell-reserved characters.
    local pcre_chars_unreserved='(?:\\\R|[^\v'${char_class_ureserved}'])++'

    # Unquoted inescapable shell word, comprising one or more arbitrary
    # characters excluding:
    #
    # * Shell-reserved characters.
    # * Whitespace characters.
    # * Escape prefix "\".
    local pcre_word_inescapable='[^\s\\'${char_class_ureserved}']++'
    local pcre_word_inescapable_grouped='('${pcre_word_inescapable}')'

    # Single-quoted string *NOT* supporting escaped single quotes.
    local          pcre_quotes_single_inescapable="'[^']*+'"
    local pcre_quotes_single_inescapable_grouped="'([^']*+)'"

    # Double-quoted string *NOT* supporting escape prefix "\".
    local          pcre_quotes_double_inescapable='"[^"]*+"'
    local pcre_quotes_double_inescapable_grouped='"([^"\]*+)"'

    #FIXME: For each named subroutine below, we need to directly embed the
    #definition of such subroutine somewhere in ${ZESHY__MACRO_PCRE} --
    #ideally, before the first call to such subroutine in such PCRE. (Yes, this
    #is somewhat annoying.)

    # Unquoted shell word.
    local pcre_word_unquoted='(?<uword>[^\s'${char_class_ureserved}']++)'
    # local pcre_spaces='(?:\h|\\\R)++'

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local pcre_quotes_single='(?<squote>''(?:[^'']|'''')*'')'

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    #
    # Since zsh appears to parse terminating '"' delimiters in a phase *BEFORE*
    # that of variable expansions, this PCRE can (and possibly should) avoid
    # matching such expansions here. Since such behaviour is arguably either
    # a bug or unreliable implementation detail, however, we match
    # substitutables embedded in double quotes in the same manner as that of
    # substitutables embedded in other syntax (e.g., arithmetic substitutions).
    local pcre_quotes_double='(?<dquote>"(?:\\["$`]|[^"$`]|(?&sub))*")'

    # Here-document or -string. Unfortunately, matching all possible
    # here-document strings is infeasible within the purview of a pure PCRE.
    # Matching here-document delimiters embedding escaped characters (e.g.,
    # '<<"mother\"destroyer"') requires unescaping such characters -- a simple
    # operation that, by definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    local pcre_here_doc_prefix='-?\s*+(?|'${pcre_quotes_single_inescapable_grouped}'|'${pcre_quotes_double_inescapable_grouped}'|'${pcre_word_inescapable_grouped}')\R'
    local pcre_here_doc_body='.*?'
    local pcre_here_doc_suffix='\R(?-1)'
    local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}
    local pcre_here_string='<\s*+(?&word)+'
    local pcre_here_doc_or_string='(?<here><<(?:'${pcre_here_doc}'|'${pcre_here_string}')'

    # Possibly recursively nested variable expansion. While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    local pcre_var_expansion_recursive='\$\{(?:\\[$}`]|[^$}`]|(?&sub))*\}'

    # Non-recursive variable expansion. See ${ZESHY_VAR_NAME_GLOB}.
    local pcre_var_expansion_nonrecursive='\$[a-zA-Z_][a-zA-Z0-9_]*+'

    # Variable expansion.
    local pcre_var_expansion='(?<var>'${pcre_var_expansion_nonrecursive}'|'${pcre_var_expansion_recursive}')'

    # Possibly recursively nested arithmetic substitution. See below.
    local pcre_math_sub='(?<math>\$\(\((?:\\[$`]|(?!\)\))[^$`]|(?&sub))*\)\))'

    # Possibly recursively nested process substitution. While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    local pcre_process_sub_recursive='(?<proc>\$\((?:\\[)''"$`<]|(?!<<)[^)''"$`]|(?&code))*\))'

    #FIXME: Match the same embedded constructs as above.
    #FIXME: Perhaps simpler to replicate the definition of
    #${pcre_process_sub_recursive} here, augmented with a negative lookahead
    #assertion to prevent matching of an unescaped "`". Ignore for now;
    #somewhat too much complexity, here!

    # Non-recursive process substitution. Since the named group "<sub>" matches
    # non-recursive process substitution, such group *CANNOT* be referenced
    # here. (Doing so would permit such substitutions to be recursively
    # nested.) Instead, match all groups matched by such group excluding
    # non-recursive process substitution.
    local pcre_process_sub_nonrecursive='(?<tick>`(?:\\[''"$`<]|(?!<<)[^''"$`]|(&squote)|(&dquote)|(&here)|(?=\$)(?:(?&var)|(?&math)|(?&proc)))*`)'

    # Recursively substitutable or expandable syntactic construct. Since
    # arithmetic substitution syntax greedily overlaps that of process
    # substitution syntax, match the former prior to the latter.
    local pcre_substitutable='(?<sub>(?=\$)(?:(?&var)|(?&math)|(?&proc))|(?&tick))'

    # Shell word, comprising one of the prior syntactic constructs. Ideally,
    # this matches any standard argument passable to a zsh command.
    local pcre_word='(?<word>(&uword)|(&squote)|(&dquote)|(?&sub))'

    # Zero or more whitespace-delimited shells words.
    local pcre_words='(?:(?:(?&spaces)|(?&word))*(?&word))?'

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing and hence parsing of unquoted "{" and "}" characters.
    # Unlike shell word matching, this does *NOT* include unquoted characters.
    local pcre_code='(?<code>(&squote)|(&dquote)|(?&sub)|(&here))'

    # Macro name, dynamically constructed from the current set of all declared
    # macro names. By macro design, such names are guaranteed to contain no
    # PCRE-reserved characters and hence require no escaping here. See :macro()
    # and :list.join_to_string_on_char().
    local pcre_macro_name='(?:'${(j:|:)ZESHY__MACRO_NAMES}')'

    #FIXME: Such "}" must be matched as prefixed by a newline (\R) followed by
    #the same exact horizontal whitespace as the initial macro. We currently
    #match this as named group "(?&indent)" below. Such group *MUST* contain
    #such newline.

    # Block argument specific to zeshy macros. Ideally, 
    local pcre_arg_block_prefix='(?&spaces)\{(?&spaces)'
    local pcre_arg_block_body=''
    local pcre_arg_block_suffix='(?&indent)\}(?:(?&spaces)|\Z)'
    local pcre_arg_block=${pcre_arg_block_prefix}${pcre_arg_block_body}${pcre_arg_block_suffix}

    # Argument of any type.
    local pcre_arg='(?:'${pcre_words}'|'${pcre_arg_block}')'

    # One or more arguments of any type.
    local pcre_args=${pcre_arg}'+'

    # PCRE capturing all macros (including names and block arguments) in
    # arbitrary code.
    ZESHY__MACRO_PCRE=${pcre_macro_name}${pcre_spaces}${pcre_args}
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Excise me.

    # One or more whitespace-delimited shells words.
    # local pcre_words='(?:'${pcre_spaces}'|'${pcre_word}')+'

    #FUXME: Match only whitespace delimiting such words -- *NOT* prefixing such
    #words. This should simplify matching of block arguments a bit.
    # local pcre_words='(?:(?:'${pcre_word}'(?:\\\R)?\h++(?:\\\R)?))*(?&word))?'

    # local pcre_arg_block_prefix='(?<=[ \t]|\\\v)\{'

    #FUXME: This is actually used. ${pcre_spaces}, however, doesn't really
    #appear to be. Excise the latter and shift such documentation here.
    # local pcre_spaces='(?:\h|\\\R)+'

    # local pcre_arg_block_prefix='(?:\h(?:\\\R)?|(?:\\\R)?\h)\{'

    #FUXME: Excise. This is wrong, anyway. Matching line continuations is
    #*USELESS*, if one considers. We don't care about line continuations. They
    #signify 

    # local pcre_arg_block_prefix='(?<=[ \t]|\\\v)\{'

 # Hence, we
    #really can't match this outside of the full PCRE. *shrug* 
# '(?:'${pcre_arg}')*(?&arg)'

    # Customary argument for zsh commands, comprising one or more of the prior
    # syntactic constructs.
    # local pcre_arg_command='(&word)+'

# '(?<word>(&uword)|(&squote)|(&dquote)|(?&sub))'

# ${pcre_chars_unreserved}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_substitutable}'
    #FUXME: Correct me. Then just 
    # local pcre_code_sans_process_sub_nonrecursive='(?<codet>))'

    #FUXME: Erhm. Excise?
    # local pcre_codes='(?:\\[''")$`<]|(?!<<)[^''")$`]|(?&code))*'

    #FUXME: A non-recursive version (e.g., matching "$ughugh") needs to be
    #defined as well, and a new umbrella PCRE matching both recursive and non-
    #recursive variable expansions assigned the overarching group "<var>".

    # local pcre_quotes_single_grouped="'((?:[^']|'')*)'"
    # local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    #FUXME: Also match process substitutions (of both ilk).
    #
    #Since zsh appears to search for terminating '"' delimiters in a prior
    #phase to that of variable expansions, we do *NOT* need to match variable
    #expansion here. (Isn't that nice?)

    #FUXME: Embedding ${pcre_quotes_single} here clearly isn't quite right.
    #While we *DO* want to match single quotes, we want to do so in a
    #"(?qsingle)" manner. Moreover, we want to match considerably more than
    #simply that: double quotes, here-doc strings, and so forth. *sigh*

    #FUXME: Unify with ${pcre_word}, perhaps?
    #FUXME: Right. ${pcre_code} should subsume ${pcre_word}, adding support for
    #here-documents and -strings. (Anything else?)

    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE. Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    # local pcre_here_doc_prefix='<<-?\s*+(?|'${pcre_quotes_single_inescapable_grouped}'|'${pcre_quotes_double_inescapable_grouped}'|'${pcre_word_inescapable_grouped}')\R'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\R(?-1)'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    # Here-string.
    # local pcre_here_string='<<<\s*+(?&word)'

    #FUXME: Excise the above? Shift documentation here!

    #FUXME: No longer required, seemingly. Now that we've merged such matching
    #into ${pcre_chars_unreserved}, excise such PCRE.

 # (Since this PCRE is principally used to match here
    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # cannot 
    #
    # we have no sane means of
    # matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string).
    #
    # Why? Character escapes.  We're inclined
    #to ignore this, at the moment.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Fairly sure we can simplify this quite a bit. We don't *NEED* to
    #match individual arguments on the initial match of the full macro string.
    #In fact, we're fairly sure we don't *EVER* need to match individual
    #arguments. Hence, we can probably generalize ${pcre_arg_command} above
    #with whitespace as follows:
    #
    #    local pcre_arg_command='(?:'${pcre_spaces}'|'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'
    #
    #Of course, that immediately suggests we combine ${pcre_spaces} and
    #${pcre_sans_quotes_spaces} -- probably by omitting "\s" from the
    #definition of the latter. (In any case, it's all for the morrow!)

    # "$"- or "`"-prefixed embedded substitutable.
    # local pcre_substitutable_embedded='(?=[$`])(?&sub)'

# (?>[$`])

    #FUXME: O.K.; we're not going to be able to substitute this below as is.
    #The reason why is the "[^$]". We're afraid that will need to be extended
    #on a case-by-case basis. After doing so, we'll probably want to excise
    #this local entirely.

    # Any character excluding "$" *OR* a "$"-prefixed substitutable.
    # local pcre_char_or_substitutable='\\$|[^$]|(?&sub)'

    #FUXME: Also match recursively nestable process substitution.

    # While we prefer *NOT* to explicitly
    # match arithmetic substitutions, matching only the latter would match one ")" delimiter
    # in arithmetic substitutions as terminating such substitutions -- which,
    # clearly, is not the case.

    #FUXME: For maintainability, we probably want to use embedded named
    #references everywhere we currently use zsh variable embedding below.

    # Arbitrary string of one or more characters excluding characters reserved
    # for strict zsh argument parsing. This includes:
    #
    # * Dollar signs.
    # * Single and double quotes.
    # * Whitespace.
    # local pcre_sans_quotes_spaces='[^\s''"$]++'

    # local pcre_arg_command='(?:'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'

    #FUXME: Interestingly, this must be constructed at runtime, implying this
    #entire anonymous function should be converted into a named function
    #::preprocessor_pcres.make() called on *EACH* call to :macro(). Hmm. For
    #efficiency, perhaps:
    #
    #* :macro() should simply set ${ZESHY__MACRO_PCRE} to the empty string.
    #* :code.preprocess() should call ::preprocessor_pcres.make() if
    #  ${ZESHY__MACRO_PCRE} is the empty string.
    #
    #This permits multiple macros to be defined by a single parcel without
    #triggering multiple redundant PCRE compilations, which seems sensible.
    #FUXME: For usability, define a function ::preprocessor_pcres.clear() in
    #this parcel clearing such PCRE globals.

    # One or more such arguments.
    # Unquoted word in the strict zsh sense, comprising one or more characters
    # excluding whitespace and shell-reserved characters.
    # local pcre_word_unquoted='[^]'

    #FUXME: We *DO* need to match variables as well. Here's why:
    #
    #    >>> print ${:-
    #    ... :func
    #    ... }
    #
    #    :func
    #
    #Yes, that actually works. It's a hell of an edge case, but edge case
    #nonetheless. For robustness, we *MUST* account for all such cases.

    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # local pcre_here_doc_prefix='<<-?\s*+(?|'${ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE}'|'${ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE}'|(\S++)\n'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\g{-1}'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

#FUXME: Document me.
# # PCRE globals defined below.
# typeset -g\
#     ZESHY_SYNTAX_QUOTES_SINGLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE
# 
# # PCREs matching single-quoted strings in zsh format and hence supporting
# # escaped single quotes (i.e., "''").
#          ZESHY_SYNTAX_QUOTES_SINGLE_PCRE="'(?:[^']|'')*'"
# ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE="'((?:[^']|'')*)'"
# 
# # Double-quoted string in zsh format and hence supporting escaped double
# # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
# # matches "\" and hence must be matched *AFTER* matching the latter.
#          ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE='"(?:\\"|[^"])*"'
# ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE='"((?:\\"|[^"])*)"'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
