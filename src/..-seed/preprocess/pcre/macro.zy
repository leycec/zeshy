#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs specific to macro preprocessing.

# ....................{ GLOBALS                            }....................
#FIXME: Document me.
typeset -g ZESHY_MACRO_ARG_BLOCK_NEXT_PCRE

# PCRE matching zero or more macros *OR* syntactic constructs possibly
# containing macro-like substrings, reporting:
#
# * Success on matching each macro and capturing such macro's name and all
#   arguments passed to such macro.
# * Failure on reaching the end of the string.
#
# When iterated over via calls to pcre_match(), such PCRE iteratively ignores
# all text until matching the next macro, at which point control is returned to
# the code block associated with such call; if no such macro exists, the end of
# the string is reached, at which point control is returned to the code
# following such code block. In either case, Odium and efficiency reigns.
typeset -g ZESHY_MACRO_PCRE

# Syntactically valid macro name.
typeset -g ZESHY_MACRO_NAME_VALID_PCRE

# Macro name placeholder. Since the set of all macro names changes with each call to a
# macro function (e.g., :macro_command(), :macro_command.undefine()), such
# name *CANNOT* be matched with a constant PCRE. Instead, we define such PCRE
# as an arbitrary placeholder to be subsequently replaced by higher-level
# macro-specific PCRE functions (e.g., ::preprocessor_pcres.make()).
typeset -g ZESHY__MACRO_NAME_PLACEHOLDER_PCRE='ZESHY__MACRO_NAME'

# PCRE to which ${ZESHY_MACRO_PCRE} is set if no macros exist.
typeset -g ZESHY__MACRO_PCRE_IF_EMPTY

# ....................{ MAIN                               }....................
#FIXME: Oh, God. Does any of this still apply? Probably, but shifting the chaff
#from the wheat isn't going to be terribly thrilling.

# Declare PCRE globals *NOT* reinitialized on each call to
# ::preprocessor_pcres.make().
#
# Note that escaped backslashes (i.e., "\\") should *ALWAYS* be match
# before attempting to match other escaped characters, as escaped
# backslashes are *NOT* escape characters (e.g., "\\n" is an escaped
# backslash preceding the character "n" rather than an escaped newline).
#
# Note also that both syntactically valid and invalid constructs should be
# matched. For example, ${} is a syntactically invalid variable expansion
# but must still be matched as a variable expansion. This prevents
# unmatched syntactically invalid constructs from being catastrophically
# matched as syntactically valid delimiters.
#
# The PCRE matching double-quoted strings provides a minimum length example
# correcting such issues:
#
#     local pcre_quotes_double='"(?:\\[\\"$`]|[^"$`]|(?&bed)|[^"])*"'
#
# Let's pick this apart. In order:
#
# 1. "\\[\\"$`]", matching any relevant escaped character, where the
#    meaning of "relevant" depends on the current syntactic construct.  In
#    the case of double-quoted strings, these are:
#    * An escaped backslash, preventing such backslash from escaping the
#      following character.
#    * An escaped '"' delimiter, preventing such delimiter from terminating
#      such match.
#    * An escaped "$" or "`" character, preventing such character from
#      initiating a variable expansion, arithmetic substitution, or process
#      substitution (as matched by the following subroutine call).
# 2. "[^"$`]", matching any irrelevant character, where the meaning of
#    "irrelevant" is the inverse of the meaning of "relevant" above
#    excluding backslashes. Since the prior alternative matched all
#    relevant escaped characters, all remaining escaped characters and
#    hence backslashes are irrelevant. Since the last alternative is a
#    fallback matching all characters excluding '"' delimiters, this
#    alternative is technically redundant. However, the following
#    alternative is a PCRE subroutine call -- which, by definition, incurs
#    non-negligible space and time costs. Since such call should be
#    performed *ONLY* if necessary, this alternative matches all characters
#    guaranteed *NOT* to be matched by such call.
# 3. "(?&bed)", matching any variable expansion, arithmetic substitution,
#    or process substitution. All such syntactic constructs are recursively
#    nestable and hence matchable only with subroutine calls. (Since
#    double-quoted strings are only indirectly recursively nestable, such
#    call is replacable in this specific case by the contents of the
#    corresponding PCRE ${pcre_embeddable}. In the general case,
#    however, subroutine calls are typically required.)
# 4. "[^"]", a fallback matching any unmatched character *NOT* the
#    terminating '"' delimiter. Assuming the prior alternatives matched
#    such syntactic construct correctly, this should be equivalent to
#    matching any unescaped "$" or "`" character. For robustness, it's
#    simplest to match any non-delimiter.
#
# Syntactic constructs delimited by substrings longer than a single
# character require negative lookahead to properly match. Since such
# lookahead is comparatively inefficient, defer such lookahead to the final
# alternative in the PCRE matching such constructs: e.g.,
#
#     # Instead of this...
#     local pcre_math_substitution_parens='\$\(\((?:\\[\\)$`]|(?!\)\))(?:[^)$`]|(?&bed)|.))*\)\)'
#
#     # ...just do this.
#     local pcre_math_substitution_parens='\$\(\((?:\\[\\)$`]|[^)$`]|(?&bed)|(?!\)\)).)*\)\)'

#FIXME: Excise all unused PCREs below.

#FIXME: Fairly confident that we can further optimize such PCREs by
#globally substituting non-atomic grouping syntax "(?:...)" for atomic
#grouping syntax "(?>...)". The difference between the two is as follows:
#
#* If any alternative in the latter succeeds, such group will *NEVER* be
#  backtracked into -- even if that results in a match failure.
#* By contrast, the former is always backtracked into on subsequent match
#  failures.
#
#We believe we've implicitly designed *ALL* alternation below to not
#require backtracking. That being said, we really won't know until we get
#the backtracking-capable version working first and then attempt to
#optimize into the backtracking-incapable version.
#FIXME: Similarly, most instances of "*", "+", and "?" may be suffixed by
#the possessive quantifier "+" as well.

() {
    # ..................{ CORE                               }..................
    # PCRE options. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   vexsome default, "." matches all characters excluding newline.)
    # * "(?m)", inducing:
    #   * "^" to match either the string start *OR* newline. (By default, "^"
    #     matches only the former.)
    #   * "$" to match either the string end *OR* newline. (By default, "$"
    #     matches only the former.)
    # * "(*BSR_ANYCRLF)", forcing "\R" to match *ONLY* ASCII newlines. (By
    #   default, "\R" matches both ASCII and UTF-8-encoded newlines.)
    local pcre_options='(?sm)(*BSR_ANYCRLF)'

    # PCRE options as above, as well as anchoring the current PCRE to the first
    # match point in the the substring currently being searched. For both
    # efficiency and consistency, iterative PCREs (i.e., PCREs iteratively
    # matching consecutive substrings in strings via pcre_match() and
    # ${ZPCRE_OP}) should *ALWAYS* be anchored, ensuring such PCREs only match
    # at the first byte following the last byte of the prior such match rather
    # than at any byte following such byte (the default).
    local pcre_options_anchored=${pcre_options}'\G'

    # Report success from the current match attempt, immediately returning the
    # currently matched substring and all previously captured groups.
    local pcre_report_success='(*ACCEPT)'

    # Report failure from the current match attempt, immediately returning.
    # Dismantled, this is:
    #
    # * "(*COMMIT)", reporting failure when backtracked into from a subsequent
    #   matching failure.
    # * "(*FAIL)", forcing backtracking by inducing a matching failure.
    #
    # Since the latter is immediately preceded by the former, the latter
    # backtracks into the former that then reports failure. (Nice one.)
    local pcre_report_failure='(*COMMIT)(*FAIL)'

    # Empty group, typically used to align group indices in a list of
    # "(?|"-driven alternatives.
    local pcre_empty_group='()'

    # PCRE subroutines defined below, concatenated in a manner preventing such
    # definitions from either matching *OR* capturing in place.
    #
    # Much like programmatic subroutines, PCRE subroutine are self-consistent units
    # preserving a semblance of local scope; for example, PCRE subroutines prevent
    # substrings captured by such calls from leaking to callers (e.g., subroutines,
    # zsh code) by snapshotting the state of all captured substrings on entering
    # such call and restoring such state on leaving such call. In other words,
    # subroutines impose non-negligible time and space costs.
    #
    # For efficiency, subroutines should be leveraged *ONLY* where required.
    # Typically, this means recursion matching delimiter-balanced syntactic
    # constructs in a context-free manner. In all other cases, PCREs should be
    # encapsulated as string variables and interpolated directly where used.
    local pcre_macro_subroutines_body

    # ..................{ CLASS ~ positive                   }..................
    # Character class bodies intended to be embedded *ONLY* in positive
    # character classes (i.e., *NOT* prefixed by "^").

    # Character class matching horizontal ASCII whitespace characters.
    local char_space_horizontal=' \t'

    # Character class matching vertical ASCII whitespace characters.
    local char_space_vertical='\r\n'

    # Character class matching ASCII whitespace characters.
    local char_space=${char_space_horizontal}${char_space_vertical}

    # Character class matching embeddable-reserved characters, including:
    #
    # * The "$" prefixing variable expansions *AND* arithmetic and recursive
    #   process substitutions.
    # * The "`" prefixing non-recursive process substitutions.
    local char_embeddable_prefix='$`'

    # Character class matching substitutable-reserved characters, including all
    # embeddable-reserved characters as well as the "=" prefixing "=("-prefixed
    # recursive process substitutions.
    local char_substitutable_prefix=${char_embeddable_prefix}'='

    # Character class matching interpretable-reserved characters, including all
    # substitutable-reserved characters as well as the "<" and ">" prefixing
    # "<("- and ">("-prefixed recursive process substitutions respectively.
    local char_interpretable_prefix=${char_substitutable_prefix}'<>'

    # Character class matching interpretable-reserved characters, excluding the
    # "`" delimiting such process substitutions. To construct such character
    # class, we prefer the direct approach to replicating such "_sans_backtick"
    # variable structure above.
    local char_interpretable_prefix_sans_backtick='$=<>'

    # ..................{ CLASS ~ negative                   }..................
    # Character class bodies intended to be embedded *ONLY* in negative
    # character classes (i.e., prefixed by "^"). Since escaped characters must
    # be explicitly matched and hence *NOT* implicitly matched by such classes,
    # such classes must *ALWAYS* contain the character escape "\".
    #
    # This is significant enough to warrant repeating, in bold plaintext:
    # *ALL NEGATIVE CHARACTER CLASSES MUST CONTAIN "\".*

    # Character class matching the subset of shell-reserved characters whose
    # corresponding syntactic constructs conflict with macro preprocessing.
    # Since vertical whitespace delimits commands and horizontal whitespace
    # delimits command arguments, this includes *ALL* whitespace characters.
    local char_not_code_prefix=${char_space}'''"$<\\`'

    # Character class matching embeddable- and substitutable-reserved
    # characters for use in negative character classes -- and hence including
    # character escape "\".
    local char_not_embeddable_prefix=${char_embeddable_prefix}'\\'

    # Character class matching unconditionally invalid characters in unquoted
    # shell words, corresponding one-for-one to the set of all unconditionally
    # shell-reserved operators conflicting with preprocessing parsing (i.e.,
    # ASCII punctuation syntactically parsed in an unconditional manner,
    # typically terminating the prior command). This class omits
    # unconditionally shell-reserved operators *NOT* conflicting with
    # preprocessing, including "*", "!", "^", and "?".
    #
    # This class also omits conditionally shell-reserved characters, including:
    #
    # * "{", a block prefix when the first character of unquoted shell words.
    # * "}", a block suffix when the last character of unquoted shell words.
    # * "#", a comment prefix when the first character of unquoted shell words.
    #   In all other instances, "#" is a glob operator.
    #
    # Matching such characters as shell-reserved requires more than merely a
    # character class.
    local char_not_subword_unquoted=${char_space}'''"$&;\\<>|`'

    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(" but *NOT* ")"
    # character. While both characters are intended to be matched elsewhere in
    # a balanced manner, treating "(" as invalid in uquoted shell words
    # prevents a "(" *NOT* balanced by a following ")" from being matched --
    # which would be decidedly bad.
    local char_not_subword_unquoted_or_paren_right=${char_not_subword_unquoted_with_parens_balanced}')'

    # Character class matching additionally invalid characters in the first
    # character of unquoted shell words. For use in negative lookahead, such
    # class matches only characters uniquely invalid in such character.
    local char_not_subword_unquoted_char_first='#{'

    # Character class matching invalid characters at all character positions of
    # macro names except the first, for which additional constraints apply.
    # This comprises all ASCII- and UTF-8-encoded characters excluding PCRE-
    # *AND* shell-reserved ASCII characters.
    #
    # Technically, since PCRE-reserved characters in macro names *COULD* be
    # explicitly escaped, only shell-reserved characters need to be prohibited.
    # For simplicity, we currently prohibit both.
    #
    # Technically, zsh permits the shell-reserved characters "!" and "#" to be
    # configured via string global ${histchars}. While we could generalize our
    # current hard-coding of such characters with an expansion of such global
    # here (taking care to escape character class-reserved characters), doing
    # so would unhelpfully render the set of all syntactically valid macro
    # names a dynamic function of current shell state -- implying that some
    # names would be only conditionally syntactically valid. Since that would
    # be unequivocally bad, we ignore such technicalities...
    local char_not_macro_name_char_rest=${char_reserved}'*+?!#^(){}[]'

    # Character class matching invalid characters at the first character
    # position of macro names, for which additional constraints apply (e.g.,
    # "~", expanded to the current user's home directory when the first
    # character of unquoted shell words).
    local char_not_macro_name_char_first='~='${char_not_macro_name_char_rest}

    # ..................{ SPACE                              }..................
    # One or more horizontal or vertical whitespace characters.
    local pcre_spaces='['${char_space}']++'

    # Zero or more horizontal or vertical whitespace characters.
    local pcre_spaces_optional='['${char_space}']*+'

    # One horizontal ASCII whitespace character (i.e., space or tab). For
    # efficiency, omit horizontal UTF-8-encoded whitespace characters and hence
    # the generic character type "\h". Since PCRE provides an option for
    # preventing "\R" but *NOT* "\h" from matching UTF-8-encoded characters, we
    # have little choice but to manually define such character class. See
    # subsection "Generic character types" at:
    #      http://www.pcre.org/pcre.txt
    local pcre_space_horizontal='['${char_space_horizontal}']'

    # One or more horizontal whitespace characters.
    local pcre_spaces_horizontal=${pcre_space_horizontal}'++'
    local pcre_spaces_horizontal_grouped='('${pcre_spaces_horizontal}')'

    # Zero or more horizontal whitespace characters.
    local pcre_spaces_horizontal_optional=${pcre_space_horizontal}'*+'

    # One or two vertical ASCII whitespace characters. Specifically:
    #
    # * Unix-specific linefeed (i.e., "\n").
    # * Windows-specific carriage return followed linefeed (i.e., "\r\n").
    local pcre_space_vertical='\R'

    # One or more vertical whitespace characters.
    local pcre_spaces_vertical=${pcre_space_vertical}'++'

    # Any character other than a vertical whitespace character. Since PCRE
    # provides no inverse of "\R" as it does with most other generic types
    # (e.g., "\S", "\H", "\V"), we manually invert such type with a traditional
    # negative character class.
    local pcre_char_sans_space_vertical='[^'${char_space_vertical}']'

    # One or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments, single-quoted strings).
    local pcre_chars_sans_space_vertical=${pcre_char_sans_space_vertical}'++'
    local pcre_chars_sans_space_vertical_optional=${pcre_char_sans_space_vertical}'*+'

    # Line continuation (i.e., an unescaped backslash followed by a newline),
    # continuing the command corresponding to the current line to the next
    # line. As discussed above, newlines preceded by two backslashes are *NOT*
    # line continuations and must *NOT* be matched as such.
    local pcre_line_continuation='\\'${pcre_space_vertical}

    # Line continuation followed by optional whitespace.
    local pcre_line_continuation_spaceable=${pcre_line_continuation}${pcre_spaces_optional}

    # Line continuation followed by optional horizontal whitespace.
    local pcre_line_continuation_spaceable_horizontal=${pcre_line_continuation}${pcre_spaces_horizontal_optional}

    # One or more line continuations.
    local pcre_line_continuations='(?:'${pcre_line_continuation}')++'

    # Zero or more line continuations.
    local pcre_line_continuations_optional='(?:'${pcre_line_continuation}')*+'

    # One or more line continuations, each followed by optional whitespace.
    local pcre_line_continuations_spaceable='(?:'${pcre_line_continuation_spaceable}')++'

    # Zero or more line continuations, each followed by optional whitespace.
    local pcre_line_continuations_spaceable_optional='(?:'${pcre_line_continuation_spaceable}')*'

    # One or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_line_continuations_spaceable_horizontal='(?:'${pcre_line_continuation_spaceable_horizontal}')+'

    # Zero or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_line_continuations_spaceable_horizontal_optional='(?:'${pcre_line_continuation_spaceable_horizontal}')*'

    # One horizontal whitespace character optionally prefixed by line
    # continuations. This PCRE is principally intended for lookahead.
    local pcre_space_horizontal_continuable=${pcre_line_continuations_optional}${pcre_space_horizontal}

    # One or more whitespace characters *NOT* preceded by line continuations,
    # optionally interspersed by line continuations.
    #
    # Since line continuations are merely ignorable rather than actual
    # whitespace, such substrings *MUST* include at least one whitespace
    # character. Whereas escaped newlines are line continuations preserving the
    # current command and hence effectively whitespace, unescaped newlines are
    # effectively semicolons terminating such command and hence non-whitespace.
    local pcre_spaces_continuable=${pcre_spaces}${pcre_line_continuations_spaceable_optional}

    # One or more horizontal whitespace characters *NOT* preceded by line
    # continuations, optionally interspersed by line continuations.
    local pcre_spaces_horizontal_continuable=${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}

    # One or more whitespace characters optionally interspersed with line
    # continuations.
    local pcre_continuable_spaces=${pcre_line_continuations_optional}${pcre_spaces_continuable}

    # One or more horizontal whitespace characters optionally interspersed with
    # line continuations, comprising *ALL* whitespace delimiting one shell word.
    local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}${pcre_spaces_horizontal_continuable}

    # Zero or more whitespace characters *OR* line continuations.
    local pcre_spaces_continuable_optional='(?:'${pcre_spaces}'|'${pcre_line_continuation}')*+'

    # Zero or more horizontal whitespace characters *OR* line continuations.
    local pcre_spaces_horizontal_continuable_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*+'

    # Start and end of the subject string (i.e., the string currently being
    # matched).
    local pcre_string_start='\A'
    local pcre_string_end='\z'

    # Start of the current line, consuming one or more prefixing vertical
    # whitespace characters if any. "^" is a zero-width assertion consuming no
    # characters and hence inappropriate for use below (excluding lookahead).
    local pcre_line_start='('${pcre_spaces_vertical}'|'${pcre_string_start}')'

    # End of the current line *WITHOUT* consuming the suffixing vertical
    # whitespace character if any. Since ${pcre_line_start} already consumes
    # such character as a line prefix, permitting another general-purpose PCRE
    # to consume the same character would prevent either from matching in a
    # general-purpose manner. (That's bad.)
    local pcre_line_end='$'

    # Start of the current line followed by zero or more horizontal whitespace
    # characters *OR* one or more horizontal whitespace characters.
    local pcre_line_start_or_spaces_horizontal='(?:'${pcre_spaces_horizontal}'|'${pcre_line_start}${pcre_spaces_horizontal_optional}')'

    # Zero or more line continuations followed by either the end of the current
    # line *OR* a whitespace character. While consuming suffixing whitespace is
    # typically discouraged, this PCRE is principally intended for use in
    # positive lookahead.
    local pcre_line_end_or_space_continuable=${pcre_line_continuations_optional}'(?:'${pcre_space_horizontal}'|'${pcre_line_end}')'

    # ..................{ CHAR                               }..................
    # Character *OR* the end of such string.
    local pcre_char_optional='(?:.|'${pcre_string_end}')'

    # Block prefix and suffix. As
    # ${char_not_subword_unquoted_with_parens_balanced} details, both conflict
    # with unquoted shell word syntax (which permits such prefix when *NOT* the
    # first character and such suffix when *NOT* the last character of such
    # word) and hence require disambiguation.
    local pcre_char_block_prefix='\{'
    local pcre_char_block_suffix='\}'

    # Escaped character (i.e., "\"-prefixed character). To account for
    # syntactically invalid "\" characters immediately prefixing the end of
    # such string, shenanigans appear.
    local pcre_char_escaped_optional='\\'${pcre_char_optional}

    # Invalid character in the first character of unquoted shell words.
    local pcre_char_not_subword_unquoted_char_first='['${char_not_subword_unquoted_char_first}']'

    # One or more unquoted shell word characters.
    local pcre_chars_subword_unquoted='[^'${char_not_subword_unquoted}']++'

    # One or more unquoted shell word characters excluding ")".
    local pcre_chars_subword_unquoted_sans_paren_right='[^'${char_not_subword_unquoted_or_paren_right}']++'

    # ..................{ CONSTRUCT                          }..................
    # Recursively embeddable syntactic construct (i.e., embeddable only in
    # arithmetic substitutions, double-quoted strings, or variable expansions).
    # Since recursive syntax is matchable *ONLY* via subroutine calls, this
    # PCRE calls a subsequently defined subroutine to do so. Since such calls
    # are comparatively inefficient, such call is performed *ONLY* if the
    # current character is a prefix of such a construct. Since such subroutine
    # will consume such character if called, we non-consumptively test such
    # character with positive lookahead. See ${pcre_macro_subroutines_body}.
    local pcre_embeddable='(?=['${char_embeddable_prefix}'])(?&emb)'

    # Recursively interpretable syntactic construct (i.e., replaceable with
    # any arbitrary unquoted shell word, regardless of whether such word is
    # passed to a preprocessor macro or not).
    local pcre_interpretable='(?=['${char_interpretable_prefix}'])(?&int)'

    # Recursively interpretable syntactic construct excluding "`"-delimited
    # process substitutions.
    local pcre_interpretable_sans_backtick='(?=['${char_interpretable_prefix_sans_backtick}'])(?&int)'

    # ..................{ STRING                             }..................
    # Single-quoted string *NOT* supporting escaped single quotes (i.e., "''").
    local pcre_quotes_single_literal_body="[^']*+"
    local pcre_quotes_single_literal="'"${pcre_quotes_single_literal_body}"'"
    local pcre_quotes_single_literal_grouped="'("${pcre_quotes_single_literal_body}")'"

    # Double-quoted string containing no embedded constructs, including 
    # escape prefix "\", variable expansions, arithmetic substitutions, or
    # process substitutions.
    local pcre_quotes_double_literal_body='[^"'${char_not_embeddable_prefix}']*+'
    local pcre_quotes_double_literal='"'${pcre_quotes_double_literal_body}'"'
    local pcre_quotes_double_literal_grouped='"('${pcre_quotes_double_literal_body}')"'

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local pcre_quotes_single_prefix="'"
    local pcre_quotes_single_suffix="(?:'|"${pcre_string_end}')'
    local pcre_quotes_single_body="(?>[^']++|'')*+"
    local pcre_quotes_single_optional=${pcre_quotes_single_prefix}${pcre_quotes_single_body}${pcre_quotes_single_suffix}

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    #
    # Since zsh appears to parse terminating '"' delimiters in a phase *BEFORE*
    # that of variable expansions, this PCRE can (and possibly should) avoid
    # matching such expansions here. Since such behaviour is arguably either
    # a bug or unreliable implementation detail, however, we match
    # substitutables embedded in double quotes in the same manner as that of
    # substitutables embedded in other syntax (e.g., arithmetic substitutions).
    local pcre_quotes_double_prefix='"'
    local pcre_quotes_double_suffix='(?:"|'${pcre_string_end}')'
    local pcre_quotes_double_body='(?:[^"'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}')*+'
    local pcre_quotes_double_optional=${pcre_quotes_double_prefix}${pcre_quotes_double_body}${pcre_quotes_double_suffix}

    # Single- or double-quoted string.
    local pcre_quotes_optional=${pcre_quotes_single_optional}'|'${pcre_quotes_double_optional}

    # Comment, necessarily prefixed by either one or more horizontal whitespace
    # characters *OR* the start of the current line. The former constraint
    # implies that comments must be explicitly matched *BEFORE* horizontal
    # whitespace. Likewise, the latter constraint implies that line
    # continuations must be explicitly matched *BEFORE* comments.
    local pcre_comment_body='#'${pcre_chars_sans_space_vertical_optional}
    local pcre_comment=${pcre_comment_body}${pcre_line_end}
    local pcre_comment_optional='(?:'${pcre_comment}')?+'

    # One or more whitespace characters followed by an optional comment.
    local pcre_comment_optional_spaced=${pcre_spaces}${pcre_comment_optional}

    # Zero or more whitespace characters followed by an optional comment when
    # preceded by one or more whitespace characters.
    local pcre_comment_spaced_optional=${pcre_spaces_optional}${pcre_comment_optional}

    # ..................{ TERMINATOR ~ spaced                }..................
    # PCREs below match command terminators (i.e., substrings terminating
    # the command preceding such terminator) requiring prefixing whitespace. 
    # Such terminators precede preprocessor macros and hence *MUST* be matched
    # with syntactic accuracy.

    #FIXME: Wait. For a truly general implementation, don't we need to join the
    #set of all global alias names... No. Well, possibly? Do all global aliases
    #terminate commands? They don't *NEED* to, of course, but they probably
    #almost certainly do. Hmm; contemplate further. Perhaps we want a new
    #subtype of global alias that when declared adds the name of such alias to
    #a global private list recording the names of all global aliases that also
    #terminate commands -- say, a new declarer
    #:alias_general_command_terminator().
    #
    #Clearly, implement this all *LATER*. For now, this suffices.

    # zeshy-specific command terminator.
    local pcre_command_end_zeshy=':(?:or|and|not)'

    # Command terminator requiring one or more prefixing *AND* one or more
    # suffixing whitespace characters, each optionally interspersed by line
    # continuations. Since this PCRE matches the latter but *NOT* the former,
    # PCREs embedding this PCRE *MUST* match the former.
    #
    # While non-consumptively matching suffixing whitespace (e.g., via positive
    # lookahead) is generally preferred to consumptively matching such
    # whitespace, adopting the latter approach here perfectly coincides with
    # both PCRE design and zsh behaviour.
    #
    # Technically, some such terminators are only prefixable in a syntactically
    # valid manner by horizontal whitespace characters  (e.g., ":and", ":or")
    # and *NOT* repeatable in a syntactically valid manner (e.g., ":or :or").
    # Since macro preprocessing is largely unconcerned with the syntactic
    # validity of non-macros, however, such technicalities are ignorable.
    local pcre_command_end_spaced=${pcre_command_end_zeshy}${pcre_continuable_spaces}

    # One or more command terminators requiring one or more prefixing *AND* one
    # or more suffixing whitespace characters, each optionally interspersed by
    # line continuations.
    local pcre_command_ends_spaced_optional='(?:'${pcre_command_end_spaced}')*+'

    # ..................{ TERMINATOR ~ unspaced              }..................
    # PCREs below match command terminators requiring no prefixing whitespace.

    # "&"-prefixed command terminator, comprising a:
    #
    # * "&" or "&!" backgrounding.
    # * "&&" boolean AND operator.
    #
    # Since redirections do *NOT* terminate commands, this PCRE excludes both 
    # "&<"- and "&>"-formatted redirections.
    local pcre_command_end_ampersand='&[&!]?+'

    # Single-character command terminator excluding "{" block prefixes and
    # hence comprising only semicolons, terminating the prior command without
    # introducing additional semantics (e.g., piping, redirection).
    local pcre_command_end_char_sans_block_prefix=';'

    # Single-character command terminator, comprising both semicolons and "{"
    # block prefixes. Technically, such prefixes *MUST* be prefixed by either
    # horizontal or vertical whitespace when preceded by characters that are
    # *NOT* unspaced command terminators (e.g., "if { true } {"). Since shell
    # word-specific negative lookahead prevents such words from matching "{",
    # however, such technicalities are ignorable.
    local pcre_command_end_char='[{;]'

    # "|"-prefixed command terminator, comprising a:
    #
    # * "|" or "|&" pipe.
    # * "||" boolean OR operator.
    local pcre_command_end_pipe='\|[|&]?+'

    # Process substitution prefix command terminator. While the "`" prefixing
    # "`"-delimited process substitutions is also a command terminator,
    # matching the "`" suffixing such substitution requires an approach similar
    # to that with which we match the '"' suffixing double-quoted strings
    # containing process substitutions. Hence, this PCRE omits "`".
    #
    # For simplicity, "("- and ")"-delimited process forks are matched as well
    # (i.e., by matching the first character of such prefix optionally).
    # Interestinigly, while "(" cannot be the first character of unquoted shell
    # words, ")" *CAN* be (e.g., "ls *(/)"). This non-orthogonally differs from
    # the case of "{" and "}", of course.
    local pcre_command_end_process_prefix_sans_backtick='[$=<>]?+\('

    # One or more vertical whitespace command terminators.
    local pcre_command_end_spaces_vertical=${pcre_spaces_vertical}

    # "#"-prefixed command terminating comment.
    local pcre_command_end_comment=${pcre_comment_body}'(?:'${pcre_command_end_spaces_vertical}'|'${pcre_string_end}')'

    # Command terminator *NOT* requiring prefixing or suffixing whitespace,
    # excluding single-character command terminators.
    local pcre_command_end_unspaced_body=${pcre_command_end_spaces_vertical}'|'${pcre_command_end_comment}'|'${pcre_command_end_process_prefix_sans_backtick}'|'${pcre_command_end_pipe}'|'${pcre_command_end_ampersand}'|'${pcre_string_end}

    # Command terminator neither a "}" block suffix or requiring prefixing
    # or suffixing whitespace, optionally suffixed by horizontal whitespace
    # optionally interspersed by line continuations.
    local pcre_command_end_unspaced_sans_block_prefix='(?:'${pcre_command_end_char_sans_block_prefix}'|'${pcre_command_end_unspaced_body}')'${pcre_spaces_horizontal_continuable_optional}

    # Command terminator *NOT* requiring prefixing or suffixing whitespace,
    # optionally suffixed by horizontal whitespace optionally interspersed by
    # line continuations.
    local pcre_command_end_unspaced='(?:'${pcre_command_end_char}'|'${pcre_command_end_unspaced_body}')'${pcre_spaces_horizontal_continuable_optional}

    # ..................{ TERMINATOR                         }..................
    # Command terminator optionally prefixed by horizontal whitespace
    # optionally interspersed by line continuations and optionally suffixed by
    # one or more command terminators requiring both prefixing and suffixing
    # whitespace.
    #
    # Despite the variable name, this PCRE matches at most one command
    # terminator requiring no such whitespace. While this superficial
    # discrepancy is unfortunate, the current approach is nonetheless the
    # optimal solution if all PCREs preceding this PCRE are optional. Since
    # commands *MUST* consist of at least one terminator but may otherwise be
    # empty (e.g., ";;;", the syntactically valid concatenation of three such
    # terminators), this assumption *SHOULD* always hold.
    local pcre_command_ends='(?:'${pcre_spaces_horizontal_continuable}'(?:'${pcre_command_end_unspaced}'|'${pcre_command_end_spaced}')|'${pcre_command_end_unspaced}')'${pcre_command_ends_spaced_optional}

    # One or more command terminators excluding "}" block prefixes.
    local pcre_command_ends_sans_block_prefix='(?:'${pcre_spaces_horizontal_continuable}'(?:'${pcre_command_end_unspaced_sans_block_prefix}'|'${pcre_command_end_spaced}')|'${pcre_command_end_unspaced_sans_block_prefix}')'${pcre_command_ends_spaced_optional}

    # ..................{ WORD ~ lookahead                   }..................
    # Syntactic construct prefix containing "(", prefixing:
    #
    # * "(("- and ")"-delimited arithmetic tests, conflicting with unquoted
    #   shell word syntax (which otherwise permits balanced "(" and ")"
    #   characters) and hence requiring disambiguation.
    # * "=("- and ")"-delimited process substitution prefix, conflicting with
    #   unquoted shell word syntax (which otherwise permits unquoted "=" and
    #   balanced "(" and ")" characters) and hence requiring disambiguation.
    local pcre_word_lookahead_parens='[(=]\('

    # Negative lookahead preventing substrings that would otherwise be matched
    # as unquoted shell words from being matched as such. By PCRE design, zsh
    # command terminators (e.g., "<") are excluded from unquoted shell words
    # and hence need *NOT* be matched here. Instead, we match:
    #
    # * Block prefix and suffix. As
    #   ${char_not_subword_unquoted_with_parens_balanced} details, both
    #   conflict with unquoted shell word syntax (which permits such prefix
    #   when *NOT* the first character and such suffix when *NOT* the last
    #   character of such word) and hence require disambiguation.
    # * zeshy-specific command terminators implemented as global aliases whose
    #   syntax conflicts with unquoted shell word syntax. Since zsh expands
    #   global aliases globally and hence in ":is"- and "[["-prefixed tests,
    #   preventing unquoted shell words from containing such aliases adequately
    #   prevents such conflict. (Hence, such test syntax needn't be
    #   explicitly matched elsewhere.)
    #
    # Technically, this PCRE should *NOT* match:
    #
    # * Redirection prefixed by an integer-based file descriptor (e.g.,
    #   "1>&2"), conflicting with unquoted shell word syntax. However, since
    #   both shell words and redirections are parsed only for purposes of
    #   disambiguation, matching such descriptor as an unquoted shell word
    #   rather than redirection is of no consequence. (Note that redirections
    #   prefixed by file descriptors specified as "{"- and "}"- delimited
    #   variable names are prefixed by "{" and hence already prevented from
    #   matching unquoted shell word syntax.)
    local pcre_word_lookahead='(?!'${pcre_char_not_subword_unquoted_char_first}'|'${pcre_command_end_zeshy}'|'${pcre_word_lookahead_parens}')'

    # Negative lookbehind preventing substrings that would otherwise be matched
    # as unquoted shell words from being matched as such.
    local pcre_word_lookbehind='(?<!'${pcre_char_block_suffix}')'

    # ..................{ WORD ~ literal                     }..................
    # Unquoted literal shell word, comprising only unreserved characters.
    local pcre_word_literal=${pcre_word_lookahead}${pcre_chars_subword_unquoted}${pcre_word_lookbehind}
    local pcre_word_literal_grouped='('${pcre_word_literal}')'

    # ..................{ WORD ~ here                        }..................
    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE.  Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Consequently, only the proper subset of here-documents with delimiters
    # containing no escaped characters is matchable. Since few to no real-world
    # here-documents (certainly none zeshy itself leverages) require delimiters
    # containing such characters, this is largely ignorable.
    #
    # Such matching requires capturing and then subsequently backreferencing
    # such delimiter, fundamentally interfering with capture group indices. To
    # avoid such interference, segregate such match inside a subroutine call.
    # In analogous fashion to function-scoped local variables, such calls
    # isolate capture groups by storing the current set of such groups on
    # entering such call and restoring such set on returning from such call.

    #FIXME: Given that grouped macros are now always matched first and all
    #capture groups matched in a relative manner, we probably don't need to
    #encapsulate this in a subroutine anymore. For simplicity, however, retain
    #the current approach until arriving at the testing phase.

    local pcre_here_doc_prefix='-?'${pcre_spaces_horizontal_continuable_optional}'(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_literal_grouped}')'${pcre_space_vertical}
    local pcre_here_doc_body='.*?'
    local pcre_here_doc_suffix='(?:'${pcre_space_vertical}'(?-1)'${pcre_line_end}'|'${pcre_string_end}')'
    pcre_macro_subroutines_body+='(?<doc>'${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}')'

    # "<"-prefixed here-document or "<<"-prefixed here-string. The latter
    # prefix greedily overlaps the former prefix and must hence be matched
    # first. Since here-strings are shell words, since subsequent parsing
    # already matches such words, and since syntactically invalid here-strings
    # must also be matched, only such prefix is matched here.
    #
    # Since syntactically valid here-documents with delimiters containing
    # escaped characters (e.g., "<<war\ is\ peace") *MUST* be matched but, by
    # the above discussion, cannot actually be matched in a syntactically valid
    # manner via PCREs, such here-documents are only matchable in a
    # syntactically invalid manner via PCREs. To do so, only the "<<" suffixing
    # such here-documents is matched here by matching the proper subset of
    # here-documents that is matchable here optionally. All text following such
    # suffix will be matched by subsequent PCREs as arbitrary code, implying
    # that here-document text will be preprocessed for macros. While hardly
    # ideal, this is (arguably) the ideal solution achievable via PCREs.
    local pcre_here_optional='<(?:<|(?&doc)?+)'

    # ..................{ REDIRECTION                        }..................
    # Redirections are largely incidental to preprocessor parsing but must
    # nonetheless be partially matched for disambiguation with command
    # terminators and unquoted shell words. For example, since "&!" is a
    # command terminator while "&>" is not, matching merely an unquoted "&"
    # character is insufficient to identify a "&"-prefixed command terminator.

    # Redirection. Since command arguments may be freely interspersed with
    # redirections, redirections must be disambiguated from command terminators
    # with overlapping syntax -- particularly, "&"-prefixed command terminators
    # "&", "&!", and "&&". In addition to "<<"-prefixed here-documents and
    # -strings, the following redirections are matched:
    #
    # "<", "<>", ">", ">|", ">!", ">>", ">>|", ">>!", "<&", ">&", "&>", ">&|",
    # ">&!", "&>|", "&>!", ">>&", "&>>", ">>&|", ">>&!", "&>>|", and "&>>!".
    #
    # Since matching "<("- and ">("-prefixed process substitution redirections
    # requires recursion and hence subroutine calls exceeding the scope of this
    # PCRE, a "(" *MUST* be prevented from matching after a "<" or ">" is
    # matched with negative lookahead.
    #
    # See section "REDIRECTION" of "man zshmisc".
    local pcre_redirect_lookahead='(?!\()'
    local pcre_redirect_less_than='<(?:'${pcre_here_optional}'|[&>]|'${pcre_redirect_lookahead}')'
    local pcre_redirect_greater_than_char='>'${pcre_redirect_lookahead}
    local pcre_redirect_greater_than=${pcre_redirect_greater_than_char}'>?+&?+[!|]?+'
    local pcre_redirect_ampersand='&'${pcre_redirect_greater_than_char}'>?+[!|]?+'
    local pcre_redirect=${pcre_redirect_less_than}'|'${pcre_redirect_greater_than}'|'${pcre_redirect_ampersand}

    # ..................{ WORD ~ picoword                    }..................
    # Smallest syntactic component, matching only character escapes,
    # single-quoted strings, and double-quoted strings.
    local pcre_picoword_sans_redirect=${pcre_char_escaped_optional}'|'${pcre_quotes_optional}

    # Smallest syntactic component, matching only character escapes,
    # single-quoted strings, double-quoted strings, and redirections.
    local pcre_picoword=${pcre_picoword_sans_redirect}'|'${pcre_redirect}

    # ..................{ WORD ~ nanoword                    }..................
    # Smaller syntactic component, matching only character escapes,
    # single-quoted strings, double-quoted strings, redirections, and unquoted
    # shell word characters.
    local pcre_nanoword=${pcre_chars_subword_unquoted}'|'${pcre_picoword}

    # Smaller syntactic component *NOT* containing "}".
    local pcre_nanoword_sans_paren_right=${pcre_chars_subword_unquoted_sans_paren_right}'|'${pcre_picoword}

    # Smaller syntactic component *NOT* containing "}" or redirections.
    local pcre_nanoword_sans_paren_right_redirect=${pcre_chars_subword_unquoted_sans_paren_right}'|'${pcre_picoword_sans_redirect}

    # ..................{ WORD ~ subword : non-qualifier     }..................
    # Syntactic component permitting matching of the "`" suffixing "`"-
    # delimited process substitutions.
    local pcre_subword_backtickable=${pcre_nanoword}'|'${pcre_interpretable_sans_backtick}

    # Syntactic component permitting matching of strictly balanced braces.
    # Since matching strictly balanced parens is incidental to such matching,
    # such syntax is matched in any order.
    local pcre_subword_braceable=${pcre_nanoword}'|'${pcre_interpretable}

    # ..................{ WORD ~ subword : qualifier         }..................
    # Glob qualifiers are non-nestable and hence matchable without recursion
    # (e.g., via subroutine calls), but *CAN* nest other syntactic constructs
    # (e.g., single-quoted strings).

    # Glob qualifier prefix and suffix.
    local pcre_glob_qualifier_prefix='\((?:'
    local pcre_glob_qualifier_suffix=')*+\)'

    # Syntactic component permitting matching of strictly balanced parens.
    local pcre_subword_parenable_sans_glob_qualifier=${pcre_nanoword_sans_paren_right}'|'${pcre_interpretable}

    # Glob qualifier permitting matching of strictly balanced parens.
    local pcre_subword_parenable_glob_qualifier=${pcre_glob_qualifier_prefix}${pcre_subword_parenable_sans_glob_qualifier}${pcre_glob_qualifier_suffix}

    # Syntactic construct permitting matching of strictly balanced parens.
    # Since the strictly balanced parens and hence "(" matched by
    # ${pcre_subword_parenable_glob_qualifier} takes precedence over the
    # unbalanced "(" matched by ${pcre_subword_parenable_glob_qualifier}, the
    # former *MUST* be matched first.
    local pcre_subword_parenable=${pcre_subword_parenable_glob_qualifier}'|'${pcre_subword_parenable_sans_glob_qualifier_parens}

    # ..................{ WORD                               }..................
    # Note that since an unbalanced "}" block suffix terminates most types of
    # shell words (e.g., due to such word being embedded in a "{"- and
    # "}"-delimited block), PCREs below avoid matching such suffix via
    # negative lookbehind. PCREs below *NOT* embedding such lookbehind thus
    # match unbalanced "}" block suffixes.

    # Shell word containing one or more syntactic constructs permitting
    # matching of "`"-delimited process substitutions.
    local pcre_word_backtickable=${pcre_word_lookahead}'(?:'${pcre_subword_backtickable}')++'

    # Shell word containing one or more syntactic constructs permitting
    # matching of strictly balanced braces -- namely, by preventing unbalanced
    # "}" block suffixes from being matched here with negative lookbehind.
    local pcre_word_braceable=${pcre_word_lookahead}'(?:'${pcre_subword_braceable}')++'${pcre_word_lookbehind}

    # ..................{ WORD ~ parenable                   }..................
    # One or more syntactic constructs permitting matching of strictly balanced
    # parens.
    local pcre_subwords_parenable='(?:'${pcre_subword_parenable}')++'

    # Zero or more syntactic constructs permitting matching of strictly
    # balanced parens.
    local pcre_subwords_parenable_optional='(?:'${pcre_subword_parenable}')*+'

    # Shell word following the first such word for the current command,
    # containing one or more syntactic constructs permitting matching of
    # strictly balanced parens.
    local pcre_word_parenable_nonfirst=${pcre_word_lookahead}${pcre_subwords_parenable}

    # List assignment, whose syntax frequently conflicts with that of parent
    # syntactic constructs and hence must be explicitly matched. Specifically:
    #
    # * The delimiting ")" conflicts with the ")" delimiting possibly
    #   recursively nested process substitutions.
    # * List assignments prohibit syntax otherwise permitted in such parents
    #   (e.g., "<("- and ")"-delimited process substitutions).
    #
    # Technically, list assignments may only contain passable syntactic
    # constructs (i.e., constructs embeddable in command arguments). However,
    # enforcing such constraint would require defining PCREs matching such
    # constructs in an inefficient subroutine-based manner above rather than in
    # an efficient embedding-based manner below. Since such constraint is
    # ignorable for preprocessing purposes, we match arbitrary code in list
    # assignments with previously defined PCREs instead.
    local pcre_list_assignment_prefix=':=\('${pcre_comment_spaced_optional}
    local pcre_list_assignment_suffix=${pcre_comment_spaced_optional}'(?:\)|'${pcre_string_end}')'
    local pcre_list_assignment_body=${pcre_word_parenable_nonfirst}'(?:'${pcre_comment_optional_spaced}${pcre_word_parenable_nonfirst}')*+'
    local pcre_list_assignment=${pcre_list_assignment_prefix}${pcre_list_assignment_body}${pcre_list_assignment_suffix}

    # First shell word for the current command, containing one or more
    # syntactic constructs permitting matching of strictly balanced parens.
    #
    # Since list assignments are prefixed by variable names indistinguishable
    # from and hence conflicting with unquoted shell words, the former *MUST*
    # be matched first. Since only a first shell word is in command position
    # and hence can be a list assignment, do so only here.
    local pcre_word_parenable_first='(?:'${ZESHY_VAR_NAME_PCRE}'(?:'${pcre_list_assignment}'|'${pcre_subwords_parenable_optional}')|'${pcre_word_parenable_nonfirst}')'

    # ..................{ WORDS                              }..................
    # Zero or more shell words permitting matching of "`"-delimited process
    # substitutions, each delimited by one or more horizontal whitespace
    # characters optionally interspersed by line continuations.
    local pcre_words_backtickable_optional='(?:'${pcre_word_backtickable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_backtickable}')*+)?+'

    # One or more shell words permitting matching of strictly balanced braces,
    # each delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    local pcre_words_braceable=${pcre_word_braceable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_braceable}')*+'

    # Zero or more shell words permitting matching of strictly balanced parens,
    # each delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    local pcre_words_parenable_optional='(?:'${pcre_word_parenable_first}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_parenable_nonfirst}')*+)?+'

    # ..................{ COMMANDS ~ parenable               }..................
    # Zero or more commands permitting matching of strictly balanced parens.
    local pcre_commands_parenable_optional='(?:'${pcre_words_parenable_optional}${pcre_command_ends}')*+'

    # Zero or more commands permitting matching of "`"-delimited processs
    # substitutions.
    local pcre_commands_backtickable_optional='(?:'${pcre_words_backtickable_optional}${pcre_command_ends}')*+'

    # ..................{ COMMANDS ~ braceable               }..................
    # "{"- and "}"-delimited block. Blocks are recursively nestable and hence
    # matchable only with subroutine calls.
    local pcre_block=${pcre_char_block_prefix}'(?&blk)'

    # Zero or more commands permitting matching of strictly balanced braces.
    local pcre_commands_braceable_optional='(?:'${pcre_block}'|'${pcre_words_braceable}')'${pcre_command_ends_sans_block_prefix}')*+'

    # "{"- and "}"-delimited block excluding such "{", defined as a recursively
    # callable subroutine.
    pcre_macro_subroutines_body+='(?<blk>'${pcre_commands_braceable_optional}${pcre_char_block_suffix}')'

    # ..................{ SUBSTITUTION ~ process             }..................
    #FIXME: Actually, we can also match macros in process substitutions
    #embedded in double quotes. Doing so, however, will require a smidgeon of
    #refactoring elsewhere and hence is probably warranted only after
    #finishing a reasonable first-draft implementation. The idea is simple:
    #since matching such macros requires "remembering" that such macro was
    #embedded in double quotes, that's actually what we do. Specifically:
    #
    #* Create a new PCRE
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped}, retaining
    #  the existing ${pcre_quotes_double} for use in all other syntactic
    #  contexts.  *
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped} should be
    #  identical to ${pcre_quotes_double} except that the former should
    #  explicitly avoid matching any syntactic prefix of a process substitution
    #  (e.g., "=(") embedded in such quotes, probably via negative lookahead.
    #  Such prefix will then be subsequently matched as a command terminator by
    #  ${pcre_macro} as desired.
    #* As the variable name implies,
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped} *MUST*
    #  capture a nonempty substring of such double quotes -- say, the prefixing
    #  '"'. Such group permits the preprocessor to reliably detect when a
    #  macro-interrupted double quotes has been matched. Note that, to do so,
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped} *CANNOT*
    #  be matched within a subroutine call.
    #* Rename the existing PCRE globals ${ZESHY__MACRO_PCRE_PREFIX},
    #  ${ZESHY__MACRO_PCRE_SUFFIX}, and ${ZESHY_MACRO_PCRE} to
    #  ${ZESHY__MACRO_UNQUOTED_PCRE_PREFIX},
    #  ${ZESHY__MACRO_UNQUOTED_PCRE_SUFFIX}, and ${ZESHY_MACRO_UNQUOTED_PCRE}.
    #  The preprocessor should use the latter global by default when performing
    #  PCRE-based iteration.
    #* Create new PCRE globals ${ZESHY__MACRO_QUOTED_PCRE_PREFIX},
    #  ${ZESHY__MACRO_QUOTED_PCRE_SUFFIX}, and ${ZESHY_MACRO_QUOTED_PCRE}. The
    #  preprocessor should use the latter global only when performing
    #  PCRE-based iteration *AFTER* having just matched a macro embedded in a
    #  process substitution embedded in double quotes.
    #
    #And... that's it. Clearly feasible, if a fair amount of work. In any case,
    #such improvements are doubtless fodder for another code day.
    #FIXME: All of the above applies to "`"-delimited process substitutions as
    #well, which we currently fail to match and expand macros in.
    #FIXME: Wait. There's clearly a combinatorial explosion issue here: we'd
    #also like to match macros embedded in "$("- and ")"-delimited process
    #substitutions embedded in syntactic constructs (e.g., "${"- and
    #"}"-delimited recursive variable expansions). While matching such "$(" as
    #a command terminator *SHOULD* be feasible with named capture groups and/or
    #negative lookahead, there's obviously no way that we could restore
    #matching arbitrarily nested constructs in a balanced manner.
    #
    #Given that, we clearly won't be able to match macros in all possible
    #contexts. In that case, we'd might as well abandon any thought of matching
    #macros in "`"-delimited process substitutions: while we *COULD* do that,
    #such substitutions are obsolete anyway. There's little gain to supporting
    #them, given that we won't be supporting a variety of constructs anyway.
    #
    #That said, we *SHOULD* still attempt to match macros in process
    #substitutions in double quotes, as that is the certainly the most common
    #lexical context in which process substitutions are used. Fortunately,
    #we've roadmapped that process (meagre pun intended) above.
    #FIXME: Oh, wait. I neglected to recall that we *ALREADY* match macros
    #embedded in arbitrarily nested process substitutions: namely, by simply
    #ignoring parens balancing. Which works perfectly servicably. Given that,
    #we *SHOULD* match macros nested in all single character-prefixed
    #constructs (e.g., double-quoted strings, "`"-delimited substitutions).

    # Process substitutions accept arbitrary zsh code and hence *SHOULD*
    # technically also accept arbitrary zeshy code -- including embedded
    # macros. Unfortunately, resuming PCRE-based matching after matching such a
    # macro would prevent the former from matching the delimiter suffixing the
    # syntactic construct embedding such embed. For example, consider the
    # following zeshy code attempting to embed a hypothetical macro :macro():
    #
    #    :string.output "$(:macro); :macro"; :macro
    #
    # While such macro is certainly matchable as a macro and subsequently
    # expandable, doing so would effectively disremember that such macro was
    # embedded within a process substitution embedded within a double-quoted
    # string. Since the substring '); :macro"; :macro" would then be
    # erroneously misinterpreted as top-level code on resuming PCRE-based
    # iteration, such ";" would likewise be matched as a command terminator
    # prefixing another ":macro", likewise matched as a macro and subsequently
    # expanded -- erroneously, of course. To compound matters, such '"' would
    # be matched as a prefixing rather than suffixing double-quoted string
    # delimiter, effectively destroying all subsequent parsing.
    #
    # In short, matching and expanding macros nested in process substitutions
    # is inherently infeasible in the current PCRE-based approach. Properly
    # matching and expanding such macros would require a genuine parser, at
    # which point the ideal decision would be to patch the "zsh" interpreter
    # itself with support for a macro preprocessing phase. Since this is far
    # beyond the scope of current work, the current approach and hence
    # limitations stand.

    # "`"-delimited process substitution.
    local pcre_process_substitution_backtick_prefix='`'
    local pcre_process_substitution_backtick_suffix='(?:`|'${pcre_string_end}')'
    local pcre_process_substitution_backtick_optional=${pcre_process_substitution_backtick_prefix}${pcre_commands_backtickable_optional}${pcre_process_substitution_backtick_suffix}

    # ")"-suffixed process substitution or fork, excluding prefixing substring
    # if any (e.g., "$(", "=(").
    local pcre_process_sans_paren_left_suffix='(?:\)|'${pcre_string_end}')'
    local pcre_process_sans_paren_left_optional=${pcre_commands_parenable_optional}${pcre_process_sans_paren_left_suffix}

    # "("- and ")"-delimited process fork, excluding such prefix.
    local pcre_process_fork_sans_paren_left_optional=${pcre_process_sans_paren_left_optional}

    # "("- and ")"-delimited process fork.
    local pcre_process_fork_optional='\('${pcre_process_sans_paren_left_optional}

    # "$("- and ")"-delimited process substitution, excluding such prefix.
    local pcre_process_substitution_sans_dollar_paren_left_optional=${pcre_process_sans_paren_left_optional}

    # "=("- and )"-delimited process substitution. Since such substitutions
    # expand to an absolute path and hence shell word, such substitutions are
    # embeddable in macro arguments. Since this is *NOT* the case for all other
    # redirection process substitutions, no comparable PCREs match the latter.
    local pcre_process_substitution_equals_optional='='${pcre_process_fork_optional}

    # Redirection process substitutions, comprising:
    #
    # * "=("- and ")"-delimited process substitutions implicitly creating and
    #   removing temporary files.
    # * "<("- and ")"-delimited process substitutions redirecting standard
    #   input.
    # * ">("- and ")"-delimited process substitutions redirecting standard
    #   output.
    local pcre_process_substitution_redirection_optional='[=<>]'${pcre_process_fork_optional}

    # ..................{ SUBSTITUTION ~ math                }..................
    # "$["- and "]"-delimited arithmetic substitution. While such delimiter
    # does *NOT* conflict with "$("- and ")"-delimited process substitutions,
    # the left bit-shift operator "<<" supported by such substitutions still
    # conflicts with here-document and -string prefixes.
    local pcre_math_substitution_braces_sans_dollar_prefix='\['
    local pcre_math_substitution_braces_sans_dollar_suffix='(?:\]|'${pcre_string_end}')'
    local pcre_math_substitution_braces_sans_dollar_body='(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}')*+'
    local pcre_math_substitution_braces_sans_dollar_optional=${pcre_math_substitution_braces_sans_dollar_prefix}${pcre_math_substitution_braces_sans_dollar_body}${pcre_math_substitution_braces_sans_dollar_suffix}

    # "(("- and "))"-delimited arithmetic construct, excluding the first such
    # "(" and prefixing character if any (e.g., "$(").
    local pcre_math_sans_paren_left_prefix='\('
    local pcre_math_sans_paren_left_suffix='(?:\)\)|'${pcre_string_end}')'
    local pcre_math_sans_paren_left_body='(?:[^)'${char_not_embeddable_prefix}']++|\)(?!\)|'${pcre_char_escaped_optional}'|'${pcre_embeddable}')*+'
    local pcre_math_sans_paren_left_optional=${pcre_math_sans_paren_left_prefix}${pcre_math_sans_paren_left_body}${pcre_math_paren_left_suffix}

    # "(("- and "))"-delimited arithmetic test excluding the first such "(",
    # whose syntax conflicts in a similar manner as discussed below.
    local pcre_math_test_sans_paren_left_optional=${pcre_math_sans_paren_left_optional}
    local pcre_math_test_optional='\('${pcre_math_test_sans_paren_left_optional}

    # "$(("- and "))"-delimited arithmetic substitution, excluding such "$("
    # but *NOT* the following "(". The following arithmetic syntax conflicts
    # with conventional syntax and hence *MUST* be matched for disambiguaty:
    #
    # * The "))" delimiting such substitutions overlap and hence conflict with
    #   the ")" delimiting "$("- and ")"-delimited process substitutions.
    # * The C-style left bit-shift operator "<<" conflicts with the here-
    #   document prefix "<<" and here-string prefix "<<<".
    local pcre_math_substitution_parens_sans_dollar_paren_left_left_optional=${pcre_math_sans_paren_left_optional}
    local pcre_math_substitution_parens_sans_dollar_optional='\('${pcre_math_substitution_parens_sans_dollar_paren_left_left_optional}

    # "$"-prefixed arithmetic substitution, excluding such "$".
    local pcre_math_substitution_sans_dollar_optional=${pcre_math_substitution_parens_sans_dollar_optional}'|'${pcre_math_substitution_braces_sans_dollar_optional}

    # ..................{ VARIABLE                           }..................
    # "$"-prefixed variable expansion, excluding such "$". Since subsequent
    # PCREs already match a lone "$", this PCRE matches at least one character.
    local pcre_var_sans_dollar_prefixed_optional='(?:(?:'${pcre_chars_subword_unquoted}'|'${pcre_char_escaped_optional}')++|'${pcre_string_end}')'

    # "${"- and "}"-delimited variable expansion, excluding such "$".
    local pcre_var_sans_dollar_delimited_prefix='\{'
    local pcre_var_sans_dollar_delimited_suffix='(?:\}|'${pcre_string_end}')'
    local pcre_var_sans_dollar_delimited_body='(?:[^}'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}')*+'
    local pcre_var_sans_dollar_delimited_optional=${pcre_var_sans_dollar_delimited_prefix}${pcre_var_sans_dollar_delimited_body}${pcre_var_sans_dollar_delimited_suffix}

    # "$"-prefixed and possibly "}"-suffixed variable expansion, excluding such
    # "$".
    local pcre_var_sans_dollar_optional=${pcre_var_sans_dollar_prefixed_optional}'|'${pcre_var_sans_dollar_delimited_optional}

    # ..................{ DOLLAR                             }..................
    # "$("-prefixed substitution, comprising:
    #
    # * "$("- and ")"-delimited process substitutions.
    # * "$(("- and "))"-delimited arithmetic substitutions.
    #
    # Since the "$((" delimiting the latter greedily overlaps the "$("
    # delimiting the former, the latter *MUST* be matched first.
    local pcre_paren_substitution_sans_dollar_optional='\((?:'${pcre_math_substitution_parens_sans_dollar_paren_left_left_optional}'|'${pcre_process_substitution_sans_dollar_paren_left_optional}')'

    # "$"-prefixed interpretable syntactic construct, comprising variable
    # expansions and arithmetic and process substitutions.
    local pcre_dollar_interpretable_optional='\$(?:'${pcre_var_sans_dollar_optional}'|'${pcre_paren_substitution_sans_dollar_optional}'|'${pcre_math_substitution_braces_sans_dollar_optional}')'

    # "$"-prefixed preprocessable syntactic construct *NOT* a process
    # substitution, comprising variable expansions and arithmetic
    # substitutions.
    local pcre_dollar_macroable_optional='\$(?:'${pcre_var_sans_dollar_optional}'|'${pcre_math_substitution_sans_dollar_optional}')'

    # ..................{ PARENS                             }..................
    # "("-prefixed interpretable syntactic construct, comprising:
    #
    # * "("- and ")"-delimited process forks.
    # * "(("- and "))"-delimited arithmetic tests.
    #
    # Since the "((" delimiting the latter greedily overlaps the "(" delimiting
    # the former, the latter *MUST* be matched first.
    local pcre_parens_interpretable_optional='\((?:'${pcre_math_test_sans_paren_left_optional}'|'${pcre_process_fork_sans_paren_left_optional}')'

    # ..................{ MACRO ~ macroable                  }..................
    # Recursively preprocessable syntactic construct (i.e., preprocessable at
    # the outermost level of PCRE-based preprocessor iteration), comprising:
    #
    # * "$"-prefixed non-recursive variable expansions.
    # * "${"- and "}"-delimited recursive variable expansions.
    # * "$["- and "]"-delimited recursive arithmetic substitutions.
    # * "$(("- and "))"-delimited recursive arithmetic substitutions.
    # * "(("- and "))"-delimited recursive arithmetic tests.
    #
    # Since syntactic constructs containing arbitrary code (e.g., process
    # substitutions) may also contain macros, matching such constructs here
    # would obstruct matching macros contained by such constructs. To enable
    # such matching, the substrings prefixing such constructs are matched
    # elsewhere as command terminators. Such constructs are omitted here.
    #
    # Technically, "`"-delimited process substitutions should be parsed in a
    # piecemeal fashion to allow macros to be embedded in such substitutions.
    # Practically, however, such substitutions are obsoleted by "$("- and
    # ")"-delimited process substitutions. The effort required to support
    # macros embedded in an obsolete syntactic construct hardly seems worth it.
    local pcre_macroable='(?:'${pcre_dollar_macroable_optional}'|'${pcre_math_test_optional}'|'${pcre_process_substitution_backtick_optional}')'

    # Syntactic component permitting matching of macros. Since matching
    # strictly balanced non-macro syntax (e.g., braces, parens) is incidental
    # to preprocessor matching, such syntax is matched in any order.
    local pcre_subword_macroable=${pcre_nanoword}'|'${pcre_macroable}

    # Shell word containing one or more syntactic constructs permitting
    # matching of macros.
    local pcre_word_macroable=${pcre_word_lookahead}'(?:'${pcre_subword_macroable}')++'

    # Zero or more shell words permitting matching of macros, each delimited by
    # one or more horizontal whitespace characters optionally interspersed by
    # line continuations.
    local pcre_words_macroable_optional='(?:'${pcre_word_macroable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_macroable}')*+)?+'

    # ..................{ MACRO ~ passable                   }..................
    # Syntactic construct recursively substitutable with unquoted shell words
    # in a manner permitting matching of macro arguments. As detailed below,
    # redirections are prohibited in such arguments. Since arithmetic tests are
    # commands and hence *NOT* arguments, both *MUST* be omitted here.
    local pcre_passable='(?:'${pcre_dollar_interpretable_optional}'|'${pcre_process_substitution_equals_optional}'|'${pcre_process_substitution_backtick_optional}')'

    # Syntactic component permitting matching of macro arguments.
    #
    # Since such matching *MUST* be terminated at the first unbalanced ")"
    # character (e.g., signifying a process substitution suffix), such
    # characters must *NOT* be matched.
    #
    # Redirections are also *NOT* matched. Technically, zsh permits
    # redirections to be arbitrarily interspersed with arguments passed to
    # conventional builtins, commands, and functions: e.g.,
    #
    #    >>> function :flint_michigan() { print "${@}" }
    #    >>> :flint_michigan 1<&2 =(print gary_indiana) oakland_california
    #    /tmp/zsh3lpV1a oakland_california
    #
    # Permitting redirections to be interspersed with arguments passed to
    # macros would make comparatively less sense. Even where sensible, however,
    # permitting such edge cases would require preprocessing to shift all such
    # redirections to the end of their respective macro calls -- a non-trivial
    # chore. For now, such edge cases are explicitly prohibited by prohibiting
    # shell words and hence arguments from containing redirection primitives
    # (e.g., "<", ">", "|").
    local pcre_subword_passable_sans_glob_qualifier=${pcre_nanoword_sans_paren_right_redirect}'|'${pcre_passable}

    # Glob qualifier permitting matching of macro arguments.
    local pcre_subword_passable_glob_qualifier=${pcre_glob_qualifier_prefix}${pcre_subword_passable_sans_glob_qualifier}${pcre_glob_qualifier_suffix}

    # Syntactic construct permitting matching of command arguments.
    local pcre_subword_passable=${pcre_subword_passable_sans_glob_qualifier}'|'${pcre_subword_passable_glob_qualifier}

    # Shell word following the first such word for the current command,
    # containing one or more syntactic constructs permitting matching of macro
    # arguments.
    #
    # Since such match *MUST* be halted at the first unbalanced "}" character
    # (e.g., signifying a block suffix), such character is prevented from
    # matching with negative lookbehind. Since the definition of
    # ${pcre_subword_passable_sans_glob_qualifier} induces this PCRE to halts
    # at the first unbalanced ")" character as well, this PCRE actually halts
    # at any unbalanced suffix of interest. (This is good.)
    #
    # Since macro arguments cannot be in command position and hence cannot
    # contain list assignments, this PCRE is structured in a simpler manner
    # than that below matching arbitrary code with strictly balanced parens.
    local pcre_word_passable=${pcre_word_lookahead}'(?:'${pcre_subword_passable}')++'${pcre_word_lookbehind}

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations followed by zero or more shell words permitting
    # matching of macro arguments, each suffixed by such whitespace. Since
    # block arguments are necessarily prefixed by such whitespace, the latter
    # constraint ensures proper matching of the following such argument if any.
    #
    # Standard macro arguments are prohibited from containing redirections, in
    # contrast to standard command arguments. Since interspersing arguments
    # with redirections is comparatively rare *AND* since supporting such
    # oddities in the macro preprocessor would prove to be prohibitively
    # expensive (both in programmer and program time), redirections *MUST*
    # strictly suffix rather than be freely interspersed with macro arguments.

    #FIXME: Actually use below.

    local pcre_words_passable_optional_spaced=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable}${pcre_spaces_horizontal_continuable}')*+'
    local pcre_words_passable_optional_spaced_grouped='('${pcre_words_passable_optional_spaced}')'

    # ..................{ MACRO ~ arg                        }..................
    # "{"- and "}"-delimited block argument passed to a macro.
    #
    # Such "{" must be prefixed by at least one horizontal space. Since the
    # PCRE embedding this PCRE guarantees that, such space is unmatched here.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. While we could assert such condition with positive lookahead,
    # there's actually no need: the negative lookbehind suffixing such shell
    # words guarantees such "}" to either terminate the prior shell word or be
    # a distinct shell word.
    local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_commands_braceable_optional}${pcre_char_block_suffix}

    # Macro argument, comprising both zsh-specific standard arguments and
    # zeshy-specific block arguments. While such arguments may be matched in
    # either order, block arguments are *ALWAYS* prefixed by the same substring
    # "{" and hence more efficiently matchable.
    local pcre_macro_arg='(?:'${pcre_macro_arg_block}'|'${pcre_word_passable}')'

    # Zero or more macro arguments.
    local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_spaces_horizontal_continuable}${pcre_macro_arg}')*+)?+'

    #FIXME: Everything that fallows requires intense refactoring. Should be
    #delightful, naturally. Or possibly excising? Yes, that seems more helpful.

    #FIXME: Well, *THIS* is unfortunate. Since PCREs now match both
    #syntactically valid and invalid code and hence the universe of all
    #possible strings, this parcel of PCREs is now redundant. *sigh* 
    #FIXME: Actually, there *DO* still exist a few remaining syntactic
    #invalidities that we should detect: for example, a "{"-prefixed block
    #argument with no balanced "}" suffix. In such case, the end of the code is
    #matched, which we should probably detect by defining a new PCRE used in
    #place of ${pcre_string_end} that captures the preceding character in
    #positive lookbehind: e.g.,
    #
    #    local pcre_string_end_grouped='(?<(.))'${pcre_string_end}
    #
    #Pretty sweet. We should probably embed such PCRE rather than
    #${pcre_string_end} in ${pcre_*_braceable}, in which case such syntactic
    #invalidity may be tested for.
    #
    #While there exist similar syntactic invalidities for standard macro
    #arguments (e.g., "'" with no suffixing "'" and hence an unclosed
    #single-quoted string), merely implementing detection of block argument
    #invalidity will probably suffice for a first working implementation.

    # Syntactically invalid macro argument, capturing the remainder of the
    # first line (and following line if any) of such argument and immediately
    # terminating PCRE matching.
    #
    # Capturing such argument assists the preprocessor in distinguishing
    # syntactically valid from invalid arguments (e.g., by testing the length
    # of canonical list global ${matches}). This PCRE non-intuitively
    # terminates matching by reporting success. ensuring the corresponding 
    # code throws an exception due to such syntactically invalid macro. Hence,
    # each macro match attempt results in three possible states:
    #
    # * A syntactically valid macro was matched, in which case such match
    #   succeeds and the syntactically invalid match group is empty.
    # * A syntactically invalid macro was matched, in which case such match
    #   succeeds and the syntactically invalid match group is non-empty.
    # * No further macros were matched, in which case such match fails.
    #
    # Such argument is preceded by horizontal whitespace and hence could
    # erroneously match syntactically valid zeshy- or zsh-specific command
    # terminators. To prevent this, such match attempt must be prefixed by
    # negative lookahead preventing such terminators from matching.
    # local pcre_macro_arg_invalid_lookahead='(?!'${pcre_macro_sans_args_spaced_lookahead}')'
    # local pcre_macro_arg_invalid_body_grouped='('${pcre_chars_sans_space_vertical}${pcre_line_optional}')'
    # local pcre_macro_arg_invalid_grouped=${pcre_macro_arg_invalid_lookahead}${pcre_macro_arg_invalid_body_grouped}${pcre_report_success}

    # One or more horizontal whitespace characters followed by zero or more
    # standard or block arguments.
    local pcre_macro_args_optional_spaced_grouped=${pcre_spaces_horizontal}${pcre_macro_args_optional_grouped}${pcre_macro_args_optional_spaced_lookahead}

    # Macro body, comprising all arguments passed to such macro as well as
    # line continuations and whitespace cementing the former to the latter.
    local pcre_macro_body=${pcre_line_continuations_optional}'(?:'${pcre_macro_args_optional_spaced_grouped}'|'${pcre_macro_sans_args_unspaced_lookahead}')'

    # ..................{ MACRO                              }..................
    #FIXME: Actually use below.

    # Macro suffix, anchoring the end of a macro to the end of a line preceded
    # by zero or more horizontal whitespace characters.
    local pcre_macro_suffix=${pcre_spaces_horizontal_optional}${pcre_line_end}

    #FIXME: Rename to ${pcre_macro}? What? Help! HE-LLLP!

    # Zero or more arguments passed to a macro. Success is reported immediately
    # after matching the last character of the last such argument to notify the
    # preprocessor phase iterating over such PCRE that such macro has been
    # fully matched. To distinguish syntactically valid from invalid macros,
    # *ALL* matched substrings must be optional.
    local pcre_macro_body_report_success=${pcre_macro_body}${pcre_macro_suffix}${pcre_report_success}

    # Macro name.
    local pcre_macro_name=${ZESHY__MACRO_NAME_PLACEHOLDER_PCRE}
    local pcre_macro_name_grouped='('${pcre_macro_name}')'

    #FIXME: This... this is completely insufficient. Renovate, please.

    # Macro.
    local pcre_macro_optional_grouped='(?:'${pcre_macro_name_grouped}')?+'

    # Zero or more macros or commands. To preferentially match shell words as macro names
    # rather than mere shell words, the former is matched before the latter.
    #
    # Since "{" is a command terminator while "}" is not,
    # ${pcre_command_ends} matches the former while
    # ${pcre_words_macroable_optional} the latter.
    local pcre_macros_or_commands_optional='(?:'${pcre_macro_optional_grouped}${pcre_words_macroable_optional}${pcre_command_ends}')*+'

    # ..................{ SUBROUTINE                         }..................
    # Syntactic construct recursively embeddable in variable expansions and
    # arithmetic substitutions and tests.
    pcre_macro_subroutines_body+='(?<emb>'${pcre_dollar_interpretable_optional}'|'${pcre_process_substitution_backtick_optional}')'

    # Syntactic construct recursively interpretable in arbitrary code.
    pcre_macro_subroutines_body+='(?<int>'${pcre_dollar_interpretable_optional}'|'${pcre_parens_interpretable_optional}'|'${pcre_process_substitution_redirect_optional}'|'${pcre_process_substitution_backtick_optional}')'

    # ..................{ SUBROUTINE                         }..................
    # PCRE subroutines defined above, concatenated in a manner preventing
    # such definitions from either implicitly matching *OR* capturing.
    #
    # First, a bit of useful background. As in Perl but not Ruby, "libpcre"
    # subroutine calls (e.g., "(?&soma)") do *NOT* capture the substring
    # matched by such call. As in both Perl and Ruby, subroutine definitions
    # (e.g., "(?<soma>All the advantages of Christianity and alcohol; none of
    # their defects.)" capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is noxious. In
    # most cases, we would prefer such definitions to *NOT* capture.
    #
    # Happily, PCRE explicitly supports such behaviour via "(?(DEFINE)...)",
    # Perl- and PCRE-specific syntax defining all named and numbered capturing
    # groups in its embedded content but otherwise ignoring such content.
    # For further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
    local pcre_macro_subroutines_prefix='(?(DEFINE)'
    local pcre_macro_subroutines_suffix=')'
    local pcre_macro_subroutines=${pcre_macro_subroutines_prefix}${pcre_macro_subroutines_body}${pcre_macro_subroutines_suffix}

    # ..................{ GLOBAL                             }..................
    # PCRE matching syntactically valid macro names.
    ZESHY__MACRO_NAME_VALID_PCRE='['${char_not_macro_name_char_first}']['${char_not_macro_name_char_rest}']*+'

    #FIXME: After refactoring ${pcre_report_failure} away below, we'll probably
    #also want to refactor such PCRE away here as well.

    # PCRE to which ${ZESHY_MACRO_PCRE} is set if no macros exist.
    ZESHY__MACRO_PCRE_IF_EMPTY=${pcre_report_failure}

    #FIXME: We currently prohibit macro expansions in process substitutions,
    #largely because differentiating genuine macros from macro-like substrings
    #embedded in double-quoted strings or similar ignorable constructs is
    #non-trivial. To correct this, we'll need to duplicate each syntactic
    #construct embedding other such constructs and prohibit embedding of
    #process substitutions of any type. This doesn't necessarily need to entail
    #PCRE duplication. It will, however, probably mean a doubling in the number
    #of PCREs. See ${pcre_quotes_double_noncode} for a sensible approach, after
    #we've completed an initial draft by the current approach.
    #FIXME: Actually, we can't do it. There's simply no reasonable means by
    #which this could be made feasible. Consider it: even if we *COULD*
    #explicitly match macros in embedded process substitutions (which we could,
    #of course), we'd have no means of resuming the exterior syntactic
    #construct. For example, consider '"$(
    #    :macro)
    #    :macro"'. Ignoring the difficulty of matching ")" as a valid macro
    #terminator in such context, how would the PCRE engine know on resuming
    #iterative matching after expanding the first macro that the second macro
    #is embedded within a double-quoted string and hence ignorable? Brutal, eh?
    #
    #For now, the only reasonable solution is the current solution: ignore
    #*ALL* macro-like substrings in substitutables. We'll just have to publicly
    #note this to be a core limitation of the zeshy preprocessor.
    #FIXME: Overly zealous. While we can't reasonably expand macros in embedded
    #process substitutions (at the moment), we *CAN* expand macros in top-level
    #process substitutions, which seems an adequate compromise. To do so, we'll
    #want to replace our expansion of ${pcre_code} with something like
    #${pcre_code_sans_process_and_math_substitutions}, ensuring that top-level
    #process substitution delimiters (e.g., "$(" and ")") are treated as raw,
    #ignorable characters and hence that macros in such substitutions are
    #matched and expanded. To do so, we'll probably need to explicitly match
    #and ignore:
    #
    #* "`", which is easy, though we'll need a new
    #  ${char_not_code_prefix_sans_backtick}. (Don't actually call it that.)
    #* "$(", which is *NOT* easy. We'll want to continue ignoring arithmetic
    #  substitutions, to ensure macros are *NOT* expanded into such
    #  substitutions. (Or perhaps not? For orthogonality, we'd also need to
    #  ignore "(("- and "))"-delimited arithmetic tests, which seems overkill.)
    #  O.K.; so, explicitly matching "$(" is obviously trivial. Do so
    #  immediately after matching ${pcre_char_escaped_optional} below, we reckon.
    #* All other process substitution prefixes (i.e., "=(", "<(", ">(").
    #FIXME: O.K.; so, once we refactor this parcel to match macros at command
    #positions rather than only at the starts of lines, much of the above
    #complexity should be obliviated. Given that, perhaps we simply want to try
    #straight for the former goal? What, exactly, defines command position?
    #Consider this:
    #
    #* Immediately after a zsh command terminator. These are:
    #  * "|".
    #  * "<", and ">"

    # PCRE fragment prefixing ${ZESHY_MACRO_PCRE}, matching zero or more macros
    # *OR* syntactic constructs possibly containing macro-like substrings.
    ZESHY__MACRO_PCRE_IF_NONEMPTY_PREFIX=${pcre_options_anchored}'(?:'${pcre_macro_prefix}'(?:'${pcre_comment}'|'

    #FIXME: Use of ${pcre_report_failure} is inappropriate here, as it prevents
    #distinguishing syntactically valid from invalid scripts. To do so, we'll
    #need to supplant ${pcre_report_failure} by something resembling:
    #
    #    ${pcre_spaces_horizontal_continuable_optional}(<=(.))${pcre_string_end}
    #
    #This ensures that *ONLY* syntactically invalid matches report failure,
    #which is great. Since valid macro matches are easily distinguished by the
    #appropriate match groups, we have the following three cases:
    #
    #* ${ZESHY_MACRO_PCRE} reports failure, in which case such code is invalid.
    #  An exception should be thrown.
    #* ${ZESHY_MACRO_PCRE} reports success, in which case:
    #  * If the macro-specific match group(s) are non-empty, a valid macro was
    #    matched.
    #  * Else, the end of such code was matched. The while loop iterating such
    #    PCRE should be terminated.

    # PCRE fragment suffixing ${ZESHY_MACRO_PCRE}.
    ZESHY__MACRO_PCRE_IF_NONEMPTY_SUFFIX=${pcre_macro_body_report_success}')?|'${pcre_spaces_horizontal}'(?:'${pcre_comment}')?|'${pcre_code_sans_comment}'|.)*'${pcre_report_failure}${pcre_macro_subroutines}

    # PCRE capturing the next block argument body in a macro argument list,
    # prefixed by one or more horizontal whitespace characters followed by zero
    # or more shell words. To assist user-defined macros accepting variadic
    # arguments in distinguishing standard from block arguments, the entirety
    # of such block (including "{" and "}" delimiters) is captured.
    #
    # Such PCRE assists in finding the byte indices of the first and last
    # characters of the next block argument passed to the currently matched
    # macro. Unfortunately, unlike test operator "=~", pcre_match() sets
    # neither canonical integer globals ${MBEGIN} or ${MEND} nor list globals
    # ${mbegin} or ${mend}. Given such constraints, the only means of finding
    # such byte indices is to:
    #
    # 1. Capture the substring preceding such block argument, including
    #    otherwise ignorable whitespace.
    # 2. Add the byte length of such substring to the byte index of the last
    #    character of the prior block argument.
    ZESHY_MACRO_ARG_BLOCK_NEXT_PCRE=${pcre_options_anchored}${pcre_macro_args_zsh_optional_grouped}${pcre_macro_arg_block}${pcre_macro_subroutines}

    # ..................{ INDICES                            }..................
    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support constant globals. *sigh*

    # For each match group captured by each PCRE global declared above
    # capturing four or more such groups, declare one human-readable integer
    # global expanding to such group's 1-based index. For robustness, declare
    # such globals iteratively rather than manually.
    local match_index_name
    integer match_index

    #FIXME: Document such indices.

    # Declare indices matched by ${ZESHY_MACRO_PCRE}.
    match_index=1
    for match_index_name (
        ZESHY_MACRO_MATCH_INDEX_NAME
        ZESHY_MACRO_MATCH_INDEX_IS_INVALID
    ) {
        integer -g ${match_index_name}=$(( match_index++ ))
        print -r ${match_index_name}': '${(P)match_index_name}
    }
}

# --------------------( WASTELANDS                         )--------------------
    # End of a macro suffixed by one or more horizontal whitespace characters
    # and accepting zero or more arguments, comprising either the end of the
    # current line *OR* a zeshy- or zsh-specific command terminator.
    # local pcre_macro_args_optional_spaced_lookahead='(?='${pcre_command_ends}'|'${pcre_string_end}')'

    # End of a macro suffixed by no horizontal whitespace characters and
    # accepting no arguments, comprising either the end of the current line
    # *OR* a zsh-specific command terminator. Since zeshy-specific command
    # terminators (e.g., :or(), :and()) must be preceded by such whitespace,
    # matching only zsh-specific command terminators suffices.
    #
    # Since the preprocessor expects the last byte of the substring matched by
    # PCRE-based iteration to be the last byte of a macro, this PCRE must *NOT*
    # match any bytes following such macro -- including the command terminator
    # terminating such macro if any. To ensure this, this PCRE must consume no
    # characters and hence contain *ONLY* zero-width assertions.
    # local pcre_macro_sans_args_unspaced_lookahead='(?='${pcre_command_end_unspaced}'|'${pcre_string_end}')'

    #FUXME: ${pcre_redirect} probably already matches "<" and ">" at an
    #*EARLIER* point, preventing this PCRE from ever matching such constructs.
    #${pcre_redirect} must be improved with suffixing negative lookbehind (or
    #the equivalent thereof), preventing such PCRE from matching either "<" or
    #">" followed by "(". Not terribly difficult.

    #FUXME: Hmm; efficiently support ${pcre_redirect_lookahead} for both of the
    #following PCREs. *sigh*
    #FUXME: Actually use in macro argument-specific subroutine(s) defined below
    #(i.e., passable).
    #FUXME: This overlaps "("- and ")"-delimited shell forks and hence *MUST*
    #be matched first where embedded below. Indeed, for efficiency, we'll
    #probably want to combine the two.

    #FUXME: Ugh; obviously, shift ${pcre_process_substitution_backtick_optional} directly into ${pcre_macroable}.
    #FUXME: Oh. Right. No! Since we need to parse such construct in a manner
    #resembling that of double-quote-embedded process substitutions, we'd might
    #as well just leave this for now. Excise
    #${pcre_process_substitution_backtick_optional} here after refactoring.

    #FUXME: We also need to match "("- and ")"-delimited shell environments:
    #e.g.,
    #
    #    (grep -R okok *) &!
    #
    #For preprocessing purposes, such environments are functionally identical
    #to "$("- and ")"-delimited preprocessor substitutions and hence should be
    #shoehorned into PCREs matching such substitutions. Note, however, that the
    #above example implies that the first and last characters of unquoted shell
    #words cannot be "(" and ")" respectively. All told, mild but extensive
    #edits will be required elsewhere.
    #FUXME: O.K.; so, while "(" cannot be the first character of unquoted shell
    #words, ")" clearly *CAN* be the last character of such words. No issues
    #there.

#FUXME: ${ZESHY_MACRO_PCRE} should be generalized to explicitly match all
#ignorable code containing macro-like syntax (e.g., strings, variable
#expansions) preceding non-ignorable macros. However, this is also fraught with
#issues: for example, we'd actually like to expand macros embedded in process
#substitutions in double-quoted strings and variable expansions but *NOT* in
#all other content in double-quoted strings and variable expansions. Is this
#feasible? Perhaps not. In which case, perhaps the current approach is actually
#a bit more ideal than we first conceived.

    #FUXME: We should probably be matching ${pcre_comment} in a manner
    #resembling that of ${pcre_command_end_comment}. That is to say, now that
    #we've improved ${pcre_word_parenable} to avoid matching shell words
    #prefixed by "#", we should no longer require
    #${pcre_comment_optional_spaced} in very many places. Refactoring such PCRE
    #away should simplify logic elsewhere, we mildly suspect.

#FUXME: Since we're setting this aside for a few days to weeks, we should
#record that the next items of interest are to (in order):
#
#* Correct parsing of process substitutions in standard macro arguments *AND*
#  of arbitrary code in block macro arguments. To do so, we'll want to examine
#  the ${pcre_code_*} subsection below. The PCREs in that subsection are
#  effectively munted at the moment, and should all probably be replaced by
#  something *SUBSTANTIALLY* simpler and then simply excised. So, there's the
#  (mis)state of the present. Right! So, the most efficient (and certainly
#  simplest, since we've already implemented it) solution is to simply adopt
#  the ${pcre_macros_or_commands_optional} approach for matching *ANY*
#  arbitrary code -- including process substitutions and block argument code.
#  Of course, since ${pcre_macro} is specific to matching macros, we can't
#  adopt that *EXACT* same approach. We can, however, copy that approach and
#  simply excise the macro-specific portions. Voila!

    # '(?:'${pcre_comment_optional_spaced}')?+'
    #FUXME: Right. We should probably this approach *EVERYWHERE* where we're
    #currently using "?+" to match a syntactic suffix or the string end. This
    #approach isn't simply more correct; it also happens to be significantly
    #more efficient (and possibly the only valid way of actually matching such
    #condition). Replicate, please.
    #FUXME: This used anywhere? If not, excise please.

    # Zero or more shell words permitting matching of macro arguments, each
    # delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    # local pcre_words_passable_optional='(?:'${pcre_word_passable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_passable}')*+)?+'

    # local pcre_line_continuation_optional='(?:'${pcre_line_continuation}')?+'

    # local pcre_math_sans_paren_left_optional=${pcre_math_sans_paren_left_prefix}'(?:[^)'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}'|\)(?!\))*+'${pcre_math_paren_left_suffix}
    # local pcre_math_substitution_braces_sans_dollar_optional='\[(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}'|[^\]])*+'${pcre_math_substitution_braces_sans_dollar_suffix}

    # Line, including:
    #
    # * Prefixing newline if *NOT* the first line of such code as
    # * All non-newline characters on such line.
    #
    # To comply with ${pcre_line_end}, such PCRE does *NOT* match a suffixing
    # newline if any.
    # local pcre_line=${pcre_line_start}${pcre_chars_sans_space_vertical_optional}${pcre_line_end}
    # local pcre_line_optional='(?:'${pcre_line}')?+'

    #FUXME: Since this is now *MUCH* more frequently embedded than
    #${pcre_continuable_spaces_horizontal}, consider (in order):
    #
    #* Renaming ${pcre_continuable_spaces_horizontal} to 
    #  ${pcre_continuable_spaces_horizontal}.
    #* Renaming this PCRE to ${pcre_continuable_spaces_horizontal}.
    #
    #Rename ${pcre_continuable_spaces} and ${pcre_spaces_continuable}
    #similarly. Surely, this is a dawn of awesomeness in nomenclature incarnate.

    # Zero or more macro arguments.
    # local pcre_macro_args_optional_grouped='(?:'${pcre_macro_arg_grouped}'(?:'${pcre_spaces_horizontal}${pcre_macro_arg_grouped}')*)?'
    # local pcre_macro_arg_grouped='(?:'${pcre_macro_arg_block}'|'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_invalid_grouped}')'

    # Macro prefix, anchoring the start of a macro to the start of a line
    # followed by optional indentation (i.e., horizontal whitespace).
    # local pcre_macro_prefix=${pcre_line_start}${pcre_spaces_horizontal_optional}

    #FUXME: Correct documentation.
    # Zero or more non-macro lines preceding a macro, ensuring macro-like lines
    # embedded in multiline string contexts are ignored. Ideally, this would
    # comprise *ALL* such contexts, including double-quoted strings and
    # variable expansions. Unfortunately, both double-quoted strings and
    # variable expansions may embed process substitutions expanding non-
    # ignorable macros. Hence, this PCRE would need to distinguish between the
    # following edge cases:
    #
    #     >>> "The following macro is ignorable:
    #     ... :func :void :this_is_not_a_function_definition() {
    #     ... }"
    #     >>> "The following macro is *NOT* ignorable: $(
    #     ... :func :void :this_is_a_function_definition() {
    #     ... } )"
    #     >>> "The following macro is ignorable: $("
    #     ... :func :void :this_is_not_a_function_definition() {
    #     ... }")"
    #
    # Clearly, distinguishing such cases is non-trivial. Hence, we currently
    # only ignore macros in string contexts allowing no process substitutions:
    #
    # * Single-quoted strings.
    # * Single-quoted here-strings.
    # * Single- or double-quoted here-documents.
    #
    # While non-ideal, it's unclear whether we can readily do better.

    #FUXME: We need to make sure that macro argument parsing halts immediately
    #before the first redirection passed to such argument (rather than
    #successfully consuming such redirection). This used to be the case. For
    #this still to be the case, we'll need to explicitly omit... what? Well,
    #O.K.; this *SHOULD* behave as expected already. Double check, however.

    # Syntactic construct recursively preprocessable by the preprocessor. Since
    # syntactic constructs containing arbitrary code (e.g., process
    # substitutions) may also contain macros, matching such constructs here
    # would obstruct matching macros contained by such constructs. To enable such matching, the
    # substrings prefixing such constructs are matched elsewhere as
    # command terminators. such constructs are omitted here.
    # pcre_macro_subroutines_body+='(?<mac>'${pcre_dollar_macroable_optional}'|'${pcre_math_test_optional}')'

    # To preprocess macros embedded in such process substitutions, the "$("
    # prefixing such substitutions is matched elsewhere as a command terminator
    # and hence macro prefix.
    # local pcre_macroable='(?=\$(?:[^(]|\(\()|\(\(|'${pcre_string_end}')(?&mac)'

    #FUXME: As with substitutables above, this subroutine should be inlined
    #directly at its sole point of use and then eliminated. See to it, please.
    #FUXME: Define ${pcre_dollar_macroable_optional}. See far above.
    # For orthogonality, ${pcre_subword_macroable} is defined above.
    #FUXME: The concluding alternative "`[^`]*+`?+" is a temporary hack.
    #When we add support for parsing macros in both double quotes-embedded
    #process substitutions *AND* "`"-prefixed process substitutions, excise
    #such hack. For now, it should suffice for a working first draft.
    # To avoid matching "$("- and ")"-delimited process substitutions while
    # yet matching "$(("- and "))"-delimited arithmetic substitutions,
    # specify explicit alternatives rather than character classes in lookahead.

    # local pcre_subword_macroable=${pcre_nanoword}'|'${pcre_macroable}'|`[^`]*+`?+'
    #FUXME: Do we still require all of these? Clean up documentation according
    #to the format of ${pcre_macroable}.
    #FUXME: Does this *REALLY* need to be a subroutine? Probably not, right?
    #That said, the sheer obtuseness of defining passable words *AFTER*
    #syntactic constructs complicates matters. It's certainly feasible, but
    #*WOULD* require splitting up the word definitions -- which hardly seems
    #worthwhile at the moment.
    #FUXME: Actually, given the frequency of variable expansions in macro
    #arguments, inlining this subroutine would be *VERY* beneficial. See to it,
    #please.

    # Recursively substitutable syntactic construct (i.e., replaceable with
    # any arbitrary unquoted shell word passed to a preprocessor macro and
    # hence excluding "<("- and ">)"-prefixed redirections).
    # local pcre_substitutable='(?=['${char_substitutable_prefix}'])(?&sub)'

    # Syntactic construct recursively substitutable with unquoted shell words
    # in macro arguments. Since such arguments accept neither arithmetic tests
    # or redirections, such constructs *MUST* be omitted.
    # pcre_macro_subroutines_body+='(?<sub>'${pcre_dollar_interpretable_optional}'|'${pcre_process_substitution_equals_optional}'|'${pcre_process_substitution_backtick_optional}')'

    #FUXME: Actually, this is silly. Instead:
    #
    #* *ALWAYS* match "(" (but not ")", of course) in the unquoted shell word
    #  character class defined above.
    #* Match ${pcre_subword_parenable_glob_qualifier} *BEFORE*
    #  ${pcre_subword_parenable_sans_glob_qualifier} in the PCRE embedding
    #  both below.
    #* Drop the "?+" from ${pcre_glob_qualifier_suffix}.
    #
    #This marginally improves efficiency while dramatically improving
    #readability and hence maintainability.
    # Since "(" is *NOT* matched elsewhere
    # for PCREs embedding these PCREs, ")" *MUST* be matched optionally to
    # ensure that "(" unconditionally matches irregardless of balancing.

    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(" and ")" characters --
    # intended to be matched elsewhere in a balanced manner. Specifically,
    # this class additionally matches:
    #
    # * "(", either:
    #   * A list assignment prefix when the last character of unquoted shell
    #     words preceded by a valid variable name followed by "=".
    #   * A glob qualifier prefix when balanced by a subsequent ")" in the same
    #     unquoted shell word.
    # * ")", a glob qualifier suffix when balanced by a prior "(" in the same
    #   unquoted shell word.

    # local pcre_list_assignment_body='(?:'${pcre_word_passable}'(?:'${pcre_comment_optional_spaced}${pcre_word_passable}')*+)?+'

    #FUXME: Likewise, we probably need to add "|[^)]" back to
    #${pcre_subword_parenable} or some such. Why? Because we no longer match
    #syntactically invalid syntax as such. For example, we have no current
    #means of matching "${=

#  Note the
    #FUXME comment elsewhere discussing use of a substitution-style approach to
    #interpolating macro names 
    # ..................{ OBSOLETE                           }..................
    #FUXME: Unify the following with the above PCREs; then, excise this.

    # Zero or more standard arguments matched in a manner assuming that a block
    # argument *WILL* be subsequently matched. Specifically, zero or more line
    # continuations followed by one or more horizontal whitespace characters
    # followed by such arguments, each necessarily suffixed by such whitespace.
    # Since block arguments are necessarily prefixed by such whitespace, the
    # latter constraint ensures proper matching of the following such argument.
    #
    # Standard macro arguments are prohibited from containing redirections, in
    # contrast to standard command arguments. Since interspersing arguments
    # with redirections is comparatively rare *AND* since supporting such
    # rarities in the macro preprocessor would prove to be non-trivially
    # expensive (both in programmer and program time), redirections *MUST*
    # strictly suffix rather than be freely interspersed with macro arguments.
    # local pcre_macro_args_zsh_optional=${pcre_continuable_spaces_horizontal}${pcre_words_argumentable_spaced_with_parens_balanced_optional}
    # local pcre_macro_args_zsh_optional_grouped='('${pcre_macro_args_zsh_optional}')'

    # Zero or more shell words permitting matching of command arguments, each
    # suffixed by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.

    # Since shell words passed as arguments to preprocessor macros accept
    # neither arithmetic tests *OR* redirections, such constructs are omitted.
    #FUXME: O.K.; we may now refactor the main "$"-prefixed PCRE below to *NOT*
    #be optionalized. Yay!

    #FUXME: What's this? Do we still require this? O.K.; yes, yes we do. Shift
    #this upwards, we should think. We'll need to adjust
    #${pcre_dollar_interpretable} accordingly, of course.
    #FUXME: Actually use in subroutine(s) defined below.

    # "$"-prefixed arithmetic substitution, excluding such prefix.
    # local pcre_math_substitution_sans_dollar_optional=${pcre_math_substitution_sans_dollar_paren_left_optional}'|'${pcre_math_substitution_sans_dollar_braces_optional}

# pcre_math_substitution_sans_dollar_optional}'|'${pcre_process_substitution_sans_dollar_optional
    #FUXME: What's this? Do we still require this? Why would we ever want to
    #exclude process substitutions?

    # "$"-prefixed syntactic construct *NOT* a process substitution, comprising
    # variable expansions and arithmetic substitutions.
    # local pcre_dollar_expandable_optional='\$(?:'${pcre_var_sans_dollar_optional}'|'${pcre_math_substitution_sans_dollar_optional}')?+'

    # Recursively expandable syntactic construct.
    # pcre_macro_subroutines_body+='(?<exp>'${pcre_dollar_expansion_optional}'|'${pcre_math_test_optional}')'

    #FUXME: Insufficient. Such expansions may also be suffixed by multiple "["-
    #and "]'-delimited indices as well as ":"-prefixed history operators. Yes,
    #all of this syntax *MUST* be explicitly matched. (No way around that.)
    #FUXME: Actually, the following suffices. We'll probably need to ressurct 
    #${chars_not_construct_prefix}, however. (Was it ${chars_not_code_prefix},
    #perhaps?)
    #FUXME: Wait. This was rather silly. On contemplation, we neither require
    #nor benefit from this. Excise, please.
#  Since
    # subsequent PCREs match merely "$"-prefixed variable expansions (e.g.,
    # $rebel_rock) by virtue of 
#theatrics  such escaped character *MUST* be optional.
    #FUXME: This is totally munted. Do we still require this? We have doubts.
#  While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    # "$("- or "=("- *AND* )"-delimited process substitution, comprising only
    # process substitutions allowed in macro arguments. Since such arguments
    # prohibit redirections, redirections and shell forks are excluded.
    # local pcre_process_substitution_passable_optional='[$=]'${pcre_process_fork_optional}

    #FUXME: Actually, for efficiency, we'll need to split "("- and "$"-prefixed
    #constructs into their own PCREs. Everything else can remain.
    # "("- and ")"-delimited process substitution or fork, excluding leading
    # prefix if any (e.g., "$", "=").
    # local pcre_process_parens_body='\('${pcre_process_body}
    # local pcre_process_fork_optional=${pcre_process_parens_body}

    # * "("- and ")"-delimited shell forks.
    # * "$("- and ")"-delimited process substitutions.

    #FUXME: Something's not quite right here. Don't we require "|[^\[]"?
    # "))" delimiting arithmetic syntactic constructs.

    # Possibly recursively nested arithmetic syntactic construct content
    # prefixed by at least "((", omitting such prefix.
#, matching "(" and ")" characters in an arbitrary manner
    # local pcre_macros_or_commands_preprocessable_optional='(?:'${pcre_macro_optional}${pcre_words_macroable_optional}${pcre_command_ends}')*+'

    #FUXME: O.K.; we've just conceived of a considerable issue: syntactically
    #invalid constructs. They *MUST* be matched both here and everywhere. To do
    #so here in the customary way we do elsewhere, however, would basically
    #require adding an alternative the following below:
    #
    #    '|(?!'${pcre_command_end_unspaced}').'
    #
    #While that *WOULD* work, it also matches each unspaced command terminator
    #twice, which is terrible. A superior solution is to refactor *EVERY*
    #syntactic construct below so as to render *EVERYTHING* following such
    #syntactic construct's unique prefix optional. This has a number of
    #ancillary benefits, aside from the obvious efficiency improvements:
    #namely, that we could then remove all fallback alternatives resembling
    #"|[^)]" from the syntactic constructs matched below. Since this is
    #unequivocally a good thing, see to it, please.

# (i.e., substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) passed to a macro.
    #FUXME: Shift above, replacing ${pcre_words_braceable_optional} by
    #${pcre_words_braceable}.
    # local pcre_words_braceable_optional='(?:'${pcre_word_braceable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_braceable}')*+)?+'

    #FUXME: Match block arguments with this PCRE.
    #FUXME: Define ${pcre_command_ends_sans_block_prefix}. Should be trivial.
    #FUXME: Fix. Hideously broken, we should think.
    #FUXME: Actually use in process substitutions.

    # # ..................{ OBSOLETE                           }..................
    # #FUXME: How many of the following PCREs do we still use? Investigate.
    # #Right. So, this current approach appears increasingly horrific. While it
    # #was pleasant, in concept, to believe that we could generalize a set of
    # #alternatives for matching arbitrary code, it probably can't be done. It
    # #certainly doesn't appear worth the effort or confusion, does it? So let's
    # #dramatically simplify this quagmire, probably by resetting and... yup,
    # #just starting over. (The deletion axe must be applied with a firm grip.)
    #
    # # Code atom excluding command terminators, comments, and whitespace. Such
    # # code comprises either one:
    # #
    # # * List assignment.
    # # * Interpretable shell word.
    # # * Here-document or -string.
    # #
    # # Since list assignments are prefixed by variable names indistinguishable
    # # from (and hence conflicting with) unquoted shell words, the former *MUST*
    # # be matched before the latter.
    # #
    # # Since the "<" of the "<("- and ")"-delimited process substitution matched
    # # in shell words conflicts with the "<" unconditionally matched in
    # # here-documents or -string prefixes, the former *MUST* be matched first.
    # local pcre_code_sans_comment_or_command_end_or_paren_right_prefix=${pcre_list_assignment_optional}'|'
    # local pcre_code_sans_comment_or_command_end_or_paren_right_suffix='|'${pcre_here_optional}
    #
    # local pcre_code_sans_comment_or_command_end_prefix=${pcre_list_assignment_optional}'|'
    # local pcre_code_sans_comment_or_command_end_suffix='|'${pcre_here_optional}
    # local pcre_code_sans_comment_or_command_end=${pcre_code_sans_comment_or_command_end_prefix}${pcre_word_interpretable_or_block_suffix}${pcre_code_sans_comment_or_command_end_suffix}
    #
    # # One or more code atoms excluding command terminators, comments, and
    # # whitespace.
    # local pcre_codes_sans_comment_or_command_end='('${pcre_code_sans_comment_or_command_end}')++'
    #
    # #FUXME: The inclusion of ${pcre_chars_command_end_not_code_prefix} could
    # #probably use a rethink. That's a pretty terrible PCRE, which, due to
    # #copious revisions, is probably no longer even mildly correct in this
    # #context. Examine where we currently use this PCRE and contemplate changes.
    #
    # # Code atom excluding comments and whitespace.
    # local pcre_code_sans_comment_prefix=${pcre_chars_command_end_not_code_prefix}'|'${pcre_code_sans_comment_or_command_end_prefix}
    # local pcre_code_sans_comment_suffix=${pcre_code_sans_comment_or_command_end_suffix}
    #
    # # Code atom, excluding "}" block suffixes and "#"-prefixed comments.
    # local pcre_code_sans_comment_and_block_suffix=${pcre_code_sans_comment_prefix}${pcre_word_parenable}${pcre_code_sans_comment_suffix}
    #
    # # Code atom, comprising any syntactic construct matched by
    # # ${pcre_code_sans_comment} as well as:
    # #
    # # * One or more whitespace characters.
    # # * A "#"-prefixed comment.
    # # * A "}" block suffix, matched by omitting the customary negative
    # #   lookbehind from interpretable shell words.
    #
    # #FUXME: We need to match unbalanced syntactic prefixes and suffixes (e.g.,
    # #"{", "}", "(", ")"). Are there any others? Now, we clearly match "}" and
    # #"(" here, but "{" and ")" appear to have gone astray. Investigate.
    #
    # local pcre_code_prefix=${pcre_code_sans_comment_prefix}${pcre_comment_optional_spaced}'|'
    # local pcre_code_suffix=${pcre_code_sans_comment_suffix}
    # local pcre_code=${pcre_code_prefix}${pcre_word_interpretable_or_block_suffix}${pcre_code_suffix}
    #
    # # Code atom, excluding "`"-delimited process substitutions.
    # local pcre_code_sans_backtick=${pcre_code_prefix}${pcre_word_interpretable_sans_backtick}${pcre_code_suffix}
    #
    # # Zero or more code atoms.
    # local pcre_codes_optional='('${pcre_code}')*+'

    #FUXME: This character class is probably an unpleasantly ichorous idea --
    #which is to say, bad. For example, while "|" *IS* a single-character
    #command terminator, "|&" is *NOT*. Matching the former precludes matching
    #the latter, which may not necessarily be sensible. Honestly, this
    #character class is only embedded once elsewhere, suggesting the whole
    #distinction between this and ${char_command_end} is terrible and should be
    #eliminated entirely.
    #FUXME: Yes, absolute excise this. Repugnant to writhing life itself.

    # Character class matching single-character command terminators *NOT*
    # prefixing syntactic constructs possibly containing macro-like substrings.
    # Since the latter comprises only ">("-prefix process substitutions and
    # "<<"-prefixed here-documents and -strings, this class excludes only "<"
    # and ">".
    # local char_command_end_not_code_prefix=${char_space_vertical}'|;'

    # Redirection-specific punctuation. Since command arguments may be freely
    # interspersed with redirections, redirections must be disambiguated from
    # command terminators with overlapping syntax (e.g., redirection "&>" and
    # command terminators "&", "&!", and "&&").
    #
    # This PCRE matches the following such punctuation: "<", "<>", ">", ">|",
    # ">!", ">>", ">>|", ">>!", "<&", ">&", "&>", ">&|", ">&!", "&>|", "&>!",
    # ">>&", "&>>", ">>&|", ">>&!", "&>>|", and "&>>!". Since here-documents
    # are syntactically rich enough to warrant special consideration, such
    # punctuation excludes "<<"-prefixed here-documents (and, by extension,
    # here-strings). See section "REDIRECTION" of "man zshmisc".
    # local pcre_redirect_punctuation_less_than='<[&>]?+'
    # local pcre_redirect_punctuation_greater_than='>>?+&?+[!|]?+'
    # local pcre_redirect_punctuation_ampersand='&>>?+[!|]?+'

    #FUXME: Excise ${pcre_redirect_punctuation} in favor of ${pcre_redirect}.
    # local pcre_redirect_punctuation=${pcre_redirect_punctuation_less_than}'|'${pcre_redirect_punctuation_greater_than}'|'${pcre_redirect_punctuation_ampersand}

    # Since here-documents are syntactically rich enough to warrant special
    # consideration, such punctuation excludes "<<"-prefixed here-documents
    # (and, by extension, here-strings).

    # Here-string prefix. Since here-string arguments are shell words, since
    # subsequent parsing already matches such words, and since syntactically
    # invalid here-string arguments must be matched, match only such prefix.
    # local pcre_here_string_prefix='<'

    # Note that
    # here-strings are shell words matched by subsequent PCREs and hence *NOT* matched here; for simplicity, only such prefix is matched here.
    # Substring prefixing both here-documents and -strings.
    # local pcre_here_prefix='<<'
    # local pcre_here_optional='<(?:<'${pcre_here_string_prefix}'|(?&here)?+)'

    #FUXME: Excise in favor of ${pcre_here_optional}; then rename
    #the latter to ${pcre_here_optional}.
    # local pcre_here_optional=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|(?&here)?+)'

    #FUXME: Redefine in terms of ${pcre_command_end_unspaced_body}.
    # local pcre_command_end_unspaced='(?:'${pcre_command_end_char}'|'${pcre_command_end_spaces_vertical}'|'${pcre_command_end_comment}'|'${pcre_command_end_process_substitution_prefix_sans_backtick}'|'${pcre_command_end_pipe}'|'${pcre_command_end_ampersand}'|'${pcre_string_end}')'${pcre_spaces_horizontal_continuable_optional}

    #FUXME: The nomenclature implies such PCRE matches one or more arbitrary
    #command terminators -- which, of course, it doesn't. Which seems silly,
    #since it probably should. Right? ${pcre_command_ends_spaced_optional}, in
    #particular, is fairly bizarre and only ever expanded here. Consider
    #replacing such PCRE by something somewhat more... generalized.

    #FUXME: ${pcre_command_end_spaced} matches suffixing whitespace, implying
    #that ":and :not" will *NOT* be matched. Arguably,
    #${pcre_command_end_spaced} should be suffixed by positive lookahead
    #matching such whitespace instead.

    #FUXME: Excise now-obsolete ${pcre_arg_block_*} PCREs.
    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros.
    #
    # Such "{" must be prefixed by at least one horizontal space. Since the
    # PCRE embedding this PCRE guarantees that, avoid matching such space here.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, avoid matching suffixing whitespace matched as prefixing
    # whitespace by the subsequent such block by merely asserting this
    # constraint with positive lookahead.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code_sans_comment_and_block_suffix}'|[^}])*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_macro_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    #FUXME: Finish me. We need to explicitly match "{" and "}" in a balanced
    #manner. Examine the prior block definition, please.
    #FUXME: Contrary to commentary below, we don't appear to assert such "}" to
    #be followed by whitespace with positive lookahead. That said, is such
    #lookahead even necessary? Given the negative lookbehind suffixing such
    #words, we should be guaranteed (by the logic of greedy matching) of the
    #suffixing "}" being the end of a shell word.
    # To support macros accepting two or more consecutive argument
    # blocks, avoid matching suffixing whitespace matched as prefixing
    # whitespace by the subsequent such block by merely asserting this
    # constraint with positive lookahead.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code_sans_comment_and_block_suffix}'|[^}])*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_macro_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    #FUXME: ${pcre_words_interpretable_sans_braces_optional} is overkill, as it
    #currently appears to explicitly match glob qualifiers. While we *DO* need
    #to match such qualifiers, we don't particularly care about balanced parens
    #here, meaning such qualifiers could be matched far more efficiently with a
    #simple character class. In other words, we probably want to:
    #
    #* Rename ${pcre_words_interpretable_sans_braces_optional} to
    #  ${pcre_words_braceable_optional}.
    #* Rename ${pcre_words_interpretable_optional} to
    #  ${pcre_words_parenable_optional}.
    #* Refactor the former to use a character class matching arbitrary parens.

    # "("- and ")"-delimited list assignments are commands consisting of
    # multiple shell words rather than subwords of shell words and hence
    # matched here rather than by ${pcre_words_interpretable_optional}. Since
    # such assignments are prefixed by variable names indistinguishable from
    # and hence conflicting with unquoted shell words, the former *MUST* be
    # matched first.
    # local pcre_commands_parenable_optional='(?:(?:'${pcre_list_assignment_optional}'|'${pcre_words_parenable_optional}')'${pcre_command_ends}')*+'

    #FUXME: This doesn't quite work. Consider:
    #
    #    var_name(q#.)
    #
    #That's a perfectly valid shell word, of course, but the current coterie of
    #PCREs fails to match it! Why? Because this PCRE matches "var_name" and
    #then halts, at which point the "(" will be matched as a shell environment
    #prefix rather than a glob qualifier prefix. Of course, that is horribly
    #wrong. The point, of course, is that we need to augment the definition of
    #${pcre_word_interpretable_optional} (or is it
    #${pcre_word_parenable_optional} now?) to first attempt to match
    #${ZESHY_VAR_NAME_PCRE} and, if that succeeds, to then attempt to match
    #${pcre_list_assignment_list_optional}.
    #
    #Hence, these PCREs should be shifted to where word PCREs are defined.
    # local pcre_list_assignment_list_optional='(?:'${pcre_list_assignment_list}')?+'
    # local pcre_list_assignment_optional=${ZESHY_VAR_NAME_PCRE}${pcre_list_assignment_list_optional}

    # local pcre_list_assignment_optional='(?:'${pcre_list_assignment}')?+'
# , excluding the "`" delimiting such
#     # process substitutions
#     # Syntactic construct *NOT* containing "`" delimiters, permitting matching
    # of strictly balanced parens.
    # local pcre_subword_parenable_sans_backtick=${pcre_subword_interpretable_sans_glob_qualifier_parens_backtick}'|'${pcre_subword_interpretable_glob_qualifier_sans_backtick}

    #FUXME: Globally rename ${pcre_subword_interpretable_*} to... well, how
    #about simply ${pcre_subword_*}?

    # "`"-delimited process substitution-specific "("- and ")"-balanced glob
    # qualifier *NOT* containing "`" delimiters.
    # local pcre_subword_interpretable_glob_qualifier_sans_backtick=${pcre_glob_qualifier_prefix}${pcre_subword_interpretable_sans_glob_qualifier_parens_backtick}${pcre_glob_qualifier_suffix}

    # local pcre_subword_braceable=${pcre_subword_interpretable_sans_glob_qualifier_parens}'|'${pcre_subword_interpretable_glob_qualifier}

    #FUXME: If "substitutable" only applies to standard arguments, rename
    #"substitutable" everywhere to "passable". (Yay for terseness.)

    # Interpretable shell word, signifying arbitrary code excluding such
    # shell-reserved syntax as operators (e.g., "&!", "||") and block
    # delimiters (e.g., "{", "}").
    # local pcre_word_parenable=${pcre_word_lookahead}${pcre_subwords_interpretable}${pcre_word_lookbehind}

#  containing one or more syntactic
    # constructs optionally containing balanced and/or unbalanced parens

# containing one or more syntactic constructs
    # optionally containing strictly balanced parens
    #FUXME: Define ${pcre_comment_optional_spaced_optional}.
    # Zero or more list assignment-specific shell words, each delimited by one
    # or more horizontal whitespace characters optionally interspersed by line
    # continuations.
    # local pcre_words_passable_commentable='(?:'${pcre_word_passable}'(?:'${pcre_comment_optional_spaced}${pcre_word_passable}')*+)?+'

    #FUXME: ${pcre_spaces_horizontal_continuable} strikes us as overkill
    #in *ALL* such PCREs. Why? Because line continuations are already matched
    #as character escapes and hence unquoted shell subwords. Don

    #FUXME: Excise. This has been replaced by ${pcre_word_macroable}.
    # Interpretable shell word *OR* block suffix "}".
    # local pcre_word_interpretable_or_block_suffix=${pcre_word_lookahead}${pcre_subwords_interpretable}

    #FUXME: No, no, and surely no. The current approach fails to match:
    #
    #    my_list=( # This matches.
    #    # This does not. have now failed to match. Meagre congratulations.
    #
    #As resolution, we probably want to adopt a model similar to that of
    #${pcre_commands_parenable_optional} below: e.g.,
    #
    #    local pcre_list_assignment=${pcre_list_assignment_word_spaces_optional}'(?:'${pcre_word_passable}'(?:'${pcre_list_assignment_word_spaces}${pcre_word_passable}')*+)?+'${pcre_list_assignment_word_spaces_optional}
    #
    #${pcre_list_assignment_word_spaces} should be defined to match one or more
    #contiguous runs of one or more whitespace characters optionally followed
    #by a comment.
    #
    #Probably not worth optimizing; just go for the simplistic "|"-based
    #approach. Assuming some permutation of that applies, refactor:
    #
    #* ${pcre_list_assignment_list_prefix} and
    #  ${pcre_list_assignment_list_suffix} to use
    #  ${pcre_list_assignment_word_spaces_optional} rather than their current
    #  whitespace PCRE.
    #* ${pcre_words_assignable_with_parens_balanced_or_comments_spaced_optional}
    #  back to its prior version. Indeed, shouldn't
    #  ${pcre_words_passable_optional} suffice here?
    # local pcre_list_assignment_list_optional='(?:'${pcre_list_assignment_list_prefix}${pcre_words_assignable_with_parens_balanced_or_comments_spaced_optional}${pcre_list_assignment_list_suffix}')?+'

#  ${pcre_list_assignment_word} should probably just be replaced by
    #${pcre_word_passable}; aren't the two exactly equivalent here? 
    #FUXME: Define me. Since "(" and ")" balancing is irrelevant to such
    #parsing, the following should suffice.
    #FUXME: Hmm; the current complexity could be *GREATLY* reduced by:
    #
    #* Matching comments (sans prefixing whitespace) directly in a new PCRE
    #  ${pcre_word_passable_commentable} based on
    #  ${pcre_word_passable}.
    #* Refactoring this PCRE to use customary horizontal spacing, as below.
    #* Improving the list assignment prefix and suffix PCREs to match optional
    #  whitespace (both horizontal and vertical) immediately following and
    #  preceding such prefix and suffix, respectively.
    # local pcre_words_passable_commentable_optional='(?:'${pcre_word_passable_commentable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_passable_commentable}')*+)?+'

    #FUXME: Permitting ${pcre_glob_qualifier_suffix} to be optional strikes us
    #as inherently *WRONG*.
    #  ${pcre_word_assignable} based on ${pcre_word_passable}.

    #FUXME: Define ${pcre_word_argumentable_with_parens_balanced}. Such PCRE
    #should match "$("- and "="-prefixed process substitutions but *NOT* "<("-
    #or ">)"-prefixed redirections.
    #FUXME: Define ${pcre_word_assignable_with_parens_balanced}.
    # Preprocessor-specific syntactic construct optionally containing
    # strictly balanced parens.
    # local pcre_subword_macroable=${pcre_subword_macroable_sans_glob_qualifier_parens}'|'${pcre_subword_macroable_glob_qualifier}

#  Matching strictly balanced
    # parens requires more than merely a character class and hence is deferred
    # to more complex PCREs embedding this PCRE.
    # One or more unquoted characters *NOT* prefixing syntactic constructs
    # conflicting with general-purpose macro preprocessing. Such characters
    # include all ASCII whitespace characters but neither "{" or "}", which
    # must be matched in a much more cautious manner.
    # local pcre_chars_not_code_prefix='[^'${char_not_code_prefix}']++'

    #FUXME: This PCRE is only embedded once below and, arguably, is a terrible
    #idea. Command terminators are complex enough to warrant matching in full;
    #there really exist only a few single-character terminators.

    # One or more command terminators *NOT* prefixing syntactic constructs
    # possibly containing macro-like substrings.
    # local pcre_chars_command_end_not_code_prefix='['${char_command_end_not_code_prefix}']++'

    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(", ")", "{", and "}"
    # characters -- intended to be matched elsewhere in a balanced manner.
    # local char_not_subword_unquoted_with_parens_braces_balanced=${char_not_subword_unquoted_with_parens_balanced}'{}'

    # Core syntactic component excluding parens and braces.
    # local pcre_nanoword_sans_paren_right_braces=${pcre_chars_subword_unquoted_sans_paren_right_braces}'|'${pcre_picoword}

    # Block argument-specific syntactic component excluding glob qualifiers,
    # optionally containing strictly balanced parens and/or braces.
    # local pcre_subword_interpretable_sans_glob_qualifier_parens_braces=${pcre_nanoword_sans_paren_right_braces}'|'${pcre_interpretable}

    # Block argument-specific shell word containing one or more appropriate
    # syntactic constructs but *NOT* "}" block suffixes.
    # local pcre_subword_interpretable_sans_brace_suffix=${pcre_word_parenable}${pcre_word_lookbehind}

    # Block argument-specific "("- and ")"-balanced glob qualifier *NOT* 
    # containing braces.
    # local pcre_subword_interpretable_glob_qualifier_sans_braces=${pcre_glob_qualifier_prefix}${pcre_subword_interpretable_sans_glob_qualifier_parens_braces}${pcre_glob_qualifier_suffix}

    # Block argument-specific syntactic construct *NOT* containing braces.
    # local pcre_subword_interpretable_sans_braces=${pcre_subword_interpretable_sans_glob_qualifier_parens_braces}'|'${pcre_subword_interpretable_glob_qualifier_sans_braces}

    # Shell word containing one or more syntactic constructs optionally
    # containing block suffix "}" and/or balanced and/or unbalanced parens.
    # Note that matching the former only requires omitting negative lookbehind.

#  excluding glob qualifiers, common to only
    # subwords optionally containing parens and/or braces (regardless of
    # whether such delimiters are balanced or not)
# , common to *ALL* types of
    # subwords regardless of context
    # optionally containing strictly balanced parens .

    # List assignment-specific shell word containing one or more syntactic
    # constructs optionally containing strictly balanced parens. Since a "}"
    # block suffix terminates a list assignment, prohibit such word from
    # matching such suffix with negative lookbehind.
    # local pcre_word_assignable_with_parens_balanced=${pcre_word_lookahead}'(?:'${pcre_subword_assignable_with_parens_balanced}')++'${pcre_word_lookbehind}

    # ..................{ OBSOLETE                           }..................
    #FUXME: Excise. This has been replaced by ${pcre_subwords_macroable}.

    # One or more interpretable syntactic constructs in a shell word *OR*
    # redirections.
    # local pcre_subwords_interpretable='(?:'${pcre_subword_interpretable_unqualified}'|'${pcre_subword_interpretable_qualified}'|'${pcre_redirect_punctuation}')++'

    #FUXME: Refactor.
    # One or more interpretable syntactic constructs in a shell word excluding
    # "`"-delimited process substitutions *OR* redirections.
    # local pcre_subwords_interpretable_sans_backtick='(?:'${pcre_subword_interpretable_sans_backtick_unqualified}'|'${pcre_subword_sans_backtick_interpretable_qualified}'|'${pcre_redirect_punctuation}')++'

    #FUXME: Define in a similar manner to
    #${pcre_subword_interpretable_with_parens_balanced} above. Can we reuse
    #${pcre_subword_interpretable_sans_glob_qualifier}? We suspect not, but
    #glibly investigate.

    # Interpretable syntactic construct optionally containing strictly balanced
    # braces.
    # local pcre_subword_interpretable_with_parens_braces_balanced=

    #FUXME: Define ${pcre_subword_assignable_with_parens_balanced_sans_glob_qualifier}.
    #FUXME: Define ${pcre_subword_argumenentable_with_parens_balanced}.

    # List assignment-specific syntactic component excluding glob qualifiers,
    # optionally containing strictly balanced parens.
    # local pcre_subword_assignable_with_parens_balanced_sans_glob_qualifier=${pcre_subword_with_parens_balanced_sans_glob_qualifier}'|'${pcre_assignable}

    #FUXME: Hmm. By "argumentable," we do appear to exactly imply
    #"substitutable." As the latter is certainly more descriptive than the
    #former, rename all instances of the former to the latter.

    # ..................{ OBSOLETE                           }..................
    #FUXME: Everything below should arguably be excised now.

    # Shell word component, excluding both "("- and ")"-balanced glob qualifiers
    # and recursively nestable syntactic constructs.
    # local pcre_subword_unqualified=${pcre_chars_subword_unquoted_sans_paren_right}'|'${pcre_char_escaped_optional}'|'${pcre_quotes_optional}

    # Substitutable shell word component, excluding "("- and ")"-balanced glob
    # qualifiers.
    # local pcre_subword_passable_unqualified=${pcre_subword_unqualified}'|'${pcre_substitutable}

    # Interpretable shell word component, excluding "("- and ")"-balanced glob
    # qualifiers.
    # local pcre_subword_interpretable_unqualified=${pcre_subword_unqualified}'|'${pcre_interpretable}

    # # List assignment-specific "("- and ")"-balanced glob qualifiers.
    # local pcre_subword_assignable_glob_qualifier=${pcre_glob_qualifier_prefix}${pcre_subword_assignable_with_parens_balanced_sans_glob_qualifier}${pcre_glob_qualifier_suffix}

    #FUXME: Globally rename "word_parenable" to "word_passable"
    #*AFTER* eliminating all "OBSOLETE" subsections above and below.

    #FUXME: Document why the lookahead is more complex than that below --
    #namely, because we need to match "$("- and ")"-delimited process
    #substitutions as command terminators rather than as shell words.
    #FUXME: Hmm; this fails to match "$"-prefixed variable names, which it
    #probably should, since we probably have no other means of matching such
    #names in the context of top-level parsing. Do we?
    #
    #Taken together, this and the prior FUXME suggest that we probably want to
    #suffix the "\$" in such lookahead instead by a single negative character
    #class explicitly preventing matching of process substitutions (and other
    #undesirable syntactic constructs). That addresses both concerns with one
    #single code stone.
    #
    #The question then becomes: exactly which prefixes do we need to prohibit?

    # Substitutable shell word-specific "("- and ")"-balanced glob qualifiers.
    # local pcre_subword_passable_qualified=${pcre_subword_qualified_optional_prefix}${pcre_subword_passable_unqualified}${pcre_subword_qualified_optional_suffix}

    # Interpretable shell word-specific "("- and ")"-balanced glob qualifiers.
    # local pcre_subword_interpretable_qualified=${pcre_subword_qualified_optional_prefix}${pcre_subword_interpretable_unqualified}${pcre_subword_qualified_optional_suffix}

    #FUXME: Directly inline and then excise all such PCREs.
    # One or more argumentable syntactic constructs optionally containing
    # strictly balanced parens.
#     local pcre_subwords_argumentable_with_parens_balanced='(?:'${pcre_subword_argumentable_with_parens_balanced}')++'
# ${pcre_subwords_argumentable_with_parens_balanced}

    # One or more assignable syntactic constructs optionally containing
    # strictly balanced parens.
    # local pcre_subwords_assignable_with_parens_balanced='(?:'${pcre_subword_assignable_with_parens_balanced}')++'

    # One or more interpretable syntactic constructs optionally containing
    # strictly balanced parens.
    # local pcre_subwords_interpretable_with_parens_balanced='(?:'${pcre_subword_interpretable_with_parens_balanced}')++'
    # ${pcre_subwords_interpretable_with_parens_balanced}

    # One or more syntactic constructs optionally containing balanced and/or
    # unbalanced parens.
    # local pcre_subwords_macroable='(?:'${pcre_subword_macroable}')++'
# ${pcre_subwords_macroable}

    #FUXME: Replace *EVERYTHING* below (excluding backticks-style process
    #substitutions, of course) by this single PCRE.

    # Possibly recursively nested process substitution content, omitting
    # prefixing and suffixing delimiters.
    # local pcre_process_parens_body=${pcre_codes_optional}

    # "$("- and ")"-delimited possibly recursively nested process substitution,
    # omitting such delimiters.
    # local pcre_process_substitution_dollar_optional=${pcre_process_parens_body}'\)?+'

    # "=("- and ")"-delimited possibly recursively nested process substitution,
    # implicitly creating and removing temporary files.
    # local pcre_process_substitution_file_optional='=\('${pcre_process_parens_body}'\)?+'

    # "<("- or ">("- and ")"-delimited possibly recursively nested process
    # substitution, also performing redirection.
    # local pcre_process_substitution_redirect_optional='[<>]\('${pcre_process_parens_body}'\)?+'

    #FUXME: The current approach duplicates
    #${pcre_process_parens_body} across numerous PCREs, all of
    #which are identical except for prefixing syntax. The sane thing to do,
    #therefore, is to replace *ALL* PCREs below (including this one) by a
    #minimal number of compact PCREs resembling:
    #
    #    local pcre_process_substitution_parens='[$=<>]\('${pcre_codes_optional}
    #
    #Far simpler. Far faster. For great justice, you know what to do.

    #FUXME: Actually, we *CAN* readily match macros in process substitutions
    #*NOT* nested in double quotes -- implying that the only contexts in which
    #macros are unexpandable are double-quoted process substitutions. That
    #said, the road to matching macros in process substitutions *NOT* nested in
    #double quotes is non-trivial. Why? Because:
    #
    #* When matching macros, we want to search for command terminating
    #  positions and hence possible macros in both the top-level script code
    #  *AND* within all nested syntactic constructs.
    #* After matching a macro name and then when matching macro arguments (both
    #  block and standard), we do *NOT* want to attempt to match additional
    #  nested macros.
    #
    #This implies we need *TWO* variants of each process substitution PCRE. We
    #need the current variant, ignoring macros, for use when matching macro
    #arguments; and we need a new variant -- perhaps suffixed by "_preprocessable"
    #(e.g., ${pcre_process_substitution_dollar_preprocessable}), for use when
    #matching macros.
    #
    #Defining the latter probably implies replacing the ${pcre_codes_optional}
    #in ${pcre_process_substitution_dollar_preprocessable} with ${pcre_macro}
    #instead. Since ${pcre_macro} is quite intricate, however, we probably
    #won't want to repeat its lengthy definition in every process substitution.
    #So, yes: we'll probably want to abstract ${pcre_macro} out into a new
    #subroutine definition -- say, "<mac>".
    #
    #Now, you're probably ruminating: but isn't that inefficient? Well, no. Or,
    #not really, anyway. Process substitutions are infrequently used enough to
    #suggest that there would exist little to no performance penalty.
    #
    #There is, however, a conundrum: captured groups. Subroutine calls unwind
    #groups captured by such call, as the following example demonstrates:
    #
    #    >>> match=(); :is 'yum' =~ 'y(?&ugh)m(?(DEFINE)(?<ugh>(u)))' :si &&
    #    ...     print "${#match}: ${match[*]}" 
    #    0:
    #
    #In this case, that fairly sucks. Any way around that? We reckon not.
    #
    #Oh. Oh, boy. Wait. Yes! Of course there is. Rather than defining
    #${pcre_process_substitution_dollar_preprocessable}, we split a new PCRE 
    #${pcre_process_substitution_dollar_prefix} from the existing
    #${pcre_process_substitution_dollar}: e.g.,
    #
    #    local pcre_process_substitution_dollar_prefix='\$\('
    #
    #Then (and this is the sweet kicker), we match
    #${pcre_process_substitution_dollar_prefix} as an unspaced command
    #terminator! *BAM*. It's simple; it's fast; it requires no significant
    #changes elsewhere. Extend the same technique to every process substitution
    #prefix, and we are comparitively in business.
    #
    #Actually, a few other minor changes will be needed as well.
    #${pcre_code_sans_comment_or_command_end_prefix}, as currently embedded in
    #${pcre_macro}, matches process substitutions. Such PCRE will thus need to
    #be renamed to
    #${pcre_code_sans_comment_or_command_end_prefix_and_process_substitution}.
    #At that point, of course, it would probably be more expedient to list what
    #such PCRE *DOES* match rather than what it doesn't! In any case, such PCRE
    #will probably need to embed either ${pcre_word_passable_with_parens_balanced} or a new
    #${pcre_word_interpretable_sans_process_substitution} in place of the
    #${pcre_word_parenable} such PCRE currently embeds.

# optionally containing balanced and/or
    # unbalanced parens and hence *NOT* matched via the above approach. 
    #FUXME: Add support for parens-balanced qualified subwords.
    # local pcre_subword_interpretable_with_parens_balanced=${pcre_chars_subword_unquoted_sans_paren_right}'|'${pcre_char_escaped_optional}'|'${pcre_quotes_optional}'|'${pcre_redirect}'|'${pcre_subword_interpretable_glob_qualifier}'|'${pcre_interpretable}

    #FUXME: Honestly, this strikes us as as extreme overkill. Directly inlining
    #and then excising all such PCREs would almost certainly be to the good.
    #FUXME: Clearly not quite right. Revise according to
    #${pcre_subwords_interpretable_with_parens_balanced}.

    # Zero or more whitespace characters, comments, and/or substitutable shell
    # words optionally containing strictly balanced parens.
    # local pcre_words_argumentable_spaced_with_parens_balanced_or_comments_spaced_optional='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_comment_optional_spaced}')*+'

    #FUXME: O.K.; we can't prefix this by ${pcre_list_assignment_optional}, due
    #to chicken-and-egg issues. Instead, we'll need to manually prefix
    #${pcre_words_interpretable_with_parens_balanced} by
    #"${pcre_list_assignment_optional}|".
    #
    #Actually, that doesn't really work. No, the current approach is sound; we
    #simply need to define *ALL* substitutable word constructs before *ALL*
    #interpretable word constructs, implying a slight restructuring. But that
    #should it.
    #
    #Actually, that's a terrible idea. While it probably *WOULD* work, the core
    #issue here is that treating a list assignment consisting of multiple shell
    #words like a single shell word is fundamentally wrong. So, we *DO* need to
    #revert to the prior conception and prepend
    #"${pcre_list_assignment_optional}'|'" at the highest PCRE level possible.
#
    #FUXME: So, this is clearly munted. What's the best way to restore this?
    #There's no recursive nesting of such assignments, so this should be
    #feasible parseable without much effort. We're inclined to agree with the
    #prior approach: that is, ${pcre_list_assignment_optional} needs to be
    #defined as late (and hence as far below) as possible. That should get us
    #most of the way there, yes?
    # local pcre_subword_passable_unqualified=${pcre_subword_unqualified}'|'${pcre_substitutable}
    # local pcre_subword_passable_qualified=${pcre_subword_qualified_optional_prefix}${pcre_subword_passable_unqualified}${pcre_subword_qualified_optional_suffix}
    # local pcre_subwords_argumentable_spaced_with_parens_balanced='(?:'${pcre_subword_passable_unqualified}'|'${pcre_subword_passable_qualified}')++'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}${pcre_subwords_argumentable_spaced_with_parens_balanced}${pcre_word_lookbehind}
    # local pcre_words_argumentable_spaced_with_parens_balanced_or_comments_spaced_optional='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_comment_optional_spaced}')*'

    # While matching "("- and ")"-delimited list assignments is essential to
    # such balancing, the typical chicken-and-egg issues require we defer such
    # inclusion to PCREs embedding this PCRE. *collective shrug*

    #FUXME: This currently fails to match backticks. That appears to be the
    #only significant omission, which is mildly great.
    #FUXME: O.K.; so, we're going to need to split this into two PCREs:
    #
    #1. A PCRE specific to matching macros -- say,
    #   ${pcre_subword_macroable}. The current approach is pretty much
    #   already there. We only need to temporarily match backticks as unquoted
    #   characters. They aren't, of course; but until we at least get double
    #   quotes-embedded process substitutions to work, backticks will have to
    #   take a back seat here. To do so, just match "`[^`]*+`" manually at the
    #   very end of such PCRE and add a FUXME comment reminding ourselves to
    #   eliminate such hackiness at some future date.
    #2. A PCRE specific to matching braces -- say,
    #   ${pcre_subword_interpretable_with_braces_balanced}.

#  To match syntactically
    # valid variable expansions undelimited by "{" and "}" *AND* syntactically
    # invalid "$"-prefixed strings, such syntax is matched optionally.
    #FUXME: Eliminate this PCRE in favor of merely embedding
    #${pcre_codes_optional} directly below.
    # local pcre_macroable='(?=\$(?:[{\[]|\(\())(?&exp)'

    #FUXME: The lookahead strikes us as inherently wrong. Investigate.
    #Shouldn't we simply use a character class, as above and below -- or, if
    #only matching "$"-prefixed constructs, merely a "$"?
    #FUXME: Rather than a mere character class, wouldn't it ultimately 

    #FUXME: Honestly, defining separate ${pcre_subwords_macroable}
    #PCREs strikes us as overkill. Embed such PCREs directly here and then
    #excise such PCREs entirely.

    #FUXME: Uhm; ${pcre_macro_optional} appears to be undefined. Oh, right. The
    #reason why is that macro PCREs are necessarily split up into a prefix and
    #suffix to account for the fact that macro names are dynamically
    #updateable. We'll need to similarly split up the final PCRE below.
    #FUXME: Actually, rather than the current prefix and suffix approach, it
    #would be *MUCH* more sensible to pursue a sprintf()-style approach,
    #whereby we construct a single global embedding an expression resembling
    #"%{macro_names}" or some such, to be dynamically subsequently replaced by the
    #corresponding string at runtime (e.g., "|"-delimited macro names). This is
    #particularly helpful, both for readability and maintainability, as we
    #expect to have at least two such constructs in the future: "|"-delimited
    #macro names *AND* zeshy-specific global alias names.
    #
    #Right. While zsh provides printf() out of the box, there's no sprintf()
    #equivalent. Which is no problem. Simply adopt the Python approach (e.g.,
    #"%{macro_names}" or some such); then, manually search and replace the
    #*FIRST* such string in ${ZESHY_MACRO_PCRE} in ={pcre/pcre}. Simple!

# PCRE prefixing ${ZESHY_MACRO_PCRE} if at least one macro exists. Such prefix
# is constant and hence defined at parcel importation time.
# typeset -g ZESHY__MACRO_PCRE_IF_NONEMPTY_PREFIX

# PCRE suffixing ${ZESHY_MACRO_PCRE} if at least one macro exists. Such suffix
# is constant and hence defined at parcel importation time.
# typeset -g ZESHY__MACRO_PCRE_IF_NONEMPTY_SUFFIX

    #FUXME: Excise ${pcre_spaces_horizontal_grouped_continuable_optional}.
    # Zero or more horizontal whitespace characters *OR* line continuations,
    # capturing the last contiguous run of the former if any.
    # local pcre_spaces_horizontal_grouped_continuable_optional='(?:'${pcre_spaces_horizontal_grouped}'|'${pcre_line_continuation}')*+'

    # local pcre_command_ends=${pcre_spaces_horizontal_grouped_continuable_optional}'(?:'${pcre_command_end_unspaced}'|(?(-1)'${pcre_command_end_spaced}'))'${pcre_spaces_horizontal_continuable_optional}${pcre_command_ends_spaced_optional}

#, optionally
    # followed by a command terminator requiring either prefixing whitespace or
    # a command terminator *NOT* requiring prefixing whitespace

    #FUXME: Not quite right. We previously matched zero or more whitespace
    #characters suffixing an unspaced command terminator. We no longer do, which
    #is clearly wrong. Why? Because the current approach no longer matches
    #optional whitespace delimiting an unspaced command terminator from the
    #subsequent macro name or shell word.
    #
    #What we *NEED* to do is match such whitespace and, if matched, also
    #optionally match a spaced command terminator. But ${pcre_command_ends}
    #already does exactly that, except that it then mandatorily rather
    #optionally matches a command terminator.
    #
    #All of this whitespace matching business suggests, perhaps, that we want
    #something resembling:
    #
    #    local pcre_spaces_horizontal_grouped_continuable_body=${pcre_spaces_horizontal}'|'${pcre_line_continuation}
    #    local pcre_spaces_horizontal_grouped_continuable='(?<spa>(?:'${pcre_spaces_horizontal_grouped_continuable_body}')++)'
    #    local pcre_spaces_horizontal_grouped_continuable_optional='(?:'${pcre_spaces_horizontal_grouped_continuable}')?+'
    #
    #Ideally, this should ensure that, wherever
    #${pcre_spaces_horizontal_grouped_continuable_optional} is embedded,
    #either:
    #
    #* One or more horizontal whitespace characters are matched, in which case
    #  group "<spa>" is non-empty.
    #* No such characters are matched, in which case group "<spa>" is empty.
    #
    #In the latter case, what does logic of the form "(?<spa>A|B)" do? Does it
    #attempt to match "B" rather than "A"? Do we need to use the "libpcre"
    #directive "THEN", finally?
    #
    #Honestly, the above approach is complex enough that we want to test this
    #manually. What does "libpcre" actually do?
    #
    #Anyway, the whole point of this is that we should be able to embed a
    #single PCRE ${pcre_spaces_horizontal_grouped_continuable} or
    #${pcre_spaces_horizontal_grouped_continuable_optional} as appropriate
    #wherever we currently attempt to match horizontal whitespace by other
    #means. That, in turn, will ensure that group "<spa>" is available for
    #subsequent testing. While we suspect this can be made to work, there exist
    #a few gotchas:
    #
    #* We have to make sure that "<spa>" resets on every attempt to match such
    #  group, rather than "remembering" prior successful match attempts.
    #
    #Curiously, the "libpcre" documentation reads as follows:
    #
    #    "If you use a named reference in a condition test (see the section
    #     about conditions below), either to check whether a subpattern has
    #     matched, or to check for recursion, all subpatterns with the same name
    #     are  tested.  If  the condition is true for any one of them, the
    #     overall condition is true."
    #
    #Oh, blast it. This *WOULD* work, except that we'd need to set the
    #"PCRE_DUPNAMES" PCRE-compile-time option, except that we can't do that, as
    #pcre_compile() accepts no corresponding flag *AND* as "man pcrepattern"
    #shows that there exists no corresponding start-of-pattern item (e.g.,
    #as is the case for "(*BSR_ANYCLRF)"). This means, in turn, that we'll
    #either need to accept some measure of backtracking and complexity *OR*
    #we'll need to capture such whitespace into uniquely named groups and then
    #test all such groups. (Yeah; that sucks.)
    #
    #Given these constraints, we're definitely trending toward the former. But
    #give it all a wee more contemplation, shall we?
    #
    #Right. So, the latter is certainly feasible, as the following examples
    #shows:
    #
    #    >>> :is 'o;' =~ '^(?<za>d)?+(?<zb>o)?+(?:(?(<za>);)|(?(<zb>);)|,)$' :si :and print ok
    #    ok
    #    >>> :is 'd;' =~ '^(?<za>d)?+(?<zb>o)?+(?:(?(<za>);)|(?(<zb>);)|,)$' :si :and print ok
    #    ok
    #
    #That said, since we can't test multiple named subpatterns at a time, the
    #resulting syntax is insanely oververbose -- and the whole thing just feels
    #kludgy enough to fall over breathless at any moment. So, let's drop such
    #silliness and match suffixing whitespace manually here. Note that we
    #already match vertical whitespace appropriately; it's the optional
    #suffixing horizontal whitespace interspersed by line continuations and all
    #optionally followed by a spaced command terminator that we need to handle.
    #The difficulty here, of course, is that that process could be repeated
    #indefinitely, suggesting subtler pain. But there's really no alternative.
    #Hmm. Actually, one simple approach could be to define a new PCRE
    #${pcre_command_ends} and replace all current use of ${pcre_command_ends} by
    #that PCRE instead: e.g.,
    #
    #    local pcre_command_ends='(?:'${pcre_command_ends}')++'${pcre_spaces_horizontal_continuable_optional}
    #
    #Rather simple. Slight backtracking insofar as whitespace is concerned,
    #but... meh. We could presumably do much better if we had access to the
    #full "libpcre" API. But we don't, so here we are. (Something is better than
    #nothing, right?)
    #FUXME: Actually, we've corrected this without such shenanigans. Yay!

    # One or more vertical whitespace command terminators optionally followed
    # by a command terminator requiring prefixing whitespace.
    # local pcre_command_end_spaces_vertical=${pcre_spaces_vertical}${pcre_command_ends_spaced_optional}

    #O.K.; hmm, despite the syntactic shenanigans involved, perhaps we *DO*
    #just need to match d

    #    local pcre_spaces_horizontal_grouped_continuable_optional='(?:(?<spa>'${pcre_spaces_horizontal}')|'${pcre_line_continuation}')*+'
    #
    #Or perhaps, if the above fails (which, increasingly, it intuitively
    #appears that it will):

    #FUXME: Insufficient. All such terminators *MUST* be suffixed by at least
    #one whitespace character (either horizontal or vertical) optionally
    #prefixed by one or more line continuations. Consuming a horizontal
    #whitespace character is trivial. However, is consuming a vertical
    #whitespace character entirely safe? Well, yes. Almost certainly. So just
    #consume both. Yay!

    # zeshy-specific command terminators, prefixed by one or more shell-words
    # and suffixed by one or more whitespace characters optionally interspersed
    # with line continuations. Since numerous syntactic constructs are matched
    # by consuming prefixing whitespace, such whitespace *MUST* be non-
    # consumptively detected with positive lookahead.
    # local pcre_command_end_zeshy=':(?:or|and|not)(?='${pcre_space_horizontal_continuable}')'

    #FUXME: We need to match *SOME* unbalanced syntactic suffixes here (e.g.,
    #")", "}"). We do currently match "}", but what about ")"? The difficulty
    #with matching ")", of course, is that we need to only match ")" as a
    #last-ditch fallback to prevent subsequent attempts to match ")" as a
    #balanced syntactic delimiter from failing. So, how do we do that? Hmm.
    #Actually, matching ")" here would probably be fine, if we note that in the
    #variable name.
    #
    #That said, we'll need to avoid using this PCRE in process substitutions,
    #where an unbalanced ")" must *ABSOLUTELY* not be matched by the embedded
    #PCRE. So, perhaps we want to rename these PCREs to
    #${pcre_code_sans_comment_or_command_end_or_paren_right_prefix_*}
    #(which, while crazy, is unambiguously descriptive, which takes precedence)
    #and then define a new PCRE
    #${pcre_code_sans_comment_or_command_end} explicitly matching ")" as well.
    #Naturally, the latter should be used in ${pcre_macro}. Nice, eh?
    #FUXME: The above suggests we should just omit "(" and ")" from a new
    #negative character class -- say, ${char_sans_word_macroable} or some such.
    #In such case, we can efficiently omit both
    #${pcre_list_assignment_optional} *AND* the qualified (i.e.,
    #"("- and ")"-balanced) variant of such PCRE from ${pcre_code_preprocessable}.
    #Which is great! Of course, process substitutions still require the current
    #version of ${pcre_code} matching such constructs. Right; in terms of clear
    #nomenclature, perhaps we want:
    #
    #* A new PCRE ${pcre_code_with_parens_arbitrary}, matching arbitrary "("
    #  and ")".
    #
    #* A PCRE ${pcre_code_with_parens_balanced}, matching only balanced "("
    #  and ")". Hence, rename ${pcre_code} to
    #  ${pcre_code_with_parens_balanced}.
    #
    #Sensible, yes? Actually, how about just ${pcre_words_macroable}. Let's face it:
    #this PCRE is specific to matching non-macro syntactic constructs. That's
    #all it will ever do, and that's all it *SHOULD* ever do.

    #FUXME: Define ${pcre_char_not_command_end}: e.g.,
    #
    #    # Is this sufficient? No idea.
    #    local char_not_command_end=':'${char_command_end}
    #    local pcre_char_not_command_end='[^'${char_not_command_end}']
    #
    #That said, does this definition suffice to ensure that
    #${pcre_codes_or_chars_not_command_end_optional} *NEVER* matches command
    #terminators? Probably not. While ${pcre_macro} is *GUARANTEED* not to
    #match any command terminator (by constraints imposed by ={frontend}), no
    #such constraints apply to ${pcre_char_not_command_end}. Hmm.
    #
    #O.K.; the current ${pcre_char_not_command_end} is a poor idea. It simply
    #matches *TOO* match. Moreover, since ${pcre_code} already matches all
    #unquoted non-shell-reserved characters, we need to merely match all
    #unquoted shell-reserved characters that are *NOT* command terminators
    #here. That means something like:
    #
    #    #FIXME: No idea what ${char_not_subword_unquoted_or_command_end}
    #    #should like like. Examine existing character classes for inspiration.
    #    #Assuming ${pcre_subword_unquoted} matches everything it should, it's
    #    #unclear whether any other non-terminating shell-reserved characters
    #    #not already matched by ${pcre_subword_unquoted} exist. Is "}" really
    #    #it? That'd be great, if so.
    #    local char_not_subword_unquoted_or_command_end=${char_space_horizontal}'}'
    #    local pcre_chars_not_subword_unquoted_or_command_end='[^'${char_not_subword_unquoted_or_command_end}']++

    #FUXME: Actually, having ${char_not_subword_unquoted_or_command_end} match
    #horizontal whitespace is hardly ideal. Here's what we should do instead:
    #
    #* Explicitly match one or more horizontal whitespace characters as an
    #  additional alternative below.
    #* Such match should be followed by negative lookahead preventing such
    #  whitespace from being matched when followed by a command terminator.
    #  Fortunately, we've already implemented such lookahead -- it just happens
    #  to be in the wrong place! Shift negative lookahead matching whitespace-
    #  prefixed command terminators from ${pcre_word_parenable} to here.
    #FUXME: Right. So, we actually no longer need
    #${char_not_subword_unquoted_or_command_end} at all, assuming we:
    #
    #* Implement the prior solution regarding horizontal whitespace.
    #* Create a new PCRE ${pcre_word_interpretable_sans_lookbehind}, foregoing
    #  the negative lookbehind suffixing ${pcre_word_parenable}.
    #* Rename the existing ${pcre_code} to ${pcre_code_sans_block_suffix}.
    #* Create a new ${pcre_code} embedding
    #  ${pcre_word_interpretable_sans_lookbehind} rather than 
    #  ${pcre_word_parenable}.
    #
    #That takes care of "}", the last remaining issue relating to
    #shell-reserved characters. (We innocently believe, anyway!)
    #FUXME: O.K.; the above whitespace solution *WOULD* theoretically work, at
    #a cost of imposing mandatory backtracking on every command terminator
    #necessarily prefixed by whitespace, which is unfortunate. An alternative
    #is as follows:
    #
    #* Immediately after matching ${pcre_continuable_spaces_horizontal}, optionally match a
    #  space-prefixed command terminator. For subsequent detection, capture
    #  such terminator with a named (?) group -- say, "<term>".
    #* Replace the current use of ${pcre_command_ends} below with:
    #  '(?(<term>)|'${pcre_command_end_unspaced}')'
    #
    #Wait. That *WOULD* work, except that we have no way of clearing the named
    #group"<term>" after its detection in such conditional pattern. That said,
    #we can account for this as well with empty groups in prior alternatives:
    #e.g.,
    #
    #    local pcre_codes_or_macros='(?:(?|'${pcre_macro}${pcre_empty_group}'|'${pcre_code}${pcre_empty_group}'|'${pcre_continuable_spaces_horizontal}'('${pcre_command_end_spaced}'))(?(-1)|'${pcre_command_end_unspaced}')*'
    #
    #Reasonably clever, no?

    #FUXME: Ugh. There's a slight conflict between attempting to match
    #${pcre_continuable_spaces_horizontal} and matching ${pcre_char_escaped_optional} in
    #${pcre_code}: line continuations. Contemplate. Wait! No, there's no
    #conflict, as ${pcre_continuable_spaces_horizontal} matches greedily. That
    #said, since we don't need to match prefixing line continuations here,
    #${pcre_continuable_spaces_horizontal} is overkill. We only require the
    #portion of that PCRE *AFTER* matching optional prefixing line
    #continuations. Since we do that elsewhere as well, we'll probably want to
    #abstract the desired match into a new PCRE above.
    #FUXME: Document the usage of empty groups below. This is fairly important.
    #FUXME: Excise ${pcre_command_end_spaced} and rename
    #${pcre_command_end_spaced_body} to ${pcre_command_end_spaced}.
    # local pcre_math_test_prefix='\(\('
    # local pcre_process_substitution_equals_prefix='=\('

    # Command terminator *NOT* requiring prefixing whitespace characters,
    # optionally suffixed by one or more horizontal whitespace characters, *OR*
    # the end of such string. While such terminator may be prefixed by
    # whitespace characters, such characters *MUST* be matched by PCREs
    # embedding this PCRE.
    # , optionally suffixed by
    # one or more whitespace characters.
    #FUXME: Suffixing whitespace is probably inappropriate here. See below.
# ${pcre_spaces_horizontal_continuable_optional}

    #FUXME: Then rename ${pcre_macro_command_end} to ${pcre_command_ends} and
    #shift above.
    # One or more horizontal whitespace characters optionally interspersed with
    # line continuations optionally followed by a command terminator requiring
    # such whitespace and one or more horizontal whitespace characters.
    #
    # While ${pcre_continuable_spaces_horizontal} *COULD* be employed to match
    # such whitespace, such PCRE unnecessarily matches optional prefixing line
    # continuations already matched by ${pcre_macro_command_optional} and is
    # hence inefficient in this context.

    # local pcre_command_end_spaced=${pcre_spaces_horizontal_continuable}${pcre_command_end_spaced_body}

    #FUXME: The trailing "${pcre_spaces_horizontal_optional}" is unfortunate.
    #Ideally, command terminators should be prefixable by optional whitespace,
    #which would permit us to eliminate use of
    #${pcre_spaces_horizontal_optional} below -- which would be a good thing.

    # local pcre_macro_command_end='(?:'${pcre_spaces_horizontal_continuable}${pcre_command_end_spaced_body}'|'${pcre_command_end_unspaced}')'
    # local pcre_macro_spaces_or_words_optional='(?|'${pcre_spaces_horizontal_grouped}${pcre_line_continuations_spaceable_horizontal_optional}'|'${pcre_word_macroable}${pcre_empty_group}')*+'
    # local pcre_word_macroable_optional='(?:'${pcre_word_macroable}')?'
    # local pcre_macro_optional='(?:'${pcre_macro}')?+'
    # local pcre_macro_suffix_optional='(?|'${pcre_word_macroable_optional}${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}'(?:('${pcre_command_end_spaced_body}')?)*+'
    # ${pcre_command_end_spaced_optional_grouped}'|'${pcre_words_macroable}${pcre_empty_group}')?+'
    # local pcre_command_end_spaced_prefix=${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}
    # local pcre_command_end_spaced_optional=${pcre_command_end_spaced_prefix}'(?:'${pcre_command_end_spaced_body}')?'
    # local pcre_command_end_spaced_optional_grouped=${pcre_command_end_spaced_prefix}'('${pcre_command_end_spaced_body}')?'
    # local pcre_words_macroable=${pcre_word_macroable}'('${pcre_spaces_horizontal}${pcre_word_macroable}')*+'
    # local pcre_macro_suffix_optional='(?|'${pcre_command_end_spaced_optional_grouped}'|'${pcre_words_macroable}${pcre_empty_group}')?+'
    # local pcre_macro_command_end='(?(-1)|'${pcre_command_end_unspaced}')'

    #FUXME: This can be slightly optimized by noting that 
    #FUXME: O.K.; ${pcre_command_end_unspaced} is optionally prefixable by
    #whitespace. Hmm...
    #FUXME: Define ${pcre_spaces_horizontal_grouped_continuable_optional} in a
    #manner ensuring that such group is nonempty if at least one horizontal
    #whitespace character is matched.

    #FUXME: Refactor ${pcre_command_end_spaced_body} appropriately and
    #eliminate related unused PCREs.
    #FUXME: Shift appropriate PCREs above.
    #FUXME: The fact that we match whitespace both here and in ${pcre_macro}
    #guarantees frequent backtracking. To avoid this, this PCRE should be
    #inlined directly into ${pcre_macro} and the prefixing whitespace unified
    #with ${pcre_command_end_spaced_optional}.
    # local pcre_words_macroable=${pcre_word_macroable}'('${pcre_spaces_horizontal}${pcre_word_macroable}')*+'

    # local pcre_command_end_spaced_prefix=${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}
    # local pcre_command_end_spaced_optional=${pcre_command_end_spaced_prefix}'(?:'${pcre_command_end_spaced_body}')?'
    # local pcre_command_end_spaced_optional_grouped=${pcre_command_end_spaced_prefix}'('${pcre_command_end_spaced_body}')?'

    # local pcre_spaces_horizontal_grouped='('${pcre_spaces_horizontal}')'
    # local pcre_spaces_horizontal_continuable_after_grouped=${pcre_spaces_horizontal_grouped}${pcre_line_continuations_spaceable_horizontal_optional}

    #FUXME: Not quite. Shell words may only be delimited by whitespace.
    #Otherwise, quite close.

    # Code atom matching all syntactic constructs *NOT* preprocessor macros.

    #FUXME: Define ${pcre_word_macroable} as
    #${pcre_word_interpretable_or_block_suffix}; then excise the latter.
    #FUXME: It seems increasingly likely that ${pcre_here_optional} should be
    #embedded directly into ${pcre_word_macroable}.
    #FUXME: Still not quite right. We want to be able to match macros suffixed
    #by... well, nothing (i.e., the string end optionally preceded by ignorable
    #horizontal whitespace).

    # local pcre_macro_command_optional='(?|'${pcre_macro}${pcre_empty_group}'|'${pcre_empty_group}${pcre_empty_group}'(?:'${pcre_command_end_spaced_optional_grouped}'|'${pcre_codes_sans_comment_or_command_end}${pcre_empty_group}'))?'

#  Since all such constructs
    # are also embeddable, this subroutine matches a proper superset of the set
    # of all constructs matched by the prior subroutine.
# , intended to be called *ONLY*
    # recursively from within such constructs
    #FUXME: Actually define me as above.
    # local pcre_dollar_expansion_optional='(?:\$(?:[{\[]|\(\()'

    #FUXME: Define ${pcre_interpretable_non_macro}.
    #FUXME: Honestly, this variable name is horrid. Does this only match
    #FUXME: ${pcre_command_end_zeshy} defined below.
    #FUXME: ${pcre_comment} must be integrated, probably as below.
    #Actually, comments are almost certainly best matched by integration into
    #${pcre_command_ends}. If one considers it, a comment effectively serves as
    #a command terminator. Indeed, contemplation suggests that such an approach
    #yields an optimally efficient match.

    #FUXME: Define me, according to PCREs defined below.
    #FUXME: Define me. Wait. Actually, don't. Excise this.
    # local pcre_code_sans_comment_or_command_end_or_process_substitution

    #FUXME: Rename to ${char_not_subword_unquoted_with_parens_balanced}. Define
    #in term of a new ${char_not_subword_unquoted_with_parens_arbitrary}.
    # local char_not_subword_unquoted_with_parens_balanced=${char_reserved}'''"&()$\\`'

    # Character class matching unconditionally shell-reserved operators (i.e.,
    # ASCII punctuation parsed unconditionally, typically terminating the prior
    # command). This class omits conditionally shell-reserved operators (e.g.,
    # "{" and "#", only shell-reserved when the first characters of unquoted
    # shell words).

    # Since "#", "{", and "}" are only conditionally shell-reserved *AND* since
    # "*", "!", "^", and "?" have no bearing on preprocessor parsing (despite
    # being shell-reserved characters), this class excludes such characters.
    # Conversely, since "(" and ")" are *ALWAYS* shell-reserved but permitted
    # in unquoted shell words when strictly balanced (e.g., "like(this)" but
    # not "like(this("), this class includes such characters. Specifically:
    #
    # * "#" and "{" are only shell-reserved when preceded by either the start
    #   of a line *OR* horizontal whitespace.
    # * "}" only shell-reserved when followed by either the end of a line *OR*
    #   horizontal whitespace.
    #
    # This class should *ONLY* be used in negative character classes below.
    #FUXME: This suggests that these character classes may be profitable merged.
    #FUXME: By inspection of the classes embedding this class, can we add any
    #additional characters to this class?
    # local char_reserved=${char_space}'''"$&;\\<>|`'

    #FUXME: zsh actually permits "!" and "#" to be configured via string global
    #${histchars}. We'll need to replace our current hard-coding of "!" and "#"
    #with an expansion of such global here, taking care to prefix characters
    #requiring escaping in character classes with "\" (i.e., "^", "]", "-",
    #"\", ... any others?).

    #FUXME: This is also not necessarily a good idea. The only true
    #single-character command terminators are vertical whitespace and ";".
    #Everything else is more syntactically nuanced. We should *NEVER* use this
    #class except in a negative context to avoid matching command terminators.
    #Is that the case? Indeed, can we not eliminate this class entirely by
    #merging its contents wherever needed? Alternately, can we not rename this
    #class to reflect its confinement to negative character classes only?

#  signifying
    # "&", which in the case of "&&" signifies a shell-reserved operator while
    # "&>" is not
    # multi-character operators (e.g.,
    #
    # *NOT* suffice to match all possible command terminators.
    # For example, since "&&" is a two-character command terminator while "&>"
    # is not, this class excludes "&".
    # single-character command terminators (i.e.,
    # ASCII punctuation unconditionally terminating the preceding command).
    # This class does *NOT* suffice to match all possible command terminators.
    # For example, since "&&" is a two-character command terminator while "&>"
    # is not, this class excludes "&".

    # single-character command terminators (i.e.,
    # ASCII punctuation unconditionally terminating the preceding command).
    # This class does *NOT* suffice to match all possible command terminators.
    # For example, since "&&" is a two-character command terminator while "&>"
    # is not, this class excludes "&".

    # corresponding  are only  require double quotes-style .

    # local pcre_math_substitution_braces_optional='\[(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}'|[^\]])*+\]?+'
    # local pcre_var_expansion_optional='\{(?:[^}'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_embeddable}'|[^}])*+\}?+'
    # local pcre_process_substitution_backtick_optional='`(?:'${pcre_code_sans_backtick}'|[^`])*+`?'

    #FUXME: Matching ${pcre_spaces_horizontal_continuable_optional} here
    #strikes us as qu
    # local pcre_here_string_prefix='<'${pcre_spaces_horizontal_continuable_optional}

    # "{" block prefix. Technically, such prefix *MUST* be prefixed by either
    # horizontal or vertical whitespace when preceded by characters that are
    # *NOT* unspaced command terminators (e.g., "if { true } {"). Since shell
    # word-specific negative lookahead prevents such words from matching "{",
    # however, such technicalities are ignorable.
    # local pcre_command_end_block_prefix=${pcre_char_block_prefix}

    # ";" command terminator, terminating the prior command without
    # introducing additional semantics (e.g., piping, redirection).
    # local pcre_command_end_semicolon=';'

    #Since subroutines unwind captured groups, we (probably!) do *NOT* want to
    #call such subroutine 
    #
    #Now, you're probably ruminating: but isn

    #FUXME: We currently fail to match macros in process substitutions (and
    #possibly other syntactic constructs). There exists a difficulty here:
    #
    #* When matching macros, we want to search for command terminating
    #  positions and hence possible macros in both the top-level script code
    #  *AND* within all nested syntactic constructs.
    #* After matching a macro name and then when matching macro arguments (both
    #  block and standard), we do *NOT* want to attempt to match additional
    #  nested macros.
    #
    #This implies we need *TWO* variants for each such syntactic construct. We
    #need the current variant, ignoring macros, for use when matching macro
    #arguments; and we need a new variant -- perhaps suffixed by "_preprocessable"
    #(e.g., ${pcre_process_substitution_dollar_preprocessable}). That said, defining
    #the latter will prove exceedingly tricky. Do we perhaps want to embed
    #${pcre_macro} directly in ${pcre_process_substitution_dollar_preprocessable}
    #instead of ${pcre_codes_optional}?
    #
    #Oh, wait. This again raises the tricky subject of how we resume PCRE-based
    #iteration after handling a matched nested macro. For example, we
    #currently fail to match syntactic suffixes (e.g., "}", ")") unless
    #balanced. Actually, that's a bit of a concern. We need to match unbalanced
    #suffixes *ANYWAY*, but only as a fallback. Hmm.

    # iteration matching PCRE-based preprocessing effectively prohibits this.
    #resume PCRE-based iteration after handling a matched nested macro

    #FUXME: Hmm. In process substitutions, don't we also want ${pcre_code} to
    #match "{" block prefixes? Such characters appear to be unmatched, at the
    #moment! Investigate mildly deeper.

    #FUXME: A bit of a muntup, here. As the name suggests,
    #${pcre_chars_command_end_not_code_prefix} matches command terminators
    #-- which is exactly what we *DON'T* want ${pcre_codes} to match when
    #embedded in ${pcre_macro_command_optional}. Perhaps we want to fashion a
    #new PCRE ${pcre_codes_sans_command_end} to be embedded in
    #${pcre_macro_command_optional} instead?
    #FUXME: Actually, we want a new PCRE
    #${pcre_codes_sans_comment_or_command_end}. A bit wordy, but there you
    #are. This implies we'll also need to refactor
    #${pcre_macro_command_optional} in terms of comments -- or perhaps not?

    # Ideally, this PCRE would match comments. Since comments require prefixing
    # whitespace more efficiently matched together with similar prefixing
    # whitespace required by other syntactic constructs (e.g., block
    # arguments), however, comments are best matched explicitly by each PCRE
    # below embedding this PCRE.

    # one:
    #
    # * A list assignment.
    # * A shell word.
    # * A here-document or -string.
    # * One or more command terminators *NOT* prefixing (and hence conflicting
    #   with) syntactic constructs.
    #
    # Since list assignments are prefixed by variable names indistinguishable
    # from (and hence conflicting with) unquoted shell words, the former *MUST*
    # be matched before the latter.
    #
    # Since the "<" of the "<("- and ")"-delimited process substitution matched
    # in shell words conflicts with the "<" unconditionally matched in
    # here-documents or -string prefixes, the former *MUST* be matched first.
    #
    # Ideally, this PCRE would match comments. Since comments require prefixing
    # whitespace more efficiently matched together with similar prefixing
    # whitespace required by other syntactic constructs (e.g., block
    # arguments), however, comments are best matched explicitly by each PCRE
    # below embedding this PCRE.

    #FUXME: A bit of a muntup, here. As the name suggests,
    #${pcre_chars_command_end_not_code_prefix} matches command terminators
    #-- which is exactly what we *DON'T* want ${pcre_codes} to match when
    #embedded in ${pcre_macro_command_optional}. Perhaps we want to fashion a
    #new PCRE ${pcre_codes_sans_command_end} to be embedded in
    #${pcre_macro_command_optional} instead?

    # local pcre_code_sans_comment_prefix=${pcre_chars_command_end_not_code_prefix}'|'${pcre_list_assignment_optional}'|'
    # local pcre_code_sans_comment_suffix='|'${pcre_here_optional}

# delimiting (i.e., neither prefixing nor suffixing)

    #FUXME: For parsing purposes, this class should include ")" (but *NOT*
    #"("). That said, including ")" conflicts with the stated definition of
    #${char_command_end} below. (What's going on here?)

    # local pcre_process_parens_body='(?:'${pcre_code}'|[^)])*+'

    #FUXME: Incorrect. The current definition attempts to erroneously match
    #"=("-style process substitutions in double-quoted strings, which such
    #syntax does *NOT* support. We need to differentiate between such use cases
    #with a new subroutine definition -- say, "<code>" -- matching both
    #"(?&sub)" *AND* the three new process subroutines matched below. "<sub>"
    #should then be reverted to its prior definition below. Note that
    #"(?&code)" should only be called where actually code is permitted (e.g.,
    #process substitutions, block arguments, shell words).

    #FUXME: Is this correct? Double check, please.
    #FUXME: Nope! Since ${pcre_comment} already consumes suffixing
    #vertical whitespace, we'll need to refactor such PCRE... a tad.

    #FUXME: ${pcre_continuable_spaces_horizontal} is overkill here, as it
    #unnecessarily matches prefixing optional line continuations.
    #FUXME: Excise, shifting the suffixing ${pcre_spaces_continuable_optional}
    #back onto ${pcre_command_end_unspaced} and ${pcre_command_end_spaced}.
    #Assuming we adopt the refactoring below, this will no longer be used.

    # Command terminator (i.e., substring terminating the command preceding
    # such terminator), optionally suffixed by one or more whitespace
    # characters. Such terminators necessarily precede preprocessor macros and
    # hence *MUST* be matched with syntactic accuracy.
    # local pcre_command_ends='(?:'${pcre_command_end_unspaced}'|'${pcre_command_end_spaced}')'${pcre_spaces_continuable_optional}

    # Code atom, excluding "}" block suffixes.
    # local pcre_code_sans_block_suffix=${pcre_code_prefix}'|'${pcre_word_parenable}'|'${pcre_code_suffix}

    # Code atom *OR* block suffix "}". The latter is matched by omitting the
    # customary negative lookbehind from interpretable shell words preventing
    # such suffix from being matched as such a word.

#-- namely, only those
    # connoting no additional semantics (i.e., newline, ";"); all others are

    # Technically, only *SOME* such terminators are prefixable by both vertical
    # and horizontal whitespace characters in a syntactically valid manner
    # (e.g., the "{" block prefix); all others are prefixable only by either
    # vertical or horizontal whitespace characters but not both in a
    # syntactically valid manner (e.g., the ":and" and ":or" boolean
    # operators). Likewise, only a proper subset of command terminators are

#  already
    # match such characters. Do *NOT* do so here (e.g., by prefixing this PCRE
    # by ${pcre_spaces_continuable_optional})
    #FUXME: Insufficient. Such terminators may *ALSO* be preceded by vertical
    #whitespace characters. Since such characters are themselves command
    #terminators, however, a bit of subtlety will be required. Namely, after
    #matching any vertical whitespace character in
    #${pcre_command_end_unspaced}, we'll also need to optionally match
    #${pcre_command_end_spaced_body}.

    #FUXME: Actually use below in lieu of current start-of-line-based parsing
    #of macro prefixes.

    #FUXME: Not quite right. While zeshy-specific command terminators *DO*
    #require prefixing whitespace, "{" doesn't. "{" may appear anywhere
    #*OUTSIDE* of a shell word, regardless of surrounding whitespace.

    # Block prefix prefixed by one or more whitespace characters optionally
    # interspersed with line continuations.
    # local pcre_command_end_block_prefix=${pcre_char_block_prefix}

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations all optionally followed by a command terminator
    # requiring such whitespace, capturing such command terminator if any.

    #FUXME: Prefix ${pcre_command_end_spaced_grouped} by
    #${pcre_continuable_spaces_horizontal}, excising the latter below.
    # local pcre_command_end_spaced='(?:'${pcre_continuable_spaces_horizontal}'|'${pcre_string_start}')(?:'${pcre_command_end_block_prefix}'|'${pcre_command_end_zeshy}')'

    #FUXME: Embed a new ${pcre_command_end_spaced_grouped} below.
    # local pcre_codes_or_chars_not_command_end_optional='(?:'${pcre_code}'|'${pcre_chars_not_subword_unquoted_or_command_end}')*'
    # local pcre_codes_or_macros='(?:(?:'${pcre_macro}'|'${pcre_codes_or_chars_not_command_end_optional}')'${pcre_command_ends}')*'

    # Substitutable shell word signifying an argument passed to a macro,
    # comprising all syntactic constructs except redirections. Technically, zsh
    # permits redirections to be arbitrarily interspersed with arguments passed
    # to conventional builtins, commands, or functions: e.g.,
# and hence
    # comprising all syntactic constructs except redirections
# from match -specific lookbehind
    # preventing such words from matching the . Equivalently,
    # code atom *OR* such suffix
    #FUXME: Tangentially relatedly, does ${pcre_subword_unquoted} permit:
    #
    #* All characters to be "*", "!", "^", "?" and other shell-reserved
    #  punctuation of no consequence to preprocessor parsing?
    #* All characters *EXCEPT* the first to be "#"?
    #
    #It should probably permit all such cases. Double check, please.

    #FUXME: Since both ${pcre_command_end_unspaced} and
    #${pcre_command_end_spaced} match prefixing whitespace (albeit the former
    #optional and the latter mandatory), we can probably optimize such matching
    #by extracting out the optional portions from both into
    #${pcre_command_ends}: namely, the matching of optional prefixing line
    #continuations. Is that it? Well, something is something.

    #FUXME: Actually, forego that. Since shell words require prefixing
    #whitespace, we'll be combining ${pcre_command_end_spaced} with
    #${pcre_word_parenable} at some point to match any syntactic construct
    #necessarily prefixed by whitespace, implying that we'll probably be
    #removing ${pcre_command_ends} at some point as well. *shrug*

    #FUXME: Fairly certain we can also omit both
    #${pcre_command_end_block_prefix} and ${pcre_command_end_zeshy}, under the
    #condition that we attempt to match command terminators *BEFORE* matching
    #shell words. (Which we absolutely *SHOULD* do, as command terminators take
    #precedence.) Assuming this is the case, omit such PCREs below below and
    #comment on why above.

    #FUXME: ${pcre_codes_or_chars_not_command_end_optional} is probably *VERY*
    #close, but not quite cigar. Matching horizontal whitespace conflicts with
    #${pcre_command_ends} needing to match prefixing whitespace before certain
    #substrings (e.g., "{", ":or"). Contemplate.

    # local pcre_word_unquoted_char='[^'${char_not_subword_unquoted_with_parens_balanced}']'
    # local pcre_chars_subword_unquoted_sans_paren_right=${pcre_word_unquoted_char}'++'

    #FUXME: The command terminator(s) that terminate macros must *NOT* be
    #consumed by such macros -- or, if they are consumed, must be effectively
    #*NOT* consumed by adjusting the last byte of such macro in the
    #preprocessor.  Why? Because: if a macro is immediately followed by another
    #macro (perfectly valid, of course), the latter is only matchable by
    #matching the command terminator terminating the former, implying the
    #former must *NOT* consume such terminator. (In any case, negative
    #lookahead could always guarantee this.)
    #
    #Actually, the above is absurdly incorrect.

    #FUXME: Horribly wrong, really. How wrong, it's somewhat difficult to say.
    #But, really! ${pcre_code_or_chars_not_command_end} may not be the best
    #idea. 
    # local pcre_process_substitution_backtick='`(?:'${pcre_chars_not_code_prefix}'|'${pcre_comment_optional_spaced}'|'${pcre_char_escaped_optional}'|'${pcre_here}'|(?!`)(?:'${pcre_substitutable_or_quotes}'|.))*`'
    #FUXME: Define ${chars_not_command_end}.
    # Code atom *OR* one or more characters excluding syntactic prefixes.
    # local pcre_code_or_chars_not_command_end='(?:'${pcre_code}'|'${chars_not_command_end}')'

    #FUXME: We want to preferentially match shell words as macro names rather
    #than as mere shell words. To effect this, we use non-greedy quantifier "*?"
    #below.  Does this actually have the intended effect, however? We could,
    #alternatively, add negative lookahead to ${pcre_word_parenable}
    #preventing such PCRE from matching macro names. Hmm. There must be a
    #better way. Contemplate.
    #
    #O.K.; how about this:
    #
    #
    #This leverages ${pcre_codes_or_chars_not_command_end_optional} defined
    #below, while replacing ${pcre_code_nonmacro} (which may now be excised).
    # local pcre_code_nonmacro='(?:'${pcre_codes_or_chars_not_command_end_optional}${pcre_command_ends}')*?'${pcre_spaces_continuable_optional}

    #* ${pcre_code_or_chars_not_command_end} doesn't exist. It probably should.
    #  Such PCRE should clearly 

    #* ${pcre_words_interpretable_optional} should be replaced below by a new PCRE
    #  ${pcre_codes_or_chars_not_command_end_optional}. Such PCRE sh ${pcre_word_parenable}

    #FUXME: Actually use below in lieu of current start-of-line-based parsing
    #of macro prefixes.
    #FUXME: O.K.; so, *ALL* command terminators may be suffixed by newline
    #and optional horizontal whitespace. Some, however, may also be optionally
    #suffixed by one or more semicolons -- including semicolon and vertical
    #whitespace terminators.

    #FUXME: Excise, appending the suffixing
    #${pcre_spaces_continuable_optional} directly onto... what? Well, we
    #suppose we need... Hmm. Right. Probably directly onto
    #${pcre_command_end_spaced} and ${pcre_command_end_unspaced} for now, we
    #should think.

    # One or more command terminators. Technically, only a proper subset of
    # command terminators are repeatable -- namely, only those connoting no
    # additional semantics (i.e., newline, ";"). All others are *NOT*
    # repeatable (e.g., "|| ||"). Nonetheless, preprocessor parsing is largely
    # unconcerned with the syntactic validity of non-macros. Hence, ignoring
    # such technicalities here is appropriate.
    # local pcre_commands_end_optional='(?:'${pcre_command_ends}')*'${pcre_spaces_continuable_optional}

#  Nonetheless, preprocessor parsing is largely
    # unconcerned with the syntactic validity of non-macros. Hence, ignoring
    # such technicalities here is appropriate.

    #FUXME: While matching suffixing whitespace *IS* great, it also conflicts
    #with matching prefixing whitespace. We need to rethink this. We should
    #probably shift ${pcre_spaces_continuable_optional} into
    #${pcre_commands_end_optional} instead, where we can ensure that such
    #whitespace is consumed only after all command terminators have been
    #matched.

    #FUXME: Optimize. Substrings prefixed or suffixed by mandatory whitespace
    #should be grouped together.

    #FUXME: Actually use ${char_not_substitutable_prefix} and
    #${char_not_interpretable_prefix}. Perhaps we no longer require either? In
    #which case, we probably know what to do.
    # local char_not_substitutable_prefix=${char_substitutable_prefix}'\\'
    # local char_not_interpretable_prefix=${char_interpretable_prefix}'\\'

    #FUXME: This should go away, once we refactor backticks.
    #FUXME: Refactor in favor of the ${pcre_process_parens_body}
    #approach, at which point we can excise a number of PCREs above (e.g.,
    #${pcre_chars_not_code_prefix}, ${pcre_substitutable_or_quotes}).
    #FUXME: O.K.; to implement this sanely, we really need to concoct a new
    #PCRE local ${pcre_word_sans_backticks} above. While doing so is trivially
    #simple (i.e., by prefixing "(?&sub)" by "(?!`)"), properly incorporating
    #such PCRE here will require concocting a chain of PCREs equivalent to the
    #current ${pcre_code} -- namely, a new PCRE local
    #${pcre_code_sans_backticks}. This is annoyingly unavoidable, we're afraid.

    #FUXME: Actually use.
    #FUXME: Replace ${pcre_chars_command_end_not_code_prefix} with something
    #suitable.
    #FUXME: Excise. We no longer appear to use this anywhere.
    # Command terminator (i.e., character unconditionally terminating the
    # preceding command).
    # local pcre_char_command_end='['${char_command_end}']'

    #FUXME: This should go away, once we refactor backticks.
    #FUXME: Now that we have ${pcre_word_parenable}, this PCRE should
    #probably simply be embedded directly into that PCRE. Examine wherever we
    #currently use ${pcre_word_parenable} to ensure the sanity of this.

    #FUXME: Most uses of this PCRE should probably instead be embedding
    #${pcre_word_parenable}.

    # ..................{ COMMON                             }..................
    #FUXME: Rename to ${ZESHY_VAR_NAME_PCRE}, shift to ={pcre.zy}, and replace
    #all current usage of ${ZESHY_VAR_NAME_GLOB} with ${ZESHY_VAR_NAME_PCRE}.

    # Variable name. See ${ZESHY_VAR_NAME_GLOB}.
    # local pcre_var_name='[a-zA-Z_][a-zA-Z0-9_]*+'

    #FUXME: This is actually broken, now.
    # # Zero or more whitespace characters *OR* line continuations.
    # local pcre_spaces_continuable_optional='(?:(?:'${pcre_spaces}${pcre_line_continuations_optional}')+|'${pcre_line_continuations_spaceable}')'
    #
    # # Zero or more horizontal whitespace characters *OR* line continuations.
    # local pcre_spaces_horizontal_continuable_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    # local pcre_spaces_horizontal_continuable_optional='(?:(?:'${pcre_spaces_horizontal}${pcre_line_continuations_optional}')+|'${pcre_line_continuations_spaceable}')'

    #FUXME: Are either of the following two PCREs frequently used enough to
    #warrant re-optimization? The answer is almost certainly yes, in which case
    #we may want to resurrect the "_by_spaces" and such PCREs.
    # local pcre_spaces_continuable_optional='(?:'${pcre_spaces}'|'${pcre_line_continuation}')*'

    # local pcre_spaces_continuable_optional='(?:'${pcre_spaces}'|'${pcre_line_continuation}')*'

    #FUXME: Actually, is distinguishing between horizontal and vertical
    #whitespace actually helpful here? We suspect not. ":or" always expands to
    #"||" and hence precedes macro expansions, whether such ":or" is
    #syntactically valid or not.

    # Command terminator prefixed by one or more horizontal whitespace
    # characters.
    # local pcre_command_end_spaced_horizontal=${pcre_continuable_spaces_horizontal}'(?:'${pcre_command_end_block_prefix}'|'${pcre_command_end_zeshy}')'

    # Command terminator prefixed by one or more vertical whitespace
    # characters.
    # local pcre_command_end_spaced_vertical=${pcre_continuable_spaces_horizontal}'(?:'${pcre_command_end_block_prefix}')'

    # Block suffix suffixed by one or more whitespace characters optionally
    # interspersed with line continuations. Since suffixing whitespace must
    # *NOT* be consumed, such whitespace is detected via positive lookahead.
    # local pcre_command_end_block_suffix=${pcre_char_block_suffix}'(?='${pcre_line_end_or_space_continuable}')'

    #FUXME: Technically, such syntax conflicts with the same syntax embedded in
    #":is"- and "[["-prefixed tests, implying we'll need to begin matching
    #such tests for disambiguation. Wait! Wait; no! All we have to do is
    #prohibit ${pcre_word_*} from matching such text with negative lookahead...
    #which we should already do, correct? We should make a note where we do so
    #that, since zsh expands global aliases literally globally and hence in
    #":is"- and "[["-prefixed tests, preventing unquoted shell words from
    #containing such aliases suffices (i.e., we needn't actually match ":is"-
    #or "[["-prefixed test syntax).
    #FUXME: Oh, right. We *DEFINITELY* need to match such tests to avoid
    #accidentally matching macro-like unquoted substrings in such tests. (That
    #and the fact that "(("- and "))"-delimited arithmetic tests may contain
    #the left bit shift operator "<<" conflicting with here syntax.)

    #FUXME: Erroneous. PCREs must *NOT* consume suffixing whitespace. Moreover,
    #string end is also an acceptable suffix in this case. We should note that
    #we had an *AWESOME* lookahead solution to this aready. Where'd that go?
    # local pcre_command_end_block_suffix=${pcre_char_block_suffix}${pcre_continuable_spaces}

    #FUXME: This sufficient? Check man pages.
    #FUXME: "&<" or "&>" must both be followed by particular syntax. Match it.
    #FUXME: *WAIT*. Clearly, redirections do *NOT* terminate commands. Indeed,
    #redirections may be freely mixed with standard arguments. Given this,
    #we're inclined to concoct a new PCRE ${pcre_word_parenable} matching
    #*EITHER* a word or redirection. As for backgrounding, well... let's just
    #ignore such syntax for the moment. Probably ignorable? *shrug*
    #FUXME: Wait. Interestingly, backgroundings *DO* terminate the prior
    #command. Long story short, concoct a new PCRE ${pcre_word_parenable}.
    #Ideally, such PCRE would reduce to the current shell word-specific
    #character class but omitting "&". That'd be simple, right? Sure, but it'd
    #also overzealously match "&!" and "&&" and hence be wrong. So, such PCRE
    #*WILL* need to match redirects in a reasonably intelligent fashion. We
    #already match digit-prefixed redirects (...sort of, anyway). Hmm.
    #
    #We don't really care *AT ALL* about matching redirects in a syntactically
    #correct fashion; we merely need to match them in a manner disambiguous
    #from command terminators. Hence, an efficient first implementation might
    #resemble the following:
    #
    #    local pcre_redirect='&[^!&'${char_command_end}']'
    #
    #Excrutiatingly simple, no?
    #
    #The most efficient way to implement ${pcre_word_parenable} would then be
    #by defining a new PCRE ${pcre_subwords_interpretable} as follows:
    #
    #    local pcre_subwords_interpretable='(?:'${pcre_subword_sans_parens}'|'${pcre_subword_parens}'|'${pcre_redirect})+'
    #
    #Then simply define ${pcre_word_parenable} as we define ${pcre_word_passable_with_parens_balanced}.
    #FUXME: Note that the lookahead for ${pcre_word_passable_with_parens_balanced} prohibits
    #redirects from matching. While that *IS* beneficial for preventing macros
    #from being passed redirects interspersed with arguments, that's not
    #terribly beneficial for general-purpose parsing.
    #${pcre_word_parenable} should clearly omit such lookahead.

    #FUXME: Consider renaming to
    #${pcre_words_interpretable_or_comments_spaced_optional} instead and
    #embedding ${pcre_words_interpretable} here instead.

    #FUXME: Incorrect. Must use interpretables rather than substitutables.
    #FUXME: Actually, "<("- and ">)"-prefixed process substitutions are
    #redirections and hence *MUST* be embedded in ${pcre_word_parenable}
    #rather than ${pcre_word_passable_with_parens_balanced}. "=("-prefixed process substitutions are *NOT*
    #redirections and hence applicable here.

    # "=("-, "<("-, *OR* ">("- and ")"-delimited possibly recursively nested
    # process substitution.
    # local pcre_process_substitution_file='[=<>]\('${pcre_process_parens_body}'\)'

    #FUXME: Actually define subroutine call <int> below.
    #FUXME: Also implement:
    #"[["- and "]]"-delimited non-recursive standard test.
    #":is"- and ":si"-delimited non-recursive standard test.

    #FUXME: Why the discrepancy between ${char_not_embeddable_prefix} and
    #${pcre_embeddable}? If this is indeed in error, correct elsewhere as well.
    #FUXME: Define all PCREs interpolated into such PCRE.
    #FUXME: Shouldn't this be ${pcre_word_parenable} here?
    #FUXME: Reasonably certain this serves little to no actual purpose. Excise.

    # Redirection prefixed by a file descriptor specified as an integer (e.g.,
    # "1>&2"). Such redirections conflict with unquoted shell word syntax and
    # hence *MUST* be matched for disambiguation. Note that redirections
    # prefixed by file descriptors specified as "{"- and "}"- delimited
    # variable names are prefixed by "{" and hence already prevented from
    # matching unquoted shell word syntax. See section "REDIRECTION" of
    # "man zshexpn".
    # local pcre_redirect_numbered_prefix='[0-9]++&?[<>]'

    #FUXME: Erroneous. Insufficient. Correct to comply with the above syntax.
    # Redirection prefixed by a file descriptor specified as a non-negative
    # integer (e.g., "1>&2").
    # local pcre_redirect_punctuation='<[&>]?|>>?&?[!|]?|&>>?[!|]?'

    #FUXME: Actually use.
# signifying arguments
    # passed to macros
    #FUXME: This sufficient? Check man pages.
    #FUXME: Shift above and actually use below.
    # local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}'(?&var)'${pcre_quotes_double_suffix}
    # Recursively substitutable *OR* quotes syntactic construct.
    # local pcre_interpretable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_substitutable}

    # Character class matching substitutable-reserved characters, including all
    # embeddable-reserved characters as well as:
    #
    # * The "=", "<", and ">" prefixing "=("-, "<("-, and ">("-prefixed
    #   recursive process substitutions respectively.
    #FUXME: Erroneous. "<("-, and ">("-prefixed process substitutions are
    #redirections and hence *MUST* be excluded. Perhaps we want a new local
    #${char_interpretable_prefix} comprising *ALL* possible syntactic
    #constructs? That seems reasonably sensible, but contemplate.

    #FUXME: Given that we define ${char_not_embeddable_prefix}, shouldn't we also define ${char_not_embeddable_prefix}?

#(or ${char_syntactic_prefix} -- right,
    #probably the latter) 
    # Here-document or -string prefix "<<" optionally followed by such document
    # in the former case. The here-string prefix greedily overlaps the
    # here-document prefix and hence *MUST* be matched first. To ensure that
    # syntactically invalid syntactic constructs are matched, optionally rather
    # than mandatorily match the here-document argument.
    # local pcre_here=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|(?&here))?'

    #FUXME: Honestly, is any of this optional prefix matching approach
    #essential or even beneficial? Given the increase in complexity (and
    #probably subtle issues) and decrease in intelligibility, we question
    #whether there exists any demonstrable reason to continue doing this.

    #FUXME: Syntactically invalid here-documents should also be matched. Rename
    #${pcre_here} to ${pcre_here} and render all syntax following such
    #prefixing "<<" delimiter to be optional.

    #FUXME: Actually, let's just revert to the prior form. This form fails to
    #match syntactically invalid here-strings (e.g., "<<<&"), which we'd rather
    #match for generality. The prior form is also simpler, which is nice.

    # Here-string.
    # local pcre_here_string='<'${pcre_spaces_horizontal_continuable_optional}${pcre_word_passable_with_parens_balanced}

    #FUXME: Actually, suffixing whitespace must be matched with positive
    #lookahead, instead.

    #FUXME: Inappropriate. *SOME* command terminators may be indefinitely
    #repeated -- perhaps, only those lacking additional semantics (e.g.,
    #vertical whitespace, semicolon)? Others, however, may *NOT* be (e.g.,
    #"||", "&!"). Though, to be fair, do we particularly care

    #FUXME: Actually, suffixing whitespace must be matched with positive
    #lookahead, instead.
    # Since numerous syntactic
    # constructs are matched by consuming prefixing whitespace, avoid consuming
    # such whitespace here with positive lookaheads.

    #FUXME: "[<>]++" is overly simplistic. We need to exclude here-documents.
    # local pcre_redirect_punctuation='&?[<>]++&?[!|]?'

    #FUXME: Insufficient. Since unquoted words prohibit "<" and ">", we also
    #need to match such characters *AND* all other shell-reserved
    #redirection-related characters (e.g., a suffixing optional "!").

    #FUXME: Matching merely ${pcre_char_command_end} does *NOT* suffice here.
    #We need to match ${pcre_command_ends}, in which case
    #${pcre_char_command_end} is probably unused and hence excisable.

    #FUXME: This sufficient? Check man pages.
    # Redirection.
    # local pcre_redirect='(?:'${pcre_redirect_numbered}')'
    # One or more redirections.
    # local pcre_redirects='('${pcre_redirect}')+'

    #FUXME: Correct me, please.

    # Redirection prefixed by a file descriptor specified as a non-negative
    # integer (e.g., "1>&2").
    # local pcre_redirect_numbered_prefix='[0-9]++&?[<>]'
    # local pcre_redirect_numbered=${pcre_redirect_numbered_prefix}

    # be disambiguated from command terminators "&" (optionally followed by any
    # single-character command terminator), "&!", and "&&". All other unquoted
    # instances of "&" necessarily 
    #FUXME: Actually, this is not the case. This matches "&z", which clearly is
    #*NOT* a redirection. Optimize.
    # local pcre_redirect_ampersand='&[^!&'${char_command_end}']?'

#  a non-negative integer optionally followed by "&"
    # mandatorily followed by either "<" or ">" and a shell word redirects and
    # hence terminates the preceding command (e.g., "1&>2").
    #
    # Of course, the prior paragraph is a lie: redirections may be freely
    # interspersed with typical command arguments. However, since supporting such
    # uncommon edge cases in the preprocessor would probably prove to be non-
    # trivially expensive, redirections must strictly suffix rather than be
    # freely interspersed with macro arguments.
    #FUXME: Actually, "&" only *CONDITIONALLY* indicates a command terminator.
    #For example, the "&" in "grep &;" is a command terminator, while the "&"
    #in "print ok &>/dev/null" is not. Hence, "&" *MUST* be omitted here.

    #FUXME: This class includes ";" but excludes "\R", which strikes us as
    #quite irrational. If one is included, surely the other must be as well?
    #Certainly, both signify the exact same semantics.

    # local pcre_macro_sans_args_unspaced_lookahead=${pcre_line_end}'|'${pcre_char_command_end}
    # local pcre_macro_sans_args_unspaced='(?='${pcre_macro_sans_args_unspaced_lookahead}'|'${pcre_string_end}')'

    # Zero or much such constructs.
    # local pcre_subword_sans_parens_optional='(?:'${pcre_subword_sans_parens}')*'

    #FUXME: O.K.; so, we can clearly have zero or more redirections followed by
    #a pipe (e.g., "1>&2 2>&1 |&"), implying we have quite a bit of legwork to
    #run through here.

    # Character class matching ASCII punctuation characters that unconditionally
    # terminate the preceding command in a manner signifying additional
    # semantics (e.g., "|" signifying standard output from the prior command to
    # be piped to standard input of the subsequent command). While most
    # command-terminating characters signify additional semantics, some do not
    # (e.g., newline, ":").

    #FUXME: ${pcre_command_end_boolean_or} overlaps ${pcre_pipe}. Aggregate the
    #two, noting the former *MUST* be matched prior to the latter. Consider
    #something like the following:
    #
    #local pcre_pipe_or_boolean_or='\|[|&]?'

    #FUXME: This no longer strikes us as sufficient. A here-string prefix
    #*MUST* be suffixed by a shell word. For both correctness and efficiency,
    #replace all current uses of this PCRE with ${pcre_here_string}; then,
    #excise this PCRE entirely.

    # Here-document or here-string prefix. Since the latter overlaps the
    # here-document prefix, the former *MUST* be matched first.
    # local pcre_here_doc_or_string_prefix_optional=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|(&here))?'

    # Here-string prefix. Since here-strings are syntactically identical to
    # standard arguments (i.e., as one or more shell words) *AND* since
    # subsequent parsing presumably matches such arguments, such prefix is
    # ignorable for most preprocessing purposes. For simplicity, avoid matching
    # the here-string here. Subsequent parsing does so for us.
    # local pcre_here_string_prefix='<'${pcre_spaces_horizontal_continuable_optional}

    #FUXME: This efficiency model should be adopted everywhere we match a
    #syntactic prefix (e.g., "<(", ">)", "=(").
    # local pcre_here=${pcre_here_prefix}'(?:'${pcre_here_string}'|(?&here))'

    #FUXME: We're almost certainly using this is numerous places where we
    #should be using ${pcre_continuable_spaces_horizontal} instead. Examine.
    #FUXME: Honestly. this is a significantly more precise and hence preferable
    #name than ${pcre_continuable_spaces_horizontal}. Assuming this PCRE is used only in this
    #subsection, rename this PCRE something else and rename ${pcre_continuable_spaces_horizontal}
    #to ${pcre_continuable_spaces_horizontal}.
    # One or more horizontal whitespace characters preceded by zero or more
    # line continuations.
    # local pcre_continuable_spaces_horizontal=

    #FUXME: Excise ${pcre_continuable_spaces_horizontal*} PCREs from PCREs below in a similar
    #manner to that accomplished here (which, presumably, works). 

    #FUXME: Err, there *IS* no ${pcre_spaces_horizontal_continuable_optional},
    #at the moment. Do we have something comparable?

    #FUXME: Insufficient. The existing
    #${pcre_line_continuations_spaceable_optional} should be renamed to
    #${pcre_line_continuations_spaceable_horizontal_optional}. Then a new PCRE
    #${pcre_line_continuations_spaceable_optional} should be defined in the
    #expected way and used here.

#  While the here-string prefix "<<<" is ignorable for most
    # preprocessing purposes, here-strings suffixing macros *MUST* be matched
    # in full. Why? Because such here-strings *MUST* be passed on standard
    # input to such macros at expansion time.
    #explicitly match such word and rename this PCRE accordingly. See
    #${pcre_here_string} below.

    #FUXME: Wait. Do we *REALLY* require this? Even here-documents and -strings
    #passed to macros should (arguably) be interpreted and passed to the
    #resulting expansion rather than to the function producing such expansion.
    #Why? Because such here-document or -string could contain process
    #substitutions intended to be evaluated at macro expansion execution time
    #rather than the substantially earlier macro expansion time. Indeed, the
    #current behaviour contravenes basic sensibility.
    #
    #Let's unwind this nonsense, please. Excise *ALL* of the following PCREs
    #and their expansions below.
    # local pcre_here='(?:'${pcre_here}')?'

    #FUXME: Actually, from our perspective, there's not terribly much
    #difference between matching adjacent backticks in an nested recursive
    #manner (as we would by default) or in a non-nested consecutive manner (an
    #we currently attempt to do). Given that, let's defer to the dramatically
    #simpler solution of matching adjacent backticks in a nested recursive
    #manner by refactoring this to exactly resemble the above process
    #substitution syntax.
    #FUXME: Fold ${pcre_list_assignment_optional} directly into
    #${pcre_code_sans_comment}.
    #This is fairly important, as such syntax prohibits syntax otherwise
    #permitted in the parent syntactic construct (e.g., "<("- and ")"-delimited
    #process substitutions).

#  For convenience, prefer this PCRE to
    # ${pcre_word_passable_with_parens_balanced} when matching code constructs.
    #FUXME: Rename to simply ${pcre_code}. Interesting how matters come full
    #circle, isn't it?

    #FUXME: Abstract "'(?:'${pcre_comment}')?" into a new PCRE above.
# ${pcre_chars_not_code_prefix}'|'${pcre_char_escaped_optional}'|'

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing. Since unquoted shell words do *NOT* obstruct such
    # preprocessing, ignore such words. Ideally, such PCRE would match
    # comments. As comments require prefixing whitespace more efficiently
    # matched together with similar prefixing whitespace required by other
    # syntactic constructs (e.g., block arguments), however, comments are best
    # matched explicitly by each PCRE below embedding this PCRE.
    #FUXME: This should be excisable, now. *SHOULD* be.
    # local pcre_code=${pcre_substitutable_or_quotes}'|'${pcre_here_doc_or_string_prefix}

    #FUXME: Replace current use of ${pcre_embeddable*} in code contexts below
    #with ${pcre_substitutable_or_quotes}.

    # Recursively embeddable syntactic construct *OR* single- or double-quoted
    # string.
    #FUXME: Hm; shouldn't this be ${pcre_substitutable_or_quotes} everywhere?
    # local pcre_embeddable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}

    # local pcre_code=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here_doc_or_string_prefix}'|'${pcre_embeddable}

    # ..................{ FUNCTION                           }..................
    #FUXME: Shift here from ={*-start/*-declare/*-pcre}.
    #FUXME: Actually, this parcel is more than long enough already. We should
    #probably define a new subdirectory tree structure here as follows:
    #
    #    preprocess/
    #        pcre/
    #            macro.zy  # This existing file.
    #            func.zy   # Moved from ={*-soil/*-declare/*-pcre}.
    #
    # We shouldn't need a ={preprocess/pcre/pcre.zy}, but... one never knows.

    # Boolean zsh command terminators.
    # local pcre_boolean_or='\|\|'
    # local pcre_boolean_and='&&'
    # local pcre_boolean=${pcre_command_end_boolean_or}'|'${pcre_command_end_boolean_and}

    #FUXME: Insufficient. May be suffixed by *EITHER* one or more word spaces and/or newlines.

    #FUXME: Shift block delimiters here. Rename ${pcre_char_block_prefix} to
    #${pcre_char_block_prefix}. Define a new ${pcre_char_block_prefix} embedding
    #${pcre_char_block_prefix} prefixed by ${pcre_spaces_word_or_vertical}.

    # Block prefix and suffix. As ${char_not_subword_unquoted_with_parens_balanced} documents, both
    # conflict with unquoted shell word syntax (which permits such prefix when
    # *NOT* the first character and such suffix when *NOT* the last character
    # of such word) and hence require disambiguation.
    # local pcre_char_block_prefix='\{'
    # local pcre_char_block_suffix='\}'

    # One or more command-specific whitespace sequences (i.e., zero or more
    # non-negligible horizontal whitespace characters or negligible line
    # continuations), prefixed by at least one horizontal whitespace character.
    # While escaped newlines are line continuations preserving the current
    # command and hence effectively whitespace, unprefixed newlines are
    # effectively semicolons terminating such command and hence non-whitespace.
    # local pcre_word_spaces_prefixed_by_spaces_horizontal=${pcre_spaces_horizontal}'(?:'${pcre_line_continuation_spaceable_horizontal}')*'

    # One or more command-specific whitespace sequences. Since line
    # continuations are merely ignorable rather than actual whitespace, such
    # sequences *MUST* include at least one horizontal whitespace character.
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}${pcre_word_spaces_prefixed_by_spaces_horizontal}

    # One or more command-specific whitespace sequences, prefixed by at least
    # one line continuation.
    # local pcre_word_spaces_prefixed_by_line_continuations=${pcre_line_continuations}'(?:'${pcre_continuable_spaces_horizontal}')*'

    # Zero or more command-specific whitespace sequences. Technically, this
    # PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.

    #FUXME: It's not necessarily clear that this is required anywhere outside
    #of here-documents. (Indeed, even here-strings shouldn't require this,
    #since words already match escaped characters and hence line continuations.)
    #In all other cases, ${pcre_spaces_optional} should suffice. Ideally, we
    #should find a way of obsoleting this even in here-documents and then
    #excise this. That, in turn, would permit us to excise
    #${pcre_line_continuation}, which is almost certainly a good thing.
    #FUXME: We should probably refactor this back to its prior version. We use
    #such PCRE sufficiently infrequently (i.e., only in here-documents) that
    #the current approach is extreme overkill. As documented above, this is:
    #
    #     local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    #
    #Before we do so, however, we should confirm whether we still need
    #${pcre_continuable_spaces_horizontal} anywhere, which would impact our decision.
    #FUXME: Incidentally, this PCRE has little to nothing to do with shell
    #word-specific whitespace. Rather, it's simply excisable now.
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    #FUXME: Insufficient. Must be preceded by one or more horizontal whitespace
    #characters and (of course) ignorable line continuations.

    #FUXME: Shift above, probably to where we define ${pcre_command_end_zeshy}
    #and such (which should clearly be shifted here).

    #FUXME: Arguably shift
    #"'(?:'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'" to a new PCRE
    #${pcre_words_spaced_optional}.
    # Since block
    # arguments are necessarily prefixed by such whitespace, this PCRE is
    # principally intended to match all standard arguments prefixing a block
    # argument passed to a macro.

    #FUXME: This could be optimized by preventing ${pcre_word_passable_with_parens_balanced} from matching
    #line continuations. In such case, the order of the two alternative choices
    #could be switched, which would be quite desirable. Ignoring that, however,
    #this appears to be feature complete.
    #FUXME: We probably need to ensure everywhere we use ${pcre_word_passable_with_parens_balanced} that
    #we also explicitly match ${pcre_line_continuation_spaceable_horizontal}. Given that,
    #perhaps the latter should be incorporated into the former?
    # local pcre_macro_args_zsh_optional=${pcre_continuable_spaces_horizontal}'(?:'${pcre_line_continuation_spaceable_horizontal}'|'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'

    #FUXME: Eliminate the "_arg" from all PCRE names below.
#this PCRE is guaranteed
    # to *NOT* be preceded by horizontal whitespace *AND* since 
    # If one or more such arguments
    # were passed, such arguments must be preceded by at least one horizontal
    # whitespace character; else, no such arguments were passed, in which case 
    # such macro must either be:
    #
    # * Suffixed by one or more horizontal whitespace characters followed by a
    #   command terminator. Since command terminators are *NOT* valid macro
    #   arguments, ${pcre_macro_args_optional} implicitly halts matching
    #   immediately prior to such terminator.
    # * Suffixed directly by a command terminator. Since
    #   ${pcre_macro_args_optional} only matches when preceded by one or more
    #   horizontal whitespace characters, this case must be explicitly matched.

    #FUXME: No longer quite right. We *REALLY* don't want this to be optional,
    #as the resulting semantics are... wierd, and probably wrong. Instead, we
    #probably need to explicitly match a command terminator here.

    # Zero or more standard or block arguments. If one or more such arguments
    # were passed, such arguments must be preceded by at least one horizontal
    # whitespace character; else, no such arguments were passed, in which case 
    # such macro must either be:
    #
    # * Suffixed by one or more horizontal whitespace characters followed by a
    #   command terminator. Since command terminators are *NOT* valid macro
    #   arguments, ${pcre_macro_args_optional} implicitly halts matching
    #   immediately prior to such terminator.
    # * Suffixed directly by a command terminator. Since
    #   ${pcre_macro_args_optional} only matches when preceded by one or more
    #   horizontal whitespace characters, this case must be explicitly matched.

    #FUXME: No longer quite right. We *REALLY* don't want this to be optional,
    #as the resulting semantics are... wierd, and probably wrong. Instead, we
    #probably need to explicitly match a command terminator here.

    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_spaces_horizontal}${pcre_macro_arg}')*)?'
    # local pcre_macro_body_optional=${pcre_line_continuations_optional}'(?:'${pcre_spaces_horizontal}${pcre_macro_args_optional}'|'${pcre_macro_sans_args}')'

    # Zero or more standard or block arguments, each prefixed by one or more
    # horizontal whitespace characters, optionally followed by a here-document
    # or -string. To ensure that such macro is passed no unmatched
    # syntactically invalid arguments and hence is syntactically valid, such
    # match is anchored to the end of the current line.

    # rather than silently terminating such iteration.
    # Zero or more standard or block arguments optionally followed by a here-
    # document or -string, the end of the current line, *OR* the nonempty
    # remainder of the current line. The latter substring if any is captured,
    # ensuring that syntactically invalid macros are uniquely identifiable by
    # testing whether or not the corresponding match group exists (e.g., by
    # testing the length of canonical list global ${matches}).

#'|'${pcre_macro_args_invalid}'
    # local pcre_chars_sans_space_vertical_grouped='('${pcre_chars_sans_space_vertical}')'
    #FUXME: Erronious. We probably no longer require
    #${pcre_chars_sans_space_vertical_grouped}; instead, refactor this to use
    #${pcre_chars_sans_space_vertical}. Arguably, shift the latter PCRE
    #fragment below to a new PCRE ${pcre_line_optional} above.
    #FUXME: We'll probably also need to define
    #${pcre_chars_sans_space_vertical_optional} above.

    # local pcre_macro_arg_invalid_body_grouped=${pcre_chars_sans_space_vertical_grouped}'{1,3}'
    #FUXME: Document me.

    #FUXME: For error reporting purposes, it would probably be *FAR* more
    #helpful to shift ${pcre_macro_args_invalid} into ${pcre_macro_arg} rather
    #than interpolated below, renaming such PCRE to ${pcre_macro_arg_invalid}:
    #e.g.,
    #
    #    local pcre_macro_arg='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'|'${pcre_macro_arg_invalid}')'
    #
    #For that to work, however, we'll need to append ${pcre_macro_arg_invalid}
    #by ${pcre_report_failure}. Will that suffice to terminate the entire
    #current match, however? Wait. No, we don't want to report failure, as that
    #would unconditionally terminate the current iteration -- at least, as
    #currently implemented. Perhaps append ${pcre_report_success} instead?
    #Since further research is clearly required here, implement such
    #refactoring after we have a tolerable, working first draft.
    #FUXME: Right. Appending ${pcre_report_success} will *DEFINITELY* work, as
    #the PCRE below demonstrates. Let's do this now, yes?

    #FUXME: Ugh! How do we distinguish between a syntactically invalid macro
    #and an argumentless macro suffixed by a command terminator? Argumentative
    #macros suffixed by command terminators are no issue, as in that case at
    #least one argument character will be matched and hence such match group
    #will be nonempty. The only issue is with argumentless macros, as ever. For
    #example:
    #
    #    # Syntactically invalid macro.
    #    :macro uh(oh
    #
    #    # Macro suffixed by a command terminator.
    #    :macro :or true
    #
    #In the former case, ${pcre_chars_sans_space_vertical_grouped} will
    #appropriately be triggered; in the latter case, the same PCRE will be
    #inappropriately triggered. One way of handling this would be to define a
    #PCRE used below in lieu of ${pcre_chars_sans_space_vertical_grouped}:
    #
    #    local pcre_macro_args_invalid='(?!'${pcre_macro_sans_args_lookahead}'|'${pcre_command_end_zeshy}')'${pcre_chars_sans_space_vertical_grouped}
    #
    #We'll need to define ${pcre_command_end_zeshy}, of course. (Didn't we
    #already define a PCRE matching zeshy-specific command terminators?)

# ${pcre_spaces_horizontal_optional}

    #FUXME: Consider replacing ${pcre_continuable_spaces_horizontal} by
    #${pcre_continuable_spaces_horizontal}. (Should work; consider further to
    #ensure success, however.)
    #FUXME: Hmm. Right. O.K.; so, we need to extract
    #${pcre_line_continuations_optional} out as follows.

    # local pcre_macro_sans_args_end=${pcre_spaces_horizontal_optional}'(?:'${pcre_line_end}'|(?='${pcre_char_command_end}'))'

    #FUXME: We increasingly regard the dichotomy between ${pcre_continuable_spaces_horizontal}
    #and ${pcre_spaces_horizontal} as bath false and harmful. Ideally, we
    #shouldn't *NEED* to explicitly match line continuations and hence match
    #${pcre_continuable_spaces_horizontal} at *ALL*. If one considers it, ${pcre_word_unquoted}
    #and hence ${pcre_word_passable_with_parens_balanced} and hence ${pcre_macro_arg} already implicitly
    #matches line continuations.
    #FUXME: No, we can't simply replace ${pcre_continuable_spaces_horizontal} by
    #${pcre_spaces_horizontal} -- at least, not as currently defined. Why?
    #Because doing so would fail to match ":macro a \
    #b". Wait; no, that would still be successfully matched. Right, then!

    #FUXME: We increasingly regard the dichotomy between ${pcre_continuable_spaces_horizontal}
    #and ${pcre_spaces_horizontal} as bath false and harmful. Ideally, we
    #shouldn't *NEED* to explicitly match line continuations and hence match
    #${pcre_continuable_spaces_horizontal} at *ALL*. If one considers it, ${pcre_word_unquoted}
    #and hence ${pcre_word_passable_with_parens_balanced} and hence ${pcre_macro_arg} already implicitly
    #matches line continuations.
    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_continuable_spaces_horizontal}${pcre_macro_arg}')*'${pcre_word_spaces_optional}')?'${pcre_here}

    #FUXME: Macros accepting no arguments should be matchable in a
    #significantly more generalized, zsh-like manner. While matching
    #${pcre_line_end} is helpful, it fails to suffice; we'd also like to match
    #argumentless macros terminated by:
    #
    #* A standard command terminator (e.g., "<", "|") *WITHOUT* matching such
    #  terminator (i.e., use positive lookahead).
    #* A zeshy-specific command terminator (e.g., ":or", ":and"). Any others,
    #  or are those the only two ones? Oh, wait. *NO.* If this fallback
    #  alternative was matched, then no horizontal whitespace was matched after
    #  such macro's name, implying that a zeshy-specific command terminator
    #  could *NEVER* possibly match here. Ignore such terminators, but
    #  explicitly note why in the comments above.
    #
    #This should only be required for argumentless macros. Macros accepting one
    #or more arguments already follow the above stricture.

    #FUXME: Shift this and the following PCREs up to "space" above.

    # matches s to  To prevent 
    # any of the several standard syntactic primitives that
    # terminate commands.

    # Command terminator, comprising either the end of the current line *OR*
    # any of the several standard syntactic primitives that terminate commands.
    #     local pcre_command_ends=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=;|([<>|])))'

    #FUXME: This may be incorrect. In fact, it almost certainly is. Why?
    #Because we currently treat the last byte of the currently matched
    #substring as synonymous with the last byte of the currently matched
    #*MACRO*. However, by consuming such command terminator here, we interfere
    #with such interpretation. Ideally, such terminator should be captured but
    #*NOT* consumed via positive lookahead. Note our explicit use of "captured"
    #here yes, we do actually need to inspect the contents of such command
    #terminator programmatically in ={backend}. Why? Well, it's fairly simple:
    #
    #* If the captured command terminator group is nonempty, then such macro's
    #  expansion is intended to be piped or redirected elsewhere. How can we
    #  ensure that any arbitrary expansion can be piped or redirected? For now,
    #  the simplest solution is almost certainly the best. ={backend} must
    #  check for the following conditions *AFTER* expanding such macro:
    #  * If such captured group is nonempty *AND* the expansion returned by
    #    such macro's function is *NOT* delimited by "{" and "}", then
    #    delimit such expansion by "{" and "}".
    #
    #That's hopefully it.
    #FUXME: Moreover, this fails to account for possible line continuations
    #preceding such command terminator (e.g., ":macro\
    #| :piped_to_something"). How about something resembling:
    #
    #     local pcre_command_ends=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=(['${char_command_end}'])))'
    #
    #Of course, we probably haven't even defined ${pcre_word_spaces_optional}
    #by this point, requiring this PCRE be shifteb below.
    #FUXME: Actually, ";" is equivalent to a newline for command termination
    #purposes and hence ignorable. So, the above should be augmented to read:
    #
    #     local pcre_command_ends=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=;|([<>|])))'
    #
    #Of course, that suggests definition of a new character class above -- say:
    #    local char_command_end_semantic='<>|'
    #FUXME: We'll need to add a new global match index for such captured group.
    #FUXME: Actually, this strikes us as overkill. The existing
    #${pcre_macro_args_zsh_optional} should *NEVER* match a command-terminating
    #subsequence, for obvious reasons. That said, the current definition of
    #such PCRE currently does and hence is clearly insufficient. See
    #${char_command_end_semantic} for details. Consider excising this PCRE.
    # local pcre_command_ends='(?:'${pcre_line_end}'|['${char_command_end}'])'

    #FUXME: For efficiency, rename to ${pcre_here_doc_or_string_prefix_optional}
    #and suffix by "?".

    # ..................{ MACRO ~ word : embed               }..................
    #FUXME: Optimizable by eliminating extraneous "(?:" and ")" groupings.
    #FUXME: Actually, we want to revert to the prior approach. See above.
    #FUXME: Actually, this is probably *ALL* eliminatable by noting that
    #${pcre_word_passable_with_parens_balanced} pretty much suffices for both this and the
    #parens-specific PCREs below. Honestly, why did we go to such extreme
    #lengths to differentiate the three? It's rather difficult to say, now.
    #FUXME: Hmm; perhaps it *IS* useful to at least maintain the distinction
    #between ${pcre_word_passable_with_parens_balanced} and a new sort of word encompassing both braces
    #and parens words -- say, ${pcre_code_sans_comment}.
    #FUXME: O.K.; we've implemented a new ${char_not_word_embedded_unquoted}
    #character class. Use below in place of the current approach!
    #FUXME: O.K.; we've excised all ${pcre_word_braces*} and ${pcre_word_parens*}
    #definitions. Now, we need to replace all use of such PCREs by these PCREs.
    #FUXME: Actually, we want to excise all PCREs in this section as well as
    #${char_not_word_embedded_unquoted}, replacing both with their argument
    #word equivalents above. Then rename "word_arg" to "word" everywhere. As an
    #optimization, we can largely retain the benefits of using the approach
    #below by defining a new ${char_command_end_not_code_prefix} character
    #class probably defined something like so:
    #
    #    local char_command_end_not_code_prefix='&>|;'
    #
    #Such class explicitly omits "<", the here-document and -string prefix,
    #which must be matched in a more complex manner than a simple character
    #class. Given such class, we may then match all unquoted command
    #terminators in an efficient manner in all PCREs previously embedding
    #${pcre_code_sans_comment}, which seems rather nice.

    #FUXME: Arguably suffix by "'|'${pcre_here_doc_or_string_prefix}".

    # Character class matching invalid characters in unquoted shell words
    # embedded in syntactic constructs (e.g., blocks, process substitutions).
    # Since such words are matched merely to correctly parse the substrings
    # delimiting such constructs, this class excludes invalid characters
    # irrelevant to such parsing (e.g., "<", ">", "|").
    #
    # Since unquoted "(" and ")" characters are only permitted when balanced
    # (e.g., ":glob *.zy(.)"), such characters are excluded as above.
    # local char_not_word_embedded_unquoted='()'${char_not_code_prefix}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with argument word PCREs above.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # One or more characters of unquoted shell words embedded in syntactic
    # constructs.
    # local pcre_code_sans_comment_unquoted_char='[^'${char_not_word_embedded_unquoted}']'
    # local pcre_code_sans_comment_unquoted_chars=${pcre_code_sans_comment_unquoted_char}'++'
    #
    # # Syntactic construct embedded in shell words themselves embedded in
    # # syntactic constructs.
    # local pcre_code_sans_comment_substring=${pcre_code_sans_comment_unquoted_chars}'|'${pcre_char_escaped_optional}'|'${pcre_substitutable_or_quotes}
    #
    # # Zero or much such constructs.
    # local pcre_code_sans_comment_substrings_optional='(?:'${pcre_code_sans_comment_substring}')*'
    #
    # # "("- and ")"-balanced substrings in shell words signifying embeddeduments
    # # passed to macros. See ${pcre_word_unquoted_balanced} above.
    # local pcre_code_sans_comment_unquoted_balanced='\('${pcre_code_sans_comment_substrings_optional}'\)'
    #
    # # One or much such constructs *OR* "("- and ")"-balanced substrings.
    # local pcre_code_sans_comment_substrings_balanced='(?:'${pcre_code_sans_comment_substring}'|'${pcre_code_sans_comment_unquoted_balanced}')+'
    #
    # # Shell word embedded in a syntactic construct.
    # local pcre_code_sans_comment=${pcre_word_lookahead}${pcre_code_sans_comment_substrings_balanced}${pcre_word_lookbehind}
    #
    # # Zero or more shell words, whitespace characters, or comments embedded in
    # # a syntactic construct.
    # local pcre_words_embedded_or_comments_optional='(?:'${pcre_code_sans_comment}'|'${pcre_comment_optional_spaced}')*'

    #FUXME: Wait. Even a simple character class is insufficient. We'll want to
    #additionally support the following command terminating substrings:
    #* Either "<", ">", or "&" preceded by a nonnegative digit.
    #* A "}" delimiting a code block.
    #* A process substitution of the form "=(...)".
    #
    #In short, "Ugh." Hopefully, merely improving matching elsewhere will
    #implicitly correct for such shortfalls.
    # local char_command_end_semantic='<>|&'

    # local char_command_end_semantic='<>|&'

    # Character class matching ASCII punctuation characters that unconditionally
    # terminate the preceding command. 
    # local char_command_end=${char_command_end_semantic}';'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with embedded word PCREs below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Excise below.

    # # First, middle, and last unquoted substrings of unquoted shell words
    # # embedded in "{"- and "}"-delimited code blocks.
    # local pcre_word_braces_unquoted_char_first_last='[^'${char_not_word_braces_unquoted}'{}]'
    # local pcre_word_braces_unquoted_char_first='(?:[^'${char_not_word_braces_unquoted}'{]|'${pcre_char_escaped_optional}')'
    # local pcre_word_braces_unquoted_char_last='(?:[^'${char_not_word_braces_unquoted}'}]|'${pcre_char_escaped_optional}')'
    # local pcre_word_braces_unquoted_char_middle='(?:[^'${char_not_word_braces_unquoted}']+|'${pcre_char_escaped_optional}')'
    # local pcre_word_braces_unquoted_chars_middle_optional=${pcre_word_braces_unquoted_char_middle}'*'
    #
    # # First, middle, and last substrings of a shell word embedded in "{"- and
    # # "}"-delimited code blocks.
    # local pcre_word_braces_first_last=${pcre_word_braces_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_braces_first='(?:'${pcre_word_braces_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_braces_last='(?:'${pcre_word_braces_unquoted_char_last}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_braces_middle='(?:'${pcre_word_braces_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_braces_middle_optional=${pcre_word_braces_middle}'*'
    #
    # # Shell word embedded in "{"- and "}"-delimited code block.
    # local pcre_word_braces='(?:'${pcre_word_braces_first}${pcre_words_braces_middle_optional}${pcre_word_braces_last}')|'${pcre_word_braces_first_last}')'

    # ..................{ MACRO ~ word : parens              }..................
    # Unquoted substrings of unquoted shell words embedded in "$("- and
    # ")"-delimited process substitutions. Technically, such words are also
    # subject to the same constraints as those above (e.g., "{" cannot be the
    # first character of such words). However, such constraints are irrelevant
    # to the parsing of such substitutions and hence ignorable here.
    # local pcre_word_parens_unquoted_char='[^'${char_not_word_parens_unquoted}']'
    # local pcre_word_parens_unquoted_chars=${pcre_word_parens_unquoted_char}'++'
    #
    # # Syntactic constructs embedded in shell words embedded in "$("- and
    # # ")"-delimited code blocks.
    # local pcre_word_parens_body=${pcre_words_parens_unquoted_chars}'|'${pcre_char_escaped_optional}'|'${pcre_substitutable_or_quotes}
    #
    # # "("- and ")"-balanced substrings in shell words embedded in "$("- and
    # # ")"-delimited code blocks. Since such substrings are non-nestable,
    # # recursion and hence subroutine calls are *NOT* required. Yet, such
    # # substrings can contain other constructs (e.g., single-quoted strings).
    # local pcre_word_parens_unquoted_balanced='\((?:'${pcre_word_parens_body}')*\)'
    #
    # # Shell word embedded in "$("- and ")"-delimited code blocks.
    # local pcre_word_parens=${pcre_word_parens_body}'|'${pcre_word_parens_unquoted_balanced}
    #
    # # One or more shell words embedded in "$("- and ")"-delimited code blocks.
    # local pcre_words_parens_optional='(?:'${pcre_word_parens}')*'

    #FUXME: This didn't even work under the prior definition. Why? Because
    #${pcre_words_parens_optional} does *NOT* match whitespace, implying this
    #pretty always failed to correctly match. Naturally, it fails even worse
    #now that we've refactored such PCREs away. That said, it shouldn't be
    #*TOO* terribly hard to gin up something that works. This should do it:
    #
    #${pcre_code_sans_comment}'|'${pcre_comment_optional_spaced}
    # local pcre_list_assignment_optional=${pcre_var_name}'(?:=\('${pcre_words_parens_optional}'\))?'

    #FUXME: This didn't even work under the prior definition, since it failed

    # One or more shell words embedded a syntactic construct.
    # local pcre_code_sans_comment_optional='(?:'${pcre_code_sans_comment}')*'

    # Character class matching invalid characters in unquoted shell words
    # embedded in "$("- and ")"-delimited process substitutions. Since such
    # words are matched merely to correctly parse such delimiters, this class
    # excludes invalid characters irrelevant to such parsing (e.g., "|", ">").
    #
    # Since unquoted "(" and ")" characters are only permitted when balanced
    # (e.g., ":glob *.zy(.)"), exclude such characters here.
    # local char_not_word_embedded_unquoted='()'${char_not_code_prefix}

    # Character class matching invalid characters in unquoted shell words
    # embedded in "{"- and "}"-delimited code blocks. Since such words are
    # matched merely to correctly parse such delimiters, this class excludes
    # invalid characters irrelevant to such parsing (e.g., "|", ">").
    # local char_not_word_braces_unquoted='()'${char_not_code_prefix}

    #FUXME: We suspect that unquoted word characters *CANNOT* be optimized with
    #possessiveness (e.g., "+"), due to the occasional need to backtrack into
    #such characters (e.g., on matching the "}" in "shellword}"). Test us on
    #such edge cases, please. 
    #FUXME: Insufficient! PCREs below need to match shell words *PERFECTLY*.
    #Why? Because we need to ensure that macros either embedded in other
    #syntactic constructs *OR* suffixed by command-terminating substrings
    #(e.g., "=(uhoh)") are correctly matched. To ensure this, we'll need to:
    #
    #* Avoid matching any word-like substring prefixed by "=(" (regardless of
    #  subsequent text) as a word.
    #* Avoid matching digits prefixing "&", "<", or ">" as standard arguments
    #  (e.g., the "1" in "1<&2"). Only check at the start of a word.
    #* Avoid matching "{"- and "}"-delimited variable names prefixing the same
    #  primitives (e.g., "{myfid}>&1"). Only check at the start of a word.
    #* Match "(" and ")" in unquoted shell words in a non-recursive balanced
    #  manner. Happily, we've already done this; we simply need to integrate
    #  that work here.

    # First, middle, and last unquoted substrings of unquoted literal shell
    # words. Since both shell words in the context of passed arguments *AND*
    # shell-reserved "{" delimiters are always preceded by at least one
    # horizontal character, shell words cannot be prefixed by "{" characters.
    # Naturally, a similar argument holds for "}" characters (i.e., shell words
    # cannot be suffixed by such characters).

    #FUXME: Drop the "_literal" from such names. No longer required, and
    #they're already quite long.
    #FUXME: Horrible. Refactor to use the lookahead-driven approach below.
    # local pcre_word_literal_char_first_last='[^'${char_not_subword_unquoted_with_parens_balanced}'{}]'
    # local  pcre_word_literal_char_first='[^'${char_not_subword_unquoted_with_parens_balanced}'{]'
    # local   pcre_word_literal_char_last='[^'${char_not_subword_unquoted_with_parens_balanced}'}]'
    # local pcre_word_literal_char_middle='[^'${char_not_subword_unquoted_with_parens_balanced}']'
    # local pcre_word_literal_chars_middle_optional=${pcre_word_literal_char_middle_optional}'*'

    # Unquoted literal shell word, comprising one or more characters that are
    # neither shell-reserved *OR* "\"-escaped.
    # local pcre_word_literal='(?:'${pcre_word_literal_char_first}${pcre_word_literal_chars_middle_optional}${pcre_word_literal_char_last}'|'${pcre_word_literal_char_first_last}')'
    # local pcre_word_literal_grouped='('${pcre_word_literal}')'

    #FUXME: Oh, boy. It turns out that *ALL* redirections other than
    #here-documents and -strings may be freely interspersed with standard
    #command arguments: e.g.,
    #
    #    >>> function :yil() { print "${@}" }
    #    >>> :yil 1<&2 =(print ok) yum
    #    /tmp/zsh3lpV1a yum
    #
    #So. Where do we go from here? Frankly, we're inclined to ignore this
    #distinction by implementing the following:
    #
    #* Words should be permitted to contain arbitrary "<", ">", and "&"
    #  characters.
    #
    #Wait... How do we deal with macro expansion now?

    #FUXME: Oh, boy. This requires heavy examination.

    # Syntactic primitives breaking the standard "flow of control" with which
    # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # here-documents and -strings. Hence, shell words are synonymous with
    # standard arguments passable to external commands or functions.

#, comprising one or more
    # of the prior syntactic constructs
    # local pcre_word_body='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped_optional}'|'${pcre_substitutable_or_quotes}')+'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}${pcre_word_body}${pcre_word_lookbehind}

    # * "(" and ")" are technically shell-reserved but permitted in unquoted
    #   shell words when strictly balanced (e.g., "(this)" but not "(this(").
    #FUXME: Use in process substitutions to match "$( ugh*.txt(.) )".

    #FUXME: The current approach incurs quite a bit of backtracking, which
    #could be obviated by simple use of forward and negative lookahead.  In
    #hindsight, the prior approach genuinely appears to have been superior.
    #The current approach is blatantly overly complex and inefficient. Revert
    #both here and below, please. (Regretful apologies on that one.)
    #
    #Use ${pcre_word_middle} as a basis for our reversion, shifting all
    #desired forward lookahead constraints into
    #${pcre_word_lookahead} above. (Nice, eh?)

    # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_literal_char_first_last}'|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_literal_char_first}'|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_literal_char_last}'|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_middle='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'
    #
    # # Shell word, comprising one or more of the prior syntactic constructs.
    # # Syntactic primitives breaking the standard "flow of control" with which
    # # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # # here-documents and -strings. Hence, shell words are synonymous with
    # # standard arguments passable to external commands or functions.
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}'(?:'${pcre_word_first_last}'|'${pcre_word_first}${pcre_words_middle_optional}${pcre_word_last}')'

    # # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_literal_char_first_last}'|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_literal_char_first}'|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_literal_char_last}'|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_middle='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped_optional}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'
    #
    # # Shell word, comprising one or more of the prior syntactic constructs.
    # # Syntactic primitives breaking the standard "flow of control" with which
    # # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # # here-documents and -strings. Hence, shell words are synonymous with
    # # standard arguments passable to external commands or functions.
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}'(?:'${pcre_word_first_last}'|'${pcre_word_first}${pcre_words_middle_optional}${pcre_word_last}')'

    # Single- or double-quoted string, arithmetic or process substitution, *OR*
    # variable expansion embedded in a shell word.
    #FUXME: Contemplate either:
    #
    #* Supplanting ${pcre_embeddable} by "(?&sub)" below and then excising
    #  ${pcre_embeddable}. This has the disadvantage of slowing commonplace
    #  variable expansions, however.
    #* Replacing the embeddings of both ${pcre_process_substitution_dollar_recursive}
    #  and ${pcre_process_substitution_dollar_nonrecursive} with new subroutines
    #  calling such PCREs. This amends the prior issue.
    #* Reducing this PCRE to:
    #    local pcre_embeddable_or_quotes='(?&word)'
    #    pcre_subroutines_body+='(?<word>${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'
    #
    #While the second option would be preferable in the ideal world, we should
    #consider adopting the third option as a concession to real-world
    #pragmatism. After all, this PCRE is transitively embedded into so many
    #other expressions that the current approach patently fails to scale. As a
    #temporary hotfix, therefore, we've elected to adopt the first option.

    #FUXME: Overkill. Combine the following three into one conglomerate PCRE.
    # # "=("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_equals='=\('${pcre_process_parens_body}'\)'
    #
    # # "<("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_angle_left='<\('${pcre_process_parens_body}'\)'
    #
    # # ">("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_angle_right='>\('${pcre_process_parens_body}'\)'

#  Since the named group
    # "<sub>" matches non-recursive process substitution, such group *CANNOT*
    # be referenced here. (Doing so would permit such substitutions to be
    # recursively nested.) Instead, match all groups matched by such group
    # excluding non-recursive process substitution.
    # Recursively substitutable syntactic construct (e.g., "=("- and
    # ")"-delimited process substutition), intended to be called *ONLY* from
    # within such constructs.

    # First, middle, and last unquoted substrings of unquoted shell words.

    #FUXME: Optimizable by eliminating extraneous "(?:" and ")" groupings.

    # local pcre_word_unquoted_char_first_last=${pcre_word_literal_char_first_last}
    # local pcre_word_unquoted_char_first='(?:'${pcre_word_literal_char_first}'|'${pcre_char_escaped_optional}')'
    # local pcre_word_unquoted_char_last='(?:'${pcre_word_literal_char_last}'|'${pcre_char_escaped_optional}')'
    # local pcre_word_unquoted_char_middle='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped_optional}')'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'+'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'*'

    # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_unquoted_char_last}'|'${pcre_word_quoted_or_substitutable}')'
    # local pcre_word_middle='(?:'${pcre_word_unquoted_chars_middle}'|'${pcre_word_quoted_or_substitutable}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'

    #FUXME: Reasonably tired of "${pcre_quotes_single}'|'${pcre_quotes_double}"
    #everywhere. Time to recover ${pcre_quotes_optional}, we should think.

# ${pcre_quotes_single}'|'${pcre_quotes_double}'|'

    #FUXME: The above is great and should be shifted to ={backend}. That said,
    #the whole point of [<>=]"("- and ")"-delimited process substitutions is
    #that they can be passed as customary arguments, meaning we need to treat
    #them as such. All other redirections should still be required to be passed
    #at the end of the macro expansion as is customary.
    #FUXME: Insufficient. Sadly, this fails to take into account the following
    #process substitution variants:
    #
    #* "=(...)", capturing the output of such command(s) to a temporary file
    #  and passing such file's handle to the current command. Unlike the
    #  variants below (which may appear *ANYWHERE*), "=(...)" must begin at the
    #  first character of a shell word or will otherwise be treated as a part
    #  of an unquoted shell word (e.g., "file*.txt=(.)" is a glob rather than a
    #  process substitution!). Yes, this is terrible. Correctly matching this
    #  pretty much requires matching words properly. That said, we *SHOULD* be
    #  matching words properly anyway in process substitutions... yes?
    #* "<(...)", redirecting the output of such command(s) to the current
    #  command's standard input.
    #* ">(...)", redirecting the output of the current command to standard
    #  input for such command(s).

    #FUXME: Actually use the following three PCREs. At the very least, embed
    #them in the definition of "<sub>" below.

    #FUXME: Use everywhere below in place of "(?&sub)".
    #FUXME: Abstract "[^'${char_not_code_prefix}']++" into a new PCRE above and
    #replace all current instances of such substring by such PCRE.
    #FUXME: Abstract out [^'${char_not_code_prefix}']++.

    # local pcre_process_substitution_dollar='(?:'${pcre_list_assignment_optional}'|'${pcre_word_parens}'|'${pcre_comment_optional_spaced}'|'${pcre_here_doc_or_string_prefix}'|[^)])*'

    # Redirection prefixed by a file descriptor specified as either a
    # non-negative integer *OR* "{"- and "}"-delimited variable name. Such
    # redirections conflict with unquoted shell word syntax and hence *MUST* be
    # matched for disambiguation. See section "REDIRECTION" of "man zshexpn".
    # local pcre_redirect_prefix='(?:[0-9]++|\{'${pcre_var_name}'\})&?[<>]'

    # ${pcre_redirect_file_handle_id}'|'${pcre_redirect_file_handle_id}
    # l are incidental to macro parsing but  
    #FUXME: The lookahead optimization preceding such call is rather nice,
    #here. Does a similar optimization apply elsewhere?
# (?=['${char_embeddable_prefix}'])(?&sub)'

    #FUXME: O.K.; so, clearly, we *DO* require this. Probably? Maybe. Hmm. Will
    #the "1" in "1<&2" be matched as an unquoted argument here? Surely not.

    #FUXME: Do we still require this?
    # "&&" (but not "&" on its own)
    #FUXME: Wait. Both "||" and "&&" also terminate commands.

# by such assert such constraint We assert such constraint with
    # ..................{ MACRO ~ word                       }..................
    #FUXME: Shift below.
    #FUXME: We're fairly certain that *OUTSIDE* of process substitutions, it
    #suffices to match the prefixes "\(" and "\[" respectively. *INSIDE* of
    #process substitutions, of course, the full "\("-prefixed math substitution
    #must be matched (to avoid conflict with embedded "("- and ")"-delimited
    #parens in math substitutions and the ")" delimiter for the outer process
    #substitution). Yikes!
    #FUXME: Oh! Jeebus. No, no, and no; do you wish to know why? Math operators
    #(namely, "<<") fundamentally conflict with exterior zsh syntax. Sadly, we
    #failed to note that above. This does imply, however, that we'll need to
    #resurrect ${pcre_math_substitution_braces} from below. *sigh*

    # whose syntax fundamentally conflicts with conventional zsh
    #
    # delimiters and must thus be matched. (Note that zsh also supports
    # possibly recursively nested "$["- and "]"-delimited arithmetic
    # substitutions. Since such delimiters conflict with no syntax of
    # preprocessor significance, such substitutions are ignorable.)

    #FUXME: Embed me in process substitutions below, please. Or perhaps not?
    # Shell word, here-document, or here-string prefix.
    # local pcre_word_parens_or_here=${pcre_word_parens}'|'${pcre_here_doc_or_string_prefix}

    #FUXME: We need to add substitutable constructs here!
    # Technically, such PCRE is somewhat inefficient: the negative lookahead
    # "(?!`)" only needs to prefix the "(?&sub)" and "." alternatives. Since
    # "`" is deprecated and never appears in the zeshy codebase, however, we
    # currently ignore such inefficiencies for simplicity.

    #FUXME: Replace all instances of  ${pcre_here_doc} with "(?&here)".
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    #FUXME: Note the repetition between this and the following PCRE. Such body
    #should be extracted into a new common PCRE -- say,
    #${pcre_word_parens_body} -- and interpolated into both this
    #PCRE and the PCRE below.

    #FUXME: This can be optimized by reduction to:
    #
    #     local pcre_words_parens_body=${pcre_words_parens_unquoted_chars}'|'${pcre_word_parens_unquoted_balanced}'|'${pcre_embeddable_or_quotes}
    #
    #Then expand such PCRE where we currently expand ${pcre_words_parens}.

    # local pcre_words_parens='(?:'${pcre_words_parens_unquoted_chars}'|'${pcre_word_parens_unquoted_balanced}'|'${pcre_embeddable_or_quotes}'|'${pcre_char_escaped_optional}')+'
    # local pcre_word_parens_unquoted_balanced='\((?:'${pcre_words_parens_unquoted_chars}'|'${pcre_embeddable_or_quotes}'|'${pcre_char_escaped_optional}')*\)'
    # local pcre_word_parens_unquoted_char='(?:[^'${char_not_word_parens_unquoted}']+|'${pcre_char_escaped_optional}')'
    # local pcre_word_parens_unquoted_chars=${pcre_word_parens_unquoted_char}'+'

    # local pcre_process_substitution_dollar_nonrecursive='`(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_comment_optional_spaced}'|(?!`)(?:'${pcre_code}'|.))*`'

    #FUXME: Give me another eyeball over, please.
    # local pcre_process_substitution_dollar_recursive='(?:'${pcre_list_assignment}'|[^)'${char_not_code_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_comment_optional_spaced}'|'${pcre_code}'|[^)])*'
    # local pcre_macro_arg_block_body='(?:'${pcre_word_braces}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^}])*'

    # Block delimiter "}". As ${char_not_subword_unquoted_with_parens_balanced} documents, such "}" must
    # be suffixed by at least one horizontal whitespace or newline character
    # (optionally preceded by zero or more line continuations). To support
    # macros accepting two or more consecutive argument blocks, avoid matching
    # suffixing whitespace matched as prefixing whitespace by the next such
    # block by merely asserting this constraint with positive lookahead.
    #FUXME: This is terrible. More to the point, given the refactored
    #${pcre_word_passable_with_parens_balanced}, this is no longer required. Instead, refactor
    #${pcre_macro_arg_block_body} below to leverage ${pcre_word_passable_with_parens_balanced} rather than
    #the current negative character class-driven approach. This *SHOULD*
    #substantially reduce the complex of such PCRE, as well as improving the
    #efficiency. (*SHOULD*, anyway.)
    #FUXME: O.K.; we should be good to go to excise both ${pcre_char_block_prefix}
    #and ${pcre_char_block_suffix}. This will invoke backtracking on edge-case
    #failures (...actually, not, come to think), but should nonetheless work
    #capably under all substrings.
    # local pcre_block_suffix_lookahead=${pcre_line_continuations_optional}'(?:'${pcre_space_horizontal}'|'${pcre_line_end}')'
    # local pcre_char_block_suffix='\}(?='${pcre_block_suffix_lookahead}')'

    #FUXME: The current definition of ${pcre_process_substitution_dollar_recursive} is
    #sadly incorrect as well, as it fails to match "$( print file*.txt(.) )"
    #correctly. Interestingly, such PCRE fails for the exact same reason that
    #we required lookahead ahead. Hence, the exact same solution of replacing
    #the current negative character class-driven approach in such PCRE with a
    #${pcre_word_passable_with_parens_balanced}-based solution *SHOULD* amend that and similar issues. Oh!

    # Non-block delimiter "}" (i.e., a "}" *NOT* followed by the syntax
    # qualifying such "}" as a block delimiter).
    # local pcre_brace_right='\}(?!'${pcre_block_suffix_lookahead}')'

    #FUXME: While a highly unlikely edge case, we suspect block "{" delimiters
    #may be preceded by "|" without intervening whitespace. Perhaps not? Not
    #terribly critical, but worth investigating.

    #FUXME: Optimizable, possibly? ${pcre_word_braces} may *ONLY* be followed
    #by either the terminating "}" *OR* by whitespace (either vertical or
    #horizontal).

    #FUXME: The fact that we're capturing grouped substrings here suggests that
    #this will almost certainly interfere with captured group indices.
    #Subroutines provide a nice way around this. Alternately, we vaguely recall
    #a "(*...)"-style directive for clearing previously captured groups. "\K"
    #also effects something similar. Investigate. Contemplate.
    #FUXME: While subroutines *WOULD* work here to effectively "erase" such
    #capturing, a more efficient alternative would be to ensure that
    #${ZESHY__MACRO_PCRE} is designed in such a way that:
    #
    #* The macro name is *ALWAYS* the first captured group.
    #* Invalid macro arguments are *ALWAYS* the last captured group.
    #
    #In such case, the latter may be reliably indexed as ${match[-1]}. (We'll
    #need to modify the index globals below accordingly.) Given that, all
    #intermediate captured groups would simply be ignorable. Sounds good, no?
    #FUXME: Oh, and given the fact that here-documents group, we *REALLY* want
    #to rename all such PCREs below to reflect that.
    #FUXME: No, no, no. After briefly flirting with such nomenclature change,
    #it's clear that we would be capturing here-document delimiters in so many
    #PCREs that we'd probably end up with a countably infinite number of empty
    #groups preceding a captured syntactically invalid macro group. This is
    #nonsense, and probably equally as inefficient as simply subrouting
    #here-documents -- which, clearly, is what we're going to do instead. Yay!
    #Happily, such subroutine calls may be optimized by being prefixed by
    #positive lookahead: e.g.,
    #
    #    (?=<)(?&here)

    #FUXME: Unused anywhere. Why? We'll need to at least ensure that
    #${pcre_word_unquoted_char_first_last} is being used.

    # Unquoted shell word, comprising one or more characters that are *NOT*
    # shell-reserved.
    # local pcre_word_unquoted='(?:'${pcre_word_unquoted_char_first}${pcre_word_unquoted_chars_middle_optional}${pcre_word_unquoted_char_last}')|'${pcre_word_unquoted_char_first_last}')'

    #FUXME: Define ${pcre_words_parens} above.

    #FUXME: O.K.; so, to do this, we need to implement support for balanced
    #(but *NOT* nested) parens in an unquoted fashion. Shouldn't be terribly
    #difficult, but you know the score.

    # First, middle, and last substrings of a shell word embedded in "$("-
    # and ")"-delimited code blocks.
    # local pcre_word_paren_left_last=${pcre_word_parens_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_paren_left='(?:'${pcre_word_parens_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_parens_last='(?:'${pcre_word_parens_unquoted_char_last}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_parens_middle='(?:'${pcre_word_parens_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_parens_middle_optional=${pcre_word_parens_middle}'*'

    # local pcre_word_parens_middle='(?:'${pcre_word_parens_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_parens_middle_optional=${pcre_word_parens_middle}'*'
    # local pcre_word_parens_unquoted_balanced='\('${pcre_words_parens_middle_optional}'\)'

    #FUXME: Actually use this. Or excise, perhaps? In the latter case, we'll
    #need to ensure we're using ${pcre_word_braces_unquoted_char_first_last}.

    # Unquoted shell word embedded in "{"- and "}"-delimited code blocks.
    # local pcre_word_braces_unquoted='(?:'${pcre_word_braces_unquoted_char_first}${pcre_word_braces_unquoted_chars_middle_optional}${pcre_word_braces_unquoted_char_last}')|'${pcre_word_braces_unquoted_char_first_last}')'

    # Unquoted shell word embedded in "$("- and ")"-delimited process
    # substitutions.

    #FUXME: Use in process substitutions to match "$( ugh*.txt(.) )"? That, or
    #we'll probably need to leverage lookahead. (Ugh! This is terrible. Perhaps
    #just ignore such edge case for now?)
    # local pcre_word_parens_unquoted='[^'${char_not_word_parens_unquoted}']++'

    #FUXME: O.K.; so, we do *ABSOLUTELY* want to use this. Indeed, we can
    #actually use a truncated form of ${char_not_subword_unquoted_with_parens_balanced} ignoring
    #non-conflicting syntax (e.g., "{", "}", "|", etc.), meaning that we can
    #produce a vastly simplified variant of ${pcre_word_passable_with_parens_balanced} specific to process
    #substitutions -- say, ${pcre_word_parens}.

    #FUXME: Actually, we probably *NEVER* need to match the old math
    #substitution form, as such form should conflict with no existing syntax.
    #Excise, please!
    # local pcre_math_substitution_braces='\[(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped_optional}'|(?&sub)|[^\]])*\]'

    # in both current (i.e., "$(("- and "))"-delimited) and obsolete (i.e.,
    # "$["- and "]"- delimited) forms.

    #FUXME: Refactor to use ${pcre_word_braces} here.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_word_braces}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^}])*'
    # local pcre_macro_arg_block_body='(?:[^{}'${char_not_code_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code}'|[^}]|'${pcre_brace_right}')*'

    # escaping characters, including the above such prefixes.
    # local pcre_embeddable=${pcre_dollar_construct}'|'${pcre_process_substitution_dollar_nonrecursive}
    # pcre_macro_subroutines_body+='(?<sub>'${pcre_embeddable}')'

    # local pcre_embeddable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}

    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:[^{}'${char_not_code_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code}'|[^}]|'${pcre_brace_right}')*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_macro_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    # local pcre_word_braces_unquoted='[^'${char_not_word_braces_unquoted}']++'

    #FUXME: Likewise, we should produce a new ${pcre_word_braces} similarly
    #ignoring non-conflicting syntax nested inside of a block argument (e.g.,
    #"|", etc.). Note, however, that we *MUST* retain ${pcre_word_passable_with_parens_balanced} for use in
    #detecting standard arguments at the outermost level.

    #FUXME: Actually, even that doesn't quite suffice. We realized that such
    #PCRE also fails to match "$( :list y; y=( ) )". Hence, we'll now need to
    #match list assignments *ONLY* inside process substitutions. *sigh*

    # local pcre_macro_args_zsh_optional=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'

    #FUXME: Use of ${pcre_line_end} is insufficient both here and below.
    #Numerous syntactic primitives effectively terminate the current command
    #and hence macro, including "|", ">", and non-here-specific "<". Any
    #others? (Probably not, but contemplate.)
    #
    #O.K.; after examination, "|", ">", and "<" should absolutely suffice. Oh,
    #and ";", of course. Yes!

    #FUXME: Shift above and use everywhere we use ${pcre_line_end} below.

    # Macro terminator, either the end of the current line *OR* any of the
    # several standard command terminators.
    # local pcre_macro_end='(?:'${pcre_line_end}'|'${pcre_command_ends}')'

    #FUXME: O.K.; so, we're implementing an increasing amount of work,
    #complexity, and inefficiency -- all to match  
    # Zero or more command-specific whitespace sequences. Technically, this
    # PCRE is optimizable to:
    # local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'

    # local pcre_here_string_prefix='<'${pcre_word_spaces_optional}
    #FUXME: We need to actually ensure that *ALL* negative character classes
    #contain "\" and then modify the PCREs embedding such classes to match
    #${pcre_char_escaped_optional}. Grep everywhere below, we're afraid, for "[^".

    # Zero or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments).

    # local pcre_word_unquoted_char_last=${pcre_word_literal_char_last}
    #FUXME: Insufficient; "}" is *NOT* an unquoted shell word.

    # local  pcre_word_unquoted_char_middle='(?:'${pcre_word_literal_char_middle}'|'${pcre_char_escaped_optional}')'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'+'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'?'

    # local  pcre_word_unquoted_char_first='(?:'${pcre_char_escaped_optional}'|[^'${char_not_subword_unquoted_with_parens_balanced}'{])'
    # local   pcre_word_unquoted_char_last='[^'${char_not_subword_unquoted_with_parens_balanced}'}\\]'
    # local pcre_word_unquoted_char_middle='(?:'${pcre_char_escaped_optional}'|[^'${char_not_subword_unquoted_with_parens_balanced}'])'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'++'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'?'

    # local  pcre_word_literal_char_first='[^'${char_not_subword_literal}'{]'
    # local   pcre_word_literal_char_last='[^'${char_not_subword_literal}'}]'
    # local pcre_word_literal_char_middle='[^'${char_not_subword_literal}']'
    # local pcre_word_literal_chars_middle_optional=${pcre_word_literal_char_middle}'?'

    # Unquoted literal shell word, comprising one or more shell-unreserved,
    # "\"-unescaped characters.

    # Character class matching invalid characters in unquoted literal shell
    # words (i.e., shell words interpreted literally and hence *NOT* containing
    # escaped characters), comprising most shell-reserved characters along with
    # character escape "\".
    # local char_not_subword_literal=${char_not_subword_unquoted_with_parens_balanced}'\\'

    # To ensure this, the character escape "\" must *ALWAYS* be 

    #FUXME: Incorrect, as we also need to match comments and "{" delimiters at
    #the start of lines when *NOT* prefixed by line continuations. (Good lord.)
    #Incidentally, this suggests we're probably matching comments incorrectly
    #everywhere else as well.
    #FUXME: O.K.; we *ARE* dealing with comments appropriately elsewhere. While
    #confirming this, we also noted that we deal with whitespace in a
    #considerably simpler and more straightforward manner than we do here.
    #On the face of it, there doesn't *APPEAR* to be any reason that we can't
    #supplant ${pcre_macro_arg_block_spaces} with ${pcre_line_start_or_spaces_horizontal}
    #(which, clearly, should be renamed and shifted to the "spaces" section).
    #Clearly, we wanted to prevent a line continuation followed immediately by
    #"{" from being matched as a block prefix. But, if you consider it,
    #${pcre_line_start_or_spaces_horizontal} already ensures this! So, embedding
    #${pcre_word_spaces_prefixed_by_spaces} here gains us nothing. Thankfully,
    #this would appear to be among the last PCRE chores.
    # local pcre_macro_arg_block_spaces='(?:'${pcre_line_start}'|'${pcre_word_spaces_prefixed_by_spaces}')'
# ${pcre_line_start_or_spaces_horizontal}

    # local pcre_line_start_or_spaces_horizontal='(?:'${pcre_spaces_horizontal}'|'${pcre_line_start}${pcre_spaces_horizontal_optional}')'

    #FUXME: Still required? Ideally, this should be excisable.

    # One or more horizontal whitespace characters optionally followed by a
    # comment.
    # local pcre_spaces_horizontal_and_comment_optional=${pcre_spaces_horizontal}'(?:'${pcre_comment}')?'

# ${pcre_spaces_horizontal_and_comment_optional}'
    #FUXME: Concoct ${pcre_here} if not already. Excise now redundant
    #PCREs (e.g., ${pcre_macro_here_optional}).
    #FUXME: Abstract "[^'${char_space_vertical}']++" into a PCRE local.
    # local pcre_macro_args_zsh_or_block_optional='(?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'))*'
    # local pcre_macro_args_optional='(?:'${pcre_macro_args_zsh_or_block_optional}${pcre_word_spaces_optional}${pcre_here}${pcre_line_end}'|([^'${char_space_vertical}']++))'

    # arguments of any type.
    # To assist the preprocessor in
    # differentating between syntactically valid macros accepting no arguments
    # and syntactically invalid macros accepting arguments, embed an empty
    # group at some arbitrary position in such PCRE. Differentiating such cases
    # then reduces to testing the length of canonical list global ${matches}.
    # While we could also effect this by capturing the entire substring matched
    # by such PCRE, doing so has no demonstrable benefit over the current
    # approach while incurring minor time and space costs. So, the current
    # approach reigns.

    #FUXME: This is a wee crazy. Is there no terser solution?
    # local pcre_macro_args_zsh_or_block_optional='(?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'))*'

    # One or more standard arguments, comprising one or more shell words all of
    # which are delimited by shell word-specific whitespace. Such condition
    # prevents whitespace suffixing the last such argument from being matched,
    # ensuring such whitespace will be matched only as the mandatory whitespace
    # prefixing a subsequent block argument if any or otherwise ignored. (Since
    # unquoted whitespace is significant only for argument delimitation in both
    # zsh and zeshy, trailing unmatched whitespace is safely ignorable.)
    # local pcre_args_zsh=${pcre_word_passable_with_parens_balanced}'(?:'${pcre_continuable_spaces_horizontal}${pcre_word_passable_with_parens_balanced}')*'
    # local pcre_args_zsh_optional='(?:'${pcre_args_zsh}')?'

    #FUXME: Correct the definition of ${pcre_word_unquoted} above.
    #FUXME: Erroneous, as ${pcre_here} has yet to be defined. We suspect
    #circular dependencies due to here-strings.

    #FUXME: Apply all fixes to this PCRE to the following PCRE.
    # local pcre_word_literal='[^'${char_not_subword_literal}']++'

#  As ${char_not_subword_unquoted_with_parens_balanced} documents, character "}"
    # when conditionally followed by horizontal whitespace is shell-reserved
    # and must be excluded.

    #FUXME: Not quite right. "}ounhou" is a valid unquoted word and should be
    #matched by this PCRE. Likewise, a "{" preceded by horizontal whitespace is
    #invalid and must *NOT* be matched this PCRE. We'll probably want to
    #redesign this in favor of the current ${pcre_word_passable_with_parens_balanced} approach.
    # local pcre_word_passable_with_parens_balanced=${pcre_word_first}'(?:'${pcre_words_middle_optional}${pcre_word_last}')?'
    # local pcre_word_unquoted='[^'${char_not_subword_unquoted_with_parens_balanced}']++|'${pcre_brace_right}

    # ..................{ MACRO ~ word                       }..................
    # Optional here-document or -string.
    # Here-document or -string prefixed by one or more horizontal whitespace
    # characters.
    # local pcre_macro_here_optional='(?:'${pcre_word_spaces_optional}${pcre_here}')?'

    # local pcre_macro_here_optional='(?:'${pcre_word_spaces_optional}${pcre_here}')?'
    # '(?:'${pcre_continuable_spaces_horizontal}${pcre_word_passable_with_parens_balanced}')*
    # '(?:'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'
    # local pcre_macro_args_optional='(?:(?:'${pcre_continuable_spaces_horizontal}'(?=([^'${char_space_vertical}']?))(?:'${pcre_args_zsh_optional}${pcre_macro_arg_blocks_optional}')*'${pcre_macro_here_optional}')?'${pcre_line_end}${pcre_empty_group}')?'
    # local pcre_macro_args_optional='(?:(?:'${pcre_continuable_spaces_horizontal}'(?=([^'${char_space_vertical}']))(?:'${pcre_macro_arg_block}'|'${pcre_args_zsh}')*'${pcre_macro_here_optional}')?'${pcre_line_end}${pcre_empty_group}')?'
    # local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block}'|'${pcre_args_zsh}')*)?'

#, and named accordingly
#zsh_optional_grouped
    #FUXME: Still not quite right: must match suffixing whitespace if any.
    # local pcre_macro_args_zsh_optional_grouped='('${pcre_continuable_spaces_horizontal}${pcre_args_zsh_optional}')'

    #FUXME: Excrutiatingly simple. Simply replace by the two PCREs such PCREs
    #expand to. *sigh*
    # local pcre_word_spaces_and_args_zsh_optional=${pcre_continuable_spaces_horizontal}${pcre_args_zsh_optional}
    # local pcre_word_spaces_and_args_zsh_optional=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}${pcre_word_spaces_optional}')*'
    # local pcre_word_spaces_and_args_zsh_optional_grouped='('${pcre_word_spaces_and_args_zsh_optional}')'

    #FUXME: Subtly broken. Why? Because combining ${pcre_word_spaces_optional}
    #with ${pcre_word_passable_with_parens_balanced} permits otherwise impermissible lexical combinations: in
    #particular, " { ". Such combinations *MUST* be prohibited here. Note,
    #also, that we probably have a similar problem anywhere else that we've
    #combined words with spaces. We'll probably want to grep about for other
    #instances of such error.
    #
    #The simplest fix would be to prefix ${pcre_brace_left} be negative
    #lookbehind prohibiting "{" preceded by whitespace. No; that doesn't work,
    #because of line continuations. Hmmm; so, we need to refine
    #${pcre_word_unquoted} to prevent such PCRE from matching either a lone "{"
    #or lone "}". Hmmm; but that doesn't seem quite precise enough. Here's what
    #we need to handle: if at least one horizontal whitespace character is
    #matched, the following character *CANNOT* be a "{".
    #
    #O.K.; it really does seem that ${pcre_word_unquoted} should prohibit "{"
    #as the first character and "}" as the last. That would probably solve all
    #issues with the current approach, yes?
    #
    #Wrong. We want to improve ${pcre_word_passable_with_parens_balanced} such that only the first and
    #last if any words are constrained to prohibit an unquoted prefixing "{" or
    #suffixing "}" from being matched.

    # local pcre_args_zsh=${pcre_word_passable_with_parens_balanced}'(?:'${pcre_word_spaces_optional}${pcre_word_passable_with_parens_balanced}')*'
    # local pcre_word_unquoted='(?:'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'
    # local pcre_words_unquoted=${pcre_words_unquoted}'+'
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    # local char_not_subword_unquoted_with_parens_balanced=${char_space}'''"$<>|`'

    # For subtle reasons, this includes the conditionally shell-reserved
    # character "}" but *NOT* "{". "{" is only shell-reserved when preceded by
    # horizontal whitespace; "}" is only shell-reserved when followed by
    # horizontal whitespace. Since this class is only interpolated into
    # negative character classes, such classes exclude horizontal whitespace
    # and hence "{" as a shell-reserved character. Hence, "{" need (and indeed
    # *MUST*) not be listed in this class. "}", however, *MUST* be explicitly
    # listed here and then subsequently matched outside such classes when *NOT*
    # suffixed by horizontal whitespace. (Oh, shell life is complicated.)
    # local char_not_subword_unquoted_with_parens_balanced=${char_space}'''"$}<>|`'

  # Ideally, this includes all strings passable
    # as a standard argument to a zsh command.
    # local pcre_word_passable_with_parens_balanced='(?:[^'${char_not_subword_unquoted_with_parens_balanced}'{]|'${pcre_embeddable_or_quotes}')(?:(?:[^'${char_not_subword_unquoted_with_parens_balanced}'}]|'${pcre_embeddable_or_quotes}'))?'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_first}'(?:'${pcre_word_middle}'*'${pcre_word_last}')?'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_passable_with_parens_balanced}'+'

    # local pcre_word_unquoted='[^'${char_not_subword_unquoted_with_parens_balanced}']++|'${pcre_brace_right}
    # local  pcre_word_first_unquoted='[^'${char_not_subword_unquoted_with_parens_balanced}'{][^'${char_not_subword_unquoted_with_parens_balanced}']*+'
    # local pcre_word_middle_unquoted='[^'${char_not_subword_unquoted_with_parens_balanced}']++'
    # local   pcre_word_last_unquoted='[^'${char_not_subword_unquoted_with_parens_balanced}']*+[^'${char_not_subword_unquoted_with_parens_balanced}'}]'

    # local pcre_word_passable_with_parens_balanced='(?:'${pcre_word_unquoted}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'

    #FUXME: We're probably going to have issues with possessiveness here. Why?
    #Because ${pcre_continuable_spaces_horizontal} matches horizontal whitespace possessively,
    #preventing backtracking if the non-whitespace following such whitespace
    #constitutes a valid block argument. That's bad.

    # PCRE unconditionally reporting failure.
    # ZESHY__PCRE_REPORT_FAILURE

    #FUXME: Use in ={frontend.zy}, replacing current glob usage.

# PCRE fragment prefixing ${ZESHY_MACRO_PCRE} the PCRE defined by
# ::preprocessor_pcres.make_if_needed() matching zero or more macros *OR*
# syntactic constructs possibly containing macro-like substrings.

    # ZESHY_MACRO_ARG_BLOCK_NEXT_PCRE=
    # local pcre_macro_name_grouped_lookahead='(?=([^'${char_space}'\\]++)'

    # Character class matching invalid characters in macro names during
    # positive lookahead capturing such names. While we could simply replace
    # this class by embedding ${ZESHY__MACRO_NAME_VALID_PCRE} instead, the
    # former is considerably shorter and hence more efficient than the latter.

    #FUXME: Actually use such class in lookahead below.

    # local pcre_not_macro_name_lookahead=${char_space}'\\'

#  Since macro names are necessarily
    # unquoted *AND* since the first character of unquoted shell words are
    # constrained by additional 
    #
    # This omits characters only conditionally valid in certain positions
    # of macro names (e.g., "~", valid everywhere *EXCEPT* as the first
    # character of such names).

    # Character class matching invalid characters in macro names, comprising
    # all PCRE- *AND* shell-reserved characters. Since PCRE-reserved characters
    # in macro names *COULD* technically be explicitly escaped, only shell-
    # reserved characters need to be prohibited. For simplicity, we currently
    # prohibit both classes of characters.
    # local char_not_macro_name=${char_space}'''"*+?!#^$(){}[]<>&|\\`'

    # Technically, "(" and ")" are also only conditionally shell-reserved.
    # Nonetheless, prohibit both for simplicity.

    #FUXME: Make sure we're not using "\h", "\v", or "\s" anywhere anymore.
    #FUXME: Globalize.

    # PCRE fragment prefixing ${ZESHY_MACRO_PCRE}, matching zero or more macros
    # *OR* syntactic constructs possibly containing macro-like substrings.
    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE_PREFUX=${pcre_options_anchored}${pcre_word_spaces_and_args_zsh_optional_grouped}${pcre_macro_arg_block}${ZESHY__MACRO_SUBROUTINES}

    # PCRE matching macro *OR* syntactic construct possibly containing
    # macro-like substrings. In the former case, such macro's name and all
    # passed arguments will be captured.
    # ZESHY_MACRO_PCRE=${pcre_macros_grouped_report_success_or_codes_report_failure}

# PCRE subroutines defined below, concatenated in a manner preventing such
# definitions from either matching *OR* capturing in place.
#
# Much like programmatic subroutines, PCRE subroutine are self-consistent units
# preserving a semblance of local scope; for example, PCRE subroutines prevent
# substrings captured by such calls from leaking to callers (e.g., subroutines,
# zsh code) by snapshotting the state of all captured substrings on entering
# such call and restoring such state on leaving such call. In other words,
# subroutines impose non-negligible time and space costs.
#
# For efficiency, subroutines should be leveraged *ONLY* where required.
# Typically, this means recursion matching delimiter-balanced syntactic
# constructs in a context-free manner. In all other cases, PCREs should be
# encapsulated as string variables and interpolated directly where used.
# typeset -g ZESHY__MACRO_SUBROUTINES

#  For
    # further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
# All PCRE subroutines defined below, concatenated in a manner preventing such
# definitions from matching. Such subroutines remain callable and hence are
# defined only for recursion purposes.

    # If *NO* macros were previously registered, clear the prior PCRE to
    # prevent spurious or scurrilous preprocessor behaviour.
    # (( ZESHY__MACRO_TO_FUNC_NAME )) || pcre_macro_or_code_optional_grouped=

    # Macro *OR* comment possibly containing zsh syntax-like substrings.
    # local pcre_macro_grouped_report_success_or_comment_optional=${pcre_macro_prefix}'(?:'${pcre_comment}'|'${pcre_macro_grouped_report_success}')?'

    # Macro, comprising such macro's name and all passed arguments. Since the
    # macro prefix is zero or more horizontal whitespace characters anchored to
    # the start of a line, such prefix is identical to a comment prefix and
    # hence matched below for both macros and comments.
    # local pcre_macro_grouped_report_success=${pcre_macro_name_grouped}${ZESHY__MACRO_ARGS_OPTIONAL_REPORT_SUCCESS}

    # local pcre_macros_grouped_report_success_or_codes_report_failure='(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_macro_grouped_report_success_or_comment_optional}'|'${pcre_code}'|.)*'${pcre_report_failure}

    # For efficiency, success is reported immediately after matching such
    # macro's last character (e.g., the last character of the last argument
    # passed to such macro). To distinguish syntactically valid from invalid
    # macros, *ALL* macro-specific substrings following such name are optional.

    # and :list.join_to_string_on_char().
    #FUXME: O.K.; technically, this works. But it's *SUPER* inefficient.
    #Why? Because it forces pcre_match() calls *NOT* matching a macro te be
    #ignored and simply iterated past. This is horrible, and should be
    #correctable. (Or... maybe not. Contemplate further.)
    #FUXME: Actually, this is erroneous! "^" and "$" are zero-width assertions
    #consuming no characters. Hence, we'll need to manually consume newlines.
    #Sadly, we've probably screwed this up above as well, where we're matching
    #argument block prefixes and suffixes. (Oh, and here-docs!)
    #FUXME: We're also fairly sure that newlines are *NOT* matched properly. A
    #concrete example: blank lines (i.e., "\n\n"). Do we match that?
    #FUXME: Split "${pcre_line_start_or_spaces_horizontal_spaces}'(?:'${pcre_comment}')?"
    #into a new PCRE above.

    # local pcre_macro_or_code_optional_grouped='(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped_optional}'|'${pcre_macro_or_comment_optional_grouped}'|'${pcre_code}'|.)'

# For efficiency, match such macro's prefix below.
    # , where we may more efficiently match both
    # macros and comments.

    #FUXME: Use of ${pcre_spaces_horizontal_optional} both here and below is
    #probably erroneous.

    # Since the "." in ${pcre_here_doc_body} matches newlines, zero-width
    # assertions "^" and "$" are acceptable here.

    #FUXME: Use in place of "\v" below. *sigh*

    # By design, there exists no comparable PCRE local ${pcre_line_end} (i.e.,
    # matching the end of the current line, consuming the suffixing vertical
    # whitespace character if any). Since this PCRE consumes newlines,
    # permitting another general-purpose PCRE to consume newlines would
    # prevent this PCRE from matching in a general-purpose manner. (Not good.)

    # local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    # local pcre_word_spaces_prefixed_by_spaces_optional='\h*+(?:'${pcre_line_continuation}'\h*+)*'

    #FUXME: Optimizable. By the above ${pcre_words_spaces} technique, such
    #alternation may be improved by noting that ${pcre_args_zsh} and
    #${pcre_macro_arg_block} *MUST* always alternate.
    # local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_continuable_spaces_horizontal}'(?:'${pcre_args_zsh}'|'${pcre_macro_arg_block}')*)'

    # One or more command-specific whitespace sequences. Since line
    # continuations are merely ignorable rather than actual whitespace, match
    # at least one horizontal whitespace character. Interestingly, this
    # constraint engenders a simpler and presumably more efficient PCRE.
    #FUXME: Hmm. Don't we usually implicitly match prefixing line continuations
    #now by use of ${pcre_char_escaped_optional}? Where doing so, replace use of this
    #PCRE by the slightly more efficient
    #${pcre_word_spaces_prefixed_by_spaces_optional} instead.

#  Technically, this
    # PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.
    # local pcre_word_spaces_optional='(?:\h*+'${pcre_line_continuation_optional}')*'

    #FUXME: We used to have "\h" in character classes here; now we effectively
    #have "\s", thus matching line continuations. While probably not a terrible
    #thing, this does seem slightly inefficient, given that
    #${pcre_macro_arg_block_or_comment_optional} *ALSO* attempts to match such
    #continuations
    #FUXME: O.K.; the core issue at hand is that
    #${pcre_macro_arg_block_or_comment_optional} is prefixed by
    #${pcre_continuable_spaces_horizontal}, itself prefixed by
    #${pcre_line_continuations_optional}, which is unnecessary in this case and
    #*ONLY* this case.

    #FUXME: Honestly, when in reality would we *EVER* see adjacent line
    #continuations? While we of course need to match such edge case, explicitly
    #optimizing for it as we do so here strikes us as useless. Supplant all use
    #of either of the following two PCREs by their singular versions above.

    # local pcre_continuable_spaces_horizontal='(?:'${pcre_line_continuations_optional}'\h++)+'${pcre_line_continuations_optional}
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}${pcre_word_spaces_prefixed_by_spaces}
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    #FUXME: Hmm. Don't we *ALWAYS* implicitly match prefixing line
    #continuations now by use of ${pcre_char_escaped_optional}? If so, this PCRE is
    #excisable and ${pcre_word_spaces_optional} reducible to:
    #
    #    local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}')?'
    #
    #We probably want to drop the "_prefixed_by_spaces", as well.
    #FUXME: Actually, since the PCRE above is the common case and the PCRE
    #below the edge case, consider just eliminating the PCRE below and instead
    #defining ${pcre_word_spaces_optional} as follows:
    #
    #    local pcre_word_spaces_prefixed_by_spaces='\h++(?:'${pcre_line_continuation_optional}'\h*+)*'

    # One or more command-specific whitespace sequences, prefixed by at least
    # one line continuation.
    # local pcre_word_spaces_prefixed_by_line_continuations=${pcre_line_continuations}'(?:\h++'${pcre_line_continuations}')*\h*+'

    #FUXME: This strikes us as increasingly absurdly overwrought. Reconsider.
       # local pcre_word_spaces_prefixed_by_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}')?'

    #FUXME: O.K.; so we're not necessarily convinced that lookbehinds are
    #sufficient to match line continuations. Consider:
    #
    #    # Not a line continuation, due to being commented out.
    #    >>> # \
    #
    #We need to closely examine where we're using such continuations.
    # local pcre_line_continuation='(?<!\\)\\\v'

    # End of the current line, consuming the suffixing vertical whitespace
    # character if any. "$" is a zero-width assertion consuming no characters
    # and hence inappropriate for most uses below (excluding lookahead).
    # local pcre_line_end='(\v|\z)'

# (Disambiguating the two requires explicitly matching both.)
    # PCRE capturing the macro name and all block argument bodies in a
    # preprocessor macro. To distinguish syntactically valid from invalid
    # preprocessor macros, all syntax following the macro name is optional.

    # '\h++(?:'${pcre_line_continuations}'\h++)*'${pcre_line_continuations_optional}
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h++'${pcre_word_spaces_optional}

    # Zero or more command-specific whitespace sequences (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # most whitespace but excluding unescaped newlines (i.e., newlines *NOT*
    # prefixed by "\"). While escaped newlines are line continuations
    # preserving the current command and hence effectively whitespace,
    # unprefixed newlines are effectively semicolons terminating such command.
    #
    # Technically, this PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.
    # local pcre_word_spaces_optional='(?:\h++(?:'${pcre_line_continuations}'\h++)*'${pcre_line_continuations_optional}'|'${pcre_line_continuations}'(?:\h++'${pcre_line_continuations}')*\h*+)?'

    # local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h++'${pcre_word_spaces_optional}

#  (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # all whitespace except newlines *NOT* prefixed by "\". While "\"-prefixed
    # newlines are line continuations preserving the current command,
    # unprefixed newlines are effectively semicolons terminating such command
    #FUXME: Refactor inefficient negative character classes as follows both
    #here and below, wherever applied:

    #FUXME: Not quite. We need to ignore everything after a comment prefix "#"
    #until the end of the line, as well. Unfortunately, differentiating such
    #prefix from "#" characters embedded in other contents (e.g., variable
    #expansions, unquoted globs) is *HIGHLY* non-trivial.
    #
    #Actually, it shouldn't be. zsh comments should *ALWAYS* unconditionally be
    #detectable by being prefixed by either the start of the line *OR*
    #non-empty horizontal whitespace (assuming strings to be properly matched,
    #anyway). That doesn't appear to be the case for all other uses of "#",
    #which appear to *ALWAYS* be prefixed by something other than what prefixes
    #a comment. Hopefully, there exist no exceptions to such heuristic.
    #
    #Actually, *DO* we need to match comments? Well, yes, technically. Consider
    #the following:
    #
    #    # If we ignore comments, then the " basically causes havoc.
    #    if :is uuugh == u##gh :si { # " uhoh
    #        :macro
    #    }
    #FUXME: The above implies that we need to prevent unquoted "#" characters
    #prefixed by blahblah from being matched into macro argument lists. Such
    #characters *MUST* terminate such lists.

    #FUXME: The above also implies that we *DO* need to ignore double-quoted
    #strings and such as well here, to ensure proper matching of single-quoted
    #strings. Failure to do this *WILL* cause extreme parsing havoc. While this
    #does currently prevent us from embedding macros in process substitutions,
    #it's difficult to conceive of a situation in which we'd want to do so. So,
    #let's do this, execrable though it may be.

    #FUXME: Interesting. We've unrelatedly realized that, since "\"
    #unconditionally escapes the following character, we can reduce all
    #"\\[...]" alternatives to simply ${pcre_char_escaped_optional}, where:
    #    local pcre_char_escaped_optional='\\.'
    #We'll want to make such change everywhere, of course, including above.

# \\["'${char_not_embeddable_prefix}']
# \\[}'${char_not_embeddable_prefix}']
# \\[\]'${char_not_embeddable_prefix}']
# \\[)'${char_not_code_prefix}']
# \\[}'${char_not_code_prefix}']
# \\['${char_not_code_prefix}']
# \\[}'${char_not_code_prefix}']

    #FUXME: Fixmeplz. Actually, we're fairly certain we can excise this such
    #subroutine, convert this back into a PCRE local, and shift above.

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing and hence parsing of unquoted "{" and "}" characters.
    # Unlike shell word matching, this does *NOT* include unquoted characters.
    # pcre_macro_subroutines_body+='(?<code>'${pcre_quotes_single}'|'${pcre_here}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'

#\s)''"$\\<`
    #FUXME: Avoid repetition. We're seeing the following character classes
    #heavily reused. Abstract out to a sensible string local above.

    #FUXME: And comments, please! Wait. Actually, comments probably have to be
    #embedded directly into PCREs below due to matching prefixing whitespace.
    #FUXME: Wait. Can't we just insert comments here and be done with it?
    #FUXME: Substitute me below for all instances of "(?&code)".

    #FUXME: The inefficient subroutine call "(?&code)" matches non-recursive
    #constructs (e.g., single-quoted strings, here-documents, here-strings).
    #Such constructs should simply be matched here with an embedded PCRE.

    # One or more horizontal whitespace characters followed by zero or more
    # such words. If one or more such words match, such words must be suffixed
    # by one or more horizontal whitespace characters.

#  Since the first
    # and last such substrings are constrained to also be shell words,
    # whitespace is permitted only between shell words.
    # Such word *OR* word-delimiting whitespace.
    # local pcre_word_or_spaces='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_continuable_spaces_horizontal}')'

    # Such PCRE interpolates the PCRE matching substitutables and hence must be
    # declared *AFTER* the latter.

    # Here-documents and -strings are *NOT*
    # freely mixable with standard arguments and hence unmatched here.

    # ..................{ MACRO ~ space                      }..................

    #FUXME: We're fairly certain that our comment prefix still isn't quite
    #right. Investigate: are comments immediately prefixed by line
    #continuations comments? We suspect not. That said, the zeshy codebase
    #doesn't currently contain any such monstrosities, so we can probably
    #neglect this.
    #FUXME: We're fairly sure we match line continuations anywhere where we
    #would also match comments. Verify this below.

    #FUXME: Excise this and ${pcre_here_doc_quotes}, when no longer required.
    # local pcre_here_doc_quotes_prefix=${pcre_here_doc_prefix_ignore}'(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}')$'
    # local pcre_here_doc_quotes=${pcre_here_doc_quotes_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    #FUXME: "{" and "}" are *ONLY* shell-reserved when preceded and followed
    #(respectively) by whitespace. This requires correcting. To ascertain a
    #proper fix, examine where this character class is actually used.
    #FUXME: Right. 

#  excluding "}" as a shell-reserved
    # character requires somewhat more finesse. ${pcre_word_unquoted}.
    # local pcre_block_suffix_lookahead='$|'${pcre_continuable_spaces_horizontal}
    #FUXME: Use line continuation PCREs instead, once we correct them.

    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\\v)*)?'

    #FUXME: Use of ${pcre_continuable_spaces_horizontal} is somewhat inefficient here. We only need to
    #match up to the first horizontal whitespace.
    #FUXME: Actually, it's also wrong. As the comment above indicates, such "}"
    #must be suffixed by at least one horizontal whitespace *OR* newline
    #character (optionally preceded by zero or more line continuations).
    # local pcre_line_continuation='(?<!\\)\\\v'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\\v)*)?'
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}

    #FUXME: Shift such "\h++" up into a new comment prefix PCRE.

    # local pcre_macro_arg_block_prefix='\{'
    # local pcre_macro_arg_block_suffix_lookahead=${pcre_continuable_spaces_horizontal}'|\Z'
    # local pcre_macro_arg_block_suffix='\}(?='${pcre_macro_arg_block_suffix_lookahead}')'

#  Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline *NOT* prefixed by an unescaped
    # backslash (i.e., line continuation).
    # excluding the escape prefix "\".
# excluding:
    #
    # * Whitespace characters.
    # * Shell-reserved characters
    #FUXME: Still require ${pcre_embeddable}?

    # local pcre_math_substitution_parens='\((?:\\[\\)$`]|[^)$`]|(?&sub)|(?!\)\)).)*\)'
    # local pcre_math_substitution_braces='\[(?:\\[\\]$`]|[^]$`]|(?&sub)|[^]])*\]'
    # local pcre_var_expansion='\{(?:\\[\\}$`]|[^}$`]|(?&sub)|[^}])*\}'

    #FUXME: Prefixing whitespace will need to be integrated with other PCREs.

    # local pcre_macros_or_code_optional_grouped='\A(?:\\[\v\\''<]|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|[^''<]|'${pcre_quotes_single}'|'${pcre_here_doc_quotes}'|.)*\Z'

    #FUXME: Not quite right. We don't need to confine 
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}
    # local pcre_comment_optional_spaced='\h++'${pcre_comment}

    #FUXME: Comment support, please!
    # local pcre_macro_arg_block_nested=${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}
    # local pcre_comment_optional_spaced='\h++'${pcre_comment}

    # local pcre_macro_arg_block_nested=${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:\\[\\\h}''"$<`]|'${pcre_macro_arg_block_nested}'|[^}''"$<`]|(?&code)|[^}]|\}(?!'${pcre_macro_arg_block_suffix_lookahead}'))*'

    # local pcre_code_or_comment=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here}'|(?&sub)'

    #FUXME: Need to match and ignore comment lines. *sigh*
    #FUXME: Ugh; can't define this here. But we *DO* need to explicitly match
    #here strings. Ah! Right. Simple. All we do is match the "<" and let all
    #following text be matched by other means elsewhere.
    #FUXME: Wait. Not quite true. We match here strings for a variety of
    #purposes. We'll need to shift this below and come up with something else
    #here. New nomenclature would help.

    # local pcre_quotes_double_prefix='"(?:\\[\\"$`]|[^"$`]|'
    # local pcre_quotes_double_suffix='|[^"])*"'
    # local pcre_quotes_double=${pcre_quotes_double_prefix}${pcre_embeddable}${pcre_quotes_double_suffix}
    # local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}${pcre_embeddable_noncode}${pcre_quotes_double_suffix}

#  Unlike shell word matching, this does *NOT* include
    # unquoted characters.
#  and hence parsing of unquoted "{" and "}" characters
    # Single- or double-quoted string.
    # local pcre_quotes_optional=${pcre_quotes_single}'|'${pcre_quotes_double}

    #FUXME: Also omit embedded substitutions. For that reason, rename
    #"_literal" to "_literal" globally.

    #FUXME: O.K.; so, we mucked this up a bit. For both generality and
    #efficiency, replace *ALL* instances of "\R" (and ideally of "\v" as well,
    #though that naturally doesn't apply to negative character classes) by:
    #
    #* End-of-line assertion "$".
    #* Enable multiline mode with "(?m)" above.

    #FUXME: Slightly erroneous. We make the dangerous assumption in
    #::code.preprocess() that such PCRE matches only ASCII characters. Clearly,
    #however, both "\h" and "\R" match multibyte characters. To correct this
    #discrepancy, we'll want to match only the explicit ASCII characters
    #satisfying horizontal and vertical whitespace requirements in a
    #cross-platform portable manner (think Windows line endings) *AND* replace
    #all instances of "\h" and "\R" below by similar constructs.
    #
    #Unfortunately, "libpcre" documentation notes that:
    #
    #"The choice of newline convention does not affect the interpretation of
    # the \n or \r escape sequences or \R." This implies we'll need to:
    #
    # * Test the OS already detected by ={inspect}.
    # * Define a new string local ${pcre_newline} expanding to the OS-specific
    #   PCRE matching newlines.
    #
    # Annoying, but certainly feasible. For now, the current implementation
    # appears to be basically acceptable.

    #FUXME: A minor issue. If ${ZESHY__MACRO_NAMES} is empty, the resulting
    #PCRE will match in a fairly disastrous manner. Guard against such inept
    #edge cases, please.

    #FUXME: Incorrect. We want to ignore preceding newlines prefixed by "\"
    #(i.e., line continuations). Hence, explicitly match line continuations in
    #the PCRE immediately above.

    #FUXME: ${pcre_line_continuations_optional} is somewhat inefficient here.
    #By PCRE definition, we should't need to lookbehind. Or perhaps we do still
    #need lookbehind? It's either that or lookahead. Hm; honestly, cutting
    #${${pcre_line_continuations_optional}} *ENTIRELY* and then prefixing
    #${pcre_macro_prefix} by a negative lookbehind assertion ensuring such
    #newline to *NOT* be preceded by an unescaped backslash seems like the
    #somewhat simpler and hence more efficient implementation, yes?
#(?!'${pcre_macro_arg_block_suffix}')
# ${pcre_continuable_spaces_horizontal}${pcre_macro_arg_block_prefix}'|'

#(?!<<)(?:
#'${pcre_line_continuations_optional}'|
    #FUXME: Implement me for use below.
    # local pcre_here_string_quotes_single='<\s*+'${pcre_word_passable_with_parens_balanced}

    # local pcre_zsh_grouped='(?:'${pcre_line_continuations_optional}'|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|(?!<<)(?:[^'']|'${pcre_quotes_single}'|.))*'

# local pcre_line_continuations_optional='(?<!\\)(?:\\\R)*'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}')*'

    #FUXME: Improve similar negative lookahead assertions elsewhere.

    #FUXME: Honestly, "(?!<<)" seems a bit silly. Ideally, since neither
    #here-documents or strings are recursive, such substrings should be matched
    #by an embedded PCRE here rather than a subroutine call.

    # local pcre_math_substitution=${pcre_math_substitution_parens}'|'${pcre_math_substitution_braces}
    #FUXME: For efficiency, combine this with ${pcre_math_substitution_parens}.

    #FUXME: Sadly, we're fairly confident we need to back out most subroutine
    #calls below. The reason, of course, is inefficiency. PCRE appears to treat
    #subroutines as genuine boundaries for certain purposes; in particular,
    #PCRE copies all match groups prior to a subroutine call and then restores
    #such groups after such call. Hence, while subroutines are a fantastic
    #means of enabling recursion *AND* isolating match groups, they should be
    #avoided for all other purposes. Since we extensively leverage recursion
    #below, we *DO* need to retain subroutine support -- but only for these
    #specific purposes.

#FUXME: We should probably augment such PCREs to also capture optional here-
#documents and -strings passed to such macros and then pass either sort of
#string to such macro function on standard input as a simple here-string. The
#current approach is rather kludgy, it should be admitted. It's also not
#terribly general; after all, macros should be able to modify their output
#based on whether or not they were passed standard input as well as the exact
#content of that input. (It's only sensible, and not terribly difficult to
#implement, given current here-document and -string syntax support.)

    #FUXME: Not right either here or below. All PCRE fragments of the form
    #"[^"$`]|(?&sub)" *NEED* to be switched to
    #"(?&sub)|[^"]". Simple, thankfully.
    #FUXME: Actually, we can achieve the best of both worlds as follows:
    #    [^"$`]|(?&sub)|[^"]

    # local pcre_macro_arg_block_prefix='\{'${pcre_continuable_spaces_horizontal}''
    # local pcre_macro_arg_block_suffix=${pcre_continuable_spaces_horizontal}'\}(?:'${pcre_continuable_spaces_horizontal}'|\Z)'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')*'
    # local pcre_macro_arg_block_nested=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_nested_body}${pcre_macro_arg_block_suffix}
    # pcre_macro_subroutines_body+='(?<block>'${pcre_macro_arg_block_nested}')'

    # pcre_macro_subroutines_body+='(?<macro>'${(j:|:)ZESHY__MACRO_NAMES}')'

    # local pcre_math_substitution='(?:'${pcre_math_substitution_parens}'|'${pcre_math_substitution_braces}')'

    #FUXME: Pointless. Excise, please.

    # Non-recursive variable expansion *OR* a literal "$" character. To match
    # the latter, match zero or more such characters. See
    # ${ZESHY_VAR_NAME_GLOB}.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    # local pcre_var_expansion_nonrecursive='[a-zA-Z_][a-zA-Z0-9_]*+'

    # Variable expansion.
    # local pcre_var_expansion='(?:'${pcre_var_expansion_nonrecursive}'|'${pcre_var_expansion_recursive}')'

    #FUXME: We probably expand such locals above. Correct circularities.
    #FUXME: Shift back above, actually.

    # local pcre_here_unsubstitutable='(?:'${pcre_here_prefix}${pcre_here}')?'

    #FUXME: Fairly certain that, as currently defined, this will erroneously
    #match *ALL* block arguments in the current code rather than merely those
    #passed to the current macro. Why? Because we haven't anchored the start of
    #such PCRE to the end of the prior iterative match. While we can't quite
    #recall how to go about such anchoring, we suspect that PCRE documentation
    #for pcre_match() should lend some insight.

# '${pcre_quotes_optional}'|'${pcre_here}'|

    #FUXME: Convert to a conventional PCRE variable.
    #FUXME: Actually, we no longer need this at all. We never did! Rather than
    #calling the "(?&dollar)" subroutine in
    #${pcre_process_substitution_dollar_nonrecursive}, simply call the conventional
    #"(?&sub)" subroutine preceded by negative lookahead preventing a backtick
    #from matching. Since this form of process substitution is heavily
    #discouraged anyway, efficiency is of little to no concern.

    # Any of the above "$"-prefixed syntactic constructs.
    # local pcre_dollar_construct+=

    #FUXME: Woops. Wherever we match an escaped character (e.g., "\\[)]"), we
    #need to match a an escaped "\\" *BEFORE* matching such character. Why?
    #Consider "$(( \\))". This is (sort of, anyway!) a balanced arithmetic
    #expansion and must be treated as such.
    # local pcre_backslash_escaped='\\\\'

    # When applied in an iterative context,  
    # of the first
    # byte following the last byte of the prior match. 

    #    :func :void :outer1() {
    #         :func :void :mid1() {
    #         }
    #    }
    #
    #    :func :void :outer2() {
    #         :func :void :mid2() {
    #             :func :void :inner1() {
    #             }
    #         } {
    #             :func :void :inner2() {
    #             }
    #         } <<'/---
    #    /---
    #         :func :void :mid3() {
    #             :func :void :inner3() {
    #             }
    #         } {
    #             :func :void :inner4() {
    #             }
    #         } <<'/---
    #    /---
    #    } <<'/---
    #    /---

    #FUXME: Not quite right. Rather than ineptly trying to coerce
    #${pcre_args_zsh} and ${pcre_continuable_spaces_horizontal} together, we probably
    #probably want a new PCRE adroitly aggregating both.
    # local pcre_word_spaces_words_optional_grouped='('${pcre_continuable_spaces_horizontal}'(?:'${pcre_args_zsh}${pcre_continuable_spaces_horizontal}')?)'

    # local pcre_args_zsh=${pcre_word_passable_with_parens_balanced}'(?:'$pcre_word_or_spaces'*'${pcre_word_passable_with_parens_balanced}')?'
    # local pcre_args_zsh='(?:'${pcre_word_passable_with_parens_balanced}'(?:(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_continuable_spaces_horizontal}')*'${pcre_continuable_spaces_horizontal}')?)?'

    # Such PCRE implicitly requires backtracking and hence cannot be optimized
    # with atomic grouping.
    # local pcre_continuable_spaces_horizontal='(?:\h|\\\R)*\h(?:\h|\\\R)*'

        # ZESHY_MACRO_MATCH_INDEX_HERE_DOC_OR_STRING
    # local pcre_args_zsh='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_continuable_spaces_horizontal}')*'${pcre_word_passable_with_parens_balanced}

    #FUXME: We've mucked up, it would appear. Expansions of ${pcre_word_passable_with_parens_balanced}
    #should have been expansions of this PCRE. (Ugh.)

    # local pcre_macro_args_optional_grouped='('${pcre_macro_args_optional}')'

    # To do so, append such definitions to ${pcre_macro_subroutines_body}
    # and, after doing so, prefix and suffix ${pcre_macro_subroutines_body} by the prefix
    # and suffix defined below below.  and then interpolate such string into a PCRE guaranteed to
    # never match and hence capture.

    # supports such behaviour by ignoring
    # all content aside from defining named and numbered capturing
    # groups in such content.

# efficiency and readability purposes.
    # pcre_macro_subroutines_body+='(?<quote>'${pcre_quotes_single}'|'${pcre_quotes_double}')'

    # Declare indices matched by ${ZESHY_MACRO_PCRE}, ignoring match groups
    # required only for internal use in such PCRE -- including:
    #
    # * Match group 1, capturing prefixing indentation.
    # match_index=2

    #To do so, see the section "Newline conventions" in "man pcrepattern".
    #Specifically, to quote:
    #
    #"It is also possible to specify a newline convention by starting a  pat-
    # tern string with one of the following five sequences:
    #
    #    (*CR)        carriage return
    #    (*LF)        linefeed
    #    (*CRLF)      carriage return, followed by linefeed
    #    (*ANYCRLF)   any of the three above
    #    (*ANY)       all Unicode newline sequences"
    #prepend the appropriate pattern option to the PCRE globals we construct
    #below.

    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'

    #FUXME: Replace subroutine calls called in only one place with low-level
    #variable expansions.
    #FUXME: Compress PCREs together. For example, we don't benefit from
    #separate ${pcre_macro_arg} and ${pcre_macro_args} PCREs.

    #FUXME: Capture block arguments. 
    #FUXME: Define match index globals. This is going to considerably more
    #troublesome than it otherwise would, due to each named group being
    #unconditionally captured. We'll have to ignore all such groups in a sane
    #way -- probably by incrementing in integer local here immediately after
    #defining any ignorable named group (which will be most if not all of them).

    # ZESHY_MACRO_PCRE=${pcre_macro_indentation}${pcre_macro_name}${pcre_macro_args_optional_grouped}${pcre_subroutines}

    #FUXME: Convert ${pcre_macro_arg_block} into a subroutine.

    # Zero or more arguments of any type. Since we match a run of shell words
    # greedily, avoid matching consecutive runs of shell words for efficiency.

    # local pcre_macro_args_optional='(?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'(?:(?&spaces)'${pcre_macro_arg_block}')?|'${pcre_macro_arg_block}'))*'

    #FUXME: This may be optimizable by noting that ${pcre_word_passable_with_parens_balanced}
    #matches greedily and hence cannot by definition match consecutively.
    # local pcre_macro_args_optional_grouped='((?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'))*)'

# local pcre_macro_args_optional_grouped='((?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block}'|'${pcre_word_passable_with_parens_balanced}'(?&spaces))?'${pcre_macro_arg_block}'))*)'
    # Zero or more runs of whitespace or shells words ending in a shell word.
    # local pcre_words_optional='(?:'${pcre_word_passable_with_parens_balanced}')?'

    # Argument of any type prefixed by one or more horizontal whitespace
    # characters followed by zero or more shell words.
    # local         pcre_macro_arg=${pcre_macro_arg_block}
    # local pcre_macro_arg_grouped=''${pcre_continuable_spaces_horizontal}''${pcre_words_optional}${pcre_macro_arg_block_grouped}

#matched from a previously captured macro argument list
#''${pcre_continuable_spaces_horizontal}''
    #FUXME: For efficiency, split the "'${pcre_continuable_spaces_horizontal}'" prefixing each such PCRE out
    #into this PCRE instead.

    # local pcre_macro_arg_block_prefix=''${pcre_continuable_spaces_horizontal}'\{(?&spaces)'
    # local    pcre_macro_arg_block_nested_prefix='\{'${pcre_continuable_spaces_horizontal}''

    # local        pcre_macro_arg_block_suffix=''${pcre_continuable_spaces_horizontal}'\}(?:(?&spaces)|\Z)'
    # local pcre_macro_arg_block_nested_suffix=''${pcre_continuable_spaces_horizontal}'\}(?&spaces)'

    # local pcre_word_passable_with_parens_balanced=''${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|(?&spaces))*(?&word)'

    #FUXME: Define all remaining ${ZESHY_MACRO_MATCH_INDEX_ARG_*} globals.

        # ZESHY_MACRO_MATCH_INDEX_ARG_1
        # ZESHY_MACRO_MATCH_INDEX_ARG_2
        # ZESHY_MACRO_MATCH_INDEX_ARG_3

    # local        pcre_macro_arg_block_nested_body='(?<blockb>(?:'${pcre_continuable_spaces_horizontal}'(?&block)?|\\[''"$`<]|(?!<<)[^''"$`]|(?&code))*'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')'

    # local        pcre_macro_arg_block_body='(?:'${pcre_continuable_spaces_horizontal}'(?&block)?|\\[''"$`<]|(?!<<)[^)''"$`]|(?&code))*?'
    # local pcre_macro_arg_block_nested_body=${pcre_macro_arg_block_body}

 # While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    # Macro indentation. Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline.
    #
    # Since such indentation is guaranteed to be the first match group, we
    # match such indentation with numbered back references (e.g., "\g1").
    # local pcre_macro_indentation_grouped='(\R\h*+)'

    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros. Since such macros
    # are currently matched solely by prefixing indentation regardless of zsh
    # context (i.e., ignoring string literals, variable expansions, and other
    # syntactic constructs), the "}" delimiting such argument is also matched
    # solely by the same prefixing indentation.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, merely assert this constraint with positive lookahead.
    # local pcre_macro_arg_block_prefix=''${pcre_continuable_spaces_horizontal}'\{(?&spaces)'
    # local pcre_macro_arg_block_body='.*?'
    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'
    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_continuable_spaces_horizontal}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_continuable_spaces_horizontal}'|\Z)'
    # local pcre_macro_arg_block_suffix_ahead='\g1\}(?='${pcre_continuable_spaces_horizontal}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

#         ZESHY_MACRO_MATCH_INDEX_ARGS_END
# ${pcre_empty_group}
    # local pcre_macro_args_optional_grouped='(?:(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block_grouped}')((?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block_grouped}')*))?'

        # ZESHY_MACRO_MATCH_INDEX_ARG_1
        # ZESHY_MACRO_MATCH_INDEX_ARGS_2_OR_MORE

    #FUXME: Not quote right. We require spaces after a macro name *AND* before
    #a "{", but we can only match such spaces once. How?

    # '(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block_grouped}')*'
    # '(?:'${pcre_macro_args_optional_grouped}')?'${pcre_subroutines}
    # ZESHY_MACRO_PCRE=${pcre_macro_indentation_grouped}${pcre_macro_name}'(?:'${pcre_continuable_spaces_horizontal}${pcre_macro_args_grouped}')?'${pcre_subroutines}

    # One or more runs of whitespace or shells words both initiating and
    # terminating in a shell word.
    #
    # The former condition is purely an optimization concern. The latter
    # condition, however, is not; it prevents this PCRE from matching
    # substrings ending in a run of whitespace, ensuring such whitespace will

    #FUXME: Such subroutines are embedded only in the following PCRE fragment:
    #    (?=\$)(?:(?&var)|(?&math)|(?&proc))
    #Hence, simplify this by refactoring this and the other subroutines into
    #PCREs and embedding them directly in a new subroutine <dollar>.

    #FUXME: Insufficient, as it currently fails to match multiple adjacent line
    #continuations. Hmmm.

    # pcre_macro_subroutines_body+='(?<spaces>(?:\\\R)?(?:\h++(?:\\\R)?)+)'

    #FUXME: Such "}" must be matched as prefixed by a newline (\R) followed by
    #the same exact horizontal whitespace as the initial macro. We currently
    #match this as named group "(?&indent)" below. Such group *MUST* contain
    #such newline.

# (?=\$)(?:(?&var)|(?&math)|(?&proc))

    #FUXME: Match the same embedded constructs as above.
    #FUXME: Perhaps simpler to replicate the definition of
    #${pcre_process_sub_recursive} here, augmented with a negative lookahead
    #assertion to prevent matching of an unescaped "`". Ignore for now;
    #somewhat too much complexity, here!

    # local pcre_process_substitution_dollar_nonrecursive='`(?:\\[''"$`<]|(?!<<)[^''"$`]|(&squote)|(&dquote)|(&here)|(?=\$)(?:(?&var)|(?&math)|(?&proc)))*`'

    # Unquoted shell word.
    # pcre_macro_subroutines_body+='(?<uword>[^\s'${char_not_subword_unquoted_with_parens_balanced}']++)'

    # Character class matching shell-reserved characters.
    # local char_not_subword_unquoted_with_parens_balanced='''"$<>{}|`'
    # local pcre_word_literal='[^\s\\'${char_not_subword_unquoted_with_parens_balanced}']++'

    #FUXME: For each named subroutine below, we need to directly embed the
    #definition of such subroutine somewhere in ${ZESHY_MACRO_PCRE} --
    #ideally, before the first call to such subroutine in such PCRE. (Yes, this
    #is somewhat annoying.)

    # Suffix suffixing all subroutines defined below, preventing such
    # subroutines from matching. Since such subroutines remain callable, To ensure this:
    #
    # * Suffix each subroutine definition by a suffix guaranteeing such
    #   definition to never match.

    # local pcre_subroutine_suffix='{0}'

    # As in Perl (but not Ruby), "libpcre" subroutine calls (e.g.,
    # "(?&soma)") do *NOT* capture the substring matched by such call if any.
    # As in both Perl and Ruby, subroutine definitions (e.g.,
    # "(?<soma>All the advantages of Christianity and alcohol; none of their defects.)"
    # capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is somewhat
    # noxious. In most cases, we would prefer such definitions to *NOT*
    # capture. Unfortunately, we have little alternative but to ignore the
    # groups captured by such matches.
    #
    # To facilitate this, increment ${match_count_ignore} (an integer local
    # counting the total number of ignorable match groups) after every
    # subroutine defined below.

    #FUXME: We had a reasonably clever idea. Will it work? Only CLI testing
    #will demonstrate the feasibility of the idea. If it *DOES* work, that'd be
    #reasonably awesome. So, what's the idea? Since subroutine definitions
    #implicitly capture *AND* since that's bad, shift all such definitions past
    #the valid end of the PCRE (e.g., "$") into a region guaranteed *NOT* to
    #match, reserved for only defining subroutines. Such subroutines would
    #never be matched as definitions but only called, avoiding all such
    #capturing issues.
    #FUXME: Sweet. Both of the following work as advertised:
    #
    #    >>> :is yum =~ '(?&yam)(?<yam>yum){0}' :si and print ok
    #    ok
    #    >>> :is yum =~ '(?<yam>yum){0}(?&yam)' :si and print ok
    #    ok
    #
    #Subroutine definitions suffixed by "{0}" are thus guaranteed to never
    #match and hence capture. Fairly awesome!

    #FUXME: Suffix all subroutines defined below by such PCRE fragment.

    # # Declare indices matched by ${ZESHY_MACRO_PCRE}.
    # match_index=1

    # #FUXME: Correct names.
    # # Declare indices preceding the first ignorable match group.
    # for match_index_name (
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_NAME
    # ) {
    #     integer -g ${match_index_name}=$(( match_index++ ))
    #     print -r ${match_index_name}': '${(P)match_index_name}
    # }

    # # Increment the index of the next ignorable match group past all
    # # intermediate match groups.
    # match_index+=${match_count_ignore}

    # #FUXME: Declare subsequent groups.

    # integer match_count_ignore=0
    # match_count_ignore+=1

 # Right? Wrong. There appears to be a bug in either
    #"libpcre" or zsh (...guess which, presumably?) forcing
    # local pcre_continuable_spaces_horizontal='(?:\h|\\\R)++'

 # all macros (including names and block arguments) in
    # arbitrary code.

    #FUXME: Use of named references complicates match indexing. I beliewe we
    #can circumvent this, however, by leveraging named subroutines: that is,
    #declaring *ALL* named references at the very end of the regex.

    # # Argument of any type.
    # local pcre_macro_arg='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}')'

    # # One or more arguments of any type.
    # local pcre_macro_args=${pcre_macro_arg}'+'

    #FUXME: This still used? Probably... not.

    # One or more arbitrary characters excluding shell-reserved characters.
    # local pcre_chars_unreserved='(?:\\\R|[^\v'${char_class_ureserved}'])++'

    # ZESHY__MACRO_NAMES_PCRE
    # ZESHY__MACRO_NAMES_PCRE=${}

    #FUXME: Excise me.

    # One or more whitespace-delimited shells words.
    # local pcre_word_passable_with_parens_balanced='(?:'${pcre_continuable_spaces_horizontal}'|'${pcre_word_passable_with_parens_balanced}')+'

    #FUXME: Match only whitespace delimiting such words -- *NOT* prefixing such
    #words. This should simplify matching of block arguments a bit.
    # local pcre_word_passable_with_parens_balanced='(?:(?:'${pcre_word_passable_with_parens_balanced}'(?:\\\R)?\h++(?:\\\R)?))*'${pcre_word_passable_with_parens_balanced}')?'

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

    #FUXME: This is actually used. ${pcre_continuable_spaces_horizontal}, however, doesn't really
    #appear to be. Excise the latter and shift such documentation here.
    # local pcre_continuable_spaces_horizontal='(?:\h|\\\R)+'

    # local pcre_macro_arg_block_prefix='(?:\h(?:\\\R)?|(?:\\\R)?\h)\{'

    #FUXME: Excise. This is wrong, anyway. Matching line continuations is
    #*USELESS*, if one considers. We don't care about line continuations. They
    #signify 

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

 # Hence, we
    #really can't match this outside of the full PCRE. *shrug* 
# '(?:'${pcre_macro_arg}')*(?&arg)'

    # Customary argument for zsh commands, comprising one or more of the prior
    # syntactic constructs.
    # local pcre_macro_arg_command='(&word)+'

# '(?<word>(&uword)|(&squote)|(&dquote)|(?&sub))'

# ${pcre_chars_unreserved}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}'
    #FUXME: Correct me. Then just 
    # local pcre_code_sans_process_sub_nonrecursive='(?<codet>))'

    #FUXME: Erhm. Excise?
    # local pcre_codes='(?:\\[''")$`<]|(?!<<)[^''")$`]|(?&code))*'

    #FUXME: A non-recursive version (e.g., matching "$ughugh") needs to be
    #defined as well, and a new umbrella PCRE matching both recursive and non-
    #recursive variable expansions assigned the overarching group "<var>".

    # local pcre_quotes_single_grouped="'((?:[^']|'')*)'"
    # local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    #FUXME: Also match process substitutions (of both ilk).
    #
    #Since zsh appears to search for terminating '"' delimiters in a prior
    #phase to that of variable expansions, we do *NOT* need to match variable
    #expansion here. (Isn't that nice?)

    #FUXME: Embedding ${pcre_quotes_single} here clearly isn't quite right.
    #While we *DO* want to match single quotes, we want to do so in a
    #"(?qsingle)" manner. Moreover, we want to match considerably more than
    #simply that: double quotes, here-doc strings, and so forth. *sigh*

    #FUXME: Unify with ${pcre_word_passable_with_parens_balanced}, perhaps?
    #FUXME: Right. ${pcre_code} should subsume ${pcre_word_passable_with_parens_balanced}, adding support for
    #here-documents and -strings. (Anything else?)

    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE. Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    # local pcre_here_doc_prefix='<<-?\s*+(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_literal_grouped}')\R'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\R(?-1)'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    # Here-string.
    # local pcre_here_string='<<<\s*+'${pcre_word_passable_with_parens_balanced}''

    #FUXME: Excise the above? Shift documentation here!

    #FUXME: No longer required, seemingly. Now that we've merged such matching
    #into ${pcre_chars_unreserved}, excise such PCRE.

 # (Since this PCRE is principally used to match here
    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # cannot 
    #
    # we have no sane means of
    # matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string).
    #
    # Why? Character escapes.  We're inclined
    #to ignore this, at the moment.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Fairly sure we can simplify this quite a bit. We don't *NEED* to
    #match individual arguments on the initial match of the full macro string.
    #In fact, we're fairly sure we don't *EVER* need to match individual
    #arguments. Hence, we can probably generalize ${pcre_macro_arg_command} above
    #with whitespace as follows:
    #
    #    local pcre_macro_arg_command='(?:'${pcre_continuable_spaces_horizontal}'|'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'
    #
    #Of course, that immediately suggests we combine ${pcre_continuable_spaces_horizontal} and
    #${pcre_sans_quotes_spaces} -- probably by omitting "\s" from the
    #definition of the latter. (In any case, it's all for the morrow!)

    # "$"- or "`"-prefixed embedded substitutable.
    # local pcre_embeddable_embedded='(?=[$`])(?&sub)'

# (?>[$`])

    #FUXME: O.K.; we're not going to be able to substitute this below as is.
    #The reason why is the "[^$]". We're afraid that will need to be extended
    #on a case-by-case basis. After doing so, we'll probably want to excise
    #this local entirely.

    # Any character excluding "$" *OR* a "$"-prefixed substitutable.
    # local pcre_char_or_substitutable='\\$|[^$]|(?&sub)'

    #FUXME: Also match recursively nestable process substitution.

    # While we prefer *NOT* to explicitly
    # match arithmetic substitutions, matching only the latter would match one ")" delimiter
    # in arithmetic substitutions as terminating such substitutions -- which,
    # clearly, is not the case.

    #FUXME: For maintainability, we probably want to use embedded named
    #references everywhere we currently use zsh variable embedding below.

    # Arbitrary string of one or more characters excluding characters reserved
    # for strict zsh argument parsing. This includes:
    #
    # * Dollar signs.
    # * Single and double quotes.
    # * Whitespace.
    # local pcre_sans_quotes_spaces='[^\s''"$]++'

    # local pcre_macro_arg_command='(?:'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'

    #FUXME: Interestingly, this must be constructed at runtime, implying this
    #entire anonymous function should be converted into a named function
    #::preprocessor_pcres.make() called on *EACH* call to :macro(). Hmm. For
    #efficiency, perhaps:
    #
    #* :macro() should simply set ${ZESHY_MACRO_PCRE} to the empty string.
    #* :code.preprocess() should call ::preprocessor_pcres.make() if
    #  ${ZESHY_MACRO_PCRE} is the empty string.
    #
    #This permits multiple macros to be defined by a single parcel without
    #triggering multiple redundant PCRE compilations, which seems sensible.
    #FUXME: For usability, define a function ::preprocessor_pcres.clear() in
    #this parcel clearing such PCRE globals.

    # One or more such arguments.
    # Unquoted word in the strict zsh sense, comprising one or more characters
    # excluding whitespace and shell-reserved characters.
    # local pcre_word_unquoted='[^]'

    #FUXME: We *DO* need to match variables as well. Here's why:
    #
    #    >>> print ${:-
    #    ... :func
    #    ... }
    #
    #    :func
    #
    #Yes, that actually works. It's a hell of an edge case, but edge case
    #nonetheless. For robustness, we *MUST* account for all such cases.

    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # local pcre_here_doc_prefix='<<-?\s*+(?|'${ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE}'|'${ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE}'|(\S++)\n'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\g{-1}'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

#FUXME: Document me.
# # PCRE globals defined below.
# typeset -g\
#     ZESHY_SYNTAX_QUOTES_SINGLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE
# 
# # PCREs matching single-quoted strings in zsh format and hence supporting
# # escaped single quotes (i.e., "''").
#          ZESHY_SYNTAX_QUOTES_SINGLE_PCRE="'(?:[^']|'')*'"
# ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE="'((?:[^']|'')*)'"
# 
# # Double-quoted string in zsh format and hence supporting escaped double
# # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
# # matches "\" and hence must be matched *AFTER* matching the latter.
#          ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE='"(?:\\"|[^"])*"'
# ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE='"((?:\\"|[^"])*)"'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
