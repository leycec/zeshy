#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs common to both macro preprocessing and function declaration.

# ....................{ DEPENDENCIES                       }....................
::script_zsh.source_or_unwind_call_stack func.zy macro.zy

# ....................{ GLOBALS                            }....................
# PCRE matching zero or more macros *OR* syntactic constructs possibly
# containing macro-like substrings, reporting:
#
# * Success on matching each macro and capturing such macro's name and all
#   arguments passed to such macro.
# * Failure on reaching the end of the string.
#
# When iterated over via calls to pcre_match(), such PCRE iteratively ignores
# all text until matching the next macro, at which point control is returned to
# the code block associated with such call; if no such macro exists, the end of
# the string is reached, at which point control is returned to the code
# following such code block. In either case, Odium and efficiency reigns.
typeset -g ZESHY__MACRO_PCRE

# PCRE matching zsh variable names.
typeset -g ZESHY_VAR_NAME_PCRE

# ....................{ CLEARERS                           }....................
# :void ::preprocessor_pcres.clear()
#
# Set ${ZESHY__MACRO_PCRE} to the empty string, inducing a subsequent call to
# ::preprocessor_pcres.make_if_needed() to recreate such PCRE.
#
# == Motivation ==
#
# Various substrings of such PCRE dynamically depend on external shell state
# (e.g., the set of all currently defined macro names) and hence *MUST* be
# invalidated on changes to such state. This function performs such
# invalidation and hence *MUST* be explicitly called when such changes occur.
function ::preprocessor_pcres.clear() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ZESHY__MACRO_PCRE=
}

# ....................{ MAKERS                             }....................
# :void ::preprocessor_pcres.make_if_needed()
#
# Initialize ${ZESHY__MACRO_PCRE} if currently set to the empty string,
# typically by a prior call to ::preprocessor_pcres.clear(). See such function.
function ::preprocessor_pcres.make_if_needed() {
    (( # == 0 )) || :die 'Expected no arguments.'
    [[ -n ${ZESHY__MACRO_PCRE} ]] || ::preprocessor_pcres.make
}

# :void ::preprocessor_pcres.make()
#
# Initialize ${ZESHY__MACRO_PCRE}.
function ::preprocessor_pcres.make() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # If at least one macro exists, match all such macros.
    if (( ${#ZESHY__MACRO_TO_FUNC_NAME} )) {
        # Macro name, dynamically constructed from the current set of all
        # macro names. By design, such names are guaranteed to contain no
        # PCRE-reserved characters and hence require no escaping. See :macro().
        local pcre_macro_name

        # If one or more ":"-prefixed macros exist, match such macros.
        if (( ${#ZESHY__MACRO_NAMES_SEMICOLON_PREFIXED} )) {
            pcre_macro_name=':(?>'${(j:|:)ZESHY__MACRO_NAMES_SEMICOLON_PREFIXED}')'
        }

        # If one or more non-":"-prefixed macros exist, match such macros.
        if (( ${#ZESHY__MACRO_NAMES_SEMICOLON_UNPREFIXED} )) {
            # If one or more ":"-prefixed macros exist, alternate the two.
            [[ -z ${pcre_macro_name} ]] || pcre_macro_name+='|'

            # Match such macros.
            pcre_macro_name+=${(j:|:)ZESHY__MACRO_NAMES_SEMICOLON_UNPREFIXED}
        }

        # Macro name grouped.
        local pcre_macro_name_grouped='('${pcre_macro_name}')'

        # Macros, replacing the static placeholder in such PCRE by the
        # dynamically constructed PCRE matching macro names grouped.
        ZESHY__MACRO_PCRE=${ZESHY__MACRO_PCRE_IF_NONEMPTY//${ZESHY__MACRO_NAME_PLACEHOLDER_PCRE}/${pcre_macro_name_grouped}}
    # Else, no macros exist. To prevent spurious or scurrilous preprocessor
    # behaviour, induce such PCRE to *ALWAYS* report failure.
    } else {
        ZESHY__MACRO_PCRE=${ZESHY__MACRO_PCRE_IF_EMPTY}
    }
}

# ....................{ MAIN                               }....................
# Declare general-purpose PCRE globals *NOT* reinitialized on each call to
# ::preprocessor_pcres.make().
() {
    # ..................{ GLOBAL                             }..................
    # POSIX variable name. Dismantled, this is:
    #
    # * "[...]", matching the first character of such name.
    # * "[...]*+", matching all remaining characters of such name.
    ZESHY_VAR_NAME_PCRE='[a-zA-Z_][a-zA-Z0-9_]*+'
}

# --------------------( WASTELANDS                         )--------------------
    # # If at least one macro exists, match all such macros.
    # if ((
    #     ${#ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME} +
    #     ${#ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME} )) {
    #     # Macro name, dynamically constructed from the current set of all
    #     # macro names. By design, such names are guaranteed to contain no
    #     # PCRE-reserved characters and hence require no escaping. See :macro().
    #     local pcre_macro_name
    #
    #     # If one or more ":"-prefixed macros exist, match such macros.
    #     if (( ${#ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME} )) {
    #         pcre_macro_name=':(?>'${(kj:|:)ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME}')'
    #     }
    #
    #     # If one or more non-":"-prefixed macros exist, match such macros.
    #     if (( ${#ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME} )) {
    #         # If one or more ":"-prefixed macros exist, alternate the two.
    #         [[ -z ${pcre_macro_name} ]] || pcre_macro_name+='|'
    #
    #         # Match such macros.
    #         pcre_macro_name+=${(kj:|:)ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME}
    #     }

        #FUXME: Obsolete. Instead, search and replace the *FIRST* substring in
        #${ZESHY__MACRO_PCRE} matching ${ZESHY__MACRO_NAME_PLACEHOLDER_PCRE} by
        #such concatenation.
        # Such macros or macro-like substrings.
        # ZESHY__MACRO_PCRE=${ZESHY__MACRO_PCRE_IF_NONEMPTY_PREFIX}${pcre_macro_name_grouped}${ZESHY__MACRO_PCRE_IF_NONEMPTY_SUFFIX}

#  Since subsequent locals often depend on prior locals
    # locals, define one local per line below.
    #FUXME: Rename to ${ZESHY_VAR_NAME_PCRE}, shift to ={pcre.zy}, and replace
    #all current usage of ${ZESHY_VAR_NAME_GLOB} with ${ZESHY_VAR_NAME_PCRE}.

    # Boolean zsh command terminators.
    # local pcre_boolean_or='\|\|'
    # local pcre_boolean_and='&&'
    # local pcre_boolean=${pcre_command_end_boolean_or}'|'${pcre_command_end_boolean_and}

    #FUXME: Insufficient. May be suffixed by *EITHER* one or more word spaces and/or newlines.

    #FUXME: Shift block delimiters here. Rename ${pcre_char_block_prefix} to
    #${pcre_char_block_prefix}. Define a new ${pcre_char_block_prefix} embedding
    #${pcre_char_block_prefix} prefixed by ${pcre_spaces_word_or_vertical}.

    # Block prefix and suffix. As ${char_not_word_unquoted} documents, both
    # conflict with unquoted shell word syntax (which permits such prefix when
    # *NOT* the first character and such suffix when *NOT* the last character
    # of such word) and hence require disambiguation.
    # local pcre_char_block_prefix='\{'
    # local pcre_char_block_suffix='\}'

    # One or more command-specific whitespace sequences (i.e., zero or more
    # non-negligible horizontal whitespace characters or negligible line
    # continuations), prefixed by at least one horizontal whitespace character.
    # While escaped newlines are line continuations preserving the current
    # command and hence effectively whitespace, unprefixed newlines are
    # effectively semicolons terminating such command and hence non-whitespace.
    # local pcre_word_spaces_prefixed_by_spaces_horizontal=${pcre_spaces_horizontal}'(?:'${pcre_line_continuation_spaceable}')*'

    # One or more command-specific whitespace sequences. Since line
    # continuations are merely ignorable rather than actual whitespace, such
    # sequences *MUST* include at least one horizontal whitespace character.
    # local pcre_spaces_word=${pcre_line_continuations_optional}${pcre_word_spaces_prefixed_by_spaces_horizontal}

    # One or more command-specific whitespace sequences, prefixed by at least
    # one line continuation.
    # local pcre_word_spaces_prefixed_by_line_continuations=${pcre_line_continuations}'(?:'${pcre_spaces_horizontal_continuable}')*'

    # Zero or more command-specific whitespace sequences. Technically, this
    # PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.

    #FUXME: It's not necessarily clear that this is required anywhere outside
    #of here-documents. (Indeed, even here-strings shouldn't require this,
    #since words already match escaped characters and hence line continuations.)
    #In all other cases, ${pcre_spaces_optional} should suffice. Ideally, we
    #should find a way of obsoleting this even in here-documents and then
    #excise this. That, in turn, would permit us to excise
    #${pcre_line_continuation}, which is almost certainly a good thing.
    #FUXME: We should probably refactor this back to its prior version. We use
    #such PCRE sufficiently infrequently (i.e., only in here-documents) that
    #the current approach is extreme overkill. As documented above, this is:
    #
    #     local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    #
    #Before we do so, however, we should confirm whether we still need
    #${pcre_spaces_word} anywhere, which would impact our decision.
    #FUXME: Incidentally, this PCRE has little to nothing to do with shell
    #word-specific whitespace. Rather, it's simply excisable now.
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    #FUXME: Insufficient. Must be preceded by one or more horizontal whitespace
    #characters and (of course) ignorable line continuations.

    #FUXME: Shift above, probably to where we define ${pcre_command_end_zeshy}
    #and such (which should clearly be shifted here).

    #FUXME: Arguably shift
    #"'(?:'${pcre_word}${pcre_spaces_horizontal_continuable}')*'" to a new PCRE
    #${pcre_words_spaced_optional}.
    # Since block
    # arguments are necessarily prefixed by such whitespace, this PCRE is
    # principally intended to match all standard arguments prefixing a block
    # argument passed to a macro.

    #FUXME: This could be optimized by preventing ${pcre_word} from matching
    #line continuations. In such case, the order of the two alternative choices
    #could be switched, which would be quite desirable. Ignoring that, however,
    #this appears to be feature complete.
    #FUXME: We probably need to ensure everywhere we use ${pcre_word} that
    #we also explicitly match ${pcre_line_continuation_spaceable}. Given that,
    #perhaps the latter should be incorporated into the former?
    # local pcre_macro_args_zsh_optional=${pcre_spaces_horizontal_continuable}'(?:'${pcre_line_continuation_spaceable}'|'${pcre_word}${pcre_spaces_horizontal_continuable}')*'

    #FUXME: Eliminate the "_arg" from all PCRE names below.
#this PCRE is guaranteed
    # to *NOT* be preceded by horizontal whitespace *AND* since 
    # If one or more such arguments
    # were passed, such arguments must be preceded by at least one horizontal
    # whitespace character; else, no such arguments were passed, in which case 
    # such macro must either be:
    #
    # * Suffixed by one or more horizontal whitespace characters followed by a
    #   command terminator. Since command terminators are *NOT* valid macro
    #   arguments, ${pcre_macro_args_optional} implicitly halts matching
    #   immediately prior to such terminator.
    # * Suffixed directly by a command terminator. Since
    #   ${pcre_macro_args_optional} only matches when preceded by one or more
    #   horizontal whitespace characters, this case must be explicitly matched.

    #FUXME: No longer quite right. We *REALLY* don't want this to be optional,
    #as the resulting semantics are... wierd, and probably wrong. Instead, we
    #probably need to explicitly match a command terminator here.

    # Zero or more standard or block arguments. If one or more such arguments
    # were passed, such arguments must be preceded by at least one horizontal
    # whitespace character; else, no such arguments were passed, in which case 
    # such macro must either be:
    #
    # * Suffixed by one or more horizontal whitespace characters followed by a
    #   command terminator. Since command terminators are *NOT* valid macro
    #   arguments, ${pcre_macro_args_optional} implicitly halts matching
    #   immediately prior to such terminator.
    # * Suffixed directly by a command terminator. Since
    #   ${pcre_macro_args_optional} only matches when preceded by one or more
    #   horizontal whitespace characters, this case must be explicitly matched.

    #FUXME: No longer quite right. We *REALLY* don't want this to be optional,
    #as the resulting semantics are... wierd, and probably wrong. Instead, we
    #probably need to explicitly match a command terminator here.

    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_spaces_horizontal}${pcre_macro_arg}')*)?'
    # local pcre_macro_body_optional=${pcre_line_continuations_optional}'(?:'${pcre_spaces_horizontal}${pcre_macro_args_optional}'|'${pcre_macro_sans_args}')'

    # Zero or more standard or block arguments, each prefixed by one or more
    # horizontal whitespace characters, optionally followed by a here-document
    # or -string. To ensure that such macro is passed no unmatched
    # syntactically invalid arguments and hence is syntactically valid, such
    # match is anchored to the end of the current line.

    # rather than silently terminating such iteration.
    # Zero or more standard or block arguments optionally followed by a here-
    # document or -string, the end of the current line, *OR* the nonempty
    # remainder of the current line. The latter substring if any is captured,
    # ensuring that syntactically invalid macros are uniquely identifiable by
    # testing whether or not the corresponding match group exists (e.g., by
    # testing the length of canonical list global ${matches}).

#'|'${pcre_macro_args_invalid}'
    # local pcre_chars_sans_space_vertical_grouped='('${pcre_chars_sans_space_vertical}')'
    #FUXME: Erronious. We probably no longer require
    #${pcre_chars_sans_space_vertical_grouped}; instead, refactor this to use
    #${pcre_chars_sans_space_vertical}. Arguably, shift the latter PCRE
    #fragment below to a new PCRE ${pcre_line_optional} above.
    #FUXME: We'll probably also need to define
    #${pcre_chars_sans_space_vertical_optional} above.

    # local pcre_macro_arg_invalid_body_grouped=${pcre_chars_sans_space_vertical_grouped}'{1,3}'
    #FUXME: Document me.

    #FUXME: For error reporting purposes, it would probably be *FAR* more
    #helpful to shift ${pcre_macro_args_invalid} into ${pcre_macro_arg} rather
    #than interpolated below, renaming such PCRE to ${pcre_macro_arg_invalid}:
    #e.g.,
    #
    #    local pcre_macro_arg='(?:'${pcre_word}'|'${pcre_macro_arg_block}'|'${pcre_macro_arg_invalid}')'
    #
    #For that to work, however, we'll need to append ${pcre_macro_arg_invalid}
    #by ${pcre_report_failure}. Will that suffice to terminate the entire
    #current match, however? Wait. No, we don't want to report failure, as that
    #would unconditionally terminate the current iteration -- at least, as
    #currently implemented. Perhaps append ${pcre_report_success} instead?
    #Since further research is clearly required here, implement such
    #refactoring after we have a tolerable, working first draft.
    #FUXME: Right. Appending ${pcre_report_success} will *DEFINITELY* work, as
    #the PCRE below demonstrates. Let's do this now, yes?

    #FUXME: Ugh! How do we distinguish between a syntactically invalid macro
    #and an argumentless macro suffixed by a command terminator? Argumentative
    #macros suffixed by command terminators are no issue, as in that case at
    #least one argument character will be matched and hence such match group
    #will be nonempty. The only issue is with argumentless macros, as ever. For
    #example:
    #
    #    # Syntactically invalid macro.
    #    :macro uh(oh
    #
    #    # Macro suffixed by a command terminator.
    #    :macro :or true
    #
    #In the former case, ${pcre_chars_sans_space_vertical_grouped} will
    #appropriately be triggered; in the latter case, the same PCRE will be
    #inappropriately triggered. One way of handling this would be to define a
    #PCRE used below in lieu of ${pcre_chars_sans_space_vertical_grouped}:
    #
    #    local pcre_macro_args_invalid='(?!'${pcre_macro_sans_args_lookahead}'|'${pcre_command_end_zeshy}')'${pcre_chars_sans_space_vertical_grouped}
    #
    #We'll need to define ${pcre_command_end_zeshy}, of course. (Didn't we
    #already define a PCRE matching zeshy-specific command terminators?)

# ${pcre_spaces_horizontal_optional}

    #FUXME: Consider replacing ${pcre_spaces_word} by
    #${pcre_spaces_horizontal_continuable}. (Should work; consider further to
    #ensure success, however.)
    #FUXME: Hmm. Right. O.K.; so, we need to extract
    #${pcre_line_continuations_optional} out as follows.

    # local pcre_macro_sans_args_end=${pcre_spaces_horizontal_optional}'(?:'${pcre_line_end}'|(?='${pcre_char_command_end}'))'

    #FUXME: We increasingly regard the dichotomy between ${pcre_spaces_word}
    #and ${pcre_spaces_horizontal} as bath false and harmful. Ideally, we
    #shouldn't *NEED* to explicitly match line continuations and hence match
    #${pcre_spaces_word} at *ALL*. If one considers it, ${pcre_word_unquoted}
    #and hence ${pcre_word} and hence ${pcre_macro_arg} already implicitly
    #matches line continuations.
    #FUXME: No, we can't simply replace ${pcre_spaces_word} by
    #${pcre_spaces_horizontal} -- at least, not as currently defined. Why?
    #Because doing so would fail to match ":macro a \
    #b". Wait; no, that would still be successfully matched. Right, then!

    #FUXME: We increasingly regard the dichotomy between ${pcre_spaces_word}
    #and ${pcre_spaces_horizontal} as bath false and harmful. Ideally, we
    #shouldn't *NEED* to explicitly match line continuations and hence match
    #${pcre_spaces_word} at *ALL*. If one considers it, ${pcre_word_unquoted}
    #and hence ${pcre_word} and hence ${pcre_macro_arg} already implicitly
    #matches line continuations.
    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_spaces_word}${pcre_macro_arg}')*'${pcre_word_spaces_optional}')?'${pcre_here_optional}

    #FUXME: Macros accepting no arguments should be matchable in a
    #significantly more generalized, zsh-like manner. While matching
    #${pcre_line_end} is helpful, it fails to suffice; we'd also like to match
    #argumentless macros terminated by:
    #
    #* A standard command terminator (e.g., "<", "|") *WITHOUT* matching such
    #  terminator (i.e., use positive lookahead).
    #* A zeshy-specific command terminator (e.g., ":or", ":and"). Any others,
    #  or are those the only two ones? Oh, wait. *NO.* If this fallback
    #  alternative was matched, then no horizontal whitespace was matched after
    #  such macro's name, implying that a zeshy-specific command terminator
    #  could *NEVER* possibly match here. Ignore such terminators, but
    #  explicitly note why in the comments above.
    #
    #This should only be required for argumentless macros. Macros accepting one
    #or more arguments already follow the above stricture.

    #FUXME: Shift this and the following PCREs up to "space" above.

    # matches s to  To prevent 
    # any of the several standard syntactic primitives that
    # terminate commands.

    # Command terminator, comprising either the end of the current line *OR*
    # any of the several standard syntactic primitives that terminate commands.
    #     local pcre_command_end=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=;|([<>|])))'

    #FUXME: This may be incorrect. In fact, it almost certainly is. Why?
    #Because we currently treat the last byte of the currently matched
    #substring as synonymous with the last byte of the currently matched
    #*MACRO*. However, by consuming such command terminator here, we interfere
    #with such interpretation. Ideally, such terminator should be captured but
    #*NOT* consumed via positive lookahead. Note our explicit use of "captured"
    #here yes, we do actually need to inspect the contents of such command
    #terminator programmatically in ={backend}. Why? Well, it's fairly simple:
    #
    #* If the captured command terminator group is nonempty, then such macro's
    #  expansion is intended to be piped or redirected elsewhere. How can we
    #  ensure that any arbitrary expansion can be piped or redirected? For now,
    #  the simplest solution is almost certainly the best. ={backend} must
    #  check for the following conditions *AFTER* expanding such macro:
    #  * If such captured group is nonempty *AND* the expansion returned by
    #    such macro's function is *NOT* delimited by "{" and "}", then
    #    delimit such expansion by "{" and "}".
    #
    #That's hopefully it.
    #FUXME: Moreover, this fails to account for possible line continuations
    #preceding such command terminator (e.g., ":macro\
    #| :piped_to_something"). How about something resembling:
    #
    #     local pcre_command_end=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=(['${char_command_end}'])))'
    #
    #Of course, we probably haven't even defined ${pcre_word_spaces_optional}
    #by this point, requiring this PCRE be shifteb below.
    #FUXME: Actually, ";" is equivalent to a newline for command termination
    #purposes and hence ignorable. So, the above should be augmented to read:
    #
    #     local pcre_command_end=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=;|([<>|])))'
    #
    #Of course, that suggests definition of a new character class above -- say:
    #    local char_command_end_semantic='<>|'
    #FUXME: We'll need to add a new global match index for such captured group.
    #FUXME: Actually, this strikes us as overkill. The existing
    #${pcre_macro_args_zsh_optional} should *NEVER* match a command-terminating
    #subsequence, for obvious reasons. That said, the current definition of
    #such PCRE currently does and hence is clearly insufficient. See
    #${char_command_end_semantic} for details. Consider excising this PCRE.
    # local pcre_command_end='(?:'${pcre_line_end}'|['${char_command_end}'])'

    #FUXME: For efficiency, rename to ${pcre_here_doc_or_string_prefix_optional}
    #and suffix by "?".

    # ..................{ MACRO ~ word : embed               }..................
    #FUXME: Optimizable by eliminating extraneous "(?:" and ")" groupings.
    #FUXME: Actually, we want to revert to the prior approach. See above.
    #FUXME: Actually, this is probably *ALL* eliminatable by noting that
    #${pcre_word} pretty much suffices for both this and the
    #parens-specific PCREs below. Honestly, why did we go to such extreme
    #lengths to differentiate the three? It's rather difficult to say, now.
    #FUXME: Hmm; perhaps it *IS* useful to at least maintain the distinction
    #between ${pcre_word} and a new sort of word encompassing both braces
    #and parens words -- say, ${pcre_word_embedded}.
    #FUXME: O.K.; we've implemented a new ${char_not_word_embedded_unquoted}
    #character class. Use below in place of the current approach!
    #FUXME: O.K.; we've excised all ${pcre_word_braces*} and ${pcre_word_parens*}
    #definitions. Now, we need to replace all use of such PCREs by these PCREs.
    #FUXME: Actually, we want to excise all PCREs in this section as well as
    #${char_not_word_embedded_unquoted}, replacing both with their argument
    #word equivalents above. Then rename "word_arg" to "word" everywhere. As an
    #optimization, we can largely retain the benefits of using the approach
    #below by defining a new ${char_command_end_not_code_prefix} character
    #class probably defined something like so:
    #
    #    local char_command_end_not_code_prefix='&>|;'
    #
    #Such class explicitly omits "<", the here-document and -string prefix,
    #which must be matched in a more complex manner than a simple character
    #class. Given such class, we may then match all unquoted command
    #terminators in an efficient manner in all PCREs previously embedding
    #${pcre_word_embedded}, which seems rather nice.

    #FUXME: Arguably suffix by "'|'${pcre_here_doc_or_string_prefix}".

    # Character class matching invalid characters in unquoted shell words
    # embedded in syntactic constructs (e.g., blocks, process substitutions).
    # Since such words are matched merely to correctly parse the substrings
    # delimiting such constructs, this class excludes invalid characters
    # irrelevant to such parsing (e.g., "<", ">", "|").
    #
    # Since unquoted "(" and ")" characters are only permitted when balanced
    # (e.g., ":glob *.zy(.)"), such characters are excluded as above.
    # local char_not_word_embedded_unquoted='()'${char_not_code_prefix}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with argument word PCREs above.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # One or more characters of unquoted shell words embedded in syntactic
    # constructs.
    # local pcre_word_embedded_unquoted_char='[^'${char_not_word_embedded_unquoted}']'
    # local pcre_word_embedded_unquoted_chars=${pcre_word_embedded_unquoted_char}'++'
    #
    # # Syntactic construct embedded in shell words themselves embedded in
    # # syntactic constructs.
    # local pcre_word_embedded_substring=${pcre_word_embedded_unquoted_chars}'|'${pcre_char_escaped}'|'${pcre_substitutable_or_quotes}
    #
    # # Zero or much such constructs.
    # local pcre_word_embedded_substrings_optional='(?:'${pcre_word_embedded_substring}')*'
    #
    # # "("- and ")"-balanced substrings in shell words signifying embeddeduments
    # # passed to macros. See ${pcre_word_unquoted_balanced} above.
    # local pcre_word_embedded_unquoted_balanced='\('${pcre_word_embedded_substrings_optional}'\)'
    #
    # # One or much such constructs *OR* "("- and ")"-balanced substrings.
    # local pcre_word_embedded_substrings_balanced='(?:'${pcre_word_embedded_substring}'|'${pcre_word_embedded_unquoted_balanced}')+'
    #
    # # Shell word embedded in a syntactic construct.
    # local pcre_word_embedded=${pcre_word_lookahead}${pcre_word_embedded_substrings_balanced}${pcre_word_lookbehind}
    #
    # # Zero or more shell words, whitespace characters, or comments embedded in
    # # a syntactic construct.
    # local pcre_words_embedded_or_comments_optional='(?:'${pcre_word_embedded}'|'${pcre_comment_optional}')*'

    #FUXME: Wait. Even a simple character class is insufficient. We'll want to
    #additionally support the following command terminating substrings:
    #* Either "<", ">", or "&" preceded by a nonnegative digit.
    #* A "}" delimiting a code block.
    #* A process substitution of the form "=(...)".
    #
    #In short, "Ugh." Hopefully, merely improving matching elsewhere will
    #implicitly correct for such shortfalls.
    # local char_command_end_semantic='<>|&'

    # local char_command_end_semantic='<>|&'

    # Character class matching ASCII punctuation characters that unconditionally
    # terminate the preceding command. 
    # local char_command_end=${char_command_end_semantic}';'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with embedded word PCREs below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Excise below.

    # # First, middle, and last unquoted substrings of unquoted shell words
    # # embedded in "{"- and "}"-delimited code blocks.
    # local pcre_word_braces_unquoted_char_first_last='[^'${char_not_word_braces_unquoted}'{}]'
    # local pcre_word_braces_unquoted_char_first='(?:[^'${char_not_word_braces_unquoted}'{]|'${pcre_char_escaped}')'
    # local pcre_word_braces_unquoted_char_last='(?:[^'${char_not_word_braces_unquoted}'}]|'${pcre_char_escaped}')'
    # local pcre_word_braces_unquoted_char_middle='(?:[^'${char_not_word_braces_unquoted}']+|'${pcre_char_escaped}')'
    # local pcre_word_braces_unquoted_chars_middle_optional=${pcre_word_braces_unquoted_char_middle}'*'
    #
    # # First, middle, and last substrings of a shell word embedded in "{"- and
    # # "}"-delimited code blocks.
    # local pcre_word_braces_first_last=${pcre_word_braces_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_braces_first='(?:'${pcre_word_braces_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_braces_last='(?:'${pcre_word_braces_unquoted_char_last}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_braces_middle='(?:'${pcre_word_braces_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_braces_middle_optional=${pcre_word_braces_middle}'*'
    #
    # # Shell word embedded in "{"- and "}"-delimited code block.
    # local pcre_word_braces='(?:'${pcre_word_braces_first}${pcre_words_braces_middle_optional}${pcre_word_braces_last}')|'${pcre_word_braces_first_last}')'

    # ..................{ MACRO ~ word : parens              }..................
    # Unquoted substrings of unquoted shell words embedded in "$("- and
    # ")"-delimited process substitutions. Technically, such words are also
    # subject to the same constraints as those above (e.g., "{" cannot be the
    # first character of such words). However, such constraints are irrelevant
    # to the parsing of such substitutions and hence ignorable here.
    # local pcre_word_parens_unquoted_char='[^'${char_not_word_parens_unquoted}']'
    # local pcre_word_parens_unquoted_chars=${pcre_word_parens_unquoted_char}'++'
    #
    # # Syntactic constructs embedded in shell words embedded in "$("- and
    # # ")"-delimited code blocks.
    # local pcre_word_parens_body=${pcre_words_parens_unquoted_chars}'|'${pcre_char_escaped}'|'${pcre_substitutable_or_quotes}
    #
    # # "("- and ")"-balanced substrings in shell words embedded in "$("- and
    # # ")"-delimited code blocks. Since such substrings are non-nestable,
    # # recursion and hence subroutine calls are *NOT* required. Yet, such
    # # substrings can contain other constructs (e.g., single-quoted strings).
    # local pcre_word_parens_unquoted_balanced='\((?:'${pcre_word_parens_body}')*\)'
    #
    # # Shell word embedded in "$("- and ")"-delimited code blocks.
    # local pcre_word_parens=${pcre_word_parens_body}'|'${pcre_word_parens_unquoted_balanced}
    #
    # # One or more shell words embedded in "$("- and ")"-delimited code blocks.
    # local pcre_words_parens_optional='(?:'${pcre_word_parens}')*'

    #FUXME: This didn't even work under the prior definition. Why? Because
    #${pcre_words_parens_optional} does *NOT* match whitespace, implying this
    #pretty always failed to correctly match. Naturally, it fails even worse
    #now that we've refactored such PCREs away. That said, it shouldn't be
    #*TOO* terribly hard to gin up something that works. This should do it:
    #
    #${pcre_word_embedded}'|'${pcre_comment_optional}
    # local pcre_list_assignment_optional=${pcre_var_name}'(?:=\('${pcre_words_parens_optional}'\))?'

    #FUXME: This didn't even work under the prior definition, since it failed

    # One or more shell words embedded a syntactic construct.
    # local pcre_word_embedded_optional='(?:'${pcre_word_embedded}')*'

    # Character class matching invalid characters in unquoted shell words
    # embedded in "$("- and ")"-delimited process substitutions. Since such
    # words are matched merely to correctly parse such delimiters, this class
    # excludes invalid characters irrelevant to such parsing (e.g., "|", ">").
    #
    # Since unquoted "(" and ")" characters are only permitted when balanced
    # (e.g., ":glob *.zy(.)"), exclude such characters here.
    # local char_not_word_embedded_unquoted='()'${char_not_code_prefix}

    # Character class matching invalid characters in unquoted shell words
    # embedded in "{"- and "}"-delimited code blocks. Since such words are
    # matched merely to correctly parse such delimiters, this class excludes
    # invalid characters irrelevant to such parsing (e.g., "|", ">").
    # local char_not_word_braces_unquoted='()'${char_not_code_prefix}

    #FUXME: We suspect that unquoted word characters *CANNOT* be optimized with
    #possessiveness (e.g., "+"), due to the occasional need to backtrack into
    #such characters (e.g., on matching the "}" in "shellword}"). Test us on
    #such edge cases, please. 
    #FUXME: Insufficient! PCREs below need to match shell words *PERFECTLY*.
    #Why? Because we need to ensure that macros either embedded in other
    #syntactic constructs *OR* suffixed by command-terminating substrings
    #(e.g., "=(uhoh)") are correctly matched. To ensure this, we'll need to:
    #
    #* Avoid matching any word-like substring prefixed by "=(" (regardless of
    #  subsequent text) as a word.
    #* Avoid matching digits prefixing "&", "<", or ">" as standard arguments
    #  (e.g., the "1" in "1<&2"). Only check at the start of a word.
    #* Avoid matching "{"- and "}"-delimited variable names prefixing the same
    #  primitives (e.g., "{myfid}>&1"). Only check at the start of a word.
    #* Match "(" and ")" in unquoted shell words in a non-recursive balanced
    #  manner. Happily, we've already done this; we simply need to integrate
    #  that work here.

    # First, middle, and last unquoted substrings of unquoted literal shell
    # words. Since both shell words in the context of passed arguments *AND*
    # shell-reserved "{" delimiters are always preceded by at least one
    # horizontal character, shell words cannot be prefixed by "{" characters.
    # Naturally, a similar argument holds for "}" characters (i.e., shell words
    # cannot be suffixed by such characters).

    #FUXME: Drop the "_literal" from such names. No longer required, and
    #they're already quite long.
    #FUXME: Horrible. Refactor to use the lookahead-driven approach below.
    # local pcre_word_unquoted_literal_char_first_last='[^'${char_not_word_unquoted}'{}]'
    # local  pcre_word_unquoted_literal_char_first='[^'${char_not_word_unquoted}'{]'
    # local   pcre_word_unquoted_literal_char_last='[^'${char_not_word_unquoted}'}]'
    # local pcre_word_unquoted_literal_char_middle='[^'${char_not_word_unquoted}']'
    # local pcre_word_unquoted_literal_chars_middle_optional=${pcre_word_unquoted_literal_char_middle_optional}'*'

    # Unquoted literal shell word, comprising one or more characters that are
    # neither shell-reserved *OR* "\"-escaped.
    # local pcre_word_unquoted_literal='(?:'${pcre_word_unquoted_literal_char_first}${pcre_word_unquoted_literal_chars_middle_optional}${pcre_word_unquoted_literal_char_last}'|'${pcre_word_unquoted_literal_char_first_last}')'
    # local pcre_word_unquoted_literal_grouped='('${pcre_word_unquoted_literal}')'

    #FUXME: Oh, boy. It turns out that *ALL* redirections other than
    #here-documents and -strings may be freely interspersed with standard
    #command arguments: e.g.,
    #
    #    >>> function :yil() { print "${@}" }
    #    >>> :yil 1<&2 =(print ok) yum
    #    /tmp/zsh3lpV1a yum
    #
    #So. Where do we go from here? Frankly, we're inclined to ignore this
    #distinction by implementing the following:
    #
    #* Words should be permitted to contain arbitrary "<", ">", and "&"
    #  characters.
    #
    #Wait... How do we deal with macro expansion now?

    #FUXME: Oh, boy. This requires heavy examination.

    # Syntactic primitives breaking the standard "flow of control" with which
    # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # here-documents and -strings. Hence, shell words are synonymous with
    # standard arguments passable to external commands or functions.

#, comprising one or more
    # of the prior syntactic constructs
    # local pcre_word_body='(?:'${pcre_word_unquoted_literal_char_middle}'+|'${pcre_char_escaped}'|'${pcre_substitutable_or_quotes}')+'
    # local pcre_word=${pcre_word_lookahead}${pcre_word_body}${pcre_word_lookbehind}

    # * "(" and ")" are technically shell-reserved but permitted in unquoted
    #   shell words when strictly balanced (e.g., "(this)" but not "(this(").
    #FUXME: Use in process substitutions to match "$( ugh*.txt(.) )".

    #FUXME: The current approach incurs quite a bit of backtracking, which
    #could be obviated by simple use of forward and negative lookahead.  In
    #hindsight, the prior approach genuinely appears to have been superior.
    #The current approach is blatantly overly complex and inefficient. Revert
    #both here and below, please. (Regretful apologies on that one.)
    #
    #Use ${pcre_word_middle} as a basis for our reversion, shifting all
    #desired forward lookahead constraints into
    #${pcre_word_lookahead} above. (Nice, eh?)

    # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_unquoted_literal_char_first_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_unquoted_literal_char_first}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_unquoted_literal_char_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_middle='(?:'${pcre_word_unquoted_literal_char_middle}'+|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'
    #
    # # Shell word, comprising one or more of the prior syntactic constructs.
    # # Syntactic primitives breaking the standard "flow of control" with which
    # # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # # here-documents and -strings. Hence, shell words are synonymous with
    # # standard arguments passable to external commands or functions.
    # local pcre_word=${pcre_word_lookahead}'(?:'${pcre_word_first_last}'|'${pcre_word_first}${pcre_words_middle_optional}${pcre_word_last}')'

    # # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_unquoted_literal_char_first_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_unquoted_literal_char_first}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_unquoted_literal_char_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_middle='(?:'${pcre_word_unquoted_literal_char_middle}'+|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'
    #
    # # Shell word, comprising one or more of the prior syntactic constructs.
    # # Syntactic primitives breaking the standard "flow of control" with which
    # # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # # here-documents and -strings. Hence, shell words are synonymous with
    # # standard arguments passable to external commands or functions.
    # local pcre_word=${pcre_word_lookahead}'(?:'${pcre_word_first_last}'|'${pcre_word_first}${pcre_words_middle_optional}${pcre_word_last}')'

    # Single- or double-quoted string, arithmetic or process substitution, *OR*
    # variable expansion embedded in a shell word.
    #FUXME: Contemplate either:
    #
    #* Supplanting ${pcre_embeddable} by "(?&sub)" below and then excising
    #  ${pcre_embeddable}. This has the disadvantage of slowing commonplace
    #  variable expansions, however.
    #* Replacing the embeddings of both ${pcre_process_substitution_dollar_recursive}
    #  and ${pcre_process_substitution_dollar_nonrecursive} with new subroutines
    #  calling such PCREs. This amends the prior issue.
    #* Reducing this PCRE to:
    #    local pcre_embeddable_or_quotes='(?&word)'
    #    pcre_subroutines_body+='(?<word>${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'
    #
    #While the second option would be preferable in the ideal world, we should
    #consider adopting the third option as a concession to real-world
    #pragmatism. After all, this PCRE is transitively embedded into so many
    #other expressions that the current approach patently fails to scale. As a
    #temporary hotfix, therefore, we've elected to adopt the first option.

    #FUXME: Overkill. Combine the following three into one conglomerate PCRE.
    # # "=("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_equals='=\('${pcre_process_substitution_parens_body}'\)'
    #
    # # "<("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_angle_left='<\('${pcre_process_substitution_parens_body}'\)'
    #
    # # ">("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_angle_right='>\('${pcre_process_substitution_parens_body}'\)'

#  Since the named group
    # "<sub>" matches non-recursive process substitution, such group *CANNOT*
    # be referenced here. (Doing so would permit such substitutions to be
    # recursively nested.) Instead, match all groups matched by such group
    # excluding non-recursive process substitution.
    # Recursively substitutable syntactic construct (e.g., "=("- and
    # ")"-delimited process substutition), intended to be called *ONLY* from
    # within such constructs.

    # First, middle, and last unquoted substrings of unquoted shell words.

    #FUXME: Optimizable by eliminating extraneous "(?:" and ")" groupings.

    # local pcre_word_unquoted_char_first_last=${pcre_word_unquoted_literal_char_first_last}
    # local pcre_word_unquoted_char_first='(?:'${pcre_word_unquoted_literal_char_first}'|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_char_last='(?:'${pcre_word_unquoted_literal_char_last}'|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_char_middle='(?:'${pcre_word_unquoted_literal_char_middle}'+|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'+'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'*'

    # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_unquoted_char_last}'|'${pcre_word_quoted_or_substitutable}')'
    # local pcre_word_middle='(?:'${pcre_word_unquoted_chars_middle}'|'${pcre_word_quoted_or_substitutable}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'

    #FUXME: Reasonably tired of "${pcre_quotes_single}'|'${pcre_quotes_double}"
    #everywhere. Time to recover ${pcre_quotes}, we should think.

# ${pcre_quotes_single}'|'${pcre_quotes_double}'|'

    #FUXME: The above is great and should be shifted to ={backend}. That said,
    #the whole point of [<>=]"("- and ")"-delimited process substitutions is
    #that they can be passed as customary arguments, meaning we need to treat
    #them as such. All other redirections should still be required to be passed
    #at the end of the macro expansion as is customary.
    #FUXME: Insufficient. Sadly, this fails to take into account the following
    #process substitution variants:
    #
    #* "=(...)", capturing the output of such command(s) to a temporary file
    #  and passing such file's handle to the current command. Unlike the
    #  variants below (which may appear *ANYWHERE*), "=(...)" must begin at the
    #  first character of a shell word or will otherwise be treated as a part
    #  of an unquoted shell word (e.g., "file*.txt=(.)" is a glob rather than a
    #  process substitution!). Yes, this is terrible. Correctly matching this
    #  pretty much requires matching words properly. That said, we *SHOULD* be
    #  matching words properly anyway in process substitutions... yes?
    #* "<(...)", redirecting the output of such command(s) to the current
    #  command's standard input.
    #* ">(...)", redirecting the output of the current command to standard
    #  input for such command(s).

    #FUXME: Actually use the following three PCREs. At the very least, embed
    #them in the definition of "<sub>" below.

    #FUXME: Use everywhere below in place of "(?&sub)".
    #FUXME: Abstract "[^'${char_not_code_prefix}']++" into a new PCRE above and
    #replace all current instances of such substring by such PCRE.
    #FUXME: Abstract out [^'${char_not_code_prefix}']++.

    # local pcre_process_substitution_dollar='(?:'${pcre_list_assignment_optional}'|'${pcre_word_parens}'|'${pcre_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^)])*'

    # Redirection prefixed by a file descriptor specified as either a
    # non-negative integer *OR* "{"- and "}"-delimited variable name. Such
    # redirections conflict with unquoted shell word syntax and hence *MUST* be
    # matched for disambiguation. See section "REDIRECTION" of "man zshexpn".
    # local pcre_redirect_prefix='(?:[0-9]++|\{'${pcre_var_name}'\})&?[<>]'

    # ${pcre_redirect_file_handle_id}'|'${pcre_redirect_file_handle_id}
    # l are incidental to macro parsing but  
    #FUXME: The lookahead optimization preceding such call is rather nice,
    #here. Does a similar optimization apply elsewhere?
# (?=['${char_embeddable_prefix}'])(?&sub)'

    #FUXME: O.K.; so, clearly, we *DO* require this. Probably? Maybe. Hmm. Will
    #the "1" in "1<&2" be matched as an unquoted argument here? Surely not.

    #FUXME: Do we still require this?
    # "&&" (but not "&" on its own)
    #FUXME: Wait. Both "||" and "&&" also terminate commands.

# by such assert such constraint We assert such constraint with
    # ..................{ MACRO ~ word                       }..................
    #FUXME: Shift below.
    #FUXME: We're fairly certain that *OUTSIDE* of process substitutions, it
    #suffices to match the prefixes "\(" and "\[" respectively. *INSIDE* of
    #process substitutions, of course, the full "\("-prefixed math substitution
    #must be matched (to avoid conflict with embedded "("- and ")"-delimited
    #parens in math substitutions and the ")" delimiter for the outer process
    #substitution). Yikes!
    #FUXME: Oh! Jeebus. No, no, and no; do you wish to know why? Math operators
    #(namely, "<<") fundamentally conflict with exterior zsh syntax. Sadly, we
    #failed to note that above. This does imply, however, that we'll need to
    #resurrect ${pcre_math_substitution_old} from below. *sigh*

    # whose syntax fundamentally conflicts with conventional zsh
    #
    # delimiters and must thus be matched. (Note that zsh also supports
    # possibly recursively nested "$["- and "]"-delimited arithmetic
    # substitutions. Since such delimiters conflict with no syntax of
    # preprocessor significance, such substitutions are ignorable.)

    #FUXME: Embed me in process substitutions below, please. Or perhaps not?
    # Shell word, here-document, or here-string prefix.
    # local pcre_word_parens_or_here=${pcre_word_parens}'|'${pcre_here_doc_or_string_prefix}

    #FUXME: We need to add substitutable constructs here!
    # Technically, such PCRE is somewhat inefficient: the negative lookahead
    # "(?!`)" only needs to prefix the "(?&sub)" and "." alternatives. Since
    # "`" is deprecated and never appears in the zeshy codebase, however, we
    # currently ignore such inefficiencies for simplicity.

    #FUXME: Replace all instances of  ${pcre_here_doc} with "(?&here)".
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    #FUXME: Note the repetition between this and the following PCRE. Such body
    #should be extracted into a new common PCRE -- say,
    #${pcre_word_parens_body} -- and interpolated into both this
    #PCRE and the PCRE below.

    #FUXME: This can be optimized by reduction to:
    #
    #     local pcre_words_parens_body=${pcre_words_parens_unquoted_chars}'|'${pcre_word_parens_unquoted_balanced}'|'${pcre_embeddable_or_quotes}
    #
    #Then expand such PCRE where we currently expand ${pcre_words_parens}.

    # local pcre_words_parens='(?:'${pcre_words_parens_unquoted_chars}'|'${pcre_word_parens_unquoted_balanced}'|'${pcre_embeddable_or_quotes}'|'${pcre_char_escaped}')+'
    # local pcre_word_parens_unquoted_balanced='\((?:'${pcre_words_parens_unquoted_chars}'|'${pcre_embeddable_or_quotes}'|'${pcre_char_escaped}')*\)'
    # local pcre_word_parens_unquoted_char='(?:[^'${char_not_word_parens_unquoted}']+|'${pcre_char_escaped}')'
    # local pcre_word_parens_unquoted_chars=${pcre_word_parens_unquoted_char}'+'

    # local pcre_process_substitution_dollar_nonrecursive='`(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_comment_optional}'|(?!`)(?:'${pcre_code}'|.))*`'

    #FUXME: Give me another eyeball over, please.
    # local pcre_process_substitution_dollar_recursive='(?:'${pcre_list_assignment}'|[^)'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_comment_optional}'|'${pcre_code}'|[^)])*'
    # local pcre_macro_arg_block_body='(?:'${pcre_word_braces}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^}])*'

    # Block delimiter "}". As ${char_not_word_unquoted} documents, such "}" must
    # be suffixed by at least one horizontal whitespace or newline character
    # (optionally preceded by zero or more line continuations). To support
    # macros accepting two or more consecutive argument blocks, avoid matching
    # suffixing whitespace matched as prefixing whitespace by the next such
    # block by merely asserting this constraint with positive lookahead.
    #FUXME: This is terrible. More to the point, given the refactored
    #${pcre_word}, this is no longer required. Instead, refactor
    #${pcre_macro_arg_block_body} below to leverage ${pcre_word} rather than
    #the current negative character class-driven approach. This *SHOULD*
    #substantially reduce the complex of such PCRE, as well as improving the
    #efficiency. (*SHOULD*, anyway.)
    #FUXME: O.K.; we should be good to go to excise both ${pcre_char_block_prefix}
    #and ${pcre_char_block_suffix}. This will invoke backtracking on edge-case
    #failures (...actually, not, come to think), but should nonetheless work
    #capably under all substrings.
    # local pcre_block_suffix_lookahead=${pcre_line_continuations_optional}'(?:'${pcre_space_horizontal}'|'${pcre_line_end}')'
    # local pcre_char_block_suffix='\}(?='${pcre_block_suffix_lookahead}')'

    #FUXME: The current definition of ${pcre_process_substitution_dollar_recursive} is
    #sadly incorrect as well, as it fails to match "$( print file*.txt(.) )"
    #correctly. Interestingly, such PCRE fails for the exact same reason that
    #we required lookahead ahead. Hence, the exact same solution of replacing
    #the current negative character class-driven approach in such PCRE with a
    #${pcre_word}-based solution *SHOULD* amend that and similar issues. Oh!

    # Non-block delimiter "}" (i.e., a "}" *NOT* followed by the syntax
    # qualifying such "}" as a block delimiter).
    # local pcre_brace_right='\}(?!'${pcre_block_suffix_lookahead}')'

    #FUXME: While a highly unlikely edge case, we suspect block "{" delimiters
    #may be preceded by "|" without intervening whitespace. Perhaps not? Not
    #terribly critical, but worth investigating.

    #FUXME: Optimizable, possibly? ${pcre_word_braces} may *ONLY* be followed
    #by either the terminating "}" *OR* by whitespace (either vertical or
    #horizontal).

    #FUXME: The fact that we're capturing grouped substrings here suggests that
    #this will almost certainly interfere with captured group indices.
    #Subroutines provide a nice way around this. Alternately, we vaguely recall
    #a "(*...)"-style directive for clearing previously captured groups. "\K"
    #also effects something similar. Investigate. Contemplate.
    #FUXME: While subroutines *WOULD* work here to effectively "erase" such
    #capturing, a more efficient alternative would be to ensure that
    #${ZESHY__MACRO_PCRE} is designed in such a way that:
    #
    #* The macro name is *ALWAYS* the first captured group.
    #* Invalid macro arguments are *ALWAYS* the last captured group.
    #
    #In such case, the latter may be reliably indexed as ${match[-1]}. (We'll
    #need to modify the index globals below accordingly.) Given that, all
    #intermediate captured groups would simply be ignorable. Sounds good, no?
    #FUXME: Oh, and given the fact that here-documents group, we *REALLY* want
    #to rename all such PCREs below to reflect that.
    #FUXME: No, no, no. After briefly flirting with such nomenclature change,
    #it's clear that we would be capturing here-document delimiters in so many
    #PCREs that we'd probably end up with a countably infinite number of empty
    #groups preceding a captured syntactically invalid macro group. This is
    #nonsense, and probably equally as inefficient as simply subrouting
    #here-documents -- which, clearly, is what we're going to do instead. Yay!
    #Happily, such subroutine calls may be optimized by being prefixed by
    #positive lookahead: e.g.,
    #
    #    (?=<)(?&here)

    #FUXME: Unused anywhere. Why? We'll need to at least ensure that
    #${pcre_word_unquoted_char_first_last} is being used.

    # Unquoted shell word, comprising one or more characters that are *NOT*
    # shell-reserved.
    # local pcre_word_unquoted='(?:'${pcre_word_unquoted_char_first}${pcre_word_unquoted_chars_middle_optional}${pcre_word_unquoted_char_last}')|'${pcre_word_unquoted_char_first_last}')'

    #FUXME: Define ${pcre_words_parens} above.

    #FUXME: O.K.; so, to do this, we need to implement support for balanced
    #(but *NOT* nested) parens in an unquoted fashion. Shouldn't be terribly
    #difficult, but you know the score.

    # First, middle, and last substrings of a shell word embedded in "$("-
    # and ")"-delimited code blocks.
    # local pcre_word_parens_first_last=${pcre_word_parens_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_parens_first='(?:'${pcre_word_parens_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_parens_last='(?:'${pcre_word_parens_unquoted_char_last}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_parens_middle='(?:'${pcre_word_parens_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_parens_middle_optional=${pcre_word_parens_middle}'*'

    # local pcre_word_parens_middle='(?:'${pcre_word_parens_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_parens_middle_optional=${pcre_word_parens_middle}'*'
    # local pcre_word_parens_unquoted_balanced='\('${pcre_words_parens_middle_optional}'\)'

    #FUXME: Actually use this. Or excise, perhaps? In the latter case, we'll
    #need to ensure we're using ${pcre_word_braces_unquoted_char_first_last}.

    # Unquoted shell word embedded in "{"- and "}"-delimited code blocks.
    # local pcre_word_braces_unquoted='(?:'${pcre_word_braces_unquoted_char_first}${pcre_word_braces_unquoted_chars_middle_optional}${pcre_word_braces_unquoted_char_last}')|'${pcre_word_braces_unquoted_char_first_last}')'

    # Unquoted shell word embedded in "$("- and ")"-delimited process
    # substitutions.

    #FUXME: Use in process substitutions to match "$( ugh*.txt(.) )"? That, or
    #we'll probably need to leverage lookahead. (Ugh! This is terrible. Perhaps
    #just ignore such edge case for now?)
    # local pcre_word_parens_unquoted='[^'${char_not_word_parens_unquoted}']++'

    #FUXME: O.K.; so, we do *ABSOLUTELY* want to use this. Indeed, we can
    #actually use a truncated form of ${char_not_word_unquoted} ignoring
    #non-conflicting syntax (e.g., "{", "}", "|", etc.), meaning that we can
    #produce a vastly simplified variant of ${pcre_word} specific to process
    #substitutions -- say, ${pcre_word_parens}.

    #FUXME: Actually, we probably *NEVER* need to match the old math
    #substitution form, as such form should conflict with no existing syntax.
    #Excise, please!
    # local pcre_math_substitution_old='\[(?:[^\]'${char_not_substitutable_prefix}']++|'${pcre_char_escaped}'|(?&sub)|[^\]])*\]'

    # in both current (i.e., "$(("- and "))"-delimited) and obsolete (i.e.,
    # "$["- and "]"- delimited) forms.

    #FUXME: Refactor to use ${pcre_word_braces} here.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment_body}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_word_braces}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^}])*'
    # local pcre_macro_arg_block_body='(?:[^{}'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code}'|[^}]|'${pcre_brace_right}')*'

    # escaping characters, including the above such prefixes.
    # local pcre_embeddable=${pcre_dollar_substitution}'|'${pcre_process_substitution_dollar_nonrecursive}
    # pcre_macro_subroutines_body+='(?<sub>'${pcre_embeddable}')'

    # local pcre_embeddable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}

    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment_body}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:[^{}'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code}'|[^}]|'${pcre_brace_right}')*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_macro_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    # local pcre_word_braces_unquoted='[^'${char_not_word_braces_unquoted}']++'

    #FUXME: Likewise, we should produce a new ${pcre_word_braces} similarly
    #ignoring non-conflicting syntax nested inside of a block argument (e.g.,
    #"|", etc.). Note, however, that we *MUST* retain ${pcre_word} for use in
    #detecting standard arguments at the outermost level.

    #FUXME: Actually, even that doesn't quite suffice. We realized that such
    #PCRE also fails to match "$( :list y; y=( ) )". Hence, we'll now need to
    #match list assignments *ONLY* inside process substitutions. *sigh*

    # local pcre_macro_args_zsh_optional=${pcre_spaces_word}'(?:'${pcre_word}${pcre_spaces_word}')*'

    #FUXME: Use of ${pcre_line_end} is insufficient both here and below.
    #Numerous syntactic primitives effectively terminate the current command
    #and hence macro, including "|", ">", and non-here-specific "<". Any
    #others? (Probably not, but contemplate.)
    #
    #O.K.; after examination, "|", ">", and "<" should absolutely suffice. Oh,
    #and ";", of course. Yes!

    #FUXME: Shift above and use everywhere we use ${pcre_line_end} below.

    # Macro terminator, either the end of the current line *OR* any of the
    # several standard command terminators.
    # local pcre_macro_end='(?:'${pcre_line_end}'|'${pcre_command_end}')'

    #FUXME: O.K.; so, we're implementing an increasing amount of work,
    #complexity, and inefficiency -- all to match  
    # Zero or more command-specific whitespace sequences. Technically, this
    # PCRE is optimizable to:
    # local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'

    # local pcre_here_string_prefix='<'${pcre_word_spaces_optional}
    #FUXME: We need to actually ensure that *ALL* negative character classes
    #contain "\" and then modify the PCREs embedding such classes to match
    #${pcre_char_escaped}. Grep everywhere below, we're afraid, for "[^".

    # Zero or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments).

    # local pcre_word_unquoted_char_last=${pcre_word_unquoted_literal_char_last}
    #FUXME: Insufficient; "}" is *NOT* an unquoted shell word.

    # local  pcre_word_unquoted_char_middle='(?:'${pcre_word_unquoted_literal_char_middle}'|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'+'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'?'

    # local  pcre_word_unquoted_char_first='(?:'${pcre_char_escaped}'|[^'${char_not_word_unquoted}'{])'
    # local   pcre_word_unquoted_char_last='[^'${char_not_word_unquoted}'}\\]'
    # local pcre_word_unquoted_char_middle='(?:'${pcre_char_escaped}'|[^'${char_not_word_unquoted}'])'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'++'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'?'

    # local  pcre_word_unquoted_literal_char_first='[^'${char_not_word_unquoted_literal}'{]'
    # local   pcre_word_unquoted_literal_char_last='[^'${char_not_word_unquoted_literal}'}]'
    # local pcre_word_unquoted_literal_char_middle='[^'${char_not_word_unquoted_literal}']'
    # local pcre_word_unquoted_literal_chars_middle_optional=${pcre_word_unquoted_literal_char_middle}'?'

    # Unquoted literal shell word, comprising one or more shell-unreserved,
    # "\"-unescaped characters.

    # Character class matching invalid characters in unquoted literal shell
    # words (i.e., shell words interpreted literally and hence *NOT* containing
    # escaped characters), comprising most shell-reserved characters along with
    # character escape "\".
    # local char_not_word_unquoted_literal=${char_not_word_unquoted}'\\'

    # To ensure this, the character escape "\" must *ALWAYS* be 

    #FUXME: Incorrect, as we also need to match comments and "{" delimiters at
    #the start of lines when *NOT* prefixed by line continuations. (Good lord.)
    #Incidentally, this suggests we're probably matching comments incorrectly
    #everywhere else as well.
    #FUXME: O.K.; we *ARE* dealing with comments appropriately elsewhere. While
    #confirming this, we also noted that we deal with whitespace in a
    #considerably simpler and more straightforward manner than we do here.
    #On the face of it, there doesn't *APPEAR* to be any reason that we can't
    #supplant ${pcre_macro_arg_block_spaces} with ${pcre_line_start_or_spaces_horizontal}
    #(which, clearly, should be renamed and shifted to the "spaces" section).
    #Clearly, we wanted to prevent a line continuation followed immediately by
    #"{" from being matched as a block prefix. But, if you consider it,
    #${pcre_line_start_or_spaces_horizontal} already ensures this! So, embedding
    #${pcre_word_spaces_prefixed_by_spaces} here gains us nothing. Thankfully,
    #this would appear to be among the last PCRE chores.
    # local pcre_macro_arg_block_spaces='(?:'${pcre_line_start}'|'${pcre_word_spaces_prefixed_by_spaces}')'
# ${pcre_line_start_or_spaces_horizontal}

    # local pcre_line_start_or_spaces_horizontal='(?:'${pcre_spaces_horizontal}'|'${pcre_line_start}${pcre_spaces_horizontal_optional}')'

    #FUXME: Still required? Ideally, this should be excisable.

    # One or more horizontal whitespace characters optionally followed by a
    # comment.
    # local pcre_spaces_horizontal_and_comment_optional=${pcre_spaces_horizontal}'(?:'${pcre_comment_body}')?'

# ${pcre_spaces_horizontal_and_comment_optional}'
    #FUXME: Concoct ${pcre_here_optional} if not already. Excise now redundant
    #PCREs (e.g., ${pcre_macro_here_optional}).
    #FUXME: Abstract "[^'${char_space_vertical}']++" into a PCRE local.
    # local pcre_macro_args_zsh_or_block_optional='(?:'${pcre_spaces_word}'(?:'${pcre_word}'|'${pcre_macro_arg_block}'))*'
    # local pcre_macro_args_optional='(?:'${pcre_macro_args_zsh_or_block_optional}${pcre_word_spaces_optional}${pcre_here_optional}${pcre_line_end}'|([^'${char_space_vertical}']++))'

    # arguments of any type.
    # To assist the preprocessor in
    # differentating between syntactically valid macros accepting no arguments
    # and syntactically invalid macros accepting arguments, embed an empty
    # group at some arbitrary position in such PCRE. Differentiating such cases
    # then reduces to testing the length of canonical list global ${matches}.
    # While we could also effect this by capturing the entire substring matched
    # by such PCRE, doing so has no demonstrable benefit over the current
    # approach while incurring minor time and space costs. So, the current
    # approach reigns.

    #FUXME: This is a wee crazy. Is there no terser solution?
    # local pcre_macro_args_zsh_or_block_optional='(?:'${pcre_spaces_word}'(?:'${pcre_word}'|'${pcre_macro_arg_block}'))*'

    # One or more standard arguments, comprising one or more shell words all of
    # which are delimited by shell word-specific whitespace. Such condition
    # prevents whitespace suffixing the last such argument from being matched,
    # ensuring such whitespace will be matched only as the mandatory whitespace
    # prefixing a subsequent block argument if any or otherwise ignored. (Since
    # unquoted whitespace is significant only for argument delimitation in both
    # zsh and zeshy, trailing unmatched whitespace is safely ignorable.)
    # local pcre_args_zsh=${pcre_word}'(?:'${pcre_spaces_word}${pcre_word}')*'
    # local pcre_args_zsh_optional='(?:'${pcre_args_zsh}')?'

    #FUXME: Correct the definition of ${pcre_word_unquoted} above.
    #FUXME: Erroneous, as ${pcre_here} has yet to be defined. We suspect
    #circular dependencies due to here-strings.

    #FUXME: Apply all fixes to this PCRE to the following PCRE.
    # local pcre_word_unquoted_literal='[^'${char_not_word_unquoted_literal}']++'

#  As ${char_not_word_unquoted} documents, character "}"
    # when conditionally followed by horizontal whitespace is shell-reserved
    # and must be excluded.

    #FUXME: Not quite right. "}ounhou" is a valid unquoted word and should be
    #matched by this PCRE. Likewise, a "{" preceded by horizontal whitespace is
    #invalid and must *NOT* be matched this PCRE. We'll probably want to
    #redesign this in favor of the current ${pcre_word} approach.
    # local pcre_word=${pcre_word_first}'(?:'${pcre_words_middle_optional}${pcre_word_last}')?'
    # local pcre_word_unquoted='[^'${char_not_word_unquoted}']++|'${pcre_brace_right}

    # ..................{ MACRO ~ word                       }..................
    # Optional here-document or -string.
    # Here-document or -string prefixed by one or more horizontal whitespace
    # characters.
    # local pcre_macro_here_optional='(?:'${pcre_word_spaces_optional}${pcre_here}')?'

    # local pcre_macro_here_optional='(?:'${pcre_word_spaces_optional}${pcre_here}')?'
    # '(?:'${pcre_spaces_word}${pcre_word}')*
    # '(?:'${pcre_word}${pcre_spaces_word}')*'
    # local pcre_macro_args_optional='(?:(?:'${pcre_spaces_word}'(?=([^'${char_space_vertical}']?))(?:'${pcre_args_zsh_optional}${pcre_macro_arg_blocks_optional}')*'${pcre_macro_here_optional}')?'${pcre_line_end}${pcre_empty_group}')?'
    # local pcre_macro_args_optional='(?:(?:'${pcre_spaces_word}'(?=([^'${char_space_vertical}']))(?:'${pcre_macro_arg_block}'|'${pcre_args_zsh}')*'${pcre_macro_here_optional}')?'${pcre_line_end}${pcre_empty_group}')?'
    # local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_spaces_word}'(?:'${pcre_macro_arg_block}'|'${pcre_args_zsh}')*)?'

#, and named accordingly
#zsh_optional_grouped
    #FUXME: Still not quite right: must match suffixing whitespace if any.
    # local pcre_macro_args_zsh_optional_grouped='('${pcre_spaces_word}${pcre_args_zsh_optional}')'

    #FUXME: Excrutiatingly simple. Simply replace by the two PCREs such PCREs
    #expand to. *sigh*
    # local pcre_word_spaces_and_args_zsh_optional=${pcre_spaces_word}${pcre_args_zsh_optional}
    # local pcre_word_spaces_and_args_zsh_optional=${pcre_spaces_word}'(?:'${pcre_word}${pcre_word_spaces_optional}')*'
    # local pcre_word_spaces_and_args_zsh_optional_grouped='('${pcre_word_spaces_and_args_zsh_optional}')'

    #FUXME: Subtly broken. Why? Because combining ${pcre_word_spaces_optional}
    #with ${pcre_word} permits otherwise impermissible lexical combinations: in
    #particular, " { ". Such combinations *MUST* be prohibited here. Note,
    #also, that we probably have a similar problem anywhere else that we've
    #combined words with spaces. We'll probably want to grep about for other
    #instances of such error.
    #
    #The simplest fix would be to prefix ${pcre_brace_left} be negative
    #lookbehind prohibiting "{" preceded by whitespace. No; that doesn't work,
    #because of line continuations. Hmmm; so, we need to refine
    #${pcre_word_unquoted} to prevent such PCRE from matching either a lone "{"
    #or lone "}". Hmmm; but that doesn't seem quite precise enough. Here's what
    #we need to handle: if at least one horizontal whitespace character is
    #matched, the following character *CANNOT* be a "{".
    #
    #O.K.; it really does seem that ${pcre_word_unquoted} should prohibit "{"
    #as the first character and "}" as the last. That would probably solve all
    #issues with the current approach, yes?
    #
    #Wrong. We want to improve ${pcre_word} such that only the first and
    #last if any words are constrained to prohibit an unquoted prefixing "{" or
    #suffixing "}" from being matched.

    # local pcre_args_zsh=${pcre_word}'(?:'${pcre_word_spaces_optional}${pcre_word}')*'
    # local pcre_word_unquoted='(?:'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'
    # local pcre_words_unquoted=${pcre_words_unquoted}'+'
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    # local char_not_word_unquoted=${char_space}'''"$<>|`'

    # For subtle reasons, this includes the conditionally shell-reserved
    # character "}" but *NOT* "{". "{" is only shell-reserved when preceded by
    # horizontal whitespace; "}" is only shell-reserved when followed by
    # horizontal whitespace. Since this class is only interpolated into
    # negative character classes, such classes exclude horizontal whitespace
    # and hence "{" as a shell-reserved character. Hence, "{" need (and indeed
    # *MUST*) not be listed in this class. "}", however, *MUST* be explicitly
    # listed here and then subsequently matched outside such classes when *NOT*
    # suffixed by horizontal whitespace. (Oh, shell life is complicated.)
    # local char_not_word_unquoted=${char_space}'''"$}<>|`'

  # Ideally, this includes all strings passable
    # as a standard argument to a zsh command.
    # local pcre_word='(?:[^'${char_not_word_unquoted}'{]|'${pcre_embeddable_or_quotes}')(?:(?:[^'${char_not_word_unquoted}'}]|'${pcre_embeddable_or_quotes}'))?'
    # local pcre_word=${pcre_word_first}'(?:'${pcre_word_middle}'*'${pcre_word_last}')?'
    # local pcre_word=${pcre_word}'+'

    # local pcre_word_unquoted='[^'${char_not_word_unquoted}']++|'${pcre_brace_right}
    # local  pcre_word_first_unquoted='[^'${char_not_word_unquoted}'{][^'${char_not_word_unquoted}']*+'
    # local pcre_word_middle_unquoted='[^'${char_not_word_unquoted}']++'
    # local   pcre_word_last_unquoted='[^'${char_not_word_unquoted}']*+[^'${char_not_word_unquoted}'}]'

    # local pcre_word='(?:'${pcre_word_unquoted}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'

    #FUXME: We're probably going to have issues with possessiveness here. Why?
    #Because ${pcre_spaces_word} matches horizontal whitespace possessively,
    #preventing backtracking if the non-whitespace following such whitespace
    #constitutes a valid block argument. That's bad.

    # PCRE unconditionally reporting failure.
    # ZESHY__PCRE_REPORT_FAILURE

    #FUXME: Use in ={frontend.zy}, replacing current glob usage.

# PCRE fragment prefixing ${ZESHY__MACRO_PCRE} the PCRE defined by
# ::preprocessor_pcres.make_if_needed() matching zero or more macros *OR*
# syntactic constructs possibly containing macro-like substrings.

    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE=
    # local pcre_macro_name_grouped_lookahead='(?=([^'${char_space}'\\]++)'

    # Character class matching invalid characters in macro names during
    # positive lookahead capturing such names. While we could simply replace
    # this class by embedding ${ZESHY__MACRO_NAME_VALID_PCRE} instead, the
    # former is considerably shorter and hence more efficient than the latter.

    #FUXME: Actually use such class in lookahead below.

    # local pcre_not_macro_name_lookahead=${char_space}'\\'

#  Since macro names are necessarily
    # unquoted *AND* since the first character of unquoted shell words are
    # constrained by additional 
    #
    # This omits characters only conditionally valid in certain positions
    # of macro names (e.g., "~", valid everywhere *EXCEPT* as the first
    # character of such names).

    # Character class matching invalid characters in macro names, comprising
    # all PCRE- *AND* shell-reserved characters. Since PCRE-reserved characters
    # in macro names *COULD* technically be explicitly escaped, only shell-
    # reserved characters need to be prohibited. For simplicity, we currently
    # prohibit both classes of characters.
    # local char_not_macro_name=${char_space}'''"*+?!#^$(){}[]<>&|\\`'

    # Technically, "(" and ")" are also only conditionally shell-reserved.
    # Nonetheless, prohibit both for simplicity.

    #FUXME: Make sure we're not using "\h", "\v", or "\s" anywhere anymore.
    #FUXME: Globalize.

    # PCRE fragment prefixing ${ZESHY__MACRO_PCRE}, matching zero or more macros
    # *OR* syntactic constructs possibly containing macro-like substrings.
    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE_PREFUX=${pcre_options_anchored}${pcre_word_spaces_and_args_zsh_optional_grouped}${pcre_macro_arg_block}${ZESHY__MACRO_SUBROUTINES}

    # PCRE matching macro *OR* syntactic construct possibly containing
    # macro-like substrings. In the former case, such macro's name and all
    # passed arguments will be captured.
    # ZESHY__MACRO_PCRE=${pcre_macros_grouped_report_success_or_codes_report_failure}

# PCRE subroutines defined below, concatenated in a manner preventing such
# definitions from either matching *OR* capturing in place.
#
# Much like programmatic subroutines, PCRE subroutine are self-consistent units
# preserving a semblance of local scope; for example, PCRE subroutines prevent
# substrings captured by such calls from leaking to callers (e.g., subroutines,
# zsh code) by snapshotting the state of all captured substrings on entering
# such call and restoring such state on leaving such call. In other words,
# subroutines impose non-negligible time and space costs.
#
# For efficiency, subroutines should be leveraged *ONLY* where required.
# Typically, this means recursion matching delimiter-balanced syntactic
# constructs in a context-free manner. In all other cases, PCREs should be
# encapsulated as string variables and interpolated directly where used.
# typeset -g ZESHY__MACRO_SUBROUTINES

#  For
    # further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
# All PCRE subroutines defined below, concatenated in a manner preventing such
# definitions from matching. Such subroutines remain callable and hence are
# defined only for recursion purposes.

    # If *NO* macros were previously registered, clear the prior PCRE to
    # prevent spurious or scurrilous preprocessor behaviour.
    # (( ZESHY__MACRO_TO_FUNC_NAME )) || pcre_macro_or_code_optional_grouped=

    # Macro *OR* comment possibly containing zsh syntax-like substrings.
    # local pcre_macro_grouped_report_success_or_comment_optional=${pcre_macro_prefix}'(?:'${pcre_comment_body}'|'${pcre_macro_grouped_report_success}')?'

    # Macro, comprising such macro's name and all passed arguments. Since the
    # macro prefix is zero or more horizontal whitespace characters anchored to
    # the start of a line, such prefix is identical to a comment prefix and
    # hence matched below for both macros and comments.
    # local pcre_macro_grouped_report_success=${pcre_macro_name_grouped}${ZESHY__MACRO_ARGS_OPTIONAL_REPORT_SUCCESS}

    # local pcre_macros_grouped_report_success_or_codes_report_failure='(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_macro_grouped_report_success_or_comment_optional}'|'${pcre_code}'|.)*'${pcre_report_failure}

    # For efficiency, success is reported immediately after matching such
    # macro's last character (e.g., the last character of the last argument
    # passed to such macro). To distinguish syntactically valid from invalid
    # macros, *ALL* macro-specific substrings following such name are optional.

    # and :list.join_to_string_on_char().
    #FUXME: O.K.; technically, this works. But it's *SUPER* inefficient.
    #Why? Because it forces pcre_match() calls *NOT* matching a macro te be
    #ignored and simply iterated past. This is horrible, and should be
    #correctable. (Or... maybe not. Contemplate further.)
    #FUXME: Actually, this is erroneous! "^" and "$" are zero-width assertions
    #consuming no characters. Hence, we'll need to manually consume newlines.
    #Sadly, we've probably screwed this up above as well, where we're matching
    #argument block prefixes and suffixes. (Oh, and here-docs!)
    #FUXME: We're also fairly sure that newlines are *NOT* matched properly. A
    #concrete example: blank lines (i.e., "\n\n"). Do we match that?
    #FUXME: Split "${pcre_line_start_or_spaces_horizontal_spaces}'(?:'${pcre_comment_body}')?"
    #into a new PCRE above.

    # local pcre_macro_or_code_optional_grouped='(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_macro_or_comment_optional_grouped}'|'${pcre_code}'|.)'

# For efficiency, match such macro's prefix below.
    # , where we may more efficiently match both
    # macros and comments.

    #FUXME: Use of ${pcre_spaces_horizontal_optional} both here and below is
    #probably erroneous.

    # Since the "." in ${pcre_here_doc_body} matches newlines, zero-width
    # assertions "^" and "$" are acceptable here.

    #FUXME: Use in place of "\v" below. *sigh*

    # By design, there exists no comparable PCRE local ${pcre_line_end} (i.e.,
    # matching the end of the current line, consuming the suffixing vertical
    # whitespace character if any). Since this PCRE consumes newlines,
    # permitting another general-purpose PCRE to consume newlines would
    # prevent this PCRE from matching in a general-purpose manner. (Not good.)

    # local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    # local pcre_word_spaces_prefixed_by_spaces_optional='\h*+(?:'${pcre_line_continuation}'\h*+)*'

    #FUXME: Optimizable. By the above ${pcre_words_spaces} technique, such
    #alternation may be improved by noting that ${pcre_args_zsh} and
    #${pcre_macro_arg_block} *MUST* always alternate.
    # local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_spaces_word}'(?:'${pcre_args_zsh}'|'${pcre_macro_arg_block}')*)'

    # One or more command-specific whitespace sequences. Since line
    # continuations are merely ignorable rather than actual whitespace, match
    # at least one horizontal whitespace character. Interestingly, this
    # constraint engenders a simpler and presumably more efficient PCRE.
    #FUXME: Hmm. Don't we usually implicitly match prefixing line continuations
    #now by use of ${pcre_char_escaped}? Where doing so, replace use of this
    #PCRE by the slightly more efficient
    #${pcre_word_spaces_prefixed_by_spaces_optional} instead.

#  Technically, this
    # PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.
    # local pcre_word_spaces_optional='(?:\h*+'${pcre_line_continuation_optional}')*'

    #FUXME: We used to have "\h" in character classes here; now we effectively
    #have "\s", thus matching line continuations. While probably not a terrible
    #thing, this does seem slightly inefficient, given that
    #${pcre_macro_arg_block_or_comment_optional} *ALSO* attempts to match such
    #continuations
    #FUXME: O.K.; the core issue at hand is that
    #${pcre_macro_arg_block_or_comment_optional} is prefixed by
    #${pcre_spaces_word}, itself prefixed by
    #${pcre_line_continuations_optional}, which is unnecessary in this case and
    #*ONLY* this case.

    #FUXME: Honestly, when in reality would we *EVER* see adjacent line
    #continuations? While we of course need to match such edge case, explicitly
    #optimizing for it as we do so here strikes us as useless. Supplant all use
    #of either of the following two PCREs by their singular versions above.

    # local pcre_spaces_word='(?:'${pcre_line_continuations_optional}'\h++)+'${pcre_line_continuations_optional}
    # local pcre_spaces_word=${pcre_line_continuations_optional}${pcre_word_spaces_prefixed_by_spaces}
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    #FUXME: Hmm. Don't we *ALWAYS* implicitly match prefixing line
    #continuations now by use of ${pcre_char_escaped}? If so, this PCRE is
    #excisable and ${pcre_word_spaces_optional} reducible to:
    #
    #    local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}')?'
    #
    #We probably want to drop the "_prefixed_by_spaces", as well.
    #FUXME: Actually, since the PCRE above is the common case and the PCRE
    #below the edge case, consider just eliminating the PCRE below and instead
    #defining ${pcre_word_spaces_optional} as follows:
    #
    #    local pcre_word_spaces_prefixed_by_spaces='\h++(?:'${pcre_line_continuation_optional}'\h*+)*'

    # One or more command-specific whitespace sequences, prefixed by at least
    # one line continuation.
    # local pcre_word_spaces_prefixed_by_line_continuations=${pcre_line_continuations}'(?:\h++'${pcre_line_continuations}')*\h*+'

    #FUXME: This strikes us as increasingly absurdly overwrought. Reconsider.
       # local pcre_word_spaces_prefixed_by_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}')?'

    #FUXME: O.K.; so we're not necessarily convinced that lookbehinds are
    #sufficient to match line continuations. Consider:
    #
    #    # Not a line continuation, due to being commented out.
    #    >>> # \
    #
    #We need to closely examine where we're using such continuations.
    # local pcre_line_continuation='(?<!\\)\\\v'

    # End of the current line, consuming the suffixing vertical whitespace
    # character if any. "$" is a zero-width assertion consuming no characters
    # and hence inappropriate for most uses below (excluding lookahead).
    # local pcre_line_end='(\v|\z)'

# (Disambiguating the two requires explicitly matching both.)
    # PCRE capturing the macro name and all block argument bodies in a
    # preprocessor macro. To distinguish syntactically valid from invalid
    # preprocessor macros, all syntax following the macro name is optional.

    # '\h++(?:'${pcre_line_continuations}'\h++)*'${pcre_line_continuations_optional}
    # local pcre_spaces_word=${pcre_line_continuations_optional}'\h++'${pcre_word_spaces_optional}

    # Zero or more command-specific whitespace sequences (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # most whitespace but excluding unescaped newlines (i.e., newlines *NOT*
    # prefixed by "\"). While escaped newlines are line continuations
    # preserving the current command and hence effectively whitespace,
    # unprefixed newlines are effectively semicolons terminating such command.
    #
    # Technically, this PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.
    # local pcre_word_spaces_optional='(?:\h++(?:'${pcre_line_continuations}'\h++)*'${pcre_line_continuations_optional}'|'${pcre_line_continuations}'(?:\h++'${pcre_line_continuations}')*\h*+)?'

    # local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    # local pcre_spaces_word=${pcre_line_continuations_optional}'\h++'${pcre_word_spaces_optional}

#  (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # all whitespace except newlines *NOT* prefixed by "\". While "\"-prefixed
    # newlines are line continuations preserving the current command,
    # unprefixed newlines are effectively semicolons terminating such command
    #FUXME: Refactor inefficient negative character classes as follows both
    #here and below, wherever applied:

    #FUXME: Not quite. We need to ignore everything after a comment prefix "#"
    #until the end of the line, as well. Unfortunately, differentiating such
    #prefix from "#" characters embedded in other contents (e.g., variable
    #expansions, unquoted globs) is *HIGHLY* non-trivial.
    #
    #Actually, it shouldn't be. zsh comments should *ALWAYS* unconditionally be
    #detectable by being prefixed by either the start of the line *OR*
    #non-empty horizontal whitespace (assuming strings to be properly matched,
    #anyway). That doesn't appear to be the case for all other uses of "#",
    #which appear to *ALWAYS* be prefixed by something other than what prefixes
    #a comment. Hopefully, there exist no exceptions to such heuristic.
    #
    #Actually, *DO* we need to match comments? Well, yes, technically. Consider
    #the following:
    #
    #    # If we ignore comments, then the " basically causes havoc.
    #    if :is uuugh == u##gh :si { # " uhoh
    #        :macro
    #    }
    #FUXME: The above implies that we need to prevent unquoted "#" characters
    #prefixed by blahblah from being matched into macro argument lists. Such
    #characters *MUST* terminate such lists.

    #FUXME: The above also implies that we *DO* need to ignore double-quoted
    #strings and such as well here, to ensure proper matching of single-quoted
    #strings. Failure to do this *WILL* cause extreme parsing havoc. While this
    #does currently prevent us from embedding macros in process substitutions,
    #it's difficult to conceive of a situation in which we'd want to do so. So,
    #let's do this, execrable though it may be.

    #FUXME: Interesting. We've unrelatedly realized that, since "\"
    #unconditionally escapes the following character, we can reduce all
    #"\\[...]" alternatives to simply ${pcre_char_escaped}, where:
    #    local pcre_char_escaped='\\.'
    #We'll want to make such change everywhere, of course, including above.

# \\["'${char_not_substitutable_prefix}']
# \\[}'${char_not_substitutable_prefix}']
# \\[\]'${char_not_substitutable_prefix}']
# \\[)'${char_not_code_prefix}']
# \\[}'${char_not_code_prefix}']
# \\['${char_not_code_prefix}']
# \\[}'${char_not_code_prefix}']

    #FUXME: Fixmeplz. Actually, we're fairly certain we can excise this such
    #subroutine, convert this back into a PCRE local, and shift above.

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing and hence parsing of unquoted "{" and "}" characters.
    # Unlike shell word matching, this does *NOT* include unquoted characters.
    # pcre_macro_subroutines_body+='(?<code>'${pcre_quotes_single}'|'${pcre_here}'|'${pcre_quotes_double}'|'${pcre_embeddable}')'

#\s)''"$\\<`
    #FUXME: Avoid repetition. We're seeing the following character classes
    #heavily reused. Abstract out to a sensible string local above.

    #FUXME: And comments, please! Wait. Actually, comments probably have to be
    #embedded directly into PCREs below due to matching prefixing whitespace.
    #FUXME: Wait. Can't we just insert comments here and be done with it?
    #FUXME: Substitute me below for all instances of "(?&code)".

    #FUXME: The inefficient subroutine call "(?&code)" matches non-recursive
    #constructs (e.g., single-quoted strings, here-documents, here-strings).
    #Such constructs should simply be matched here with an embedded PCRE.

    # One or more horizontal whitespace characters followed by zero or more
    # such words. If one or more such words match, such words must be suffixed
    # by one or more horizontal whitespace characters.

#  Since the first
    # and last such substrings are constrained to also be shell words,
    # whitespace is permitted only between shell words.
    # Such word *OR* word-delimiting whitespace.
    # local pcre_word_or_spaces='(?:'${pcre_word}'|'${pcre_spaces_word}')'

    # Such PCRE interpolates the PCRE matching substitutables and hence must be
    # declared *AFTER* the latter.

    # Here-documents and -strings are *NOT*
    # freely mixable with standard arguments and hence unmatched here.

    # ..................{ MACRO ~ space                      }..................

    #FUXME: We're fairly certain that our comment prefix still isn't quite
    #right. Investigate: are comments immediately prefixed by line
    #continuations comments? We suspect not. That said, the zeshy codebase
    #doesn't currently contain any such monstrosities, so we can probably
    #neglect this.
    #FUXME: We're fairly sure we match line continuations anywhere where we
    #would also match comments. Verify this below.

    #FUXME: Excise this and ${pcre_here_doc_quotes}, when no longer required.
    # local pcre_here_doc_quotes_prefix=${pcre_here_doc_prefix_ignore}'(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}')$'
    # local pcre_here_doc_quotes=${pcre_here_doc_quotes_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    #FUXME: "{" and "}" are *ONLY* shell-reserved when preceded and followed
    #(respectively) by whitespace. This requires correcting. To ascertain a
    #proper fix, examine where this character class is actually used.
    #FUXME: Right. 

#  excluding "}" as a shell-reserved
    # character requires somewhat more finesse. ${pcre_word_unquoted}.
    # local pcre_block_suffix_lookahead='$|'${pcre_spaces_word}
    #FUXME: Use line continuation PCREs instead, once we correct them.

    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\\v)*)?'

    #FUXME: Use of ${pcre_spaces_word} is somewhat inefficient here. We only need to
    #match up to the first horizontal whitespace.
    #FUXME: Actually, it's also wrong. As the comment above indicates, such "}"
    #must be suffixed by at least one horizontal whitespace *OR* newline
    #character (optionally preceded by zero or more line continuations).
    # local pcre_line_continuation='(?<!\\)\\\v'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\\v)*)?'
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_spaces_word=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}

    #FUXME: Shift such "\h++" up into a new comment prefix PCRE.

    # local pcre_macro_arg_block_prefix='\{'
    # local pcre_macro_arg_block_suffix_lookahead=${pcre_spaces_word}'|\Z'
    # local pcre_macro_arg_block_suffix='\}(?='${pcre_macro_arg_block_suffix_lookahead}')'

#  Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline *NOT* prefixed by an unescaped
    # backslash (i.e., line continuation).
    # excluding the escape prefix "\".
# excluding:
    #
    # * Whitespace characters.
    # * Shell-reserved characters
    #FUXME: Still require ${pcre_embeddable}?

    # local pcre_math_substitution_new='\((?:\\[\\)$`]|[^)$`]|(?&sub)|(?!\)\)).)*\)'
    # local pcre_math_substitution_old='\[(?:\\[\\]$`]|[^]$`]|(?&sub)|[^]])*\]'
    # local pcre_var_expansion='\{(?:\\[\\}$`]|[^}$`]|(?&sub)|[^}])*\}'

    #FUXME: Prefixing whitespace will need to be integrated with other PCREs.

    # local pcre_macros_or_code_optional_grouped='\A(?:\\[\v\\''<]|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|[^''<]|'${pcre_quotes_single}'|'${pcre_here_doc_quotes}'|.)*\Z'

    #FUXME: Not quite right. We don't need to confine 
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_spaces_word=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}
    # local pcre_comment_optional='\h++'${pcre_comment_body}

    #FUXME: Comment support, please!
    # local pcre_macro_arg_block_nested=${pcre_spaces_word}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_spaces_word=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}
    # local pcre_comment_optional='\h++'${pcre_comment_body}

    # local pcre_macro_arg_block_nested=${pcre_spaces_word}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:\\[\\\h}''"$<`]|'${pcre_macro_arg_block_nested}'|[^}''"$<`]|(?&code)|[^}]|\}(?!'${pcre_macro_arg_block_suffix_lookahead}'))*'

    # local pcre_code_or_comment=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here}'|(?&sub)'

    #FUXME: Need to match and ignore comment lines. *sigh*
    #FUXME: Ugh; can't define this here. But we *DO* need to explicitly match
    #here strings. Ah! Right. Simple. All we do is match the "<" and let all
    #following text be matched by other means elsewhere.
    #FUXME: Wait. Not quite true. We match here strings for a variety of
    #purposes. We'll need to shift this below and come up with something else
    #here. New nomenclature would help.

    # local pcre_quotes_double_prefix='"(?:\\[\\"$`]|[^"$`]|'
    # local pcre_quotes_double_suffix='|[^"])*"'
    # local pcre_quotes_double=${pcre_quotes_double_prefix}${pcre_embeddable}${pcre_quotes_double_suffix}
    # local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}${pcre_embeddable_noncode}${pcre_quotes_double_suffix}

#  Unlike shell word matching, this does *NOT* include
    # unquoted characters.
#  and hence parsing of unquoted "{" and "}" characters
    # Single- or double-quoted string.
    # local pcre_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}

    #FUXME: Also omit embedded substitutions. For that reason, rename
    #"_literal" to "_literal" globally.

    #FUXME: O.K.; so, we mucked this up a bit. For both generality and
    #efficiency, replace *ALL* instances of "\R" (and ideally of "\v" as well,
    #though that naturally doesn't apply to negative character classes) by:
    #
    #* End-of-line assertion "$".
    #* Enable multiline mode with "(?m)" above.

    #FUXME: Slightly erroneous. We make the dangerous assumption in
    #::code.preprocess() that such PCRE matches only ASCII characters. Clearly,
    #however, both "\h" and "\R" match multibyte characters. To correct this
    #discrepancy, we'll want to match only the explicit ASCII characters
    #satisfying horizontal and vertical whitespace requirements in a
    #cross-platform portable manner (think Windows line endings) *AND* replace
    #all instances of "\h" and "\R" below by similar constructs.
    #
    #Unfortunately, "libpcre" documentation notes that:
    #
    #"The choice of newline convention does not affect the interpretation of
    # the \n or \r escape sequences or \R." This implies we'll need to:
    #
    # * Test the OS already detected by ={inspect}.
    # * Define a new string local ${pcre_newline} expanding to the OS-specific
    #   PCRE matching newlines.
    #
    # Annoying, but certainly feasible. For now, the current implementation
    # appears to be basically acceptable.

    #FUXME: A minor issue. If ${ZESHY__MACRO_NAMES} is empty, the resulting
    #PCRE will match in a fairly disastrous manner. Guard against such inept
    #edge cases, please.

    #FUXME: Incorrect. We want to ignore preceding newlines prefixed by "\"
    #(i.e., line continuations). Hence, explicitly match line continuations in
    #the PCRE immediately above.

    #FUXME: ${pcre_line_continuations_optional} is somewhat inefficient here.
    #By PCRE definition, we should't need to lookbehind. Or perhaps we do still
    #need lookbehind? It's either that or lookahead. Hm; honestly, cutting
    #${${pcre_line_continuations_optional}} *ENTIRELY* and then prefixing
    #${pcre_macro_prefix} by a negative lookbehind assertion ensuring such
    #newline to *NOT* be preceded by an unescaped backslash seems like the
    #somewhat simpler and hence more efficient implementation, yes?
#(?!'${pcre_macro_arg_block_suffix}')
# ${pcre_spaces_word}${pcre_macro_arg_block_prefix}'|'

#(?!<<)(?:
#'${pcre_line_continuations_optional}'|
    #FUXME: Implement me for use below.
    # local pcre_here_string_quotes_single='<\s*+'${pcre_word}

    # local pcre_zsh_grouped='(?:'${pcre_line_continuations_optional}'|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|(?!<<)(?:[^'']|'${pcre_quotes_single}'|.))*'

# local pcre_line_continuations_optional='(?<!\\)(?:\\\R)*'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}')*'

    #FUXME: Improve similar negative lookahead assertions elsewhere.

    #FUXME: Honestly, "(?!<<)" seems a bit silly. Ideally, since neither
    #here-documents or strings are recursive, such substrings should be matched
    #by an embedded PCRE here rather than a subroutine call.

    # local pcre_math_substitution=${pcre_math_substitution_new}'|'${pcre_math_substitution_old}
    #FUXME: For efficiency, combine this with ${pcre_math_substitution_new}.

    #FUXME: Sadly, we're fairly confident we need to back out most subroutine
    #calls below. The reason, of course, is inefficiency. PCRE appears to treat
    #subroutines as genuine boundaries for certain purposes; in particular,
    #PCRE copies all match groups prior to a subroutine call and then restores
    #such groups after such call. Hence, while subroutines are a fantastic
    #means of enabling recursion *AND* isolating match groups, they should be
    #avoided for all other purposes. Since we extensively leverage recursion
    #below, we *DO* need to retain subroutine support -- but only for these
    #specific purposes.

#FUXME: We should probably augment such PCREs to also capture optional here-
#documents and -strings passed to such macros and then pass either sort of
#string to such macro function on standard input as a simple here-string. The
#current approach is rather kludgy, it should be admitted. It's also not
#terribly general; after all, macros should be able to modify their output
#based on whether or not they were passed standard input as well as the exact
#content of that input. (It's only sensible, and not terribly difficult to
#implement, given current here-document and -string syntax support.)

    #FUXME: Not right either here or below. All PCRE fragments of the form
    #"[^"$`]|(?&sub)" *NEED* to be switched to
    #"(?&sub)|[^"]". Simple, thankfully.
    #FUXME: Actually, we can achieve the best of both worlds as follows:
    #    [^"$`]|(?&sub)|[^"]

    # local pcre_macro_arg_block_prefix='\{'${pcre_spaces_word}''
    # local pcre_macro_arg_block_suffix=${pcre_spaces_word}'\}(?:'${pcre_spaces_word}'|\Z)'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')*'
    # local pcre_macro_arg_block_nested=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_nested_body}${pcre_macro_arg_block_suffix}
    # pcre_macro_subroutines_body+='(?<block>'${pcre_macro_arg_block_nested}')'

    # pcre_macro_subroutines_body+='(?<macro>'${(j:|:)ZESHY__MACRO_NAMES}')'

    # local pcre_math_substitution='(?:'${pcre_math_substitution_new}'|'${pcre_math_substitution_old}')'

    #FUXME: Pointless. Excise, please.

    # Non-recursive variable expansion *OR* a literal "$" character. To match
    # the latter, match zero or more such characters. See
    # ${ZESHY_VAR_NAME_GLOB}.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    # local pcre_var_expansion_nonrecursive='[a-zA-Z_][a-zA-Z0-9_]*+'

    # Variable expansion.
    # local pcre_var_expansion='(?:'${pcre_var_expansion_nonrecursive}'|'${pcre_var_expansion_recursive}')'

    #FUXME: We probably expand such locals above. Correct circularities.
    #FUXME: Shift back above, actually.

    # local pcre_here_unsubstitutable='(?:'${pcre_here_prefix}${pcre_here}')?'

    #FUXME: Fairly certain that, as currently defined, this will erroneously
    #match *ALL* block arguments in the current code rather than merely those
    #passed to the current macro. Why? Because we haven't anchored the start of
    #such PCRE to the end of the prior iterative match. While we can't quite
    #recall how to go about such anchoring, we suspect that PCRE documentation
    #for pcre_match() should lend some insight.

# '${pcre_quotes}'|'${pcre_here}'|

    #FUXME: Convert to a conventional PCRE variable.
    #FUXME: Actually, we no longer need this at all. We never did! Rather than
    #calling the "(?&dollar)" subroutine in
    #${pcre_process_substitution_dollar_nonrecursive}, simply call the conventional
    #"(?&sub)" subroutine preceded by negative lookahead preventing a backtick
    #from matching. Since this form of process substitution is heavily
    #discouraged anyway, efficiency is of little to no concern.

    # Any of the above "$"-prefixed syntactic constructs.
    # local pcre_dollar_substitution+=

    #FUXME: Woops. Wherever we match an escaped character (e.g., "\\[)]"), we
    #need to match a an escaped "\\" *BEFORE* matching such character. Why?
    #Consider "$(( \\))". This is (sort of, anyway!) a balanced arithmetic
    #expansion and must be treated as such.
    # local pcre_backslash_escaped='\\\\'

    # When applied in an iterative context,  
    # of the first
    # byte following the last byte of the prior match. 

    #    :func :void :outer1() {
    #         :func :void :mid1() {
    #         }
    #    }
    #
    #    :func :void :outer2() {
    #         :func :void :mid2() {
    #             :func :void :inner1() {
    #             }
    #         } {
    #             :func :void :inner2() {
    #             }
    #         } <<'/---
    #    /---
    #         :func :void :mid3() {
    #             :func :void :inner3() {
    #             }
    #         } {
    #             :func :void :inner4() {
    #             }
    #         } <<'/---
    #    /---
    #    } <<'/---
    #    /---

    #FUXME: Not quite right. Rather than ineptly trying to coerce
    #${pcre_args_zsh} and ${pcre_spaces_word} together, we probably
    #probably want a new PCRE adroitly aggregating both.
    # local pcre_word_spaces_words_optional_grouped='('${pcre_spaces_word}'(?:'${pcre_args_zsh}${pcre_spaces_word}')?)'

    # local pcre_args_zsh=${pcre_word}'(?:'$pcre_word_or_spaces'*'${pcre_word}')?'
    # local pcre_args_zsh='(?:'${pcre_word}'(?:(?:'${pcre_word}'|'${pcre_spaces_word}')*'${pcre_spaces_word}')?)?'

    # Such PCRE implicitly requires backtracking and hence cannot be optimized
    # with atomic grouping.
    # local pcre_spaces_word='(?:\h|\\\R)*\h(?:\h|\\\R)*'

        # ZESHY__MACRO_MATCH_INDEX_HERE_DOC_OR_STRING
    # local pcre_args_zsh='(?:'${pcre_word}'|'${pcre_spaces_word}')*'${pcre_word}

    #FUXME: We've mucked up, it would appear. Expansions of ${pcre_word}
    #should have been expansions of this PCRE. (Ugh.)

    # local pcre_macro_args_optional_grouped='('${pcre_macro_args_optional}')'

    # To do so, append such definitions to ${pcre_macro_subroutines_body}
    # and, after doing so, prefix and suffix ${pcre_macro_subroutines_body} by the prefix
    # and suffix defined below below.  and then interpolate such string into a PCRE guaranteed to
    # never match and hence capture.

    # supports such behaviour by ignoring
    # all content aside from defining named and numbered capturing
    # groups in such content.

# efficiency and readability purposes.
    # pcre_macro_subroutines_body+='(?<quote>'${pcre_quotes_single}'|'${pcre_quotes_double}')'

    # Declare indices matched by ${ZESHY__MACRO_PCRE}, ignoring match groups
    # required only for internal use in such PCRE -- including:
    #
    # * Match group 1, capturing prefixing indentation.
    # match_index=2

    #To do so, see the section "Newline conventions" in "man pcrepattern".
    #Specifically, to quote:
    #
    #"It is also possible to specify a newline convention by starting a  pat-
    # tern string with one of the following five sequences:
    #
    #    (*CR)        carriage return
    #    (*LF)        linefeed
    #    (*CRLF)      carriage return, followed by linefeed
    #    (*ANYCRLF)   any of the three above
    #    (*ANY)       all Unicode newline sequences"
    #prepend the appropriate pattern option to the PCRE globals we construct
    #below.

    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'

    #FUXME: Replace subroutine calls called in only one place with low-level
    #variable expansions.
    #FUXME: Compress PCREs together. For example, we don't benefit from
    #separate ${pcre_macro_arg} and ${pcre_macro_args} PCREs.

    #FUXME: Capture block arguments. 
    #FUXME: Define match index globals. This is going to considerably more
    #troublesome than it otherwise would, due to each named group being
    #unconditionally captured. We'll have to ignore all such groups in a sane
    #way -- probably by incrementing in integer local here immediately after
    #defining any ignorable named group (which will be most if not all of them).

    # ZESHY__MACRO_PCRE=${pcre_macro_indentation}${pcre_macro_name}${pcre_macro_args_optional_grouped}${pcre_subroutines}

    #FUXME: Convert ${pcre_macro_arg_block} into a subroutine.

    # Zero or more arguments of any type. Since we match a run of shell words
    # greedily, avoid matching consecutive runs of shell words for efficiency.

    # local pcre_macro_args_optional='(?:'${pcre_spaces_word}'(?:'${pcre_word}'(?:(?&spaces)'${pcre_macro_arg_block}')?|'${pcre_macro_arg_block}'))*'

    #FUXME: This may be optimizable by noting that ${pcre_word}
    #matches greedily and hence cannot by definition match consecutively.
    # local pcre_macro_args_optional_grouped='((?:'${pcre_spaces_word}'(?:'${pcre_word}'|'${pcre_macro_arg_block}'))*)'

# local pcre_macro_args_optional_grouped='((?:'${pcre_spaces_word}'(?:'${pcre_macro_arg_block}'|'${pcre_word}'(?&spaces))?'${pcre_macro_arg_block}'))*)'
    # Zero or more runs of whitespace or shells words ending in a shell word.
    # local pcre_words_optional='(?:'${pcre_word}')?'

    # Argument of any type prefixed by one or more horizontal whitespace
    # characters followed by zero or more shell words.
    # local         pcre_macro_arg=${pcre_macro_arg_block}
    # local pcre_macro_arg_grouped=''${pcre_spaces_word}''${pcre_words_optional}${pcre_macro_arg_block_grouped}

#matched from a previously captured macro argument list
#''${pcre_spaces_word}''
    #FUXME: For efficiency, split the "'${pcre_spaces_word}'" prefixing each such PCRE out
    #into this PCRE instead.

    # local pcre_macro_arg_block_prefix=''${pcre_spaces_word}'\{(?&spaces)'
    # local    pcre_macro_arg_block_nested_prefix='\{'${pcre_spaces_word}''

    # local        pcre_macro_arg_block_suffix=''${pcre_spaces_word}'\}(?:(?&spaces)|\Z)'
    # local pcre_macro_arg_block_nested_suffix=''${pcre_spaces_word}'\}(?&spaces)'

    # local pcre_word=''${pcre_spaces_word}'(?:'${pcre_word}'|(?&spaces))*(?&word)'

    #FUXME: Define all remaining ${ZESHY__MACRO_MATCH_INDEX_ARG_*} globals.

        # ZESHY__MACRO_MATCH_INDEX_ARG_1
        # ZESHY__MACRO_MATCH_INDEX_ARG_2
        # ZESHY__MACRO_MATCH_INDEX_ARG_3

    # local        pcre_macro_arg_block_nested_body='(?<blockb>(?:'${pcre_spaces_word}'(?&block)?|\\[''"$`<]|(?!<<)[^''"$`]|(?&code))*'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')'

    # local        pcre_macro_arg_block_body='(?:'${pcre_spaces_word}'(?&block)?|\\[''"$`<]|(?!<<)[^)''"$`]|(?&code))*?'
    # local pcre_macro_arg_block_nested_body=${pcre_macro_arg_block_body}

 # While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    # Macro indentation. Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline.
    #
    # Since such indentation is guaranteed to be the first match group, we
    # match such indentation with numbered back references (e.g., "\g1").
    # local pcre_macro_indentation_grouped='(\R\h*+)'

    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros. Since such macros
    # are currently matched solely by prefixing indentation regardless of zsh
    # context (i.e., ignoring string literals, variable expansions, and other
    # syntactic constructs), the "}" delimiting such argument is also matched
    # solely by the same prefixing indentation.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, merely assert this constraint with positive lookahead.
    # local pcre_macro_arg_block_prefix=''${pcre_spaces_word}'\{(?&spaces)'
    # local pcre_macro_arg_block_body='.*?'
    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'
    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_spaces_word}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_spaces_word}'|\Z)'
    # local pcre_macro_arg_block_suffix_ahead='\g1\}(?='${pcre_spaces_word}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

#         ZESHY__MACRO_MATCH_INDEX_ARGS_END
# ${pcre_empty_group}
    # local pcre_macro_args_optional_grouped='(?:(?:'${pcre_word}'|'${pcre_macro_arg_block_grouped}')((?:'${pcre_word}'|'${pcre_macro_arg_block_grouped}')*))?'

        # ZESHY__MACRO_MATCH_INDEX_ARG_1
        # ZESHY__MACRO_MATCH_INDEX_ARGS_2_OR_MORE

    #FUXME: Not quote right. We require spaces after a macro name *AND* before
    #a "{", but we can only match such spaces once. How?

    # '(?:'${pcre_word}'|'${pcre_macro_arg_block_grouped}')*'
    # '(?:'${pcre_macro_args_optional_grouped}')?'${pcre_subroutines}
    # ZESHY__MACRO_PCRE=${pcre_macro_indentation_grouped}${pcre_macro_name}'(?:'${pcre_spaces_word}${pcre_macro_args_grouped}')?'${pcre_subroutines}

    # One or more runs of whitespace or shells words both initiating and
    # terminating in a shell word.
    #
    # The former condition is purely an optimization concern. The latter
    # condition, however, is not; it prevents this PCRE from matching
    # substrings ending in a run of whitespace, ensuring such whitespace will

    #FUXME: Such subroutines are embedded only in the following PCRE fragment:
    #    (?=\$)(?:(?&var)|(?&math)|(?&proc))
    #Hence, simplify this by refactoring this and the other subroutines into
    #PCREs and embedding them directly in a new subroutine <dollar>.

    #FUXME: Insufficient, as it currently fails to match multiple adjacent line
    #continuations. Hmmm.

    # pcre_macro_subroutines_body+='(?<spaces>(?:\\\R)?(?:\h++(?:\\\R)?)+)'

    #FUXME: Such "}" must be matched as prefixed by a newline (\R) followed by
    #the same exact horizontal whitespace as the initial macro. We currently
    #match this as named group "(?&indent)" below. Such group *MUST* contain
    #such newline.

# (?=\$)(?:(?&var)|(?&math)|(?&proc))

    #FUXME: Match the same embedded constructs as above.
    #FUXME: Perhaps simpler to replicate the definition of
    #${pcre_process_sub_recursive} here, augmented with a negative lookahead
    #assertion to prevent matching of an unescaped "`". Ignore for now;
    #somewhat too much complexity, here!

    # local pcre_process_substitution_dollar_nonrecursive='`(?:\\[''"$`<]|(?!<<)[^''"$`]|(&squote)|(&dquote)|(&here)|(?=\$)(?:(?&var)|(?&math)|(?&proc)))*`'

    # Unquoted shell word.
    # pcre_macro_subroutines_body+='(?<uword>[^\s'${char_not_word_unquoted}']++)'

    # Character class matching shell-reserved characters.
    # local char_not_word_unquoted='''"$<>{}|`'
    # local pcre_word_unquoted_literal='[^\s\\'${char_not_word_unquoted}']++'

    #FUXME: For each named subroutine below, we need to directly embed the
    #definition of such subroutine somewhere in ${ZESHY__MACRO_PCRE} --
    #ideally, before the first call to such subroutine in such PCRE. (Yes, this
    #is somewhat annoying.)

    # Suffix suffixing all subroutines defined below, preventing such
    # subroutines from matching. Since such subroutines remain callable, To ensure this:
    #
    # * Suffix each subroutine definition by a suffix guaranteeing such
    #   definition to never match.

    # local pcre_subroutine_suffix='{0}'

    # As in Perl (but not Ruby), "libpcre" subroutine calls (e.g.,
    # "(?&soma)") do *NOT* capture the substring matched by such call if any.
    # As in both Perl and Ruby, subroutine definitions (e.g.,
    # "(?<soma>All the advantages of Christianity and alcohol; none of their defects.)"
    # capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is somewhat
    # noxious. In most cases, we would prefer such definitions to *NOT*
    # capture. Unfortunately, we have little alternative but to ignore the
    # groups captured by such matches.
    #
    # To facilitate this, increment ${match_count_ignore} (an integer local
    # counting the total number of ignorable match groups) after every
    # subroutine defined below.

    #FUXME: We had a reasonably clever idea. Will it work? Only CLI testing
    #will demonstrate the feasibility of the idea. If it *DOES* work, that'd be
    #reasonably awesome. So, what's the idea? Since subroutine definitions
    #implicitly capture *AND* since that's bad, shift all such definitions past
    #the valid end of the PCRE (e.g., "$") into a region guaranteed *NOT* to
    #match, reserved for only defining subroutines. Such subroutines would
    #never be matched as definitions but only called, avoiding all such
    #capturing issues.
    #FUXME: Sweet. Both of the following work as advertised:
    #
    #    >>> :is yum =~ '(?&yam)(?<yam>yum){0}' :si and print ok
    #    ok
    #    >>> :is yum =~ '(?<yam>yum){0}(?&yam)' :si and print ok
    #    ok
    #
    #Subroutine definitions suffixed by "{0}" are thus guaranteed to never
    #match and hence capture. Fairly awesome!

    #FUXME: Suffix all subroutines defined below by such PCRE fragment.

    # # Declare indices matched by ${ZESHY__MACRO_PCRE}.
    # match_index=1

    # #FUXME: Correct names.
    # # Declare indices preceding the first ignorable match group.
    # for match_index_name (
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_NAME
    # ) {
    #     integer -g ${match_index_name}=$(( match_index++ ))
    #     print -r ${match_index_name}': '${(P)match_index_name}
    # }

    # # Increment the index of the next ignorable match group past all
    # # intermediate match groups.
    # match_index+=${match_count_ignore}

    # #FUXME: Declare subsequent groups.

    # integer match_count_ignore=0
    # match_count_ignore+=1

 # Right? Wrong. There appears to be a bug in either
    #"libpcre" or zsh (...guess which, presumably?) forcing
    # local pcre_spaces_word='(?:\h|\\\R)++'

 # all macros (including names and block arguments) in
    # arbitrary code.

    #FUXME: Use of named references complicates match indexing. I beliewe we
    #can circumvent this, however, by leveraging named subroutines: that is,
    #declaring *ALL* named references at the very end of the regex.

    # # Argument of any type.
    # local pcre_macro_arg='(?:'${pcre_word}'|'${pcre_macro_arg_block}')'

    # # One or more arguments of any type.
    # local pcre_macro_args=${pcre_macro_arg}'+'

    #FUXME: This still used? Probably... not.

    # One or more arbitrary characters excluding shell-reserved characters.
    # local pcre_chars_unreserved='(?:\\\R|[^\v'${char_class_ureserved}'])++'

    # ZESHY__MACRO_NAMES_PCRE
    # ZESHY__MACRO_NAMES_PCRE=${}

    #FUXME: Excise me.

    # One or more whitespace-delimited shells words.
    # local pcre_word='(?:'${pcre_spaces_word}'|'${pcre_word}')+'

    #FUXME: Match only whitespace delimiting such words -- *NOT* prefixing such
    #words. This should simplify matching of block arguments a bit.
    # local pcre_word='(?:(?:'${pcre_word}'(?:\\\R)?\h++(?:\\\R)?))*'${pcre_word}')?'

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

    #FUXME: This is actually used. ${pcre_spaces_word}, however, doesn't really
    #appear to be. Excise the latter and shift such documentation here.
    # local pcre_spaces_word='(?:\h|\\\R)+'

    # local pcre_macro_arg_block_prefix='(?:\h(?:\\\R)?|(?:\\\R)?\h)\{'

    #FUXME: Excise. This is wrong, anyway. Matching line continuations is
    #*USELESS*, if one considers. We don't care about line continuations. They
    #signify 

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

 # Hence, we
    #really can't match this outside of the full PCRE. *shrug* 
# '(?:'${pcre_macro_arg}')*(?&arg)'

    # Customary argument for zsh commands, comprising one or more of the prior
    # syntactic constructs.
    # local pcre_macro_arg_command='(&word)+'

# '(?<word>(&uword)|(&squote)|(&dquote)|(?&sub))'

# ${pcre_chars_unreserved}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable}'
    #FUXME: Correct me. Then just 
    # local pcre_code_sans_process_sub_nonrecursive='(?<codet>))'

    #FUXME: Erhm. Excise?
    # local pcre_codes='(?:\\[''")$`<]|(?!<<)[^''")$`]|(?&code))*'

    #FUXME: A non-recursive version (e.g., matching "$ughugh") needs to be
    #defined as well, and a new umbrella PCRE matching both recursive and non-
    #recursive variable expansions assigned the overarching group "<var>".

    # local pcre_quotes_single_grouped="'((?:[^']|'')*)'"
    # local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    #FUXME: Also match process substitutions (of both ilk).
    #
    #Since zsh appears to search for terminating '"' delimiters in a prior
    #phase to that of variable expansions, we do *NOT* need to match variable
    #expansion here. (Isn't that nice?)

    #FUXME: Embedding ${pcre_quotes_single} here clearly isn't quite right.
    #While we *DO* want to match single quotes, we want to do so in a
    #"(?qsingle)" manner. Moreover, we want to match considerably more than
    #simply that: double quotes, here-doc strings, and so forth. *sigh*

    #FUXME: Unify with ${pcre_word}, perhaps?
    #FUXME: Right. ${pcre_code} should subsume ${pcre_word}, adding support for
    #here-documents and -strings. (Anything else?)

    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE. Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    # local pcre_here_doc_prefix='<<-?\s*+(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_unquoted_literal_grouped}')\R'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\R(?-1)'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    # Here-string.
    # local pcre_here_string='<<<\s*+'${pcre_word}''

    #FUXME: Excise the above? Shift documentation here!

    #FUXME: No longer required, seemingly. Now that we've merged such matching
    #into ${pcre_chars_unreserved}, excise such PCRE.

 # (Since this PCRE is principally used to match here
    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # cannot 
    #
    # we have no sane means of
    # matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string).
    #
    # Why? Character escapes.  We're inclined
    #to ignore this, at the moment.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Fairly sure we can simplify this quite a bit. We don't *NEED* to
    #match individual arguments on the initial match of the full macro string.
    #In fact, we're fairly sure we don't *EVER* need to match individual
    #arguments. Hence, we can probably generalize ${pcre_macro_arg_command} above
    #with whitespace as follows:
    #
    #    local pcre_macro_arg_command='(?:'${pcre_spaces_word}'|'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'
    #
    #Of course, that immediately suggests we combine ${pcre_spaces_word} and
    #${pcre_sans_quotes_spaces} -- probably by omitting "\s" from the
    #definition of the latter. (In any case, it's all for the morrow!)

    # "$"- or "`"-prefixed embedded substitutable.
    # local pcre_embeddable_embedded='(?=[$`])(?&sub)'

# (?>[$`])

    #FUXME: O.K.; we're not going to be able to substitute this below as is.
    #The reason why is the "[^$]". We're afraid that will need to be extended
    #on a case-by-case basis. After doing so, we'll probably want to excise
    #this local entirely.

    # Any character excluding "$" *OR* a "$"-prefixed substitutable.
    # local pcre_char_or_substitutable='\\$|[^$]|(?&sub)'

    #FUXME: Also match recursively nestable process substitution.

    # While we prefer *NOT* to explicitly
    # match arithmetic substitutions, matching only the latter would match one ")" delimiter
    # in arithmetic substitutions as terminating such substitutions -- which,
    # clearly, is not the case.

    #FUXME: For maintainability, we probably want to use embedded named
    #references everywhere we currently use zsh variable embedding below.

    # Arbitrary string of one or more characters excluding characters reserved
    # for strict zsh argument parsing. This includes:
    #
    # * Dollar signs.
    # * Single and double quotes.
    # * Whitespace.
    # local pcre_sans_quotes_spaces='[^\s''"$]++'

    # local pcre_macro_arg_command='(?:'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'

    #FUXME: Interestingly, this must be constructed at runtime, implying this
    #entire anonymous function should be converted into a named function
    #::preprocessor_pcres.make() called on *EACH* call to :macro(). Hmm. For
    #efficiency, perhaps:
    #
    #* :macro() should simply set ${ZESHY__MACRO_PCRE} to the empty string.
    #* :code.preprocess() should call ::preprocessor_pcres.make() if
    #  ${ZESHY__MACRO_PCRE} is the empty string.
    #
    #This permits multiple macros to be defined by a single parcel without
    #triggering multiple redundant PCRE compilations, which seems sensible.
    #FUXME: For usability, define a function ::preprocessor_pcres.clear() in
    #this parcel clearing such PCRE globals.

    # One or more such arguments.
    # Unquoted word in the strict zsh sense, comprising one or more characters
    # excluding whitespace and shell-reserved characters.
    # local pcre_word_unquoted='[^]'

    #FUXME: We *DO* need to match variables as well. Here's why:
    #
    #    >>> print ${:-
    #    ... :func
    #    ... }
    #
    #    :func
    #
    #Yes, that actually works. It's a hell of an edge case, but edge case
    #nonetheless. For robustness, we *MUST* account for all such cases.

    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # local pcre_here_doc_prefix='<<-?\s*+(?|'${ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE}'|'${ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE}'|(\S++)\n'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\g{-1}'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

#FUXME: Document me.
# # PCRE globals defined below.
# typeset -g\
#     ZESHY_SYNTAX_QUOTES_SINGLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE
# 
# # PCREs matching single-quoted strings in zsh format and hence supporting
# # escaped single quotes (i.e., "''").
#          ZESHY_SYNTAX_QUOTES_SINGLE_PCRE="'(?:[^']|'')*'"
# ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE="'((?:[^']|'')*)'"
# 
# # Double-quoted string in zsh format and hence supporting escaped double
# # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
# # matches "\" and hence must be matched *AFTER* matching the latter.
#          ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE='"(?:\\"|[^"])*"'
# ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE='"((?:\\"|[^"])*)"'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
