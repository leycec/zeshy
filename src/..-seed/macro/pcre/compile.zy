#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Compile PCREs in an optimized manner avoiding unnecessary recompilation.

# ....................{ GLOBALS                            }....................
# Most recently compiled PCRE, as passed to (and internally cached by) the
# most recent call to :pcre_compile(). For efficiency, such function avoids
# recompiling already compiled PCREs by only compiling PCREs differing from
# this global.
#
# Builtin pcre_compile() defined by module `zsh/pcre` permits only a single
# PCRE to be compiled at a time and hence implements a singleton PCRE cache.
# However, such module provides no comparable means of determining whether
# previously compiled PCREs are still compiled (and hence do _not_ require
# recompilation) or have since been supplanted in such cache by newly compiled
# PCREs (and hence require recompilation). Given the expense of recompiling
# PCREs, this is a mildly unfortunate oversight. This global amends that.
typeset -g ZESHY__PCRE_COMPILED_LAST

# ....................{ COMPILER                           }....................
# :void :pcre.compile(:string pcre)
#
# Compile the passed *Perl-compatible regular expression* (PCRE) in an optimized
# manner if differing from the most recently compiled PCRE (i.e., the PCRE
# passed to the most recent call to this function) or report success immediately
# otherwise. Hence, if the passed PCRE has already been compiled by a prior call
# to this function, such PCRE will only be recompiled if another PCRE has been
# compiled over the passed PCRE by a more recent call to this function.
function :pcre.compile() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one PCRE.'
    local pcre=${1}
    
    # If such PCRE is the empty string, throw an exception. Such PCRE
    # successfully matches *ALL* input and hence is semantically useless.
    # Moreover, such PCRE induces infinite loops on iterative matching and hence
    # constitutes a fatal error, which is less than semantically useless.
    [[ -n ${pcre} ]] || :die 'PCRE empty.'

    # If such PCRE has yet to be compiled *OR* was compiled but has since
    # been replaced in the internal cache by a more recently compiled PCRE,
    # (re)compile such PCRE in an optimized manner.
    if [[ ${ZESHY__PCRE_COMPILED_LAST} != ${pcre} ]] {
        pcre_compile -- "${pcre}"
        pcre_study

        # Avoid unnecessary recompilation on subsequent iterations.
        ZESHY__PCRE_COMPILED_LAST=${pcre}
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Define :pcre.compile() and :pcre.compile,set_state() as documented
#below. Specifically:
#
#* :pcre.compile() accepts a single PCRE. Do *NOT* bother accepting optional
#  pcre_compile() arguments, as all such arguments are better embedded directly
#  in such PCRE. Such function should internally:
#  * Test whether such PCRE equals ${ZESHY__PCRE_COMPILED_LAST}. If so, such
#    function should report success immediately; else, such function should:
#    * Call pcre_compile().
#    * Call pcre_study().
#    * Set ZESHY__PCRE_COMPILED_LAST to such string only *AFTER* successfully
#      compiling and optimizing such PCRE.
#
#Lovely simple.
#FUXME: Actually, there exists a demonstrably simpler and hence significantly
#better way. :pcre.compile() should simply cache the exact PCRE passed to such
#function to . On a subsequent call to  
