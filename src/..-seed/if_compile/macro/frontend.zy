#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.
#
#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Preprocess zeshy-specific code into zsh-specific code.

#FIXME: Define a new :macro_in_reverse() declarer, declaring macros which the
#preprocessor "reverses" until bumping up against a preceding brace. Since such
#macros must *ALWAYS* be preceded by a brace, however, perhaps that should
#appear in the declarer name? How about:
#
#* :macro_reverse_until_right_brace().
#* :macro_brace_right(). (Yes, this seems the more appropriate choice.)

#FIXME: Define a new :macro_command_prototyped() function, defining a new class
#of command macros: prototyped. As the nomenclature implies, the functions
#expanding such macros take the following signature:
#
#    :void :macro_command_prototyped_name(
#        ^:string expansion_name,
#        :string prototype_attributes,
#        :string prototype_return_type_channels,
#        :string prototype_names,
#        :string prototype_argument_channels,
#        ...)
#
#This approach generalizes the current conception of a :func() macro to *ANY*
#desired user-defined macro accepting a prototype as a first argument.
#
#However, recall that current PCREs capture *EITHER* a single return type *OR* a
#set of return channels into separate match groups. While the preprocessor could
#technically pass both such groups onto such macro functions and let them
#internally sort it out, this may not necessarily be the optimal approach. Or
#will it? It's probably the most efficient approach, which is quite critical
#here. The alternative is to have the preprocessor convert all single return
#types into "[stdout: "- and "]"-delimited sets of return channels and then pass
#the latter to macro functions. This simplifies the signature and internal logic
#of such functions, at the (possibly) substantial efficiency cost of then
#forcing such "packed" single return types to be unpacked by PCRE iteration back
#into the original types -- which, frankly, seems silly. Given that, consider
#the following function signature instead:
#
#    :void :macro_command_prototyped_name(
#        ^:string expansion_name,
#        :string prototype_attributes,
#        :string prototype_return_type,
#        :string prototype_return_type_channels,
#        :string prototype_name,
#        :string prototype_names,
#        :string prototype_arguments,
#        :string prototype_argument_channels,
#        ...)
#
#Though, that's fairly long-winded as well. While efficiency is paramount here,
#optimizing for efficiency by expanding the number of arguments in this fashion
#strikes us as a poor idea. The optimal solution might be to leverage the first
#macro function prototype above but to compact *BOTH* singular and plural
#arguments into each...
#
#Hmm. *WAIT*. Given the primacy of efficiency and the patent clumsiness of the
#above solutions, we necessarily ask ourselves: *WHY ARE WE EVEN PASSING SUCH
#ARGUMENTS TO MACRO FUNCTIONS IN THE FIRST PLACE ANYWAY!?* No, really. We
#shouldn't be passing ${expansion_name} to each and every macro function call;
#since ${expansion_name} *ALWAYS* unconditionally equals
#"ZESHY__MACRO_EXPANSION", repassing such string and then forcing macro
#functions to set such variable in an inefficiently dynamic manner is
#excessively overkill, a bureaucratic burden on macro function implementations,
#and absurdly inefficient in the aggregate. Instead:
#
#* Rename ${ZESHY__MACRO_EXPANSION} to ${ZESHY_MACRO_EXPANSION}.
#* Require every macro function to set ${ZESHY_MACRO_EXPANSION} unconditionally.
#* Declare string globals ${ZESHY_MACRO_PROTOTYPE_ATTRIBUTES},
#  ${ZESHY_MACRO_PROTOTYPE_RETURN_TYPE},
#  ${ZESHY_MACRO_PROTOTYPE_RETURN_CHANNELS}, and so on. Alternately, the
#  +{backend} preprocessor *COULD* preparse apart such string globals into
#  structured map globals ${ZESHY_MACRO_PROTOTYPE_ATTRIBUTE_NAME_TO_VALUE},
#  ${ZESHY_MACRO_PROTOTYPE_RETURN_CHANNEL_NAME_TO_TYPE}, and so on. The former
#  approach is undoubtedly more efficient but less user-friendly. Given that
#  aliases ignore return types and argument lists in prototypes, however, the
#  former approach is probably the better. And just contemplate how many
#  functions we'll eventually be compiling. Efficiency really is paramount here.
#  Indeed, we could probably perform an efficiency copy from ${match} groups
#  into such string globals via the empty for loop approach: e.g.,
#    for\
#        ZESHY_MACRO_PROTOTYPE_ATTRIBUTES\
#        ZESHY_MACRO_PROTOTYPE_RETURN_TYPE\
#        ZESHY_MACRO_PROTOTYPE_RETURN_CHANNELS ...\
#        ("${match[${ZESHY__MACRO_GROUP_INDEX_PROTOTYPE_ATTRIBUTES},${ZESHY__MACRO_GROUP_INDEX_PROTOTYPE_ARGUMENT_CHANNELS}]}") { }
#  Classic hackery for the lossless win.
#* Require every prototyped macro function to access such globals. Done!
#
#The implementation of :macro_command_prototyped() should leverage three new
#globals: ${ZESHY__MACRO_PROTOTYPED_TO_FUNC_NAME},
#${ZESHY__MACRO_PROTOTYPED_NAMES_SEMICOLON_PREFIXED}, and
#${ZESHY__MACRO_PROTOTYPED_NAMES_SEMICOLON_UNPREFIXED}. (Naturally, inject
#"_UNPROTOTYPED" into the names of the corresponding unprototyped globals.)
#
#+{pcre/prototype.zy} will need to be defined (e.g., with the current prototype-
#specific portion of +{*-declare/*-pcre}) and the resulting global
#${ZESHY__MACRO_PROTOTYPE_PCRE} embedded into ${ZESHY__PREPROCESS_PCRE}. This in turn
#implies that +{pcre/pcre.zy} should source parcels in the following order:
#
#    prototype.zy macro.zy
#
#+{pcre/macro.zy} will need to be generalized to match both unprototyped *AND*
#prototyped command macros, implying the need for unprototyped- and prototyped-
#specific capture groups and group index globals. Good hacklish fun all around.
#FIXME: Define :func() as such a prototyped command macro.
#FIXME: Redefine :alias_command(), :alias_maximal(), and :alias_suffix() as
#prototyped command macros via :macro_command_prototyped(). Naturally, this will
#necessitate redefining *ALL* currently defined aliases in the zeshy codebase so
#as to extract their prototypes into such macro-based approach.
#
#For aliases expanding to mostly valid zsh *NOT* inducing syntax highlighting
#issues in IDEs, define such aliases in a block-oriented approach: e.g.,
#
#    # Refactor this...
#    :alias_command ':void {:arg.prepend, :arg.unshift}(:string arg)'\
#        '{ :args.set "$(:stdin.get)" "${@}" } <<<' <<'/---'
#    Prepend the passed argument to the beginning of the current argument list.
#    /---
#
#    # Into this...
#    :alias_command :void {:arg.prepend, :arg.unshift}(:string arg) {
#        { :args.set "$(:stdin.get)" "${@}" } <<<
#    } <<'/---'
#    Prepend the passed argument to the beginning of the current argument list.
#    /---
#
#For all other aliases (typically expanding to zsh code fragments inducing IDE
#issues), define such aliases with single-quoted strings: e.g.,
#
#    # A purely hypothetical example.
#    :alias_command :void :bad_alias() '{ thisisbad } <<EOD' <<'/---'
#    Opus dei.
#    /---

#FIXME: Once we get a working preprocessor up, it becomes trivial to implement
#support for eliding away debug-specific code under optimized builds. Simply
#define a new macro :build.if_debug() accepting one and only one block
#argument. Such macro behaves in the expected way:
#
#* If the current build is an optimized build, such macro unconditionally
#  expands to the empty string.
#* Else, such macro expands to the passed block argument verbatim.

#FIXME: We'd *LOVE* to add support for command-line option-based syntax
#checking (e.g., syntax checking scripts passed at the command-line when option
#"--syntax-check" or some such is passed). Unfortunately, due to both
#preprocessor macros and global aliases, getting from here to there will be
#highly non-trivial. That said, we do have a few ideas on how to approach this.
#
#The fundamental issue is that of mapping from the post-processed line
#numbers that zsh emits on syntax errors to the preprocessed line numbers
#corresponding to the original scripts accepted by zeshy. On the face of it,
#such issue would appear to be intractable -- until you conceive the crucial
#trick, that is! So here we go. In full:
#
#* Define new command line options "-n" and "--syntax-check" acting as synonyms
#  of each other. "-n" is the customary command-line option for syntax checking
#  in literally *ALL* popular shells and hence should be followed here.
#* On receiving either such option, do the following for each passed script (in
#  exact order):
#  . Prepreprocess such script's contents in a syntax validation-specific
#    manner. Specifically (in exact order):
#    . For each line of such contents *NOT* suffixed by the line continuation
#      substring, suffix such line by:
#      " # line ${line_number}", where ${line_number} is such line's number.
#      Such comments serve as the basis for our subsequent mapping. (Clever.)
#    . Prefix *ALL* such contents by the newline-delimited string list of
#      all general aliases defined within the currently compiled digest file.
#      We may also need to define *ALL* command aliases as well. Hopefully,
#      however, it doesn't come to that.
#  . Preprocess but do *NOT* evaluate such script's contents in the usual way.
#  . Write the resulting code to a temporary file.
#  . Syntax check such file by passing either option "-n" or "--no-exec"
#    to zsh.
#  . If zsh fails with nonzero exit status and reports an syntax error on
#    standard error, such error will assume the following form:
#    "${temporary_filename}:${line_number_plus_one}: ${error_message}"
#    No surprises there, except for the ${line_number_plus_one}. zsh appears
#    to emit a line number one greater than the actual line number of the
#    erroneous line, as can be verified with a simple erroneous zsh script.
#    So, we'll not only need to substract such line number by 1 but by the line
#    length of all preceding general alias definitions. (Simple.)
#  . In the event of a syntax error, examine the erroneous line of the
#    postprocessed code string still in memory. If all went according to dismal
#    plan, such line *SHOULD* be suffixed by a comment indicating the
#    corresponding line number in the preprocessed original zeshy script,
#    in which case we're done. If this is *NOT* the case, something went
#    horribly wrong, implying the current zeshy process should probably throw a
#    verbose exception.
#
#That actually doesn't seem terribly hard, now that we've purportedly uncovered
#the essential trick of suffixing preprocessed lines by " # line" comments.
#Give us a go, eh?

# ....................{ GLOBALS                            }....................
# Map from macro name to the name of the function expanding such macro.
typeset -gA ZESHY__MACRO_TO_FUNC_NAME

# List set of all macro names prefixed by ":", excluding such ":" from each such
# name for simplicity (e.g., when joining such names into a PCRE).
typeset -gaU ZESHY__MACRO_NAMES_SEMICOLON_PREFIXED

# List set of all macro names *NOT* prefixed by ":".
typeset -gaU ZESHY__MACRO_NAMES_SEMICOLON_UNPREFIXED

# ....................{ DECLARERS                          }....................
#FIXME: Implement macro documentation support. This implies, of course, that
#we'll need to shift early-time documentation functionality here. *sigh*
#FIXME: Document me.

# :void :macro_command[
#     args =  (:string macro_name, :string func_name),
#     stdin = (:string macro_asciidoc)]
#
# Declare the passed macro as expanding to the passed function, documented by
# http://asciidoc.org[AsciiDoc]-formatted standard input if passed or
# undocumented otherwise. For convenience, consider passing such documentation
# as a single- or double-quoted here-document: e.g.,
#
# == Macro Name ==
#
# === Namespace ===
#
# Macros are `zeshy`-specific constructs and hence reside in an independent
# namespace from that of conventional aliases and functions. Since aliases and
# functions also reside in independent namespaces, macros, aliases, and
# functions may all share the same names without conflict. In such cases, the
# following precedence applies (in order):
#
# . Macros are expanded by the `zeshy` preprocessor into raw `zsh` code (at
#   `zeshy` script sourcing _and_ code evaluation time).
# . Aliases are expanded by the `zsh` interpreter into raw `zsh` code (at
#   `zsh` script sourcing, code evaluation, _and_ function definition time).
# . Functions are defined by the `zsh` interpreter (at `zsh` script sourcing,
#   code evaluation, _and_ function execution time).
#
# Equivalently, macro names take precedence over alias names take precedence
# over function names.
#  
# === Lexical Constraints ===
#
# For simplicity, macro names are constrained as follows:
#
# FIXME: Document me.
#
# == Caveats ==
#
# For technical reasons associated with PCRE-based macro preprocessing, macros
# are ignored in the following edge-case syntactic contexts.
#
# === Case Statement Patterns ===
#
# Macros situated on the same line as case statement patterns (e.g., the
# `:hairyou` in `:case 'Joui-uchi' { (*[oiu]) :hairyou tsuma shimatsu;; }`) are 
# currently ignored. This is circumventable by prefixing such macros by a
# command terminator (e.g., `;`, newline).
#
# === Complex Command Lists ===
#
# Macros situated in command position of complex command lists (e.g., the
# `:tokyo` in `:if :tokyo monogatari { :noop yasujirou ozu }`) are currently
# ignored. This is circumventable by embedding such macros within `{`- and `}`-
# delimited blocks (e.g., `:if { :tokyo monogatari } { :noop yasujirou ozu }`).
#
# The exception to this caveat is the complex command `time`, whose simplistic
# syntax demands no `{`- and `}`-delimited blocks and hence does _not_ conflict
# with macro syntax. Macros situated in command position in `time` lists (e.g.,
# the `:mononoke` in `:time :mononoke hime { :noop ashitaka }`) are _not_
# ignored.
#
# === Process Substitutions in Double-quoted Strings ===
#
# Macros embedded in either `$(`- and `)`-delimited _or_ `\``-delimited process
# substitutions embedded in double-quoted strings (e.g.,
# the `:harakiri` in `"masaki koboyashi's $(:harakiri seppuku)"`) are currently
# ignored. This is circumventable by concatenating such substitutions to such
# strings rather than embedding such substitutions in such strings (e.g.,
# `"masaki koboyashi's "$(:harakiri seppuku)`).
#
# === Non-whitespaced Block Delimiters ===
#
# Macros accepting no arguments situated in command position of `{`- and
# `}`-delimited blocks whose `{` delimiter is unsuffixed by whitespace _and_
# whose `}` delimiter is unprefixed by whitespace (e.g., the `:gunnm` in
# `{:gunnm}`) are currently ignored, preventing erroneous expansion of
# macro-like substrings in brace expansions (e.g., the `:gunnm` in
# `:print {:gunnm}`). This is circumventable by suffixing such `{` _and/or_
# prefixing such `}` by whitespace (e.g., `{ :gunnm }`).
#
# === `\``-delimited Process Substitutions ===
#
# Macros in command position of `\``-delimited process substitutions (e.g., the
# `:ningen` in `\`:ningen no jouken\``) are currently ignored, even where _not_
# embedded in double-quoted strings. This is circumventable by either:
#
# * Embedding such macros in `$(`- and `)`- rather than `\``-delimited process
#   substitutions. Since the former already obsolete the latter, this is the
#   recommended solution.
# * Prefixing macros in command position of `\``-delimited process substitutions
#   by a command terminator (e.g., `;`, newline).
function :macro_command() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one macro name and one function name.'
    local macro_name=${1} func_name=${2}
    [[ -n ${macro_name} ]] || :die 'Macro name empty.'
    [[ -n ${func_name}  ]] || :die 'Function name empty.'

    # If such name is *NOT* a valid macro name, throw an exception.  While we
    # *COULD* allow *ANY* nonempty strings to be valid macro names (as is
    # the case with alias and function names), doing so would complicate:
    #
    # * PCRE generation. All "libpcre"-reserved characters in such name would
    #   need to be explicitly escaped.
    # * Code preprocessing. Since macro users would need to explicitly escape
    #   all shell-reserved characters in such name *AND* since there exist
    #   multiple means of escape such characters in zsh (e.g., "\"-prefixed
    #   escapes and single- and double-quoted strings), matching all
    #   permissible uses of such macro would require either:
    #   * Matching all possible means of escape such characters.
    #   * Matching only one such means, requiring macro users to only escape
    #     such characters by such means.
    #   * Matching *NO* such means, requiring macro users to *NEVER* escape
    #     such characters. Since such preprocessing is *NOT* a zsh-compliant
    #     parser, such requirement is implementable. Unfortunately, it also
    #     introduces syntactic non-orthogonalities between the zsh parser and
    #     zeshy preprocessor. In other words, it's highly problematic.
    #
    # The latter is, arguably, the greater concern. While correcting the former
    # issue is certainly (albeit annoyingly) feasible, correcting the latter
    # issue is considerably less feasible if not infeasible altogether. For the
    # moment, sidestep such issues by prohibiting such characters.
    [[ ${macro_name} =~ ${ZESHY__MACRO_NAME_VALID_PCRE} ]] || :die\
        'Macro name "'${macro_name}'" invalid (i.e., not matched by PCRE /'${ZESHY__MACRO_NAME_VALID_PCRE}'/).'

    # If such function does *NOT exist, throw an exception.
    (( ${+functions[${func_name}]} )) || :die\
        'Macro '${macro_name}'() function '${func_name}'() undefined.'

    # If such macro already exists, throw an exception.
    (( ${+ZESHY__MACRO_TO_FUNC_NAME[${macro_name}]} == 0 )) || :die\
        'Macro '${macro_name}'() already defined to be expanded by function '${ZESHY__MACRO_TO_FUNC_NAME[${macro_name}]}'().'

    # Declare such macro.
    ZESHY__MACRO_TO_FUNC_NAME[${macro_name}]=${func_name}

    # If such macro is prefixed by ":", record such fact. Since this is the case
    # for all official zeshy macros (and hence most macros), this is an
    # optimization specific to the common case.
    if [[ ${macro_name[1]} == ':' ]] {
        ZESHY__MACRO_NAMES_SEMICOLON_PREFIXED+=${macro_name[2,-1]}
    # Else, such macro is *NOT* prefixed by ":". Record such fact.
    } else {
        ZESHY__MACRO_NAMES_SEMICOLON_UNPREFIXED+=${macro_name}
    }

    # Clear all previously generated preprocessor PCREs, forcing their
    # regeneration on the next preprocessor call. Since such PCREs match and
    # hence depend on the set of all macro names, declaring such macro
    # invalidates such PCREs. (While we *COULD* do so here, deferring such
    # regeneration prevents redundant regeneration in the common case of
    # multiple adjacent macro declarations in a parcel.)
    ::preprocessor.pcres.clear
}

# ....................{ SOURCERS                           }....................
# :void :script.source(:string filename)
function :script.source() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one filename.'
    local script_filename=${1} script_code
    [[ -f ${script_filename} ]] || :die\
        'Script "'${script_filename}'" not found or not a file.'

    # To avoid modifying such script, localize such script's contents. For
    # efficiency, do so via zsh module "mapfile" rather than customary
    # alternatives (e.g., process substitution).
    {
        zmodload zsh/mapfile
        script_code=${mapfile[${script_filename}]}
    # Since such module is inherently unsafe, guarantee such module to be
    # unloaded immediately after such retrieval -- even in the event such
    # retrieval throws an exception.
    } always {
        zmodload -ui zsh/mapfile
    }

    #FIXME: Nontrivial. We'll need to refactor
    #get_shell_script_shebang_command_name_if_found() into a setter and shift
    #the resulting function into a new parcel at this level. *sigh*
    #
    #Actually, probably no. Just inline the corresponding code here.
    #FIXME: Strip the prefixing shebang line from such code. Such line does
    #*NOT* constitute interpretable zeshy code and must not be treated as such.
    #
    #Actually, probably no. Shebang lines are "#"-prefixed and hence already
    #implicitly ignored.

    # If the first line of such code is *NOT* a shebang referencing the "zeshy"
    # interpreter, print a nonfatal warning. Preprocessing and evaluating
    # arbitrary bytes as valid zeshy code could have painful consequences and
    # should be avoided at all costs.

    # Preprocess such code.
    local ZESHY__PREPROCESS_CODE=${script_code}
    ::code.preprocess

    # Execute such preprocessed code.
    eval "${ZESHY__PREPROCESS_CODE}"
}

# --------------------( WASTELANDS                         )--------------------
# yukito kishiro
# from the start of such macro
# _nor_ suffixing such `{` from the start of such macro by whitespace
# command terminator such as `;` or newline (e.g.,
# `:case 'Joui-uchi' { (*[oiu]) ;:hairyou tsuma shimatsu;; }`).

    # # If the first character of such macro is ":", declare such macro
    # # accordingly. Since this is the case for all official zeshy macros and
    # # hence most macros, this is an optimization specific to the common case.
    # if [[ ${macro_name[1]} == ':' ]] {
    #     # If such macro already exists, throw an exception.
    #     (( ${+ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]} == 0 )) || :die\
    #         'Macro '${macro_name}'() already defined to be expanded by function '${ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]}'().'
    #
    #     # Else, declare such macro. For simplicity elsewhere (e.g., when
    #     # subsequently joining all such names together), omit the prefixing ":".
    #     ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name[2,-1]}]=${func_name}
    # # Else, the first character of such macro is any character *NOT* ":". Again,
    # # declare such macro accordingly.
    # } else {
    #     (( ${+ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]} == 0 )) || :die\
    #         'Macro '${macro_name}'() already defined to be expanded by function '${ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]}'().'
    #     ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME[${macro_name}]=${func_name}
    # }

#FUXME: *ALL* macro names should be suffixed by ":". Since macros are
#regrettably subject to constraints that conventional zsh builtins and
#functions and external commands are not, callers must have some immediate
#means of differentiating macros from non-macro callables. This is how. Given
#this convention, we should probably print non-fatal warnings when macros *NOT*
#suffixed by ":" are declared.
#FUXME: Actually, we've obviated most such constraints. Assuming we correct the
#well-documented issue of matching macros in process substitutions embedded in
#double-quoted strings (which certainly seems feasible), the only remaining
#discrepancy between zsh and zeshy parsing remains the matching of macros in
#"`"-delimited process substitutions -- which, honestly, is perfectly ignorable.
#In other words, for all intents and purposes, macros should indeed be
#expandable everywhere command aliases are and hence *NOT* require lexical
#differentiation by the above ":"-suffixed scheme. Contemplate, anyway.
# From from macro name to the name of the function expanding such macro.
# typeset -gA\
#     ZESHY__MACRO_NAME_WITH_SEMICOLON_PREFIX_TO_FUNC_NAME\
#     ZESHY__MACRO_NAME_SANS_SEMICOLON_PREFIX_TO_FUNC_NAME

    #FUXME: For identical reasons, we need to also ensure on alias and function
    #declaration that there exists no macro of the same name. In other words,
    #macros should be considered to share the same namespace as callables, even
    #though they technically don't.
    #FUXME: Actually, this is nonsense. Aliases being able to shadow functions
    #is a *good* thing. There's no justification for prohibiting shadowing in
    #macro names as well.

    # If such macro is the name of an existing callable (i.e., alias or
    # function), throw an exception. Since macros and callables technically
    # reside in different namespaces, there exists no explicit conflict between
    # the two. Nonetheless, permitting macros to share the same names as
    # callables invites numerous issues both subtle and notable. For example,
    # permitting such sharing obscures otherwise clear errors when erroneously
    # interpreting unpreprocessed zeshy scripts under the zsh interpreter, as
    # in that case unpreprocessed macros will still be executable as the
    # corresponding callables of the same. In other words, it's a bad idea.
    # (( ${+functions[${macro_name}]} +\
    #    ${+aliases[${macro_name}]} +\
    #    ${+galiases[${macro_name}]} == 0 )) || :die\
    #     'Macro '${macro_name}'() already a defined callable:'$'\n\n'$(which -- "${macro_name}")

# In such cases, note
# that the `zeshy` preprocessor expands all applicable macros to raw `zsh` code
# _before_ evaluating such code under the `zsh` interpreter, the following
# precedence

# ==== Caveats ====
#
# While technically feasible, defining macros, aliases, and/or functions of the
# same names does invite subtle issues. Notably, erroneously interpreting
# unpreprocessed `zeshy` scripts under the `zsh` interpreter
# permitting such sharing obscures otherwise clear errors when erroneously
    # interpreting unpreprocessed zeshy scripts under the zsh interpreter, as
    # in that case unpreprocessed macros will still be executable as the
    # corresponding callables of the same.

        # 'Macro name "'${macro_name}'" invalid. Consider renaming such macro to match PCRE "'${ZESHY__MACRO_NAME_VALID_PCRE}'".'
#only contain characters in the character class 
    # [[ ${macro_name} == ${~ZESHY__MACRO_NAME_GLOB} ]] || :die\
#FUXME: Incidentally, this is overly restrictive. To support non-English
#locales, We really want to support UTF-8-encoded macro names. All we
#really need to prohibit are shell- *AND* PCRE-reserved characters. We
#already have a shell-reserved character class in ={pcre}, so just augment
#with PCRE-reserved characters (e.g., "+", "?", "*", "^", "$").

# Character class matching all permissible characters in macro names.
# typeset -g ZESHY__MACRO_NAME_CHAR_CLASS='a-zA-Z0-9-_:.'

# Glob matching syntactically valid macro names.
# typeset -g ZESHY__MACRO_NAME_GLOB='['${ZESHY__MACRO_NAME_CHAR_CLASS}']##'

    #FUXME: We require this character class elsewhere (e.g., for PCRE use);
    #hence, extract "a-zA-Z0-9-_:." out into a new string global
    #${ZESHY__MACRO_NAME_CHAR_CLASS}.

#letters and "_", "-", ".", and ":" characters
# 'Function '${func_name}'() not found for macro '${macro_name}'().'
