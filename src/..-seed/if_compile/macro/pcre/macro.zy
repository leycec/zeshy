#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs specific to macro preprocessing.

#FIXME: Implement support for right-brace macros (e.g., :always, :elif, :else).
#After brief consideration, this *SHOULD* be feasible. The sticky point is not
#matching such macros at such position but duplicating the PCRE fragment
#matching macro arguments. Of course, we'll do just that; we have little choice
#and, anyway, only ever compile such PCRE once. Still, due to such duplication,
#we probably want to hold off on this until later.
#
#Matching "}" braces at the top level should be feasible as follows:
#
#* Define a new ${ZESHY__MACRO_BRACE_RIGHT_NAME_PLACEHOLDER} string global
#  defining a PCRE placeholder for right-brace macro names.
#* Define a new ${pcre_macro_brace_right} PCRE matching right-brace macros.
#  Such PCRE should (probably) share the same PCRE body as conventional command
#  macros but be prefixed by a distinct PCRE matching only right-brace macro
#  names with a new placeholder.
#* Define new ${char_not_literal_macroable_*} character classes, equivalent to
#  ${char_not_literal_sourceable_*} character classes with exception of
#  explicitly listing "}".
#* Define new ${pcre_literal_macroable_*} PCREs based on such classes,
#  suffixing ${pcre_literal_macroable_rest} by
#  ${pcre_literal_blockable_lookbehind} but otherwise defined as expected.
#* Embed such ${pcre_literal_macroable_*} PCREs in macroable word PCREs.
#* Explicitly match "${pcre_brace_right}" in macroable word PCREs, immediately
#  followed by (in order):
#  * One or more whitespace characters (horizontal and/or vertical) optionally
#    interspersed by line continuations.
#  * ${pcre_macro_brace_right}.
#* Define capture group index globals specific to right-brace macros.
#
#Phew! While each of the above steps is largely trivial, there certainly exist
#more than a few of them. *wet choleric sigh*

#FIXME: We need to match macros immediately following each ")"-suffixed glob
#expression of a case() statement. While this is certainly feasible for the
#first such expression, it's unclear how (if at all) macros following any
#subsequent ")"-suffixed glob expressions could be matched. If they can't,
#then, for orthogonality, the first shouldn't be matched either. Contemplate.
#
#After contemplation, macros are technically matchable following ")"-suffixed
#glob expressions in *NON-NESTED* case statements (i.e., case statements *NOT*
#nested in other case statements, which require subroutine calls precluding
#capturing of macro substrings). That said, we're hard-pressed to recall the
#last time we required nested case statements, implying such matching to be
#feasible in practice. However, it's a bit non-trivial.
#
#No existing PCRE substructure needs to be modified to accomodate such
#matching. Instead, if the command name is "case", a new parallel top-level
#PCRE structure matching case statement syntax suffices. Such structure should
#mirror the current PCRE structure with one simple addition: ")"-suffixed
#glob expressions in command position should be matched as terminators. That's
#it. That said, while relatively simple, that could impose quite a bit of PCRE
#duplication significantly increasing the length and hence debuggability of
#such PCRE. Hold off on such improvement until stabilizing such PCRE.

#FIXME: For debuggability, we probably want to prepand global PCREs with option
#"(?x)" enabling "extended PCRE" mode. Following that, append suitable
#subsections of such PCREs by newlines for improved readability.

# ....................{ GLOBALS ~ pcre                     }....................
# PCRE to which ${ZESHY__PREPROCESS_PCRE} will be set if no macros exist.
typeset -g ZESHY__PREPROCESS_PCRE_IF_EMPTY

# PCRE to which ${ZESHY__PREPROCESS_PCRE} will be set if at least one macro exists.
typeset -g ZESHY__PREPROCESS_PCRE_IF_NONEMPTY

# PCRE matching unsupported here-documents (i.e., here-documents with
# non-literal and hence non-PCRE-matchable delimiters).
typeset -g ZESHY__MACRO_HERE_DOC_UNSUPPORTED_PCRE

# ....................{ GLOBALS ~ pcre : name              }....................
# Syntactically valid macro name.
typeset -g ZESHY__MACRO_NAME_VALID_PCRE

# Command nacro name placeholder.
#
# == Motivation ==
#
# Since the set of all such names changes with each call to a command macro
# definer and undefiner (e.g., :macro_command(), :macro_command.undefine()),
# such name *CANNOT* be matched by a static PCRE. Instead, such PCRE embeds an
# arbitrary placeholder to be subsequently substituted by higher-level
# macro-specific PCRE functions (e.g., ::preprocessor_pcres.make()) with a
# dynamically constructed PCRE matching such names.
typeset -g ZESHY__MACRO_COMMAND_NAME_PLACEHOLDER='ZESHY__MACRO_COMMAND_NAME'

# ....................{ MAIN                               }....................
#FIXME: Oh, gods. Does any of this still apply? Probably, but shifting the
#chaff from the wheat isn't going to be especially thrilling.

# Declare PCRE globals *NOT* reinitialized on each call to
# ::preprocessor_pcres.make().
#
# For simplicity, the zeshy preprocessor avoids duplicating behaviour already
# implemented by the zsh parser. Since this particularly includes syntactic
# checking, such globals match both syntactically valid *AND* invalid
# constructs. Of course, this has ancillary benefits as well: namely,
# preventing unmatched syntactically invalid constructs from being erroneously
# matched as syntactically valid delimiters. For example, despite syntactic
# ivalidity, "${}" is matched (and ideally ignored) as a variable expansion
# rather than as a "}" block suffix preceded by ignorable garbage.
#
# The PCRE matching double-quoted strings provides a minimum length example
# correcting such issues:
#
#     local pcre_quotes_double='"(?:\\[\\"$`]|[^"$`]|(?&bed)|[^"])*"'
#
# Let's pick this apart. In order:
#
# 1. "\\[\\"$`]", matching any relevant escaped character, where the
#    meaning of "relevant" depends on the current syntactic construct.  In
#    the case of double-quoted strings, these are:
#    * An escaped backslash, preventing such backslash from escaping the
#      following character.
#    * An escaped '"' delimiter, preventing such delimiter from terminating
#      such match.
#    * An escaped "$" or "`" character, preventing such character from
#      initiating a variable expansion, arithmetic substitution, or process
#      substitution (as matched by the following subroutine call).
# 2. "[^"$`]", matching any irrelevant character, where the meaning of
#    "irrelevant" is the inverse of the meaning of "relevant" above
#    excluding backslashes. Since the prior alternative matched all
#    relevant escaped characters, all remaining escaped characters and
#    hence backslashes are irrelevant. Since the last alternative is a
#    fallback matching all characters excluding '"' delimiters, this
#    alternative is technically redundant. However, the following
#    alternative is a PCRE subroutine call -- which, by definition, incurs
#    non-negligible space and time costs. Since such call should be
#    performed *ONLY* if necessary, this alternative matches all characters
#    guaranteed *NOT* to be matched by such call.
# 3. "(?&bed)", matching any variable expansion, arithmetic substitution,
#    or process substitution. All such syntactic constructs are recursively
#    nestable and hence matchable only with subroutine calls. (Since
#    double-quoted strings are only indirectly recursively nestable, such
#    call is replacable in this specific case by the contents of the
#    corresponding PCRE ${pcre_embeddable_or_char_escaped}. In the general case,
#    however, subroutine calls are typically required.)
# 4. "[^"]", a fallback matching any unmatched character *NOT* the
#    terminating '"' delimiter. Assuming the prior alternatives matched
#    such syntactic construct correctly, this should be equivalent to
#    matching any unescaped "$" or "`" character. For robustness, it's
#    simplest to match any non-delimiter.
#
# Syntactic constructs delimited by substrings longer than a single
# character require negative lookahead to properly match. Since such
# lookahead is comparatively inefficient, defer such lookahead to the final
# alternative in the PCRE matching such constructs: e.g.,
#
#     # Instead of this...
#     local pcre_math_substitution_parens='\$\(\((?:\\[\\)$`]|(?!\)\))(?:[^)$`]|(?&bed)|.))*\)\)'
#
#     # ...just do this.
#     local pcre_math_substitution_parens='\$\(\((?:\\[\\)$`]|[^)$`]|(?&bed)|(?!\)\)).)*\)\)'

#FIXME: Excise all unused PCREs below.
#FIXME: Fairly confident that we can further optimize such PCREs by
#globally substituting non-atomic grouping syntax "(?:...)" for atomic
#grouping syntax "(?>...)". The difference between the two is as follows:
#
#* If any alternative in the latter succeeds, such group will *NEVER* be
#  backtracked into -- even if that results in a match failure.
#* By contrast, the former is always backtracked into on subsequent match
#  failures.
#
#We believe we've implicitly designed *ALL* alternation below to not
#require backtracking. That being said, we really won't know until we get
#the backtracking-capable version working first and then attempt to
#optimize into the backtracking-incapable version.
#FIXME: Similarly, most instances of "*", "+", and "?" may be suffixed by
#the possessive quantifier "+" as well.

() {
    # PCRE subroutines defined below, concatenated in a manner preventing such
    # definitions from either matching *OR* capturing in place.
    #
    # Much like programmatic subroutines, PCRE subroutine are self-consistent units
    # preserving a semblance of local scope; for example, PCRE subroutines prevent
    # substrings captured by such calls from leaking to callers (e.g., subroutines,
    # zsh code) by snapshotting the state of all captured substrings on entering
    # such call and restoring such state on leaving such call. In other words,
    # subroutines impose non-negligible time and space costs.
    #
    # For efficiency, subroutines should be leveraged *ONLY* where required.
    # Typically, this means recursion matching delimiter-balanced syntactic
    # constructs in a context-free manner. In all other cases, PCREs should be
    # encapsulated as string variables and interpolated directly where used.
    local pcre_subroutines_body

    # Empty string captured to a group. Since "libpcre" already captures the
    # empty string to unmatched groups (excluding trailing unmatched groups
    # detectable with ${#match}), this PCRE is typically only required to
    # structure group indices in "(?|"-based alternatives.
    local pcre_empty_group='()'

    # ..................{ OPTIONS                            }..................
    # PCRE options. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   vexsome default, "." matches all characters *EXCLUDING* newline.)
    # * "(?m)", inducing:
    #   * "^" to match either the string start *OR* newline. (By default, "^"
    #     matches only the former.)
    #   * "$" to match either the string end *OR* newline. (By default, "$"
    #     matches only the former.)
    # * "(?x)", enabling "extended PCRE" mode lexing the following substrings
    #   in PCREs as insignificant:
    #   * Unescaped whitespace *NOT* embedded in character classes.
    #   * "#"-prefixed comments (i.e., unescaped "#" characters *NOT* embedded 
    #     in character classes and all non-newline characters following such
    #     "#" character).
    # * "(*BSR_ANYCRLF)", forcing "\R" to match *ONLY* ASCII newlines. (By
    #   default, "\R" matches both ASCII and UTF-8-encoded newlines.)
    local pcre_options='(?smx)(*BSR_ANYCRLF)'

    # PCRE options as above, as well as anchoring the current PCRE to the first
    # match point in the the substring currently being searched. For both
    # efficiency and consistency, iterative PCREs (i.e., PCREs iteratively
    # matching consecutive substrings in strings via pcre_match() and
    # ${ZPCRE_OP}) should *ALWAYS* be anchored, ensuring such PCREs only match
    # at the first byte following the last byte of the prior such match rather
    # than at any byte following such byte (the default).
    local pcre_options_anchored=${pcre_options}'\G'

    # ..................{ REPORT                             }..................
    # Report success from the current match attempt, immediately returning the
    # currently matched substring and all previously captured groups.
    local pcre_succeed='(*ACCEPT)'

    # Report failure from the current match attempt, immediately returning.
    # Dismantled, this is:
    #
    # * "(*COMMIT)", reporting failure when backtracked into from a subsequent
    #   matching failure.
    # * "(*FAIL)", forcing backtracking by inducing a matching failure.
    #
    # Since the latter is immediately preceded by the former, the latter
    # backtracks into the former that then reports failure. (Nice one.)
    local pcre_report_failure='(*COMMIT)(*FAIL)'

    # ..................{ CLASS                              }..................
    # Character class bodies intended to be embedded *ONLY* in positive
    # character classes (i.e., *NOT* prefixed by "^").

    # Character class matching embeddable-reserved characters, including:
    #
    # * "$", prefixing variable expansions *AND* arithmetic and standard
    #   process substitutions.
    # * "`", prefixing non-recursive process substitutions.
    local char_embeddable_prefix='$`'

    # Character class matching horizontal ASCII whitespace characters.
    local char_space_horizontal=' \t'

    # Character class matching vertical ASCII whitespace characters.
    local char_space_vertical='\r\n'

    # Character class matching ASCII whitespace characters.
    local char_space=${char_space_horizontal}${char_space_vertical}

    # ..................{ CLASS ~ sourceable                 }..................
    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the first of any shell word of a command, excluding
    # embeddable-reserved characters and hence including only:
    #
    # * "<", prefixing "<("- and ")"-delimited process substitutions.
    # * ">", prefixing ">("- and ")"-delimited process substitutions.
    local char_sourceable_nanoword_rest_sans_embeddable='<>'

    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the start of any shell word of a command, including the entirety
    # of the prior class as well as:
    #
    # * "$", prefixing variable expansions *AND* arithmetic and standard
    #   process substitutions.
    #
    # Unlike embeddable-reserved characters, the "`" delimiting "`"-delimited
    # process substitutions is intentionally excluded. (See the definition of
    # subroutine "<emb>" for details.)
    local char_sourceable_nanoword_rest='$'${char_sourceable_nanoword_rest_sans_embeddable}

    # Character class matching sourceable-reserved characters at the start of
    # any shell word *AFTER* the first of a command, including the entirety of
    # the prior class as well as:
    #
    # * "=", prefixing "=("- and ")"-delimited process substitutions.
    local char_sourceable_nanoword_start=${char_sourceable_nanoword_rest}'='

    # Character class matching sourceable-reserved characters at the start of
    # the first shell word of a command, including the entirety of the prior
    # class as well as:
    #
    # * "(", prefixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    local char_sourceable_nanoword_start_word_first='('${char_sourceable_nanoword_start}

    # ..................{ CLASS ~ passable                   }..................
    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the start of a scalar macro argument. Since "("-prefixed process
    # forks and arithmetic tests are commands and hence *NOT* arguments, "(" is
    # omitted both here and below (e.g., by embedding
    # ${char_sourceable_nanoword_rest}).
    local char_passable_nanoword_rest=${char_sourceable_nanoword_rest}

    # Character class matching sourceable-reserved characters at the start of a
    # scalar macro argument. Such arguments follow macro names and hence the
    # first shell words of such macros, eliminating the need for a separate
    # PCRE matching characters at the start of such words.
    local char_passable_nanoword_start=${char_passable_nanoword_rest}'='

    # ..................{ CLASS ~ terminator                 }..................
    # Character class matching single-character command terminators at the
    # top level and hence excluding:
    #
    # * Vertical whitespace, prefixing commented "WASTELANDS" code terminators
    #   and hence requiring more complex matching than afforded by a simple
    #   character class.
    #
    # Technically, characters this class matches should be prefixed by either
    # horizontal or vertical whitespace when preceded by characters that are
    # *NOT* unspaced command terminators (e.g., "if { true } {"). Since shell
    # word-specific negative lookahead prevents such words from matching "{",
    # however, such technicalities are ignorable.
    local char_terminator_macroable='{;'

    # Character class matching single-character command terminators in a
    # general context.
    local char_terminator=${char_space_vertical}${char_terminator_macroable}

    # Character class matching single-character command terminators in a block
    # and hence excluding:
    #
    # " "{", prefixing blocks. Matching such prefix as a command terminator
    #   here prevents recursive subroutine calls from matching such prefix as a
    #   balanced block delimiter elsewhere. Note that "}" is *NOT* a command
    #   terminator and hence need *NOT* be explicitly excluded here.)
    local char_terminator_blockable=${char_space_vertical}';'

    # ..................{ NOT ~ embeddable                   }..................
    # Character class bodies intended to be embedded *ONLY* in negative
    # character classes (i.e., prefixed by "^"). Since escaped characters must
    # be explicitly matched and hence *NOT* implicitly matched by such classes,
    # such classes must *ALWAYS* contain the character escape "\".
    #
    # This is significant enough to warrant repeating, in bold plaintext:
    # *ALL NEGATIVE CHARACTER CLASSES OPERATING ON ZSH CODE MUST CONTAIN "\".*

    # Character class matching invalid characters in embeddable syntactic
    # constructs (e.g., arithmetic substitutions, variable expansions).
    local char_not_embeddable_prefix=${char_embeddable_prefix}'\\'

    # ..................{ NOT ~ unquoted : sourceable        }..................
    # Character class matching invalid characters *AFTER* the start of unquoted
    # shell words in top-level syntactic contexts rather than directly embedded
    # within embeddable syntactic constructs (i.e., double-quoted strings,
    # variable expansions, arithmetic substitutions and tests).
    #
    # This comprises most zsh-reserved operators conflicting with macro
    # preprocessing, equivalent to all unconditionally syntactically
    # significant ASCII punctuation (typically terminating the prior command).
    # This includes:
    #
    # * "{", prefixing:
    #   * Blocks when the first character of the first shell word of a command.
    #   * Brace expansions when any other character of such words of a command.
    #
    # This excludes:
    #
    # * zsh-reserved operators *NOT* conflicting with preprocessing (e.g.,
    #   "*", "!", "^", "?").
    # * zsh-reserved characters conditionally dependent on position in unquoted
    #   shell words, including:
    #   * "}", a block suffix only when the last character of such words.
    #   * "#", a comment prefix only when the first character of such words. In
    #     all other lexical contexts, "#" acts as a glob operator.
    # * Process fork and/or substitution-specific delimiters *NOT* requiring
    #   strict balancing. Since most such delimiters require such balancing,
    #   this includes only:
    #   * "`", delimiting "`"-delimited process substitutions.
    #
    # Excluding "`" here implies that macros embedded in "`"-delimited process
    # substitutions immediately following such prefixing "`" will *NOT* be
    # preprocessed as macros; all other macros in such substitutions will be
    # preprocessed as macros, however. Since such substitutions have been
    # officially deprecated by "$("- and ")"-prefixed process substitutions
    # *AND* since the current aapproach significantly improves the simplicity
    # and efficiency of the resulting PCREs, we adopt the current approach.
    local char_not_literal_sourceable_rest=${char_space}'''"${;|&<>\\'

    # Character class matching invalid characters at the start of unquoted
    # shell words *AFTER* the first of a command, additionally including:
    #
    # * "#", prefixing comments.
    local char_not_literal_sourceable_start_word_rest='#'${char_not_literal_sourceable_rest}

    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command, additionally including:
    #
    # * "(", prefixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    #
    # Since this only applies to first command words, all subsequent command
    # words are prefixable by "("-prefixed glob qualifiers.
    local char_not_literal_sourceable_start_word_first='('${char_not_literal_sourceable_start_word_rest}

    # ..................{ NOT ~ unquoted : parenable         }..................
    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as both "(" and ")", permitting matching of strictly
    # balanced parens in such words (i.e., glob qualifiers).
    local char_not_literal_parenable_rest='()'${char_not_literal_sourceable_rest}

    # Character class matching invalid characters at the start of unquoted
    # shell words as well as both "(" and ")". Unlike the classes above, this
    # class is invariant with respect to word order; that is, this class
    # equally applies to both the first unquoted shell word and all following
    # such words of a command.
    local char_not_literal_parenable_start='#{'${char_not_literal_parenable_rest}

    # ..................{ NOT ~ unquoted : backtickable      }..................
    # Character class matching invalid characters *AFTER* the start of unquoted
    # shell words, comprising all zsh-reserved operators conflicting with
    # preprocessing and hence all unconditionally syntactically significant
    # ASCII punctuation (typically terminating the prior command).
    local char_not_literal_backtickable_rest=${char_not_literal_sourceable_rest}'`'

    # Character class matching invalid characters at the start of unquoted
    # shell words *AFTER* the first of a command.
    local char_not_literal_backtickable_start_word_rest=${char_not_literal_sourceable_start_word_rest}'`'

    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command.
    local char_not_literal_backtickable_start_word_first=${char_not_literal_sourceable_start_word_first}'`'

    # ..................{ NOT ~ unquoted : expandable        }..................
    # Character class matching invalid characters in brace expansions.
    local char_not_literal_braceable='}'${char_not_literal_sourceable_rest}

    # ..................{ NOT ~ macro name                   }..................
    # Character class matching invalid characters at all character positions of
    # macro names except the first, for which additional constraints apply.
    # Such characters comprise all PCRE- and zsh-reserved characters,
    # permitting only a handful of the most common punctuation characters for
    # use in macro names (e.g., ".", ",", "_", "-").
    #
    # Technically, since PCRE-reserved characters in macro names *COULD* be
    # explicitly escaped, only zsh-reserved characters need to be prohibited.
    # For simplicity, we currently prohibit both.
    #
    # Technically, zsh permits the zsh-reserved characters "!" and "#" to be
    # configured via string global ${histchars}. While we could generalize our
    # current hard-coding of such characters with an expansion of such global
    # here (taking care to escape character class-reserved characters), doing
    # so would unhelpfully render the set of all syntactically valid macro
    # names a dynamic function of current shell state -- implying that some
    # names would be only conditionally syntactically valid. Since that would
    # be unequivocally bad, we ignore such technicalities...
    local char_not_macro_name_rest='#{}[]()'${char_not_literal_backtickable_rest}'*+?!^'

    # Character class matching invalid characters at the first character
    # position of macro names, for which additional constraints apply (e.g.,
    # "~", expanded to the current user's home directory when the first
    # character of unquoted shell words).
    local char_not_macro_name_first=${char_not_macro_name_rest}'~='

    # First character of a macro name.
    local pcre_macro_name_first='[^'${char_not_macro_name_first}']'

    # Any character *AFTER* the first of a macro name.
    local pcre_macro_name_rest='[^'${char_not_macro_name_rest}']'

    # One or more macro name characters, excluding such name's first character.
    local pcre_macro_name_chars_rest_optional=${pcre_macro_name_rest}'*+'

    # Any invalid character of a macro name *AFER* the start of such name.
    local pcre_char_not_macro_name_rest='['${char_not_macro_name_rest}']'

    # ..................{ SPACE                              }..................
    # One or more horizontal or vertical whitespace ASCII characters. Although
    # the builtin character type "\s" already matches both ASCII and non-ASCII
    # whitespace, the latter are inapplicable here. Since zsh lexes only ASCII
    # whitespace characters as whitespace *AND* since there exist substantially
    # more non-ASCII than ASCII whitespace characters, such characters are best
    # matched with explicit character classes instead.
    local pcre_spaces='['${char_space}']++'

    # Zero or more horizontal or vertical whitespace characters.
    local pcre_spaces_optional='['${char_space}']*+'

    # Horizontal ASCII whitespace character (i.e., space or tab). For
    # efficiency, omit non-ASCII horizontal whitespace characters and hence the
    # generic character type "\h". Since PCRE provides an option for preventing
    # "\R" but *NOT* "\h" from matching UTF-8-encoded characters, we have
    # little choice but to manually define such character class. See subsection
    # "Generic character types" at: http://www.pcre.org/pcre.txt
    local pcre_space_horizontal='['${char_space_horizontal}']'

    # One or more horizontal whitespace characters.
    local pcre_spaces_horizontal=${pcre_space_horizontal}'++'

    # Zero or more horizontal whitespace characters.
    local pcre_spaces_horizontal_optional=${pcre_space_horizontal}'*+'

    # One or two vertical ASCII whitespace characters. Specifically, either:
    #
    # * Unix-specific linefeed (i.e., "\n").
    # * Windows-specific carriage return followed by linefeed (i.e., "\r\n").
    local pcre_space_vertical='\R'
    local pcre_space_vertical_grouped='('${pcre_space_vertical}')'

    # One or more vertical whitespace characters.
    local pcre_spaces_vertical=${pcre_space_vertical}'++'

    # Any character other than a vertical whitespace character. While PCRE
    # provides no inverse of "\R" as it does with most other generic types
    # (e.g., "\S", "\H", "\V"), a customary negative character class suffices.
    local pcre_char_sans_space_vertical='[^'${char_space_vertical}']'

    # One or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments, single-quoted strings).
    local pcre_chars_sans_space_vertical=${pcre_char_sans_space_vertical}'++'

    # Zero or more characters other than vertical whitespace characters.
    local pcre_chars_sans_space_vertical_optional=${pcre_char_sans_space_vertical}'*+'

    # Line continuation (i.e., an unescaped backslash followed by a newline),
    # continuing the command corresponding to the current line to the next
    # line. As discussed above, newlines preceded by two backslashes are *NOT*
    # line continuations and must *NOT* be matched as such.
    local pcre_line_continuation='\\'${pcre_space_vertical}

    # Line continuation followed by optional whitespace.
    local pcre_line_continuation_spaceable=${pcre_line_continuation}${pcre_spaces_optional}

    # Line continuation followed by optional horizontal whitespace.
    local pcre_line_continuation_spaceable_horizontal=${pcre_line_continuation}${pcre_spaces_horizontal_optional}

    # One or more line continuations.
    local pcre_line_continuations='(?>'${pcre_line_continuation}')++'

    # Zero or more line continuations.
    local pcre_line_continuations_optional='(?>'${pcre_line_continuation}')*+'

    # One or more line continuations, each followed by optional whitespace.
    local pcre_line_continuations_spaceable='(?>'${pcre_line_continuation_spaceable}')++'

    # Zero or more line continuations, each followed by optional whitespace.
    local pcre_line_continuations_spaceable_optional='(?>'${pcre_line_continuation_spaceable}')*+'

    # One or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_line_continuations_spaceable_horizontal='(?>'${pcre_line_continuation_spaceable_horizontal}')++'

    # Zero or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_line_continuations_spaceable_horizontal_optional='(?>'${pcre_line_continuation_spaceable_horizontal}')*+'

    # One horizontal whitespace character optionally prefixed by line
    # continuations. This PCRE is principally intended for lookahead.
    local pcre_space_horizontal_continuable=${pcre_line_continuations_optional}${pcre_space_horizontal}

    # One or more whitespace characters *NOT* preceded by line continuations,
    # optionally interspersed by line continuations.
    #
    # Since line continuations are merely ignorable rather than actual
    # whitespace, such substrings *MUST* include at least one whitespace
    # character. Whereas escaped newlines are line continuations preserving the
    # current command and hence effectively whitespace, unescaped newlines are
    # effectively semicolons terminating such command and hence non-whitespace.
    local pcre_spaces_continuable=${pcre_spaces}${pcre_line_continuations_spaceable_optional}

    # One or more horizontal whitespace characters *NOT* preceded by line
    # continuations, optionally interspersed by line continuations.
    local pcre_spaces_horizontal_continuable=${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}

    # One or more whitespace characters optionally interspersed with line
    # continuations.
    local pcre_continuable_spaces=${pcre_line_continuations_optional}${pcre_spaces_continuable}

    # One or more horizontal whitespace characters optionally interspersed with
    # line continuations, comprising *ALL* whitespace delimiting one shell word.
    local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}${pcre_spaces_horizontal_continuable}
    local pcre_continuable_spaces_horizontal_grouped='('${pcre_continuable_spaces_horizontal}')'

    # Zero or more whitespace characters *OR* line continuations.
    local pcre_spaces_continuable_optional='(?>'${pcre_spaces}'|'${pcre_line_continuation}')*+'

    # Zero or more horizontal whitespace characters *OR* line continuations.
    local pcre_spaces_horizontal_continuable_optional='(?>'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*+'

    # ..................{ SPACE ~ subject                    }..................
    # Start of the subject string (i.e., the string currently being matched).
    local pcre_subject_start='\A'

    # End of the subject string.
    local pcre_subject_end='\z'

    # End of the subject string, immediately reporting success from the current
    # match attempt. This both avoids spurious match successs *AND* mildly
    # improves efficiency after detecting invalid constructs (e.g., by *NOT*
    # attempting to match subsequent command termination). While reporting
    # failure would frequently be semantically preferable, doing so unhelpfully
    # prevents zsh from setting canonical list global ${match}.
    local pcre_subject_end_succeed=${pcre_subject_end}${pcre_succeed}
    local pcre_subject_end_succeed_optional='(?>'${pcre_subject_end_succeed}')?+'

    # ..................{ SPACE ~ reset                      }..................
    # Reset matching to the current position in the subject string, ensuring
    # ${ZPCRE_OP[(w)1]} will expand to such position's byte index. This PCRE
    # circumvents the global discrepancy between operator "=~" and builtin
    # pcre_match(): namely, that only the former sets canonical match globals
    # expanding to the byte indices of captured groups (e.g., ${mbegin}),
    # requiring use of this PCRE in the latter to achieve the same effect.
    local pcre_reset='\K'

    # Reset matching to the current match position, reporting success from the
    # current match attempt.
    local pcre_reset_succeed=${pcre_reset}${pcre_succeed}

    # Remainder of the subject string (i.e., all text between the current match
    # position inclusive and the end of such string), resetting matching to
    # the current match position and reporting success from the current match
    # attempt.
    #
    # This PCRE is intended for use in matching and "returning" syntactically
    # invalid constructs (e.g., "'"-prefixed strings with no suffixing "'") to
    # the caller. In such case, resetting matching to the current position
    # ensures the matched substring contains only such construct. With respect
    # to lexicality, there are two broad types of such constructs:
    #
    # * Constructs invalidly spanning from the current match position to the
    #   end of the subject string (e.g., due to a lack of balanced suffixes).
    #   Since such constructs already consume all remaining text, manually
    #   doing so here is entirely sensible.
    # * Constructs invalidly spanning from the current match position to a
    #   somewhere *NOT* the end of the subject string (e.g., due to erroneous
    #   internal syntax). Since such constructs do *NOT* consume all remaining
    #   text, manually doing so here seems rather insensible. Nonetheless,
    #   since subroutines isolate capture groups and hence appear incapable of
    #   passing information back to their caller via capturing, there appears
    #   to be no other PCRE-based means of notifying callers of syntactic
    #   invalidities in previously called subroutines. Consuming all remaining
    #   text permits callers to match ${pcre_subject_end_succeed}
    #   immediately after calling subroutines, guaranteeing successful
    #   termination and hence the detectability of such invalidities by the
    #   code iterating over such PCREs. Don't think too hard about that.
    local pcre_reset_remainder_succeed=${pcre_reset}'.*+'${pcre_succeed}

    # ..................{ SPACE ~ line                       }..................
    # Start of the current line, consuming one or more prefixing vertical
    # whitespace characters if any. "^" is a zero-width assertion consuming no
    # characters and hence inappropriate for use below (excluding lookahead).
    local pcre_line_start='('${pcre_spaces_vertical}'|'${pcre_subject_start}')'

    # End of the current line *WITHOUT* consuming the suffixing vertical
    # whitespace character if any. Since ${pcre_line_start} already consumes
    # such character as a line prefix, permitting another general-purpose PCRE
    # to consume the same character would prevent either from matching in a
    # general-purpose manner. (That's bad.)
    local pcre_line_end='$'

    # Start of the current line followed by zero or more horizontal whitespace
    # characters *OR* one or more horizontal whitespace characters.
    local pcre_line_start_or_spaces_horizontal='(?>'${pcre_spaces_horizontal}'|'${pcre_line_start}${pcre_spaces_horizontal_optional}')'

    # Zero or more line continuations followed by either the end of the current
    # line *OR* a whitespace character. While consuming suffixing whitespace is
    # typically discouraged, this PCRE is principally intended for use in
    # positive lookahead.
    local pcre_line_end_or_space_continuable=${pcre_line_continuations_optional}'(?>'${pcre_space_horizontal}'|'${pcre_line_end}')'

    # ..................{ CHAR ~ brace                       }..................
    # Left brace, conditionally matched elsewhere as either a (in order):
    #
    # * Block prefix when situated in the first shell word of a command and
    #   hence prefixed by one or more whitespace characters or the start of the
    #   subject string. Since PCREs embedding this PCRE guarantee such
    #   constraint, such whitespace is *NOT* matched here.
    # * Brace expansion prefix at all other character positions when followed
    #   by a balanced right brace within the same shell word.
    # * Literal "{" character in all other lexical contexts.
    local pcre_brace_left='\{'

    # Right brace, conditionally matched elsewhere as either a (in order):
    #
    # * Brace expansion suffix when preceded by a balanced left brace within
    #   the same shell word *NOT* signifying a block prefix.
    # * Block suffix when situated as the last character of any shell word of a
    #   command and hence suffixed by at least one whitespace character or the
    #   end of the subject string. While such condition could be asserted here
    #   with positive lookahead, there's no need: the negative lookbehind
    #   suffixing shell words in blocks guarantees such suffixes to either
    #   terminate their shell words or be distinct shell words.
    local pcre_brace_right='\}'
    local pcre_brace_right_optional=${pcre_brace_right}'?+'

    # ..................{ CHAR ~ paren                       }..................
    # Left paren.
    local pcre_paren_left='\('

    # Right paren.
    local pcre_paren_right='\)'
    local pcre_paren_right_optional=${pcre_paren_right}'?+'

    # ..................{ CHAR ~ escape                      }..................
    # "\"-prefixed escaped character *OR* syntactically invalid "\" character
    # at the end of the subject string. By matching all escaped characters,
    # this PCRE solves numerous issues commonly related to such characters:
    #
    # * Escaped backslashes (i.e., "\\") must be matched before matching
    #   subsequent escaped characters, as the former effectively disable
    #   escaping (e.g., "\\n", an escaped backslash preceding the character "n"
    #   rather than an escaped newline).
    # * Line continuations (i.e., "\
    #   ") must be matched as insignificant unquoted characters rather than
    #   significant vertical whitespace.
    local pcre_char_escaped_prefix='\\'
    local pcre_char_escaped=${pcre_char_escaped_prefix}'(?>.|'${pcre_reset_remainder_succeed}')'

    # ..................{ SUBROUTINE CALL                    }..................
    # Recursive syntax is matchable *ONLY* via comparatively inefficient
    # subroutine calls, which subsequent PCREs perform *ONLY* if the character
    # at the current match position is a prefix signifying such syntax (e.g.,
    # "$", prefixing any of several different syntactic constructs). Since such
    # subroutines consume such prefixing characters when called, such PCREs
    # non-consumptively detect such characters with positive lookahead. See
    # ${pcre_subroutines_body}.
    #
    # Subroutine calls matching nestable syntactic constructs *MUST* be
    # suffixed by ${pcre_subject_end_succeed_optional}. Since all such
    # constructs may be either syntactically valid or invalid and in the latter
    # case will have erroneously matched all remaining text in the subject
    # string (e.g., due to missing or unbalanced delimiters), the current match
    # point will be at the end of such string on returning from calls matching
    # syntactically invalid constructs. While reporting failure from such match
    # attempt would be preferable, doing so prevents identifying and hence
    # responding to such failure. Rather, success should be reported.

    # Embeddable syntactic construct (i.e., embeddable only in arithmetic
    # substitutions, double-quoted strings, and variable expansions).
    local pcre_embeddable_body='(?&emb)'${pcre_subject_end_succeed_optional}
    local pcre_embeddable='(?=['${char_embeddable_prefix}'])'${pcre_embeddable_body}

    # Embeddable syntactic construct *OR* "\"-prefixed escaped character. For
    # convenience, since the two are *ALWAYS* matched together, this PCRE
    # matches both (in the optimal order).
    local pcre_embeddable_or_char_escaped=${pcre_char_escaped}'|'${pcre_embeddable}

    # ..................{ SUBROUTINE CALL ~ interpretable    }..................
    # Subroutine matching all possible interpretable syntactic constructs
    # without regard for character or word positions.
    #
    # For simplicity, subsequent PCREs all embed this PCRE and hence call the
    # same subroutine gated by positive lookahead constraining such subroutine
    # call to only a subset of such constructs. Since excluded constructs
    # (e.g., "("-prefixed process forks) are comparatively rare *AND* since
    # this subroutine matches such constructs at the end rather than start of
    # its internal list of alternatives, such reuse incurs little to no
    # performance penalties. This is critical, as the alternative of
    # duplicating this subroutine twice incurs substantially worse penalties at
    # PCRE recompilation time (i.e., on sourcing each zeshy script).
    local pcre_sourceable_body='(?&sou)'${pcre_subject_end_succeed_optional}

    # Sourceable syntactic construct at the start of the first shell word of a
    # command (i.e., a construct embeddable at such position regardless of
    # syntactic context and hence replaceable by any arbitrary unquoted shell
    # word in arbitrary code).
    local pcre_sourceable_nanoword_start_word_first='(?=['${char_sourceable_nanoword_start_word_first}'])'${pcre_sourceable_body}

    # Sourceable syntactic construct at the start of any shell word *AFTER* the
    # first of a command.
    local pcre_sourceable_nanoword_start_word_rest='(?=['${char_sourceable_nanoword_start_word_rest}'])'${pcre_sourceable_body}

    # Sourceable syntactic construct at any character *AFTER* the start of a
    # shell word of a command.
    local pcre_sourceable_nanoword_rest='(?=['${char_sourceable_nanoword_rest}'])'${pcre_sourceable_body}

    # ..................{ SUBROUTINE CALL ~ passable         }..................
    # "`"-delimited process substitution.
    local pcre_passable_nanoword_process_substitution_backtick='(?=`)'${pcre_embeddable_body}

    # Sourceable syntactic construct at the first character of a scalar macro
    # argument. To match "`"-delimited process substitutions at such positions,
    # this matches both sourceables *AND* embeddables (in that order). Since
    # the former already matches all possible "$"-prefixed syntactic constructs
    # matched by the latter, the latter is confined via positive lookahead to
    # match only "`"-delimited process substitutions. While this could be
    # misconstrued as mildly inefficient, the obsoletion of such substitutions
    # should dissuade efficiency concerns.
    local pcre_passable_nanoword_start='(?=['${char_passable_nanoword_start}'])'${pcre_sourceable_body}'|'${pcre_passable_nanoword_process_substitution_backtick}

    # Sourceable syntactic construct at any character *AFTER* the start of a
    # scalar macro argument.
    local pcre_passable_nanoword_rest='(?=['${char_passable_nanoword_rest}'])'${pcre_sourceable_body}'|'${pcre_passable_nanoword_process_substitution_backtick}

    # ..................{ STRING                             }..................
    # Single-quoted string delimiter.
    local pcre_quotes_single_delimiter="'"

    # Double-quoted string delimiter.
    local pcre_quotes_double_delimiter='"'

    # Single-quoted literal string (i.e., single-quoted string *NOT* supporting
    # escaped single quotes "''").
    local pcre_quotes_single_literal_body='[^'${pcre_quotes_single_delimiter}']*+'
    local pcre_quotes_single_literal=${pcre_quotes_single_delimiter}${pcre_quotes_single_literal_body}${pcre_quotes_single_delimiter}
    local pcre_quotes_single_literal_grouped=${pcre_quotes_single_delimiter}'('${pcre_quotes_single_literal_body}')'${pcre_quotes_single_delimiter}

    # Double-quoted literal string (i.e., double-quoted string *NOT* supporting
    # embedded syntactic constructs), thus prohibiting escaped characters,
    # variable expansions, arithmetic substitutions, and process substitutions.
    local pcre_quotes_double_literal_body='[^'${pcre_quotes_double_delimiter}${char_not_embeddable_prefix}']*+'
    local pcre_quotes_double_literal=${pcre_quotes_double_delimiter}${pcre_quotes_double_literal_body}${pcre_quotes_double_delimiter}
    local pcre_quotes_double_literal_grouped=${pcre_quotes_double_delimiter}'('${pcre_quotes_double_literal_body}')'${pcre_quotes_double_delimiter}

    # Single- or double-quoted literal string. Unlike ${pcre_quotes} and
    # similar top-level PCREs, syntactic invalidities (e.g., the absence of
    # suffixing delimiters) are handled by parent PCREs embedding this PCRE.
    # Attempting to handle such invalidities here would obscure their
    # underlying causes -- namely, by:
    #
    # * Conflating syntactically valid non-literal strings (e.g., strings
    #   containing escaped characters) with syntactically invalid literal
    #   strings (i.e., literal strings with *NO* suffixing delimiter).
    # * Preventing parent PCREs from reporting such invalidities at their
    #   prior match positions (e.g., "<<" here-document prefixes).
    local pcre_quotes_literal_grouped='(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}')'

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local pcre_quotes_single_delimiter_escaped=${pcre_quotes_single_delimiter}${pcre_quotes_single_delimiter}
    local pcre_quotes_single_body='(?>[^'${pcre_quotes_single_delimiter}']++|'${pcre_quotes_single_delimiter_escaped}')*+'
    local pcre_quotes_single=${pcre_quotes_single_delimiter}'(?>'${pcre_quotes_single_body}${pcre_quotes_single_delimiter}'|'${pcre_reset_remainder_succeed}')'

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    #
    # Since zsh (appears to, at least) parse terminating '"' delimiters in a
    # phase *BEFORE* that of variable expansions, this PCRE can and possibly
    # should avoid matching such expansions here. Since such behaviour is
    # arguably either a bug or undependable implementation detail, however,
    # syntactic constructs embedded in double quotes are matched similarly to0
    # syntactic constructs embedded in other syntax (e.g., arithmetic tests).
    local pcre_quotes_double_body='(?>[^'${pcre_quotes_double_delimiter}${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_quotes_double=${pcre_quotes_double_delimiter}'(?>'${pcre_quotes_double_body}${pcre_quotes_double_delimiter}'|'${pcre_reset_remainder_succeed}')'

    # Single- or double-quoted string.
    local pcre_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}

    # Comment, necessarily prefixed by either one or more horizontal whitespace
    # characters *OR* the start of the current line. The former constraint
    # implies that comments must be explicitly matched *BEFORE* horizontal
    # whitespace. Likewise, the latter constraint implies that line
    # continuations must be explicitly matched *BEFORE* comments.
    local pcre_comment_prefix='\#'
    local pcre_comment_body=${pcre_chars_sans_space_vertical_optional}
    local pcre_comment=${pcre_comment_prefix}${pcre_comment_body}${pcre_line_end}
    local pcre_comment_optional='(?:'${pcre_comment}')?+'

    # One or more whitespace characters followed by an optional comment.
    local pcre_comment_optional_spaced=${pcre_spaces}${pcre_comment_optional}

    # Zero or more whitespace characters followed by an optional comment when
    # preceded by one or more whitespace characters.
    local pcre_comment_spaced_optional=${pcre_spaces_optional}${pcre_comment_optional}

    # ..................{ TERMINATOR ~ spaced                }..................
    # PCREs below match command terminators (i.e., substrings terminating
    # the command preceding such terminator) requiring prefixing whitespace. 
    # Such terminators precede preprocessor macros and hence *MUST* be matched
    # with syntactic accuracy.

    #FIXME: Wait. For a truly general implementation, don't we need to join the
    #set of all global alias names... No. Well, possibly? Do all global aliases
    #terminate commands? They don't *NEED* to, of course, but they probably
    #almost certainly do. Hmm; contemplate further. Perhaps we want a new
    #subtype of global alias that when declared adds the name of such alias to
    #a global private list recording the names of all global aliases that also
    #terminate commands -- say, a new declarer
    #:alias_general_command_terminator().
    #
    #Clearly, implement this all *LATER*. For now, this suffices.

    # zeshy-specific command terminator.
    local pcre_terminator_zeshy=':(?:or|and|not)'

    # Command terminator suffixing boundary, non-consumptively matched with
    # positive lookahead. Since any single character invalid in macro names
    # necessarily implies such boundary, this PCRE matches any PCRE- or zsh-
    # reserved character.
    local pcre_terminator_spaced_suffix_lookahead='(?='${pcre_char_not_macro_name_rest}'|'${pcre_subject_end}')'

    # Command terminator requiring one or more prefixing *AND* one or more
    # suffixing whitespace characters, each optionally interspersed by line
    # continuations. Since this PCRE matches the latter but *NOT* the former,
    # PCREs embedding this PCRE *MUST* match the former.
    #
    # Technically, some such terminators are only prefixable in a syntactically
    # valid manner by horizontal whitespace characters  (e.g., ":and", ":or")
    # and *NOT* repeatable in a syntactically valid manner (e.g., ":or :or").
    # Since macro preprocessing is largely unconcerned with the syntactic
    # validity of non-macros, however, such technicalities are ignorable.
    local pcre_terminator_spaced=${pcre_terminator_zeshy}${pcre_terminator_spaced_suffix}

    # ..................{ TERMINATOR ~ unspaced : comment    }..................
    # PCREs below match command terminators requiring no prefixing whitespace.

    # One or more single-character command terminators in a generic context.
    local pcre_terminator_chars='['${char_terminator}']++'

    # One or more single-character command terminators in a block.
    local pcre_terminator_chars_blockable='['${char_terminator_blockable}']++'

    # One or more single-character command terminators at the top level.
    local pcre_terminator_chars_macroable='['${char_terminator_macroable}']++'

    # End of the subject string, capturing the last character of such string to
    # differentiate syntactically invalid from valid subject strings. In the
    # former case, the corresponding capture group will be absent.
    local pcre_terminator_string_end=${pcre_subject_end_succeed}

    # "#"-prefixed comment suffix, comprising either one or more vertical
    # whitespace characters one the end of the subject string. While matching
    # trailing whitespace is typically discouraged, negative lookahead in
    # unquoted shell strings ensure such matching to be safe.
    local pcre_terminator_comment_suffix='(?>'${pcre_spaces_vertical}'|'${pcre_terminator_string_end}')'

    # "#"-prefixed comment excluding such prefix.
    local pcre_terminator_comment_sans_prefix=${pcre_comment_body}${pcre_terminator_comment_suffix}

    # "#"-prefixed comment.
    local pcre_terminator_comment=${pcre_comment_prefix}${pcre_terminator_comment_sans_prefix}

    # "&"-prefixed command terminator, comprising a:
    #
    # * "&" or "&!" backgrounding.
    # * "&&" boolean AND operator.
    #
    # Since redirections do *NOT* terminate commands, this PCRE excludes both 
    # "&<"- and "&>"-formatted redirections.
    local pcre_terminator_ampersand='&[&!]?+'

    # "|"-prefixed command terminator, comprising a:
    #
    # * "|" or "|&" pipe.
    # * "||" boolean OR operator.
    local pcre_terminator_pipe='\|[|&]?+'

    # Process fork or substitution prefix command terminator. Since such
    # prefixes should typically be matched as prefixes of syntactic constructs
    # requiring subroutine-driven recursive matching in a strictly balanced
    # manner, this PCRE only applies to contexts ignoring such constructs
    # (e.g., top-level macro and block macro argument matching).
    #
    # While the "`" prefixing "`"-delimited process substitutions is also a
    # command terminator, matching such "`" requires an approach like that
    # with which the '"' suffixing double-quoted strings nesting process
    # substitutions is matched. Hence, this PCRE omits "`".
    #
    # For simplicity, "("- and ")"-delimited process forks are matched as well
    # (i.e., by matching the first character of such prefix optionally).
    # Interestingly, while "(" cannot be the first character of unquoted shell
    # words, ")" *CAN* be (e.g., "ls *(/)"). Naturally, this non-orthogonality 
    # differs from the case of "{" and "}".
    local pcre_terminator_process_prefix_sans_backtick='[$=<>]?+\('

    # ..................{ TERMINATOR ~ unspaced : macro      }..................
    # "#"-prefixed zeshy-specific "WASTELANDS" comment, capturing such comment
    # and reporting success from the current match attempt. This is an optional
    # optimization intended for use on the official zeshy codebase.
    local pcre_terminator_comment_wastelands='-{20}\( WASTELANDS {25}\)-{20}(?>'${pcre_space_vertical_grouped}'|'${pcre_subject_end}')'${pcre_succeed}

    # "# "-prefixed comment *OR* comment-like "WASTELANDS" code terminators and
    # hence optimized for matching preprocessor macros.
    local pcre_terminator_comment_spaced_macroable=' (?>'${pcre_terminator_comment_wastelands}'|'${pcre_terminator_comment_sans_prefix}')'

    # "#"-prefixed comment optimized for matching preprocessor macros.
    local pcre_terminator_comment_macroable=${pcre_comment_prefix}'(?>'${pcre_terminator_comment_spaced_macroable}'|'${pcre_terminator_comment_sans_prefix}')'
    local pcre_terminator_comment_macroable_optional='(?>'${pcre_terminator_comment_macroable}')?+'

    # One or more vertical whitespace command terminators optionally followed
    # by a comment or commented "WASTELANDS" code terminator at the top level.
    # The latter is *ALWAYS* preceded by vertical whitespace, dictating this
    # PCRE's rather curious structure.
    local pcre_terminator_spaces_vertical_macroable=${pcre_spaces_vertical}${pcre_terminator_comment_macroable_optional}

    # ..................{ TERMINATOR ~ unspaced              }..................
    # Command terminator excluding single characters *NOT* requiring prefixing
    # or suffixing whitespace, excluding single-character command terminators.
    #
    # Since ${pcre_terminator_unspaced_macroable} matches macroable-specific
    # comments in a non-generalized manner (i.e., when prefixed by vertical but
    # *NOT* horizontal whitespace), such PCRE requires generalized matching of
    # comments. Hence, such matching applies to all PCREs below.
    local pcre_terminator_unspaced_body=${pcre_terminator_comment}'|'${pcre_terminator_pipe}'|'${pcre_terminator_ampersand}'|'${pcre_terminator_string_end}

    # Command terminator *NOT* requiring prefixing or suffixing whitespace in a
    # generic context.
    local pcre_terminator_unspaced='(?>'${pcre_terminator_chars}'|'${pcre_terminator_unspaced_body}')'

    # Command terminator *NOT* requiring prefixing or suffixing whitespace in a
    # block.
    local pcre_terminator_unspaced_blockable='(?>'${pcre_terminator_chars_blockable}'|'${pcre_terminator_unspaced_body}'|'${pcre_terminator_process_prefix_sans_backtick}')'

    # Command terminator *NOT* requiring prefixing or suffixing whitespace at
    # the top level.
    local pcre_terminator_unspaced_macroable='(?>'${pcre_terminator_chars_macroable}'|'${pcre_terminator_spaces_vertical_macroable}'|'${pcre_terminator_unspaced_body}'|'${pcre_terminator_process_prefix_sans_backtick}')'

    # ..................{ TERMINATORS                        }..................
    # Command terminator(s) header and footer, implicity prefixed and
    # explicitly suffixed by zero or more horizontal whitespace characters
    # optionally interspersed by line continuations, all optionally followed by
    # one or more command terminators requiring such whitespace.
    #
    # Despite nomenclature, such PCREs match at most one command terminator
    # requiring no such whitespace (rather than one or more such terminators).
    # While this superficial discrepancy is unfortunate, the current approach
    # is nonetheless the optimal solution under the assumption that all PCREs
    # preceding this PCRE are optional. Since commands *MUST* consist of at
    # least one terminator but may otherwise be empty (e.g., ";;;", the
    # syntactically valid concatenation of three such terminators), this
    # assumption *SHOULD* always hold.
    #
    # While spaced terminators (e.g., ":not") *MUST* be preceded by horizontal
    # whitespace, such whitespace need *NOT* be matched in a mandatory manner
    # here, somewhat streamlining PCRE construction. Since unquoted shell words
    # are already prevented from matching such terminators at the start of such
    # words and since such words match in the customary greedy manner, spaced
    # terminators *NOT* preceded by such whitespace are already correctly
    # matched as subwords of such words; likewise, spaced terminators preceded
    # by whitespace are already correctly matched as such terminators.
    #
    # While all terminators may be preceded by horizontal whitespace, such
    # whitespace need *NOT* be matched here -- even in an optional manner. By
    # design (e.g., of ${pcre_words_*} PCREs), prior PCREs are guaranteed to
    # already match such whitespace.
    local pcre_terminators_head='(?>'
    local pcre_terminators_foot='|'${pcre_terminator_spaced}')'${pcre_spaces_horizontal_continuable_optional}

    # Command terminator(s).
    local pcre_terminators=${pcre_terminators_head}${pcre_terminator_unspaced}${pcre_terminators_foot}

    # Command terminator(s) in a block.
    local pcre_terminators_blockable=${pcre_terminators_head}${pcre_terminator_unspaced_blockable}${pcre_terminators_foot}

    # Command terminator(s) optimizing matching of preprocessor macros.
    local pcre_terminators_macroable=${pcre_terminators_head}${pcre_terminator_unspaced_macroable}${pcre_terminators_foot}

    # ..................{ REDIRECTION ~ unique               }..................
    # Digit-prefixed redirection prefix, matching only sufficiently many
    # characters to identify such redirection.
    local pcre_redirect_numbered_prefix='[0-9]++&?[<>]'

    # "{"- and "}"-delimited variable name-prefixed redirection prefix,
    # matching only sufficiently many characters to identify such redirection.
    # By "man zshmisc" commentary, "No whitespace is allowed between the
    # closing brace and the redirection character."
    local pcre_redirect_file_descriptor_prefix='\{'${ZESHY_VAR_NAME_PCRE}'\}[<>]'

    # Digit- or file descriptor redirection prefix, principally intended for
    # use in negative lookahead preventing matching of such redirections. All
    # other redirections are prefixed by characters already prevented from
    # matching in unquoted shell words (e.g., "<", ">") and hence need *NOT* be
    # matched explicitly.
    local pcre_redirect_unique_prefix=${pcre_redirect_numbered_prefix}'|'${pcre_redirect_file_descriptor_prefix}

    # ..................{ LITERAL ~ sourceable               }..................
    # Negative lookahead preventing substrings that would otherwise be matched
    # as unquoted shell words from being matched as such. By PCRE design, most
    # command terminators (e.g., "<") are already excluded from unquoted shell
    # words and hence need *NOT* be matched here. Instead, this matches:
    #
    # * "=(", prefixing "=("- and ")"-delimited process substitutions,
    #   conflicting with both unquoted "=" characters *AND* "("- and ")"-
    #   delimited glob qualifiers.
    # * zeshy-specific command terminators (e.g., ":not") implemented as and
    #   hence intended to be expanded as global aliases. Usefully, since zsh
    #   expands global aliases in ":is"- and "[["-prefixed tests, preventing
    #   unquoted shell words from containing such aliases implicitly avoids
    #   such conflict. Tests need *NOT* be explicitly matched elsewhere.
    #
    # Notably, this PCRE does *NOT* match redirections technically conflicting
    # with unquoted shell word syntax (e.g., "1>&2", in which such "1" will be
    # erroneously matched as an unquoted shell word). Since redirections and
    # such words are principally matched for disambiguation, such
    # technicalities are usually of no consequence. (Note that redirections
    # prefixed by "{"- and "}"-delimited variable name file descriptors are
    # prefixed by "{" and hence already prevented from matching such words.)
    local pcre_literal_sourceable_lookahead_body=${pcre_terminator_spaced}'|=\('
    local pcre_literal_sourceable_lookahead='(?!='${pcre_literal_sourceable_lookahead_body}')'

    # Unquoted shell word character at the start of the first such word of a
    # command in a general context.
    local pcre_literal_sourceable_start_word_first=${pcre_literal_sourceable_lookahead}'['${char_not_literal_sourceable_start_word_first}']'

    # Unquoted shell word character at the start of any such word *AFTER* the
    # first of a command in a general context.
    local pcre_literal_sourceable_start_word_rest=${pcre_literal_sourceable_lookahead}'['${char_not_literal_sourceable_start_word_rest}']'

    # One or more unquoted shell word characters *AFTER* the start of any such
    # word of a command in a general context, including characters technically
    # invalid at the end of such words (i.e., "}" block suffixes). For
    # efficiency, most subsequent word types treat such suffixes as valid at
    # the end of such words and hence require no distinction between characters
    # valid at the middle and end of such words.
    local pcre_literals_sourceable_rest='['${char_not_literal_sourceable_rest}']++'

    # ..................{ LITERAL ~ backtickable             }..................
    # Unquoted shell word character at the start of the first such word of a
    # command in a "`"-delimited process substitution.
    local pcre_literal_backtickable_start_word_first=${pcre_literal_sourceable_lookahead}'['${char_not_literal_backtickable_start_word_first}']'

    # Unquoted shell word character at the start of any such word *AFTER* the
    # first of a command in a "`"-delimited process substitution.
    local pcre_literal_backtickable_start_word_rest=${pcre_literal_sourceable_lookahead}'['${char_not_literal_backtickable_start_word_rest}']'

    # One or more unquoted shell word characters *AFTER* the start of any such
    # word of a command in a "`"-delimited process substitution.
    local pcre_literals_backtickable_rest='['${char_not_literal_backtickable_rest}']++'

    # ..................{ LITERAL ~ blockable                }..................
    # Negative lookbehind preventing subsequent PCREs from matching "}" block
    # suffixes suffixing shell words in blocks as unquoted shell characters
    # (rather than as balanced block delimiters). Such constraint technically
    # applies to all such words but pertains only to brace-balanced matching.
    # Note that, while "(" is unconditionally invalid as the first character of
    # such words, ")" is conditionally valid (e.g., when preceded by a "(" in
    # the same word) and hence omitted here.
    #
    # There exists an alternative means of achieving the same effect: positive
    # construction of word PCREs, preventing such PCREs from terminating in
    # such suffixes. Since lookbehind is known to be relatively expensive,
    # such construction would seem to be superficially superior. In practice,
    # such construction requires significant backtracking (e.g., at the last
    # character of every unquoted shell word to guarentee that the constrained
    # set of permissible last characters is matched instead). Since such
    # backtracking is equally expensive *AND* since such construction is
    # considerably more complex than negative lookbehind, the current approach
    # is (surprisingly) the optimal solution in both efficiency and simplicity.
    local pcre_literal_blockable_lookbehind='(?<!'${pcre_brace_right}')'

    # Unquoted shell word character at the start of the first such word of a
    # command in a block.
    local pcre_literal_blockable_start_word_first=${pcre_literal_sourceable_start_word_first}${pcre_literal_blockable_lookbehind}

    # Unquoted shell word character at the start of any such word *AFTER* the
    # first of a command in a block.
    local pcre_literal_blockable_start_word_rest=${pcre_literal_sourceable_start_word_rest}${pcre_literal_blockable_lookbehind}

    # One or more unquoted shell word characters *AFTER* the start of any such
    # word of a command in a block.
    local pcre_literals_blockable_rest=${pcre_literals_sourceable_rest}${pcre_literal_blockable_lookbehind}

    # ..................{ LITERAL ~ braceable                }..................
    # Brace expansion, whose delimiters conflict with block delimiters and
    # hence require disambiguation. Technically, such expansion prohibits
    # UTF-8-encoded characters. For simplicity, subsequent PCREs ignore such
    # technicality by matching both ASCII and UTF-8-encoded characters.
    # Likewise, since the syntactic structure of such expansions dynamically
    # depends on shell option "brace_ccl" *AND* since such structure is
    # irrelevant to such disambiguation, such PCREs ignore structure.

    # ONe or more characters in a brace expansion.
    local pcre_literal_braceable='[^'${char_not_literal_braceable}']'

    # ONe or more characters in a brace expansion.
    local pcre_literals_braceable=${pcre_literal_braceable}'++'

    # Zero or more characters in a brace expansion.
    local pcre_literals_braceable_optional=${pcre_literal_braceable}'*+'

    # ..................{ LITERAL ~ parenable                }..................
    # Unquoted shell word character at the start of any such word of a command
    # in a paren-delimited syntactic construct.
    local pcre_literal_parenable_start=${pcre_literal_sourceable_lookahead}'['${char_not_literal_parenable_start}']'

    # One or more unquoted shell word characters *AFTER* the start of any such
    # word of a command in a paren-delimited syntactic construct.
    local pcre_literals_parenable_rest='['${char_not_literal_parenable_rest}']++'

    # Zero or more unquoted shell word characters *AFTER* the start of any such
    # word of a command in a paren-delimited syntactic construct.
    local pcre_literals_parenable_rest_optional='['${char_not_literal_parenable_rest}']*+'

    # ..................{ LITERAL ~ passable                 }..................
    # Negative lookahead preventing matching of syntactic construct prefixes
    # conflicting with the start of unquoted shell words permitting matching of
    # macro arguments. To ensure argument matching halts at the first
    # redirection applied to such macro, this includes redirection prefixes.
    local pcre_literal_passable_lookahead='(?!'${pcre_literal_sourceable_lookahead_body}'|'${pcre_redirect_unique_prefix}')'

    # Unquoted shell word character at the start of a scalar macro argument. To
    # properly match arguments embedding "`"-delimited process substitutions,
    # "`" characters are matched elsewhere in a proper manner rather than here.
    # To ensure argument matching halts at the first "}" block suffix, such
    # suffix is prevented from matching via negative lookbehind.
    local pcre_literal_passable_start=${pcre_literal_passable_lookahead}'['${char_not_literal_backtickable_start_word_rest}']'${pcre_literal_blockable_lookbehind}

    # One or more unquoted shell word characters *AFTER* the start of a scalar
    # macro argument.
    local pcre_literals_passable_rest=${pcre_literals_backtickable_rest}${pcre_literal_blockable_lookbehind}

    # ..................{ REDIRECTION                        }..................
    # Unquoted literal shell word, comprising only unconditionally unreserved
    # characters and hence excluding conditionally unreserved parens.
    local pcre_word_literal=${pcre_literal_parenable_start}${pcre_literals_parenable_rest_optional}
    local pcre_word_literal_grouped='('${pcre_word_literal}')'

    # Redirections are largely incidental to preprocessor parsing but must
    # nonetheless be partially matched for disambiguation with command
    # terminators and unquoted shell words. For example, since "&!" is a
    # command terminator while "&>" is not, matching merely an unquoted "&"
    # character is insufficient to identify a "&"-prefixed command terminator.

    # "<"-prefixed here-document or "<<"-prefixed here-string. The latter
    # prefix greedily overlaps the former prefix and must hence be matched
    # first. Since here-strings are shell words, since subsequent parsing
    # already matches such words, and since syntactically invalid here-strings
    # must also be matched, only such prefix is matched here.
    local pcre_here_prefix='<'
    local pcre_here=${pcre_here_prefix}'(?>'${pcre_here_prefix}'|(?&doc))|'${pcre_reset_remainder_succeed}')'

    # Redirection. Since command arguments may be freely interspersed with
    # redirections, redirections must be disambiguated from command terminators
    # with overlapping syntax -- particularly, "&"-prefixed command terminators
    # "&", "&!", and "&&". In addition to "<<"-prefixed here-documents and
    # -strings, the following redirections are matched:
    #
    # "<", "<>", ">", ">|", ">!", ">>", ">>|", ">>!", "<&", ">&", "&>", ">&|",
    # ">&!", "&>|", "&>!", ">>&", "&>>", ">>&|", ">>&!", "&>>|", and "&>>!".
    #
    # Since matching "<("- and ">("-prefixed process substitution redirections
    # requires recursion and hence subroutine calls exceeding the scope of this
    # PCRE, a "(" *MUST* be prevented from matching after a "<" or ">" is
    # matched with negative lookahead.
    #
    # See section "REDIRECTION" of "man zshmisc".
    local pcre_redirect_not_process_substitution_lookahead='(?!\()'
    local pcre_redirect_less_than='<(?:'${pcre_here}'|[&>]|'${pcre_redirect_not_process_substitution_lookahead}')'
    local pcre_redirect_greater_than_char='>'${pcre_redirect_not_process_substitution_lookahead}
    local pcre_redirect_greater_than=${pcre_redirect_greater_than_char}'>?+&?+[!|]?+'
    local pcre_redirect_ampersand='&'${pcre_redirect_greater_than_char}'>?+[!|]?+'
    local pcre_redirect=${pcre_redirect_less_than}'|'${pcre_redirect_greater_than}'|'${pcre_redirect_ampersand}

    # ..................{ BRACE EXPANSION                    }..................
    # Smallest syntactic component in a brace expansion and hence matching
    # neither redirections nor quoted strings. (Such expansions prohibit both.)
    local pcre_picoword_braceable=${pcre_char_escaped}

    # Syntactic component in a brace expansion.
    local pcre_nanoword_braceable=${pcre_literals_braceable_optional}'|'${pcre_picoword_braceable}'|'${pcre_sourceable_nanoword_rest}

    # One or more syntactic components in a brace expansion.
    local pcre_nanowords_braceable='(?>'${pcre_nanoword_braceable}')++'

    # Zero or more syntactic components in a brace expansion.
    local pcre_nanowords_braceable_optional='(?>'${pcre_nanoword_braceable}')*+'

    # Brace expansion *OR* "{" character balanced by no subsequent "}"
    # character at the start of any shell word *AFTER* the first of a command.
    # Since "{" characters at the start of the first shell word of a command
    # are *ALWAYS* block prefixes, this applies only to subsequent words. To
    # prevent such expansion from erroneously matching shell words consisting
    # only of "{" and hence block prefixes, such prefix is suffixed by one
    # (rather than zero) or more characters.
    local pcre_brace_expansion_or_brace_left_start_word_rest=${pcre_brace_left}'(?>'${pcre_nanowords_braceable}${pcre_brace_right_optional}'|'${pcre_brace_right}')'

    # Brace expansion *OR* "{" character balanced by no subsequent "}"
    # character *AFTER* the start of any shell word of a command. 
    local pcre_brace_expansion_or_brace_left_rest=${pcre_brace_left}${pcre_nanowords_braceable_optional}${pcre_brace_right_optional}

    # ..................{ PICOWORD ~ passable                }..................
    # Smallest syntactic component in a scalar macro argument and hence *NOT*
    # matching redirections.
    local pcre_picoword_passable_sans_brace_left=${pcre_picoword_braceable}'|'${pcre_quotes}

    # Smallest syntactic component at the start of a scalar macro argument.
    local pcre_picoword_passable_start=${pcre_picoword_passable_sans_brace_left}'|'${pcre_brace_expansion_or_brace_left_start_word_rest}

    # Smallest syntactic component *AFTER* the start of a scalar macro
    # argument.
    local pcre_picoword_passable_rest=${pcre_picoword_passable_sans_brace_left}'|'${pcre_brace_expansion_or_brace_left_rest}

    # ..................{ PICOWORD ~ sourceable              }..................
    # Smallest syntactic component at the start of the first shell word of a
    # command.
    local pcre_picoword_sourceable_start_word_first=${pcre_picoword_passable_sans_brace_left}'|'${pcre_redirect}

    # Smallest syntactic component at the start of any shell word *AFTER* the
    # first of a command.
    local pcre_picoword_sourceable_start_word_rest=${pcre_picoword_passable_start}'|'${pcre_redirect}

    # Smallest syntactic component *AFTER* the start of any shell word of a
    # command.
    local pcre_picoword_sourceable_rest=${pcre_picoword_passable_rest}'|'${pcre_redirect}

    # ..................{ NANOWORD ~ backtickable            }..................
    # Syntactic component at the start of the first shell word of a command
    # embedded in a "`"-delimited process substitution.
    local pcre_nanoword_backtickable_start_word_first=${pcre_literal_backtickable_start_word_first}'|'${pcre_picoword_sourceable_start_word_first}'|'${pcre_sourceable_nanoword_start_word_first}

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command embedded in a "`"-delimited process substitution.
    local pcre_nanoword_backtickable_start_word_rest=${pcre_literal_backtickable_start_word_rest}'|'${pcre_picoword_sourceable_start_word_rest}'|'${pcre_sourceable_nanoword_start_word_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command embedded in a "`"-delimited process substitution.
    local pcre_nanowords_backtickable_rest_optional='(?>'${pcre_literals_backtickable_rest}'|'${pcre_picoword_sourceable_rest}'|'${pcre_sourceable_nanoword_rest}')*+'

    # ..................{ NANOWORD ~ parenable               }..................
    # Syntactic component at the start of the first shell word of a command in
    # a paren-delimited syntactic construct.
    local pcre_nanoword_parenable_start_word_first=${pcre_literal_parenable_start}'|'${pcre_picoword_sourceable_start_word_first}'|'${pcre_sourceable_nanoword_start_word_first}

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command in a paren-delimited syntactic construct.
    local pcre_nanoword_parenable_start_word_rest=${pcre_literal_parenable_start}'|'${pcre_picoword_sourceable_start_word_rest}'|'${pcre_sourceable_nanoword_start_word_rest}

    # Syntactic component *AFTER* the start of a shell word of a command in a
    # paren-delimited syntactic construct.
    local pcre_nanoword_parenable_rest=${pcre_literals_parenable_rest}'|'${pcre_picoword_sourceable_rest}'|'${pcre_sourceable_nanoword_rest}

    # ..................{ NANOWORD ~ passable                }..................
    # Macro argument matching *MUST* halt at the first unbalanced ")" and "}"
    # characters (signifying process substitutions and block suffixes,
    # respectively), implying such characters should *NOT* be matched below.
    # Preventing "}" characters from matching only requires trivial lookbehind.
    # Preventing unbalanced ")" characters from matching, however, requires
    # matching glob qualifiers. (In either case, both are readily feasible.)
    #
    # Redirections are also *NOT* matched. Technically, zsh permits
    # redirections to be arbitrarily interspersed with arguments passed to
    # conventional builtins, commands, and functions: e.g.,
    #
    #    >>> function :flint_michigan() { print "${@}" }
    #    >>> :flint_michigan 1<&2 =(print gary_indiana) oakland_california
    #    /tmp/zsh3lpV1a oakland_california
    #
    # Permitting redirections to be arbitrarily interspersed with macro
    # arguments makes comparatively less sense. Even where sensible, permitting
    # such edge cases would require preprocessing to shift all such
    # redirections to the end of their respective macro calls -- a non-trivial
    # chore. For now, such edge cases are explicitly prohibited by prohibiting
    # redirection primitives in macro arguments (e.g., "<", ">", "|"). Hence,
    # redirections *MUST* strictly suffix macro arguments.

    # Syntactic component at the start of a scalar macro argument.
    local pcre_nanoword_passable_start=${pcre_literal_passable_start}'|'${pcre_picoword_passable_start}'|'${pcre_passable_nanoword_start}

    # Syntactic component *AFTER* the start of a scalar macro argument.
    local pcre_nanoword_passable_rest=${pcre_literals_passable_rest}'|'${pcre_picoword_passable_rest}'|'${pcre_passable_nanoword_rest}

    # ..................{ GLOB QUALIFIER                     }..................
    # Parenable-specific word PCREs are split into two subsections, reflecting
    # the need to match list assignments matching glob qualifiers. (See below.)
    # Glob qualifiers are non-nestable and hence matchable without recursion
    # (e.g., via subroutine calls), but *CAN* nest other syntactic constructs
    # (e.g., single-quoted strings).
    #
    # Note that since an unbalanced "}" block suffix terminates most types of
    # shell words (e.g., due to such word being embedded in a "{"- and
    # "}"-delimited block), PCREs below avoid matching such suffix via
    # negative lookbehind. PCREs below *NOT* embedding such lookbehind thus
    # match unbalanced "}" block suffixes.

    # "("- and ")"-delimited glob qualifier prefix.
    local pcre_qualifier_prefix=${pcre_paren_left}

    # "("- and ")"-delimited glob qualifier suffix.
    local pcre_qualifier_suffix=${pcre_paren_right_optional}

    # "("- and ")"-delimited glob qualifier permitting matching of strictly
    # balanced parens.
    local pcre_qualifier_parenable=${pcre_qualifier_prefix}'(?>'${pcre_nanoword_parenable_rest}')'${pcre_qualifier_suffix}

    # Zero or more syntactic components *AFTER* the start of a shell word,
    # permitting matching of strictly balanced parens.
    local pcre_nanowords_parenable_rest_optional='(?>'${pcre_nanoword_parenable_rest}'|'${pcre_qualifier_parenable}')*+'

    # Shell word *AFTER* the first such word of a command, permitting matching
    # of strictly balanced parens.
    local pcre_word_parenable_rest='(?>'${pcre_nanoword_parenable_start_word_rest}'|'${pcre_qualifier_parenable}')'${pcre_nanowords_parenable_rest_optional}
    local pcre_word_parenable_rest_optional='(?>'${pcre_word_parenable_rest}')?+'

    # ..................{ LIST ASSIGNMENT                    }..................
    # List assignment, whose syntax fundamentally conflicts with *ALL*
    # syntactic contexts and hence requires disambiguation. Specifically:
    #
    # * Vertical whitespace in list assignments is *NOT* a command terminator,
    #   unlike in customary commands.
    # * The ")" suffixing list assignments conflicts with the ")" suffixing
    #   such syntactic constructs (e.g., process forks and substitutions).
    # * List assignments prohibit syntax otherwise permitted in customary
    #   commands (e.g., "<("- and ">)"-prefixed process substitutions).
    #
    # Technically, list assignments may only contain passable syntactic
    # constructs (i.e., constructs embeddable in command arguments). However,
    # enforcing such constraint would require defining PCREs matching such
    # constructs in an inefficient subroutine-based manner above rather than in
    # an efficient embedding-based manner below. Since such constraint is
    # ignorable for preprocessing purposes, we match arbitrary code in list
    # assignments with previously defined PCREs instead.

    # One or more list assignment-specific syntactic constructs. For
    # generality, this PCRE mostly complies with list assignment syntax.
    # Specifically:
    #
    # * "}" block suffixes are prevented from matching by negative lookbehind,
    #   permitting use of this PCRE for matching strictly balanced braces.
    # * "("-prefixed syntactic constructs (i.e., arithmetic substitutions and
    #   process forks) are prevented from matching by embedding
    #   ${pcre_word_parenable_rest} rather than
    #   ${pcre_word_parenable_first}, implying "("-prefixed words in list
    #   assignments will be matched as glob qualifiers. Fortunately, this
    #   corresponds exactly to zsh behaviour.
    #
    # Technically, this PCRE should but does *NOT* prohibit redirections and
    # hence "<("- and ">("-prefixed process substitutions. However, this is
    # largely ignorable: attempting to violate such technicalities *WILL* still
    # induce a fatal exception during zsh parsing.
    local pcre_list_assignment_word=${pcre_word_parenable_rest}${pcre_word_lookbehind}

    # One or more list assignment-specific shell words. Disambiguating "#"-
    # prefixed comments from "#" glob operators *AND* terminating ")" suffixes
    # from embedded ")"-suffixed glob qualifiers inherently requires word-
    # rather than character- oriented matching. (Insert collective shrug here.)
    local pcre_list_assignment_words=${pcre_list_assignment_word}'(?:'${pcre_comment_optional_spaced}${pcre_list_assignment_word}')*+'

    # "=("-prefixed list assignment, excluding prefixing variable name.
    local pcre_list_assignment_prefix=':=\('
    local pcre_list_assignment_suffix='\)'
    local pcre_list_assignment_body=${pcre_comment_spaced_optional}${pcre_list_assignment_words}${pcre_comment_spaced_optional}
    local pcre_list_assignment_sans_var_name=${pcre_list_assignment_prefix}'(?>'${pcre_list_assignment_body}${pcre_list_assignment_suffix}'|'${pcre_reset_remainder_succeed}')'

    # Substring prefixing the first shell word of a command, ensuring list
    # assignments to be matched preferentially at the start of such words.
    #
    # Since list assignments are prefixed by variable names indistinguishable
    # from and hence conflicting with unquoted shell words, the former are
    # matched first. Naturally, only the first shell word is in command
    # position and hence requires matching for list assignments.
    local pcre_var_name_with_list_assignment_or_head=${ZESHY_VAR_NAME_PCRE}'(?>'${pcre_list_assignment_sans_var_name}'|'
    local pcre_var_name_with_list_assignment_or_foot=')'

    # ..................{ WORD ~ parenable                   }..................
    # First shell word of a command, permitting matching of strictly balanced
    # parens. List assignment parens conflict with such matching and hence are
    # explicitly matched.
    local pcre_word_parenable_first_body='(?>'${pcre_nanoword_parenable_start_word_first}')'${pcre_nanowords_parenable_rest_optional}
    local pcre_word_parenable_first='(?>'${pcre_var_name_with_list_assignment_or_head}${pcre_nanowords_parenable_rest_optional}${pcre_var_name_with_list_assignment_or_foot}'|'${pcre_word_parenable_first_body}')'

    # Zero or more shell words permitting matching of strictly balanced parens,
    # each delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    local pcre_words_parenable_optional='(?>'${pcre_word_parenable_first}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_parenable_rest_optional}')*+)?+'

    # Zero or more commands permitting matching of strictly balanced parens.
    local pcre_commands_parenable_optional='(?>'${pcre_words_parenable_optional}${pcre_terminators}')*+'

    # ..................{ WORD ~ backtickable                }..................
    # First shell word of a command, permitting matching of "`"-delimited
    # process substitutions. Note that list assignments are irrelevant to such
    # matching and hence omitted.
    local pcre_word_backtickable_first='(?>'${pcre_nanoword_backtickable_start_word_first}')'${pcre_nanowords_backtickable_rest_optional}

    # Any shell word *AFTER* the first of a command, permitting matching of
    # "`"-delimited process substitutions.
    local pcre_word_backtickable_rest='(?>'${pcre_nanoword_backtickable_start_word_rest}')'${pcre_nanowords_backtickable_rest_optional}
    local pcre_word_backtickable_rest_optional='(?>'${pcre_word_backtickable_rest}')?+'

    # Zero or more shell words permitting matching of "`"-delimited process
    # substitutions, delimited by one or more horizontal whitespace characters
    # optionally interspersed by line continuations.
    local pcre_words_backtickable_optional='(?>'${pcre_word_backtickable_first}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_backtickable_rest_optional}')*+)?+'

    # Zero or more commands permitting matching of "`"-delimited processs
    # substitutions.
    local pcre_commands_backtickable_optional='(?>'${pcre_words_backtickable_optional}${pcre_terminators}')*+'

    # ..................{ WORD ~ passable                    }..................
    # "("- and ")"-delimited glob qualifier in a scalar macro argument.
    local pcre_qualifier_passable=${pcre_qualifier_prefix}'(?>'${pcre_nanoword_passable_rest}')'${pcre_qualifier_suffix}

    # Scalar macro argument. Since arguments are never in command position,
    # list assignments are irrelevant to such matching and hence omitted.
    local pcre_word_passable='(?>'${pcre_nanoword_passable_start}'|'${pcre_qualifier_passable}')(?>'${pcre_nanoword_passable_rest}'|'${pcre_qualifier_passable}')*+'
    local pcre_word_passable_optional='(?>'${pcre_word_passable_rest}')?+'

    # Zero or more scalar macro arguments, preceded by one or more horizontal
    # whitespace characters optionally interspersed by line continuations.
    # ${pcre_word_passable} matches escaped characters and hence line
    # continuations, implying the whitespace preceding such PCRE to be more
    # efficiently matchable with ${pcre_spaces_horizontal_continuable} than
    # ${pcre_continuable_spaces_horizontal}. However, embedding the former
    # prevents one or more initial line continuations from matching, requiring
    # explicit matching of such continuations. (Phew!)
    local pcre_words_passable_spaced_optional=${pcre_line_continuations_optional}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_passable}')*+'
    local pcre_words_passable_spaced_optional_grouped='('${pcre_words_passable_optional_spaced}')'

    local pcre_words_passable_spaced=
    local pcre_words_passable_spaced_grouped

    # ..................{ HERE                               }..................
    # Note that here-document syntactic invalidities (e.g., unmatched suffixing
    # delimiters) need *NOT* be matched here, as the PCRE embedding such PCREs
    # already accounts for such invalidities in a generalized manner.

    # Here-document delimiter prefix, comprising an ignorable optional hyphen
    # (signifying leading tabs to be insignificant) followed by zero or more
    # horizontal whitespace characters.  Since line continuations appear to
    # conflict with and hence be prohibited by such syntax, such whitespace
    # must *NOT* be interspersed by line continuations,
    local pcre_here_doc_delimiter_prefix='-?'${pcre_spaces_horizontal_optional} 
    # Here-document delimiter suffix, comprising zero or more horizontal
    # whitespace characters followed by a vertical whitespace character.
    local pcre_here_doc_delimiter_suffix=${pcre_spaces_horizontal_optional}${pcre_space_vertical}

    # Here-document suffix, matching the previously captured delimiter.
    local pcre_here_doc_suffix=${pcre_space_vertical}'(?-1)'${pcre_line_end}

    # Negative lookahead preventing matching of a here-document suffix
    # corresponding to a previously matched here-document prefix.
    local pcre_here_doc_not_suffix='(?!'${pcre_here_doc_suffix}')'

    # Quoted here-document and hence *NOT* embedding syntactic constructs.
    # Sadly, matching all possible here-document delimiters is infeasible
    # within the purview of a pure PCRE. Matching delimiters embedding escaped
    # characters (e.g., '<<"mother\"destroyer"') requires unescaping such
    # characters -- a trivial operation *NOT* implementable under PCRE.
    #
    # Only the proper subset of here-document delimiters containing no escaped
    # characters are matchable. Since no here-documents in the zeshy codebase
    # leverage such delimiters, such concerns are largely ignorable.
    local pcre_here_doc_quoted_delimiter_grouped=${pcre_quotes_literal_grouped}${pcre_here_doc_delimiter_suffix}
    local pcre_here_doc_quoted_body='.*?'
    local pcre_here_doc_quoted_grouped=${pcre_here_doc_quoted_delimiter_grouped}${pcre_here_doc_quoted_body}

    # Unquoted here-document and hence *NOT* embedding syntactic constructs.
    local pcre_here_doc_unquoted_delimiter_grouped=${pcre_word_literal_grouped}${pcre_here_doc_delimiter_suffix}
    local pcre_here_doc_unquoted_body='(?:[^'${char_space_vertical}${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}'|'${pcre_here_doc_not_suffix}${pcre_spaces}')'
    local pcre_here_doc_unquoted_grouped=${pcre_here_doc_unquoted_delimiter_grouped}${pcre_here_doc_unquoted_body}

    # Here-document. Such matching requires capturing and then subsequently
    # backreferencing the here-document delimiter, fundamentally interfering
    # with capture group indices. To obviate this, such matching is isolated to
    # a subroutine call. (Similar to function-scoped local variables, such
    # calls isolate capture groups by storing the current set of such groups on
    # entering such call and restoring such set on returning from such call.)
    local pcre_here_doc_body_grouped='(?:'${pcre_here_doc_quoted_grouped}'|'${pcre_here_doc_unquoted_grouped}')'
    pcre_subroutines_body+='(?<doc>'${pcre_here_doc_delimiter_prefix}${pcre_here_doc_body_grouped}${pcre_here_doc_suffix}')'

    # ..................{ HERE ~ unsupported                 }..................
    # The following PCREs are intended for use *ONLY* in
    # ${ZESHY__MACRO_HERE_DOC_UNSUPPORTED_PCRE} and hence break "the rules."

    # Here-document prefix disambiguated from a here-string prefix with
    # negative lookahead.
    local pcre_here_doc_unsupported_delimiter_prefix='<<(?!<)'${pcre_here_doc_delimiter_prefix}

    # Unsupported here-document delimiter, excluding delimiters matched above.
    local pcre_here_doc_unsupported_delimiter='(?!(?:'${pcre_quotes_single_literal}'|'${pcre_quotes_double_literal}'|'${pcre_word_literal}')'${pcre_here_doc_delimiter_suffix}')'

    # Unsupported here-document delimiter, matching any delimiter *NOT* matched
    # above with negative lookahead. To prevent either the empty string or
    # vertical whitespace characters from matching, match exactly one non-
    # vertical whitespace character.
    local pcre_here_doc_unsupported=${pcre_here_doc_unsupported_delimiter_prefix}${pcre_here_doc_unsupported_delimiter}${pcre_char_sans_space_vertical}

    # ..................{ SUBSTITUTION ~ process             }..................
    #FIXME: Actually, we can also match macros in process substitutions in
    #double-quoted strings at the top-level -- which is to say, in pretty much
    #all syntactic contexts of general interest. While this precludes macros in
    #nested process substitutions in nested double-quoted strings, such
    #contexts strike us as outlier in the extreme and hence (hopefully)
    #negligibly ignorable.
    #
    #Doing so, however, will require a smidgeon of refactoring elsewhere and
    #hence is probably warranted only after finishing a reasonable first-draft
    #implementation. The idea is simple: since matching such macros requires
    #"remembering" that such macro was embedded in double quotes, that's
    #actually what we do. Specifically:
    #
    #* Create a new PCRE
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped},
    #  retaining the existing ${pcre_quotes_double} for use in all other
    #  syntactic contexts.
    #* ${pcre_quotes_double_sans_process_substitution_prefix_grouped} should be
    #  identical to ${pcre_quotes_double} except that the former should:
    #  * Explicitly avoid matching the "$(" prefixing such process
    #    substitutions (e.g., with a PCRE fragment resembling
    #    "(?>[^$]++|\$[^(]*+)*+"). Such prefix will then be subsequently
    #    matched as a command terminator by ${pcre_macro} as desired.
    #  * Wait. No; since the preprocessor needs to be able to distinguish
    #    between macros embedded in "$("-prefixed process substitutions
    #    embedded in double-quoted strings and macros *NOT* embedded in such
    #    contexts, a unique group index or indices must be allocated to each.
    #    While there exist any number of means of doing so, the simplest and
    #    most efficient is probably as follows:
    #    * Wrap the leading PCRE matching macros in an on-the-fly subroutine
    #      definition (e.g., "(?<mac>...)"). Since a definition is *NOT* a
    #      call, matching top-level macros in this manner should *NOT* induce
    #      additional inefficiencies -- which is critical.
    #    * Call such subroutine from within "$("-prefixed process substitutions
    #      embedded in double-quoted strings (e.g.,
    #      "(?>[^"$]++|\$(?>[^(]*+|\((?>(?&mac)|...)))*+").
    #    * Such subroutine call should have the effect of duplicating the match
    #      groups defined by such leading subroutine definition, enabling
    #      disambiguation between the two categories of macros in
    #      preprocessor logic.
    #* Rename the existing PCRE global ${ZESHY__PREPROCESS_PCRE} to
    #  ${ZESHY__MACRO_UNQUOTED_PCRE}. The preprocessor should use such global
    #  by default when performing PCRE-based iteration.
    #* Create new PCRE global ${ZESHY__MACRO_QUOTED_PCRE}, beginning matching
    #  from within a process substitution embedded in a double-quoted string.
    #  The preprocessor should use such global only when performing PCRE-based
    #  iteration *AFTER* having just matched a macro embedded in a process
    #  substitution embedded in double quotes.
    #
    #And... that's it. Clearly feasible, if a fair amount of work. In any case,
    #such improvements are doubtless fodder for another code day.

    # Process substitutions accept arbitrary zsh code and hence *SHOULD*
    # technically also accept arbitrary zeshy code -- including embedded
    # macros. Unfortunately, resuming PCRE-based matching after matching such a
    # macro would prevent the former from matching the delimiter suffixing the
    # syntactic construct embedding such embed. For example, consider the
    # following zeshy code attempting to embed a hypothetical macro :macro():
    #
    #    :string.output "$(:macro); :macro"; :macro
    #
    # While such macro is certainly matchable as a macro and subsequently
    # expandable, doing so would effectively disremember that such macro was
    # embedded within a process substitution embedded within a double-quoted
    # string. Since the substring '); :macro"; :macro" would then be
    # erroneously misinterpreted as top-level code on resuming PCRE-based
    # iteration, such ";" would likewise be matched as a command terminator
    # prefixing another ":macro", likewise matched as a macro and subsequently
    # expanded -- erroneously, of course. To compound matters, such '"' would
    # be matched as a prefixing rather than suffixing double-quoted string
    # delimiter, effectively destroying all subsequent parsing.
    #
    # In short, matching and expanding macros nested in process substitutions
    # is inherently infeasible in the current PCRE-based approach. Properly
    # matching and expanding such macros would require a genuine parser, at
    # which point the ideal decision would be to patch the "zsh" interpreter
    # itself with support for macro preprocessing. As this exceeds the scope of
    # current work, the current approach and hence constraints stand.

    # "`"-delimited process substitution.
    local pcre_process_substitution_backtick_delimiter='`'
    local pcre_process_substitution_backtick=${pcre_process_substitution_backtick_delimiter}'(?>'${pcre_commands_backtickable_optional}${pcre_process_substitution_backtick_delimiter}'|'${pcre_reset_remainder_succeed}')'

    # ")"-suffixed process substitution or fork, excluding prefixing substring
    # if any (e.g., "$(", "=(").
    local pcre_process_sans_paren_left_suffix='\)'
    local pcre_process_sans_paren_left=${pcre_commands_parenable_optional}${pcre_process_sans_paren_left_suffix}

    # "("- and ")"-delimited process fork, excluding such prefix.
    local pcre_process_fork_sans_paren_left=${pcre_process_sans_paren_left}

    # "("- and ")"-delimited process fork.
    local pcre_process_fork_prefix='\('
    local pcre_process_fork=${pcre_process_fork_prefix}'(?>'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # "$("- and ")"-delimited process substitution, excluding such prefix.
    local pcre_process_substitution_sans_dollar_paren_left=${pcre_process_sans_paren_left}

    # "=("- and )"-delimited process substitution. Since such substitutions
    # expand to an absolute path and hence shell word, such substitutions are
    # embeddable in macro arguments. Since this is *NOT* the case for all other
    # redirection process substitutions, no comparable PCREs match the latter.
    local pcre_process_substitution_equals_prefix='\=\('
    local pcre_process_substitution_equals=${pcre_process_substitution_equals_prefix}'(?>'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # Redirection process substitutions, comprising:
    #
    # * "=("- and ")"-delimited process substitutions implicitly creating and
    #   removing temporary files.
    # * "<("- and ")"-delimited process substitutions redirecting standard
    #   input.
    # * ">("- and ")"-delimited process substitutions redirecting standard
    #   output.
    local pcre_process_substitution_redirection_prefix='[=<>]\('
    local pcre_process_substitution_redirection=${pcre_process_substitution_redirection_prefix}'(?>'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # ..................{ SUBSTITUTION ~ math                }..................
    # "$["- and "]"-delimited arithmetic substitution. While such delimiter
    # does *NOT* conflict with "$("- and ")"-delimited process substitutions,
    # the left bit-shift operator "<<" supported by such substitutions still
    # conflicts with here-document and -string prefixes.
    local pcre_math_substitution_braces_sans_dollar_prefix='\['
    local pcre_math_substitution_braces_sans_dollar_suffix='\]'
    local pcre_math_substitution_braces_sans_dollar_body='(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_math_substitution_braces_sans_dollar=${pcre_math_substitution_braces_sans_dollar_prefix}${pcre_math_substitution_braces_sans_dollar_body}${pcre_math_substitution_braces_sans_dollar_suffix}

    # "))"-suffixed arithmetic construct excluding prefix (e.g., "$((").
    local pcre_paren_right_not_math_suffix='\)(?!\))'
    local pcre_math_suffix='\)\)'
    local pcre_math_body='(?:[^)'${char_not_embeddable_prefix}']++|'${pcre_paren_right_not_math_suffix}'|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_math_sans_prefix='(?>'${pcre_math_body}${pcre_math_suffix}'|'${pcre_reset_remainder_succeed}')'

    # "(("- and "))"-delimited arithmetic test excluding the first such "(",
    # whose syntax conflicts in a similar manner as discussed below.
    local pcre_math_test_sans_paren_left='\('${pcre_math_sans_prefix}

    # "(("- and "))"-delimited arithmetic test.
    local pcre_math_test='\(\('${pcre_math_sans_prefix}

    # "$(("- and "))"-delimited arithmetic substitution excluding such "$(" but
    # *NOT* the following "(". The following syntax conflicts with conventional
    # syntax and hence *MUST* be matched for disambiguaty:
    #
    # * "))", delimiting such substitutions as well as overlapping and hence
    #   conflicting with the ")" delimiting "$("- and ")"-delimited process
    #   substitutions.
    # * "<<", the C-style left bit-shift operator conflicting with the here-
    #   document prefix "<<" and here-string prefix "<<<".
    local pcre_math_substitution_parens_sans_dollar_paren_left='\('${pcre_math_sans_prefix}

    # "$(("- and "))"-delimited arithmetic substitution, excluding such "$"
    # but *NOT* the following "((".
    local pcre_math_substitution_parens_sans_dollar='\(\('${pcre_math_sans_prefix}

    # "$"-prefixed arithmetic substitution, excluding such "$".
    local pcre_math_substitution_sans_dollar=${pcre_math_substitution_parens_sans_dollar}'|'${pcre_math_substitution_braces_sans_dollar}

    # ..................{ VARIABLE                           }..................
    # "$"-prefixed variable expansion *NOT* delimited by "{" and "}", excluding
    # such "$". To permissively match syntax specific to such expansion *NOT*
    # conflicting with preprocessor matching, one or more such characters are
    # arbitrarily matched. Although this erroneously results in edge-case
    # raw strings matching as variable expansions (e.g., "$::"), such
    # misidentification is irrelevant to preprocessing and hence ignorable.
    local pcre_var_undelimited_sans_dollar='(?:[^'${char_not_literal_backtickable_rest}']++|'${pcre_char_escaped}')++'

    # "${"- and "}"-delimited variable expansion, excluding such "$".
    local pcre_var_delimited_sans_dollar_prefix='\{'
    local pcre_var_delimited_sans_dollar_suffix='\}'
    local pcre_var_delimited_sans_dollar_body='(?:[^}'${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_var_delimited_sans_dollar=${pcre_var_delimited_sans_dollar_prefix}${pcre_var_delimited_sans_dollar_body}${pcre_var_delimited_sans_dollar_suffix}

    # "$"-prefixed and possibly "}"-suffixed variable expansion, excluding such
    # "$".
    local pcre_var_sans_dollar=${pcre_var_undelimited_sans_dollar}'|'${pcre_var_delimited_sans_dollar}

    # ..................{ CONSTRUCT ~ dollar                 }..................
    # "$("-prefixed substitution excluding such "$", comprising:
    #
    # * "$(("- and "))"-delimited arithmetic substitutions.
    # * "$("- and ")"-delimited process substitutions.
    #
    # Since the "$((" delimiting the former greedily overlaps the "$("
    # delimiting the latter, the former *MUST* be matched first.
    local pcre_dollar_parenable_sans_dollar_prefix='\('
    local pcre_dollar_parenable_sans_dollar_body='(?:'${pcre_math_substitution_parens_sans_dollar_paren_left}'|'${pcre_process_substitution_sans_dollar_paren_left}')'
    local pcre_dollar_parenable_sans_dollar=${pcre_dollar_parenable_sans_dollar_prefix}${pcre_dollar_parenable_sans_dollar_body}

    # "$"-prefixed interpretable syntactic construct, comprising variable
    # expansions and arithmetic and process substitutions.
    local pcre_dollar_prefix='\$'
    local pcre_dollar_head=${pcre_dollar_prefix}'(?>'${pcre_var_sans_dollar}'|'
    local pcre_dollar_foot='|'${pcre_reset_remainder_succeed}')'
    local pcre_dollar_interpretable=${pcre_dollar_head}${pcre_math_substitution_braces_sans_dollar}'|'${pcre_dollar_parenable_sans_dollar}${pcre_dollar_foot}

    # ..................{ CONSTRUCT ~ parens                 }..................
    # "("-prefixed interpretable syntactic construct, comprising:
    #
    # * "("- and ")"-delimited process forks.
    # * "(("- and "))"-delimited arithmetic tests.
    #
    # Since the "((" delimiting the latter greedily overlaps the "(" delimiting
    # the former, the latter *MUST* be matched first.
    local pcre_paren_left_interpretable_prefix='\('
    local pcre_paren_left_interpretable=${pcre_paren_left_interpretable_prefix}'(?>'${pcre_math_test_sans_paren_left}'|'${pcre_process_fork_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # ..................{ CONSTRUCT ~ subroutine             }..................
    # Syntactic construct recursively embeddable in variable expansions,
    # arithmetic substitutions, and arithmetic tests. Unlike interpretable
    # syntactic constructs defined below, embeddable syntactic constructs
    # *MUST* include "`"-delimited process substitutions -- as the following
    # examples demonstrate:
    # 
    # * '"`: ""`"', a syntactically valid double-quoted string embedding such a
    #   substitution embedding such a string.
    # * "${:-`{}`}", a syntactically valid variable expansion embedding such a
    #   substitution embedding an empty block.
    # 
    # The first example suggests the delimitation of such embeddables by single
    # characters (e.g., quotes) rather than balanced pairs of characters (e.g.,
    # parens) to require matching such substitutions in embeddables. Since the
    # second example demonstrates even embeddables delimited by balanced
    # characters to require such matching *AND* since non-embeddable
    # interpretables (e.g., "$("- and ")"-delimited process substitutions)
    # require no such matching, there *MUST* exist some fundamental disparity
    # between embeddables and non-embeddable interpretables.
    # 
    # Indeed, there does. Since "`"-delimited process substitutions are
    # themselves interpretables, the following observations hold:
    #
    # * When non-embeddable interpretables embed such substitutions (e.g.,
    #   "$(``)"), both the outer and inner syntactic contexts admit arbitrary
    #   zsh code and hence adhere to the same syntactic constraints.
    # * When embeddables embed such substitutions (e.g., '"``"'), only the
    #   inner syntactic context admits arbitrary zsh code. Hence, such contexts
    #   do *NOT* adhere to the same syntactic constraints.
    #
    # In the former case, since the internal substitutions comply with the
    # syntax of the external non-embeddable interpretables embedding such
    # substitutions *WITHOUT* disrupting the balancing of the characters
    # delimiting such interpretables, the contents of the internal
    # substitutions may be matched as if they were instead the contents of the 
    # external non-embeddable interpretables. In so doing, the "`" delimiting
    # such substitutions are fully ignorable.
    #
    # Naturally, this optimization ignores syntactic invalidities in
    # "`"-delimited process substitutions (e.g., the lack of a trailing "`")
    # embedded in interpretables. Since preprocessing is only concerned with
    # macro expansion *AND* since such substitutions are depracated, this
    # oversight is of no consequence.
    pcre_subroutines_body+='(?<emb>'${pcre_dollar_interpretable}'|'${pcre_process_substitution_backtick}')'

    # Syntactic construct recursively sourceable in any character positions
    # of any shell words of any commands in any syntactic contexts, including:
    #
    # * At the start of the first shell words of commands and hence including
    #   "("-prefixed syntactic constructs.
    # * In scalar macro arguments and hence including "`"-prefixed process
    #   substitutions. Since such substitutions are explicitly matched *ONLY*
    #   in such contexts...
    pcre_subroutines_body+='(?<sou>'${pcre_dollar_interpretable}'|'${pcre_paren_left_interpretable}'|'${pcre_process_substitution_redirect_optional}')'

    # ..................{ CONSTRUCT ~ unforkable             }..................
    # This subsection redefines the subset of syntactic constructs specific to
    # top-level macro and block matching. Since efficiency is paramount in such
    # syntactic contexts, the following PCREs are directly embedded rather than
    # called as indirect subroutines. While the efficiency cost of redefining
    # these constructs would typically outweigh efficiency gains of embedding
    # such PCREs, such constructs are *NOT* sourceable (e.g., process
    # substitutions) and hence are sufficiently simple to justify redefinition.

    # "$"-prefixed non-sourceable syntactic construct, comprising only variable
    # expansions and arithmetic substitutions.
    local pcre_dollar_unforkable=${pcre_dollar_head}${pcre_math_substitution_sans_dollar}${pcre_dollar_foot}

    # Unforkable syntactic construct at the first character of the first shell
    # word of a command (i.e., a construct neither a process fork nor
    # substitution). Since process forks and substitutions may embed arbitrary
    # code and hence macros, matching such constructs here would obstruct
    # matching macros embedded within such constructs elsewhere. To permit such
    # matching, such constructs' prefixes are matched as command terminators
    # wherever this PCRE is embedded. Specifically, this PCRE matches:
    #
    # * "$"-prefixed variable expansions.
    # * "${"- and "}"-delimited variable expansions.
    # * "$["- and "]"-delimited arithmetic substitutions.
    # * "$(("- and "))"-delimited arithmetic substitutions.
    # * "(("- and "))"-delimited arithmetic tests.
    #
    # For efficiency, this PCRE is directly embedded rather than called as an
    # indirect subroutine.
    local pcre_unforkable_subword_start_word_first=${pcre_dollar_unforkable}'|'${pcre_math_test}

    # Unforkable syntactic construct at the first character of any shell word
    # *AFTER* the first of a command.
    local pcre_unforkable_subword_start_word_rest=${pcre_dollar_unforkable}

    # Unforkable syntactic construct at any character *AFTER* the first of any 
    # shell word of a command.
    local pcre_unforkable_subword_rest=${pcre_dollar_unforkable}

    # ..................{ PICOWORD ~ unforkable              }..................
    # Smallest unforkable syntactic component at the start of the first shell
    # word of a command.
    local pcre_picoword_unforkable_start_word_first=${pcre_picoword_sourceable_start_word_first}'|'${pcre_unforkable_subword_start_word_first}

    # Smallest unforkable syntactic component at the start of any shell word
    # *AFTER* the first of a command.
    local pcre_picoword_unforkable_start_word_rest=${pcre_picoword_sourceable_start_word_rest}'|'${pcre_unforkable_subword_start_word_rest}

    # Smalleest unforkable syntactic component *AFTER* the start of any shell
    # word of a command.
    local pcre_picoword_unforkable_rest=${pcre_picoword_sourceable_rest}'|'${pcre_unforkable_subword_rest}

    # ..................{ MACRO ~ macroable                  }..................
    # Since strict balancing of delimiters (e.g., braces, parens) is irrelevant
    # to macro name matching, such delimiters are matched in arbitrary order.

    # Smaller syntactic component at the start of the first shell word of a
    # command at the top level.
    local pcre_nanoword_macroable_start_word_first=${pcre_literal_sourceable_start_word_first}'|'${pcre_picoword_unforkable_start_word_first}

    # Smaller syntactic component at the start of any shell word following the
    # first of a command at the top level.
    local pcre_nanoword_macroable_start_word_rest=${pcre_literal_sourceable_start_word_rest}'|'${pcre_picoword_unforkable_start_word_rest}

    # Smaller syntactic component *AFTER* the start of any shell word of a
    # command at the top level.
    local pcre_nanoword_macroable_rest=${pcre_literals_sourceable_rest}'|'${pcre_picoword_sourceable_rest}'|'${pcre_picoword_unforkable_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command at the top-level.
    local pcre_nanowords_macroable_rest_optional='(?:'${pcre_nanoword_macroable_rest}')*+'

    # First shell word of a command, permitting matching of macros. Since list
    # assignments contain vertical whitespace resembling command terminators
    # but no commands and hence macros, list assignments *MUST* be explicitly
    # matched to prevent macros from being erroneously matched after such
    # whitespace in such assignments.
    local pcre_word_macroable_first_body='(?>'${pcre_nanoword_macroable_start_word_first}')'${pcre_nanowords_macroable_rest_optional}
    local pcre_word_macroable_first=${pcre_var_name_with_list_assignment_or_head}${pcre_nanowords_macroable_rest_optional}${pcre_var_name_with_list_assignment_or_foot}'|'${pcre_word_macroable_first_body}

    # Any shell word *AFTER* the first of a command permitting matching of
    # macros.
    local pcre_word_macroable_rest='(?>'${pcre_nanoword_macroable_start_word_rest}')'${pcre_nanowords_macroable_rest_optional}
    local pcre_word_macroable_rest_optional='(?>'${pcre_word_macroable_rest}')?+'

    # Zero or more shell words *AFTER* the first of a command permitting
    # matching of macros, each delimited by one or more horizontal whitespace
    # characters optionally interspersed by line continuations.
    local pcre_words_macroable_rest_optional='(?>'${pcre_spaces_horizontal_continuable}${pcre_word_macroable_rest_optional}')*+'

    # ..................{ MACRO ~ blockable                  }..................
    # "{"- and "}"-delimited block, recursively nestable and hence matchable
    # only with a subroutine call.
    local pcre_block=${pcre_brace_left}'(?>(?&blk)'${pcre_brace_right}'|'${pcre_reset_remainder_succeed}')'
    local pcre_block_grouped='('${pcre_block}')'

    # Smaller syntactic component at the start of the first shell word of a
    # command in a block.
    local pcre_nanoword_blockable_start_word_first=${pcre_literal_blockable_start_word_first}'|'${pcre_picoword_unforkable_start_word_first}'|'${pcre_block}

    # Smaller syntactic component at the start of any shell word following the
    # first of a command in a block.
    local pcre_nanoword_blockable_start_word_rest=${pcre_literal_blockable_start_word_rest}'|'${pcre_picoword_unforkable_start_word_rest}'|'${pcre_block}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command in a block.
    local pcre_nanowords_blockable_rest_optional='(?:'${pcre_literals_blockable_rest}'|'${pcre_picoword_unforkable_rest}'|'${pcre_block}')*+'

    # First shell word of a command in a block. Unbalanced "}" block suffixes
    # are prevented from being matched with negative lookbehind. Note that list
    # assignments are irrelevant to such matching and hence omitted.
    local pcre_word_blockable_first='(?>'${pcre_nanoword_blockable_start_word_first}')'${pcre_nanowords_blockable_rest_optional}

    # Shell word *AFTER* the first such word of a command in a block.
    local pcre_word_blockable_rest='(?>'${pcre_nanoword_blockable_start_word_rest}')'${pcre_nanowords_blockable_rest_optional}
    local pcre_word_blockable_rest_optional='(?>'${pcre_word_blockable_rest}')?+'

    # One or more shell words in a block.
    local pcre_words_blockable=${pcre_word_blockable_first}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_blockable_rest_optional}')*+'

    # Zero or more commands in a block.
    local pcre_commands_blockable_optional='(?>'${pcre_words_blockable}${pcre_terminators_blockable}')*+'

    # "{"- and "}"-delimited block excluding such delimiters, defined as a
    # recursively callable subroutine.
    pcre_subroutines_body+='(?<blk>'${pcre_commands_blockable_optional}')'

    # ..................{ MACRO ~ arg                        }..................
    # To permit efficient reuse of a single compilation of ${ZESHY__PREPROCESS_PCRE}
    # for *ALL* macro preprocessing, such PCRE is generalized to support
    # PCRE-based iteration of both macros *AND* macro arguments. The former is
    # trivially achieved by capturing the name of the currently matched macro
    # and the latter by capturing the last block and/or scalar argument(s)
    # passed to such macro. When iterating macros, such argument-specific
    # groups are ignorable; likewise, when iterating macro arguments, such
    # macro-specific groups are ignorable.
    #
    # While all scalar and block arguments will be matched, the '*+' quantifier
    # suffixing ${pcre_macro_args_grouped} implies that only the last block
    # argument passed to a macro will be captured. Since such argument may be
    # optionally followed by zero or more scalar arguments, determining the
    # first and last byte indices of such last block argument and following
    # scalar arguments requires capturing both.

    # Macro block argument optionally followed by zero or more scalar macro
    # arguments.
    local pcre_macro_arg_block_grouped_and_args_scalar_optional_grouped=${pcre_block_grouped}${pcre_words_passable_spaced_optional_grouped}

    # One or more macro scalar arguments. To simplify argument iteration, such
    # arguments are captured to the same group index as that of the same
    # arguments captured by the prior PCRE via a prefixing empty group.
    local pcre_macro_args_scalar_grouped=${pcre_empty_group}${pcre_words_passable_spaced_grouped}

    # Macro block argument optionally followed by zero or more scalar macro
    # arguments *OR* one or more macro scalar arguments. While such arguments
    # may be matched in either order, the former are *ALWAYS* prefixed by "{"
    # and hence more efficiently matchable than the latter.
    local pcre_macro_arg_grouped='(?|'${pcre_macro_arg_block_grouped_and_args_scalar_optional_grouped}'|'${pcre_macro_args_scalar_grouped}')'

    # One or more macro arguments preceded by one or more horizontal whitespace
    # characters optionally interspersed by line continuations,
    local pcre_macro_args_spaced_grouped='(?>'${pcre_spaces_horizontal_continuable}${pcre_macro_arg_grouped}')++'

    # Positive lookahead non-consumptively matching the command terminator
    # terminating macros accepting no arguments.
    #
    # zeshy-specific terminators (e.g., :or()) are necessarily preceded by one
    # or more horizontal whitespace characters optionally interspersed by line
    # continuations, while zsh-standard terminators (e.g., "||") are only
    # optionally preceded by such characters.  Since negative lookahead
    # elsewhere prevents unquoted macro scalar arguments from matching such
    # terminators *AND* since preceding PCREs already match such characters
    # preceding such arguments, any such character matching here *MUST* precede
    # such a terminator rather than such an argument. Hence, matching only one 
    # such character here suffices to match the end of a macro terminated by a
    # whitespace-prefixed terminator.
    #
    # Since zsh-standard terminators are *NOT* necessarily preceded by such
    # characters, only matching the entirety of such terminator suffices to
    # match the end of a macro terminated by a terminator *NOT* prefixed by
    # such whitespace.
    local pcre_macro_sans_args_lookahead='(?='${pcre_space_horizontal_continuable}'|'${pcre_terminator_unspaced_body}')'

    # ..................{ COMPLEX COMMAND                    }..................
    # Name of a complex command (e.g., "if", "for", "while") requiring no "{"- 
    # and "}"-delimited block arguments and hence _not_ conflicting with macro
    # syntax. As of this writing, there exists only one such command.
    local pcre_command_complex_blockless_name='time'

    # Blockless complex command suffixed by one or more horizontal whitespace
    # characters optionally interspersed by line continuations.
    local pcre_command_complex_blockless_optional='(?>'${pcre_command_complex_blockless_name}${pcre_continuable_spaces_horizontal}')?+'

    # ..................{ MACRO                              }..................
    # Macro name, grouped for disambiguating non-erroneous macros from
    # erroneous syntactic invalidities. (See below.)
    local pcre_macro_name_grouped='('${ZESHY__MACRO_COMMAND_NAME_PLACEHOLDER}')'

    # Macro body, comprising all arguments passed to such macro as well as
    # line continuations and whitespace cementing the former to the latter. To
    # permit macros to be suffixed by whitespace-prefixed zeshy-specific
    # command terminators (e.g., ":and"), optional whitespace suffixing such
    # body is matched by ${pcre_words_macroable_rest_optional} -- *NOT* here.
    local pcre_macro_body=${pcre_line_continuations_optional}'(?:'${pcre_macro_args_spaced_grouped}'|'${pcre_macro_sans_args_lookahead}')'

    # Macro. To notify the preprocessor iterating on such PCRE of such macro's:
    #
    # * First byte index, the match position is reset immediately before such
    #   match.
    # * Last byte index, success is reported immediately after such match.
    #
    # Syntactic invalidities also leverage such resetting and reporting but
    # fail to capture non-empty substrings into the macro name group. Hence,
    # the two are readily disambiguatable.
    local pcre_macro_grouped_succeed=${pcre_reset}${pcre_macro_name_grouped}${pcre_macro_body}${pcre_succeed}

    # Macro or first shell word of a command permitting matching of macros. To
    # preferentially match the first unquoted such word as a macro rather than
    # command name, the former is matched before the latter.
    local pcre_macro_grouped_or_word_macroable_first='(?:'${pcre_macro_grouped_succeed}'|'${pcre_word_macroable_first}')'

    # Macro or command, permitting matching of macros. Since macros may be
    # suffixed by shell words external to such macros (e.g., redirections),
    # zero or more such words are matched after matching either a macro *OR* a
    # command name.
    local pcre_macro_grouped_or_command_optional='(?:'${pcre_macro_grouped_or_word_macroable_first}${pcre_words_macroable_rest_optional}')?+'

    # Zero or more macros or commands permitting matching of macros.
    local pcre_commands_macroable_optional_grouped='(?:'${pcre_command_complex_blockless_optional}${pcre_macro_grouped_or_command_optional}${pcre_terminators_macroable}')*+'

    # ..................{ SUBROUTINE                         }..................
    # PCRE subroutines defined above, concatenated in a manner preventing
    # such definitions from either implicitly matching *OR* capturing.
    #
    # First, a bit of useful background. As in Perl but not Ruby, "libpcre"
    # subroutine calls (e.g., "(?&soma)") do *NOT* capture the substring
    # matched by such call. As in both Perl and Ruby, subroutine definitions
    # (e.g., "(?<soma>All the advantages of Christianity and alcohol; none of
    # their defects.)" capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is noxious. In
    # most cases, we would prefer such definitions to *NOT* capture.
    #
    # Happily, PCRE explicitly supports such behaviour via "(?(DEFINE)...)",
    # Perl- and PCRE-specific syntax defining all named and numbered capturing
    # groups in its embedded content but otherwise ignoring such content.
    # For further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
    local pcre_subroutines='(?(DEFINE)'${pcre_subroutines_body}')'

    # ..................{ GLOBAL                             }..................
    # PCRE matching unsupported here-documents (i.e., here-documents with
    # non-literal and hence non-PCRE-matchable delimiters).
    ZESHY__MACRO_HERE_DOC_UNSUPPORTED_PCRE=${pcre_here_doc_unsupported}

    # PCRE matching syntactically valid macro names.
    ZESHY__MACRO_NAME_VALID_PCRE=${pcre_macro_name_first}${pcre_macro_name_chars_rest_optional}

    # PCRE to which ${ZESHY__PREPROCESS_PCRE} will be set if at least one macro
    # exists.
    ZESHY__PREPROCESS_PCRE_IF_NONEMPTY=${pcre_options_anchored}${pcre_commands_macroable_optional_grouped}${pcre_subroutines}

    # PCRE to which ${ZESHY__PREPROCESS_PCRE} will be set if no macros exist.
    ZESHY__PREPROCESS_PCRE_IF_EMPTY=${pcre_succeed}

    # ..................{ INDICES                            }..................
    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support constant globals. *sigh*

    # For each match group captured by each PCRE global declared above
    # capturing four or more such groups, declare one human-readable integer
    # global expanding to such group's 1-based index. For robustness, declare
    # such globals iteratively rather than manually.
    local   group_name
    integer group_index

    #FIXME: Document such indices.

    # Declare positive absolute indices matched by ${ZESHY__PREPROCESS_PCRE}.
    group_index=1

    for group_name (
        ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_UNPROTOTYPED_NAME
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPED_NAME
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_ATTRS
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_RETURN_TYPE
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_RETURN_CHANNELS
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_NAMES
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_ARG_LIST
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_ARG_CHANNELS
        ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_BLOCK_LAST
        ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARGS_SCALAR_LAST
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_BRACE_RIGHT_NAME
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_BRACE_RIGHT_ARG_BLOCK_LAST
        # ZESHY__PREPROCESS_GROUP_INDEX_MACRO_BRACE_RIGHT_ARGS_SCALAR_LAST
        ZESHY__PREPROCESS_GROUP_INDEX_WASTELANDS
    ) {
        integer -g ${group_name}=$(( group_index++ ))
        # print -r ${group_name}': '${(P)group_name}
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: We don't particularly care about invalidities in brace expansions.
    #Should we care here? Probably not; the two contexts are functionally
    #equivalent. O.K.; we've confirmed that matching invalidities here
    #substantially complicates disambiguation between invalid process forks and
    #invalid glob qualifiers. Since matching the former is essential and the
    #latter *NOT*, excise ${pcre_reset_remainder_succeed} below and
    #simplify accordingly.

    # "("- and ")"-delimited glob qualifier prefix.
    # local pcre_qualifier_prefix='\('
    # local pcre_qualifier_head=${pcre_qualifier_prefix}'(?>(?>'

    # "("- and ")"-delimited glob qualifier suffix.
    # local pcre_qualifier_suffix='\)'
    # local pcre_qualifier_foot=')*+'${pcre_qualifier_suffix}'|'${pcre_reset_remainder_succeed}')'

    # "("- and "))"-delimited arithmetic construct. While there exists no exact
    # such construct, such PCREs are helpful below.
    # local pcre_math_sans_paren_left_prefix='\('
    # local pcre_math_sans_paren_left=${pcre_math_sans_paren_left_prefix}${pcre_math_sans_prefix}

#, excluding the first such
    # "(" and prefixing character if any (e.g., "$(")

#     local pcre_math_sans_paren_left_suffix_char='\)'
#     local pcre_math_sans_paren_left_suffix=${pcre_math_sans_paren_left_suffix_char}${pcre_math_sans_paren_left_suffix_char}
# '(?!'${pcre_math_sans_paren_left_suffix_char}')'
    # List assignment prefix, excluding prefixing variable name.
    # local pcre_list_assignment_prefix=':=\('

    # List assignment suffix.
    # local pcre_list_assignment_suffix='\)'

#FUXME: We currently employ positive lookahead to simplify identification of
#the syntactic prefix prefixing syntactically invalid constructs. For
#efficiency, refactoring such lookahead into backtracking to the first
#character following such prefix supplies an ideal alternative: e.g.,
#
#    local pcre_quotes_single="'(?:(?>[^']++|'')*+'"'|\K.*+)'

    # local pcre_block='(?='${pcre_brace_left}')(?:.(?&blk)'${pcre_brace_right}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_paren_left_interpretable='(?='${pcre_paren_left_interpretable_prefix}')(?:.(?:'${pcre_math_test_sans_paren_left}'|'${pcre_process_fork_sans_paren_left}')|'${pcre_reset_remainder_succeed}')'
    # local pcre_dollar_head='(?=\$)(?:.(?:'${pcre_var_sans_dollar}'|'
    # local pcre_dollar_foot=')|'${pcre_reset_remainder_succeed}')'
    # local pcre_math_test='(?='${pcre_math_sans_paren_left_prefix}')(?:.'${pcre_math_test_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_process_substitution_redirection='(?='${pcre_process_substitution_redirection_prefix}')(?:.'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_process_substitution_equals='(?='${pcre_process_substitution_equals_prefix}')(?:.'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_process_fork='(?='${pcre_process_fork_prefix}'(?:.'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_process_substitution_backtick='(?='${pcre_process_substitution_backtick_delimiter}')(?:.'${pcre_commands_backtickable_optional}${pcre_process_substitution_backtick_delimiter}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_list_assignment_sans_var_name='(?='${pcre_list_assignment_prefix}')(?:..'${pcre_list_assignment_body}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_qualifier_head='(?='${pcre_qualifier_prefix}')(?:.(?:'
    # local pcre_qualifier_foot=')*+'${pcre_qualifier_suffix}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_here='(?='${pcre_here_prefix}')(?:.(?:'${pcre_here_prefix}'|(?&doc))|'${pcre_reset_remainder_succeed}')'
    # local pcre_quotes='(?=['${pcre_quotes_single_delimiter}${pcre_quotes_double_delimiter}'])(?:'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_char_escaped='(?='${pcre_char_escaped_prefix}')(?:..|'${pcre_reset_remainder_succeed}')'

    # ..................{ NANOWORD ~ sourceable              }..................
    #FUXME: Excise by inlining at their point of expansion.

    # Syntactic component at the start of the first shell word of a command.
    # local pcre_nanoword_sourceable_start_word_first=${pcre_literal_sourceable_start_word_first}'|'${pcre_picoword_sourceable_start_word_first}

    # Syntactic component at the start of any shell word following the first of
    # a command.
    # local pcre_nanoword_sourceable_start_word_rest=${pcre_literal_sourceable_start_word_rest}'|'${pcre_picoword_sourceable_start_word_rest}

    # Syntactic component *AFTER* the start of any shell word of a command.
    # local pcre_nanoword_sourceable_rest=${pcre_literals_sourceable_rest}'|'${pcre_picoword_sourceable_rest}

    #FUXME: For use below, define a new suite of ${pcre_picoword_unforkable_*}
    #PCREs: e.g.,
    #
    #local pcre_picoword_unforkable_start_word_first=${pcre_picoword_sourceable_start_word_first}'|'${pcre_unforkable_subword_start_word_first}

    #FUXME: Incorrect. While similar to macroable nanowords, blockable
    #nanowords *MUST* prevent "}" block suffixes from matching by suffixing the
    #corresponding ${pcre_literal_blockable_*} PCREs by
    #${pcre_literal_blockable_lookbehind}. Problematically, of course, such
    #PCREs do *NOT* exist. Consequently, we'll need to employ a bit of work
    #both here and above.

    # Brace expansion prefix.
    # local pcre_brace_expansion_prefix='\{'

    # Brace expansion suffix.
    # local pcre_brace_expansion_suffix='\}'
    # local pcre_brace_expansion_suffix_optional=${pcre_brace_expansion_suffix}'?+'

    #FUXME: Ehrm; ${pcre_brace_expansion_or_brace_left_start_word_rest} has yet
    #to be defined here. Amend us, please.

#*NOT* signifying a brace expansion suffix.
    #FUXME: O.K.; so, because of "{"- and "}"-delimited brace expansions,
    #${pcre_literal_blockable_lookbehind} is currently applied in a fundamentally
    #erroneous manner. Thankfully, this is amendable as follows:
    #
    #* Rename ${pcre_literal_blockable_lookbehind} to
    #  ${pcre_literal_blockable_lookbehind}.
    #* Shift every embedding of ${pcre_literal_blockable_lookbehind} to suffix a
    #  ${pcre_literal_*} PCRE rather than a ${pcre_word_*} PCRE.

#  as follows:
#
#* Modify the definition of ${pcre_words_macroable_*} and all PCREs such PCRE
#  transitively embeds to 
#* Duplicate the definition
    # Character class matching single-character command terminators excluding
    # vertical whitespace characters. 
    # local char_terminator_macroable=${char_terminator_sans_space_vertical}

    # * "}", suffixing blocks preceding right-brace macros at the top level
    #   (e.g., the first "}" in ":if true; { :noop } :else { :noop }").

# To permit balanced matching of block delimiters, "{" is excluded. (
    #   at signifying a command terminator at the top level but prefixing . 

    #FUXME: ={backend} should then be improved to:
    #
    #* If such group contains a string of length greater than 1, indicating a
    #  "WASTELANDS"-formatted comment block, removing such block from such
    #  code: e.g.,
    #
    #    if (( ${match[${ZESHY__MACRO_GROUP_INDEX_WASTELANDS}]-} > 1 )) {
    #        ZESHY__CODE[-${#match[
    #            ${ZESHY__MACRO_GROUP_INDEX_WASTELANDS}]},-1]=
    #    }
    #
    #Simple, and should dramatically improve preprocessing speed on the
    #official zeshy codebase.

    #FUXME: ={backend} should then be improved to:
    #
    #* If such group contains a string of length greater than 1, indicating a
    #  "WASTELANDS"-formatted comment block, removing such block from such
    #  code: e.g.,
    #
    #    if (( ${match[${ZESHY__MACRO_GROUP_INDEX_WASTELANDS}]-} > 1 )) {
    #        ZESHY__CODE[-${#match[
    #            ${ZESHY__MACRO_GROUP_INDEX_WASTELANDS}]},-1]=
    #    }
    #
    #Simple, and should dramatically improve preprocessing speed on the
    #official zeshy codebase.

    # "#"-prefixed zeshy-specific "WASTELANDS" comment, capturing the remainder
    # of the subject string into the last capture group and reporting success
    # from the current match attempt. This is an optional optimization intended
    # principally for use on the official zeshy codebase.

    #FUXME: Actually, we can also match macros in process substitutions
    #embedded in double quotes. Doing so, however, will require a smidgeon of
    #refactoring elsewhere and hence is probably warranted only after
    #finishing a reasonable first-draft implementation. The idea is simple:
    #since matching such macros requires "remembering" that such macro was
    #embedded in double quotes, that's actually what we do. Specifically:
    #
    #* Create a new PCRE
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped},
    #  retaining the existing ${pcre_quotes_double} for use in all other
    #  syntactic contexts.
    #* ${pcre_quotes_double_sans_process_substitution_prefix_grouped} should be
    #  identical to ${pcre_quotes_double} except that the former should
    #  explicitly avoid matching any syntactic prefix of a process substitution
    #  (e.g., "=(") embedded in such quotes, probably via negative lookahead.
    #  (Uhm; no. Just avoid matching such prefix with a positive construction
    #  resembling the PCRE "([^$]++|\$[^(]*+)*+". That will efficiently do it.)
    #  Such prefix will then be subsequently matched as a command terminator by
    #  ${pcre_macro} as desired. (Hmm; are "=("-prefixed substitutions even
    #  parsed in double-quoted strings? We strongly doubt it; but test. Right.
    #  So, no: the only process substitutions parsed in double-quoted strings
    #  are "$("-prefixed process substitutions, simplifying matters somewhat.)
    #* As the variable name implies,
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped} *MUST*
    #  capture a nonempty substring of such double quotes -- say, the prefixing
    #  '"'. Such group permits the preprocessor to reliably detect when a
    #  macro-interrupted double quotes has been matched. Note that, to do so,
    #  ${pcre_quotes_double_sans_process_substitution_prefix_grouped} *CANNOT*
    #  by definition be matched within a subroutine call, confining such
    #  matching to only non-recursive (i.e., top-level) macro usage -- which,
    #  again, simplifies matters.
    #* Rename the existing PCRE globals ${ZESHY__PREPROCESS_PCRE_PREFUX},
    #  ${ZESHY__PREPROCESS_PCRE_SUFFUX}, and ${ZESHY__PREPROCESS_PCRE} to
    #  ${ZESHY__MACRO_UNQUOTED_PCRE_PREFUX},
    #  ${ZESHY__MACRO_UNQUOTED_PCRE_SUFFUX}, and ${ZESHY__MACRO_UNQUOTED_PCRE}.
    #  The preprocessor should use the latter global by default when performing
    #  PCRE-based iteration.
    #* Create new PCRE globals ${ZESHY__MACRO_QUOTED_PCRE_PREFUX},
    #  ${ZESHY__MACRO_QUOTED_PCRE_SUFFUX}, and ${ZESHY__MACRO_QUOTED_PCRE}. The
    #  preprocessor should use the latter global only when performing
    #  PCRE-based iteration *AFTER* having just matched a macro embedded in a
    #  process substitution embedded in double quotes.
    #
    #And... that's it. Clearly feasible, if a fair amount of work. In any case,
    #such improvements are doubtless fodder for another code day.
    #FUXME: All of the above applies to "`"-delimited process substitutions as
    #well, which we currently fail to match and expand macros in.
    #FUXME: Wait. There's clearly a combinatorial explosion issue here: we'd
    #also like to match macros embedded in "$("- and ")"-delimited process
    #substitutions embedded in syntactic constructs (e.g., "${"- and
    #"}"-delimited recursive variable expansions). While matching such "$(" as
    #a command terminator *SHOULD* be feasible with named capture groups and/or
    #negative lookahead, there's obviously no way that we could restore
    #matching arbitrarily nested constructs in a balanced manner.
    #
    #Given that, we clearly won't be able to match macros in all possible
    #contexts. In that case, we'd might as well abandon any thought of matching
    #macros in "`"-delimited process substitutions: while we *COULD* do that,
    #such substitutions are obsolete anyway. There's little gain to supporting
    #them, given that we won't be supporting a variety of constructs anyway.
    #
    #That said, we *SHOULD* still attempt to match macros in process
    #substitutions in double quotes, as that is the certainly the most common
    #lexical context in which process substitutions are used. Fortunately,
    #we've roadmapped that process (meagre pun intended) above.
    #FUXME: Oh, wait. I neglected to recall that we *ALREADY* match macros
    #embedded in arbitrarily nested process substitutions: namely, by simply
    #ignoring parens balancing. Which works perfectly serviceably. Given that,
    #we *SHOULD* match macros nested in all single character-prefixed
    #constructs (e.g., double-quoted strings, "`"-delimited substitutions).
    #FUXME: Actually, we strongly suspect that the above method is technically
    #infeasible even for matching macros in "$("-prefixed process substitutions
    #in double-quoted strings at the top-level. Why? Because capturing. The
    #match group to which the the previous PCRE "iteration" captured the '"'
    #character will be reset to the empty string on the current PCRE iteration
    #matching such macro, implying such condition to be undetectable.
    #
    #In other words, macros *MUST* be prohibited from all "$("-prefixed process
    #substitutions in double-quoted strings. This constraint is
    #incontrovertible and should be documented above along with:
    #
    #* The inability to match macros in "`"-delimited process substitutions in
    #  double-quoted strings.
    #* The current inability to match macros immediately following the "`"
    #  prefixing such process substitutions.

    # Comment prefix.
    # local char_comment_prefix='#'

    #FUXME: Not quite right, due to recent refactoring. To match commands
    #resembling ":some_macro :and print ok", we avoid consuming whitespace
    #suffixing macros here and hence *MUST* match such whitespace with positive
    #lookahead here instead; however, ${pcre_macro_unspaced_lookahead}
    #currently only matches unspaced terminators (e.g., "||") with such
    #lookahead -- probably requiring:
    #
    #* Renaming ${pcre_macro_unspaced_lookahead} to
    #  ${pcre_macro_sans_args_lookahead}.
    #* Generalizing ${pcre_macro_sans_args_lookahead} to match both unspaced
    #  terminators *AND* ${pcre_space_horizontal_continuable}.

    # The latter condition implies such macro to be terminated by a zsh-
    # specific command terminator. Since zeshy-specific command terminators
    # (e.g., :or()) *MUST* be preceded by such whitespace, only zsh-specific
    # command terminators are valid here. Such terminator will be subsequently
    # consumed by the PCRE embedding this PCRE and hence *MUST* be matched by
    # positive lookahead rather than consumed here.
    # Positive lookahead matching the end of a macro both accepting no
    # arguments *AND* suffixed by no horizontal whitespace characters.
    #
    # The latter condition implies such macro to be terminated by a zsh-
    # specific command terminator. Since zeshy-specific command terminators
    # (e.g., :or()) *MUST* be preceded by such whitespace, only zsh-specific
    # command terminators are valid here. Such terminator will be subsequently
    # consumed by the PCRE embedding this PCRE and hence *MUST* be matched by
    # positive lookahead rather than consumed here.
    # local pcre_macro_unspaced_lookahead='(?='${pcre_terminator_unspaced_body}')'

    # local pcre_spaces_horizontal_continuable_grouped='('${pcre_spaces_horizontal_continuable}')'
    # Zero or more macro arguments, preceded by one or more horizontal
    # whitespace characters optionally interspersed by line continuations,
    # local pcre_macro_args_optional_spaced_grouped=${pcre_spaces_horizontal_continuable}${pcre_macro_arg_grouped}'*+'

    # local pcre_macro_arg_optional_grouped=${pcre_macro_arg_grouped}'?+'
    #
    # # One or more macro arguments.
    # local pcre_macro_args_grouped=${pcre_macro_arg_grouped}'(?>'${pcre_spaces_horizontal_continuable}${pcre_macro_arg_optional_grouped}')*+'
    #
    # # One or more horizontal whitespace characters optionally interspersed by
    # # line continuations, followed by zero or more macro arguments.
    # local pcre_macro_args_optional_spaced_grouped=${pcre_spaces_horizontal_continuable}'(?:'${pcre_macro_args_grouped}')?+'

    # Macro argument optionally suffixed by line continuations, comprising both
    # scalar and arguments and zeshy-specific block arguments. For efficiency,
    # block arguments are captured and optionally followed by zero or more
    # scalar arguments, also captured. 

# Note that such capturing is required for
    # iterative matching of macro block arguments but otherwise ignorable for
    # iterative matching of macros.
#, each captured to a group for argument iteration.
    # local pcre_block_grouped_and_words_passable_optional_grouped=${pcre_block_grouped}${pcre_words_passable_spaced_optional_grouped}
    # Blockless complex command name (i.e., the 
#FUXME: There technically exist a few other locations at which macros should be
#matchable and expandable: namely, as the shell word immediately following a
#builtin conditional (e.g., "if", "elif") or iterator (e.g., "while", "until")
#or the "time" builtin. zsh documentation refers to such contexts in its "info"
#documentation as "Complex Commands." See such documentation.
#
#Since zeshy style *ALWAYS* employs "{"- and "}"-delimited conditional style in
#such contexts, the current PCRE structure already suffices for all official
#zeshy uses. While matching macros immediately following the command names
#"if", "time", "until", and "while" is trivial, doing so following "elif"
#intuitively seems non-trivial. Contemplate.

# PCRE matching the next block argument in a macro-specific argument list,
# explicitly designed such that:
#
# * ${ZPCRE_OP[(w)1]} expands to the byte index of the block's first character.
# * ${ZPCRE_OP[(w)2]} expands to the byte index of the block's last character.
# typeset -g ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE

    # PCRE matching the next block argument in a macro-specific argument list.
    # To support identification of such block's first byte index, the mandatory
    # horizontal whitespace and optional scalar arguments preceding such block
    # are captured to a group. Adding the string length of such group to the
    # current match position's byte index yields such block's first byte index.
    #
    # While embedding ${pcre_reset} before ${pcre_block} would yield the same
    # result, doing so would complicate edge-case detection of syntactic
    # invalidities also ebedding ${pcre_reset}. For disambiguity, the current
    # approach is strongly preferable.
    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE=${pcre_options_anchored}${pcre_words_passable_optional_spaced_grouped}${pcre_block}${pcre_subroutines}

    #FUXME: Not quite. We need to match optional line continuations suffixing
    #blocks, even if such blocks are *NOT* suffixed by scalar arguments. Hence,
    # permit reuse of a single precompiled ${ZESHY__PREPROCESS_PCRE} for  

    # Block macro argument optionally suffixed by line continuations. Since
    # ${pcre_word_passable} implicitly matches such continuations,
    # ${pcre_macro_args_optional} matches ${pcre_spaces_horizontal_continuable}
    # rather than ${pcre_continuable_spaces_horizontal} for efficiency. Since
    # ${pcre_block} does *NOT* implicitly match trailing line continuations,
    # however, such continuations are explicitly matched here.
    # local pcre_word_blockable_grouped='('${pcre_block}${pcre_line_continuations_optional}')'

    # Zero or more syntactic components *AFTER* the start of a scalar macro
    # argument.
    # local pcre_nanowords_passable_rest_optional='(?:'${pcre_nanoword_passable_rest}'|'${pcre_qualifier_passable}')*+'

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations followed by zero or more macro arguments, each
    # suffixed by such whitespace. Since block arguments are necessarily
    # prefixed by such whitespace, the latter constraint ensures proper
    # matching of the following such argument if any.
    # local pcre_words_passable_optional_spaced=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable}${pcre_spaces_horizontal_continuable}')*+'
    # local pcre_words_passable_optional_spaced_grouped='('${pcre_words_passable_optional_spaced}')'

#FUXME: Ugh; we just uncovered a minor flaw: "{"- and "}"-delimited brace
#expansion requires we explicitly parse such expansions to avoid matching
#either such delimiter as a block delimiter. Grep "brace_ccl" in +{src/.main}
#for the specific syntactic forms accepted by such expansions. We can probably
#get away with something resembling:
#
#    # Since zsh explicitly does *NOT* support UTF-8-encoded characters in such
#    # expansions, this is both the most correct and efficient means of
#    # matching such expansions.
#    local pcre_brace_expansion='\{[a-bA-B0-9.,^!-]\}'
#
#    # Hmm; actually, this is probably better. For both forwards compatibility
#    # and simplicity, let's just ignore the UTF-8 issue for now. This is
#    # almost certainly the best way to match such expansions.
#    local pcre_brace_expansion='\{[^}'${char_space}']\}'
#FUXME: However, this uncovers another minor flow: "{" is only a block prefix
#when such character is either:
#
#* The only character of a word: e.g.,
#    >>> print { ok }
#    zsh: parse error near `}'
#* The first character of the first word of a command: e.g.,
#    >>> print {ok}
#    {ok}
#
#The latter example isn't what we expected, though it makes sense in syntactic
#hindsight. Correct for this, please.
    #FUXME: We appear to repeat the expressions
    #"${pcre_picoword_sourceable_start_word_first}'|'${pcre_sourceable_nanoword_start_word_first}" and so forth quite a bit below. Is
    #${pcre_sourceable_nanoword_start_word_first} *ALWAYS* prefixed by
    #${pcre_picoword_sourceable_start_word_first}'|'? If so, explicitly embed
    #the latter into the former and excise all other embeddings of the latter.

    # Smallest syntactic component in a general-purpose context.
    # local pcre_picoword=${pcre_picoword_passable}'|'${pcre_redirect}

    # Syntactic component embedded in a brace expansion at the start of any
    # shell word *AFTER* the first of a command. Since a "{" character at the
    # start of the first shell word of a command is *ALWAYS* a block prefix,
    # this applies only to subsequent words.
    # Since "{"
    # characters s are also allowed at arbitrary 
    # local pcre_nanoword_braceable_start_word_rest=${pcre_literals_braceable_optional}'|'${pcre_picoword_braceable}'|'${pcre_sourceable_nanoword_rest}

    #FUXME: The following PCREs are only ever embedded once into the suite of
    #corresponding ${pcre_nanoword_macroable_*} PCREs. This is silly. Just
    #embed their contents directly into such PCREs and excise these.

    # Smaller syntactic component *AFTER* the start of any shell word of a
    # command in a block.
    # local pcre_nanoword_blockable_rest=${pcre_literals_sourceable_rest}'|'${pcre_picoword}'|'${pcre_unforkable_subword_rest}

    #   * "{", a block prefix only when the first character of such words.

    # this PCRE ignores such
    # structure in matching the contents of such expansions.
    # the former are  comparatively rarer than the latter, ASCII whitespace
    # local pcre_words_macroable_optional='(?:'${pcre_word_macroable_first}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_macroable_rest_optional}')*+)?+'
#  Since such calls isolate groups
    # captured by such calls to such calls, such grouped block suffix is
    # matched outside rather than inside such call.

    #FUXME: O.K.; so, we use the reset mechanism to identify both syntactic
    #invalidities *AND* successfully matched macros, slightly complicating
    #disambiguation between the two in the preprocessor.

    # PCRE capturing the next block argument in a macro-specific argument list,
    # prefixed by one or more horizontal whitespace characters followed by zero
    # or more shell words.
    # PCRE implicitly capturing the next block argument in a macro-specific
    # argument list by confining the resulting matched substring to such argument. the current position in the subject string, ensuring
    # ${ZPCRE_OP[(w)1]} will expand to such position's byte index. This PCRE
    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE=${pcre_options_anchored}${pcre_words_passable_optional_spaced_grouped}${pcre_reset}${pcre_macro_arg_block}${pcre_subroutines}

    # PCRE fragment prefixing ${ZESHY__PREPROCESS_PCRE}, matching zero or more macros
    # *OR* syntactic constructs possibly containing macro-like substrings.
    # ZESHY__PREPROCESS_PCRE_IF_NONEMPTY_PREFIX=${pcre_options_anchored}'(?:'${pcre_macro_prefix}'(?:'${pcre_comment}'|'

    #FUXME: Use of ${pcre_report_failure} is inappropriate here, as it prevents
    #distinguishing syntactically valid from invalid scripts. To do so, we'll
    #need to supplant ${pcre_report_failure} by something resembling:
    #
    #    ${pcre_spaces_horizontal_continuable_optional}(<=(.))${pcre_subject_end}
    #
    #This ensures that *ONLY* syntactically invalid matches report failure,
    #which is great. Since valid macro matches are easily distinguished by the
    #appropriate match groups, we have the following three cases:
    #
    #* ${ZESHY__PREPROCESS_PCRE} reports failure, in which case such code is invalid.
    #  An exception should be thrown.
    #* ${ZESHY__PREPROCESS_PCRE} reports success, in which case:
    #  * If the macro-specific match group(s) are non-empty, a valid macro was
    #    matched.
    #  * Else, the end of such code was matched. The while loop iterating such
    #    PCRE should be terminated.

    # PCRE fragment suffixing ${ZESHY__PREPROCESS_PCRE}.
    # ZESHY__PREPROCESS_PCRE_IF_NONEMPTY_SUFFIX=${pcre_macro_body_succeed}')?|'${pcre_spaces_horizontal}'(?:'${pcre_comment}')?|'${pcre_code_sans_comment}'|.)*'${pcre_report_failure}${pcre_subroutines}

    #FUXME: We do *NOT* need to match "`"-delimited process substitutions at
    #top-level contexts (e.g., macros, macro arguments, interpretables). We
    #only need to much such substitutions when embedded in other constructs
    #(e.g., double-quoted strings) for purposes of properly matching such
    #constructs. This could be a worthwhile optimization -- though probably not
    #at this general context here. Where would we situate that, exactly?
    #
    #Wait. No, my intuition was correct: such optimization should be situated
    #exactly here. "`"-delimited process substitutions *MUST* be matched in
    #embeddables, as the following examples demonstrate:
    #
    #* '"`""`"', a double-quoted string embedding such a substitution embedding
    #  such a string.
    #* "${:-`{}`}", a variable expansion embedding such a substitution
    #  embedding an empty block.
    #
    #The first example suggests that matching "`"-delimited process
    #substitutions in embeddables to be necessitated by the delimitation of
    #such embeddables by single characters rather than pairs of "balanced"
    #characters. The second example, however, demonstrates even embeddables
    #delimited by balanced characters to require such matching. However, there
    #exists no syntactically valid example necessitating matching such
    #substitutions in interpretables. The question, then, is why.
    #
    #The answer appears to be that, since such substitutions are
    #interpretables, both the outer and inner syntactic contexts in the case of
    #an interpretable embedding such a substitution follow the same syntactic
    #constraints, whereas the outer and inner syntactic contexts in the case of
    #an embeddable embedding such a substitution follow dissimilar syntactic
    #constraints. In the former case, since such substitutions comply with the
    #syntax of the interpretables embedding such substitutions without
    #disrupting the balancing of the characters delimiting such interpretables,
    #the characters delimiting such substitutions may be ignored.
    #
    #Hence, perform the following:
    #
    #* Excise ${pcre_process_substitution_backtick} here but *NOT* above.
    #* Rename ${char_not_literal_sourceable_rest} and cohorts to
    #  ${char_not_literal_sourceable_rest}.
    #* Rename ${char_not_literal_backtickable_rest} and cohorts to
    #  ${char_not_literal_backtickable_rest}.
    #* Rename ${char_not_literal_parenable_rest} and cohorts in terms of
    #  ${char_not_literal_sourceable_rest}.
    #* Embed ${char_not_literal_sourceable_*} in all interpretable
    #  contexts, excluding passables and backtickables.
    #* Embed ${char_not_literal_backtickable_*} in only passables and
    #  backtickables.
    #* Document such subtleties above.
    #
    #A fair amount of work, but commendably worth it.
    #FUXME: O.K.; we've now done *MOST* of this, with exception of excising
    #${pcre_process_substitution_backtick} below. While we certainly should do
    #so, this will necessitate matching *BOTH* sourceables *AND* embeddables
    #(to match "`"-delimited process substitutions) in passables. The simplest
    #means of eff

    #FUXME: Terrible idea. The negligible efficiency gains are *NOT* worth
    #redefining such constructs here. Since we've already defined
    #${pcre_passable_nanoword_*} PCREs above, excise such PCREs here and, after
    #doing so, shift this subsection up to where all similar PCREs are defined.

    # Syntactic construct at the start of a macro argument. As detailed below,
    # redirections are prohibited in such arguments. Since arithmetic tests are
    # commands and hence *NOT* arguments, both are omitted here.
    # local pcre_passable_nanoword_start=${pcre_dollar_interpretable}'|'${pcre_process_substitution_equals}'|'${pcre_process_substitution_backtick}

    # Syntactic construct *AFTER* the start of a macro argument.
    # local pcre_passable_nanoword_rest=${pcre_dollar_interpretable}'|'${pcre_process_substitution_backtick}

    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the start of a scalar macro argument. To match "`"-delimited
    # process substitutions at such positions, this includes "`".
    # local char_passable_nanoword_rest=${char_sourceable_nanoword_rest}'`'

    # ..................{ CLASS ~ backtickable               }..................
    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the start of any shell word of a command embedded in a "`"-
    # delimited process substitution.
    # local char_backtickable_subword_rest=${char_sourceable_nanoword_rest}'`'

    # Character class matching sourceable-reserved characters at the start of
    # any shell word *AFTER* the first of a command embedded in a "`"-delimited
    # process substitution.
    # local char_backtickable_subword_start=${char_sourceable_nanoword_rest}'='

    # Character class matching sourceable-reserved characters at the start of
    # the first shell word of a command embedded in a "`"-delimited process
    # substitution.
    # local char_backtickable_subword_start_word_first='('${char_sourceable_nanoword_start}

    # Negative lookahead preventing a subsequent subroutine call from matching 
    # a "`"-delimited process substitution. While there technically exist more
    # efficient means of enforcing such constraint than via negative lookahead,
    # the obsoletion of such substitutions (and hence "`" delimiters) by "$("- 
    # and ")"-delimited process substitutions implies efficiency to *NOT* be a
    # concern. Subsequent PCREs thus opt for simplicity -- and this is the
    # simplest approach.
    # local pcre_backtickable_lookahead='(?!`)'

    # Smaller syntactic component at the start of the first shell word of a
    # command, permitting matching of "`"-delimited process substitutions.
    # local pcre_nanoword_backtickable_start_word_first=${pcre_nanoword_sourceable_start_word_first}'|'${pcre_backtickable_lookahead}${pcre_sourceable_word_first_start}

    # Smaller syntactic component at the start of any shell word *AFTER* the
    # first of a command, permitting matching of "`"-delimited process
    # substitutions.
    # local pcre_nanoword_backtickable_start_word_rest=${pcre_nanoword_sourceable_start_word_rest}'|'${pcre_backtickable_lookahead}${pcre_sourceable_word_first_rest}

    # Smaller syntactic component *AFTER* the start of any shell word of a
    # command, permitting matching of "`"-delimited process substitutions.
    # local pcre_nanoword_backtickable_rest=${pcre_nanoword_sourceable_rest}'|'${pcre_backtickable_lookahead}${pcre_sourceable_word_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command, permitting matching of "`"-delimited process substitutions.
    # local pcre_nanowords_backtickable_rest_optional='(?:'${pcre_nanoword_backtickable_rest}')*+'

    #FUXME: Most embeddings of the following classes should be supplanted by
    #the corresponding ${char_not_literal_sourceable_*} class instead.

    # ..................{ UNQUOTED : unforkable              }..................
    #FUXME: Probably obsoleted by the above suite of ${pcre_char_unquoted_*}
    #PCREs. Verify and excise all following PCREs if the case. Ah; not quite;
    #the following two PCREs are prefixed by
    #${pcre_literal_sourceable_lookahead}, which appears to *NOT* exist.
    #Since unforkable contexts probably do omit certain syntactic constructs
    #and hence prefixes matched in general sourceable contexts, we probably
    #need to define such lookahead accordingly. Copy the structure of
    #${pcre_literal_passable_lookahead} for this purpose.

    # Unquoted shell word character at the start of the first such word of an
    # unforkable command.
    # local pcre_literal_sourceable_start_word_first=${pcre_literal_sourceable_lookahead}'['${char_not_literal_sourceable_start_word_first}']'

    # Unquoted shell word character at the start of any such word following the
    # first of an unforkable command.
    # local pcre_literal_sourceable_start_word_rest=${pcre_literal_sourceable_lookahead}'['${char_not_literal_sourceable_start_word_rest}']'

    # One or more unquoted shell word characters *AFTER* the start of any such
    # word of an unforkable command.
    # local pcre_literals_sourceable_rest='[^'${char_not_literal_sourceable_rest}']++'

    #FUXME: Excellent! We believe we've found our replacement for
    #"interpretable": "top-level"! Or, rather, some synonym thereof suffixed by
    #"able". (You know how it is.) Consider:
    #
    #* "infixable".
    #* "uprootable".
    #* "sourceable".
    #* "insertable".
    #* "injectable".
    #* "unembedded".
    #* "conceivable".
    #* "implantable".

    # character *AFTER* the start of a scalar macro argument. Unlike general-
    # purpose sourceable-reserved characters, the "`" delimiting "`"-
    # delimited process substitutions *MUST* be explicitly matched for proper
    # argument matching and hence is included rather than excluded here (i.e.,
    # by use of ${char_embeddable_prefix}).
    # local char_passable_nanoword_rest=${char_embeddable_prefix}${char_sourceable_nanoword_rest_sans_embeddable}

    # Character class matching invalid characters *AFTER* the start of unquoted
    # "unforkable" shell words (i.e., unquoted shell words in a context
    # ignoring process forks and substitutions, such as at top-level macro
    # matching), comprising most zsh-reserved operators conflicting with
    # preprocessing and hence unconditionally syntactically significant
    # ASCII punctuation (typically terminating the prior command). This class
    # intentionally omits:
    #
    # * zsh-reserved operators *NOT* conflicting with preprocessing (e.g.,
    #   "*", "!", "^", "?").
    # * zsh-reserved characters conditionally dependent on position in unquoted
    #   shell words, including:
    #   * "{", a block prefix only when the first character of such words.
    #   * "}", a block suffix only when the last character of such words.
    #   * "#", a comment prefix only when the first character of such words. In
    #     all other lexical contexts, "#" acts as a glob operator.
    # * Process fork and/or substitution-specific delimiters *NOT* requiring
    #   strict balancing. Since most such delimiters require such balancing,
    #   this includes only:
    #   * "`", delimiting "`"-delimited process substitutions.
    #
    # Excluding "`" here implies that macros embedded in "`"-delimited process
    # substitutions immediately following such prefixing "`" will *NOT* be
    # preprocessed as macros; all other macros in such substitutions will be
    # preprocessed as macros, however. Since such substitutions have been
    # officially deprecated by "$("- and ")"-prefixed process substitutions
    # *AND* since the current aapproach significantly improves the simplicity
    # and efficiency of the resulting PCREs, we adopt the current approach.
    # local char_not_literal_sourceable_rest=${char_space}'''"$&;<>|\\'

    # Character class matching sourceable-reserved characters at any
    # character following the first of any shell word of a command. This
    # includes  the entirety of the prior class as well as:
    #
    # * "<", prefixing "<("- and ")"-delimited process substitutions.
    # * ">", prefixing ">("- and ")"-delimited process substitutions.
    # local char_sourceable_nanoword_rest=${char_embeddable_prefix}'<>'

    # there must exist a broader disparity 
    # there exists no comparable example demonstrating such substitutions in ,
    # however, a broader d.
    #
    # Since there exists no comparable example demonstrating such substitutions
    # in interpretables (e.g., "$("- and ")"-delimited process substitutions),
    # The question, then, is why.

    #FUXME: We do *NOT* need to match "`"-delimited process substitutions at
    #top-level contexts (e.g., macros, macro arguments, interpretables). We
    #only need to much such substitutions when embedded in other constructs
    #(e.g., double-quoted strings) for purposes of properly matching such
    #constructs. This could be a worthwhile optimization -- though probably not
    #at this general context here. Where would we situate that, exactly?

    #FUXME: Not quite. Rather than matching ${pcre_words_macroable_optional}
    #here (which we probably now want to excise), we want to match:
    #
    #* *EITHER*:
    #  * A macro *OR*
    #  * A first macroable shell word.
    #* Followed by zero or more horizontal whitespace-prefixed macroable shell
    #  words.
    #* Followed by one or more *MACROABLE* command terminators.
    #
    #It's not about efficiency, in this case. Neither approach is more or less
    #efficient than the other. It's about syntactic correctness.

    # local pcre_macro_optional_grouped_succeed='(?:'${pcre_macro_grouped}')?+'
    # Zero or more shell words permitting matching of macros, each delimited by
    # one or more horizontal whitespace characters optionally interspersed by
    # line continuations.
    # local pcre_words_macroable_optional='(?:'${pcre_word_macroable_first}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_macroable_rest_optional}')*+)?+'
    # local pcre_macros_succeed_or_commands_optional='(?:'${pcre_macro_optional_grouped_succeed}${pcre_words_macroable_optional}${pcre_terminators_macroable}')*+'

    #FUXME: We do *NOT* need to match "`"-delimited process substitutions at
    #top-level contexts (e.g., macros, macro arguments, interpretables). We
    #only need to much such substitutions when embedded in other constructs
    #(e.g., double-quoted strings) for purposes of properly matching such
    #constructs. This could be a worthwhile optimization -- though probably not
    #at this general context here. Where would we situate that, exactly?

    # Since "{" is a command terminator while "}" is not,
    # ${pcre_terminators} matches the former while
    # ${pcre_words_macroable_optional} the latter.

    #FUXME: Document why we do *NOT* handle syntactic errors here.
    #FUXME: Actually, we *DO* want to handle syntactic errors. Doing so is
    #trivial and orthogonally complies with PCRE style elsewhere. Simply append
    #the internal list of alternatives by
    #"'|'${pcre_reset_remainder_succeed}", after prefixing the lot by...
    #
    #Oh. *RIGHT*. No; indeed, we do *NOT* handle syntactic errors here, for the
    #simple reason that doing so prevents us from distinguishing between a
    #syntactically valid non-literal string *AND* a syntactically invalid
    #literal string (i.e., a literal string with no suffixing delimiter). Of
    #course, there's no sensible means of doing so anyway, but at least the
    #current approach permits us to detect the root cause of the issue as a
    #here-document delimiter, which is somewhat more informative. Document.

#There exist several reasons for this. 
    #FUXME: Hmm. It might be that *ALL* instances of
    #"'|'${pcre_reset_remainder_succeed}" should be extracted out from
    #wihin each syntactic construct PCRE to the end of the alternatives list at
    #which such syntactic construct PCRE is embedded. This should dramatically
    #reduce the length of the final PCRE, as well as improve efficiency.
    #Indeed, such an approach should permit us to avoid such lookahead.
    #
    #For example, refactor this to read:
    #
    #    local pcre_quotes_single=${pcre_quotes_single_delimiter}${pcre_quotes_single_body}${pcre_quotes_single_delimiter}
    #
    #Then, refactor all PCREs transitively embedding this PCRE to read: e.g.,
    #
    #    # As an example, we arbitrarily demonstrate such refactoring on
    #    # ${pcre_subword_parenable_rest_sans_qualifier}.
    #    local pcre_subword_parenable_rest_sans_qualifier=${pcre_nanoword_parenable_rest}'|'${pcre_sourceable_nanoword_rest}'|'${pcre_reset_remainder_succeed}
    #
    #Simple. Given that, however, an even simpler refactoring may be in order.
    #Rather than refactoring all PCREs transitively embedding this PCRE, it
    #might be feasible to simply append
    #"'|'${pcre_reset_remainder_succeed}" to only:
    #
    #* ${pcre_embeddable_or_char_escaped}.
    #* ${pcre_sourceable_body}.
    #* ${pcre_unforkable_*}.
    #* ${pcre_passable_*}.
    #
    #For laziness purposes, that would certainly seem preferable. Investigate.
    #Note that this implies that, after such refactoring, the latter PCREs will
    #*NEED* to strictly be the last alternatives wherever embedded.
    #FUXME: Note also that such refactoring applies to *ALL* syntactic
    #constructs whether matched at the start of subwords (e.g., most
    #constructs) or within subwords (e.g., glob qualifiers, list assignments).
    #In both cases, the error will be reported as occurring at the start of
    #subword. Hmmm; actually, while that *WOULD* be feasible (and slightly
    #improve efficiency as well, presumably), doing so would prevent us from
    #reliably reporting the cause of syntactic invalidities (since one could
    #never be sure whether such invalidity was caused by the construct starting
    #the erroneous subword or some other construct within such subword).
    #
    #Consequently, it would probably behoove us to *ONLY* refactor constructs
    #guaranteed to start subwords in this manner -- which is most of them,
    #happily. To ensure sensible error messages, glob qualifiers and list
    #assignments will need to retain the current approach. Since both are
    #comparatively rare, this should impose no significant constraints.
    #
    #We'll want to document this subtle difference somewhere -- probably at the
    #glob qualifier and list assignment PCREs themselves.
    #FUXME: Oh; no, that doesn't quite work, as such a fallback choice matches
    #non-erroneous conditions as well (e.g., unquoted characters intentionally
    #prohibited from matching in that syntactic context). Given that, the
    #current approach is definitively unavoidable. That said, since single- and
    #double-quotes are only ever matched together, the lookahead prefixing both
    #PCREs can be centralized into ${pcre_quotes}.

    # local pcre_quotes_single_body='(?>[^'${pcre_quotes_single_delimiter}']++|'${pcre_quotes_single_delimiter_escaped}')*+'
    # local pcre_quotes_single='(?='${pcre_quotes_single_delimiter}')(?:.'${pcre_quotes_single_body}${pcre_quotes_single_delimiter}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_quotes_double_body='(?:[^'${pcre_quotes_double_delimiter}${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    # local pcre_quotes_double='(?='${pcre_quotes_double_delimiter}')(?:.'${pcre_quotes_double_body}${pcre_quotes_double_delimiter}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}

    #FUXME: Embed below at the head of *EVERY* type of word PCRE. To do so,
    #leverage the structure of ${pcre_word_parenable_first_body} below.
    #FUXME: Actually, the only other place we require .

    # Since macro arguments are *NOT* in command position, syntactic constructs
    # specific to such position need *NOT* be considered (e.g., list
    # assignments).

    # First shell word of a command, permitting matching of macros.
    # local pcre_word_macroable_first='(?:'${pcre_nanoword_macroable_start_word_first}')'${pcre_nanowords_macroable_rest_optional}
    # local pcre_word_backtickable_first_body='(?:'${pcre_nanoword_backtickable_start_word_first}')'${pcre_nanowords_backtickable_rest_optional}
    # local pcre_word_backtickable_first=${pcre_var_name_with_list_assignment_or}${pcre_nanowords_backtickable_rest_optional}')|'${pcre_word_backtickable_first_body}')'

    # Here-document prefix common to both quoted and unquoted here-documents,
    # consisting of an ignorable optional hyphen (signifying leading tabs to be
    # insignificant) followed by zero or more horizontal whitespace characters
    # optionally interspersed by line continuations,
    # local pcre_here_doc_prefix='-?'${pcre_continuable_spaces_horizontal_optional} 

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command, permitting matching of strictly balanced parens. Glob qualifiers
    # are permissible at the start of such words, interestingly.
    # local pcre_subword_parenable_start_word_rest=

    # Syntactic component at the start of the first shell word of a command,
    # permitting matching of strictly balanced parens.
    # local pcre_subword_parenable_start_word_first=

    #FUXME: Most uses of "_optional" below no longer apply. Excise, including
    #here as well.

    # Syntactic component at the start of a macro argument.
    # local pcre_subword_passable_start=

    # Zero or more syntactic components *AFTER* the start of a macro argument.
    # local pcre_subwords_passable_rest_optional=

    # Syntactic component *NOT* a glob qualifier after the start of a macro
    # argument.
    # local pcre_subword_passable_rest_sans_qualifier=${pcre_nanoword_passable_rest}'|'${pcre_passable_nanoword_rest}

    # Syntactic component at the start of the first shell word of a command,
    # permitting matching of macros.
    # local pcre_subword_macroable_start_word_first=

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command, permitting matching of macros.
    # local pcre_subword_macroable_start_word_rest=

    # Syntactic component at the start of the first shell word of a command,
    # permitting matching of strictly balanced braces.
    # local pcre_subword_blockable_start_word_first=

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command, permitting matching of strictly balanced braces.
    # local pcre_subword_blockable_start_word_rest='(?:'${pcre_nanoword_blockable_start_word_rest}')'

    # ..................{ PICOWORD ~ blockable               }..................
    # Smallest syntactic component permitting matching of strictly balanced
    # braces.
    # local pcre_picoword_blockable=${pcre_picoword}'|'${pcre_block}

    # Syntactic component at the first character *NOT* "`" of a shell word,
    # permitting matching of "`"-delimited process substitutions. While there
    # technically exist more efficient means of preventing "`" from matching
    # than via negative lookahead, the obsoletion of such substitutions and
    # hence characters by "$("- and ")"-delimited process substitutions implies
    # that efficiency is *NOT* a concern. This PCRE opts for simplicity
    # instead -- and this is certainly the simplest approach.
    # Since list assignments are irrelevant to such matching, such matching is
    # simpler than above.

    #FUXME: Differentiate into first word and non-first word PCREs.

    # local pcre_subword_backtickable_start=${pcre_nanoword_sourceable_start}'|(?!`)'${pcre_sourceable_word_first_start}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command, permitting matching of "`"-delimited process substitutions.
    # local pcre_subwords_backtickable_rest_optional='(?:'${pcre_nanoword_backtickable_rest}')*+'

    #FUXME: We don't appear to use the following three PCREs terribly much,
    #which is plainly wrong. Investigate, please.
    #FUXME: There's pretty much *NO* point to this PCRE. Instead:
    #
    #* Append ${pcre_nanoword_parenable_rest} by
    #  "'|'${pcre_sourceable_nanoword_rest}".
    #* Replace all embeddings of this PCRE with
    #  ${pcre_nanoword_parenable_rest}.
    #* Excise this PCRE.
    #
    #In fact, all ${pcre_nanoword_*} PCREs except for those specific to
    #passables, blockables, and macroables should be appended in this manner.
    #Indeed, all ${pcre_subword*} PCREs should probably be excised away
    #entirely after performing such refactoring. (Nice, eh?)

    # Syntactic component *NOT* a glob qualifier after the start of a shell
    # word, permitting matching of strictly balanced parens.
    # local pcre_subword_parenable_rest_sans_qualifier=${pcre_nanoword_parenable_rest}'|'${pcre_sourceable_nanoword_rest}

    #FUXME: Reduce PCRE verbosity by shifting error handling here from above.
    # local pcre_quotes_optional='(?=['${pcre_quotes_single_delimiter}${pcre_quotes_double_delimiter}'])(?:'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_reset_remainder_succeed}')'

    # ..................{ CHAR                               }..................
    #FUXME: There *IS* no clean equivalent to ${char_not_unquoted}, as
    #precisely which characters are acceptable and which are not in unquoted
    #strings depends on character position. Consequently, we'll need to
    #manually hunt through the codebase and determine exactly what constitutes
    #a sensible general-purpose replacement for this.

    # One or more unquoted shell word characters.
    # local pcre_chars_nanoword_unquoted='[^'${char_not_literal_backtickable_rest}']++'

#Since subsequent PCREs already match a lone "$", this PCRE
    # consumes at least one character.
    #FUXME: "${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}" appears over
    #and over and over again. Grep whether or not ${pcre_embeddable_or_char_escaped} ever
    #appears in the absence of ${pcre_char_escaped}. (Hint: it
    #shouldn't.) If ${pcre_embeddable_or_char_escaped} is indeed always preceded by
    #${pcre_char_escaped}, the latter should simply be folded into the
    #former. Investigate, good sir!

    # Since recursive syntax is matchable *ONLY* via subroutine calls, this
    # PCRE calls a subsequently defined subroutine to do so. Since such calls
    # are comparatively inefficient, such call is performed *ONLY* if the
    # current character is a prefix of such a construct. Since such subroutine
    # will consume such character if called, we non-consumptively test such
    # character with positive lookahead. See ${pcre_subroutines_body}.

    #FUXME: Revise. All ${*_start_word_*} PCREs should be delimited by grouping
    #"(?:" and ")" expressions. Grep elsewhere for such errors as well.

    # Syntactic component *AFTER* the start of any shell word of a command,
    # permitting matching of strictly balanced braces.
    # local pcre_subword_blockable_rest=${pcre_nanoword_blockable_rest}'|'${pcre_unforkable_subword_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command, permitting matching of strictly balanced braces.
    # local pcre_subwords_blockable_rest_optional='(?:'${pcre_subword_blockable_rest}')*+'

    # Syntactic component *AFTER* the start of any shell word of a command,
    # permitting matching of macro names.
    # local pcre_subword_macroable_rest=${pcre_nanoword_macroable_rest}'|'${pcre_unforkable_subword_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command, permitting matching of macro names.
    # local pcre_subwords_macroable_rest_optional='(?:'${pcre_subword_macroable_rest}')*+'

    #FUXME: This... this is probably completely insufficient. Renovate, please.
    # Zero or more macro arguments.
    # local pcre_macro_args_optional='(?:'${pcre_macro_args}')?+'

    # To distinguish syntactically valid from invalid macros, note that macro
    # substrings should be matched in an optional manner.

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations followed by zero or more macro arguments.
    # local pcre_macro_args_optional_spaced=${pcre_spaces_horizontal_continuable}${pcre_macro_args_optional}

    #FUXME: Still not quite right, due to grouping. We want line continuations
    #following such name to be grouped *IF AND ONLY IF* such continuations are
    #then followed by horizontal whitespace followed by one or more arguments.
    #We'll probably need to shift ${pcre_line_continuations_optional} directly
    #into each such PCRE above.
    #
    #Ah; alternatively, (and probably the better solution) simply group such
    #continuations here. A bit silly, yes; but probably the simplest *AND* most
    #efficient approach. We'll need a new index as well, naturally. *sigh*

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations followed by zero or more macro arguments. To identify
    # the last byte indices of macros, all characters comprising such macro
    # following such macro's name are captured -- including whitespace
    # delimiting such name from subsequent arguments.

#  To identify
    # the last byte indices of macros, all characters comprising such macro
    # following such macro's name are captured -- including whitespace
    # delimiting such name from subsequent arguments.

    #FUXME: Excise ${pcre_process_substitution_backtick} here. In fact,
    #${pcre_process_substitution_backtick} should be excised pretty much
    #everywhere *EXCEPT* in macro arguments, where we have no choice but to
    #match such substitutions for backwards compatibility. Everywhere else,
    #there doesn't appear to be any .

    #FUXME: Overkill. Since "("- and ")"-delimited process forks are incredibly
    #rare, they needn't be optimized at all for. The final PCRE could be
    #considerably shortened by instead:
    #
    #* Excising the following two PCREs.
    #* Excising ${pcre_process_fork_sans_paren_left}.
    #* Renaming ${pcre_process_substitution_redirection} to
    #  ${pcre_process_substitution_non_dollar_optional}, refactored to match
    #  process forks again (e.g., by rendering its prefix optional).
    #* Refactoring ${pcre_math_test_sans_paren_left} back into
    #  ${pcre_math_test}.
    #* Embedding ${pcre_math_test} where
    #  ${pcre_paren_left_interpretable} is currently embedded,
    #  ensuring that ${pcre_math_test} is embedded *BEFORE* 
    #  ${pcre_process_substitution_non_dollar_optional}.
    #
    #Not terribly hard, thankfully.

    #FUXME: Refactor to use ${*_first}- and ${*_rest}-style PCREs.
    #FUXME: Leverage ${pcre_literals_sourceable_rest} and so forth here.

    # Syntactic component permitting matching of macros. Since matching
    # strictly balanced non-macro syntax (e.g., braces, parens) is incidental
    # to preprocessor matching, such syntax is matched in any order.
    # local pcre_subword_macroable=${pcre_nanoword}'|'${pcre_unforkable}

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations followed by zero or more shell words permitting
    # matching of macro arguments, each suffixed by such whitespace. Since
    # block arguments are necessarily prefixed by such whitespace, the latter
    # constraint ensures proper matching of the following such argument if any.
    #
    # Standard macro arguments are prohibited from containing redirections, in
    # contrast to standard command arguments. Since interspersing arguments
    # with redirections is comparatively rare *AND* since supporting such
    # oddities in the macro preprocessor would prove to be prohibitively
    # expensive (both in programmer and program time), redirections *MUST*
    # strictly suffix rather than be freely interspersed with macro arguments.
    # local pcre_words_passable_optional_spaced=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable}${pcre_spaces_horizontal_continuable}')*+'
    # local pcre_words_passable_optional_spaced_grouped='('${pcre_words_passable_optional_spaced}')'

    #FUXME: Pick up here tomorrow -- presumably, excising most of this, eh?
    # local pcre_subword_passable_sans_qualifier=${pcre_nanoword_passable}'|'${pcre_passable}

    # Glob qualifier permitting matching of macro arguments.
    # local pcre_subword_passable_glob_qualifier=${pcre_qualifier_head}${pcre_subword_passable_sans_qualifier}${pcre_qualifier_foot}

    # Syntactic construct permitting matching of command arguments.
    # local pcre_subword_passable=${pcre_subword_passable_sans_qualifier}'|'${pcre_subword_passable_glob_qualifier}

    # Shell word following the first such word for the current command,
    # containing one or more syntactic constructs permitting matching of macro
    # arguments.
    #
    # Since such match *MUST* be halted at the first unbalanced "}" character
    # (e.g., signifying a block suffix), such character is prevented from
    # matching with negative lookbehind. Since the definition of
    # ${pcre_subword_passable_sans_qualifier} induces this PCRE to halt
    # at the first unbalanced ")" character as well, this PCRE actually halts
    # at any unbalanced suffix of interest. (This is good.)
    #
    # Since macro arguments cannot be in command position and hence cannot
    # contain list assignments, this PCRE is structured in a simpler manner
    # than that below matching arbitrary code with strictly balanced parens.
    # local pcre_word_passable='(?:'${pcre_subword_passable}')++'${pcre_literal_blockable_lookbehind}

    #FUXME: We need to ensure that macro argument matching halts at (without
    #consuming, of course) a "}" block suffix or ")" process substitution
    #suffix when *NOT* preceded by a balanced "(". Does it currently?
    # ${pcre_*_passable_start_word_first} PCREs need *NOT* be defined here.
    #FUXME: Not quite right. Glob qualifiers *ARE* permissible at the first
    #character of a macro argument.
    # Syntactic construct recursively substitutable with unquoted shell words
    # in a manner permitting matching of macro arguments. As detailed below,
    # redirections are prohibited in such arguments. Since arithmetic tests are
    # commands and hence *NOT* arguments, both are omitted here.

    #FUXME: Not quite right. Glob qualifiers *ARE* permissible at the first
    #character of a macro argument.
    # Syntactic component permitting matching of macro arguments.
    #FUXME: Split into "start_word_first" and "start_word_rest" variants, with
    #appropriate edits below as well.
    # local pcre_word_first_foot=')'

    #FUXME: The following PCREs still correct? Examine closer, please.
    # While both block and scalar arguments may be syntactically invalid, only
    # invalidities in the latter are explicitly detected and captured.
    # Invalidities in the former are implicitly detected instead either at at
    # macro preprocessing time (due either to such macro being passed an
    # insufficient number of arguments *OR* to the resulting
    # preprocessed code being syntactically invalid when dynamically evaluated)
    # or, failing that, at subsequent runtime. In either case, the resulting
    # error should be reasonably intelligible.
    #
    # While such approach could also be adopted for block arguments, explicitly
    # detecting and capturing unbalanced "{" and "}" delimiters requires only
    # negligible effort. While feasible, extending such detection to unbalanced
    # delimiters in scalar arguments would effectively require producing two
    # variants of every syntactic construct and hence non-trivial effort.

    #FUXME: List assignments only accept a subset of interpretable syntactic
    #constructs -- suggesting a new ${pcre_passable} subroutine handling
    #constructs accepted in both macro arguments *AND* list assignments. Is
    #this distinction worth caring about? Probably not, but somewhat consider.
    #Actually, maybe it is. After all, don't we already require such
    #distinction for proper macro argument parsing? If not, we probably should.
    #FUXME: O.K.; we *DO* have ${pcre_passable_nanoword_*} PCREs
    #now. However, we don't have ${pcre_word_passable_rest}. We *REALLY* need
    #to match macro arguments in a glob qualifier-aware manner, to ensure that
    #macro argument matching halts at the first unbalanced ")". Assuming we do
    #define ${pcre_word_passable_rest} in a glob qualifier-aware manner above,
    #replace ${pcre_word_parenable_rest} below by such PCRE.
    #
    #For efficiency, passables pretty much *HAVE* to be defined below. Hence,
    #ignore such technical concerns for now.
    #FUXME: Arguably incorrect. We want ${pcre_sourceable_word_first_start}
    #to take precedence over ${pcre_nanoword}, while still permitting matching
    #of glob qualifiers in an ignorably unbalanced manner.
    #
    #We no longer have any idea what the prior paragraph means. Is this still
    #relevant, or were we merely too nondescript above?
    #FUXME: For both efficiency and simplicity, we should arguably be matching
    #the contents of "{"- and "}"-delimited argument blocks in a similar manner
    #as top-level preprocessor macros: that is, matching process substitution
    #prefixes (e.g., "$(") as command terminators rather than matching process
    #substitutions in a strictly balanced manner. What matters in argument
    #blocks is strict balancing of braces -- not of parens. Parens don't matter
    #at all; instead, simply let any syntactic invalidities in parens balancing
    #in argument blocks "resolve themselves" during zsh interpretation. Yay!
    #
    #Since this implies we'll be matching the same subset of syntactic
    #constructs in both macroable and blockable contexts, we should probably
    #generalize the current macroable-specific PCRE matching such subset to
    #blockables as well.
    #FUXME: Excellent; we've done just that with the new suite of
    #${pcre_unforkable_subword_*} PCREs. Embed such PCREs below in lieu of
    #${pcre_sourceable_word_*} PCREs. Following that, shift this entire
    #subsection beneath that of "CONSTRUCT ~ unforkable".

    # each delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.

    # Shell word *AFTER* the first such word for the current command,
    # comprising one or more syntactic constructs permitting matching of
    # strictly balanced parens.

    # Shell word containing one or more syntactic constructs permitting
    # matching of strictly balanced braces -- namely, by preventing unbalanced
    # "}" block suffixes from being matched here with negative lookbehind.
    # local pcre_word_blockable='(?:'${pcre_subword_blockable}')++'${pcre_literal_blockable_lookbehind}
    # local pcre_word_blockable_rest=${pcre_subword_blockable_start}${pcre_subwords_blockable_rest_optional}

    # Declare negative relative indices matched by ${ZESHY__PREPROCESS_PCRE}.
    # group_index=-1
    # for group_name (
    #     ZESHY__MACRO_GROUP_INDEX_WASTELANDS
    # ) {
    #     integer -g ${group_name}=$(( group_index-- ))
    # }

    # Smallest syntactic component, matching only character escapes, single-
    # and double-quoted strings, and redirections.
    # command, permitting ignoring of process forks and substitutions.

    #FUXME: Actually, these are probably all macroable-specific, given that we
    #already have a blockable-specific subsection below.
    #FUXME: Split into character-aware PCREs, as above.
    # Syntactic component permitting matching of strictly balanced braces.
    # local pcre_nanoword_blockable=${pcre_nanoword}'|'${pcre_block}

    #FUXME: We want to exclude glob qualifiers from such literals, clearly.
    #Does the current approach effect this? If so, document such fact.
    #FUXME: Better, but hardly optimal. Can we do better? We can. We can simply
    #*IGNORE* backticks altogether in macroable and blockable contexts,
    #obtaining the same effect at a reduced complexity and efficiency cost.
    #Specifically, do the following:
    #
    #* Excise this PCRE entirely (i.e., here and below).
    #* Define new unforkable character classes: e.g.,
    #  local char_not_literal_sourceable_rest=${char_space}'''"$&;<>|\\'
    #* Redefine ${char_not_literal_backtickable_rest} as follows:
    #  local char_not_literal_backtickable_rest=${char_not_literal_sourceable_rest}'`'
    #* Define new unforkable-specific PCREs leveraging such classes: e.g.,
    #  local pcre_literals_sourceable_rest='[^'${char_not_literal_sourceable_rest}']++'
    # "`"-delimited process substitution, leveraging the already defined
    # subroutine <int>. While such substitution is also directly and more
    # efficiently matchable by embedding ${pcre_process_substitution_backtick},
    # doing so would duplicate such PCRE's embedding in such subroutine. Since
    # such substitutions are deprecated, efficiency is *NOT* a concern.
    # Consequently, we adopt an approach minimizing PCRE duplication.
    # local pcre_process_substitution_backtick_unforkable='(?=`)'${pcre_sourceable_body}

    # local pcre_unforkable_subword_start_word_first='(?:'${pcre_dollar_unforkable}'|'${pcre_math_test}'|'${pcre_process_substitution_backtick_unforkable}')'

    # Unforkable syntactic construct at the first character of any shell word
    # *AFTER* the first of a command.
    # local pcre_unforkable_subword_start='(?:'${pcre_dollar_unforkable}'|'${pcre_process_substitution_backtick_unforkable}')'

    # * "`"-delimited process substitutions.
    #
    # Technically, "`"-delimited process substitutions should be parsed in
    # piecemeal fashion to allow macros to be embedded in such substitutions.
    # Practically, however, such substitutions are obsoleted by "$("- and
    # ")"-delimited process substitutions. The effort required to support
    # macros embedded in an obsolete syntactic construct hardly seems worth it.
    # Character class matching invalid characters at the start of unquoted
    # shell words *AFTER* the first of a command, additionally including:
    #
    # * "#", prefixing comments.
    # * "{", prefixing blocks.
    # local char_not_literal_backtickable_start_word_rest='#{'${char_not_literal_backtickable_rest}

    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command, additionally including:
    #
    # * "(", prefixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    #
    # Since this only applies to first command words, all subsequent command
    # words are prefixable by "(".
    # local char_not_literal_backtickable_start_word_first='('${char_not_literal_backtickable_start_word_rest}

    #FUXME: Suffix all "_unquoted" substrings in this subsection by
    #"_interpretable". Incidentally, do we want to rename "_interpretable" to
    #something else globally, say:
    #
    #* "applicable".
    #FUXME: Embed ${pcre_brace_right} here. Arguably shift this below the
    #definition of such PCRE.

    #FUXME: Since this only constitutes a single character, simply inline such
    #character here and excise such class.
    # Character class matching invalid characters at the end of unquoted shell
    # words, intended for use in negative lookbehind and hence including only:
    #
    # * "}", suffixing blocks.
    #
    # Note that, while "(" is unconditionally invalid as the first character of
    # such words, ")" is conditionally valid (e.g., when preceded by a "(" in
    # the same word) and hence omitted here.
    # local char_not_literal_last_only='}'

    # Character class matching invalid characters *AFTER* the first of unquoted
    # shell words, comprising all zsh-reserved operators conflicting with
    # preprocessing and hence all unconditionally syntactically significant
    # ASCII punctuation (typically terminating the prior command). This class
    # omits zsh-reserved operators *NOT* conflicting with preprocessing,
    # including "*", "!", "^", and "?", as well as the following zsh-reserved
    # characters conditionally dependent on position in unquoted shell words:
    #
    # * "{", a block prefix only when the first character of such words.
    # * "}", a block suffix only when the last character of such words.
    # * "#", a comment prefix only when the first character of such words. (In
    #   all other instances, "#" acts as a glob operator.)
    # local char_not_literal_backtickable_rest=${char_space}'''"$&;<>|\\`'

    # Character class matching unconditionally invalid characters in unquoted
    # shell words (i.e., characters invalid at all positions of such words).

    #FUXME: Use in lieu of ${pcre_process_substitution_backtick} below.
    #FUXME: Not quite. "(("-prefixed arithmetic tests are only valid at the
    #first word of a command, requiring differentiation here.
    #FUXME: Rename to ${pcre_unforkable}. We'll probably want to rename
    #${pcre_dollar_macroable_optional} to
    #${pcre_dollar_unforkable_optional} as well.
    # Syntactic construct permitting matching of preprocessor macros and hence
    # excluding constructs containing such macros (principally, process forks
    # and substitutions), intended to be matched *ONLY* at the outermost level
    # of PCRE-based preprocessor iteration. This PCRE matches:
    #
    # * "$"-prefixed non-recursive variable expansions.
    # * "${"- and "}"-delimited recursive variable expansions.
    # * "$["- and "]"-delimited recursive arithmetic substitutions.
    # * "$(("- and "))"-delimited recursive arithmetic substitutions.
    # * "(("- and "))"-delimited recursive arithmetic tests.
    #
    # Since syntactic constructs containing arbitrary code (e.g., process
    # substitutions) may also contain macros, matching such constructs here
    # would obstruct matching macros contained by such constructs. To enable
    # such matching, the substrings prefixing such constructs are matched
    # elsewhere as command terminators. Such constructs are omitted here.
    #
    # Technically, "`"-delimited process substitutions should be parsed in
    # piecemeal fashion to allow macros to be embedded in such substitutions.
    # Practically, however, such substitutions are obsoleted by "$("- and
    # ")"-delimited process substitutions. The effort required to support
    # macros embedded in an obsolete syntactic construct hardly seems worth it.
    # local pcre_macroable='(?:'${pcre_dollar_macroable_optional}'|'${pcre_math_test}'|'${pcre_process_substitution_backtick}')'

    #FUXME: Generalize into a new subroutine <unf> called by a new PCRE
    #${pcre_unforkable}. We'll probably want to rename

    # Temporary PCRE containing the placeholder substring
    # "PCRE__COMMAND_END_UNSPACED", intended to be globally replaced below by
    # either ${pcre_terminator_unspaced} or some derivative thereof. While the
    # same effect could be achieved by either three disparate PCREs (e.g.,
    # prefix, suffix, and middle) *OR* a function, this approach is simpler.
    #
    # While spaced terminators (e.g., ":not") *MUST* be preceded by horizontal
    # whitespace, such whitespace need *NOT* be matched in a mandatory manner
    # here, somewhat streamlining PCRE construction. Since unquoted shell words
    # are already prevented from matching such terminators at the start of such
    # words and since such words match in the customary greedy manner, spaced
    # terminators *NOT* preceded by such whitespace are already correctly
    # matched as subwords of such words; likewise, spaced terminators preceded
    # by whitespace are already correctly matched as such terminators.
    #
    # While all terminators may be preceded by horizontal whitespace, such
    # whitespace need *NOT* be matched here -- even in an optional manner. By
    # design (e.g., of ${pcre_words_*} PCREs), prior PCREs are guaranteed to
    # already match such whitespace.
    # local pcre_terminators_unsubstituted='(?:PCRE__COMMAND_END_UNSPACED|'${pcre_terminator_spaced}')'${pcre_spaces_horizontal_continuable_optional}

    # Command terminator(s), both prefixed and suffixed by zero or more
    # horizontal whitespace characters optionally interspersed by line
    # continuations *AND* optionally suffixed by one or more command
    # terminators requiring both prefixing and suffixing whitespace.
    #
    # Despite nomenclature, this PCRE matches at most one command terminator
    # requiring no such whitespace (rather than one or more such terminators).
    # While this superficial discrepancy is unfortunate, the current approach
    # is nonetheless the optimal solution under the assumption that all PCREs
    # preceding this PCRE are optional. Since commands *MUST* consist of at
    # least one terminator but may otherwise be empty (e.g., ";;;", the
    # syntactically valid concatenation of three such terminators), this
    # assumption *SHOULD* always hold.

    #FUXME: Overkill, thanks to simplifications above. Replace such global
    #replacements by simple string concatenations.

    # local pcre_terminators=${pcre_terminators_unsubstituted//PCRE__COMMAND_END_UNSPACED/${pcre_terminator_unspaced}}

    # Command terminator(s) permitting matching of strictly balanced braces.
    # local pcre_terminators_blockable=${pcre_terminators_unsubstituted//PCRE__COMMAND_END_UNSPACED/${pcre_terminator_unspaced_blockable}}

    # Command terminator(s) optimizing matching of preprocessor macros.
    # local pcre_terminators_macroable=${pcre_terminators_unsubstituted//PCRE__COMMAND_END_UNSPACED/${pcre_terminator_unspaced_macroable}}

    #FUXME: Uh oh. This particular set of terminators is macroable- (and
    #arguably blockable-) specific and hence should *ONLY* be matched in such
    #contexts. In parenable contexts, this set of terminators should *NOT* be
    #matched (for obvious reasons). Naturally, this implies we'll need to
    #distinguish between terminators including process prefixes and terminators
    #*NOT* including such prefixes. Fortunately, we already do! See
    #${pcre_terminator_unspaced_body_blockable} and
    #${pcre_terminator_unspaced_body_macroable}.

# where such distinctions are trivial meaningless
    # local pcre_terminator_unspaced_body=${pcre_terminator_comment}'|'${pcre_terminator_process_prefix_sans_backtick}'|'${pcre_terminator_pipe}'|'${pcre_terminator_ampersand}'|'${pcre_terminator_string_end}

    #FUXME: This all seems a bit... overkillish. Ideally, we'd simply be able
    #to reuse the ${pcre_qualifier}-centric PCREs we defined above.
    #FUXME: Prefix by ${pcre_list_assignment_sans_var_name} where used below.
    #FUXME: What's with the recursive ${pcre_word_parenable_rest}? Did we
    #intend to embed ${pcre_subword_parenable_first} instead -- which may or
    #may not actually exist?
    #FUXME: Refactor as above. When we do, we'll probably want to add a suite
    #of passable-specific nanochars *AND* nanowords, with the former embedding
    #a new ${pcre_passable} PCRE calling the existing "<int>" subroutine. Yay!
    # Smaller syntactic component permitting matching of macro arguments.
    # local pcre_nanoword_passable=${pcre_literal_passable_lookahead}'(?:'${pcre_literals_parenable_rest}'|'${pcre_picoword_passable}')'

    #FUXME: The contents of this PCRE should be embedded directly into
    #${pcre_literal_sourceable_lookahead}; then, this PCRE should be excised.
    # Negative lookahead preventing substrings that would otherwise be matched
    # as unquoted shell words from being matched as such. By PCRE design, most
    # command terminators (e.g., "<") are already excluded from unquoted shell
    # words and hence need *NOT* be matched here. Instead, such lookahead matches:
    #
    # * zeshy-specific command terminators implemented as global aliases whose
    #   syntax conflicts with unquoted shell word syntax. Since zsh expands
    #   global aliases globally and hence in ":is"- and "[["-prefixed tests,
    #   preventing unquoted shell words from containing such aliases adequately
    #   prevents such conflict. (Hence, such test syntax needn't be
    #   explicitly matched elsewhere.)
    #
    # Technically, this PCRE should *NOT* match:
    #
    # * Redirection prefixed by an integer-based file descriptor (e.g.,
    #   "1>&2"), conflicting with unquoted shell word syntax. However, since
    #   both shell words and redirections are parsed only for purposes of
    #   disambiguation, matching such descriptor as an unquoted shell word
    #   rather than redirection is of no consequence. (Note that redirections
    #   prefixed by file descriptors specified as "{"- and "}"- delimited
    #   variable names are prefixed by "{" and hence already prevented from
    #   matching unquoted shell word syntax.)
    # local pcre_word_lookahead='(?!'${pcre_terminator_spaced}')'

#  whose syntax conflicts with unquoted shell word syntax.
    # Negative lookahead preventing matching of syntactic construct prefixes
    # conflicting with the start of unquoted shell words, including:
# first (presumably previously matched) character.

    #FUXME: Excise.
    # One or more unquoted shell word characters excluding both "(" and ")".
    # local pcre_chars_nanoword_unquoted_sans_parens='[^'${char_not_literal_parenable}']++'

    #FUXME: Define ${char_parenable_prefix}.
    #FUXME: Define a new "<par>" subroutine as well.
    #FUXME: Actually, we don't quite get it. This PCRE strikes us as an
    #inherently poor idea; by definition, we match "("-prefixed syntactic
    #constructs precisely *BECAUSE* we want to match strictly balanced parens.
    #Hence, at the very least, the above comment is horribly wrong. In all
    #honesty, however, we probably want to excise this entirely.
    #
    #Even if we do require or desire this, a much more efficient implementation
    #would be to defer to the existing subroutines defined below (rather than
    #defining a new subroutine "<par>") constrained by the current lookahead.
    # Sourceable syntactic construct, excluding "("-prefixed syntactic
    # constructs and hence permitting matching of strictly balanced parens.
    # local pcre_parenable='(?=['${char_parenable_prefix}'])(?&par)'${pcre_subject_end_succeed_optional}

    #FUXME: We currently erroneously apply this PCRE to the first character of
    #*ALL* words of a command rather than merely the first word of a command.
    #Correct, please.
    #FUXME: For efficiency, embed ${pcre_not_redirect_prefix_lookahead} into a
    #new PCRE ${pcre_literal_passable_lookahead} matching the current contents
    #of both ${pcre_not_redirect_prefix_lookahead} *AND*
    #${pcre_literal_sourceable_lookahead}. We'll probably want a new
    #${pcre_literal_sourceable_lookahead_body} to simplify the latter.
    # Negative lookahead preventing matching of both digit- and file
    # descriptor-prefixed redirections. All other redirections are prefixed by
    # characters already prevented from matching in unquoted shell words (e.g.,
    # "<", ">") and hence need *NOT* be matched here.
    # local pcre_not_redirect_prefix_lookahead='(?!'${pcre_redirect_numbered_prefix}'|'${pcre_redirect_file_descriptor_prefix}')'

# , matching unquoted word characters valid at the start of such
    # words, character escapes, redirections, and single- and double-quoted
    # strings
# excluding "(" and hence "("-
    # prefixed syntactic constructs permissible only at the start of the first 
    # such word. Since "("-prefixed process forks are comparatively rare *AND*
    # since such subroutine matches such constructs at the end rather than
    # start of its internal list of alternatives, such reuse incurs little to
    # no performance penalties. This is critical, as the alternative of largely
    # duplicating the immensity that is the "<int>" subroutine incurs
    # substantially worse penalties at PCRE recompilation time.

    #FUXME: Not quite specific enough, unfortunately. "(" is only permitted at
    #the start of the first word of a command, whereas "=" is permitted at the
    #start of any word. zsh differentiates between these cases, so we do too.

    # such reuse incurs a largely negligible time cost (e.g., constructs are 
    #FUXME: Actually, given the likelihood of the extreme length of such PCRE,
    #we probably want to do what the comment notes: namely,
    #
    #* Rename subroutine "<inf>" to "<int>".
    #* Excise ${pcre_sourceable_word_rest_body}.
    #* Embed ${pcre_sourceable_word_first_start_body} here.
    #
    #The resulting PCRE should still be quite efficient, thanks to lookahead.
    # Sourceable syntactic construct *AFTER* the first character of shell
    # words. Technically, this PCRE could reduce to calling the subroutine
    # called by ${pcre_sourceable_word_rest}, in which case the subroutine
    # called by this PCRE could be removed.
    # local pcre_sourceable_word_rest_body='(?&inr)'${pcre_subject_end_succeed_optional}
    # local pcre_sourceable_word_rest='(?=['${char_sourceable_word_rest}'])'${pcre_sourceable_word_rest_body}

    # For generality, this includes at any character position of shell words.
    # Syntactic construct recursively interpretable at any character position
    # except the first of shell words.
    # local pcre_sourceable_word_rest=${pcre_dollar_interpretable}'|'${pcre_process_substitution_redirect_optional}'|'${pcre_process_substitution_backtick}
    # pcre_subroutines_body+='(?<inr>'${pcre_sourceable_word_rest}')'

    # Syntactic construct recursively interpretable at the first character position
    # of shell words.
    # pcre_subroutines_body+='(?<inf>'${pcre_paren_left_interpretable}'|'${pcre_sourceable_word_rest}')'

    #FUXME: Sweet refactoring for character positions. Replicate both above and
    #below, please. In particular, don't neglect to define
    #${pcre_nanoword_sourceable_start}, ${pcre_nanoword_sourceable_rest}, and
    #${pcre_char_unquoted_last}. Actually, this needs to be extended to account
    #for first words as well.

    #FUXME: This is silly. Extending the above refactoring to backticks very
    #quickly spirals into monstrous overkill. Instead:
    #
    #* Excise both this PCRE and ${char_sourceable_sans_backtick}.
    #* Refactor ${pcre_word_backtickable} so as to embed both
    #  ${pcre_sourceable_word_first_start} and ${pcre_sourceable_word_rest},
    #  preceding both embeddings by "(?!`)".

    # Sourceable syntactic construct excluding "`"-delimited process
    # substitutions and hence permitting matching of such substitutions. While
    # a new subroutine could be defined below for optimization purposes (e.g.,
    # "<bac>"), such substitutions are deprecated and hence hardly worth
    # optimizing for.
    # local pcre_backtickable='(?=['${char_sourceable_sans_backtick}'])'${pcre_sourceable_body}

    #FUXME: Given the unlikelihood of backticks ever appearing, let's leverage
    #above PCREs as much as feasible. Which may not be terribly feasible, given
    #the need to prevent unquoted "`" characters from matching. So, we'll
    #probably end up having to pursue the current approach.
    #
    #At the very last, however, we'll want to refactor this to reflect the
    #nomenclature used above *AND* to replace ${pcre_backtickable} by either:
    #
    #* '(?!`)'${pcre_sourceable_word_first_start}
    #* '(?!`)'${pcre_sourceable_word_rest}
    #
    #...as desired, of course.

    # Syntactic component permitting matching of the "`" suffixing "`"-
    # delimited process substitutions.
    # local pcre_subword_backtickable_start=${pcre_nanoword_sourceable_start}'|'${pcre_backtickable}
    # local pcre_subword_backtickable_rest=${pcre_char_unquoted_middle}'|'${pcre_backtickable}
    # local pcre_subword_backtickable_chars_rest_optional='(?:'${pcre_subword_backtickable_char_middle}')*+'

    #FUXME: This will all be excised in the specific case of backticks (see
    #FUXME commentary above); so, don't worry terribly much about the details.
    #FUXME: Surely use of ${pcre_subword_parenable_start} here is horribly
    #wrong, yes? Such PCRE embeds ${pcre_sourceable_word_first_start}, when we
    #really want ${pcre_sourceable_word_rest} instead.

    #FUXME: Indeed, our use of ${pcre_word_parenable_rest} is problematic here,
    #as such PCRE matches "}", implying such list assignment PCREs cannot be
    #used in a general-purpose manner. We'll need to refactor these PCREs to
    #match in a maximally constrained and hence conformant manner, to ensure
    #their applicability in all other contexts.
    #
    #Hmmm; actually, the current approach should suffice, so long as we
    #manually suffix words by ${pcre_word_lookbehind}.
    #We've tried to overoptimize a number of special-purpose PCREs for use in
    #only specific contexts (e.g., brace matching, parens matching). In
    #hindsight, that appears to have been quite the time sink -- and with
    #little pragmatic gain to warrant that time. Consider reducing to a single
    #uniform PCRE used for matching both braces *AND* parens in a balanced
    #manner, which should assist us dramatically during debugging.

    #FUXME: O.K.; for the obvious reason that vertical whitespace is *NOT* a
    #command separator in list assignments, such assignments fundamentally
    #conflict with customary syntax and hence *MUST* be matched in all
    #interpretable contexts -- not simply parenable. To that end, shifting this
    #to ${pcre_nanoword_word_first} is probably in order.
    #FUXME: For generality, all such PCREs have been generalized to *NOT* match
    #"}" brace suffixes, implying:
    #
    #* The "_parenable" in *ALL* such PCREs should be renamed to
    #  "_interpretable" instead.
    #* "}" will need to matched manually in non-brace-specific PCREs in
    #  subsequent subsections. (Trivial, of course; but see to it.)
    #FUXME: Wait. No; thanks no negative lookbehind, 

    #FUXME: Refactor invalidity matching according to the modern approach.
    # List assignment body.
    # local pcre_list_assignment_body=
    # local pcre_list_assignment_suffix=${pcre_comment_spaced_optional}'(?:\)|'${pcre_reset_remainder_succeed}')'

    #FUXME: Embed ${pcre_list_assignment_sans_var_name} (prefixed by something
    #matching variable names, of course) somewhere below.
    # Variable name suffixed by either a list assignment *OR* zero or more
    # syntactic components permitting matching of .
    # local pcre_var_name_with_list_assignment_optional=${ZESHY_VAR_NAME_PCRE}'(?:'${pcre_list_assignment_sans_var_name}'|'${pcre_subwords_parenable_rest_optional}')'

    #FUXME: A word-based approach is arguably overkill here. Due to the
    #expected chicken-and-egg issues, such approach is probably infeasible here
    #anyway. In lieu of both, we *REALLY* want to adopt a variable expansion-
    #based embedding approach instead. We think, anyway.
    #FUXME: Hmm; no. Disambiguating comments from "#" glob operators *AND*
    #list assignment ")" suffixes from glob qualifiers inherently requires
    #word-oriented matching, resurrecting chicken-and-egg issues. That said,
    #we'd might as well do this right, as it appears we have to run the
    #full gauntlet anyway. List assignments only accept a subset of
    #interpretable syntactic constructs -- suggesting a new ${pcre_passable}
    #subroutine handling constructs accepted in both macro arguments *AND* list
    #assignments. Indeed, for simplicity, let's assume that exists.
    # local pcre_list_assignment_body=${pcre_word_parenable_rest}'(?:'${pcre_comment_optional_spaced}${pcre_word_parenable_rest}')*+'
    # local pcre_var_delimited_sans_dollar_body='(?:[^'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}')*+'

    # local pcre_subwords_parenable_rest='(?:'${pcre_subword_parenable_rest}')++'
    # Syntactic component *AFTER* the first character of a shell word,
    # permitting matching of strictly balanced parens.
    # local pcre_subword_parenable=${pcre_subword_parenable_rest_sans_qualifier}'|'${pcre_qualifier}

    # Zero or more such components.
    # local pcre_subwords_parenable_rest_optional='(?:'${pcre_subword_parenable_rest}')*+'

    # One or more syntactic constructs permitting matching of strictly balanced
    # parens.
    # local pcre_subwords_parenable='(?:'${pcre_subword_parenable}')++'

    # Zero or more syntactic constructs permitting matching of strictly
    # balanced parens.
    # local pcre_subwords_parenable_optional='(?:'${pcre_subword_parenable}')*+'

    #FUXME: The comment should no longer apply. We should be able to reorder
    #this as efficiently follows:
    # Syntactic construct permitting matching of strictly balanced parens.
    # Since strictly balanced parens and hence the "(" matched by
    # ${pcre_subword_parenable_glob_qualifier} take precedence over the
    # unbalanced "(" matched by ${pcre_subword_parenable_glob_qualifier}, the
    # former *MUST* be matched first.
    # local pcre_subword_parenable=${pcre_qualifier}'|'${pcre_subword_parenable_sans_qualifier_parens}

    #FUXME: Note that glob qualifiers must *NOT* be matched at the first
    #character of the first word of a command.
    #FUXME: Insufficient. ${pcre_interpretable} matches "("-prefixed syntactic
    #constructs (e.g., process forks, arithmetic tests) conflicting with
    #parsing of glob qualifiers. At the minimum, we'll probably need a new
    #${pcre_sourceable_sans_paren_left} PCRE defined above and embedded
    #below in place of ${pcre_interpretable}.
    #FUXME: Sadly, that alone's insufficient. There exist additional and
    #arguably more significant issues as well. Namely, we need to match
    #"("-prefixed:
    #
    #* Syntactic constructs at the first character of parenable words.
    #* Glob qualifiers at all other characters of such words.

    # To match and "return" syntactically invalid  "notify" calling when 

    # ..................{ WORD ~ deciword                    }..................
    #FUXME: Rename every instance of "_nanoword" below to "_deciword".

    #FUXME: Shift everything above above the "LIST ASSIGNMENT" section defined
    #above. Sweet home, sanitarium.
    # Character class matching the subset of zsh-reserved characters whose
    # corresponding syntactic constructs conflict with macro preprocessing.
    # Since vertical whitespace delimits commands and horizontal whitespace
    # delimits command arguments, this includes *ALL* whitespace characters.
    # local char_not_code_prefix=${char_space}'''"$<\\`'

    #FUXME: We currently prohibit macro expansions in process substitutions,
    #largely because differentiating genuine macros from macro-like substrings
    #embedded in double-quoted strings or similar ignorable constructs is
    #non-trivial. To correct this, we'll need to duplicate each syntactic
    #construct embedding other such constructs and prohibit embedding of
    #process substitutions of any type. This doesn't necessarily need to entail
    #PCRE duplication. It will, however, probably mean a doubling in the number
    #of PCREs. See ${pcre_quotes_double_noncode} for a sensible approach, after
    #we've completed an initial draft by the current approach.
    #FUXME: Actually, we can't do it. There's simply no reasonable means by
    #which this could be made feasible. Consider it: even if we *COULD*
    #explicitly match macros in embedded process substitutions (which we could,
    #of course), we'd have no means of resuming the exterior syntactic
    #construct. For example, consider '"$(
    #    :macro)
    #    :macro"'. Ignoring the difficulty of matching ")" as a valid macro
    #terminator in such context, how would the PCRE engine know on resuming
    #iterative matching after expanding the first macro that the second macro
    #is embedded within a double-quoted string and hence ignorable? Brutal, eh?
    #
    #For now, the only reasonable solution is the current solution: ignore
    #*ALL* macro-like substrings in substitutables. We'll just have to publicly
    #note this to be a core limitation of the zeshy preprocessor.
    #FUXME: Overly zealous. While we can't reasonably expand macros in embedded
    #process substitutions (at the moment), we *CAN* expand macros in top-level
    #process substitutions, which seems an adequate compromise. To do so, we'll
    #want to replace our expansion of ${pcre_code} with something like
    #${pcre_code_sans_process_and_math_substitutions}, ensuring that top-level
    #process substitution delimiters (e.g., "$(" and ")") are treated as raw,
    #ignorable characters and hence that macros in such substitutions are
    #matched and expanded. To do so, we'll probably need to explicitly match
    #and ignore:
    #
    #* "`", which is easy, though we'll need a new
    #  ${char_not_code_prefix_sans_backtick}. (Don't actually call it that.)
    #* "$(", which is *NOT* easy. We'll want to continue ignoring arithmetic
    #  substitutions, to ensure macros are *NOT* expanded into such
    #  substitutions. (Or perhaps not? For orthogonality, we'd also need to
    #  ignore "(("- and "))"-delimited arithmetic tests, which seems overkill.)
    #  O.K.; so, explicitly matching "$(" is obviously trivial. Do so
    #  immediately after matching ${pcre_char_escaped} below, we reckon.
    #* All other process substitution prefixes (i.e., "=(", "<(", ">(").
    #FUXME: O.K.; so, once we refactor this parcel to match macros at command
    #positions rather than only at the starts of lines, much of the above
    #complexity should be obliviated. Given that, perhaps we simply want to try
    #straight for the former goal? What, exactly, defines command position?
    #Consider this:
    #
    #* Immediately after a zsh command terminator. These are:
    #  * "|".
    #  * "<", and ">"

    # Unquoted shell word character (excluding parens) valid at the start of
    # the first such word of a command.
    # local pcre_nanoword_parenable_word_first_char_first=${pcre_literal_sourceable_lookahead}'['${char_not_literal_parenable_first}']'

    # ..................{ WORD ~ nanoword : braces           }..................
    # local pcre_char_unquoted_last='['${char_not_literal_last}']'

    # Beginning of the first word of a command as a smaller syntactic
    # component, permitting matching of strictly balanced braces.
    # local pcre_nanoword_blockable_word_first_start=${pcre_nanoword_sourceable_start_word_first}

    # Beginning of any word *EXCEPT* the first of a command as a smaller
    # syntactic component, permitting matching of strictly balanced braces.
    # local pcre_nanoword_blockable_word_rest_start=${pcre_nanoword_sourceable_start_word_rest}

    #FUXME: The possessiveness of ${pcre_chars_unquoted_middle} will probably
    #get us into trouble here -- one of the few cases where possessiveness
    #unavoidably does so. The issue is that we'll need to backtrack off the
    #last matched unquoted shell character to match the constrained set of
    #permissible last characters.
    #
    #Actually, the need for backtracking (and duplication incurred by the
    #current approach) is a demonstrable argument to revert back to the prior
    #lookbehind approach. Let's do that, making a detailed note as to why
    #lookbehind is both the optimal solution in efficiency and simplicity.
    #
    #That, in turn, should permit us to excise a number of unneeded PCREs --
    #or, at least ${char_not_literal_last} anyway.

    # Middle of a smaller syntactic component permitting matching of strictly
    # balanced braces.
    # local pcre_nanoword_blockable_middle=${pcre_nanoword_sourceable_rest}

    # Ending of a smaller syntactic component permitting matching of strictly
    # balanced braces.
    # local pcre_nanoword_blockable_end=${pcre_char_unquoted_last}'|'${pcre_picoword}

    # substrings that would otherwise be
    # erroneously matched as unquoted shell words from being matched as such,
    # permitting matching of strictly balanced braces.

    # Character class matching sourceable-reserved characters, excluding the
    # "`" delimiting such process substitutions. To construct such character
    # class, we prefer the direct approach to replicating such "_sans_backtick"
    # variable structure above.
    # local char_sourceable_sans_backtick='$=<>'

    # Character classes matching invalid characters in unquoted shell words as
    # well as both "(" and ")", permitting matching of strictly balanced parens
    # in such words (i.e., glob qualifiers).
    # local char_not_literal_last='}'${char_not_literal_backtickable_rest}

    # ..................{ CLASS ~ negative : nanoword-parens }..................
    # local char_not_literal_parenable_last='}'${char_not_literal_backtickable_rest}

    #FUXME: We probably no longer require or benefit from most of these. They
    #also appear to be broken. Excise!

    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as both "(" and ")", permitting matching of strictly
    # balanced parens in such words (i.e., glob qualifiers).
    # local char_not_literal_parenable_rest='()'${char_not_literal_backtickable_rest}

    # Character class matching invalid characters at the start of unquoted
    # shell words as well as both "(" and ")".
    # local char_not_literal_parenable_first='#{'${char_not_literal_parenable_rest}

    # Character class matching invalid characters at the end of unquoted shell
    # words as well as both "(" and ")".

    #FUXME: Ugh. It's actually even more complex than this: "(" is only a
    #shell-reserved prefix when the first character of the *FIRST WORD* of a
    #command -- not merely the first character of any word. We'll therefore
    #need to additionally distinguish between such cases here and below.
    #Fortunately, we already more-or-less do this for parenable subwords.  See
    #${pcre_subwords_parenable} for yankable help.
    #FUXME: Note that we'll need to take care to ensure that unquoted shell
    #words do *NOT* attempt to match "((" at the start of such words (e.g., via
    #negative lookahead).

    #FUXME: We can do even better. At present, we force backtracking on
    #horizontal whitespace here, which is terrible. This is entirely
    #correctable as follows:
    #
    #* Excise ${pcre_spaces_horizontal_continuable_optional} here.
    #* Refactor ${pcre_words_backtickable_optional},
    #  ${pcre_words_parenable_optional}, and so on as follows:
    #
    #    local pcre_word_backtickable_optional='(?:'${pcre_word_backtickable}')?+'
    #    local pcre_words_backtickable_optional='(?:'${pcre_word_backtickable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_backtickable_optional}')*+)?+'
    #
    #  Specifically:
    #  * For each ${pcre_word_*}, make a new ${pcre_word_*_optional}.
    #  * Replace the second embedding in ${pcre_words_*_optional} of
    #    ${pcre_word_*} by ${pcre_word_*_optional}.
        # ZESHY__MACRO_GROUP_INDEX_ARG_CHAR_LAST

    # local pcre_macro_args_optional_grouped='('${pcre_macro_args_optional}')?+'
    # local pcre_words_backtickable_optional='(?:'${pcre_word_backtickable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_backtickable}')*+)?+'
    # local pcre_terminators_unsubstituted=${pcre_spaces_horizontal_continuable_optional}'(?:PCRE__COMMAND_END_UNSPACED|'${pcre_terminator_spaced}')'${pcre_spaces_horizontal_continuable_optional}

    #FUXME: Insufficient. We want macro argument matching to halt at (without
    #consuming, of course) redirections prefixed by digits (e.g., "1>&2") or
    #"{"- and "}"-delimited variable names (e.g., "{file_handle}>&2"). Doing so
    #will require negative lookahead here at the start of such naneword, but
    #should probably be defined in the "redirect" subsection above.

    #FUXME: Replace the existing "<int>" subroutine by new "<inf>" and "<inr>"
    #ssubroutines.
    #FUXME: Replicate such refactoring for ${pcre_nanoword_sans_parens} and
    #${pcre_nanoword_passable} below.
    #FUXME: Excise.
    # Smaller syntactic component containing neither "(" nor ")".
    # local pcre_nanoword_sans_parens=${pcre_chars_nanoword_unquoted_sans_parens}'|'${pcre_picoword}

    #FUXME: This has also been replaced by positive matching via
    #${char_not_literal_last}. Excise, please.
    # Negative lookbehind preventing substrings that would otherwise be
    # erroneously matched as unquoted shell words from being matched as such,
    # permitting matching of strictly balanced braces.
    # local pcre_literal_blockable_lookbehind='(?<!['${char_not_literal_char_last}'])'

    #FUXME: Given that we can positively construct words whose first characters
    #are *NOT* in ${char_not_literal_char_first} without such
    #lookahead (which would be more efficient), it's unclear what the current
    #approach. Ease of implementation, perhaps? But that's hardly an
    #applaudable goal. Consider replacing
    #"['${char_not_literal_char_first}']|'" below by positive
    #construction of word characters elsewhere, instead.
    # local pcre_word_lookahead='(?!['${char_not_literal_char_first}']|'${pcre_terminator_spaced}')'

    # Previously matched character, captured with negative lookbehind.
    # local pcre_char_prior_grouped='(?<(.))'

    #FUXME: Refactor in a similar manner as below.
    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(" and ")".
    # local char_not_literal_parenable=${char_not_unquoted}'()'

    #FUXME: Excise. Obsolete by ${char_not_literal_char_first} and
    #friends.
    #FUXME: Overly complex, thankfully. By PCRE design, unquoted shell words
    #are already prevented from matching spaced terminators (e.g., ":not").
    #Since such words match in a greedy manner, a spaced terminator *NOT*
    #preceded by whitespace will already be correctly matched as a continuation
    #of an unquoted shell word; likewise, a spaced terminator preceded by
    #whitespace will already be correctly matched as such a terminator. Hence,
    #such terminators theoretically need *NOT* be explicitly preceded by a
    #whitespace match here. Instead, this PCRE should be reducible to:
    #
    #   local pcre_terminators_unsubstituted=${pcre_spaces_horizontal_continuable_optional}'(?:PCRE__COMMAND_END_UNSPACED|'${pcre_terminator_spaced}')'${pcre_spaces_horizontal_continuable_optional}${pcre_terminators_spaced_optional}
    #
    #Sweet, no?
    # local pcre_terminators_unsubstituted='(?:'${pcre_spaces_horizontal_continuable}'(?:PCRE__COMMAND_END_UNSPACED|'${pcre_terminator_spaced}')|PCRE__COMMAND_END_UNSPACED)'${pcre_spaces_horizontal_continuable_optional}${pcre_terminators_spaced_optional}

    # One or more command terminators requiring one or more prefixing *AND*
    # suffixing whitespace characters.
    # local pcre_terminators_spaced_optional='(?:'${pcre_terminator_spaced}')*+'

    #FUXME: We probably need to prefix ${pcre_chars_nanoword_unquoted} *ONLY* by
    #negative lookahead preventing such PCRE from matching "=(". Simple.

    # Character class matching additionally invalid characters in the last
    # character of unquoted shell words, comprising "}" block suffixes. Note
    # that, while "(" is unconditionally invalid as the first character of such
    # words, ")" is conditionally valid (e.g., when preceded by a "(" in the
    # same word) and hence omitted here.
    # local char_not_literal_char_last='}'

    # Matching such characters as zsh-reserved requires more than merely a
    # character class.
    # Character class matching additionally invalid characters in the first
    # character of unquoted shell words, including:
    #
    # * "#", prefixing comments.
    # * "{", prefixing blocks.
    # local char_not_literal_char_first='#{'

    # Smaller syntactic component, matching only character escapes, unquoted
    # shell word characters, redirections, single-quoted strings, and double-
    # quoted strings.
    # local pcre_nanoword=${pcre_chars_nanoword_unquoted}'|'${pcre_picoword}

    # ..................{ WORD ~ subword : non-qualifier     }..................
    #FUXME: Revise ${pcre_chars_nanoword_unquoted_sans_parens} to exclude "(".
    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(" but *NOT* ")". While
    # both characters are intended to be matched elsewhere in a balanced
    # manner, treating "(" as invalid in unquoted shell words prevents a "("
    # *NOT* balanced by a following ")" from being matched -- which would be
    # decidedly bad.
    # local char_not_literal_or_paren_right=${char_not_unquoted}')'

    # Smaller syntactic component containing neither "(" nor ")". By PCRE design, such
    # components are already prohibited from containing "(", implying such
    # components contain neither "(" nor ")".
    # local pcre_nanoword_sans_parens=${pcre_chars_nanoword_unquoted_sans_paren_right}'|'${pcre_picoword}

    # * "(", prefixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    # local char_not_literal_char_first='#{('

    #FUXME: ${pcre_word_lookahead} lookahead currently prohibits matching of "=(".
    # "=("- and ")"-delimited process substitution prefix, conflicting with
    # unquoted shell word syntax (which otherwise permits unquoted "=" and
    # balanced "(" and ")" characters) and hence requiring disambiguation.
    # local pcre_word_lookahead_process_substitution_equals_prefix='=\('

    #FUXME: Oh, for sake's sake. In reflection, we *ALREADY* perform such
    #lookahead for most syntactic constructs immediately before calling the
    #subroutines matching such constructs. Consequently, we could readily
    #shift most instances of "'|'${pcre_reset_remainder_succeed}')'" to
    #${pcre_embeddable_or_char_escaped} and ${pcre_interpretable} instead. Excellent deduction,
    #but it is unfortunate that we arrived at such conclusion so late in the
    #refactoring process. (Typical, we suppose.)
    #FUXME: Oh, wait. That's a great observation in principal, but probably
    #inapplicable in practice. We probably want to retain the current
    #generalized (if slightly less efficient) approach. See
    #${pcre_interpretable} for commentary.

    # Character class matching sourceable-reserved characters, including all
    # substitutable-reserved characters as well as the "<" and ">" prefixing
    # "<("- and ">("-prefixed recursive process substitutions respectively.

    #FUXME: Split into two character classes as follows:
    #
    #local char_sourceable_word_rest=${char_embeddable_prefix}'<>'
    #local char_sourceable_word_first_start=${char_sourceable_word_rest}'(='
    # local char_interpretable=${char_embeddable_prefix}'(=<>'

    #FUXME: Define me.
    # local char_parenable_prefix

    # Character class matching substitutable-reserved characters, including all
    # embeddable-reserved characters as well as the "=" prefixing "=("-prefixed
    # recursive process substitutions.
    # local char_substitutable_prefix=${char_embeddable_prefix}'='

    #FUXME: While a great idea, this doesn't pan out in practice. Why?
    #"(" prefixes *BOTH* glob qualifiers (matched elsewhere) and syntactic
    #constructs (matched here), implying that a "("-prefixed substring failing
    #to match a syntactic construct to *NOT* deterministically imply a
    #syntactic invalidity. Hence, we need to revert this to the prior
    #definition. For orthogonality, we should probably do so above as well.
    # local pcre_embeddable_or_char_escaped='(?=['${char_embeddable_prefix}'])(?:(?&emb)'${pcre_subject_end_succeed_optional}'|'${pcre_reset_remainder_succeed}')'
    # local pcre_sourceable_body='(?:(?&int)'${pcre_subject_end_succeed_optional}'|'${pcre_reset_remainder_succeed}')'

    #FUXME: For intelligibility, ${pcre_interpretable*} should almost certainly
    #be renamed to ${pcre_parenable*}.
    # local pcre_interpretable='(?=['${char_interpretable}'])(?&int)'${pcre_subject_end_succeed_optional}
    # local pcre_embeddable_or_char_escaped='(?=['${char_embeddable_prefix}'])(?&emb)'${pcre_subject_end_succeed_optional}

    # local pcre_process_sans_paren_left_suffix='(?:\)|'${pcre_subject_end_succeed}')'
    # local pcre_process_sans_paren_left=${pcre_commands_parenable_optional}${pcre_process_sans_paren_left_suffix}

    #FUXME: Wait. It is syntactically invalid to have a "(" *NOT* eventually
    #followed by a balanced ")", implying we need to match such "(" in a
    #syntactically invalid manner (e.g., with
    #${pcre_reset_remainder_succeed}).

    #FUXME: Still incorrect. While technically syntactically invalid in this
    #case (since such operators assume one or more subsequent shell words), any
    #command word and hence spaced command terminator is suffixable by
    #syntactic suffixes (e.g., ")", "}") -- which should probably *NOT* be
    #matched consumptively -- rather than merely whitespace. Note that
    #syntactic prefixes (e.g., "(", "{") are invalid at the end of shell words
    #and hence already prohibited here. Any other than ")" and "}"?
    #
    #Oh, yes: and, of course, they may also be suffixed by unspaced command
    #terminators (e.g., "{", ";"). O.K.; so, this will probably be
    #significantly easier to match as follows:
    #
    #* Refactor this to use non-consumptive positive lookahead leveraging a
    #  simple negative character class: ideally, the inverse of
    #  ${char_not_macro_name_rest}.
    #* Generalize ${pcre_terminator_unspaced_suffix} to apply to both spaced
    #  and unspaced terminators.
    # either one or more horizontal
    # whitespace characters optionally interspersed by line continuations *OR*
    # the end of the subject string.
    #
    # While non-consumptively rather than consumptively matching suffixing
    # whitespace (e.g., via positive lookahead) is strongly preferred, the
    # latter coincides with both PCRE design and zsh behaviour here.
    # local pcre_terminator_spaced_suffix='(?:'${pcre_continuable_spaces}'|'${pcre_subject_end_succeed}')'

    # Command terminator suffix, comprising zero or more horizontal whitespace
    # characters optionally interspersed by line continuations.
    # local pcre_terminator_unspaced_suffix=${pcre_spaces_horizontal_continuable_optional}

    #FUXME: After refactoring ${pcre_report_failure} away below, we'll probably
    #also want to refactor such PCRE away here as well.

    # ZESHY__MACRO_NAME_VALID_PCRE='['${char_not_macro_name_first}']['${char_not_macro_name_rest}']*+'

    # Such comprises all ASCII- and UTF-8-encoded characters excluding PCRE-
    # *AND* shell-reserved ASCII characters. Interestingly, this omits common
    # punctuation characters
    #FUXME: Refactor to the new approach leveraging
    #${pcre_reset_remainder_succeed}. If this is embedded external to a recursive
    #syntactic construct syntax, we'll need to manually match
    #${pcre_subject_end_succeed_optional}. (That probably shouldn't
    #happen anywhere, though.)

    # Empty string, captured as a group. Since libpcre already captures the
    # empty string to unmatched groups (excluding trailing unmatched groups,
    # which are detectable with ${#match}), this PCRE is typically only needed
    # to align group indices in a list of "(?|"-driven alternatives.
    # local pcre_empty_group='()'

    #FUXME: Didn't we intend to excise this?
    #FUXME: Wait. Hmm. As the following example demonstrates, zsh treats "("
    #characters unbalanced by subsequent ")" characters in the same unquoted
    #shell word as the prefixes of process forks. 

    #FUXME: We shouldn't need to leverage this anywhere *EXCEPT* where we
    #capture empty groups at the top level after *NOT* matching a macro. Wait;
    #obviously, we don't need empty groups even then, as "libpcre" implicitly
    #empties such groups already. In other words, hunt down all uses of this
    #PCRE and (ideally) excise. 

    #FUXME: Rename to ${pcre_macro}? What? Help! HE-LLLP!
    # Zero or more arguments passed to a macro. Success is reported immediately
    # after matching the last character of the last such argument to notify the
    # preprocessor phase iterating over such PCRE that such macro has been
    # fully matched. To distinguish syntactically valid from invalid macros,
    # *ALL* matched substrings must be optional.
    # local pcre_macro_body_succeed_grouped=

    #F}XME: Not quite right. If ${pcre_macro_optional_grouped} fails to match,
    #we need to match the *EXACT* same number of groups matched by such PCRE
    #except all empty.

    #FUXME: Consider excising. We shouldn't require this anymore. Indeed, most
    #or even all embeddings of this PCRE should be replaced by
    #${pcre_reset_remainder_succeed}.
    # End of the subject string, capturing the character immediately preceding
    # such end. Capturing such character facilitates detection of syntactically
    # invalid constructs in subsequent PCREs (e.g., double-quoted strings
    # lacking a prefixing '"'). Note this assumes a non-empty subject string.
    # local pcre_subject_end_grouped=${pcre_char_prior_grouped}${pcre_subject_end}

    # local pcre_subject_end_succeed=${pcre_subject_end}${pcre_empty_group}${pcre_succeed}

    #FUXME: Don't we need this to immediately report success as well? Examine.
    #FUXME: Do we need to add empty grouping? 
    # hence discarding all previously
    # matched text.

# To differentiate block from standard arguments passed to macros accepting
# variadic arguments, the entirety of such block (including "{" and "}"
# delimiters) is captured. By zsh design, the first and last characters of
# standard arguments cannot be unquoted "{" and "}" characters respectively.

    #FUXME: Actually, this is rather bollocks. While the current PCRE design is
    #constrained in this fashion, simple usage of "\K" immediately preceding
    #the matched block argument permits us to obtain byte indices simply by
    #examining ${ZPCRE_OP}. Yah; we really needed to level up our PCRE skill.

    # Unlike the "=~" operator, the pcre_match() builtin does *NOT* set canonical
    # byte index globals globals ${MBEGIN} or ${MEND} nor list globals ${mbegin} or ${mend}.
    # Given such constraints, the only means of finding such byte indices is to:
    #
    # This PCRE assists in finding the byte indices of the first and last
    # characters of the next block argument passed to the currently matched macro.
    # Unfortunately, unlike test operator "=~", pcre_match() sets neither canonical
    # integer globals ${MBEGIN} or ${MEND} nor list globals ${mbegin} or ${mend}.
    # Given such constraints, the only means of finding such byte indices is to:
    #
    # 1. Capture the substring preceding such block argument, including otherwise
    #    ignorable whitespace.
    # 2. Add the byte length of such substring to the byte index of the last
    #    character of the prior block argument.

    #FUXME: While correct, this is no longer used correctly elsewhere.
    #Formerly, this only prevented "}" from matching; now that this prevents
    #both "}" and ")" from matching, we'll probably need to create a new PCRE.
    #Right, so, we've completely refactored these. Embed appropriately below.

    # Negative lookbehind preventing substrings that would otherwise be
    # erroneously matched as unquoted shell words from being matched as such,
    # For simplicity, permit "}" block suffixes to be matched as unquoted shell
    # words by omitting such characters here.
    # local pcre_literal_blockable_lookbehind='(?<!['${char_not_literal_char_last_sans_brace_right}'])'

    # Character class matching additionally invalid characters in the last
    # character of unquoted shell words, excluding "}" block suffixes and hence
    # including only:
    #
    # * ")", suffixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    # local char_not_literal_char_last_sans_brace_right=')'

    # Character class matching additionally invalid characters in the last
    # character of unquoted shell words.
    # local char_not_literal_char_last='}'${char_not_literal_char_last_sans_brace_right}

    #FUXME: Is the claim that "By PCRE design, zsh command terminators (e.g.,
    #"<") are excluded from unquoted shell words and hence need *NOT* be
    #matched here." true? My suspicion is "No, this is completely false and
    #hence should be revised." However, if so, this is optimizable by removing
    #"['${char_not_literal_char_first}']|'" below.

#  (but probably
    #should *NOT* be, for both sanity and orthogonality with
    #${pcre_literal_blockable_lookbehind})
    # Negative lookbehind preventing substrings that would otherwise be
    # erroneously matched as unquoted shell words from being matched as such.
    #
    # As ${char_not_literal_with_parens_balanced} details, "}" block
    # suffixes conflict with unquoted shell word syntax (which permits such
    # suffix when *NOT* the last character of such word) and hence require
    # disambiguation.
    # local pcre_literal_blockable_lookbehind='(?<!\})'

    # * Block prefix and suffix. As
    #   ${char_not_literal_with_parens_balanced} details, both
    #   conflict with unquoted shell word syntax (which permits such prefix
    #   when *NOT* the first character and such suffix when *NOT* the last
    #   character of such word) and hence require disambiguation.

    # Invalid character in the first character of unquoted shell words.
    # local pcre_char_not_literal_char_first='['${char_not_literal_char_first}']'

# . For use in negative lookahead, such
    # class matches only characters uniquely invalid in such character:
    # "=("- and ")"-delimited process substitution prefix, conflicting with
    # unquoted shell word syntax (which otherwise permits unquoted "=" and
    # balanced "(" and ")" characters) and hence requiring disambiguation.
    # local pcre_word_lookahead_process_substitution_equals_prefix='=\('

    #FUXME: This doesn't necessarily seem quite right. We want to ensure that
    #"("-prefixed process forks are *NOT* matched as unquoted shell words,
    #which we currently don't appear to do. The simplest means would probably
    #be to:
    #
    #* Add "(" to ${pcre_char_not_literal_char_first}, ensuring that
    #  both that *AND* "(("- and "))"-delimited arithmetic tests are not matched.
    #* Reduce ${pcre_word_lookahead_parens} to the following definition:
    #    local pcre_word_lookahead_process_substitution_equals_prefix='=\('
    #FUXME: Ah; right. We often don't care about "(" and ")" balancing; hence,
    #such change needs to be applied in a manner specific to balancing. Outside
    #of such balancing, the current approach is appropriate. Actually, the
    #current approach is overkill for 
    #FUXME: Actually use below in both parenable and passable PCREs.

    # Syntactic construct prefix containing "(", prefixing:
    #
    # * "(("- and "))"-delimited arithmetic tests, whose left shift operator
    #   "<<" conflicts with here-document prefix "<<" and hence requires
    #   disambiguation.
    # * "=("- and ")"-delimited process substitutions, conflicting with
    #   unquoted shell word syntax (which otherwise permits unquoted "=" and
    #   balanced "(" and ")" characters) and hence requiring disambiguation.
    #
    #Note that "("- and ")"-delimited process forks do *NOT* conflict with 
    #FUXME: Actually use below in both parenable and passable PCREs.
    # local pcre_word_lookahead_parens_parenable='[(=]\('

    #   conflicting with unquoted
    #   shell word syntax (which otherwise permits balanced "(" and ")"
    #   characters) and hence requiring disambiguation.

    # Command terminator *NOT* requiring prefixing or suffixing whitespace,
    # optionally suffixed by horizontal whitespace optionally interspersed by
    # line continuations.
    # local pcre_terminator_unspaced=${pcre_terminator_unspaced_body}${pcre_terminator_unspaced_suffix}

    # Command terminator excluding "{" block prefixes and *NOT* requiring
    # prefixing or suffixing whitespace, optionally suffixed by horizontal
    # whitespace optionally interspersed by line continuations.
    # local pcre_terminator_unspaced_blockable=${pcre_terminator_unspaced_body_blockable}${pcre_terminator_unspaced_suffix}

    # Command terminator including "WASTELANDS" code terminators and
    # *NOT* requiring prefixing or suffixing whitespace, optionally suffixed by
    # horizontal whitespace optionally interspersed by line continuations.
    # local pcre_terminator_unspaced_macroable=${pcre_terminator_unspaced_body_macroable}${pcre_terminator_unspaced_suffix}

    # Single-character command terminator excluding "{" block prefixes and
    # hence comprising only semicolons, terminating the prior command without
    # introducing additional semantics (e.g., piping, redirection).
    # One or more vertical whitespace command terminators.
    # local pcre_terminator_spaces_vertical=${pcre_spaces_vertical}

    # Single-character command terminator, comprising both semicolons and "{"
    # block prefixes.

    #FUXME: Inefficient. This should arguably be suffixed by "++". In such
    #case, however, we'd might as well aggregate this with
    #${pcre_terminator_spaces_vertical}.
    # local pcre_terminator_char='[{;]'

    #FUXME: Ugh. Actually, while this is unreservedly great at the top level,
    #we're fairly convinced this substantially conflicts within matching of
    #invalid syntactic constructs -- which is horrible. To rectify this, we
    #would need to create a new ${pcre_terminators_macroable} or some such
    #intended to be embedded *ONLY* at the macro-specific top-level. While
    #feasible, let's simply disable this optimization-specific functionality
    #for now. (The easy road is the correct road here.)
    #FUXME: Woops! This should be optimized even further. Since such comment
    #*MUST* always be prefixed by vertical whitespace, this should actually be
    #shifted up to where we match such whitespace.

# *NOT* prefixed by "# " and hence excluding zeshy-
    # specific "WASTELANDS" comments. (This condition is guaranteed below by
    # the order of PCRE inclusion.)
    #FUXME: Inefficient. Optimize by replacing everything between "(?|" and ")"
    #with ${pcre_char_optional_grouped} (e.g., "(.?+)").
    #FUXME: Consider excising.
    # End of the subject string, capturing the character immediately preceding
    # such end *AND* immediately reporting success from this match attempt.
    # local pcre_subject_end_succeed_grouped=${pcre_subject_end_grouped}${pcre_succeed}

    #FUXME: Improper suffix: string end is also an acceptable suffix.
    # local pcre_terminators='(?:'${pcre_spaces_horizontal_continuable}'(?:'${pcre_terminator_unspaced}'|'${pcre_terminator_spaced}')|'${pcre_terminator_unspaced}')'${pcre_terminators_spaced_optional}
    # local pcre_terminators_blockable='(?:'${pcre_spaces_horizontal_continuable}'(?:'${pcre_terminator_unspaced_blockable}'|'${pcre_terminator_spaced}')|'${pcre_terminator_unspaced_blockable}')'${pcre_terminators_spaced_optional}

    #FUXME: Far too much error-prone reduplication. Abstract out:
    #
    #* Everything preceding ${pcre_terminator_unspaced} into a new PCRE 
    #  ${pcre_terminators_sans_unspaced_prefix} above.
    #* Everything following ${pcre_terminator_unspaced} into a new PCRE 
    #  ${pcre_terminators_sans_unspaced_suffix} above.
    #* Refactor this and the PCRE below to leverage such PCREs.
    # local pcre_terminators_sans_unspaced_prefix='(?:'${pcre_spaces_horizontal_continuable}'(?:'
    # local pcre_terminators_sans_unspaced_suffix='(?:'${pcre_spaces_horizontal_continuable}'(?:'

    # Either one or more horizontal whitespace characters optionally
    # interspersed by line continuations followed by a command terminator *OR*
    # a command terminator *NOT* requiring such prefixing whitespace,  either optionally suffixed by
    # one or more command terminators requiring prefixing and suffixing
    # whitespace.

    #FUXME: We don't quite understand why we suffix by optional line
    #continuations. There's probably a good reason; sadly, we failed to
    #document that reason. Hmm.
    #
    #Oh, right. It's because we only match
    #${${pcre_spaces_horizontal_continuable}} for efficiency below, since
    #${pcre_word_passable} already implicitly matches line continuations.
    #Document us up, please.

    # local pcre_brace_right_grouped='(?:'${pcre_brace_right}'|'${pcre_subject_end_succeed_grouped}')'

    # To detect unbalanced and hence syntactically invalid block arguments, the
    # last character of the subject string is captured from such arguments.

    #FUXME: Clever. To distinguish unexpected PCRE match errors from expected
    #end-of-string matches, we *REALLY* want to unconditionally capture the
    #character immediately preceding the end-of-string at the topmost PCRE
    #level external to macro matching. That, in turn, implies we do *NOT* need
    #to group such character. Instead, since we'll be grouping such character
    #elsewhere, all we need to do to detect a missing "}" is to see whether...
    #err, O.K.; so, we won't be able to readily discern between scalar and
    #block arguments in exception messages, but... eh? Who terribly cares.
    #Given that, implement the following:
    #
    #* Replace ${pcre_subject_end} by ${pcre_subject_end_grouped} in *ALL* PCREs,
    #  ensuring that the non-emptiness of final capture group "${match[-1]}"
    #  reliably indicates whether the end-of-string has been reached. By using
    #  "-1" rather than a positive index, we should be guaranteed of the
    #  validity of this working regardless of context.
    #* Add sufficient empty groups to macro matches below to ensure that the
    #  corresponding group index is *ALWAYS* empty for valid macro matches.
    #
    #Pretty darn sweet, no? What's particularly awesome about this is that it
    #permits us to transparently detect invalidities in *BOTH* scalar and block
    #macro arguments without any heavy lifting, which is great.
    #FUXME: Sadly, the above won't quite work due to captured group isolation
    #in subroutine calls. However, a minor tweak gets us there:
    #
    #* In ${pcre_terminator_unspaced}, match
    #  ${pcre_subject_end_succeed_grouped}, ensuring that successful
    #  preprocessor parsing captures the last character of such code. In such
    #  case, the last group will be nonempty.
    #* In syntactic constructs, match ${pcre_subject_end_succeed}. Note
    #  the lack of grouping! Since syntactic constructs are recursively
    #  embeddable, there's little point in attempting to group. This ensures
    #  that syntactically invalid constructs will *NOT* capture the last
    #  character of such code. In such case, the last group will *NOT* exist
    #  (as we'd have no means of setting such group to the empty string, absent
    #  overkill-style usage of PCRE directives).
    #
    #Testing for syntactic invalidity thus reduces to testing whether a macro
    #was matched or not and, if not, whether the last capture group exists:
    #
    #    if [[ -z ${match[${ZESHY__MACRO_MATCH_INDEX_NAME}]} ]] &&
    #        (( ${#match} < ZESHY__MACRO_MATCH_INDEX_STRING_IS_VALID )) {
    #        :die "Uh oh! Syntactic invalidity found."
    #    }
    #FUXME: Actually, discerning between scalar and block arguments is trivial
    #with capturing. If:
    #
    #* A block argument is matched, capture the prefixing "{" (which is
    #  guaranteed to be matched, of course) to a new group.
    #* Else, a scalar argument is matched. In such case, capture the empty
    #  string to the same group.
    #
    #Hence, the non-emptiness of such group indicates the *LAST* argument
    #passed to the current macro to be a block; else, to be a scalar.
    #
    #To provide exception message context, we could even go one farther; by
    #capturing with positive lookahead instead. We could arbitrarily capture
    #"(?=(.{1,80}+))" -- that is, anywhere from 1 to 80 characters starting at
    #the first character of such argument. If such character is a "{", such
    #argument is a block; else, such argument is a scalar. Note, however, that
    #we cannot use a positive lookbehind to capture additional context, as
    #lookbehinds require a fixed number of characters whereas we have no idea
    #exactly how many characters would be matchable. This could be
    #circumventable, of course, by prefixing every preprocessed string with an
    #80 character buffer of ignorable whitespace, guaranteeing the
    #unconditional validity of lookbehind resembling "(?<(.{80}))"
    #regardless of context. But, yeah... probably overkill for the moment.

    #FUXME: We shouldn't be embedding this PCRE terribly many places at all,
    #below. Grep and correct, please.
    #FUXME: Correct documentation. We no longer ignore unsupported
    #here-document delimiters: we force failure.
    # Since syntactically valid here-documents with delimiters containing
    # escaped characters (e.g., "<<war\ is\ peace") *MUST* be matched but, by
    # the above discussion, cannot actually be matched in a syntactically valid
    # manner via PCREs, such here-documents are only matchable in a
    # syntactically invalid manner via PCREs. To do so, only the "<<" suffixing
    # such here-documents is matched here by matching the proper subset of
    # here-documents that is matchable here optionally. All text following such
    # suffix will be matched by subsequent PCREs as arbitrary code, implying
    # that here-document text will be preprocessed for macros. While hardly
    # ideal, this is (arguably) the ideal solution achievable via PCREs.

    #FUXME: Actually handle such error condition with fatal exceptions in
    #={backend}. Shouldn't be terribly hard, though we may need to generalize
    #our current exception handling approach in such parcel.

    # Unsupported here-document excluding prefixing "<<" *AND* all subsequent
    # text in the subject string, captured for subsequent identification of
    # such here-document's line in such string (e.g., for use in exception
    # messages). Unfortunately, since subroutine calls isolate captured groups,
    # Unsupported here-documents embedded in syntactic constructs cannot be
    # precisely identified in this manner. Happily, the overwhelming majority
    # of here-documents in zeshy code appear at the top level (e.g., as
    # operable documentation), somewhat mitigating such concerns.
    # local pcre_here_doc_unsupported_grouped='(.*+)'${pcre_empty_group}${pcre_subject_end_succeed}

# Maximum number of match groups capturable by ${ZESHY__PREPROCESS_PCRE}.
# integer -g ZESHY__MACRO_GROUP_COUNT_MAX
    # ZESHY__MACRO_GROUP_COUNT_MAX=1
        # ZESHY__MACRO_GROUP_COUNT_MAX+=1

    # Declare negative relative indices matched by ${ZESHY__PREPROCESS_PCRE}.
    # group_index=-1
    # for group_name (
    #     ZESHY__MACRO_GROUP_INDEX_CODE_VALID_CHAR_LAST_OR_WASTELANDS
    #     ZESHY__MACRO_GROUP_INDEX_HERE_DOC_DELIMITER_INVALID_REMAINDER
    # ) {
    #     ZESHY__MACRO_GROUP_COUNT_MAX+=1
    #     integer -g ${group_name}=$(( group_index-- ))
    #     # print -r ${group_name}': '${(P)group_name}
    # }

    #FUXME: We're unclear: why do we require *ANY* of the following capture
    #groups except ${ZESHY__MACRO_GROUP_INDEX_NAME}? In truth, we probably
    #don't. Contemplate excising both here and above.
        # ZESHY__MACRO_GROUP_INDEX_LINE_CONTINUATIONS
        # ZESHY__MACRO_GROUP_INDEX_SPACES_HORIZONTAL

    # local pcre_here_optional='<(?:<|(?&doc)|'${pcre_here_doc_unsupported_grouped}')'

    # # Character *OR* the end of such string.
    # local pcre_char_optional='(?:.|'${pcre_subject_end_succeed}')'
    #
    # # Escaped character (i.e., "\"-prefixed character). To account for
    # # syntactically invalid "\" characters immediately prefixing the end of
    # # such string, shenanigans appear.
    # local pcre_char_escaped='\\'${pcre_char_optional}

#FUXME: Improve exception messages on syntactically invalid code. At the
#moment, we have no means of printing the line number and/or character range of
#such code -- which is positively terrible. Fortunately, we believe we *MAY*
#have a tolerable means of improving this. It will require a bit of additional
#work, but should substantially improve usability:
#
#* For each syntactic construct currently embedding
#  ${pcre_subject_end_succeed} (e.g.,
#  ${pcre_var_sans_dollar_delimited_prefix}), replace the current use of
#  ${pcre_subject_end_succeed} by a duplication of such syntactic
#  construct's full PCRE with the following:
#  * Prepend such PCRE by positive lookahead capturing *ALL* text from the
#    current position to the end-of-string. Since we know the byte-size of such
#    full string *AND* of such captured substring, we can subtract the latter
#    from the former to determine the starting byte of the invalid construct.
#
#Of course, this fails for recursively embedded invalid constructs due to group
#isolation in subroutine calls -- ever the perennial problem. While there may
#be no meaningful means of correcting that, at least we can improve the general
#situation for top-level invalid constructs. Hmm; actually, pretty much *ALL*
#constructs will be recursively embedded at least one level deep within "{"-
#and "}"-delimited blocks, implying that handling top-level invalid constructs
#is pretty much useless. Pretty frustrating.
#FUXME: So... grouping, however clever, clearly won't work. What *WILL* work
#(more or less, anyway) is to:
#
#* Create a temporary file containing exactly such string (e.g., via
#  "=(...)"-style process substitution).
#* Pass such file to "zsh --no_exec".
#
#The difficulty there, of course, is that zeshy scripts are probably inherently
#syntactically invalid as zsh scripts. Or not? Only one way to find out, eh?

    # One or more characters excluding both embeddable-reserved *AND* vertical
    # whitespace characters.
    # local pcre_chars_not_embeddable_prefix_or_space_vertical='[^'${char_space_vertical}${char_not_embeddable_prefix}']++'

    # Character class matching both embeddable-reserved *AND* vertical
    # whitespace characters for negative character classes.
    # local char_not_embeddable_prefix_or_space_vertical=${char_space_vertical}${char_not_embeddable_prefix}

    # local pcre_quotes_double_prefix='"'
    # local pcre_quotes_double_suffix='(?:"|'${pcre_subject_end_succeed}')'
    # local pcre_quotes_double_body='(?:[^"'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}')*+'
    # local pcre_quotes_double=${pcre_quotes_double_prefix}${pcre_quotes_double_body}${pcre_quotes_double_suffix}

    # local pcre_quotes_single_prefix="'"
    # local pcre_quotes_single_suffix="(?:'|"${pcre_subject_end_succeed}')'
    # local pcre_quotes_single_body="(?>[^']++|'')*+"
    # local pcre_quotes_single=${pcre_quotes_single_prefix}${pcre_quotes_single_body}${pcre_quotes_single_suffix}
    #FUXME: Implement ${pcre_here_doc_unquoted_body} in an analogous fashion to
    #"{"- and "}"-delimited variable expansions.

# -- and hence including character escape "\".
# local pcre_here_doc_unquoted_not_delimiter='(?!'${pcre_here_doc_delimiter_current}')'
    #FUXME: Given that grouped macros are now always matched first and all
    #capture groups matched in a relative manner, we probably don't need to
    #encapsulate this in a subroutine anymore. For simplicity, however, retain
    #the current approach until arriving at the testing phase.
    #FUXME: In reflection, the current approach is fairly bad. We *NEVER* want
    #to treat here-document bodies like arbitrary code, as doing so could
    #readily induce pathological parser behavior; instead, we need to attempt
    #to match a grouped ${pcre_word_parenable} here (probably in an optional
    #manner also matching the end-of-string: e.g.,
    #"(${pcre_word_parenable}|${pcre_subject_end_grouped})") and then simply
    #attempt to match the same word as the closing delimiter. Incidentally,
    #this permits us to excise all ${pcre_*_literal_grouped} PCREs, which is
    #mildly nice. More importantly, this ensures that for edge-case here-
    #documents *NOT* supported by the zeshy preprocessor (e.g.,
    #"<<$(print ugh)
    #ugh"), an explicit fatal exception will be thrown. Which is a *FANTASTIC*
    #thing. Indeed, such exception message could even be improved by grouping
    #${pcre_subject_end_grouped} in such PCRE into a unique group, permitting
    #the preprocessor to disambiguate ordinary syntactic invalidities from
    #non-preprocessable, ossibly syntactically valid here-documents. Which is
    #fairly important, though hardly required for a first working draft.
    #FUXME: Wait. We can do considerably better than even that. Consider:
    #   local pcre_here_doc_prefix_succeed_grouped=${pcre_char_prior_grouped}${pcre_empty_group}${pcre_succeed}
    #   local pcre_here_doc_prefix_delimiter_grouped='(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_literal_grouped}'|'${pcre_subject_end_succeed_grouped}'|'${pcre_here_doc_prefix_succeed_grouped}')'
    #   local pcre_here_doc_prefix_grouped='-?'${pcre_spaces_horizontal_continuable_optional}${pcre_here_doc_prefix_delimiter_grouped}${pcre_space_vertical}
    #
    #This is fairly clever. In the event of no sanely matchable here-document
    #delimiter *OR* end-of-string being matched, we report success with a new
    #group capturing the previous -- which, since we've just matched at least
    #"<<", obviously exists. This permits us to differentiate between error
    #conditions, which is... well, great!
    #FUXME: There's just one tiny issue with the prior approach: subroutine
    #calls occlude captured groups, requiring that this be extracted out of
    #such calls and into the mainstream PCRE. Shouldn't pose any issues; we
    #just need to do so, as postulated above. *shrug*

    #FUXME: Comment me. This *REALLY* needs it. Also, note that this will be
    #ignored in nested invalid here-documents. Since that's *VERY* edge-casey,
    #however, we don't except that to be of terribly much concern.

    #FUXME: Substantially optimize this by expliciting detecting "WASTELANDS"-
    #formatted comments and, where detected, capturing all remaining text
    #including such comment to the last numbered group. ={backend} should then

    #FUXME: Hmm; by matching vertical whitespace here, aren't we prohibiting
    #matching of such 

# captured without
    # preprocessing 
#FUXME: Ultimately, we arguably need to post a patch to zsh-workers adding 
    # local pcre_here_optional='<(?:<|(?&doc)?+)'

    # local pcre_here_doc_quoted_suffix='(?:'${pcre_space_vertical}'(?-1)'${pcre_line_end}'|'${pcre_subject_end_succeed}')'
#  This could be amended, of
#course, by 
    #FUXME: Hmm; since this suffixing ${pcre_line_end} *NEEDS* to be consumed as
    #a command terminator instead, we'll need to match such constraint with
    #only positive lookahead.

    # Reporting success prevents spurious match successs *AND* mildly improves
    # efficiency after detecting such invalid constructs (e.g., by preventing
    # matching command terminators). While reporting failure would be
    # samentically preferable, doing so inhibits zsh from setting canonical
    # list global ${match} to such groups, which rather defeats the purpose.
    #Note first that we embed "?+" rather than "'|'${pcre_subject_end}", as the
    #former matches both end

    #FUXME: Rename ${pcre_subject_end_grouped} to
    #${pcre_subject_end_succeed_grouped} and refactor such PCRE to
    #*IMMEDIATELY* halt matching. Failing to do this could induce match
    #failure and, in any case, inefficiency (e.g., as subsequent command
    #terminators will attempt to be matched).

    # To facilitate detection of such constraint, the character immediately preceding such end is grouped.
    #Likewise, we only want such whitespace to be grouped
    #when followed by one or more arguments; when *NOT* followed by such
    #arguments, such whitespace should be matched in a positive look.
    #Moreover, we only want such whitespace to be *MATCHED* (let alone grouped)
    #when followed by one or more arguments; when *NOT* followed by such
    #arguments, such whitespace should be matched in a positive look.
    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_spaces_horizontal_continuable}${pcre_macro_arg}')*+)?+'
    # Zero or more macro arguments preceded by one or more horizontal
    # whitespace characters optionally interspersed by line continuations.
    # local pcre_macro_body_grouped='(?:'${pcre_macro_args_optional_spaced_grouped}'|'${pcre_macro_sans_args_unspaced_lookahead}')'

    # To comply with PCRE design expecting such
    # terminators to be subsequently consumable, this PCRE non-consumpctively
    # matches such terminator with a zero-width assertion.
    #FUXME: Add additional global index for whitespace below.
    # local pcre_macro_args_spaced_optional_grouped='('${pcre_continuable_spaces_horizontal}${pcre_macro_args_optional}')'

    # Argumentless macro suffix, comprising zero or more horizontal whitespace
    # characters optionally interspersed by line continuations followed by
    # the prior positive lookahead.
    # local pcre_macro_unspaced_spaced_optional=${pcre_continuable_spaces_horizontal_optional}${pcre_macro_unspaced_lookahead}

    # local pcre_macro_args=${pcre_macro_arg}'(?:'${pcre_spaces_horizontal_continuable}${pcre_macro_arg}')*+'
    # local pcre_macro_args_optional_grouped='('${pcre_macro_args_optional}')'
    # local pcre_macro_args_spaced_optional_grouped='('${pcre_continuable_spaces_horizontal}${pcre_macro_args_optional}')?+'

    #FUXME: Actually use below.
    # Macro suffix, anchoring the end of a macro to the end of a line preceded
    # by zero or more horizontal whitespace characters.
    # local pcre_macro_suffix=${pcre_spaces_horizontal_optional}${pcre_line_end}

    # local pcre_macro_args_spaced_optional_grouped=${pcre_line_continuations_optional}'('${pcre_spaces_horizontal}${pcre_macro_args}')?+'

    #FUXME: Everything that fallows requires intense refactoring. Should be
    #delightful, naturally. Or possibly excising? Yes, that seems more helpful.

    # One or more horizontal whitespace characters followed by zero or more
    # scalar or block arguments.
    # local pcre_macro_args_optional_spaced_grouped=${pcre_spaces_horizontal}${pcre_macro_args_optional_grouped}${pcre_macro_args_optional_spaced_lookahead}

    # Macro body, comprising all arguments passed to such macro as well as
    # line continuations and whitespace cementing the former to the latter.
    # local pcre_macro_body=${pcre_line_continuations_optional}'(?:'${pcre_macro_args_optional_spaced_grouped}'|'${pcre_macro_sans_args_unspaced_lookahead}')'

    #FUXME: Well, *THIS* is unfortunate. Since PCREs now match both
    #syntactically valid and invalid code and hence the universe of all
    #possible strings, this parcel of PCREs is now redundant. *sigh* 
    #FUXME: Actually, there *DO* still exist a few remaining syntactic
    #invalidities that we should detect: for example, a "{"-prefixed block
    #argument with no balanced "}" suffix. In such case, the end of the code is
    #matched, which we should probably detect by defining a new PCRE used in
    #place of ${pcre_subject_end} that captures the preceding character in
    #positive lookbehind: e.g.,
    #
    #    local pcre_subject_end_grouped='(?<(.))'${pcre_subject_end}
    #
    #Pretty sweet. We should probably embed such PCRE rather than
    #${pcre_subject_end} in ${pcre_*_blockable}, in which case such syntactic
    #invalidity may be tested for.
    #FUXME: While there exist similar syntactic invalidities for standard macro
    #arguments (e.g., "'" with no suffixing "'" and hence an unclosed
    #single-quoted string), merely implementing detection of block argument
    #invalidity will probably suffice for a first working implementation. The
    #difficulty -- minor, but still a difficulty -- with generalizing to
    #passable macro arguments is that we'll then need to implement two variants
    #for each syntactic construct:
    #
    #* A common variant using ${pcre_subject_end}, intended for use everywhere
    #  *EXCEPT* in passable macro arguments.
    #* An uncommon variant using ${pcre_subject_end_grouped}, intended for use
    #  only in passable macro arguments.
    #
    #Wait. Actually, this is largely unnecessary. It certainly hardly seems
    #worth the effort. Such syntactic validities will be typically be
    #implicitly detected at macro preprocessing time (due to either such macro
    #being passed an insufficient number of arguments *OR* due to the
    #preprocessed code being syntactically invalid when evalled) and, that
    #failing, would certainly be detected anyway at runtime. Note this below.

    # Syntactically invalid macro argument, capturing the remainder of the
    # first line (and following line if any) of such argument and immediately
    # terminating PCRE matching.
    #
    # Capturing such argument assists the preprocessor in distinguishing
    # syntactically valid from invalid arguments (e.g., by testing the length
    # of canonical list global ${matches}). This PCRE non-intuitively
    # terminates matching by reporting success. ensuring the corresponding 
    # code throws an exception due to such syntactically invalid macro. Hence,
    # each macro match attempt results in three possible states:
    #
    # * A syntactically valid macro was matched, in which case such match
    #   succeeds and the syntactically invalid match group is empty.
    # * A syntactically invalid macro was matched, in which case such match
    #   succeeds and the syntactically invalid match group is non-empty.
    # * No further macros were matched, in which case such match fails.
    #
    # Such argument is preceded by horizontal whitespace and hence could
    # erroneously match syntactically valid zeshy- or zsh-specific command
    # terminators. To prevent this, such match attempt must be prefixed by
    # negative lookahead preventing such terminators from matching.
    # local pcre_macro_arg_invalid_lookahead='(?!'${pcre_macro_sans_args_spaced_lookahead}')'
    # local pcre_macro_arg_invalid_body_grouped='('${pcre_chars_sans_space_vertical}${pcre_line_optional}')'
    # local pcre_macro_arg_invalid_grouped=${pcre_macro_arg_invalid_lookahead}${pcre_macro_arg_invalid_body_grouped}${pcre_succeed}

    # "{"- and "}"-delimited block argument passed to a macro.
    #
    # Such "{" must be prefixed by at least one horizontal space. Since the
    # PCRE embedding this PCRE guarantees that, such space is unmatched here.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. While we could assert such condition with positive lookahead,
    # there's actually no need: the negative lookbehind suffixing such shell
    # words guarantees such "}" to either terminate the prior shell word or be
    # a distinct shell word.
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_commands_blockable_optional}${pcre_char_block_suffix}

    # Technically, we require only the outermost such suffix to be captured.
    # For simplicity, we currently capture all such suffixes regardless of
    # nesting depth. Since subroutine isolation prevents such groups from
    # "leaking," this is a non-issue.
    # local pcre_commands_blockable_grouped_optional='(?:'${pcre_block_grouped}'|'${pcre_words_blockable}')'${pcre_terminators_blockable}')*+'

    # ..................{ WORD ~ subword : blockable         }..................
    #FUXME: All blockable- and block-related PCREs should (arguably) be shifted
    #to where the related passable and macroable PCREs are defined below.

    #FUXME: Invalid. Blocks are, of course, freely mixable with customary words
    #(e.g., "if { true } { print agh } else { print ugh }"). Consequently,
    #${pcre_block_grouped} probably needs to be embedded in
    #${pcre_words_blockable}. The only issue with doing so is that this then
    #creates *TWO* capture group indices for ${pcre_brace_right_grouped}, when
    #we definitely only require and want one. The sensible solution, of course,
    #is to only use ${pcre_brace_right_grouped} for the outermost level (i.e.,
    #for the actual block argument) and to use ${pcre_brace_right} for all
    #inner levels (i.e., blocks embedded in such argument).
    #
    #Ah; nevermind. That's clearly no issue, thanks to subroutine isolation.

    # Since matching strictly balanced parens is incidental to such matching,
    # such syntax is matched in any order.

    # Block prefix and suffix. As
    # ${char_not_literal_with_parens_balanced} details, both conflict
    # with unquoted shell word syntax (which permits such prefix when *NOT* the
    # first character and such suffix when *NOT* the last character of such
    # word) and hence require disambiguation.
    # local pcre_char_block_prefix='\{'
    # local pcre_char_block_suffix='\}'
    # local pcre_literal_blockable_lookbehind='(?<!'${pcre_char_block_suffix}')'

    # End of a macro suffixed by one or more horizontal whitespace characters
    # and accepting zero or more arguments, comprising either the end of the
    # current line *OR* a zeshy- or zsh-specific command terminator.
    # local pcre_macro_args_optional_spaced_lookahead='(?='${pcre_terminators}'|'${pcre_subject_end}')'

    # End of a macro suffixed by no horizontal whitespace characters and
    # accepting no arguments, comprising either the end of the current line
    # *OR* a zsh-specific command terminator. Since zeshy-specific command
    # terminators (e.g., :or(), :and()) must be preceded by such whitespace,
    # matching only zsh-specific command terminators suffices.
    #
    # Since the preprocessor expects the last byte of the substring matched by
    # PCRE-based iteration to be the last byte of a macro, this PCRE must *NOT*
    # match any bytes following such macro -- including the command terminator
    # terminating such macro if any. To ensure this, this PCRE must consume no
    # characters and hence contain *ONLY* zero-width assertions.
    # local pcre_macro_sans_args_unspaced_lookahead='(?='${pcre_terminator_unspaced}'|'${pcre_subject_end}')'

    #FUXME: ${pcre_redirect} probably already matches "<" and ">" at an
    #*EARLIER* point, preventing this PCRE from ever matching such constructs.
    #${pcre_redirect} must be improved with suffixing negative lookbehind (or
    #the equivalent thereof), preventing such PCRE from matching either "<" or
    #">" followed by "(". Not terribly difficult.

    #FUXME: Hmm; efficiently support ${pcre_redirect_lookahead} for both of the
    #following PCREs. *sigh*
    #FUXME: Actually use in macro argument-specific subroutine(s) defined below
    #(i.e., passable).
    #FUXME: This overlaps "("- and ")"-delimited shell forks and hence *MUST*
    #be matched first where embedded below. Indeed, for efficiency, we'll
    #probably want to combine the two.

    #FUXME: Ugh; obviously, shift ${pcre_process_substitution_backtick} directly into ${pcre_macroable}.
    #FUXME: Oh. Right. No! Since we need to parse such construct in a manner
    #resembling that of double-quote-embedded process substitutions, we'd might
    #as well just leave this for now. Excise
    #${pcre_process_substitution_backtick} here after refactoring.

    #FUXME: We also need to match "("- and ")"-delimited shell environments:
    #e.g.,
    #
    #    (grep -R okok *) &!
    #
    #For preprocessing purposes, such environments are functionally identical
    #to "$("- and ")"-delimited preprocessor substitutions and hence should be
    #shoehorned into PCREs matching such substitutions. Note, however, that the
    #above example implies that the first and last characters of unquoted shell
    #words cannot be "(" and ")" respectively. All told, mild but extensive
    #edits will be required elsewhere.
    #FUXME: O.K.; so, while "(" cannot be the first character of unquoted shell
    #words, ")" clearly *CAN* be the last character of such words. No issues
    #there.

#FUXME: ${ZESHY__PREPROCESS_PCRE} should be generalized to explicitly match all
#ignorable code containing macro-like syntax (e.g., strings, variable
#expansions) preceding non-ignorable macros. However, this is also fraught with
#issues: for example, we'd actually like to expand macros embedded in process
#substitutions in double-quoted strings and variable expansions but *NOT* in
#all other content in double-quoted strings and variable expansions. Is this
#feasible? Perhaps not. In which case, perhaps the current approach is actually
#a bit more ideal than we first conceived.

    #FUXME: We should probably be matching ${pcre_comment} in a manner
    #resembling that of ${pcre_terminator_comment}. That is to say, now that
    #we've improved ${pcre_word_parenable} to avoid matching shell words
    #prefixed by "#", we should no longer require
    #${pcre_comment_optional_spaced} in very many places. Refactoring such PCRE
    #away should simplify logic elsewhere, we mildly suspect.

#FUXME: Since we're setting this aside for a few days to weeks, we should
#record that the next items of interest are to (in order):
#
#* Correct parsing of process substitutions in standard macro arguments *AND*
#  of arbitrary code in block macro arguments. To do so, we'll want to examine
#  the ${pcre_code_*} subsection below. The PCREs in that subsection are
#  effectively munted at the moment, and should all probably be replaced by
#  something *SUBSTANTIALLY* simpler and then simply excised. So, there's the
#  (mis)state of the present. Right! So, the most efficient (and certainly
#  simplest, since we've already implemented it) solution is to simply adopt
#  the ${pcre_macros_or_commands_optional} approach for matching *ANY*
#  arbitrary code -- including process substitutions and block argument code.
#  Of course, since ${pcre_macro} is specific to matching macros, we can't
#  adopt that *EXACT* same approach. We can, however, copy that approach and
#  simply excise the macro-specific portions. Voila!

    # '(?:'${pcre_comment_optional_spaced}')?+'
    #FUXME: Right. We should probably this approach *EVERYWHERE* where we're
    #currently using "?+" to match a syntactic suffix or the string end. This
    #approach isn't simply more correct; it also happens to be significantly
    #more efficient (and possibly the only valid way of actually matching such
    #condition). Replicate, please.
    #FUXME: This used anywhere? If not, excise please.

    # Zero or more shell words permitting matching of macro arguments, each
    # delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    # local pcre_words_passable_optional='(?:'${pcre_word_passable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_passable}')*+)?+'

    # local pcre_line_continuation_optional='(?:'${pcre_line_continuation}')?+'

    # local pcre_math_sans_paren_left=${pcre_math_sans_paren_left_prefix}'(?:[^)'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}'|\)(?!\))*+'${pcre_math_paren_left_suffix}
    # local pcre_math_substitution_braces_sans_dollar='\[(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}'|[^\]])*+'${pcre_math_substitution_braces_sans_dollar_suffix}

    # Line, including:
    #
    # * Prefixing newline if *NOT* the first line of such code as
    # * All non-newline characters on such line.
    #
    # To comply with ${pcre_line_end}, such PCRE does *NOT* match a suffixing
    # newline if any.
    # local pcre_line=${pcre_line_start}${pcre_chars_sans_space_vertical_optional}${pcre_line_end}
    # local pcre_line_optional='(?:'${pcre_line}')?+'

    #FUXME: Since this is now *MUCH* more frequently embedded than
    #${pcre_continuable_spaces_horizontal}, consider (in order):
    #
    #* Renaming ${pcre_continuable_spaces_horizontal} to 
    #  ${pcre_continuable_spaces_horizontal}.
    #* Renaming this PCRE to ${pcre_continuable_spaces_horizontal}.
    #
    #Rename ${pcre_continuable_spaces} and ${pcre_spaces_continuable}
    #similarly. Surely, this is a dawn of awesomeness in nomenclature incarnate.

    # Zero or more macro arguments.
    # local pcre_macro_args_optional_grouped='(?:'${pcre_macro_arg_grouped}'(?:'${pcre_spaces_horizontal}${pcre_macro_arg_grouped}')*)?'
    # local pcre_macro_arg_grouped='(?:'${pcre_macro_arg_block}'|'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_invalid_grouped}')'

    # Macro prefix, anchoring the start of a macro to the start of a line
    # followed by optional indentation (i.e., horizontal whitespace).
    # local pcre_macro_prefix=${pcre_line_start}${pcre_spaces_horizontal_optional}

    #FUXME: Correct documentation.
    # Zero or more non-macro lines preceding a macro, ensuring macro-like lines
    # embedded in multiline string contexts are ignored. Ideally, this would
    # comprise *ALL* such contexts, including double-quoted strings and
    # variable expansions. Unfortunately, both double-quoted strings and
    # variable expansions may embed process substitutions expanding non-
    # ignorable macros. Hence, this PCRE would need to distinguish between the
    # following edge cases:
    #
    #     >>> "The following macro is ignorable:
    #     ... :func :void :this_is_not_a_function_definition() {
    #     ... }"
    #     >>> "The following macro is *NOT* ignorable: $(
    #     ... :func :void :this_is_a_function_definition() {
    #     ... } )"
    #     >>> "The following macro is ignorable: $("
    #     ... :func :void :this_is_not_a_function_definition() {
    #     ... }")"
    #
    # Clearly, distinguishing such cases is non-trivial. Hence, we currently
    # only ignore macros in string contexts allowing no process substitutions:
    #
    # * Single-quoted strings.
    # * Single-quoted here-strings.
    # * Single- or double-quoted here-documents.
    #
    # While non-ideal, it's unclear whether we can readily do better.

    #FUXME: We need to make sure that macro argument parsing halts immediately
    #before the first redirection passed to such argument (rather than
    #successfully consuming such redirection). This used to be the case. For
    #this still to be the case, we'll need to explicitly omit... what? Well,
    #O.K.; this *SHOULD* behave as expected already. Double check, however.

    # Syntactic construct recursively preprocessable by the preprocessor. Since
    # syntactic constructs containing arbitrary code (e.g., process
    # substitutions) may also contain macros, matching such constructs here
    # would obstruct matching macros contained by such constructs. To enable such matching, the
    # substrings prefixing such constructs are matched elsewhere as
    # command terminators. such constructs are omitted here.
    # pcre_subroutines_body+='(?<mac>'${pcre_dollar_macroable_optional}'|'${pcre_math_test}')'

    # To preprocess macros embedded in such process substitutions, the "$("
    # prefixing such substitutions is matched elsewhere as a command terminator
    # and hence macro prefix.
    # local pcre_macroable='(?=\$(?:[^(]|\(\()|\(\(|'${pcre_subject_end}')(?&mac)'

    #FUXME: As with substitutables above, this subroutine should be inlined
    #directly at its sole point of use and then eliminated. See to it, please.
    #FUXME: Define ${pcre_dollar_macroable_optional}. See far above.
    # For orthogonality, ${pcre_subword_macroable} is defined above.
    #FUXME: The concluding alternative "`[^`]*+`?+" is a temporary hack.
    #When we add support for parsing macros in both double quotes-embedded
    #process substitutions *AND* "`"-prefixed process substitutions, excise
    #such hack. For now, it should suffice for a working first draft.
    # To avoid matching "$("- and ")"-delimited process substitutions while
    # yet matching "$(("- and "))"-delimited arithmetic substitutions,
    # specify explicit alternatives rather than character classes in lookahead.

    # local pcre_subword_macroable=${pcre_nanoword}'|'${pcre_macroable}'|`[^`]*+`?+'
    #FUXME: Do we still require all of these? Clean up documentation according
    #to the format of ${pcre_macroable}.
    #FUXME: Does this *REALLY* need to be a subroutine? Probably not, right?
    #That said, the sheer obtuseness of defining passable words *AFTER*
    #syntactic constructs complicates matters. It's certainly feasible, but
    #*WOULD* require splitting up the word definitions -- which hardly seems
    #worthwhile at the moment.
    #FUXME: Actually, given the frequency of variable expansions in macro
    #arguments, inlining this subroutine would be *VERY* beneficial. See to it,
    #please.

    # Recursively substitutable syntactic construct (i.e., replaceable with
    # any arbitrary unquoted shell word passed to a preprocessor macro and
    # hence excluding "<("- and ">)"-prefixed redirections).
    # local pcre_substitutable='(?=['${char_substitutable_prefix}'])(?&sub)'

    # Syntactic construct recursively substitutable with unquoted shell words
    # in macro arguments. Since such arguments accept neither arithmetic tests
    # or redirections, such constructs *MUST* be omitted.
    # pcre_subroutines_body+='(?<sub>'${pcre_dollar_interpretable}'|'${pcre_process_substitution_equals}'|'${pcre_process_substitution_backtick}')'

    #FUXME: Actually, this is silly. Instead:
    #
    #* *ALWAYS* match "(" (but not ")", of course) in the unquoted shell word
    #  character class defined above.
    #* Match ${pcre_subword_parenable_glob_qualifier} *BEFORE*
    #  ${pcre_subword_parenable_sans_qualifier} in the PCRE embedding
    #  both below.
    #* Drop the "?+" from ${pcre_qualifier_suffix}.
    #
    #This marginally improves efficiency while dramatically improving
    #readability and hence maintainability.
    # Since "(" is *NOT* matched elsewhere
    # for PCREs embedding these PCREs, ")" *MUST* be matched optionally to
    # ensure that "(" unconditionally matches irregardless of balancing.

    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(" and ")" characters --
    # intended to be matched elsewhere in a balanced manner. Specifically,
    # this class additionally matches:
    #
    # * "(", either:
    #   * A list assignment prefix when the last character of unquoted shell
    #     words preceded by a valid variable name followed by "=".
    #   * A glob qualifier prefix when balanced by a subsequent ")" in the same
    #     unquoted shell word.
    # * ")", a glob qualifier suffix when balanced by a prior "(" in the same
    #   unquoted shell word.

    # local pcre_list_assignment_body='(?:'${pcre_word_passable}'(?:'${pcre_comment_optional_spaced}${pcre_word_passable}')*+)?+'

    #FUXME: Likewise, we probably need to add "|[^)]" back to
    #${pcre_subword_parenable} or some such. Why? Because we no longer match
    #syntactically invalid syntax as such. For example, we have no current
    #means of matching "${=

#  Note the
    #FUXME comment elsewhere discussing use of a substitution-style approach to
    #interpolating macro names 
    # ..................{ OBSOLETE                           }..................
    #FUXME: Unify the following with the above PCREs; then, excise this.

    # Zero or more standard arguments matched in a manner assuming that a block
    # argument *WILL* be subsequently matched. Specifically, zero or more line
    # continuations followed by one or more horizontal whitespace characters
    # followed by such arguments, each necessarily suffixed by such whitespace.
    # Since block arguments are necessarily prefixed by such whitespace, the
    # latter constraint ensures proper matching of the following such argument.
    #
    # Standard macro arguments are prohibited from containing redirections, in
    # contrast to standard command arguments. Since interspersing arguments
    # with redirections is comparatively rare *AND* since supporting such
    # rarities in the macro preprocessor would prove to be non-trivially
    # expensive (both in programmer and program time), redirections *MUST*
    # strictly suffix rather than be freely interspersed with macro arguments.
    # local pcre_macro_args_zsh_optional=${pcre_continuable_spaces_horizontal}${pcre_words_argumentable_spaced_with_parens_balanced_optional}
    # local pcre_macro_args_zsh_optional_grouped='('${pcre_macro_args_zsh_optional}')'

    # Zero or more shell words permitting matching of command arguments, each
    # suffixed by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.

    # Since shell words passed as arguments to preprocessor macros accept
    # neither arithmetic tests *OR* redirections, such constructs are omitted.
    #FUXME: O.K.; we may now refactor the main "$"-prefixed PCRE below to *NOT*
    #be optionalized. Yay!

    #FUXME: What's this? Do we still require this? O.K.; yes, yes we do. Shift
    #this upwards, we should think. We'll need to adjust
    #${pcre_dollar_interpretable} accordingly, of course.
    #FUXME: Actually use in subroutine(s) defined below.

    # "$"-prefixed arithmetic substitution, excluding such prefix.
    # local pcre_math_substitution_sans_dollar=${pcre_math_substitution_sans_dollar_paren_left}'|'${pcre_math_substitution_sans_dollar_braces_optional}

# pcre_math_substitution_sans_dollar}'|'${pcre_process_substitution_sans_dollar
    #FUXME: What's this? Do we still require this? Why would we ever want to
    #exclude process substitutions?

    # "$"-prefixed syntactic construct *NOT* a process substitution, comprising
    # variable expansions and arithmetic substitutions.
    # local pcre_dollar_braceable_optional='\$(?:'${pcre_var_sans_dollar}'|'${pcre_math_substitution_sans_dollar}')?+'

    # Recursively expandable syntactic construct.
    # pcre_subroutines_body+='(?<exp>'${pcre_dollar_expansion_optional}'|'${pcre_math_test}')'

    #FUXME: Insufficient. Such expansions may also be suffixed by multiple "["-
    #and "]'-delimited indices as well as ":"-prefixed history operators. Yes,
    #all of this syntax *MUST* be explicitly matched. (No way around that.)
    #FUXME: Actually, the following suffices. We'll probably need to ressurct 
    #${chars_not_construct_prefix}, however. (Was it ${chars_not_code_prefix},
    #perhaps?)
    #FUXME: Wait. This was rather silly. On contemplation, we neither require
    #nor benefit from this. Excise, please.
#  Since
    # subsequent PCREs match merely "$"-prefixed variable expansions (e.g.,
    # $rebel_rock) by virtue of 
#theatrics  such escaped character *MUST* be optional.
    #FUXME: This is totally munted. Do we still require this? We have doubts.
#  While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    # "$("- or "=("- *AND* )"-delimited process substitution, comprising only
    # process substitutions allowed in macro arguments. Since such arguments
    # prohibit redirections, redirections and shell forks are excluded.
    # local pcre_process_substitution_passable_optional='[$=]'${pcre_process_fork}

    #FUXME: Actually, for efficiency, we'll need to split "("- and "$"-prefixed
    #constructs into their own PCREs. Everything else can remain.
    # "("- and ")"-delimited process substitution or fork, excluding leading
    # prefix if any (e.g., "$", "=").
    # local pcre_process_parens_body='\('${pcre_process_body}
    # local pcre_process_fork=${pcre_process_parens_body}

    # * "("- and ")"-delimited shell forks.
    # * "$("- and ")"-delimited process substitutions.

    #FUXME: Something's not quite right here. Don't we require "|[^\[]"?
    # "))" delimiting arithmetic syntactic constructs.

    # Possibly recursively nested arithmetic syntactic construct content
    # prefixed by at least "((", omitting such prefix.
#, matching "(" and ")" characters in an arbitrary manner
    # local pcre_macros_or_commands_preprocessable_optional='(?:'${pcre_macro_optional}${pcre_words_macroable_optional}${pcre_terminators}')*+'

    #FUXME: O.K.; we've just conceived of a considerable issue: syntactically
    #invalid constructs. They *MUST* be matched both here and everywhere. To do
    #so here in the customary way we do elsewhere, however, would basically
    #require adding an alternative the following below:
    #
    #    '|(?!'${pcre_terminator_unspaced}').'
    #
    #While that *WOULD* work, it also matches each unspaced command terminator
    #twice, which is terrible. A superior solution is to refactor *EVERY*
    #syntactic construct below so as to render *EVERYTHING* following such
    #syntactic construct's unique prefix optional. This has a number of
    #ancillary benefits, aside from the obvious efficiency improvements:
    #namely, that we could then remove all fallback alternatives resembling
    #"|[^)]" from the syntactic constructs matched below. Since this is
    #unequivocally a good thing, see to it, please.

# (i.e., substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) passed to a macro.
    #FUXME: Shift above, replacing ${pcre_words_blockable_optional} by
    #${pcre_words_blockable}.
    # local pcre_words_blockable_optional='(?:'${pcre_word_blockable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_blockable}')*+)?+'

    #FUXME: Match block arguments with this PCRE.
    #FUXME: Define ${pcre_terminators_blockable}. Should be trivial.
    #FUXME: Fix. Hideously broken, we should think.
    #FUXME: Actually use in process substitutions.

    # # ..................{ OBSOLETE                           }..................
    # #FUXME: How many of the following PCREs do we still use? Investigate.
    # #Right. So, this current approach appears increasingly horrific. While it
    # #was pleasant, in concept, to believe that we could generalize a set of
    # #alternatives for matching arbitrary code, it probably can't be done. It
    # #certainly doesn't appear worth the effort or confusion, does it? So let's
    # #dramatically simplify this quagmire, probably by resetting and... yup,
    # #just starting over. (The deletion axe must be applied with a firm grip.)
    #
    # # Code atom excluding command terminators, comments, and whitespace. Such
    # # code comprises either one:
    # #
    # # * List assignment.
    # # * Interpretable shell word.
    # # * Here-document or -string.
    # #
    # # Since list assignments are prefixed by variable names indistinguishable
    # # from (and hence conflicting with) unquoted shell words, the former *MUST*
    # # be matched before the latter.
    # #
    # # Since the "<" of the "<("- and ")"-delimited process substitution matched
    # # in shell words conflicts with the "<" unconditionally matched in
    # # here-documents or -string prefixes, the former *MUST* be matched first.
    # local pcre_code_sans_comment_or_terminator_or_paren_right_prefix=${pcre_list_assignment_optional}'|'
    # local pcre_code_sans_comment_or_terminator_or_paren_right_suffix='|'${pcre_here_optional}
    #
    # local pcre_code_sans_comment_or_terminator_prefix=${pcre_list_assignment_optional}'|'
    # local pcre_code_sans_comment_or_terminator_suffix='|'${pcre_here_optional}
    # local pcre_code_sans_comment_or_terminator=${pcre_code_sans_comment_or_terminator_prefix}${pcre_word_interpretable_or_block_suffix}${pcre_code_sans_comment_or_terminator_suffix}
    #
    # # One or more code atoms excluding command terminators, comments, and
    # # whitespace.
    # local pcre_codes_sans_comment_or_terminator='('${pcre_code_sans_comment_or_terminator}')++'
    #
    # #FUXME: The inclusion of ${pcre_chars_terminator_not_code_prefix} could
    # #probably use a rethink. That's a pretty terrible PCRE, which, due to
    # #copious revisions, is probably no longer even mildly correct in this
    # #context. Examine where we currently use this PCRE and contemplate changes.
    #
    # # Code atom excluding comments and whitespace.
    # local pcre_code_sans_comment_prefix=${pcre_chars_terminator_not_code_prefix}'|'${pcre_code_sans_comment_or_terminator_prefix}
    # local pcre_code_sans_comment_suffix=${pcre_code_sans_comment_or_terminator_suffix}
    #
    # # Code atom, excluding "}" block suffixes and "#"-prefixed comments.
    # local pcre_code_sans_comment_and_block_suffix=${pcre_code_sans_comment_prefix}${pcre_word_parenable}${pcre_code_sans_comment_suffix}
    #
    # # Code atom, comprising any syntactic construct matched by
    # # ${pcre_code_sans_comment} as well as:
    # #
    # # * One or more whitespace characters.
    # # * A "#"-prefixed comment.
    # # * A "}" block suffix, matched by omitting the customary negative
    # #   lookbehind from interpretable shell words.
    #
    # #FUXME: We need to match unbalanced syntactic prefixes and suffixes (e.g.,
    # #"{", "}", "(", ")"). Are there any others? Now, we clearly match "}" and
    # #"(" here, but "{" and ")" appear to have gone astray. Investigate.
    #
    # local pcre_code_prefix=${pcre_code_sans_comment_prefix}${pcre_comment_optional_spaced}'|'
    # local pcre_code_suffix=${pcre_code_sans_comment_suffix}
    # local pcre_code=${pcre_code_prefix}${pcre_word_interpretable_or_block_suffix}${pcre_code_suffix}
    #
    # # Code atom, excluding "`"-delimited process substitutions.
    # local pcre_code_sans_backtick=${pcre_code_prefix}${pcre_word_interpretable_sans_backtick}${pcre_code_suffix}
    #
    # # Zero or more code atoms.
    # local pcre_codes_optional='('${pcre_code}')*+'

    #FUXME: This character class is probably an unpleasantly ichorous idea --
    #which is to say, bad. For example, while "|" *IS* a single-character
    #command terminator, "|&" is *NOT*. Matching the former precludes matching
    #the latter, which may not necessarily be sensible. Honestly, this
    #character class is only embedded once elsewhere, suggesting the whole
    #distinction between this and ${char_terminator} is terrible and should be
    #eliminated entirely.
    #FUXME: Yes, absolute excise this. Repugnant to writhing life itself.

    # Character class matching single-character command terminators *NOT*
    # prefixing syntactic constructs possibly containing macro-like substrings.
    # Since the latter comprises only ">("-prefix process substitutions and
    # "<<"-prefixed here-documents and -strings, this class excludes only "<"
    # and ">".
    # local char_terminator_not_code_prefix=${char_space_vertical}'|;'

    # Redirection-specific punctuation. Since command arguments may be freely
    # interspersed with redirections, redirections must be disambiguated from
    # command terminators with overlapping syntax (e.g., redirection "&>" and
    # command terminators "&", "&!", and "&&").
    #
    # This PCRE matches the following such punctuation: "<", "<>", ">", ">|",
    # ">!", ">>", ">>|", ">>!", "<&", ">&", "&>", ">&|", ">&!", "&>|", "&>!",
    # ">>&", "&>>", ">>&|", ">>&!", "&>>|", and "&>>!". Since here-documents
    # are syntactically rich enough to warrant special consideration, such
    # punctuation excludes "<<"-prefixed here-documents (and, by extension,
    # here-strings). See section "REDIRECTION" of "man zshmisc".
    # local pcre_redirect_punctuation_less_than='<[&>]?+'
    # local pcre_redirect_punctuation_greater_than='>>?+&?+[!|]?+'
    # local pcre_redirect_punctuation_ampersand='&>>?+[!|]?+'

    #FUXME: Excise ${pcre_redirect_punctuation} in favor of ${pcre_redirect}.
    # local pcre_redirect_punctuation=${pcre_redirect_punctuation_less_than}'|'${pcre_redirect_punctuation_greater_than}'|'${pcre_redirect_punctuation_ampersand}

    # Since here-documents are syntactically rich enough to warrant special
    # consideration, such punctuation excludes "<<"-prefixed here-documents
    # (and, by extension, here-strings).

    # Here-string prefix. Since here-string arguments are shell words, since
    # subsequent parsing already matches such words, and since syntactically
    # invalid here-string arguments must be matched, match only such prefix.
    # local pcre_here_string_prefix='<'

    # Note that
    # here-strings are shell words matched by subsequent PCREs and hence *NOT* matched here; for simplicity, only such prefix is matched here.
    # Substring prefixing both here-documents and -strings.
    # local pcre_here_prefix='<<'
    # local pcre_here_optional='<(?:<'${pcre_here_string_prefix}'|(?&here)?+)'

    #FUXME: Excise in favor of ${pcre_here_optional}; then rename
    #the latter to ${pcre_here_optional}.
    # local pcre_here_optional=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|(?&here)?+)'

    #FUXME: Redefine in terms of ${pcre_terminator_unspaced_body}.
    # local pcre_terminator_unspaced='(?:'${pcre_terminator_char}'|'${pcre_terminator_spaces_vertical}'|'${pcre_terminator_comment}'|'${pcre_terminator_process_substitution_prefix_sans_backtick}'|'${pcre_terminator_pipe}'|'${pcre_terminator_ampersand}'|'${pcre_subject_end}')'${pcre_spaces_horizontal_continuable_optional}

    #FUXME: The nomenclature implies such PCRE matches one or more arbitrary
    #command terminators -- which, of course, it doesn't. Which seems silly,
    #since it probably should. Right? ${pcre_terminators_spaced_optional}, in
    #particular, is fairly bizarre and only ever expanded here. Consider
    #replacing such PCRE by something somewhat more... generalized.

    #FUXME: ${pcre_terminator_spaced} matches suffixing whitespace, implying
    #that ":and :not" will *NOT* be matched. Arguably,
    #${pcre_terminator_spaced} should be suffixed by positive lookahead
    #matching such whitespace instead.

    #FUXME: Excise now-obsolete ${pcre_arg_block_*} PCREs.
    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros.
    #
    # Such "{" must be prefixed by at least one horizontal space. Since the
    # PCRE embedding this PCRE guarantees that, avoid matching such space here.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, avoid matching suffixing whitespace matched as prefixing
    # whitespace by the subsequent such block by merely asserting this
    # constraint with positive lookahead.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code_sans_comment_and_block_suffix}'|[^}])*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    #FUXME: Finish me. We need to explicitly match "{" and "}" in a balanced
    #manner. Examine the prior block definition, please.
    #FUXME: Contrary to commentary below, we don't appear to assert such "}" to
    #be followed by whitespace with positive lookahead. That said, is such
    #lookahead even necessary? Given the negative lookbehind suffixing such
    #words, we should be guaranteed (by the logic of greedy matching) of the
    #suffixing "}" being the end of a shell word.
    # To support macros accepting two or more consecutive argument
    # blocks, avoid matching suffixing whitespace matched as prefixing
    # whitespace by the subsequent such block by merely asserting this
    # constraint with positive lookahead.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code_sans_comment_and_block_suffix}'|[^}])*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    #FUXME: ${pcre_words_interpretable_sans_braces_optional} is overkill, as it
    #currently appears to explicitly match glob qualifiers. While we *DO* need
    #to match such qualifiers, we don't particularly care about balanced parens
    #here, meaning such qualifiers could be matched far more efficiently with a
    #simple character class. In other words, we probably want to:
    #
    #* Rename ${pcre_words_interpretable_sans_braces_optional} to
    #  ${pcre_words_blockable_optional}.
    #* Rename ${pcre_words_interpretable_optional} to
    #  ${pcre_words_parenable_optional}.
    #* Refactor the former to use a character class matching arbitrary parens.

    # "("- and ")"-delimited list assignments are commands consisting of
    # multiple shell words rather than subwords of shell words and hence
    # matched here rather than by ${pcre_words_interpretable_optional}. Since
    # such assignments are prefixed by variable names indistinguishable from
    # and hence conflicting with unquoted shell words, the former *MUST* be
    # matched first.
    # local pcre_commands_parenable_optional='(?:(?:'${pcre_list_assignment_optional}'|'${pcre_words_parenable_optional}')'${pcre_terminators}')*+'

    #FUXME: This doesn't quite work. Consider:
    #
    #    var_name(q#.)
    #
    #That's a perfectly valid shell word, of course, but the current coterie of
    #PCREs fails to match it! Why? Because this PCRE matches "var_name" and
    #then halts, at which point the "(" will be matched as a shell environment
    #prefix rather than a glob qualifier prefix. Of course, that is horribly
    #wrong. The point, of course, is that we need to augment the definition of
    #${pcre_word_interpretable_optional} (or is it
    #${pcre_word_parenable_optional} now?) to first attempt to match
    #${ZESHY_VAR_NAME_PCRE} and, if that succeeds, to then attempt to match
    #${pcre_list_assignment_list_optional}.
    #
    #Hence, these PCREs should be shifted to where word PCREs are defined.
    # local pcre_list_assignment_list_optional='(?:'${pcre_list_assignment_list}')?+'
    # local pcre_list_assignment_optional=${ZESHY_VAR_NAME_PCRE}${pcre_list_assignment_list_optional}

    # local pcre_list_assignment_optional='(?:'${pcre_list_assignment}')?+'
# , excluding the "`" delimiting such
#     # process substitutions
#     # Syntactic construct *NOT* containing "`" delimiters, permitting matching
    # of strictly balanced parens.
    # local pcre_subword_parenable_sans_backtick=${pcre_subword_interpretable_sans_qualifier_parens_backtick}'|'${pcre_subword_interpretable_glob_qualifier_sans_backtick}

    #FUXME: Globally rename ${pcre_subword_interpretable_*} to... well, how
    #about simply ${pcre_subword_*}?

    # "`"-delimited process substitution-specific "("- and ")"-balanced glob
    # qualifier *NOT* containing "`" delimiters.
    # local pcre_subword_interpretable_glob_qualifier_sans_backtick=${pcre_qualifier_prefix}${pcre_subword_interpretable_sans_qualifier_parens_backtick}${pcre_qualifier_suffix}

    # local pcre_subword_blockable=${pcre_subword_interpretable_sans_qualifier_parens}'|'${pcre_subword_interpretable_glob_qualifier}

    #FUXME: If "substitutable" only applies to standard arguments, rename
    #"substitutable" everywhere to "passable". (Yay for terseness.)

    # Interpretable shell word, signifying arbitrary code excluding such
    # shell-reserved syntax as operators (e.g., "&!", "||") and block
    # delimiters (e.g., "{", "}").
    # local pcre_word_parenable=${pcre_word_lookahead}${pcre_subwords_interpretable}${pcre_literal_blockable_lookbehind}

#  containing one or more syntactic
    # constructs optionally containing balanced and/or unbalanced parens

# containing one or more syntactic constructs
    # optionally containing strictly balanced parens
    #FUXME: Define ${pcre_comment_optional_spaced_optional}.
    # Zero or more list assignment-specific shell words, each delimited by one
    # or more horizontal whitespace characters optionally interspersed by line
    # continuations.
    # local pcre_words_passable_commentable='(?:'${pcre_word_passable}'(?:'${pcre_comment_optional_spaced}${pcre_word_passable}')*+)?+'

    #FUXME: ${pcre_spaces_horizontal_continuable} strikes us as overkill
    #in *ALL* such PCREs. Why? Because line continuations are already matched
    #as character escapes and hence unquoted shell subwords. Don

    #FUXME: Excise. This has been replaced by ${pcre_word_macroable}.
    # Interpretable shell word *OR* block suffix "}".
    # local pcre_word_interpretable_or_block_suffix=${pcre_word_lookahead}${pcre_subwords_interpretable}

    #FUXME: No, no, and surely no. The current approach fails to match:
    #
    #    my_list=( # This matches.
    #    # This does not. have now failed to match. Meagre congratulations.
    #
    #As resolution, we probably want to adopt a model similar to that of
    #${pcre_commands_parenable_optional} below: e.g.,
    #
    #    local pcre_list_assignment=${pcre_list_assignment_word_spaces_optional}'(?:'${pcre_word_passable}'(?:'${pcre_list_assignment_word_spaces}${pcre_word_passable}')*+)?+'${pcre_list_assignment_word_spaces_optional}
    #
    #${pcre_list_assignment_word_spaces} should be defined to match one or more
    #contiguous runs of one or more whitespace characters optionally followed
    #by a comment.
    #
    #Probably not worth optimizing; just go for the simplistic "|"-based
    #approach. Assuming some permutation of that applies, refactor:
    #
    #* ${pcre_list_assignment_list_prefix} and
    #  ${pcre_list_assignment_list_suffix} to use
    #  ${pcre_list_assignment_word_spaces_optional} rather than their current
    #  whitespace PCRE.
    #* ${pcre_words_assignable_with_parens_balanced_or_comments_spaced_optional}
    #  back to its prior version. Indeed, shouldn't
    #  ${pcre_words_passable_optional} suffice here?
    # local pcre_list_assignment_list_optional='(?:'${pcre_list_assignment_list_prefix}${pcre_words_assignable_with_parens_balanced_or_comments_spaced_optional}${pcre_list_assignment_list_suffix}')?+'

#  ${pcre_list_assignment_word} should probably just be replaced by
    #${pcre_word_passable}; aren't the two exactly equivalent here? 
    #FUXME: Define me. Since "(" and ")" balancing is irrelevant to such
    #parsing, the following should suffice.
    #FUXME: Hmm; the current complexity could be *GREATLY* reduced by:
    #
    #* Matching comments (sans prefixing whitespace) directly in a new PCRE
    #  ${pcre_word_passable_commentable} based on
    #  ${pcre_word_passable}.
    #* Refactoring this PCRE to use customary horizontal spacing, as below.
    #* Improving the list assignment prefix and suffix PCREs to match optional
    #  whitespace (both horizontal and vertical) immediately following and
    #  preceding such prefix and suffix, respectively.
    # local pcre_words_passable_commentable_optional='(?:'${pcre_word_passable_commentable}'(?:'${pcre_spaces_horizontal_continuable}${pcre_word_passable_commentable}')*+)?+'

    #FUXME: Permitting ${pcre_qualifier_suffix} to be optional strikes us
    #as inherently *WRONG*.
    #  ${pcre_word_assignable} based on ${pcre_word_passable}.

    #FUXME: Define ${pcre_word_argumentable_with_parens_balanced}. Such PCRE
    #should match "$("- and "="-prefixed process substitutions but *NOT* "<("-
    #or ">)"-prefixed redirections.
    #FUXME: Define ${pcre_word_assignable_with_parens_balanced}.
    # Preprocessor-specific syntactic construct optionally containing
    # strictly balanced parens.
    # local pcre_subword_macroable=${pcre_subword_macroable_sans_qualifier_parens}'|'${pcre_subword_macroable_glob_qualifier}

#  Matching strictly balanced
    # parens requires more than merely a character class and hence is deferred
    # to more complex PCREs embedding this PCRE.
    # One or more unquoted characters *NOT* prefixing syntactic constructs
    # conflicting with general-purpose macro preprocessing. Such characters
    # include all ASCII whitespace characters but neither "{" or "}", which
    # must be matched in a much more cautious manner.
    # local pcre_chars_not_code_prefix='[^'${char_not_code_prefix}']++'

    #FUXME: This PCRE is only embedded once below and, arguably, is a terrible
    #idea. Command terminators are complex enough to warrant matching in full;
    #there really exist only a few single-character terminators.

    # One or more command terminators *NOT* prefixing syntactic constructs
    # possibly containing macro-like substrings.
    # local pcre_chars_terminator_not_code_prefix='['${char_terminator_not_code_prefix}']++'

    # Character class matching unconditionally invalid characters in unquoted
    # shell words as well as the conditionally valid "(", ")", "{", and "}"
    # characters -- intended to be matched elsewhere in a balanced manner.
    # local char_not_literal_with_parens_braces_balanced=${char_not_literal_with_parens_balanced}'{}'

    # Core syntactic component excluding parens and braces.
    # local pcre_nanoword_sans_parens_braces=${pcre_chars_nanoword_unquoted_sans_paren_right_braces}'|'${pcre_picoword}

    # Block argument-specific syntactic component excluding glob qualifiers,
    # optionally containing strictly balanced parens and/or braces.
    # local pcre_subword_interpretable_sans_qualifier_parens_braces=${pcre_nanoword_sans_parens_braces}'|'${pcre_interpretable}

    # Block argument-specific shell word containing one or more appropriate
    # syntactic constructs but *NOT* "}" block suffixes.
    # local pcre_subword_interpretable_sans_brace_suffix=${pcre_word_parenable}${pcre_literal_blockable_lookbehind}

    # Block argument-specific "("- and ")"-balanced glob qualifier *NOT* 
    # containing braces.
    # local pcre_subword_interpretable_glob_qualifier_sans_braces=${pcre_qualifier_prefix}${pcre_subword_interpretable_sans_qualifier_parens_braces}${pcre_qualifier_suffix}

    # Block argument-specific syntactic construct *NOT* containing braces.
    # local pcre_subword_interpretable_sans_braces=${pcre_subword_interpretable_sans_qualifier_parens_braces}'|'${pcre_subword_interpretable_glob_qualifier_sans_braces}

    # Shell word containing one or more syntactic constructs optionally
    # containing block suffix "}" and/or balanced and/or unbalanced parens.
    # Note that matching the former only requires omitting negative lookbehind.

#  excluding glob qualifiers, common to only
    # subwords optionally containing parens and/or braces (regardless of
    # whether such delimiters are balanced or not)
# , common to *ALL* types of
    # subwords regardless of context
    # optionally containing strictly balanced parens .

    # List assignment-specific shell word containing one or more syntactic
    # constructs optionally containing strictly balanced parens. Since a "}"
    # block suffix terminates a list assignment, prohibit such word from
    # matching such suffix with negative lookbehind.
    # local pcre_word_assignable_with_parens_balanced=${pcre_word_lookahead}'(?:'${pcre_subword_assignable_with_parens_balanced}')++'${pcre_literal_blockable_lookbehind}

    # ..................{ OBSOLETE                           }..................
    #FUXME: Excise. This has been replaced by ${pcre_subwords_macroable}.

    # One or more interpretable syntactic constructs in a shell word *OR*
    # redirections.
    # local pcre_subwords_interpretable='(?:'${pcre_subword_interpretable_unqualified}'|'${pcre_subword_interpretable_qualified}'|'${pcre_redirect_punctuation}')++'

    #FUXME: Refactor.
    # One or more interpretable syntactic constructs in a shell word excluding
    # "`"-delimited process substitutions *OR* redirections.
    # local pcre_subwords_interpretable_sans_backtick='(?:'${pcre_subword_interpretable_sans_backtick_unqualified}'|'${pcre_subword_sans_backtick_interpretable_qualified}'|'${pcre_redirect_punctuation}')++'

    #FUXME: Define in a similar manner to
    #${pcre_subword_interpretable_with_parens_balanced} above. Can we reuse
    #${pcre_subword_interpretable_sans_qualifier}? We suspect not, but
    #glibly investigate.

    # Sourceable syntactic construct optionally containing strictly balanced
    # braces.
    # local pcre_subword_interpretable_with_parens_braces_balanced=

    #FUXME: Define ${pcre_subword_assignable_with_parens_balanced_sans_qualifier}.
    #FUXME: Define ${pcre_subword_argumenentable_with_parens_balanced}.

    # List assignment-specific syntactic component excluding glob qualifiers,
    # optionally containing strictly balanced parens.
    # local pcre_subword_assignable_with_parens_balanced_sans_qualifier=${pcre_subword_with_parens_balanced_sans_qualifier}'|'${pcre_assignable}

    #FUXME: Hmm. By "argumentable," we do appear to exactly imply
    #"substitutable." As the latter is certainly more descriptive than the
    #former, rename all instances of the former to the latter.

    # ..................{ OBSOLETE                           }..................
    #FUXME: Everything below should arguably be excised now.

    # Shell word component, excluding both "("- and ")"-balanced glob qualifiers
    # and recursively nestable syntactic constructs.
    # local pcre_subword_unqualified=${pcre_chars_nanoword_unquoted_sans_paren_right}'|'${pcre_char_escaped}'|'${pcre_quotes_optional}

    # Substitutable shell word component, excluding "("- and ")"-balanced glob
    # qualifiers.
    # local pcre_subword_passable_unqualified=${pcre_subword_unqualified}'|'${pcre_substitutable}

    # Interpretable shell word component, excluding "("- and ")"-balanced glob
    # qualifiers.
    # local pcre_subword_interpretable_unqualified=${pcre_subword_unqualified}'|'${pcre_interpretable}

    # # List assignment-specific "("- and ")"-balanced glob qualifiers.
    # local pcre_subword_assignable_glob_qualifier=${pcre_qualifier_prefix}${pcre_subword_assignable_with_parens_balanced_sans_qualifier}${pcre_qualifier_suffix}

    #FUXME: Globally rename "word_parenable" to "word_passable"
    #*AFTER* eliminating all "OBSOLETE" subsections above and below.

    #FUXME: Document why the lookahead is more complex than that below --
    #namely, because we need to match "$("- and ")"-delimited process
    #substitutions as command terminators rather than as shell words.
    #FUXME: Hmm; this fails to match "$"-prefixed variable names, which it
    #probably should, since we probably have no other means of matching such
    #names in the context of top-level parsing. Do we?
    #
    #Taken together, this and the prior FUXME suggest that we probably want to
    #suffix the "\$" in such lookahead instead by a single negative character
    #class explicitly preventing matching of process substitutions (and other
    #undesirable syntactic constructs). That addresses both concerns with one
    #single code stone.
    #
    #The question then becomes: exactly which prefixes do we need to prohibit?

    # Substitutable shell word-specific "("- and ")"-balanced glob qualifiers.
    # local pcre_subword_passable_qualified=${pcre_subword_qualified_optional_prefix}${pcre_subword_passable_unqualified}${pcre_subword_qualified_optional_suffix}

    # Interpretable shell word-specific "("- and ")"-balanced glob qualifiers.
    # local pcre_subword_interpretable_qualified=${pcre_subword_qualified_optional_prefix}${pcre_subword_interpretable_unqualified}${pcre_subword_qualified_optional_suffix}

    #FUXME: Directly inline and then excise all such PCREs.
    # One or more argumentable syntactic constructs optionally containing
    # strictly balanced parens.
#     local pcre_subwords_argumentable_with_parens_balanced='(?:'${pcre_subword_argumentable_with_parens_balanced}')++'
# ${pcre_subwords_argumentable_with_parens_balanced}

    # One or more assignable syntactic constructs optionally containing
    # strictly balanced parens.
    # local pcre_subwords_assignable_with_parens_balanced='(?:'${pcre_subword_assignable_with_parens_balanced}')++'

    # One or more interpretable syntactic constructs optionally containing
    # strictly balanced parens.
    # local pcre_subwords_interpretable_with_parens_balanced='(?:'${pcre_subword_interpretable_with_parens_balanced}')++'
    # ${pcre_subwords_interpretable_with_parens_balanced}

    # One or more syntactic constructs optionally containing balanced and/or
    # unbalanced parens.
    # local pcre_subwords_macroable='(?:'${pcre_subword_macroable}')++'
# ${pcre_subwords_macroable}

    #FUXME: Replace *EVERYTHING* below (excluding backticks-style process
    #substitutions, of course) by this single PCRE.

    # Possibly recursively nested process substitution content, omitting
    # prefixing and suffixing delimiters.
    # local pcre_process_parens_body=${pcre_codes_optional}

    # "$("- and ")"-delimited possibly recursively nested process substitution,
    # omitting such delimiters.
    # local pcre_process_substitution_dollar_optional=${pcre_process_parens_body}'\)?+'

    # "=("- and ")"-delimited possibly recursively nested process substitution,
    # implicitly creating and removing temporary files.
    # local pcre_process_substitution_file_optional='=\('${pcre_process_parens_body}'\)?+'

    # "<("- or ">("- and ")"-delimited possibly recursively nested process
    # substitution, also performing redirection.
    # local pcre_process_substitution_redirect_optional='[<>]\('${pcre_process_parens_body}'\)?+'

    #FUXME: The current approach duplicates
    #${pcre_process_parens_body} across numerous PCREs, all of
    #which are identical except for prefixing syntax. The sane thing to do,
    #therefore, is to replace *ALL* PCREs below (including this one) by a
    #minimal number of compact PCREs resembling:
    #
    #    local pcre_process_substitution_parens='[$=<>]\('${pcre_codes_optional}
    #
    #Far simpler. Far faster. For great justice, you know what to do.

    #FUXME: Actually, we *CAN* readily match macros in process substitutions
    #*NOT* nested in double quotes -- implying that the only contexts in which
    #macros are unexpandable are double-quoted process substitutions. That
    #said, the road to matching macros in process substitutions *NOT* nested in
    #double quotes is non-trivial. Why? Because:
    #
    #* When matching macros, we want to search for command terminating
    #  positions and hence possible macros in both the top-level script code
    #  *AND* within all nested syntactic constructs.
    #* After matching a macro name and then when matching macro arguments (both
    #  block and standard), we do *NOT* want to attempt to match additional
    #  nested macros.
    #
    #This implies we need *TWO* variants of each process substitution PCRE. We
    #need the current variant, ignoring macros, for use when matching macro
    #arguments; and we need a new variant -- perhaps suffixed by "_preprocessable"
    #(e.g., ${pcre_process_substitution_dollar_preprocessable}), for use when
    #matching macros.
    #
    #Defining the latter probably implies replacing the ${pcre_codes_optional}
    #in ${pcre_process_substitution_dollar_preprocessable} with ${pcre_macro}
    #instead. Since ${pcre_macro} is quite intricate, however, we probably
    #won't want to repeat its lengthy definition in every process substitution.
    #So, yes: we'll probably want to abstract ${pcre_macro} out into a new
    #subroutine definition -- say, "<mac>".
    #
    #Now, you're probably ruminating: but isn't that inefficient? Well, no. Or,
    #not really, anyway. Process substitutions are infrequently used enough to
    #suggest that there would exist little to no performance penalty.
    #
    #There is, however, a conundrum: captured groups. Subroutine calls unwind
    #groups captured by such call, as the following example demonstrates:
    #
    #    >>> match=(); :is 'yum' =~ 'y(?&ugh)m(?(DEFINE)(?<ugh>(u)))' :si &&
    #    ...     print "${#match}: ${match[*]}" 
    #    0:
    #
    #In this case, that fairly sucks. Any way around that? We reckon not.
    #
    #Oh. Oh, boy. Wait. Yes! Of course there is. Rather than defining
    #${pcre_process_substitution_dollar_preprocessable}, we split a new PCRE 
    #${pcre_process_substitution_dollar_prefix} from the existing
    #${pcre_process_substitution_dollar}: e.g.,
    #
    #    local pcre_process_substitution_dollar_prefix='\$\('
    #
    #Then (and this is the sweet kicker), we match
    #${pcre_process_substitution_dollar_prefix} as an unspaced command
    #terminator! *BAM*. It's simple; it's fast; it requires no significant
    #changes elsewhere. Extend the same technique to every process substitution
    #prefix, and we are comparitively in business.
    #
    #Actually, a few other minor changes will be needed as well.
    #${pcre_code_sans_comment_or_terminator_prefix}, as currently embedded in
    #${pcre_macro}, matches process substitutions. Such PCRE will thus need to
    #be renamed to
    #${pcre_code_sans_comment_or_terminator_prefix_and_process_substitution}.
    #At that point, of course, it would probably be more expedient to list what
    #such PCRE *DOES* match rather than what it doesn't! In any case, such PCRE
    #will probably need to embed either ${pcre_word_passable_with_parens_balanced} or a new
    #${pcre_word_interpretable_sans_process_substitution} in place of the
    #${pcre_word_parenable} such PCRE currently embeds.

# optionally containing balanced and/or
    # unbalanced parens and hence *NOT* matched via the above approach. 
    #FUXME: Add support for parens-balanced qualified subwords.
    # local pcre_subword_interpretable_with_parens_balanced=${pcre_chars_nanoword_unquoted_sans_paren_right}'|'${pcre_char_escaped}'|'${pcre_quotes_optional}'|'${pcre_redirect}'|'${pcre_subword_interpretable_glob_qualifier}'|'${pcre_interpretable}

    #FUXME: Honestly, this strikes us as as extreme overkill. Directly inlining
    #and then excising all such PCREs would almost certainly be to the good.
    #FUXME: Clearly not quite right. Revise according to
    #${pcre_subwords_interpretable_with_parens_balanced}.

    # Zero or more whitespace characters, comments, and/or substitutable shell
    # words optionally containing strictly balanced parens.
    # local pcre_words_argumentable_spaced_with_parens_balanced_or_comments_spaced_optional='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_comment_optional_spaced}')*+'

    #FUXME: O.K.; we can't prefix this by ${pcre_list_assignment_optional}, due
    #to chicken-and-egg issues. Instead, we'll need to manually prefix
    #${pcre_words_interpretable_with_parens_balanced} by
    #"${pcre_list_assignment_optional}|".
    #
    #Actually, that doesn't really work. No, the current approach is sound; we
    #simply need to define *ALL* substitutable word constructs before *ALL*
    #interpretable word constructs, implying a slight restructuring. But that
    #should it.
    #
    #Actually, that's a terrible idea. While it probably *WOULD* work, the core
    #issue here is that treating a list assignment consisting of multiple shell
    #words like a single shell word is fundamentally wrong. So, we *DO* need to
    #revert to the prior conception and prepend
    #"${pcre_list_assignment_optional}'|'" at the highest PCRE level possible.
#
    #FUXME: So, this is clearly munted. What's the best way to restore this?
    #There's no recursive nesting of such assignments, so this should be
    #feasible parseable without much effort. We're inclined to agree with the
    #prior approach: that is, ${pcre_list_assignment_optional} needs to be
    #defined as late (and hence as far below) as possible. That should get us
    #most of the way there, yes?
    # local pcre_subword_passable_unqualified=${pcre_subword_unqualified}'|'${pcre_substitutable}
    # local pcre_subword_passable_qualified=${pcre_subword_qualified_optional_prefix}${pcre_subword_passable_unqualified}${pcre_subword_qualified_optional_suffix}
    # local pcre_subwords_argumentable_spaced_with_parens_balanced='(?:'${pcre_subword_passable_unqualified}'|'${pcre_subword_passable_qualified}')++'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}${pcre_subwords_argumentable_spaced_with_parens_balanced}${pcre_literal_blockable_lookbehind}
    # local pcre_words_argumentable_spaced_with_parens_balanced_or_comments_spaced_optional='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_comment_optional_spaced}')*'

    # While matching "("- and ")"-delimited list assignments is essential to
    # such balancing, the typical chicken-and-egg issues require we defer such
    # inclusion to PCREs embedding this PCRE. *collective shrug*

    #FUXME: This currently fails to match backticks. That appears to be the
    #only significant omission, which is mildly great.
    #FUXME: O.K.; so, we're going to need to split this into two PCREs:
    #
    #1. A PCRE specific to matching macros -- say,
    #   ${pcre_subword_macroable}. The current approach is pretty much
    #   already there. We only need to temporarily match backticks as unquoted
    #   characters. They aren't, of course; but until we at least get double
    #   quotes-embedded process substitutions to work, backticks will have to
    #   take a back seat here. To do so, just match "`[^`]*+`" manually at the
    #   very end of such PCRE and add a FUXME comment reminding ourselves to
    #   eliminate such hackiness at some future date.
    #2. A PCRE specific to matching braces -- say,
    #   ${pcre_subword_interpretable_with_braces_balanced}.

#  To match syntactically
    # valid variable expansions undelimited by "{" and "}" *AND* syntactically
    # invalid "$"-prefixed strings, such syntax is matched optionally.
    #FUXME: Eliminate this PCRE in favor of merely embedding
    #${pcre_codes_optional} directly below.
    # local pcre_macroable='(?=\$(?:[{\[]|\(\())(?&exp)'

    #FUXME: The lookahead strikes us as inherently wrong. Investigate.
    #Shouldn't we simply use a character class, as above and below -- or, if
    #only matching "$"-prefixed constructs, merely a "$"?
    #FUXME: Rather than a mere character class, wouldn't it ultimately 

    #FUXME: Honestly, defining separate ${pcre_subwords_macroable}
    #PCREs strikes us as overkill. Embed such PCREs directly here and then
    #excise such PCREs entirely.

    #FUXME: Uhm; ${pcre_macro_optional} appears to be undefined. Oh, right. The
    #reason why is that macro PCREs are necessarily split up into a prefix and
    #suffix to account for the fact that macro names are dynamically
    #updateable. We'll need to similarly split up the final PCRE below.
    #FUXME: Actually, rather than the current prefix and suffix approach, it
    #would be *MUCH* more sensible to pursue a sprintf()-style approach,
    #whereby we construct a single global embedding an expression resembling
    #"%{macro_names}" or some such, to be dynamically subsequently replaced by the
    #corresponding string at runtime (e.g., "|"-delimited macro names). This is
    #particularly helpful, both for readability and maintainability, as we
    #expect to have at least two such constructs in the future: "|"-delimited
    #macro names *AND* zeshy-specific global alias names.
    #
    #Right. While zsh provides printf() out of the box, there's no sprintf()
    #equivalent. Which is no problem. Simply adopt the Python approach (e.g.,
    #"%{macro_names}" or some such); then, manually search and replace the
    #*FIRST* such string in ${ZESHY__PREPROCESS_PCRE} in ={pcre/pcre}. Simple!

# PCRE prefixing ${ZESHY__PREPROCESS_PCRE} if at least one macro exists. Such prefix
# is constant and hence defined at parcel importation time.
# typeset -g ZESHY__PREPROCESS_PCRE_IF_NONEMPTY_PREFIX

# PCRE suffixing ${ZESHY__PREPROCESS_PCRE} if at least one macro exists. Such suffix
# is constant and hence defined at parcel importation time.
# typeset -g ZESHY__PREPROCESS_PCRE_IF_NONEMPTY_SUFFIX

    #FUXME: Excise ${pcre_spaces_horizontal_grouped_continuable_optional}.
    # Zero or more horizontal whitespace characters *OR* line continuations,
    # capturing the last contiguous run of the former if any.
    # local pcre_spaces_horizontal_grouped_continuable_optional='(?:'${pcre_spaces_horizontal_grouped}'|'${pcre_line_continuation}')*+'

    # local pcre_terminators=${pcre_spaces_horizontal_grouped_continuable_optional}'(?:'${pcre_terminator_unspaced}'|(?(-1)'${pcre_terminator_spaced}'))'${pcre_spaces_horizontal_continuable_optional}${pcre_terminators_spaced_optional}

#, optionally
    # followed by a command terminator requiring either prefixing whitespace or
    # a command terminator *NOT* requiring prefixing whitespace

    #FUXME: Not quite right. We previously matched zero or more whitespace
    #characters suffixing an unspaced command terminator. We no longer do, which
    #is clearly wrong. Why? Because the current approach no longer matches
    #optional whitespace delimiting an unspaced command terminator from the
    #subsequent macro name or shell word.
    #
    #What we *NEED* to do is match such whitespace and, if matched, also
    #optionally match a spaced command terminator. But ${pcre_terminators}
    #already does exactly that, except that it then mandatorily rather
    #optionally matches a command terminator.
    #
    #All of this whitespace matching business suggests, perhaps, that we want
    #something resembling:
    #
    #    local pcre_spaces_horizontal_grouped_continuable_body=${pcre_spaces_horizontal}'|'${pcre_line_continuation}
    #    local pcre_spaces_horizontal_grouped_continuable='(?<spa>(?:'${pcre_spaces_horizontal_grouped_continuable_body}')++)'
    #    local pcre_spaces_horizontal_grouped_continuable_optional='(?:'${pcre_spaces_horizontal_grouped_continuable}')?+'
    #
    #Ideally, this should ensure that, wherever
    #${pcre_spaces_horizontal_grouped_continuable_optional} is embedded,
    #either:
    #
    #* One or more horizontal whitespace characters are matched, in which case
    #  group "<spa>" is non-empty.
    #* No such characters are matched, in which case group "<spa>" is empty.
    #
    #In the latter case, what does logic of the form "(?<spa>A|B)" do? Does it
    #attempt to match "B" rather than "A"? Do we need to use the "libpcre"
    #directive "THEN", finally?
    #
    #Honestly, the above approach is complex enough that we want to test this
    #manually. What does "libpcre" actually do?
    #
    #Anyway, the whole point of this is that we should be able to embed a
    #single PCRE ${pcre_spaces_horizontal_grouped_continuable} or
    #${pcre_spaces_horizontal_grouped_continuable_optional} as appropriate
    #wherever we currently attempt to match horizontal whitespace by other
    #means. That, in turn, will ensure that group "<spa>" is available for
    #subsequent testing. While we suspect this can be made to work, there exist
    #a few gotchas:
    #
    #* We have to make sure that "<spa>" resets on every attempt to match such
    #  group, rather than "remembering" prior successful match attempts.
    #
    #Curiously, the "libpcre" documentation reads as follows:
    #
    #    "If you use a named reference in a condition test (see the section
    #     about conditions below), either to check whether a subpattern has
    #     matched, or to check for recursion, all subpatterns with the same name
    #     are  tested.  If  the condition is true for any one of them, the
    #     overall condition is true."
    #
    #Oh, blast it. This *WOULD* work, except that we'd need to set the
    #"PCRE_DUPNAMES" PCRE-compile-time option, except that we can't do that, as
    #pcre_compile() accepts no corresponding flag *AND* as "man pcrepattern"
    #shows that there exists no corresponding start-of-pattern item (e.g.,
    #as is the case for "(*BSR_ANYCLRF)"). This means, in turn, that we'll
    #either need to accept some measure of backtracking and complexity *OR*
    #we'll need to capture such whitespace into uniquely named groups and then
    #test all such groups. (Yeah; that sucks.)
    #
    #Given these constraints, we're definitely trending toward the former. But
    #give it all a wee more contemplation, shall we?
    #
    #Right. So, the latter is certainly feasible, as the following examples
    #shows:
    #
    #    >>> :is 'o;' =~ '^(?<za>d)?+(?<zb>o)?+(?:(?(<za>);)|(?(<zb>);)|,)$' :si :and print ok
    #    ok
    #    >>> :is 'd;' =~ '^(?<za>d)?+(?<zb>o)?+(?:(?(<za>);)|(?(<zb>);)|,)$' :si :and print ok
    #    ok
    #
    #That said, since we can't test multiple named subpatterns at a time, the
    #resulting syntax is insanely oververbose -- and the whole thing just feels
    #kludgy enough to fall over breathless at any moment. So, let's drop such
    #silliness and match suffixing whitespace manually here. Note that we
    #already match vertical whitespace appropriately; it's the optional
    #suffixing horizontal whitespace interspersed by line continuations and all
    #optionally followed by a spaced command terminator that we need to handle.
    #The difficulty here, of course, is that that process could be repeated
    #indefinitely, suggesting subtler pain. But there's really no alternative.
    #Hmm. Actually, one simple approach could be to define a new PCRE
    #${pcre_terminators} and replace all current use of ${pcre_terminators} by
    #that PCRE instead: e.g.,
    #
    #    local pcre_terminators='(?:'${pcre_terminators}')++'${pcre_spaces_horizontal_continuable_optional}
    #
    #Rather simple. Slight backtracking insofar as whitespace is concerned,
    #but... meh. We could presumably do much better if we had access to the
    #full "libpcre" API. But we don't, so here we are. (Something is better than
    #nothing, right?)
    #FUXME: Actually, we've corrected this without such shenanigans. Yay!

    # One or more vertical whitespace command terminators optionally followed
    # by a command terminator requiring prefixing whitespace.
    # local pcre_terminator_spaces_vertical=${pcre_spaces_vertical}${pcre_terminators_spaced_optional}

    #O.K.; hmm, despite the syntactic shenanigans involved, perhaps we *DO*
    #just need to match d

    #    local pcre_spaces_horizontal_grouped_continuable_optional='(?:(?<spa>'${pcre_spaces_horizontal}')|'${pcre_line_continuation}')*+'
    #
    #Or perhaps, if the above fails (which, increasingly, it intuitively
    #appears that it will):

    #FUXME: Insufficient. All such terminators *MUST* be suffixed by at least
    #one whitespace character (either horizontal or vertical) optionally
    #prefixed by one or more line continuations. Consuming a horizontal
    #whitespace character is trivial. However, is consuming a vertical
    #whitespace character entirely safe? Well, yes. Almost certainly. So just
    #consume both. Yay!

    # zeshy-specific command terminators, prefixed by one or more shell-words
    # and suffixed by one or more whitespace characters optionally interspersed
    # with line continuations. Since numerous syntactic constructs are matched
    # by consuming prefixing whitespace, such whitespace *MUST* be non-
    # consumptively detected with positive lookahead.
    # local pcre_terminator_zeshy=':(?:or|and|not)(?='${pcre_space_horizontal_continuable}')'

    #FUXME: We need to match *SOME* unbalanced syntactic suffixes here (e.g.,
    #")", "}"). We do currently match "}", but what about ")"? The difficulty
    #with matching ")", of course, is that we need to only match ")" as a
    #last-ditch fallback to prevent subsequent attempts to match ")" as a
    #balanced syntactic delimiter from failing. So, how do we do that? Hmm.
    #Actually, matching ")" here would probably be fine, if we note that in the
    #variable name.
    #
    #That said, we'll need to avoid using this PCRE in process substitutions,
    #where an unbalanced ")" must *ABSOLUTELY* not be matched by the embedded
    #PCRE. So, perhaps we want to rename these PCREs to
    #${pcre_code_sans_comment_or_terminator_or_paren_right_prefix_*}
    #(which, while crazy, is unambiguously descriptive, which takes precedence)
    #and then define a new PCRE
    #${pcre_code_sans_comment_or_terminator} explicitly matching ")" as well.
    #Naturally, the latter should be used in ${pcre_macro}. Nice, eh?
    #FUXME: The above suggests we should just omit "(" and ")" from a new
    #negative character class -- say, ${char_sans_word_macroable} or some such.
    #In such case, we can efficiently omit both
    #${pcre_list_assignment_optional} *AND* the qualified (i.e.,
    #"("- and ")"-balanced) variant of such PCRE from ${pcre_code_preprocessable}.
    #Which is great! Of course, process substitutions still require the current
    #version of ${pcre_code} matching such constructs. Right; in terms of clear
    #nomenclature, perhaps we want:
    #
    #* A new PCRE ${pcre_code_with_parens_arbitrary}, matching arbitrary "("
    #  and ")".
    #
    #* A PCRE ${pcre_code_with_parens_balanced}, matching only balanced "("
    #  and ")". Hence, rename ${pcre_code} to
    #  ${pcre_code_with_parens_balanced}.
    #
    #Sensible, yes? Actually, how about just ${pcre_words_macroable}. Let's face it:
    #this PCRE is specific to matching non-macro syntactic constructs. That's
    #all it will ever do, and that's all it *SHOULD* ever do.

    #FUXME: Define ${pcre_char_not_terminator}: e.g.,
    #
    #    # Is this sufficient? No idea.
    #    local char_not_terminator=':'${char_terminator}
    #    local pcre_char_not_terminator='[^'${char_not_terminator}']
    #
    #That said, does this definition suffice to ensure that
    #${pcre_codes_or_chars_not_terminator_optional} *NEVER* matches command
    #terminators? Probably not. While ${pcre_macro} is *GUARANTEED* not to
    #match any command terminator (by constraints imposed by ={frontend}), no
    #such constraints apply to ${pcre_char_not_terminator}. Hmm.
    #
    #O.K.; the current ${pcre_char_not_terminator} is a poor idea. It simply
    #matches *TOO* match. Moreover, since ${pcre_code} already matches all
    #unquoted non-shell-reserved characters, we need to merely match all
    #unquoted shell-reserved characters that are *NOT* command terminators
    #here. That means something like:
    #
    #    #FIXME: No idea what ${char_not_literal_or_terminator}
    #    #should like like. Examine existing character classes for inspiration.
    #    #Assuming ${pcre_subword_unquoted} matches everything it should, it's
    #    #unclear whether any other non-terminating shell-reserved characters
    #    #not already matched by ${pcre_subword_unquoted} exist. Is "}" really
    #    #it? That'd be great, if so.
    #    local char_not_literal_or_terminator=${char_space_horizontal}'}'
    #    local pcre_chars_not_subword_unquoted_or_terminator='[^'${char_not_literal_or_terminator}']++

    #FUXME: Actually, having ${char_not_literal_or_terminator} match
    #horizontal whitespace is hardly ideal. Here's what we should do instead:
    #
    #* Explicitly match one or more horizontal whitespace characters as an
    #  additional alternative below.
    #* Such match should be followed by negative lookahead preventing such
    #  whitespace from being matched when followed by a command terminator.
    #  Fortunately, we've already implemented such lookahead -- it just happens
    #  to be in the wrong place! Shift negative lookahead matching whitespace-
    #  prefixed command terminators from ${pcre_word_parenable} to here.
    #FUXME: Right. So, we actually no longer need
    #${char_not_literal_or_terminator} at all, assuming we:
    #
    #* Implement the prior solution regarding horizontal whitespace.
    #* Create a new PCRE ${pcre_word_interpretable_sans_lookbehind}, foregoing
    #  the negative lookbehind suffixing ${pcre_word_parenable}.
    #* Rename the existing ${pcre_code} to ${pcre_code_sans_block_suffix}.
    #* Create a new ${pcre_code} embedding
    #  ${pcre_word_interpretable_sans_lookbehind} rather than 
    #  ${pcre_word_parenable}.
    #
    #That takes care of "}", the last remaining issue relating to
    #shell-reserved characters. (We innocently believe, anyway!)
    #FUXME: O.K.; the above whitespace solution *WOULD* theoretically work, at
    #a cost of imposing mandatory backtracking on every command terminator
    #necessarily prefixed by whitespace, which is unfortunate. An alternative
    #is as follows:
    #
    #* Immediately after matching ${pcre_continuable_spaces_horizontal}, optionally match a
    #  space-prefixed command terminator. For subsequent detection, capture
    #  such terminator with a named (?) group -- say, "<term>".
    #* Replace the current use of ${pcre_terminators} below with:
    #  '(?(<term>)|'${pcre_terminator_unspaced}')'
    #
    #Wait. That *WOULD* work, except that we have no way of clearing the named
    #group"<term>" after its detection in such conditional pattern. That said,
    #we can account for this as well with empty groups in prior alternatives:
    #e.g.,
    #
    #    local pcre_codes_or_macros='(?:(?|'${pcre_macro}${pcre_empty_group}'|'${pcre_code}${pcre_empty_group}'|'${pcre_continuable_spaces_horizontal}'('${pcre_terminator_spaced}'))(?(-1)|'${pcre_terminator_unspaced}')*'
    #
    #Reasonably clever, no?

    #FUXME: Ugh. There's a slight conflict between attempting to match
    #${pcre_continuable_spaces_horizontal} and matching ${pcre_char_escaped} in
    #${pcre_code}: line continuations. Contemplate. Wait! No, there's no
    #conflict, as ${pcre_continuable_spaces_horizontal} matches greedily. That
    #said, since we don't need to match prefixing line continuations here,
    #${pcre_continuable_spaces_horizontal} is overkill. We only require the
    #portion of that PCRE *AFTER* matching optional prefixing line
    #continuations. Since we do that elsewhere as well, we'll probably want to
    #abstract the desired match into a new PCRE above.
    #FUXME: Document the usage of empty groups below. This is fairly important.
    #FUXME: Excise ${pcre_terminator_spaced} and rename
    #${pcre_terminator_spaced_body} to ${pcre_terminator_spaced}.
    # local pcre_math_test_prefix='\(\('
    # local pcre_process_substitution_equals_prefix='=\('

    # Command terminator *NOT* requiring prefixing whitespace characters,
    # optionally suffixed by one or more horizontal whitespace characters, *OR*
    # the end of such string. While such terminator may be prefixed by
    # whitespace characters, such characters *MUST* be matched by PCREs
    # embedding this PCRE.
    # , optionally suffixed by
    # one or more whitespace characters.
    #FUXME: Suffixing whitespace is probably inappropriate here. See below.
# ${pcre_spaces_horizontal_continuable_optional}

    #FUXME: Then rename ${pcre_macro_terminator} to ${pcre_terminators} and
    #shift above.
    # One or more horizontal whitespace characters optionally interspersed with
    # line continuations optionally followed by a command terminator requiring
    # such whitespace and one or more horizontal whitespace characters.
    #
    # While ${pcre_continuable_spaces_horizontal} *COULD* be employed to match
    # such whitespace, such PCRE unnecessarily matches optional prefixing line
    # continuations already matched by ${pcre_macro_command_optional} and is
    # hence inefficient in this context.

    # local pcre_terminator_spaced=${pcre_spaces_horizontal_continuable}${pcre_terminator_spaced_body}

    #FUXME: The trailing "${pcre_spaces_horizontal_optional}" is unfortunate.
    #Ideally, command terminators should be prefixable by optional whitespace,
    #which would permit us to eliminate use of
    #${pcre_spaces_horizontal_optional} below -- which would be a good thing.

    # local pcre_macro_terminator='(?:'${pcre_spaces_horizontal_continuable}${pcre_terminator_spaced_body}'|'${pcre_terminator_unspaced}')'
    # local pcre_macro_spaces_or_words_optional='(?|'${pcre_spaces_horizontal_grouped}${pcre_line_continuations_spaceable_horizontal_optional}'|'${pcre_word_macroable}${pcre_empty_group}')*+'
    # local pcre_word_macroable_optional='(?:'${pcre_word_macroable}')?'
    # local pcre_macro_optional='(?:'${pcre_macro}')?+'
    # local pcre_macro_suffix_optional='(?|'${pcre_word_macroable_optional}${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}'(?:('${pcre_terminator_spaced_body}')?)*+'
    # ${pcre_terminator_spaced_optional_grouped}'|'${pcre_words_macroable}${pcre_empty_group}')?+'
    # local pcre_terminator_spaced_prefix=${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}
    # local pcre_terminator_spaced_optional=${pcre_terminator_spaced_prefix}'(?:'${pcre_terminator_spaced_body}')?'
    # local pcre_terminator_spaced_optional_grouped=${pcre_terminator_spaced_prefix}'('${pcre_terminator_spaced_body}')?'
    # local pcre_words_macroable=${pcre_word_macroable}'('${pcre_spaces_horizontal}${pcre_word_macroable}')*+'
    # local pcre_macro_suffix_optional='(?|'${pcre_terminator_spaced_optional_grouped}'|'${pcre_words_macroable}${pcre_empty_group}')?+'
    # local pcre_macro_terminator='(?(-1)|'${pcre_terminator_unspaced}')'

    #FUXME: This can be slightly optimized by noting that 
    #FUXME: O.K.; ${pcre_terminator_unspaced} is optionally prefixable by
    #whitespace. Hmm...
    #FUXME: Define ${pcre_spaces_horizontal_grouped_continuable_optional} in a
    #manner ensuring that such group is nonempty if at least one horizontal
    #whitespace character is matched.

    #FUXME: Refactor ${pcre_terminator_spaced_body} appropriately and
    #eliminate related unused PCREs.
    #FUXME: Shift appropriate PCREs above.
    #FUXME: The fact that we match whitespace both here and in ${pcre_macro}
    #guarantees frequent backtracking. To avoid this, this PCRE should be
    #inlined directly into ${pcre_macro} and the prefixing whitespace unified
    #with ${pcre_terminator_spaced_optional}.
    # local pcre_words_macroable=${pcre_word_macroable}'('${pcre_spaces_horizontal}${pcre_word_macroable}')*+'

    # local pcre_terminator_spaced_prefix=${pcre_spaces_horizontal}${pcre_line_continuations_spaceable_horizontal_optional}
    # local pcre_terminator_spaced_optional=${pcre_terminator_spaced_prefix}'(?:'${pcre_terminator_spaced_body}')?'
    # local pcre_terminator_spaced_optional_grouped=${pcre_terminator_spaced_prefix}'('${pcre_terminator_spaced_body}')?'

    # local pcre_spaces_horizontal_grouped='('${pcre_spaces_horizontal}')'
    # local pcre_spaces_horizontal_continuable_after_grouped=${pcre_spaces_horizontal_grouped}${pcre_line_continuations_spaceable_horizontal_optional}

    #FUXME: Not quite. Shell words may only be delimited by whitespace.
    #Otherwise, quite close.

    # Code atom matching all syntactic constructs *NOT* preprocessor macros.

    #FUXME: Define ${pcre_word_macroable} as
    #${pcre_word_interpretable_or_block_suffix}; then excise the latter.
    #FUXME: It seems increasingly likely that ${pcre_here_optional} should be
    #embedded directly into ${pcre_word_macroable}.
    #FUXME: Still not quite right. We want to be able to match macros suffixed
    #by... well, nothing (i.e., the string end optionally preceded by ignorable
    #horizontal whitespace).

    # local pcre_macro_command_optional='(?|'${pcre_macro}${pcre_empty_group}'|'${pcre_empty_group}${pcre_empty_group}'(?:'${pcre_terminator_spaced_optional_grouped}'|'${pcre_codes_sans_comment_or_terminator}${pcre_empty_group}'))?'

#  Since all such constructs
    # are also embeddable, this subroutine matches a proper superset of the set
    # of all constructs matched by the prior subroutine.
# , intended to be called *ONLY*
    # recursively from within such constructs
    #FUXME: Actually define me as above.
    # local pcre_dollar_expansion_optional='(?:\$(?:[{\[]|\(\()'

    #FUXME: Define ${pcre_sourceable_non_macro}.
    #FUXME: Honestly, this variable name is horrid. Does this only match
    #FUXME: ${pcre_terminator_zeshy} defined below.
    #FUXME: ${pcre_comment} must be integrated, probably as below.
    #Actually, comments are almost certainly best matched by integration into
    #${pcre_terminators}. If one considers it, a comment effectively serves as
    #a command terminator. Indeed, contemplation suggests that such an approach
    #yields an optimally efficient match.

    #FUXME: Define me, according to PCREs defined below.
    #FUXME: Define me. Wait. Actually, don't. Excise this.
    # local pcre_code_sans_comment_or_terminator_or_process_substitution

    #FUXME: Rename to ${char_not_literal_with_parens_balanced}. Define
    #in term of a new ${char_not_literal_with_parens_arbitrary}.
    # local char_not_literal_with_parens_balanced=${char_reserved}'''"&()$\\`'

    # Character class matching unconditionally shell-reserved operators (i.e.,
    # ASCII punctuation parsed unconditionally, typically terminating the prior
    # command). This class omits conditionally shell-reserved operators (e.g.,
    # "{" and "#", only shell-reserved when the first characters of unquoted
    # shell words).

    # Since "#", "{", and "}" are only conditionally shell-reserved *AND* since
    # "*", "!", "^", and "?" have no bearing on preprocessor parsing (despite
    # being shell-reserved characters), this class excludes such characters.
    # Conversely, since "(" and ")" are *ALWAYS* shell-reserved but permitted
    # in unquoted shell words when strictly balanced (e.g., "like(this)" but
    # not "like(this("), this class includes such characters. Specifically:
    #
    # * "#" and "{" are only shell-reserved when preceded by either the start
    #   of a line *OR* horizontal whitespace.
    # * "}" only shell-reserved when followed by either the end of a line *OR*
    #   horizontal whitespace.
    #
    # This class should *ONLY* be used in negative character classes below.
    #FUXME: This suggests that these character classes may be profitable merged.
    #FUXME: By inspection of the classes embedding this class, can we add any
    #additional characters to this class?
    # local char_reserved=${char_space}'''"$&;\\<>|`'

    #FUXME: zsh actually permits "!" and "#" to be configured via string global
    #${histchars}. We'll need to replace our current hard-coding of "!" and "#"
    #with an expansion of such global here, taking care to prefix characters
    #requiring escaping in character classes with "\" (i.e., "^", "]", "-",
    #"\", ... any others?).

    #FUXME: This is also not necessarily a good idea. The only true
    #single-character command terminators are vertical whitespace and ";".
    #Everything else is more syntactically nuanced. We should *NEVER* use this
    #class except in a negative context to avoid matching command terminators.
    #Is that the case? Indeed, can we not eliminate this class entirely by
    #merging its contents wherever needed? Alternately, can we not rename this
    #class to reflect its confinement to negative character classes only?

#  signifying
    # "&", which in the case of "&&" signifies a shell-reserved operator while
    # "&>" is not
    # multi-character operators (e.g.,
    #
    # *NOT* suffice to match all possible command terminators.
    # For example, since "&&" is a two-character command terminator while "&>"
    # is not, this class excludes "&".
    # single-character command terminators (i.e.,
    # ASCII punctuation unconditionally terminating the preceding command).
    # This class does *NOT* suffice to match all possible command terminators.
    # For example, since "&&" is a two-character command terminator while "&>"
    # is not, this class excludes "&".

    # single-character command terminators (i.e.,
    # ASCII punctuation unconditionally terminating the preceding command).
    # This class does *NOT* suffice to match all possible command terminators.
    # For example, since "&&" is a two-character command terminator while "&>"
    # is not, this class excludes "&".

    # corresponding  are only  require double quotes-style .

    # local pcre_math_substitution_braces_optional='\[(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}'|[^\]])*+\]?+'
    # local pcre_var_expansion_optional='\{(?:[^}'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|'${pcre_embeddable_or_char_escaped}'|[^}])*+\}?+'
    # local pcre_process_substitution_backtick='`(?:'${pcre_code_sans_backtick}'|[^`])*+`?'

    #FUXME: Matching ${pcre_spaces_horizontal_continuable_optional} here
    #strikes us as qu
    # local pcre_here_string_prefix='<'${pcre_spaces_horizontal_continuable_optional}

    # "{" block prefix. Technically, such prefix *MUST* be prefixed by either
    # horizontal or vertical whitespace when preceded by characters that are
    # *NOT* unspaced command terminators (e.g., "if { true } {"). Since shell
    # word-specific negative lookahead prevents such words from matching "{",
    # however, such technicalities are ignorable.
    # local pcre_terminator_block_prefix=${pcre_char_block_prefix}

    # ";" command terminator, terminating the prior command without
    # introducing additional semantics (e.g., piping, redirection).
    # local pcre_terminator_semicolon=';'

    #Since subroutines unwind captured groups, we (probably!) do *NOT* want to
    #call such subroutine 
    #
    #Now, you're probably ruminating: but isn

    #FUXME: We currently fail to match macros in process substitutions (and
    #possibly other syntactic constructs). There exists a difficulty here:
    #
    #* When matching macros, we want to search for command terminating
    #  positions and hence possible macros in both the top-level script code
    #  *AND* within all nested syntactic constructs.
    #* After matching a macro name and then when matching macro arguments (both
    #  block and standard), we do *NOT* want to attempt to match additional
    #  nested macros.
    #
    #This implies we need *TWO* variants for each such syntactic construct. We
    #need the current variant, ignoring macros, for use when matching macro
    #arguments; and we need a new variant -- perhaps suffixed by "_preprocessable"
    #(e.g., ${pcre_process_substitution_dollar_preprocessable}). That said, defining
    #the latter will prove exceedingly tricky. Do we perhaps want to embed
    #${pcre_macro} directly in ${pcre_process_substitution_dollar_preprocessable}
    #instead of ${pcre_codes_optional}?
    #
    #Oh, wait. This again raises the tricky subject of how we resume PCRE-based
    #iteration after handling a matched nested macro. For example, we
    #currently fail to match syntactic suffixes (e.g., "}", ")") unless
    #balanced. Actually, that's a bit of a concern. We need to match unbalanced
    #suffixes *ANYWAY*, but only as a fallback. Hmm.

    # iteration matching PCRE-based preprocessing effectively prohibits this.
    #resume PCRE-based iteration after handling a matched nested macro

    #FUXME: Hmm. In process substitutions, don't we also want ${pcre_code} to
    #match "{" block prefixes? Such characters appear to be unmatched, at the
    #moment! Investigate mildly deeper.

    #FUXME: A bit of a muntup, here. As the name suggests,
    #${pcre_chars_terminator_not_code_prefix} matches command terminators
    #-- which is exactly what we *DON'T* want ${pcre_codes} to match when
    #embedded in ${pcre_macro_command_optional}. Perhaps we want to fashion a
    #new PCRE ${pcre_codes_sans_terminator} to be embedded in
    #${pcre_macro_command_optional} instead?
    #FUXME: Actually, we want a new PCRE
    #${pcre_codes_sans_comment_or_terminator}. A bit wordy, but there you
    #are. This implies we'll also need to refactor
    #${pcre_macro_command_optional} in terms of comments -- or perhaps not?

    # Ideally, this PCRE would match comments. Since comments require prefixing
    # whitespace more efficiently matched together with similar prefixing
    # whitespace required by other syntactic constructs (e.g., block
    # arguments), however, comments are best matched explicitly by each PCRE
    # below embedding this PCRE.

    # one:
    #
    # * A list assignment.
    # * A shell word.
    # * A here-document or -string.
    # * One or more command terminators *NOT* prefixing (and hence conflicting
    #   with) syntactic constructs.
    #
    # Since list assignments are prefixed by variable names indistinguishable
    # from (and hence conflicting with) unquoted shell words, the former *MUST*
    # be matched before the latter.
    #
    # Since the "<" of the "<("- and ")"-delimited process substitution matched
    # in shell words conflicts with the "<" unconditionally matched in
    # here-documents or -string prefixes, the former *MUST* be matched first.
    #
    # Ideally, this PCRE would match comments. Since comments require prefixing
    # whitespace more efficiently matched together with similar prefixing
    # whitespace required by other syntactic constructs (e.g., block
    # arguments), however, comments are best matched explicitly by each PCRE
    # below embedding this PCRE.

    #FUXME: A bit of a muntup, here. As the name suggests,
    #${pcre_chars_terminator_not_code_prefix} matches command terminators
    #-- which is exactly what we *DON'T* want ${pcre_codes} to match when
    #embedded in ${pcre_macro_command_optional}. Perhaps we want to fashion a
    #new PCRE ${pcre_codes_sans_terminator} to be embedded in
    #${pcre_macro_command_optional} instead?

    # local pcre_code_sans_comment_prefix=${pcre_chars_terminator_not_code_prefix}'|'${pcre_list_assignment_optional}'|'
    # local pcre_code_sans_comment_suffix='|'${pcre_here_optional}

# delimiting (i.e., neither prefixing nor suffixing)

    #FUXME: For parsing purposes, this class should include ")" (but *NOT*
    #"("). That said, including ")" conflicts with the stated definition of
    #${char_terminator} below. (What's going on here?)

    # local pcre_process_parens_body='(?:'${pcre_code}'|[^)])*+'

    #FUXME: Incorrect. The current definition attempts to erroneously match
    #"=("-style process substitutions in double-quoted strings, which such
    #syntax does *NOT* support. We need to differentiate between such use cases
    #with a new subroutine definition -- say, "<code>" -- matching both
    #"(?&sub)" *AND* the three new process subroutines matched below. "<sub>"
    #should then be reverted to its prior definition below. Note that
    #"(?&code)" should only be called where actually code is permitted (e.g.,
    #process substitutions, block arguments, shell words).

    #FUXME: Is this correct? Double check, please.
    #FUXME: Nope! Since ${pcre_comment} already consumes suffixing
    #vertical whitespace, we'll need to refactor such PCRE... a tad.

    #FUXME: ${pcre_continuable_spaces_horizontal} is overkill here, as it
    #unnecessarily matches prefixing optional line continuations.
    #FUXME: Excise, shifting the suffixing ${pcre_spaces_continuable_optional}
    #back onto ${pcre_terminator_unspaced} and ${pcre_terminator_spaced}.
    #Assuming we adopt the refactoring below, this will no longer be used.

    # Command terminator (i.e., substring terminating the command preceding
    # such terminator), optionally suffixed by one or more whitespace
    # characters. Such terminators necessarily precede preprocessor macros and
    # hence *MUST* be matched with syntactic accuracy.
    # local pcre_terminators='(?:'${pcre_terminator_unspaced}'|'${pcre_terminator_spaced}')'${pcre_spaces_continuable_optional}

    # Code atom, excluding "}" block suffixes.
    # local pcre_code_sans_block_suffix=${pcre_code_prefix}'|'${pcre_word_parenable}'|'${pcre_code_suffix}

    # Code atom *OR* block suffix "}". The latter is matched by omitting the
    # customary negative lookbehind from interpretable shell words preventing
    # such suffix from being matched as such a word.

#-- namely, only those
    # connoting no additional semantics (i.e., newline, ";"); all others are

    # Technically, only *SOME* such terminators are prefixable by both vertical
    # and horizontal whitespace characters in a syntactically valid manner
    # (e.g., the "{" block prefix); all others are prefixable only by either
    # vertical or horizontal whitespace characters but not both in a
    # syntactically valid manner (e.g., the ":and" and ":or" boolean
    # operators). Likewise, only a proper subset of command terminators are

#  already
    # match such characters. Do *NOT* do so here (e.g., by prefixing this PCRE
    # by ${pcre_spaces_continuable_optional})
    #FUXME: Insufficient. Such terminators may *ALSO* be preceded by vertical
    #whitespace characters. Since such characters are themselves command
    #terminators, however, a bit of subtlety will be required. Namely, after
    #matching any vertical whitespace character in
    #${pcre_terminator_unspaced}, we'll also need to optionally match
    #${pcre_terminator_spaced_body}.

    #FUXME: Actually use below in lieu of current start-of-line-based parsing
    #of macro prefixes.

    #FUXME: Not quite right. While zeshy-specific command terminators *DO*
    #require prefixing whitespace, "{" doesn't. "{" may appear anywhere
    #*OUTSIDE* of a shell word, regardless of surrounding whitespace.

    # Block prefix prefixed by one or more whitespace characters optionally
    # interspersed with line continuations.
    # local pcre_terminator_block_prefix=${pcre_char_block_prefix}

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations all optionally followed by a command terminator
    # requiring such whitespace, capturing such command terminator if any.

    #FUXME: Prefix ${pcre_terminator_spaced_grouped} by
    #${pcre_continuable_spaces_horizontal}, excising the latter below.
    # local pcre_terminator_spaced='(?:'${pcre_continuable_spaces_horizontal}'|'${pcre_subject_start}')(?:'${pcre_terminator_block_prefix}'|'${pcre_terminator_zeshy}')'

    #FUXME: Embed a new ${pcre_terminator_spaced_grouped} below.
    # local pcre_codes_or_chars_not_terminator_optional='(?:'${pcre_code}'|'${pcre_chars_not_subword_unquoted_or_terminator}')*'
    # local pcre_codes_or_macros='(?:(?:'${pcre_macro}'|'${pcre_codes_or_chars_not_terminator_optional}')'${pcre_terminators}')*'

    # Substitutable shell word signifying an argument passed to a macro,
    # comprising all syntactic constructs except redirections. Technically, zsh
    # permits redirections to be arbitrarily interspersed with arguments passed
    # to conventional builtins, commands, or functions: e.g.,
# and hence
    # comprising all syntactic constructs except redirections
# from match -specific lookbehind
    # preventing such words from matching the . Equivalently,
    # code atom *OR* such suffix
    #FUXME: Tangentially relatedly, does ${pcre_subword_unquoted} permit:
    #
    #* All characters to be "*", "!", "^", "?" and other shell-reserved
    #  punctuation of no consequence to preprocessor parsing?
    #* All characters *EXCEPT* the first to be "#"?
    #
    #It should probably permit all such cases. Double check, please.

    #FUXME: Since both ${pcre_terminator_unspaced} and
    #${pcre_terminator_spaced} match prefixing whitespace (albeit the former
    #optional and the latter mandatory), we can probably optimize such matching
    #by extracting out the optional portions from both into
    #${pcre_terminators}: namely, the matching of optional prefixing line
    #continuations. Is that it? Well, something is something.

    #FUXME: Actually, forego that. Since shell words require prefixing
    #whitespace, we'll be combining ${pcre_terminator_spaced} with
    #${pcre_word_parenable} at some point to match any syntactic construct
    #necessarily prefixed by whitespace, implying that we'll probably be
    #removing ${pcre_terminators} at some point as well. *shrug*

    #FUXME: Fairly certain we can also omit both
    #${pcre_terminator_block_prefix} and ${pcre_terminator_zeshy}, under the
    #condition that we attempt to match command terminators *BEFORE* matching
    #shell words. (Which we absolutely *SHOULD* do, as command terminators take
    #precedence.) Assuming this is the case, omit such PCREs below below and
    #comment on why above.

    #FUXME: ${pcre_codes_or_chars_not_terminator_optional} is probably *VERY*
    #close, but not quite cigar. Matching horizontal whitespace conflicts with
    #${pcre_terminators} needing to match prefixing whitespace before certain
    #substrings (e.g., "{", ":or"). Contemplate.

    # local pcre_word_unquoted_char='[^'${char_not_literal_with_parens_balanced}']'
    # local pcre_chars_nanoword_unquoted_sans_paren_right=${pcre_word_unquoted_char}'++'

    #FUXME: The command terminator(s) that terminate macros must *NOT* be
    #consumed by such macros -- or, if they are consumed, must be effectively
    #*NOT* consumed by adjusting the last byte of such macro in the
    #preprocessor.  Why? Because: if a macro is immediately followed by another
    #macro (perfectly valid, of course), the latter is only matchable by
    #matching the command terminator terminating the former, implying the
    #former must *NOT* consume such terminator. (In any case, negative
    #lookahead could always guarantee this.)
    #
    #Actually, the above is absurdly incorrect.

    #FUXME: Horribly wrong, really. How wrong, it's somewhat difficult to say.
    #But, really! ${pcre_code_or_chars_not_terminator} may not be the best
    #idea. 
    # local pcre_process_substitution_backtick='`(?:'${pcre_chars_not_code_prefix}'|'${pcre_comment_optional_spaced}'|'${pcre_char_escaped}'|'${pcre_here}'|(?!`)(?:'${pcre_substitutable_or_quotes}'|.))*`'
    #FUXME: Define ${chars_not_terminator}.
    # Code atom *OR* one or more characters excluding syntactic prefixes.
    # local pcre_code_or_chars_not_terminator='(?:'${pcre_code}'|'${chars_not_terminator}')'

    #FUXME: We want to preferentially match shell words as macro names rather
    #than as mere shell words. To effect this, we use non-greedy quantifier "*?"
    #below.  Does this actually have the intended effect, however? We could,
    #alternatively, add negative lookahead to ${pcre_word_parenable}
    #preventing such PCRE from matching macro names. Hmm. There must be a
    #better way. Contemplate.
    #
    #O.K.; how about this:
    #
    #
    #This leverages ${pcre_codes_or_chars_not_terminator_optional} defined
    #below, while replacing ${pcre_code_nonmacro} (which may now be excised).
    # local pcre_code_nonmacro='(?:'${pcre_codes_or_chars_not_terminator_optional}${pcre_terminators}')*?'${pcre_spaces_continuable_optional}

    #* ${pcre_code_or_chars_not_terminator} doesn't exist. It probably should.
    #  Such PCRE should clearly 

    #* ${pcre_words_interpretable_optional} should be replaced below by a new PCRE
    #  ${pcre_codes_or_chars_not_terminator_optional}. Such PCRE sh ${pcre_word_parenable}

    #FUXME: Actually use below in lieu of current start-of-line-based parsing
    #of macro prefixes.
    #FUXME: O.K.; so, *ALL* command terminators may be suffixed by newline
    #and optional horizontal whitespace. Some, however, may also be optionally
    #suffixed by one or more semicolons -- including semicolon and vertical
    #whitespace terminators.

    #FUXME: Excise, appending the suffixing
    #${pcre_spaces_continuable_optional} directly onto... what? Well, we
    #suppose we need... Hmm. Right. Probably directly onto
    #${pcre_terminator_spaced} and ${pcre_terminator_unspaced} for now, we
    #should think.

    # One or more command terminators. Technically, only a proper subset of
    # command terminators are repeatable -- namely, only those connoting no
    # additional semantics (i.e., newline, ";"). All others are *NOT*
    # repeatable (e.g., "|| ||"). Nonetheless, preprocessor parsing is largely
    # unconcerned with the syntactic validity of non-macros. Hence, ignoring
    # such technicalities here is appropriate.
    # local pcre_commands_end_optional='(?:'${pcre_terminators}')*'${pcre_spaces_continuable_optional}

#  Nonetheless, preprocessor parsing is largely
    # unconcerned with the syntactic validity of non-macros. Hence, ignoring
    # such technicalities here is appropriate.

    #FUXME: While matching suffixing whitespace *IS* great, it also conflicts
    #with matching prefixing whitespace. We need to rethink this. We should
    #probably shift ${pcre_spaces_continuable_optional} into
    #${pcre_commands_end_optional} instead, where we can ensure that such
    #whitespace is consumed only after all command terminators have been
    #matched.

    #FUXME: Optimize. Substrings prefixed or suffixed by mandatory whitespace
    #should be grouped together.

    #FUXME: Actually use ${char_not_substitutable_prefix} and
    #${char_not_interpretable_prefix}. Perhaps we no longer require either? In
    #which case, we probably know what to do.
    # local char_not_substitutable_prefix=${char_substitutable_prefix}'\\'
    # local char_not_interpretable_prefix=${char_interpretable}'\\'

    #FUXME: This should go away, once we refactor backticks.
    #FUXME: Refactor in favor of the ${pcre_process_parens_body}
    #approach, at which point we can excise a number of PCREs above (e.g.,
    #${pcre_chars_not_code_prefix}, ${pcre_substitutable_or_quotes}).
    #FUXME: O.K.; to implement this sanely, we really need to concoct a new
    #PCRE local ${pcre_word_sans_backticks} above. While doing so is trivially
    #simple (i.e., by prefixing "(?&sub)" by "(?!`)"), properly incorporating
    #such PCRE here will require concocting a chain of PCREs equivalent to the
    #current ${pcre_code} -- namely, a new PCRE local
    #${pcre_code_sans_backticks}. This is annoyingly unavoidable, we're afraid.

    #FUXME: Actually use.
    #FUXME: Replace ${pcre_chars_terminator_not_code_prefix} with something
    #suitable.
    #FUXME: Excise. We no longer appear to use this anywhere.
    # Command terminator (i.e., character unconditionally terminating the
    # preceding command).
    # local pcre_char_terminator='['${char_terminator}']'

    #FUXME: This should go away, once we refactor backticks.
    #FUXME: Now that we have ${pcre_word_parenable}, this PCRE should
    #probably simply be embedded directly into that PCRE. Examine wherever we
    #currently use ${pcre_word_parenable} to ensure the sanity of this.

    #FUXME: Most uses of this PCRE should probably instead be embedding
    #${pcre_word_parenable}.

    # ..................{ COMMON                             }..................
    #FUXME: Rename to ${ZESHY_VAR_NAME_PCRE}, shift to ={pcre.zy}, and replace
    #all current usage of ${ZESHY_VAR_NAME_GLOB} with ${ZESHY_VAR_NAME_PCRE}.

    # Variable name. See ${ZESHY_VAR_NAME_GLOB}.
    # local pcre_var_name='[a-zA-Z_][a-zA-Z0-9_]*+'

    #FUXME: This is actually broken, now.
    # # Zero or more whitespace characters *OR* line continuations.
    # local pcre_spaces_continuable_optional='(?:(?:'${pcre_spaces}${pcre_line_continuations_optional}')+|'${pcre_line_continuations_spaceable}')'
    #
    # # Zero or more horizontal whitespace characters *OR* line continuations.
    # local pcre_spaces_horizontal_continuable_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    # local pcre_spaces_horizontal_continuable_optional='(?:(?:'${pcre_spaces_horizontal}${pcre_line_continuations_optional}')+|'${pcre_line_continuations_spaceable}')'

    #FUXME: Are either of the following two PCREs frequently used enough to
    #warrant re-optimization? The answer is almost certainly yes, in which case
    #we may want to resurrect the "_by_spaces" and such PCREs.
    # local pcre_spaces_continuable_optional='(?:'${pcre_spaces}'|'${pcre_line_continuation}')*'

    # local pcre_spaces_continuable_optional='(?:'${pcre_spaces}'|'${pcre_line_continuation}')*'

    #FUXME: Actually, is distinguishing between horizontal and vertical
    #whitespace actually helpful here? We suspect not. ":or" always expands to
    #"||" and hence precedes macro expansions, whether such ":or" is
    #syntactically valid or not.

    # Command terminator prefixed by one or more horizontal whitespace
    # characters.
    # local pcre_terminator_spaced_horizontal=${pcre_continuable_spaces_horizontal}'(?:'${pcre_terminator_block_prefix}'|'${pcre_terminator_zeshy}')'

    # Command terminator prefixed by one or more vertical whitespace
    # characters.
    # local pcre_terminator_spaced_vertical=${pcre_continuable_spaces_horizontal}'(?:'${pcre_terminator_block_prefix}')'

    # Block suffix suffixed by one or more whitespace characters optionally
    # interspersed with line continuations. Since suffixing whitespace must
    # *NOT* be consumed, such whitespace is detected via positive lookahead.
    # local pcre_terminator_block_suffix=${pcre_char_block_suffix}'(?='${pcre_line_end_or_space_continuable}')'

    #FUXME: Technically, such syntax conflicts with the same syntax embedded in
    #":is"- and "[["-prefixed tests, implying we'll need to begin matching
    #such tests for disambiguation. Wait! Wait; no! All we have to do is
    #prohibit ${pcre_word_*} from matching such text with negative lookahead...
    #which we should already do, correct? We should make a note where we do so
    #that, since zsh expands global aliases literally globally and hence in
    #":is"- and "[["-prefixed tests, preventing unquoted shell words from
    #containing such aliases suffices (i.e., we needn't actually match ":is"-
    #or "[["-prefixed test syntax).
    #FUXME: Oh, right. We *DEFINITELY* need to match such tests to avoid
    #accidentally matching macro-like unquoted substrings in such tests. (That
    #and the fact that "(("- and "))"-delimited arithmetic tests may contain
    #the left bit shift operator "<<" conflicting with here syntax.)

    #FUXME: Erroneous. PCREs must *NOT* consume suffixing whitespace. Moreover,
    #string end is also an acceptable suffix in this case. We should note that
    #we had an *AWESOME* lookahead solution to this aready. Where'd that go?
    # local pcre_terminator_block_suffix=${pcre_char_block_suffix}${pcre_continuable_spaces}

    #FUXME: This sufficient? Check man pages.
    #FUXME: "&<" or "&>" must both be followed by particular syntax. Match it.
    #FUXME: *WAIT*. Clearly, redirections do *NOT* terminate commands. Indeed,
    #redirections may be freely mixed with standard arguments. Given this,
    #we're inclined to concoct a new PCRE ${pcre_word_parenable} matching
    #*EITHER* a word or redirection. As for backgrounding, well... let's just
    #ignore such syntax for the moment. Probably ignorable? *shrug*
    #FUXME: Wait. Interestingly, backgroundings *DO* terminate the prior
    #command. Long story short, concoct a new PCRE ${pcre_word_parenable}.
    #Ideally, such PCRE would reduce to the current shell word-specific
    #character class but omitting "&". That'd be simple, right? Sure, but it'd
    #also overzealously match "&!" and "&&" and hence be wrong. So, such PCRE
    #*WILL* need to match redirects in a reasonably intelligent fashion. We
    #already match digit-prefixed redirects (...sort of, anyway). Hmm.
    #
    #We don't really care *AT ALL* about matching redirects in a syntactically
    #correct fashion; we merely need to match them in a manner disambiguous
    #from command terminators. Hence, an efficient first implementation might
    #resemble the following:
    #
    #    local pcre_redirect='&[^!&'${char_terminator}']'
    #
    #Excrutiatingly simple, no?
    #
    #The most efficient way to implement ${pcre_word_parenable} would then be
    #by defining a new PCRE ${pcre_subwords_interpretable} as follows:
    #
    #    local pcre_subwords_interpretable='(?:'${pcre_subword_sans_parens}'|'${pcre_subword_parens}'|'${pcre_redirect})+'
    #
    #Then simply define ${pcre_word_parenable} as we define ${pcre_word_passable_with_parens_balanced}.
    #FUXME: Note that the lookahead for ${pcre_word_passable_with_parens_balanced} prohibits
    #redirects from matching. While that *IS* beneficial for preventing macros
    #from being passed redirects interspersed with arguments, that's not
    #terribly beneficial for general-purpose parsing.
    #${pcre_word_parenable} should clearly omit such lookahead.

    #FUXME: Consider renaming to
    #${pcre_words_interpretable_or_comments_spaced_optional} instead and
    #embedding ${pcre_words_interpretable} here instead.

    #FUXME: Incorrect. Must use interpretables rather than substitutables.
    #FUXME: Actually, "<("- and ">)"-prefixed process substitutions are
    #redirections and hence *MUST* be embedded in ${pcre_word_parenable}
    #rather than ${pcre_word_passable_with_parens_balanced}. "=("-prefixed process substitutions are *NOT*
    #redirections and hence applicable here.

    # "=("-, "<("-, *OR* ">("- and ")"-delimited possibly recursively nested
    # process substitution.
    # local pcre_process_substitution_file='[=<>]\('${pcre_process_parens_body}'\)'

    #FUXME: Actually define subroutine call <int> below.
    #FUXME: Also implement:
    #"[["- and "]]"-delimited non-recursive standard test.
    #":is"- and ":si"-delimited non-recursive standard test.

    #FUXME: Why the discrepancy between ${char_not_embeddable_prefix} and
    #${pcre_embeddable_or_char_escaped}? If this is indeed in error, correct elsewhere as well.
    #FUXME: Define all PCREs interpolated into such PCRE.
    #FUXME: Shouldn't this be ${pcre_word_parenable} here?
    #FUXME: Reasonably certain this serves little to no actual purpose. Excise.

    # Redirection prefixed by a file descriptor specified as an integer (e.g.,
    # "1>&2"). Such redirections conflict with unquoted shell word syntax and
    # hence *MUST* be matched for disambiguation. Note that redirections
    # prefixed by file descriptors specified as "{"- and "}"- delimited
    # variable names are prefixed by "{" and hence already prevented from
    # matching unquoted shell word syntax. See section "REDIRECTION" of
    # "man zshexpn".
    # local pcre_redirect_numbered_prefix='[0-9]++&?[<>]'

    #FUXME: Erroneous. Insufficient. Correct to comply with the above syntax.
    # Redirection prefixed by a file descriptor specified as a non-negative
    # integer (e.g., "1>&2").
    # local pcre_redirect_punctuation='<[&>]?|>>?&?[!|]?|&>>?[!|]?'

    #FUXME: Actually use.
# signifying arguments
    # passed to macros
    #FUXME: This sufficient? Check man pages.
    #FUXME: Shift above and actually use below.
    # local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}'(?&var)'${pcre_quotes_double_suffix}
    # Recursively substitutable *OR* quotes syntactic construct.
    # local pcre_sourceable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_substitutable}

    # Character class matching substitutable-reserved characters, including all
    # embeddable-reserved characters as well as:
    #
    # * The "=", "<", and ">" prefixing "=("-, "<("-, and ">("-prefixed
    #   recursive process substitutions respectively.
    #FUXME: Erroneous. "<("-, and ">("-prefixed process substitutions are
    #redirections and hence *MUST* be excluded. Perhaps we want a new local
    #${char_interpretable} comprising *ALL* possible syntactic
    #constructs? That seems reasonably sensible, but contemplate.

    #FUXME: Given that we define ${char_not_embeddable_prefix}, shouldn't we also define ${char_not_embeddable_prefix}?

#(or ${char_syntactic_prefix} -- right,
    #probably the latter) 
    # Here-document or -string prefix "<<" optionally followed by such document
    # in the former case. The here-string prefix greedily overlaps the
    # here-document prefix and hence *MUST* be matched first. To ensure that
    # syntactically invalid syntactic constructs are matched, optionally rather
    # than mandatorily match the here-document argument.
    # local pcre_here=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|(?&here))?'

    #FUXME: Honestly, is any of this optional prefix matching approach
    #essential or even beneficial? Given the increase in complexity (and
    #probably subtle issues) and decrease in intelligibility, we question
    #whether there exists any demonstrable reason to continue doing this.

    #FUXME: Syntactically invalid here-documents should also be matched. Rename
    #${pcre_here} to ${pcre_here} and render all syntax following such
    #prefixing "<<" delimiter to be optional.

    #FUXME: Actually, let's just revert to the prior form. This form fails to
    #match syntactically invalid here-strings (e.g., "<<<&"), which we'd rather
    #match for generality. The prior form is also simpler, which is nice.

    # Here-string.
    # local pcre_here_string='<'${pcre_spaces_horizontal_continuable_optional}${pcre_word_passable_with_parens_balanced}

    #FUXME: Actually, suffixing whitespace must be matched with positive
    #lookahead, instead.

    #FUXME: Inappropriate. *SOME* command terminators may be indefinitely
    #repeated -- perhaps, only those lacking additional semantics (e.g.,
    #vertical whitespace, semicolon)? Others, however, may *NOT* be (e.g.,
    #"||", "&!"). Though, to be fair, do we particularly care

    #FUXME: Actually, suffixing whitespace must be matched with positive
    #lookahead, instead.
    # Since numerous syntactic
    # constructs are matched by consuming prefixing whitespace, avoid consuming
    # such whitespace here with positive lookaheads.

    #FUXME: "[<>]++" is overly simplistic. We need to exclude here-documents.
    # local pcre_redirect_punctuation='&?[<>]++&?[!|]?'

    #FUXME: Insufficient. Since unquoted words prohibit "<" and ">", we also
    #need to match such characters *AND* all other shell-reserved
    #redirection-related characters (e.g., a suffixing optional "!").

    #FUXME: Matching merely ${pcre_char_terminator} does *NOT* suffice here.
    #We need to match ${pcre_terminators}, in which case
    #${pcre_char_terminator} is probably unused and hence excisable.

    #FUXME: This sufficient? Check man pages.
    # Redirection.
    # local pcre_redirect='(?:'${pcre_redirect_numbered}')'
    # One or more redirections.
    # local pcre_redirects='('${pcre_redirect}')+'

    #FUXME: Correct me, please.

    # Redirection prefixed by a file descriptor specified as a non-negative
    # integer (e.g., "1>&2").
    # local pcre_redirect_numbered_prefix='[0-9]++&?[<>]'
    # local pcre_redirect_numbered=${pcre_redirect_numbered_prefix}

    # be disambiguated from command terminators "&" (optionally followed by any
    # single-character command terminator), "&!", and "&&". All other unquoted
    # instances of "&" necessarily 
    #FUXME: Actually, this is not the case. This matches "&z", which clearly is
    #*NOT* a redirection. Optimize.
    # local pcre_redirect_ampersand='&[^!&'${char_terminator}']?'

#  a non-negative integer optionally followed by "&"
    # mandatorily followed by either "<" or ">" and a shell word redirects and
    # hence terminates the preceding command (e.g., "1&>2").
    #
    # Of course, the prior paragraph is a lie: redirections may be freely
    # interspersed with typical command arguments. However, since supporting such
    # uncommon edge cases in the preprocessor would probably prove to be non-
    # trivially expensive, redirections must strictly suffix rather than be
    # freely interspersed with macro arguments.
    #FUXME: Actually, "&" only *CONDITIONALLY* indicates a command terminator.
    #For example, the "&" in "grep &;" is a command terminator, while the "&"
    #in "print ok &>/dev/null" is not. Hence, "&" *MUST* be omitted here.

    #FUXME: This class includes ";" but excludes "\R", which strikes us as
    #quite irrational. If one is included, surely the other must be as well?
    #Certainly, both signify the exact same semantics.

    # local pcre_macro_sans_args_unspaced_lookahead=${pcre_line_end}'|'${pcre_char_terminator}
    # local pcre_macro_sans_args_unspaced='(?='${pcre_macro_sans_args_unspaced_lookahead}'|'${pcre_subject_end}')'

    # Zero or much such constructs.
    # local pcre_subword_sans_parens_optional='(?:'${pcre_subword_sans_parens}')*'

    #FUXME: O.K.; so, we can clearly have zero or more redirections followed by
    #a pipe (e.g., "1>&2 2>&1 |&"), implying we have quite a bit of legwork to
    #run through here.

    # Character class matching ASCII punctuation characters that unconditionally
    # terminate the preceding command in a manner signifying additional
    # semantics (e.g., "|" signifying standard output from the prior command to
    # be piped to standard input of the subsequent command). While most
    # command-terminating characters signify additional semantics, some do not
    # (e.g., newline, ":").

    #FUXME: ${pcre_terminator_boolean_or} overlaps ${pcre_pipe}. Aggregate the
    #two, noting the former *MUST* be matched prior to the latter. Consider
    #something like the following:
    #
    #local pcre_pipe_or_boolean_or='\|[|&]?'

    #FUXME: This no longer strikes us as sufficient. A here-string prefix
    #*MUST* be suffixed by a shell word. For both correctness and efficiency,
    #replace all current uses of this PCRE with ${pcre_here_string}; then,
    #excise this PCRE entirely.

    # Here-document or here-string prefix. Since the latter overlaps the
    # here-document prefix, the former *MUST* be matched first.
    # local pcre_here_doc_or_string_prefix_optional=${pcre_here_prefix}'(?:'${pcre_here_string_prefix}'|(&here))?'

    # Here-string prefix. Since here-strings are syntactically identical to
    # standard arguments (i.e., as one or more shell words) *AND* since
    # subsequent parsing presumably matches such arguments, such prefix is
    # ignorable for most preprocessing purposes. For simplicity, avoid matching
    # the here-string here. Subsequent parsing does so for us.
    # local pcre_here_string_prefix='<'${pcre_spaces_horizontal_continuable_optional}

    #FUXME: This efficiency model should be adopted everywhere we match a
    #syntactic prefix (e.g., "<(", ">)", "=(").
    # local pcre_here=${pcre_here_prefix}'(?:'${pcre_here_string}'|(?&here))'

    #FUXME: We're almost certainly using this is numerous places where we
    #should be using ${pcre_continuable_spaces_horizontal} instead. Examine.
    #FUXME: Honestly. this is a significantly more precise and hence preferable
    #name than ${pcre_continuable_spaces_horizontal}. Assuming this PCRE is used only in this
    #subsection, rename this PCRE something else and rename ${pcre_continuable_spaces_horizontal}
    #to ${pcre_continuable_spaces_horizontal}.
    # One or more horizontal whitespace characters preceded by zero or more
    # line continuations.
    # local pcre_continuable_spaces_horizontal=

    #FUXME: Excise ${pcre_continuable_spaces_horizontal*} PCREs from PCREs below in a similar
    #manner to that accomplished here (which, presumably, works). 

    #FUXME: Err, there *IS* no ${pcre_spaces_horizontal_continuable_optional},
    #at the moment. Do we have something comparable?

    #FUXME: Insufficient. The existing
    #${pcre_line_continuations_spaceable_optional} should be renamed to
    #${pcre_line_continuations_spaceable_horizontal_optional}. Then a new PCRE
    #${pcre_line_continuations_spaceable_optional} should be defined in the
    #expected way and used here.

#  While the here-string prefix "<<<" is ignorable for most
    # preprocessing purposes, here-strings suffixing macros *MUST* be matched
    # in full. Why? Because such here-strings *MUST* be passed on standard
    # input to such macros at expansion time.
    #explicitly match such word and rename this PCRE accordingly. See
    #${pcre_here_string} below.

    #FUXME: Wait. Do we *REALLY* require this? Even here-documents and -strings
    #passed to macros should (arguably) be interpreted and passed to the
    #resulting expansion rather than to the function producing such expansion.
    #Why? Because such here-document or -string could contain process
    #substitutions intended to be evaluated at macro expansion execution time
    #rather than the substantially earlier macro expansion time. Indeed, the
    #current behaviour contravenes basic sensibility.
    #
    #Let's unwind this nonsense, please. Excise *ALL* of the following PCREs
    #and their expansions below.
    # local pcre_here='(?:'${pcre_here}')?'

    #FUXME: Actually, from our perspective, there's not terribly much
    #difference between matching adjacent backticks in an nested recursive
    #manner (as we would by default) or in a non-nested consecutive manner (an
    #we currently attempt to do). Given that, let's defer to the dramatically
    #simpler solution of matching adjacent backticks in a nested recursive
    #manner by refactoring this to exactly resemble the above process
    #substitution syntax.
    #FUXME: Fold ${pcre_list_assignment_optional} directly into
    #${pcre_code_sans_comment}.
    #This is fairly important, as such syntax prohibits syntax otherwise
    #permitted in the parent syntactic construct (e.g., "<("- and ")"-delimited
    #process substitutions).

#  For convenience, prefer this PCRE to
    # ${pcre_word_passable_with_parens_balanced} when matching code constructs.
    #FUXME: Rename to simply ${pcre_code}. Interesting how matters come full
    #circle, isn't it?

    #FUXME: Abstract "'(?:'${pcre_comment}')?" into a new PCRE above.
# ${pcre_chars_not_code_prefix}'|'${pcre_char_escaped}'|'

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing. Since unquoted shell words do *NOT* obstruct such
    # preprocessing, ignore such words. Ideally, such PCRE would match
    # comments. As comments require prefixing whitespace more efficiently
    # matched together with similar prefixing whitespace required by other
    # syntactic constructs (e.g., block arguments), however, comments are best
    # matched explicitly by each PCRE below embedding this PCRE.
    #FUXME: This should be excisable, now. *SHOULD* be.
    # local pcre_code=${pcre_substitutable_or_quotes}'|'${pcre_here_doc_or_string_prefix}

    #FUXME: Replace current use of ${pcre_embeddable_or_char_escaped*} in code contexts below
    #with ${pcre_substitutable_or_quotes}.

    # Recursively embeddable syntactic construct *OR* single- or double-quoted
    # string.
    #FUXME: Hm; shouldn't this be ${pcre_substitutable_or_quotes} everywhere?
    # local pcre_embeddable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}

    # local pcre_code=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here_doc_or_string_prefix}'|'${pcre_embeddable_or_char_escaped}

    # ..................{ FUNCTION                           }..................
    #FUXME: Shift here from ={*-start/*-declare/*-pcre}.
    #FUXME: Actually, this parcel is more than long enough already. We should
    #probably define a new subdirectory tree structure here as follows:
    #
    #    preprocess/
    #        pcre/
    #            macro.zy  # This existing file.
    #            func.zy   # Moved from ={*-soil/*-declare/*-pcre}.
    #
    # We shouldn't need a ={preprocess/pcre/pcre.zy}, but... one never knows.

    # Boolean zsh command terminators.
    # local pcre_boolean_or='\|\|'
    # local pcre_boolean_and='&&'
    # local pcre_boolean=${pcre_terminator_boolean_or}'|'${pcre_terminator_boolean_and}

    #FUXME: Insufficient. May be suffixed by *EITHER* one or more word spaces and/or newlines.

    #FUXME: Shift block delimiters here. Rename ${pcre_char_block_prefix} to
    #${pcre_char_block_prefix}. Define a new ${pcre_char_block_prefix} embedding
    #${pcre_char_block_prefix} prefixed by ${pcre_spaces_word_or_vertical}.

    # Block prefix and suffix. As ${char_not_literal_with_parens_balanced} documents, both
    # conflict with unquoted shell word syntax (which permits such prefix when
    # *NOT* the first character and such suffix when *NOT* the last character
    # of such word) and hence require disambiguation.
    # local pcre_char_block_prefix='\{'
    # local pcre_char_block_suffix='\}'

    # One or more command-specific whitespace sequences (i.e., zero or more
    # non-negligible horizontal whitespace characters or negligible line
    # continuations), prefixed by at least one horizontal whitespace character.
    # While escaped newlines are line continuations preserving the current
    # command and hence effectively whitespace, unprefixed newlines are
    # effectively semicolons terminating such command and hence non-whitespace.
    # local pcre_word_spaces_prefixed_by_spaces_horizontal=${pcre_spaces_horizontal}'(?:'${pcre_line_continuation_spaceable_horizontal}')*'

    # One or more command-specific whitespace sequences. Since line
    # continuations are merely ignorable rather than actual whitespace, such
    # sequences *MUST* include at least one horizontal whitespace character.
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}${pcre_word_spaces_prefixed_by_spaces_horizontal}

    # One or more command-specific whitespace sequences, prefixed by at least
    # one line continuation.
    # local pcre_word_spaces_prefixed_by_line_continuations=${pcre_line_continuations}'(?:'${pcre_continuable_spaces_horizontal}')*'

    # Zero or more command-specific whitespace sequences. Technically, this
    # PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.

    #FUXME: It's not necessarily clear that this is required anywhere outside
    #of here-documents. (Indeed, even here-strings shouldn't require this,
    #since words already match escaped characters and hence line continuations.)
    #In all other cases, ${pcre_spaces_optional} should suffice. Ideally, we
    #should find a way of obsoleting this even in here-documents and then
    #excise this. That, in turn, would permit us to excise
    #${pcre_line_continuation}, which is almost certainly a good thing.
    #FUXME: We should probably refactor this back to its prior version. We use
    #such PCRE sufficiently infrequently (i.e., only in here-documents) that
    #the current approach is extreme overkill. As documented above, this is:
    #
    #     local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'
    #
    #Before we do so, however, we should confirm whether we still need
    #${pcre_continuable_spaces_horizontal} anywhere, which would impact our decision.
    #FUXME: Incidentally, this PCRE has little to nothing to do with shell
    #word-specific whitespace. Rather, it's simply excisable now.
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    #FUXME: Insufficient. Must be preceded by one or more horizontal whitespace
    #characters and (of course) ignorable line continuations.

    #FUXME: Shift above, probably to where we define ${pcre_terminator_zeshy}
    #and such (which should clearly be shifted here).

    #FUXME: Arguably shift
    #"'(?:'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'" to a new PCRE
    #${pcre_words_spaced_optional}.
    # Since block
    # arguments are necessarily prefixed by such whitespace, this PCRE is
    # principally intended to match all standard arguments prefixing a block
    # argument passed to a macro.

    #FUXME: This could be optimized by preventing ${pcre_word_passable_with_parens_balanced} from matching
    #line continuations. In such case, the order of the two alternative choices
    #could be switched, which would be quite desirable. Ignoring that, however,
    #this appears to be feature complete.
    #FUXME: We probably need to ensure everywhere we use ${pcre_word_passable_with_parens_balanced} that
    #we also explicitly match ${pcre_line_continuation_spaceable_horizontal}. Given that,
    #perhaps the latter should be incorporated into the former?
    # local pcre_macro_args_zsh_optional=${pcre_continuable_spaces_horizontal}'(?:'${pcre_line_continuation_spaceable_horizontal}'|'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'

    #FUXME: Eliminate the "_arg" from all PCRE names below.
#this PCRE is guaranteed
    # to *NOT* be preceded by horizontal whitespace *AND* since 
    # If one or more such arguments
    # were passed, such arguments must be preceded by at least one horizontal
    # whitespace character; else, no such arguments were passed, in which case 
    # such macro must either be:
    #
    # * Suffixed by one or more horizontal whitespace characters followed by a
    #   command terminator. Since command terminators are *NOT* valid macro
    #   arguments, ${pcre_macro_args_optional} implicitly halts matching
    #   immediately prior to such terminator.
    # * Suffixed directly by a command terminator. Since
    #   ${pcre_macro_args_optional} only matches when preceded by one or more
    #   horizontal whitespace characters, this case must be explicitly matched.

    #FUXME: No longer quite right. We *REALLY* don't want this to be optional,
    #as the resulting semantics are... wierd, and probably wrong. Instead, we
    #probably need to explicitly match a command terminator here.

    # Zero or more standard or block arguments. If one or more such arguments
    # were passed, such arguments must be preceded by at least one horizontal
    # whitespace character; else, no such arguments were passed, in which case 
    # such macro must either be:
    #
    # * Suffixed by one or more horizontal whitespace characters followed by a
    #   command terminator. Since command terminators are *NOT* valid macro
    #   arguments, ${pcre_macro_args_optional} implicitly halts matching
    #   immediately prior to such terminator.
    # * Suffixed directly by a command terminator. Since
    #   ${pcre_macro_args_optional} only matches when preceded by one or more
    #   horizontal whitespace characters, this case must be explicitly matched.

    #FUXME: No longer quite right. We *REALLY* don't want this to be optional,
    #as the resulting semantics are... wierd, and probably wrong. Instead, we
    #probably need to explicitly match a command terminator here.

    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_spaces_horizontal}${pcre_macro_arg}')*)?'
    # local pcre_macro_body_optional=${pcre_line_continuations_optional}'(?:'${pcre_spaces_horizontal}${pcre_macro_args_optional}'|'${pcre_macro_sans_args}')'

    # Zero or more standard or block arguments, each prefixed by one or more
    # horizontal whitespace characters, optionally followed by a here-document
    # or -string. To ensure that such macro is passed no unmatched
    # syntactically invalid arguments and hence is syntactically valid, such
    # match is anchored to the end of the current line.

    # rather than silently terminating such iteration.
    # Zero or more standard or block arguments optionally followed by a here-
    # document or -string, the end of the current line, *OR* the nonempty
    # remainder of the current line. The latter substring if any is captured,
    # ensuring that syntactically invalid macros are uniquely identifiable by
    # testing whether or not the corresponding match group exists (e.g., by
    # testing the length of canonical list global ${matches}).

#'|'${pcre_macro_args_invalid}'
    # local pcre_chars_sans_space_vertical_grouped='('${pcre_chars_sans_space_vertical}')'
    #FUXME: Erronious. We probably no longer require
    #${pcre_chars_sans_space_vertical_grouped}; instead, refactor this to use
    #${pcre_chars_sans_space_vertical}. Arguably, shift the latter PCRE
    #fragment below to a new PCRE ${pcre_line_optional} above.
    #FUXME: We'll probably also need to define
    #${pcre_chars_sans_space_vertical_optional} above.

    # local pcre_macro_arg_invalid_body_grouped=${pcre_chars_sans_space_vertical_grouped}'{1,3}'
    #FUXME: Document me.

    #FUXME: For error reporting purposes, it would probably be *FAR* more
    #helpful to shift ${pcre_macro_args_invalid} into ${pcre_macro_arg} rather
    #than interpolated below, renaming such PCRE to ${pcre_macro_arg_invalid}:
    #e.g.,
    #
    #    local pcre_macro_arg='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'|'${pcre_macro_arg_invalid}')'
    #
    #For that to work, however, we'll need to append ${pcre_macro_arg_invalid}
    #by ${pcre_report_failure}. Will that suffice to terminate the entire
    #current match, however? Wait. No, we don't want to report failure, as that
    #would unconditionally terminate the current iteration -- at least, as
    #currently implemented. Perhaps append ${pcre_succeed} instead?
    #Since further research is clearly required here, implement such
    #refactoring after we have a tolerable, working first draft.
    #FUXME: Right. Appending ${pcre_succeed} will *DEFINITELY* work, as
    #the PCRE below demonstrates. Let's do this now, yes?

    #FUXME: Ugh! How do we distinguish between a syntactically invalid macro
    #and an argumentless macro suffixed by a command terminator? Argumentative
    #macros suffixed by command terminators are no issue, as in that case at
    #least one argument character will be matched and hence such match group
    #will be nonempty. The only issue is with argumentless macros, as ever. For
    #example:
    #
    #    # Syntactically invalid macro.
    #    :macro uh(oh
    #
    #    # Macro suffixed by a command terminator.
    #    :macro :or true
    #
    #In the former case, ${pcre_chars_sans_space_vertical_grouped} will
    #appropriately be triggered; in the latter case, the same PCRE will be
    #inappropriately triggered. One way of handling this would be to define a
    #PCRE used below in lieu of ${pcre_chars_sans_space_vertical_grouped}:
    #
    #    local pcre_macro_args_invalid='(?!'${pcre_macro_sans_args_lookahead}'|'${pcre_terminator_zeshy}')'${pcre_chars_sans_space_vertical_grouped}
    #
    #We'll need to define ${pcre_terminator_zeshy}, of course. (Didn't we
    #already define a PCRE matching zeshy-specific command terminators?)

# ${pcre_spaces_horizontal_optional}

    #FUXME: Consider replacing ${pcre_continuable_spaces_horizontal} by
    #${pcre_continuable_spaces_horizontal}. (Should work; consider further to
    #ensure success, however.)
    #FUXME: Hmm. Right. O.K.; so, we need to extract
    #${pcre_line_continuations_optional} out as follows.

    # local pcre_macro_sans_args_end=${pcre_spaces_horizontal_optional}'(?:'${pcre_line_end}'|(?='${pcre_char_terminator}'))'

    #FUXME: We increasingly regard the dichotomy between ${pcre_continuable_spaces_horizontal}
    #and ${pcre_spaces_horizontal} as bath false and harmful. Ideally, we
    #shouldn't *NEED* to explicitly match line continuations and hence match
    #${pcre_continuable_spaces_horizontal} at *ALL*. If one considers it, ${pcre_word_unquoted}
    #and hence ${pcre_word_passable_with_parens_balanced} and hence ${pcre_macro_arg} already implicitly
    #matches line continuations.
    #FUXME: No, we can't simply replace ${pcre_continuable_spaces_horizontal} by
    #${pcre_spaces_horizontal} -- at least, not as currently defined. Why?
    #Because doing so would fail to match ":macro a \
    #b". Wait; no, that would still be successfully matched. Right, then!

    #FUXME: We increasingly regard the dichotomy between ${pcre_continuable_spaces_horizontal}
    #and ${pcre_spaces_horizontal} as bath false and harmful. Ideally, we
    #shouldn't *NEED* to explicitly match line continuations and hence match
    #${pcre_continuable_spaces_horizontal} at *ALL*. If one considers it, ${pcre_word_unquoted}
    #and hence ${pcre_word_passable_with_parens_balanced} and hence ${pcre_macro_arg} already implicitly
    #matches line continuations.
    # local pcre_macro_args_optional='(?:'${pcre_macro_arg}'(?:'${pcre_continuable_spaces_horizontal}${pcre_macro_arg}')*'${pcre_word_spaces_optional}')?'${pcre_here}

    #FUXME: Macros accepting no arguments should be matchable in a
    #significantly more generalized, zsh-like manner. While matching
    #${pcre_line_end} is helpful, it fails to suffice; we'd also like to match
    #argumentless macros terminated by:
    #
    #* A standard command terminator (e.g., "<", "|") *WITHOUT* matching such
    #  terminator (i.e., use positive lookahead).
    #* A zeshy-specific command terminator (e.g., ":or", ":and"). Any others,
    #  or are those the only two ones? Oh, wait. *NO.* If this fallback
    #  alternative was matched, then no horizontal whitespace was matched after
    #  such macro's name, implying that a zeshy-specific command terminator
    #  could *NEVER* possibly match here. Ignore such terminators, but
    #  explicitly note why in the comments above.
    #
    #This should only be required for argumentless macros. Macros accepting one
    #or more arguments already follow the above stricture.

    #FUXME: Shift this and the following PCREs up to "space" above.

    # matches s to  To prevent 
    # any of the several standard syntactic primitives that
    # terminate commands.

    # Command terminator, comprising either the end of the current line *OR*
    # any of the several standard syntactic primitives that terminate commands.
    #     local pcre_terminators=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=;|([<>|])))'

    #FUXME: This may be incorrect. In fact, it almost certainly is. Why?
    #Because we currently treat the last byte of the currently matched
    #substring as synonymous with the last byte of the currently matched
    #*MACRO*. However, by consuming such command terminator here, we interfere
    #with such interpretation. Ideally, such terminator should be captured but
    #*NOT* consumed via positive lookahead. Note our explicit use of "captured"
    #here yes, we do actually need to inspect the contents of such command
    #terminator programmatically in ={backend}. Why? Well, it's fairly simple:
    #
    #* If the captured command terminator group is nonempty, then such macro's
    #  expansion is intended to be piped or redirected elsewhere. How can we
    #  ensure that any arbitrary expansion can be piped or redirected? For now,
    #  the simplest solution is almost certainly the best. ={backend} must
    #  check for the following conditions *AFTER* expanding such macro:
    #  * If such captured group is nonempty *AND* the expansion returned by
    #    such macro's function is *NOT* delimited by "{" and "}", then
    #    delimit such expansion by "{" and "}".
    #
    #That's hopefully it.
    #FUXME: Moreover, this fails to account for possible line continuations
    #preceding such command terminator (e.g., ":macro\
    #| :piped_to_something"). How about something resembling:
    #
    #     local pcre_terminators=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=(['${char_terminator}'])))'
    #
    #Of course, we probably haven't even defined ${pcre_word_spaces_optional}
    #by this point, requiring this PCRE be shifteb below.
    #FUXME: Actually, ";" is equivalent to a newline for command termination
    #purposes and hence ignorable. So, the above should be augmented to read:
    #
    #     local pcre_terminators=${pcre_word_spaces_optional}'(?:'${pcre_line_end}'|(?=;|([<>|])))'
    #
    #Of course, that suggests definition of a new character class above -- say:
    #    local char_terminator_semantic='<>|'
    #FUXME: We'll need to add a new global match index for such captured group.
    #FUXME: Actually, this strikes us as overkill. The existing
    #${pcre_macro_args_zsh_optional} should *NEVER* match a command-terminating
    #subsequence, for obvious reasons. That said, the current definition of
    #such PCRE currently does and hence is clearly insufficient. See
    #${char_terminator_semantic} for details. Consider excising this PCRE.
    # local pcre_terminators='(?:'${pcre_line_end}'|['${char_terminator}'])'

    #FUXME: For efficiency, rename to ${pcre_here_doc_or_string_prefix_optional}
    #and suffix by "?".

    # ..................{ MACRO ~ word : embed               }..................
    #FUXME: Optimizable by eliminating extraneous "(?:" and ")" groupings.
    #FUXME: Actually, we want to revert to the prior approach. See above.
    #FUXME: Actually, this is probably *ALL* eliminatable by noting that
    #${pcre_word_passable_with_parens_balanced} pretty much suffices for both this and the
    #parens-specific PCREs below. Honestly, why did we go to such extreme
    #lengths to differentiate the three? It's rather difficult to say, now.
    #FUXME: Hmm; perhaps it *IS* useful to at least maintain the distinction
    #between ${pcre_word_passable_with_parens_balanced} and a new sort of word encompassing both braces
    #and parens words -- say, ${pcre_code_sans_comment}.
    #FUXME: O.K.; we've implemented a new ${char_not_word_embedded_unquoted}
    #character class. Use below in place of the current approach!
    #FUXME: O.K.; we've excised all ${pcre_word_braces*} and ${pcre_word_parens*}
    #definitions. Now, we need to replace all use of such PCREs by these PCREs.
    #FUXME: Actually, we want to excise all PCREs in this section as well as
    #${char_not_word_embedded_unquoted}, replacing both with their argument
    #word equivalents above. Then rename "word_arg" to "word" everywhere. As an
    #optimization, we can largely retain the benefits of using the approach
    #below by defining a new ${char_terminator_not_code_prefix} character
    #class probably defined something like so:
    #
    #    local char_terminator_not_code_prefix='&>|;'
    #
    #Such class explicitly omits "<", the here-document and -string prefix,
    #which must be matched in a more complex manner than a simple character
    #class. Given such class, we may then match all unquoted command
    #terminators in an efficient manner in all PCREs previously embedding
    #${pcre_code_sans_comment}, which seems rather nice.

    #FUXME: Arguably suffix by "'|'${pcre_here_doc_or_string_prefix}".

    # Character class matching invalid characters in unquoted shell words
    # embedded in syntactic constructs (e.g., blocks, process substitutions).
    # Since such words are matched merely to correctly parse the substrings
    # delimiting such constructs, this class excludes invalid characters
    # irrelevant to such parsing (e.g., "<", ">", "|").
    #
    # Since unquoted "(" and ")" characters are only permitted when balanced
    # (e.g., ":glob *.zy(.)"), such characters are excluded as above.
    # local char_not_word_embedded_unquoted='()'${char_not_code_prefix}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with argument word PCREs above.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # One or more characters of unquoted shell words embedded in syntactic
    # constructs.
    # local pcre_code_sans_comment_unquoted_char='[^'${char_not_word_embedded_unquoted}']'
    # local pcre_code_sans_comment_unquoted_chars=${pcre_code_sans_comment_unquoted_char}'++'
    #
    # # Syntactic construct embedded in shell words themselves embedded in
    # # syntactic constructs.
    # local pcre_code_sans_comment_substring=${pcre_code_sans_comment_unquoted_chars}'|'${pcre_char_escaped}'|'${pcre_substitutable_or_quotes}
    #
    # # Zero or much such constructs.
    # local pcre_code_sans_comment_substrings_optional='(?:'${pcre_code_sans_comment_substring}')*'
    #
    # # "("- and ")"-balanced substrings in shell words signifying embeddeduments
    # # passed to macros. See ${pcre_word_unquoted_balanced} above.
    # local pcre_code_sans_comment_unquoted_balanced='\('${pcre_code_sans_comment_substrings_optional}'\)'
    #
    # # One or much such constructs *OR* "("- and ")"-balanced substrings.
    # local pcre_code_sans_comment_substrings_balanced='(?:'${pcre_code_sans_comment_substring}'|'${pcre_code_sans_comment_unquoted_balanced}')+'
    #
    # # Shell word embedded in a syntactic construct.
    # local pcre_code_sans_comment=${pcre_word_lookahead}${pcre_code_sans_comment_substrings_balanced}${pcre_literal_blockable_lookbehind}
    #
    # # Zero or more shell words, whitespace characters, or comments embedded in
    # # a syntactic construct.
    # local pcre_words_embedded_or_comments_optional='(?:'${pcre_code_sans_comment}'|'${pcre_comment_optional_spaced}')*'

    #FUXME: Wait. Even a simple character class is insufficient. We'll want to
    #additionally support the following command terminating substrings:
    #* Either "<", ">", or "&" preceded by a nonnegative digit.
    #* A "}" delimiting a code block.
    #* A process substitution of the form "=(...)".
    #
    #In short, "Ugh." Hopefully, merely improving matching elsewhere will
    #implicitly correct for such shortfalls.
    # local char_terminator_semantic='<>|&'

    # local char_terminator_semantic='<>|&'

    # Character class matching ASCII punctuation characters that unconditionally
    # terminate the preceding command. 
    # local char_terminator=${char_terminator_semantic}';'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with embedded word PCREs below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Excise below.

    # # First, middle, and last unquoted substrings of unquoted shell words
    # # embedded in "{"- and "}"-delimited code blocks.
    # local pcre_word_braces_unquoted_char_first_last='[^'${char_not_word_braces_unquoted}'{}]'
    # local pcre_word_braces_unquoted_char_first='(?:[^'${char_not_word_braces_unquoted}'{]|'${pcre_char_escaped}')'
    # local pcre_word_braces_unquoted_char_last='(?:[^'${char_not_word_braces_unquoted}'}]|'${pcre_char_escaped}')'
    # local pcre_word_braces_unquoted_char_middle='(?:[^'${char_not_word_braces_unquoted}']+|'${pcre_char_escaped}')'
    # local pcre_word_braces_unquoted_chars_middle_optional=${pcre_word_braces_unquoted_char_middle}'*'
    #
    # # First, middle, and last substrings of a shell word embedded in "{"- and
    # # "}"-delimited code blocks.
    # local pcre_word_braces_first_last=${pcre_word_braces_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_braces_first='(?:'${pcre_word_braces_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_braces_last='(?:'${pcre_word_braces_unquoted_char_last}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_braces_middle='(?:'${pcre_word_braces_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_braces_middle_optional=${pcre_word_braces_middle}'*'
    #
    # # Shell word embedded in "{"- and "}"-delimited code block.
    # local pcre_word_braces='(?:'${pcre_word_braces_first}${pcre_words_braces_middle_optional}${pcre_word_braces_last}')|'${pcre_word_braces_first_last}')'

    # ..................{ MACRO ~ word : parens              }..................
    # Unquoted substrings of unquoted shell words embedded in "$("- and
    # ")"-delimited process substitutions. Technically, such words are also
    # subject to the same constraints as those above (e.g., "{" cannot be the
    # first character of such words). However, such constraints are irrelevant
    # to the parsing of such substitutions and hence ignorable here.
    # local pcre_word_parens_unquoted_char='[^'${char_not_word_parens_unquoted}']'
    # local pcre_word_parens_unquoted_chars=${pcre_word_parens_unquoted_char}'++'
    #
    # # Syntactic constructs embedded in shell words embedded in "$("- and
    # # ")"-delimited code blocks.
    # local pcre_word_parens_body=${pcre_words_parens_unquoted_chars}'|'${pcre_char_escaped}'|'${pcre_substitutable_or_quotes}
    #
    # # "("- and ")"-balanced substrings in shell words embedded in "$("- and
    # # ")"-delimited code blocks. Since such substrings are non-nestable,
    # # recursion and hence subroutine calls are *NOT* required. Yet, such
    # # substrings can contain other constructs (e.g., single-quoted strings).
    # local pcre_word_parens_unquoted_balanced='\((?:'${pcre_word_parens_body}')*\)'
    #
    # # Shell word embedded in "$("- and ")"-delimited code blocks.
    # local pcre_word_parens=${pcre_word_parens_body}'|'${pcre_word_parens_unquoted_balanced}
    #
    # # One or more shell words embedded in "$("- and ")"-delimited code blocks.
    # local pcre_words_parens_optional='(?:'${pcre_word_parens}')*'

    #FUXME: This didn't even work under the prior definition. Why? Because
    #${pcre_words_parens_optional} does *NOT* match whitespace, implying this
    #pretty always failed to correctly match. Naturally, it fails even worse
    #now that we've refactored such PCREs away. That said, it shouldn't be
    #*TOO* terribly hard to gin up something that works. This should do it:
    #
    #${pcre_code_sans_comment}'|'${pcre_comment_optional_spaced}
    # local pcre_list_assignment_optional=${pcre_var_name}'(?:=\('${pcre_words_parens_optional}'\))?'

    #FUXME: This didn't even work under the prior definition, since it failed

    # One or more shell words embedded a syntactic construct.
    # local pcre_code_sans_comment_optional='(?:'${pcre_code_sans_comment}')*'

    # Character class matching invalid characters in unquoted shell words
    # embedded in "$("- and ")"-delimited process substitutions. Since such
    # words are matched merely to correctly parse such delimiters, this class
    # excludes invalid characters irrelevant to such parsing (e.g., "|", ">").
    #
    # Since unquoted "(" and ")" characters are only permitted when balanced
    # (e.g., ":glob *.zy(.)"), exclude such characters here.
    # local char_not_word_embedded_unquoted='()'${char_not_code_prefix}

    # Character class matching invalid characters in unquoted shell words
    # embedded in "{"- and "}"-delimited code blocks. Since such words are
    # matched merely to correctly parse such delimiters, this class excludes
    # invalid characters irrelevant to such parsing (e.g., "|", ">").
    # local char_not_word_braces_unquoted='()'${char_not_code_prefix}

    #FUXME: We suspect that unquoted word characters *CANNOT* be optimized with
    #possessiveness (e.g., "+"), due to the occasional need to backtrack into
    #such characters (e.g., on matching the "}" in "shellword}"). Test us on
    #such edge cases, please. 
    #FUXME: Insufficient! PCREs below need to match shell words *PERFECTLY*.
    #Why? Because we need to ensure that macros either embedded in other
    #syntactic constructs *OR* suffixed by command-terminating substrings
    #(e.g., "=(uhoh)") are correctly matched. To ensure this, we'll need to:
    #
    #* Avoid matching any word-like substring prefixed by "=(" (regardless of
    #  subsequent text) as a word.
    #* Avoid matching digits prefixing "&", "<", or ">" as standard arguments
    #  (e.g., the "1" in "1<&2"). Only check at the start of a word.
    #* Avoid matching "{"- and "}"-delimited variable names prefixing the same
    #  primitives (e.g., "{myfid}>&1"). Only check at the start of a word.
    #* Match "(" and ")" in unquoted shell words in a non-recursive balanced
    #  manner. Happily, we've already done this; we simply need to integrate
    #  that work here.

    # First, middle, and last unquoted substrings of unquoted literal shell
    # words. Since both shell words in the context of passed arguments *AND*
    # shell-reserved "{" delimiters are always preceded by at least one
    # horizontal character, shell words cannot be prefixed by "{" characters.
    # Naturally, a similar argument holds for "}" characters (i.e., shell words
    # cannot be suffixed by such characters).

    #FUXME: Drop the "_literal" from such names. No longer required, and
    #they're already quite long.
    #FUXME: Horrible. Refactor to use the lookahead-driven approach below.
    # local pcre_word_literal_char_first_last='[^'${char_not_literal_with_parens_balanced}'{}]'
    # local  pcre_word_literal_char_first='[^'${char_not_literal_with_parens_balanced}'{]'
    # local   pcre_word_literal_char_last='[^'${char_not_literal_with_parens_balanced}'}]'
    # local pcre_word_literal_char_middle='[^'${char_not_literal_with_parens_balanced}']'
    # local pcre_word_literal_chars_middle_optional=${pcre_word_literal_char_middle_optional}'*'

    # Unquoted literal shell word, comprising one or more characters that are
    # neither shell-reserved *OR* "\"-escaped.
    # local pcre_word_literal='(?:'${pcre_word_literal_char_first}${pcre_word_literal_chars_middle_optional}${pcre_word_literal_char_last}'|'${pcre_word_literal_char_first_last}')'
    # local pcre_word_literal_grouped='('${pcre_word_literal}')'

    #FUXME: Oh, boy. It turns out that *ALL* redirections other than
    #here-documents and -strings may be freely interspersed with standard
    #command arguments: e.g.,
    #
    #    >>> function :yil() { print "${@}" }
    #    >>> :yil 1<&2 =(print ok) yum
    #    /tmp/zsh3lpV1a yum
    #
    #So. Where do we go from here? Frankly, we're inclined to ignore this
    #distinction by implementing the following:
    #
    #* Words should be permitted to contain arbitrary "<", ">", and "&"
    #  characters.
    #
    #Wait... How do we deal with macro expansion now?

    #FUXME: Oh, boy. This requires heavy examination.

    # Syntactic primitives breaking the standard "flow of control" with which
    # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # here-documents and -strings. Hence, shell words are synonymous with
    # standard arguments passable to external commands or functions.

#, comprising one or more
    # of the prior syntactic constructs
    # local pcre_word_body='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped}'|'${pcre_substitutable_or_quotes}')+'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}${pcre_word_body}${pcre_literal_blockable_lookbehind}

    # * "(" and ")" are technically shell-reserved but permitted in unquoted
    #   shell words when strictly balanced (e.g., "(this)" but not "(this(").
    #FUXME: Use in process substitutions to match "$( ugh*.txt(.) )".

    #FUXME: The current approach incurs quite a bit of backtracking, which
    #could be obviated by simple use of forward and negative lookahead.  In
    #hindsight, the prior approach genuinely appears to have been superior.
    #The current approach is blatantly overly complex and inefficient. Revert
    #both here and below, please. (Regretful apologies on that one.)
    #
    #Use ${pcre_word_middle} as a basis for our reversion, shifting all
    #desired forward lookahead constraints into
    #${pcre_word_lookahead} above. (Nice, eh?)

    # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_literal_char_first_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_literal_char_first}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_literal_char_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_middle='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'
    #
    # # Shell word, comprising one or more of the prior syntactic constructs.
    # # Syntactic primitives breaking the standard "flow of control" with which
    # # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # # here-documents and -strings. Hence, shell words are synonymous with
    # # standard arguments passable to external commands or functions.
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}'(?:'${pcre_word_first_last}'|'${pcre_word_first}${pcre_words_middle_optional}${pcre_word_last}')'

    # # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_literal_char_first_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_literal_char_first}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_literal_char_last}'|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_middle='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'
    #
    # # Shell word, comprising one or more of the prior syntactic constructs.
    # # Syntactic primitives breaking the standard "flow of control" with which
    # # zsh parses arguments are excluded (e.g., "<", "|"), thus excludeing
    # # here-documents and -strings. Hence, shell words are synonymous with
    # # standard arguments passable to external commands or functions.
    # local pcre_word_passable_with_parens_balanced=${pcre_word_lookahead}'(?:'${pcre_word_first_last}'|'${pcre_word_first}${pcre_words_middle_optional}${pcre_word_last}')'

    # Single- or double-quoted string, arithmetic or process substitution, *OR*
    # variable expansion embedded in a shell word.
    #FUXME: Contemplate either:
    #
    #* Supplanting ${pcre_embeddable_or_char_escaped} by "(?&sub)" below and then excising
    #  ${pcre_embeddable_or_char_escaped}. This has the disadvantage of slowing commonplace
    #  variable expansions, however.
    #* Replacing the embeddings of both ${pcre_process_substitution_dollar_recursive}
    #  and ${pcre_process_substitution_dollar_nonrecursive} with new subroutines
    #  calling such PCREs. This amends the prior issue.
    #* Reducing this PCRE to:
    #    local pcre_embeddable_or_quotes='(?&word)'
    #    pcre_subroutines_body+='(?<word>${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}')'
    #
    #While the second option would be preferable in the ideal world, we should
    #consider adopting the third option as a concession to real-world
    #pragmatism. After all, this PCRE is transitively embedded into so many
    #other expressions that the current approach patently fails to scale. As a
    #temporary hotfix, therefore, we've elected to adopt the first option.

    #FUXME: Overkill. Combine the following three into one conglomerate PCRE.
    # # "=("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_equals='=\('${pcre_process_parens_body}'\)'
    #
    # # "<("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_angle_left='<\('${pcre_process_parens_body}'\)'
    #
    # # ">("- and ")"-delimited possibly recursively nested process substitution.
    # local pcre_process_substitution_angle_right='>\('${pcre_process_parens_body}'\)'

#  Since the named group
    # "<sub>" matches non-recursive process substitution, such group *CANNOT*
    # be referenced here. (Doing so would permit such substitutions to be
    # recursively nested.) Instead, match all groups matched by such group
    # excluding non-recursive process substitution.
    # Recursively substitutable syntactic construct (e.g., "=("- and
    # ")"-delimited process substutition), intended to be called *ONLY* from
    # within such constructs.

    # First, middle, and last unquoted substrings of unquoted shell words.

    #FUXME: Optimizable by eliminating extraneous "(?:" and ")" groupings.

    # local pcre_word_unquoted_char_first_last=${pcre_word_literal_char_first_last}
    # local pcre_word_unquoted_char_first='(?:'${pcre_word_literal_char_first}'|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_char_last='(?:'${pcre_word_literal_char_last}'|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_char_middle='(?:'${pcre_word_literal_char_middle}'+|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'+'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'*'

    # First, middle, and last substrings of a shell word.
    # local pcre_word_first_last=${pcre_word_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_first='(?:'${pcre_word_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_last='(?:'${pcre_word_unquoted_char_last}'|'${pcre_word_quoted_or_substitutable}')'
    # local pcre_word_middle='(?:'${pcre_word_unquoted_chars_middle}'|'${pcre_word_quoted_or_substitutable}')'
    # local pcre_words_middle_optional=${pcre_word_middle}'*'

    #FUXME: Reasonably tired of "${pcre_quotes_single}'|'${pcre_quotes_double}"
    #everywhere. Time to recover ${pcre_quotes_optional}, we should think.

# ${pcre_quotes_single}'|'${pcre_quotes_double}'|'

    #FUXME: The above is great and should be shifted to ={backend}. That said,
    #the whole point of [<>=]"("- and ")"-delimited process substitutions is
    #that they can be passed as customary arguments, meaning we need to treat
    #them as such. All other redirections should still be required to be passed
    #at the end of the macro expansion as is customary.
    #FUXME: Insufficient. Sadly, this fails to take into account the following
    #process substitution variants:
    #
    #* "=(...)", capturing the output of such command(s) to a temporary file
    #  and passing such file's handle to the current command. Unlike the
    #  variants below (which may appear *ANYWHERE*), "=(...)" must begin at the
    #  first character of a shell word or will otherwise be treated as a part
    #  of an unquoted shell word (e.g., "file*.txt=(.)" is a glob rather than a
    #  process substitution!). Yes, this is terrible. Correctly matching this
    #  pretty much requires matching words properly. That said, we *SHOULD* be
    #  matching words properly anyway in process substitutions... yes?
    #* "<(...)", redirecting the output of such command(s) to the current
    #  command's standard input.
    #* ">(...)", redirecting the output of the current command to standard
    #  input for such command(s).

    #FUXME: Actually use the following three PCREs. At the very least, embed
    #them in the definition of "<sub>" below.

    #FUXME: Use everywhere below in place of "(?&sub)".
    #FUXME: Abstract "[^'${char_not_code_prefix}']++" into a new PCRE above and
    #replace all current instances of such substring by such PCRE.
    #FUXME: Abstract out [^'${char_not_code_prefix}']++.

    # local pcre_process_substitution_dollar='(?:'${pcre_list_assignment_optional}'|'${pcre_word_parens}'|'${pcre_comment_optional_spaced}'|'${pcre_here_doc_or_string_prefix}'|[^)])*'

    # Redirection prefixed by a file descriptor specified as either a
    # non-negative integer *OR* "{"- and "}"-delimited variable name. Such
    # redirections conflict with unquoted shell word syntax and hence *MUST* be
    # matched for disambiguation. See section "REDIRECTION" of "man zshexpn".
    # local pcre_redirect_prefix='(?:[0-9]++|\{'${pcre_var_name}'\})&?[<>]'

    # ${pcre_redirect_file_handle_id}'|'${pcre_redirect_file_handle_id}
    # l are incidental to macro parsing but  
    #FUXME: The lookahead optimization preceding such call is rather nice,
    #here. Does a similar optimization apply elsewhere?
# (?=['${char_embeddable_prefix}'])(?&sub)'

    #FUXME: O.K.; so, clearly, we *DO* require this. Probably? Maybe. Hmm. Will
    #the "1" in "1<&2" be matched as an unquoted argument here? Surely not.

    #FUXME: Do we still require this?
    # "&&" (but not "&" on its own)
    #FUXME: Wait. Both "||" and "&&" also terminate commands.

# by such assert such constraint We assert such constraint with
    # ..................{ MACRO ~ word                       }..................
    #FUXME: Shift below.
    #FUXME: We're fairly certain that *OUTSIDE* of process substitutions, it
    #suffices to match the prefixes "\(" and "\[" respectively. *INSIDE* of
    #process substitutions, of course, the full "\("-prefixed math substitution
    #must be matched (to avoid conflict with embedded "("- and ")"-delimited
    #parens in math substitutions and the ")" delimiter for the outer process
    #substitution). Yikes!
    #FUXME: Oh! Jeebus. No, no, and no; do you wish to know why? Math operators
    #(namely, "<<") fundamentally conflict with exterior zsh syntax. Sadly, we
    #failed to note that above. This does imply, however, that we'll need to
    #resurrect ${pcre_math_substitution_braces} from below. *sigh*

    # whose syntax fundamentally conflicts with conventional zsh
    #
    # delimiters and must thus be matched. (Note that zsh also supports
    # possibly recursively nested "$["- and "]"-delimited arithmetic
    # substitutions. Since such delimiters conflict with no syntax of
    # preprocessor significance, such substitutions are ignorable.)

    #FUXME: Embed me in process substitutions below, please. Or perhaps not?
    # Shell word, here-document, or here-string prefix.
    # local pcre_word_parens_or_here=${pcre_word_parens}'|'${pcre_here_doc_or_string_prefix}

    #FUXME: We need to add substitutable constructs here!
    # Technically, such PCRE is somewhat inefficient: the negative lookahead
    # "(?!`)" only needs to prefix the "(?&sub)" and "." alternatives. Since
    # "`" is deprecated and never appears in the zeshy codebase, however, we
    # currently ignore such inefficiencies for simplicity.

    #FUXME: Replace all instances of  ${pcre_here_doc} with "(?&here)".
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    #FUXME: Note the repetition between this and the following PCRE. Such body
    #should be extracted into a new common PCRE -- say,
    #${pcre_word_parens_body} -- and interpolated into both this
    #PCRE and the PCRE below.

    #FUXME: This can be optimized by reduction to:
    #
    #     local pcre_words_parens_body=${pcre_words_parens_unquoted_chars}'|'${pcre_word_parens_unquoted_balanced}'|'${pcre_embeddable_or_quotes}
    #
    #Then expand such PCRE where we currently expand ${pcre_words_parens}.

    # local pcre_words_parens='(?:'${pcre_words_parens_unquoted_chars}'|'${pcre_word_parens_unquoted_balanced}'|'${pcre_embeddable_or_quotes}'|'${pcre_char_escaped}')+'
    # local pcre_word_parens_unquoted_balanced='\((?:'${pcre_words_parens_unquoted_chars}'|'${pcre_embeddable_or_quotes}'|'${pcre_char_escaped}')*\)'
    # local pcre_word_parens_unquoted_char='(?:[^'${char_not_word_parens_unquoted}']+|'${pcre_char_escaped}')'
    # local pcre_word_parens_unquoted_chars=${pcre_word_parens_unquoted_char}'+'

    # local pcre_process_substitution_dollar_nonrecursive='`(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_comment_optional_spaced}'|(?!`)(?:'${pcre_code}'|.))*`'

    #FUXME: Give me another eyeball over, please.
    # local pcre_process_substitution_dollar_recursive='(?:'${pcre_list_assignment}'|[^)'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_comment_optional_spaced}'|'${pcre_code}'|[^)])*'
    # local pcre_macro_arg_block_body='(?:'${pcre_word_braces}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^}])*'

    # Block delimiter "}". As ${char_not_literal_with_parens_balanced} documents, such "}" must
    # be suffixed by at least one horizontal whitespace or newline character
    # (optionally preceded by zero or more line continuations). To support
    # macros accepting two or more consecutive argument blocks, avoid matching
    # suffixing whitespace matched as prefixing whitespace by the next such
    # block by merely asserting this constraint with positive lookahead.
    #FUXME: This is terrible. More to the point, given the refactored
    #${pcre_word_passable_with_parens_balanced}, this is no longer required. Instead, refactor
    #${pcre_macro_arg_block_body} below to leverage ${pcre_word_passable_with_parens_balanced} rather than
    #the current negative character class-driven approach. This *SHOULD*
    #substantially reduce the complex of such PCRE, as well as improving the
    #efficiency. (*SHOULD*, anyway.)
    #FUXME: O.K.; we should be good to go to excise both ${pcre_char_block_prefix}
    #and ${pcre_char_block_suffix}. This will invoke backtracking on edge-case
    #failures (...actually, not, come to think), but should nonetheless work
    #capably under all substrings.
    # local pcre_brace_right_lookahead=${pcre_line_continuations_optional}'(?:'${pcre_space_horizontal}'|'${pcre_line_end}')'
    # local pcre_char_block_suffix='\}(?='${pcre_brace_right_lookahead}')'

    #FUXME: The current definition of ${pcre_process_substitution_dollar_recursive} is
    #sadly incorrect as well, as it fails to match "$( print file*.txt(.) )"
    #correctly. Interestingly, such PCRE fails for the exact same reason that
    #we required lookahead ahead. Hence, the exact same solution of replacing
    #the current negative character class-driven approach in such PCRE with a
    #${pcre_word_passable_with_parens_balanced}-based solution *SHOULD* amend that and similar issues. Oh!

    # Non-block delimiter "}" (i.e., a "}" *NOT* followed by the syntax
    # qualifying such "}" as a block delimiter).
    # local pcre_brace_right='\}(?!'${pcre_brace_right_lookahead}')'

    #FUXME: While a highly unlikely edge case, we suspect block "{" delimiters
    #may be preceded by "|" without intervening whitespace. Perhaps not? Not
    #terribly critical, but worth investigating.

    #FUXME: Optimizable, possibly? ${pcre_word_braces} may *ONLY* be followed
    #by either the terminating "}" *OR* by whitespace (either vertical or
    #horizontal).

    #FUXME: The fact that we're capturing grouped substrings here suggests that
    #this will almost certainly interfere with captured group indices.
    #Subroutines provide a nice way around this. Alternately, we vaguely recall
    #a "(*...)"-style directive for clearing previously captured groups. "\K"
    #also effects something similar. Investigate. Contemplate.
    #FUXME: While subroutines *WOULD* work here to effectively "erase" such
    #capturing, a more efficient alternative would be to ensure that
    #${ZESHY__PREPROCESS_PCRE} is designed in such a way that:
    #
    #* The macro name is *ALWAYS* the first captured group.
    #* Invalid macro arguments are *ALWAYS* the last captured group.
    #
    #In such case, the latter may be reliably indexed as ${match[-1]}. (We'll
    #need to modify the index globals below accordingly.) Given that, all
    #intermediate captured groups would simply be ignorable. Sounds good, no?
    #FUXME: Oh, and given the fact that here-documents group, we *REALLY* want
    #to rename all such PCREs below to reflect that.
    #FUXME: No, no, no. After briefly flirting with such nomenclature change,
    #it's clear that we would be capturing here-document delimiters in so many
    #PCREs that we'd probably end up with a countably infinite number of empty
    #groups preceding a captured syntactically invalid macro group. This is
    #nonsense, and probably equally as inefficient as simply subrouting
    #here-documents -- which, clearly, is what we're going to do instead. Yay!
    #Happily, such subroutine calls may be optimized by being prefixed by
    #positive lookahead: e.g.,
    #
    #    (?=<)(?&here)

    #FUXME: Unused anywhere. Why? We'll need to at least ensure that
    #${pcre_word_unquoted_char_first_last} is being used.

    # Unquoted shell word, comprising one or more characters that are *NOT*
    # shell-reserved.
    # local pcre_word_unquoted='(?:'${pcre_word_unquoted_char_first}${pcre_word_unquoted_chars_middle_optional}${pcre_word_unquoted_char_last}')|'${pcre_word_unquoted_char_first_last}')'

    #FUXME: Define ${pcre_words_parens} above.

    #FUXME: O.K.; so, to do this, we need to implement support for balanced
    #(but *NOT* nested) parens in an unquoted fashion. Shouldn't be terribly
    #difficult, but you know the score.

    # First, middle, and last substrings of a shell word embedded in "$("-
    # and ")"-delimited code blocks.
    # local pcre_word_paren_left_last=${pcre_word_parens_unquoted_char_first_last}'|'${pcre_embeddable_or_quotes}
    # local pcre_word_paren_left='(?:'${pcre_word_parens_unquoted_char_first}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_parens_last='(?:'${pcre_word_parens_unquoted_char_last}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_word_parens_middle='(?:'${pcre_word_parens_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_parens_middle_optional=${pcre_word_parens_middle}'*'

    # local pcre_word_parens_middle='(?:'${pcre_word_parens_unquoted_chars_middle}'|'${pcre_embeddable_or_quotes}')'
    # local pcre_words_parens_middle_optional=${pcre_word_parens_middle}'*'
    # local pcre_word_parens_unquoted_balanced='\('${pcre_words_parens_middle_optional}'\)'

    #FUXME: Actually use this. Or excise, perhaps? In the latter case, we'll
    #need to ensure we're using ${pcre_word_braces_unquoted_char_first_last}.

    # Unquoted shell word embedded in "{"- and "}"-delimited code blocks.
    # local pcre_word_braces_unquoted='(?:'${pcre_word_braces_unquoted_char_first}${pcre_word_braces_unquoted_chars_middle_optional}${pcre_word_braces_unquoted_char_last}')|'${pcre_word_braces_unquoted_char_first_last}')'

    # Unquoted shell word embedded in "$("- and ")"-delimited process
    # substitutions.

    #FUXME: Use in process substitutions to match "$( ugh*.txt(.) )"? That, or
    #we'll probably need to leverage lookahead. (Ugh! This is terrible. Perhaps
    #just ignore such edge case for now?)
    # local pcre_word_parens_unquoted='[^'${char_not_word_parens_unquoted}']++'

    #FUXME: O.K.; so, we do *ABSOLUTELY* want to use this. Indeed, we can
    #actually use a truncated form of ${char_not_literal_with_parens_balanced} ignoring
    #non-conflicting syntax (e.g., "{", "}", "|", etc.), meaning that we can
    #produce a vastly simplified variant of ${pcre_word_passable_with_parens_balanced} specific to process
    #substitutions -- say, ${pcre_word_parens}.

    #FUXME: Actually, we probably *NEVER* need to match the old math
    #substitution form, as such form should conflict with no existing syntax.
    #Excise, please!
    # local pcre_math_substitution_braces='\[(?:[^\]'${char_not_embeddable_prefix}']++|'${pcre_char_escaped}'|(?&sub)|[^\]])*\]'

    # in both current (i.e., "$(("- and "))"-delimited) and obsolete (i.e.,
    # "$["- and "]"- delimited) forms.

    #FUXME: Refactor to use ${pcre_word_braces} here.
    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:'${pcre_word_braces}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_here_doc_or_string_prefix}'|[^}])*'
    # local pcre_macro_arg_block_body='(?:[^{}'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code}'|[^}]|'${pcre_brace_right}')*'

    # escaping characters, including the above such prefixes.
    # local pcre_embeddable_or_char_escaped=${pcre_dollar_construct}'|'${pcre_process_substitution_dollar_nonrecursive}
    # pcre_subroutines_body+='(?<sub>'${pcre_embeddable_or_char_escaped}')'

    # local pcre_embeddable_or_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}

    # local pcre_macro_arg_block_or_comment_optional='(?:'${pcre_comment}'|'${pcre_char_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:[^{}'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_line_start_or_spaces_horizontal}${pcre_macro_arg_block_or_comment_optional}'|'${pcre_code}'|[^}]|'${pcre_brace_right}')*'
    # local pcre_macro_arg_block=${pcre_char_block_prefix}${pcre_macro_arg_block_body}${pcre_char_block_suffix}
    # pcre_subroutines_body+='(?<block>'${pcre_macro_arg_block_body}${pcre_char_block_suffix}')'

    # local pcre_word_braces_unquoted='[^'${char_not_word_braces_unquoted}']++'

    #FUXME: Likewise, we should produce a new ${pcre_word_braces} similarly
    #ignoring non-conflicting syntax nested inside of a block argument (e.g.,
    #"|", etc.). Note, however, that we *MUST* retain ${pcre_word_passable_with_parens_balanced} for use in
    #detecting standard arguments at the outermost level.

    #FUXME: Actually, even that doesn't quite suffice. We realized that such
    #PCRE also fails to match "$( :list y; y=( ) )". Hence, we'll now need to
    #match list assignments *ONLY* inside process substitutions. *sigh*

    # local pcre_macro_args_zsh_optional=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'

    #FUXME: Use of ${pcre_line_end} is insufficient both here and below.
    #Numerous syntactic primitives effectively terminate the current command
    #and hence macro, including "|", ">", and non-here-specific "<". Any
    #others? (Probably not, but contemplate.)
    #
    #O.K.; after examination, "|", ">", and "<" should absolutely suffice. Oh,
    #and ";", of course. Yes!

    #FUXME: Shift above and use everywhere we use ${pcre_line_end} below.

    # Macro terminator, either the end of the current line *OR* any of the
    # several standard command terminators.
    # local pcre_macro_end='(?:'${pcre_line_end}'|'${pcre_terminators}')'

    #FUXME: O.K.; so, we're implementing an increasing amount of work,
    #complexity, and inefficiency -- all to match  
    # Zero or more command-specific whitespace sequences. Technically, this
    # PCRE is optimizable to:
    # local pcre_word_spaces_optional='(?:'${pcre_spaces_horizontal}'|'${pcre_line_continuation}')*'

    # local pcre_here_string_prefix='<'${pcre_word_spaces_optional}
    #FUXME: We need to actually ensure that *ALL* negative character classes
    #contain "\" and then modify the PCREs embedding such classes to match
    #${pcre_char_escaped}. Grep everywhere below, we're afraid, for "[^".

    # Zero or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments).

    # local pcre_word_unquoted_char_last=${pcre_word_literal_char_last}
    #FUXME: Insufficient; "}" is *NOT* an unquoted shell word.

    # local  pcre_word_unquoted_char_middle='(?:'${pcre_word_literal_char_middle}'|'${pcre_char_escaped}')'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'+'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'?'

    # local  pcre_word_unquoted_char_first='(?:'${pcre_char_escaped}'|[^'${char_not_literal_with_parens_balanced}'{])'
    # local   pcre_word_unquoted_char_last='[^'${char_not_literal_with_parens_balanced}'}\\]'
    # local pcre_word_unquoted_char_middle='(?:'${pcre_char_escaped}'|[^'${char_not_literal_with_parens_balanced}'])'
    # local pcre_word_unquoted_chars_middle=${pcre_word_unquoted_char_middle}'++'
    # local pcre_word_unquoted_chars_middle_optional=${pcre_word_unquoted_char_middle}'?'

    # local  pcre_word_literal_char_first='[^'${char_not_word_literal}'{]'
    # local   pcre_word_literal_char_last='[^'${char_not_word_literal}'}]'
    # local pcre_word_literal_char_middle='[^'${char_not_word_literal}']'
    # local pcre_word_literal_chars_middle_optional=${pcre_word_literal_char_middle}'?'

    # Unquoted literal shell word, comprising one or more shell-unreserved,
    # "\"-unescaped characters.

    # Character class matching invalid characters in unquoted literal shell
    # words (i.e., shell words interpreted literally and hence *NOT* containing
    # escaped characters), comprising most shell-reserved characters along with
    # character escape "\".
    # local char_not_word_literal=${char_not_literal_with_parens_balanced}'\\'

    # To ensure this, the character escape "\" must *ALWAYS* be 

    #FUXME: Incorrect, as we also need to match comments and "{" delimiters at
    #the start of lines when *NOT* prefixed by line continuations. (Good lord.)
    #Incidentally, this suggests we're probably matching comments incorrectly
    #everywhere else as well.
    #FUXME: O.K.; we *ARE* dealing with comments appropriately elsewhere. While
    #confirming this, we also noted that we deal with whitespace in a
    #considerably simpler and more straightforward manner than we do here.
    #On the face of it, there doesn't *APPEAR* to be any reason that we can't
    #supplant ${pcre_macro_arg_block_spaces} with ${pcre_line_start_or_spaces_horizontal}
    #(which, clearly, should be renamed and shifted to the "spaces" section).
    #Clearly, we wanted to prevent a line continuation followed immediately by
    #"{" from being matched as a block prefix. But, if you consider it,
    #${pcre_line_start_or_spaces_horizontal} already ensures this! So, embedding
    #${pcre_word_spaces_prefixed_by_spaces} here gains us nothing. Thankfully,
    #this would appear to be among the last PCRE chores.
    # local pcre_macro_arg_block_spaces='(?:'${pcre_line_start}'|'${pcre_word_spaces_prefixed_by_spaces}')'
# ${pcre_line_start_or_spaces_horizontal}

    # local pcre_line_start_or_spaces_horizontal='(?:'${pcre_spaces_horizontal}'|'${pcre_line_start}${pcre_spaces_horizontal_optional}')'

    #FUXME: Still required? Ideally, this should be excisable.

    # One or more horizontal whitespace characters optionally followed by a
    # comment.
    # local pcre_spaces_horizontal_and_comment_optional=${pcre_spaces_horizontal}'(?:'${pcre_comment}')?'

# ${pcre_spaces_horizontal_and_comment_optional}'
    #FUXME: Concoct ${pcre_here} if not already. Excise now redundant
    #PCREs (e.g., ${pcre_macro_here_optional}).
    #FUXME: Abstract "[^'${char_space_vertical}']++" into a PCRE local.
    # local pcre_macro_args_zsh_or_block_optional='(?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'))*'
    # local pcre_macro_args_optional='(?:'${pcre_macro_args_zsh_or_block_optional}${pcre_word_spaces_optional}${pcre_here}${pcre_line_end}'|([^'${char_space_vertical}']++))'

    # arguments of any type.
    # To assist the preprocessor in
    # differentating between syntactically valid macros accepting no arguments
    # and syntactically invalid macros accepting arguments, embed an empty
    # group at some arbitrary position in such PCRE. Differentiating such cases
    # then reduces to testing the length of canonical list global ${matches}.
    # While we could also effect this by capturing the entire substring matched
    # by such PCRE, doing so has no demonstrable benefit over the current
    # approach while incurring minor time and space costs. So, the current
    # approach reigns.

    #FUXME: This is a wee crazy. Is there no terser solution?
    # local pcre_macro_args_zsh_or_block_optional='(?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'))*'

    # One or more standard arguments, comprising one or more shell words all of
    # which are delimited by shell word-specific whitespace. Such condition
    # prevents whitespace suffixing the last such argument from being matched,
    # ensuring such whitespace will be matched only as the mandatory whitespace
    # prefixing a subsequent block argument if any or otherwise ignored. (Since
    # unquoted whitespace is significant only for argument delimitation in both
    # zsh and zeshy, trailing unmatched whitespace is safely ignorable.)
    # local pcre_args_zsh=${pcre_word_passable_with_parens_balanced}'(?:'${pcre_continuable_spaces_horizontal}${pcre_word_passable_with_parens_balanced}')*'
    # local pcre_args_zsh_optional='(?:'${pcre_args_zsh}')?'

    #FUXME: Correct the definition of ${pcre_word_unquoted} above.
    #FUXME: Erroneous, as ${pcre_here} has yet to be defined. We suspect
    #circular dependencies due to here-strings.

    #FUXME: Apply all fixes to this PCRE to the following PCRE.
    # local pcre_word_literal='[^'${char_not_word_literal}']++'

#  As ${char_not_literal_with_parens_balanced} documents, character "}"
    # when conditionally followed by horizontal whitespace is shell-reserved
    # and must be excluded.

    #FUXME: Not quite right. "}ounhou" is a valid unquoted word and should be
    #matched by this PCRE. Likewise, a "{" preceded by horizontal whitespace is
    #invalid and must *NOT* be matched this PCRE. We'll probably want to
    #redesign this in favor of the current ${pcre_word_passable_with_parens_balanced} approach.
    # local pcre_word_passable_with_parens_balanced=${pcre_word_first}'(?:'${pcre_words_middle_optional}${pcre_word_last}')?'
    # local pcre_word_unquoted='[^'${char_not_literal_with_parens_balanced}']++|'${pcre_brace_right}

    # ..................{ MACRO ~ word                       }..................
    # Optional here-document or -string.
    # Here-document or -string prefixed by one or more horizontal whitespace
    # characters.
    # local pcre_macro_here_optional='(?:'${pcre_word_spaces_optional}${pcre_here}')?'

    # local pcre_macro_here_optional='(?:'${pcre_word_spaces_optional}${pcre_here}')?'
    # '(?:'${pcre_continuable_spaces_horizontal}${pcre_word_passable_with_parens_balanced}')*
    # '(?:'${pcre_word_passable_with_parens_balanced}${pcre_continuable_spaces_horizontal}')*'
    # local pcre_macro_args_optional='(?:(?:'${pcre_continuable_spaces_horizontal}'(?=([^'${char_space_vertical}']?))(?:'${pcre_args_zsh_optional}${pcre_macro_arg_blocks_optional}')*'${pcre_macro_here_optional}')?'${pcre_line_end}${pcre_empty_group}')?'
    # local pcre_macro_args_optional='(?:(?:'${pcre_continuable_spaces_horizontal}'(?=([^'${char_space_vertical}']))(?:'${pcre_macro_arg_block}'|'${pcre_args_zsh}')*'${pcre_macro_here_optional}')?'${pcre_line_end}${pcre_empty_group}')?'
    # local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block}'|'${pcre_args_zsh}')*)?'

#, and named accordingly
#zsh_optional_grouped
    #FUXME: Still not quite right: must match suffixing whitespace if any.
    # local pcre_macro_args_zsh_optional_grouped='('${pcre_continuable_spaces_horizontal}${pcre_args_zsh_optional}')'

    #FUXME: Excrutiatingly simple. Simply replace by the two PCREs such PCREs
    #expand to. *sigh*
    # local pcre_word_spaces_and_args_zsh_optional=${pcre_continuable_spaces_horizontal}${pcre_args_zsh_optional}
    # local pcre_word_spaces_and_args_zsh_optional=${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}${pcre_word_spaces_optional}')*'
    # local pcre_word_spaces_and_args_zsh_optional_grouped='('${pcre_word_spaces_and_args_zsh_optional}')'

    #FUXME: Subtly broken. Why? Because combining ${pcre_word_spaces_optional}
    #with ${pcre_word_passable_with_parens_balanced} permits otherwise impermissible lexical combinations: in
    #particular, " { ". Such combinations *MUST* be prohibited here. Note,
    #also, that we probably have a similar problem anywhere else that we've
    #combined words with spaces. We'll probably want to grep about for other
    #instances of such error.
    #
    #The simplest fix would be to prefix ${pcre_brace_left} be negative
    #lookbehind prohibiting "{" preceded by whitespace. No; that doesn't work,
    #because of line continuations. Hmmm; so, we need to refine
    #${pcre_word_unquoted} to prevent such PCRE from matching either a lone "{"
    #or lone "}". Hmmm; but that doesn't seem quite precise enough. Here's what
    #we need to handle: if at least one horizontal whitespace character is
    #matched, the following character *CANNOT* be a "{".
    #
    #O.K.; it really does seem that ${pcre_word_unquoted} should prohibit "{"
    #as the first character and "}" as the last. That would probably solve all
    #issues with the current approach, yes?
    #
    #Wrong. We want to improve ${pcre_word_passable_with_parens_balanced} such that only the first and
    #last if any words are constrained to prohibit an unquoted prefixing "{" or
    #suffixing "}" from being matched.

    # local pcre_args_zsh=${pcre_word_passable_with_parens_balanced}'(?:'${pcre_word_spaces_optional}${pcre_word_passable_with_parens_balanced}')*'
    # local pcre_word_unquoted='(?:'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}')'
    # local pcre_words_unquoted=${pcre_words_unquoted}'+'
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    # local char_not_literal_with_parens_balanced=${char_space}'''"$<>|`'

    # For subtle reasons, this includes the conditionally shell-reserved
    # character "}" but *NOT* "{". "{" is only shell-reserved when preceded by
    # horizontal whitespace; "}" is only shell-reserved when followed by
    # horizontal whitespace. Since this class is only interpolated into
    # negative character classes, such classes exclude horizontal whitespace
    # and hence "{" as a shell-reserved character. Hence, "{" need (and indeed
    # *MUST*) not be listed in this class. "}", however, *MUST* be explicitly
    # listed here and then subsequently matched outside such classes when *NOT*
    # suffixed by horizontal whitespace. (Oh, shell life is complicated.)
    # local char_not_literal_with_parens_balanced=${char_space}'''"$}<>|`'

  # Ideally, this includes all strings passable
    # as a standard argument to a zsh command.
    # local pcre_word_passable_with_parens_balanced='(?:[^'${char_not_literal_with_parens_balanced}'{]|'${pcre_embeddable_or_quotes}')(?:(?:[^'${char_not_literal_with_parens_balanced}'}]|'${pcre_embeddable_or_quotes}'))?'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_first}'(?:'${pcre_word_middle}'*'${pcre_word_last}')?'
    # local pcre_word_passable_with_parens_balanced=${pcre_word_passable_with_parens_balanced}'+'

    # local pcre_word_unquoted='[^'${char_not_literal_with_parens_balanced}']++|'${pcre_brace_right}
    # local  pcre_word_first_unquoted='[^'${char_not_literal_with_parens_balanced}'{][^'${char_not_literal_with_parens_balanced}']*+'
    # local pcre_word_middle_unquoted='[^'${char_not_literal_with_parens_balanced}']++'
    # local   pcre_word_last_unquoted='[^'${char_not_literal_with_parens_balanced}']*+[^'${char_not_literal_with_parens_balanced}'}]'

    # local pcre_word_passable_with_parens_balanced='(?:'${pcre_word_unquoted}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}')'

    #FUXME: We're probably going to have issues with possessiveness here. Why?
    #Because ${pcre_continuable_spaces_horizontal} matches horizontal whitespace possessively,
    #preventing backtracking if the non-whitespace following such whitespace
    #constitutes a valid block argument. That's bad.

    # PCRE unconditionally reporting failure.
    # ZESHY__PCRE_REPORT_FAILURE

    #FUXME: Use in ={frontend.zy}, replacing current glob usage.

# PCRE fragment prefixing ${ZESHY__PREPROCESS_PCRE} the PCRE defined by
# ::preprocessor_pcres.make_if_needed() matching zero or more macros *OR*
# syntactic constructs possibly containing macro-like substrings.

    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE=
    # local pcre_macro_name_grouped_lookahead='(?=([^'${char_space}'\\]++)'

    # Character class matching invalid characters in macro names during
    # positive lookahead capturing such names. While we could simply replace
    # this class by embedding ${ZESHY__MACRO_NAME_VALID_PCRE} instead, the
    # former is considerably shorter and hence more efficient than the latter.

    #FUXME: Actually use such class in lookahead below.

    # local pcre_not_macro_name_lookahead=${char_space}'\\'

#  Since macro names are necessarily
    # unquoted *AND* since the first character of unquoted shell words are
    # constrained by additional 
    #
    # This omits characters only conditionally valid in certain positions
    # of macro names (e.g., "~", valid everywhere *EXCEPT* as the first
    # character of such names).

    # Character class matching invalid characters in macro names, comprising
    # all PCRE- *AND* shell-reserved characters. Since PCRE-reserved characters
    # in macro names *COULD* technically be explicitly escaped, only shell-
    # reserved characters need to be prohibited. For simplicity, we currently
    # prohibit both classes of characters.
    # local char_not_macro_name=${char_space}'''"*+?!#^$(){}[]<>&|\\`'

    # Technically, "(" and ")" are also only conditionally shell-reserved.
    # Nonetheless, prohibit both for simplicity.

    #FUXME: Make sure we're not using "\h", "\v", or "\s" anywhere anymore.
    #FUXME: Globalize.

    # PCRE fragment prefixing ${ZESHY__PREPROCESS_PCRE}, matching zero or more macros
    # *OR* syntactic constructs possibly containing macro-like substrings.
    # ZESHY__MACRO_ARG_BLOCK_NEXT_PCRE_PREFUX=${pcre_options_anchored}${pcre_word_spaces_and_args_zsh_optional_grouped}${pcre_macro_arg_block}${ZESHY__MACRO_SUBROUTINES}

    # PCRE matching macro *OR* syntactic construct possibly containing
    # macro-like substrings. In the former case, such macro's name and all
    # passed arguments will be captured.
    # ZESHY__PREPROCESS_PCRE=${pcre_macros_grouped_succeed_or_codes_report_failure}

# PCRE subroutines defined below, concatenated in a manner preventing such
# definitions from either matching *OR* capturing in place.
#
# Much like programmatic subroutines, PCRE subroutine are self-consistent units
# preserving a semblance of local scope; for example, PCRE subroutines prevent
# substrings captured by such calls from leaking to callers (e.g., subroutines,
# zsh code) by snapshotting the state of all captured substrings on entering
# such call and restoring such state on leaving such call. In other words,
# subroutines impose non-negligible time and space costs.
#
# For efficiency, subroutines should be leveraged *ONLY* where required.
# Typically, this means recursion matching delimiter-balanced syntactic
# constructs in a context-free manner. In all other cases, PCREs should be
# encapsulated as string variables and interpolated directly where used.
# typeset -g ZESHY__MACRO_SUBROUTINES

#  For
    # further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
# All PCRE subroutines defined below, concatenated in a manner preventing such
# definitions from matching. Such subroutines remain callable and hence are
# defined only for recursion purposes.

    # If *NO* macros were previously registered, clear the prior PCRE to
    # prevent spurious or scurrilous preprocessor behaviour.
    # (( ZESHY__MACRO_TO_FUNC_NAME )) || pcre_macro_or_code_optional_grouped=

    # Macro *OR* comment possibly containing zsh syntax-like substrings.
    # local pcre_macro_grouped_succeed_or_comment_optional=${pcre_macro_prefix}'(?:'${pcre_comment}'|'${pcre_macro_grouped_succeed}')?'

    # Macro, comprising such macro's name and all passed arguments. Since the
    # macro prefix is zero or more horizontal whitespace characters anchored to
    # the start of a line, such prefix is identical to a comment prefix and
    # hence matched below for both macros and comments.
    # local pcre_macro_grouped_succeed=${pcre_macro_name_grouped}${ZESHY__MACRO_ARGS_OPTIONAL_REPORT_SUCCESS}

    # local pcre_macros_grouped_succeed_or_codes_report_failure='(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_macro_grouped_succeed_or_comment_optional}'|'${pcre_code}'|.)*'${pcre_report_failure}

    # For efficiency, success is reported immediately after matching such
    # macro's last character (e.g., the last character of the last argument
    # passed to such macro). To distinguish syntactically valid from invalid
    # macros, *ALL* macro-specific substrings following such name are optional.

    # and :list.join_to_string_on_char().
    #FUXME: O.K.; technically, this works. But it's *SUPER* inefficient.
    #Why? Because it forces pcre_match() calls *NOT* matching a macro te be
    #ignored and simply iterated past. This is horrible, and should be
    #correctable. (Or... maybe not. Contemplate further.)
    #FUXME: Actually, this is erroneous! "^" and "$" are zero-width assertions
    #consuming no characters. Hence, we'll need to manually consume newlines.
    #Sadly, we've probably screwed this up above as well, where we're matching
    #argument block prefixes and suffixes. (Oh, and here-docs!)
    #FUXME: We're also fairly sure that newlines are *NOT* matched properly. A
    #concrete example: blank lines (i.e., "\n\n"). Do we match that?
    #FUXME: Split "${pcre_line_start_or_spaces_horizontal_spaces}'(?:'${pcre_comment}')?"
    #into a new PCRE above.

    # local pcre_macro_or_code_optional_grouped='(?:[^'${char_not_code_prefix}']++|'${pcre_char_escaped}'|'${pcre_macro_or_comment_optional_grouped}'|'${pcre_code}'|.)'

# For efficiency, match such macro's prefix below.
    # , where we may more efficiently match both
    # macros and comments.

    #FUXME: Use of ${pcre_spaces_horizontal_optional} both here and below is
    #probably erroneous.

    # Since the "." in ${pcre_here_doc_body} matches newlines, zero-width
    # assertions "^" and "$" are acceptable here.

    #FUXME: Use in place of "\v" below. *sigh*

    # By design, there exists no comparable PCRE local ${pcre_line_end} (i.e.,
    # matching the end of the current line, consuming the suffixing vertical
    # whitespace character if any). Since this PCRE consumes newlines,
    # permitting another general-purpose PCRE to consume newlines would
    # prevent this PCRE from matching in a general-purpose manner. (Not good.)

    # local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    # local pcre_word_spaces_prefixed_by_spaces_optional='\h*+(?:'${pcre_line_continuation}'\h*+)*'

    #FUXME: Optimizable. By the above ${pcre_words_spaces} technique, such
    #alternation may be improved by noting that ${pcre_args_zsh} and
    #${pcre_macro_arg_block} *MUST* always alternate.
    # local pcre_macro_args_optional='(?:'${pcre_empty_group}${pcre_continuable_spaces_horizontal}'(?:'${pcre_args_zsh}'|'${pcre_macro_arg_block}')*)'

    # One or more command-specific whitespace sequences. Since line
    # continuations are merely ignorable rather than actual whitespace, match
    # at least one horizontal whitespace character. Interestingly, this
    # constraint engenders a simpler and presumably more efficient PCRE.
    #FUXME: Hmm. Don't we usually implicitly match prefixing line continuations
    #now by use of ${pcre_char_escaped}? Where doing so, replace use of this
    #PCRE by the slightly more efficient
    #${pcre_word_spaces_prefixed_by_spaces_optional} instead.

#  Technically, this
    # PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.
    # local pcre_word_spaces_optional='(?:\h*+'${pcre_line_continuation_optional}')*'

    #FUXME: We used to have "\h" in character classes here; now we effectively
    #have "\s", thus matching line continuations. While probably not a terrible
    #thing, this does seem slightly inefficient, given that
    #${pcre_macro_arg_block_or_comment_optional} *ALSO* attempts to match such
    #continuations
    #FUXME: O.K.; the core issue at hand is that
    #${pcre_macro_arg_block_or_comment_optional} is prefixed by
    #${pcre_continuable_spaces_horizontal}, itself prefixed by
    #${pcre_line_continuations_optional}, which is unnecessary in this case and
    #*ONLY* this case.

    #FUXME: Honestly, when in reality would we *EVER* see adjacent line
    #continuations? While we of course need to match such edge case, explicitly
    #optimizing for it as we do so here strikes us as useless. Supplant all use
    #of either of the following two PCREs by their singular versions above.

    # local pcre_continuable_spaces_horizontal='(?:'${pcre_line_continuations_optional}'\h++)+'${pcre_line_continuations_optional}
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}${pcre_word_spaces_prefixed_by_spaces}
    # local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}'|'${pcre_word_spaces_prefixed_by_line_continuations}')?'

    #FUXME: Hmm. Don't we *ALWAYS* implicitly match prefixing line
    #continuations now by use of ${pcre_char_escaped}? If so, this PCRE is
    #excisable and ${pcre_word_spaces_optional} reducible to:
    #
    #    local pcre_word_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}')?'
    #
    #We probably want to drop the "_prefixed_by_spaces", as well.
    #FUXME: Actually, since the PCRE above is the common case and the PCRE
    #below the edge case, consider just eliminating the PCRE below and instead
    #defining ${pcre_word_spaces_optional} as follows:
    #
    #    local pcre_word_spaces_prefixed_by_spaces='\h++(?:'${pcre_line_continuation_optional}'\h*+)*'

    # One or more command-specific whitespace sequences, prefixed by at least
    # one line continuation.
    # local pcre_word_spaces_prefixed_by_line_continuations=${pcre_line_continuations}'(?:\h++'${pcre_line_continuations}')*\h*+'

    #FUXME: This strikes us as increasingly absurdly overwrought. Reconsider.
       # local pcre_word_spaces_prefixed_by_spaces_optional='(?:'${pcre_word_spaces_prefixed_by_spaces}')?'

    #FUXME: O.K.; so we're not necessarily convinced that lookbehinds are
    #sufficient to match line continuations. Consider:
    #
    #    # Not a line continuation, due to being commented out.
    #    >>> # \
    #
    #We need to closely examine where we're using such continuations.
    # local pcre_line_continuation='(?<!\\)\\\v'

    # End of the current line, consuming the suffixing vertical whitespace
    # character if any. "$" is a zero-width assertion consuming no characters
    # and hence inappropriate for most uses below (excluding lookahead).
    # local pcre_line_end='(\v|\z)'

# (Disambiguating the two requires explicitly matching both.)
    # PCRE capturing the macro name and all block argument bodies in a
    # preprocessor macro. To distinguish syntactically valid from invalid
    # preprocessor macros, all syntax following the macro name is optional.

    # '\h++(?:'${pcre_line_continuations}'\h++)*'${pcre_line_continuations_optional}
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h++'${pcre_word_spaces_optional}

    # Zero or more command-specific whitespace sequences (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # most whitespace but excluding unescaped newlines (i.e., newlines *NOT*
    # prefixed by "\"). While escaped newlines are line continuations
    # preserving the current command and hence effectively whitespace,
    # unprefixed newlines are effectively semicolons terminating such command.
    #
    # Technically, this PCRE is reducible to the following:
    #
    #     local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    #
    # However, only either a longest string of horizontal whitespace followed
    # by a longest string of line continuation *OR* the latter followed by the
    # former signifies a run of such whitespace. In other words, the two must
    # alternate. Given that, a more efficient PCRE explicitly specifies such
    # alternation, avoiding unnecessary match failures and backtracking.
    # local pcre_word_spaces_optional='(?:\h++(?:'${pcre_line_continuations}'\h++)*'${pcre_line_continuations_optional}'|'${pcre_line_continuations}'(?:\h++'${pcre_line_continuations}')*\h*+)?'

    # local pcre_word_spaces_optional='(?:\h++|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h++'${pcre_word_spaces_optional}

#  (i.e., all substrings
    # connoting whitespace *NOT* terminating the current command), including
    # all whitespace except newlines *NOT* prefixed by "\". While "\"-prefixed
    # newlines are line continuations preserving the current command,
    # unprefixed newlines are effectively semicolons terminating such command
    #FUXME: Refactor inefficient negative character classes as follows both
    #here and below, wherever applied:

    #FUXME: Not quite. We need to ignore everything after a comment prefix "#"
    #until the end of the line, as well. Unfortunately, differentiating such
    #prefix from "#" characters embedded in other contents (e.g., variable
    #expansions, unquoted globs) is *HIGHLY* non-trivial.
    #
    #Actually, it shouldn't be. zsh comments should *ALWAYS* unconditionally be
    #detectable by being prefixed by either the start of the line *OR*
    #non-empty horizontal whitespace (assuming strings to be properly matched,
    #anyway). That doesn't appear to be the case for all other uses of "#",
    #which appear to *ALWAYS* be prefixed by something other than what prefixes
    #a comment. Hopefully, there exist no exceptions to such heuristic.
    #
    #Actually, *DO* we need to match comments? Well, yes, technically. Consider
    #the following:
    #
    #    # If we ignore comments, then the " basically causes havoc.
    #    if :is uuugh == u##gh :si { # " uhoh
    #        :macro
    #    }
    #FUXME: The above implies that we need to prevent unquoted "#" characters
    #prefixed by blahblah from being matched into macro argument lists. Such
    #characters *MUST* terminate such lists.

    #FUXME: The above also implies that we *DO* need to ignore double-quoted
    #strings and such as well here, to ensure proper matching of single-quoted
    #strings. Failure to do this *WILL* cause extreme parsing havoc. While this
    #does currently prevent us from embedding macros in process substitutions,
    #it's difficult to conceive of a situation in which we'd want to do so. So,
    #let's do this, execrable though it may be.

    #FUXME: Interesting. We've unrelatedly realized that, since "\"
    #unconditionally escapes the following character, we can reduce all
    #"\\[...]" alternatives to simply ${pcre_char_escaped}, where:
    #    local pcre_char_escaped='\\.'
    #We'll want to make such change everywhere, of course, including above.

# \\["'${char_not_embeddable_prefix}']
# \\[}'${char_not_embeddable_prefix}']
# \\[\]'${char_not_embeddable_prefix}']
# \\[)'${char_not_code_prefix}']
# \\[}'${char_not_code_prefix}']
# \\['${char_not_code_prefix}']
# \\[}'${char_not_code_prefix}']

    #FUXME: Fixmeplz. Actually, we're fairly certain we can excise this such
    #subroutine, convert this back into a PCRE local, and shift above.

    # Shell code, comprising all syntactic constructs obstructing zeshy
    # preprocessing and hence parsing of unquoted "{" and "}" characters.
    # Unlike shell word matching, this does *NOT* include unquoted characters.
    # pcre_subroutines_body+='(?<code>'${pcre_quotes_single}'|'${pcre_here}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}')'

#\s)''"$\\<`
    #FUXME: Avoid repetition. We're seeing the following character classes
    #heavily reused. Abstract out to a sensible string local above.

    #FUXME: And comments, please! Wait. Actually, comments probably have to be
    #embedded directly into PCREs below due to matching prefixing whitespace.
    #FUXME: Wait. Can't we just insert comments here and be done with it?
    #FUXME: Substitute me below for all instances of "(?&code)".

    #FUXME: The inefficient subroutine call "(?&code)" matches non-recursive
    #constructs (e.g., single-quoted strings, here-documents, here-strings).
    #Such constructs should simply be matched here with an embedded PCRE.

    # One or more horizontal whitespace characters followed by zero or more
    # such words. If one or more such words match, such words must be suffixed
    # by one or more horizontal whitespace characters.

#  Since the first
    # and last such substrings are constrained to also be shell words,
    # whitespace is permitted only between shell words.
    # Such word *OR* word-delimiting whitespace.
    # local pcre_word_or_spaces='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_continuable_spaces_horizontal}')'

    # Such PCRE interpolates the PCRE matching substitutables and hence must be
    # declared *AFTER* the latter.

    # Here-documents and -strings are *NOT*
    # freely mixable with standard arguments and hence unmatched here.

    # ..................{ MACRO ~ space                      }..................

    #FUXME: We're fairly certain that our comment prefix still isn't quite
    #right. Investigate: are comments immediately prefixed by line
    #continuations comments? We suspect not. That said, the zeshy codebase
    #doesn't currently contain any such monstrosities, so we can probably
    #neglect this.
    #FUXME: We're fairly sure we match line continuations anywhere where we
    #would also match comments. Verify this below.

    #FUXME: Excise this and ${pcre_here_doc_quotes}, when no longer required.
    # local pcre_here_doc_quotes_prefix=${pcre_here_doc_prefix_ignore}'(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}')$'
    # local pcre_here_doc_quotes=${pcre_here_doc_quotes_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    #FUXME: "{" and "}" are *ONLY* shell-reserved when preceded and followed
    #(respectively) by whitespace. This requires correcting. To ascertain a
    #proper fix, examine where this character class is actually used.
    #FUXME: Right. 

#  excluding "}" as a shell-reserved
    # character requires somewhat more finesse. ${pcre_word_unquoted}.
    # local pcre_brace_right_lookahead='$|'${pcre_continuable_spaces_horizontal}
    #FUXME: Use line continuation PCREs instead, once we correct them.

    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\\v)*)?'

    #FUXME: Use of ${pcre_continuable_spaces_horizontal} is somewhat inefficient here. We only need to
    #match up to the first horizontal whitespace.
    #FUXME: Actually, it's also wrong. As the comment above indicates, such "}"
    #must be suffixed by at least one horizontal whitespace *OR* newline
    #character (optionally preceded by zero or more line continuations).
    # local pcre_line_continuation='(?<!\\)\\\v'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}'(?:\\\v)*)?'
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}

    #FUXME: Shift such "\h++" up into a new comment prefix PCRE.

    # local pcre_macro_arg_block_prefix='\{'
    # local pcre_macro_arg_block_suffix_lookahead=${pcre_continuable_spaces_horizontal}'|\Z'
    # local pcre_macro_arg_block_suffix='\}(?='${pcre_macro_arg_block_suffix_lookahead}')'

#  Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline *NOT* prefixed by an unescaped
    # backslash (i.e., line continuation).
    # excluding the escape prefix "\".
# excluding:
    #
    # * Whitespace characters.
    # * Shell-reserved characters
    #FUXME: Still require ${pcre_embeddable_or_char_escaped}?

    # local pcre_math_substitution_parens='\((?:\\[\\)$`]|[^)$`]|(?&sub)|(?!\)\)).)*\)'
    # local pcre_math_substitution_braces='\[(?:\\[\\]$`]|[^]$`]|(?&sub)|[^]])*\]'
    # local pcre_var_expansion='\{(?:\\[\\}$`]|[^}$`]|(?&sub)|[^}])*\}'

    #FUXME: Prefixing whitespace will need to be integrated with other PCREs.

    # local pcre_macros_or_code_optional_grouped='\A(?:\\[\v\\''<]|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|[^''<]|'${pcre_quotes_single}'|'${pcre_here_doc_quotes}'|.)*\Z'

    #FUXME: Not quite right. We don't need to confine 
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}
    # local pcre_comment_optional_spaced='\h++'${pcre_comment}

    #FUXME: Comment support, please!
    # local pcre_macro_arg_block_nested=${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_word_spaces_optional='(?:\h|'${pcre_line_continuation}')*'
    # local pcre_continuable_spaces_horizontal=${pcre_line_continuations_optional}'\h'${pcre_word_spaces_optional}
    # local pcre_comment_optional_spaced='\h++'${pcre_comment}

    # local pcre_macro_arg_block_nested=${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block_prefix}'(?&block))?'
    # local pcre_macro_arg_block_body='(?:\\[\\\h}''"$<`]|'${pcre_macro_arg_block_nested}'|[^}''"$<`]|(?&code)|[^}]|\}(?!'${pcre_macro_arg_block_suffix_lookahead}'))*'

    # local pcre_code_or_comment=${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_here}'|(?&sub)'

    #FUXME: Need to match and ignore comment lines. *sigh*
    #FUXME: Ugh; can't define this here. But we *DO* need to explicitly match
    #here strings. Ah! Right. Simple. All we do is match the "<" and let all
    #following text be matched by other means elsewhere.
    #FUXME: Wait. Not quite true. We match here strings for a variety of
    #purposes. We'll need to shift this below and come up with something else
    #here. New nomenclature would help.

    # local pcre_quotes_double_prefix='"(?:\\[\\"$`]|[^"$`]|'
    # local pcre_quotes_double_suffix='|[^"])*"'
    # local pcre_quotes_double=${pcre_quotes_double_prefix}${pcre_embeddable_or_char_escaped}${pcre_quotes_double_suffix}
    # local pcre_quotes_double_noncode=${pcre_quotes_double_prefix}${pcre_embeddable_noncode}${pcre_quotes_double_suffix}

#  Unlike shell word matching, this does *NOT* include
    # unquoted characters.
#  and hence parsing of unquoted "{" and "}" characters
    # Single- or double-quoted string.
    # local pcre_quotes_optional=${pcre_quotes_single}'|'${pcre_quotes_double}

    #FUXME: Also omit embedded substitutions. For that reason, rename
    #"_literal" to "_literal" globally.

    #FUXME: O.K.; so, we mucked this up a bit. For both generality and
    #efficiency, replace *ALL* instances of "\R" (and ideally of "\v" as well,
    #though that naturally doesn't apply to negative character classes) by:
    #
    #* End-of-line assertion "$".
    #* Enable multiline mode with "(?m)" above.

    #FUXME: Slightly erroneous. We make the dangerous assumption in
    #::code.preprocess() that such PCRE matches only ASCII characters. Clearly,
    #however, both "\h" and "\R" match multibyte characters. To correct this
    #discrepancy, we'll want to match only the explicit ASCII characters
    #satisfying horizontal and vertical whitespace requirements in a
    #cross-platform portable manner (think Windows line endings) *AND* replace
    #all instances of "\h" and "\R" below by similar constructs.
    #
    #Unfortunately, "libpcre" documentation notes that:
    #
    #"The choice of newline convention does not affect the interpretation of
    # the \n or \r escape sequences or \R." This implies we'll need to:
    #
    # * Test the OS already detected by ={inspect}.
    # * Define a new string local ${pcre_newline} expanding to the OS-specific
    #   PCRE matching newlines.
    #
    # Annoying, but certainly feasible. For now, the current implementation
    # appears to be basically acceptable.

    #FUXME: A minor issue. If ${ZESHY__MACRO_NAMES} is empty, the resulting
    #PCRE will match in a fairly disastrous manner. Guard against such inept
    #edge cases, please.

    #FUXME: Incorrect. We want to ignore preceding newlines prefixed by "\"
    #(i.e., line continuations). Hence, explicitly match line continuations in
    #the PCRE immediately above.

    #FUXME: ${pcre_line_continuations_optional} is somewhat inefficient here.
    #By PCRE definition, we should't need to lookbehind. Or perhaps we do still
    #need lookbehind? It's either that or lookahead. Hm; honestly, cutting
    #${${pcre_line_continuations_optional}} *ENTIRELY* and then prefixing
    #${pcre_macro_prefix} by a negative lookbehind assertion ensuring such
    #newline to *NOT* be preceded by an unescaped backslash seems like the
    #somewhat simpler and hence more efficient implementation, yes?
#(?!'${pcre_macro_arg_block_suffix}')
# ${pcre_continuable_spaces_horizontal}${pcre_macro_arg_block_prefix}'|'

#(?!<<)(?:
#'${pcre_line_continuations_optional}'|
    #FUXME: Implement me for use below.
    # local pcre_here_string_quotes_single='<\s*+'${pcre_word_passable_with_parens_balanced}

    # local pcre_zsh_grouped='(?:'${pcre_line_continuations_optional}'|'${pcre_macro_prefix}'(?:'${pcre_macro_grouped}')?|(?!<<)(?:[^'']|'${pcre_quotes_single}'|.))*'

# local pcre_line_continuations_optional='(?<!\\)(?:\\\R)*'
    # local pcre_line_continuations_optional='(?:'${pcre_line_continuation}')*'

    #FUXME: Improve similar negative lookahead assertions elsewhere.

    #FUXME: Honestly, "(?!<<)" seems a bit silly. Ideally, since neither
    #here-documents or strings are recursive, such substrings should be matched
    #by an embedded PCRE here rather than a subroutine call.

    # local pcre_math_substitution=${pcre_math_substitution_parens}'|'${pcre_math_substitution_braces}
    #FUXME: For efficiency, combine this with ${pcre_math_substitution_parens}.

    #FUXME: Sadly, we're fairly confident we need to back out most subroutine
    #calls below. The reason, of course, is inefficiency. PCRE appears to treat
    #subroutines as genuine boundaries for certain purposes; in particular,
    #PCRE copies all match groups prior to a subroutine call and then restores
    #such groups after such call. Hence, while subroutines are a fantastic
    #means of enabling recursion *AND* isolating match groups, they should be
    #avoided for all other purposes. Since we extensively leverage recursion
    #below, we *DO* need to retain subroutine support -- but only for these
    #specific purposes.

#FUXME: We should probably augment such PCREs to also capture optional here-
#documents and -strings passed to such macros and then pass either sort of
#string to such macro function on standard input as a simple here-string. The
#current approach is rather kludgy, it should be admitted. It's also not
#terribly general; after all, macros should be able to modify their output
#based on whether or not they were passed standard input as well as the exact
#content of that input. (It's only sensible, and not terribly difficult to
#implement, given current here-document and -string syntax support.)

    #FUXME: Not right either here or below. All PCRE fragments of the form
    #"[^"$`]|(?&sub)" *NEED* to be switched to
    #"(?&sub)|[^"]". Simple, thankfully.
    #FUXME: Actually, we can achieve the best of both worlds as follows:
    #    [^"$`]|(?&sub)|[^"]

    # local pcre_macro_arg_block_prefix='\{'${pcre_continuable_spaces_horizontal}''
    # local pcre_macro_arg_block_suffix=${pcre_continuable_spaces_horizontal}'\}(?:'${pcre_continuable_spaces_horizontal}'|\Z)'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')*'
    # local pcre_macro_arg_block_nested=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_nested_body}${pcre_macro_arg_block_suffix}
    # pcre_subroutines_body+='(?<block>'${pcre_macro_arg_block_nested}')'

    # pcre_subroutines_body+='(?<macro>'${(j:|:)ZESHY__MACRO_NAMES}')'

    # local pcre_math_substitution='(?:'${pcre_math_substitution_parens}'|'${pcre_math_substitution_braces}')'

    #FUXME: Pointless. Excise, please.

    # Non-recursive variable expansion *OR* a literal "$" character. To match
    # the latter, match zero or more such characters. See
    # ${ZESHY_VAR_NAME_GLOB}.
    #
    # Since we prefix such PCRE by "$" below, avoid doing so here.
    # local pcre_var_expansion_nonrecursive='[a-zA-Z_][a-zA-Z0-9_]*+'

    # Variable expansion.
    # local pcre_var_expansion='(?:'${pcre_var_expansion_nonrecursive}'|'${pcre_var_expansion_recursive}')'

    #FUXME: We probably expand such locals above. Correct circularities.
    #FUXME: Shift back above, actually.

    # local pcre_here_unsubstitutable='(?:'${pcre_here_prefix}${pcre_here}')?'

    #FUXME: Fairly certain that, as currently defined, this will erroneously
    #match *ALL* block arguments in the current code rather than merely those
    #passed to the current macro. Why? Because we haven't anchored the start of
    #such PCRE to the end of the prior iterative match. While we can't quite
    #recall how to go about such anchoring, we suspect that PCRE documentation
    #for pcre_match() should lend some insight.

# '${pcre_quotes_optional}'|'${pcre_here}'|

    #FUXME: Convert to a conventional PCRE variable.
    #FUXME: Actually, we no longer need this at all. We never did! Rather than
    #calling the "(?&dollar)" subroutine in
    #${pcre_process_substitution_dollar_nonrecursive}, simply call the conventional
    #"(?&sub)" subroutine preceded by negative lookahead preventing a backtick
    #from matching. Since this form of process substitution is heavily
    #discouraged anyway, efficiency is of little to no concern.

    # Any of the above "$"-prefixed syntactic constructs.
    # local pcre_dollar_construct+=

    #FUXME: Woops. Wherever we match an escaped character (e.g., "\\[)]"), we
    #need to match a an escaped "\\" *BEFORE* matching such character. Why?
    #Consider "$(( \\))". This is (sort of, anyway!) a balanced arithmetic
    #expansion and must be treated as such.
    # local pcre_backslash_escaped='\\\\'

    # When applied in an iterative context,  
    # of the first
    # byte following the last byte of the prior match. 

    #    :func :void :outer1() {
    #         :func :void :mid1() {
    #         }
    #    }
    #
    #    :func :void :outer2() {
    #         :func :void :mid2() {
    #             :func :void :inner1() {
    #             }
    #         } {
    #             :func :void :inner2() {
    #             }
    #         } <<'/---
    #    /---
    #         :func :void :mid3() {
    #             :func :void :inner3() {
    #             }
    #         } {
    #             :func :void :inner4() {
    #             }
    #         } <<'/---
    #    /---
    #    } <<'/---
    #    /---

    #FUXME: Not quite right. Rather than ineptly trying to coerce
    #${pcre_args_zsh} and ${pcre_continuable_spaces_horizontal} together, we probably
    #probably want a new PCRE adroitly aggregating both.
    # local pcre_word_spaces_words_optional_grouped='('${pcre_continuable_spaces_horizontal}'(?:'${pcre_args_zsh}${pcre_continuable_spaces_horizontal}')?)'

    # local pcre_args_zsh=${pcre_word_passable_with_parens_balanced}'(?:'$pcre_word_or_spaces'*'${pcre_word_passable_with_parens_balanced}')?'
    # local pcre_args_zsh='(?:'${pcre_word_passable_with_parens_balanced}'(?:(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_continuable_spaces_horizontal}')*'${pcre_continuable_spaces_horizontal}')?)?'

    # Such PCRE implicitly requires backtracking and hence cannot be optimized
    # with atomic grouping.
    # local pcre_continuable_spaces_horizontal='(?:\h|\\\R)*\h(?:\h|\\\R)*'

        # ZESHY__MACRO_MATCH_INDEX_HERE_DOC_OR_STRING
    # local pcre_args_zsh='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_continuable_spaces_horizontal}')*'${pcre_word_passable_with_parens_balanced}

    #FUXME: We've mucked up, it would appear. Expansions of ${pcre_word_passable_with_parens_balanced}
    #should have been expansions of this PCRE. (Ugh.)

    # local pcre_macro_args_optional_grouped='('${pcre_macro_args_optional}')'

    # To do so, append such definitions to ${pcre_subroutines_body}
    # and, after doing so, prefix and suffix ${pcre_subroutines_body} by the prefix
    # and suffix defined below below.  and then interpolate such string into a PCRE guaranteed to
    # never match and hence capture.

    # supports such behaviour by ignoring
    # all content aside from defining named and numbered capturing
    # groups in such content.

# efficiency and readability purposes.
    # pcre_subroutines_body+='(?<quote>'${pcre_quotes_single}'|'${pcre_quotes_double}')'

    # Declare indices matched by ${ZESHY__PREPROCESS_PCRE}, ignoring match groups
    # required only for internal use in such PCRE -- including:
    #
    # * Match group 1, capturing prefixing indentation.
    # match_index=2

    #To do so, see the section "Newline conventions" in "man pcrepattern".
    #Specifically, to quote:
    #
    #"It is also possible to specify a newline convention by starting a  pat-
    # tern string with one of the following five sequences:
    #
    #    (*CR)        carriage return
    #    (*LF)        linefeed
    #    (*CRLF)      carriage return, followed by linefeed
    #    (*ANYCRLF)   any of the three above
    #    (*ANY)       all Unicode newline sequences"
    #prepend the appropriate pattern option to the PCRE globals we construct
    #below.

    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'

    #FUXME: Replace subroutine calls called in only one place with low-level
    #variable expansions.
    #FUXME: Compress PCREs together. For example, we don't benefit from
    #separate ${pcre_macro_arg} and ${pcre_macro_args} PCREs.

    #FUXME: Capture block arguments. 
    #FUXME: Define match index globals. This is going to considerably more
    #troublesome than it otherwise would, due to each named group being
    #unconditionally captured. We'll have to ignore all such groups in a sane
    #way -- probably by incrementing in integer local here immediately after
    #defining any ignorable named group (which will be most if not all of them).

    # ZESHY__PREPROCESS_PCRE=${pcre_macro_indentation}${pcre_macro_name}${pcre_macro_args_optional_grouped}${pcre_subroutines}

    #FUXME: Convert ${pcre_macro_arg_block} into a subroutine.

    # Zero or more arguments of any type. Since we match a run of shell words
    # greedily, avoid matching consecutive runs of shell words for efficiency.

    # local pcre_macro_args_optional='(?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'(?:(?&spaces)'${pcre_macro_arg_block}')?|'${pcre_macro_arg_block}'))*'

    #FUXME: This may be optimizable by noting that ${pcre_word_passable_with_parens_balanced}
    #matches greedily and hence cannot by definition match consecutively.
    # local pcre_macro_args_optional_grouped='((?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}'))*)'

# local pcre_macro_args_optional_grouped='((?:'${pcre_continuable_spaces_horizontal}'(?:'${pcre_macro_arg_block}'|'${pcre_word_passable_with_parens_balanced}'(?&spaces))?'${pcre_macro_arg_block}'))*)'
    # Zero or more runs of whitespace or shells words ending in a shell word.
    # local pcre_words_optional='(?:'${pcre_word_passable_with_parens_balanced}')?'

    # Argument of any type prefixed by one or more horizontal whitespace
    # characters followed by zero or more shell words.
    # local         pcre_macro_arg=${pcre_macro_arg_block}
    # local pcre_macro_arg_grouped=''${pcre_continuable_spaces_horizontal}''${pcre_words_optional}${pcre_macro_arg_block_grouped}

#matched from a previously captured macro argument list
#''${pcre_continuable_spaces_horizontal}''
    #FUXME: For efficiency, split the "'${pcre_continuable_spaces_horizontal}'" prefixing each such PCRE out
    #into this PCRE instead.

    # local pcre_macro_arg_block_prefix=''${pcre_continuable_spaces_horizontal}'\{(?&spaces)'
    # local    pcre_macro_arg_block_nested_prefix='\{'${pcre_continuable_spaces_horizontal}''

    # local        pcre_macro_arg_block_suffix=''${pcre_continuable_spaces_horizontal}'\}(?:(?&spaces)|\Z)'
    # local pcre_macro_arg_block_nested_suffix=''${pcre_continuable_spaces_horizontal}'\}(?&spaces)'

    # local pcre_word_passable_with_parens_balanced=''${pcre_continuable_spaces_horizontal}'(?:'${pcre_word_passable_with_parens_balanced}'|(?&spaces))*(?&word)'

    #FUXME: Define all remaining ${ZESHY__MACRO_MATCH_INDEX_ARG_*} globals.

        # ZESHY__MACRO_MATCH_INDEX_ARG_1
        # ZESHY__MACRO_MATCH_INDEX_ARG_2
        # ZESHY__MACRO_MATCH_INDEX_ARG_3

    # local        pcre_macro_arg_block_nested_body='(?<blockb>(?:'${pcre_continuable_spaces_horizontal}'(?&block)?|\\[''"$`<]|(?!<<)[^''"$`]|(?&code))*'
    # local pcre_macro_arg_block_body='(?:(?!'${pcre_macro_arg_block_suffix}')'${pcre_macro_arg_block_nested_body}')'

    # local        pcre_macro_arg_block_body='(?:'${pcre_continuable_spaces_horizontal}'(?&block)?|\\[''"$`<]|(?!<<)[^)''"$`]|(?&code))*?'
    # local pcre_macro_arg_block_nested_body=${pcre_macro_arg_block_body}

 # While we would prefer
    # *NOT* to capture such expansion, recursive pattern matching in "libpcre"
    # requires interior back references to the outermost syntactic construct
    # recapitulating such recursion. Such groups are recursion-specific and
    # hence *MUST* be explicitly ignored for all other purposes.
    # Macro indentation. Since *ALL* zeshy scripts are currently guaranteed to
    # be prefixed by a shebang line, all non-shebang and hence macro lines are
    # guaranteed to be prefixed by a newline.
    #
    # Since such indentation is guaranteed to be the first match group, we
    # match such indentation with numbered back references (e.g., "\g1").
    # local pcre_macro_indentation_grouped='(\R\h*+)'

    # Block argument (i.e., "{"- and "}"-delimited substring containing
    # arbitrary zeshy code, including block arguments nested at deeper
    # indentation levels) specific to preprocessor macros. Since such macros
    # are currently matched solely by prefixing indentation regardless of zsh
    # context (i.e., ignoring string literals, variable expansions, and other
    # syntactic constructs), the "}" delimiting such argument is also matched
    # solely by the same prefixing indentation.
    #
    # Such "}" must be suffixed by at least one horizontal space or the end of
    # such code. To support macros accepting two or more consecutive argument
    # blocks, merely assert this constraint with positive lookahead.
    # local pcre_macro_arg_block_prefix=''${pcre_continuable_spaces_horizontal}'\{(?&spaces)'
    # local pcre_macro_arg_block_body='.*?'
    # local pcre_macro_arg_block_body_grouped='('${pcre_macro_arg_block_body}')'
    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_continuable_spaces_horizontal}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

    # local pcre_macro_arg_block_suffix='\g1\}(?:'${pcre_continuable_spaces_horizontal}'|\Z)'
    # local pcre_macro_arg_block_suffix_ahead='\g1\}(?='${pcre_continuable_spaces_horizontal}'|\Z)'
    # local         pcre_macro_arg_block=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body}${pcre_macro_arg_block_suffix}
    # local pcre_macro_arg_block_grouped=${pcre_macro_arg_block_prefix}${pcre_macro_arg_block_body_grouped}${pcre_macro_arg_block_suffix_ahead}

#         ZESHY__MACRO_MATCH_INDEX_ARGS_END
# ${pcre_empty_group}
    # local pcre_macro_args_optional_grouped='(?:(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block_grouped}')((?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block_grouped}')*))?'

        # ZESHY__MACRO_MATCH_INDEX_ARG_1
        # ZESHY__MACRO_MATCH_INDEX_ARGS_2_OR_MORE

    #FUXME: Not quote right. We require spaces after a macro name *AND* before
    #a "{", but we can only match such spaces once. How?

    # '(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block_grouped}')*'
    # '(?:'${pcre_macro_args_optional_grouped}')?'${pcre_subroutines}
    # ZESHY__PREPROCESS_PCRE=${pcre_macro_indentation_grouped}${pcre_macro_name}'(?:'${pcre_continuable_spaces_horizontal}${pcre_macro_args_grouped}')?'${pcre_subroutines}

    # One or more runs of whitespace or shells words both initiating and
    # terminating in a shell word.
    #
    # The former condition is purely an optimization concern. The latter
    # condition, however, is not; it prevents this PCRE from matching
    # substrings ending in a run of whitespace, ensuring such whitespace will

    #FUXME: Such subroutines are embedded only in the following PCRE fragment:
    #    (?=\$)(?:(?&var)|(?&math)|(?&proc))
    #Hence, simplify this by refactoring this and the other subroutines into
    #PCREs and embedding them directly in a new subroutine <dollar>.

    #FUXME: Insufficient, as it currently fails to match multiple adjacent line
    #continuations. Hmmm.

    # pcre_subroutines_body+='(?<spaces>(?:\\\R)?(?:\h++(?:\\\R)?)+)'

    #FUXME: Such "}" must be matched as prefixed by a newline (\R) followed by
    #the same exact horizontal whitespace as the initial macro. We currently
    #match this as named group "(?&indent)" below. Such group *MUST* contain
    #such newline.

# (?=\$)(?:(?&var)|(?&math)|(?&proc))

    #FUXME: Match the same embedded constructs as above.
    #FUXME: Perhaps simpler to replicate the definition of
    #${pcre_process_sub_recursive} here, augmented with a negative lookahead
    #assertion to prevent matching of an unescaped "`". Ignore for now;
    #somewhat too much complexity, here!

    # local pcre_process_substitution_dollar_nonrecursive='`(?:\\[''"$`<]|(?!<<)[^''"$`]|(&squote)|(&dquote)|(&here)|(?=\$)(?:(?&var)|(?&math)|(?&proc)))*`'

    # Unquoted shell word.
    # pcre_subroutines_body+='(?<uword>[^\s'${char_not_literal_with_parens_balanced}']++)'

    # Character class matching shell-reserved characters.
    # local char_not_literal_with_parens_balanced='''"$<>{}|`'
    # local pcre_word_literal='[^\s\\'${char_not_literal_with_parens_balanced}']++'

    #FUXME: For each named subroutine below, we need to directly embed the
    #definition of such subroutine somewhere in ${ZESHY__PREPROCESS_PCRE} --
    #ideally, before the first call to such subroutine in such PCRE. (Yes, this
    #is somewhat annoying.)

    # Suffix suffixing all subroutines defined below, preventing such
    # subroutines from matching. Since such subroutines remain callable, To ensure this:
    #
    # * Suffix each subroutine definition by a suffix guaranteeing such
    #   definition to never match.

    # local pcre_subroutine_suffix='{0}'

    # As in Perl (but not Ruby), "libpcre" subroutine calls (e.g.,
    # "(?&soma)") do *NOT* capture the substring matched by such call if any.
    # As in both Perl and Ruby, subroutine definitions (e.g.,
    # "(?<soma>All the advantages of Christianity and alcohol; none of their defects.)"
    # capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is somewhat
    # noxious. In most cases, we would prefer such definitions to *NOT*
    # capture. Unfortunately, we have little alternative but to ignore the
    # groups captured by such matches.
    #
    # To facilitate this, increment ${match_count_ignore} (an integer local
    # counting the total number of ignorable match groups) after every
    # subroutine defined below.

    #FUXME: We had a reasonably clever idea. Will it work? Only CLI testing
    #will demonstrate the feasibility of the idea. If it *DOES* work, that'd be
    #reasonably awesome. So, what's the idea? Since subroutine definitions
    #implicitly capture *AND* since that's bad, shift all such definitions past
    #the valid end of the PCRE (e.g., "$") into a region guaranteed *NOT* to
    #match, reserved for only defining subroutines. Such subroutines would
    #never be matched as definitions but only called, avoiding all such
    #capturing issues.
    #FUXME: Sweet. Both of the following work as advertised:
    #
    #    >>> :is yum =~ '(?&yam)(?<yam>yum){0}' :si and print ok
    #    ok
    #    >>> :is yum =~ '(?<yam>yum){0}(?&yam)' :si and print ok
    #    ok
    #
    #Subroutine definitions suffixed by "{0}" are thus guaranteed to never
    #match and hence capture. Fairly awesome!

    #FUXME: Suffix all subroutines defined below by such PCRE fragment.

    # # Declare indices matched by ${ZESHY__PREPROCESS_PCRE}.
    # match_index=1

    # #FUXME: Correct names.
    # # Declare indices preceding the first ignorable match group.
    # for match_index_name (
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_ATTRS
    #     ZESHY_CALLABLE_PROTOTYPE_MATCH_INDEX_NAME
    # ) {
    #     integer -g ${match_index_name}=$(( match_index++ ))
    #     print -r ${match_index_name}': '${(P)match_index_name}
    # }

    # # Increment the index of the next ignorable match group past all
    # # intermediate match groups.
    # match_index+=${match_count_ignore}

    # #FUXME: Declare subsequent groups.

    # integer match_count_ignore=0
    # match_count_ignore+=1

 # Right? Wrong. There appears to be a bug in either
    #"libpcre" or zsh (...guess which, presumably?) forcing
    # local pcre_continuable_spaces_horizontal='(?:\h|\\\R)++'

 # all macros (including names and block arguments) in
    # arbitrary code.

    #FUXME: Use of named references complicates match indexing. I beliewe we
    #can circumvent this, however, by leveraging named subroutines: that is,
    #declaring *ALL* named references at the very end of the regex.

    # # Argument of any type.
    # local pcre_macro_arg='(?:'${pcre_word_passable_with_parens_balanced}'|'${pcre_macro_arg_block}')'

    # # One or more arguments of any type.
    # local pcre_macro_args=${pcre_macro_arg}'+'

    #FUXME: This still used? Probably... not.

    # One or more arbitrary characters excluding shell-reserved characters.
    # local pcre_chars_unreserved='(?:\\\R|[^\v'${char_class_ureserved}'])++'

    # ZESHY__MACRO_NAMES_PCRE
    # ZESHY__MACRO_NAMES_PCRE=${}

    #FUXME: Excise me.

    # One or more whitespace-delimited shells words.
    # local pcre_word_passable_with_parens_balanced='(?:'${pcre_continuable_spaces_horizontal}'|'${pcre_word_passable_with_parens_balanced}')+'

    #FUXME: Match only whitespace delimiting such words -- *NOT* prefixing such
    #words. This should simplify matching of block arguments a bit.
    # local pcre_word_passable_with_parens_balanced='(?:(?:'${pcre_word_passable_with_parens_balanced}'(?:\\\R)?\h++(?:\\\R)?))*'${pcre_word_passable_with_parens_balanced}')?'

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

    #FUXME: This is actually used. ${pcre_continuable_spaces_horizontal}, however, doesn't really
    #appear to be. Excise the latter and shift such documentation here.
    # local pcre_continuable_spaces_horizontal='(?:\h|\\\R)+'

    # local pcre_macro_arg_block_prefix='(?:\h(?:\\\R)?|(?:\\\R)?\h)\{'

    #FUXME: Excise. This is wrong, anyway. Matching line continuations is
    #*USELESS*, if one considers. We don't care about line continuations. They
    #signify 

    # local pcre_macro_arg_block_prefix='(?<=[ \t]|\\\v)\{'

 # Hence, we
    #really can't match this outside of the full PCRE. *shrug* 
# '(?:'${pcre_macro_arg}')*(?&arg)'

    # Customary argument for zsh commands, comprising one or more of the prior
    # syntactic constructs.
    # local pcre_macro_arg_command='(&word)+'

# '(?<word>(&uword)|(&squote)|(&dquote)|(?&sub))'

# ${pcre_chars_unreserved}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_embeddable_or_char_escaped}'
    #FUXME: Correct me. Then just 
    # local pcre_code_sans_process_sub_nonrecursive='(?<codet>))'

    #FUXME: Erhm. Excise?
    # local pcre_codes='(?:\\[''")$`<]|(?!<<)[^''")$`]|(?&code))*'

    #FUXME: A non-recursive version (e.g., matching "$ughugh") needs to be
    #defined as well, and a new umbrella PCRE matching both recursive and non-
    #recursive variable expansions assigned the overarching group "<var>".

    # local pcre_quotes_single_grouped="'((?:[^']|'')*)'"
    # local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    #FUXME: Also match process substitutions (of both ilk).
    #
    #Since zsh appears to search for terminating '"' delimiters in a prior
    #phase to that of variable expansions, we do *NOT* need to match variable
    #expansion here. (Isn't that nice?)

    #FUXME: Embedding ${pcre_quotes_single} here clearly isn't quite right.
    #While we *DO* want to match single quotes, we want to do so in a
    #"(?qsingle)" manner. Moreover, we want to match considerably more than
    #simply that: double quotes, here-doc strings, and so forth. *sigh*

    #FUXME: Unify with ${pcre_word_passable_with_parens_balanced}, perhaps?
    #FUXME: Right. ${pcre_code} should subsume ${pcre_word_passable_with_parens_balanced}, adding support for
    #here-documents and -strings. (Anything else?)

    # Here-document. Unfortunately, matching all possible here-document strings
    # is infeasible within the purview of a pure PCRE. Matching here-document
    # delimiters embedding escaped characters (e.g., '<<"mother\"destroyer"')
    # requires unescaping such characters -- a simple operation that, by
    # definition, exceeds the purview of pure PCREs.
    #
    # Hence, match only the proper subset of here-document strings with
    # delimiters containing no escaped characters. Since few to no real-world
    # here-document strings (certainly, none zeshy itself leverages) require
    # delimiters containing escaped characters, this is moderately ignorable.
    # local pcre_here_doc_prefix='<<-?\s*+(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}'|'${pcre_word_literal_grouped}')\R'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\R(?-1)'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

    # Here-string.
    # local pcre_here_string='<<<\s*+'${pcre_word_passable_with_parens_balanced}''

    #FUXME: Excise the above? Shift documentation here!

    #FUXME: No longer required, seemingly. Now that we've merged such matching
    #into ${pcre_chars_unreserved}, excise such PCRE.

 # (Since this PCRE is principally used to match here
    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # cannot 
    #
    # we have no sane means of
    # matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string).
    #
    # Why? Character escapes.  We're inclined
    #to ignore this, at the moment.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #FUXME: Fairly sure we can simplify this quite a bit. We don't *NEED* to
    #match individual arguments on the initial match of the full macro string.
    #In fact, we're fairly sure we don't *EVER* need to match individual
    #arguments. Hence, we can probably generalize ${pcre_macro_arg_command} above
    #with whitespace as follows:
    #
    #    local pcre_macro_arg_command='(?:'${pcre_continuable_spaces_horizontal}'|'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'
    #
    #Of course, that immediately suggests we combine ${pcre_continuable_spaces_horizontal} and
    #${pcre_sans_quotes_spaces} -- probably by omitting "\s" from the
    #definition of the latter. (In any case, it's all for the morrow!)

    # "$"- or "`"-prefixed embedded substitutable.
    # local pcre_embeddable_embedded='(?=[$`])(?&sub)'

# (?>[$`])

    #FUXME: O.K.; we're not going to be able to substitute this below as is.
    #The reason why is the "[^$]". We're afraid that will need to be extended
    #on a case-by-case basis. After doing so, we'll probably want to excise
    #this local entirely.

    # Any character excluding "$" *OR* a "$"-prefixed substitutable.
    # local pcre_char_or_substitutable='\\$|[^$]|(?&sub)'

    #FUXME: Also match recursively nestable process substitution.

    # While we prefer *NOT* to explicitly
    # match arithmetic substitutions, matching only the latter would match one ")" delimiter
    # in arithmetic substitutions as terminating such substitutions -- which,
    # clearly, is not the case.

    #FUXME: For maintainability, we probably want to use embedded named
    #references everywhere we currently use zsh variable embedding below.

    # Arbitrary string of one or more characters excluding characters reserved
    # for strict zsh argument parsing. This includes:
    #
    # * Dollar signs.
    # * Single and double quotes.
    # * Whitespace.
    # local pcre_sans_quotes_spaces='[^\s''"$]++'

    # local pcre_macro_arg_command='(?:'${pcre_sans_quotes_spaces}'|'${pcre_quotes_single}'|'${pcre_quotes_double}'|'${pcre_var_expansion}')+'

    #FUXME: Interestingly, this must be constructed at runtime, implying this
    #entire anonymous function should be converted into a named function
    #::preprocessor_pcres.make() called on *EACH* call to :macro(). Hmm. For
    #efficiency, perhaps:
    #
    #* :macro() should simply set ${ZESHY__PREPROCESS_PCRE} to the empty string.
    #* :code.preprocess() should call ::preprocessor_pcres.make() if
    #  ${ZESHY__PREPROCESS_PCRE} is the empty string.
    #
    #This permits multiple macros to be defined by a single parcel without
    #triggering multiple redundant PCRE compilations, which seems sensible.
    #FUXME: For usability, define a function ::preprocessor_pcres.clear() in
    #this parcel clearing such PCRE globals.

    # One or more such arguments.
    # Unquoted word in the strict zsh sense, comprising one or more characters
    # excluding whitespace and shell-reserved characters.
    # local pcre_word_unquoted='[^]'

    #FUXME: We *DO* need to match variables as well. Here's why:
    #
    #    >>> print ${:-
    #    ... :func
    #    ... }
    #
    #    :func
    #
    #Yes, that actually works. It's a hell of an edge case, but edge case
    #nonetheless. For robustness, we *MUST* account for all such cases.

    #FUXME: Minor issue. If the captured here-document word embeds quote
    #escapes (e.g., "ugh\"umu"), we have no sane means of matching the
    #corresponding terminator (e.g., in the prior example, we would need to
    #match 'ugh"umu' rather than the literally captured string). We're inclined
    #to ignore this, at the moment. (Indeed, fixing this may be infeasible!)
    #FUXME: Honestly, this is rather difficult to implement correctly. Given
    #such difficulty, we're inclined to instead 

    # local pcre_here_doc_prefix='<<-?\s*+(?|'${ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE}'|'${ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE}'|(\S++)\n'
    # local pcre_here_doc_body='.*?'
    # local pcre_here_doc_suffix='\g{-1}'
    # local pcre_here_doc=${pcre_here_doc_prefix}${pcre_here_doc_body}${pcre_here_doc_suffix}

#FUXME: Document me.
# # PCRE globals defined below.
# typeset -g\
#     ZESHY_SYNTAX_QUOTES_SINGLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE\
#     ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE\
#     ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE
# 
# # PCREs matching single-quoted strings in zsh format and hence supporting
# # escaped single quotes (i.e., "''").
#          ZESHY_SYNTAX_QUOTES_SINGLE_PCRE="'(?:[^']|'')*'"
# ZESHY_SYNTAX_QUOTES_SINGLE_GROUPED_PCRE="'((?:[^']|'')*)'"
# 
# # Double-quoted string in zsh format and hence supporting escaped double
# # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
# # matches "\" and hence must be matched *AFTER* matching the latter.
#          ZESHY_SYNTAX_QUOTES_DOUBLE_PCRE='"(?:\\"|[^"])*"'
# ZESHY_SYNTAX_QUOTES_DOUBLE_GROUPED_PCRE='"((?:\\"|[^"])*)"'

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ={*-soil/*-declare/*-pcre}.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
