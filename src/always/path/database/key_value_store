#!/usr/bin/env zsh
# ====================[ dir                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle disk-backed key-value stores (i.e., NoSQL-style databases storing only
# schema-less key-value pairs to disk). Since zsh currently lacks built-in
# support for such stores, emulate such support.
#
# --------------------( TODO                               )--------------------
# * While directory-style KVSs are a reasonable solution and should
#   absolutely be retained for cross-platform purposes, compressed "dar"-style KVSs
#   are probably ultimately the most efficient solution -- at least for retrieval.
#   Naturally, such solution only applies to systems installing "dar"... which,
#   let's face it, is probably not terribly many. Nonetheless, the Linux ecosystem
#   might eventually see fit to phase "tar" out in favor of "dar", at which point
#   such solutions become considerably more useful.

#FIXME: Rename to "kvs", as "kvs_dir" is *MUCH* more sensible than
#"key_value_store_dir". Then shift this component to "path/database/kvs/dir".
#FIXME: We'll need to *NON-RECURSIVELY* remove all *PLAIN FILES* in each
#such directory, first. Since this is potentially dangerous, I propose the
#following tried-and-true solution:
#
#* Define function clear_kvs_dir() to source a previously serialized shell
#  script "${dirname}/index" defining list ${kvs_dir_filenames}.
#* Define function set_kvs_dir_key() defining such key and if such key has not
#  been previously defined,
#
#This suggests a directory structure resembling:
#
#${kvs_dirname}/ # top directory
#  index         # file
#  store/        # subdirectory
#    ${keyname}  # 
#FIXME: Since key names are stored as filenames, some care must be taken to
#escape filesystem-reserved characters -- namely, "/" and "\0". (I believe those
#are the only characters reserved by the filesystem, yes?) Actually, they can't
#even be escaped -- they can't be included in filenames at all! This suggests we
#need to encode filenames, which is fairly annoying. Ah, yes. Of course we need
#to encode! "/" and "\0" aren't the only problematic substrings: "." and ".."
#are also reserved, of course.
#FIXME: O.K., we've now efficiently implemented this as function
#convert_string_to_pathname_hexadecimal_encoded_minimally_for_unix(). Great!

#FIXME: Storing keys as files in a single directory has significant scaling
#issues. While unlikely that I'll hit them anytime soon, it will probably merit
#solving at some point. The solution is fairly simple, here. Split keys into
#substrings of three or four characters and assign each such substring a new
#subdirectory under "store/": e.g.,
#
#store/
#  set_/
#    stri/
#      ing_/
#        to_st/     # subdirectory
#          ing      # actual file, signifying key "set_string_to_string"
#
#While this requires significantly more inode lookups, such lookups should be
#considerably faster than the one *EXTREMELY* slow lookup on the top-level
#"store/" directory inode when stuffing all keys in the same directory. Indeed,
#the following source suggests three character subdirectory names:
#http://serverfault.com/questions/343351/max-files-per-directory-in-ext4
#
#Since such implementation is slightly more complex (particularly on unsetting
#keys and clearing the store, which requires finding and removing empty
#subdirectories), let's defer this one to another day.

# ....................{ GLOBALS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string ZESHY_KVS_DIR_INDEX_BASENAME

Basename of the key-value store file caching all keys for such store. Such cache
improves safety by identifying spurious keys (i.e., keys _not_ added to the
store by key-value functionality but by some external user or process), which
such functionality avoids modifying or removing.
________________<heredoc?>________________
ZESHY_KVS_DIR_INDEX_BASENAME='store'

declare_function_with_stdin <<'________________<heredoc?>________________'
string ZESHY_KVS_DIR_STORE_BASENAME

Basename of the key-value store subdirectory storing key-value pairs. Each file
of such subdirectory is a key-value pair whose key is its filename (technically,
the hexadecimal decoding of its filename) and value is its file contents. Such
subdirectory contains no subdirectories.
________________<heredoc?>________________
ZESHY_KVS_DIR_STORE_BASENAME='store'

# ....................{ TESTERS                            }....................
#FIXME: Implement the corresponding exception.
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_kvs_dir(string dirname)

Return success if the passed directory is an existing key-value store.
________________<heredoc?>________________
function is_kvs_dir() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string dirname="${1}"

    # Test such directory.
    is_dir_writable "${dirname}/${ZESHY_KVS_DIR_STORE_BASENAME}"
}

# ....................{ MAKERS                             }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void make_kvs_dir(string dirname)

Create a key-value store under the passed directory, structured as follows:

* `${dirname}/${ZESHY_KVS_DIR_INDEX_BASENAME}`, the file caching all keys.
* `${dirname}/${ZESHY_KVS_DIR_STORE_BASENAME}`, the subdirectory storing all
  key-value pairs.
________________<heredoc?>________________
function make_kvs_dir() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string dirname="${1}"

    # Create such directory structure, if not already.
    make_dir_if_not_found "${dirname}/${ZESHY_KVS_DIR_STORE_BASENAME}"

    # Verify such directory structure to be writable, if already extant.
    die_unless_dir_writable "${dirname}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_kvs_dir_key(string dirname, string key, string value)

Set the passed non-empty key to the passed value in the key-value store at the
passed directory.
________________<heredoc?>________________
function set_kvs_dir_key() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one dirname, one key, and one value'
    string dirname="${1}" key="${2}" value="${3}" filename
    die_unless_kvs_dir "${dirname}"
    die_unless_string_nonempty "${key}" 'key empty'

    #FIXME: Implement me!

    # Set such key by creating a new file in such directory with basename such
    # key and file text such value. For safety, escape forward slashes in such
    # key (to avoid treating such slashes as directory separators).
    filename="${dirname}/$(escape_string_dir_separator "${key}")"
    if { is_file "${filename}" } {
        die
    } else {
        die
    }
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_dir_writable "${dirname}/${ZESHY_KVS_DIR_STORE_BASENAME}"
# If such directory already
#exists and is non-empty or not writable by the current user, throw an exception.
#   if { is_dir "${dirname}" } {
#       die_unless_dir_empty    "${dirname}"
#       die_unless_dir_writable "${dirname}"
#   }

#   die_if_dir_nonempty "${dirname}"

#FUXME: O.K.; the only substrings that need be encoded are:
#
#* "/".
#* "\0".
#* "\x", the percent-encoding prefix in zsh, due to printf() implementation
#  details. (See below.)
#
#The only strings that need be encoded are:
#
#* ".".
#* "..".
#
#Since *nix filenames can adequately encode *ALL* other strings, percent-encoding
#merely these suffices. Since we don't need to encode arbitrary characters, a
#simple global regular string replacement should suffice: e.g.,
#
#string convert_string_to_pathname_hexadecimal_encoded_minimally_for_unix() {
#    die_unless_args 'expected at least one string'
#    string pathname="${*}"
#
#    if is "${pathname}" == '.'|'..' si {
#       pathname='\x2E'
#       is "${pathname}" == '..' si and pathname="${pathname}${pathname}"
#    } elif is "${pathname}" == *('/'|"${ZESHY_ASCII_NULL}"|'\x')* si {
#       # Right. So we actually have to encode *ALL* "\" characters, not merely
#       # "\" preceding "x" characters. Why? Because efficiently decoding such
#       # strings below passes them through "echo -e", which recognizes all
#       # escape codes. That's bad, in this case, because it implies "\"-prefixed
#       # substrings (e.g., "\n") would be erroneously converted on decoding. So,
#       # we escape all such substrings here to prevent erroroneous decoding.
#       pathname="${${${${pathname//\//\x2F}//${ZESHY_ASCII_NULL}/\x00}//\\/\x5C}"
##      pathname="${${${${pathname//\//\x2F}//${ZESHY_ASCII_NULL}/\x00}//\\x/\x5C\x78}"
#    }
#
#    return_string "${pathname}"
#}
#
#Its counterpart is *FAR* simpler:
#
#string convert_string_from_pathname_hexadecimal_encoded() {
#    die_unless_arg 'expected one string'
#    echo -e "${1}"
#}
#
#Awesomeness.
#FUXME: Intuition served correct: everyone pretty much uses percent encoding to
#store filenames containing arbitrary characters. While I'm not convinced that
#that's the most efficient scheme, it does work. What about Base64?
#FUXME: O.K.; percent *DE*coding is astonishingly efficient in zsh:
#    printf ${url_encoded_string//%/\\x}
#That's it. Ridiculous, no? Apparently, printf() implicitly decodes all
#"\x"-prefixed hexadecimal integers into the corresponding character, thus
#implicitly supporting percent decoding *AFTER* replacing all percents with "\x".
#FUXME: Ah. Of course, in this case, we're using "\x" encoding, so decoding
#reduces to simply "printf ${key_filename}". That's it, which is great, as it
#makes reads slightly faster. Oh, but not. We have to encode the passed key
#string to such format, requiring iteration. Well, if the caller wanted
#something fast, they should have used "dar"! ;}
#FUXME: Do we ever actually need to decode key filenames? Probably not, sadly.
#But it's nice to know that we can do so efficiently, should we require. Also,
#note that both "echo -e ${key_filename}" and "printf ${key_filename}" suffice.
#FUXME: Contemplate renaming... possibly to, say, make_kvs_dir() or
#make_database_kvs_dir(). Hmmm; or not!
    #FUXME: Implement and uncomment me.
#   die_unless_dir_not_found_or_empty "${dirname}"
