#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file and directory listings.

# ....................{ LISTERS                            }....................
document_function '
string list_path(string ls_arg1, string ls_arg2, ...)

List the passed paths (defaulting to the current directory) with the passed
"ls" options.
'
function list_path() {
    run_with_options 'run_paged command ls' 'ZESHY_LS_OPTIONS' "${(q)@}"
}

# ....................{ LISTERS ~ concise                  }....................
document_function '
void list_path_concisely(string pathname)

Concisely list the passed path with the currently configured "ls"-specific
options, throwing an exception if any such path does not exist. Assuming default
Zeshy configuration settings, concise listings exclude path metadata (e.g.,
owner, permissions) and hence include only path basenames.
'
function list_path_concisely() {
    list_path_concisely_with_options -- "${@}"
}

document_function '
void list_path_concisely_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

Concisely list the passed paths (defaulting to the current directory) with both
the passed and currently configured "ls"-specific options, throwing an exception
if any such path does not exist. Assuming default Zeshy configuration settings,
concise listings exclude path metadata (e.g., owner, permissions) and hence
include only path basenames.
'
function list_path_concisely_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_CONCISE' "${(q)@}"
}

# ....................{ LISTERS ~ verbose                  }....................
document_function '
void list_path_verbosely(string ls_arg1, string ls_arg2, ...)

List the passed paths (defaulting to the current directory) with verbose
print_string and the passed "ls" options.
'
function list_path_verbosely() {
    run_with_options 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE' "${(q)@}"
}

# ....................{ LISTERS ~ recursive                }....................
document_function '
void list_path_recursively(string ls_arg1, string ls_arg2, ...)

List the passed paths (defaulting to the current directory) recursively with
verbose print_string and the passed "ls" options.
'
function list_path_recursively() {
    run_with_options 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_RECURSIVE' "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ ALIASES                            }....................
#interactive_substitution {l}s='list_path_concisely'
#interactive_abbreviation {l}s{l}ong='list_path_verbosely'
#interactive_abbreviation {l}s{r}ecursive='list_path_recursively'

#is_zeshy_wrapping_core_commands and
#interactive_alias dus='list_path_disk_usage_sorted'
#   print_path_verbosely --recursive "${@}"
#   run_with_options 'run_paged command ls' 'options' "${@}"
#FIXME: This and friends below really need to be reimplemented to use "--".
#And drop all of the funcstack nonsense. Slight changes, but... *shrug*
    # "ls" command to be run.
#   list ls; ls=( run_paged command ls "${ZESHY_LS_OPTIONS[@]}" )
#       "${ls[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}" "${@}"

    #FIXME: The conditional is pretty much broken. We really need to fix
    #Zeshy Digest so as to accept function aliases ala "print_path ls()".
    #Note that "content/grep" contains a similarly broken conditional.

    # If the topmost function on the function stack is "ls"-specific,
    # the current user called this function directly from the command-line.
#   if (( ${#funcstack} == 1 )) or is "${funcstack[-2]}" == print_path* si
#   then "${ls[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}" "${@}"
#   else "${ls[@]}" "${ZESHY_LS_OPTIONS[@]}" "${@}"
#   fi
#

    # Call is_shell_interactive() rather than is_shell_interactive_directly(). The embedded
    # conditional below implicitly implements the latter, already.
    # If running non-interactively, pass *NO* Zeshy-specific options to "grep".
    # Doing so breaks non-interactive shell scripts and functions expecting
    # default "grep" behavior (e.g., basic patterns).
#   else command ls "${@}"
#   fi

#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#       say "running \"${ls_command[@]} ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]} ${@}\"..."
#   if is_shell_interactive_directly
#   then "${ls_command[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#   else "${ls_command[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#   fi

#       say "running \"${ls_command[@]} ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]} ${@}\"..."
#       say "options: ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}"#interactive_alias l='list_path'
#interactive_alias ls='list_path'
#interactive_alias ls='list_path_recursively'
#'ls --all --color=always --group-directories-first --human-readable --indicator-style=classify --quoting-style=shell --sort=version --time-style=long-iso'
#lr()  { ls --recursive               $* | less --no-init }
#ll()  { ls --format=long             $* | less --no-init }
#llr() { ls --format=long --recursive $* | less --no-init }
