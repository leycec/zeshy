#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path listings.

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_list_colors().
document_function '
string get_list_command_colors(void)

Get the colon-delimited string of colors with which "ls" colors list output.
As a (hopefully) beneficial side effect, running "ls" in color terminals after
calling this function implicitly colors all list output.
'
function get_list_command_colors() {
    # Validate sanity.
    die_if_args

    #FIXME: Probably Linux specific. I vaguely wonder what the BSD variant is...
    # If global ${LS_COLORS} has not yet been defined, do so by evaluating the
    # output of "dircolors" as a Bourne shell script. (While odd, this remains
    # the canonical method for doing so.)
    is_variable LS_COLORS or {
        die_unless_pathable dircolors
        run_under_shell "$(dircolors --sh)" 'sh'
    }

    # Get such colors.
    print_string "${LS_COLORS}"
}

# ....................{ LISTERS                            }....................
# Unfortunately, POSIX "ls" returns exit status 2 on non-fatal errors, including
# non-permission to access a nested path when run recursively. While Zeshy could
# theoretically define new list_path*() functions coercing such exit status to
# 0, doing so requires either prefiltering passed paths for nested paths to
# which the current user has no read or execute permissions *OR* postfiltering
# "ls" output to detect such contexts. The former, though simpler, remains non-
# trivial: by recursing all applicable paths before running "ls", we guarantee
# different output than is output by "ls -R" unless we again postprocess "ls"
# output; additionally, portably passing such paths to "ls" requires a zargs()-
# driven passing style. Since the effort in either case substantially outweighs
# the gain, reluctantly retain the POSIX exit status model.

document_function '
void list_path(string pathname1, string pathname2, ...)

List the passed paths with currently configured "ls"-specific options. See
list_path_with_options() for further details.
'
function list_path() {
    die_unless_args 'expected at least one pathname'
    list_path_with_options -- "${@}"
}

document_function '
void list_path_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

List the passed paths (defaulting to the current directory) with both the passed
and currently configured "ls"-specific options. Throw an exception if any such
path does not exist. Assuming default user configuration settings, concisely
list only path basenames.
'
function list_path_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_CONCISE' "${(q)@}"
}

# ....................{ LISTERS ~ verbose                  }....................
document_function '
void list_path_verbosely(string pathname1, string pathname2, ...)

List the passed paths verbosely with currently configured "ls"-specific options.
See list_path_verbosely_with_options() for further details.
'
function list_path_verbosely() {
    die_unless_args 'expected at least one pathname'
    list_path_verbosely_with_options -- "${@}"
}

document_function '
void list_path_verbosely_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

List the passed paths (defaulting to the current directory) verbosely with both
the passed and currently configured "ls"-specific options. Throw an exception if
any such path does not exist. Assuming default Zeshy configuration settings,
verbose listings include path metadata (e.g., owner, permissions).
'
function list_path_verbosely_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE' "${(q)@}"
}

# ....................{ LISTERS ~ recursive                }....................
document_function '
void list_path_recursively(string pathname1, string pathname2, ...)

List the passed paths recursively with currently configured "ls"-specific
options. See list_path_with_options() for further details.
'
function list_path_recursively() {
    die_unless_args 'expected at least one pathname'
    list_path_recursively_with_options -- "${@}"
}

document_function '
void list_path_recursively_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

Concisely, recursively list the passed paths (defaulting to the current
directory) with both the passed and currently configured "ls"-specific options.
See list_path_with_options() for further details.
'
function list_path_recursively_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_CONCISE ZESHY_LS_OPTIONS_IF_RECURSIVE'\
        "${(q)@}"
}

# ....................{ LISTERS ~ recursive : verbose      }....................
document_function '
void list_path_recursively_verbosely(string pathname1, string pathname2, ...)

List the passed path recursively verbosely with currently configured "ls"-
specific options. See list_path_verbosely_with_options() for further details.
'
function list_path_recursively_verbosely() {
    die_unless_args 'expected at least one pathname'
    list_path_recursively_verbosely_with_options -- "${@}"
}

document_function '
void list_path_recursively_verbosely_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

List the passed path (defaulting to the current directory) recursively verbosely
with both the passed and currently configured "ls"-specific options. See
list_path_verbosely_with_options() for further details.
'
function list_path_recursively_verbosely_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE ZESHY_LS_OPTIONS_IF_RECURSIVE'\
        "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Not the best nomenclature. The recursion is far more important than the
#verbosity, so rename to list_path_recursively_verbosely() here and below.

# concisely and hence excluding path metadata (e.g., owner, permissions) and hence
#include only path basenames
#FUXME: Annoyingly, "command ls" returns non-zero exit status 2 when passed "-R"
#and at least *ONE* path recursively under the passed path cannot be read by the
#current user. Ideally, such paths should simply be ignored. "man ls" indicates
#"ls" should be returning 2 *ONLY* "if serious trouble (e.g., cannot access
#command-line argument)." Since no serious (or even minor) trouble exists here,
#I can only conjecture such return value to be in error. Amend this here. The
#implementation should call an underlying list_path_recursively_with_options()
#function rather the current "command ls"; such function should, in turn,
#capture output in the exact same manner as run_with_options(). (In fact, we'd
#might as well reimplement the exact subset of such function applicable to this
#functionality and stop calling run_with_options().) Given captured output,
#parse such output on receiving exit status 2; if such output contains a line
#matching "ls: cannot open directory ./${DIRNAME_HERE}: Permission denied",
#return exit status 0 instead.
#FUXME: To test exit status, we'll probably need a new function based on
#return_command_exit_status(). See such function for the basic implementation;
#shouldn't be terribly difficult. (Clever implementation, actually. Nice, man.)
#FUXME: Actually, string matching sucks. *REALLY* sucks. Couldn't we just
#perform such recursion ourselves at the same time we filter away non-readable
#paths? Yesss. Don't see why not, really... Ah; the only issue is argument
#length: as I recall, we'll probably have to user builtin zargs() to guarantee
#sane behavior. Hmmm; actually, this is non-ideal, largely because "ls" output
#changes under option "-R" to produce more aesthetically pleasing details. More
#importantly, we want to retain the existing warnings; we just want to cease
#such warnings from inducing non-zero exit status. Go with the initial plan,
#please.
#FUXME: Actually, how do we even reliably go with the initial plan? The problem,
#as I see it, is that we'd need to distinguish between a real fatal error and
#a "fake" permissions-related fatal error. If at least one real fatal error was
#printed, we'd need to retain non-zero exit status. Ow! That substantially puts
#a damper on things, eh? O.K.; so, it appears we'll have to emulate "lr -R"
#output; annoying, but hardly infeasible. It will be substantially slower,
#however. O.K.; this is all a bit of a pipe-dream at the moment. Retain the
#existing exit status...and try to eventually come back to this.

#FUXME: Drop the "_concisely". It's a reasonable default; we needn't specify it.
#Indeed, doing so unnecessarily increases complexity elsewhere.
#function set_list_to_path_recursively() {
#function list_path_recursively() {
    # Validate passed arguments.
#    die_unless_args 'expected at least one pathname'
#    die_unless_paths "${@}"
#   for pathname ("${@}") {
#       die_unless_path "${pathname}"
#       if is_file "${pathname}"
#   }
#   list pathnames; pathnames=( ${^@}/**/* )
#}

#Throw an exception if any such path does not exist.
# ....................{ LISTERS                            }....................
#document_function '
#string list_path(string ls_arg1, string ls_arg2, ...)
#
#List the passed paths (defaulting to the current directory) with the passed
#"ls" options.
#'
#function list_path() {
#    run_with_options 'run_paged command ls' 'ZESHY_LS_OPTIONS' "${(q)@}"
#}

#Throw an exception if such path does not exist.
#   run_with_options 'run_paged command ls'\
#       'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE' "${(q)@}"
# ....................{ ALIASES                            }....................
#interactive_substitution {l}s='list_path'
#interactive_abbreviation {l}s{l}ong='list_path_verbosely'
#interactive_abbreviation {l}s{r}ecursive='list_path_recursively'

#is_zeshy_wrapping_core_commands and
#interactive_alias dus='list_path_disk_usage_sorted'
#   print_path_verbosely --recursive "${@}"
#   run_with_options 'run_paged command ls' 'options' "${@}"
#FUXME: This and friends below really need to be reimplemented to use "--".
#And drop all of the funcstack nonsense. Slight changes, but... *shrug*
    # "ls" command to be run.
#   list ls; ls=( run_paged command ls "${ZESHY_LS_OPTIONS[@]}" )
#       "${ls[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}" "${@}"

    #FUXME: The conditional is pretty much broken. We really need to fix
    #Zeshy Digest so as to accept function aliases ala "print_path ls()".
    #Note that "content/grep" contains a similarly broken conditional.

    # If the topmost function on the function stack is "ls"-specific,
    # the current user called this function directly from the command-line.
#   if (( ${#funcstack} == 1 )) or is "${funcstack[-2]}" == print_path* si
#   then "${ls[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}" "${@}"
#   else "${ls[@]}" "${ZESHY_LS_OPTIONS[@]}" "${@}"
#   fi
#

    # Call is_shell_interactive() rather than is_shell_interactive_directly(). The embedded
    # conditional below implicitly implements the latter, already.
    # If running non-interactively, pass *NO* Zeshy-specific options to "grep".
    # Doing so breaks non-interactive shell scripts and functions expecting
    # default "grep" behavior (e.g., basic patterns).
#   else command ls "${@}"
#   fi

#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#       say "running \"${ls_command[@]} ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]} ${@}\"..."
#   if is_shell_interactive_directly
#   then "${ls_command[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#   else "${ls_command[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#   fi

#       say "running \"${ls_command[@]} ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]} ${@}\"..."
#       say "options: ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}"#interactive_alias l='list_path'
#interactive_alias ls='list_path'
#interactive_alias ls='list_path_recursively'
#'ls --all --color=always --group-directories-first --human-readable --indicator-style=classify --quoting-style=shell --sort=version --time-style=long-iso'
#lr()  { ls --recursive               $* | less --no-init }
#ll()  { ls --format=long             $* | less --no-init }
#llr() { ls --format=long --recursive $* | less --no-init }
