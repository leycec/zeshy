#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file and directory listings.

# ....................{ LISTERS ~ concise                  }....................
#FIXME: Drop the "_concisely". It's a reasonable default; we needn't specify it.
#Indeed, doing so unnecessarily increases complexity elsewhere.
document_function '
void list_path_concisely(string pathname)

Concisely list the passed path with currently configured "ls"-specific options.
See list_path_concisely_with_options() for further details.
'
function list_path_concisely() {
    die_unless_arg 'expected one pathname'
    list_path_concisely_with_options -- "${@}"
}

document_function '
void list_path_concisely_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

Concisely list the passed paths (defaulting to the current directory) with both
the passed and currently configured "ls"-specific options. Throw an exception if
any such path does not exist. Assuming default Zeshy configuration settings,
concise listings exclude path metadata (e.g., owner, permissions) and hence
include only path basenames.
'
function list_path_concisely_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_CONCISE' "${(q)@}"
}

# ....................{ LISTERS ~ verbose                  }....................
document_function '
void list_path_verbosely(string pathname)

Verbosely list the passed path with currently configured "ls"-specific options.
See list_path_verbosely_with_options() for further details.
'
function list_path_verbosely() {
    die_unless_arg 'expected one pathname'
    list_path_verbosely_with_options -- "${1}"
}

document_function '
void list_path_verbosely_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

Verbosely list the passed paths (defaulting to the current directory) with both
the passed and currently configured "ls"-specific options. Throw an exception if
any such path does not exist. Assuming default Zeshy configuration settings,
verbose listings include path metadata (e.g., owner, permissions).
'
function list_path_verbosely_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE' "${(q)@}"
}

# ....................{ LISTERS ~ concise - recursive      }....................
#FIXME: Annoyingly, "command ls" returns non-zero exit status 2 when passed "-R"
#and at least *ONE* path recursively under the passed path cannot be read by the
#current user. Ideally, such paths should simply be ignored. "man ls" indicates
#"ls" should be returning 2 *ONLY* "if serious trouble (e.g., cannot access
#command-line argument)." Since no serious (or even minor) trouble exists here,
#I can only conjecture such return value to be in error. Amend this here. The
#implementation should call an underlying list_path_recursively_with_options()
#function rather the current "command ls"; such function should, in turn,
#capture output in the exact same manner as run_with_options(). (In fact, we'd
#might as well reimplement the exact subset of such function applicable to this
#functionality and stop calling run_with_options().) Given captured output,
#parse such output on receiving exit status 2; if such output contains a line
#matching "ls: cannot open directory ./${DIRNAME_HERE}: Permission denied",
#return exit status 0 instead.
#FIXME: To test exit status, we'll probably need a new function based on
#return_command_exit_status(). See such function for the basic implementation;
#shouldn't be terribly difficult. (Clever implementation, actually. Nice, man.)
#FIXME: Actually, string matching sucks. *REALLY* sucks. Couldn't we just
#perform such recursion ourselves at the same time we filter away non-readable
#paths? Yesss. Don't see why not, really... Ah; the only issue is argument
#length: as I recall, we'll probably have to user builtin zargs() to guarantee
#sane behavior. Hmmm; actually, this is non-ideal, largely because "ls" output
#changes under option "-R" to produce more aesthetically pleasing details. More
#importantly, we want to retain the existing warnings; we just want to cease
#such warnings from inducing non-zero exit status. Go with the initial plan,
#please.
#FIXME: Actually, how do we even reliably go with the initial plan? The problem,
#as I see it, is that we'd need to distinguish between a real fatal error and
#a "fake" permissions-related fatal error. If at least one real fatal error was
#printed, we'd need to retain non-zero exit status. Ow! That substantially puts
#a damper on things, eh? O.K.; so, it appears we'll have to emulate "lr -R"
#output; annoying, but hardly infeasible. It will be substantially slower,
#however. O.K.; this is all a bit of a pipe-dream at the moment. Retain the
#existing exit status...and try to eventually come back to this.

#FIXME: Drop the "_concisely", as above.
document_function '
void list_path_concisely_recursively(string pathname)

Concisely, recursively list the passed path with currently configured "ls"-
specific options. See list_path_concisely_with_options() for further details.
'
function list_path_concisely_recursively() {
    die_unless_arg 'expected one pathname'
    list_path_concisely_recursively_with_options -- "${1}"
}

document_function '
void list_path_concisely_recursively_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

Concisely, recursively list the passed paths (defaulting to the current
directory) with both the passed and currently configured "ls"-specific options.
See list_path_concisely_with_options() for further details.
'
function list_path_concisely_recursively_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_CONCISE ZESHY_LS_OPTIONS_IF_RECURSIVE'\
        "${(q)@}"
}

# ....................{ LISTERS ~ verbose - recursive      }....................
#FIXME: Not the best nomenclature. The recursion is far more important than the
#verbosity, so rename to list_path_recursively_verbosely() here and below.

document_function '
void list_path_verbosely_recursively(string pathname)

Verbosely, recursively list the passed path with currently configured "ls"-
specific options. See list_path_verbosely_with_options() for further details.
'
function list_path_verbosely_recursively() {
    die_unless_arg 'expected one pathname'
    list_path_verbosely_recursively_with_options -- "${1}"
}

document_function '
void list_path_verbosely_recursively_with_options(
    string ls_option1, string ls_option2, ...,
    string pathname1, string pathname2, ...)

Verbosely, recursively list the passed paths (defaulting to the current
directory) with both the passed and currently configured "ls"-specific options.
See list_path_verbosely_with_options() for further details.
'
function list_path_verbosely_recursively_with_options() {
    run_with_options_configured 'run_paged command ls'\
        'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE ZESHY_LS_OPTIONS_IF_RECURSIVE'\
        "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#function set_list_to_path_recursively() {
#function list_path_recursively() {
    # Validate passed arguments.
#    die_unless_args 'expected at least one pathname'
#    die_unless_paths "${@}"
#   for pathname ("${@}") {
#       die_unless_path "${pathname}"
#       if is_file "${pathname}"
#   }
#   list pathnames; pathnames=( ${^@}/**/* )
#}

#Throw an exception if any such path does not exist.
# ....................{ LISTERS                            }....................
#document_function '
#string list_path(string ls_arg1, string ls_arg2, ...)
#
#List the passed paths (defaulting to the current directory) with the passed
#"ls" options.
#'
#function list_path() {
#    run_with_options 'run_paged command ls' 'ZESHY_LS_OPTIONS' "${(q)@}"
#}

#Throw an exception if such path does not exist.
#   run_with_options 'run_paged command ls'\
#       'ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_VERBOSE' "${(q)@}"
# ....................{ ALIASES                            }....................
#interactive_substitution {l}s='list_path_concisely'
#interactive_abbreviation {l}s{l}ong='list_path_verbosely'
#interactive_abbreviation {l}s{r}ecursive='list_path_recursively'

#is_zeshy_wrapping_core_commands and
#interactive_alias dus='list_path_disk_usage_sorted'
#   print_path_verbosely --recursive "${@}"
#   run_with_options 'run_paged command ls' 'options' "${@}"
#FIXME: This and friends below really need to be reimplemented to use "--".
#And drop all of the funcstack nonsense. Slight changes, but... *shrug*
    # "ls" command to be run.
#   list ls; ls=( run_paged command ls "${ZESHY_LS_OPTIONS[@]}" )
#       "${ls[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}" "${@}"

    #FIXME: The conditional is pretty much broken. We really need to fix
    #Zeshy Digest so as to accept function aliases ala "print_path ls()".
    #Note that "content/grep" contains a similarly broken conditional.

    # If the topmost function on the function stack is "ls"-specific,
    # the current user called this function directly from the command-line.
#   if (( ${#funcstack} == 1 )) or is "${funcstack[-2]}" == print_path* si
#   then "${ls[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}" "${@}"
#   else "${ls[@]}" "${ZESHY_LS_OPTIONS[@]}" "${@}"
#   fi
#

    # Call is_shell_interactive() rather than is_shell_interactive_directly(). The embedded
    # conditional below implicitly implements the latter, already.
    # If running non-interactively, pass *NO* Zeshy-specific options to "grep".
    # Doing so breaks non-interactive shell scripts and functions expecting
    # default "grep" behavior (e.g., basic patterns).
#   else command ls "${@}"
#   fi

#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#       say "running \"${ls_command[@]} ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]} ${@}\"..."
#   if is_shell_interactive_directly
#   then "${ls_command[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#   else "${ls_command[@]}" "${ZESHY_LS_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#   fi

#       say "running \"${ls_command[@]} ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]} ${@}\"..."
#       say "options: ${ZESHY_LS_OPTIONS_IF_SHELL_INTERACTIVE[@]}"#interactive_alias l='list_path'
#interactive_alias ls='list_path'
#interactive_alias ls='list_path_recursively'
#'ls --all --color=always --group-directories-first --human-readable --indicator-style=classify --quoting-style=shell --sort=version --time-style=long-iso'
#lr()  { ls --recursive               $* | less --no-init }
#ll()  { ls --format=long             $* | less --no-init }
#llr() { ls --format=long --recursive $* | less --no-init }
