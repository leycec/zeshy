#!/usr/bin/env zsh
# ====================[ user_and_group                     ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path user and group changes.

# ....................{ SETTERS                            }....................
declare_function '
string set_path_user_and_group(
  string pathname1, string pathname2, ..., string user_and_group)

Silently set the user and/or group of all passed paths with the passed ":"-
delimited ownership under currently configured "chown"-specific options. Specify
such ownership as an optional username, optional ":", and optional groupname. If
any such path does not exist, throw an exception. See "man chown" for further
details on such strings: e.g.,

    # Passing both a user and group.
    >>> set_path_user_and_group "/battle/of/bannockburn" bruce:scotland
    # Passing only a user and colon, equivalent to passing "bruce:bruce".
    >>> set_path_user_and_group "/battle/of/bannockburn" bruce:
    # Passing only a user.
    >>> set_path_user_and_group "/battle/of/bannockburn" bruce
    # Passing only a group.
    >>> set_path_user_and_group "/battle/of/bannockburn" :scotland
'
function set_path_user_and_group() {
    # Validate passed arguments.
    die_unless_two_args 'expected one path and one ownership string'
    string ownership="${@[-1]}"
    pop_arg

    # Change such ownership.
    run_command_with_options_silently\
        'command chown' ZESHY_CHOWN_OPTIONS -- "${ownership}" "${(q)@}"
}

declare_function '
void set_path_user_and_group_with_options(
  string chown_option1, string chown_option2, ...,
  string ownership,
  string source_pathname1 = "$(get_current_dir)/"{.,*},
  string source_pathname2, ...)

Set the user and/or group of all passed paths (defaulting to all paths in the
current directory including such directory) with the passed ":"-delimited
ownership under both the passed and currently configured "chown"-specific
options. See set_path_user_and_group() for further details.
'
function set_path_user_and_group_with_options() {
    # Validate passed arguments.
    die_unless_args_1_or_more\
        'expected one ownership string and optional pathnames'

    # If passed no paths, default to the current directory and all paths in it.
    set_integer_to_arg_nonoption_count arg_nonoption_count
    (( arg_nonoption_count == 1 )) and append_arg "$(get_current_dir)/"{.,*}

    # Change such ownership.
    run_command_with_options_configured 'command chown' ZESHY_CHOWN_OPTIONS "${(q)@}"
}

# ....................{ SETTERS ~ recursive                }....................
declare_function '
string set_path_user_and_group_recursively(
  string pathname1, string pathname2, ..., string user_and_group)

Silently set the user and/or group of all passed paths recursively with the
passed ":"-delimited ownership under currently configured "chown"-specific
options. See set_path_user_and_group() for further details.
'
function set_path_user_and_group_recursively() {
    append_list_with_list_locally_from\
        'ZESHY_CHOWN_OPTIONS ZESHY_CHOWN_OPTIONS_IF_RECURSIVE'
    set_path_user_and_group "${@}"
}

declare_function '
void set_path_user_and_group_recursively_with_options(
  string chown_option1, string chown_option2, ...,
  string user_and_group,
  string source_pathname1 = "$(get_current_dir)", string source_pathname2, ...)

Set the user and/or group of all passed paths (defaulting to the current
directory) recursively with the passed ":"-delimited ownership under both the
passed and currently configured "chown"-specific options. See
set_path_user_and_group() for further details.
'
function set_path_user_and_group_recursively_with_options() {
    # Validate passed arguments.
    die_unless_args_1_or_more\
        'expected one ownership string and optional pathnames'

    # If passed no paths, default to the current directory.
    set_integers_to_arg_nonoption_count_and_first_index_from\
        'arg_nonoption_count arg_nonoption_first_index'
    (( arg_nonoption_count == 1 )) and {
        append_arg "$(get_current_dir)"

        # Increment the number of passed arguments to ensure sanity below.
        (( ++arg_nonoption_count ))
    }

    # If the current shell is interactive, return non-zero exit status unless
    # the current user interactively affirms such changes. Recursively changing
    # ownership is often permanently harmful and hence deserves confirmation.
    is_shell_interactive and {
        string paths\
            ownership="${@[${arg_nonoption_first_index}]}"\
             first_path="${@[$(( arg_nonoption_first_index + 1 ))]}"

        # Set the question to be asked depending on the number of passed paths.
        paths="\"${first_path}\""
        (( arg_nonoption_count == 2 )) or paths+=', ...'

        # Confirm such change.
        is_response_yes_for_question\
            "recursively change ownership of ${paths} to ${ownership}?" or
            return_false
    }

    # Change such ownership.
    run_command_with_options_configured 'command chown'\
        'ZESHY_CHOWN_OPTIONS ZESHY_CHOWN_OPTIONS_IF_RECURSIVE' "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#   >>> remove_path_recursively "/battle/of/bannockburn"
#   rm: permission denied: /battle/of/bannockburn
