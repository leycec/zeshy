#!/usr/bin/env zsh
# ====================[ remove                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path removal.

#FIXME: It'd be nice to render remove_filename() an uber-powerful meta-remove
#command used in place of "rmdir", "rm -rf *", etc. The essential ideas are:
#* Add a config file option ${ZESHY_IS_RECYCLING}, disabled by default but, when
#  enabled, auto-moving all removed files to a new path
#  "${ZESHY_RECYCLE_BIN)/$(date +'%N')/', the former defaulting to
#  "${HOME}/tmp/zeshy.recycled". This effectively guarantees no
#  collision (still test such collision, and simply repeat until non-colliding).
#  I'll probably enable this locally, I imagine. Obviously, such auto-moving
#  such test for sufficient free disk space on the mounted disk to be moved to
#  prior to doing so and fail with error if insufficient disk space remains.
#  *ALSO*, note that no recycling must be done on paths in the recycler: an "rm"
#  within the recycler is always perma-death.
#* Add implicit support for "rmdir". Basically, if the passed path is an empty
#  directory, use "rmdir"; otherwise, either "rm -ri ${DIRNAME}" or
#  "rm -rI ${DIRNAME}", depending on how many files or subdirectories exist
#  in such directory.
#* O.K.; so, we should add a new trash_path(), implementing a trash bin-
#  style move to "~/tmp" (if such path exists) or "/tmp/$(get_user)" if such
#  path is creatable or already exists and is writable by the current user. This
#  suggests a new "file/trash" component with getter get_trash_home(). If
#  trash_path() is called from within get_trash_home(), it should:
#
#  * Die unless interactive.
#  * Manually confirm such removals as under remove_file().
#
#  Since such functionality will doubtless enrage a substantial subset of the zsh
#  populace (and fair enough), this should be subject to a global boolean
#  ${ZESHY_IS_RECYCLING}. Consider adding a new "ZESHY_RM_OPTIONS_IF_RECYCLING",
#  as well. (Though, perhaps we don't need that?) Hmm; but perhaps the existing
#  ${ZESHY_IS_REPLACING_CORE_COMMANDS} suffices.
#
#  Note the implementation needs to be partition-aware; specifically, if the
#  target partition the target path resides on has insufficient space, ask the
#  user whether they'd like to remove-in-place. This requires additional
#  functionality elsewhere; namely:
#
#  * A new get_disk_size() in "device/disk", passed a disk device.
#  * A new get_mount_point_from_path() in "device/disk", passed a pathname. The most
#    efficient implementation for this function is probably to get a list of all
#    mount points, dynamically OR such mount points together into a glob pattern
#    or PCRE, and match such pathname against such pattern. The resulting $match
#    is the desired mount point.
#  * A new get_disk_from_mount_point() in "device/disk", passed a mount point
#    pathname. The most efficient implementation for this function is probably just
#    to glob the desired column of "blkid -o list" or "mount" for such mount point.
#    No PCRE required. (Canonicalize the passed mount point first, yes? That
#    helpfully removes trailing "/", as well.) Then, just call the following pipeline:
#
#    integer disk_size
#    disk_size="$(get_disk_size "$(get_disk_from_mount_point "$(get_mount_point_from_path "${pathname}")")")"
#    interactive_alias rm='trash_path'
#* Replace "trash" in the prior discussion with "compost", a verb and noun with
#  delectable connotations. Also, it would be quite nice if, much like compost,
#  the compost heap were confined to a user-configurable percentage of total
#  partition size -- defaulting to, say, 10%. Then configuring such percentage
#  to 100% gives default Recycle Bin-like behavior (i.e., unintelligently
#  filling up the entire partition with deleted refuse). The default, of
#  course, behaves much more intelligently. On reaching full capacity, sort the
#  immediate subpaths of the compost heap by ascending date and iteratively
#  delete such subpaths starting from the first in this order until the compost
#  heap subsides beneath the desired threshold. Behavior precisely resembles a
#  genuine compost heap, which rather titillates my obscure fancy.

# ....................{ REMOVERS                           }....................
declare_function '
string remove_path_recursively(string pathname1, string pathname2, ...)

Silently recursively remove the passed paths, throwing an exception if any such
path does not exist.
'
function remove_path_recursively() {
    die_unless_args 'expected at least one pathname'
    run_command_silent_with_options\
        'command rm' 'ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_RECURSIVE' --\
        "${(q)@}"
}

declare_function '
string remove_path_recursively_with_options(
    string rm_option1, string rm_option2, ...,
    string pathname1, string pathname2, ...)

Recursively remove the passed paths with both the passed and currently
configured "rm"-specific options, throwing an exception if any such path does
not exist.
'
function remove_path_recursively_with_options() {
    # Validate passed arguments. Unlike most path operations accepting passed
    # options, do not default to the current directory (for hopefully obvious
    # reasons).
    die_unless_args 'expected at least one pathname'

    # If interactive, pass interactive-specific options.
    string option_list_names='ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_RECURSIVE'
    is_shell_interactive &&
        option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'

    # Remove such paths.
    run_command_with_options_configured 'command rm' "${option_list_names}" "${(q)@}"
}

# ....................{ REMOVERS ~ dir                     }....................
declare_function '
void remove_dir_empty(string dirname1, string dirname2, ...)

Silently remove the passed empty directories, throwing an exception if any such
directory does not exist or does but is non-empty.
'
function remove_dir_empty() {
    die_unless_args 'expected at least one dirname'
    run_command_silent_with_options 'command rmdir' ZESHY_RMDIR_OPTIONS -- "${(q)@}"
}

declare_function '
void remove_dir_empty_if_found(string dirname1, string dirname2, ...)

Silently remove only passed empty directories that exist (i.e., ignoring non-
extant directories), throwing an exception if any passed directory that exists
is non-empty.
'
function remove_dir_empty_if_found() {
    # Validate passed arguments.
    die_unless_args 'expected at least one dirname'

    #FIXME: Call the helper in "file/path" we recently defined.
    # Filter non-extant directories from the passed directories. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed directory.
    # * "(e:...:), excluding directories failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant directories.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If any extant directories remain, remove such directories.
    is_args and remove_dir_empty "${@}"
}

declare_function '
string remove_dir_empty_with_options(
    string rm_option1, string rm_option2, ...,
    string pathname1, string pathname2, ...)

Remove the passed empty directories with both the passed and currently
configured "rmdir"-specific options, throwing an exception if any such directory
does not exist or does but is non-empty.
'
function remove_dir_empty_with_options() {
    # If passed no arguments, default to the current directory. By design,
    # avoid the more specific (and seemingly clever) test of whether the caller
    # passed no non-option arguments; callers passing any non-option arguments
    # intend to run "rmdir" traditionally and hence without such defaults.
    is_args or set_args "$(get_dir)"

    # Validate passed arguments.
    die_unless_args 'expected at least one dirname'

    # Remove such directories.
    run_command_with_options_configured 'command rmdir' ZESHY_RMDIR_OPTIONS "${(q)@}"
}

# ....................{ REMOVERS ~ file                    }....................
declare_function '
void remove_file(string pathname1, string pathname2, ...)

Silently remove the passed files, throwing an exception if any such file does
not exist.
'
function remove_file() {
    die_unless_args 'expected at least one filename'
    run_command_silent_with_options 'command rm' ZESHY_RM_OPTIONS -- "${(q)@}"
}

declare_function '
void remove_file_if_found(string pathname1, string pathname2, ...)

Silently remove only passed files that exist (i.e., ignoring non-extant files).
'
function remove_file_if_found() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    #FIXME: Call the helper in "path/path" we recently defined.
    # Filter non-extant files from the passed files. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed file.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant files.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If at least one such file exists, remove such file(s).
    is_args and remove_file "${@}"
}

declare_function '
string remove_file_with_options(
    string rm_option1, string rm_option2, ...,
    string pathname1, string pathname2, ...)

Remove the passed files with both the passed and currently configured "rm"-
specific options, throwing an exception if any such file does not exist.
'
function remove_file_with_options() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # Since removal options depend on the number of such arguments,
    # run_command_with_options() is insufficient. Implement such logic manually.
    string option_list_names='ZESHY_RM_OPTIONS'
    is_shell_interactive && {
        if is_arg_nonoptions_1_to_3
        then option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3'
        else option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'
        fi
    }

    # Remove such files.
    run_command_with_options_configured 'command rm' "${option_list_names}" "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#declare_function '
#string remove_file_with_optionsconfigured(
#  string pathname1, string pathname2, ...)
#
#Remove the passed files with the currently configured "rm"-specific options,
#throwing an exception if any such file does not exist.
#'
#function remove_file_with_optionsconfigured() {
#    remove_file_with_options -- "${(q)@}"
#}

#FUXME: Implementation isn't quite right: we only want to ignore the path if not
#found; if the path is found but is *NOT* empty, we still want to throw an exception.

#(i.e., contains at least one subdirectory or file).
#   run_command_with_options 'command rmdir' ZESHY_RMDIR_OPTIONS "${(q)@}"

#Remove all passed directories if all such directories exist and
#are empty  or throw an exception if at
#least one such directory  See
#remove_dir_empty_if_found() for an alternative throwing no such exception.

#   run_command_silent run_command_with_options 'command rm'\
#       'ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_SHELL_NONINTERACTIVE' -- "${(q)@}"

#       if set_integer_to_arg_nonoption_count __nonoptions__ and
#           (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
    # Validate passed arguments.
#   die_unless_args 'expected at least one filename'

    # Since removal options depend on the number of such arguments,
    # run_command_with_options() is insufficient. Implement such logic manually.
#   string option_list_names='ZESHY_RM_OPTIONS'
#   is_shell_interactive && {
#       if is_args_1_to_3
#       then option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3'
#       else option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'
#       fi
#   }

    # Remove such files.
#   run_command_with_optionsconfigured\
#       'command rm' "${option_list_names}" -- "${(q)@}"

#FUXME: This function should *NOT* be called by copy_file() or move_file() --
#only by the subsidiary copy_file_with_optionsconfigured()-style functions.
