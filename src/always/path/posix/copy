#!/usr/bin/env zsh
# ====================[ copy                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path copying.

# ....................{ COPIERS ~ shallow                  }....................
document_function '
void copy_path_shallowly(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Silently copy the passed source path to the passed target path shallowly (i.e.,
copying source symbolic links rather than the targets of such links). If any
source path does not exist, throw an exception. If any source path is a symbolic
link broken after such copy, print a warning.
'
function copy_path_shallowly() {
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'
    run_with_options 'command cp' ZESHY_CP_OPTIONS "${(q)@}"
    cry_if_link_symbolic_broken_after_copy_or_move_path "${@}"
}

document_function '
void copy_path_shallowly_with_options(
  string cp_option1, string cp_option2, ...,
  string source_pathname1, string source_pathname2, ...,
  string target_pathname = "$(get_current_dir)")

Copy the passed source paths to the passed target path (defaulting to the current
directory) shallowly, with both the passed and currently configured "cp"-specific
options. See copy_path_shallowly() for further details.
'
function copy_path_shallowly_with_options() {
    # Validate passed arguments.
    die_unless_args_1_or_more\
        'expected at least one source pathname and optional target pathname'

    # If passed only one source path, default the target path to the current
    # directory.
    set_integers_to_arg_nonoption_count_and_first_index_from\
        'arg_nonoption_count arg_nonoption_first_index'
    (( arg_nonoption_count == 1 )) and append_arg "$(get_current_dir)"

    # Copy such paths.
    run_with_options_configured 'command cp' ZESHY_CP_OPTIONS "${(q)@}"

    # Print warnings for symbolic links broken by such copy.
    cry_if_link_symbolic_broken_after_copy_or_move_path\
        "${@[${arg_nonoption_first_index},-1]}"
}

# ....................{ COPIERS ~ physical                 }....................
#FIXME: Rename to copy_path_deeply().
#FIXME: Implement copy_path_deeply_with_options().

document_function '
void copy_path_physically(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Copy the passed source to target paths "deeply" (i.e., copying the targets of
source path symbolic links rather than such links).
'
function copy_path_physically() {
    # We copy no symbolic links and hence needn't test brokenness.
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'
    list zeshy_cp_options; zeshy_cp_options=( "${ZESHY_CP_OPTIONS[@]}" )
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=( "${zeshy_cp_options[@]}" -L )
    run_with_options 'command cp' ZESHY_CP_OPTIONS "${(q)@}"
}

# ....................{ COPIERS ~ recursive                }....................
#FIXME: Implement copy_path_recursively_with_options().
document_function '
void copy_path_recursively(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Copy the passed source to target paths recursively "shallowly." See
copy_path() for further details.
'
function copy_path_recursively() {
    # Defer to copy_path() by temporarily appending recursive options to the
    # global list accessed by such function.
    list zeshy_cp_options; zeshy_cp_options=( "${ZESHY_CP_OPTIONS[@]}" )
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=(
        "${zeshy_cp_options[@]}"
        "${ZESHY_CP_OPTIONS_IF_RECURSIVE[@]}"
    )
    copy_path "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Implementation isn't quite right: we only want to ignore the path if not
#found; if the path is found but is *NOT* empty, we still want to throw an exception.

#(i.e., contains at least one subdirectory or file).
#   run_with_options 'command rmdir' ZESHY_RMDIR_OPTIONS "${(q)@}"

#Remove all passed directories if all such directories exist and
#are empty  or throw an exception if at
#least one such directory  See
#remove_dir_empty_if_found() for an alternative throwing no such exception.

#   run_silently run_with_options 'command rm'\
#       'ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_SHELL_NONINTERACTIVE' -- "${(q)@}"

#       if set_integer_to_arg_nonoption_count __nonoptions__ and
#           (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
    # Validate passed arguments.
#   die_unless_args 'expected at least one filename'

    # Since removal options depend on the number of such arguments,
    # run_with_options() is insufficient. Implement such logic manually.
#   string option_list_names='ZESHY_RM_OPTIONS'
#   is_shell_interactive && {
#       if is_args_1_to_3
#       then option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3'
#       else option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'
#       fi
#   }

    # Remove such files.
#   run_with_options_configured\
#       'command rm' "${option_list_names}" -- "${(q)@}"

#FUXME: This function should *NOT* be called by copy_file() or move_file() --
#only by the subsidiary copy_file_with_options_configured()-style functions.
