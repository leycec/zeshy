#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle text file patching.
-/-

#FIXME: Add support for compressed patch files, both on input (apply_) and output
#(make_). For the latter, we'll need a new function "is_archive_file" in
#"file/content/archive" matching on... hmm; we probably shouldn't trust
#filenames. "file" is probably faster, anyway, given it's C heritage; just
#call get_file_type_media() and test the return value. Most archive files should
#(hopefully) have a common prefix (say, "x-compressed"). Check this.

# ....................{ MAKERS                             }....................
declare_function_with_stdin <<'/---'
string make_file_text_patch(
    string patch_filename = "${old_pathname}.patch",
    string old_pathname,
    string new_pathname)

Write the passed patch file (defaulting to the passed old path suffixed by
`.patch`, if called directly from the command line) with all differences between
the passed old and new paths. Such paths must be either both files or both
directories. In the latter case, this function recursively differences all text
files in such directories.

Assuming default ${ZESHY_DIFF_OPTIONS}, such differences will be in
https://en.wikipedia.org/wiki/Diff#Unified_format[*unified `diff` format*], the
canonical patch file format for most open-source software projects.
/---
function make_file_text_patch() {
    # Validate sanity.
    if { is_zsh_cli_function } {
        die_unless_args_2_to_3\
            'Expected optional patch filename, one old filename, and one new filename.'

        # If no patch filename was passed, default such filename to such old
        # pathname (excluding any suffixing "/" if such path was a directory).
        if { is_args_2 } {
            prepend_arg "$(remove_string_suffix "${1}" '/').patch"
        }
    } else {
        die_unless_args_3\
            'Expected one patch filename, one old filename, and one new filename.'
    }
    string\
        patch_filename="${1}"\
        pathname_old="${2}"\
        pathname_new="${3}"
    list diff zeshy_diff_options
    die_unless_files_text "${pathname_new}" "${pathname_old}"

    #FIXME: This is silly. I see no compelling reason why we can't defer to
    #run_code_with_options_configured(). We will require a new alias for
    #setting the exit status of a command to an integer variable. But *THAT*
    #shouldn't be terribly difficult. *SIGH*

    # Ensure either two files or two directories were passed.
    zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
    if { is_files "${pathname_old}" "${pathname_new}" } {
        noop
    } elif { is_dir "${pathname_old}" and is_dir "${pathname_new}" } {
        zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )
    } else {
        die "\"${pathname_old}\" and \"${pathname_new}\" neither both files or directories."
    }

    #FIXME: Nice, but should *REALLY* be shifted to a new
    #make_file_text_patch_with_options() function. Hmmmmm; actually, we can do
    #one better. It's rarely (O.K., *NEVER*) helpful to write such patch into
    #the codebase itself. Instead, default to:
    #"$(get_dir)/$(get_basename "${pathname_old}").patch"
    #FIXME: Add a new interactive alias expanding to
    #make_file_text_patch_with_options().

    # Default the passed patch to the passed old path excluding suffixing "/",
    # removing such patch if already found.
    patch_filename="${3:-$(remove_string_suffix "${pathname_old}" '/').patch}"
#   print_message "removing \"${patch_filename}\"..."
    remove_file_if_found "${patch_filename}"

    # Make the passed patch. If interactive, redirect standard output to error
    # to assist the current user review the patch. Oddly, "diff" returns exit
    # status 1 on successfully differencing non-identical files (!?) and exit
    # status 2 on fatal error. Thanks for being idiotically different, "diff".
    #
    # Fortunately, the return_exit_status() approach helps revise such idiocy.
    # Unfortunately, this approach requires manually reimplementing both
    # run_code_with_options() and return_exit_status() here.
    #
    # *crudely blows both nostrils at the "diff" authors' pale-faced cupidity*
    diff=( command diff "${zeshy_diff_options[@]}" )
    if { is_shell_interactive } {
        diff+=( "${ZESHY_DIFF_OPTIONS_IF_INTERACTIVE[@]}" )
    } else {
        diff+=( "${ZESHY_DIFF_OPTIONS_IF_NONINTERACTIVE[@]}" )
    }

    print_message_item "Patching into \"${patch_filename}\"..."

    #FIXME: Such coercion is sufficiently useful to warrant generalization into
    #a new alias -- say, return_exit_status_converting_1_to_0().

    # Coerce exit status 1 to 0.
    integer exit_status
    "${diff[@]}" "${pathname_old}" "${pathname_new}" >"${patch_filename}" |
        cat and exit_status="${pipestatus[1]}"
    if (( exit_status == 1 )) {
        return_true
    } else {
        return ${exit_status}
    }
}

# ....................{ PATCHERS                           }....................
#FIXME: Function implementation is GNU-specific. Correct with the usual
#${ZESHY_OPTIONS_PATCH_IF_DRY_RUN} approach.
declare_function_with_stdin <<'/---'
string apply_file_text_patch(
    string patch_filename,
    string target_directory = "$(get_dir)",
    integer patch_level = "")

Apply the passed patch file to the appropriate file(s) in the passed directory
(defaulting to the current directory, if called directly from the command line)
under the passed 0-based patch level (defaulting to the empty string and hence
the first patch level in [0, 5] to successfully apply).

For security, this function throws an exception if the passed patch file
attempts to patch absolute filenames (e.g., `/sbin/init`) or parent-relative
filenames (e.g., `../../../init/sh`).
/---
function apply_file_patch() {
    # Validate sanity.
    die_unless_args_1_to_3\
        'Axpected one patch filename, optional target dirname, and optional patch level.'
    string\
        patch_filename="${1}"\
        target_path_dirname="${2:-$(get_dir)}"\
        patch_level="${3:-}"
    die_unless_file "${patch_filename}"
    die_unless_dir "${target_path_dirname}"

    # Forbid absolute and parent-relative filenames in the patch file.
    if { is_file_text_matches_pcre_multiline "${patch_filename}"\
        '^(\*\*\*|\+\+\+|\/---\-)\s+(/|(.*/)?\.\./)' } {
        string error_message="\"${patch_filename}\" dangerously patches an absolute or parent-relative path."

        # If interactive, require the user confirm such risky behavior.
        if { is_shell_interactive } {
            print_warning "${error_message}"
            is_query_line_yes 'Really apply a potentially dangerous patch?' or
                return_false
        # Else, throw an exception.
        } else {
            die "${error_message}"
        }
    }

    # Patch such file.
    store_dir "${target_path_dirname}"
    {
        # If no patch level was passed, iteractively search for a successful
        # patch level by attempting each in ascending order (as dry runs).
        if { is_string_empty "${patch_level}" } {
            integer patch_level=0  patch_level_max=5
            for ((; patch_level <= patch_level_max; patch_level++)) {
                print_message_item\
                    "Attempting patch level ${patch_level} on \"${patch_filename}\"..."
#               run_code_with_options "patch -p${patch_level} --dry-run --force"\
                run_code_with_options\
                    "command patch -p${patch_level} --dry-run --force --quiet"\
                    'ZESHY_PATCH_OPTIONS' "< '${patch_filename}'"\
                    and break or ignore_exit_status
            }

            # If no patch level succeeded, rerun the first dry run, thus forcing
            # "patch" to print a helpful error message before returning non-zero
            # exit status and hence inducing a fatal exception.
            if (( patch_level > patch_level_max )) {
                run_code_with_options "command patch -p0 --dry-run --force"\
                    'ZESHY_PATCH_OPTIONS' "< '${patch_filename}'"
            }
        }

        # Apply the current (presumably successful) patch level.
        die_unless_integer "${patch_level}"\
            "Patch level \"${patch_level}\" invalid."
        print_message_item\
            "Applying \"${patch_filename}\" to \"${target_path_dirname}\" under patch level ${patch_level}..."
        run_code_with_options\
            "command patch -p${patch_level}" 'ZESHY_PATCH_OPTIONS'\
            "< ${(q)patch_filename}"
    } always {
        restore_dir
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: "cat"-ing such diff doesn't strike me as particularly desirable.
    #After all, this function is *NOT* a printer function. How hard is it to
    #simply vim or cat the output patch file, anyway? For generality, cease
    #such nonsense.

    # Ensure either two files or two directories were passed.
#   list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
#   if { is_files "${pathname_old}" "${pathname_new}" } {
#       noop
#   } elif { is_dir "${pathname_old}" and is_dir "${pathname_new}" } {
#       zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )
#   } else {
#       die "\"${pathname_old}\" and \"${pathname_new}\" neither both files or directories"
#   }

    # Default the passed patch to the passed old path excluding suffixing "/",
    # removing such patch if already found.
#   string patch_filename
#   patch_filename="${3:-$(remove_string_suffix "${pathname_old}" '/').patch}"
#   print_message "removing \"${patch_filename}\"..."
#   remove_file_if_found "${patch_filename}"

    # Make the passed patch. If interactive, redirect standard output to error
    # to assist the current user review the patch. Oddly, "diff" returns exit
    # status 1 on successfully differencing non-identical files (!?) and exit
    # status 2 on fatal error. Thanks for being idiotically different, "diff".
    #
    # Fortunately, the return_exit_status() approach helps revise such idiocy.
    # Unfortunately, this approach requires manually reimplementing both
    # run_code_with_options() and return_exit_status() here.
    #
    # *crudely blows both nostrils at the "diff" authors' pale-faced cupidity*
#   list diff; diff=( diff "${zeshy_diff_options[@]}" )
#   if { is_shell_interactive } {
#       print_message "making \"${patch_filename}\"... [${pathname_old} -> ${pathname_new}]"
#       diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_INTERACTIVE[@]}" )
#   } else {
#       diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" )
#   }

    # Coerce exit status 1 to 0.
#   integer exit_status
#   "${diff[@]}" "${pathname_old}" "${pathname_new}" >"${patch_filename}" |
#       cat and exit_status="${pipestatus[1]}"
#   if (( exit_status == 1 )) {
#       return_true
#   } else {
#       return ${exit_status}
#   }

#string make_file_patch(
#    string old_pathname,
#    string new_pathname,
#    string patch_filename = "${old_pathname}.patch")
#
#Make the passed patch file (defaulting to the passed old path suffixed with
#`.patch`) differencing the passed old and new paths. Such paths must either be
#both files or both directories. In the latter case, differencing is recursive.

#FUXME: Rename to make_path_patch(). Actually, split into two new
#make_file_text_patch() and make_dir_file_text_patch_recursively(). Hmm... For
#the latter, how about make_file_text_patch_from_new_and_old_dir_recursively() instead?
#FUXME: It's not clear this function is actually helpful. In general, the
#caller will probably prefer to call make_path_file() with source and target
#directories, in which case "diff" should perform such operation already.
# string make_file_patch_for_new_path(string new_pathname, string patch_filename)
#
# Make the passed patch file with the contents of the passed pathname. If such
# path is a directory, the patch file contains the recursive contents of all
# files in such directory. The resulting patch file is typically used for new
# files added to projects.
#make_file_patch_for_new_path() {
    # Localize passed arguments, removing the passed patch if already extant.
#    die_unless_args_3 'expected one new pathname and one patch filename'
#    string new_pathname="${1}" patch_filename="${2}"
#    die_unless_path "${new_pathname}"
#    remove_file_if_found "${patch_filename}"

    # Validate passed arguments.
#    list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
#    is_dir "${new_pathname}" and
#        zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )

    # Difference.
#    interactively say\
#        "from \"${new_pathname}\" into \"${patch_filename}\"..."
#    run_code_with_options 'diff --from-file=/dev/null' 'zeshy_diff_options'\
#        "${new_pathname}" > "${patch_filename}"
#}

#   string redirect_to_screen
#   and redirect_to_screen='1>&2'
#   run_code_with_options diff 'zeshy_diff_options'\
#       "${old_pathname}" "${new_pathname}"\
#        ${redirect_to_screen} >"${patch_filename}" | true and
#       print_message ${pipestatus[@]}

# function thus is intended for describing new
# files added to a project.
# By precedent, the old pathname in the resulting patch
# file will be "/dev/null".
