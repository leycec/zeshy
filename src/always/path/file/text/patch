#!/usr/bin/env zsh
# ====================[ patch                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file patching.
#
# --------------------( TODO                               )--------------------
# * Add support for compressed patch files, both on input (apply_) and output
#   (make_). For the latter, we'll need a new function "is_archive_file" in
#   "file/content/archive" matching on... hmm; we probably shouldn't trust
#   filenames. "file" is probably faster, anyway, given it's C heritage; just
#   call get_file_mimetype() and test the return value. Most archive files should
#   (hopefully) have a common prefix (say, "x-compressed"). Check this.

# ....................{ MAKERS                             }....................
# string make_file_patch(
#   string old_pathname, string new_pathname,
#   string patch_filename = "${old_pathname}.patch")
#
# Make the passed patch file (defaulting to the passed old path suffixed with
# ".patch") differencing the passed old and new paths. Such paths must either be
# both files or both directories. In the latter case, differencing is recursive.
function make_file_patch() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one old pathname, one new pathname, and optional patch filename'
    string old_pathname="${1}" new_pathname="${2}"
    die_unless_path "${old_pathname}"
    die_unless_path "${new_pathname}"

    # Ensure either two files or two directories were passed.
    list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
    if is_file "${old_pathname}" and is_file "${new_pathname}"
    then noop
    elif is_dir "${old_pathname}" and is_dir "${new_pathname}"
    then zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )
    else die\
        "\"${old_pathname}\" and \"${new_pathname}\" neither both files or directories"
    fi

    # Default the passed patch to the passed old path excluding suffixing "/",
    # removing such patch if already found.
    string patch_filename
    patch_filename="${3:-$(remove_string_suffix "${old_pathname}" '/').patch}"
#   say "removing \"${patch_filename}\"..."
    remove_file_if_found "${patch_filename}"

    # Make the passed patch. If interactive, redirect standard print_string to error
    # to assist the current user review the patch. Oddly, "diff" returns exit
    # status 1 on successfully differencing non-identical files (!?) and exit
    # status 2 on fatal error. Thanks for being idiotically different, "diff".
    #
    # Fortunately, the return_command_exit_status() approach helps revise such idiocy.
    # Unfortunately, this approach requires manually reimplementing both
    # run_with_options() and return_command_exit_status() here.
    #
    # *crudely blows both nostrils at the "diff" authors' pale-faced cupidity*
    list diff; diff=( diff "${zeshy_diff_options[@]}" )
    if is_shell_interactive; then
        say "making \"${patch_filename}\"... [${old_pathname} -> ${new_pathname}]"
        diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_INTERACTIVE[@]}" )
    else
        diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" )
    fi

    # Coerce non-zero exit status of 1 to 0.
    integer diff_status
    "${diff[@]}" "${old_pathname}" "${new_pathname}" >"${patch_filename}" |
        cat and diff_status="${pipestatus[1]}"
    if (( diff_status == 1 ))
    then return_true
    else return ${diff_status}
    fi
}

# ....................{ PATCHERS                           }....................
# string apply_file_patch(
#   string patch_filename,
#   string target_directory = get_current_dir(),
#   int patch_level = 0)
#
# Apply the passed patch file to the appropriate file(s) in the passed directory
# (defaulting to the current directory) under the passed 0-based patch level
# (defaulting to the first level in the range 0 to 5 that successfully applies).
#
# For security, this function throws an exception if the passed patch file
# attempts to patch absolute filenames (e.g., "/sbin/init") or parent-relative
# filenames (e.g., "../../../init/sh").
function apply_file_patch() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one patch filename, optional target dirname, and optional patch level'
    string\
        patch_filename="${1}"\
        target_path_dirname="${2:-$(get_current_dir)}"\
        patch_level="${3:-}"
    die_unless_file "${patch_filename}"
    die_unless_dir "${target_path_dirname}"

    # Forbid absolute and parent-relative filenames in the patch file.
    if is_file_text_line_match_pcre "${patch_filename}"\
        '^(\*\*\*|\+\+\+|\-\-\-)\s+(/|(.*/)?\.\./)'; then
        string error_message="\"${patch_filename}\" dangerously patches an absolute or parent-relative path"

        # If interactive, require the user confirm such risky behavior.
        if is_shell_interactive; then
            cry "${error_message}"
            ask_boolean_strongly 'really apply a potentially dangerous patch?' or
                return_false
        # Otherwise, throw an exception.
        else die "${error_message}"
        fi
    fi

    # Patch.
    store_current_dir "${target_path_dirname}"
    {
        # If no patch level was passed, iteractively search for a successful
        # patch level by attempting each in ascending order (as dry runs).
        if is_empty "${patch_level}"; then
            integer patch_level=0  patch_level_max=5
            for ((; patch_level <= patch_level_max; patch_level++)) {
                say "attempting patch level ${patch_level} on \"${patch_filename}\"..."
#               run_with_options "patch -p${patch_level} --dry-run --force"\
                run_with_options "patch -p${patch_level} --dry-run --force --quiet"\
                    'ZESHY_PATCH_OPTIONS' "< '${patch_filename}'"\
                    and break or true
#                   and break or continue
            }

            # If no patch level succeeded, rerun the first dry run, thus forcing
            # "patch" to print a helpful error message before returning non-zero
            # exit status and hence inducing a fatal exception.
            (( patch_level <= patch_level_max )) or
                run_with_options "patch -p0 --dry-run --force"\
                    'ZESHY_PATCH_OPTIONS' "< '${patch_filename}'"
        fi

        # Apply the current (presumably successful) patch level.
        die_unless_string_integer "${patch_level}"
        interactively say "applying \"${patch_filename}\" to \"${target_path_dirname}\" under patch level ${patch_level}..."
        run_with_options "patch -p${patch_level}" 'ZESHY_PATCH_OPTIONS'\
            "< '${patch_filename}'"
    } always {
        restore_current_dir
    }
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: It's not clear this function is actually helpful. In general, the
#caller will probably prefer to call make_path_file() with source and target
#directories, in which case "diff" should perform such operation already.
# string make_file_patch_for_new_path(string new_pathname, string patch_filename)
#
# Make the passed patch file with the contents of the passed pathname. If such
# path is a directory, the patch file contains the recursive contents of all
# files in such directory. The resulting patch file is typically used for new
# files added to projects.
#make_file_patch_for_new_path() {
    # Localize passed arguments, removing the passed patch if already extant.
#    die_unless_args_3 'expected one new pathname and one patch filename'
#    string new_pathname="${1}" patch_filename="${2}"
#    die_unless_path "${new_pathname}"
#    remove_file_if_found "${patch_filename}"

    # Validate passed arguments.
#    list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
#    is_dir "${new_pathname}" and
#        zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )

    # Difference.
#    interactively say\
#        "from \"${new_pathname}\" into \"${patch_filename}\"..."
#    run_with_options 'diff --from-file=/dev/null' 'zeshy_diff_options'\
#        "${new_pathname}" > "${patch_filename}"
#}

#   string redirect_to_screen
#   and redirect_to_screen='1>&2'
#   run_with_options diff 'zeshy_diff_options'\
#       "${old_pathname}" "${new_pathname}"\
#        ${redirect_to_screen} >"${patch_filename}" | true and
#       say ${pipestatus[@]}

# function thus is intended for describing new
# files added to a project.
# By precedent, the old pathname in the resulting patch
# file will be "/dev/null".
