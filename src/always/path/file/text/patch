#!/usr/bin/env zsh
# ====================[ patch                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle text file patching.
#
# --------------------( TODO                               )--------------------
# * Add support for compressed patch files, both on input (apply_) and output
#   (make_). For the latter, we'll need a new function "is_archive_file" in
#   "file/content/archive" matching on... hmm; we probably shouldn't trust
#   filenames. "file" is probably faster, anyway, given it's C heritage; just
#   call get_file_mimetype() and test the return value. Most archive files should
#   (hopefully) have a common prefix (say, "x-compressed"). Check this.

# ....................{ MAKERS                             }....................
declare_function_with_stdin <<'/---'
string make_file_text_patch(
    string patch_filename,
    string new_pathname,
    string old_pathname)

Write the passed patch file with all differences between the passed new and old
paths. Such paths must be either both files or both directories. In the latter
case, recursively difference all text files in such directories.

Assuming default ${ZESHY_DIFF_OPTIONS}, such differences will be in
https://en.wikipedia.org/wiki/Diff#Unified_format[*unified `diff` format*], the
canonical patch file format for most open-source software projects.
/---
function make_file_text_patch() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one patch filename, one new filename, and one old filename'
    string pathname_new="${1}" pathname_old="${2}"
    die_unless_files_text "${pathname_new}" "${pathname_old}"

    #FIXME: This is silly. I see no compelling reason why we can't defer to
    #run_command_with_options_configured(). We will require a new alias for
    #setting the exit status of a command to an integer variable. But *THAT*
    #shouldn't be terribly difficult. *SIGH*

    # Ensure either two files or two directories were passed.
    list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
    if { is_files "${pathname_old}" "${pathname_new}" } {
        noop
    } elif { is_dir "${pathname_old}" and is_dir "${pathname_new}" } {
        zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )
    } else {
        die "\"${pathname_old}\" and \"${pathname_new}\" neither both files or directories"
    }

    # Default the passed patch to the passed old path excluding suffixing "/",
    # removing such patch if already found.
    string patch_filename

    #FIXME: Nice, but should *REALLY* be shifted to a new
    #make_file_text_patch_with_options() function. Hmmmmm; actually, we can do
    #one better. It's rarely (O.K., *NEVER*) helpful to write such patch into
    #the codebase itself. Instead, default to:
    #"$(get_dir)/$(get_basename "${pathname_old}").patch"
    #FIXME: Add a new interactive alias expanding to
    #make_file_text_patch_with_options().
    patch_filename="${3:-$(remove_string_suffix "${pathname_old}" '/').patch}"
#   print_message "removing \"${patch_filename}\"..."
    remove_file_if_found "${patch_filename}"

    # Make the passed patch. If interactive, redirect standard output to error
    # to assist the current user review the patch. Oddly, "diff" returns exit
    # status 1 on successfully differencing non-identical files (!?) and exit
    # status 2 on fatal error. Thanks for being idiotically different, "diff".
    #
    # Fortunately, the return_exit_status() approach helps revise such idiocy.
    # Unfortunately, this approach requires manually reimplementing both
    # run_command_with_options() and return_exit_status() here.
    #
    # *crudely blows both nostrils at the "diff" authors' pale-faced cupidity*
    list diff; diff=( diff "${zeshy_diff_options[@]}" )
    if { is_shell_interactive } {
        #FIXME: Printing such a message is largely unhelpful.
        print_message "making \"${patch_filename}\"... [${pathname_old} -> ${pathname_new}]"
        diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_INTERACTIVE[@]}" )
    } else {
        diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" )
    }

    #FIXME: "cat"-ing such diff doesn't strike me as particularly desirable.
    #After all, this function is *NOT* a printer function. How hard is it to
    #simply vim or cat the output patch file, anyway? For generality, cease
    #such nonsense.

    # Coerce exit status 1 to 0.
    integer exit_status
    "${diff[@]}" "${pathname_old}" "${pathname_new}" >"${patch_filename}" |
        cat and exit_status="${pipestatus[1]}"
    if (( exit_status == 1 )) {
        return_true
    } else {
        return ${exit_status}
    }
}

# ....................{ PATCHERS                           }....................
declare_function '
string apply_file_text_patch(
  string patch_filename,
  string target_directory = "$(get_dir)",
  integer patch_level = 0)

Apply the passed patch file to the appropriate file(s) in the passed directory
(defaulting to the current directory) under the passed 0-based patch level
(defaulting to the first level in the range 0 to 5 that successfully applies).

For security, this function throws an exception if the passed patch file
attempts to patch absolute filenames (e.g., "/sbin/init") or parent-relative
filenames (e.g., "../../../init/sh").
'
function apply_file_patch() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one patch filename, optional target dirname, and optional patch level'
    string\
        patch_filename="${1}"\
        target_path_dirname="${2:-$(get_dir)}"\
        patch_level="${3:-}"
    die_unless_file "${patch_filename}"
    die_unless_dir "${target_path_dirname}"

    # Forbid absolute and parent-relative filenames in the patch file.
    if is_file_text_line_pcre_match "${patch_filename}"\
        '^(\*\*\*|\+\+\+|\/---\-)\s+(/|(.*/)?\.\./)'; then
        string error_message="\"${patch_filename}\" dangerously patches an absolute or parent-relative path"

        # If interactive, require the user confirm such risky behavior.
        if is_shell_interactive; then
            print_warning "${error_message}"
            is_response_yes_strongly_for_question 'really apply a potentially dangerous patch?' or
                return_false
        # Otherwise, throw an exception.
        else die "${error_message}"
        fi
    fi

    # Patch.
    set_dir_and_prepend_to_dir_stack "${target_path_dirname}"
    {
        # If no patch level was passed, iteractively search for a successful
        # patch level by attempting each in ascending order (as dry runs).
        if is_string_empty "${patch_level}"; then
            integer patch_level=0  patch_level_max=5
            for ((; patch_level <= patch_level_max; patch_level++)) {
                print_message "attempting patch level ${patch_level} on \"${patch_filename}\"..."
#               run_command_with_options "patch -p${patch_level} --dry-run --force"\
                run_command_with_options "patch -p${patch_level} --dry-run --force --quiet"\
                    'ZESHY_PATCH_OPTIONS' "< '${patch_filename}'"\
                    and break or true
#                   and break or continue
            }

            # If no patch level succeeded, rerun the first dry run, thus forcing
            # "patch" to print a helpful error message before returning non-zero
            # exit status and hence inducing a fatal exception.
            (( patch_level <= patch_level_max )) or
                run_command_with_options "patch -p0 --dry-run --force"\
                    'ZESHY_PATCH_OPTIONS' "< '${patch_filename}'"
        fi

        # Apply the current (presumably successful) patch level.
        die_unless_integer "${patch_level}"
        interactively print_message "applying \"${patch_filename}\" to \"${target_path_dirname}\" under patch level ${patch_level}..."
        run_command_with_options "patch -p${patch_level}" 'ZESHY_PATCH_OPTIONS'\
            "< '${patch_filename}'"
    } always {
        pop_dir_stack_and_set_dir_to_top
    }
}

# --------------------( WASTELANDS                         )--------------------
    # Ensure either two files or two directories were passed.
#   list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
#   if { is_files "${pathname_old}" "${pathname_new}" } {
#       noop
#   } elif { is_dir "${pathname_old}" and is_dir "${pathname_new}" } {
#       zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )
#   } else {
#       die "\"${pathname_old}\" and \"${pathname_new}\" neither both files or directories"
#   }

    # Default the passed patch to the passed old path excluding suffixing "/",
    # removing such patch if already found.
#   string patch_filename
#   patch_filename="${3:-$(remove_string_suffix "${pathname_old}" '/').patch}"
#   print_message "removing \"${patch_filename}\"..."
#   remove_file_if_found "${patch_filename}"

    # Make the passed patch. If interactive, redirect standard output to error
    # to assist the current user review the patch. Oddly, "diff" returns exit
    # status 1 on successfully differencing non-identical files (!?) and exit
    # status 2 on fatal error. Thanks for being idiotically different, "diff".
    #
    # Fortunately, the return_exit_status() approach helps revise such idiocy.
    # Unfortunately, this approach requires manually reimplementing both
    # run_command_with_options() and return_exit_status() here.
    #
    # *crudely blows both nostrils at the "diff" authors' pale-faced cupidity*
#   list diff; diff=( diff "${zeshy_diff_options[@]}" )
#   if { is_shell_interactive } {
#       print_message "making \"${patch_filename}\"... [${pathname_old} -> ${pathname_new}]"
#       diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_INTERACTIVE[@]}" )
#   } else {
#       diff+=( "${ZESHY_DIFF_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" )
#   }

    # Coerce exit status 1 to 0.
#   integer exit_status
#   "${diff[@]}" "${pathname_old}" "${pathname_new}" >"${patch_filename}" |
#       cat and exit_status="${pipestatus[1]}"
#   if (( exit_status == 1 )) {
#       return_true
#   } else {
#       return ${exit_status}
#   }

#string make_file_patch(
#    string old_pathname,
#    string new_pathname,
#    string patch_filename = "${old_pathname}.patch")
#
#Make the passed patch file (defaulting to the passed old path suffixed with
#`.patch`) differencing the passed old and new paths. Such paths must either be
#both files or both directories. In the latter case, differencing is recursive.

#FUXME: Rename to make_path_patch(). Actually, split into two new
#make_file_text_patch() and make_dir_file_text_patch_recursively(). Hmm... For
#the latter, how about make_file_text_patch_from_new_and_old_dir_recursively() instead?
#FUXME: It's not clear this function is actually helpful. In general, the
#caller will probably prefer to call make_path_file() with source and target
#directories, in which case "diff" should perform such operation already.
# string make_file_patch_for_new_path(string new_pathname, string patch_filename)
#
# Make the passed patch file with the contents of the passed pathname. If such
# path is a directory, the patch file contains the recursive contents of all
# files in such directory. The resulting patch file is typically used for new
# files added to projects.
#make_file_patch_for_new_path() {
    # Localize passed arguments, removing the passed patch if already extant.
#    die_unless_args_3 'expected one new pathname and one patch filename'
#    string new_pathname="${1}" patch_filename="${2}"
#    die_unless_path_exists "${new_pathname}"
#    remove_file_if_found "${patch_filename}"

    # Validate passed arguments.
#    list zeshy_diff_options; zeshy_diff_options=( "${ZESHY_DIFF_OPTIONS[@]}" )
#    is_dir "${new_pathname}" and
#        zeshy_diff_options+=( "${ZESHY_DIFF_OPTIONS_IF_RECURSIVE[@]}" )

    # Difference.
#    interactively say\
#        "from \"${new_pathname}\" into \"${patch_filename}\"..."
#    run_command_with_options 'diff --from-file=/dev/null' 'zeshy_diff_options'\
#        "${new_pathname}" > "${patch_filename}"
#}

#   string redirect_to_screen
#   and redirect_to_screen='1>&2'
#   run_command_with_options diff 'zeshy_diff_options'\
#       "${old_pathname}" "${new_pathname}"\
#        ${redirect_to_screen} >"${patch_filename}" | true and
#       print_message ${pipestatus[@]}

# function thus is intended for describing new
# files added to a project.
# By precedent, the old pathname in the resulting patch
# file will be "/dev/null".
