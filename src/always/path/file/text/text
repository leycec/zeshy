#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *plaintext files* (i.e., non-binary files).
-/-

#FIXME: When printing text files to a terminal, perform syntax highlighting of
#source files. Calling get_file_type_media() should efficiently suffice to decide
#this. There exist any number of source code highlighters; the three most
#popular as of this date are:
#
#* GNU source-highlighter (https://www.gnu.org/software/src-highlite).
#* Highlight (http://www.andre-simon.de/doku/highlight/en/langs.html).
#* Pygments (http://pygments.org/languages).
#
#Ideally, I'd like to default to Pygments if available. In practice, we should
#probably default to the highlighter that provides a command line option for
#either listing supported languages and/or filetypes *OR* for testing whether it
#supports the passed file(s).
#
#Happily, a helpful blog post has already been authored on how to robustly
#replace "cat" and "less" with zsh-specific Pygmentized versions. See:
#    http://www.jonathangross.de/2012/08/13/adding-a-little-color-to-your-command-line-life

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_text(
    string filename,
    string error_message = "\"${filename}\" not a text file")

Throw an exception with the passed message unless the passed text file exists.
See is_file_text() for further details.
/---
function die_unless_file_text() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string filename="${1}"
    is_file_text "${filename}" or die "${2:-\"${filename}\" not a text file}"
}

declare_function_with_stdin <<'/---'
void die_unless_files(string filename1, string filename2, ...)

Throw an exception with a stock message unless all passed text files exist.
/---
function die_unless_files_text() {
    die_unless_args 'expected at least one filename'
    string filename
    for    filename ("${@}") { die_unless_file_text "${filename}" }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_text(string pathname)

Return success if the passed path is an existing *text file* (i.e., non-binary
file), as decided by dynamically inspecting such file's contents with `file`.

== Symbolic Links ==

Symbolic links are binary files and hence _not_ text files. Although most high-
level commands operating on text files accept text files as text files, low-
level commands (e.g., `zsh` module `mapfile`) do not. For safety, this function
thus complies with the technical definition of symbolic links as non-text files
by returning failure when passed symbolic links. If this is unacceptable,
consider calling die_if_link_symbolic() before calling this function.
/---
function is_file_text() {
    die_unless_arg 'expected one pathname'
    string pathname="${1}"
    is_file "${pathname}" and not is_file_binary "${pathname}"
}

# ....................{ TESTERS ~ text                     }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_text_equals(string filename, string text)

Return success if the passed text file contains only the passed text.
/---
function is_file_text_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one string'
    string filename="${1}" text="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_equals "$(get_file_text "${filename}")" "${text}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_file_text_contains(string filename, string text)

Return success if the passed text file contains the passed text.
/---
function is_file_text_contains() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one string'
    string filename="${1}" substring="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_contains "$(get_file_text "${filename}")" "${substring}"
}

#FIXME: Rename to is_file_text_line_matches_pcre(). No, wait. Rename to
#is_file_text_matches_pcre_multiline() and correct all functions calling this
#function. *sigh*
declare_function_with_stdin <<'/---'
[status: boolean] is_file_text_line_pcre_match(
    string filename, string pcre)

Return success if the passed text file matches the passed PCRE with multiline
matching enabled.
/---
function is_file_text_line_pcre_match() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one PCRE'
    string filename="${1}" pcre="${2}"
    die_unless_file_text "${filename}"

    # Test such PCRE.
    is_string_matches_pcre_multiline "$(get_file_text "${filename}")" "${pcre}"
}

# ....................{ GETTERS                            }....................
#FIXME: Whoops! Turns out canonicalize_path() is subtly dangerous. Here's why:
#if the passed path is a shell-specific path (e.g., "/proc/mounts"), then
#calling canonicalize_path() from a command substitution success *BUT* basically
#fails since the returned path ceases to exist when such substitution completes.
#Hence, we basically need to replace every call to canonicalize_path() to
#set_string_to_path_canonicalized() *AND* document why in this documentation.
#It's important, to avoid bugs both here and elsewhere.
#FIXME: Shift elsewhere.
#FIXME: Document.
function set_string_to_path_canonicalized() {
    # Validate sanity.
    die_unless_args_2 'expected one variable name and one pathname'
    string string_name__sstpc="${1}" pathname__sstpc="${2}"
    die_unless_variable_string "${string_name__sstpc}"
    die_unless_path_exists "${pathname__sstpc}"

    # Set such string.
    set_string_to_string "${string_name__sstpc}" "${pathname__sstpc}"(:A)
}

declare_function_with_stdin <<'/---'
string get_file_text(string filename)

Get the contents of the passed text file.
/---
function get_file_text() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    # Canonicalize such path. If such path is a symbolic link rather than text
    # file and we do *NOT* canonicalize such path from the former to latter,
    # attempting to index ${mapfile} by such path below fails with an error:
    # "get_file_text:21: mapfile[${filename}]: parameter not set".
    set_string_to_path_canonicalized filename "${filename}"
#   filename="$(canonicalize_path "${filename}")"

    # Since symbolic links are *NOT* text files, test such path after
    # canonicalizing such path.
    die_unless_file_text "${filename}"

    #FIXME: Actually, we should probably benchmark this for sufficiently large
    #files. "mapfile" should be the fastest, but "cat" probably gives it a run
    #for its money.

    # Get such text. While precompiled zsh module "mapfile" provides the most
    # efficient access to such text, recall the following techniques to also
    # suffice:
    #
    #     cat -- "${filename}"
    #     output_string "$(< "${filename}")"
    #
    # For efficiency, avoid string copies and hence extraneous function calls.
    # See run_command_with_mapfile() for further details.
    load_module_mapfile
    {
        output_string "${mapfile[${filename}]}"
    } always {
        unload_module_mapfile
    }
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'/---'
integer get_file_text_line_count(
    string filename1, string filename2, ...)

Get the total number of lines in the passed text files.
/---
function get_file_text_line_count() {
    die_unless_args 'expected at least one filename'
    command wc -l -- "${@}"
}

declare_function_with_stdin <<'/---'
integer get_file_text_word_count(
    string filename1, string filename2, ...)

Get the total number of words in the passed text files.
/---
function get_file_text_word_count() {
    die_unless_args 'expected at least one filename'
    command wc -w -- "${@}"
}

# ....................{ SETTERS                            }....................
#FIXME: If such file is a symbolic link to a text file, make this still work.
#All we have to do is canonicalize its path, as in get_file_text(). Make it so.

declare_function_with_stdin <<'/---'
string set_list_to_file_text_lines(string list_name, string filename)

Set the passed list to the contents of the passed text file split on newlines.
/---
function set_list_to_file_text_lines() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one filename'
    string list_name="${1}" filename="${2}"
    die_unless_list "${list_name}"
    die_unless_file_text "${filename}"

    # Set such list.
    run_command_with_mapfile "${list_name}=( \${(z)mapfile[${filename}]} )"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_file_text(string filename1, string filename2, ...)

Print the contents of the passed text files piped to the current pager if such
output exceeds the terminal height or as is (i.e., without paging) otherwise.
/---
function print_file_text() {
    #FIXME: This only applies to an eventual print_file_text_with_options()
    #implementation and hence should be shifted there... when it exists.

    # If piped input, pass such input to "cat" and return.
    if { is_stdin_nonempty } {
        die_if_args
        get_stdin | run_command_paged command cat
        return_true
    }

    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # When passed one file, "cat" output unambiguously corresponds to such
    # file. In such a case, "cat" suffices.
    if { is_arg } {
        run_command_paged command cat -- "${(q)@}"
    # When passed multiple files, "cat" fails to prepend the output from each
    # with the corresponding filename. (Fix this, scallywag "cat"!)
    } else {
        string filename
        for    filename ("${@}") {
            print_heading  "${filename}"
            command cat -- "${filename}"
        } | page_stdin
    }
}

#FIXME: Rename to print_path_line_count_recursively(), as the implementation
#below demonstrates.
declare_function_with_stdin <<'/---'
integer get_file_text_line_count_recursively(string path)

Get the total number of lines corresponding to the file(s) in the passed path,
as follows:

* If no path is passed, default to the current directory.
* If this path is a directory, recursively sum the number of lines for files
  in this path ignoring binary files.
* If this path is a file:
** And this file is a PDF, use `pdftotext` to sum the number of text lines in
   the rendered PDF.
** Else, sum the number of lines in this file.
/---
function get_file_text_line_count_recursively() {
    # Validate passed parameters.
    die_unless_args_0_to_1 'expected optional pathname'
    string find_path; file_path="${1:-$(get_dir)}"
    integer line_count

    if { is_dir "${find_path}" } {
        print_message_interactively\
            "counting lines for all text files in \"${find_path}\"..."

        #FIXME: This is horrible. Replace dependency on "find" and "wc" with
        #pure homecooked zsh.
        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_file_text().
        line_count="$(find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_file_text_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }')"
    } elif { is_file "${find_path}" } {
        print_message_interactively "counting lines for \"${find_path}\"..."

        #FIXME: This is rather shoddy. Generalize to multiple filetypes and
        #functions handling such filetypes as for extract_archive().
        if { is_file_type "${find_path}" 'pdf' and is_pathable pdftotext } {
            line_count="$(pdftotext "${find_path}" - | wc -l)"
        } else {
            die_unless_file_file "${find_path}"
            line_count="$(wc -l "${find_path}")"
        }
    } else {
        die "\"${find_path}\" neither a file or directory"
    }

    # Print such count human-readably.
    convert_integer_to_string_localized "${line_count}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_list_to_dir_files_text(string list_name, string dirname)

Set the passed list to all text files directly in the passed directory.
/---
function set_list_to_dir_files_text() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one dirname'
    string list_name__sltdft="${1}" dirname__sltdft="${2}"
    die_unless_list "${list_name__sltdft}"
    die_unless_dir "${dirname__sltdft}"

    # Set such list. For efficiency, manually implement the test for such glob
    # qualifier. See get_file_encoding() and is_file_binary() for further
    # details. Dismantled, this is:
    #
    # * "-", resolving symbolic links to their transitive targets.
    # * ".", excluding non-plain files.
    # * "e{...}", excluding all files for which such test evaluates to false
    #   (i.e., binary files).
    set_list_to_path_matches_qualified\
        "${list_name__sltdft}" "${dirname__sltdft}/*"\
        "-.e:'[[ \$(file --brief --mime-encoding '\${REPLY}') != binary ]]':"
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
void write_file_with_string(string filename, string text)

Overwrite the contents of the passed text file with the passed string if such
file exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function write_file_with_string() {
    # zeshy disables zsh option "clobber", thus requiring the ">!" operator to
    # force truncating the contents of the passed file if extant.
    die_unless_args_2 'expected one string and one filename'
    output_string "${2}" >!"${1}"
}

declare_function_with_stdin <<'/---'
void append_file_with_string(string filename, string text)

Append the passed string to the contents of the passed text file if such file
exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function append_file_with_string() {
    # zeshy disables zsh option "clobber", thus requiring the ">>!" operator to
    # force creating the passed file if non-extant.
    die_unless_args_2 'expected one string and one filename'
    output_string "${2}" >>!"${1}"
}

# --------------------( WASTELANDS                         )--------------------
    # If such path is an existing nonfile and the canonical file to which such path
    # refers is *NOT* binary, return success; else, failure.

#Return success if the passed path is an existing text file _and_ is either a:
#
#* *Text file* (i.e., a non-binary file), as decided by dynamically inspecting
#  the contents of such file with `file`.
#* Symbolic link to a text file. Technically, symbolic links are binary files.
#  Subjectively, however, nearly all commands operating an text files accept
#  symbolic links to text files as text files. Hence, this function does the
#  same. If unacceptable, consider calling die_if_link_symbolic() before calling
#  this function.

    #FUXME: Uhm; we also need to encapsulate "< /dev/stdin" as get_stdin().
    #Easy, it's just yet another requirement.
        # Canonicalize such path, thus converting symbolic links in such path
        # into their transitive targets.
#This implements a pure-`zsh` analogue to the GNU-specific `grep --perl-regexp`.
#As the
#function name suggests, this function does _not_ interactively confirm such
#overwriting. Call this function only where guaranteed to be non-destructive.
    #FUXME: Convert to a run_command_with_options()-centric implementation. Or
#   string filename="${1}" text="${2}"
#FUXME: Rename write_file_with_string() to write_file_with_string_text().
#Naturally, reorder arguments as well and apply to appending below. Actually,
#drop the "_text"; obviously, the outcome is a text file. So, just:
#write_file_with_string(). This nicely coincides with other such functions as
#write_file_with_variable() on the one hand and print_string() on the other.
#Hence, "string" is the dominant object here. Hmm; come to think of it, why not
#print_string_to_file() and print_variable_to_script()? Ah; no. Write and read
#are much better file-oriented verbs here.
#
#tl;dr:
#Rename to write_file_with_string().

#FUXME: Rename to is_file_text_pcre_match_line() or perhaps
#is_file_text_match_line_pcre() or is_file_text_matches_line_pcre(). Ah; we're
#getting closer. We really want the "_line" adjacent to the "_text", however,
#which synchronizes much better with the conception of "line" as a discrete
#component. That then leaves us with is_file_text_line_pcre_match() and a
#corresponding is_file_text_line_match() function. All good, yes? We should
#broadly apply similar fixes elsewhere to "_line" functions: particularly, to
#"variable/string/line".
#
#tl;dr:
#Rename to is_file_text_line_pcre_match().

#FUXME: Rename to is_file_text_equals(), is_file_text_string(), or
#is_file_text_equals(). Hmm; the latter, possibly? This suggests a similar
#is_string_equals(), which makes perfect sense, permitting an implementation
#here resembling:
#       get_file_text "${pathname}" | is_string_equals "${text}"
#       is "$(get_file_text "${pathname}")" == "${text}" si
#Nice!
# or is_file_text_contains(). Yes... yes? Come to think,
#I now prefer (I know, I know...) verbs "equals" and "contains" for such matches
#and nouns "prefix" and "suffix" for such matches. Apply elsewhere, yes?
#run_command_with_stdin_piped
#FUXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_command_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FUXME: It'd be nice to abstract out the load_module/freeze_variable/unload_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load zsh module "mapfile".
#   load_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_module zsh/mapfile
#FUXME: Should be renamed to, say, "get_find_command_file_text_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# boolean is_file_text_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_file_text_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
