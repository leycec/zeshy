#!/usr/bin/env zsh
# ====================[ text                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle text (i.e., non-binary) files.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_file_text(
  string filename,
  string error_message = "\"${filename}\" not a text file")

Throw an exception unless the passed file is an existing text file.
'
function die_unless_file_text() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string filename="${1}"
    is_file_text "${filename}" or die "${2:-\"${filename}\" not a text file}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_file_text(string pathname)

Return true if the passed path is a text (i.e., non-binary) file.
'
function is_file_text() {
    die_unless_arg 'expected one pathname'
    string pathname="${1}"
    is_file "${pathname}" and not is_file_binary "${1}"
}

document_function '
boolean is_file_text_equals(string pathname, string text)

Return true if the passed text file contains exactly the passed text.
'
function is_file_text_equals() {
    die_unless_args_2 'expected one pathname and one string'
    string pathname="${1}" text="${2}"
    is_file_text "${pathname}" and
        get_file_text "${pathname}" | is_string_equals "${text}"
}

document_function '
boolean is_file_text_substring(string pathname, string text)

Return true if the passed text file contains the passed text.
'
function is_file_text_substring() {
    die_unless_args_2 'expected one pathname and one string'
    string pathname="${1}" text="${2}"
    is_file_text "${pathname}" and
        get_file_text "${pathname}" | is_string_substring "${text}"
}

document_function '
boolean is_file_text_line_match_pcre(
  string pathname, string pcre, string pcre_arg1, string pcre_arg2, ...)

Return true if the passed text file contains a line matching the passed PCRE
under option "-m" for multiline matching and the additional passed options.
This function implements a pure-zsh analogue to "grep --perl-regexp".
'
function is_file_text_line_match_pcre() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one pathname, one regex, and optional regex options'
    string pathname="${1}"

    # If such path is an existing text file, perform such match.
    is_file_text "${pathname}" and {
        behead_arg
        get_file_text "${pathname}" | is_string_line_match_pcre "${@}"
    }
}

# ....................{ GETTERS                            }....................
document_function '
string get_file_text(string filename)

Get the contents of the passed text file.
'
function get_file_text() {
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file_text "${filename}"
    run_with_mapfile "output \${mapfile[${filename}]}"
}

# ....................{ GETTERS ~ lines                    }....................
document_function '
integer get_file_text_line_count_recursively(string path)

Get the total number of lines corresponding to the file(s) in the passed path,
as follows:

* If no path is passed, default to the current directory.
* If this path is a directory, recursively sum the number of lines for files
  in this path ignoring binary files.
* If this path is a file:
  * And this file is a PDF, use "pdftotext" to sum the number of text lines in
    the rendered PDF.
  * Otherwise, sum the number of lines in this file.
'
function get_file_text_line_count_recursively() {
    # Validate passed parameters.
    die_unless_args_0_to_1 'expected optional pathname'
    string find_path; file_path="${1:-$(get_current_dir)}"

    if is_dir "${find_path}"; then
        say "counting lines for all text files in \"${find_path}\"..."

        #FIXME: This is horrible. Replace dependency on "find" and "wc" with
        #pure homecooked zsh.
        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_file_text().
        find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_file_text_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }' |\
            convert_integer_to_comma_separated_string
    elif is_file "${find_path}"; then
        say "counting lines for \"${find_path}\"..."

        if is "$(get_file_type "${find_path}")" == pdf si
        then pdftotext "${find_path}" - | wc -l | comma_separate_integer
        else
            die_unless_file_file "${find_path}"
            wc -l "${find_path}" | comma_separate_integer
        fi
    else die "\"${find_path}\" neither a file or directory"
    fi
}

# ....................{ SETTERS                            }....................
document_function '
string set_list_to_file_text_lines(string list_name, string filename)

Set the passed list to the contents of the passed text file split on newlines.
'
function set_list_to_file_text_lines() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one filename'
    string list_name="${1}" filename="${2}"
    die_unless_list "${list_name}"
    die_unless_file_text "${filename}"

    # Set such list.
    run_with_mapfile "${list_name}=( \${(z)mapfile[${filename}]} )"
}

# ....................{ PRINTERS                           }....................
document_function '
string print_file_text(string filename1, string filename2, ...)

Print the contents of the passed text files piped to the current pager if such
print_string exceeds the terminal height or as is (i.e., without paging) otherwise.
'
function print_file_text() {
    # If piped input, pass such input to "cat" and return.
    is_standard_input_piped and {
        die_if_args
        run_paged command cat
        return_true
    }

    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # When passed one file, "cat" print_string unambiguously corresponds to such
    # file. In such a case, "cat" suffices.
    if is_args_1
    then run_paged command cat -- "${(q)@}"
    # When passed multiple files, "cat" fails to prepend the print_string from
    # each with the corresponding filename. Correct this, scallywag "cat"!
    else {
            # Print the first passed file.
            say_first_section "${1}"
            command cat -- "${1}"
            behead_arg

            # Print all other passed files.
            for filename ("${@}") {
                say_next_section "${filename}"
                command cat -- "${filename}"
            }
        } | page_string
    fi
}

# ....................{ WRITERS                            }....................
#FIXME: Rename to write_file_with_string().
document_function '
void write_string_to_file(string filename, string text)

Overwrite the contents of the passed text file with the passed string. As the
function name suggests, this function does *NOT* interactively confirm such
overwriting. Call this function only where guaranteed to be non-destructive.
'
function write_string_to_file() {
    # Zeshy disables zsh option "clobber", thus requiring the ">!" operator to
    # force truncating the contents of the passed file if extant.
    die_unless_args_2 'expected one string and one filename'
    print_string "${2}" >! "${1}"
}

#FIXME: Rename to append_file_with_string().
document_function '
void append_string_to_file(string filename, string text)

Append the passed string to the contents of the passed text file. As under
write_string_to_file(), this function does *NOT* interactively confirm.
'
function append_string_to_file() {
    # Zeshy disables zsh option "clobber", thus requiring the ">>!" operator to
    # force creating the passed file if non-extant.
    die_unless_args_2 'expected one string and one filename'
    print_string "${2}" >>! "${1}"
}

# --------------------( WASTELANDS                         )--------------------
#   string filename="${1}" text="${2}"
#FUXME: Rename write_string_to_file() to write_string_to_file_text().
#Naturally, reorder arguments as well and apply to appending below. Actually,
#drop the "_text"; obviously, the outcome is a text file. So, just:
#write_string_to_file(). This nicely coincides with other such functions as
#write_variable_to_script() on the one hand and print_string() on the other.
#Hence, "string" is the dominant object here. Hmm; come to think of it, why not
#print_string_to_file() and print_variable_to_script()? Ah; no. Write and read
#are much better file-oriented verbs here.
#
#tl;dr:
#Rename to write_string_to_file().

#FUXME: Rename to is_file_text_match_pcre_line() or perhaps
#is_file_text_match_line_pcre() or is_file_text_matches_line_pcre(). Ah; we're
#getting closer. We really want the "_line" adjacent to the "_text", however,
#which synchronizes much better with the conception of "line" as a discrete
#component. That then leaves us with is_file_text_line_match_pcre() and a
#corresponding is_file_text_line_match() function. All good, yes? We should
#broadly apply similar fixes elsewhere to "_line" functions: particularly, to
#"variable/string/line".
#
#tl;dr:
#Rename to is_file_text_line_match_pcre().

#FUXME: Rename to is_file_text_equals(), is_file_text_string(), or
#is_file_text_equals(). Hmm; the latter, possibly? This suggests a similar
#is_string_equals(), which makes perfect sense, permitting an implementation
#here resembling:
#       get_file_text "${pathname}" | is_string_equals "${text}"
#       is "$(get_file_text "${pathname}")" == "${text}" si
#Nice!
# or is_file_text_contains(). Yes... yes? Come to think,
#I now prefer (I know, I know...) verbs "equals" and "contains" for such matches
#and nouns "prefix" and "suffix" for such matches. Apply elsewhere, yes?
#run_with_standard_input_piped
#FUXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FUXME: It'd be nice to abstract out the load_zsh_module/freeze_variable/unload_zsh_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load zsh module "mapfile".
#   load_zsh_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_zsh_module zsh/mapfile
#FUXME: Should be renamed to, say, "get_find_command_file_text_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# boolean is_file_text_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_file_text_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
