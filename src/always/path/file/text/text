#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *plaintext files* (i.e., non-binary files).
-/-

#FIXME: When printing text files to a terminal, perform syntax highlighting of
#source files. Calling get_file_type_media() should efficiently suffice to decide
#this. There exist any number of source code highlighters; the three most
#popular as of this date are:
#
#* GNU source-highlighter (https://www.gnu.org/software/src-highlite).
#* Highlight (http://www.andre-simon.de/doku/highlight/en/langs.html).
#* Pygments (http://pygments.org/languages).
#
#Ideally, I'd like to default to Pygments if available. In practice, we should
#probably default to the highlighter that provides a command line option for
#either listing supported languages and/or filetypes *OR* for testing whether it
#supports the passed file(s).
#
#Happily, a helpful blog post has already been authored on how to robustly
#replace "cat" and "less" with zsh-specific Pygmentized versions. See:
#    http://www.jonathangross.de/2012/08/13/adding-a-little-color-to-your-command-line-life

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_text(
    string filename,
    string error_message = "\"${filename}\" not a text file.")

Throw an exception with the passed message unless the passed text file exists.
See is_file_text() for further details.
/---
function die_unless_file_text() {
    die_unless_args_1_to_2\
        'Expected one pathname and optional error message.'
    string filename="${1}"
    is_file_text "${filename}" or die "${2:-\"${filename}\" not a text file.}"
}

declare_function_with_stdin <<'/---'
void die_unless_files(string filename1, string filename2, ...)

Throw an exception with a stock message unless all passed text files exist.
/---
function die_unless_files_text() {
    die_unless_args 'Expected at least one filename.'
    string filename
    for    filename ("${@}") { die_unless_file_text "${filename}" }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_text(string pathname)

Return success if the passed path is an existing *text file* (i.e., non-binary
file), as decided by dynamically inspecting such file's contents with `file`.

== Symbolic Links ==

Symbolic links are binary files and hence _not_ text files. Although most high-
level commands operating on text files accept text files as text files, low-
level commands (e.g., `zsh` module `mapfile`) do not. For safety, this function
thus complies with the technical definition of symbolic links as non-text files
by returning failure when passed symbolic links. If this is unacceptable,
consider calling die_if_link_symbolic() before calling this function.
/---
function is_file_text() {
    die_unless_arg 'Expected one pathname.'
    string pathname="${1}"
    is_file "${pathname}" and not is_file_binary "${pathname}"
}

# ....................{ TESTERS ~ text                     }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_text_equals(string filename, string text)

Return success if the passed text file contains only the passed text.
/---
function is_file_text_equals() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one filename and one string.'
    string filename="${1}" text="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_equals "$(get_file_text "${filename}")" "${text}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_file_text_contains(string filename, string text)

Return success if the passed text file contains the passed text.
/---
function is_file_text_contains() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one filename and one string.'
    string filename="${1}" substring="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_contains "$(get_file_text "${filename}")" "${substring}"
}

#FIXME: Provide examples.
declare_function_with_stdin <<'/---'
[status: boolean] is_file_text_matches_pcre_multiline(
    string filename, string pcre)

Return success if the passed text file matches the passed PCRE with multiline
matching enabled.
/---
function is_file_text_matches_pcre_multiline() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one filename and one PCRE.'
    string filename="${1}" pcre="${2}"
    die_unless_file_text "${filename}"

    # Test such PCRE.
    is_string_matches_pcre_multiline "$(get_file_text "${filename}")" "${pcre}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_file_text(string filename)

Get the contents of the passed text file: e.g.,

.get_file_text()
==========================================
[source]
------------------------------------------
>>> string on_employment=\
...    "Liberals say we should end employment discrimination. I say we should
...     end employment. Conservatives support right-to-work laws. Following Karl
...     Marx's wayward son-in-law Paul Lafargue, I support the right to be lazy.
...     Leftists favor full employment. Like the surrealists – except that I'm
...     not kidding – I favor full unemployment. Trotskyists agitate for
...     permanent revolution. I agitate for permanent revelry. But if all the
...     ideologues (as they do) advocate work – and not only because they plan
...     to make other people do theirs – they are strangely reluctant to say so.
...     They will carry on endlessly about wages, hours, working conditions,
...     exploitation, productivity, profitability. They'll gladly talk about
...     anything but work itself. These experts who offer to do our thinking for
...     us rarely share their conclusions about work, for all its saliency in
...     the lives of all of us. Among themselves they quibble over the details.
...     Unions and management agree that we ought to sell the time of our lives
...     in exchange for survival, although they haggle over the price. Marxists
...     think we should be bossed by bureaucrats. Libertarians think we should
...     be bossed by businessmen. Feminists don't care which form bossing takes
...     so long as the bosses are women. Clearly these ideology-mongers have
...     serious differences over how to divvy up the spoils of power. Just as
...     clearly, none of them have any objection to power as such and all of
...     them want to keep us working."
>>> write_file_with_string on_wage_slavery "${on_employment}"
>>> get_string_line "$(get_file_text on_wage_slavery)" 5
not kidding – I favor full unemployment. Trotskyists agitate for
------------------------------------------
==========================================

== Caveats ==

This function is typically called as a getter function from command substitution
and hence subshell of the current shell. While typically safe, such substitution
is _inherently_ unsafe in the general case, in which the passed path is a
shell-specific symbolic link. In such case, consider calling
set_string_to_file_text() instead. See canonicalize_path() for further details.
/---
function get_file_text() {
    # Validate passed arguments.
    die_unless_arg 'Expected one filename.'
    string filename

    # Canonicalize such path. If such path is a symbolic link rather than text
    # file and we do *NOT* canonicalize such path from the former to latter,
    # attempting to index ${mapfile} by such path below fails with an error:
    # "get_file_text:21: mapfile[${filename}]: parameter not set". For safety,
    # prefer set_string_to_path_canonical() to canonicalize_path().
    set_string_to_path_canonical filename "${1}"

    # Since symbolic links are *NOT* text files, test such path *AFTER*
    # canonicalizing such path.
    die_unless_file_text "${filename}"

    #FIXME: Actually, we should probably benchmark this for sufficiently large
    #files. "mapfile" should be the fastest, but "cat" probably gives it a run
    #for its money.

    # Get such text. While precompiled zsh module "mapfile" provides the most
    # efficient access to such text, recall the following techniques to also
    # suffice:
    #
    #     >>> cat -- "${filename}"
    #     >>> output_string "$(< "${filename}")"
    #
    # For efficiency, avoid string copies and hence extraneous function calls.
    # See run_code_with_mapfile() for further details. This is equivalent to:
    #
    #     >>> run_code_with_mapfile "output_string \"${mapfile[${filename}]}\""
    load_module_mapfile
    {
        output_string "${mapfile[${filename}]}"
    } always {
        unload_module_mapfile
    }
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'/---'
integer get_file_text_line_count(
    string filename1, string filename2, ...)

Get the total number of lines in the passed text files.
/---
function get_file_text_line_count() {
    die_unless_args 'Expected one or more filenames.'
    command wc -l -- "${@}"
}

declare_function_with_stdin <<'/---'
integer get_file_text_word_count(
    string filename1, string filename2, ...)

Get the total number of words in the passed text files.
/---
function get_file_text_word_count() {
    die_unless_args 'Expected one or more filenames.'
    command wc -w -- "${@}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_string_to_file_text(string list_name, string filename)

Set the passed string to the contents of the passed text file: e.g.,

.set_string_to_file_text()
==========================================
[source]
------------------------------------------
>>> string on_short_lives on_generalized_nastiness=\
...    "Crowley had always known that he would be around when the world ended,
...     because he was immortal and wouldn't have any alternative. But he'd
...     hoped it would be a long way off.
...     Because he rather liked people. It was a major failing in a demon.
...     Oh, he did his best to make their short lives miserable, because that
...     was his job, but nothing he could think up was half as bad as the stuff
...     they thought up themselves. They seemed to have a talent for it. It was
...     built into the design, somehow. They were born into a world that was
...     against them in a thousand little ways, and then devoted most of their
...     energies to making it worse. Over the years Crowley had found it
...     increasingly difficult to find anything demonic to do which showed up
...     against the natural background of generalized nastiness. There had been
...     times, over the past millennium, when he'd felt like sending a message
...     back Below saying, Look, we may as well give up right now, we might as
...     well shut down Dis and Pandemonium and everywhere and move up here,
...     there's nothing we can do to them that they don't do themselves and they
...     do things we've never even thought of, often involving electrodes.
...     They've got what we lack. They've got imagination. And electricity, of
...     course.
...     One of them had written it, hadn't he . . . \"Hell is empty, and all the
...     devils are here.\""
>>> write_file_with_string  on_empty_hell "${on_generalized_nastiness}"
>>> set_string_to_file_text on_short_lives on_empty_hell
>>> get_string_line "${on_short_lives}" -1
devils are here."
------------------------------------------
==========================================
/---
function set_string_to_file_text() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one string name and one filename.'
    string string_name="${1}" filename
    die_unless_variable_string "${string_name}"

    # Canonicalize such file. See get_file_text() for further details.
    set_string_to_path_canonical filename "${2}"
    die_unless_file_text "${filename}"

    # Set such string to such file's contents.
    run_code_with_mapfile ${string_name}'="${mapfile[${filename}]}"'
}

declare_function_with_stdin <<'/---'
void set_list_to_file_text_lines(string list_name, string filename)

Set the passed list to the contents of the passed text file split on newlines:
e.g.,

.set_list_to_file_text_lines()
==========================================
[source]
------------------------------------------
>>> string on_satanism=\
...    "Most of the members of the convent were old-fashioned Satanists, like
...     their parents and grandparents before them. They'd been brought up to
...     it and weren't, when you got right down to it, particularly evil. Human
...     beings mostly aren't. They just get carried away by new ideas, like
...     dressing up in jackboots and shooting people, or dressing up in white
...     sheets and lynching people, or dressing up in tie-dye jeans and playing
...     guitars at people. Offer people a new creed with a costume and their
...     hearts and minds will follow. Anyway, being brought up as a Satanist
...     tended to take the edge off it. It was something you did on Saturday
...     nights. And the rest of the time you simply got on with life as best you
...     could, just like everyone else."
>>> list on_creeds
>>> write_file_with_string on_costumes "${on_satanism}"
>>> set_list_to_file_text_lines on_creeds on_costumes
>>> print_string "${on_creeds[5]}"
dressing up in jackboots and shooting people, or dressing up in white
------------------------------------------
==========================================
/---
function set_list_to_file_text_lines() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one list name and one filename.'
    string list_name="${1}" filename
    die_unless_list "${list_name}"

    # Canonicalize such file. See get_file_text() for further details.
    set_string_to_path_canonical filename "${2}"
    die_unless_file_text "${filename}"

    # Split such file's contents on newline into such list. For efficiency,
    # inline such implementation. See set_list_to_string_split_on_newline() for
    # further details.
    run_code_with_mapfile ${list_name}'=( ${(z)mapfile[${filename}]} )'
}

# ....................{ SETTERS ~ dir                      }....................
declare_function_with_stdin <<'/---'
void set_list_to_dir_files_text(string list_name, string dirname)

Set the passed list to all text files directly in the passed directory.
/---
function set_list_to_dir_files_text() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one list name and one dirname.'
    string list_name__sltdft="${1}" dirname__sltdft="${2}"
    die_unless_list "${list_name__sltdft}"
    die_unless_dir "${dirname__sltdft}"

    # Set such list. For efficiency, manually implement the test for such glob
    # qualifier. See get_file_encoding() and is_file_binary() for further
    # details. Dismantled, this is:
    #
    # * "-", resolving symbolic links to their transitive targets.
    # * ".", excluding non-plain files.
    # * "e{...}", excluding all files for which such test evaluates to false
    #   (i.e., binary files).
    set_list_to_paths_globbed_matching_qualifier\
        "${list_name__sltdft}" "${dirname__sltdft}/*"\
        "-.e:'[[ \$(file --brief --mime-encoding '\${REPLY}') != binary ]]':"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_file_text(string filename1, string filename2, ...)

Print a human-readable synopsis of the contents of the passed text files.
/---
function print_file_text() {
    #FIXME: This only applies to an eventual print_file_text_with_options()
    #implementation and hence should be shifted there... when it exists.

    # If piped input, pass such input to "cat" and return.
    if { is_stdin_readable_sans_blocking } {
        die_if_args
        get_stdin | run_code_paged command cat
        return_true
    }

    # Validate passed arguments.
    die_unless_args 'Expected one or more filenames.'

    # When passed one file, "cat" output unambiguously corresponds to such
    # file. In such a case, "cat" suffices.
    if { is_arg } {
        run_code_paged command cat -- "${(q)@}"
    # When passed multiple files, "cat" fails to prepend the output from each
    # with the corresponding filename. (Fix this, scallywag "cat"!)
    } else {
        string filename
        for    filename ("${@}") {
            print_heading  "${filename}"
            command cat -- "${filename}"
        } | page_stdin
    }
}

#FIXME: Rename to print_path_line_count_recursive(), as the implementation
#below demonstrates.
declare_function_with_stdin <<'/---'
integer get_file_text_line_count_recursively(string path)

Get the total number of lines corresponding to the file(s) in the passed path,
as follows:

* If no path is passed, default to the current directory.
* If this path is a directory, recursively sum the number of lines for files
  in this path ignoring binary files.
* If this path is a file:
** And this file is a PDF, use `pdftotext` to sum the number of text lines in
   the rendered PDF.
** Else, sum the number of lines in this file.
/---
function get_file_text_line_count_recursively() {
    # Validate passed parameters.
    die_unless_args_0_to_1 'Expected optional pathname.'
    string find_path; file_path="${1:-$(get_dir)}"
    integer line_count

    if { is_dir "${find_path}" } {
        print_message_item_interactively\
            "Counting lines for all text files in \"${find_path}\"..."

        #FIXME: This is horrible. Replace dependency on "find" and "wc" with
        #pure homecooked zsh.
        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_file_text().
        line_count="$(find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_file_text_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }')"
    } elif { is_file "${find_path}" } {
        print_message_interactively "counting lines for \"${find_path}\"..."

        #FIXME: This is rather shoddy. Generalize to multiple filetypes and
        #functions handling such filetypes as for extract_archive().
        if { is_file_type "${find_path}" 'pdf' and is_pathable pdftotext } {
            line_count="$(pdftotext "${find_path}" - | wc -l)"
        } else {
            die_unless_file_file "${find_path}"
            line_count="$(wc -l "${find_path}")"
        }
    } else {
        die "\"${find_path}\" neither a file or directory."
    }

    # Print such count human-readably.
    convert_integer_to_string_localized "${line_count}"
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
void write_file_with_string(string filename, string text)

Overwrite the contents of the passed text file with the passed string if such
file exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function write_file_with_string() {
    # zeshy disables zsh option "clobber", thus requiring the ">!" operator to
    # force truncating the contents of the passed file if extant.
    die_unless_args_2 'Expected one string and one filename.'
    output_string "${2}" >!"${1}"
}

declare_function_with_stdin <<'/---'
void append_file_with_string(string filename, string text)

Append the passed string to the contents of the passed text file if such file
exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
/---
function append_file_with_string() {
    # zeshy disables zsh option "clobber", thus requiring the ">>!" operator to
    # force creating the passed file if non-extant.
    die_unless_args_2 'Expected one string and one filename.'
    output_string "${2}" >>!"${1}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to is_file_text_line_matches_pcre(). No, wait. Rename to
#is_file_text_matches_pcre_multiline() and correct all functions calling this
#function. *sigh*
# If such synopsis exceeds the height, this function pipes such to the current
# pager  or as is (i.e., without paging) otherwise.

#FUXME: If such file is a symbolic link to a text file, make this still work.
#All we have to do is canonicalize its path, as in get_file_text(). Make it so.

#   filename="$(canonicalize_path "${filename}")"
    # If such path is an existing nonfile and the canonical file to which such path
    # refers is *NOT* binary, return success; else, failure.

#Return success if the passed path is an existing text file _and_ is either a:
#
#* *Text file* (i.e., a non-binary file), as decided by dynamically inspecting
#  the contents of such file with `file`.
#* Symbolic link to a text file. Technically, symbolic links are binary files.
#  Subjectively, however, nearly all commands operating an text files accept
#  symbolic links to text files as text files. Hence, this function does the
#  same. If unacceptable, consider calling die_if_link_symbolic() before calling
#  this function.

    #FUXME: Uhm; we also need to encapsulate "< /dev/stdin" as get_stdin().
    #Easy, it's just yet another requirement.
        # Canonicalize such path, thus converting symbolic links in such path
        # into their transitive targets.
#This implements a pure-`zsh` analogue to the GNU-specific `grep --perl-regexp`.
#As the
#function name suggests, this function does _not_ interactively confirm such
#overwriting. Call this function only where guaranteed to be non-destructive.
    #FUXME: Convert to a run_code_with_options()-centric implementation. Or
#   string filename="${1}" text="${2}"
#FUXME: Rename write_file_with_string() to write_file_with_string_text().
#Naturally, reorder arguments as well and apply to appending below. Actually,
#drop the "_text"; obviously, the outcome is a text file. So, just:
#write_file_with_string(). This nicely coincides with other such functions as
#write_file_with_variable() on the one hand and print_string() on the other.
#Hence, "string" is the dominant object here. Hmm; come to think of it, why not
#print_string_to_file() and print_variable_to_script()? Ah; no. Write and read
#are much better file-oriented verbs here.
#
#tl;dr:
#Rename to write_file_with_string().

#FUXME: Rename to is_file_text_pcre_match_line() or perhaps
#is_file_text_match_line_pcre() or is_file_text_matches_line_pcre(). Ah; we're
#getting closer. We really want the "_line" adjacent to the "_text", however,
#which synchronizes much better with the conception of "line" as a discrete
#component. That then leaves us with is_file_text_matches_pcre_multiline() and a
#corresponding is_file_text_line_match() function. All good, yes? We should
#broadly apply similar fixes elsewhere to "_line" functions: particularly, to
#"variable/string/line".
#
#tl;dr:
#Rename to is_file_text_matches_pcre_multiline().

#FUXME: Rename to is_file_text_equals(), is_file_text_string(), or
#is_file_text_equals(). Hmm; the latter, possibly? This suggests a similar
#is_string_equals(), which makes perfect sense, permitting an implementation
#here resembling:
#       get_file_text "${pathname}" | is_string_equals "${text}"
#       is "$(get_file_text "${pathname}")" == "${text}" si
#Nice!
# or is_file_text_contains(). Yes... yes? Come to think,
#I now prefer (I know, I know...) verbs "equals" and "contains" for such matches
#and nouns "prefix" and "suffix" for such matches. Apply elsewhere, yes?
#run_code_with_stdin_piped
#FUXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_code_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FUXME: It'd be nice to abstract out the load_module/freeze_variable/unload_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load zsh module "mapfile".
#   load_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_module zsh/mapfile
#FUXME: Should be renamed to, say, "get_find_command_file_text_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# boolean is_file_text_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_file_text_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
