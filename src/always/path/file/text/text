#!/usr/bin/env zsh
# ====================[ text                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle text (i.e., non-binary) files.

#FIXME: When printing text files to a terminal, perform syntax highlighting of
#source files. Calling get_file_mimetype() should efficiently suffice to decide
#this. There exist any number of source code highlighters; the three most
#popular as of this date are:
#
#* GNU source-highlighter (https://www.gnu.org/software/src-highlite).
#* Highlight (http://www.andre-simon.de/doku/highlight/en/langs.html).
#* Pygments (http://pygments.org/languages).
#
#Ideally, I'd like to default to Pygments if available. In practice, we should
#probably default to the highlighter that provides a command line option for
#either listing supported languages and/or filetypes *OR* for testing whether it
#supports the passed file(s).
#
#Happily, a helpful blog post has already been authored on how to robustly
#replace "cat" and "less" with zsh-specific Pygmentized versions. See:
#    http://www.jonathangross.de/2012/08/13/adding-a-little-color-to-your-command-line-life

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_file_text(
    string filename,
    string error_message = "\"${filename}\" not a text file")

Throw an exception with the passed message unless the passed text file exists.
See is_file_text() for further details.
________________<heredoc?>________________
function die_unless_file_text() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string filename="${1}"
    is_file_text "${filename}" or die "${2:-\"${filename}\" not a text file}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_files(string filename1, string filename2, ...)

Throw an exception with a stock message unless all passed text files exist.
________________<heredoc?>________________
function die_unless_files_text() {
    die_unless_args 'expected at least one filename'
    for filename ("${@}") die_unless_file_text "${filename}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_file_text(string pathname)

Return success if the passed path is a *text file* (i.e., a non-binary file, as
dynamically inspected by `file`).
________________<heredoc?>________________
function is_file_text() {
    die_unless_arg 'expected one pathname'
    string pathname="${1}"
    is_file "${pathname}" and not is_file_binary "${1}"
}

# ....................{ TESTERS ~ text                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_file_text_equals(string filename, string text)

Return success if the passed text file contains only the passed text.
________________<heredoc?>________________
function is_file_text_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one string'
    string filename="${1}" text="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_equals "$(get_file_text "${pathname}")" "${text}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_file_text_contains(string filename, string text)

Return success if the passed text file contains the passed text.
________________<heredoc?>________________
function is_file_text_contains() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one string'
    string filename="${1}" substring="${2}"
    die_unless_file_text "${filename}"

    # Test such text.
    is_string_contains "$(get_file_text "${pathname}")" "${substring}"
}

#FIXME: Rename to is_file_text_line_matches_pcre(). No, wait. Rename to
#is_file_text_matches_pcre_multiline() and correct all functions calling this
#function. *sigh*
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_file_text_line_match_pcre(
    string filename, string pcre)

Return success if the passed text file matches the passed PCRE with multiline
matching enabled.
________________<heredoc?>________________
function is_file_text_line_match_pcre() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one PCRE'
    string filename="${1}" pcre="${2}"
    die_unless_file_text "${filename}"

    # Test such PCRE.
    is_string_line_matches_pcre "$(get_file_text "${pathname}")" "${pcre}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_file_text(string filename)

Get the contents of the passed text file.
________________<heredoc?>________________
function get_file_text() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file_text "${filename}"

    #FIXME: Actually, we should probably benchmark this for sufficiently large
    #files. "mapfile" should be the fastest, but "cat" probably gives it a run
    #for its money.

    # Get such text. While precompiled zsh module "mapfile" provides the most
    # efficient access to such text, recall the following techniques to also
    # suffice:
    #
    #     cat -- "${filename}"
    #     output_string "$(< "${filename}")"
    #
    # For efficiency, avoid string copies and hence extraneous function calls.
    # See run_command_with_mapfile() for further details.
    load_module_mapfile
    {
        output_string "${mapfile[${filename}]}"
    } always {
        unload_module_mapfile
    }
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_file_text_line_count(
    string filename1, string filename2, ...)

Get the total number of lines in the passed text files.
________________<heredoc?>________________
function get_file_text_line_count() {
    die_unless_args 'expected at least one filename'
    wc -l -- "${@}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_file_text_word_count(
    string filename1, string filename2, ...)

Get the total number of words in the passed text files.
________________<heredoc?>________________
function get_file_text_word_count() {
    die_unless_args 'expected at least one filename'
    wc -w -- "${@}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_file_text_lines(string list_name, string filename)

Set the passed list to the contents of the passed text file split on newlines.
________________<heredoc?>________________
function set_list_to_file_text_lines() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one filename'
    string list_name="${1}" filename="${2}"
    die_unless_list "${list_name}"
    die_unless_file_text "${filename}"

    # Set such list.
    run_command_with_mapfile "${list_name}=( \${(z)mapfile[${filename}]} )"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_file_text(string filename1, string filename2, ...)

Print the contents of the passed text files piped to the current pager if such
output exceeds the terminal height or as is (i.e., without paging) otherwise.
________________<heredoc?>________________
function print_file_text() {
    #FIXME: This only applies to an eventual print_file_text_with_options()
    #implementation and hence should be shifted there... when it exists.
    #FIXME: Uhm; we also need to implement get_stdin(). Easy, it's just... yet
    #another requirement.
    # If piped input, pass such input to "cat" and return.
    is_stdin and {
        die_if_args
        get_stdin | run_command_paged command cat
        return_true
    }

    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # When passed one file, "cat" output unambiguously corresponds to such
    # file. In such a case, "cat" suffices.
    if { is_arg } {
        run_command_paged command cat -- "${(q)@}"
    # When passed multiple files, "cat" fails to prepend the output from each
    # with the corresponding filename. (Fix this, scallywag "cat"!)
    } else {
        for filename ("${@}") {
            print_heading "${filename}"
            command cat -- "${filename}"
        } | page_stdin
    }
}

#FIXME: Rename to print_path_line_count_recursively(), as the implementation
#below demonstrates.
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_file_text_line_count_recursively(string path)

Get the total number of lines corresponding to the file(s) in the passed path,
as follows:

* If no path is passed, default to the current directory.
* If this path is a directory, recursively sum the number of lines for files
  in this path ignoring binary files.
* If this path is a file:
** And this file is a PDF, use `pdftotext` to sum the number of text lines in
   the rendered PDF.
** Else, sum the number of lines in this file.
________________<heredoc?>________________
function get_file_text_line_count_recursively() {
    # Validate passed parameters.
    die_unless_args_0_to_1 'expected optional pathname'
    string find_path; file_path="${1:-$(get_dir)}"
    integer line_count

    if { is_dir "${find_path}" } then
        print_message "counting lines for all text files in \"${find_path}\"..."

        #FIXME: This is horrible. Replace dependency on "find" and "wc" with
        #pure homecooked zsh.
        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_file_text().
        line_count="$(find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_file_text_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }')"
    elif { is_file "${find_path}" }
        print_message "counting lines for \"${find_path}\"..."

        #FIXME: This is rather shoddy. Generalize to multiple filetypes and
        #functions handling such filetypes as for extract_archive().
        if is "$(get_file_type "${find_path}")" == pdf si {
            line_count="$(pdftotext "${find_path}" - | wc -l)"
        } else {
            die_unless_file_file "${find_path}"
            line_count="$(wc -l "${find_path}")"
        }
    else {
        die "\"${find_path}\" neither a file or directory"
    }

    # Print such count human-readably.
    convert_integer_to_string_localized "${line_count}"
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void write_file_with_string(string filename, string text)

Overwrite the contents of the passed text file with the passed string if such
file exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
________________<heredoc?>________________
function write_file_with_string() {
    # zeshy disables zsh option "clobber", thus requiring the ">!" operator to
    # force truncating the contents of the passed file if extant.
    die_unless_args_2 'expected one string and one filename'
    output_string "${2}" >!"${1}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void append_file_with_string(string filename, string text)

Append the passed string to the contents of the passed text file if such file
exists or create a new file containing such string otherwise. Since this
function does _not_ interactively confirm such append, call this function only
where guaranteed to be non-destructive.
________________<heredoc?>________________
function append_file_with_string() {
    # zeshy disables zsh option "clobber", thus requiring the ">>!" operator to
    # force creating the passed file if non-extant.
    die_unless_args_2 'expected one string and one filename'
    output_string "${2}" >>!"${1}"
}

# --------------------( WASTELANDS                         )--------------------
#This implements a pure-`zsh` analogue to the GNU-specific `grep --perl-regexp`.
#As the
#function name suggests, this function does _not_ interactively confirm such
#overwriting. Call this function only where guaranteed to be non-destructive.
    #FUXME: Convert to a run_command_with_options()-centric implementation. Or
#   string filename="${1}" text="${2}"
#FUXME: Rename write_file_with_string() to write_file_with_string_text().
#Naturally, reorder arguments as well and apply to appending below. Actually,
#drop the "_text"; obviously, the outcome is a text file. So, just:
#write_file_with_string(). This nicely coincides with other such functions as
#write_file_with_variable() on the one hand and print_string() on the other.
#Hence, "string" is the dominant object here. Hmm; come to think of it, why not
#print_string_to_file() and print_variable_to_script()? Ah; no. Write and read
#are much better file-oriented verbs here.
#
#tl;dr:
#Rename to write_file_with_string().

#FUXME: Rename to is_file_text_match_pcre_line() or perhaps
#is_file_text_match_line_pcre() or is_file_text_matches_line_pcre(). Ah; we're
#getting closer. We really want the "_line" adjacent to the "_text", however,
#which synchronizes much better with the conception of "line" as a discrete
#component. That then leaves us with is_file_text_line_match_pcre() and a
#corresponding is_file_text_line_match() function. All good, yes? We should
#broadly apply similar fixes elsewhere to "_line" functions: particularly, to
#"variable/string/line".
#
#tl;dr:
#Rename to is_file_text_line_match_pcre().

#FUXME: Rename to is_file_text_equals(), is_file_text_string(), or
#is_file_text_equals(). Hmm; the latter, possibly? This suggests a similar
#is_string_equals(), which makes perfect sense, permitting an implementation
#here resembling:
#       get_file_text "${pathname}" | is_string_equals "${text}"
#       is "$(get_file_text "${pathname}")" == "${text}" si
#Nice!
# or is_file_text_contains(). Yes... yes? Come to think,
#I now prefer (I know, I know...) verbs "equals" and "contains" for such matches
#and nouns "prefix" and "suffix" for such matches. Apply elsewhere, yes?
#run_command_with_stdin_piped
#FUXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_command_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FUXME: It'd be nice to abstract out the load_module/freeze_variable/unload_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load zsh module "mapfile".
#   load_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_module zsh/mapfile
#FUXME: Should be renamed to, say, "get_find_command_file_text_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# boolean is_file_text_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_file_text_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
