#!/usr/bin/env zsh
# ====================[ text                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle text (i.e., non-binary) file content.

# ....................{ ALIASES                            }....................
interactive_substitution cat='print_text_file'
interactive_abbreviation {w}ord{c}ount{l}ine{r}ecursive="get_text_file_line_count_recursively"

# ....................{ EXCEPTIONS                         }....................
# void die_unless_text_file(
#   string filename,
#   string error_message = "\"${filename}\" not a text file")
#
# Throw an exception unless the passed file is an existing text file.
function die_unless_text_file() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string filename="${1}"
    is_text_file "${filename}" or die "${2:-\"${filename}\" not a text file}"
}

# ....................{ TESTERS                            }....................
# boolean is_text_file(string pathname)
#
# Return true if the passed path is a text (i.e., non-binary) file.
function is_text_file() {
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}"
    is_file "${pathname}" and not is_binary_file "${1}"
}

# boolean is_text_file_content(string pathname, string text)
#
# Return true if the passed text file contains exactly the passed text.
function is_text_file_content() {
    die_unless_two_args 'expected one pathname and one string'
    string pathname="${1}" text="${2}"
    is_text_file "${pathname}" and
        is "$(get_text_file_contents "${pathname}")" == "${text}" si
}

# boolean is_text_file_containing(string pathname, string text)
#
# Return true if the passed text file contains the passed text.
function is_text_file_containing() {
    die_unless_two_args 'expected one pathname and one string'
    string pathname="${1}" text="${2}"
    is_text_file "${pathname}" and
        is "$(get_text_file_contents "${pathname}")" == *"${text}"* si
}

# boolean is_text_file_pcre_line_match(
#   string pathname, string pcre, string pcre_arg1, string pcre_arg2, ...)
#
# Return true if the passed text file contains a line matching the passed PCRE
# under option "-m" for multiline matching and the additional passed options.
# This function implements a pure-Zsh analogue to "grep --perl-regexp".
function is_text_file_pcre_line_match() {
    # Validate passed arguments.
    die_unless_two_or_three_args\
        'expected one pathname, one regex, and optional regex options'
    string pathname="${1}"

    # If such path is an existing text file, perform such match.
    is_text_file "${pathname}" and {
        shift_one_arg
        is_string_pcre_line_match\
            "$(get_text_file_contents "${pathname}")" "${@}"
    }
}

# ....................{ GETTERS                            }....................
# string get_text_file_contents(string filename)
#
# Get the contents of the passed text file.
function get_text_file_contents() {
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_text_file "${filename}"
    run_with_mapfile "output \${mapfile[${filename}]}"
}

# ....................{ GETTERS ~ lines                    }....................
#FIXME: Silly. Completely replace with a new get_text_file_lines() function
#returning the passed range. See "shell/shell" for further comments. Oh, and
#this should be calling get_text_file_contents().

# string get_text_file_first_line(string filename)
#
# Get the first line of the passed text file.
function get_text_file_first_line() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_text_file "${filename}"

    # Grep. See run_with_mapfile() for mapfile discussion.
    load_zsh_module zsh/mapfile
    list lines; lines=( ${(f)mapfile[${filename}]} )
    output ${lines[1]}
    unload_zsh_module zsh/mapfile
#   eval "list lines; lines=( oeu oeu); print -l -- \${lines[@]}"
#   run_with_mapfile "list lines;
#       lines=( \${(f)mapfile[${filename}]} );
#       output \${lines[1]}"
}

# integer get_text_file_line_count_recursively(string path)
#
# Get the total number of lines corresponding to the file(s) in the passed path,
# as follows:
#
# * If no path is passed, default to the current directory.
# * If this path is a directory, recursively sum the number of lines for files
#   in this path ignoring binary files.
# * If this path is a file:
#   * And this file is a PDF, use "pdftotext" to sum the number of text lines in
#     the rendered PDF.
#   * Otherwise, sum the number of lines in this file.
function get_text_files_total_line_count_recursively() {
    # Validate passed parameters.
    die_unless_no_or_one_arg 'expected optional pathname'
    string find_path; file_path="${1:-$(get_current_dir)}"

    if is_dir "${find_path}"; then
        say "counting lines for all text files in \"${find_path}\"..."

        #FIXME: This is horrible. Replace dependency on "find" and "wc" with
        #pure homecooked Zsh.
        # Recursively find all files *NOT*:
        #
        # * Non-files (e.g., directories, device files).
        # * Dotfiles and dot directories (e.g., ".cvs/", ".git/", ".svn/").
        # * Binary files. We borrow this expression from is_text_file().
        find "${find_path}"\
            -type d -iname '*test*' -prune -o\
            -type f \( ! -regex '.*/\..*' \)\
            $(is_text_file_find_compatible)\
            -exec wc -l {} \; |\
            awk '{ total += \$1 } END { print total }' |\
            convert_string_integer_to_comma_separated_string
    elif is_file "${find_path}"; then
        say "counting lines for \"${find_path}\"..."

        if is "$(get_filetype "${find_path}")" == pdf si
        then pdftotext "${find_path}" - | wc -l | comma_separate_integer
        else
            die_unless_file_file "${find_path}"
            wc -l "${find_path}" | comma_separate_integer
        fi
    else die "\"${find_path}\" neither a file or directory"
    fi
}

# ....................{ PRINTERS                           }....................
# string print_text_file(string filename1, string filename2, ...)
#
# Print the contents of the passed text files piped to the current pager if such
# output exceeds the terminal height or as is (i.e., without paging) otherwise.
function print_text_file() {
    if is_piped_input; then
        die_if_args
        run_paged command cat
    else
        die_unless_args 'expected at least one filename'

        # When passed one file, "cat" output unambiguously corresponds to such
        # file. In such a case, "cat" suffices.
        if is_one_arg
        then run_paged command cat -- "${@}"
        # When passed multiple files, "cat" fails to prepend the output from
        # each with the corresponding filename. Correct this, scallywag "cat"!
        else
            {
                # Print the first passed file.
                say_first_section "${1}"
                command cat -- "${1}"
                shift_one_arg

                # Print all other passed files.
                for filename ("${@}") {
                    say_next_section "${filename}"
                    command cat -- "${filename}"
                }
            } | output_paged
        fi
    fi
}

# ....................{ WRITERS                            }....................
#FIXME: Rename overwrite_text_file_with() to write_text_file_with().
# void overwrite_text_file_with(string filename, string text)
#
# Overwrite the contents of the passed text file with the passed string. As the
# function name suggests, this function does *NOT* interactively confirm such
# overwriting. Call this function only where guaranteed to be non-destructive.
function overwrite_text_file_with() {
    # Validate passed arguments.
    die_unless_two_args 'expected one string and one filename'
    string filename="${1}" text="${2}"

    # Zeshy disables Zsh option "clobber", thus requiring the ">!" operator to
    # force truncating the contents of the passed file if extant.
    output "${text}" >! "${filename}"
}

# void append_text_file_with(string filename, string text)
#
# Append the passed string to the contents of the passed text file. As under
# overwrite_text_file_with(), this function does *NOT* interactively confirm.
function append_text_file_with() {
    # Validate passed arguments.
    die_unless_two_args 'expected one string and one filename'
    string filename="${1}" text="${2}"

    # Zeshy disables Zsh option "clobber", thus requiring the ">>!" operator to
    # force creating the passed file if non-extant.
    output "${text}" >>! "${filename}"
}

# --------------------( WASTELANDS                         )--------------------
#run_with_piped_input
#FIXME: This probably isn't behaving as intended. It *SHOULD* be printing
    #file contents to stderr while concatenating together file contents. In
    #practice, it probably just exhumes an error. Hurk!
#   string output
#   for filename ("${@}") {
#       output+="$(< "${filename}" 1>&1 1>&2)"
#   }
    # Test under the "mapfile" module for efficiency.
#   load_mapfile
#   is ${mapfile[${filename}]} == *"${text}"* si
#   unload_mapfile
#   run_with_mapfile "is \${mapfile[${filename}]} == *""${text}""* si"

#FIXME: It'd be nice to abstract out the load_zsh_module/freeze_variable/unload_zsh_module
#cruft into a helper function -- say, with_mapfile(): e.g.,
#
#    with_mapfile 'print ${${(f)mapfile[${filename}]}[1]}'

    # Load Zsh module "mapfile".
#   load_zsh_module zsh/mapfile

    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Print the first line of the file with the passed filename.
#   print ${${(f)mapfile[${filename}]}[1]}

    # Unload "mapfile", for safety.
#   unload_zsh_module zsh/mapfile
#FIXME: Should be renamed to, say, "get_find_command_text_file_filter()", and
#consequently moved -- ideally, into a new "zeshy/file/find".
# boolean is_text_file_find_compatible(void)
#
# Return a string which, when passed as argument to a "find" process, filters
# the currently visited filename if the corresponding file is binary. "find"
# itself provides no built-in means of performing such filtering, unfortunately.
#is_text_file_find_compatible() {
#    print "\-exec sh -c 'file --mime-encoding {} | grep --invert-match --quiet \": binary$\"' \\\;"
#}
