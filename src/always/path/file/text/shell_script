#!/usr/bin/env zsh
# ====================[ shell_script                       ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle shell scripts, executable text files implemented in some shell
# scripting language (e.g., Zeshy, Zsh, Bash, Bourne).

# ....................{ EXCEPTIONS                         }....................
# string die_unless_shell_script(
#   string pathname,
#   string error_message = "\"${pathname}\" not a shell script")
#
# Throw an exception unless the passed path exists and is a script.
function die_unless_shell_script() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_shell_script "${pathname}" or
        die "${2:-\"${pathname}\" not a shell script}"
}

# ....................{ TESTERS                            }....................
# boolean is_shell_script(string pathname)
#
# Return true if the passed path exists and is a shell script.
function is_shell_script() {
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}"
    is_text_file "${pathname}" and
        run_quietly get_shell_script_shebang_command_if_found "${pathname}"
}

# ....................{ GETTERS                            }....................
# string get_shell_script_shebang_command_if_found(string filename)
#
# Get the first line excluding prefixing "#!" of the passed shell script if such
# line is prefixed with "#!" or return false: e.g.,
#
#     >>> get_shell_script_shebang_command_if_found '/etc/zsh/zshrc'
#     /usr/bin/env zsh
function get_shell_script_shebang_command_if_found() {
    # Validate passed arguments. Avoid calling die_unless_shell_script(), which
    # transitively calls this function.
    die_unless_one_arg 'expected one pathname'
    string filename="${1}" shebang_line
    die_unless_text_file "${filename}"

    # Get such command or fail trying.
    if run_with_mapfile "shebang_line=\"\$(get_string_match_if_found\
        \"\${mapfile[\${filename}]}\"\
        '(#s)\#!([^${ZESHY_CHARACTER_NEWLINE}]#)*')\""
    then output "${shebang_line}"
    else return_false
    fi
}

# --------------------( WASTELANDS                         )--------------------
    #FIXME: Replace with single call to run_with_mapfile().
#   if shebang_line="$(get_string_match_if_found\
#       "${mapfile[${pathname}]}"\
#       "([^${ZESHY_CHARACTER_NEWLINE}]#)")"
#   if run_with_mapfile "shebang_line=\"\$(get_string_match_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '[#]!([^${ZESHY_CHARACTER_NEWLINE}]#)')\""
#       '\#!([^$'\n']#)')\""
#   then output "${shebang_line}"
#   else return_false
#   fi
#   run_with_mapfile "get_string_match_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '[#]!([^${ZESHY_CHARACTER_NEWLINE}]#)'"
#   load_mapfile
#   get_string_match_if_found\
#       "${mapfile[${filename}]}" "(#s)\#!([^${ZESHY_CHARACTER_NEWLINE}]#)*"
#   unload_mapfile
#   list lines; set_list_to_text_file_lines lines "${pathname}"
#   if is_string_prefix "${lines[1]}" '#!'
#   then output "${lines[1]}"
#   else return_false
#   fi

    # Technically, we could implement this with pure-Zsh.
