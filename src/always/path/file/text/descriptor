#!/usr/bin/env zsh
# ====================[ descriptor                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file descriptors (i.e., nonnegative integers signifying open files
# dynamically allocated device files under "/dev/fd").

# ....................{ EXCEPTIONS                         }....................
# string die_unless_file_descriptor(
#   string integer_name,
#   string error_message = "\"${integer_name}\" not a file descriptor")
#
# Throw an exception unless a file descriptor is allocated the passed integer.
function die_unless_file_descriptor() {
    die_unless_args_1_to_2\
        'expected one integer name and optional error message'
    string integer_name="${1}"
    is_file_descriptor "${integer_name}" or
        die "${2:-\"${integer_name}\" not a file descriptor}"
}

# string die_unless_file_descriptor_writable(
#   string integer_name,
#   string error_message = \"${integer_name}\" not a writable file descriptor")
#
# Throw an exception unless the passed file descriptor exists and is writable.
function die_unless_file_descriptor_writable() {
    die_unless_args_1_to_2\
        'expected one integer name and optional error message'
    string integer_name="${1}"
    is_file_descriptor_writable "${integer_name}" or
        die "${2:-\"${integer_name}\" not a writable file descriptor}"
}

# ....................{ TESTERS                            }....................
# boolean is_file_descriptor(string integer_name)
#
# Return true if the passed file descriptor exists (i.e., is currently allocated
# the passed integer and hence open for reading and/or writing).
function is_file_descriptor() {
    die_unless_arg 'expected one integer name'
    string integer_name="${1}"
    is_integer_nonnegative "${integer_name}" and
        is_path "$(get_file_descriptor_device "${integer_name}")"
}

# boolean is_file_descriptor_readable(string integer_name)
#
# Return true if the passed file descriptor exists and is readable.
function is_file_descriptor_readable() {
    die_unless_arg 'expected one integer name'
    string integer_name="${1}"
    is_integer_nonnegative "${integer_name}" and
        is_path_readable "$(get_file_descriptor_device "${integer_name}")"
}

# boolean is_file_descriptor_writable(string integer_name)
#
# Return true if the passed file descriptor exists and is writable.
function is_file_descriptor_writable() {
    die_unless_arg 'expected one integer name'
    string integer_name="${1}"
    is_integer_nonnegative "${integer_name}" and
        is_path_writable "$(get_file_descriptor_device "${integer_name}")"
}

# ....................{ GETTERS                            }....................
# string get_file_descriptor_file(string integer_name)
#
# Get the absolute path of the file accessed by the passed file descriptor.
function get_file_descriptor_file() {
    die_unless_arg 'expected one integer name'
    canonicalize_path "$(get_file_descriptor_device "${1}")"
}

# string get_file_descriptor_device(string integer_name)
#
# Get the absolute path of the device file allocated by the operating system to
# the passed file descriptor.
function get_file_descriptor_device() {
    # According to section "REDIRECTION" of "man zshmisc", Zsh cross-platform-
    # portably treats "/dev/fd/${file_descriptor}" as the underlying platform-
    # specific path. Hence, this should require no platform-specific munging.
    # Avoid calling die_unless_file_descriptor(), as that calls this function.
    die_unless_arg 'expected one integer name'
    string integer_name="${1}"
    die_unless_integer_nonnegative "${integer_name}"
    print_string "/dev/fd/${(P)integer_name}"
}

# ....................{ SETTERS                            }....................
# void set_integer_to_file_descriptor_writable(
#   string integer_name, string filename)
#
# Set the passed integer to a file descriptor writing to the passed file. Since
# file descriptors are shell specific, such integer applies only to the current
# shell. Hence, this functionality *CANNOT* be encapsulated in a getter function
# (e.g., "$(get_file_descriptor_writing_to_file black_koi "/yokan")"): e.g.,
#
#     >>> integer white_pony
#     >>> set_integer_to_file_descriptor_writable white_pony "/diamond/eyes"
#     >>> write_string_to_file_descriptor "koi no yokan" white_pony
#     >>> close_file_descriptor white_pony
#     >>> print_file_text "/diamond/eyes"
#     koi no yokan
function set_integer_to_file_descriptor_writable() {
    # Validate passed arguments.
    die_unless_args_2 'expected one integer name and one filename'
    string integer_name="${1}" filename="${2}"
    die_unless_integer "${integer_name}"

    # Allocate such file descriptor.
    eval "exec {${integer_name}}>'${filename}'"
}

# ....................{ WRITERS                            }....................
# void write_string_to_file_descriptor(
#   string text1, string text2, ..., string integer_name)
#
# Write the passed strings over the passed file descriptor, overwriting the
# file such descriptor refers to with such strings. See
# set_integer_to_file_descriptor_writable() for examples.
function write_string_to_file_descriptor() {
    # Validate passed arguments.
    die_unless_args_2 'expected at least one string and one integer name'
    string integer_name="${@[-1]}"
    die_unless_file_descriptor_writable "${integer_name}"
    pop_arg

    # Write such strings. Bizarrely, Zsh provides no corresponding ">>&"
    # operation. Instead, ">&" appends and *NO* operation writes. While
    # nonsensical, there's not terribly much we can do about it. So, we
    # stupidly fake it by silently removing the underlying file. *shrug*
    remove_file "$(get_file_descriptor_file "${integer_name}")"
    append_string_to_file_descriptor "${@}" "${integer_name}"
}

# void append_string_to_file_descriptor(
#   string text1, string text2, ..., integer file_descriptor)
#
# Append the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
function append_string_to_file_descriptor() {
    # Validate passed arguments.
    die_unless_args_2 'expected at least one string and one integer name'
    string integer_name="${@[-1]}"
    die_unless_file_descriptor_writable "${integer_name}"
    pop_arg

    # Append such strings. See write_string_to_file_descriptor() for discussion.
    print_string "${@}" >& ${(P)integer_name}
}

# ....................{ CLOSERS                            }....................
# void close_file_descriptor(string integer_name)
#
# Close the file descriptor previously allocated the passed integer. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
function close_file_descriptor() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer name'
    string integer_name="${1}"
    die_unless_file_descriptor "${integer_name}"

    # Close such file descriptor.
    eval "exec {${integer_name}}>&-"
}

# --------------------( WASTELANDS                         )--------------------
# void write_string_to_file_descriptor(
#   string text1, string text2, ..., integer file_descriptor)
#
# Write the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
#function write_string_to_file_descriptor() {
    # Validate passed arguments.
#    die_unless_args_2 'expected at least one string and one file descriptor'
#    string file_descriptor="${@[-1]}"
#    die_unless_file_descriptor_writable "${file_descriptor}"
#    pop_arg

    # Write such strings.
#}

#FIXME: Frankly, the whole reliance on integer names greatly and entirely
#unnecessarily complicates all functionality below. I don't see why we can't
#just dynamically assign passed string integers to actual integers in function
#implementations, if needed. For example:
#function get_file_descriptor_writing_to_file() {
    # Validate passed arguments.
#    die_unless_arg 'expected one one filename'
#    string filename="${1}"

    # Allocate such file descriptor.
#    integer file_descriptor
#    exec {file_descriptor}>"${filename}"
#    print_string "${file_descriptor}"
#}
