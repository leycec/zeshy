#!/usr/bin/env zsh
# ====================[ descriptor                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file descriptors (i.e., nonnegative integers signifying open files
# dynamically allocated device files under "/dev/fd").

# ....................{ EXCEPTIONS                         }....................
document_function '
string die_unless_file_descriptor(
  string integer_name,
  string error_message = "\"${integer_name}\" not a file descriptor")

Throw an exception unless a file descriptor is allocated the passed integer.
'
function die_unless_file_descriptor() {
    die_unless_args_1_to_2\
        'expected one integer name and optional error message'
    string integer_name__dufd="${1}"
    is_file_descriptor "${integer_name__dufd}" or
        die "${2:-\"${integer_name__dufd}\" not a file descriptor}"
}

document_function '
string die_unless_file_descriptor_writable(
  string integer_name,
  string error_message = \"${integer_name}\" not a writable file descriptor")

Throw an exception unless the passed file descriptor exists and is writable.
'
function die_unless_file_descriptor_writable() {
    die_unless_args_1_to_2\
        'expected one integer name and optional error message'
    string integer_name__dufdw="${1}"
    is_file_descriptor_writable "${integer_name__dufdw}" or
        die "${2:-\"${integer_name__dufdw}\" not a writable file descriptor}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_file_descriptor(string integer_name)

Return true if the passed file descriptor exists (i.e., is currently allocated
the passed integer and hence open for reading and/or writing).
'
function is_file_descriptor() {
    die_unless_arg 'expected one integer name'
    string integer_name__ifd="${1}"
    is_integer_nonnegative "${integer_name__ifd}" and
        is_path "$(get_file_descriptor_device "${integer_name__ifd}")"
}

document_function '
boolean is_file_descriptor_readable(string integer_name)

Return true if the passed file descriptor exists and is readable.
'
function is_file_descriptor_readable() {
    die_unless_arg 'expected one integer name'
    string integer_name__ifdr="${1}"
    is_integer_nonnegative "${integer_name__ifdr}" and
        is_path_readable "$(get_file_descriptor_device "${integer_name__ifdr}")"
}

document_function '
boolean is_file_descriptor_writable(string integer_name)

Return true if the passed file descriptor exists and is writable.
'
function is_file_descriptor_writable() {
    die_unless_arg 'expected one integer name'
    string integer_name__ifdw="${1}"
    is_integer_nonnegative "${integer_name__ifdw}" and
        is_path_writable "$(get_file_descriptor_device "${integer_name__ifdw}")"
}

# ....................{ GETTERS                            }....................
document_function '
string get_file_descriptor_file(string integer_name)

Get the absolute path of the file accessed by the passed file descriptor.
'
function get_file_descriptor_file() {
    die_unless_arg 'expected one integer name'
    canonicalize_path "$(get_file_descriptor_device "${1}")"
}

#FIXME: Rename to get_file_descriptor_file_device().
document_function '
string get_file_descriptor_device(string integer_name)

Get the absolute path of the device file allocated by the operating system to
the passed file descriptor.
'
function get_file_descriptor_device() {
    # According to section "REDIRECTION" of "man zshmisc", zsh cross-platform-
    # portably treats "/dev/fd/${file_descriptor}" as the underlying platform-
    # specific path. Hence, this should require no platform-specific munging.
    # Avoid calling die_unless_file_descriptor(), as that calls this function.
    die_unless_arg 'expected one integer name'
    string integer_name__gfdfd="${1}"
    die_unless_integer_nonnegative "${integer_name__gfdfd}"

    # Get such path.
    print_string "/dev/fd/${(P)integer_name__gfdfd}"
}

# ....................{ SETTERS                            }....................
#FIXME: Implement a corresponding set_integer_to_file_descriptor() function.
document_function '
void set_integer_to_file_descriptor_writable(
  string integer_name, string filename)

Set the passed integer to a file descriptor writing to the passed file. Since
file descriptors are shell specific, such integer applies only to the current
shell. Hence, this functionality *CANNOT* be encapsulated in a getter function
(e.g., "$(get_file_descriptor_writing_to_file black_koi "/yokan")"): e.g.,

    >>> integer white_pony
    >>> set_integer_to_file_descriptor_writable white_pony "/diamond/eyes"
    >>> write_file_with_string_descriptor "koi no yokan" white_pony
    >>> close_file_descriptor white_pony
    >>> print_file_text "/diamond/eyes"
    koi no yokan
'
function set_integer_to_file_descriptor_writable() {
    # Validate passed arguments.
    die_unless_args_2 'expected one integer name and one filename'
    string integer_name__sitfdw="${1}" filename__sitfdw="${2}"
    die_unless_variable_integer "${integer_name__sitfdw}"

    # Allocate such file descriptor.
    eval "exec {${integer_name__sitfdw}}>'${filename__sitfdw}'"
}

# ....................{ WRITERS                            }....................
#FIXME: Rename to write_file_descriptor_with_string() and reorder passed
#arguments appropriately.
document_function '
void write_file_with_string_descriptor(
  string text1, string text2, ..., string integer_name)

Write the passed strings over the passed file descriptor, overwriting the
file such descriptor refers to with such strings. See
set_integer_to_file_descriptor_writable() for examples.
'
function write_file_with_string_descriptor() {
    # Validate passed arguments.
    die_unless_args_2 'expected at least one string and one integer name'
    string integer_name__wfdws="${@[-1]}"
    die_unless_file_descriptor_writable "${integer_name__wfdws}"
    pop_arg

    # Write such strings. Bizarrely, zsh provides no corresponding ">>&"
    # operation. Instead, ">&" appends and *NO* operation writes. While
    # nonsensical, there's not terribly much we can do about it. So, we
    # stupidly fake it by silently removing the underlying file. *shrug*
    remove_file "$(get_file_descriptor_file "${integer_name__wfdws}")"
    append_file_with_string_descriptor "${@}" "${integer_name__wfdws}"
}

#FIXME: Rename to append_file_descriptor_with_string() and reorder passed
#arguments appropriately.
document_function '
void append_file_with_string_descriptor(
  string text1, string text2, ..., integer file_descriptor)

Append the passed strings to the passed file descriptor. See
set_integer_to_file_descriptor_writing_to_file() for examples.
'
function append_file_with_string_descriptor() {
    # Validate passed arguments.
    die_unless_args_2 'expected at least one string and one integer name'
    string integer_name__afdws="${@[-1]}"
    die_unless_file_descriptor_writable "${integer_name__afdws}"
    pop_arg

    # Append such strings. See write_file_with_string_descriptor() for discussion.
    print_string "${@}" >& ${(P)integer_name__afdws}
}

# ....................{ CLOSERS                            }....................
document_function '
void close_file_descriptor(string integer_name)

Close the file descriptor previously allocated the passed integer. See
set_integer_to_file_descriptor_writing_to_file() for examples.
'
function close_file_descriptor() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer name'
    string integer_name="${1}"
    die_unless_file_descriptor "${integer_name}"

    # Close such file descriptor.
    eval "exec {${integer_name}}>&-"
}

# --------------------( WASTELANDS                         )--------------------
# void write_file_with_string_descriptor(
#   string text1, string text2, ..., integer file_descriptor)
#
# Write the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
#function write_file_with_string_descriptor() {
    # Validate passed arguments.
#    die_unless_args_2 'expected at least one string and one file descriptor'
#    string file_descriptor="${@[-1]}"
#    die_unless_file_descriptor_writable "${file_descriptor}"
#    pop_arg

    # Write such strings.
#}

#FIXME: Frankly, the whole reliance on integer names greatly and entirely
#unnecessarily complicates all functionality below. I don't see why we can't
#just dynamically assign passed string integers to actual integers in function
#implementations, if needed. For example:
#function get_file_descriptor_writing_to_file() {
    # Validate passed arguments.
#    die_unless_arg 'expected one one filename'
#    string filename="${1}"

    # Allocate such file descriptor.
#    integer file_descriptor
#    exec {file_descriptor}>"${filename}"
#    print_string "${file_descriptor}"
#}
