#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *filetypes* (i.e., `.`-prefixed filename suffixes).
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_type_equals:(
    string pathname,
    string filetype,
    string error_message = "\"${pathname}\" not of filetype \"${filetype}\".")

Throw an exception with the passed message unless the passed filename has the
passed filetype. See is_file_type_equals:() for further details.
/---
function die_unless_file_type_equals:() {
    die_unless_args_2_to_3\
        'Expected one pathname, one filetype, and optional error message.'
    string pathname="${1}" filetype="${2}"
    is_file_type_equals: "${pathname}" "${filetype}" or die\
        "${3-\"${pathname}\" not of filetype \"${filetype}\".}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_file_type_equals:(string filename, string filetype)

Report success if the passed filename has the passed filetype: e.g.,

.is_file_type_equals:()
==========================================
[source]
------------------------------------------
>>> string on_status_quos=\
...    "At issue is not whether the global economy will pass away. It is
...     passing away. Rising populations and debt combined with depletion of
...     freshwater sources and fossil fuel make the status quo untenable. The
...     only question is whether civil society will survive the transition. Can
...     we use the darknet to preserve representative democracy, or will we seek
...     protection from brutal strong-men as the old order begins to fail?"
>>> is_file_type_equals: "saverin.in" "out" or get_string_line "${on_status_quos}" -1
protection from brutal strong-men as the old order begins to fail?
------------------------------------------
==========================================
/---
function is_file_type_equals:() {
    # Validate sanity.
    die_unless_args_2 'Expected one filename and one filetype.'
    string filename="${1}" filetype_test="${2}" filetype_true

    # Test such filetype.
    filetype_true="$(get_file_type_if_found "${filename}")" and
        is "${filetype_test}" == "${filetype_true}" si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_file_type(string filename)

Get the filetype of the passed filename or throw an exception if such filename
has no filetype. For filenames suffixed by two-part `tar` designators, the
filetype is `tar.` followed by the rightmost period-delimited suffix; else,
filetype is the merely the rightmost period-delimited suffix: e.g.,

.get_file_type()
==========================================
[source]
------------------------------------------
>>> get_file_type "hastur.tar.gz"
tar.gz
>>> get_file_type "pasteur.ar.gz"
gz
------------------------------------------
==========================================
/---
function get_file_type() {
    # Validate sanity.
    die_unless_arg 'Expected one filename.'
    string filename="${1}"

    # Get such file type if found or throw an exception.
    get_file_type_if_found "${filename}" or
        die "\"${filename}\" has no filetype."
}

declare_function_with_stdin <<'/---'
[stdout: string, status: bool] get_file_type_if_found(string filename)

Get the filetype of the passed filename or return failure if such filename has
no filetype. See get_file_type() for further details: e.g.,

.get_file_type_if_found()
==========================================
[source]
------------------------------------------
>>> get_file_type_if_found "a_thing_of_beauty" or print_string "is a joy"
is a joy
------------------------------------------
==========================================
/---
function get_file_type_if_found() {
    # Validate sanity.
    die_unless_arg 'Expected one filename.'
    string filename="${1}"

    # Match the passed filename's filetype, discarding leading ".".
    is "$(get_path_basename "${filename}")" == *'.'(#b)(('tar.')|)[^.]## si and
        output_string "${match[1]}"
}

# ....................{ GETTERS ~ path                     }....................
#FIXME: Rename to get_path_sans_file_type:().
declare_function_with_stdin <<'/---'
string get_path_sans_file_type:(string pathname)

Get the passed pathname excluding `.`-prefixed filetype if such path is suffixed
by such type or such pathname ``as is'' otherwise: e.g.,

.get_path_sans_file_type:()
==========================================
[source]
------------------------------------------
>>> get_path_sans_file_type: "/endymion/hastur.tar.gz"
/endymion/hastur
>>> get_path_sans_file_type: "/hyperion/azazoth"
/hyperion/azazoth
------------------------------------------
==========================================
/---
function get_path_sans_file_type:() {
    # Validate sanity.
    die_unless_arg 'Expected one pathname.'
    string pathname="${1}" filetype

    # If such pathname contains a filetype, remove such filetype. See
    # remove_string_suffix() for further details.
    if { filetype="$(get_file_type_if_found "${pathname}")" } {
        output_string "${pathname%.${filetype}}"
    # Else, return such pathname as is.
    } else {
        output_string "${pathname}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#. If such filename has no filetype,
#this is the filename itself

#   filetype="$(get_file_type_if_found "${filename}")" or
#       die "\"${filename}\" has no filetype"
#   return_string "${filetype}"
#>>> is_file_type_equals: "saverin.in" "out" or print_string "Othello says, \"Hi.\""
#Othello says, "Hi."

#. Since this
#function tests only such filename, no such file need actually exist
#FUXME: Rename to get_path_sans_file_type:(). It makes little sense to speak of
#anything but files in regards to file types and, anyway, breaks nomenclature.
