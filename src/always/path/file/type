#!/usr/bin/env zsh
# ====================[ type                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle filetypes (i.e., "."-prefixed filename suffixes).

# ....................{ EXCEPTIONS                         }....................
declare_alias_with_stdin <<'________________<heredoc?>________________'
void die_unless_file_type(
    string pathname,
    string filetype,
    string error_message = "\"${pathname}\" not of filetype \"${filetype}\"")

Throw an exception with the passed message unless the passed filename has the
passed filetype.
________________<heredoc?>________________
function die_unless_file_type() {
    die_unless_args_2_to_3\
        'expected one pathname, one filetype, and optional error message'
    string pathname="${1}" filetype="${2}"
    is_file_type "${pathname}" "${filetype}" or
        die "${2:-\"${pathname}\" not of filetype \"${filetype}\"}"
}

# ....................{ TESTERS                            }....................
declare_alias_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_file_type(string filename, string filetype)

Return success if the passed filename has the passed filetype. Since this
function tests only such filename, no such file need actually exist: e.g.,

.is_file_type()
==========================================
[source]
------------------------------------------
>>> is_file_type "saverin.in" "out" or print_string "Othello says, \"Hi.\""
Othello says, "Hi."
------------------------------------------
==========================================
________________<heredoc?>________________
function is_file_type() {
    die_unless_args_2 'expected one filename and one filetype'
    string filename="${1}" filetype_test="${2}" filetype_true
    filetype_true="$(get_file_type_if_found "${filename}")" and
        is "${filetype_test}" == "${filetype_true}" si
}

#FIXME: Rename to is_file_type_glob_matches().
declare_alias_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_file_type_match(string filename, string glob)

Return success if the passed filename has a filetype matching the passed glob:
e.g.,

.is_file_type_match()
==========================================
[source]
------------------------------------------
>>> is_file_type_match "parker.out" "(in|to)" or print_string "Dionysus!"
Dionysus!
------------------------------------------
==========================================
________________<heredoc?>________________
function is_file_type_match() {
    die_unless_args_2 'expected one filename and one glob'
    string filename="${1}" filetype_glob="${2}" filetype
    filetype="$(get_file_type_if_found "${filename}")" and
        is_string_glob_matches "${filetype}" "${filetype_glob}"
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_file_sans_file_type(). It makes little sense to speak of
#anything but files in regards to file types and, anyway, breaks nomenclature.
declare_alias_with_stdin <<'________________<heredoc?>________________'
string get_path_sans_file_type(string filename)

Get the passed filename excluding filetype. If such filename has no filetype,
this is the filename itself: e.g.,

.get_path_sans_file_type()
==========================================
[source]
------------------------------------------
>>> get_path_sans_file_type "/endymion/hastur.tar.gz"
/endymion/hastur
>>> get_path_sans_file_type "/hyperion/azazoth"
/hyperion/azazoth
------------------------------------------
==========================================
________________<heredoc?>________________
function get_path_sans_file_type() {
    die_unless_arg 'expected one filename'
    string filetype; filetype="$(get_file_type_if_found "${1}")" or true
    print_string "${1%.${filetype}}"
}

# ....................{ GETTERS ~ type                     }....................
declare_alias_with_stdin <<'________________<heredoc?>________________'
string get_file_type(string filename)

Get the filetype of the passed filename or throw an exception if such filename
has no filetype. For filenames suffixed by two-part `tar` designators, the
filetype is `tar.` followed by the rightmost period-delimited suffix; else,
filetype is the merely the rightmost period-delimited suffix: e.g.,

.get_file_type()
==========================================
[source]
------------------------------------------
>>> get_file_type "hastur.tar.gz"
tar.gz
>>> get_file_type "pasteur.ar.gz"
gz
------------------------------------------
==========================================
________________<heredoc?>________________
function get_file_type() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}" filetype

    # Get such filetype.
    filetype="$(get_file_type_if_found "${filename}")" or
        die "\"${filename}\" has no filetype"
    return_string "${filetype}"
}

declare_alias_with_stdin <<'________________<heredoc?>________________'
[stdout: string, status: boolean] get_file_type_if_found(string filename)

Get the filetype of the passed filename or return failure if such filename has
no filetype. See get_file_type() for further details: e.g.,

.get_file_type_if_found()
==========================================
[source]
------------------------------------------
>>> get_file_type_if_found "a_thing_of_beauty" or print_string "is a joy"
is a joy
------------------------------------------
==========================================
________________<heredoc?>________________
function get_file_type_if_found() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"

    #FIXME: Convert to an equivalent glob.
    # Match the passed filename's filetype, discarding leading ".".
    is "$(get_path_basename "${filename}")" =~ '\.(tar\.)?[^.]+$' si or
        return_false
    remove_string_prefix "${MATCH}" '.'
}

#FIXME: Rename to get_file_type_if_glob_matches().
declare_alias_with_stdin <<'________________<heredoc?>________________'
string get_file_type_if_matching(string filename, string filetype_glob)

Get the filetype of the passed filename if such filetype matches the passed
glob or return failure. See get_file_type() for further details: e.g.,

.get_file_type_if_matching()
==========================================
[source]
------------------------------------------
>>> get_file_type_if_matching "loveliness" "t*" or print_string "will never"
will never
------------------------------------------
==========================================
________________<heredoc?>________________
function get_file_type_if_matching() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one glob'
    string filename="${1}" filetype_glob="${2}" filetype

    # Get such filetype if matching such glob or return false.
    { filetype="$(get_file_type_if_found "${filename}")" and
        is_string_glob_matches "${filetype}" "${filetype_glob}" } or
        return_false
    return_string "${filetype}"
}

# --------------------( WASTELANDS                         )--------------------
