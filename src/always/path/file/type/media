#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle file *media types* (i.e., lowercase `/`-delimited strings uniquely
identifying file formats), also referred to as *MIME types* in pre-2005
parlance.

== Configuration ==

This parcel assumes external mappings from filetype to mimetype and from
mimetype to command handling such mimetype. Installing mappings is simple, if
somewhat tedious:

.Media Type Configuration
==========================================
[source]
------------------------------------------
# Edit "/etc/mime.type", adding one line for the mimetype for each such
# filetype (e.g., a line "application/pdf pdf" for associating PDF files
# with the "application/pdf" mimetype and hence Okular, above).
>>> edit_file /etc/mime.type

# Edit "/etc/mailcap", adding one line for the application opening each such
# filetype (e.g., a line "application/pdf;/usr/bin/okular %s" for opening
# PDF files in Okular).
>>> edit_file /etc/mailcap

# Reload mimetype aliases.
>>> setup_mimetype_aliases
------------------------------------------
==========================================

== See Also ==

* http://www.bash2zsh.com/essays/essay1_file_manager.html[Helpful introduction]
  to suffix aliases, mime types, and file magic.
-/-

#FIXME: MIME types are now officially referred to as "media types," which
#certainly seems more human-readable. Contemplate renaming this component and
#corresponding functions below.

# ....................{ GLOBALS                            }....................
# There are various thoughts on media type validation. The W3C approach,
# naturally, recommends the following overly overkill PCRE:
#
#     /^[a-zA-Z0-9!#$%^&\*_-\+{}\|'.`~]+/[a-zA-Z0-9!#$%^&\*_-\+{}\|'.`~]+$/
#     http://lists.w3.org/Archives/Public/xml-dist-app/2003Jul/0064.html
#
# The Zend framework takes a different tack, opting instead for:
#
#     /^[a-z-]+\/[a-z0-9.+-]+$/i'
#     https://github.com/zendframework/zf2/blob/master/library/Zend/Mail/Header/ContentType.php
#
# The former arguably encompasses pathological edge cases that sane frameworks
# report as erroneous. We opt for the latter, generalized for
# case-insensitivity. Since non-ASCII Unicode characters do *NOT* constitute
# valid media type characters, avoid otherwise helpful character classes (e.g.,
# "[[:alpha:]]").
declare_global_with_stdin string\
    ZESHY_FILE_TYPE_MEDIA_REGEX='[a-zA-Z_-]##/[a-zA-Z0-9.+_-]##' <<'/---'
PCRE matching valid media types (e.g., `text/plain`). See is_type_media() for
further details.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_type_media(string media_type)

Return success if the passed string is a syntactically valid *media type* (i.e.,
(i.e., MIME type in pre-2005 parlance): e.g.,

.is_type_media()
==========================================
[source]
------------------------------------------
>>> string on_work=\
...    "No one should ever work. Work is the source of nearly all the misery in
...     the world. Almost any evil you'd care to name comes from working or from
...     living in a world designed for work. In order to stop suffering, we have
...     to stop working. That doesn't mean we have to stop doing things. It does
...     mean creating a new way of life based on play; in other words, a ludic
...     conviviality, commensality, and maybe even art. There is more to play
...     than child's play, as worthy as that is. I call for a collective
...     adventure in generalized joy and freely interdependent exuberance. Play
...     isn't passive. Doubtless we all need a lot more time for sheer sloth and
...     slack than we ever enjoy now, regardless of income or occupation, but
...     once recovered from employment-induced exhaustion nearly all of us want
...     to act. Oblomovism and Stakhanovism are two sides of the same debased
...     coin."
>>> is_type_media "All living things on earth are kindred." or
...     get_string_line "${on_work}" 1
No one should ever work. Work is the source of nearly all the misery in
------------------------------------------
==========================================
/---
function is_type_media() {
    die_unless_arg 'expected one media type'
    is_string_matches_glob "${1}" "${ZESHY_FILE_TYPE_MEDIA_REGEX}"
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_file_type_media().
declare_function_with_stdin <<'/---'
string get_file_type_media(string filename)

Get the *media type* (i.e., MIME type in pre-2005 parlance) of the passed file:
e.g.,

.get_file_type_media()
==========================================
[source]
------------------------------------------
>>> get_file_type_media "/etc/issue"
text/plain
------------------------------------------
==========================================
/---
function get_file_type_media() {
    # Validate passed arguments. Since "file" successfully outputs media types
    # for non-regular files (e.g., "inode/directory" for directories) rather
    # than failing, throw an exception if such path is not a regular file.
    die_unless_arg 'expected one filename'
    string filename="${1}" media_type
    die_unless_file_plain "${filename}"

    #FIXME: GNU-specific. Unfortunately, there exists no short option for
    #"--mime-type". How do the BSDs handle this? Ah, I see; "--mime-type" parses
    #the desired substring from "-i" (i.e., "--mime"), which should certainly
    #exist on BSDs. We'll have to do some heavier lifting to generalize this,
    #but it certainly seems doable: parse "-i" output ourselves!
    #FIXME: O.K.; the output for file "/etc/issue" resembles:
    #    /etc/issue: text/plain; charset=us-ascii
    #To account for filenames containing ":", we'll clearly need to dynamically
    #create a glob first matching the desired filename (with glob characters
    #escaped, of course), followed by a colon, and so on. Certainly doable, but
    #somewhat annoying.

    # Defer to "file". (Oh, how we obsequiously bow before thy magnanimity.)
    media_type="$(command file --brief --mime-type -- "${filename}")"

    # Alas, "file" is perhaps not as rigorously tested as expected. file 5.12,
    # for example, behaves as follows:
    #
    #    # The following output isn't simply mistaken. It's fatally wrong. Why?
    #    # Such output fails to conform to valid media type syntax, thus
    #    # breaking functionality elsewhere expecting valid syntax.
    #    >>> command file --brief --mime-type -- /bin/busybox
    #    application/x-executableapplication/octet-stream
    #
    # Since such issues are likely to be subsequently fixed, we refuse to invest
    # any effort in doing so. Since such issues nonetheless exist *AND* since
    # this function is transitively depended on by core functionality elsewhere
    # (e.g., is_binary_executable()), we should at least attempt to detect such
    # issues and notify the user accordingly.
    is_type_media "${media_type}" or
        die "Media type \"${media_type}\" invalid for file \"${filename}\". Your installation of command \"file\" appears to be broken; consider downgrading to a prior version."

    # Return such media type.
    output_string "${media_type}"
}

#FIXME: Shift elsewhere.
declare_function_with_stdin <<'/---'
string get_file_encoding(string filename)

Get the name of character set with which the passed file is encoded: e.g.,

.get_file_encoding()
==========================================
[source]
------------------------------------------
>>> get_file_encoding "/etc/issue"
us-ascii
------------------------------------------
==========================================
/---
function get_file_encoding() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "binary" for directories), throw an exception if the
    # passed path is not a file prior to running "file".
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    #FIXME: GNU-specific. See above.
    # Defer to "file".
    command file --brief --mime-encoding -- "${filename}"
}

# ....................{ OPENERS                            }....................
declare_function_with_stdin <<'/---'
void edit_file(string filename)

Edit the passed file with the command associated with such file's media type.
/---
function edit_file() {
    die_unless_arg 'expected one filename'
    open_file_for_media_action "${1}" edit
}

declare_function_with_stdin <<'/---'
void print_file(string filename)

Print the passed file with the command associated with such file's media type.
/---
function print_file() {
    die_unless_arg 'expected one filename'
    open_file_for_media_action "${1}" print
}

declare_function_with_stdin <<'/---'
void view_file(string filename)

View the passed file with the command associated with such file's media type.
/---
function view_file() {
    die_unless_arg 'expected one filename'
    open_file_for_media_action "${1}" see
}

#FIXME: Rename to open_file_with_media_action().
declare_function_with_stdin <<'/---'
void open_file_for_media_action(string filename, string mime_command_name)

Open the passed file with the command associated with such file's media type and
the passed ``media action'', a string in the following list:

* `compose`, the action creating a new such file.
* `edit`, the action editing such file.
* `print`, the action printing such file.
* `see`, the action viewing such file.
/---
function open_file_for_media_action() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one media action'
    string filename="${1}" media_action="${2}"
    die_unless_alias_suffixed "${filename}"

    # If such action is a command in the current ${PATH}, defer to such command.
    if { is_pathable "${media_action}" } {
        command "${media_action}" "${filename}"
    # Else, print a warning and defer to zsh-mime-handler().
    } else {
        print_warning "media action \"${media_action}\" unrecognized"
        zsh-mime-handler "${filename}"
    }
}

# ....................{ PRINTERS                           }....................
#FIXME: Rename to print_aliases_suffix_media().
declare_function_with_stdin <<'/---'
string print_mimetype_aliases(void)

Print a human-readable synopsis of all *media type-specific suffix aliases*
(i.e., suffix aliases previously defined by setup_mimetype_aliases()).
/---
function print_mimetype_aliases() {
    # See define_mimetype_aliases() for further details.
    die_if_args
    run_command_paged run_command_under_zsh_defaults zsh-mime-setup -l
}

# ....................{ MAKERS                             }....................
#FIXME: Rename to define_aliases_suffix_media().
declare_function_with_stdin <<'/---'
string define_mimetype_aliases(void)

Define one suffix alias for each mimetype mapping listed in the system-wide and
user-specific "mailcap" files. Such aliases associate filename suffixes with the
command handling such files, enabling BSD-style file handling: e.g.,

.define_mimetype_aliases()
==========================================
[source]
------------------------------------------
# Run files to open files. What could be simpler? Assuming installation of
# PDF readers and mimetype mapping associating the PDF mimetype with some
# PDF reader, running PDF files now opens such files in such reader.
>>> define_mimetype_aliases
>>> ./Devour_All_the_Living_Things.pdf
------------------------------------------
==========================================
/---
function define_mimetype_aliases() {
    # Validate sanity.
    die_if_args

    # Autoload such function and functions such function transitively calls.
    # While Zeshy autoloads such functions on startup, Zeshy calls this function
    # during precompilation before startup.
    autoload_function zsh-mime-setup zsh-mime-handler

    #FIXME: run_command_and_undefine_runnables_defined_except_alias_suffixes()
    #is a pretty terrible function name, it must be admitted.

    # Define such aliases. (While such function does initially call emulate(),
    # such call fails to revert traps and hence remains unsafe.)
    #
    # Prevent runnables such function temporarily defines from polluting the
    # current namespace and hence being compiled into Zeshy's user digest file.
    run_command_and_undefine_runnables_defined_except_alias_suffixes\
        run_command_under_zsh_defaults zsh-mime-setup -f
}

# ....................{ PRECOMPILERS                       }....................
run_hook_on_zeshy_precompile precompile_zeshy_aliases_suffix_media

declare_function_with_stdin <<'/---'
void precompile_zeshy_aliases_suffix_media(void)

Define one suffix alias for each media type mapped by system-wide and user-
specific `mailcap` files. See define_mimetype_aliases() for further details.
/---
function precompile_zeshy_aliases_suffix_media() {
    # Validate sanity.
    die_if_args

    # System-wide and user-specific mailcap files mapping MIME types to the
    # application handling files of such type.
    list mailcap_filenames
    mailcap_filenames=( "/etc/mailcap" "${HOME}/.mailcap" )

    # If any such files exist, define mimetype aliases from such file(s).
    # Prevent runnables such function temporarily defines from polluting the
    # current namespace and hence being compiled into Zeshy's user digest file.
    if { is_files_1_or_more "${mailcap_filenames[@]}" } {
        run_command_and_undefine_runnables_defined_except_alias_suffixes\
            define_mimetype_aliases
    }

    # Add such files to the list of paths Zeshy's user digest file depends on.
    add_zeshy_digest_dependency_path "${mailcap_filenames[@]}"
}

# --------------------( WASTELANDS                         )--------------------
    # On digest compilation, Zeshy
    # parses such files to define suffix aliases for such MIME types. See
    # precompile_zeshy_mimetype_aliases() for further details.

# Such function assumes default shell options and
    # hence *CANNOT* be run under Zeshy shell options.
#FUXME: Defining such aliases at precompilation rather than startup time
#surprisingly *SIGNIFICANTLY* decreases performance -- by as much as several
#seconds on both digest compilation and subsequent startup! That's a bit crazy.
#Investigate when time affords. For the meanwhile, we revert to startup-based
#alias definition.
#FUXME: Ah; I think I've nailed it. Note, however, that the prior implementation
#under "WASTELANDS" failed to properly undefine functions *INTERNALLY* defined
#by such scripts. So, how do we do that? I reckon we want a new run_command_*()
#function -- say, run_command_and_undefine_functions_defined(). Naturally, such
#function should run the passed command and then undefine all new functions
#defined by such command. Not terribly difficult, using an approach similar to
#that of "src/compile".

    #FUXME: Not the most granular of exception messages, obviously. To improve
    #output, I suspect we'll probably have to reimplement "zsh-mime-setup" in
    #pure Zeshy, at some lamentable future point.
    # If such definition failed, throw an exception.
#   run_command_silent_stdout print_mimetype_aliases or
#       die 'mimetype aliases not defined'

    #FUXME: Honestly, this is a bit odd. It works, but both the nomenclature and
    #underlying implementation just don't fit here. "zsh-mime-setup" is a zsh
    #script, yes; but at this point of Zeshy startup, zsh-mime-setup() has
    #already been autoloaded. Hence, it's much more straightforward simply to
    #call zsh-mime-setup(). The issue with that, of course, is that such
    #function assumes stock zsh options. Hence, what we *REALLY* want is a new
    #Zeshy function for calling non-Zeshy zsh functions under emulation: say,
    #run_command_with_default_zsh_options(). Ah, but that's not quite right.
    #Emulation doesn't *JUST* revert to default options; it also temporarily
    #unsets TRAPZERR(). How about run_command_under_zsh_emulation()? That
    #nicely coincides with the existing run_command_under_shell(). Ah; right.
    #Then let's go with run_command_under_shell_zsh().
#   source_shell_script_defining_function zsh-mime-setup -f

    #FUXME: How does run_command_paged() find "zsh-mime-setup", and couldn't we
    #implement a similar solution below?
#run_hook_on_zeshy_precompile precompile_zeshy_mimetype_aliases

#declare_function '
#void precompile_zeshy_mimetype_aliases(void)
#
#Define one suffix alias for each mimetype mapping listed in the system-wide and
#user-specific "mailcap" files. See define_mimetype_aliases() for further details.
#'
#function precompile_zeshy_mimetype_aliases() {
#    # Validate sanity.
#    die_if_args
#
#    # If either the system-wide or user-specific "mailcap" file exists and is
#    # non-empty, try to define mimetype aliases using such file(s).
#    { is_file_nonempty '/etc/mailcap' or
#      is_file_nonempty "${HOME}/.mailcap" } and {
#        # Autoload the underlying functions such function calls. While Zeshy
#        # autoloads such functions on startup, Zeshy performs precompilation
#        # before startup.
#        autoload_function zsh-mime-setup zsh-mime-handler
#
#        # Define such aliases.
#        define_mimetype_aliases
#
#        # Avoid compiling autoloaded functions into Zeshy's user digest.
#        undefine_function zsh-mime-setup zsh-mime-handler
#    }
#}

    # Else, print a non-fatal warning.
#   else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" 0-byte or not found'
#   fi

#   source_shell_script_defining_function zsh-mime-setup -f
    #FUXME: Revert back to the prior method of:
    #
    #   run_command_silent_stdout print_mimetype_aliases or {
    #
    #But replace run_command_silent() with an equivalent function
    #squelching *ONLY* stdout. We need to print stderr, for obvious reasons.

    # If either the system-wide or user-specific "mailcap" file exists and is
    # non-empty, define mimetype aliases from such file(s).
#   if is_file_nonempty "${HOME}/.mailcap" or is_file_nonempty '/etc/mailcap'
#   then define_mimetype_aliases
    # Else, print a non-fatal warning.
#   else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" empty or not found'
#   fi

#FUXME: *YE GODS*! This should absolutely be done at precompile time instead.
#Note this implies we should add tests for both "~/.mailcap" and "/etc/mailcap"
#to is_zeshy_digest_outdated(), which shouldn't be too cumbersome.
# run_hook_on_zeshy_startup_if_interactive startup_zeshy_mimetype_aliases
#   if is_file "${HOME}/.mailcap" and is_file_nonempty "${HOME}/.mailcap" or
#      is_file '/etc/mailcap'     and is_file_nonempty '/etc/mailcap'
    # If no such aliases were defined, print an error.
#   run_command_silent print_mimetype_aliases or {
#       string message_prefix='no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap"'

#       if is_file "${HOME}/.mailcap" or is_file '/etc/mailcap'
#       then print_warning "${message_prefix} empty"
#       else print_warning "${message_prefix} not found"
#       fi

#       # Technically, print_mimetype_aliases() failing does not necessary imply
#       # no mimetype aliases to be defined. run_command_paged() may, for
#       # example, be subject to an internal bug. To ascertain which, run
#       # print_mimetype_aliases() again, loudly.
#       print_warning "print_mimetype_aliases() output:"
#       print_mimetype_aliases
#   }

# This is helpful only from non-
# interactive scripts, since from interactive shells one opens a filename by
# simply typing the filename.
#alias_cli_abbreviation {e}ditfile='edit_file'
#alias_cli_abbreviation {v}iewfile='view_file'

    #FUXME: Unhelpful, I suspect.
    # Set default mailcap and mimetype paths prior to installing suffix aliases
    # dependent on these paths.
#   zstyle :mime: mailcap    ~/.mailcap    /etc/mailcap
#   zstyle :mime: mime-types ~/.mime.types /etc/mime.types

    # Emit a message corresponding to whether or not we've already installed
    # aliases with a prior call to this function.
#   if is "$(mimetype_aliases_list)"
#   then print_message 'reinstalling mimetype aliases...'
#   else print_message   'installing mimetype aliases...'
#   fi

# ....................{ MAIN                               }....................
# Automatically install mimetype aliases, as this is *ALWAYS* generally helpful.
#mimetype_aliases_init
