#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *regular files* (i.e., non-directory, non-special files). See
is_file_regular() for further details.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_regular(
    string pathname,
    string error_message = "\"${pathname}\" not a regular file.")

Throw an exception with the passed message unless the passed path is an existing
regular file. See is_file_regular() for further details.
/---
function die_unless_file_regular() {
    die_unless_args_1_to_2 'Expected one pathname and optional error message.'
    string pathname="${1}"
    is_file_regular "${pathname}" or
        die "${2:-\"${pathname}\" not a regular file.}"
}

declare_function_with_stdin <<'/---'
void die_unless_files_regular(string pathname1, string pathname2, ...)

Throw an exception unless the passed paths are all existing regular files. See
is_file_regular() for further details.
/---
function die_unless_files_regular() {
    die_unless_args 'Expected one or more pathnames.'
    is_files_regular "${@}" or
        die "${2:-$(join_strings_readably "${@}") not all regular files.}"
}

declare_function_with_stdin <<'/---'
void die_unless_file_regular_or_not_path(
    string pathname,
    string error_message = "\"${pathname}\" not a regular file.")

Throw an exception with the passed message unless the passed path is either an
existing regular file or does _not_ exist (i.e., throw an exception if such path
exists but is _not_ a regular file). This sanity check is helpful for avoiding
accidentally overwriting existing irregular paths (e.g., device files).
/---
function die_unless_file_regular_or_not_path() {
    die_unless_args_1_to_2 'Expected one pathname and optional error message.'
    string pathname="${1}"
    not is_path "${pathname}" or is_file_regular "${pathname}" or
        die "${2:-\"${pathname}\" not a regular file.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_regular(string pathname)

Return success if the passed path is an existing *regular file* (i.e., non-
special file) and hence _not_ a device file, directory, named pipe, socket, or
symbolic link.
/---
function is_file_regular() {
    die_unless_arg 'Expected one pathname.'
    is -f "${1}" si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_files_regular(string pathname1, string pathname2, ...)

Return success if all passed paths are existing regular files. See
is_file_regular() for further details.
/---
function is_files_regular() {
    is_path_matches_qualifier "${@}" '.'
}

#FIXME: In lieu of unit tests...
#function isom() {
#    is_files_regular /home/leycec/.xsession          or print 'ugh!'
#    is_files_regular /home/leycec/{.xsession,.zshrc} or print 'ugh!!'
#}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Generalize implementation to a new is_path_matching_qualifier() function.
    # Validate passed arguments.
#   die_unless_args 'expected one or more pathname'
#   list filenames

    # Filter non-regular files from such paths.
#   set_list_to_paths_matching_qualifier filenames "${@}" '.'
#   output_string "filenames: ${filenames[*]}"

    # If no such paths were excluded, return success; else, failure. For
    # efficiency, inline such implementation.
#   (( ${#filenames} == ${#@} ))

#   (( $(get_list_size filenames) 
    # Filter non-regular files from such paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each such path.
    # * "(.)", excluding non-regular files.
#   pathnames=( ${^@}(.) )

    # If no such paths were excluded, return success; else, failure. For
    # efficiency, inline such implementation.
#   (( "${#pathnames}" == "${#@}" ))

#FUXME: Rename to die_unless_file_if_exists(). Much more readable.

#FUXME: Our distinction between files and directories is, of course,
#nonsensical. Directories *ARE* special files, as are symbolic links, named
#pipes (FIFOs), and so on. There's a reason prior shells chose "-f" to test for
#regular files. Why? Because that's almost *ALWAYS* what the programmer wants
#and hence expects. So, we should probably instate the following changes:
#
#* Rename functions matching "\b(\w+?)_file\b" to "\1_file_nondir": e.g.,
#  rename is_file() to is_file_nondir(). It's not necessarily clear such
#  functions are genuinely helpful; but, to avoid breaking everything, let's be
#  at least this careful.
#  * *WAIT*. Yes, this is a good rename, but it's a bit *TOO* broad. We really
#    just need to do this on a case-by-case basis for functions to be
#    overwritten by the rename below (e.g., is_file()). There should only four
#    or so functions, so... not a significant concern.
#* Rename "_file_regular" and "_files_regular" to simply "_file" and "_files"
#  everywhere.
#FUXME: Actually, I now disagree. If symbolic files were also considered
#regular, I probably would agree. But as it stands, the current broad conception
#of "file" better captures real-world use.

#FUXME: Rename the adjective "regular" to "regular" everywhere. See
#https://en.wikipedia.org/wiki/Unix_file_types as to why. (Reason: everyone
#calls them "regular files.")

#FUXME: Rename to die_unless_file_if_exists(). die_if_file_nonregular(). There
#* Rename is_path() to is_file_(). 
#function die_if_path_not_file_regular() {
