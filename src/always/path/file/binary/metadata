#!/usr/bin/env zsh
# ====================[ media                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle binary file metadata (e.g., author, bitrate, codec, tags).

# ....................{ PRINTERS                           }....................
#FIXME: Generalize to accept multiple filenames, particularly helpful for
#running interactively as "pfm *".
document_function '
string print_file_metadata(string filename1, string filename2, ...)

Print all textual metadata (e.g., author, codec, tags) in the passed files.
'
function print_file_metadata() {
    # Validate passed arguments.
    die_unless_args_1_or_more 'expected at least one filename'

    # Print such metadata paged, deferring to print_file_metadata_unpaged().
    # Since such printing is computationally expensive and hence unlikely to
    # completely print quickly, paging via run_paged() is preferable to paging
    # via page_string(). The former prints input responsively, in an on-demand
    # manner; the latter prints input unresponsively, blocking on completion.
    run_paged print_file_metadata_unpaged "${(q)@}"
}

document_function '
string print_file_metadata_unpaged(string filename1, string filename2, ...)

Print all textual metadata (e.g., author, codec, tags) in the passed files with
no paging of such metadata. This function is largely intended to be called by
print_file_metadata() only.
'
function print_file_metadata_unpaged() {
    # Validate passed arguments.
    die_unless_args_1_or_more 'expected at least one filename'

    #FIXME: Extract into a new print_file_metadata_fallback() function calling
    #run_with_options_configured() with a new
    #"ZESHY_FILE_OPTIONS_IF_PRINTING_METADATA" list in "if_config/posix".

    # Synopsize all metadata for such files before printing detailed metadata
    # for each such file. External command "file" tabulates output into multiple
    # columns when passed multiple files. Such output aptly, if imperfectly,
    # synopsizes metadata for a multitude of common formats.
    is_installed file and {
        say_first_section "metadata synopsis"
        file --dereference "${@}"
    }

    # Print detailed metadata for each such file, if possible.
    string function_name
    for filename ("${@}") {
        # If some function prints metadata for files of such file's filetype, do so.
        function_name="print_file_metadata_$(get_file_type "${filename}")"
        is_function "${function_name}" and {
            say_next_section "\"${filename}\" metadata"
            "${function_name}" "${filename}"
        }
    }
}

# ....................{ PRINTERS ~ audio                   }....................
document_function '
string print_file_metadata_mp3(string filename)

Print all textual metadata in the passed MP3 compressed audio file.
'
function print_file_metadata_mp3() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file_type "${filename}" 'mp3'

    #FIXME: "ffprobe" supports nearly every conceivable media format, as
    #verified by running "ffprobe -formats", which lists all recognized file
    #types. Great idea: dynamically parse such list and, for each printed file
    #type, associate such filetype with a function using ffprobe to print such
    #metadata. This suggests a rather different structure to this component,
    #reverting back to the prior map style. While seemingly cumbersome, using
    #maps is *MONSTROUSLY* more convenient than this overly verbose one-function-
    #per-file-type structure. So... yeah. Back we go, into the breach!
    #FIXME: Other tools to support:
    #
    #* "avprobe". Basically identical to "ffprobe", for obvious reasons. Note
    #  "avprobe" takes *HIGHER* precedence over "ffprobe", again for obvious
    #  reasons.
    #* "exiftool". (Very popular; very stable. Try out and install to see what
    #  formats it supports and whether its output is preferable to that of
    #  "ffprobe". Despite the name, "exiftool" works on most metadata formats --
    #  not just EXIF. Hmm; you know, it might be helpful to print out *BOTH*
    #  "avprobe" and "exiftool" output; I suspect the two to be complimentary.)
    #* "mediainfo". (Gentoo has it. I wasn't terribly impressed with the
    #  website, but strongly suspect that to be *VERY* out-of-date by now. Heck,
    #  it beats nothing; and if that's all the user has installed, that's what
    #  we use, right?)
    #* "mp3info". (Again, a bit old and no longer updated, but pretty much
    #  *EVERYONE* still uses it for rudimentary ID3 tag printing. Awesome!)
    #* "identify". (ImageMagick. Not for audio files, obviously, but great
    #  nonetheless. Listed here to avoid neglecting it. :))
    #
    #O.K.; that's basically it. The above list gleaned after two hours of
    #furious googling, basically. While there probably do technically exist
    #other audio file describers, they're probably not worth uncovering at this
    #early stage of things.
    #FIXME: The first two lines of "avprobe -show_format" output are a useless
    #version string. *CUT*.

    # Prefer FFmpeg's "ffprobe" utility, if installed.
    if is_installed ffprobe
    then ffprobe -show_format "${filename}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#       die_unless_file_binary "${filename}"

#       # Set the function name printing metadata for files of such file's filetype.
#       filetype="$(get_file_type "${filename}")"
#       function_name="print_file_metadata_${filetype}"

#       # If some function prints metadata for files of such file's filetype, do so.
#       say "printing \"${filename}\" metadata..."
#       if is_function "${function_name}"
#       then "${function_name}" "${filename}"
#       # Else, attempt to print such metadata by running pathable "file" as a
#       # fallback. While imperfect, "file" often prints surprisingly accurate
#       # metadata.
#       else file --dereference "${filename}"
#       fi

#FUXME: This is more general than media. Frankly, this is going to eventually be
#an *INSANELY* enormous function using a conventional "case" approach. Switch to
#a proper map from filetype to function printing all metadata for such filetype.
#If no such function exists, print a warning and default to running "file".
    # If some function prints metadata for files of such file's filetype, do so.
#   if is_map_key\
#          ZESHY_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA "${filetype}"; then
#       "${ZESHY_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA["${filetype}"]}"\
#           "${filename}"
    # Else, default to pathable "file".

# ....................{ GLOBALS                            }....................
#FUXME: Overly heavyweight, actually. Instead, simply call the expected function
#dynamically. If we ever subsequently desire, such a map approach can easily be
#bolted on dynamic function calling (e.g., if such function does not exist).
#document_global '
#map ZESHY_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA
#
#Map from filetype to function printing metadata for files of such filetype.
#'
#ZESHY_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA=(
#    'mp3' print_file_metadata_mp3
#)

#ZESHY_METADATA_FILETYPE_TO_FUNCTION_NAME_PRINT_METADATA
