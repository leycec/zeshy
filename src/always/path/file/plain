#!/usr/bin/env zsh
# ====================[ plain                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle plain files (i.e., files not devices, directories, named pipes,
# sockets, or symbolic links).

#FIXME: Rename the adjective "plain" to "regular" everywhere. See
#https://en.wikipedia.org/wiki/Unix_file_types as to why. (Reason: everyone
#calls them "regular files.")
#FIXME: Our distinction between files and directories is, of course,
#nonsensical. Directories *ARE* special files, as are symbolic links, named
#pipes (FIFOs), and so on. There's a reason prior shells chose "-f" to test for
#regular files. Why? Because that's almost *ALWAYS* what the programmer wants
#and hence expects. So, we should probably instate the following changes:
#
#* Rename functions matching "\b(\w+?)_file\b" to "\1_file_nondir": e.g.,
#  rename is_file() to is_file_nondir(). It's not necessarily clear such
#  functions are genuinely helpful; but, to avoid breaking everything, let's be
#  at least this careful.
#  * *WAIT*. Yes, this is a good rename, but it's a bit *TOO* broad. We really
#    just need to do this on a case-by-case basis for functions to be
#    overwritten by the rename below (e.g., is_file()). There should only four
#    or so functions, so... not a significant concern.
#* Rename "_file_plain" and "_files_plain" to simply "_file" and "_files"
#  everywhere.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_plain(
    string pathname,
    string error_message = "\"${pathname}\" not a plain file")

Throw an exception with the passed message unless the passed path is an existing
plain file. See is_file_plain() for further details.
/---
function die_unless_file_plain() {
    die_unless_args_1_to_2 'expected one pathname and optional error message'
    string pathname="${1}"
    is_file_plain "${pathname}" or die "${2:-\"${pathname}\" not a plain file}"
}

declare_function_with_stdin <<'/---'
void die_unless_files_plain(string pathname1, string pathname2, ...)

Throw an exception unless the passed paths are all existing regular files. See
is_file_plain() for further details.
/---
function die_unless_files_plain() {
    die_unless_args 'expected at least one pathname'
    is_files_plain "${@}" or
        die "${2:-$(join_strings_readably "${@}") not all plain files}"
}

#FIXME: Rename to die_unless_file_if_exists(). Much more readable.
declare_function_with_stdin <<'/---'
void die_unless_file_plain_or_not_path(
    string pathname,
    string error_message = "\"${pathname}\" not a plain file")

Throw an exception with the passed message unless the passed file either does
_not_ exist or is an existing regular file (i.e., throw an exception if such file
is an existing path that is _not_ a regular file). This sanity check is helpful for
avoiding accidentally overwriting existing paths that are _not_ regular files.
/---
function die_unless_file_plain_or_not_path() {
    die_unless_args_1_to_2 'expected one pathname and optional error message'
    string pathname="${1}"
    not is_path "${pathname}" or is_file_plain "${pathname}" or
        die "${2:-\"${pathname}\" not a plain file}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_plain(string pathname)

Return success if the passed path is an existing *regular file* (i.e., a file
_not_ a device, directory, named pipe, socket, or symbolic link).
/---
function is_file_plain() {
    die_unless_arg 'expected one pathname'
    is -f "${1}" si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_files_plain(string pathname1, string pathname2, ...)

Return success if all passed paths are existing regular files. See
is_file_plain() for further details.
/---
function is_files_plain() {
    # Validate passed arguments, filtering non-files from the passed paths.
    # Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(.)", excluding non-filenames.
    die_unless_args 'expected at least one pathname'
    list filenames; filenames=( ${^@}(.) )

    # Return true only if no such pathnames were excluded.
    (( "${#filenames}" == "${#@}" ))
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to die_unless_file_if_exists(). die_if_file_nonregular(). There
#* Rename is_path() to is_file_(). 
#function die_if_path_not_file_plain() {
