#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *file descriptors* (i.e., nonnegative integers signifying open files
accessible as device files under pseudo-filesystem `/dev/fd`).
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_descriptor(
    string file_descriptor_name,
    string error_message = "\"${file_descriptor_name}\" not a file descriptor")

Throw an exception with the passed message unless the passed file descriptor is
well-formatted. See is_file_descriptor() for further details.
/---
function die_unless_file_descriptor() {
    die_unless_args_1_to_2\
        'expected one file descriptor name and optional error message'
    string file_descriptor_name__dufd="${1}"
    is_file_descriptor "${file_descriptor_name__dufd}" or
        die "${2:-\"${file_descriptor_name__dufd}\" not a file descriptor}"
}

declare_function_with_stdin <<'/---'
void die_unless_file_descriptor_open(
    string file_descriptor_name,
    string error_message =
        "file descriptor \"${file_descriptor_name}\" not open")

Throw an exception with the passed message unless the passed file descriptor is
open under the current shell. See is_file_descriptor_open() for further details.
/---
function die_unless_file_descriptor_open() {
    die_unless_args_1_to_2\
        'expected one file descriptor name and optional error message'
    string file_descriptor_name__dufdo="${1}"
    is_file_descriptor_open "${file_descriptor_name__dufdo}" or
        die "${2:-file descriptor \"${file_descriptor_name__dufdo}\" not open}"
}

declare_function_with_stdin <<'/---'
void die_unless_file_descriptor_open_for_writing(
    string file_descriptor_name,
    string error_message =
        "file descriptor \"${file_descriptor_name}\" not opened for writing")

Throw an exception with the passed message unless the passed file descriptor is
open for writing under the current shell. See
is_file_descriptor_open_for_writing() for further details.
/---
function die_unless_file_descriptor_open_for_writing() {
    die_unless_args_1_to_2\
        'expected one file descriptor name and optional error message'
    string file_descriptor_name__dufdw="${1}"
    is_file_descriptor_open_for_writing "${file_descriptor_name__dufdw}" or
        die "${2:-file descriptor \"${file_descriptor_name__dufdw}\" not opened for writing}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_descriptor(
    string file_descriptor_name)

Return success if the passed file descriptor is *well-formatted* (i.e., is a
nonnegative integer), regardless of whether such descriptor is open under the
current shell.
/---
function is_file_descriptor() {
    # File descriptors are internally implemented as non-negative integers.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifd="${1}"
    is_integer_nonnegative "${(P)file_descriptor_name__ifd}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_file_descriptor_open(string file_descriptor_name)

Return success if the passed file descriptor is open for reading and/or
writing under the current shell.
/---
function is_file_descriptor_open() {
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifdo="${1}"
    die_unless_file_descriptor "${file_descriptor_name__ifdo}"
    is_path_exists\
        "$(get_file_descriptor_device_file "${file_descriptor_name__ifdo}")"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_file_descriptor_open_for_reading(string file_descriptor_name)

Return success if the passed file descriptor is open for reading under the
current shell.
/---
function is_file_descriptor_open_for_reading() {
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifdofr="${1}"
    die_unless_file_descriptor "${file_descriptor_name__ifdofr}"
    is_path_readable\
        "$(get_file_descriptor_device_file "${file_descriptor_name__ifdofr}")"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_file_descriptor_open_for_writing(string file_descriptor_name)

Return success if the passed file descriptor is open for writing under the
current shell.
/---
function is_file_descriptor_open_for_writing() {
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifdofw="${1}"
    die_unless_file_descriptor "${file_descriptor_name__ifdofw}"
    is_path_writable\
        "$(get_file_descriptor_device_file "${file_descriptor_name__ifdofw}")"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_file_descriptor_file(string file_descriptor_name)

Get the absolute path of the target file opened for the passed file descriptor
under the current shell. If such descriptor is not open under such shell, an
exception is thrown.
/---
function get_file_descriptor_file() {
    # Validate passed arguments.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__gfdf="${1}"
    die_unless_file_descriptor_open "${file_descriptor_name__gfdf}"

    # Get such path.
    canonicalize_path\
        "$(get_file_descriptor_device_file "${file_descriptor_name__gfdf}")"
}

declare_function_with_stdin <<'/---'
string get_file_descriptor_device_file(string file_descriptor_name)

Get the absolute path of the device file of the pseudo-filesystem `/dev/fd`
opened for the passed file descriptor under the current shell. If such
descriptor is not open under such shell, an exception is thrown.
/---
function get_file_descriptor_device_file() {
    # According to section "REDIRECTION" of "man zshmisc", zsh cross-platform-
    # portably treats "/dev/fd/${file_descriptor}" as the underlying platform-
    # specific path. Hence, this should require no platform-specific munging.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__gfdfd="${1}"
    die_unless_file_descriptor "${file_descriptor_name__gfdfd}"

    # Get such path.
    return_string "/dev/fd/${(P)file_descriptor_name__gfdfd}"
}

# ....................{ OPENERS ~ read                     }....................
declare_function_with_stdin <<'/---'
void open_file_descriptor_for_reading_file(
    string file_descriptor_name, string filename)

Open the passed file descriptor under the current shell for reading from the
passed file. If such descriptor is already open under the current shell,
silently close such descriptor first. See
open_file_descriptor_for_writing_file() for further details.
/---
function open_file_descriptor_for_reading_file() {
    # See open_file_descriptor_for_writing_file().
    die_unless_args_2 'expected one file descriptor name and one filename'
    string file_descriptor_name__ofdff="${1}" filename__ofdff="${2}"
    die_unless_file_descriptor "${file_descriptor_name__ofdff}"
    close_file_descriptor_if_open_nonstandard "${file_descriptor_name__ofdff}"
    eval "exec {${file_descriptor_name__ofdff}}<'${filename__ofdff}'"
}

# ....................{ OPENERS ~ write                    }....................
declare_function_with_stdin <<'/---'
void open_file_descriptor_for_writing_file(string file_descriptor_name, string filename)

Open the passed file descriptor under the current shell for overwriting the
contents of the passed file. If such descriptor is already open under such
shell, silently close such descriptor first: e.g.,

.open_file_descriptor_for_writing_file()
==========================================
[source]
------------------------------------------
>>> file_descriptor                       white_pony
>>> open_file_descriptor_for_writing_file white_pony "/diamond/eyes"
>>> write_file_descriptor_with_string     white_pony "koi no yokan"
>>> close_file_descriptor                 white_pony
>>> print_file_text "/diamond/eyes"
koi no yokan
------------------------------------------
==========================================
/---
function open_file_descriptor_for_writing_file() {
    # Validate passed arguments.
    die_unless_args_2 'expected one file descriptor name and one filename'
    string file_descriptor_name__ofdtf="${1}" filename__ofdtf="${2}"
    die_unless_file_descriptor "${file_descriptor_name__ofdtf}"

    # If such descriptor is open and nonstandard, close such descriptor.
    close_file_descriptor_if_open_nonstandard "${file_descriptor_name__ofdtf}"

    # Allocate such descriptor.
    eval "exec {${file_descriptor_name__ofdtf}}>'${filename__ofdtf}'"
}

# ....................{ OPENERS ~ write : fd               }....................
declare_function_with_stdin <<'/---'
void open_file_descriptor_for_writing_stdout(string file_descriptor_name)

Open the passed file descriptor under the current shell for appending to the
standard output stream of such shell: e.g.,

.open_file_descriptor_for_writing_stdout()
==========================================
[source]
------------------------------------------
>>> file_descriptor                         black_rose
>>> open_file_descriptor_for_writing_stdout black_rose
>>> write_file_descriptor_with_string       black_rose "immortal"
immortal
>>> close_file_descriptor                   black_rose
------------------------------------------
==========================================
/---
function open_file_descriptor_for_writing_stdout() {
    die_unless_arg 'expected one file descriptor name'
    open_file_descriptor_for_writing_file_descriptor "${1}"\
        ZESHY_STDOUT_FILE_DESCRIPTOR
}

declare_function_with_stdin <<'/---'
void open_file_descriptor_for_writing_stderr(string file_descriptor_name)

Open the passed file descriptor under the current shell for appending to the
standard error stream of such shell: e.g.,

.open_file_descriptor_for_writing_stderr()
==========================================
[source]
------------------------------------------
>>> file_descriptor                         birch_white
>>> open_file_descriptor_for_writing_stderr birch_white
>>> write_file_descriptor_with_string       birch_white "birch black"
birch black
>>> close_file_descriptor                   birch_white
------------------------------------------
==========================================
/---
function open_file_descriptor_for_writing_stderr() {
    die_unless_arg 'expected one file descriptor name'
    open_file_descriptor_for_writing_file_descriptor "${1}"\
        ZESHY_STDERR_FILE_DESCRIPTOR
}

declare_function_with_stdin <<'/---'
void open_file_descriptor_for_writing_file_descriptor(
    string target_file_descriptor_name, string source_file_descriptor_name)

Open the first passed file descriptor for overwriting the contents of the file
already opened by the second passed file descriptor under the current shell. If
the former is already open under the current shell, silently close such
descriptor first. This function thus performs file descriptor duplication: e.g.,

.open_file_descriptor_for_writing_file_descriptor()
==========================================
[source]
------------------------------------------
>>> file_descriptor black_star
>>> open_file_descriptor_for_writing_file_descriptor black_star\
...     ZESHY_STDOUT_FILE_DESCRIPTOR
>>> write_file_descriptor_with_string black_star "respiration"
respiration
>>> close_file_descriptor black_star
------------------------------------------
==========================================
/---
function open_file_descriptor_for_writing_file_descriptor() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target and one source file descriptor name'
    string fd_name_target__ofdtfd="${1}" fd_name_source__ofdtfd="${2}"
    die_unless_file_descriptor "${fd_name_target__ofdtfd}"
    die_unless_file_descriptor "${fd_name_source__ofdtfd}"

    # If the target file descriptor is open and nonstandard, close such
    # descriptor.
    close_file_descriptor_if_open_nonstandard "${fd_name_target__ofdtfd}"

    # Open such descriptor. Unfortunately, the following seemingly valid
    # assignment fails with nonzero exit status:
    #
    #     eval "exec {${fd_name_target__ofdtfd}}>&${(P)fd_name_source__ofdtfd}"
    #
    # Unless expanding the source descriptor before its expansion in such
    # "eval" statement, such statement inexplicably fails. While this should
    # probably be reported, expand such descriptor beforehand in the meanwhile.
    integer fd_source__ofdtfd="${(P)fd_name_source__ofdtfd}"
    eval "exec {${fd_name_target__ofdtfd}}>&${fd_source__ofdtfd}"
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
void write_file_descriptor_with_string(
    string file_descriptor_name, string text1, string text2, ..., )

Overwrite the existing contents of the file opened for writing by the passed
file descriptor with the passed strings. See
open_file_descriptor_for_writing_file() for further details.
/---
function write_file_descriptor_with_string() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one file descriptor name and at least one string'
    string file_descriptor_name__wfdws="${1}"
    die_unless_file_descriptor_open_for_writing "${file_descriptor_name__wfdws}"
    shift_arg

    # Write such strings. Bizarrely, zsh provides no corresponding ">>&"
    # operation. Instead, ">&" appends and *NO* operation writes. While
    # nonsensical, there's not terribly much we can do about it. So, we
    # stupidly fake it by silently removing the underlying file. Yes, this is
    # non-atomic and hence terrible. *shrug*
    remove_file "$(get_file_descriptor_file "${file_descriptor_name__wfdws}")"
    append_file_descriptor_with_string "${file_descriptor_name__wfdws}" "${@}"
}

declare_function_with_stdin <<'/---'
void append_file_descriptor_with_string(
    string file_descriptor_name, string text1, string text2, ...)

Append the passed strings to the existing contents of the file opened for
writing by the passed file descriptor. See
open_file_descriptor_for_writing_file() for further details.
/---
function append_file_descriptor_with_string() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one file descriptor name and at least one string'
    string file_descriptor_name__afdws="${1}"
    die_unless_file_descriptor_open_for_writing "${file_descriptor_name__afdws}"
    shift_arg

    # Append such strings.
    output_string "${@}" >& ${(P)file_descriptor_name__afdws}
}

# ....................{ CLOSERS                            }....................
declare_function_with_stdin <<'/---'
void close_file_descriptor(string file_descriptor_name)

Close the passed open file descriptor. If such descriptor is not open under the
current shell, throw an exception. See open_file_descriptor_for_writing_file()
for further details.
/---
function close_file_descriptor() {
    # Validate passed arguments.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__cfd="${1}"
    die_unless_file_descriptor_open "${file_descriptor_name__cfd}"

    # Close such descriptor.
    eval "exec {${file_descriptor_name__cfd}}>&-"
}

declare_function_with_stdin <<'/---'
void close_file_descriptor_if_open(string file_descriptor_name)

Close the passed file descriptor if open or return silently otherwise. See
open_file_descriptor_for_writing_file() for further details.
/---
function close_file_descriptor_if_open() {
    # Validate passed arguments.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__cfdio="${1}"

    # If such descriptor is open, close such descriptor.
    is_file_descriptor_open "${file_descriptor_name__cfdio}" and
        close_file_descriptor "${file_descriptor_name__cfdio}"
}

declare_function_with_stdin <<'/---'
void close_file_descriptor_if_open_nonstandard(string file_descriptor_name)

Close the passed file descriptor if open _and_ *nonstandard* (i.e., _not_ opened
for reading or writing the standard input, output, or error streams of the
current shell) or return silently otherwise. Since closing standard file
descriptors is generally a poor idea, consider calling this function rather than
close_file_descriptor(). See such function for further details.
/---
function close_file_descriptor_if_open_nonstandard() {
    # Validate passed arguments.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__cfdion="${1}"
    die_unless_file_descriptor "${file_descriptor_name__cfdion}"

    # If such descriptor is open and nonstandard, close such descriptor. Since
    # POSIX assigns standard error the largest file descriptor of the three
    # standard file descriptors, check against such descriptor.
    (( ${(P)file_descriptor_name__cfdion} > ${ZESHY_STDERR_FILE_DESCRIPTOR} )) and
        close_file_descriptor_if_open "${file_descriptor_name__cfdion}"
}

# --------------------( WASTELANDS                         )--------------------
# Don't bother calling the more expensive
    # die_unless_file_descriptor(), as functions this function transitively
    # calls already do so.
    # Avoid calling die_unless_file_descriptor(), as that calls this function.
#FUXME: Actually, these two functions imply different semantics. The latter
#*SHOULD* throw an exception if such variable does not exist; the former simply
#returns failure. Due to laziness, just grep the codebase and determine which we
#need. Excise the other (and corresponding exception handler above).
    # If such descriptor is *NOT* a standard file descriptor (i.e., 0, 1, or 2)
    # and already open, close before opening such descriptor. zsh fails with
    # non-zero exit status otherwise.
#   (( ${(P)file_descriptor_name__ofdtf} >= 3 )) and
#       is_file_descriptor_open "${file_descriptor_name__ofdtf}" and
#       close_file_descriptor   "${file_descriptor_name__ofdtf}"
#Write the passed strings to the passed file descriptor, overwriting the file
#such descriptor refers to with such strings

#allocated by the operating system to the passed file descriptor.
#FUXME: Make a new "file_descriptor" type, aliased to integers.
#FUXME: Define new open_file_descriptor_for_writing_file_descriptor() and
#open_file_descriptor_for_writing_stderr() functions.
# Such descriptor is shell specific and hence applies only to the current shell
#this functionality *CANNOT* be encapsulated in a getter function
#(e.g., "$(get_file_descriptor_writing_to_file black_koi "/yokan")"):

#FUXME: Rename to get_file_descriptor_path(). The current nomenclature is
#slightly more specific but *MUCH* less understandable.
#   >>> set_file_descriptor_to_write_file white_pony "/diamond/eyes"
# void write_file_with_string_descriptor(
#   string text1, string text2, ..., integer file_descriptor)
#
# Write the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
#function write_file_with_string_descriptor() {
    # Validate passed arguments.
#    die_unless_args_2 'expected at least one string and one file descriptor'
#    string file_descriptor="${@[-1]}"
#    die_unless_file_descriptor_open_for_writing "${file_descriptor}"
#    pop_arg

    # Write such strings.
#}

#FUXME: Frankly, the whole reliance on file descriptor names greatly and entirely
#unnecessarily complicates all functionality below. I don't see why we can't
#just dynamically assign passed string integers to actual integers in function
#implementations, if needed. For example:
#function get_file_descriptor_writing_to_file() {
    # Validate passed arguments.
#    die_unless_arg 'expected one one filename'
#    string filename="${1}"

    # Allocate such file descriptor.
#    integer file_descriptor
#    exec {file_descriptor}>"${filename}"
#    print_string "${file_descriptor}"
#}
