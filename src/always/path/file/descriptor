#!/usr/bin/env zsh
# ====================[ descriptor                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file descriptors (i.e., nonnegative integers signifying open files
# dynamically allocated device files under "/dev/fd").

# ....................{ EXCEPTIONS                         }....................
#FIXME: Writemeplzkthx.

# ....................{ GETTERS                            }....................
# boolean is_file_descriptor(integer file_descriptor)
#
# Return true if the passed file descriptor exists (i.e., is currently allocated
# the passed integer and hence open for reading and/or writing).
is_file_descriptor() {
    die_unless_one_arg 'expected one file descriptor'
    string file_descriptor_path="${1}" file_descriptor_path
    is_string_nonnegative_integer "${file_descriptor}" and {
        file_descriptor_path="$(get_file_descriptor_path "${file_descriptor}")"
        is_path "${file_descriptor_path}"
    }
}

# boolean is_file_descriptor_readable(integer file_descriptor)
#
# Return true if the passed file descriptor exists and is readable.
is_file_descriptor_readable() {
    die_unless_one_arg 'expected one file descriptor'
    string file_descriptor_path="${1}" file_descriptor_path
    is_string_nonnegative_integer "${file_descriptor}" and {
        file_descriptor_path="$(get_file_descriptor_path "${file_descriptor}")"
        is_path_readable "${file_descriptor_path}"
    }
}

# boolean is_file_descriptor_writable(integer file_descriptor)
#
# Return true if the passed file descriptor exists and is writable.
is_file_descriptor_writable() {
    die_unless_one_arg 'expected one file descriptor'
    string file_descriptor_path="${1}" file_descriptor_path
    is_string_nonnegative_integer "${file_descriptor}" and {
        file_descriptor_path="$(get_file_descriptor_path "${file_descriptor}")"
        is_path_writable "${file_descriptor_path}"
    }
}

# ....................{ GETTERS                            }....................
# string get_file_descriptor_path(integer file_descriptor)
#
# Get the absolute path of the device file with which the passed file
# descriptor reads and/or writes.
function get_file_descriptor_path() {
    # According to section "REDIRECTION" of "man zshmisc", Zsh cross-platform-
    # portably treats "/dev/fd/${file_descriptor}" as the underlying platform-
    # specific path. Hence, this should require no platform-specific munging.
    die_unless_one_arg 'expected one file descriptor'
    string file_descriptor="${1}"
    die_unless_string_nonnegative_integer "${file_descriptor}"
    output "/dev/fd/${file_descriptor}"
}

# ....................{ SETTERS                            }....................
# void set_integer_to_file_descriptor_writing_to_file(
#   string integer_name, string filename)
#
# Set the passed integer to a newly allocated output file descriptor, which when
# written to writes to the passed file: e.g.,
#
#     >>> integer white_pony
#     >>> set_integer_to_file_descriptor_writing_to_file\
#     ...     white_pony "/diamond/eyes"
#     >>> write_integer_file_descriptor_with white_pony "koi no yokan"
#     >>> close_integer_file_descriptor white_pony
#     >>> print_text_file "/diamond/eyes"
#     koi no yokan
function set_integer_to_file_descriptor_writing_to_file() {
    # Validate passed arguments.
    die_unless_two_args 'expected one integer name and one filename'
    string integer_name="${1}" filename="${2}"
    die_unless_integer "${integer_name}"

    # Open such file descriptor.
    exec {${integer_name}}>"${filename}"
}

# ....................{ WRITERS                            }....................
# void write_integer_file_descriptor_with(
#   string integer_name, string text1, string text2, ...)
#
# Write the passed strings to the file descriptor allocated the passed integer.
# See set_integer_to_file_descriptor_writing_to_file() for examples.
function write_integer_file_descriptor_with() {
    # Validate passed arguments.
    die_unless_two_args 'expected one integer name and one string'
    string integer_name="${1}"
    die_unless_integer_file_descriptor "${integer_name}"
    shift_one_arg

    # Write such strings.
    write_file_descriptor_with "${(P)integer_name}" "${@}"
}

# void write_file_descriptor_with(
#   integer file_descriptor, string text1, string text2, ...)
#
# Write the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
function write_file_descriptor_with() {
    # Validate passed arguments.
    die_unless_two_args 'expected one file descriptor and one string'
    string file_descriptor="${1}"
    die_unless_file_descriptor_writable "${file_descriptor}"
    shift_one_arg

    # Write such strings.
    output "${@}" >&${file_descriptor}
}

# ....................{ WRITERS ~ appenders                }....................
# void append_file_descriptor_with(
#   integer file_descriptor, string text1, string text2, ...)
#
# Append the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
function append_file_descriptor_with() {
    # Validate passed arguments.
    die_unless_two_args 'expected one file descriptor and one string'
    string file_descriptor="${1}"
    die_unless_file_descriptor_writable "${file_descriptor}"
    shift_one_arg

    #FIXME: Hmmm; "man zshmisc" lists no such operation. I suspect the above
    #write_*file_descriptor_with() functions may actually be appending.
    #Investigate.
    # Append such strings.
    output "${@}" >>&${file_descriptor}
}

# ....................{ CLOSERS                            }....................
# void close_integer_file_descriptor(string integer_name)
#
# Close the file descriptor previously allocated the passed integer. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
function close_integer_file_descriptor() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one integer name'
    string integer_name="${1}"
    die_unless_integer_file_descriptor "${integer_name}"

    # Close such file descriptor.
    exec {${integer_name}}>&-
}

# --------------------( WASTELANDS                         )--------------------
