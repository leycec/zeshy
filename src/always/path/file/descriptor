#!/usr/bin/env zsh
# ====================[ descriptor                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle file descriptors (i.e., nonnegative integers signifying open files
# dynamically allocated device files under "/dev/fd").

# ....................{ EXCEPTIONS                         }....................
document_function '
string die_unless_file_descriptor [OR] die_unless_variable_file_descriptor(
  string file_descriptor_name,
  string error_message = "\"${file_descriptor_name}\" not a file descriptor")

Throw an exception with the passed message unless the passed file descriptor
exists.
'
function die_unless_file_descriptor die_unless_variable_file_descriptor() {
    die_unless_args_1_to_2\
        'expected one file descriptor name and optional error message'
    string file_descriptor_name__dufd="${1}"
    is_file_descriptor "${file_descriptor_name__dufd}" or
        die "${2:-\"${file_descriptor_name__dufd}\" not a file descriptor}"
}

document_function '
string die_unless_file_descriptor_writable(
  string file_descriptor_name,
  string error_message = \"${file_descriptor_name}\" not a writable file descriptor")

Throw an exception with the passed message unless the passed file descriptor is
open for writing.
'
function die_unless_file_descriptor_writable() {
    die_unless_args_1_to_2\
        'expected one file descriptor name and optional error message'
    string file_descriptor_name__dufdw="${1}"
    is_file_descriptor_writable "${file_descriptor_name__dufdw}" or
        die "${2:-\"${file_descriptor_name__dufdw}\" not a writable file descriptor}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_file_descriptor [OR] is_variable_file_descriptor(
    string file_descriptor_name)

Return true if the passed file descriptor exists (but is not necessarily open).
'
function is_file_descriptor is_variable_file_descriptor() {
    # File descriptors are internally implemented as non-negative integers.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifd="${1}"
    is_integer_nonnegative "${(P)file_descriptor_name__ifd}"
}

document_function '
boolean is_file_descriptor_open(string file_descriptor_name)

Return true if the passed file descriptor is open for reading and/or writing.
'
function is_file_descriptor_open() {
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifdo="${1}"
    is_file_descriptor "${file_descriptor_name__ifdo}" and is_path\
        "$(get_file_descriptor_device_file "${file_descriptor_name__ifdo}")"
}

document_function '
boolean is_file_descriptor_readable(string file_descriptor_name)

Return true if the passed file descriptor is open for reading.
'
function is_file_descriptor_readable() {
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifdr="${1}"
    is_file_descriptor "${file_descriptor_name__ifdr}" and is_path_readable\
        "$(get_file_descriptor_device_file "${file_descriptor_name__ifdr}")"
}

document_function '
boolean is_file_descriptor_writable(string file_descriptor_name)

Return true if the passed file descriptor is open for writing.
'
function is_file_descriptor_writable() {
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__ifdw="${1}"
    is_file_descriptor "${file_descriptor_name__ifdw}" and is_path_writable\
        "$(get_file_descriptor_device_file "${file_descriptor_name__ifdw}")"
}

# ....................{ GETTERS                            }....................
document_function '
string get_file_descriptor_file(string file_descriptor_name)

Get the absolute path of the file opened by the passed file descriptor.
'
function get_file_descriptor_file() {
    # Validate passed arguments.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__gfdf="${1}"
    die_unless_file_descriptor_open "${file_descriptor_name__gfdf}"

    # Get such path.
    canonicalize_path\
        "$(get_file_descriptor_device_file "${file_descriptor_name__gfdf}")"
}

document_function '
string get_file_descriptor_device_file(string file_descriptor_name)

Get the absolute path of the device file allocated by the operating system to
the passed file descriptor.
'
function get_file_descriptor_device_file() {
    # According to section "REDIRECTION" of "man zshmisc", zsh cross-platform-
    # portably treats "/dev/fd/${file_descriptor}" as the underlying platform-
    # specific path. Hence, this should require no platform-specific munging.
    # Avoid calling die_unless_file_descriptor(), as that calls this function.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__gfdfd="${1}"
    die_unless_integer_nonnegative "${(P)file_descriptor_name__gfdfd}"

    # Get such path.
    print_string "/dev/fd/${(P)file_descriptor_name__gfdfd}"
}

# ....................{ OPENERS ~ write                    }....................
document_function '
void open_file_descriptor_to_file(string file_descriptor_name, string filename)

Open the passed file descriptor for writing to the passed file. If such
descriptor has already been opened, silently close such descriptor: e.g.,

    >>> file_descriptor white_pony
    >>> open_file_descriptor_to_file white_pony "/diamond/eyes"
    >>> write_file_descriptor_with_string white_pony "koi no yokan"
    >>> close_file_descriptor white_pony
    >>> print_file_text "/diamond/eyes"
    koi no yokan
'
function open_file_descriptor_to_file() {
    # Validate passed arguments.
    die_unless_args_2 'expected one file descriptor name and one filename'
    string file_descriptor_name__ofdtf="${1}" filename__ofdtf="${2}"
    die_unless_file_descriptor "${file_descriptor_name__ofdtf}"

    # If such descriptor is *NOT* a standard file descriptor (i.e., 0, 1, or 2)
    # and already open, close before opening such descriptor. zsh fails with
    # non-zero exit status otherwise.
    (( ${(P)file_descriptor_name__ofdtf} >= 3 )) and
        is_file_descriptor_open "${file_descriptor_name__ofdtf}" and
        close_file_descriptor   "${file_descriptor_name__ofdtf}"

    # Allocate such descriptor.
    eval "exec {${file_descriptor_name__ofdtf}}>'${filename__ofdtf}'"
}

document_function '
void open_file_descriptor_to_file_descriptor(
    string target_file_descriptor_name, string source_file_descriptor_name)

Open the passed file descriptor for writing to the passed open file descriptor.
If the former has already been opened, silently close such descriptor. This is
often referred to as "duplicating" a file descriptor: e.g.,

    >>> file_descriptor black_star
    >>> open_file_descriptor_to_file_descriptor\
    ...     black_star ZESHY_FILE_DESCRIPTOR_STDOUT
    >>> write_file_descriptor_with_string black_star "respiration"
    respiration
    >>> close_file_descriptor black_star
'
function open_file_descriptor_to_file_descriptor() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target and one source file descriptor name'
    string\
        file_descriptor_name_target__ofdtfd="${1}"\
        file_descriptor_name_source__ofdtfd="${2}"
    die_unless_file_descriptor "${file_descriptor_name_target__ofdtfd}"
    die_unless_file_descriptor "${file_descriptor_name_source__ofdtfd}"

    # Close such descriptor if open. See open_file_descriptor_to_file().
    (( ${(P)file_descriptor_name_target__ofdtfd} >= 3 )) and
        is_file_descriptor_open "${file_descriptor_name_target__ofdtfd}" and
        close_file_descriptor   "${file_descriptor_name_target__ofdtfd}"

    # Open such descriptor. Unfortunately, the following seemingly valid
    # assignment fails with non-zero exit status:
    #
    #     eval "exec {${file_descriptor_name_target__ofdtfd}}>&${(P)file_descriptor_name_source__ofdtfd}"
    # Unless expanding the source descriptor before its expansion in such
    # "eval" statement, such statement inexplicably fails. While this should
    # probably be reported, expand such descriptor beforehand in the meanwhile.
    integer file_descriptor_source__ofdtfd="${(P)file_descriptor_name_source__ofdtfd}"
    eval "exec {${file_descriptor_name_target__ofdtfd}}>&${file_descriptor_source__ofdtfd}"
}

document_function '
void open_file_descriptor_to_stdout(string file_descriptor_name)

Open the passed file descriptor for writing to the current shell''s standard
output: e.g.,

    >>> file_descriptor black_rose
    >>> open_file_descriptor_to_stdout black_rose
    >>> write_file_descriptor_with_string black_rose "immortal"
    immortal
    >>> close_file_descriptor black_rose
'
function open_file_descriptor_to_stdout() {
    die_unless_arg 'expected one file descriptor name'
    open_file_descriptor_to_file_descriptor "${1}" ZESHY_FILE_DESCRIPTOR_STDOUT
}

document_function '
void open_file_descriptor_to_stderr(string file_descriptor_name)

Open the passed file descriptor for writing to the current shell''s standard
error: e.g.,

    >>> file_descriptor birch_white
    >>> open_file_descriptor_to_stderr birch_white
    >>> write_file_descriptor_with_string birch_white "birch black"
    birch black
    >>> close_file_descriptor birch_white
'
function open_file_descriptor_to_stderr() {
    die_unless_arg 'expected one file descriptor name'
    open_file_descriptor_to_file_descriptor "${1}" ZESHY_FILE_DESCRIPTOR_STDERR
}

# ....................{ OPENERS ~ read                     }....................
document_function '
void open_file_descriptor_from_file(
    string file_descriptor_name, string filename)

Open the passed file descriptor for reading from the passed file. If such
integer is currently set to an open file descriptor, throw an exception. See
open_file_descriptor_to_file() for further details.
'
function open_file_descriptor_from_file() {
    # See open_file_descriptor_to_file().
    die_unless_args_2 'expected one file descriptor name and one filename'
    string file_descriptor_name__ofdff="${1}" filename__ofdff="${2}"
    die_unless_file_descriptor "${file_descriptor_name__ofdff}"
    is_file_descriptor_open   "${file_descriptor_name__ofdtf}" and
        close_file_descriptor "${file_descriptor_name__ofdtf}"
    eval "exec {${file_descriptor_name__ofdff}}<'${filename__ofdff}'"
}

# ....................{ WRITERS                            }....................
document_function '
void write_file_descriptor_with_string(
  string file_descriptor_name, string text1, string text2, ..., )

Write the passed strings to the passed file descriptor, overwriting the file
such descriptor refers to with such strings. See
open_file_descriptor_to_file() for further details.
'
function write_file_descriptor_with_string() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one file descriptor name and at least one string'
    string file_descriptor_name__wfdws="${1}"
    die_unless_file_descriptor_writable "${file_descriptor_name__wfdws}"
    shift_arg

    # Write such strings. Bizarrely, zsh provides no corresponding ">>&"
    # operation. Instead, ">&" appends and *NO* operation writes. While
    # nonsensical, there's not terribly much we can do about it. So, we
    # stupidly fake it by silently removing the underlying file. *shrug*
    remove_file "$(get_file_descriptor_file "${file_descriptor_name__wfdws}")"
    append_file_descriptor_with_string "${file_descriptor_name__wfdws}" "${@}"
}

document_function '
void append_file_descriptor_with_string(
  string file_descriptor_name, string text1, string text2, ...)

Append the passed strings to the existing content of the passed file descriptor.
See open_file_descriptor_to_file() for examples.
'
function append_file_with_string_descriptor() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one file descriptor name and at least one string'
    string file_descriptor_name__afdws="${1}"
    die_unless_file_descriptor_writable "${file_descriptor_name__afdws}"
    shift_arg

    # Append such strings.
    print_string "${@}" >& ${(P)file_descriptor_name__afdws}
}

# ....................{ CLOSERS                            }....................
document_function '
void close_file_descriptor(string file_descriptor_name)

Close the passed open file descriptor. If such descriptor is not open, silently
return. See open_file_descriptor_to_file() for further details.
'
function close_file_descriptor() {
    # Validate passed arguments.
    die_unless_arg 'expected one file descriptor name'
    string file_descriptor_name__cfd="${1}"
    die_unless_file_descriptor "${file_descriptor_name__cfd}"

    # If such descriptor is open, close such descriptor.
    is_file_descriptor_open "${file_descriptor_name__cfd}" and
        eval "exec {${file_descriptor_name__cfd}}>&-"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Make a new "file_descriptor" type, aliased to integers.
#FUXME: Define new open_file_descriptor_to_file_descriptor() and
#open_file_descriptor_to_stderr() functions.
# Such descriptor is shell specific and hence applies only to the current shell
#this functionality *CANNOT* be encapsulated in a getter function
#(e.g., "$(get_file_descriptor_writing_to_file black_koi "/yokan")"):

#FUXME: Rename to get_file_descriptor_path(). The current nomenclature is
#slightly more specific but *MUCH* less understandable.
#   >>> set_file_descriptor_to_write_file white_pony "/diamond/eyes"
# void write_file_with_string_descriptor(
#   string text1, string text2, ..., integer file_descriptor)
#
# Write the passed strings to the passed file descriptor. See
# set_integer_to_file_descriptor_writing_to_file() for examples.
#function write_file_with_string_descriptor() {
    # Validate passed arguments.
#    die_unless_args_2 'expected at least one string and one file descriptor'
#    string file_descriptor="${@[-1]}"
#    die_unless_file_descriptor_writable "${file_descriptor}"
#    pop_arg

    # Write such strings.
#}

#FUXME: Frankly, the whole reliance on file descriptor names greatly and entirely
#unnecessarily complicates all functionality below. I don't see why we can't
#just dynamically assign passed string integers to actual integers in function
#implementations, if needed. For example:
#function get_file_descriptor_writing_to_file() {
    # Validate passed arguments.
#    die_unless_arg 'expected one one filename'
#    string filename="${1}"

    # Allocate such file descriptor.
#    integer file_descriptor
#    exec {file_descriptor}>"${filename}"
#    print_string "${file_descriptor}"
#}
