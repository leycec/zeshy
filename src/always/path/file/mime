#!/usr/bin/env zsh
# ====================[ mime                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle filename and file content-derived mimetypes.
#
# --------------------( INSTALLATION                       )--------------------
# This component assumes external mappings from filetype to mimetype and from
# mimetype to command handling such mimetype. Installing mappings is simple, if
# somewhat tedious:
#
#   # Edit "/etc/mime.type", adding one line for the mimetype for each such
#   # filetype (e.g., a line "application/pdf pdf" for associating PDF files
#   # with the "application/pdf" mimetype and hence Okular, above).
#   vi /etc/mime.type
#
#   # Edit "/etc/mailcap", adding one line for the application opening each such
#   # filetype (e.g., a line "application/pdf;/usr/bin/okular %s" for opening
#   # PDF files in Okular).
#   vi /etc/mailcap
#
#   # Reload mimetype aliases.
#   setup_mimetype_aliases
#
# --------------------( SEE ALSO                           )--------------------
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Brilliant introduction to suffix aliases, mime types, and file magic.

# ....................{ GETTERS                            }....................
# string get_file_mimetype(string filename)
#
# Get the mimetype of the passed file by inspecting its file content.
function get_file_mimetype() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "inode/directory" for directories), throw an exception if
    # the passed path is not a file prior to running "file".
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    # Defer to "file". (Oh, how we obsequiously bow before thy magnanimity.)
    file --brief --mime-type -- "${filename}"
}

# string get_file_encoding(string filename)
#
# Get the character set encoding the passed file by inspecting its file content.
function get_file_encoding() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "binary" for directories), throw an exception if the
    # passed path is not a file prior to running "file".
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    # Defer to "file".
    file --brief --mime-encoding -- "${filename}"
}

# ....................{ RUNNERS                            }....................
# void edit_file(string filename)
#
# Edit the passed file with the command associated with such file's mimetype.
function edit_file() {
    die_unless_one_arg 'expected one filename'
    open_file_with edit "${1}"
}

# void view_file(string filename)
#
# View the passed file with the command associated with such file's mimetype.
function view_file() {
    die_unless_one_arg 'expected one filename'
    open_file_with see "${1}"
}

# void open_file_with(string mime_command_name, string filename)
#
# Open the passed file with the command associated with such file's mimetype and
# the passed mime command name (e.g., "see", "edit", "compose").
function open_file_with() {
    # Validate passed arguments.
    die_unless_two_args\
        'expected one mime command and one filename'
    string mime_command="${1}" filename="${2}"
    die_unless_suffix_aliased "${filename}"

    # If this system provides the passed command, prefer that.
    if is_installed "${mimetype_command_name}"
    then "${mimetype_command_name}" "${filename}"
    # Otherwise, default to the zsh "zsh-mime-handler" command.
    else
        cry "\"\""
        zsh-mime-handler "${filename}"
    fi
}

# ....................{ PRINTERS                           }....................
# string print_mimetype_aliases(void)
#
# List all suffix aliases defined by a prior call to setup_mimetype_aliases().
function print_mimetype_aliases() {
    die_if_args
    run_paged zsh-mime-setup -l
}

# ....................{ SETUP                              }....................
# void setup_mimetype_aliases(void)
#
# Define suffix aliases corresponding to mimetype mappings defined by
# "/etc/mailcap" and "~/.mail.cap". Such aliases associate filename suffixes
# with the command handling such files, enabling BSD-style file handling: e.g.,
#
#     # Run files to open files. What could be simpler? Assuming installation of
#     # PDF readers and mimetype mapping associating the PDF mimetype with some
#     # PDF reader, running PDF files now opens such files in such reader.
#     >>> setup_mimetypes
#     >>> ./Devour_All_the_Living_Things.pdf
function setup_mimetypes() {
    # Validate sanity and install such aliases.
    die_if_args
    source_safely zsh-mime-setup -f

    # If no such aliases were installed, print an error.
    run_quietly print_mimetype_aliases or {
        if is_file "${HOME}/.mailcap" or is_file '/etc/mailcap'
        then cry '"~/.mailcap" and "/etc/mailcap" empty, so no mimetype aliases installed'
        else cry '"~/.mailcap" and "/etc/mailcap" not found, so no mimetype aliases installed'
        fi
    }
}

# --------------------( WASTELANDS                         )--------------------
# This is helpful only from non-
# interactive scripts, since from interactive shells one opens a filename by
# simply typing the filename.
#interactive_abbreviation {e}ditfile='edit_file'
#interactive_abbreviation {v}iewfile='view_file'

    #FIXME: Unhelpful, I suspect.
    # Set default mailcap and mimetype paths prior to installing suffix aliases
    # dependent on these paths.
#   zstyle :mime: mailcap    ~/.mailcap    /etc/mailcap
#   zstyle :mime: mime-types ~/.mime.types /etc/mime.types

    # Emit a message corresponding to whether or not we've already installed
    # aliases with a prior call to this function.
#   if is "$(mimetype_aliases_list)"
#   then say 'reinstalling mimetype aliases...'
#   else say   'installing mimetype aliases...'
#   fi

# ....................{ MAIN                               }....................
# Automatically install mimetype aliases, as this is *ALWAYS* generally helpful.
#mimetype_aliases_init
