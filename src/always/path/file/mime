#!/usr/bin/env zsh
# ====================[ mime                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle filename and file content-derived mimetypes.
#
# --------------------( INSTALLATION                       )--------------------
# This component assumes external mappings from filetype to mimetype and from
# mimetype to command handling such mimetype. Installing mappings is simple, if
# somewhat tedious:
#
#   # Edit "/etc/mime.type", adding one line for the mimetype for each such
#   # filetype (e.g., a line "application/pdf pdf" for associating PDF files
#   # with the "application/pdf" mimetype and hence Okular, above).
#   vi /etc/mime.type
#
#   # Edit "/etc/mailcap", adding one line for the application opening each such
#   # filetype (e.g., a line "application/pdf;/usr/bin/okular %s" for opening
#   # PDF files in Okular).
#   vi /etc/mailcap
#
#   # Reload mimetype aliases.
#   setup_mimetype_aliases
#
# --------------------( SEE ALSO                           )--------------------
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Brilliant introduction to suffix aliases, mime types, and file magic.

# ....................{ GETTERS                            }....................
document_function '
string get_file_mimetype(string filename)

Get the passed file''s mimetype by dynamically inspecting such file''s content.
'
function get_file_mimetype() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "inode/directory" for directories), throw an exception if
    # the passed path is not a file prior to running "file".
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    #FIXME: GNU-specific. Unfortunately, there exists no short option for
    #"--mime-type". How do the BSDs handle this? Ah, I see; "--mime-type" parses
    #the desired substring from "-i" (i.e., "--mime"), which should certainly
    #exist on BSDs. We'll have to do some heavier lifting to generalize this,
    #but it certainly seems doable: parse "-i" output ourselves!

    # Defer to "file". (Oh, how we obsequiously bow before thy magnanimity.)
    file --brief --mime-type -- "${filename}"
}

document_function '
string get_file_encoding(string filename)

Get the passed file''s character set encoding by dynamically inspecting such
file''s content.
'
function get_file_encoding() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "binary" for directories), throw an exception if the
    # passed path is not a file prior to running "file".
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    #FIXME: GNU-specific. See above.
    # Defer to "file".
    file --brief --mime-encoding -- "${filename}"
}

# ....................{ RUNNERS                            }....................
document_function '
void edit_file(string filename)

Edit the passed file with the command associated with such file''s mimetype.
'
function edit_file() {
    die_unless_arg 'expected one filename'
    open_file_with edit "${1}"
}

document_function '
void view_file(string filename)

View the passed file with the command associated with such file''s mimetype.
'
function view_file() {
    die_unless_arg 'expected one filename'
    open_file_with see "${1}"
}

#FIXME: Switch the passed parameter order.
document_function '
void open_file_with(string mime_command_name, string filename)

Open the passed file with the command associated with such file''s mimetype and
the passed mime command name (e.g., "see", "edit", "compose").
'
function open_file_with() {
    # Validate passed arguments.
    die_unless_args_2 'expected one mime command and one filename'
    string mime_command="${1}" filename="${2}"
    die_unless_suffix_aliased "${filename}"

    # If this system provides the passed command, prefer that.
    if is_pathable "${mimetype_command_name}"
    then "${mimetype_command_name}" "${filename}"
    #FIXME: Should probably print a warning in such case, no?
    # Otherwise, default to the zsh "zsh-mime-handler" command.
    else zsh-mime-handler "${filename}"
    fi
}

# ....................{ PRINTERS                           }....................
document_function '
string print_mimetype_aliases(void)

List all suffix aliases defined by a prior call to setup_mimetype_aliases().
'
function print_mimetype_aliases() {
    die_if_args

    #FIXME: How does run_command_paged() find "zsh-mime-setup", and couldn't we
    #implement a similar solution below?
    run_command_paged zsh-mime-setup -l
}

# ....................{ MAKERS                             }....................
document_function '
string define_mimetype_aliases(void)

Define one suffix aliase for each mimetype mapping listed in the system-wide
and user-specific "mailcap" files. Such aliases associate filename suffixes with
the command handling such files, enabling BSD-style file handling: e.g.,

    # Run files to open files. What could be simpler? Assuming installation of
    # PDF readers and mimetype mapping associating the PDF mimetype with some
    # PDF reader, running PDF files now opens such files in such reader.
    >>> define_mimetype_aliases
    >>> ./Devour_All_the_Living_Things.pdf
'
function define_mimetype_aliases() {
    die_if_args
    source_shell_script_defining_function zsh-mime-setup -f
}

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_startup_if_shell_interactive startup_zeshy_mimetype_aliases

document_function '
void startup_zeshy_mimetype_aliases(void)

See define_mimetype_aliases() for further details.
'
function startup_zeshy_mimetype_aliases() {
    # Validate sanity.
    die_if_args

    # If either the system-wide or user-specific "mailcap" file exists and is
    # non-empty, define mimetype aliases from such file(s).
    if is_file_nonempty "${HOME}/.mailcap" or is_file_nonempty '/etc/mailcap'
    then define_mimetype_aliases
    # Else, print a non-fatal warning.
    else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" empty or not found'
    fi
}

# --------------------( WASTELANDS                         )--------------------
#   if is_file "${HOME}/.mailcap" and is_file_nonempty "${HOME}/.mailcap" or
#      is_file '/etc/mailcap'     and is_file_nonempty '/etc/mailcap'
    # If no such aliases were defined, print an error.
#   run_command_silently print_mimetype_aliases or {
#       string message_prefix='no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap"'

#       if is_file "${HOME}/.mailcap" or is_file '/etc/mailcap'
#       then print_warning "${message_prefix} empty"
#       else print_warning "${message_prefix} not found"
#       fi

#       # Technically, print_mimetype_aliases() failing does not necessary imply
#       # no mimetype aliases to be defined. run_command_paged() may, for
#       # example, be subject to an internal bug. To ascertain which, run
#       # print_mimetype_aliases() again, loudly.
#       print_warning "print_mimetype_aliases() output:"
#       print_mimetype_aliases
#   }

# This is helpful only from non-
# interactive scripts, since from interactive shells one opens a filename by
# simply typing the filename.
#interactive_abbreviation {e}ditfile='edit_file'
#interactive_abbreviation {v}iewfile='view_file'

    #FUXME: Unhelpful, I suspect.
    # Set default mailcap and mimetype paths prior to installing suffix aliases
    # dependent on these paths.
#   zstyle :mime: mailcap    ~/.mailcap    /etc/mailcap
#   zstyle :mime: mime-types ~/.mime.types /etc/mime.types

    # Emit a message corresponding to whether or not we've already installed
    # aliases with a prior call to this function.
#   if is "$(mimetype_aliases_list)"
#   then print_message 'reinstalling mimetype aliases...'
#   else print_message   'installing mimetype aliases...'
#   fi

# ....................{ MAIN                               }....................
# Automatically install mimetype aliases, as this is *ALWAYS* generally helpful.
#mimetype_aliases_init
