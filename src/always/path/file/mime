#!/usr/bin/env zsh
# ====================[ mime                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle filename and file content-derived mimetypes.
#
# --------------------( INSTALLATION                       )--------------------
# This component assumes external mappings from filetype to mimetype and from
# mimetype to command handling such mimetype. Installing mappings is simple, if
# somewhat tedious:
#
#   # Edit "/etc/mime.type", adding one line for the mimetype for each such
#   # filetype (e.g., a line "application/pdf pdf" for associating PDF files
#   # with the "application/pdf" mimetype and hence Okular, above).
#   vi /etc/mime.type
#
#   # Edit "/etc/mailcap", adding one line for the application opening each such
#   # filetype (e.g., a line "application/pdf;/usr/bin/okular %s" for opening
#   # PDF files in Okular).
#   vi /etc/mailcap
#
#   # Reload mimetype aliases.
#   setup_mimetype_aliases
#
# --------------------( SEE ALSO                           )--------------------
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Brilliant introduction to suffix aliases, mime types, and file magic.

#FIXME: MIME types are now officially referred to as "media types," which
#certainly seems more human-readable. Contemplate renaming this component and
#corresponding functions below.

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_file_mime_type().
declare_function_with_stdin <<'-\-'
string get_file_mimetype(string filename)

Get the media type (i.e., MIME type) of the passed file: e.g.,

.get_file_mimetype()
==========================================
[source]
------------------------------------------
>>> get_file_mimetype "/etc/issue"
text/plain
------------------------------------------
==========================================
-\-
function get_file_mimetype() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "inode/directory" for directories), throw an exception if
    # the passed path is not a file prior to running "file".
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    #FIXME: GNU-specific. Unfortunately, there exists no short option for
    #"--mime-type". How do the BSDs handle this? Ah, I see; "--mime-type" parses
    #the desired substring from "-i" (i.e., "--mime"), which should certainly
    #exist on BSDs. We'll have to do some heavier lifting to generalize this,
    #but it certainly seems doable: parse "-i" output ourselves!
    #FIXME: O.K.; the output for file "/etc/issue" resembles:
    #    /etc/issue: text/plain; charset=us-ascii
    #To account for filenames containing ":", we'll clearly need to dynamically
    #create a glob first matching the desired filename (with glob characters
    #escaped, of course), followed by a colon, and so on. Certainly doable, but
    #somewhat annoying.

    # Defer to "file". (Oh, how we obsequiously bow before thy magnanimity.)
    file --brief --mime-type -- "${filename}"
}

declare_function_with_stdin <<'-\-'
string get_file_encoding(string filename)

Get the name of character set with which the passed file is encoded: e.g.,

.get_file_encoding()
==========================================
[source]
------------------------------------------
>>> get_file_encoding "/etc/issue"
us-ascii
------------------------------------------
==========================================
-\-
function get_file_encoding() {
    # Validate passed arguments. Since "file" successfully outputs mimetypes for
    # non-files (e.g., "binary" for directories), throw an exception if the
    # passed path is not a file prior to running "file".
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    #FIXME: GNU-specific. See above.
    # Defer to "file".
    file --brief --mime-encoding -- "${filename}"
}

# ....................{ OPENERS                            }....................
declare_function_with_stdin <<'-\-'
void edit_file(string filename)

Edit the passed file with the command associated with such file's media type.
-\-
function edit_file() {
    die_unless_arg 'expected one filename'
    open_file_for_media_action "${1}" edit
}

declare_function_with_stdin <<'-\-'
void print_file(string filename)

Print the passed file with the command associated with such file's media type.
-\-
function print_file() {
    die_unless_arg 'expected one filename'
    open_file_for_media_action "${1}" print
}

declare_function_with_stdin <<'-\-'
void view_file(string filename)

View the passed file with the command associated with such file's media type.
-\-
function view_file() {
    die_unless_arg 'expected one filename'
    open_file_for_media_action "${1}" see
}

declare_function_with_stdin <<'-\-'
void open_file_for_media_action(string filename, string mime_command_name)

Open the passed file with the command associated with such file's media type and
the passed ``media action'', a string in the following list:

* `compose`, the action creating a new such file.
* `edit`, the action editing such file.
* `print`, the action printing such file.
* `see`, the action viewing such file.
-\-
function open_file_for_media_action() {
    # Validate passed arguments.
    die_unless_args_2 'expected one filename and one media action'
    string filename="${2}" media_action="${1}"
    die_unless_alias_suffixed "${filename}"

    # If such action is a command in the current ${PATH}, defer to such command.
    if { is_pathable "${media_action}" } {
        "${media_action}" "${filename}"
    # Else, print a warning and defer to zsh-mime-handler().
    } else {
        print_warning "media action \"${media_action}\" unrecognized"
        zsh-mime-handler "${filename}"
    }
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'-\-'
string print_mimetype_aliases(void)

List all suffix aliases previously defined setup_mimetype_aliases().
-\-
function print_mimetype_aliases() {
    # See define_mimetype_aliases() for further details.
    die_if_args
    run_command_paged run_command_under_zsh_defaults zsh-mime-setup -l
}

# ....................{ MAKERS                             }....................
declare_function_with_stdin <<'-\-'
string define_mimetype_aliases(void)

Define one suffix alias for each mimetype mapping listed in the system-wide and
user-specific "mailcap" files. Such aliases associate filename suffixes with the
command handling such files, enabling BSD-style file handling: e.g.,

.define_mimetype_aliases()
==========================================
[source]
------------------------------------------
# Run files to open files. What could be simpler? Assuming installation of
# PDF readers and mimetype mapping associating the PDF mimetype with some
# PDF reader, running PDF files now opens such files in such reader.
>>> define_mimetype_aliases
>>> ./Devour_All_the_Living_Things.pdf
------------------------------------------
==========================================
-\-
function define_mimetype_aliases() {
    # Validate sanity.
    die_if_args

    # Autoload such function and functions such function transitively calls.
    # While Zeshy autoloads such functions on startup, Zeshy calls this function
    # during precompilation before startup.
    autoload_function zsh-mime-setup zsh-mime-handler

    # Define such aliases. (While such function does initially call emulate(),
    # such call fails to revert traps and hence remains unsafe.)
    run_command_under_zsh_defaults zsh-mime-setup -f
}

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_precompile precompile_zeshy_mimetype_aliases

declare_function_with_stdin <<'-\-'
void precompile_zeshy_mimetype_aliases(void)

Define one suffix alias for each media type mapped by system-wide and user-
specific `mailcap` files. See define_mimetype_aliases() for further details.
-\-
function precompile_zeshy_mimetype_aliases() {
    # Validate sanity.
    die_if_args

    # System-wide and user-specific mailcap files mapping MIME types to the
    # application handling files of such type.
    list mailcap_filenames
    mailcap_filenames=( "/etc/mailcap" "${HOME}/.mailcap" )

    # If any such files exist, define mimetype aliases from such file(s).
    # Prevent runnables such function temporarily defines from polluting the
    # current namespace and hence being compiled into Zeshy's user digest file.
    is_files_1_or_more "${mailcap_filenames[@]}" and
        run_command_and_undefine_runnables_defined_except_alias_suffixes\
            define_mimetype_aliases

    # Add such files to the list of paths Zeshy's user digest file depends on.
    add_zeshy_digest_dependency_path "${mailcap_filenames[@]}"
}

# --------------------( WASTELANDS                         )--------------------
    # On digest compilation, Zeshy
    # parses such files to define suffix aliases for such MIME types. See
    # precompile_zeshy_mimetype_aliases() for further details.

# Such function assumes default shell options and
    # hence *CANNOT* be run under Zeshy shell options.
#FUXME: Defining such aliases at precompilation rather than startup time
#surprisingly *SIGNIFICANTLY* decreases performance -- by as much as several
#seconds on both digest compilation and subsequent startup! That's a bit crazy.
#Investigate when time affords. For the meanwhile, we revert to startup-based
#alias definition.
#FUXME: Ah; I think I've nailed it. Note, however, that the prior implementation
#under "WASTELANDS" failed to properly undefine functions *INTERNALLY* defined
#by such scripts. So, how do we do that? I reckon we want a new run_command_*()
#function -- say, run_command_and_undefine_functions_defined(). Naturally, such
#function should run the passed command and then undefine all new functions
#defined by such command. Not terribly difficult, using an approach similar to
#that of "src/compile".

    #FUXME: Not the most granular of exception messages, obviously. To improve
    #output, I suspect we'll probably have to reimplement "zsh-mime-setup" in
    #pure Zeshy, at some lamentable future point.
    # If such definition failed, throw an exception.
#   run_command_silent_stdout print_mimetype_aliases or
#       die 'mimetype aliases not defined'

    #FUXME: Honestly, this is a bit odd. It works, but both the nomenclature and
    #underlying implementation just don't fit here. "zsh-mime-setup" is a zsh
    #script, yes; but at this point of Zeshy startup, zsh-mime-setup() has
    #already been autoloaded. Hence, it's much more straightforward simply to
    #call zsh-mime-setup(). The issue with that, of course, is that such
    #function assumes stock zsh options. Hence, what we *REALLY* want is a new
    #Zeshy function for calling non-Zeshy zsh functions under emulation: say,
    #run_command_with_default_zsh_options(). Ah, but that's not quite right.
    #Emulation doesn't *JUST* revert to default options; it also temporarily
    #unsets TRAPZERR(). How about run_command_under_zsh_emulation()? That
    #nicely coincides with the existing run_command_under_shell(). Ah; right.
    #Then let's go with run_command_under_shell_zsh().
#   source_shell_script_defining_function zsh-mime-setup -f

    #FUXME: How does run_command_paged() find "zsh-mime-setup", and couldn't we
    #implement a similar solution below?
#run_hook_on_zeshy_precompile precompile_zeshy_mimetype_aliases

#declare_function '
#void precompile_zeshy_mimetype_aliases(void)
#
#Define one suffix alias for each mimetype mapping listed in the system-wide and
#user-specific "mailcap" files. See define_mimetype_aliases() for further details.
#'
#function precompile_zeshy_mimetype_aliases() {
#    # Validate sanity.
#    die_if_args
#
#    # If either the system-wide or user-specific "mailcap" file exists and is
#    # non-empty, try to define mimetype aliases using such file(s).
#    { is_file_nonempty '/etc/mailcap' or
#      is_file_nonempty "${HOME}/.mailcap" } and {
#        # Autoload the underlying functions such function calls. While Zeshy
#        # autoloads such functions on startup, Zeshy performs precompilation
#        # before startup.
#        autoload_function zsh-mime-setup zsh-mime-handler
#
#        # Define such aliases.
#        define_mimetype_aliases
#
#        # Avoid compiling autoloaded functions into Zeshy's user digest.
#        undefine_function zsh-mime-setup zsh-mime-handler
#    }
#}

    # Else, print a non-fatal warning.
#   else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" 0-byte or not found'
#   fi

#   source_shell_script_defining_function zsh-mime-setup -f
    #FUXME: Revert back to the prior method of:
    #
    #   run_command_silent_stdout print_mimetype_aliases or {
    #
    #But replace run_command_silent() with an equivalent function
    #squelching *ONLY* stdout. We need to print stderr, for obvious reasons.

    # If either the system-wide or user-specific "mailcap" file exists and is
    # non-empty, define mimetype aliases from such file(s).
#   if is_file_nonempty "${HOME}/.mailcap" or is_file_nonempty '/etc/mailcap'
#   then define_mimetype_aliases
    # Else, print a non-fatal warning.
#   else print_warning 'no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap" empty or not found'
#   fi

#FUXME: *YE GODS*! This should absolutely be done at precompile time instead.
#Note this implies we should add tests for both "~/.mailcap" and "/etc/mailcap"
#to is_zeshy_digest_outdated(), which shouldn't be too cumbersome.
# run_hook_on_zeshy_startup_if_interactive startup_zeshy_mimetype_aliases
#   if is_file "${HOME}/.mailcap" and is_file_nonempty "${HOME}/.mailcap" or
#      is_file '/etc/mailcap'     and is_file_nonempty '/etc/mailcap'
    # If no such aliases were defined, print an error.
#   run_command_silent print_mimetype_aliases or {
#       string message_prefix='no mimetype aliases defined: "~/.mailcap" and "/etc/mailcap"'

#       if is_file "${HOME}/.mailcap" or is_file '/etc/mailcap'
#       then print_warning "${message_prefix} empty"
#       else print_warning "${message_prefix} not found"
#       fi

#       # Technically, print_mimetype_aliases() failing does not necessary imply
#       # no mimetype aliases to be defined. run_command_paged() may, for
#       # example, be subject to an internal bug. To ascertain which, run
#       # print_mimetype_aliases() again, loudly.
#       print_warning "print_mimetype_aliases() output:"
#       print_mimetype_aliases
#   }

# This is helpful only from non-
# interactive scripts, since from interactive shells one opens a filename by
# simply typing the filename.
#interactive_abbreviation {e}ditfile='edit_file'
#interactive_abbreviation {v}iewfile='view_file'

    #FUXME: Unhelpful, I suspect.
    # Set default mailcap and mimetype paths prior to installing suffix aliases
    # dependent on these paths.
#   zstyle :mime: mailcap    ~/.mailcap    /etc/mailcap
#   zstyle :mime: mime-types ~/.mime.types /etc/mime.types

    # Emit a message corresponding to whether or not we've already installed
    # aliases with a prior call to this function.
#   if is "$(mimetype_aliases_list)"
#   then print_message 'reinstalling mimetype aliases...'
#   else print_message   'installing mimetype aliases...'
#   fi

# ....................{ MAIN                               }....................
# Automatically install mimetype aliases, as this is *ALWAYS* generally helpful.
#mimetype_aliases_init
