#!/usr/bin/env zsh
# ====================[ file                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle non-directory files and filenames (i.e., file pathnames).

# ....................{ ALIASES                            }....................
interactive_substitution rm='remove_file'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_file(
#   string pathname,
#   string error_message = "\"${pathname}\" not a file")
#
# Throw an exception unless the passed file exists.
function die_unless_file() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file "${pathname}" or die "${2:-\"${pathname}\" not a file}"
}

# void die_unless_file_type(
#   string pathname,
#   string filetype,
#   string error_message = "\"${pathname}\" not a file of type \"${filetype}\"")
#
# Throw an exception unless the passed filename has the passed filetype.
function die_unless_file_type() {
    die_unless_two_or_three_args\
        'expected one pathname, one filetype, and optional error message'
    string pathname="${1}" filetype="${2}"
    is_file_type "${pathname}" "${filetype}" or
        die "${2:-\"${pathname}\" not of filetype \"${filetype}\"}"
}

# ....................{ EXCEPTIONS ~ plain                 }....................
# void die_unless_file_plain(
#   string pathname,
#   string error_message = "\"${pathname}\" not a plain file")
#
# Throw an exception unless the passed plain file exists. See is_file_plain().
function die_unless_file_plain() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file_plain "${pathname}" or die "${2:-\"${pathname}\" not a plain file}"
}

# void die_unless_files_plain(string pathname1, string pathname2, ...)
#
# Throw an exception unless the passed plain files all exist. See
# is_file_plain().
function die_unless_files_plain() {
    die_unless_args 'expected at least one pathname'
    is_files_plain "${@}" or
        die "${2:-$(join_list_elements_conjunctively "${@}") not all plain files}"
}

# ....................{ TESTERS                            }....................
# boolean is_file(string pathname)
#
# Return true if the passed path is an existing non-directory file.
function is_file() {
    die_unless_one_arg 'expected one pathname'
    is -e "${1}" and not -d "${1}" si
}

# boolean is_file_type(string filename, string filetype)
#
# Return true if the the passed filename has the passed filetype.
function is_file_type() {
    die_unless_two_args 'expected one pathname and one filetype'
    is "$(get_file_type_if_found "${1}")" == "${2}" si
}

# ....................{ TESTERS ~ plain                    }....................
# boolean is_file_plain(string pathname)
#
# Return true if the passed path is an existing plain file (i.e., a file not a
# device, directory, named pipe, socket, or symbolic link).
function is_file_plain() {
    die_unless_one_arg 'expected one pathname'
    is -f "${1}" si
}

# boolean is_files_plain(string pathname1, string pathname2, ...)
#
# Return true if all passed plain files all exist. See is_file_plain().
function is_files_plain() {
    # Validate passed arguments, filtering non-files from the passed paths.
    # Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(.)", excluding non-filenames.
    die_unless_args 'expected at least one pathname'
    list filenames; filenames=( ${^@}(.) )

    # Return true only if no such pathnames were excluded.
    (( "${#filenames}" == "${#@}" ))
}

# ....................{ GETTERS                            }....................
# string get_file_name_sans_type(string filename)
#
# Get the passed filename excluding filetype. If such filename has no filetype,
# this is the filename itself: e.g.,
#
#     >>> get_file_name_sans_type '/endymion/hastur.tar.gz'
#     /endymion/hastur
#     >>> get_file_name_sans_type '/hyperion/azazoth'
#     /hyperion/azazoth
function get_file_name_sans_type() {
    die_unless_one_arg 'expected one filename'
    string filetype; filetype="$(get_file_type_if_found "${1}")" or true
    output "${1%.${filetype}}"
}

# ....................{ GETTERS ~ filetype                 }....................
# string get_file_type(string filename)
#
# Get the filetype of the passed filename or throw an exception if that filename
# has no filetype. For filenames suffixed by two-part "tar" designators, the
# filetype is "tar." followed by the rightmost period-delimited suffix; else,
# filetype is the merely the rightmost period-delimited suffix: e.g.,
#
#     >>> get_file_type 'hastur.tar.gz'
#     tar.gz
#     >>> get_file_type 'pasteur.ar.gz'
#     gz
function get_file_type() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}" filetype

    # Get such filetype.
    if filetype="$(get_file_type_if_found "${filename}")"
    then output "${filetype}"
    else die "\"${filename}\" has no filetype"
    fi
}

# string get_file_type_if_found(string filename)
#
# Get the filetype of the passed filename or the empty string if that filename
# has no filetype. See get_file_type() for further details.
function get_file_type_if_found() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}"

    # Match the passed filename's filetype, discarding leading ".".
    if is "$(get_path_basename "${filename}")" =~ '\.(tar\.)?[^.]+$' si
    then output "$(remove_string_prefix "${MATCH}" '.')"
    else return_false
    fi
}

# ....................{ MAKERS                             }....................
# void make_file(string filename1, string filename2, ...)
#
# Make all passed files if no such files exist to be zero byte files or throw
# an exception if at least one such file exists. See make_file_if_not_found()
# for an alternative throwing no such exception.
function make_file() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # While Zeshy enables "noclobber" by default, the current user or context
    # may have re-enabled "clobber". For safety, force "noclobber" locally.
    localize_shell_options noclobber

    # For each passed file, attempt to make such file without truncating such
    # file if already extant. Since the simplest means of effecting this is to
    # attempt to redirect zero-length output to such file under "noclobber",
    # perform such redirection as the intentional side effect of a noop. While
    # admittedly bizarre, this technique has the advantage of actually working.
    for filename ("${@}") {
        noop > "${filename}"
    }
}

# void make_file_if_not_found(string filename1, string filename2, ...)
#
# Make all passed files that do not already exist to be zero byte files,
# ignoring those that do exist.
function make_file_if_not_found() {
    die_unless_args 'expected at least one filename'
    touch -- "${@}"
}

# ....................{ REMOVERS                           }....................
# void remove_file(string pathname1, string pathname2, ...)
#
# Remove the passed files, throwing an exception if any such file does not
# exist. See remove_file_if_found() if this is undesirable.
function remove_file() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # Remove passed paths. Since removal arguments depend on the number of such
    # paths, run_with_options() is insufficient to run "rm". So, implement such
    # logic explicitly.
    list rm; rm=( command rm "${ZESHY_RM_OPTIONS[@]}" )
    if is_shell_interactive; then
        if is_one_to_three_args
        then rm+=( "${ZESHY_RM_OPTIONS_IF_INTERACTIVE_WITH_FEW_PATHS}" )
        else rm+=( "${ZESHY_RM_OPTIONS_IF_INTERACTIVE_WITH_MANY_PATHS}" )
        fi

         "${rm[@]}" "${ZESHY_RM_OPTIONS_IF_INTERACTIVE[@]}" -- "${@}"
    else "${rm[@]}" "${ZESHY_RM_OPTIONS_IF_NON_INTERACTIVE[@]}" -- "${@}"
    fi
}

# void remove_file_if_found(string pathname1, string pathname2, ...)
#
# Remove all passed files that exist, ignoring those that do not.
function remove_file_if_found() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    #FIXME: Call the helper in "file/path" we recently defined.
    # Filter non-extant paths from the passed paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed path.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant paths.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If any extant paths remain, remove such paths.
    is_args and remove_file "${@}"
}

# void remove_file_quietly(string pathname1, string pathname2, ...)
#
# Remove the passed files quietly (i.e., without interactive confirmation),
# throwing an exception if any such file does not exist.
function remove_file_quietly() {
    die_unless_args 'expected at least one filename'
    command rm -- "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Not right. Should remove the filetype returned by get_file_type -- not
#simply the rightmost filetype.
# If this filename has a filetype, this excludes only
# the rightmost filetype#   output "${1%.*}"
#FIXME: Poor idea. Invites race conditions.
# void die_if_file(
#   string pathname,
#   string error_message = "\"${pathname}\" is an existing file")
#
# Throw an exception if the passed file exists.
#function die_if_file() {
#    die_unless_one_or_two_args\
#        'expected one pathname and optional error message'
#    string pathname="${1}"
#    is_file "${pathname}" and die "${2:-\"${pathname}\" is an existing file}"
#}

#   say "passed...";  print -l -- ${^@}
#   say "setting..."; print -l -- ${^@}(e:'[[ -e "${REPLY}" ]]':)
# See remove_file() for further discussion.
# If interactive and the current user has not reconfigured
# ${ZESHY_RM_OPTIONS_IF_INTERACTIVE[@]} and:
#
# * Only one, two, or three files were passed, confirm each such removal.
# * Four or more files were passed, confirm only the first such removal.    #FIXME: Poor implementation. We should, instead, use additional list
    #globals: ${ZESHY_RM_OPTIONS_IF_FEW_ARGUMENTS} and
    #${ZESHY_RM_OPTIONS_IF_MANY_ARGUMENTS}.
        # If the caller passed no more than three files to be deleted, require
        # manual confirmation for each such deletion.
        # If the caller passed at least four files to be deleted *AND* requests
        # interactive confirmation with option "-i", require only one initial
        # confirmation implicitly covering all deletions with option "-I".
        # Otherwise, delete all passed files without confirmation.
#We hereafter use "file" to mean plain file.

    # Localize and validate passed arguments.
#   string source_filename="${1}" target_filename="${1}"
#   die_unless_file "${source_filename}"

    # Copy.
#   then "${copy[@]}" "${CP_OPTIONS_IF_INTERACTIVE}" "${source_filename}" "${target_filename}"
#   setopt local_options
#   die_unless_files "${@}"
#   touch -c -- "${@}"

    # List of filenames filtered from the passed list of pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(.)", excluding non-filenames.
#   list filenames; filenames=( ${^@}(.) )

    # If filenames were filtered from the list of passed pathnames, die.
#   (( "${#filenames}" == "${#@}" )) or
#       die "${2:-\"${filename}\" not all found or not all files}"

#   run_quietly ls -- "${@}" or die ''
#           "$(find "${pathname}" -type f -printf '%A@\t%p\n' | sort -r -k1 | head -n1 | cut -f2)"
#
#   readlink --canonicalize-existing "${1}"
# string which_command(string command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_one_arg 'expected one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        cry "\"${command_name}\" not found"
#        return_false
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# string *get_filenames(string dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_no_or_one_arg 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_arg)"
#       get_next_arg_as filename
