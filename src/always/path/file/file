#!/usr/bin/env zsh
# ====================[ file                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle non-directory files.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_file(
  string pathname,
  string error_message = "\"${pathname}\" not a file")

Throw an exception unless the passed path is an existing non-directory file.
'
function die_unless_file() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file "${pathname}" or die "${2:-\"${pathname}\" not a file}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_file(string pathname)

Return true if the passed path is an existing non-directory file.
'
function is_file() {
    die_unless_args_1 'expected one pathname'
    is -e "${1}" and not -d "${1}" si
}

# ....................{ MAKERS                             }....................
document_function '
void make_file(string filename1, string filename2, ...)

Make all passed files if no such files exist to be zero byte files or throw
an exception if at least one such file exists. See make_file_if_not_found()
for an alternative throwing no such exception.
'
function make_file() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # While Zeshy enables "noclobber" by default, the current user or context
    # may have re-enabled "clobber". For safety, force "noclobber" locally.
    localize_shell_options noclobber

    # For each passed file, attempt to make such file without truncating such
    # file if already extant. Since the simplest means of effecting this is to
    # attempt to redirect zero-length print_string to such file under "noclobber",
    # perform such redirection as the intentional side effect of a noop. While
    # admittedly bizarre, this technique has the advantage of actually working.
    for filename ("${@}") {
        noop > "${filename}"
    }
}

document_function '
void make_file_if_not_found(string filename1, string filename2, ...)

Make all passed files that do not already exist to be zero byte files,
ignoring those that do exist.
'
function make_file_if_not_found() {
    die_unless_args 'expected at least one filename'
    touch -- "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#See remove_file_if_found() for an alternative not throwing such exceptions.
    #FUXME: This doesn't really work.
#   if is_shell_interactive; then
#       option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE'

#       if is_args_1_to_3
#       then option_list_names+=ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3
#       else option_list_names+=ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_AT_LEAST
#       fi
#   else option_list_names+=ZESHY_RM_OPTIONS_IF_SHELL_NONINTERACTIVE
# ....................{ ALIASES                            }....................
#interactive_substitution rm='remove_file'

#FUXME: Not right. Should be passing default and non-interactive "rm" options.
#   run_quietly command rm -- "${@}"
    #FUXME: We should, actually, be utilizing run_with_options(). Do so once we
    #refactor such function to accept a list of options list names.
#   list rm; rm=( command rm "${ZESHY_RM_OPTIONS[@]}" )
#   if is_shell_interactive; then
#       if is_args_1_to_3
#       then rm+=( "${ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3}" )
#       else rm+=( "${ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_AT_LEAST}" )
#       fi

#        "${rm[@]}" "${ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE[@]}" -- "${@}"
#   else "${rm[@]}" "${ZESHY_RM_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" -- "${@}"
#   fi

#FUXME: Not right. Should remove the filetype returned by get_file_type -- not
#simply the rightmost filetype.
# If this filename has a filetype, this excludes only
# the rightmost filetype#   print_string "${1%.*}"
#FUXME: Poor idea. Invites race conditions.
# void die_if_file(
#   string pathname,
#   string error_message = "\"${pathname}\" is an existing file")
#
# Throw an exception if the passed file exists.
#function die_if_file() {
#    die_unless_args_1_to_2\
#        'expected one pathname and optional error message'
#    string pathname="${1}"
#    is_file "${pathname}" and die "${2:-\"${pathname}\" is an existing file}"
#}

#   say "passed...";  print -l -- ${^@}
#   say "setting..."; print -l -- ${^@}(e:'[[ -e "${REPLY}" ]]':)
# See remove_file() for further discussion.
# If interactive and the current user has not reconfigured
# ${ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE[@]} and:
#
# * Only one, two, or three files were passed, confirm each such removal.
# * Four or more files were passed, confirm only the first such removal.    #FUXME: Poor implementation. We should, instead, use additional list
    #globals: ${ZESHY_RM_OPTIONS_IF_FEW_ARGUMENTS} and
    #${ZESHY_RM_OPTIONS_IF_MANY_ARGUMENTS}.
        # If the caller passed no more than three files to be deleted, require
        # manual confirmation for each such deletion.
        # If the caller passed at least four files to be deleted *AND* requests
        # interactive confirmation with option "-i", require only one initial
        # confirmation implicitly covering all deletions with option "-I".
        # Otherwise, delete all passed files without confirmation.
#We hereafter use "file" to mean plain file.

    # Localize and validate passed arguments.
#   string source_filename="${1}" target_filename="${1}"
#   die_unless_file "${source_filename}"

    # Copy.
#   then "${copy[@]}" "${CP_OPTIONS_IF_SHELL_INTERACTIVE}" "${source_filename}" "${target_filename}"
#   setopt local_options
#   die_unless_files "${@}"
#   touch -c -- "${@}"

    # List of filenames filtered from the passed list of pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(.)", excluding non-filenames.
#   list filenames; filenames=( ${^@}(.) )

    # If filenames were filtered from the list of passed pathnames, die.
#   (( "${#filenames}" == "${#@}" )) or
#       die "${2:-\"${filename}\" not all found or not all files}"

#   run_quietly ls -- "${@}" or die ''
#           "$(find "${pathname}" -type f -printf '%A@\t%p\n' | sort -r -k1 | head -n1 | cut -f2)"
#
#   readlink --canonicalize-existing "${1}"
# string which_command(string command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_args_1 'expected one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        cry "\"${command_name}\" not found"
#        return_false
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# string *get_filenames(string dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_args_0_to_1 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_arg)"
#       get_next_arg_as filename
