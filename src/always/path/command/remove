#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle path removal.
/---

#FIXME: O.K. Pretty clearly, the current bifurcation between the coercively
#silent family of path_operation() functions ignoring ${ZESHY_OPTIONS_*_IF_CLI}
#and ${ZESHY_OPTIONS_*_IF_NONCLI} _and_ the verbose family of
#path_operation_with_options() functions respecting such options lists is
#insufficient, and remove_path_recursive() demonstrates exactly why: it's
#excessively dangerous for such function to ignore such options, as we pretty
#much *ALWAYS* want to confirm recursive directory removal with the current user
#if under an interactive shell. Hence, we needed a new
#remove_path_recursive_silent() function dangerously, silently, and recursively
#removing paths and to refactor remove_path_recursive() to basically do the
#exact same thing as remove_path_recursive_with_options() *EXCEPT* that the
#former prefixes passed paths with "--". That's it. Such refactoring actually
#makes sense, unlike the current approach. It's sensible. There *SHOULD* be
#little difference between path_operation() and path_operation_with_options()
#save that the former prohibits options. There *SHOULD* also be a separate
#path_operation_silent() function guaranteeing silence. Excellent. Since
#implementing such changes elsewhere is not going to be altogether fun, approach
#the problem intermittently: refactor one parcel one day, another the next. Yum.

#FIXME: Right. We're currently using the external command "rm", but this isn't
#necessarily ideal. zsh provides an rm() builtin with a great option "-s":
#
#    "The -s option is a zsh extension to rm functionality.  It enables
#     paranoid behaviour, intended to avoid common security problems
#     involving a root-run rm being tricked into removing files other
#     than the ones intended.  It will refuse to follow symbolic links,
#     so that (for example) ``rm /tmp/foo/passwd'' can't accidentally
#     remove /etc/passwd if /tmp/foo happens to be a link to /etc.  It
#     will also check where it is after leaving directories, so that a
#     recursive removal of a deep directory tree can't end up
#     recursively removing /usr as a result of directories being moved
#     up the tree."
#
#At the least, we should prefer the rm() builtin to the "rm" command when
#running as the superuser. Depending on how decent the rm() builtin is, perhaps
#we should *ALWAYS* prefer such builtin -- right?
#
#zsh provides a means of preferring its rm() builtin -- but I'm afraid I can't
#quite recall what it is, at the moment.

#FIXME: It'd be nice to render remove_filename() an uber-powerful meta-remove
#command used in place of "rmdir", "rm -rf *", etc. The essential ideas are:
#
#* Add a config file option ${ZESHY_IS_RECYCLING}, disabled by default but, when
#  enabled, auto-moving all removed files to a new path
#  "${ZESHY_RECYCLE_BIN)/$(date +'%N')/', the former defaulting to
#  "${HOME}/tmp/zeshy.recycled". This effectively guarantees no
#  collision (still test such collision, and simply repeat until non-colliding).
#  I'll probably enable this locally, I imagine. Obviously, such auto-moving
#  such test for sufficient free disk space on the mounted disk to be moved to
#  prior to doing so and fail with error if insufficient disk space remains.
#  *ALSO*, note that no recycling must be done on paths in the recycler: an "rm"
#  within the recycler is always perma-death.
#* Add implicit support for "rmdir". Basically, if the passed path is an empty
#  directory, use "rmdir"; otherwise, either "rm -ri ${DIRNAME}" or
#  "rm -rI ${DIRNAME}", depending on how many files or subdirectories exist
#  in such directory.
#* O.K.; so, we should add a new trash_path(), implementing a trash bin-
#  style move to "~/tmp" (if such path exists) or "/tmp/$(get_user)" if such
#  path is creatable or already exists and is writable by the current user. This
#  suggests a new "file/trash" component with getter get_trash_home(). If
#  trash_path() is called from within get_trash_home(), it should:
#
#  * Die unless interactive.
#  * Manually confirm such removals as under remove_file().
#
#  Since such functionality will doubtless enrage a substantial subset of the zsh
#  populace (and fair enough), this should be subject to a global boolean
#  ${ZESHY_IS_RECYCLING}. Consider adding a new "ZESHY_OPTIONS_RM_IF_RECYCLING",
#  as well. (Though, perhaps we don't need that?) Hmm; but perhaps the existing
#  ${ZESHY_IS_REPLACING_CORE_COMMANDS} suffices.
#
#  Note the implementation needs to be partition-aware; specifically, if the
#  target partition the target path resides on has insufficient space, ask the
#  user whether they'd like to remove-in-place. This requires additional
#  functionality elsewhere; namely:
#
#  * A new get_disk_size() in "device/disk", passed a disk device.
#  * A new get_mount_point_from_path() in "device/disk", passed a pathname. The most
#    efficient implementation for this function is probably to get a list of all
#    mount points, dynamically OR such mount points together into a glob pattern
#    or PCRE, and match such pathname against such pattern. The resulting $match
#    is the desired mount point.
#  * A new get_disk_from_mount_dir_statically() in "device/disk", passed a mount point
#    pathname. The most efficient implementation for this function is probably just
#    to glob the desired column of "blkid -o list" or "mount" for such mount point.
#    No PCRE required. (Canonicalize the passed mount point first, yes? That
#    helpfully removes trailing "/", as well.) Then, just call the following pipeline:
#
#    integer disk_size
#    disk_size="$(get_disk_size "$(get_disk_from_mount_dir_statically "$(get_mount_point_from_path "${pathname}")")")"
#    alias_cli rm='trash_path'
#* Replace "trash" in the prior discussion with "compost", a verb and noun with
#  delectable connotations. Also, it would be quite nice if, much like compost,
#  the compost heap were confined to a user-configurable percentage of total
#  partition size -- defaulting to, say, 10%. Then configuring such percentage
#  to 100% gives default Recycle Bin-like behavior (i.e., unintelligently
#  filling up the entire partition with deleted refuse). The default, of
#  course, behaves much more intelligently. On reaching full capacity, sort the
#  immediate subpaths of the compost heap by ascending date and iteratively
#  delete such subpaths starting from the first in this order until the compost
#  heap subsides beneath the desired threshold. Behavior precisely resembles a
#  genuine compost heap, which rather titillates my obscure fancy.

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: void, status: boolean] remove_path_recursive(
    string pathname1, ...)

Recursively remove the passed paths with the currently configured `rm`-specific
options (e.g., ${ZESHY_OPTIONS_RM}). If any such path does not exist, this
function reports failure.
/---
function remove_path_recursive() {
    remove_path_recursive_with_options -- "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: void, stderr: void, status: boolean] remove_path_recursive_silent(
    string pathname1, ...)

Silently recursively remove the passed paths with the currently configured
`rm`-specific options (e.g., ${ZESHY_OPTIONS_RM}). If any such path does not
exist, this function reports failure.

== Caveats ==

*Consider calling remove_path_recursive() instead.* Such function respects
options configured for interactive use, including default options `-i` and `-I`
interactively confirming such removal. This function _never_ confirms such
removal, despite the inherent risks in recursive path removal. Hence, only call
this function when guaranteed of the contents of such paths.
/---
function remove_path_recursive_silent() {
    die_unless_args 'Expected one or more pathnames.'
    run_code_silent_with_options\
        'command rm' 'ZESHY_OPTIONS_RM ZESHY_OPTIONS_RM_IF_RECURSIVE' --\
        "${(q)@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: void, status: boolean]
    remove_path_recursive_with_options(
        string rm_option1?, ...,
        string pathname1, ...)

Recursively remove the passed paths with both the passed and currently
configured `rm`-specific options (e.g., ${ZESHY_OPTIONS_RM}). If any such path
does not exist, this function reports failure.
/---
function remove_path_recursive_with_options() {
    # Validate sanity.
    die_unless_args 'Expected one or more pathnames.'

    # If interactive, pass interactive-specific options.
    string option_list_names='ZESHY_OPTIONS_RM ZESHY_OPTIONS_RM_IF_RECURSIVE'
    if { is_shell_interactive } {
        option_list_names+=' ZESHY_OPTIONS_RM_IF_INTERACTIVE_AND_ARGS_4_OR_MORE'
    }

    # Remove such paths.
    run_code_with_options_configured\
        'command rm' "${option_list_names}" "${(q)@}"
}

# ....................{ REMOVERS ~ dir                     }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: void, status: boolean] remove_dir_empty(
    string dirname1, ...)

Remove the passed empty directories with the currently configured `rmdir`-specific
options (e.g., ${ZESHY_OPTIONS_RMDIR}). If any such directory does not exist or
is nonempty, this function reports failure.
/---
function remove_dir_empty() {
    remove_dir_empty_with_options -- "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: void, status: boolean] remove_dir_empty_if_found(
    string dirname1, ...)

Remove all passed empty directories with the currently configured
`rmdir`-specific options (e.g., ${ZESHY_OPTIONS_RMDIR}), ignoring directories
that do not exist. If any such existing directory is nonempty, this function
reports failure.
/---
function remove_dir_empty_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more dirnames.'

    #FIXME: This implementation is non-atomic, which is hardly ideal. Are there
    #any alternative atomic implementations?
    #FIXME: Call the helper in "file/path" we recently defined.

    # Filter non-extant directories from the passed directories. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed directory.
    # * "(e:...:), excluding directories failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant directories.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If any extant directories remain, remove such directories.
    if { is_args } {
        remove_dir_empty "${@}"
    }
}

declare_function_with_stdin <<'/---'
[stdout: void, stderr: void, status: boolean] remove_dir_empty_silent(
    string dirname1, ...)

Silently remove the passed empty directories with the currently configured
`rmdir`-specific options. If any such directory does not exist or is nonempty,
this function reports failure.
/---
function remove_dir_empty_silent() {
    die_unless_args 'Expected one or more dirnames.'
    run_code_silent_with_options\
        'command rmdir' ZESHY_OPTIONS_RMDIR -- "${(q)@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: void, status: boolean] remove_dir_empty_with_options(
    string rm_option1?, ...,
    string dirname1 = "$(get_dir)", ...)

Remove the passed empty directories (defaulting to the current directory, if
called directly from the command line) with both the passed and currently
configured `rmdir`-specific options (e.g., ${ZESHY_OPTIONS_RMDIR}). If any such
directory does not exist or is nonempty, this function reports failure.
/---
function remove_dir_empty_with_options() {
    # Validate sanity.
    #
    # If passed no arguments, default to the current directory. By design,
    # avoid the more specific (and seemingly clever) test of whether the caller
    # passed no non-option arguments; callers passing any non-option arguments
    # intend to run "rmdir" traditionally and hence without such defaults.
    if { is_context_cli_function } {
        is_args or set_args "$(get_dir)"
    } else {
        die_unless_args 'Expected one or more dirnames.'
    }

    # Remove such directories.
    run_code_with_options_configured\
        'command rmdir' ZESHY_OPTIONS_RMDIR "${(q)@}"
}

# ....................{ REMOVERS ~ file                    }....................
declare_function_with_stdin <<'/---'
void remove_file(string pathname1, ...)

Silently remove the passed files with the currently configured `rm`-specific
options. If any such file does not exist, throw an exception.
/---
function remove_file() {
    die_unless_args 'Expected one or more filenames.'
    run_code_silent_with_options 'command rm' ZESHY_OPTIONS_RM -- "${(q)@}"
}

declare_function_with_stdin <<'/---'
void remove_file_if_found(string pathname1, ...)

Silently remove all passed extant files with the currently configured `rm`-
specific options, ignoring *nonextant files* (i.e., files that do not exist).
/---
function remove_file_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more filenames.'

    #FIXME: Call the helper in "path/path" we recently defined.

    # Filter non-extant files from the passed files. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed file.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant files.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If at least one such file exists, remove such file(s).
    is_args and remove_file "${@}"
}

declare_function_with_stdin <<'/---'
string remove_file_with_options(
    string rm_option1?, ...,
    string pathname1, ...)

Remove the passed files with both the passed and currently configured `rm`-
specific options. If any such file does not exist, throw an exception.
/---
function remove_file_with_options() {
    # Validate sanity.
    die_unless_args 'Expected one or more filenames.'

    # Since removal options depend on the number of such arguments,
    # run_code_with_options() is insufficient. Implement such logic manually.
    string option_list_names='ZESHY_OPTIONS_RM'
    if { is_context_cli_function } {
        if { is_arg_nonoptions_1_to_3 } {
            option_list_names+=' ZESHY_OPTIONS_RM_IF_INTERACTIVE_AND_ARGS_1_TO_3'
        } else {
            option_list_names+=' ZESHY_OPTIONS_RM_IF_INTERACTIVE_AND_ARGS_4_OR_MORE'
        }
    }

    # Remove such files.
    run_code_with_options_configured\
        'command rm' "${option_list_names}" "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
# Unlike most path operations accepting passed
    # options, do not default to the current directory (for hopefully obvious
    # reasons).
#   die_unless_args 'Expected one or more pathnames.'
#   run_code_with_options_configured\
#       'command rm' 'ZESHY_OPTIONS_RM ZESHY_OPTIONS_RM_IF_RECURSIVE' --\
#       "${(q)@}"

#an (arguably) unsafe evasion given the risks inherent to such removal.
#While this function _never_
#interactively confirms such removal, . Since path removal remains inherently risky,
#remove_path_recursive() is preferrable to this function in most cases.
#carries inherent risk, which. Such function respects options configured
#for interactive use and hence options `-i` and `-I`. and Since  ;  

#FUXME: Split into two files "if_config/option/builtin" and
#"if_config/option/posix". Of course, the line is a bit blurry between the two;
#but this file's simply become too lengthy to retain as a conglomerate file.
    #FUXME: This should be "is_shell_cli", instead.

#declare_function '
#string remove_file_with_optionsconfigured(
#  string pathname1, string pathname2, ...)
#
#Remove the passed files with the currently configured "rm"-specific options,
#throwing an exception if any such file does not exist.
#'
#function remove_file_with_optionsconfigured() {
#    remove_file_with_options -- "${(q)@}"
#}

#FUXME: Implementation isn't quite right: we only want to ignore the path if not
#found; if the path is found but is *NOT* empty, we still want to throw an exception.

#(i.e., contains at least one subdirectory or file).
#   run_code_with_options 'command rmdir' ZESHY_OPTIONS_RMDIR "${(q)@}"

#Remove all passed directories if all such directories exist and
#are empty  or throw an exception if at
#least one such directory  See
#remove_dir_empty_if_found() for an alternative throwing no such exception.

#   run_code_silent run_code_with_options 'command rm'\
#       'ZESHY_OPTIONS_RM ZESHY_OPTIONS_RM_IF_SHELL_NONINTERACTIVE' -- "${(q)@}"

#       if set_integer_to_arg_nonoption_count __nonoptions__ and
#           (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
    # Validate sanity.
#   die_unless_args 'expected at least one filename'

    # Since removal options depend on the number of such arguments,
    # run_code_with_options() is insufficient. Implement such logic manually.
#   string option_list_names='ZESHY_OPTIONS_RM'
#   is_shell_interactive && {
#       if is_args_1_to_3
#       then option_list_names+=' ZESHY_OPTIONS_RM_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3'
#       else option_list_names+=' ZESHY_OPTIONS_RM_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'
#       fi
#   }

    # Remove such files.
#   run_code_with_optionsconfigured\
#       'command rm' "${option_list_names}" -- "${(q)@}"

#FUXME: This function should *NOT* be called by copy_file() or move_file() --
#only by the subsidiary copy_file_with_optionsconfigured()-style functions.
