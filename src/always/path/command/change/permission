#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *path permission changers* (i.e., functions changing path permissions).
/---

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
string set_path_permissions(
    string pathname1, ...,
    string permissions)

Silently change the permissions of all passed paths with the passed permissions
under currently configured `chmod`-specific options. Specify such permissions in
either machine-readable (e.g., 0711) or human-readable format (e.g., `ugo+rX`).
If any such path does not exist, an exception is thrown. See `man chmod` for
further details on permission formats: e.g.,

.set_path_permissions()
==========================================
[source]
------------------------------------------
>>> set_path_permissions "/ogallala/yucca" ugo-rwx
>>> cd /ogallala/yucca
cd: permission denied: /ogallala/yucca
------------------------------------------
==========================================
/---
function set_path_permissions() {
    # Validate sanity.
    die_unless_args_2 'Expected one path and one permissions string.'
    string permissions="${@[-1]}"
    pop_arg

    # Change such permissions.
    run_code_silent_with_options\
        'command chmod' ZESHY_OPTIONS_CHMOD -- "${permissions}" "${(q)@}"
}

declare_function_with_stdin <<'/---'
void set_path_permissions_with_options(
    string chmod_option1?, ...,
    string permissions,
    string source_pathname1 = "$(get_dir)/"{.,*}, ...)

Change the permissions of all passed paths (defaulting to the current directory
and all immediate paths in such directory, if called directly from the command
line) with the passed permissions under both the passed and currently configured
`chmod`-specific options. See set_path_permissions() for further details.
/---
function set_path_permissions_with_options() {
    # Validate sanity.
    if { is_context_cli_function } {
        die_unless_args_1_or_more\
            'Expected optional "chmod" options, one permissions string, and optional pathnames.'

        # If passed no paths, default to the current directory and paths in it.
        set_integer_to_arg_nonoption_count arg_nonoption_count
        (( arg_nonoption_count == 1 )) and append_arg "$(get_dir)/"{.,*}
    } else {
        die_unless_args_2_or_more\
            'Expected optional "chmod" options, one permissions string, and one or more pathnames.'
    }

    # Change such permissions.
    run_code_with_options_configured\
        'command chmod' ZESHY_OPTIONS_CHMOD "${(q)@}"
}

# ....................{ SETTERS ~ recursive                }....................
declare_function_with_stdin <<'/---'
string set_path_permissions_recursive(
    string pathname1, ...,
    string permissions)

Silently change the permissions of all passed paths recursively with the passed
permissions under currently configured `chmod`-specific options. See
set_path_permissions() for further details.
/---
function set_path_permissions_recursive() {
    append_list_with_list_locally_from\
        'ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE'
    set_path_permissions "${@}"
}

declare_function_with_stdin <<'/---'
void set_path_permissions_recursive_with_options(
  string chmod_option1?, ...,
  string permissions,
  string source_pathname1 = "$(get_dir)", ...)

Change the permissions of all passed paths (defaulting to the current directory,
if called directly from the command line) recursively with the passed
permissions under both the passed and currently configured `chmod`-specific
options. See set_path_permissions() for further details.
/---
function set_path_permissions_recursive_with_options() {
    # Validate sanity.
    set_integers_to_arg_nonoption_count_and_index_first\
        'arg_nonoption_count arg_nonoption_index_first'
    if { is_context_cli_function } {
        die_unless_args_1_or_more\
            'Expected optional "chmod" options, one permissions string, and optional pathnames.'

        # If passed no paths, default to the current directory. 
        if (( arg_nonoption_count == 1 )) {
            # Increment the number of passed arguments to ensure sanity below.
            arg_nonoption_count+=1
            append_arg "$(get_dir)"
        }
    } else {
        die_unless_args_2_or_more\
            'Expected optional "chmod" options, one permissions string, and one or more pathnames.'
    }

    # If the current shell is interactive, return non-zero exit status unless
    # the current user interactively affirms such changes. Recursively changing
    # permissions is often permanently harmful and hence deserves confirmation.
    if { is_shell_interactive } {
        string paths\
            permissions="${@[${arg_nonoption_index_first}]}"\
             first_path="${@[$(( arg_nonoption_index_first + 1 ))]}"

        # Set the question to be asked depending on the number of passed paths.
        paths="\"${first_path}\""
#       print "count: ${arg_nonoption_count}"
        if (( arg_nonoption_count > 2 )) {
            paths+=', ...'
        }

        # Confirm such change.
        is_query_character_yes\
            "Recursively change permissions of ${paths} to ${permissions}?" or
            report_failure
    }

    # Change such permissions.
    run_code_with_options_configured 'command chmod'\
        'ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE' "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#       then  to ${permissions}?"
#       else question "recursively change permissions of \"${first_path}\", etc. to ${permissions}?"
#       fi

#FUXME: Recursive path changing can be dangerous. Interactively confirm such
#changes (but don't bother with non-recursive path changing).

    #FUXME: Replace with call to append_list_with_lists_locally(), as below.
    # Recursively change permissions by delegating to set_path_permissions(),
    # temporarily appending recursive options to ${ZESHY_OPTIONS_CHMOD}.
#   list options; options=(
#       "${ZESHY_OPTIONS_CHMOD[@]}"
#       "${ZESHY_OPTIONS_CHMOD_IF_RECURSIVE[@]}"
#   )
#   list ZESHY_OPTIONS_CHMOD; ZESHY_OPTIONS_CHMOD=( "${options[@]}" )
#       then paths="recursively change permissions of \"${first_path}\" to ${permissions}?"
#       else question "recursively change permissions of \"${first_path}\", etc. to ${permissions}?"
#
#function set_path_permissions_recursive_with_options() {
#    append_list_with_list_locally\
#        ZESHY_OPTIONS_CHMOD ZESHY_OPTIONS_CHMOD_IF_RECURSIVE
#    set_path_permissions_with_options "${@}"
#}

#declare_function '
#string set_path_permissions_with_options(
#  string option1, string option2, ...,
#  string permissions,
#  string path1 = "$(get_dir)", string path2, ...)
#
#Change the permissions of the passed paths (defaulting to the current
#directory) via the passed permission specifier and "chmod" options. See
#set_path_permissions() or "man chmod" for further details.
#'
#function set_path_permissions_with_options() {
#    # Validate passed arguments.
#    die_unless_args 'expected one permissions string and at least one path'
#
#    #FUXME: Insufficient. The user could have passed arguments "-R" and "go+X",
#    #in which case at least two arguments were passed but none of them a proper
#    #path. To test this properly, first temporarily remove all passed arguments
#    #prefixed with "-" and *THEN* test the number of arguments: if still only
#    #one, then, indeed, we do need to append the current directory.
#
#    # If passed one argument, default the path to the current working directory.
#    is_one_arg and append_arg "$(get_dir)"
#
#    # Change permissions.
#    run_code_with_options 'command chmod' ZESHY_OPTIONS_CHMOD "${(q)@}"
#}

# ....................{ CHANGERS                           }....................
#FUXME: Shift pertinent "../permission" functionality here.
#FUXME: Argument order is appropriate when called interactively but not non-
#interactively. Each such function should accept only two arguments.
