#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle path user and group changes.
/---

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
string set_path_user_and_group(
    string pathname1, ...,
    string user_and_group)

Silently set the user and/or group of all passed paths with the passed `:`-
delimited ownership under currently configured `chown`-specific options. Specify
such ownership as an optional username, optional `:`, and optional groupname. If
any such path does not exist, throw an exception. See `man chown` for further
details on such strings: e.g.,

.set_path_user_and_group()
==========================================
[source]
------------------------------------------
# Passing both a user and group.
>>> set_path_user_and_group "/battle/of/bannockburn" bruce:scotland
# Passing only a user and colon, equivalent to passing "bruce:bruce".
>>> set_path_user_and_group "/battle/of/bannockburn" bruce:
# Passing only a user.
>>> set_path_user_and_group "/battle/of/bannockburn" bruce
# Passing only a group.
>>> set_path_user_and_group "/battle/of/bannockburn" :scotland
------------------------------------------
==========================================
/---
function set_path_user_and_group() {
    # Validate sanity.
    die_unless_two_args 'Expected one path and one ownership string.'
    string ownership="${@[-1]}"
    pop_arg

    # Change such ownership.
    run_code_silent_with_options\
        'command chown' ZESHY_OPTIONS_CHOWN -- "${ownership}" "${(q)@}"
}

declare_function_with_stdin <<'/---'
void set_path_user_and_group_with_options(
    string chown_option1?, ...,
    string ownership,
    string source_pathname1 = "$(get_dir)/"{.,*}, ...)

Set the user and/or group of all passed paths (defaulting to all paths in the
current directory including such directory) with the passed ":"-delimited
ownership under both the passed and currently configured "chown"-specific
options. See set_path_user_and_group() for further details.
/---
function set_path_user_and_group_with_options() {
    # Validate sanity.
    die_unless_args_1_or_more\
        'Expected one ownership string and optional pathnames.'

    # If passed no paths, default to the current directory and all paths in it.
    set_integer_to_arg_nonoption_count arg_nonoption_count
    (( arg_nonoption_count )) or append_arg "$(get_dir)/"{.,*}

    # Change such ownership.
    run_code_with_options_configured\
        'command chown' ZESHY_OPTIONS_CHOWN "${(q)@}"
}

# ....................{ SETTERS ~ recursive                }....................
declare_function_with_stdin <<'/---'
string set_path_user_and_group_recursive(
    string pathname1, ...,
    string user_and_group)

Set the user and/or group of all passed paths recursively with the
passed ":"-delimited ownership under currently configured "chown"-specific
options. See set_path_user_and_group() for further details.
/---
function set_path_user_and_group_recursive() {
    #FIXME: Call set_path_user_and_group_recursive_with_options() instead. This
    #is silly. Clearly, we were attempting to avoid the interactive query such
    #function leverages; since such query only pertains to CLI calls, however,
    #there's no tangible reason to *NOT* just call such function.
    append_list_with_list_locally_from\
        'ZESHY_OPTIONS_CHOWN ZESHY_OPTIONS_CHOWN_IF_RECURSIVE'
    set_path_user_and_group "${@}"
}

declare_function_with_stdin <<'/---'
void set_path_user_and_group_recursive_with_options(
    string chown_option1?, ...,
    string user_and_group,
    string source_pathname1 = "$(get_dir)", ...)

Set the user and/or group of all passed paths (defaulting to the current
directory) recursively with the passed ":"-delimited ownership under both the
passed and currently configured "chown"-specific options. See
set_path_user_and_group() for further details.
/---
function set_path_user_and_group_recursive_with_options() {
    # Validate sanity.
    die_unless_args_1_or_more\
        'Expected one ownership string and optional pathnames.'

    # If passed no paths, default to the current directory.
    set_integers_to_arg_nonoption_count_and_index_first\
        'arg_nonoption_count arg_nonoption_index_first'
    (( arg_nonoption_count )) or {
        append_arg "$(get_dir)"

        # Increment the number of passed arguments to ensure sanity below.
        arg_nonoption_count+=1
    }

    # If the current shell is interactive, return non-zero exit status unless
    # the current user interactively affirms such changes. Recursively changing
    # ownership is often permanently harmful and hence deserves confirmation.
    if { is_context_cli_function } {
        # A synopsis of the passed paths for prompt purposes.
        string paths ownership="${@[${arg_nonoption_index_first}]}"
        paths="\"${@[$(( arg_nonoption_index_first + 1 ))]}\""
        if (( arg_nonoption_count > 2 )) {
            paths+=', ...'
        }

        # Confirm such change.
        is_query_character_yes\
            "Recursively change ownership of ${paths} to ${ownership}?" or
            report_failure
    }

    # Change such ownership.
    run_code_with_options_configured 'command chown'\
        'ZESHY_OPTIONS_CHOWN ZESHY_OPTIONS_CHOWN_IF_RECURSIVE' "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#   >>> remove_path_recursive "/battle/of/bannockburn"
#   rm: permission denied: /battle/of/bannockburn
