#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'---'
Handle *path grepping* (i.e., recursive pattern matching on file content).
---

#FIXME: Define is_path_matches_grep() and is_path_matches_grep_recursive() to
#*SILENTLY* grep such paths. Don't bother accepting "grep" arguments: these
#functions are solely for non-interactive use.

#FIXME: It'd be nice to emit a progress bar for long `grep` operations. Investigate.
#Yes. It looks like this is halfway there:
#   find . -name "*.rb" | pv | xargs grep
#Note that we should use "zargs" instead, that we'll need to explicitly pass
#the total number of files to "pv" (...perhaps it has a mode or option for
#this already), and that...uhm. Well, it'll be a bit of work, anyway! But
#it's well doable.
#FIXME: Hmmmm; actually, the above command could significantly alter the semantics
#(or at least output content, which is quite relevant for scripting
#purposes). That said, implementing a zsh analogue to the above in a *NEW*
#function named something resembling
#grep_path_recursive_progressively_with_options() seems an excellent idea.
#Note this also solves the issue under default recursion of fatal errors on
#broken symlinks and such, which is quite nice.

# ....................{ GREPERS                            }....................
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] string grep_path(
    string pathname1, ...,
    string pattern)

Search the contents of the passed text files for the passed pattern with
currently configured `grep`-specific options, returning success if at least one
such file matches and failure otherwise. If any such file does not exist, an
exception is thrown: e.g.,

.grep_path()
==========================================
[source]
------------------------------------------
>>> grep_path /proc/* "matthew@sobol"
/proc/version: Linux version 3.6.11-gentoo (matthew@sobol) (gcc version 4.6.3)
------------------------------------------
==========================================
/---
function grep_path() {
    # Validate sanity.
    die_unless_args_2_or_more 'Expected one or more filenames and one pattern.'
    string pattern="${@[-1]}"
    pop_arg

    # Grep such paths.
    run_code_with_options 'run_code_paged command grep' ZESHY_OPTIONS_GREP --\
        "${(q)pattern}" "${(q)@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] grep_path_with_options(
    string grep_option1?, ...,
    string pattern,
    string pathname1 = "$(get_dir)/*(-.)", ...)

Search the contents of the passed text files (defaulting to all text files in
the current directory after resolving symbolic links, if called directly from
the command line) for the passed `grep` pattern with both the passed and
currently configured `grep`-specific options, returning success if at least one
such file matches and failure otherwise. See grep_path() for further details.
/---
function grep_path_with_options() {
    # Validate sanity. If called from the command line and passed only such
    # pattern, default pathnames to all text files in the current directory.
    if { is_context_cli_function } {
        die_unless_args_1_or_more\
            'Expected optional "grep" options, one pattern, and optional pathnames.'
        set_integer_to_arg_nonoption_count arg_nonoption_count

        if (( arg_nonoption_count == 1 )) {
            list filenames
            set_list_to_dir_files_text filenames "$(get_dir)"
            append_arg "${filenames[@]}"
        }
    } else {
        die_unless_args_2_or_more\
            'Expected optional "grep" options, one pattern, and one or more pathnames.'
    }

    # Grep such paths.
    run_code_with_options_configured\
        'run_code_paged command grep' ZESHY_OPTIONS_GREP "${(q)@}"
}

# ....................{ GREPERS ~ recursive                }....................
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] grep_path_recursive(
    string pathname1, ...,
    string pattern)

Grep the passed paths (defaulting to the current directory) for the passed
pattern recursively with both the passed and currently configured `grep`-
specific options. See grep_path() for further details.
/---
function grep_path_recursive() {
    grep_path_recursive_with_options -- "${@[-1]}" "${@[1,-2]}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] grep_path_recursive_with_options(
    string grep_option1?, ...,
    string pattern,
    string pathname1 = "$(get_dir)", ...)

Grep the passed paths (defaulting to the current directory, if called directly
from the command line) for the passed pattern recursively with both the passed
and currently configured `grep`- specific options. See grep_path() for further
details.
/---
function grep_path_recursive_with_options() {
    # Validate sanity. If passed only a pattern, note that `grep`
    # already defaults to the current directory. Hence, do not manually append
    # either "." or "$(get_dir)" to the current argument list, which
    # slightly reduces output verbosity.
    if { is_context_cli_function } {
        die_unless_args_1_or_more\
            'Expected optional "grep" options, one pattern, and optional pathnames.'
    } else {
        die_unless_args_2_or_more\
            'Expected optional "grep" options, one pattern, and one or more pathnames.'
    }
    list command

    #FIXME: Not the best interactive message. Rather, this should resemble:
    #
    #    print_message_item_interactively\
    #        "Grepping $(join_strings_readably "${pathnames[@]}") for \"${pattern}\"..."
    #
    #Naturally, this requires ignoring any prefixing passed options. Certainly
    #feasible via set_list_to_dir_files_text() (as above); just have to do it!

    # The conditional below first runs `grep` silently. To (slightly) improve
    # the user experience, print a brief message first.
    print_message_item_interactively\
        "Grepping $(join_strings_readably "${@}")..."

    # Command to be run, *EXCLUDING* prefixing command name. To accommodate
    # multiple executions of such command, we manually add such command name
    # back below.
    command=(
        'ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_RECURSIVE'
        "${(q)@}"
    )

    # Silently dry-run such search before performing such search below. For
    # numerous common cases many users would not consider to constitute fatal
    # errors (e.g., broken symbolic links, subdirectories unreadable by the
    # current user), the former returns zero exit status and the latter non-
    # zero. To avoid throwing an exception for non-fatal errors, dry-run such
    # search first and fail *ONLY* if such dry-run fails. Assuming default
    # ${ZESHY_GREP_IF_SILENT} options, the dry-run enables options "-qs".
    #
    # Bang-up job, esteemable `grep` authors.
    run_code_silent_with_options 'command grep' "${command[@]}" or
        return_exit_status

    # Perform such search. Since the prior search already guarantees non-zero
    # exit status on fatal error, force zero exit status and hence success here.
    run_code_with_options_configured\
        'run_code_paged command grep' "${command[@]}" or ignore_failure
}

# ....................{ GREPERS ~ caseless                 }....................
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] grep_path_caseless(
    string pathname1, ...,
    string pattern)

Grep the passed paths for the passed case-insensitive pattern with currently
configured `grep`-specific options. See grep_path() for further details.
/---
function grep_path_caseless() {
    append_list_with_list_locally_from\
        'ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_CASELESS'
    grep_path "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] grep_path_caseless_with_options(
    string grep_option1?, ...,
    string pattern,
    string pathname1 = "$(get_dir)", ...)

Grep the passed paths (defaulting to the current directory) for the passed
case-insensitive pattern with both the passed and currently configured `grep`-
specific options. See grep_path() for further details.
/---
function grep_path_caseless_with_options() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with grep_path_recursive_caseless_with_options().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Instruct grep_path_with_options() to ignore the call to this function for
    # purposes of testing zsh context and hence whether or not argument defaults
    # are applicable. See is_context_cli_function() for further details.
    ignore_context_function_call

    # Grep such path(s).
    append_list_with_list_locally_from\
        'ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_CASELESS'
    grep_path_with_options "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] grep_path_recursive_caseless_with_options(
    string grep_option1?, ...,
    string pattern,
    string pathname1 = "$(get_dir)", ...)

Grep the passed paths (defaulting to the current directory) for the passed
case-insensitive pattern recursively with both the passed and currently
configured `grep`-specific options. See grep_path() for further details.
/---
function grep_path_recursive_caseless_with_options() {
    # See grep_path_caseless_with_options() for further details.
    ignore_context_function_call
    append_list_with_list_locally_from\
        'ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_CASELESS'
    grep_path_recursive_with_options "${@}"
}

#FIXME: In lieu of unit tests...
#function gree() {
#    grep_path_recursive_caseless_with_options "$(get_home)/tmp" 'oeu'
#}

# ....................{ GETTERS                            }....................
#FIXME: The current implementation pretty suck. Stop using "--pcre-regexp"
#and just use the "ZESHY_OPTIONS_GREP" default. Ah; right. We can pretty much
#cut the whole implementation and replace with a much simpler call to
#run_code_with_options(). Out with the verbosely old; in with the briefly new!

declare_function_with_stdin <<'/---'
integer get_path_subpaths_matching_grep_count(
    string pathname1, ...,
    string pattern)

Get the number of matches in the passed string. Among other uses, this
function counts occurrences of characters and substrings in strings: e.g.,

    #FIXME: Uhm, what? Did I eat the rest of this example?
    >>> get_grep_match_count
    2
/---
function get_path_subpaths_matching_grep_count() {
    #FIXME: Uhm; what? The function signature fails to correspond to the current
    #implementation. *UGH* <~~~ our feelings in relation to this function
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one or more pathnames and one grep expression.'
    string pattern="${@[-1]}" string_newlined
    pop_arg

    #FIXME: This is *TERRIBLE*. No, really. ${string} used to be a single passed
    #path. But we now accept any number of passed paths, so this doesn't apply.
    #Did I also mention it's terrible?

    # Escape """ and "~" characters in the passed string, in preparation for
    # replacement by "sed".
    string="${string//\"/\\\"}"
    string="${string//\~/\\~}"

    # This exceptionally clever (and frankly obscene) logic comes inspired by
    # StackOverflow user "user216915" via this question:
    #
    #     http://stackoverflow.com/questions/1781329/count-the-number-of-occurrences-of-a-string-using-sed
    #
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences regardless of newline; rather, they only
    # match each such occurence as a newline-specific group. This hack uses this
    # newline obsession by replacing each match with that match suffixed by a
    # newline. This guarantees no more than one match occupies each line.
    #
    # Finally, feeding the result into "grep -c" counts the number of such lines
    # and hence the number of matches. (Yeth, this sucketh mightily.)
#   print "sed expression: s/${(q)pattern}/${(q)pattern}\n/g"
    string_newlined="$(print "${string}" | sed --patternp-extended "s~(${pattern})~\1\n~g")"
#   die_unless_ok "string \"${string}\" or regular expression \"${pattern}\" malformed"
#   print "string_newlined: ${string_newlined}"

    # If "sed" said nothing, then neither should we.
    if { is "${string}" == "${string_newlined}" si } {
        return_string 0
    } else {
        output_string "${string_newlined}" |
            command grep --perl-patternp --count "${pattern}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: To comply with zeshy nomenclature, globally rename "\bgrep_path" to
#"is_path_matches_grep". This is important, as we'll probably eventually add
#"is_path_matches_glob" and "is_path_matches_pcre" variants of such functions.

#FUXME: Globally rename "_recursive" to "_recursive" and "_caseless" to
#"_caseless".
    #FUXME: Fix default option handling. Not quite sure how, however. The
    #simplest solution would be to define a boolean local
    #${ZESHY_IS_CONTEXT_CLI_FUNCTION} here defined according to the state of
    #is_context_cli_function() in this function *AND* then to change the
    #conditional test in grep_path_recursive_with_options() to:
    #
    #    if { is_context_cli_function or
    #       (( ${ZESHY_IS_CONTEXT_CLI_FUNCTION-0} )) {
    #FUXME: Such functionality should be extended to grep_path_with_options() as
    #well.

#FUXME: Rename to something consonant with zeshy nomenclature -- say,
#get_path_

#While
#grep_path() returns success only if at least one such file matches such pattern,
#this function _always_ returns success to avoid unhelpful exceptions .

    #FUXME: It'd actually be better to run the first grep with a progress bar of
    #some sort.
#   join_list_on_newline ZESHY_OPTIONS_GREP
#FUXME: Re-enable after improving grep_path() for safety. We need grep_path()
#to succeed on receiving piped input: e.g.,
#
#  find /bin /sbin /usr/bin /usr/sbin -type l | xargs ls -l | grep busybox
#
#The prior command currently fails. Prefixing `grep` with "command" succeeds,
#however. Hence, something is awry. Ah, yes -- it's fairly obvious: `grep`
#either requires file arguments or standard input and no arguments. But die_*()
#aliases set arguments, by default. So, we need to cease using die_*(), test the
#passed args manually, test if stdin is piped (is_stdin_pipe), and if so
#propagate the pipe on to grep. Since this is becoming a common theme, perhaps:
#
#  alias propagate_piped_input='cat /dev/stdin |'  # --OR--
#  alias run_code_with_stdin_piped='cat /dev/stdin |'   # --OR--
#  alias run_code_with_stdin_piped='cat /dev/stdin |'
#
#Yeah. The latter one rocks. Let's adopt that one.

#alias_cli_substitution {g}rep='grep_path'

# ....................{ GREP ~ old                         }....................
#FUXME: Again, this is terrible. We really want to be using run_code_with_options().
#FUXME: The order of arguments is wrong. Shift the paths to before the pattern.
#declare_function '
#string grep_path_caseless(string grep_arg1, string grep_arg2, ...)
#
#Match the contents of the passed files against the passed `grep` pattern case-
#insensitively.
#'
#function grep_path_caseless() {
#    # Append "-i" to ${ZESHY_OPTIONS_GREP} for the duration of this call.
#    list zeshy_grep_options; zeshy_grep_options=( "${ZESHY_OPTIONS_GREP[@]}" -i )
#    list ZESHY_OPTIONS_GREP; ZESHY_OPTIONS_GREP=( "${zeshy_grep_options[@]}" )
#    grep_path "${@}"
#}

# ....................{ GREP ~ recursive                   }....................
#declare_function '
#string grep_path_recursive_caseless(
#  string pattern, string pathname = "$(get_dir)")
#
#Recursively match the contents of all files in the passed paths (defaulting to
#the current working directory) against the passed `grep` pattern case-
#insensitively.
#'
#function grep_path_recursive_caseless() {
#    # Append "-ri" to ${ZESHY_OPTIONS_GREP} for the duration of this call.
#    list zeshy_grep_options; zeshy_grep_options=( "${ZESHY_OPTIONS_GREP[@]}" -ri )
#    list ZESHY_OPTIONS_GREP; ZESHY_OPTIONS_GREP=( "${zeshy_grep_options[@]}" )
#    is_args_1 and append_arg "${PWD}"
#    grep_path "${@}"
#}

#FUXME: The grep_path_recursive() implementation should just defer to
#grep_path_recursive_with_options() much like in "list".

#declare_function '
#string grep_path_old(string pattern, string pathname1, string pathname2, ...)
#
#Match the contents of the passed pathnames (defaulting to all plain files in
#the current directory) against the passed grep expression: e.g.,
#
#    # Grep all text files in the current directory for the passed string.
#    >>> grep_path "Matthew*Sobol"
#'
#function grep_path_old() {
    # Mimic run_code_with_options(). Unfortunately, grep's eccentric runtime behavior
    # precludes our calling that function directly.
#    die_unless_args 'expected at least one grep pattern'
#    list grep; grep=( command grep "${ZESHY_OPTIONS_GREP[@]}" )

#    if is_shell_interactive
#    then grep+=( "${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}" )
#    else grep+=( "${ZESHY_OPTIONS_GREP_IF_SHELL_NONINTERACTIVE[@]}" )
#    fi

    #FIXME: Should really be all plaintext plain files. Unsure how to test
    #efficiently... grep the forums.
    # Default to all plaintext files in the current directory, if needed.
#    is_args_1 and append_arg "${^PWD}/"*(.)

    #FIXME: Clever, but insufficient. Unfortunately, conditional
    #'if "${grep[@]}" -qs -- "${(q)@}"' still fails when called recursively
    #and at least one subdirectory of a passed directory is not readable by the
    #current user, in the same way that "ls" fails. This is silly. The solution
    #is the same as under "ls": exclude paths to which the current user has no
    #permissions or which are broken symbolic links. (It'd be helpful to print
    #warning messages for each excluded path, but by no means necessary under an
    #initial implementation. Actually, this shouldn't be terribly hard to
    #implement, no? Since we'd like to perform such printing elsewhere, we'd
    #probably want to encapsulate such printing as an alias or function.
    #Consider.)
    #FIXME: This is pointless for non-recursive operation, since we can simply
    #manually exclude broken symbolic links and non-readable files. That said,
    #we probably shouldn't do *ANY* of that for non-recursive operation. When
    #non-recursive, users expect actual errors on such files... so, shift all of
    #this to grep_path_recursive().
    #FIXME: Actually, this block works to ignore both broken links and non-
    #readable paths, which is quite sweet. Cleverness. Definitely preserve for
    #recursive use.

    # Grep such paths. Since `grep` fails if at least one of the passed paths is
    # a broken symbolic link despite such links *NOT* signifying a true `grep`
    # failure, ignore such links by preemptively running the same `grep` command
    # with additional options "-qs" squelching output. Such preemptive  and hence only helpful in returning the proper exit code.Since `grep` fails to emit helpful messages on failure,
    # do so. Unfortunately, detecting failure is more cumbersome than it need
    # be. 
    # # For efficiency, perform such testing prior to running the real `grep`
    # command printing proper output. If such testing succeeds, force `grep`
    # to return success. (Yes, this is all incredibly, indelibly non-
    # sensical. Thanks, GNU `grep`. Bang-up job there.)
    #
    # For safety, quote-protect the sanity. (Otherwise, `grep` fails
    # to receive whitespace in grep expressions.)
#    if "${grep[@]}" -qs -- "${(q)@}"
#       print_message "running \"${grep[@]} -- ${@}\" paged..."
#    then run_code_paged "${grep[@]}" -- "${(q)@}" or true
    #FIXME: Truncate such list to produce reasonable output.
#    else die\
#        "\"${1}\" not found in $(join_strings_readably "${@[2,-1]}")"
#    fi
#}

    #FUXME: Actually, I bet we can do this by reconstituting the bloody thing
    #twice. It's not *TOO* heavy-weight, is it? Just give it a go. Because this
    #is way too heavy-weight on the developer end.

    #FUXME: It'd be nice to return the actual failure code. I believe we could
    #run the above statement in a subshell preceded by run_code_and_get_exit_status(),
    #yes? Come to think, it'd be devilishly easy to define a new
    #run_code_silent_with_options_and_get_exit_status() function.
    #FUXME: Ah; actually, it'd be much simpler to define a new
    #return_prior_exit_status_if_nonzero<> alias. Note this alias should expand
    #to true otherwise, to allow the above conditional to continue working.
#   else return_failure
#   fi

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #NEW, but old
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Mimic run_code_with_options(). Unfortunately, the eccentric runtime behavior of
    # POSIX `grep` precludes calling that function directly. AND NOW YOU KNOW
    # WHY WE DON'T MANUALLY RE-IMPLEMENT run_code_with_options(), EVERYWHERE.
    #
    # Validate sanity. If passed only a pattern, note that `grep`
    # already defaults to the current directory. Hence, do not manually append
    # either "." or "$(get_dir)" to the current argument list, which
    # slightly reduces output verbosity.
#   die_unless_args_1_or_more 'expected one pattern and optional paths'

    # Command to be run.
#   list command__gprwo

    # If passed piped input, propagate such input to the command to be run.
#   is_stdin_pipe and command__gprwo+=( cat '/dev/stdin' \| )

    # Append the actual command.
#   command__gprwo+=( command grep )

    # List of option list names to be interpolated below.
#   list options_list__gprwo; options_list__gprwo=( ZESHY_OPTIONS_GREP )

    # If an options list with name corresponding to whether the current shell is
    # interactive or not exists, append such name to the passed list of such
    # names if such list exists.
#   string options_list_name__gprwo
#   if is_shell_interactive
#   then options_list_name__gprwo="ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE"
#   else options_list_name__gprwo="ZESHY_OPTIONS_GREP_IF_SHELL_NONINTERACTIVE"
#   fi
#   is_list "${options_list_name__gprwo}" and
#       options_list__gprwo+="${options_list_name__gprwo}"

    # For each options list name, append the contents of such list to such
    # command or print a warning if no such list exists.
#   for options_list_name__gprwo ("${options_list__gprwo[@]}") {
#       if is_list "${options_list_name__gprwo}"
#       then command__gprwo+=( "${(@P)options_list_name__gprwo}" )
#       else print_warning "\"${options_list_name__gprwo}\" not a list"
#       fi
#   }

    # Append all remaining sanity to such command.
#   command__gprwo+=( "${(q)@}" )

    # Grep such paths. Since `grep` fails if at least one of the passed paths is
    # a broken symbolic link despite such links *NOT* signifying a true `grep`
    # failure, ignore such links by preemptively running the same `grep` command
    # with additional options "-qs" squelching output. Such preemptive  and hence only helpful in returning the proper exit code.Since `grep` fails to emit helpful messages on failure,
    # do so. Unfortunately, detecting failure is more cumbersome than it need
    # be. 
    #
    # For efficiency, perform such testing prior to running the real `grep`
    # command printing proper output. If such testing succeeds, force `grep`
    # to return success. (Yes, this is all incredibly, indelibly non-
    # sensical. Thanks, GNU `grep`. Bang-up job there.)
    #
    # For safety, quote-protect the sanity. (Otherwise, `grep` fails
    # to receive whitespace in grep expressions.)
#   if "${command__gprwo[@]}" -qs -- "${(q)@}"
#       print_message "running \"${grep[@]} -- ${@}\" paged..."
#   then run_code_paged "${command__gprwo[@]}" -- "${(q)@}" or true
    #FUXME: Truncate such list to produce reasonable output.
#   else die\
#       "\"${1}\" not found in $(join_strings_readably "${@[2,-1]}")"
#   fi

    # Grep such paths.
#   print_string "run_code_with_options: \"${command__rwo[*]}\"..."
#   run "${command__gprwo[@]}"

    # Grep such paths.
#   run_code_with_options_configured 'command grep' ZESHY_OPTIONS_GREP "${(q)@}"

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #OLD
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Mimic run_code_with_options(). Unfortunately, grep's eccentric runtime behavior
    # precludes our calling that function directly.
#   die_unless_args 'expected at least one grep pattern'
#   list grep; grep=( command grep "${ZESHY_OPTIONS_GREP[@]}" )

#   if is_shell_interactive
#   then grep+=( "${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}" )
#   else grep+=( "${ZESHY_OPTIONS_GREP_IF_SHELL_NONINTERACTIVE[@]}" )
#   fi

    #FUXME: Should really be all plaintext plain files. Unsure how to test
    #efficiently... grep the forums.
    # Default to all plaintext files in the current directory, if needed.
#   is_args_1 and append_arg "${^PWD}/"*(.)

    #FUXME: Clever, but insufficient. Unfortunately, conditional
    #'if "${grep[@]}" -qs -- "${(q)@}"' still fails when called recursively
    #and at least one subdirectory of a passed directory is not readable by the
    #current user, in the same way that "ls" fails. This is silly. The solution
    #is the same as under "ls": exclude paths to which the current user has no
    #permissions or which are broken symbolic links. (It'd be helpful to print
    #warning messages for each excluded path, but by no means necessary under an
    #initial implementation. Actually, this shouldn't be terribly hard to
    #implement, no? Since we'd like to perform such printing elsewhere, we'd
    #probably want to encapsulate such printing as an alias or function.
    #Consider.)
    #FUXME: This is pointless for non-recursive operation, since we can simply
    #manually exclude broken symbolic links and non-readable files. That said,
    #we probably shouldn't do *ANY* of that for non-recursive operation. When
    #non-recursive, users expect actual errors on such files... so, shift all of
    #this to grep_path_recursive().
    #FUXME: Actually, this block works to ignore both broken links and non-
    #readable paths, which is quite sweet. Cleverness. Definitely preserve for
    #recursive use.

    # Grep such paths. Since `grep` fails if at least one of the passed paths is
    # a broken symbolic link despite such links *NOT* signifying a true `grep`
    # failure, ignore such links by preemptively running the same `grep` command
    # with additional options "-qs" squelching output. Such preemptive  and hence only helpful in returning the proper exit code.Since `grep` fails to emit helpful messages on failure,
    # do so. Unfortunately, detecting failure is more cumbersome than it need
    # be. 
    #
    # For efficiency, perform such testing prior to running the real `grep`
    # command printing proper output. If such testing succeeds, force `grep`
    # to return success. (Yes, this is all incredibly, indelibly non-
    # sensical. Thanks, GNU `grep`. Bang-up job there.)
    #
    # For safety, quote-protect the sanity. (Otherwise, `grep` fails
    # to receive whitespace in grep expressions.)
#   if "${grep[@]}" -qs -- "${(q)@}"
#       print_message "running \"${grep[@]} -- ${@}\" paged..."
#   then run_code_paged "${grep[@]}" -- "${(q)@}" or true
    #FUXME: Truncate such list to produce reasonable output.
#   else die\
#       "\"${1}\" not found in $(join_strings_readably "${@[2,-1]}")"
#   fi

#Since `grep` fails to emit helpful messages on failure,
    # do so. Unfortunately, detecting failure is more cumbersome than it need
    # be. 
    #
    # For efficiency, perform such testing prior to running the real `grep`
    # command printing proper output. If such testing succeeds, force `grep`
    # to return success. (Yes, this is all incredibly, indelibly non-
    # sensical.#
#   if run_code_silent_with_options 'command grep' ZESHY_OPTIONS_GREP "${(q)@}"
#       run_code_with_options_configured\
#           'run_code_paged command grep' ZESHY_OPTIONS_GREP "${(q)@}" or
#           true
#declare_function '
#string grep_path_recursive(
#  string pattern, string pathname = "$(get_dir)")
#
#Recursively match the contents of all files in the passed paths (defaulting to
#the current working directory) against the passed `grep` pattern.
#'
#function grep_path_recursive() {
#    # Append "-r" to ${ZESHY_OPTIONS_GREP} for the duration of this call.
#    list zeshy_grep_options; zeshy_grep_options=( "${ZESHY_OPTIONS_GREP[@]}" -r )
#    list ZESHY_OPTIONS_GREP; ZESHY_OPTIONS_GREP=( "${zeshy_grep_options[@]}" )
#    is_args_1 and append_arg "${PWD}"
#    grep_path "${@}"
#}

    # For safety, quote-protect the sanity. (Otherwise, `grep` fails
    # to receive whitespace in grep expressions.)
#
#FUXME: If passed no paths, default to "." rather than "$(get_dir)"; the
#former produces much shorter and hence more intelligible path output.
#FUXME: Interesting; when using option "-r", we don't need to provide any
#default. `grep` implicitly greps the current directory. Not passing even "."
#has the added marginal benefit of reducing output by two characters each line.
#Helpful, if not earth shatteringly so!
#FUXME: grep_path_recursive_with_options() should not deferring to calling
#grep_path_with_options(), by the first FUXME above.
    # also pass the current
    # directory as "." rather than "$(get_dir)" to reduce output
    # verbosity.
#   set_integers_to_arg_nonoption_count arg_nonoption_count
#   (( arg_nonoption_count == 1 )) and append_arg '.'
#It would help if we
#first improve is_shell_interactive() to note that commands in the middle of a
#pipeline (e.g., the `grep` in "cat /tmp/oeu | grep humu | sort -r") are
#non-interactive. Readily testable with "[[ -p /dev/stdout ]]", I expect.) Or
#does zsh ensure that already? Probably not. Test. Whatever the fix, we'll also
#need adjust alias_cli() to accomodate such changes.
#
#Then,#   is_args_1 and append_arg "${^PWD}/"*
#   die_unless_args 'expected at least one grep expression'
#   string grep_pattern="${1}"
#   shift_arg
#   grep -r "${grep_pattern}" "${@:-${PWD}}"

#       then print_message "grepping ${grep[@]} -qs ${@}..."; run_code_paged "${grep[@]}" "${@}"
#       then "${grep[@]}"     "${@}"

    #FUXME: Truncate the list of files to seem reasonable length. We'll probably
    #need a new trivial "type/string/string" function for this.

    #FUXME: Terrible. See related "FUXME" comments elsewhere.
    # If the topmost function on the function stack is `grep`-specific,
    # the current user called this function directly from the command-line.

#       if (( ${#funcstack} == 1 )) or is "${funcstack[-2]}" == grep* si
#FUXME: Obsolete.
    # Call is_shell_interactive() rather than is_shell_interactive_directly(). The embedded
    # conditional below implicitly implements the latter, already.
#   if is_shell_interactive; then

    # If running non-interactively, pass *NO* Zeshy-specific options to `grep`.
    # Doing so breaks non-interactive shell scripts and functions expecting
    # default (and arguably broken) `grep` behavior.
#   else command grep "${@}"
#   fi

# Please note that `grep` fails with error if at least one of the passed files
# is a broken symbolic link, even if when passing symbolic brokens

#grep_caseless() {
#    die_unless_args_2_or_more\
#        'expected at least one grep pattern and filename'
#
##    # See alias_cli().
#    disable_function grep
#    if is_shell_interactive; then
#        if (( #funcstack == 1 ))
#        then grep --ignore-case "${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}" "${@}"
#        else grep --ignore-case "${ZESHY_OPTIONS_GREP[@]}" "${@}"
#        fi
#    # If running non-interactively, pass *NO* Zeshy-specific options to `grep`.
#    # Doing so breaks non-interactive shell scripts and functions expecting
#    # default `grep` behavior (e.g., basic patterns).
#    else grep "${@}"
#    fi
#    enable_function grep
#}
#
## ....................{ RECURSIVE                          }....................
##FUXME: Reimplement to resemble the implementation of grep(), above.
## string grep_recursive(string pattern, string path)
##
## Recursively match all file contents under the passed path against the passed
## POSIX-style regular expression. If no path is passed, this recursively matches
## under the current path. Thusly, the simplest usage of this shell script is:
##
##   # Find all text files whose contents match "Wisdom ~ \d\d ~ Outlays".
##   >>> grep-recursively 'Wisdom ~ \d\d ~ Outlays'
#grep_recursive() {
#    die_unless_args 'expected at least a regular expression'
#    string grep_pattern="${1}"; shift
#
##   print_message 'grepping...'
#    run_code_paged grep\
#        --recursive "${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}"\
#        "${grep_pattern}" "${@:-${PWD}}"
#}
#
## string grep_caseless_recursive(string pattern, string path)
##
## Recursively match all file contents under the passed path against the passed
## POSIX-style regular expression, case-insensitively.
#grep_caseless_recursive() {
#    die_unless_args 'expected at least a regular expression'
#    string grep_pattern="${1}"; shift
#
##   print_message 'grepping case-insensitively...'
#    run_code_paged grep\
#        --recursive "${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}" --ignore-case\
#        "${grep_pattern}" "${@:-${PWD}}"
#}
#
#list ZESHY_OPTIONS_GREP_MORE
#alias_cli gr="grep ${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}"
#alias_cli gri="grep ${ZESHY_OPTIONS_GREP_IF_SHELL_INTERACTIVE[@]}"

# This
#   includes the standard retinue of *NIX commands, like "awk", `grep`, "sed", 
#   and so forth.
        #as a directory, ignoring non-text files, dotfiles, and \"test\" subdirectories..."
#FUXME: Bizarre. "grep --include" does absolutely nothing. O_o
#alias grg="grep_glob"
#alias grgi="grep_glob_insensitively"
#
## string grep_glob(string grep_pattern, string glob_expression)
##
## Grep all files matching the passed glob expression (e.g., "*.txt") against the
## passed grep pattern (e.g., "^unity in faith$").
#grep_glob() {
#    [[ ${#} -eq 1 || ${#} -eq 2 ]] ||
#        die "expected at least one regular expression"
#
#    local grep_pattern="${1}"
#    local glob_pattern="${2:-*.txt}"
#
#    print_message "grepping \"${glob_pattern}\"..."
#    grep --include "${glob_pattern}" ${=ZESHY_OPTIONS_GREP}\
#        "${grep_pattern}" | "${PAGER}"
#}
#
## string grep_glob_insensitively(string grep_pattern, string glob_expression)
##
## Grep all files matching the passed glob expression (e.g., "*.txt") against the
## passed grep pattern (e.g., "^unity in faith$") insensitively.
#grep_glob_insensitively() {
#    [[ ${#} -eq 1 || ${#} -eq 2 ]] ||
#        die "expected at least one regular expression"
#
#    local grep_pattern="${1}"
#    local glob_pattern="${2:-*.txt}"
#
#    print_message "grepping \"${glob_pattern}\" case-insensitively..."
#    grep --include="${glob_pattern}" ${=ZESHY_GREP_INSENSITIVELY_OPTIONS}\
#        "${grep_pattern}"
#}
