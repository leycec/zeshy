#!/usr/bin/env zsh
# ====================[ move                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path movement (i.e., copy, move, and remove).

# ....................{ PRINTERS                           }....................
#FIXME: Take care when calling this function with "-"-prefixed arguments.

document_function '
cry_if_shifted_broken_symbolic_links(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Print a warning for passed source paths that are symbolic links broken by a
copy or move to the passed target path. This is a utility function intended to
be called only by the copy_path_*() and move_path_*() families of functions.
'
function cry_if_shifted_broken_symbolic_links() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'

    # List of shifted pathnames to be tested for broken symbolic links.
    list shifted_pathnames
    if is_args_2
    then shifted_pathnames=( "${2}" )
    #FIXME: Documentation's a tad off.
    # Dismantled, this is:
    #
    # * "${@[-1]}", expanding to the target pathname. Since at least three paths
    #   were passed and "cp" returned successfully, this is always a dirname.
    # * "${^@[1,-2]:t}", iteratively expanding to the basename for each passed
    #   source pathname.
    else shifted_pathnames=( "${@[-1]}/${^@[1,-2]:t}" )
    fi

    # Print a warning for all shifted paths that are broken symbolic links.
#   print_string "shifted_pathnames: ${shifted_pathnames[*]}"
    for shifted_pathname ("${shifted_pathnames[@]}") {
        is_broken_symbolic_link "${shifted_pathname}" and {
            string target_pathname
            target_pathname="$(get_symbolic_link_target "${shifted_pathname}")"
            cry "symbolic link \"${shifted_pathname}\" target \"${target_pathname}\" not found"
        }
    }

    # If the last shifted path is not a broken symbolic link, the prior
    # conditional returns false. To avoid returning false from this function in
    # such a case, return true...by force!
    return_true
}

# ....................{ COPIERS                            }....................
document_function '
void copy_path(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Copy the passed source to target paths "shallowly" (i.e., copying source path
symbolic links rather than the targets of such links). Print a warning for
symbolic links broken under the target path by such copy.
'
function copy_path() {
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'
    run_with_options 'command cp' ZESHY_CP_OPTIONS "${(q)@}"
    cry_if_shifted_broken_symbolic_links "${@}"
}

document_function '
void copy_path_physically(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Copy the passed source to target paths "deeply" (i.e., copying the targets of
source path symbolic links rather than such links).
'
function copy_path_physically() {
    # We copy no symbolic links and hence needn't test brokenness.
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'
    list zeshy_cp_options; zeshy_cp_options=( "${ZESHY_CP_OPTIONS[@]}" )
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=( "${zeshy_cp_options[@]}" -L )
    run_with_options 'command cp' ZESHY_CP_OPTIONS "${(q)@}"
}

document_function '
void copy_path_recursively(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Copy the passed source to target paths recursively "shallowly." See
copy_path() for further details.
'
function copy_path_recursively() {
    # Defer to copy_path() by temporarily appending recursive options to the
    # global list accessed by such function.
    list zeshy_cp_options; zeshy_cp_options=( "${ZESHY_CP_OPTIONS[@]}" )
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=(
        "${zeshy_cp_options[@]}"
        "${ZESHY_CP_OPTIONS_IF_RECURSIVE[@]}"
    )
    copy_path "${@}"
}

# ....................{ MOVERS                             }....................
document_function '
void move_path(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Move the passed source to target paths "shallowly" (i.e., moving source path
symbolic links rather than the targets of such links). Print a warning for
symbolic links broken under the target path by such copy.
'
function move_path() {
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'
    run_with_options 'command mv' ZESHY_MV_OPTIONS "${(q)@}"
    cry_if_shifted_broken_symbolic_links "${@}"
}

# ....................{ REMOVERS                           }....................
document_function '
string remove_path_recursively(string pathname1, string pathname2, ...)

Silently recursively remove the passed paths, throwing an exception if any such
path does not exist.
'
function remove_path_recursively() {
    die_unless_args 'expected at least one pathname'
    run_with_options_quietly\
        'command rm' 'ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_RECURSIVE' --\
        "${(q)@}"
}

document_function '
string remove_path_recursively_with_options_passed_and_configured(
    string rm_option1, string rm_option2, ...,
    string pathname1, string pathname2, ...)

Silently recursively remove the passed paths with both the passed and currently
configured "rm"-specific options, throwing an exception if any such path does
not exist.
'
function remove_path_recursively_with_options_passed_and_configured() {
    #FIXME: If no non-option arguments are passed, default to the current directory.
    # Validate passed arguments.
    die_unless_args 'expected at least one pathname'

    # If interactive, pass interactive-specific options.
    string option_list_names='ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_RECURSIVE'
    is_shell_interactive &&
        option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'

    # Remove such paths.
    run_with_options_configured 'command rm' "${option_list_names}" "${(q)@}"
}

# ....................{ REMOVERS ~ dir                     }....................
document_function '
void remove_dir_empty(string dirname1, string dirname2, ...)

Silently remove the passed empty directories, throwing an exception if any such
directory does not exist or does but is non-empty.
'
function remove_dir_empty() {
    die_unless_args 'expected at least one dirname'
    run_with_options_quietly\
        'command rmdir' 'ZESHY_RMDIR_OPTIONS' -- "${(q)@}"
}

document_function '
void remove_dir_empty_if_found(string dirname1, string dirname2, ...)

Silently remove only passed empty directories that exist (i.e., ignoring non-
extant directories), throwing an exception if any passed directory that exists
is non-empty.
'
function remove_dir_empty_if_found() {
    # Validate passed arguments.
    die_unless_args 'expected at least one dirname'

    #FIXME: Call the helper in "file/path" we recently defined.
    # Filter non-extant directories from the passed directories. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed directory.
    # * "(e:...:), excluding directories failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant directories.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If any extant directories remain, remove such directories.
    is_args and remove_dir_empty "${@}"
}

document_function '
string remove_dir_empty_with_options_passed_and_configured(
    string rm_option1, string rm_option2, ...,
    string pathname1, string pathname2, ...)

Remove the passed empty directories with both the passed and currently
configured "rmdir"-specific options, throwing an exception if any such directory
does not exist or does but is non-empty.
'
function remove_dir_empty_with_options_passed_and_configured() {
    #FIXME: If no non-option arguments are passed, default to the current directory.
    die_unless_args 'expected at least one dirname'
    run_with_options_configured\
        'command rmdir' 'ZESHY_RMDIR_OPTIONS' "${(q)@}"
}

# ....................{ REMOVERS ~ file                    }....................
document_function '
void remove_file(string pathname1, string pathname2, ...)

Silently remove the passed files, throwing an exception if any such file does
not exist.
'
function remove_file() {
    die_unless_args 'expected at least one filename'
    run_with_options_quietly 'command rm' 'ZESHY_RM_OPTIONS' -- "${(q)@}"
}

document_function '
void remove_file_if_found(string pathname1, string pathname2, ...)

Silently remove only passed files that exist (i.e., ignoring non-extant files).
'
function remove_file_if_found() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    #FIXME: Call the helper in "path/path" we recently defined.
    # Filter non-extant files from the passed files. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed file.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant files.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)

    # If at least one such file exists, remove such file(s).
    is_args and remove_file "${@}"
}

document_function '
string remove_file_with_options_configured(
  string pathname1, string pathname2, ...)

Remove the passed files with the currently configured "rm"-specific options,
throwing an exception if any such file does not exist.
'
function remove_file_with_options_configured() {
    remove_file_with_options_passed_and_configured -- "${(q)@}"
}

document_function '
string remove_file_with_options_passed_and_configured(
    string rm_option1, string rm_option2, ...,
    string pathname1, string pathname2, ...)

Remove the passed files with both the passed and currently configured "rm"-
specific options, throwing an exception if any such file does not exist.
'
function remove_file_with_options_passed_and_configured() {
    # Validate passed arguments.
    die_unless_args 'expected at least one filename'

    # Since removal options depend on the number of such arguments,
    # run_with_options() is insufficient. Implement such logic manually.
    string option_list_names='ZESHY_RM_OPTIONS'
    is_shell_interactive && {
        if is_arg_nonoptions_1_to_3
        then option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3'
        else option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'
        fi
    }

    # Remove such files.
    run_with_options_configured\
        'command rm' "${option_list_names}" "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Implementation isn't quite right: we only want to ignore the path if not
#found; if the path is found but is *NOT* empty, we still want to throw an exception.

#(i.e., contains at least one subdirectory or file).
#   run_with_options 'command rmdir' ZESHY_RMDIR_OPTIONS "${(q)@}"

#Remove all passed directories if all such directories exist and
#are empty  or throw an exception if at
#least one such directory  See
#remove_dir_empty_if_found() for an alternative throwing no such exception.

#   run_quietly run_with_options 'command rm'\
#       'ZESHY_RM_OPTIONS ZESHY_RM_OPTIONS_IF_SHELL_NONINTERACTIVE' -- "${(q)@}"

#       if set_integer_to_arg_nonoption_count __nonoptions__ and
#           (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
    # Validate passed arguments.
#   die_unless_args 'expected at least one filename'

    # Since removal options depend on the number of such arguments,
    # run_with_options() is insufficient. Implement such logic manually.
#   string option_list_names='ZESHY_RM_OPTIONS'
#   is_shell_interactive && {
#       if is_args_1_to_3
#       then option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_1_TO_3'
#       else option_list_names+=' ZESHY_RM_OPTIONS_IF_SHELL_INTERACTIVE_AND_ARGS_4_OR_MORE'
#       fi
#   }

    # Remove such files.
#   run_with_options_configured\
#       'command rm' "${option_list_names}" -- "${(q)@}"

#FUXME: This function should *NOT* be called by copy_file() or move_file() --
#only by the subsidiary copy_file_with_options_configured()-style functions.
