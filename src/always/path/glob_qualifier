#!/usr/bin/env zsh
# ====================[ glob_qualifier                     ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Path Glob Qualifier, handling path list glob qualifiers. See section
# "Glob Qualifiers" of "man zshexpn" for detailed documentation.

# ....................{ GETTERS                            }....................
# string get_first_path_matching_glob_qualifiers(
#   string match_type_singular,
#   string match_type_plural,
#   string glob_qualifiers,
#   string pathname1, string pathname2, ...)
#
# Get the first path in the passed list successfully matching all passed glob
# qualifiers or throw an exception if no such path exists interpolating the
# passed singular match type if passed only one: e.g.,
#
#     # Get the first owner-writable temporary directory.
#     >>> get_first_path_matching_glob_qualifiers (e.g., 'w/', matching all owner-writable directories) .
function get_first_path_matching_glob_qualifiers() {
    # Validate passed arguments.
    die_unless_at_least_four_args\
        'expected one singular label, one plural label, one glob qualifiers string, and at least one pathname'
    string match_type_singular="${1}" match_type_plural="${2}" first_pathname
    shift_two_args

    # If at least one argument matches such glob qualifiers, return the first.
    if first_pathname="$(get_first_path_matching_glob_qualifiers_if_found "${@}")"
    then output "${first_pathname}"
    # Otherwise, throw an exception.
    else
        # Shift the glob qualifier off the argument list, leaving only the list
        # of passed pathnames. While hardly necessary, this simplifies logic.
        shift_one_arg

        #FIXME: Whatever gettext() interface we support will certainly include
        #support for plurality. See "terminal/locale" for further discussion.
        # Throw a differing error message depending on argument plurality.
        if is_one_arg
        then die "\"${1}\" not found or not ${match_type_singular}"
        else die "$(join_list_to_conjunction "${@}") not found or not ${match_type_plural}"
        fi
    fi
}

# string get_first_path_matching_glob_qualifiers_if_found(
#   string glob_qualifiers,
#   string pathname1, string pathname2, ...)
#
# Get the first pathname in the passed list to successfully match all passed
# glob qualifiers (e.g., 'r.', matching all owner-readable plain files) or
# return false if no such directory exists.
function get_first_path_matching_glob_qualifiers_if_found() {
    # Validate passed arguments.
    die_unless_at_least_two_args\
        'expected at least one glob qualifiers string and one pathname'
    string glob_qualifiers="${1}"
    shift_one_arg

    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, Zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
    list pathnames; pathnames=( ${^@}(${glob_qualifiers}[1]) ) or true

    # If the list of passed pathnames contains at least one writable pathname,
    # print the first such match; otherwise, return false.
    is_list_nonempty pathnames and output "${pathnames[1]}" or return_false
}

# ....................{ GETTERS ~ file                     }....................
# string get_first_file(string filename1, string filename2, ...)
#
# Get the absolute path of the first file in the passed list to (after resolving
# symbolic links) exist or throw an exception if no such file exists.
get_first_file() {
    die_unless_args 'expected at least one filename'
    get_first_path_matching_glob_qualifiers 'a file' 'files' '-.' "${@}"
}

# string get_first_file_if_found(string filename1, string filename2, ...)
#
# Get the absolute path of the first file in the passed list to (after resolving
# symbolic links) exist or return false.
get_first_file_if_found() {
    die_unless_args 'expected at least one filename'
    get_first_path_matching_glob_qualifiers_if_found\
        'a file' 'files' '-.' "${@}"
}

# ....................{ GETTERS ~ dir                      }....................
# string get_first_dir(string dirname1, string dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists after resolving symbolic links or raise an exception if no such
# directory exists.
get_first_dir() {
    get_first_path_matching_glob_qualifiers\
        'a directory' 'directories' '-/' "${@}"
}

# string get_first_writable_dir(string dirname1, string dirname2, ...)
#
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
get_first_writable_dir() {
    get_first_path_matching_glob_qualifiers\
        'a writable directory' 'writable directories'\
        '-e{[[ -d $REPLY && -w $REPLY ]]}' "${@}"
}

# ....................{ REMOVERS                           }....................
#FIXME: Complete implementation.
function remove_list_elements_not_matching_glob_qualifiers() {
    # Filter non-extant paths from the passed paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed path.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant paths.
    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)
}

# --------------------( WASTELANDS                         )--------------------
