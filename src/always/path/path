#!/usr/bin/env zsh
# ====================[ path                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle paths and pathnames.

#FIXME: It'd be nice to incorporate "zmv", for those who want and/or expect it.
#"zmv" is a built-in shell function applying extended glob patterns to
#the usual "mv" command, thus allowing batch renaming of file- and path-names.
#(Use option "-n" before permanently applying any such pattern, so as to
#prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
#force "zmv" to [i]nteractively ask your permission to perform each rename.)
#For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
#end in 'xtx'. Naturally, "zmv" is an autoloadable function: e.g.,
#autoload -U zmv

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_path(
  string pathname,
  string error_message = "\"${pathname}\" not found")

Throw an exception unless the passed path exists.
'
function die_unless_path() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_path "${pathname}" or die "${2:-\"${pathname}\" not found}"
}

document_function '
void die_unless_file_or_dir(
  string pathname,
  string error_message = "\"${pathname}\" not a file or directory")

Throw an exception unless the passed path is either a file or directory. This
excludes symbolic links, device files, named pipes (FIFOs), and similar
"special" files.
'
function die_unless_file_or_dir() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file "${pathname}" or is_dir "${pathname}" or
        die "${2:-\"${pathname}\" not a file or directory}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_path(string pathname)

Return true if the passed path exists.
'
function is_path() {
    die_unless_arg 'expected one pathname'
    is -e "${1}" si
}

document_function '
boolean is_path_executable(string pathname)

Return true if the passed path exists and is executable by the current user.
'
function is_path_executable() {
    die_unless_arg 'expected one pathname'
    is -x "${1}" si
}

document_function '
boolean is_path_readable(string pathname)

Return true if the passed path exists and is readable by the current user.
'
function is_path_readable() {
    die_unless_arg 'expected one pathname'
    is -r "${1}" si
}

document_function '
boolean is_path_writable(string pathname)

Return true if the passed path exists and is writable by the current user.
'
function is_path_writable() {
    die_unless_arg 'expected one pathname'
    is -w "${1}" si
}

document_function '
boolean is_path_absolute(string pathname)

Return true if the passed path is absolute (i.e., begins with an "/"),
regardless of whether it actually exists.
'
function is_path_absolute() {
    die_unless_arg 'expected one pathname'
    is "${1[1]}" == '/' si
}

# ....................{ GETTERS                            }....................
document_function '
string canonicalize_path(string pathname)

Get the canonicalized form of the passed absolute path. Canonicalization
reduces this path to standard form, such that two canonical paths are equal
if and only if they represent the same file. Note that this is not
necessarily the case with non-canonical paths (e.g., "/tmp" and
"/tmp/../tmp/./" are not equal but represent the same directory).
Specifically, canonicalization:

* Expands every pseudo-directory component (e.g., "./", "../") iteratively,
  until the resulting path contains no pseudo-directory components.
* Expands every symlink in every component of the passed path recursively,
  until the resulting path contains no symlinks.
'
function canonicalize_path() {
    # Validate passed arguments.
    die_unless_arg 'expected one pathname'
    string pathname="${1}"
    die_unless_path "${pathname}"

    # Canonicalize such path.
    print_string "${pathname}"(:A)
}

document_function '
string get_path_basename(string pathname)

Get the basename of the passed path (i.e., sans parent directory name).
'
function get_path_basename() {
    die_unless_arg 'expected one pathname'
    print_string "${1:t}"
}

document_function '
string get_path_dirname(string pathname)

Get the dirname of the passed path (i.e., sans basename).
'
function get_path_dirname() {
    die_unless_arg 'expected one pathname'
    print_string "${1:h}"
}

# ....................{ GETTERS ~ size                     }....................
document_function '
integer get_path_size(string pathname)

Get the size in bytes of the passed path. If such path is:

* A directory, this is the recursive disk usage reported by the "du" command.
* A symbolic link, this is the non-dereferenced file size of such link. To get
  the dereferenced file or directory size of the non-symbolic target of such
  link, explicitly call canonicalize_path() prior to this function.
* Anything else (e.g., device node, plain file), this is the typical file size
  reported by the "stat" command.

Regardless of type, such size is always the physical space allocated to such
path by the filesystem containing such path and *NOT* the logical space such
path pretends to consume (e.g., due to contiguous runs of logical zeroes in the
case of sparse files or redirection in the case of symbolic links).
'
function get_path_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one pathname'
    string pathname="${1}"
    die_unless_path "${pathname}"

    # If the passed path is a directory, get its recursive disk usage.
    if is_dir "${pathname}"; then
        get_string_word "$(run_with_options 'command du'\
            'ZESHY_DU_OPTIONS ZESHY_DU_OPTIONS_IF_GETTING_DIR_SIZE' --\
            "${(q)pathname}")" 1
    # Otherwise, the passed path is a non-directory file (e.g., symbolic link,
    # device node, plain file). Dismantled, this is:
    #
    # * "-L", preserving rather than dereferencing symbolic links. (In contrast
    #   to some commands, zstat() dereferences by default.)
    # * "+size", expanding to such file's size in bytes.
    else zstat -L +size "${pathname}"
    fi
}

#FIXME: Shift to "path" and complete implementation.
#function remove_list_nonpaths() {
    # Filter non-extant paths from the passed paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed path.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant paths.
#    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)
#}

# --------------------( WASTELANDS                         )--------------------
    # Dismantled, this is:
    #
    # * "-s", a summary of the form "4815162342 /the/numbers".
    # * "-B1", in bytes rather than the default kilobytes.
#   then get_string_word "$(command du -s -B1 "${pathname}")" 1
# ....................{ ALIASES                            }....................
#interactive_abbreviation {c}p{r}ecursive='copy_path_recursively'
#interactive_abbreviation {r}m{r}ecursive='remove_path_recursively'
#interactive_substitution {c}p='copy_path'
#interactive_substitution {m}v='move_path'

#   string canonical_pathname=( "${pathname}"(:A) )
#   is_string_nonempty "${canonical_pathname}" or die "\"${pathname}\" "
# recursive path creation or change of path content, filename, or
# permissions. This function is considerably more costly than get_path_modification_time().
# not reflect
# file or .
#
# * File, this is the most recent of file creation or change of file content or
#   permissions.
# * Directory, this is the most recent of directory creation or change of
#   directory content or permissions.
# (i.e., file content for files and the list of files and subdirectories for
# directories), filename, or permissions. For directories, mtime does *NOT*
# reflect change of file or subdirectory content or permissions.
    # Move paths.
    #FIXME: Call a helper function testing for broken symbolic links. See above.
    # If only two arguments were passed, print a warning if the latter is a
    # broken symbolic link.

    # Otherwise, print warnings for all passed source paths whose copies in the
    # last passed argument are broken symbolic links.
#   for source_pathname ("${@[1,-2]}") {
#   is_link_symbolic "${1}" and
#       is_link_symbolic_broken "${filename}" and {
#           string target; target="$(get_link_symbolic_target "${filename}")"
#           cry "symbolic link \"${filename}\" target \"${target}\" not found"
#       }
#   }
#   fi
#FIXME: These could use copy_path() and copy_path_recursively() functions with
#corresponding globals ${ZESHY_CP_OPTIONS} and so forth.
#interactive_abbreviation cr='cp --archive --recursive --verbose --update'

# If the former is a
# symbolic link, copy the physical path to which that symbolic link
# transitively links rather than the shallow symbolic link itself (i.e., perform a deep rather than shallow copy).
#If interactive and the
# current user has not reconfigured ${ZESHY_CP_OPTIONS_IF_SHELL_INTERACTIVE[@]},
# confirm such copy for each already extant target path.
#   string first_match="$(print ${^@}(${glob_qualifiers}[1]))"
#   if is_string_nonempty "${first_match}"
#   then print     "${first_match}"
#   else return_false
#   fi
#interactive_alias c='copy_path'
#interactive_alias cp='copy_path'
#   string filetype="$(remove_string_match_prefix '*.')"
#   string filetype="${filename##*.}"

    # If the passed filename has no filetype, remove_string_match_prefix() failed to
    # match and hence returned the filename itself. If this is the case, return the empty string instead.
#   if is "${filetype}" == "${filename}" si or print "${filetype}"

    # Target filetype, supporting two-part "tar" designators. The regular expression
    # matches a prefixing ".", discarded via "#." below for brevity.
#   is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#       die "\"${filename}\" has no identifying filetype"
#   filetype="$(remove_string_prefix "${MATCH}" '.')"

# string get_file_type(string filename)
#
# Get the filetype of the passed filename. If this filename has no filetype,
# this is the empty string. Note the only matches the rightmost filetype: e.g.,
#
#     >>> get_file_type 'hastur.tar.gz'
#     gz
#get_file_type() {
#    die_unless_arg 'expected one filename'
#    string filename="${1}"
#    string filetype="${filename##*.}"
#
#    # If this filename has no filetype, then the prior parameter expansion
#    # matched the filename itself, in which case we test for and ignore this.
#    is "${filetype}" == "${filename}" si or print "${filetype}"
#
#    # Target filetype, supporting two-part "tar" designators. The regular expression
#    # matches a prefixing ".", discarded via "#." below for brevity.
#    is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#        die "\"${filename}\" has no identifying filetype"
#    filetype="$(remove_string_prefix "${MATCH}" '.')"
#}

    # The difficulty of removing specific indices from ${@} prompts us to copy ${@}
    # into a local list and operate on that, instead.
#   list extant_paths; extant_paths=( "${@}" )
#   extant_paths

#   list cp; cp=( command cp "${ZESHY_CP_OPTIONS[@]}" )
#   if is_shell_interactive
#   then "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     -- "${@}"
#   else "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" -- "${@}"
#   fi
#   list cp; cp=( command cp "${ZESHY_CP_OPTIONS[@]}" )
#   if is_shell_interactive
#   then "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     -L -- "${@}"
#   else "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" -L -- "${@}"
#   fi

#FIXME: When copying and moving symbolic links, we should verify afterwards that
#the target symbolic link is still valid. If it isn't, we should cry to stderr
#but probably not die. We'll want a new function for this; courtesy the mailing
#list, here's how we test for broken symbolic links. Cool:
#
#  # ...where "mylinktest" is the filename of the link to test. Replace with
#  # a parameter expansion, of course.
#  broken=( mylinktest(N-@) )
#
#  if (( ${#broken} ))
#  then print mylinktest is a broken symbolic link
#  else print mylinktest is not a symbolic link or is not broken
#  fi
#
#See http://www.zsh.org/mla/users/2005/msg00394.html for helpful explanation.

        #FIXME: Pretty sure there's a better way to do this by substituting "-i" 
        #for "-I" in "rm" with parameter expansion flags. Investigate.
#       elif is_list_element rm '-i'
#       then "${rm[@]}" -I -- "${@}"
#       else "${rm[@]}"    -- "${@}"

        #FIXME: Not right. We should only replace an existing option "-i" with
        #"-I" rather than indiscriminantly appending "-I". 
#   string cp_option1, string cp_option2, ...,
