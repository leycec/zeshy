#!/usr/bin/env zsh
# ====================[ path                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle paths and pathnames.
#
# --------------------( TODO                               )--------------------
# * It'd be nice to render remove_filename() an uber-powerful meta-remove command used in
#   place of "rmdir", "rm -rf *", etc. The essential ideas are:
#   * Add a config file option ${ZESHY_IS_RECYCLING}, disabled by default but, when
#     enabled, auto-moving all removed files to a new path
#     "${ZESHY_RECYCLE_BIN)/$(date +'%N')/', the former defaulting to
#     "${HOME}/tmp/zeshy.recycled". This effectively guarantees no
#     collision (still test such collision, and simply repeat until non-colliding).
#     I'll probably enable this locally, I imagine. Obviously, such auto-moving
#     such test for sufficient free disk space on the mounted disk to be moved to
#     prior to doing so and fail with error if insufficient disk space remains.
#     *ALSO*, note that no recycling must be done on paths in the recycler: an "rm"
#     within the recycler is always perma-death.
#   * Add implicit support for "rmdir". Basically, if the passed path is an empty
#     directory, use "rmdir"; otherwise, either "rm -ri ${DIRNAME}" or
#     "rm -rI ${DIRNAME}", depending on how many files or subdirectories exist
#     in such directory.
# * It'd be nice to incorporate "zmv", for those who want and/or expect it.
#   "zmv" is a built-in shell function applying extended glob patterns to
#   the usual "mv" command, thus allowing batch renaming of file- and path-names.
#   (Use option "-n" before permanently applying any such pattern, so as to
#   prete[n]d- apply the pattern as initial "trial run;" or, use option "-i" to
#   force "zmv" to [i]nteractively ask your permission to perform each rename.)
#   For example: zmv -n '(*).txt' '$1.xtx'  # renames files ending in 'txt' to
#   end in 'xtx'. Naturally, "zmv" is an autoloadable function: e.g.,
#   autoload -U zmv
# * O.K.; so, we should add a new trash_path(), implementing a trash bin-
#   style move to "~/tmp" (if such path exists) or "/tmp/$(get_current_user)" if such
#   path is creatable or already exists and is writable by the current user. This
#   suggests a new "file/trash" component with getter get_trash_home(). If
#   trash_path() is called from within get_trash_home(), it should:
#
#   * Die unless interactive.
#   * Manually confirm such removals as under remove_file().
#
#   Since such functionality will doubtless enrage a substantial subset of the Zsh
#   populace (and fair enough), this should be subject to a global boolean
#   ${ZESHY_IS_RECYCLING}. Consider adding a new "ZESHY_RM_OPTIONS_IF_RECYCLING",
#   as well. (Though, perhaps we don't need that?) Hmm; but perhaps the existing
#   ${ZESHY_IS_REPLACING_CORE_COMMANDS} suffices.
#
#   Note the implementation needs to be partition-aware; specifically, if the
#   target partition the target path resides on has insufficient space, ask the
#   user whether they'd like to remove-in-place. This requires additional
#   functionality elsewhere; namely:
#
#   * A new get_disk_size() in "device/disk", passed a disk device.
#   * A new get_mount_point_from_path() in "device/disk", passed a pathname. The most
#     efficient implementation for this function is probably to get a list of all
#     mount points, dynamically OR such mount points together into a glob pattern
#     or PCRE, and match such pathname against such pattern. The resulting $match
#     is the desired mount point.
#   * A new get_disk_from_mount_point() in "device/disk", passed a mount point
#     pathname. The most efficient implementation for this function is probably just
#     to glob the desired column of "blkid -o list" or "mount" for such mount point.
#     No PCRE required. (Canonicalize the passed mount point first, yes? That
#     helpfully removes trailing "/", as well.) Then, just call the following pipeline:
#
#     integer disk_size
#     disk_size="$(get_disk_size "$(get_disk_from_mount_point "$(get_mount_point_from_path "${pathname}")")")"
#     interactive_alias rm='trash_path'
# * Replace "trash" in the prior discussion with "compost", a verb and noun with
#   delectable connotations. Also, it would be quite nice if, much like compost,
#   the compost heap were confined to a user-configurable percentage of total
#   partition size -- defaulting to, say, 10%. Then configuring such percentage
#   to 100% gives default Recycle Bin-like behavior (i.e., unintelligently
#   filling up the entire partition with deleted refuse). The default, of
#   course, behaves much more intelligently. On reaching full capacity, sort the
#   immediate subpaths of the compost heap by ascending date and iteratively
#   delete such subpaths starting from the first in this order until the compost
#   heap subsides beneath the desired threshold. Behavior precisely resembles a
#   genuine compost heap, which rather titillates my obscure fancy.

# ....................{ ALIASES                            }....................
interactive_abbreviation {c}opy{r}ecursively='copy_path_recursively'
interactive_substitution {c}p='copy_path'
interactive_substitution {m}v='move_path'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_path(
#   string pathname,
#   string error_message = "\"${pathname}\" not found")
#
# Throw an exception unless the passed path exists.
function die_unless_path() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_path "${pathname}" or die "${2:-\"${pathname}\" not found}"
}

# void die_unless_file_or_dir(
#   string pathname,
#   string error_message = "\"${pathname}\" not a file or directory")
#
# Throw an exception unless the passed path is either a file or directory. This
# excludes symbolic links, device files, named pipes (FIFOs), and similar
# "special" files.
function die_unless_file_or_dir() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_file "${pathname}" or is_dir "${pathname}" or
        die "${2:-\"${pathname}\" not a file or directory}"
}

# ....................{ TESTERS                            }....................
# boolean is_path(string pathname)
#
# Return true if the passed path exists.
function is_path() {
    die_unless_args_1 'expected one pathname'
    is -e "${1}" si
}

# boolean is_path_executable(string pathname)
#
# Return true if the passed path exists and is executable by the current user.
function is_path_executable() {
    die_unless_args_1 'expected one pathname'
    is -x "${1}" si
}

# boolean is_path_readable(string pathname)
#
# Return true if the passed path exists and is readable by the current user.
function is_path_readable() {
    die_unless_args_1 'expected one pathname'
    is -r "${1}" si
}

# boolean is_path_writable(string pathname)
#
# Return true if the passed path exists and is writable by the current user.
function is_path_writable() {
    die_unless_args_1 'expected one pathname'
    is -w "${1}" si
}

# boolean is_path_absolute(string pathname)
#
# Return true if the passed path is absolute (i.e., begins with an "/"),
# regardless of whether it actually exists.
function is_path_absolute() {
    die_unless_args_1 'expected one pathname'
    is "${1[1]}" == '/' si
}

# ....................{ GETTERS                            }....................
# string canonicalize_path(string pathname)
#
# Get the canonicalized form of the passed absolute path. Canonicalization
# reduces this path to standard form, such that two canonical paths are equal
# if and only if they represent the same file. Note that this is not
# necessarily the case with non-canonical paths (e.g., "/tmp" and
# "/tmp/../tmp/./" are not equal but represent the same directory).
# Specifically, canonicalization:
#
# * Expands every pseudo-directory component (e.g., "./", "../") iteratively,
#   until the resulting path contains no pseudo-directory components.
# * Expands every symlink in every component of the passed path recursively,
#   until the resulting path contains no symlinks.
function canonicalize_path() {
    # Validate passed arguments.
    die_unless_args_1 'expected one pathname'
    string pathname="${1}"
    die_unless_path "${pathname}"

    # Canonicalize such path.
    output_string "${pathname}"(:A)
}

# string get_path_basename(string pathname)
#
# Get the basename of the passed path (i.e., sans parent directory name).
function get_path_basename() {
    die_unless_args_1 'expected one pathname'
    output_string "${1:t}"
}

# string get_path_dirname(string pathname)
#
# Get the dirname of the passed path (i.e., sans basename).
function get_path_dirname() {
    die_unless_args_1 'expected one pathname'
    output_string "${1:h}"
}

# ....................{ SHIFTERS                           }....................
# cry_if_shifted_broken_symbolic_links(
#   string source_pathname1, string source_pathname2, ...,
#   string target_pathname)
#
# Print a warning for passed source paths that are symbolic links broken by a
# copy or move to the passed target path. This is a utility function intended to
# be called only by the copy_path_*() and move_path_*() families of functions.
function cry_if_shifted_broken_symbolic_links() {
    # Validate passed arguments.
    die_unless_args_at_least_2\
        'expected at least one source pathname and one target pathname'

    # List of shifted pathnames to be tested for broken symbolic links.
    list shifted_pathnames
    if is_args_2
    then shifted_pathnames=( "${2}" )
    # Dismantled, this is:
    #
    # * "${@[-1]}", expanding to the target pathname. Since at least three paths
    #   were passed and "cp" returned successfully, this is always a dirname.
    # * "${^@[1,-2]:t}", iteratively expanding to the basename for each passed
    #   source pathname.
    else shifted_pathnames=( "${@[-1]}/${^@[1,-2]:t}" )
    fi

    # Print a warning for all shifted paths that are broken symbolic links.
#   output_string "shifted_pathnames: ${shifted_pathnames[*]}"
    for shifted_pathname ("${shifted_pathnames[@]}") {
        is_broken_symbolic_link "${shifted_pathname}" and {
            string target_pathname
            target_pathname="$(get_symbolic_link_target "${shifted_pathname}")"
            cry "symbolic link \"${shifted_pathname}\" target \"${target_pathname}\" not found"
        }
    }

    # If the last shifted path is not a broken symbolic link, the prior
    # conditional returns false. To avoid returning false from this function in
    # such a case, return true...by force!
    return_true
}

# ....................{ SHIFTERS ~ copiers                 }....................
# void copy_path(
#   string source_pathname1, string source_pathname2, ...,
#   string target_pathname)
#
# Copy the passed source to target paths "shallowly" (i.e., copying source path
# symbolic links rather than the targets of such links). Print a warning for
# symbolic links broken under the target path by such copy.
function copy_path() {
    die_unless_args_at_least_2\
        'expected at least one source pathname and one target pathname'
    run_with_options 'command cp' ZESHY_CP_OPTIONS "${(q)@}"
    cry_if_shifted_broken_symbolic_links "${@}"
}

# void copy_path_physically(
#   string source_pathname1, string source_pathname2, ...,
#   string target_pathname)
#
# Copy the passed source to target paths "deeply" (i.e., copying the targets of
# source path symbolic links rather than such links).
function copy_path_physically() {
    # We copy no symbolic links and hence needn't test brokenness.
    die_unless_args_at_least_2\
        'expected at least one source pathname and one target pathname'
    list zeshy_cp_options; zeshy_cp_options=( "${ZESHY_CP_OPTIONS[@]}" )
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=( "${zeshy_cp_options[@]}" -L )
    run_with_options 'command cp' ZESHY_CP_OPTIONS "${(q)@}"
}

# void copy_path_recursively(
#   string source_pathname1, string source_pathname2, ...,
#   string target_pathname)
#
# Copy the passed source to target paths recursively "shallowly." See
# copy_path() for further details.
function copy_path_recursively() {
    # Defer to copy_path() by temporarily appending recursive options to the
    # global list accessed by such function.
    list zeshy_cp_options; zeshy_cp_options=( "${ZESHY_CP_OPTIONS[@]}" )
    list ZESHY_CP_OPTIONS; ZESHY_CP_OPTIONS=(
        "${zeshy_cp_options[@]}"
        "${ZESHY_CP_OPTIONS_IF_RECURSIVE[@]}"
    )
    copy_path "${@}"
}

# ....................{ MOVERS                             }....................
# void move_path(
#   string source_pathname1, string source_pathname2, ...,
#   string target_pathname)
#
# Move the passed source to target paths "shallowly" (i.e., moving source path
# symbolic links rather than the targets of such links). Print a warning for
# symbolic links broken under the target path by such copy.
function move_path() {
    die_unless_args_at_least_2\
        'expected at least one source pathname and one target pathname'
    run_with_options 'command mv' ZESHY_MV_OPTIONS "${(q)@}"
    cry_if_shifted_broken_symbolic_links "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#   string canonical_pathname=( "${pathname}"(:A) )
#   is_nonempty "${canonical_pathname}" or die "\"${pathname}\" "
# recursive path creation or change of path content, filename, or
# permissions. This function is considerably more costly than get_path_modification_time().
# not reflect
# file or .
#
# * File, this is the most recent of file creation or change of file content or
#   permissions.
# * Directory, this is the most recent of directory creation or change of
#   directory content or permissions.
# (i.e., file content for files and the list of files and subdirectories for
# directories), filename, or permissions. For directories, mtime does *NOT*
# reflect change of file or subdirectory content or permissions.
    # Move paths.
    #FIXME: Call a helper function testing for broken symbolic links. See above.
    # If only two arguments were passed, print a warning if the latter is a
    # broken symbolic link.

    # Otherwise, print warnings for all passed source paths whose copies in the
    # last passed argument are broken symbolic links.
#   for source_pathname ("${@[1,-2]}") {
#   is_symbolic_link "${1}" and
#       is_broken_symbolic_link "${filename}" and {
#           string target; target="$(get_symbolic_link_target "${filename}")"
#           cry "symbolic link \"${filename}\" target \"${target}\" not found"
#       }
#   }
#   fi
#FIXME: These could use copy_path() and copy_path_recursively() functions with
#corresponding globals ${ZESHY_CP_OPTIONS} and so forth.
#interactive_abbreviation cr='cp --archive --recursive --verbose --update'

# If the former is a
# symbolic link, copy the physical path to which that symbolic link
# transitively links rather than the shallow symbolic link itself (i.e., perform a deep rather than shallow copy).
#If interactive and the
# current user has not reconfigured ${ZESHY_CP_OPTIONS_IF_SHELL_INTERACTIVE[@]},
# confirm such copy for each already extant target path.
#   string first_match="$(print ${^@}(${glob_qualifiers}[1]))"
#   if is_nonempty "${first_match}"
#   then print     "${first_match}"
#   else return_false
#   fi
#interactive_alias c='copy_path'
#interactive_alias cp='copy_path'
#   string filetype="$(remove_string_prefix_matching '*.')"
#   string filetype="${filename##*.}"

    # If the passed filename has no filetype, remove_string_prefix_matching() failed to
    # match and hence returned the filename itself. If this is the case, return the empty string instead.
#   if is "${filetype}" == "${filename}" si or print "${filetype}"

    # Target filetype, supporting two-part "tar" designators. The regular expression
    # matches a prefixing ".", discarded via "#." below for brevity.
#   is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#       die "\"${filename}\" has no identifying filetype"
#   filetype="$(remove_string_prefix "${MATCH}" '.')"

# string get_file_type(string filename)
#
# Get the filetype of the passed filename. If this filename has no filetype,
# this is the empty string. Note the only matches the rightmost filetype: e.g.,
#
#     >>> get_file_type 'hastur.tar.gz'
#     gz
#get_file_type() {
#    die_unless_args_1 'expected one filename'
#    string filename="${1}"
#    string filetype="${filename##*.}"
#
#    # If this filename has no filetype, then the prior parameter expansion
#    # matched the filename itself, in which case we test for and ignore this.
#    is "${filetype}" == "${filename}" si or print "${filetype}"
#
#    # Target filetype, supporting two-part "tar" designators. The regular expression
#    # matches a prefixing ".", discarded via "#." below for brevity.
#    is "${filename}" =~ '\.(tar\.)?([^.]+)$' si or
#        die "\"${filename}\" has no identifying filetype"
#    filetype="$(remove_string_prefix "${MATCH}" '.')"
#}

    # The difficulty of removing specific indices from ${@} prompts us to copy ${@}
    # into a local list and operate on that, instead.
#   list extant_paths; extant_paths=( "${@}" )
#   extant_paths

#   list cp; cp=( command cp "${ZESHY_CP_OPTIONS[@]}" )
#   if is_shell_interactive
#   then "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     -- "${@}"
#   else "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_NON_INTERACTIVE[@]}" -- "${@}"
#   fi
#   list cp; cp=( command cp "${ZESHY_CP_OPTIONS[@]}" )
#   if is_shell_interactive
#   then "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     -L -- "${@}"
#   else "${cp[@]}" "${ZESHY_CP_OPTIONS_IF_NON_INTERACTIVE[@]}" -L -- "${@}"
#   fi

#FIXME: When copying and moving symbolic links, we should verify afterwards that
#the target symbolic link is still valid. If it isn't, we should cry to stderr
#but probably not die. We'll want a new function for this; courtesy the mailing
#list, here's how we test for broken symbolic links. Cool:
#
#  # ...where "mylinktest" is the filename of the link to test. Replace with
#  # a parameter expansion, of course.
#  broken=( mylinktest(N-@) )
#
#  if (( ${#broken} ))
#  then print mylinktest is a broken symbolic link
#  else print mylinktest is not a symbolic link or is not broken
#  fi
#
#See http://www.zsh.org/mla/users/2005/msg00394.html for helpful explanation.

        #FIXME: Pretty sure there's a better way to do this by substituting "-i" 
        #for "-I" in "rm" with parameter expansion flags. Investigate.
#       elif is_list_element rm '-i'
#       then "${rm[@]}" -I -- "${@}"
#       else "${rm[@]}"    -- "${@}"

        #FIXME: Not right. We should only replace an existing option "-i" with
        #"-I" rather than indiscriminantly appending "-I". 
#   string cp_option1, string cp_option2, ...,
