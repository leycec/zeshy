#!/usr/bin/env zsh
# ====================[ temporary                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle temporary files and directories.
#
# --------------------( TODO                               )--------------------
# * The current implementation is arguably blatantly brainless. The existing
#   "mktemp" command available pretty much everywhere already creates temporary
#   directories and files in a safe manner. *sigh* Fixup, please. Ugh!

#FIXME: It'd be helpful to manually create "${HOME}/tmp", if needed.
# ....................{ GETTERS                            }....................
# string get_temporary_home(void)
#
# Get the absolute path of the first temporary directory writable by the
# current user in the following list (in order):
#
# * "${HOME}/tmp", the canonical user-specific temporary home.
# * "/tmp", the canonical system-wide temporary home for non-persistent files.
# * "/var/tmp", the canonical system-wide temporary home for persistent files.
get_temporary_home() {
    die_if_args 'expected no arguments'
    get_first_dir_writable "${HOME}/tmp" '/tmp' '/var/tmp'
}

# ....................{ MAKERS                             }....................
# string make_temporary_dir_prefixed_with(string prefix = '')
#
# Make a new temporary directory with basename prefixed by the passed prefix
# (defaulting to the empty string) and return its absolute path: e.g.,
#
#     >>> make_temporary_dir_prefixed_with ursus_maritimus
#     /tmp/ursus_maritimus~2012-04-18_22-58-34_609198275
make_temporary_dir_prefixed_with() {
    make_temporary_path_prefixed_with 'make_dir' "${@}"
}

# string make_temporary_file_prefixed_with(string prefix = '')
#
# Make a new temporary file with basename prefixed by the passed prefix
# (defaulting to the empty string) and return its absolute path: e.g.,
#
#     >>> make_temporary_file_prefixed_with ursus_nanulak
#     /tmp/ursus_nanulak~2012-04-18_22-58-34_609198275
make_temporary_file_prefixed_with() {
    make_temporary_path_prefixed_with 'make_file' "${@}"
}

# string make_temporary_path_prefixed_with(
#   string make_command_name, string prefix = '')
#
# Make a new temporary path with basename prefixed by the passed prefix
# (defaulting to the empty string) by calling the passed command and return its
# absolute pathname. This helper function avoids common race conditions by
# guaranteeing only this and no prior call created this path, with caveats:
#
# * This function *CANNOT* guarantee the returned path exists on returning. It
#   guarantees only that the returned path once existed prior to returning. In
#   theory, another concurrent process could delete (or move) this path after
#   this function creates this path but before returning. Short of patching Zsh
#   itself with mutual exclusion primitives, this is not likely to be fixable.
make_temporary_path_prefixed_with() {
    # If the caller passed a prefix, suffix such prefix with a delimiter
    # separating that prefix from a uniquifying current date and time string.
    die_unless_args_1_to_2\
        'expected one command name and optional dirname prefix'
    string make_command_name="${1}" temporary_home="$(get_temporary_home)"\
           temporary_dirname_prefix="${2+${2}~}" temporary_dirname
    die_unless_runnable "${make_command_name}"

    while (true) {
        # If the desired temporary path does not exist...
        temporary_dirname="${temporary_home}/${temporary_dirname_prefix}$(date +'%F_%H-%M-%S_%N')"
        if not is_path "${temporary_dirname}"; then
            # ...and is successfully created, return its absolute path.
            if run_quietly "${make_command_name}" "${temporary_dirname}"; then
                print "${temporary_dirname}"
                return
            # ...and is *NOT* successfully created and the temporary home
            # directory is not writable, raise an exception. This is probably
            # incredibly rare, but could theoretically occur if the current user
            # loses write permissions to the temporary home directory after the
            # prior call to get_temporary_home(). In such a case, failing to
            # explicitly test this case induces an infinite loop. Which is bad.
            elif not is_path_writable "${temporary_home}"; then
                die "\"${temporary_home}\" not writable"
            # ...otherwise, another concurrent process (probably calling this
            # function) successfully created this directory after the call to
            # is_path() but before the call to make_directory(). Try again!
            fi
        # ...otherwise, the desired temporary path already exists (probably
        # by some prior call to this function). Try again!
        fi
    }
}

# ....................{ MOVERS                             }....................
#FIXME: Obsolete, once we complete a working remove_file() function. Also, the
#current implementation is riddled with probably dangerous race conditions.
# void move_to_temporary_dir(string pathname1, string pathname2, ...)
#
# Move the passed set of files and/or directories to the "/tmp" directory. For
# Additionally, this suffixing all files and
# paths that already exist in "/tmp/" with the current time. 
move_to_temporary_dir() {
    die_unless_args
    string target_path source_basename

    # Quote the list of all passed paths with "(q)" to avoid improperly
    # splitting individual paths on whitespace.
    for source_path ("${(q)@}") {
        source_basename="$(get_path_basename "${source_path}")"
        target_path="/tmp/${source_basename}"
        is_path "${target_path}" and
            target_path="$(get_temporary_home)/$source_basename~$(date +'%F_%H-%M-%S')"
        mv "${source_path}" "${target_path}"
    }
}

# void remove_temporary_paths(void)
#
# Remove all temporary files and directories writable by the current user.
remove_temporary_paths() {
    # Confirm.
    ask_boolean_strongly "really clean temporary files and directories?" or
        return_false
    output_newline

    is_current_user_superuser and {
        #FIXME: Do the deletions below already clean such cache? I suspect so.
        if is_installed ccache; then
            interactively say "cleaning \"ccache\"..."
            try_as_superuser ccache -C
        fi
    }

    #FIXME: It would be nice to implement a clever "distfile" cleaner that ONLY
    #removed distfiles for which there is no corresponding installed version.
    list temporary_dirnames
    temporary_dirnames=( '/tmp' '/var/tmp' '/home/'*'/tmp' )
    for cleanable_dir ("${^temporary_dirnames[@]}"(w/)) {
        interactively say "cleaning \"${cleanable_dir}\"..."
        rm -rf "${cleanable_dir}"/*
    }
}

# --------------------( WASTELANDS                         )--------------------
        #FIXME: Just use list globs: e.g.,
#       if is_dir "${cleanable_dir}" and is_path_writable "${cleanable_dir}"; then
#   is_nonempty '2' and temporary_dirname_prefix="${2}~"

#FIXME: Revise to call which_dir_writable(). *THIS IS EXCEPTIONALLY IMPORTANT*.
#Failure to check writability results in subtle failure, below.
#   string user_temporary_home="${HOME}/tmp" root_temporary_home="/tmp"
#   if   is_dir "${user_temporary_home}"
#   then print  "${user_temporary_home}"
#   elif is_dir "${root_temporary_home}"
#   then print  "${root_temporary_home}"
#   else die 'no temporary directory found'
#   fi

# string get_temporary_filename_prefixed_with(string prefix)
#
# Get the absolute path to a temporary file having the passed prefix: e.g.,
#
#     >>> get_temporary_filename_prefixed_with git_patch_file
#     /tmp/git_patch_file~2012-12-01_18-37-41_837170937
#
# Subtle race conditions may arise, as above.
#get_temporary_filename_prefixed_with() {
#    die_unless_args_1 'expected exactly one filename prefix'
#    string temporary_filename_prefix="${1}" which_temporary_file
#
#    while (true) {
#        which_temporary_file="$(get_temporary_home)/${temporary_filename_prefix}.file~$(date +'%F_%H-%M-%S_%N')"
#        if not is_file "${which_temporary_file}"; then
#            print "${which_temporary_file}"
#            break
#        fi
#    }
#}

# string get_temporary_pathname_prefixed_with(string prefix)
#
# Get the absolute path of a temporary path having the passed prefix: e.g.,
#
#     >>> get_temporary_pathname_prefixed_with git_patches
#     /tmp/git_patches~2012-04-18_22-58-34_609198275
#
# While subtle race conditions may arise with concurrent processing, this path
# is generally unique. This should probably not be depended upon for mission
# critical Zsh scripts, however. (.......of course, if you're coding mission
# critical Zsh scripts, you've probably already gone too far.)
#get_temporary_pathname_prefixed_with() {
#    die_unless_args_1 'expected exactly one dirname prefix'
#    
#    string which_temporary_dir
#    while (true) {
#        which_temporary_dir="$(get_temporary_home)/${1}.path~$(date +'%F_%H-%M-%S_%N')"
#        if not is_dir "${which_temporary_dir}"; then
#            print "${which_temporary_dir}"
#            break
#        fi
#    }
#}
