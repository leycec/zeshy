#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle directories.
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_dir(
    string dirname,
    string error_message = "\"${dirname}\" not a directory")

Throw an exception with the passed message unless the passed directory exists.
/---
function die_unless_dir() {
    die_unless_args_1_to_2 'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" or die "${2:-\"${dirname}\" not a directory}"
}

declare_function_with_stdin <<'/---'
void die_unless_dir_writable(
    string dirname,
    string error_message = "\"${dirname}\" not a writable directory")

Throw an exception with the passed message unless the passed directory exists
and is writable by the current user.
/---
function die_unless_dir_writable() {
    die_unless_args_1_to_2 'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir_writable "${dirname}" or
        die "${2:-\"${dirname}\" not a writable directory}"
}

# ....................{ EXCEPTIONS ~ if                    }....................
declare_function_with_stdin <<'/---'
void die_if_dir(
    string dirname,
    string error_message = "\"${dirname}\" already a directory")

Throw an exception with the passed message if the passed directory exists. See
die_if_files() for potential pitfalls (e.g., race conditions).
/---
function die_if_dir() {
    die_unless_args_1_to_2 'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir "${dirname}" and die "${2:-\"${dirname}\" already a directory}"
}

declare_function_with_stdin <<'/---'
void die_if_dir_nonempty(
    string dirname,
    string error_message = "\"${dirname}\" already a non-empty directory")

Throw an exception with the passed message if the passed directory exists and is
non-empty (i.e., unless the passed directory does _not_ exist or exists but is
empty). See is_dir_nonempty() for further details and die_if_files() for
potential pitfalls (e.g., race conditions).
/---
function die_if_dir_nonempty() {
    die_unless_args_1_to_2 'expected one dirname and optional error message'
    string dirname="${1}"
    is_dir_nonempty "${dirname}" and
        die "${2:-\"${dirname}\" already a non-empty directory}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_dir(string pathname)

Return success if the passed path is an existing directory.
/---
function is_dir() {
    die_unless_arg 'expected one pathname'
    is -d "${1}" si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_dir_writable(string dirname)

Return success if the passed path is an existing directory and writable by the
current user.
/---
function is_dir_writable() {
    die_unless_arg 'expected one dirname'
    is -d "${1}" and -w "${1}" si
}

# ....................{ TESTERS ~ emptiness                }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_dir_empty(string dirname)

Return success if the passed directory exists and is empty (i.e., contains no
nested files or subdirectories).
/---
function is_dir_empty() {
    # Dismantled, this is:
    #
    # * "/^F", matching existing directories ("/") containing no files ("^F").
    #
    # Directory emptiness is also efficiently checkable by testing the number of
    # directory links for equality with two, since only empty directories have
    # two such links (i.e., "." and ".."): e.g.,
    #
    #   string dirname="${1}"
    #   is_dir "${dirname}" and (( $(get_dir_subdir_count "${dirname}") == 0 ))
    #
    # While it remains unclear which method is the more efficient, the current
    # method is certainly more straightforward.
    die_unless_arg 'expected one dirname'
    is_path_globbed_matches_qualifier "${1}" '/^F'
}

declare_function_with_stdin <<'/---'
[status: boolean] is_dir_nonempty(string dirname)

Return success if the passed directory exists and is non-empty (i.e., contains
at least one file or subdirectory).
/---
function is_dir_nonempty() {
    # Dismantled, this is:
    #
    # * "/F", matching existing directories ("/") containing some file ("F").
    #
    # See is_dir_empty() for further discussion.
    die_unless_arg 'expected one dirname'
    is_path_globbed_matches_qualifier "${1}" '/F'
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_dir(void)

Get the absolute path of the current working directory.
/---
function get_dir() {
    die_if_args
    output_string "${PWD}"
}

declare_function_with_stdin <<'/---'
integer get_dir_subdir_count(string dirname)

Get the number of subdirectories directly under the passed directory, excluding
canonical hard links `.` and `..`.
/---
function get_dir_subdir_count() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string dirname="${1}"
    die_unless_dir "${dirname}"

    # For non-directories, "nlink" counts the number of hard links to such file;
    # for directories, "nlink" counts the number of subdirectories of such
    # directory including omnipresent "." and ".." hard links. Hence,
    # subtracting two from "nlink" counts the number of actual subdirectories.
    # While obscure, such functionality certainly is efficient!
    output_string $(( $(zstat +nlink -- "${dirname}") - 2 ))
}

# ....................{ GETTERS ~ first                    }....................
declare_function_with_stdin <<'/---'
string get_dir_first(string dirname1, string dirname2, ...)

Get the first passed directory that exists after resolving symbolic links or
throw an exception if no such directory exists.
/---
function get_dir_first() {
    die_unless_args 'expected one or more dirnames'
    get_dir_first_if_found "${@}" or die\
        "$(join_strings_readably "${@}") not found or not directories"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_dir_first_if_found(
    string dirname1, string dirname2, ...)

Get the first passed directory that exists after resolving symbolic links or
return failure if no such directory exists.
/---
function get_dir_first_if_found() {
    die_unless_args 'expected one or more dirnames'
    get_path_matching_qualifier_first_if_found "${@}" '-/'
}

# ....................{ GETTERS ~ first : writable         }....................
declare_function_with_stdin <<'/---'
string get_dir_writable_first(string dirname1, string dirname2, ...)

Get the first passed directory writable by the current user after resolving
symbolic links or throw an exception if no such directory exists.
/---
function get_dir_writable_first() {
    die_unless_args 'expected one or more dirnames'
    get_dir_writable_first_if_found "${@}" or die\
        "$(join_strings_readably "${@}") not found or not writable directories"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_dir_writable_first_if_found(
    string dirname1, string dirname2, ...)

Get the first passed directory writable by the current user after resolving
symbolic links or return failure if no such directory exists.
/---
function get_dir_writable_first_if_found() {
    die_unless_args 'expected one or more dirnames'
    get_path_matching_qualifier_first_if_found\
        "${@}" '-e{[[ -d $REPLY && -w $REPLY ]]}'
}

# ....................{ SETTERS                            }....................
#FIXME: Implement a new set_dir_idempotently() function expanding list global
#${ZESHY_CD_OPTIONS_IDEMPOTENT}.

declare_function_with_stdin <<'/---'
void set_dir(string dirname)

Set the current working directory to the passed directory. Also:

* If the current shell is interactive, implicitly call builtin chpwd() and all
  functions registered with run_hook_after_dir_set_interactively().
* If the current shell is non-interactive and:
** If list global ${ZESHY_CD_OPTIONS_IF_NONINTERACTIVE} retains default option
   `-q`, do _not_ implicitly call builtin chpwd() or any functions registered
   with run_hook_after_dir_set_interactively().
** Else, do.

If the current shell is non-interactive, this function thus behaves idempotently
(i.e., without implicit side effects) by default.
/---
function set_dir() {
    die_unless_arg 'expected one dirname'
    run_code_silent_with_options_configured\
        'builtin cd' ZESHY_CD_OPTIONS -- "${(q)1}"
}

declare_function_with_stdin <<'/---'
void set_dir_with_options(
    string cd_option1, string cd_option2, ...,
    string dirname = "-")

Set the current working directory to the passed directory (defaulting to `-`,
which `cd` interprets to be the prior directory on the directory stack), with
the passed `cd`-specific options. See set_dir() for further details.
/---
function set_dir_with_options() {
    # Validate passed arguments. If passed only one source path, default the
    # target path to the current directory.
    die_unless_args_1_or_more\
        'expected zero or more options and one dirname'
    is_arg_nonoptions or append_arg '-'

    # Set such directory.
    run_code_with_options_configured\
        'builtin cd' ZESHY_CD_OPTIONS "${(q)@}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Implement the corresponding is_dir_nonempty() by editing to:
#   list dirname_if_nonempty; dirname_if_nonempty=( "${1}"(/F) )

    #FUXME: We should really just define a helper function in "path/path"
    #resembling the current get_first_*_glob_qualifier() functions.
#   list dirname_if_empty; dirname_if_empty=( "${1}"(/^F) )
#   is_list_nonempty dirname_if_empty

# ....................{ ALIASES                            }....................
#alias_cli_substitution {m}k{d}ir='make_dir_if_not_found'
#alias_cli_substitution {r}m{d}ir='remove_dir_empty'

    # Defer to make_dir(), temporarily appending option "-p" to global list
    # ${ZESHY_MKDIR_OPTIONS}.
#   list zeshy_mkdir_options; zeshy_mkdir_options=( "${ZESHY_MKDIR_OPTIONS[@]}" )
#   list ZESHY_MKDIR_OPTIONS; ZESHY_MKDIR_OPTIONS=( "${zeshy_mkdir_options[@]}" -p )
#   make_dir "${@}"
