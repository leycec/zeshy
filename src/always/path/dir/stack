#!/usr/bin/env zsh
# ====================[ stack                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the directory stack of previously visited dirnames.
#
# --------------------( TODO                               )--------------------
# * This looks quite nice, a "vi"-key aware path switcher:
#   http://www.reddit.com/r/linux/comments/yxfwz/introducing_cdd_a_simply_directory_navigation

#FIXME: This component is entitled "stack" -- not "current". Shift all
#*_current_dir*() functions to a new "dir/current" component.

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_dir().
declare_function '
string get_current_dir(void)

Get the absolute path of the current working directory.
'
function get_current_dir() {
    die_if_args
    print_string "${PWD}"
}

# ....................{ SETTERS ~ current dir              }....................
#FIXME: Rename to set_dir().
#FIXME: Split into interactive and non-interactive versions, requiring a passed
#dirname in the latter case. Name the interactive version
#set_dir_with_options().
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_current_dir(string dirname = "")

Set the current working directory to the passed dirname, implicitly invoking
the chpwd() hook and hence pushing that dirname if valid onto the persistent
directory stack. Specifically, if:

* Called non-interactively and...
** No dirname was passed, throw an exception.
** Else, set the current working dirname to the passed dirname.
* Called interactively and...
** No dirname was passed and...
*** The directory stack is non-empty, pop the top dirname off that stack
    and set the current working dirname to that directory.
*** Else, set the current working dirname to the current user''s home.
* Else, set the current working dirname to the passed dirname.
________________<heredoc?>________________
function set_current_dir() {
    if { is_args } {
        store_current_dir "${@}"
    } elif { is_shell_interactive } {
        # If passed at least one argument, switch to such directory.
        # If the directory stack is non-empty, switch to the prior directory.
        if { is_list_nonempty dirstack } {
            restore_current_dir
        # Otherwise, switch to the home directory.
        } else {
            store_current_dir "$(get_home)"
        }
    } else {
        die 'expected one dirname'
    }
}

#FIXME: Rename to store_dir(). Or perhaps set_dir_and_prepend_dir_stack(). Yes,
#the latter's significantly better.
#FIXME: Actually, perhaps just prepend_dir_stack(). The "set_dir" is
#necessarily implied. Or perhaps prepend_dir_stack_and_set_dir(). Hm; actually,
#push_dir_stack_with_dir(). Unlike pop_dir_stack(), this function actually takes
#an argument. Sweet. push_dir_stack_with_dir() it is!
declare_function_with_stdin <<'________________<heredoc?>________________'
void store_current_dir(string dirname)

Set the current working directory to the passed dirname, implicitly invoking
the chpwd() hook and hence pushing that dirname if valid onto the persistent
directory stack. This function is the less intelligent step-child of
set_current_dir() and hence appropriate for non-interactive scripts.
________________<heredoc?>________________
function store_current_dir() {
    die_unless_arg 'expected one dirname'
    pushd -- "${1}"
}

#FIXME: Rename to restore_dir(). Or perhaps
#set_dir_to_dir_stack_top_and_pop(). Yes, the latter's significantly better.
#FIXME: Actually, perhaps just pop_dir_stack(). The "set_dir" is
#necessarily implied.
declare_function_with_stdin <<'________________<heredoc?>________________'
void restore_current_dir()

Restore the current working directory to the immediately prior directory on
the directory stack.
________________<heredoc?>________________
function restore_current_dir() {
    # Validate sanity.
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'

    # Pop off and "cd" to the top directory off the directory stack, implicitly
    # calling set_current_dir(). (If, in fact, this function was called already
    # by set_current_dir() due to the latter having been called with no
    # arguments, the second call to set_current_dir() is called with one
    # argument, thus delimiting recursion.)
    popd
#   interactively print_dir_stack
}

# ....................{ SETTERS ~ dir stack                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void clear_dir_stack(void)

Clear the directory stack.
________________<heredoc?>________________
function clear_dir_stack() {
    die_if_args
    dirs -c
}

#FIXME: Rename to rotate_dir_stack_back(). Actually, to
#set_dir_and_dir_stack_top_to_index() or to
#set_dir_to_dir_stack_index_and_rotate(). Right. The latter, again.
#FIXME: Actually, just to rotate_dir_stack_to_index(). (Yes, this actually does
#rotate. It's in the "man" pages. Sweet, no?) Such function should accept both
#positive and negative indices and correctly do the right thing. Note, in
#particularly, that pushd() treats "+1" to be the previous directory and "-0" to
#be the next directory in such stack, as opposed to the actual underlying array,
#in which "2" is the index of the previous directory and "-1" the index of the
#next. The caller *MUST* pass an index in the latter format (i.e., array index),
#to maintain sanity. Hence, this function must convert from array indices to
#pushd() indices. Happily, this is mostly simple; if:
#
#* The passed array index is 0, throw an exception. (0 is not a valid index.)
#* The passed array index is 1, return immediately. (No rotation is required.)
#* The passed array index is positive, subtract such index by 1.
#* Else, the passed array index is negative; add such index by 1.
#FIXME: We need a new "_with_options" version of this function accepting the
#default value of 1. The basic version of this function should accept no such
#default value. (Humdrum.)
declare_function_with_stdin <<'________________<heredoc?>________________'
void rotate_dir_stack_backward(integer dir_count = 1)

Set the current directory to that of the passed offset from the top of the
directory stack (defaulting to 1 and hence the prior directory).
________________<heredoc?>________________
function rotate_dir_stack_backward() {
    # Validate passed arguments.
    die_unless_arg 'expected one index'
    die_unless_list_nonempty dirstack 'directory stack empty'
    string index="${1:-1}"
    die_unless_list_index dirstack "${index}"

    # Rotate such stack.
    pushd -q +${index}
#   interactively print_dir_stack
}

#FIXME: Rename to rotate_dir_stack_next().
#FIXME: We need a new "_with_options" version of this function accepting the
#default value of 1. The basic version of this function should accept no such
#default value.
declare_function_with_stdin <<'________________<heredoc?>________________'
void rotate_dir_stack_forward(integer dir_count = 1)

Set the current directory to that of the passed offset from the bottom of the
directory stack (defaulting to 1 and hence the last directory). Assuming some
prior call to rotate_current_dir_backward(), calling this function with the
same count effectively undoes the former.
________________<heredoc?>________________
function rotate_dir_stack_forward() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'
    integer dir_count="${1:-1}"
    pushd -q -$((dir_count - 1))
#   interactively print_dir_stack
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_dir_stack(void)

Print a human-readable synopsis of the directory stack for the current shell.
________________<heredoc?>________________
function print_dir_stack() {
    # Print a prefixing header.
    die_if_args
    print_string '   index     dir'
    print_hard_rule

    # Capture standard print_string from "dirs". Oddly, this print_string does not coincide
    # with the actual contents of the ${dirstack} list: specifically, "dirs"
    # prepends print_string with the current directory regardless of whether the
    # first directory in the directory stack is already this directory. To
    # amend this:
    #
    # * If the directory stack is empty, print nothing.
    # * Otherwise, print all lines following the first.
    is_list_nonempty dirstack or return_true
    string dirs_output; dirs_output="$(dirs -p)"
    number_string_lines_highlighting "$(get_string_lines "${dirs_output}" 2 -1)" 1
}

# ....................{ HOOKS                              }....................
run_hook_after_dir_set compact_dir_stack

#FIXME: Auto-compress the stack when it gets too large. Also, we really don't
#want *ANY* duplicates on the stack; we currently only prohibit duplicates on
#the top of the stack. This should be simply to effect by re-typesetting such
#stack with "-U". (Surprised we don't already do that. Do we?)

declare_function_with_stdin <<'________________<heredoc?>________________'
void compact_dir_stack(void)

Respond to the current directory being set by pushing that directory onto the
directory stack if not already. Unlike the "auto_pushd" option activated only
on pushd() calls, zsh activates this hook on every call setting the current
directory excluding popd() (e.g., cd(), pushd()).
________________<heredoc?>________________
function compact_dir_stack() {
    #FIXME: Define a new truncate_list_to_size() function, implementing such
    #truncation.

    # If the current user requests a directory stack height maximum and the
    # current height exceeds this maximum, pop off "excess" directories.
    is_variable ZESHY_DIR_STACK_MAX_SIZE and
        (( ${#dirstack} > ZESHY_DIR_STACK_MAX_SIZE )) and
        dirstack[$(( ZESHY_DIR_STACK_MAX_SIZE + 1 )),-1]=()
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME:
    # If the top directory on the stack is not already the current working
    # directory, push this directory onto the stack.
#   print_message "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   { is_list_empty dirstack or is "${dirstack[1]}" != "${PWD}" si } and
#       dirstack=( "${PWD}" "${dirstack[@]}" )

        #FUXME: Add a new prepend_list() function to "type/list".
#   {
#       is_list_nonempty dirstack and print_message "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   }

#FUXME: Non-ideal. Since we (or someone else) will undoubtedly want to provide
#a chpwd hook, we really want to generalize this into a hook-style interface.
#Does zsh already provide such support, or is this something we need to cook up?
# * It'd be helpful to auto-truncate the directory stack if it gets too tall --
#   say, higher than ${ZESHY_DIRSTACK_MAX_SIZE} (defaulting to 16). Entries
#   should probably be truncated off the bottom, I r'ckon.
# * http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
#   Helpful chpwd() hook implementation (i.e., persistent dirs).

#   die_unless_args 'expected at least one dirname'
#   command mkdir -p -- "${@}"

#   interactively print_message 'printing the current directory stack...'
#FUXME: It'd be quite nice to improve interactive_alias() to accept multiple
#alias names for the same alias. Note this also requires "src/digest" to parse
#such names, as well. *shrug*
#interactive_alias mvt='move_to_temporary_dir'

#       integer first_dir_index_to_pop
#       (( first_dir_index_to_pop = ZESHY_DIR_STACK_MAX_SIZE + 1 ))
#       dirstack[${first_dir_index_to_pop},-1]=()
#
#       dirstack+=( "${PWD}" )
#   if is_list_empty dirstack
#   then dirstack+=( "${PWD}" )
#   else is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#   fi
#   (( ${#dirstack} )) or die 'directory stack empty'
#   die_unless_list_nonempty dirstack 'directory stack empty'

# For brevity, alias "cd" to this function.

#FUXME: Doesn't work, sadly. Investigate. (I suspect "src/digest" parses such
#whitespace incorrectly.)
#set_current_dir cd() {
#   without
#     calling the chpwd() hook or hooks in the ${chpwd_functions} list (i.e.,
#     "run_command_silent"). This prevents unintended pollution of the current user's
#     directory stack with script-specific dirnames.

# ....................{ PUSHERS                            }....................
# void change_

#FUXME: The "autopushd" option already enables this.
# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current working dirname being set by pushing that dirname if
# valid onto the directory stack.
#chpwd() {
#    # If the top directory on the stack is not already the current working
#    # directory, push this directory onto the stack.
#    is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#}

#           if is "${1}" == (-|+)* si
#           then builtin cd "${@}"
#           else pushd "${@}"
#           fi

#FUXME: Uhm; why doesn't "mkdir --parents" suffice?

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
#   string new_path
#   while is_args; do
#       new_path="${1}"; shift

#       if is_file "${new_path}"; then
#           die "\"${new_path}\" already a file"
#       elif not is_dir "${new_path}"; then
#           print_message "making \"${new_path}\"..."
#           mkdir --parents "${new_path}"
#       fi
#   done

# void make_parent_directory_if_not_found(string pathname)
#
# Make the parent directory of the passed path, if not found.
#make_parent_directory_if_not_found() {
#    die_unless_arg 'expected one pathname'
#    make_dir_if_not_found "$(dirname "${1}")"
#}

#cd() {
#  if [ -z "$1" ]
#  then popd
#  else pushd "$@"
#  fi
#}

# Get the absolute canonical path (i.e., containing no symbolic links) of the
# current working directory.

#   readlink --canonicalize-existing "${1}"
# string which_command(string command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_arg 'expected one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        print_warning "\"${command_name}\" not found"
#        return_false
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# string *get_filenames(string dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_args_0_to_1 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_arg)"
#       get_next_arg_as filename
