#!/usr/bin/env zsh
# ====================[ stack                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the directory stack of previously visited dirnames.
#
# --------------------( TODO                               )--------------------
# * This looks quite nice, a "vi"-key aware path switcher:
#   http://www.reddit.com/r/linux/comments/yxfwz/introducing_cdd_a_simply_directory_navigation

#FIXME: This component is entitled "stack" -- not "current". Shift all
#*_current_dir*() functions to a new "dir/current" component.

# ....................{ GETTERS                            }....................
document_function '
string get_current_dir(void)

Get the absolute path of the current working directory.
'
function get_current_dir() {
    die_if_args
    print_string "${PWD}"
}

# ....................{ SETTERS ~ current dir              }....................
document_function '
void set_current_dir(string dirname = "")

Set the current working directory to the passed dirname, implicitly invoking
the chpwd() hook and hence pushing that dirname if valid onto the persistent
directory stack. Specifically, if:

* Called non-interactively and...
  * No dirname was passed, raise an exception.
  * Otherwise, set the current working dirname to the passed dirname.
* Called interactively and...
  * No dirname was passed and...
    * The directory stack is non-empty, pop the top dirname off that stack
      and set the current working dirname to that directory.
    * Otherwise, set the current working dirname to the current user''s home.
  * Otherwise, set the current working dirname to the passed dirname.
'
function set_current_dir() {
    if is_args
    then store_current_dir "${@}"
    elif is_shell_interactive; then
        # If passed at least one argument, switch to such directory.
        # If the directory stack is non-empty, switch to the prior directory.
        if is_list_nonempty dirstack
        then restore_current_dir
        # Otherwise, switch to the home directory.
        else store_current_dir "$(get_current_user_dir_home)"
        fi
    else die 'expected one dirname'
    fi
}

document_function '
void store_current_dir(string dirname)

Set the current working directory to the passed dirname, implicitly invoking
the chpwd() hook and hence pushing that dirname if valid onto the persistent
directory stack. This function is the less intelligent step-child of
set_current_dir() and hence appropriate for non-interactive scripts.
'
function store_current_dir() {
    die_unless_arg 'expected one dirname'
    pushd -- "${1}"
}

document_function '
void restore_current_dir()

Restore the current working directory to the immediately prior directory on
the directory stack.
'
function restore_current_dir() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'

    # Pop off and "cd" to the top directory off the directory stack, implicitly
    # calling set_current_dir(). (If, in fact, this function was called already
    # by set_current_dir() due to the latter having been called with no
    # arguments, the second call to set_current_dir() is called with one
    # argument, thus delimiting recursion.)
    popd
#   interactively print_dir_stack
}

# ....................{ SETTERS ~ dir stack                }....................
document_function '
void clear_dir_stack(void)

Clear the directory stack.
'
function clear_dir_stack() {
    die_if_args
    dirs -c
}

document_function '
void rotate_dir_stack_backward(integer dir_count = 1)

Set the current directory to that of the passed offset from the top of the
directory stack (defaulting to 1 and hence the prior directory).
'
function rotate_dir_stack_backward() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'
    pushd -q +${1:-1}
#   interactively print_dir_stack
}

document_function '
void rotate_dir_stack_forward(integer dir_count = 1)

Set the current directory to that of the passed offset from the bottom of the
directory stack (defaulting to 1 and hence the last directory). Assuming some
prior call to rotate_current_dir_backward(), calling this function with the
same count effectively undoes the former.
'
function rotate_dir_stack_forward() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'
    integer dir_count="${1:-1}"
    pushd -q -$((dir_count - 1))
#   interactively print_dir_stack
}

# ....................{ HOOKS                              }....................
#FIXME: Auto-compress the stack when it gets too large. Also, we really don't
#want *ANY* duplicates on the stack; we currently only prohibit duplicates on
#the top of the stack. This should be simply to effect by re-typesetting such
#stack with "-U". (Surprised we don't already do that. Do we?)
#FIXME: Non-ideal. Since we (or someone else) will undoubtedly want to provide
#a chpwd hook, we really want to generalize this into a hook-style interface.
#Does Zsh already provide such support, or is this something we need to cook up?

document_function '
void chwpd(void)

Respond to the current directory being set by pushing that directory onto the
directory stack if not already. Unlike the "auto_pushd" option activated only
on pushd() calls, Zsh activates this hook on every call setting the current
directory excluding popd() (e.g., cd(), pushd()).
'
function chpwd() {
    # If the top directory on the stack is not already the current working
    # directory, push this directory onto the stack.
#   say "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   { is_list_empty dirstack or is "${dirstack[1]}" != "${PWD}" si } and
#       dirstack=( "${PWD}" "${dirstack[@]}" )

        #FIXME: Add a new prepend_list() function to "type/list".
#   {
#       is_list_nonempty dirstack and say "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   }

    # If the current user requests a directory stack height maximum and the
    # current height exceeds this maximum, pop off "excess" directories.
    is_variable_nonempty ZESHY_DIR_STACK_MAX_SIZE and
        (( ${#dirstack} > ZESHY_DIR_STACK_MAX_SIZE )) and
        dirstack[$(( ZESHY_DIR_STACK_MAX_SIZE + 1 )),-1]=()
}

# ....................{ PRINTERS                           }....................
document_function '
string print_dir_stack(void)

Print the contents of the directory stack in human-readable format.
'
function print_dir_stack() {
    # Print a prefixing header.
    die_if_args
    print_string '   index     dir'
    say_banner

    # Capture standard print_string from "dirs". Oddly, this print_string does not coincide
    # with the actual contents of the ${dirstack} list: specifically, "dirs"
    # prepends print_string with the current directory regardless of whether the
    # first directory in the directory stack is already this directory. To
    # amend this:
    #
    # * If the directory stack is empty, print nothing.
    # * Otherwise, print all lines following the first.
    is_list_nonempty dirstack or return_true
    string dirs_output; dirs_output="$(dirs -p)"
    number_string_lines_highlighting "$(get_string_lines "${dirs_output}" 2 -1)" 1
}

# --------------------( WASTELANDS                         )--------------------
# * It'd be helpful to auto-truncate the directory stack if it gets too tall --
#   say, higher than ${ZESHY_DIRSTACK_MAX_SIZE} (defaulting to 16). Entries
#   should probably be truncated off the bottom, I r'ckon.
# * http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
#   Helpful chpwd() hook implementation (i.e., persistent dirs).

#   die_unless_args 'expected at least one dirname'
#   command mkdir -p -- "${@}"

#   interactively say 'printing the current directory stack...'
#FIXME: It'd be quite nice to improve interactive_alias() to accept multiple
#alias names for the same alias. Note this also requires "src/digest" to parse
#such names, as well. *shrug*
#interactive_alias mvt='move_to_temporary_dir'

#       integer first_dir_index_to_pop
#       (( first_dir_index_to_pop = ZESHY_DIR_STACK_MAX_SIZE + 1 ))
#       dirstack[${first_dir_index_to_pop},-1]=()
#
#       dirstack+=( "${PWD}" )
#   if is_list_empty dirstack
#   then dirstack+=( "${PWD}" )
#   else is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#   fi
#   (( ${#dirstack} )) or die 'directory stack empty'
#   die_unless_list_nonempty dirstack 'directory stack empty'

# For brevity, alias "cd" to this function.

#FIXME: Doesn't work, sadly. Investigate. (I suspect "src/digest" parses such
#whitespace incorrectly.)
#set_current_dir cd() {
#   without
#     calling the chpwd() hook or hooks in the ${chpwd_functions} list (i.e.,
#     "run_silently"). This prevents unintended pollution of the current user's
#     directory stack with script-specific dirnames.

# ....................{ PUSHERS                            }....................
# void change_

#FIXME: The "autopushd" option already enables this.
# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current working dirname being set by pushing that dirname if
# valid onto the directory stack.
#chpwd() {
#    # If the top directory on the stack is not already the current working
#    # directory, push this directory onto the stack.
#    is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#}

#           if is "${1}" == (-|+)* si
#           then builtin cd "${@}"
#           else pushd "${@}"
#           fi

#FIXME: Uhm; why doesn't "mkdir --parents" suffice?

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
#   string new_path
#   while is_args; do
#       new_path="${1}"; shift

#       if is_file "${new_path}"; then
#           die "\"${new_path}\" already a file"
#       elif not is_dir "${new_path}"; then
#           say "making \"${new_path}\"..."
#           mkdir --parents "${new_path}"
#       fi
#   done

# void make_parent_directory_if_not_found(string pathname)
#
# Make the parent directory of the passed path, if not found.
#make_parent_directory_if_not_found() {
#    die_unless_arg 'expected one pathname'
#    make_dir_if_not_found "$(dirname "${1}")"
#}

#cd() {
#  if [ -z "$1" ]
#  then popd
#  else pushd "$@"
#  fi
#}

# Get the absolute canonical path (i.e., containing no symbolic links) of the
# current working directory.

#   readlink --canonicalize-existing "${1}"
# string which_command(string command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_arg 'expected one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        cry "\"${command_name}\" not found"
#        return_false
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# string *get_filenames(string dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_args_0_to_1 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_arg)"
#       get_next_arg_as filename
