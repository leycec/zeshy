#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle the *directory stack* (i.e., shell-specific stack of dirnames previously
visited by such shell).
-/-

#FIXME: This "vi"-key aware path switcher looks quite nice:
#   http://www.reddit.com/r/linux/comments/yxfwz/introducing_cdd_a_simply_directory_navigation
#FIXME: Turns out zsh already includes a hidden dir stack navigator: hitting
#<Tab> after typing either "cd +" or "cd -" displays an exceptionally readable
#indexed dir stack, without disrupting the current "cd". Man, just brilliant...
#We should probably alias these... *UGH*. We can certainly alias both, but that
#fails to induce the same completions as the original commands. *sigh*

# ....................{ STORERS                            }....................
declare_function_with_stdin <<'/---'
void store_dir(string dirname)

Set the current working directory to the passed directory and push such
directory to the top of the directory stack for the current shell, without
calling chpwd() or hooks registered by run_hook_after_dir_set_interactively().
This function is typically called only by noninteractive functions and scripts.

== Comparisons ==

While set_dir() has a similar effect under default `zeshy` settings, there
exist two compelling differences:

. Such settings are configurable and hence unreliable for general-purpose use,
  while this function guarantees the stated behavior.
. set_dir() calls chpwd() and hooks registered by
  run_hook_after_dir_set_interactively(), while this function calls neither.
/---
function store_dir() {
    # Dismantled, this is:
    #
    # * "-q", guaranteeing chwpd() and hook functions to *NOT* be called.
    die_unless_arg 'expected one dirname'
    pushd -q -- "${1}"
}

declare_function_with_stdin <<'/---'
void restore_dir()

Set the current working directory to the directory at the top of the directory
stack for the current shell and pop such directory from such stack, without
calling chpwd() or hooks registered by run_hook_after_dir_set_interactively().
This function is typically called only by noninteractive functions and scripts.
See store_dir() for further details.
/---
function restore_dir() {
    # Validate sanity.
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'

    # Restore the previous working directory. Dismantled, this is:
    #
    # * "-q", guaranteeing chwpd() and hook functions to *NOT* be called.
    popd -q
}

# ....................{ ROTATERS                           }....................
#FIXME: Rename to rotate_dir_stack_back(). Actually, to
#set_dir_and_dir_stack_top_to_index() or to
#set_dir_to_dir_stack_index_and_rotate(). Right. The latter, again.
#FIXME: Actually, just to rotate_dir_stack_to_index(). (Yes, this actually does
#rotate. It's in the "man" pages. Sweet, no?) Such function should accept both
#positive and negative indices and correctly do the right thing. Note, in
#particularly, that pushd() treats "+1" to be the previous directory and "-0" to
#be the next directory in such stack, as opposed to the actual underlying array,
#in which "2" is the index of the previous directory and "-1" the index of the
#next. The caller *MUST* pass an index in the latter format (i.e., array index),
#to maintain sanity. Hence, this function must convert from array indices to
#pushd() indices. Happily, this is mostly simple; if:
#
#* The passed array index is 0, throw an exception. (0 is not a valid index.)
#* The passed array index is 1, return immediately. (No rotation is required.)
#* The passed array index is positive, subtract such index by 1.
#* Else, the passed array index is negative; add such index by 1.
#FIXME: We need a new "_with_options" version of this function accepting the
#default value of 1. The basic version of this function should accept no such
#default value. (Humdrum.)
declare_function_with_stdin <<'/---'
void rotate_dir_stack_backward(integer dir_count = 1)

Set the current directory to that of the passed offset from the top of the
directory stack (defaulting to 1 and hence the prior directory).
/---
function rotate_dir_stack_backward() {
    # Validate passed arguments.
    die_unless_arg 'expected one index'
    die_unless_list_nonempty dirstack 'directory stack empty'
    string index="${1:-1}"
    die_unless_list_index dirstack "${index}"

    # Rotate such stack.
    pushd -q +${index}
#   interactively print_dir_stack
}

#FIXME: Rename to rotate_dir_stack_next().
#FIXME: We need a new "_with_options" version of this function accepting the
#default value of 1. The basic version of this function should accept no such
#default value.
declare_function_with_stdin <<'/---'
void rotate_dir_stack_forward(integer dir_count = 1)

Set the current directory to that of the passed offset from the bottom of the
directory stack (defaulting to 1 and hence the last directory). Assuming some
prior call to rotate_current_dir_backward(), calling this function with the
same count effectively undoes the former.
/---
function rotate_dir_stack_forward() {
    die_if_args
    die_unless_list_nonempty dirstack 'directory stack empty'
    integer dir_count="${1:-1}"
    pushd -q -$((dir_count - 1))
#   interactively print_dir_stack
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_dir_stack(void)

Print a human-readable synopsis of the directory stack for the current shell.
/---
function print_dir_stack() {
    # Validate sanity.
    die_if_args
    string dirs_output

    # Page such output.
    {
        # Print a heading.
        output_string '   index     dir'
        output_line_horizontal

        # Capture standard output from "dirs". Oddly, this output does not coincide
        # with the actual contents of the ${dirstack} list: specifically, "dirs"
        # prepends output with the current directory regardless of whether the
        # first directory in the directory stack is already this directory. To
        # amend this:
        #
        # * If the directory stack is empty, print nothing.
        # * Else, print all lines following the first.
        if { is_list_empty dirstack } { return_true }

        # Print such stack, highlighting the first directory (i.e., the current
        # working directory).
        number_string_lines_highlighting\
            "$(get_string_lines "$(builtin dirs -p)" 2 -1)" 1
    } | page_stdin
}

# ....................{ CLEARERS                           }....................
declare_function_with_stdin <<'/---'
void clear_dir_stack(void)

Clear the directory stack.
/---
function clear_dir_stack() {
    die_if_args
    builtin dirs -c
}

# ....................{ SERIALIZERS                        }....................
# On zeshy startup, initialize the directory stack from the corresponding file.
# After changing the current working directory and hence invoking shell option
# "auto_pushd", write the now-edited directory stack back to such file.
run_hook_on_zeshy_startup             read_dir_stack_file
run_hook_after_dir_set_interactively write_dir_stack_file

declare_function_with_stdin <<'/---'
void read_dir_stack_file(void)

Replace the directory stack with the contents of the directory stack file if
such file exists or return silently otherwise. See write_dir_stack_file() for
further details.
/---
function read_dir_stack_file() {
    # Validate sanity.
    die_if_args

    # If such script exists, source such script hopefully defining ${dirstack}.
    if {    is_shell_script "${ZESHY_USER_DIR_STACK_FILE}" } {
        source_shell_script "${ZESHY_USER_DIR_STACK_FILE}"
    # Else, return success.
    } else {
        return_true
    }
}

declare_function_with_stdin <<'/---'
void write_dir_stack_file(void)

Overwrite the contents of the directory stack file with the directory stack.
Such file will be a shell script sourceable by calling either the high-level
read_dir_stack_file() or lower-level source_shell_script().
/---
function write_dir_stack_file() {
    die_if_args
    write_file_with_variable "${ZESHY_USER_DIR_STACK_FILE}" dirstack
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename back to restore_dir() *AND* use "-q" below.
#FUXME: Woops. This should be shift_dir_stack_and_set_dir_to_top(), actually.
#Hmmmm; how about either:
#
#* set_dir_to_dir_stack_first_after_shifting().
#* set_dir_to_dir_stack_second_and_shift(). Shorter, but requires thought. The
#  former is much more intelligible. Actually... no! The reverse. This makes
#  much more sense. No time dependencies. It does exactly what it says.
#FUXME: Feck that. No, really. These function names are absurd. We were right
#the first time: restore_dir(). It's not an entirely unambiguously specific
#name, but at least it's bloody memorable *AND* readable. These are all
#illegible nonsense.

#Restore the current working directory to the immediately prior directory on
#the directory stack.

    # Pop off and "cd" to the top directory off the directory stack, implicitly
    # calling set_dir(). (If, in fact, this function was called already
    # by set_dir() due to the latter having been called with no
    # arguments, the second call to set_dir() is called with one
    # argument, thus delimiting recursion.)
#   interactively print_dir_stack

#FUXME: Rename back to store_dir() *AND* forcefully use "-q" below. (I think.)
#FUXME: How is this *NOT* thoroughly superfluous? set_dir() already does this.
#Right. I just can't see the justification for keeping this.
#FUXME: Oh, I get it. This is still needed, as the operation of set_dir()
#depends on the contents of user-configurable options. That's fine; store_dir()
#is a much more appropriate function name, in any case.

#, implicitly invoking
#the chpwd() hook and hence pushing that dirname if valid onto the persistent
#directory stack. This function is the less intelligent step-child of
#set_dir() and hence appropriate for non-interactive scripts.

#   string dirs_output
#       dirs_output="$(builtin dirs -p)"

#FUXME: You know what? Just excise these.
#FUXME: Excise, folding ZESHY_CD_OPTIONS_IF_IDEMPOTENT into
#ZESHY_CD_OPTIONS_IF_NONINTERACTIVE.
#declare_function_with_stdin <<'/---'
#void set_dir_idempotently(string dirname)
#
#Set the current working directory to the passed directory idempotently (i.e.,
#without implicit side effects and hence without implicitly calling builtin
#chpwd() or functions registered with run_hook_after_dir_set()).
#/---
#function set_dir_idempotently() {
#    die_unless_arg 'expected one dirname'
#    run_command_silent_with_options 'command cd'\
#        'ZESHY_CD_OPTIONS ZESHY_CD_OPTIONS_IF_IDEMPOTENT' -- "${(q)1}"
#}

#FUXME: It'd be quite nice to persist the dirstack across shell sessions, as
#Milkman advises with:
#
#DIRSTACKFILE=~/.zdirs
#if [[ -f $DIRSTACKFILE ]] && [[ $#dirstack -eq 0 ]]; then
#  dirstack=( ${(f)"$(< $DIRSTACKFILE)"} )
#  [[ -d $dirstack[1] ]] && cd $dirstack[1] && cd $OLDPWD
#fi
#chpwd() {
#  print -l $PWD ${(u)dirstack} >$DIRSTACKFILE
#}
#
#This brings up a delicate question, however: as with HISTFILE, how do you
#handle multiple concurrent terminals? As I see it, each such terminal should be
#assigned both its own DIRSTACKFILE and its own HISTFILE. It's unclear how to
#implement this is a WM-agnostic fashion -- perhaps via some command-line
#utility retrieving the window title and/or class for the current terminal? It
#certainly seems non-trivial, in any event.
#Respond to the current directory being set by pushing that directory onto the
#directory stack if not already.

#Append the current working directory to the the directory stack file,
#${ZESHY_DIR_STACK_FILE}.
# Unlike set_dir() or set_dir_with_options(), this function carries no hidden
#side effects: it simply sets the current working directory.
#FUXME: Split into interactive and non-interactive versions, requiring a passed
#dirname in the latter case. Name the interactive version
#set_dir_with_options().

#declare_global_with_stdin <<'/---'
#list ZESHY_CD_OPTIONS_IF_IDEMPOTENT
#
#`cd` options if run idempotently (i.e., without implicitly calling chpwd() and
#hence inducing side effects). See set_dir_idempotently() for further details.
#/---
#ZESHY_CD_OPTIONS_IF_IDEMPOTENT=()

#pushing that dirname if valid onto the persistent
#directory stack. Specifically, if:
#
#* Called non-interactively and...
#** No dirname was passed, throw an exception.
#** Else, set the current working dirname to the passed dirname.
#* Called interactively and...
#** No dirname was passed and...
#*** The directory stack is non-empty, pop the top dirname off that stack
#    and set the current working dirname to that directory.
#*** Else, set the current working dirname to the current user''s home.
#* Else, set the current working dirname to the passed dirname.

#   if { is_args } {
#       store_dir "${@}"
#   } elif { is_shell_interactive } {
        # If passed at least one argument, switch to such directory.
        # If the directory stack is non-empty, switch to the prior directory.
#       if { is_list_nonempty dirstack } {
#           restore_dir
        # Otherwise, switch to the home directory.
#       } else {
#           store_dir "$(get_home)"
#       }
#   } else {
#       die 'expected one dirname'
#   }
#}

# ....................{ HOOKS                              }....................
#run_hook_after_dir_set compact_dir_stack

#FUXME: Woops. Turns out this is completely obsoleted by the existing
#${DIRSTACKSIZE} global. Well, let's fix 'er up then!
#FUXME: Auto-compress the stack when it gets too large. Also, we really don't
#want *ANY* duplicates on the stack; we currently only prohibit duplicates on
#the top of the stack. This should be simply to effect by re-typesetting such
#stack with "-U". (Surprised we don't already do that. Do we?)

#declare_function_with_stdin <<'/---'
#void compact_dir_stack(void)
#
#Respond to the current directory being set by pushing that directory onto the
#directory stack if not already. Unlike the "auto_pushd" option activated only
#on cd() calls, zsh activates this hook on every call setting the current
#directory excluding popd() (e.g., cd(), pushd()).
#/---
#function compact_dir_stack() {
#    #FUXME: Define a new truncate_list_to_size() function, implementing such
#    #truncation.
#
#    # If the current user requests a directory stack height maximum and the
#    # current height exceeds this maximum, pop off "excess" directories.
#    is_variable ZESHY_DIR_STACK_MAX_SIZE and
#        (( ${#dirstack} > ZESHY_DIR_STACK_MAX_SIZE )) and
#        dirstack[$(( ZESHY_DIR_STACK_MAX_SIZE + 1 )),-1]=()
#}

#FUXME: Rename to store_dir(). Or perhaps set_dir_and_prepend_dir_stack(). Yes,
#the latter's significantly better.
#FUXME: Actually, perhaps just prepend_dir_stack(). The "set_dir" is
#necessarily implied. Or perhaps prepend_dir_stack_and_set_dir(). Hm; actually,
#push_dir_stack_with_dir(). Unlike restore_dir(), this function actually takes
#an argument. Sweet. push_dir_stack_with_dir() it is! Actually, "push" is a
#fairly poor verb. We have "prepend", so use it: prepend_dir_stack_with_dir().
#Well. Come to think, that isn't really any better than
#store_dir(). At least the latter tells you what's going on.
#FUXME: Rename to set_dir_to_dir_stack_top_and_pop(). Actually, it's a bit more
#convolute than that: it pops first, then sets. So how about
#restore_dir_and_set_dir_to_top(). Interestingly asymmetric with
#store_dir(), which I of course adore. Hmmm...
#FUXME: This component is entitled "stack" -- not "current". Shift all
#*_current_dir*() functions to a new "dir/current" component.

#FUXME: Rename to restore_dir(). Or perhaps
#set_dir_to_dir_stack_top_and_pop(). Yes, the latter's significantly better.
#FUXME: Actually, perhaps just restore_dir(). The "set_dir" is
#necessarily implied.
    #FUXME:
    # If the top directory on the stack is not already the current working
    # directory, push this directory onto the stack.
#   print_message "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   { is_list_empty dirstack or is "${dirstack[1]}" != "${PWD}" si } and
#       dirstack=( "${PWD}" "${dirstack[@]}" )

        #FUXME: Add a new prepend_list() function to "type/list".
#   {
#       is_list_nonempty dirstack and print_message "pwd: ${PWD}\ndirstack[1]: ${dirstack[1]}\ndirstack[-1]: ${dirstack[-1]}"
#   }

#FUXME: Non-ideal. Since we (or someone else) will undoubtedly want to provide
#a chpwd hook, we really want to generalize this into a hook-style interface.
#Does zsh already provide such support, or is this something we need to cook up?
# * It'd be helpful to auto-truncate the directory stack if it gets too tall --
#   say, higher than ${ZESHY_DIRSTACK_MAX_SIZE} (defaulting to 16). Entries
#   should probably be truncated off the bottom, I r'ckon.
# * http://git.grml.org/f/grml-etc-core/etc/zsh/zshrc
#   Helpful chpwd() hook implementation (i.e., persistent dirs).

#   die_unless_args 'expected at least one dirname'
#   command mkdir -p -- "${@}"

#   interactively print_message 'printing the current directory stack...'
#FUXME: It'd be quite nice to improve alias_cli() to accept multiple
#alias names for the same alias. Note this also requires "src/digest" to parse
#such names, as well. *shrug*
#alias_cli mvt='move_to_temporary_dir'

#       integer first_dir_index_to_pop
#       (( first_dir_index_to_pop = ZESHY_DIR_STACK_MAX_SIZE + 1 ))
#       dirstack[${first_dir_index_to_pop},-1]=()
#
#       dirstack+=( "${PWD}" )
#   if is_list_empty dirstack
#   then dirstack+=( "${PWD}" )
#   else is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#   fi
#   (( ${#dirstack} )) or die 'directory stack empty'
#   die_unless_list_nonempty dirstack 'directory stack empty'

# For brevity, alias "cd" to this function.

#FUXME: Doesn't work, sadly. Investigate. (I suspect "src/digest" parses such
#whitespace incorrectly.)
#set_dir cd() {
#   without
#     calling the chpwd() hook or hooks in the ${chpwd_functions} list (i.e.,
#     "run_command_silent"). This prevents unintended pollution of the current user's
#     directory stack with script-specific dirnames.

# ....................{ PUSHERS                            }....................
# void change_

#FUXME: The "autopushd" option already enables this.
# ....................{ HOOKS                              }....................
# void chwpd(void)
#
# Respond to the current working dirname being set by pushing that dirname if
# valid onto the directory stack.
#chpwd() {
#    # If the top directory on the stack is not already the current working
#    # directory, push this directory onto the stack.
#    is "${dirstack[-1]}" == "${PWD}" si or dirstack+=( "${PWD}" )
#}

#           if is "${1}" == (-|+)* si
#           then builtin cd "${@}"
#           else pushd "${@}"
#           fi

#FUXME: Uhm; why doesn't "mkdir --parents" suffice?

    # While there are more paths to consider, shift the current path to be
    # considered to a local variable "new_path" and make it when not found.
#   string new_path
#   while is_args; do
#       new_path="${1}"; shift

#       if is_file "${new_path}"; then
#           die "\"${new_path}\" already a file"
#       elif not is_dir "${new_path}"; then
#           print_message "making \"${new_path}\"..."
#           mkdir --parents "${new_path}"
#       fi
#   done

# void make_parent_directory_if_not_found(string pathname)
#
# Make the parent directory of the passed path, if not found.
#make_parent_directory_if_not_found() {
#    die_unless_arg 'expected one pathname'
#    make_dir_if_not_found "$(dirname "${1}")"
#}

#cd() {
#  if [ -z "$1" ]
#  then popd
#  else pushd "$@"
#  fi
#}

# Get the absolute canonical path (i.e., containing no symbolic links) of the
# current working directory.

#   readlink --canonicalize-existing "${1}"
# string which_command(string command_name)
#
# If found, get the absolute path to the command with the passed name;
# otherwise, return false. All but the first whitespace-delimited word of this
# string is ignored: e.g.,
#
#     >>> which_command zsh
#     /bin/zsh
#     >>> which_command "zsh -x -o shwordsplit scr"
#     /bin/zsh
#which_command() {
#    die_unless_arg 'expected one command name'
#    string command_name="${1[(w)1]}"
#    string command_path="${command_name:c}"
#
#    # If no such command exists, print an error message and return with failure.
#    if is "${command_path:c}" != /* si; then
#        print_warning "\"${command_name}\" not found"
#        return_false
#    fi
#
#    # Otherwise, print the absolute path of this command.
#    print "${command_path}"
#}

#   if not command_path="$(whence -p "${command_name}")"; then
#
# ....................{ FILENAMES ~ lists                 }....................
# string *get_filenames(string dirname = '')
#
# Return a stringified list of all files in the passed directory or, if no such
# directory was passed, the current working directory. Callers should
# destringify the return value by calling the expand_list() function.
#get_filenames() {
#    die_unless_args_0_to_1 'expected at most one optional dirname'
#    string dirname="${1:-${PWD}}"
#    die_unless_dir "${dirname}"
#    list filenames; filenames=( "${dirname}"/*(N) )
#    return_list filenames
#}

#      file --mime-encoding "${pathname}" | grep --quiet ': binary$'
#      file --mime-encoding "${pathname}" | grep --quiet --invert-match ': binary$'

#       die "neither \"${user_temporary_dir}\" or \"${root_temporary_dir}\""\
#           "found; no temporary directory found"
#alias -g get_filenames="( *(N) )"

#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#lias get_next_arg_as='string __tmp__="${1}"; shift; print "${__tmp__}"'
#       filename="$(get_next_arg)"
#       get_next_arg_as filename
