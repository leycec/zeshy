#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Match path list globs and glob qualifiers.
#
# --------------------( SEE ALSO                           )--------------------
# Section "Glob Qualifiers" of "man zshexpn"
#   Reference documentation on glob qualifiers.

# ....................{ TESTERS                            }....................
document_function '
boolean is_path_match_qualifiers(string pathname, string glob_qualifiers)

Return true if the passed path matches all glob qualifiers in the passed string.
Such string may be either parens-delimited (e.g., "(^-U)") or not (e.g., "^-U").
See section "Glob Qualifiers" in "man zshexpn" for further details: e.g.,

  # Make an empty directory and test such directory for emptiness.
  >>> make_dir nihil
  >>> is_path_match_qualifiers nihil "/^F" and print_string obstat
  obstat
'
function is_path_match_qualifiers() {
    # Validate passed arguments.
    die_unless_args_2 'expected one pathname and one string of glob qualifiers'
    string pathname="${1}" glob_qualifiers="${2}"

    # If such path exists, match such qualifiers. Since no string of glob
    # qualifiers ever matches a nonextant path, exclude such paths.
    is_path "${pathname}" and {
        # If such qualifiers are not already parens-delimited, do so.
        is_string_match "${glob_qualifiers}" '\((|\#q)*\)' or
            glob_qualifiers="(#q${glob_qualifiers})"

        # Perform such match, ignoring non-fatal errors induced by such match.
        list pathname_match
        pathname_match=( "${pathname}"${~glob_qualifiers} ) or true
        is_list_nonempty pathname_match
    }
}

# ....................{ GETTERS                            }....................
#FIXME: Generalize to accept any glob as under is_path_match_qualifiers() and rename to
#get_path_match_qualifiers_first(). This requires wrapping current arguments in "()".
#Also reorder arguments as follows:

document_function '
string get_path_match_qualifiers_first(
  string pathname1, string pathname2, ...,
  string glob_qualifiers,
  string label_if_singular, string label_if_plural)

Get the first passed pathname matching the passed glob or throw an exception.
In the latter case, interpolate the passed human-readable singular or plural
labels into the resulting exception message: e.g.,

  # Get the first owner-writable subdirectory of a newly created directory.
  >>> make_dir "imprimi_potest/{imprimatur,censorship}"
  >>> get_first_path_match "imprimi_potest" "(w/)"\
  ...     "an owner-writable directory" "owner-writable directories"
  imprimatur
'
function get_first_path_match() {
    # Validate passed arguments.
    die_unless_args_4_or_more\
        'expected at least one pathname, one glob, one singular label, and one plural label'
    string\
        label_if_singular="${@[-2]}" label_if_plural="${@[-1]}" first_pathname
    curtail_args_2

    # If at least one argument matches such glob qualifiers, return the first.
    if first_pathname="$(get_first_path_match_if_found "${@}")"
    then print_string "${first_pathname}"
    # Otherwise, throw an exception.
    else
        # For list indexing convenience, pop off the passed glob.
        curtail_arg

        #FIXME: Whatever gettext() interface we support will certainly include
        #support for plurality. See "terminal/locale" for further discussion.
        # Throw a differing error message depending on argument plurality.
        if is_args_1
        then die "\"${1}\" not found or not ${label_if_singular}"
        else die "$(join_list_conjunctively "${@}") not found or not ${label_if_plural}"
        fi
    fi
}

document_function '
string get_first_path_match_if_found(
  string pathname1, string pathname2, ..., string glob)

Get the first passed pathname matching the passed glob or return false.
'
function get_first_path_match_if_found() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected at least one pathname and one glob'
    string glob="${@[-1]}"
    curtail_arg

    # If at least one path matches, return the first; otherwise, failure.
    list pathname_match; pathname_match=( "${^@}"${~glob} ) or true
    if is_list_nonempty pathname_match
    then print_string "${pathname_match[1]}"
    else return_false
    fi
}

# ....................{ GETTERS ~ file                     }....................
#FIXME: Rename to get_file_first() and similarly below.

document_function '
string get_first_file(string filename1, string filename2, ...)

Get the first passed extant file after resolving symbolic links or throw an
exception.
'
function get_first_file() {
    die_unless_args 'expected at least one filename'
    get_first_path_match "${@}" '(-.)' 'a file' 'files'
}

document_function '
string get_first_file_if_found(string filename1, string filename2, ...)

Get the first passed extant file after resolving symbolic links or return
false.
'
function get_first_file_if_found() {
    die_unless_args 'expected at least one filename'
    get_first_path_match_if_found "${@}" '(-.)' 'a file' 'files'
}

# ....................{ GETTERS ~ dir                      }....................
document_function '
string get_first_dir(string dirname1, string dirname2, ...)

Get the first passed extant directory after resolving symbolic links or throw
an exception.
'
function get_first_dir() {
    get_first_path_match "${@}" '(-/)' 'a directory' 'directories'
}

document_function '
string get_first_dir_writable(string dirname1, string dirname2, ...)

Get the first passed extant directory writable by the current user after
resolving symbolic links or throw an exception.
'
function get_first_dir_writable() {
    get_first_path_match\
        "${@}" '(-e{[[ -d $REPLY && -w $REPLY ]]})'\
        'a writable directory' 'writable directories'
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Hmm; does non-zero exit status actually indicate a match failure in
        #all possible cases? Negligibly minor optimization, but somewhat
        #intellectually intriguing.

#, expanded immediately after expanding such path and hence equivalent to "${pathname}"${~glob}
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, Zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
#FUXME: We should probably rename all functions matching is_*_match() to
#is_*_matching_*() (e.g., from is_string_match() to is_string_matching(), from
#is_string_line_match_pcre() to is_string_matching_pcre_line()). Extending this
#to get_*_match() functions seems somewhat absurd, however: e.g., from
#list_string_line_match_pcre() to get_string_matching_pcre_line() is terrible
#and doesn't even make sense.
# boolean is_path_match_qualifiersing_glob_qualifier(
#function is_path_match_qualifiersing_glob_qualifier() {

#
        #Interestingly, this also allows us to obsolete the need to explicitly
        #pass in human-readable labels. Indeed, I now believe we should entirely
        #excise the passed ${match_type_singular} and ${match_type_plural}
        #arguments in favor of an internal lookup table from 
