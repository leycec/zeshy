#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path globs and glob qualifiers.
#
# --------------------( SEE ALSO                           )--------------------
# Section "Glob Qualifiers" of "man zshexpn"
#   Reference documentation on glob qualifiers.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
boolean is_path_qualified(string pathname, string glob_qualifier)

Return true if the passed path matches all glob qualifiers in the passed string.
Such string may be either parens-delimited (e.g., "(^-U)") or not (e.g., "^-U").
See section "Glob Qualifiers" in "man zshexpn" for further details: e.g.,

.is_path_qualified()
==========================================
[source]
------------------------------------------
# Make an empty directory and test such directory for emptiness.
>>> make_dir nihil
>>> is_path_qualified nihil "/^F" and print_string "obstat"
obstat
------------------------------------------
==========================================
________________<heredoc?>________________
function is_path_qualified() {
    # Validate passed arguments.
    die_unless_args_2 'expected one pathname and one glob qualifier'
    string pathname="${1}" glob_qualifier="${2}"

    # If such path exists, match such qualifier. Since no glob qualifier ever
    # matches a nonextant path, ignore nonextant paths.
    is_path_exists "${pathname}" and {
        # Convert such qualifier to a proper qualifier, if not already.
        glob_qualifier="$(convert_string_to_glob_qualifier "${glob_qualifier}")"

        # Perform such match, ignoring non-fatal errors induced by such match.
        list pathname_match
        pathname_match=( "${pathname}"${~glob_qualifier} ) or true
        is_list_nonempty pathname_match
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_path_matches_qualified(
    string list_name, string glob, string glob_qualifier)

Set the passed list to all paths matching the passed glob under the passed
glob qualifier: e.g.,

.set_list_to_path_matches_qualified()
==========================================
[source]
------------------------------------------
# Set this list to all temporary files more than 40,000 days old.
>>> list great_old_ones
>>> set_list_to_path_matches_qualified great_old_ones "/tmp/**/*" "a+40000"
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_path_matches_qualified() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one glob, and one glob qualifier'
    string\
        list_name__sltpmq="${1}"\
        glob__sltpmq="${2}"\
        glob_qualifier__sltpmq="${3}"
    die_unless_list "${list_name__sltpmq}"

    # Convert such qualifier to a proper qualifier, if not already.
    glob_qualifier__sltpmq="$(convert_string_to_glob_qualifier\
        "${glob_qualifier__sltpmq}")"

    # Set such list. Since such setting tends to return spurious non-zero exit
    # status (e.g., if any globbed path is not readable by the current user),
    # ignore such status.
    eval "${list_name__sltpmq}=( ${glob__sltpmq}${glob_qualifier__sltpmq} )" or
        true
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string convert_string_to_glob_qualifier(string text)

Convert the passed string to a glob qualifiers string (i.e., embedded in parens
ideally prefixed by `#q`), if not already.
________________<heredoc?>________________
function convert_string_to_glob_qualifier() {
    # Validate passed arguments.
    die_unless_arg 'expected one string'
    string glob_qualifier="${1}"

    # If such qualifier is not already parens-delimited, do so.
    is_string_glob_matches "${glob_qualifier}" '\((|\#q)*\)' or
        glob_qualifier="(#q${glob_qualifier})"

    # Return such qualifier.
    return_string "${glob_qualifier}"
}

# --------------------( WASTELANDS                         )--------------------
#       "${list_name__sltpmq}" '${~glob__sltpmq}${~glob_qualifier__sltpmq}'
#   die_unless_path_exists "${pathname}"
        # If such qualifiers are not already parens-delimited, do so.
#       is_string_glob_matches "${glob_qualifier}" '\((|\#q)*\)' or
#           glob_qualifier="(#q${glob_qualifier})"

        #FUXME: Hmm; does non-zero exit status actually indicate a match failure in
        #all possible cases? Negligibly minor optimization, but somewhat
        #intellectually intriguing.

#, expanded immediately after expanding such path and hence equivalent to "${pathname}"${~glob}
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
#FUXME: We should probably rename all functions matching is_*_match() to
#is_*_matching_*() (e.g., from is_string_glob_matches() to is_string_matchesing(), from
#is_string_pcre_multiline_matches() to is_string_matchesing_pcre_line()). Extending this
#to get_*_match() functions seems somewhat absurd, however: e.g., from
#get_string_pcre_multiline_match_index_all() to get_string_matching_pcre_line() is terrible
#and doesn't even make sense.
# boolean is_path_qualifieding_glob_qualifier(
#function is_path_qualifieding_glob_qualifier() {

#
        #Interestingly, this also allows us to obsolete the need to explicitly
        #pass in human-readable labels. Indeed, I now believe we should entirely
        #excise the passed ${match_type_singular} and ${match_type_plural}
        #arguments in favor of an internal lookup table from 
