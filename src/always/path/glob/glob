#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *glob qualifiers* (i.e., `(#q`- and `)`-delimited expressions suffixing
path-specific globs).

== See Also ==

* Section ``Glob Qualifiers'' of `man zshexpn`, documenting such qualifiers.
/---

#FIXME: Shift to @{00-core}.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_path_matches_glob_qualifier(
    string glob,
    string glob_qualifier1, string glob_qualifier2, ...)

Return success if at least one existing path matches the passed glob _and_ all
passed glob qualifiers, each of which may be either parens-delimited
(e.g., `(^-U)`) or not (e.g., `^-U`): e.g.,

.is_path_matches_glob_qualifier()
==========================================
[source]
------------------------------------------
>>> make_dir on_diversity
>>> is_path_matches_glob_qualifier\
...     ?n_d?v?rs?t? '/^F' 'u'"$(get_user)" and print_string\
...     "There are many kinds of gods. Therefore there are many kinds of men."
There are many kinds of gods. Therefore there are many kinds of men.
------------------------------------------
==========================================
/---
function is_path_matches_glob_qualifier() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one pathname and one glob qualifier'
    string glob="${1}"
    list pathnames
    shift_arg

    # Delimit such qualifiers, if not already.
    glob+="$(convert_strings_to_glob_qualifiers "${@}")"

    # Perform such match, ignoring non-fatal errors induced by such match. See
    # set_list_to_paths_matching_glob_qualifier() for further details.
    pathnames=( ${~glob} ) or ignore_exit_status
    is_list_nonempty pathnames
}

# ....................{ SETTERS                            }....................
#FIXME: Improve example.
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_paths_matching_glob_qualifier(
    string list_name,
    string glob,
    string glob_qualifier, string glob_qualifier2, ...)

Set the passed list to all existing paths matching the passed glob _and_ all
passed glob qualifiers, each of which may be either parens-delimited (e.g.,
`(^-U)`) or not (e.g., `^-U`): e.g.,

.set_list_to_paths_matching_glob_qualifier()
==========================================
[source]
------------------------------------------
# List all temporary files more than 40,000 days old.
>>> list great_old_ones
>>> set_list_to_paths_matching_glob_qualifier great_old_ones "/tmp/**/*" "a+40000"
------------------------------------------
==========================================
/---
function set_list_to_paths_matching_glob_qualifier() {
    # Validate passed arguments.
    die_unless_args_3_or_more\
        'expected one list name, one glob, and one or more glob qualifiers'
    string list_name__sltpmq="${1}" glob__sltpmq="${2}"
    die_unless_list "${list_name__sltpmq}"
    shift_args 2

    # Delimit such qualifiers, if not already.
    glob__sltpmq+="$(convert_strings_to_glob_qualifiers "${@}")"

    # Set such list. Since such setting tends to return spurious non-zero exit
    # status (e.g., if any globbed path is not readable by the current user),
    # ignore the resulting status.
    eval ${list_name__sltpmq}'=( ${~glob__sltpmq} )' or ignore_exit_status
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string convert_strings_to_glob_qualifiers(
    string glob_qualifier, string glob_qualifier2, ...)

Convert each passed string to a *glob qualifier* delimited by `(#q` and `)`, if
not already, returning the concatenation of such qualifiers: e.g.,

.convert_strings_to_glob_qualifiers()
==========================================
[source]
------------------------------------------
>>> convert_strings_to_glob_qualifiers '-.' 'a+40000'
(#q-.)(#qa+40000)
------------------------------------------
==========================================
/---
function convert_strings_to_glob_qualifiers() {
    # Validate passed arguments.
    die_unless_args 'expected one or more string'

    # If only passed one such qualifier and such qualifier is not already
    # delimited by either `(` and `)` *OR* `(#q` and `)`, delimit such qualifier
    # by the latter. This logic differs slightly from that when passed more than
    # one such qualifier, since in the latter case `(` and `)` qualifiers
    # constitute invalid syntax and hence must be replaced.
    #
    # For efficiency, inline such test both here and below.
    if { is_arg and is "${glob_qualifier}" != '('(|'#q')*')' si } {
        return_string "(#q${glob_qualifier})"
    } else {
    # Else, more than one such qualifier was passed. For each such qualifier not
    # already delimited by `(#q` and `)`, do so. If such qualifier is unsafely
    # already delimited by `(` and `)`, convert the `(` to `(#q`. The reason is
    # subtle: qualifier syntax permits `(` prefixes only if there exists one such
    # qualifier; in all other cases, `(#q` prefixes are required instead.
        string glob_qualifier glob_qualifiers
        for    glob_qualifier ("${@}") {
            if is "${glob_qualifier}" != '(#q'*')' si {
                glob_qualifiers+="(#q${${glob_qualifier#(}%)})"
            } else {
                glob_qualifiers+="${glob_qualifier}"
            }
        }
        return_string "${glob_qualifiers}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_path "${pathname}"

#Return success if at least one path matches all passed glob qualifiers, each of
#which may be either parens-delimited (e.g., `(^-U)`) or not (e.g., `^-U`): e.g.,

#FUXME: Create a new is_path_matches_glob_qualifier() accepting a glob as well.

    # Return such qualifier.
#   output_string "${glob_qualifier}"
#FUXME: Rename to convert_strings_to_glob_qualifiers().

    # If such path exists, match such qualifier. Since no glob qualifier ever
    # matches a nonextant path, ignore nonextant paths.
#   is_path "${pathname}" and {

#. See section "Glob Qualifiers" in "man zshexpn" for further details
#       "${list_name__sltpmq}" '${~glob__sltpmq}${~glob_qualifier__sltpmq}'
#   die_unless_path "${pathname}"
        # If such qualifiers are not already parens-delimited, do so.
#       is_string_matches_glob "${glob_qualifier}" '\((|\#q)*\)' or
#           glob_qualifier="(#q${glob_qualifier})"

        #FUXME: Hmm; does non-zero exit status actually indicate a match failure in
        #all possible cases? Negligibly minor optimization, but somewhat
        #intellectually intriguing.

#, expanded immediately after expanding such path and hence equivalent to "${pathname}"${~glob}
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
#FUXME: We should probably rename all functions matching is_*_match() to
#is_*_matching_*() (e.g., from is_string_matches_glob() to is_string_matchesing(), from
#is_string_matches_pcre_multiline() to is_string_matchesing_pcre_line()). Extending this
#to get_*_match() functions seems somewhat absurd, however: e.g., from
#get_string_pcre_multiline_match_index_all() to get_string_matches_pcre_line() is terrible
#and doesn't even make sense.
# boolean is_path_matches_glob_qualifiering_glob_qualifier(
#function is_path_matches_glob_qualifiering_glob_qualifier() {

#
        #Interestingly, this also allows us to obsolete the need to explicitly
        #pass in human-readable labels. Indeed, I now believe we should entirely
        #excise the passed ${match_type_singular} and ${match_type_plural}
        #arguments in favor of an internal lookup table from 
