#!/usr/bin/env zsh
# ====================[ first                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the first path matching globs and glob qualifiers.

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_path_qualified_first(
    string pathname1, string pathname2, ...,
    string glob_qualifiers,
    string label_if_singular, string label_if_plural)

Get the first passed path matching the passed glob qualifier or throw an
exception if no such path matches such qualifier, in which case embed the passed
human-readable singular or plural label into the resulting exception message
(depending on whether one or more than one paths were passed): e.g.,

.get_path_qualified_first()
==========================================
[source]
------------------------------------------
# Get the first owner-writable subdirectory of a newly created directory.
>>> make_dir "imprimi_potest/{imprimatur,censorship}"
>>> get_path_qualified_first "imprimi_potest/"* "w/"\
...     "an owner-writable directory" "owner-writable directories"
imprimatur
------------------------------------------
==========================================
/---
function get_path_qualified_first() {
    # Validate passed arguments.
    die_unless_args_4_or_more\
        'expected at least one pathname, one glob, one singular label, and one plural label'
    string\
        label_if_singular="${@[-2]}" label_if_plural="${@[-1]}" first_pathname
    pop_args 2

    # If at least one argument matches such glob qualifiers, return the first.
    if { first_pathname="$(get_path_qualified_first_if_found "${@}")" } {
        return_string "${first_pathname}"
    # Otherwise, throw an exception.
    } else {
        # For list indexing convenience, pop off the passed glob.
        pop_arg

        #FIXME: Whatever gettext() interface we support will certainly include
        #support for plurality. See "terminal/locale" for further discussion.
        # Throw a differing error message depending on argument plurality.
        if { is_arg } {
            die "\"${1}\" not found or not ${label_if_singular}"
        } else {
            die "$(join_strings_for_message "${@}") not found or not ${label_if_plural}"
        }
    }
}

#FIXME: Generalize to accept any glob as under is_path_qualified(). This
#requires wrapping current arguments in "()". Just call
#convert_string_to_glob_qualifier(), in other words.
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_path_qualified_first_if_found(
  string pathname1, string pathname2, ..., string glob_qualifier)

Get the first passed path matching the passed glob qualifier or return false if
no such path matches such qualifier.
/---
function get_path_qualified_first_if_found() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected at least one pathname and one glob'
    string glob_qualifier="${@[-1]}"
    pop_arg

    # Convert such qualifier to a proper qualifier, if not already.
    glob_qualifier="$(convert_string_to_glob_qualifier "${glob_qualifier}")"

    # If at least one path matches, return the first; otherwise, failure.
    list pathname_match; pathname_match=( "${^@}"${~glob_qualifier} ) or true
    if { is_list_nonempty pathname_match } {
        return_string "${pathname_match[1]}"
    } else {
        return_false
    }
}

# ....................{ GETTERS ~ file                     }....................
declare_function_with_stdin <<'/---'
string get_file_first(string filename1, string filename2, ...)

Get the first passed extant file after deeply resolving symbolic links or throw
an exception if no such file exists.
/---
function get_file_first() {
    die_unless_args 'expected at least one filename'
    get_path_qualified_first "${@}" '-.' 'a file' 'files'
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_file_first_if_found(
    string filename1, string filename2, ...)

Get the first passed extant file after resolving symbolic links or return
failure if no such file exists.
/---
function get_file_first_if_found() {
    die_unless_args 'expected at least one filename'
    get_path_qualified_first_if_found "${@}" '-.' 'a file' 'files'
}

# ....................{ GETTERS ~ dir                      }....................
declare_function_with_stdin <<'/---'
string get_dir_first(string dirname1, string dirname2, ...)

Get the first passed extant directory after resolving symbolic links or throw
an exception if no such directory exists.
/---
function get_dir_first() {
    get_path_qualified_first "${@}" '-/' 'a directory' 'directories'
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_dir_first_if_found(
    string dirname1, string dirname2, ...)

Get the first passed extant directory after resolving symbolic links or return
failure if no such directory exists.
/---
function get_dir_first_if_found() {
    die_unless_args 'expected at least one dirname'
    get_path_qualified_first_if_found "${@}" '-/' 'a directory' 'directories'
}

# ....................{ GETTERS ~ dir : writable           }....................
declare_function_with_stdin <<'/---'
string get_dir_writable_first(string dirname1, string dirname2, ...)

Get the first passed extant directory writable by the current user after
resolving symbolic links or throw an exception if no such directory exists.
/---
function get_dir_writable_first() {
    get_path_qualified_first\
        "${@}" '-e{[[ -d $REPLY && -w $REPLY ]]}'\
        'a writable directory' 'writable directories'
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_dir_writable_first_if_found(
    string dirname1, string dirname2, ...)

Get the first passed extant directory writable by the current user after
resolving symbolic links or return failure if no such directory exists.
/---
function get_dir_writable_first_if_found() {
    get_path_qualified_first_if_found\
        "${@}" '-e{[[ -d $REPLY && -w $REPLY ]]}'\
        'a writable directory' 'writable directories'
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: We arguably want a new "glob" directory and a new "first" component in
#such directory containing such functionality. It's a bit much for just a core
#"glob" component.
