#!/usr/bin/env zsh
# ====================[ symbolic                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle symbolic links.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_link_symbolic(
  string pathname,
  string error_message = "\"${pathname}\" not a symbolic link")

Throw an exception with the passed message unless the passed symbolic link
exists.
'
function die_unless_link_symbolic() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_link_symbolic "${pathname}" or
        die "${2:-\"${pathname}\" not a symbolic link}"
}

# ....................{ WARNINGS                           }....................
document_function '
cry_if_link_symbolic_broken(string pathname1, string pathname2, ...)

Print a warning for each passed broken symbolic link. See
is_link_symbolic_broken() for further details.
'
function cry_if_link_symbolic_broken() {
    # Validate passed arguments.
    die_unless_args_1_or_more 'expected at least one pathname'

    # Print a warning for all shifted paths that are broken symbolic links.
    for pathname ("${@}") {
        is_link_symbolic_broken "${pathname}" and {
            string pathname_target
            pathname_target="$(get_link_symbolic_target "${pathname}")"
            print_warning "symbolic link \"${pathname}\" target \"${pathname_target}\" not found"
        }
    }

    # If the last such path is not a broken symbolic link, the prior conditional
    # returns false. Avoid returning false from this function by forcefully
    # returning true, here.
    return_true
}

document_function '
void cry_if_link_symbolic_broken_after_copy_or_move_path(
  string source_pathname1, string source_pathname2, ...,
  string target_pathname)

Print a warning for each passed broken symbolic link after copying or moving
paths. This utility is intended to be called only by the copy_path*() and
move_path*() functions.
'
function cry_if_link_symbolic_broken_after_copy_or_move_path() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected at least one source pathname and one target pathname'

    # List of target pathnames to be tested for broken symbolic links.
    list target_pathnames

    # If passed two arguments and...
    if is_args_2; then
        # The second passed argument is a directory, the target pathname is such
        # argument appended with the basename of the first passed argument.
        if is_dir "${2}"
        then target_pathnames=( "${2}/${1:t}" )
        # Otherwise, the second passed argument is itself the target pathname.
        else target_pathnames=( "${2}" )
        fi
    # If passed three or more arguments, the latter is the target dirname. Find
    # the target pathnames by appending the basename of each source pathname to
    # such dirname. Dismantled, this is:
    #
    # * "${@[-1]}", expanding to the target pathname. Since at least three paths
    #   were passed and the underlying copy or move command returned
    #   successfully, this is always a dirname.
    # * "${^@[1,-2]:t}", iteratively expanding to the basename for each passed
    #   target pathname.
    else target_pathnames=( "${@[-1]}/${^@[1,-2]:t}" )
    fi

    # Print such warnings.
    cry_if_link_symbolic_broken "${target_pathnames[@]}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_link_symbolic(string pathname)

Return true if the passed path is an existing symbolic link.
'
function is_link_symbolic() {
    die_unless_arg 'expected one pathname'
    is -L "${1}" si
}

document_function '
boolean is_link_symbolic_broken(string pathname)

Return true if the passed path is an existing broken symbolic link (i.e., is
an existing symbolic link whose link target no longer exists).
'
function is_link_symbolic_broken() {
    # Validate passed arguments.
    die_unless_arg 'expected one pathname'
    string pathname="${1}"

    # Test such path. Dismantled, this is:
    #
    # * "link_symbolic_broken", an empty list if the passed symbolic link is
    #   unbroken; else, a single-element list. Define such list with:
    #   * "${pathname}"(...), filtering the passed path with glob qualifiers:
    #     * "-", transitively resolving the passed symbolic link to its final
    #       destination. If this is merely another symbolic link, the passed
    #       symbolic link is broken; else, this is a non-symbolic link (i.e.,
    #       physical file) and the passed symbolic link is unbroken.
    #     * "@", excluding non-symbolic links. When combined with the prior
    #       "-", this filters unbroken symbolic links into the empty string.
    #       (zsh first resolves the passed symbolic link to its destination and
    #       then tests whether that destination is itself a symbolic link.)
    #
    # See http://www.zsh.org/mla/users/2005/msg00394.html for Peter Stephenson's
    # clever inspiration.
    is_link_symbolic "${pathname}" and
        is_path_qualified "${pathname}" '-@'
}

# ....................{ GETTERS                            }....................
document_function '
string get_link_symbolic_target(string filename)

Get the immediate target of the passed symbolic link. This function does *NOT*
resolve intermediate symbolic links or guarantee such target to be absolute or
extant. Consider calling canonicalize_path() for such resolution.
'
function get_link_symbolic_target() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_link_symbolic "${filename}"

    # Alas, but zsh itself appears to supply no means of printing the immediate
    # target of a symbolic link. Resort to core utilities, instead.
    readlink -- "${filename}"
}

# --------------------( WASTELANDS                         )--------------------
#       list link_symbolic_broken; link_symbolic_broken=( "${pathname}"(-@) )
#       is_list_nonempty link_symbolic_broken
        #FUXME: We *REALLY* want a path glob helper. Don't we already have one?
        #Call such helper instead.
#FUXME: Take care when calling this function with "-"-prefixed arguments.
#FUXME: Generalize this function just to accept source pathnames -- exclude the
#final target pathname.
#FUXME: Rename to cry_if_link_symbolic_broken() and shift to "path/link".

# Get the physical path to which the passed symbolic link directly links.
# (i.e., resolving all intermediate symbolic links). The resulting path is
# guaranteed to be neither absolute or extant. See canonicalize_path() for an
# alternative guaranteeing absolute and extant return values.
    # Dismantled, this is:
    #
    # * "(:A)", expanding to the absolute path of such directory if relative and
    #   resolving symbolic links in such path to their non-symbolic targets.
#   print_string "${filename}"(:A)

    # See is_link_symbolic_broken() for related discussion.
#   list link_symbolic_target; link_symbolic_target=( "${filename}"(-) )
#   print_string "${link_symbolic_target[1]}"

#   string source_pathname="${1}" target_filename="${2}"
#   die_unless_file "${source_pathname}"
#
#   if is_link_symbolic "${target_filename}"; then
#       ln -sf "${source_pathname}" "${target_filename}"
#   else
#       die_if_file "${target_filename}"
#       ln -s  "${source_pathname}" "${target_filename}"
#   fi
