#!/usr/bin/env zsh
# ====================[ permission                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path permissions.

# ....................{ ALIASES                            }....................
#FIXME: Uncomment when working.
#interactive_abbreviation {cho}wn{r}ecursive='set_path_ownership_recursively_interactively'
#interactive_substitution {cho}wn='set_path_ownership_interactively'

#FIXME: Implement.
#interactive_substitution {chg}rp='set_path_group'

#FIXME: Enable. This requires we augment set_path_creation_mask() to call
#print_path_creation_mask() when called interactively directly with no args.
#Actually, that suggests a new function set_path_creation_mask_interactively().
#No need to muddy the pure intent of set_path_creation_mask().
#interactive_alias umask='umask -S'

# ....................{ SETTERS                            }....................
declare_function '
string set_path_creation_mask(string permissions)

Set the global "umask" (i.e., user mask) for the current shell to the passed
human-readable comma-delimited string of all permissions to be allowed. All
other permissions default to denied: e.g.,

    # Allow all users and groups except the current user and group from
    # reading subsequent paths created by such user and group. You really
    # don''t want to do this.
    >>> set_path_creation_mask o=rwX
'
function set_path_creation_mask() {
    die_unless_arg 'expected one permissions string'
    string permissions="${1}"
    builtin umask -- "${permissions}"
}

# ....................{ PRINTERS                           }....................
declare_function '
string print_path_creation_mask(void)

Print a human-readable  permission modifiers with which the current shell creates new paths.
'
function print_path_creation_mask() {
    # Validate passed arguments. "umask -S" prints a symbolic representation of
    # such mask resembling "u=rwx,g=rx,o=". Unlike human-readable "chmod" input
    # (e.g., "u+rwx,g+rx-w,o-rwx"), "umask -S" print_string fails to specify whether
    # such permissions are enabled or disabled. In fact, it is the former.
    # Since this is not necessarily intuitive, convert the symbolic
    # representation print_string by "umask -S" to that input by "chmod".
    # Unsurprisingly, this is a convolute munging.
    die_if_args
    string\
        symbol_umask symbols\
        symbol_name symbol_accepts symbol_forbids
    list symbol_types symbol_flags symbol_accepts_flags symbol_forbids_flags

    # Split "umask -S" print_string on commas.
    symbol_umask="$(builtin umask -S)"
    set_list_to_string_split_on_delimiter "${symbol_umask}" ',' symbol_types

    # For each of the three permission types (i.e., user, group, and other),
    # split such type on "=", convert the right-hand side of such split to a
    # list of at most three permissions (e.g., from a string "rw" to a list
    # "( r w )"), and difference the list "( r w x )" with such list. The
    # result is the list of all disabled permissions.
    symbol_flags=( 'r' 'w' 'x' )
    for symbol_type ("${symbol_types[@]}") {
        # Get the list of all disabled permissions.
        set_strings_to_string_split_on\
            symbol_name symbol_accepts "${symbol_type}" '='
        set_list_to_string_split_on_characters\
            symbol_accepts_flags "${symbol_accepts}"
        set_list_to_list_difference\
            symbol_forbids_flags symbol_flags symbol_accepts_flags
#       print_string "symbol_accepts_flags: ${symbol_accepts_flags[@]}"
#       print_string "symbol_forbids_flags: ${symbol_forbids_flags[@]}"

        # By default, list expansion delimits elements with spaces. Avoid this.
        symbol_forbids="$(join_list_undelimited symbol_forbids_flags)"

        # Avoid prefixing empty permissions with "+" and "-" symbols.
        if is_string_nonempty "${symbol_accepts}" and is_string_nonempty "${symbol_forbids}"
        then symbols+="${symbol_name}+${symbol_accepts}-${symbol_forbids},"
        elif is_string_nonempty "${symbol_accepts}"
        then symbols+="${symbol_name}+${symbol_accepts},"
        else symbols+="${symbol_name}-${symbol_forbids},"
        fi
    }

    # Remove the trailing comma accidentally appended by the final iteration.
    symbols="$(remove_string_suffix "${symbols}" ',')"

    # Print.
    print_string "path creation mask (umask):
  in octal:   $(builtin umask)
  in symbols: ${symbols}"
}

# --------------------( WASTELANDS                         )--------------------
#permissions format:
#(e.g., "ugo+rX", enabling the
#read and execute bits if already executable for all users). .

    #FUXME: Sweet; but I wonder if there's a more intuitive way to call this.
    #Would something like the following work?:
    #   append_list_with_lists_locally <ZESHY_CHMOD_OPTIONS <ZESHY_CHMOD_OPTIONS_IF_RECURSIVE
    #FUXME: Obviously insufficient, due to "--". Replace with above approach.
#   set_path_permissions_interactively\
#       "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}" "${@}"

#   string permissions="${1}"
#   shift_arg

    # If passed one argument, default the path to the current working directory.
#   is_args or set_args "$(get_current_dir)"

    # Change permissions.
#   run_command_with_options\
#       'command chmod' ZESHY_CHMOD_OPTIONS "${permissions}" "${(q)@}"

# --------------------( SEE ALSO                           )--------------------
# Zeshy File Mask
#   Handles default file creation permissions (i.e., umask).
    # Validate passed arguments.
#   die_unless_argss\
#       'expected one permissions string and zero or more paths'
#   string permissions="${1}"
#   shift_arg

    # If passed one argument, default the path to the current working directory.
#   is_args_0 and set_args "$(get_current_dir)"

    # Change permissions.
#   list zeshy_chmod_options; zeshy_chmod_options=(
#       "${ZESHY_CHMOD_OPTIONS[@]}"
#       "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}"
#   )
#   run_command_with_options 'command chmod' 'zeshy_chmod_options'\
#       "${permissions}" "${(q)@}"
    #FIXME: Create a new 'type/string/pcre' method for global substitution.
#   print_string "path creation mask (umask): $(umask) (octal); $(umask -S) (symbolic)"
#   print_string "path creation mask (umask): $(umask) (octal) {$(umask -S) (symbolic)}"
#   print_string "path creation mask (umask): octal $(umask) {symbolic $(umask -S)}"
#   print_string "path creation mask (umask): $(umask) {$(umask -S)}"
#   print_string "path creation mask (umask): $(umask) [symbolic $(umask -S)]"
#   print_string "umask: $(umask) ($(umask -S))"
#   print_string "global path creation mask (umask): $(umask) (symbolically, $(umask -S))"
