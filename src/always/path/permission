#!/usr/bin/env zsh
# ====================[ permission                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle path permissions.

# ....................{ ALIASES                            }....................
#FIXME: Uncomment "chown" aliases when working.
interactive_abbreviation {chm}od{r}ecursive='set_path_permissions_recursively_interactively'
#interactive_abbreviation {cho}wn{r}ecursive='set_path_ownership_recursively_interactively'
interactive_substitution {chm}od='set_path_permissions_interactively'
#interactive_substitution {cho}wn='set_path_ownership_interactively'

#FIXME: Implement.
#interactive_substitution {chg}rp='set_path_group'

#FIXME: Enable. This requires we augment set_path_creation_mask() to call
#print_path_creation_mask() when called interactively directly with no args.
#Actually, that suggests a new function set_path_creation_mask_interactively().
#No need to muddy the pure intent of set_path_creation_mask().
#interactive_alias umask='umask -S'

# ....................{ SETTERS                            }....................
# string set_path_creation_mask(string permissions)
#
# Set the global "umask" (i.e., user mask) for the current shell to the passed
# human-readable comma-delimited string of all permissions to be allowed. All
# other permissions default to denied: e.g.,
#
#     # Allow all users and groups except the current user and group from
#     # reading subsequent paths created by such user and group. You really
#     # don't want to do this.
#     >>> set_path_creation_mask o=rwX
function set_path_creation_mask() {
    die_unless_args_1 'expected one permissions string'
    string permissions="${1}"
    builtin umask -- "${permissions}"
}

# ....................{ SETTERS ~ permissions              }....................
#FIXME: Argument order is appropriate when called interactively but not non-
#interactively. Fix!

# string set_path_permissions(string path, string permission)
#
# Change the permissions of the passed path (defaulting to the current working
# directory) via the passed permission specifier (e.g., "ugo+rX", enabling the
# read and execute bits if already executable for all users). See "man chmod"
# for the specific format of such specifiers.
function set_path_permissions() {
    # Validate passed arguments.
    die_unless_two_args 'expected one path and one permissions string'
    string permissions="${1}"
    shift_one_arg

    # Change permissions.
    run_with_options\
        'command chmod' ZESHY_CHMOD_OPTIONS "${permissions}" "${(q)@}"
}

# string set_path_permissions_recursively(
#   string new_permissions, string path1, string path2, ...)
#
# Recursively change the permissions of the passed path as under
# set_path_permissions().
function set_path_permissions_recursively() {
    #FIXME: Replace with call to append_list_with_lists_locally(), as below.
    # Recursively change permissions by delegating to set_path_permissions(),
    # temporarily appending recursive options to ${ZESHY_CHMOD_OPTIONS}.
    list options; options=(
        "${ZESHY_CHMOD_OPTIONS[@]}"
        "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}"
    )
    list ZESHY_CHMOD_OPTIONS; ZESHY_CHMOD_OPTIONS=( "${options[@]}" )
    set_path_permissions "${@}"
}

# ....................{ SETTERS ~ interactive              }....................
#FIXME: Recursive path changing can be dangerous. Interactively confirm such
#changes (but don't bother with non-recursive path changing).

# string set_path_permissions_interactively(
#   string option1, string option2, ...,
#   string permissions,
#   string path1 = "$(get_current_dir)", string path2, ...)
#
# Change the permissions of the passed paths (defaulting to the current working
# directory) via the passed permission specifier and "chmod" options. See
# set_path_permissions() or "man chmod" for further details.
function set_path_permissions_interactively() {
    # Validate passed arguments.
    die_unless_args 'expected one permissions string and at least one path'

    #FIXME: Insufficient. The user could have passed arguments "-R" and "go+X",
    #in which case at least two arguments were passed but none of them a proper
    #path. To test this properly, first temporarily remove all passed arguments
    #prefixed with "-" and *THEN* test the number of arguments: if still only
    #one, then, indeed, we do need to append the current directory.

    # If passed one argument, default the path to the current working directory.
    is_one_arg and append_args "$(get_current_dir)"

    # Change permissions.
    run_with_options 'command chmod' ZESHY_CHMOD_OPTIONS "${(q)@}"
}

# string set_path_permissions_recursively_interactively(
#   string option1, string option2, ...,
#   string permissions,
#   string path1 = "$(get_current_dir)", string path2, ...)
#
# Change the permissions of the passed paths (defaulting to the current working
# directory) via the passed permission specifier and "chmod" options,
# recursively. See set_path_permissions() or "man chmod" for further details.
function set_path_permissions_recursively_interactively() {
    output ZESHY_CHMOD_OPTIONS ZESHY_CHMOD_OPTIONS_IF_RECURSIVE |
        append_list_with_lists_locally
    set_path_permissions_interactively "${@}"
}

#FIXME: Great, I think. Test. If working, shift to a new "00-alias/list"
#component.
# void append_list_with_lists_locally(
#   string list_name,
#   string append_list_name1, append_list_name2, ...)
#
# Shadow the first passed list with a local list of the same name containing
# such list appended by all remaining passed lists.
alias append_list_with_lists_locally='{
    # Validate passed arguments.
    die_unless_args_2_at_least "expected at least two list names"
    string list_name="${1}"
    shift_one_arg
    die_unless_list "${list_name}"

    # Create a temporary list containing the first passed list appended by all
    # remaining passed lists.
    list __appended_list__; __appended_list__=( "${(@P)list_name}" )
    for append_list_name ("${@}") {
        die_unless_list "${append_list_name}"
        __appended_list__+=( "${(@P)append_list_name}" )
    }

    # Shadow the first passed list with the temporary list.
    eval "list ${list_name}; ${list_name}=( \"\${__appended_list__[@]}\" )"

    # Delete the temporary list to avoid polluting the caller namespace.
    unset __appended_list__
}'

# ....................{ PRINTERS                           }....................
# string print_path_creation_mask(void)
#
# Print the global "umask" (i.e., user mask) for the current shell.
function print_path_creation_mask() {
    # Validate passed arguments. "umask -S" prints a symbolic representation of
    # such mask resembling "u=rwx,g=rx,o=". Unlike human-readable "chmod" input
    # (e.g., "u+rwx,g+rx-w,o-rwx"), "umask -S" print_string fails to specify whether
    # such permissions are enabled or disabled. In fact, it is the former.
    # Since this is not necessarily intuitive, convert the symbolic
    # representation print_string by "umask -S" to that input by "chmod".
    # Unsurprisingly, this is a convolute munging.
    die_if_args
    string\
        symbol_umask symbols\
        symbol_name symbol_accepts symbol_forbids
    list symbol_types symbol_flags symbol_accepts_flags symbol_forbids_flags

    # Split "umask -S" print_string on commas.
    symbol_umask="$(builtin umask -S)"
    set_list_to_string_split_on_delimiter "${symbol_umask}" ',' symbol_types

    # For each of the three permission types (i.e., user, group, and other),
    # split such type on "=", convert the right-hand side of such split to a
    # list of at most three permissions (e.g., from a string "rw" to a list
    # "( r w )"), and difference the list "( r w x )" with such list. The
    # result is the list of all disabled permissions.
    symbol_flags=( 'r' 'w' 'x' )
    for symbol_type ("${symbol_types[@]}") {
        # Get the list of all disabled permissions.
        set_strings_to_string_split_on\
            symbol_name symbol_accepts "${symbol_type}" '='
        set_list_to_string_split_on_characters\
            symbol_accepts_flags "${symbol_accepts}"
        set_list_to_list_difference\
            symbol_forbids_flags symbol_flags symbol_accepts_flags
#       print_string "symbol_accepts_flags: ${symbol_accepts_flags[@]}"
#       print_string "symbol_forbids_flags: ${symbol_forbids_flags[@]}"

        # By default, list expansion delimits elements with spaces. Avoid this.
        symbol_forbids="$(join_list_undelimited symbol_forbids_flags)"

        # Avoid prefixing empty permissions with "+" and "-" symbols.
        if is_nonempty "${symbol_accepts}" and is_nonempty "${symbol_forbids}"
        then symbols+="${symbol_name}+${symbol_accepts}-${symbol_forbids},"
        elif is_nonempty "${symbol_accepts}"
        then symbols+="${symbol_name}+${symbol_accepts},"
        else symbols+="${symbol_name}-${symbol_forbids},"
        fi
    }

    # Remove the trailing comma accidentally appended by the final iteration.
    symbols="$(remove_string_suffix "${symbols}" ',')"

    # Print.
    print_string "path creation mask (umask):
  in octal:   $(builtin umask)
  in symbols: ${symbols}"
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Sweet; but I wonder if there's a more intuitive way to call this.
    #Would something like the following work?:
    #   append_list_with_lists_locally <ZESHY_CHMOD_OPTIONS <ZESHY_CHMOD_OPTIONS_IF_RECURSIVE
    #FUXME: Obviously insufficient, due to "--". Replace with above approach.
#   set_path_permissions_interactively\
#       "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}" "${@}"

#   string permissions="${1}"
#   shift_one_arg

    # If passed one argument, default the path to the current working directory.
#   is_args or set_args "$(get_current_dir)"

    # Change permissions.
#   run_with_options\
#       'command chmod' ZESHY_CHMOD_OPTIONS "${permissions}" "${(q)@}"

# --------------------( SEE ALSO                           )--------------------
# Zeshy File Mask
#   Handles default file creation permissions (i.e., umask).
    # Validate passed arguments.
#   die_unless_argss\
#       'expected one permissions string and zero or more paths'
#   string permissions="${1}"
#   shift_one_arg

    # If passed one argument, default the path to the current working directory.
#   is_args_0 and set_args "$(get_current_dir)"

    # Change permissions.
#   list zeshy_chmod_options; zeshy_chmod_options=(
#       "${ZESHY_CHMOD_OPTIONS[@]}"
#       "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}"
#   )
#   run_with_options 'command chmod' 'zeshy_chmod_options'\
#       "${permissions}" "${(q)@}"
    #FIXME: Create a new 'type/string/pcre' method for global substitution.
#   print_string "path creation mask (umask): $(umask) (octal); $(umask -S) (symbolic)"
#   print_string "path creation mask (umask): $(umask) (octal) {$(umask -S) (symbolic)}"
#   print_string "path creation mask (umask): octal $(umask) {symbolic $(umask -S)}"
#   print_string "path creation mask (umask): $(umask) {$(umask -S)}"
#   print_string "path creation mask (umask): $(umask) [symbolic $(umask -S)]"
#   print_string "umask: $(umask) ($(umask -S))"
#   print_string "global path creation mask (umask): $(umask) (symbolically, $(umask -S))"
