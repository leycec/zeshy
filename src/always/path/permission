#!/usr/bin/env zsh
# ====================[ permission                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File Permission, handling file permissions.
#
# --------------------( SEE ALSO                           )--------------------
# Zeshy File Mask
#   Handles default file creation permissions (i.e., umask).

# ....................{ ALIASES                            }....................
#interactive_alias chgrp='change_permissions chgrp'
interactive_alias chm='set_path_permissions_recursively'
interactive_alias chmod='set_path_permissions_recursively'
#interactive_alias chown='change_permissions chown'

#FIXME: Enable. This requires we augment set_path_creation_mask() to call
#print_path_creation_mask() when called interactively directly with no args.
#Actually, that suggests a new function set_path_creation_mask_interactively().
#No need to muddy the pure intent of set_path_creation_mask().
#interactive_alias umask='umask -S'

# ....................{ PRINTERS                           }....................
# string print_path_creation_mask(void)
#
# Print the global "umask" (i.e., user mask) for the current shell.
print_path_creation_mask() {
    # Validate passed arguments. "umask -S" prints a symbolic representation of
    # such mask resembling "u=rwx,g=rx,o=". Unlike human-readable "chmod" input
    # (e.g., "u+rwx,g+rx-w,o-rwx"), "umask -S" output fails to specify whether
    # such permissions are enabled or disabled. In fact, it is the former.
    # Since this is not necessarily intuitive, convert the symbolic
    # representation output by "umask -S" to that input by "chmod".
    # Unsurprisingly, this is a convolute munging.
    die_if_args
    string\
        symbol_umask symbols\
        symbol_name symbol_accepts symbol_forbids
    list symbol_types symbol_flags symbol_accepts_flags symbol_forbids_flags

    # Split "umask -S" output on commas.
    symbol_umask="$(builtin umask -S)"
    split_string_to_list "${symbol_umask}" ',' symbol_types

    # For each of the three permission types (i.e., user, group, and other),
    # split such type on "=", convert the right-hand side of such split to a
    # list of at most three permissions (e.g., from a string "rw" to a list
    # "( r w )"), and difference the list "( r w x )" with such list. The
    # result is the list of all disabled permissions.
    symbol_flags=( 'r' 'w' 'x' )
    for symbol_type ("${symbol_types[@]}") {
        # Get the list of all disabled permissions.
        split_string_to_string_pair "${symbol_type}" '=' symbol_name symbol_accepts
        split_characters_to_list "${symbol_accepts}" symbol_accepts_flags
#       sputter "symbol_accepts_flags: ${symbol_accepts_flags[@]}"
        difference_lists symbol_flags symbol_accepts_flags symbol_forbids_flags
#       sputter "symbol_forbids_flags: ${symbol_forbids_flags[@]}"

        # By default, list expansion delimits elements with spaces. Avoid this.
        symbol_forbids="$(join_list_to_string symbol_forbids_flags)"

        # Avoid prefixing empty permissions with "+" and "-" symbols.
        if is_nonempty "${symbol_accepts}" and is_nonempty "${symbol_forbids}"
        then symbols+="${symbol_name}+${symbol_accepts}-${symbol_forbids},"
        elif is_nonempty "${symbol_accepts}"
        then symbols+="${symbol_name}+${symbol_accepts},"
        else symbols+="${symbol_name}-${symbol_forbids},"
        fi
    }

    # Remove the trailing comma accidentally appended by the final iteration.
    symbols="$(remove_suffix "${symbols}" ',')"

    # Print.
    sputter "path creation mask (umask):
  in octal:   $(builtin umask)
  in symbols: ${symbols}"
}

# ....................{ SETTERS                            }....................
# string set_path_creation_mask(string permissions)
#
# Set the global "umask" (i.e., user mask) for the current shell to the passed
# human-readable comma-delimited string of all permissions to be allowed. All
# other permissions default to denied: e.g.,
#
#     # Allow all users and groups except the current user and group from
#     # reading subsequent paths created by such user and group. You really
#     # don't want to do this.
#     >>> set_path_creation_mask o=rwX
set_path_creation_mask() {
    die_unless_one_arg 'expected one permissions string'
    string permissions="${1}"
    builtin umask -- "${permissions}"
}

# ....................{ SETTERS ~ permissions              }....................
# string set_path_permissions(
#   string new_permissions, string path1, string path2, ...)
#
# Change the permissions of the passed path (defaulting to the current working
# directory) via the passed permission specifier (e.g., "ugo+rX", enabling the
# read and execute bits if already executable for all users). See "man chmod"
# for the specific format of such specifiers.
set_path_permissions() {
    # Validate passed arguments.
    die_unless_at_least_one_arg\
        'expected one permissions string and zero or more paths'
    string permissions="${1}"
    shift_one_arg

    # If passed one argument, default the path to the current working directory.
    is_no_args and set_args "$(get_current_dir)"

    # Change permissions.
    run_with_options 'command chmod' 'ZESHY_CHMOD_OPTIONS'\
        "${permissions}" "${(q)@}"
}

# string set_path_permissions_recursively(
#   string new_permissions, string path1, string path2, ...)
#
# Recursively change the permissions of the passed path as under
# set_path_permissions().
set_path_permissions_recursively() {
    # Recursively change permissions by delegating to set_path_permissions(),
    # temporarily appending recursive options to ${ZESHY_CHMOD_OPTIONS}.
    list options; options=(
        "${ZESHY_CHMOD_OPTIONS[@]}"
        "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}"
    )
    list ZESHY_CHMOD_OPTIONS; ZESHY_CHMOD_OPTIONS=( "${options[@]}" )
    set_path_permissions "${@}"
}

# --------------------( WASTELANDS                         )--------------------
    # Validate passed arguments.
#   die_unless_at_least_one_args\
#       'expected one permissions string and zero or more paths'
#   string permissions="${1}"
#   shift_one_arg

    # If passed one argument, default the path to the current working directory.
#   is_no_args and set_args "$(get_current_dir)"

    # Change permissions.
#   list zeshy_chmod_options; zeshy_chmod_options=(
#       "${ZESHY_CHMOD_OPTIONS[@]}"
#       "${ZESHY_CHMOD_OPTIONS_IF_RECURSIVE[@]}"
#   )
#   run_with_options 'command chmod' 'zeshy_chmod_options'\
#       "${permissions}" "${(q)@}"
    #FIXME: Create a new 'type/string/pcre' method for global substitution.
#   sputter "path creation mask (umask): $(umask) (octal); $(umask -S) (symbolic)"
#   sputter "path creation mask (umask): $(umask) (octal) {$(umask -S) (symbolic)}"
#   sputter "path creation mask (umask): octal $(umask) {symbolic $(umask -S)}"
#   sputter "path creation mask (umask): $(umask) {$(umask -S)}"
#   sputter "path creation mask (umask): $(umask) [symbolic $(umask -S)]"
#   sputter "umask: $(umask) ($(umask -S))"
#   sputter "global path creation mask (umask): $(umask) (symbolically, $(umask -S))"
