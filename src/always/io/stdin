#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle miscellaneous standard input functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_stdin_readable_sans_blocking(
    string error_message = "Standard input unreadable without blocking.")

Throw an exception with the passed message unless standard input for this
function is nonempty. See is_stdin_readable_sans_blocking() for further details.
/---
function die_unless_stdin_readable_sans_blocking() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_stdin_readable_sans_blocking or
        die "${1:-Standard input unreadable without blocking.}"
}

# ....................{ TESTERS                            }....................
#FIXME: Arguably, this function should be considered harmful. There's no sane or
#sensible way to implement it safely. The current implementation is awful, as is
#any other forseeable implementation. The intrinsic difficulty is that it takes
#the shell a non-negligible amount of time to establish a pipe when under heavy
#system load. That said, there still might be a limited use case for this
#function -- but certainly *NOT* as documented below. Note the above strong
#caveat and substantially rewrite such documentation.
#FIXME: To repair such function, reduce the "-t 5" below to "-t 0" and on we go!
#This reduces the edge-case utility of such function but renders it demonstrably
#more sane. That said, it might be helpful to define another function
#is_stdin_pipe_or_readable_sans_blocking(), which is probably the closest we can
#get to a working implementation that accords with user expectations. *shrug*

declare_function_with_stdin <<'/---'
[status: boolean] is_stdin_readable_sans_blocking(void)

Return success if standard input for the current context is readable without
blocking (i.e., readable without waiting -- possibly indefinitely and always
silently -- for such input to be written to such context). Since reading from
standard input via conventional techniques (e.g., `< /dev/stdin`, zsh builtin
read(), zeshy alias get_stdin()) typically blocks or behaves erratically if no
such input has been written, consider always calling this function or
die_unless_stdin_readable_sans_blocking() before reading from standard input.
/---
function is_stdin_readable_sans_blocking() {
    # Given the criticality and commonality of this test, one would assume there
    # to exist builtins or commands for accomplishing it. One would be wrong.
    die_if_args
    integer exit_status
    list zselect_status

    # Testing whether such file descriptor and hence input is readable without
    # blocking requires calling the commonly available kernel function select().
    # Ideally, such test would elegantly reduce to the following:
    #
    #     read -t 0 -k 0
    #
    # Dismantled, this is:
    #
    # * "-t 0", testing whether standard input is readable without blocking and
    #   returning immediately if not.
    # * "-k 0", reading 0 bytes from standard input if such input is readable.
    #
    # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
    # bash, in which "read -t 0 -N 0" conditionally returns success when one
    # expects it to. Hence, such test defers to select() instead.
    #
    # Since zselect() (the zsh select() wrapper) returns failure with exit
    # status 2 when the underlying OS fails to provide a select() function,
    # capture and test such status rather than implicitly returning such status
    # as this function's exit status.
    #
    # Since standard input is context-specific, such exit status *CANNOT* be
    # trivially captured with command substitution (e.g.,
    # "$(zselect ... | get_status)"). Instead, implement the equivalent of
    # alias set_integer_to_status(). Unfortunately, such alias transitively
    # calls this function; breaking such recursion requires this function to
    # internally reimplement set_integer_to_stdin(). *sigh*
    #
    # Dismantled, this is:
    #
    # * "-t 5", returning after waiting at most 0.05s for standard input to
    #   receive input. While this technically constitutes blocking behavior,
    #   such minimally negligible wait time is essential to avoid erroneously
    #   reporting failure. As example, establishing "/dev/stdin" as a named pipe
    #   between a simple print() writer and zselect() reader consumes on the
    #   order of between 0.001s to 0.02s on an (admittedly) obsolete machine, in
    #   which case the following test commonly fails:
    #
    #       >>> print '' | { zselect -t 0 -r 0 and print Fail or print Success }
    #       Fail
    #
    #   Contrariwise, the following test commonly succeeds:
    #
    #       >>> print '' | { zselect -t 1 -r 0 and print Fail or print Success }
    #       Success
    #
    #   Such ad-hoc observation constitutes more common sense than rocket
    #   science. However, since decreasing such timeout to 0 breaks the common
    #   case *AND* since increasing such timeout above 5 correspondingly slows
    #   the entire zeshy codebase, we defer to common sense.
    # * "-a ...", setting such list to contain a string resembling either
    #   "-r 0" if standard input is nonempty or "" if standard input is empty.
    #   Since zselect() defaults such list to ${reply} if unpassed and since
    #   such list is commonly used by callers and should *NOT* be overwritten by
    #   such a low-level function as this, explicitly specify such list. Since
    #   this function never references such list, our specifying it here is
    #   simply to avoid overwriting ${reply}. Frankly, this "unique" choice of
    #   API design is one of the more eclectic that we've ever seen. And we were
    #   proficient in ML... Once.
    # * "-r ...", testing such file descriptor for nonempty reading.
    #
    # Note that the "{" and "}" delimiters surrounding such integer assignment
    # are essential; neglecting delimiters assigns such integer standard input
    # to *THIS* function rather than such exit status. (O^o)
    #
    # Thus does another feeble mind break.
    { zselect -t 5 -a zselect_status -r ${ZESHY_STDIN_FILE_DESCRIPTOR-0} } and
        output_string ${status} | { exit_status="$(get_stdin)" } or
        output_string ${status} | { exit_status="$(get_stdin)" }

    # If such status indicates such function to be absent, throw an exception.
    if (( exit_status == 2 )) {
        die 'Kernel function select() undefined.'
    }

    # Else, return such status as is. Technically, zselect() returns:
    #
    # * 0 if any passed file descriptor is both nonempty and readable.
    # * 1 otherwise.
    #
    # Since this function tests only one file descriptor for nonempty reading,
    # such status exactly coincides with what the caller expects. (Scoooooore!)
    return ${exit_status}
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_stdin_until_eot[stdin: string text]

Get all standard input to the current context until receiving a line of such
input containing only the end-of-transmission (EOT) character. If no such line
is received, all input will be returned.

This function is intended to be called as a coprocess in low-level functions
capturing output (e.g., run_silent_and_set_string_to_stderr()). Since
coprocesses typically loop on standard input until receiving end-of-file _and_
since there exists no builtin means of piping end-of-file to standard input,
this function leverages the EOT character for such purposes.
/---
function get_stdin_until_eot() {
    # Technically, there exist two means of caching standard input:
    #
    # 1. Appending each line of such input delimited by newline to a string and
    #    returning such string as is.
    # 2. Appending each line of such input undelimited to a list and returning
    #    such list joined on newline.
    #
    # Having implemented both, the former informally appears to behave much more
    # efficiently in time (and presumably in space) than the latter. Hence, we
    # adopt such approach.
    #
    # Incidentally, do *NOT* attempt to trap signals (either locally or
    # globally) within this function. Doing so irrevocably terminates the entire
    # process group of shells owning this shell -- a probable zsh bug. See
    # run_code_and_set_string_to_coprocess_output_from_redirection().

    # Validate sanity.
    die_if_args
    string stdin stdin_line

    # Temporarily buffer each line of standard input to string local ${stdin},
    # which will be output "all at once" after input subsequently terminates.
    #
    # Do *NOT* incrementally output such lines (e.g., with output_string()) in
    # the loop body. Doing so behaves as expected on sufficiently small input
    # but deadlocks on sufficiently large input when invoked from a pipeline or
    # coprocess subshell whose parent shell only reads such input back from such
    # subshell "all at once." In this case, "small" and "large" are defined by
    # the size of the kernel-specific socket buffer. If the current system
    # supports configuring such size, run "limit sockbufsize" to get such size;
    # else, the current kernel internally hardcodes such size.
    #
    # Since the socket buffer has finite size, attempting to write a string of
    # output larger than such size to such buffer blocks the process attempting
    # such write -- in the example above, the pipeline or coprocess subshell
    # executing this function.  If the process on the read end of such buffer --
    # in the example above, the parent shell of such subshell -- is *NOT*
    # concurrently reading such buffer but waiting for another command to
    # terminate, the inevitable result is deadlock. How bad is it? Bad:
    # indefinite, pseudo-random, and always silent.
    #
    # See page_stdin() for related logic.
    while {
        IFS= read -r stdin_line and\
        is "${stdin_line}" != "${ZESHY_ASCII_EOT}" si } {
        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
    }

    # Return such input to the caller via a *SINGLE* output statement. Avoid
    # suffixing such input with a newline; the prior loop already did.
    #
    # If such input is sufficiently large, attempting to output the entirety
    # of such input from a pipeline or coprocess subshell will block such
    # subshell unless the parent shell concurrently reads such output.
    # Fortunately, this is the common case under the 
#   output_string_to_stderr 'Coprocess terminating.'
    output_string_sans_newline "${stdin[1,-2]}"
}

# --------------------( WASTELANDS                         )--------------------
    # Locally trap SIGUSR1 to gracefully terminate this function. This is the
    # typical means of terminating this function when called by the coprocess.
    # See below for details on the returned string.
#   run_hook_on_signal_interrupt_local '
#       print "coprocess ${sysparams[pid]} received SIGINT" 1>&2
#       report_failure'
#   print "coprocess received SIGUSR1" 1>&2

#function get_stdin_until_eot_WAT() {
#    die_if_args
##   boolean is_uninterrupted=${ZESHY_BOOLEAN_TRUE}
#    string stdin stdin_line
##   trap 'exec 0>&-' INT
##   trap 'return 1' INT
##   trap 'is_uninterrupted=0' INT
##   run_hook_on_signal_interrupt_local 'is_uninterrupted=0'
##   run_hook_on_signal_interrupt_local 'return 0'
##       print "coprocess ${sysparams[pid]} received SIGINT" 1>&2
##       is_uninterrupted=0
##       is_uninterrupted=${ZESHY_BOOLEAN_FALSE}'
##       report_failure'
##       die "UghUgh."
##   print "coprocess received SIGUSR1" 1>&2
##   while (( is_uninterrupted )) and {
#    while {
#        IFS= read -r stdin_line and
#        is "${stdin_line}" != "${ZESHY_ASCII_EOT}" si } {
#        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
#    }
#    output_string_sans_newline "${stdin[1,-2]}"
#}
#
##FUXME: Excise. This is now rightfully obsolete and should *NEVER* be called.
#declare_function_with_stdin <<'/---'
#string get_stdin_until_signal_user1[stdin: string text]
#
#Get all standard input to the current context until receiving the first user-
#defined signal, SIGUSR1. If no such signal is received, all input will be
#returned. See run_hook_on_signal_user1() for further details.
#
#This function was intended to be called by the coprocess in low-level functions
#capturing command output (e.g., run_silent_and_set_string_to_stderr()). Since
#coprocesses typically loop on standard input until receiving end-of-file _and_
#since there exists no builtin means of piping end-of-file to standard input,
#this function leverages SIGUSR1 for such purposes instead.
#/---
#function get_stdin_until_signal_user1() {
#    # Validate sanity.
#    die_if_args
#    string stdin stdin_line
##   print "coprocess ${sysparams[pid]} starting" 1>&2
#
#    # Locally trap SIGUSR1 to gracefully terminate this function. This is the
#    # typical means of terminating this function when called by the coprocess.
#    # See below for details on the returned string.
##    run_hook_on_signal_user1_local '
##        print "coprocess ${sysparams[pid]} received SIGUSR1" 1>&2
##        output_string_sans_newline "${stdin[1,-2]}"
##        report_success'
##       print "coprocess received SIGUSR1" 1>&2
#
#    # Temporarily buffer each line of standard input to string local ${stdin},
#    # which will be output "all at once" after input subsequently terminates.
#    #
#    # Do *NOT* incrementally output such lines (e.g., with output_string()) in
#    # the loop body. Doing so behaves as expected on sufficiently small input
#    # but deadlocks on sufficiently large input when invoked from a pipeline or
#    # coprocess subshell whose parent shell only reads such input back from such
#    # subshell "all at once." In this case, "small" and "large" are defined by
#    # the size of the kernel-specific socket buffer. If the current system
#    # supports configuring such size, run "limit sockbufsize" to get such size;
#    # else, the current kernel internally hardcodes such size.
#    #
#    # Since the socket buffer has finite size, attempting to write a string of
#    # output larger than such size to such buffer blocks the process attempting
#    # such write -- in the example above, the pipeline or coprocess subshell
#    # executing this function.  If the process on the read end of such buffer --
#    # in the example above, the parent shell of such subshell -- is *NOT*
#    # concurrently reading such buffer but waiting for another command to
#    # terminate, the inevitable result is deadlock. How bad is it? Bad:
#    # indefinite, pseudo-random, and always silent.
#    #
#    # See page_stdin() for related logic.
#    while { IFS= read -r stdin_line } {
#        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
#        print -n '.' 1>&2
##       print "coprocess ${sysparams[pid]} received line: ${stdin_line}" 1>&2
#    }
#
#    # Return such input to the caller via a *SINGLE* output statement. Avoid
#    # suffixing such input with a newline; the prior loop already did.
#    #
#    # If such input is sufficiently large, attempting to output the entirety
#    # of such input from a pipeline or coprocess subshell will block such
#    # subshell unless the parent shell concurrently reads such output.
#    # Fortunately, this is the common case under the 
##   print "coprocess ${sysparams[pid]} returning normally" 1>&2
#    output_string_sans_newline "${stdin[1,-2]}"
#}

#       run_hook_on_signal_interrupt_local '
#           print "coprocess ${sysparams[pid]} received SIGINT" 1>&2
#           report_failure'

#Get all standard input to the current context, up to but _not_ including the
#first input line containing only the end-of-transmission (EOT) character. If no
#such line exists, all input will be returned.
#
#== Motivation ==
#
#This function is principally intended to be called as a coprocess in low-level
#`zeshy` runners (e.g., run_silent_and_set_string_to_stderr()). Since coprocesses
#typically loop on standard input until receiving end-of-file _and_ since there
#exists no builtin means of piping end-of-file to standard input, this function
#leverages the end-of-transmission character for such purposes instead.

#   string stdin_line
#   list stdin
#       join_list_on_newline stdin
#       report_success'
#       print "!!!!!!!!!!!!!!!!!!!!!!!!\ncoprocess received SIGUSR1" 1>&2
#       print "!!!!!!!!!!!!!!!!!!!!!!!!\ncoprocess still here" 1>&2'
#       output_string_sans_newline "${stdin[1,-2]}"
#   output_string_sans_newline "${stdin[@]}"
#   join_list_on_newline stdin
#FUXME: Rename function. We no longer expect the interrupt signal. Document why!
#(Namely, an obvious conflict with valid uses of interrupt signals -- namely, as
#signaled by the current user interactively.)
# Clearly, there's
    # some devious interplay of shell-enforced standard input and/or output
    # buffering at work here. It's unfortunate this particular piece of critical
    # machinery is so (seemingly) fragile, but there you are.

#function get_stdin_until_eot() {
#    # Validate sanity.
#    die_if_args
#    string line
#
#    # Output all lines of standard input back to the caller until either
#    # reaching the end of such input or a line containing only an EOT character.
#    # Dismantled, this is:
#    #
#    # * "IFS=", preventing read() from splitting input on field separators.
#    # * "-r", preserving input characters (e.g., backslashes do not escape).
#    while { IFS= read -r line and is "${line}" != "${ZESHY_ASCII_EOT}" si } {
#        output_string "${line}"
#    }
#}

#   while { IFS= read -r line and is "${line}" != "${ZESHY_ASCII_EOT}" si } {
#       output_string "${line}" >>/tmp/tmp.zeshy
#   while { IFS= read -r line and is "${line}" != *($'\C-D'|'-----')* si } {

#== Motivation ==
#, for reasons discussed there.  outside of a file context
    # Load zsh module "zselect", if not already. While @{zsh/module} already
    # autoloads modules on zeshy startup, this function is often called
    # before completing such startup and hence autoloading.
#   zmodload zsh/zselect
