#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle miscellaneous I/O functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_stdin_readable_sans_blocking(
    string error_message = "Standard input unreadable without blocking.")

Throw an exception with the passed message unless standard input for this
function is nonempty. See is_stdin_readable_sans_blocking() for further details.
/---
function die_unless_stdin_readable_sans_blocking() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_stdin_readable_sans_blocking or
        die "${1:-Standard input unreadable without blocking.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_stdin_readable_sans_blocking(void)

Return success if standard input for the current context is readable without
blocking (i.e., readable without waiting -- possibly indefinitely and always
silently -- for such input to be written to such context). Since reading from
standard input via conventional techniques (e.g., `< /dev/stdin`, zsh builtin
read(), zeshy alias get_stdin()) typically blocks or
behaves erratically if no such input has been written, consider always calling
this function or die_unless_stdin_readable_sans_blocking() before reading from
standard input.
/---
function is_stdin_readable_sans_blocking() {
    # Given the criticality and commonality of this test, one would assume there
    # to exist builtins or commands for accomplishing it. One would be wrong.
    die_if_args
    integer exit_status
    list zselect_status

    # Testing whether such file descriptor and hence input is readable without
    # blocking requires calling the commonly available kernel function select().
    # Ideally, such test would elegantly reduce to the following:
    #
    #     read -t 0 -k 0
    #
    # Dismantled, this is:
    #
    # * "-t 0", testing whether standard input is readable without blocking and
    #   returning immediately if not.
    # * "-k 0", reading 0 bytes from standard input if such input is readable.
    #
    # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
    # bash, in which "read -t 0 -N 0" conditionally returns success when one
    # expects it to. Hence, such test defers to select() instead.
    #
    # Since zselect() (the zsh select() wrapper) returns failure with exit
    # status 2 when the underlying OS fails to provide a select() function,
    # capture and test such status rather than implicitly returning such status
    # as this function's exit status.
    #
    # Since standard input is context-specific, such exit status *CANNOT* be
    # trivially captured with command substitution (e.g.,
    # "$(zselect ... | get_exit_status)"). Instead, implement the equivalent of
    # alias set_integer_to_exit_status(). Unfortunately, such alias transitively
    # calls this function; breaking such recursion requires this function to
    # internally reimplement set_integer_to_stdin(). *sigh*
    #
    # Dismantled, this is:
    #
    # * "-t 5", returning after waiting at most 0.05s for standard input to
    #   receive input. While this technically constitutes blocking behavior,
    #   such minimally negligible wait time is essential to avoid erroneously
    #   reporting failure. As example, establishing "/dev/stdin" as a named pipe
    #   between a simple print() writer and zselect() reader consumes on the
    #   order of between 0.001s to 0.02s on an (admittedly) obsolete machine, in
    #   which case the following test commonly fails:
    #
    #       >>> print '' | { zselect -t 0 -r 0 and print Fail or print Success }
    #       Fail
    #
    #   Contrariwise, the following test commonly succeeds:
    #
    #       >>> print '' | { zselect -t 1 -r 0 and print Fail or print Success }
    #       Success
    #
    #   Such ad-hoc observation constitutes more common sense than rocket
    #   science. However, since decreasing such timeout to 0 breaks the common
    #   case *AND* since increasing such timeout above 5 correspondingly slows
    #   the entire zeshy codebase, we defer to common sense.
    # * "-a ...", setting such list to contain a string resembling either
    #   "-r 0" if standard input is nonempty or "" if standard input is empty.
    #   Since zselect() defaults such list to ${reply} if unpassed and since
    #   such list is commonly used by callers and should *NOT* be overwritten by
    #   such a low-level function as this, explicitly specify such list. Since
    #   this function never references such list, our specifying it here is
    #   simply to avoid overwriting ${reply}. Frankly, this "unique" choice of
    #   API design is one of the more eclectic that we've ever seen. And we were
    #   proficient in ML... Once.
    # * "-r ...", testing such file descriptor for nonempty reading.
    #
    # Note that the "{" and "}" delimiters surrounding such integer assignment
    # are essential; neglecting delimiters assigns such integer standard input
    # to *THIS* function rather than such exit status. (O^o)
    #
    # Thus does another feeble mind break.
    { zselect -t 5 -a zselect_status -r ${ZESHY_STDIN_FILE_DESCRIPTOR-0} } and
        output_string ${status} | { exit_status="$(get_stdin)" } or
        output_string ${status} | { exit_status="$(get_stdin)" }

    # If such status indicates such function to be absent, throw an exception.
    if (( exit_status == 2 )) {
        die 'Kernel function select() undefined.'
    }

    # Else, return such status as is. Technically, zselect() returns:
    #
    # * 0 if any passed file descriptor is both nonempty and readable.
    # * 1 otherwise.
    #
    # Since this function tests only one file descriptor for nonempty reading,
    # such status exactly coincides with what the caller expects. (Scoooooore!)
    return ${exit_status}
}

# --------------------( WASTELANDS                         )--------------------
    # Load zsh module "zselect", if not already. While @{zsh/module} already
    # autoloads modules on zeshy startup, this function is often called
    # before completing such startup and hence autoloading.
#   zmodload zsh/zselect
