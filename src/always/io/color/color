#!/usr/bin/env zsh
# ====================[ color                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle terminal colors.
#
# --------------------( SEE ALSO                           )--------------------
# http://ciembor.github.com/4bit
#   4bit, arguably the best and probably only terminal color scheme designer.
#
# --------------------( TODO                               )--------------------
# * Add support for fish-like syntax highlighting. Happily, someone's already
#   gone to the work of zshifying this; we'll just want to Zeshify it a bit:
#   https://github.com/zsh-users/zsh-syntax-highlighting
# * Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#   urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#   some zsh code the other day simplifying such support... Hmmmmmmmm.
# * It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#   https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors

#FIXME: While the current implementation certainly works, it's overkill. Almost
#*ALL* modern-day terminals, even tunnelled over SSH, support the 8 canonical
#colors. Consequently, ZESHY_COLOR and similar globals should be *BAKED* into
#the digest file with default values supporting such colors. *IF*, on Zeshy
#startup, we find the current terminal to not in fact support such colors,
#manually iterate through each such map, setting each key value to the empty
#string. (A bit slower, but... hey, if your terminal doesn't even support
#colors, you probably have greater issues than marginal Zeshy slowdown on
#startup.)
#FIXME: That said, 256-color supporting terminals might actually be the most
#common. Contemplate. Consider. Revise.

# ....................{ GLOBALS                            }....................
# Defer initialization of color maps to precompile_zeshy_terminal_colors() below.

declare_global '
map ZESHY_COLOR

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on the current terminal. Colors include the canonical eight
colors supported by most terminal emulators as well as "grey", a Zeshy-specific
color leveraging "intense" ANSI attributes supported by most modern terminal
emulators (e.g., rxvt-unicode). Color names include:

/=====================v========================================================\
| color name          | description                                            |
>=====================+========================================================<
| reset               | reset foreground and background colors to defaults     |
>~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<
| white               | set white foreground color in regular typeface         |
| grey                | set grey foreground color in regular typeface          |
| black               | set black foreground color in regular typeface         |
| red                 | set red foreground color in regular typeface           |
| green               | set green foreground color in regular typeface         |
| blue                | set blue foreground color in regular typeface          |
| yellow              | set yellow foreground color in regular typeface        |
| magenta             | set magenta foreground color in regular typeface       |
| cyan                | set cyan foreground color in regular typeface          |
>---------------------+--------------------------------------------------------<
| white_bold          | set white foreground color in bold typeface            |
| grey_bold           | set grey foreground color in bold typeface             |
| black_bold          | set black foreground color in bold typeface            |
| red_bold            | set red foreground color in bold typeface              |
| green_bold          | set green foreground color in bold typeface            |
| blue_bold           | set blue foreground color in bold typeface             |
| yellow_bold         | set yellow foreground color in bold typeface           |
| magenta_bold        | set magenta foreground color in bold typeface          |
| cyan_bold           | set cyan foreground color in bold typeface             |
>---------------------+--------------------------------------------------------<
| white_italic        | set white foreground color in italic typeface          |
| grey_italic         | set grey foreground color in italic typeface           |
| black_italic        | set black foreground color in italic typeface          |
| red_italic          | set red foreground color in italic typeface            |
| green_italic        | set green foreground color in italic typeface          |
| blue_italic         | set blue foreground color in italic typeface           |
| yellow_italic       | set yellow foreground color in italic typeface         |
| magenta_italic      | set magenta foreground color in italic typeface        |
| cyan_italic         | set cyan foreground color in italic typeface           |
>---------------------+--------------------------------------------------------<
| white_bold_italic   | set white foreground color in bold italic typeface     |
| grey_bold_italic    | set grey foreground color in bold italic typeface      |
| black_bold_italic   | set black foreground color in bold italic typeface     |
| red_bold_italic     | set red foreground color in bold italic typeface       |
| green_bold_italic   | set green foreground color in bold italic typeface     |
| blue_bold_italic    | set blue foreground color in bold italic typeface      |
| yellow_bold_italic  | set yellow foreground color in bold italic typeface    |
| magenta_bold_italic | set magenta foreground color in bold italic typeface   |
| cyan_bold_italic    | set cyan foreground color in bold italic typeface      |
>~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<
| white_background    | set white background color in regular typeface         |
| grey_background     | set grey background color in regular typeface          |
| black_background    | set black background color in regular typeface         |
| red_background      | set red background color in regular typeface           |
| green_background    | set green background color in regular typeface         |
| blue_background     | set blue background color in regular typeface          |
| yellow_background   | set yellow background color in regular typeface        |
| magenta_background  | set magenta background color in regular typeface       |
| cyan_background     | set cyan background color in regular typeface          |
>---------------------+---+----------------------------------------------------<
| white_bold_background   | set white background color in bold typeface        |
| grey_bold_background    | set grey background color in bold typeface         |
| black_bold_background   | set black background color in bold typeface        |
| red_bold_background     | set red background color in bold typeface          |
| green_bold_background   | set green background color in bold typeface        |
| blue_bold_background    | set blue background color in bold typeface         |
| yellow_bold_background  | set yellow background color in bold typeface       |
| magenta_bold_background | set magenta background color in bold typeface      |
| cyan_bold_background    | set cyan background color in bold typeface         |
\=========================^====================================================/
'
declare_global '
map ZESHY_COLOR_2

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on monochrome terminals (i.e., *NOT* supporting the
canonical eight colors). See ${ZESHY_COLOR} for further details.
'
declare_global '
map ZESHY_COLOR_8

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on polychrome terminals (i.e., supporting at least the
canonical eight colors). See ${ZESHY_COLOR} for further details and
${ZESHY_COLOR_NAMES_8} for a list of such colors.
'

declare_global '
list ZESHY_COLOR_NAMES_8

List of the canonical eight color names supported by most *nix terminals:
white, black, red, green, blue, yellow, magenta, and cyan.
'
# List of such names, excluding pseudo-color "grey".
ZESHY_COLOR_NAMES_8=( white black red green blue yellow magenta cyan )

# ....................{ GLOBALS ~ style                    }....................
declare_global '
map ZESHY_COLOR_STYLE

Map lowercase color style name to the ANSI escape code enabling such color on
the current terminal. Color styles improve readability, genericity, and
configurability by substituting hard-coded color names with user-configurable
style names (e.g., substituting "${ZESHY_COLOR[grey]}" with
"${ZESHY_COLOR_STYLE[punctuation]}"). See
${ZESHY_COLOR_STYLE_NAME_TO_COLOR_NAME} for default color style names.
'
declare_global '
map ZESHY_COLOR_STYLE_2

Map lowercase color style name to the ANSI escape code enabling such color on
monochrome terminals. See ${ZESHY_COLOR_STYLE} and ${ZESHY_COLOR_2} for further
details on the former and latter, respectively.
'
declare_global '
map ZESHY_COLOR_STYLE_8

Map lowercase color style name to the ANSI escape code enabling such color on
polychrome terminals. See ${ZESHY_COLOR_STYLE} and ${ZESHY_COLOR_2} for further
details on the former and latter, respectively.
'

# ....................{ TESTERS                            }....................
declare_function '
boolean is_terminal_color(void)

Return true if shell output is attached to a polychrome terminal device (i.e.,
a terminal device providing more than merely monochrome black and white).
'
function is_terminal_color() {
    die_if_args
    is_stdout_terminal and (( $(get_terminal_color_count) > 2 ))
}

# ....................{ GETTERS                            }....................
declare_function '
integer get_terminal_color_count(void)

Get the number of colors supported by the current terminal device.
'
function get_terminal_color_count() {
    # Validate sanity. Since this function is typically called from a subshell,
    # avoid calling die_unless_stdout_terminal().
    die_if_args
    die_unless_shell_interactive

    # Get such colors. Note "echotc Co" also works, but is somewhat overkill.
    print_string "${terminfo[colors]}"
}

# ....................{ SETTERS                            }....................
declare_function '
void reset_terminal_color(void)

Reset foreground and background terminal colors to their defaults: under most
terminals, white foreground on black background with regular typeface.
'
function reset_terminal_color() {
    print_string_sans_newline_suffix "${ZESHY_COLOR[reset]-}"
}

# ....................{ HOOKS                              }....................
# Prevent prompt colors from bleeding into command output.
run_hook_before_input_run reset_terminal_color

# ....................{ MAKERS                             }....................
# Initialize all remaining color globals before compiling Zeshy's user digest
# file, ensuring such globals to be compiled into such file and hence *ALWAYS*
# accessible on Zeshy startup.
run_hook_on_zeshy_precompile precompile_zeshy_terminal_color

declare_function '
void precompile_zeshy_terminal_color(void)

Define terminal color globals to be compiled into Zeshy''s user digest file.
'
function precompile_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args

    # Normal and bold color attributes as ANSI escape codes.
    string\
        ansi_normal="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_weak="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[weak]}${ZESHY_ANSI_SGR_NEXT}"

    # Set the reset "color."
    ZESHY_COLOR_8[reset]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_SUFFIX}"

    # Set polychrome ANSI colors.
    for color_name ("${ZESHY_COLOR_NAMES_8[@]}") {
#       print "color (fg): ${color_name}\ncolor (bg): ${color_name}_background"
        ZESHY_COLOR_8[${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_italic]="${ansi_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_weak]="${ansi_weak}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_background]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}_background]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    }

    # Default foreground greyscale colors are notoriously "off," assigning
    # ${ZESHY_COLOR[white]} a grey rather than white color and defining no
    # corresponding suite of grey colors. To correct this:
    #
    # * Assign ${ZESHY_COLOR[white]} to new color ${ZESHY_COLOR[grey_bold]}.
    # * Assign bold black to all other foreground grey colors.
    # * Assign white and bold black to corresponding background grey colors.
    ZESHY_COLOR_8[white]="${ansi_normal}${ZESHY_ANSI_SGR[white_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey]="${ansi_bold}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold_italic]="${ansi_italic}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold]="${ansi_normal}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_weak]="${ansi_normal}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_background]="${ansi_normal}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"

    #FIXME: Prompt-specific initialization should arguably be shifted to "prompt".

    # Given the prior polychrome ANSI colors, set:
    #
    # * Style-specific colors, expanding to the corresponding ANSI color.
    # * Monochrome ANSI colors, expanding to the empty string.
    # * Prompt-specific colors, delimited by "%{" and "%}" to prevent such
    #   colors from contributing to prompt string length.
    for color_name ( $(get_map_keys ZESHY_COLOR_8) ) {
        ZESHY_COLOR_2[${color_name}]=
        ZESHY_PROMPT_COLOR_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_2[${color_name}]="%{${ZESHY_COLOR_2[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
    }

    # Assign each color style its corresponding ANSI color.
    for color_style_name color_name (
        $(get_map_key_values ZESHY_COLOR_STYLE_NAME_TO_COLOR_NAME) ) {
        ZESHY_COLOR_STYLE_2[${color_style_name}]="${ZESHY_COLOR_2[${color_name}]}"
        ZESHY_COLOR_STYLE_8[${color_style_name}]="${ZESHY_COLOR_8[${color_name}]}"
    }

    # Assign each prompt-specific color style its corresponding ANSI color.
    for color_style_name color_name (
        $(get_map_key_values ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME) ) {
        ZESHY_PROMPT_COLOR_STYLE_2[${color_style_name}]="${ZESHY_PROMPT_COLOR_2[${color_name}]}"
        ZESHY_PROMPT_COLOR_STYLE_8[${color_style_name}]="${ZESHY_PROMPT_COLOR_8[${color_name}]}"
    }
}

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_startup_if_shell_interactive startup_zeshy_terminal_color

#FIXME: Complete documentation.
declare_function '
void startup_zeshy_terminal_color(void)

Define color globals specific to the current terminal. If such terminal is:

* Monochrome (i.e., colorless), set all such colors to the empty string.
'
function startup_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Number of colors supported by the current terminal.
    integer terminal_color_count
    terminal_color_count="$(get_terminal_color_count)"

    #FIXME: Implement support for 256-color terminals.

    # If the current terminal supports less than the canonical eight colors,
    # assume such terminal to be monochrome (i.e., colorless).
    if (( terminal_color_count < 8 ))
    then terminal_color_count=2
    # Else, assume such terminal to support exactly such colors.
    else terminal_color_count=8
    fi

    # Set map globals from the map globals specific to the current terminal's
    # color count. For efficiency, avoid calling set_map_to_map().
    for map_name_target (
        ZESHY_COLOR ZESHY_COLOR_STYLE
        ZESHY_PROMPT_COLOR ZESHY_PROMPT_COLOR_STYLE) {
        eval "${map_name_target}=( \${(kv@)${map_name_target}_${terminal_color_count}} )"
    }
}

# --------------------( WASTELANDS                         )--------------------
#declare_global '
#map ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME_IF_SUPERUSER
#
#Map color style names to prompt color names if the current user is the superuser
#(i.e., root) or ignore such names otherwise. See
#${ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME} for further details.
#'
#ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME_IF_SUPERUSER=(
#    # startup_zeshy_terminal_prompt().
#    startup_zeshy_terminal_prompt.brace                   grey_bold
#    startup_zeshy_terminal_prompt.host                    red
#    startup_zeshy_terminal_prompt.user                    red_bold
#    startup_zeshy_terminal_prompt.path                    yellow
#    startup_zeshy_terminal_prompt.prior_command_succeeded yellow_bold
#    startup_zeshy_terminal_prompt.prior_command_failed    magenta_bold
#    startup_zeshy_terminal_prompt.input                   white_bold
#)
#
#declare_global '
#map ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME_IF_NONSUPERUSER
#
#Map color style names to prompt color names if the current user is the superuser
#(i.e., root) or ignore such names otherwise. See
#${ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME} for further details.
#'
#ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME_IF_NONSUPERUSER=(
#    # startup_zeshy_terminal_prompt().
#    startup_zeshy_terminal_prompt.brace                   grey_bold
#    startup_zeshy_terminal_prompt.host                    cyan
#    startup_zeshy_terminal_prompt.user                    cyan_bold
#    startup_zeshy_terminal_prompt.path                    blue
#    startup_zeshy_terminal_prompt.prior_command_succeeded blue_bold
#    startup_zeshy_terminal_prompt.prior_command_failed    red_bold
#    startup_zeshy_terminal_prompt.input                   white_bold
#)

    #FUXME: Add a new function append_map_to_map() implementing such
    #functionality.

    # If the current user is the superuser, add superuser-specific prompt color
    # styles to such global; otherwise, add non-superuser-specific prompt color
    # styles to such global.
#   if is_current_user_superuser; then
#       ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME+=(
#           ${(kv@)ZESHY_PROMPT_COLOR_STYLE_NAME_TO_COLOR_NAME_IF_SUPERUSER} )
#   else
#   fi

#       set_map_to_map ZESHY_COLOR        ZESHY_COLOR_2
#       set_map_to_map ZESHY_PROMPT_COLOR ZESHY_PROMPT_COLOR_2
#       set_map_to_map ZESHY_COLOR_STYLE  ZESHY_COLOR_STYLE_2
#   # If the current terminal supports at least the canonical eight colors,
#   # assume such terminal to be monochrome (i.e., colorless).
#   else # elif (( terminal_color_count >= 8 )); then
#       set_map_to_map ZESHY_COLOR        ZESHY_COLOR_8
#       set_map_to_map ZESHY_PROMPT_COLOR ZESHY_PROMPT_COLOR_8
#       set_map_to_map ZESHY_COLOR_STYLE  ZESHY_COLOR_STYLE_8

#/==============================v===============================================\
#| color style name             | application                                   |
#>==============================+===============================================<
#| punctuation                  | punctuation with no semantic meaning          |
#| punctuation_semantic         | punctuation with semantic meaning             |
#>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<
#| say_caller                   | caller name printed by say(), cry(), etc.     |
#\==============================^===============================================/

#abstracting all colors prefixing common substrings of output
#(e.g., punctuation) to . 
#FUXME: Interesting. We have no incentive to use underscore rather than space
#here, do we? The latter remains both easier to type and read. Woops! False. zsh
#handles spaces in keys... poorly. Pass.
#FUXME: Completely document *ALL* supported color names, after ensuring the
#implementation works as desired.
#FUXME: Reduce to either run_hook_on_zeshy_startup_if_shell_interactive() or
#run_hook_on_zeshy_startup_if_stdout_terminal(). Probably the
#latter, I should think, which is more general; the former's too specific.
#   print "ZESHY_COLOR[red]: ${ZESHY_COLOR[red]}hmm"
    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_no_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #precompile_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
#   precompile_zeshy_terminal_color_8

#declare_function '
#void precompile_zeshy_terminal_color_8(void)
#
#Define color globals for terminals supporting between 8 to 255 colors.
#'
#function precompile_zeshy_terminal_color_8() {

#       color_background_name="${color_name}_background"
#   for color_name (${color_names[@]} grey) {
#       ZESHY_PROMPT_COLOR[${color_name}]="%{${ZESHY_COLOR[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BACKGROUND[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_BOLD[${color_name}]="%{${ZESHY_COLOR_BOLD[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_BOLD_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_ITALIC[${color_name}]="%{${ZESHY_COLOR_ITALIC[${color_name}]}%}"
#   }

    # Define foreground greyscale colors. The default definitions assign
    # ${ZESHY_COLOR_BLACK} a somewhat unreadable quasi-black color value and
    # ${ZESHY_COLOR_WHITE} a somewhat grey rather than white color value.
#   ZESHY_COLOR[black]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[normal]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[black_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
#   ZESHY_COLOR[grey]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"

    #FUXME: Defer to global list ${ZESHY_COLOR_NAMES}, instead.
    # List of all such color names, excluding pseudo-color "grey".
#   list color_names
#   color_names=( white black red green blue yellow magenta cyan )

#FUXME: Hmmm; we appear to never set this. Do so here!
#declare_global '
#string ZESHY_PROMPT_COLOR_RESET
#
#Prompt escape code resetting foreground and background colors to defaults.
#'

# Declare and document reset colors.
#declare_global '
#string ZESHY_COLOR_RESET
#
#ANSI escape code resetting foreground and background colors to defaults.
#'

# Declare and document general purpose colors.
#declare_global '
#map ZESHY_COLOR
#
#Map lowercase color name to ANSI escape code foregrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_WEAK
#
#Map lowercase color name to ANSI escape code foregrounding such color weakly.
#'
#declare_global '
#map ZESHY_COLOR_BOLD
#
#Map lowercase color name to ANSI escape code foregrounding such color brightly.
#'
#declare_global '
#map ZESHY_COLOR_ITALIC
#
#Map lowercase color name to ANSI escape code foregrounding such color italicized.
#'
#declare_global '
#map ZESHY_COLOR_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_BOLD_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color brightly.
#'

# Declare and document prompt-specific colors.
#declare_global '
#map ZESHY_PROMPT_COLOR
#
#Map lowercase color name to prompt escape foregrounding such color.
#'
#declare_global '
#map ZESHY_PROMPT_COLOR_WEAK
#
#Map lowercase color name to prompt escape foregrounding such color weakly.
#'
#declare_global '
#map ZESHY_PROMPT_COLOR_BOLD
#
#Map lowercase color name to prompt escape foregrounding such color brightly.
#'
#declare_global '
#map ZESHY_PROMPT_COLOR_ITALIC
#
#Map lowercase color name to prompt escape foregrounding such color italicized.
#'
#declare_global '
#map ZESHY_PROMPT_COLOR_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color.
#'
#declare_global '
#map ZESHY_PROMPT_COLOR_BOLD_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color brightly.
#'

#FUXME: I've given a great deal of thought to this. Unfortunately, the current
#approach is demonstrably bad. For one, separating colors between maps precludes
#convenient dynamic usage resembling the following:
#
#   string ZESHY_COLOR_NAME_PUNCTUATION='grey_bold'
#   print "test${ZESHY_COLOR[${ZESHY_COLOR_NAME_PUNCTUATION}]}: yay!"
#
#I assume you see what we did there? We could have chosen
#ZESHY_COLOR_NAME_PUNCTUATION to be any composite of a color and color
#attributes, including: "grey", "grey_italic", "grey_bold_italic", "grey_weak",
#"grey_weak_background", and so on. As one can see, that's an enormous number of
#keys for each color... but not a single key more than we currently have,
#dispersed as they are across ten or so map globals. Centralize, my Self.
#
#That's great, but that's not the sole reason. By centralizing all colors into a
#single map, we *VASTLY* simplify startup logic for initializing ${ZESHY_COLOR}.
#On an 8-color terminal? No problem; just perform a *SINGLE MAP COPY*:
#
#   ZESHY_COLOR=( "${ZESHY_COLOR_8[@]}" )
#
#Done. Without such approach, we'd need a positively obscene number of maps --
#basically, ten or see for each number of terminal colors threshold. We're
#talking in upwards of fourty maps, which is simply obscenity. A different way
#is possible, friends.

    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_2_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #precompile_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
# Avoid confining such function to interactive shells and/or shells whose
# standard output is attached to a terminal device. Sufficiently many CLI
# applications are now color-aware (e.g., "less", "vim") that outputting color
# when running non-interactively is largely a non-issue.
#   die_unless_shell_interactive
# Moreover, I've always found such behavior
# exceedingly annoying in other applications (e.g., "ls"), and don't see.
#FUXME: Honestly, "_BOLD" makes little sense. It's not bold; it's *BRIGHTER*.
#Rename ZESHY_COLOR_BOLD to ZESHY_COLOR_BRIGHT and so forth. Likewise, rename
#"_WEAK" to "_FAINT" for orthogonality. (Don't forget "ansi_weak" to "ansi_faint",
#too.)

#FUXME: Map ${ZESHY_ANSI_SGR} suggests we could profitably implement _FAINT and
#_STANDOUT versions, as well. Test us up! *YES*. Great: the "italic" attribute
#is implemented as italics under many terminals. We absolutely want that. :)
#   remove_string_matches "${*}" "${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_GLOB}"
#   print_string "${*//${~ZESHY_ZSH_COLOR_GLOB}/}"
#FUXME: Rename to remove_string_ansi_color().
#FUXME: Rename to remove_string_zsh_color().
#   print_string "${*//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}/}"
#Glob matching the 2-byte ANSI Select Graphic Rendition (SGR) prefixing all
#color-specific ANSI escape codes. Dismantled, this is:
# Handle all terminal color functionality *OTHER* than defining such colors. See
# "00-setup/" for the latter.
