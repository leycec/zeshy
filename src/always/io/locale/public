#!/usr/bin/env zsh
# ====================[ public                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle public locales. Public locales are locales generated by either
# installing "glibc" or an equivalent C library (e.g., "uclibc") or running an
# external command (e.g., "locale-gen"). All other locales are private, and
# hence inaccessible to customary applications.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_locale_public(
  string locale,
  string error_message = "\"${locale}\" not a public locale")

Throw an exception unless the the passed locale has been generated on the
current system.
'
function die_unless_locale_public() {
    die_unless_args_1_to_2 'expected one locale and optional error message'
    string locale="${1}"
    is_locale_public "${locale}" or
        die "${2:-\"${locale}\" not a public locale}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_locale_public(string locale)

Return true if the passed locale has been generated on the current system.
'
function is_locale_public() {
    die_unless_arg 'expected one locale'
    print_locales_public | is_string_line "${1}"
}

# ....................{ PRINTERS                           }....................
document_function '
string print_locales_public(void)

Get a newline-delimited list of public locales generated on the current system.
'
function print_locales_public() {
    #FIXME: Does "uclibc" install a comparable command?
    # "glibc" installs "locale", which when run with option "-a" lists all
    # available locales in newline-delimited format. Since alternative C
    # libraries (e.g., "uclibc") are unlikely to install such command, throw an
    # exception unless "locale" is currently installed.
    die_if_args
    die_unless_pathable locale
    locale -a
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Contemplate alternate nomenclature resembling:
#locale.public.list:
#locale.public.die_unless:
#locale.public.is:
#Hmm. It's quaint, really; but not terribly readable. I vastly prefer the
#current (mostly) human-readable style. That said, I'm concerned about the long-
#term implications of a lack of namespacing.

# Such locales
# are usually installed on either installing "glibc" or running corresponding
# utilities (e.g., "localegen" under Gentoo).
    #FIXME: Antiquated. Just call locale.
#   get_first_nonempty_variable_value_if_found LC_ALL LC_CTYPE LANG or
#       print_string "C"
# ${LC_ALL} supersedes ${LC_CTYPE} superseding ${LANG} for purposes of
# ascertaining the character locale, according to:
#
#     http://rosettacode.org/wiki/Terminal_control/Unicode_output
#   if is_string_nonempty LC_ALL
#   then print_string ${LC_ALL}
#   elif is_string_nonempty LC_CTYPE
#   then print_string ${LC_CTYPE}
#   elif is_string_nonempty LANG
#   then print_string ${LANG}
#   else die 'environment variables "LC_ALL", "LC_CTYPE", and "LANG" either not defined or empty'
#   fi

    #FIXME: We *REALLY* want to verify the passed string is a valid locale
    #under the current system, since we're not actually calling a command. How?
# While the Linux community appears to prefer the
# former, enough systems use the latter to necessitate matching both.#
