#!/usr/bin/env zsh
# ====================[ public                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle public locales. Public locales are locales generated by either
# installing "glibc" or an equivalent C library (e.g., "uclibc") or running an
# external command (e.g., "locale-gen"). All other locales are private, and
# hence inaccessible to customary applications.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_public_locale(
#   string locale,
#   string error_message = "\"${locale}\" not a public locale")
#
# Throw an exception unless the the passed locale has been generated on the
# current system.
function die_unless_public_locale() {
    die_unless_args_1_to_2 'expected one locale and optional error message'
    string locale="${1}"
    is_public_locale "${locale}" or
        die "${2:-\"${locale}\" not a public locale}"
}

# ....................{ TESTERS                            }....................
# boolean is_public_locale(string locale)
#
# Return true if the passed locale has been generated on the current system.
function is_public_locale() {
    die_unless_arg 'expected one locale'
    list_public_locales | is_string_line "${1}"
}

# ....................{ LISTERS                            }....................
# string list_public_locales(void)
#
# Get a newline-delimited list of public locales generated on the current
# system.
function list_public_locales() {
    #FIXME: Does "uclibc" install a comparable command?
    # "glibc" installs "locale", which when run with option "-a" lists all
    # available locales in newline-delimited format. Since alternative C
    # libraries (e.g., "uclibc") are unlikely to install such command, throw an
    # exception unless "locale" is currently installed.
    die_if_args
    die_unless_pathable locale
    locale -a
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Contemplate alternate nomenclature resembling:
#locale.public.list:
#locale.public.die_unless:
#locale.public.is:
#Hmm. It's quaint, really; but not terribly readable. I vastly prefer the
#current (mostly) human-readable style. That said, I'm concerned about the long-
#term implications of a lack of namespacing.

# Such locales
# are usually installed on either installing "glibc" or running corresponding
# utilities (e.g., "localegen" under Gentoo).
    #FIXME: Antiquated. Just call locale.
#   get_first_nonempty_variable_value_if_found LC_ALL LC_CTYPE LANG or
#       print_string "C"
# ${LC_ALL} supersedes ${LC_CTYPE} superseding ${LANG} for purposes of
# ascertaining the character locale, according to:
#
#     http://rosettacode.org/wiki/Terminal_control/Unicode_output
#   if is_nonempty LC_ALL
#   then print_string ${LC_ALL}
#   elif is_nonempty LC_CTYPE
#   then print_string ${LC_CTYPE}
#   elif is_nonempty LANG
#   then print_string ${LANG}
#   else die 'environment variables "LC_ALL", "LC_CTYPE", and "LANG" either not defined or empty'
#   fi

    #FIXME: We *REALLY* want to verify the passed string is a valid locale
    #under the current system, since we're not actually calling a command. How?
# While the Linux community appears to prefer the
# former, enough systems use the latter to necessitate matching both.#
