#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *langinfo getters* (i.e., functions obtaining string constants returned
by the canonical POSIX C function `nl_langinfo`). While map ${langinfo} also
provides access to such constants, such map's keys are _not_ terribly human-
readable or -rememberable (e.g., `CRNCYSTR`, the currency symbol for the current
locale).
-/-

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_locale_format_currency(void)

Get the format string for currency signs in the current locale (e.g., `-$`). The
first character of such string signifies how to print such sign, while all
characters following such character signify the sign. Specifically, if the
first character of such string character is:

* `-`, such sign should be printed _before_ currency values.
* `+`, such sign should be printed _after_ currency values.
* `.`, such sign should be printed _in place of_ the radix point returned by
  get_locale_delimiter_radix() rather than before or after currency values.
/---
function get_locale_format_currency() {
    die_if_args
    return_string "${langinfo[CRNCYSTR]}"
}

# ....................{ GETTERS ~ delimiter                }....................
declare_function_with_stdin <<'/---'
string get_locale_delimiter_radix(void)

Get the radix point for the current locale (e.g., `.`), also referred to as the
decimal mark when applying the conventional base 10 notation. Such string
separates the integer from fractional portion of floating point numbers under
such locale.
/---
function get_locale_delimiter_radix() {
    die_if_args
    return_string "${langinfo[RADIX]}"
}

declare_function_with_stdin <<'/---'
string get_locale_delimiter_thousands(void)

Get the thousands separator for the current locale (e.g., `,`). For readability,
such character optionally separates each group of three consecutive digits of
integers and the integer portion of floating point numbers under such locale.
/---
function get_locale_delimiter_thousands() {
    die_if_args
    return_string "${langinfo[THOUSEP]}"
}

# ....................{ GETTERS ~ pcre                     }....................
# Sadly, the arguably more informative string constants "YESSTR" and "NOSTR"
# have been withdrawn from recent versions of the locale specification.

declare_function_with_stdin <<'/---'
string get_locale_pcre_yes(void)

Get a regular expression matching positive single-character responses to yes/no
questions for the current locale (e.g., `^[yYoO].*`).
/---
function get_locale_pcre_yes() {
    die_if_args
    return_string "${langinfo[YESEXPR]}"
}

declare_function_with_stdin <<'/---'
string get_locale_pcre_no(void)

Get a regular expression matching negative single-character responses to yes/no
questions for the current locale (e.g., `^[nN].*`).
/---
function get_locale_pcre_no() {
    die_if_args
    return_string "${langinfo[NOEXPR]}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_list_to_locale_characters_yes(string list_name)

Set the passed list (ideally, a list set) to all characters signifying positive
responses to yes/no questions for the current locale in the same order as
returned by get_locale_pcre_yes(): e.g.,

.set_list_to_locale_characters_yes()
==========================================
[source]
------------------------------------------
>>> set_locale en_CA.utf8
>>> get_locale_pcre_yes
^[yYoO].*
>>> list_set canadian_yes
>>> set_list_to_locale_characters_yes canadian_yes
>>> print_string "${canadian_yes[@]}"
y Y o O
------------------------------------------
==========================================
/---
function set_list_to_locale_characters_yes() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltlcy="${1}" pcre__sltlcy character_class__sltlcy
    die_unless_list "${list_name__sltlcy}"

    # If the PCRE returned by get_locale_pcre_yes() is prefixed by a character
    # class, get the contents of such class. Since all such PCREs should be of
    # the form "^[${class}].*" and hence prefixed by a character class, this is
    # (largely) a formality.
    #
    # According to the set of all such PCREs harvested by Perl 5 package
    # http://cpansearch.perl.org/src/TOBYINK/Lingua-Boolean-Tiny-0.006/lib/Lingua/Boolean/Tiny/More.pm,
    # a small subset of such PCREs are *NOT* of the above form: e.g.,
    #
    # * Central Khmer, having YESEXPR "^[yY]([eE][sS])?".
    # * Konkani, having YESEXPR "^(\x{939}\x{92f}|[yY])".
    # * Ukranian, having YESEXPR
    #   "^([Yy+]|[\x{422}\x{442}][\x{410}\x{430}][\x{41a}\x{43a}]?)\$".
    #
    # Even in such nonconformant cases, however, such PCRE always contains a
    # character class. Since nonconformant PCREs arguably constitute bugs in the
    # corresponding locale definitions, ignoring such issues by only matching a
    # character class seems the simplest general-purpose approach.
    pcre__sltlcy="$(get_locale_pcre_yes)"
    if { is_string_matches_glob_capturing_groups\
        "${pcre__sltlcy}" *'['([^\]]#)']'* } {
        # Decode encoded characters in such character class (e.g., from
        # "\x{43a}" to "ะบ").
        character_class__sltlcy="$(unescape_string_pcre_escapes "${match[1]}")"

        # Split such character class into individual characters.
        "${character_class__sltlcy}"
    # Else, throw an exception.
    } else {
        die "nl_langinfo() YESEXPR \"${pcre__sltlcy}\" contains no \"[\"- and \"]\"-delimited character class"
    }
}

# --------------------( WASTELANDS                         )--------------------
        # Convert "\x{...}" expressions in such character class into the UTF-8-
        # encoded characters such expressions match.
    #FUXME: We *REALLY* need to define is_string_matches_glob() *EARLY*, to
    #ensure that noglob is available on such function to the zeshy codebase.

#FUXME: POSIX function nl_langinfo() provides a large number of rather cool
#functions for dynamically incorporating the current user's locale in a
#language-independent fashion. I particularly liked "YESEXPR", which, to
#quote: "Returns a regular expression that can be used with the regex
#function to recognize a positive response to a yes/no question." Nice! But
#how the heck do we access this from the command line, if such library is
#available? *OOOH*. Ridiculous. Just call "locale yesexpr". God, that's neat-
#o. For a description of all available options, see "man nl_langinfo".
