#!/usr/bin/env zsh
# ====================[ encoding                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle character locale encodings (e.g., UTF-8, US-ASCII).

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_encoding_utf8(void)

Return true if the current character locale encodes to UTF-8: e.g.,

.is_encoding_utf8()
==========================================
[source]
------------------------------------------
>>> get_locale_character
en_CA.utf8
>>> is_encoding_utf8 and print_string '☺' or print_string ':)'
☺
------------------------------------------
==========================================
/---
function is_encoding_utf8() {
    # The current character locale enables UTF-8 encoding if suffixed by either:
    #
    # * ".utf8", the canonical UTF-8 encoding name or
    # * ".UTF-8", a non-canonical but common alias of ".utf8".
    die_if_args
    is_string_glob_matches "$(get_encoding)" '(utf8|UTF-8)'
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_encoding(void)

Get the current character locale encoding, a string signifying the character map
the current shell decodes standard input from and encodes standard output to.
Such map is typically defined for such locale at locale creation time via
`localedef -f`: e.g.,

.get_encoding()
==========================================
[source]
------------------------------------------
>>> get_locale_character
en_CA.utf8
>>> get_encoding
UTF-8
------------------------------------------
==========================================
/---
function get_encoding() {
    # Validate sanity.
    die_if_args

    #FIXME: Does "locale charmap" either fail or return the empty string if no
    #charmap option was passed to "localedef"? One or the other must certainly
    #be the case. Not terribly sure how to reliably test this. In any case,
    #revert to matching get_character_locale() print_string if "locale" fails.

    # If "locale" is in the current ${PATH}, defer to such command. See locale
    # documentation for the complex details.
    if { is_pathable locale } {
        locale charmap
    # Else, attempt to extract such encoding from the current character locale
    # with extended glob matching.
    } else {
        string locale_character; locale_character="$(get_locale_character)"
        get_string_glob_match_index_if_matched "${locale_character}" '*.(?*)' or {
            print_warning "character locale \"${locale_character}\" contains no \".\"-prefixed encoding; defaulting to \"ISO-8859-1\""
            return_string 'ISO-8859-1'
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: For such a central function called countless of times elsewhere, this is
#simply too heavyweight -- particularly as is_locale_encoding_utf8() will
#readily do. The "_character" is redundant, since locale encodings are *ALWAYS*
#locale character encodings. (There's no other sort.)
#
#tl;dr
#=====
#Rename to is_locale_encoding_utf8() and shift to a new component
#"io/locale/encoding". (Shift function get_locale_encoding() as well, of
#course.)
#FUXME: Wait. Even the "_locale" is redundant, since "encoding" is, of course,
#the noun referring to the current character encoding. Hence, rename such
#family of functions to is_encoding_utf8() and get_encoding(). Simple!
