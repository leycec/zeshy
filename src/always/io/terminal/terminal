#!/usr/bin/env zsh
# ====================[ terminal                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle terminals and terminal attributes (e.g., VT100 emulation).
#
# --------------------( CAVEATS                            )--------------------
# All functions defined by this component operate on file descriptors. Since
# subshells do not inherit file descriptors attached to terminal devices, some
# functions do not behave as expected when called from subshells: e.g.,
#
#    >>> is_standard_output_terminal and print "Firefly Class"
#    Firefly Class
#    >>> $(is_standard_output_terminal or print "Universal Alliance")
#    Universal Alliance
#
# Avoid calling functions from subshells, where feasible.

# ....................{ GETTERS                            }....................
document_function '
integer get_terminal_width(void)

Get the width in characters of the current terminal device.
'
function get_terminal_width() {
    die_if_args   # also gettable with "tput columns", but overkill
    print_string "${COLUMNS}"
}

document_function '
integer get_terminal_height(void)

Get the height in lines of the current terminal device.
'
function get_terminal_height() {
    die_if_args   # also gettable with "tput lines", but overkill
    print_string "${LINES}"
}

# ....................{ WRITERS                            }....................
#FIXME: Provide additional terminfo-based capabilities. See "man terminfo".

#FIXME: Rename to simply clear_terminal().
document_function '
void clear_terminal_screen(void)

Clear the current terminal of all prior output. This function implements a
pure-Zsh analogue of the "clear" command.
'
function clear_terminal_screen() {
    # Validate sanity.
    die_if_args
    die_unless_standard_output_terminal

    # Oddly, the terminfo "clear" capability moves the cursor to the second
    # rather than first line after clearing the screen. Amend this.
    echoti clear
    move_terminal_cursor_to 1 1
}

#FIXME: Rename to move_terminal_cursor_to_position().
#FIXME: Add support for negative index offsets.
document_function '
void move_terminal_cursor_to(integer column, integer row)

Move the cursor on the current terminal to the passed 1-based column and row
indices.
'
function move_terminal_cursor_to() {
    # Validate passed arguments.
    die_unless_args_2 'expected one column and one row index'
    die_unless_standard_output_terminal
    die_unless_integer_nonnegative "${1}"
    die_unless_integer_nonnegative "${2}"
    integer column="${1}" row="${2}"
    (( column <= $(get_terminal_width) )) or die\
        "column ${column} exceeds terminal width $(get_terminal_width)"
    (( row <= $(get_terminal_height) )) or die\
        "row ${row} exceeds terminal height $(get_terminal_height)"

    # Convert Zsh-style 1-based indices to "terminfo"-style 0-based indices.
    echoti cup $(( row - 1 )) $(( column - 1 ))
}

# ....................{ STARTUP                            }....................
append_startup_zeshy_command_if_shell_interactive startup_zeshy_terminal

document_function '
void startup_zeshy_terminal(void)

Reconfigure the current terminal for improved interoperability.
'
function startup_zeshy_terminal() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Permit use of meta characters (i.e., characters setting the high bit).
    set meta-flag    on
    set input-meta   on
    set output-meta  on
    set convert-meta off

    # Numerous applications complain under long ${TERM} strings (e.g.,
    # "rtorrent"). Truncate such strings to equivalent abbreviations.
    is "${TERM-}" == 'rxvt-unicode-256color' si and TERM='rxvt-unicode'
}

# --------------------( WASTELANDS                         )--------------------
#       say 'truncating ${TERM} to "rxvt-unicode" for safety...'

    # Return true if the file descriptor for standard print_string is open and
    # attached to a terminal. (Avoid testing standard input, as commands passed
    # piped input may still be attached to a terminal.)

#FUXME: Rename "shell_terminal" to "terminal" everywhere. While the former is
#strictly true, it's also cumbersome and leads to function names resembling
#get_shell_terminal_width(). Ugh.


#FUXME: I've pierced the veil. So, the difference between is_shell_interactive()
#and is_terminal() as we've currently defined them is as follows:
#
#* is_shell_interactive() == true if stdin  is a tty.
#* is_terminal()          == true if stdout is a tty.
#
#This is both silly and non-intuitive. We really need to standardize such
#terminology; how about the following, instead:
#
#* is_terminal_standard_input()  == true if stdin  is a tty.
#* is_terminal_standard_output() == true if stdout is a tty.
#* is_terminal()                 == true if both stdin and stdout are ttys.
#
#Or:
#
#* is_standard_input_terminal()  == true if stdin  is a tty.
#* is_standard_output_terminal() == true if stdout is a tty.
#* is_terminal()                 == true if both stdin and stdout are ttys.
#
#Yes! Absolutely the latter. "Standard input" and "output" are the nouns;
#"terminal" is the adjective acting on such nouns. (Reads much better, too.)
#Err... wait. But the latter's incongruous with is_terminal(). Actually, come to
#think, why do we need is_terminal_standard_input() and
#is_terminal_standard_output()? It certainly can't hurt to define them, but the
#only one we really care about is is_terminal(). I mean, how sensible is it to
#discuss a situation in which stdin is a tty but stdout isn't? What would that
#even mean? Ah; right. Pipes. It's all about pipes. O.K.; so, the distinction is
#sensible. It seems to me that we only care about:
#
#* is_terminal_standard_input() when requiring only interactive user input
#  (mostly in this file and the "input" directory only, I suspect).
#* is_terminal_standard_output() when requiring only terminal print_string (mostly in
#  this file and the "output" directory only, I suspect).
#
#In most cases, however, it seems that we really require both. So-called
#"interactive" aliases, for example, should only be active when *BOTH* stdin and
#stdout are ttys. We don't really expect them to be meaningfully called from
#pipes, etc. This suggests that most uses of the adjective "interactive" should
#really be renamed to "terminal" (e.g., terminal alias, terminal substitution).
#Ah; that *WOULD* be a fine idea, except "terminal abbreviation" doesn't read
#right. After all, VT100 is a terminal abbreviation -- but that's not at all
#what we'd mean. So keep the "interactive" for aliases, at least.
#
#Interesting: how *DO* we perfectly test for whether or not a command is called
#from an interactive prompt? It would be sensible, actually, to allow any such
#command to include piped interactive aliases. (I mean, why not? Where's the
#profit in disallowing it? None, really. Just piss people off... Including me.)
#For example, it's easy enough to allow "l | gr ok" when called from a prompt:
#"l" satisfies is_terminal_standard_input() and "gr ok" satisfies
#is_terminal_standard_output(). But what about the "ca" in "l | ca | gr ok"?
#Assuming "ca" to be an interactive alias for "cat", this should be allowed. But
#neither stdin or stdout or ttys. A question for another day, I suspect. Oh. Yes,
#it's true that "gr ok" satisfies is_terminal_standard_output() -- but so do all
#non-interactive scripts. Hence,  is_terminal_standard_output() is really non-
#useful for anything except testing explicitly whether we can muck around with
#terminal attributes. For now, consistency mandates that we allow interactive
#aliases only when *BOTH* stdin and stdout are ttys. (Hmm; assuming Zsh has no
#cleaner method, permitting interactive aliases in pipes would necessitate
#testing whether stdin for the first command in the current pipe *AND* stdout
#for the last command in the current pipe are both ttys. I have little idea how
#to dynamically inspect that. The ${pipestatus} global does suggest there might
#be a way. Investigate. Hmmm; no. There doesn't seem to be a way, I'm afraid.)
#
#O.K.; O.K.; the current definition of "interactive alias" is actually fine.
#If stdin is a tty, allow interactive aliases; otherwise, do not. Pretty simple.
#It works. Why additionally require that stdout be a tty? No incentive, really.
#
#Ah. We also want to rename is_standard_input_piped() to is_standard_input_piped() and
#set_string_to_standard_input_piped() to set_string_to_standard_input_piped(). ("piped"
#is *MUCH* better than "pipe" here.)
#
#Conclusions:
#
#* Replace is_standard_input_piped() with is_standard_input_piped().
#* Replace is_standard_output_terminal() with is_standard_output_terminal().
#* Replace set_string_to_standard_input_piped() with set_string_to_standard_input_piped().
#* Define is_shell_interactive() to be a second name for the
#  is_standard_input_terminal() function. I'm not fond of second names, in
#  general; but it just makes so much absolute sense, in this case. There are
#  two fundamentally different ways to think of this situation:
#  1. Non-semantically: standard input of the current command is a tty.
#  2. Semantically: the current shell was run "interactively" (i.e., *WHEN FIRST
#     STARTED*, standard input to such shell was a tty).
#  *OH*. Those *AREN'T THE SAME AT ALL*. They're completely different. We need
#  a separate is_shell_interactive() testing "-o interactive". That solves all
#  of the concerns above on interactive aliases and pipes, obviously; but that
#  doesn't have anything to do with whether or not the current command is
#  "interactive" (i.e., can accept interactive user input). Hence, we do need a
#  separate is_standard_input_terminal() function for testing that. Now, *HERE*
#  we can provide a separate name for is_standard_input_terminal():
#  is_current_command_interactive(). Nah; too complicated. Just go with the
#  canonical name here. Wow; I really confused myself a great deal on this. (To
#  be fair, it *IS* all rather confusing.)
#* Don't bother defining an is_terminal() function. There's just no use case, at
#  the moment.
    #FUXME: is_shell_interactive() does not necessarily imply
    #is_standard_output_terminal(), does it? If not, we'll need to merely return rather
    #than die as we currently do if non-terminal.
#FUXME: We need a new hook type:
# append_startup_zeshy_command_if_shell_interactive startup_zeshy_terminal_attributes

#That's about it. Pretty simple. While is_shell_interactive() is a nice name, it
#also obscures the underlying idea (as evidenced by the enormous thought-spree
#above). Better to be direct, honest, and unobscured.
#* Globally replace is_shell_interactive() with is_standard_input_terminal().
#In general, most current calls to is_shell_interactive() should be replaced by
#calls to the above is_terminal(). We'll probably need to evaluate on a case-by-
#case instance, however; global replace seems somewhat inadequate, in this case.
#
#Yes. Also replace "IF_INTERACTIVE" with "IF_TERMINAL" in global variables. More
#concise and coincides better with function nomenclature.
#How about the preposition "_on_", in any case? Improves readability a bit:
#
#* is_terminal_on_standard_input()  == true if stdin  is a tty.
#* is_terminal_on_standard_output() == true if stdout is a tty.
# ....................{ GETTERS ~ lines                    }....................
#FUXME: Rename get_wrapped_line_height(). Unsure it's used anywhere, anyway.
# integer get_displayed_line_length(string text1, string text2, ...)
#
# Get the total number of lines in the passed strings when displayed on the
# current terminal (i.e., accounting for long lines). This is a number strictly
# greater than or equal to that returned by get_string_line_length().
#function get_displayed_line_length() {
    # Validate passed arguments.
#    die_unless_args 'expected at least one string'
#    integer displayed_line_length terminal_width
#    terminal_width_plus_one=$(get_terminal_width)
#    (( ++terminal_width_plus_one ))

    # For each line of the passed string, increment line length by the sum of:
    #
    # * "1", for the physical trailing newline.
    # * The number of logical newlines Zsh injects into such string for wrapping
    #   purposes, calculated as the physical line length divided by terminal
    #   width (i.e., maximum logical line length). Add 1 to avoid off-by-one.
#    for line ("${(f)@}") {
#        (( displayed_line_length += 1 + (${#line} / terminal_width) ))
#    }

    # Return such length.
#    print_string ${displayed_line_length}
#}
