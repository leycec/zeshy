#!/usr/bin/env zsh
# ====================[ color                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle ANSI- and zsh-specific color codes.
#
# --------------------( SEE ALSO                           )--------------------
# https://en.wikipedia.org/wiki/ANSI_escape_code
#   Excrutiatingly helpful dissection of ANSI escape codes.
#
# http://ciembor.github.com/4bit
#   4bit, arguably the best and probably only terminal color scheme designer.
#
# --------------------( TODO                               )--------------------
# * Add support for fish-like syntax highlighting. Happily, someone's already
#   gone to the work of Zshifying this; we'll just want to Zeshify it a bit:
#   https://github.com/zsh-users/zsh-syntax-highlighting
# * Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#   urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#   some Zsh code the other day simplifying such support... Hmmmmmmmm.
# * It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#   https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors

# ....................{ GLOBALS                            }....................
# Unfortunately, zsh fails with a "bad pattern" error when aggregating the
# following CSI and SGR globs into a single glob. Separate such globs, for now.

document_global '
string ZESHY_ANSI_COLOR_CODE_GLOB_CSI

Glob matching the 2-byte ANSI Control Sequence Introducer (CSI) prefixing all
ANSI escape codes, equivalent to "<Esc>[".
'
ZESHY_ANSI_COLOR_CODE_GLOB_CSI=$'\E\['

document_global '
string ZESHY_ANSI_COLOR_CODE_GLOB_SGR

Glob matching the 2-byte ANSI Select Graphic Rendition (SGR) prefixing all
color-specific ANSI escape codes. Dismantled, this is:

* (...)m", matching zero or more Select Graphic Rendition (SGR)
  parameters also referred to as color indices:
  * "|", matching the empty string and hence the ANSI escape code
    "CSI m" identical to "<Esc>[0m" resetting all SGR parameters.
  * "[0-9](#c1,3)", matching an 8-bit integer expressed as one to three
    digits as the first SGR parameter.
  * "(;[0-9](#c1,3))##", matching zero or more sequences of a semicolon
    followed by an 8-bit integer as all following SGR parameters.
'
ZESHY_ANSI_COLOR_CODE_GLOB_SGR='(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'

document_global '
string ZESHY_ZSH_COLOR_CODE_GLOB

Glob matching color-specific Zsh prompt escapes. Dismantled, this is:

* "%(...)", matching a "%"-prefixed prompt escape.
* "[BbSsUu]", matching a bold, standout, or underline parameter.
* "[0-9]##[FfKk]", matching a fore- or background parameter prefixed by
  integer argument consisting of one or more digits.
* "[FfKk]\{?*\}", matching a fore- or background parameter suffixed by:
  * String argument consisting of a well-known color name (e.g., "red").
  * Integer argument consisting of one or more digits.
'
ZESHY_ZSH_COLOR_CODE_GLOB='%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'

# ....................{ TESTERS                            }....................
#FIXME: Rename to is_terminal_color().
document_function '
boolean is_color_terminal(void)

Return true if shell output is attached to a polychrome terminal device (i.e.,
a terminal device providing more than merely monochrome black and white).
'
function is_color_terminal() {
    die_if_args
    is_standard_output_terminal and (( $(get_terminal_color_count) > 2 ))
}

# ....................{ GETTERS                            }....................
document_function '
integer get_terminal_color_count(void)

Get the number of colors supported by the current terminal device.
'
function get_terminal_color_count() {
    die_if_args  # also gettable with "echotc Co", but overkill
    print_string "${terminfo[colors]}"
}

#FIXME: Probably Linux specific. I vaguely wonder what the BSD variant is...
document_function '
string get_list_command_colors(void)

Get the colon-delimited string of colors with which "ls" colors list output.
As a (hopefully) beneficial side effect, running "ls" in color terminals after
calling this function implicitly colors all list output.
'
function get_list_command_colors() {
    # If global ${LS_COLORS} has not yet been defined, do so by evaluating the
    # print_string of "dircolors" as a Bourne shell script. (While odd, this remains
    # the canonical method for doing so.)
#   string_global_export  LS_COLORS
#   is_string_nonempty "${LS_COLORS}" or {
    is_variable LS_COLORS or {
        die_unless_pathable dircolors
        run_under_shell "$(dircolors --sh)" 'sh'
    }

    # Get such colors.
    print_string "${LS_COLORS}"
}

# ....................{ REMOVERS                           }....................
document_function '
string remove_string_ansi_color_codes(string text)

Remove all ANSI color codes from the passed string. The resulting string will
retain non-color ANSI escapes (e.g., "\033[J", clearing from the current
cursor to the end of the screen).
'
function remove_string_ansi_color_codes() {
    die_unless_args 'expected at least one string'
    print_string "${*//${ZESHY_ANSI_COLOR_CODE_GLOB_CSI}${~ZESHY_ANSI_COLOR_CODE_GLOB_SGR}/}"
}

document_function '
string remove_string_zsh_color_codes(string text)

Remove all Zsh color codes from the passed string. The resulting string will
retain non-color prompt escapes (e.g., "%D", expanding to the current date).
'
function remove_string_zsh_color_codes() {
    die_unless_args 'expected at least one string'
    print_string "${*//${~ZESHY_ZSH_COLOR_CODE_GLOB}/}"
}

# ....................{ STARTUP                            }....................
#FIXME: It'd be nice to avoid having to startup colors. I wonder if, rather than
#requiring startup_terminal_colors() be called on startup, we couldn't switch to
#expanding colors by calling color-named functions: e.g., "$(FG_WHITE_BOLD)", or
#perhaps "$(fg white bold)" or "$(get_foreground_bold_color white)". In any
#case, such functions initialize internal color structures if necessary and
#proceed on their way. This is inherently more robust, since of course nothing
#precludes users from setting "FG_WHITE_BOLD='nonsense!!!!uhoh%P%YYDYDYD%D'"
#externally, at the moment. Yes, I rather like the
#"$(get_foreground_bold_color white)" idea. Make it so, good sir! If efficiency
#actually mattered, such verbosity would be a poor idea. But it absolutely
#doesn't, so...
#FIXME: Or rather "$(get_color_bold_foreground white)".
append_command_to_zeshy_startup_if_shell_interactive\
    startup_zeshy_terminal_color

document_function '
void startup_zeshy_terminal_color(void)

Globally define colors for the current terminal. When under color-unaware
terminals, the variables below are left undefined and thus expand without
error to nothing when evaluated in the context of an actual prompt.
'
function startup_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    #FIXME: Incorrect. If not a terminal, we still need to define such globals
    #to the empty string, to simplify use elsewhere. (The caller shouldn't have
    #to care, in other words.) We probably want to implement three helper
    #functions resembling:
    #
    #* startup_terminal_no_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FIXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.

    startup_zeshy_terminal_color_8
#   is_color_terminal or return_true
#   get_terminal_color_count
}

document_function '
void startup_zeshy_terminal_color_8(void)

Globally define colors for terminals supporting between 8 to 255 colors.
'
function startup_zeshy_terminal_color_8() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    #FIXME: Heavyweight zsh script. When time affords, shift such functionality
    #into Zeshy. The less we depend on exogenous zsh scripts, the better to all!

    # Declare color-specific dictionaries: $fg, $fg_bold, $fg_no_bold, $bg,
    # $bg_bold, and $bg_no_bold. In each such dictionary, keys are color
    # names (e.g., "red") and values terminal-specific strings activating that
    # color combination under the current output.
    colors

    # Surround each color definition in "%{...%}"; this informs ZSH that, when
    # performing prompt expansion, these strings do not contribute to the length
    # of that prompt.
    string color_name_lowercase_string
    for color_name (WHITE BLACK RED GREEN BLUE YELLOW MAGENTA CYAN) {
        color_name_lowercase_string="$(lowercase_string ${color_name})"

        #FIXME: All such globals should be previously declared at the outermost
        #level. Cease defining such globals under an "eval"; use a newly defined
        #set_string() function resembling the current set_integer().
        #FIXME: For simplicity (and revisabality), declare such globals at the
        #outermost in a similar for loop.
        eval "string_global\
            FG_${color_name}='%{${fg_no_bold[${color_name_lowercase_string}]}%}'\
            FG_${color_name}_BOLD='%{${fg_bold[${color_name_lowercase_string}]}%}'\
            BG_${color_name}='%{${bg_no_bold[${color_name_lowercase_string}]}%}'\
            BG_${color_name}_BOLD='%{${bg_bold[${color_name_lowercase_string}]}%}'"
#           eval string_global_export FG_${color_name}='%{$fg_no_bold[${(L)color_name}]%}'
#           eval string_global_export FG_${color_name}_BOLD='%{$fg_bold[${(L)color_name}]%}'
#           eval string_global_export BG_${color_name}='%{$bg_no_bold[${(L)color_name}]%}'
#           eval string_global_export BG_${color_name}_BOLD='%{$bg_bold[${(L)color_name}]%}'
    }

    # Define hard-coded ANSI color codes for use below.
    integer ansi_black=0 ansi_white=7 ansi_intense=9

    # Define reset "colors" (i.e., resetting colors to their defaults).
    string_global_export FG_RESET="%{${reset_color}%}" BG_RESET="%{${reset_color}%}"

    # Redefine foreground greyscale colors. The above definitions assign
    # FG_BLACK a somewhat unreadable pure-black color value and FG_WHITE a
    # grey rather than white color value.
    #
    # Note: the substring "$'\033['" cannot be interpolated into the prior
    # and subsequent strings as "\$\033[". (We can't recall why; do you?)
    string_global\
        FG_BLACK="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_black}m%}"\
        FG_WHITE="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_white}m%}"\
        FG_WHITE_BOLD="%{${fg_bold[white]}%}"\
        FG_GREY="%{${fg_no_bold[white]}%}"\
        FG_GREY_BOLD="${FG_WHITE}"
#           FG_GREY_BOLD="%{${fg_bold[black]}%}"
}

# --------------------( WASTELANDS                         )--------------------
# Globs matching the 2-byte ANSI Control Sequence Introducer (CSI) and Select
# Graphic Rendition (SGR), respectively. Dismantled, this is:
#
# * $'\E\[', matching the 2-byte ANSI Control Sequence Introducer (CSI)
#   identical to "<Esc>[" signifying an ANSI escape code.
# * (...)m", matching zero or more Select Graphic Rendition (SGR)
#   parameters also referred to as color indices:
#   * "|", matching the empty string and hence the ANSI escape code
#     "CSI m" identical to "<Esc>[0m" resetting all SGR parameters.
#   * "[0-9](#c1,3)", matching an 8-bit integer expressed as one to three
#     digits as the first SGR parameter.
#   * "(;[0-9](#c1,3))##", matching zero or more sequences of a semicolon
#     followed by an 8-bit integer as all following SGR parameters.
#
# Unfortunately, Zsh fails with a "bad pattern" error when we aggregate the
# CSI and SGR into a single glob. Separate such globs until solving this.
    # Colorize "ls" by importing the ${LS_COLORS} global.
#   is_pathable dircolors and run_under_shell "$(dircolors --sh)" 'sh'
#       source_shell_script_command_output 'sh' 'dircolors --sh'
# void startup_terminal_color_globs()
#
# Define globs for matching color codes in various formats.
#function startup_terminal_color_globs() {
# ....................{ GETTERS ~ globs                    }....................
# string get_ansi_color_code_glob(void)
#
# Get an extended glob matching ANSI color codes.
#get_ansi_color_code_glob() {
#    die_if_args
#    print_string '\x1B\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#}

# string get_zsh_color_code_glob(void)
#
# Get an extended glob matching Zsh color codes. See "Prompt Expansion" under
# "info zsh" for further details.
#get_zsh_color_code_glob() {
#    die_if_args
#    print_string '%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'
#}

#   string ansi_color_code_glob
#   ansi_color_code_glob="$(get_ansi_color_code_glob)"
#   string test="$'\E\['(|[0-9](#c1,3)(;[0-9](#c1,3))##)m"
#   string test="$'\E\['"
#   print_string "glob: $test"
#   print_string "${*//${~ZESHY_ANSI_COLOR_CODE_GLOB}/}"
#   print_string "${*//$'\E\[((|[0-9](#c1,3)(;[0-9](#c1,3))##)m'/}"
#   print_string "${*//$'\E\['(|[0-9](#c1,3)(;[0-9](#c1,3))##)m/}"
#   print_string "${*//$'\E'/}"
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB_SGR='(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB='\x1B\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB='\033\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB="\$'\E'"'\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB=$'\E\['"(|[0-9](#c1,3)(;[0-9](#c1,3))##)m"
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB="\\033"
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB="\E"
    # Cache the ANSI color glob to a global variable, if not already cached.
#   set_string_if_unset_or_empty_to_evaluation\
#       ZESHY_ANSI_COLOR_CODE_GLOB '$(get_ansi_color_code_glob)'
    # Cache the ZSH color glob to a global variable, if not already cached.
#   set_string_if_unset_or_empty_to_evaluation\
#       ZESHY_ZSH_COLOR_CODE_GLOB '$(get_ansi_color_code_glob)'
#   noop "${ZESHY_ZSH_COLOR_CODE_GLOB=$(get_zsh_color_code_glob)}"
#   print_string "${1//${~ZESHY_ANSI_COLOR_CODE_GLOB}}"
#   print_string "${1//${~ZESHY_ZSH_COLOR_CODE_GLOB}}"

#FIXME: Such globs are unlikely to change during runtime. (What would that even
#mean?) They should be cached to global variables for efficiency.
#   string glob; glob="$(get_ansi_color_code_glob)"
#   print_string "${1//${~glob}}"
#   string glob; glob="$(get_zsh_color_code_glob)"
#   print_string "${1//${~glob}}"
# ....................{ GETTERS ~ lines                    }....................
#FIXME: Shift to Zeshy String.
#get_string_line_length_excluding_zsh_color_codes() {
    #FIXME: Raise exception if the passed string contains a newline. We should
    #probably extricate the core logic into a separate remove_zsh_color_codes().
#    die_unless_arg 'expected one string'
#    string glob; glob="$(get_zsh_color_code_glob)"
#    print_string ${#${(S%%)1//${~glob}}
#}

#   print_string "${1//\x1B\[([0-9](#c1,2)(;[0-9](#c1,2))(#c0,1))(#c0,1)m}"
#   print_string "${1//\x1B\[([0-9](#c1,2)(;[0-9](#c1,2))(#c0,1))(#c0,1)[m|K]}"
# least the eight customary shell colors: black, white, red, green, blue,
# yellow, magenta, and cyan.
    # Do not call die_unless_standard_output_terminal(), as subshells have no terminals.
    # Do not call die_unless_standard_output_terminal(), as subshells have no terminals.
# Avoid calling this function from a subshell (e.g.,
# "$(is_standard_output_terminal and print ok)"), as subshells cannot test the file descriptors
# of their parent shells.    #* startup_terminal_colors_to_monochrome(), if no color support.

    #* startup_terminal_colors_to_8_color_polychrome(), if typical color support.
    #* startup_terminal_colors_to_256_color_polychrome(), if 256 color support.
    # Exit status of this command.
#   string output; output="$(run "${(q)@}" 1>&1 1>&2)" or exit_status=${?}
#   integer exit_status="${?}"
#   string output="$(eval "${(q)@}" 1>&1 1>&2)"
#   string output="$((eval "${@}") 1>&1 1>&2)"
#   say "running: ${*}"
#   say "output: ${output}"
#   msay 'line_length: '; printeger $(get_string_line_length "${output}")
#   say "terminal_height: $(get_terminal_height)"

    # Return the exit status of this command.
#   false
#   say "running: ${*}"
#   return "${exit_status}"

#FIXME: We currently define the "LESS" global (probably in "zshrc"), defining
#global "less" options. Shift to Zeshy "config", renamed to
#"ZESHY_PAGER_OPTIONS", and explicitly apply such global below. (We don't need
#interactive and non-interactive forms, obviously -- it's always interactive!)

        #FIXME: Ugh. This should just go into "ZESHY_PAGER_OPTIONS", clearly.
        # If "less" is the current pager, pass the following options:
        #
        # * "--no-init", avoiding clearing the screen on initialization.
#       if is "${PAGER}" == less si
#       then pager+=( '--no-init' )
#       fi

#   string output="$(run_redirecting_to_standard_output "${@}")"
#   say "output: ${output}"
    # Otherwise, printeger as is.
#   else
#       printeger "${output}" 
#   fi

#   printeger "page command line: ${*}"
#   printeger "page second arg: ${2}"
#   run "${(q)@} 2>&1 | '${PAGER:-less}'"

# string is_input_character_y_or_Y_asked(string question, string choices = 'yn', string true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#is_input_character_y_or_Y_asked() {
#    die_unless_args 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    msay "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one 
#    read   answer
#    is "${answer}" == "${true_answer}" si
#} 

#emulate -R sh -c 'eval "$(dircolors --sh)"'
# Dismantled, this is:
        # * "(L}", lowercasing the current color name. The maps colors() defines
        #   have lowercase_string rather than uppercase_string keys.

    # Coerce the response to lowercase_string for comparability and compare.
#   is_sure="$(lowercase_string "${is_sure}")"
#   is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si
#
    # Define ANSI colors for the ANSI shell prompt, below.
    #export   PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
    #export    PROMPT_GREY="%{"$'\033[${FG_BLACK}m'"%}"
    #export     PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
    #export   PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
    #export  PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
    #export    PROMPT_BLUE="%{"$'\033[${FG_BLUE_HIGH}m'"%}"
    #export PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
    #export    PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
    #export   PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

    # Define ANSI colors for "print" and "echo" uses, below.
    #export   BLACK="\e[${FG_BLACK_HIGH}m"
    #export     RED="\e[${FG_RED_HIGH}m"
    #export   GREEN="\e[${FG_GREEN_HIGH}m"
    #export  YELLOW="\e[${FG_YELLOW_HIGH}m"
    #export    BLUE="\e[${FG_BLUE}m"
    #export MAGENTA="\e[${FG_MAGENTA_HIGH}m"
    #export    CYAN="\e[${FG_CYAN}m"
    #export   WHITE="\e[${FG_WHITE}m"
    #export    BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
    #export  NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
    #export   RESET="\e[${FG_RESET}m"
# ....................{ STREAMS                            }....................
# Load the "colors" module. This defines the function "colors" that, when
# called, itself defines in excess of six associative arrays: $fg, $fg_bold,
# $fg_no_bold, $bg, $bg_bold, and $bg_no_bold. Each array, when indexed by
# color name (e.g., $bg_bold{red}), further expands to the terminal-specific
# string activating that color combination under the current output.
#autoload -U colors

#FIXME: Causes the "su" command to fail to print_string its data. Hm; obviously, this
#is a flawed approach. Research alternatives.
# Color all debug, warning, and error print_string for all processes: in particular,
# color all print_string sent by each process to the process-specific stderr "file".
#exec 2>>(\
#    while read LINE; do \
#        printeger -P "${FG_RED_BOLD}${(q)LINE}${FG_RESET}" > '/dev/tty'; \
#        printeger -n $'\0'; \
#    done &)

# ....................{ COLORS                             }....................
# See "http://en.wikipedia.org/wiki/ANSI_escape_code", for further details.

# Color bases.
#  BASE_BLACK="0"
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    BASE_RED="1"
#  BASE_GREEN="2"
# BASE_YELLOW="3"
#   BASE_BLUE="4"
#BASE_MAGENTA="5"
#   BASE_CYAN="6"
#  BASE_WHITE="7"
#  BASE_RESET="9"

# Color foregrounds.
#  FG_BLACK="3${BASE_BLACK}"
#    FG_RED="3${BASE_RED}"
#  FG_GREEN="3${BASE_GREEN}"
# FG_YELLOW="3${BASE_YELLOW}"
#   FG_BLUE="3${BASE_BLUE}"
#FG_MAGENTA="3${BASE_MAGENTA}"
#   FG_CYAN="3${BASE_CYAN}"
#  FG_WHITE="3${BASE_WHITE}"
#  FG_RESET="3${BASE_RESET}"

# Color backgrounds.
#  BG_BLACK="4${BASE_BLACK}"
#    BG_RED="4${BASE_RED}"
#  BG_GREEN="4${BASE_GREEN}"
# BG_YELLOW="4${BASE_YELLOW}"
#   BG_BLUE="4${BASE_BLUE}"
#BG_MAGENTA="4${BASE_MAGENTA}"
#   BG_CYAN="4${BASE_CYAN}"
#  BG_WHITE="4${BASE_WHITE}"
#  BG_RESET="4${BASE_RESET}"

# Color foregrounds (high intensity).
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    FG_RED_HIGH="9${BASE_RED}"
#  FG_GREEN_HIGH="9${BASE_GREEN}"
# FG_YELLOW_HIGH="9${BASE_YELLOW}"
#   FG_BLUE_HIGH="9${BASE_BLUE}"
#FG_MAGENTA_HIGH="9${BASE_MAGENTA}"
#   FG_CYAN_HIGH="9${BASE_CYAN}"
#  FG_WHITE_HIGH="9${BASE_WHITE}"
#  FG_RESET_HIGH="9${BASE_RESET}"

# Color backgrounds (high intensity).
#  BG_BLACK_HIGH="10${BASE_BLACK}"
#    BG_RED_HIGH="10${BASE_RED}"
#  BG_GREEN_HIGH="10${BASE_GREEN}"
# BG_YELLOW_HIGH="10${BASE_YELLOW}"
#   BG_BLUE_HIGH="10${BASE_BLUE}"
#BG_MAGENTA_HIGH="10${BASE_MAGENTA}"
#   BG_CYAN_HIGH="10${BASE_CYAN}"
#  BG_WHITE_HIGH="10${BASE_WHITE}"
#  BG_RESET_HIGH="10${BASE_RESET}"

# Color attributes.
#           RESET="00"
#INTENSITY_NORMAL="22"
#  INTENSITY_BOLD="01"
# INTENSITY_FAINT="02"
#       ITALIC_ON="03"
#UNDERLINE_SINGLE="04"
#UNDERLINE_DOUBLE="21"
#   UNDERLINE_OFF="24"
#      BLINK_SLOW="05"
#      BLINK_FAST="06"
#       BLINK_OFF="25"
#  IMAGE_NEGATIVE="07"  # inverse (reverse), swapping foreground and background
#  IMAGE_POSITIVE="27"
#         CONCEAL="08"
#          REVEAL="28"

# Define (but do not export) ANSI colors for the ANSI shell prompt, below.
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
#  PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
# PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
#   PROMPT_BLUE="%{"$'\033[${FG_BLUE}m'"%}"
#PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
#   PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
#  PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

# Define (but do not export) ANSI colors for "print" and "echo" uses, below.
#  BLACK="\e[${FG_BLACK_HIGH}m"
#    RED="\e[${FG_RED_HIGH}m"
#  GREEN="\e[${FG_GREEN_HIGH}m"
# YELLOW="\e[${FG_YELLOW_HIGH}m"
#   BLUE="\e[${FG_BLUE}m"
#MAGENTA="\e[${FG_MAGENTA_HIGH}m"
#   CYAN="\e[${FG_CYAN_HIGH}m"
#  WHITE="\e[${FG_WHITE}m"
#   BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
# NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
#  RESET="\e[${FG_RESET}m"
