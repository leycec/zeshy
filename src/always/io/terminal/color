#!/usr/bin/env zsh
# ====================[ color                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define terminal colors (i.e., ANSI- and zsh prompt-specific escape codes).
#
# --------------------( SEE ALSO                           )--------------------
# https://en.wikipedia.org/wiki/ANSI_escape_code
#   Excrutiatingly helpful dissection of ANSI escape codes.
#
# http://ciembor.github.com/4bit
#   4bit, arguably the best and probably only terminal color scheme designer.
#
# --------------------( TODO                               )--------------------
# * Add support for fish-like syntax highlighting. Happily, someone's already
#   gone to the work of zshifying this; we'll just want to Zeshify it a bit:
#   https://github.com/zsh-users/zsh-syntax-highlighting
# * Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#   urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#   some zsh code the other day simplifying such support... Hmmmmmmmm.
# * It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#   https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors

# ....................{ GLOBALS                            }....................
# Defer initialization of color maps to make_zeshy_terminal_colors(), below.

# ....................{ GLOBALS ~ terminal                 }....................
#FIXME: Completely document *ALL* supported color names, after ensuring the
#implementation works as desired.
document_global '
map ZESHY_COLOR

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on the current terminal. Color names include:

/==================v==========================================================\
| color name       | description                                              |
>==================+==========================================================<
| reset            | reset foreground and background color to defaults        |
\==================^==========================================================/
'
document_global '
map ZESHY_COLOR_2

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on monochrome terminals (i.e., *NOT* supporting the
canonical eight colors). See ${ZESHY_COLOR} for further details.
'
document_global '
map ZESHY_COLOR_8

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on polychrome terminals (i.e., supporting at least the
canonical eight colors). See ${ZESHY_COLOR} for further details and
${ZESHY_COLOR_NAMES_8} for a list of such colors.
'

document_global '
list ZESHY_COLOR_NAMES_8

List of the canonical eight color names supported by most *nix terminals:
white, black, red, green, blue, yellow, magenta, and cyan.
'
# List of such names, excluding pseudo-color "grey".
ZESHY_COLOR_NAMES_8=( white black red green blue yellow magenta cyan )

# ....................{ GLOBALS ~ prompt                   }....................
document_global '
map ZESHY_PROMPT_COLOR

Map lowercase color name followed by optional attributes to the prompt-specific
ANSI escape code enabling such color at the shell prompt on the current
terminal. See ${ZESHY_COLOR} for further details.
'
document_global '
map ZESHY_PROMPT_COLOR_2

Map lowercase color name followed by optional attributes to the prompt-specific
ANSI escape code enabling such color at the shell prompt on monochrome terminals
(i.e., *NOT* supporting the canonical eight colors). See ${ZESHY_COLOR} for
further details.
'
document_global '
map ZESHY_PROMPT_COLOR_8

Map lowercase color name followed by optional attributes to the prompt-specific
ANSI escape code enabling such color at the shell prompt on polychrome terminals
(i.e., supporting the canonical eight colors). See ${ZESHY_COLOR} for further
details and ${ZESHY_COLOR_NAMES_8} for a list of such colors.
'

# ....................{ GLOBALS ~ ansi                     }....................
#FIXME: Shift to "io/encoding/ansi".

# Unfortunately, zsh fails with a "bad pattern" error when aggregating the
# following CSI and SGR globs into a single glob. Gotta keep them separated.

document_global '
map ZESHY_ANSI_SGR

Map from lowercase Select Graphics Rendition (SGR) ANSI name to value.
'
ZESHY_ANSI_SGR=(
    reset 0

    # Attribute enablers.
    bold       1
    weak       2
    italic     3
    underline  4
    blink      5
    reverse    7
    conceal    8
    normal    22

    # Attribute disablers.
    italic_off    23
    underline_off 24
    blink_off     25
    reverse_off   27
    conceal_off   28

    # Foreground colors.
    black   30
    red     31
    green   32
    yellow  33
    blue    34
    magenta 35
    cyan    36
    white   37
    default 39

    # Background colors.
    black_background   40
    red_background     41
    green_background   42
    yellow_background  43
    blue_background    44
    magenta_background 45
    cyan_background    46
    white_background   47
    default_background 49

    # Foreground high-intensity colors.
    black_intense   90
    red_intense     91
    green_intense   92
    yellow_intense  93
    blue_intense    94
    magenta_intense 95
    cyan_intense    96
    white_intense   97
    default_intense 99

    # Background high-intensity colors.
    black_intense_background   100
    red_intense_background     101
    green_intense_background   102
    yellow_intense_background  103
    blue_intense_background    104
    magenta_intense_background 105
    cyan_intense_background    106
    white_intense_background   107
    default_intense_background 109
)

document_global '
string ZESHY_ANSI_CSI

2-byte ANSI Control Sequence Introducer (CSI) prefixing all ANSI escape
sequences, equivalent to "<Esc>[".
'
ZESHY_ANSI_CSI=$'\E\['

document_global '
string ZESHY_ANSI_SGR_NEXT

1-byte ANSI Select Graphics Rendition (SGR) delimiter separating subsequences
in all graphics-specific ANSI escape codes.
'
ZESHY_ANSI_SGR_NEXT=';'

document_global '
string ZESHY_ANSI_SGR_SUFFIX

1-byte ANSI Select Graphics Rendition (SGR) suffix for all graphics-specific
ANSI escape codes.
'
ZESHY_ANSI_SGR_SUFFIX='m'

document_global '
string ZESHY_ANSI_SGR_GLOB

Glob matching Select Graphics Rendition (SGR)-suffixed ANSI escape codes.
'
# Dismantled, this is:
#
# * (...)m", matching zero or more Select Graphic Rendition (SGR)
#   parameters also referred to as color indices:
#   * "|", matching the empty string and hence the ANSI escape code
#     "CSI m" identical to "<Esc>[0m" resetting all SGR parameters.
#   * "[0-9](#c1,3)", matching an 8-bit integer expressed as one to three
#     digits as the first SGR parameter.
#   * "(;[0-9](#c1,3))##", matching zero or more sequences of a semicolon
#     followed by an 8-bit integer as all following SGR parameters.
ZESHY_ANSI_SGR_GLOB="(|[0-9](#c1,3)(${ZESHY_ANSI_SGR_NEXT}[0-9](#c1,3))##)${ZESHY_ANSI_SGR_SUFFIX}"

# ....................{ GLOBALS ~ glob                     }....................
document_global '
string ZESHY_ZSH_COLOR_GLOB

Glob matching color-specific zsh prompt escape codes.
'
# Dismantled, this is:
#
# * "%(...)", matching a "%"-prefixed prompt escape.
# * "[BbSsUu]", matching a bold, italic, or underline parameter.
# * "[0-9]##[FfKk]", matching a fore- or background parameter prefixed by
#   integer argument consisting of one or more digits.
# * "[FfKk]\{?*\}", matching a fore- or background parameter suffixed by:
#   * String argument consisting of a well-known color name (e.g., "red").
#   * Integer argument consisting of one or more digits.
ZESHY_ZSH_COLOR_GLOB='%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'

# ....................{ TESTERS                            }....................
document_function '
boolean is_terminal_color(void)

Return true if shell output is attached to a polychrome terminal device (i.e.,
a terminal device providing more than merely monochrome black and white).
'
function is_terminal_color() {
    die_if_args
    is_standard_output_terminal and (( $(get_terminal_color_count) > 2 ))
}

# ....................{ GETTERS                            }....................
document_function '
integer get_terminal_color_count(void)

Get the number of colors supported by the current terminal device.
'
function get_terminal_color_count() {
    # Validate sanity. Since this function is typically called from a subshell,
    # avoid calling die_unless_standard_output_terminal().
    die_if_args
    die_unless_shell_interactive

    # Get such colors. Note "echotc Co" also works, but is somewhat overkill.
    print_string "${terminfo[colors]}"
}

#FIXME: Shift to "io/encoding/ansi".
document_function '
integer get_string_length_printable_sans_ansi_color_codes(
  string text1, string text2, ...)

Get the total length of the passed strings in multibyte characters *AFTER*
removing ANSI color codes from such strings.
'
function get_string_length_printable_sans_ansi_color_codes() {
    die_unless_args 'expected at least one string'
    get_string_length_printable "$(remove_string_ansi_color_codes "${@}")"
}

# ....................{ REMOVERS                           }....................
#FIXME: Shift to "io/encoding/ansi".
document_function '
string remove_string_ansi_color_codes(string text1, string text2, ...)

Remove all ANSI color codes from the passed string. The resulting string will
retain non-color ANSI escapes (e.g., "\033[J", clearing from the current
cursor to the end of the screen).
'
function remove_string_ansi_color_codes() {
    # Avoid calling remove_string_matches(). zsh fails with "bad pattern" when
    # expanding ${ZESHY_ANSI_CSI} as a glob expression (e.g., as
    # "${~ZESHY_ANSI_CSI}").
    die_unless_args 'expected at least one string'
    print_string "${*//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}}"
}

document_function '
string remove_string_zsh_color_codes(string text1, string text2, ...)

Remove all zsh color codes from the passed string. The resulting string will
retain non-color prompt escapes (e.g., "%D", expanding to the current date).
'
function remove_string_zsh_color_codes() {
    die_unless_args 'expected at least one string'
    remove_string_matches "${*}" "${ZESHY_ZSH_COLOR_GLOB}"
}

# ....................{ MAKERS                             }....................
# Initialize all remaining color globals before compiling Zeshy's user digest
# file, ensuring such globals to be compiled into such file and hence *ALWAYS*
# accessible on Zeshy startup.
append_make_zeshy_command make_zeshy_terminal_color

document_function '
void make_zeshy_terminal_color(void)

Define terminal color globals to be compiled into Zeshy''s user digest file.
'
function make_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args

    # Normal and bold color attributes as ANSI escape codes.
    string\
        ansi_normal="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_weak="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[weak]}${ZESHY_ANSI_SGR_NEXT}"

    # Set the reset "color."
    ZESHY_COLOR_8[reset]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_SUFFIX}"

    # Set polychrome ANSI colors.
    for color_name ("${ZESHY_COLOR_NAMES_8[@]}") {
#       print "color (fg): ${color_name}\ncolor (bg): ${color_name}_background"
        ZESHY_COLOR_8[${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_italic]="${ansi_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_weak]="${ansi_weak}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_background]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}_background]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    }

    # Default foreground greyscale colors are notoriously "off," assigning
    # ${ZESHY_COLOR[white]} a grey rather than white color and defining no
    # corresponding suite of grey colors. To correct this:
    #
    # * Assign ${ZESHY_COLOR[white]} to new color ${ZESHY_COLOR[grey_bold]}.
    # * Assign bold black to all other foreground grey colors.
    # * Assign white and bold black to corresponding background grey colors.
    ZESHY_COLOR_8[white]="${ansi_normal}${ZESHY_ANSI_SGR[white_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey]="${ansi_bold}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold_italic]="${ansi_italic}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold]="${ansi_normal}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_weak]="${ansi_normal}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_background]="${ansi_normal}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"

    # Given the prior polychrome ANSI colors, set:
    #
    # * Monochrome ANSI colors, expanding to the empty string.
    # * Prompt-specific colors, delimited by "%{" and "%}" to prevent such
    #   colors from contributing to prompt string length.
    for color_name ( $(get_map_keys ZESHY_COLOR_8) ) {
        ZESHY_COLOR_2[${color_name}]=
        ZESHY_PROMPT_COLOR_2[${color_name}]="%{${ZESHY_COLOR_2[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
    }
}

# ....................{ STARTUP                            }....................
append_startup_zeshy_command_if_shell_interactive startup_zeshy_terminal_color

#FIXME: Complete documentation.
document_function '
void startup_zeshy_terminal_color(void)

Define color globals specific to the current terminal. If such terminal is:

* Monochrome (i.e., colorless), set all such colors to the empty string.
'
function startup_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Number of colors supported by the current terminal.
    integer terminal_color_count
    terminal_color_count="$(get_terminal_color_count)"

    #FIXME: Implement support for 256-color terminals.

    # If the current terminal supports less than the canonical eight colors,
    # set globals specific to monochrome (i.e., colorless) terminals.
    if (( terminal_color_count < 8 )); then
        set_map_to_map ZESHY_COLOR ZESHY_COLOR_2
        set_map_to_map ZESHY_PROMPT_COLOR ZESHY_PROMPT_COLOR_2
    # If the current terminal supports at least the canonical eight colors,
    # set globals specific to polychrome (i.e., colorful) terminals.
    else # elif (( terminal_color_count >= 8 )); then
        set_map_to_map ZESHY_COLOR ZESHY_COLOR_8
        set_map_to_map ZESHY_PROMPT_COLOR ZESHY_PROMPT_COLOR_8
    fi
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Reduce to either append_startup_zeshy_command_if_shell_interactive() or
#append_startup_zeshy_command_if_standard_output_terminal(). Probably the
#latter, I should think, which is more general; the former's too specific.
#   print "ZESHY_COLOR[red]: ${ZESHY_COLOR[red]}hmm"
    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_no_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #make_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
#   make_zeshy_terminal_color_8

#document_function '
#void make_zeshy_terminal_color_8(void)
#
#Define color globals for terminals supporting between 8 to 255 colors.
#'
#function make_zeshy_terminal_color_8() {

#       color_background_name="${color_name}_background"
#   for color_name (${color_names[@]} grey) {
#       ZESHY_PROMPT_COLOR[${color_name}]="%{${ZESHY_COLOR[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BACKGROUND[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_BOLD[${color_name}]="%{${ZESHY_COLOR_BOLD[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_BOLD_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]}%}"
#       ZESHY_PROMPT_COLOR_ITALIC[${color_name}]="%{${ZESHY_COLOR_ITALIC[${color_name}]}%}"
#   }

    # Define foreground greyscale colors. The default definitions assign
    # ${ZESHY_COLOR_BLACK} a somewhat unreadable quasi-black color value and
    # ${ZESHY_COLOR_WHITE} a somewhat grey rather than white color value.
#   ZESHY_COLOR[black]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[normal]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[black_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
#   ZESHY_COLOR[grey]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"

    #FUXME: Defer to global list ${ZESHY_COLOR_NAMES}, instead.
    # List of all such color names, excluding pseudo-color "grey".
#   list color_names
#   color_names=( white black red green blue yellow magenta cyan )

#FUXME: Hmmm; we appear to never set this. Do so here!
#document_global '
#string ZESHY_PROMPT_COLOR_RESET
#
#Prompt escape code resetting foreground and background colors to defaults.
#'

# Declare and document reset colors.
#document_global '
#string ZESHY_COLOR_RESET
#
#ANSI escape code resetting foreground and background colors to defaults.
#'

# Declare and document general purpose colors.
#document_global '
#map ZESHY_COLOR
#
#Map lowercase color name to ANSI escape code foregrounding such color.
#'
#document_global '
#map ZESHY_COLOR_WEAK
#
#Map lowercase color name to ANSI escape code foregrounding such color weakly.
#'
#document_global '
#map ZESHY_COLOR_BOLD
#
#Map lowercase color name to ANSI escape code foregrounding such color brightly.
#'
#document_global '
#map ZESHY_COLOR_ITALIC
#
#Map lowercase color name to ANSI escape code foregrounding such color italicized.
#'
#document_global '
#map ZESHY_COLOR_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color.
#'
#document_global '
#map ZESHY_COLOR_BOLD_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color brightly.
#'

# Declare and document prompt-specific colors.
#document_global '
#map ZESHY_PROMPT_COLOR
#
#Map lowercase color name to prompt escape foregrounding such color.
#'
#document_global '
#map ZESHY_PROMPT_COLOR_WEAK
#
#Map lowercase color name to prompt escape foregrounding such color weakly.
#'
#document_global '
#map ZESHY_PROMPT_COLOR_BOLD
#
#Map lowercase color name to prompt escape foregrounding such color brightly.
#'
#document_global '
#map ZESHY_PROMPT_COLOR_ITALIC
#
#Map lowercase color name to prompt escape foregrounding such color italicized.
#'
#document_global '
#map ZESHY_PROMPT_COLOR_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color.
#'
#document_global '
#map ZESHY_PROMPT_COLOR_BOLD_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color brightly.
#'

#FUXME: I've given a great deal of thought to this. Unfortunately, the current
#approach is demonstrably bad. For one, separating colors between maps precludes
#convenient dynamic usage resembling the following:
#
#   string ZESHY_COLOR_NAME_PUNCTUATION='grey_bold'
#   print "test${ZESHY_COLOR[${ZESHY_COLOR_NAME_PUNCTUATION}]}: yay!"
#
#I assume you see what we did there? We could have chosen
#ZESHY_COLOR_NAME_PUNCTUATION to be any composite of a color and color
#attributes, including: "grey", "grey_italic", "grey_bold_italic", "grey_weak",
#"grey_weak_background", and so on. As one can see, that's an enormous number of
#keys for each color... but not a single key more than we currently have,
#dispersed as they are across ten or so map globals. Centralize, my Self.
#
#That's great, but that's not the sole reason. By centralizing all colors into a
#single map, we *VASTLY* simplify startup logic for initializing ${ZESHY_COLOR}.
#On an 8-color terminal? No problem; just perform a *SINGLE MAP COPY*:
#
#   ZESHY_COLOR=( "${ZESHY_COLOR_8[@]}" )
#
#Done. Without such approach, we'd need a positively obscene number of maps --
#basically, ten or see for each number of terminal colors threshold. We're
#talking in upwards of fourty maps, which is simply obscenity. A different way
#is possible, friends.

    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_2_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #make_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
# Avoid confining such function to interactive shells and/or shells whose
# standard output is attached to a terminal device. Sufficiently many CLI
# applications are now color-aware (e.g., "less", "vim") that outputting color
# when running non-interactively is largely a non-issue.
#   die_unless_shell_interactive
# Moreover, I've always found such behavior
# exceedingly annoying in other applications (e.g., "ls"), and don't see.
#FUXME: Honestly, "_BOLD" makes little sense. It's not bold; it's *BRIGHTER*.
#Rename ZESHY_COLOR_BOLD to ZESHY_COLOR_BRIGHT and so forth. Likewise, rename
#"_WEAK" to "_FAINT" for orthogonality. (Don't forget "ansi_weak" to "ansi_faint",
#too.)

#FUXME: Map ${ZESHY_ANSI_SGR} suggests we could profitably implement _FAINT and
#_STANDOUT versions, as well. Test us up! *YES*. Great: the "italic" attribute
#is implemented as italics under many terminals. We absolutely want that. :)
#   remove_string_matches "${*}" "${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_GLOB}"
#   print_string "${*//${~ZESHY_ZSH_COLOR_GLOB}/}"
#FUXME: Rename to remove_string_ansi_color().
#FUXME: Rename to remove_string_zsh_color().
#   print_string "${*//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}/}"
#Glob matching the 2-byte ANSI Select Graphic Rendition (SGR) prefixing all
#color-specific ANSI escape codes. Dismantled, this is:
# Handle all terminal color functionality *OTHER* than defining such colors. See
# "00-setup/" for the latter.
