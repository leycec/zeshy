#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle terminal colors.

== See Also ==
* http://ciembor.github.com/4bit[4bit], arguably the best and (probably only)
  terminal color scheme designer.
/---

#FIXME: Add support for fish-like syntax highlighting. Happily, someone's
#already gone to the work of zshifying this; we'll just want to Zeshify it a
#bit: https://github.com/zsh-users/zsh-syntax-highlighting
#FIXME: Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#some zsh code the other day simplifying such support... Hmmmmmmmm.
#FIXME: It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors

# ....................{ GLOBALS                            }....................
# Defer initialization of most globals to precompile_zeshy_terminal_colors() and
# startup_zeshy_terminal_colors(), below.

declare_global_with_stdin <<'/---'
map ZESHY_COLOR

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on the current terminal. Colors include the canonical eight
colors supported by most terminal emulators as well as "grey", a Zeshy-specific
color leveraging "intense" ANSI attributes supported by most modern terminal
emulators (e.g., rxvt-unicode). Color names include:

.Canonical Color Names
[cols=">strong,^,^,<emphasis",options="header"]
|===============================================================================
| color name              | foreground color | background color | typeface
| reset                   | white | black | plain
|
| white                   | white || plain
| grey                    | grey || plain
| black                   | black || plain
| red                     | red || plain
| green                   | green || plain
| blue                    | blue || plain
| yellow                  | yellow || plain
| magenta                 | magenta || plain
| cyan                    | cyan || plain
|
| white_bold              | white || bold
| grey_bold               | grey || bold
| black_bold              | black || bold
| red_bold                | red || bold
| green_bold              | green || bold
| blue_bold               | blue || bold
| yellow_bold             | yellow || bold
| magenta_bold            | magenta || bold
| cyan_bold               | cyan || bold
|
| white_italic            | white || italic
| grey_italic             | grey || italic
| black_italic            | black || italic
| red_italic              | red || italic
| green_italic            | green || italic
| blue_italic             | blue || italic
| yellow_italic           | yellow || italic
| magenta_italic          | magenta || italic
| cyan_italic             | cyan || italic
|
| white_bold_italic       | white || bold italic
| grey_bold_italic        | grey || bold italic
| black_bold_italic       | black || bold italic
| red_bold_italic         | red || bold italic
| green_bold_italic       | green || bold italic
| blue_bold_italic        | blue || bold italic
| yellow_bold_italic      | yellow || bold italic
| magenta_bold_italic     | magenta || bold italic
| cyan_bold_italic        | cyan || bold italic
|
| white_background        || white | plain
| grey_background         || grey | plain
| black_background        || black | plain
| red_background          || red | plain
| green_background        || green | plain
| blue_background         || blue | plain
| yellow_background       || yellow | plain
| magenta_background      || magenta | plain
| cyan_background         || cyan | plain
|
| white_bold_background   || white | bold
| grey_bold_background    || grey | bold
| black_bold_background   || black | bold
| red_bold_background     || red | bold
| green_bold_background   || green | bold
| blue_bold_background    || blue | bold
| yellow_bold_background  || yellow | bold
| magenta_bold_background || magenta | bold
| cyan_bold_background    || cyan | bold
|===============================================================================
/---

declare_global_with_stdin <<'/---'
map ZESHY_COLOR_2

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on monochrome terminals (i.e., _not_ supporting the
canonical eight colors). See ${ZESHY_COLOR} for further details.
/---

declare_global_with_stdin <<'/---'
map ZESHY_COLOR_8

Map lowercase color name followed by optional attributes to the ANSI escape code
enabling such color on polychrome terminals (i.e., supporting at least the
canonical eight colors). See ${ZESHY_COLOR} for further details and
${ZESHY_COLOR_NAMES_8} for a list of such colors.
/---

declare_global_with_stdin <<'/---'
list ZESHY_COLOR_NAMES_8

List of the canonical eight color names supported by most *nix terminals:
white, black, red, green, blue, yellow, magenta, and cyan.
/---
# List of such names, excluding pseudo-color "grey".
ZESHY_COLOR_NAMES_8=( white black red green blue yellow magenta cyan )

# ....................{ GLOBALS ~ style                    }....................
declare_global_with_stdin <<'/---'
map ZESHY_STYLE_TO_COLOR

Map style to the ANSI escape code coloring such style on the current terminal.
Color styles improve readability, genericity, and configurability by
substituting hard-coded color names with user-configurable style names (e.g.,
substituting `${ZESHY_COLOR[grey]}` with
`${ZESHY_STYLE_TO_COLOR[print_usage.punctuation]}`). See
${ZESHY_STYLE_TO_COLOR_NAME} for the map from which this map is initialized.
/---

declare_global_with_stdin <<'/---'
map ZESHY_STYLE_TO_COLOR_2

Map style to the ANSI escape code coloring such style on monochrome terminals.
See ${ZESHY_STYLE_TO_COLOR} and ${ZESHY_COLOR_2} for further details on the
former and latter, respectively.
/---

declare_global_with_stdin <<'/---'
map ZESHY_STYLE_TO_COLOR_8

Map style to the ANSI escape code coloring such style on polychrome terminals.
See ${ZESHY_STYLE_TO_COLOR} and ${ZESHY_COLOR_2} for further details on the
former and latter, respectively.
/---

# ....................{ GLOBALS ~ count                    }....................
declare_global_with_stdin <<'/---'
integer ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED

Number of colors supported by the current terminal, quantized to common color
thresholds. See get_terminal_color_count_quantized() for further details.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_terminal_color(void)

Return success if shell output is attached to a *polychrome terminal device*
(i.e., _not_ monochrome and hence supporting at least three colors).
/---
function is_terminal_color() {
    die_if_args
    (( $(get_terminal_color_count) > 2 ))
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_terminal_color_count(void)

Get the number of colors supported by the current terminal.
/---
function get_terminal_color_count() {
    # Get such colors. Note that "echotc Co" also suffices, if less efficiently.
    die_if_args
    return_string "${terminfo[colors]}"
}

#FIXME: Add 256-color support.
declare_function_with_stdin <<'/---'
integer get_terminal_color_count_quantized(void)

Get the number of colors supported by the current terminal, quantized to the
following typical color thresholds:

* 2, if such number is less than 8. Since color terminals support at least the
  8 canonical colors listed by ${ZESHY_COLOR_NAMES_8}, this often implies such
  terminal to be monochrome.
* 8, if such number is less than 255.
* 255, otherwise.
/---
function get_terminal_color_count_quantized() {
    # Validate sanity.
    die_if_args

    # Get such colors. For efficiency, inline such expansion. See
    # get_terminal_color_count() for further details.
    integer terminal_color_count="${terminfo[colors]}"

    # Quantize such count. See prior documentation.
    if (( terminal_color_count < 8 )) {
        return_string 2
    } else {
        return_string 8
    }
}

# ....................{ RESETTERS                          }....................
declare_function_with_stdin <<'/---'
void reset_terminal_color(void)

Reset color attributes for the current terminal to such terminal's defaults
(e.g., regular typeface on white foreground and black background).
/---
function reset_terminal_color() {
    die_if_args
    output_string_sans_newline "${ZESHY_COLOR[reset]-}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_terminal_color_globals(void)

Set all globals whose values depend on the number of colors supported by the
current terminal, including:

* ${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED}.
* ${ZESHY_COLOR}.
* ${ZESHY_COLOR_PROMPT}.
* ${ZESHY_STYLE_TO_COLOR}.
* ${ZESHY_STYLE_TO_COLOR_PROMPT}.
/---
function set_terminal_color_globals() {
    # Validate sanity.
    die_if_args

    # Set the quantized number of colors supported by the current terminal.
    ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED="$(get_terminal_color_count_quantized)"

    # Set map globals dependent on such number. For startup efficiency, avoid
    # calling set_map_to_map().
    string map_name_target map_name_source
    for    map_name_target (
        ZESHY_COLOR        ZESHY_STYLE_TO_COLOR
        ZESHY_COLOR_PROMPT ZESHY_STYLE_TO_COLOR_PROMPT) {
        map_name_source="${map_name_target}_${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED}"
        die_unless_map "${map_name_source}"
        eval "${map_name_target}=( \${(kv@)${map_name_source}} )"
    }
}

# ....................{ HOOKS                              }....................
# Initialize all remaining color globals before compiling zeshy's user digest
# file, ensuring such globals to be compiled into such file and hence *ALWAYS*
# accessible on zeshy startup. Such hook function expands configuration-specific
# globals inaccessible until precompilation (e.g., ${ZESHY_STYLE_TO_COLOR_NAME})
# and hence cannot be reduced to an anonymous function run immediately here.
run_hook_on_zeshy_precompile precompile_zeshy_terminal_color
run_hook_on_zeshy_startup       startup_zeshy_terminal_color

declare_function_with_stdin <<'/---'
void precompile_zeshy_terminal_color(void)

Initialize color-specific globals to be compiled into `zeshy`\'s user digest
file. If the number of colors supported by the current terminal differs from
such number on subsequent `zeshy` startup, startup_zeshy_terminal_color() will
necessarily reinitialize globals whose values depend on such colors.
/---
function precompile_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args

    # Normal and bold color attributes as ANSI escape codes.
    string\
        ansi_normal="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_weak="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[weak]}${ZESHY_ANSI_SGR_NEXT}"

    # Set the reset "color."
    ZESHY_COLOR_8[reset]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_SUFFIX}"

    # Set polychrome ANSI colors.
    string color_name
    for    color_name ("${ZESHY_COLOR_NAMES_8[@]}") {
#       print "color (fg): ${color_name}\ncolor (bg): ${color_name}_background"
        ZESHY_COLOR_8[${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_italic]="${ansi_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_weak]="${ansi_weak}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_background]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}_background]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_8[${color_name}_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    }

    # Default foreground greyscale colors are notoriously "off," assigning
    # ${ZESHY_COLOR[white]} a grey rather than white color and defining no
    # corresponding suite of grey colors. To correct this:
    #
    # * Assign ${ZESHY_COLOR[white]} to new color ${ZESHY_COLOR[grey_bold]}.
    # * Assign bold black to all other foreground grey colors.
    # * Assign white and bold black to corresponding background grey colors.
    ZESHY_COLOR_8[white]="${ansi_normal}${ZESHY_ANSI_SGR[white_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey]="${ansi_bold}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold_italic]="${ansi_italic}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold]="${ansi_normal}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_weak]="${ansi_normal}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_background]="${ansi_normal}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_8[grey_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"

    # Given the prior polychrome ANSI colors, set:
    #
    # * Style-specific colors, expanding to the corresponding ANSI color.
    # * Monochrome ANSI colors, expanding to the empty string.
    # * Prompt-specific colors, delimited by "%{" and "%}" to prevent such
    #   colors from contributing to prompt string length.
    for_map_keys ZESHY_COLOR_8 color_name '
        ZESHY_COLOR_2[${color_name}]=
        ZESHY_COLOR_PROMPT_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
        ZESHY_COLOR_PROMPT_2[${color_name}]="%{${ZESHY_COLOR_2[${color_name}]}%}"
    '

    # Assign each color style its corresponding ANSI color.
    for_map_key_value_pairs ZESHY_STYLE_TO_COLOR_NAME\
        color_style_name color_name '
        ZESHY_STYLE_TO_COLOR_2[${color_style_name}]="${ZESHY_COLOR_2[${color_name}]}"
        ZESHY_STYLE_TO_COLOR_8[${color_style_name}]="${ZESHY_COLOR_8[${color_name}]}"
    '

    # Assign each prompt-specific color style its corresponding ANSI color.
    for_map_key_value_pairs ZESHY_PROMPT_STYLE_TO_COLOR_NAME\
        color_style_name color_name '
        ZESHY_COLOR_PROMPT_STYLE_2[${color_style_name}]="${ZESHY_COLOR_PROMPT_2[${color_name}]}"
        ZESHY_COLOR_PROMPT_STYLE_8[${color_style_name}]="${ZESHY_COLOR_PROMPT_8[${color_name}]}"
    '

    # Initialize color globals.
    set_terminal_color_globals
}

declare_function_with_stdin <<'/---'
void startup_zeshy_terminal_color(void)

If the number of colors supported by the current terminal differs from such
number at the time of the most recent compilation of `zeshy`\'s user digest
file, reininitialize globals whose values depend on such number. See
set_terminal_color_globals() for further details.
/---
function startup_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args

    # Reinitialize color globals, if necessary. Note that
    # ${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED} is set by
    # set_terminal_color_global() itself called by
    # precompile_zeshy_terminal_color() during the most recent compilation of
    # zeshy's user digest file.
    if (( $(get_terminal_color_count_quantized) !=\
          ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED )) {
        set_terminal_color_globals
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: No; no; no. This is all *HORRIBLE*. There's a fundamental reason we
#refrain from performing arbitrarily complex logic at the top-level, and this is
#it: it simply doesn't work, and no degree of obscure handwaving will make it
#work.
#FUXME: I'm mildly concerned of how the "zsh/terminfo" module behaves when the
#current shell is *NOT* attached to a terminal device (e.g., when executing
#headless under a cronjob). Check documentation and probably just try it. I
#expect a fatal error, but... who knows? In such case, we'll need to only load
#such module if attached to a terminal device, which is rather easy to test. In
#such case, we should probably just default ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED
#to 2 (i.e., monochrome), ensuring plaintext output under cronjobs, which is
#almost always what you want. (Color is not particularly helpful in logfiles,
#after all. In fact, it's pretty much always a hindrance!)
#
#Of course, the exact same issue applies to the current implementation -- but
#it's worth noting, all the same.
#FUXME: O.K.; so, there's a subtlety here. It's not sufficient simply to write
#the contents of such variables into a script; we also need to serialize
#*ANOTHER* script containing logic sufficient to initialize such globals on-
#the-fly, so that a comparison between the prior and current values of such
#globals can be made. In this case, the latter script would contain the
#following logic:
#
#* Load the "zsh/terminfo" module (if attached to a terminal device, of course).
#* Perform the equivalent of get_terminal_color_count_quantized(), capturing the
#  result into ${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED}, which happily already
#  exists below.
#* To implement the prior steps, simply call something resembling:
#
#    string gtccq
#    gtccq="$(get_function_binding get_terminal_color_count_quantized)"
#    append_file_with_string "${ZESHY_USER_TEMPORARY_CACHE_FILE}" "
#       zmodload zsh/terminfo
#       ${gtccq}
#       string_global ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED
#       ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED=\"$(get_terminal_color_count_quantized)\""
#
#Now, we know what you're thinking: but isn't the above *LESS* efficient than
#the current approach? It requires a script to be executed, after all. But aside
#from the additional serialization of such script -- no. Why? Because we
#*ALWAYS* load such module and *ALWAYS* initialize such global anyway. It has to
#be done, so it had might as well be done early. The significant upside is that
#it eliminates all of the complexity with multiple maps below. That will become
#increasingly important, as the number of color thresholds (e.g., 256) and hence
#number of such maps increases.
#
#Oh! Jeez. I forgot about the corresponding prompt maps. Well, that makes this
#all the more dire then! Make this happen, man. This is beyond overkill,
#currently.
#FUXME: This is overly complex. Eliminate both ${ZESHY_STYLE_TO_COLOR_2} and
#${ZESHY_STYLE_TO_COLOR_8} by simply making digest compilation dependent on
#terminal colors. To do so properly, however, we'll need to add a new function
#add_zeshy_digest_dependency_global() to "src/digest"; as with other such
#dependencies, these dependencies must be cached to a temporary script under
#"~/.zeshy/cache" -- ideally, the same script as current dependencies are cached
#to. Actually, no! Separate scripts. Why? Because this allows efficient *AND*
#very simple comparison, below. It's worth it for the simplicity alone.
#
#Happily, there's a fairly efficient way to compare the contents of a list of
#globals:
#
#* Pass the names of such globals to get_variable_binding(), capturing the
#  output to a string local.
#* Compare such string local to the contents of the cached script containing
#  the prior output of get_variable_binding() (via write_file_with_variable(),
#  of course).
#* If the two strings differ, one or more such globals have changed, suggesting
#  zeshy's digest file to be outdated.
#
#Since path dependencies change *MUCH* more frequently than global dependencies
#under typical circumstances, only perform the above comparison if no path
#dependencies have changed.
#
#So, which globals should.

# Ideally, maps ${ZESHY_STYLE_TO_COLOR_2} and ${ZESHY_STYLE_TO_COLOR_8} could be
# eliminated in favor of an add_zeshy_digest_dependency_global()-based approach
# testing the number of terminal colors (as stored in a global) within
# is_zeshy_digest_outdated(). Unfortunately, assembling such global is
# sufficiently non-trivial to complicate such an approach. Since the current
# approach below is both efficient and reasonably simple, we prefer it instead.


# otherwise be preferable, since
# such function .
# (e.g., to colorify exception handling output)
#   die_unless_shell_interactive

#FUXME: Ugh. Actually, the suggestions below clearly demonstrate that this
#parcel is not a good fit for 
#FUXME: This is overly complex. Eliminate both ${ZESHY_STYLE_TO_COLOR_2} and
#${ZESHY_STYLE_TO_COLOR_8} by simply making digest compilation dependent on
#terminal colors. To do so properly, however, we'll need to add a new function

#, maps relating to colors must.
#
#Map color style names to prompt color names. `zeshy` uses this map to set the
#convenience map ${ZESHY_STYLE_TO_COLOR_PROMPT}, which other `zeshy` functions
#access to colorize shell prompt output. Color names are any valid keys of map
#${ZESHY_COLOR_PROMPT}, whose corresponding values expand to the prompt-specific
#ANSI escape code enabling such color at the shell prompt on the current terminal
#(e.g., `grey_bold_italic`, the color grey in bold-italic typeface). See
#${ZESHY_STYLE_TO_COLOR_NAME} for further details.
#
#== Prompt Colors ==
#
#${ZESHY_PROMPT_STYLE_TO_COLOR_NAME} maps prompt colors are mapped separately by .
#Since prompt and non-prompt color values differ, . While prompt colors must be delimited
#by `%{` and `%}` to prevent such colors from erroneously contributing to the
#prompt length, non-prompt colors require no such delimitation. Hence, `zeshy`
#maps the two separately. the former are mapped by
#${ZESHY_PROMPT_STYLE_TO_COLOR_NAME}.

#and hence _not_ intended to be
#expanded by `zeshy` runnables, which should instead expand
#${ZESHY_STYLE_TO_COLOR} -- a general-purpose map from non-prompt style to color
#value initialized using this map during digest recompilation.
#
#During digest recompilation, `zeshy` converts this
#configuration-only map into ${ZESHY_STYLE_TO_COLOR}, a general-purpose map
#`zeshy` runnables access to
#colorize output. Specifically, for each key-value pair of this map, `zeshy`
#defines the same key of map ${ZESHY_STYLE_TO_COLOR} to expand to the corresponding
#ANSI escape code. For example, if this map contains key
#`print_call_stack.colon` with value `grey`, `zeshy` adds a corresponding key
#`print_call_stack.colon` with value `\E\[0;30m` (i.e., the ANSI escape code
#resetting the current foreground color to grey).

    # If the current terminal supports less than the canonical eight colors,
    # assume such terminal to be monochrome (i.e., colorless).
#   if (( terminal_color_count < 8 )) {
#       terminal_color_count=2
    # Else, assume such terminal to support exactly such colors.
#   } else {
#       terminal_color_count=8
#   }

    # Validate sanity. Since this function is typically called from a subshell,
    # avoid calling die_unless_stdout_terminal().
#FUXME: While the current implementation certainly works, it's overkill. Almost
#*ALL* modern-day terminals, even tunnelled over SSH, support the 8 canonical
#colors. Consequently, ZESHY_COLOR and similar globals should be *BAKED* into
#the digest file with default values supporting such colors. *IF*, on Zeshy
#startup, we find the current terminal to not in fact support such colors,
#manually iterate through each such map, setting each key value to the empty
#string. (A bit slower, but... hey, if your terminal doesn't even support
#colors, you probably have greater issues than marginal Zeshy slowdown on
#startup.)
#FUXME: That said, 256-color supporting terminals might actually be the most
#common. Contemplate. Consider. Revise.

#FUXME: Rename to ${ZESHY_COLOR_FOR_TERMINAL_COLOR_COUNT_2}.
#FUXME: Rename to ${ZESHY_COLOR_FOR_TERMINAL_COLOR_COUNT_8}.
#FUXME: Rename to ${ZESHY_COLOR_NAMES_FOR_TERMINAL_COLOR_COUNT_8}.
#FUXME: Rename to ${ZESHY_STYLE_TO_COLOR_FOR_TERMINAL_COLOR_COUNT_2}.
#FUXME: Rename to ${ZESHY_STYLE_TO_COLOR_FOR_TERMINAL_COLOR_COUNT_8}.
#   for color_name ( $(get_map_keys ZESHY_COLOR_8) ) {
#       ZESHY_COLOR_2[${color_name}]=
#       ZESHY_COLOR_PROMPT_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_2[${color_name}]="%{${ZESHY_COLOR_2[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
#   }

    # Assign each color style its corresponding ANSI color.
#   for color_style_name color_name (
#       $(get_map_key_values ZESHY_STYLE_TO_COLOR_NAME) ) {
#       ZESHY_STYLE_TO_COLOR_2[${color_style_name}]="${ZESHY_COLOR_2[${color_name}]}"
#       ZESHY_STYLE_TO_COLOR_8[${color_style_name}]="${ZESHY_COLOR_8[${color_name}]}"
#   }

    # Assign each prompt-specific color style its corresponding ANSI color.
#   for color_style_name color_name (
#       $(get_map_key_values ZESHY_PROMPT_STYLE_TO_COLOR_NAME) ) {
#       ZESHY_COLOR_PROMPT_STYLE_2[${color_style_name}]="${ZESHY_COLOR_PROMPT_2[${color_name}]}"
#       ZESHY_COLOR_PROMPT_STYLE_8[${color_style_name}]="${ZESHY_COLOR_PROMPT_8[${color_name}]}"
#   }

## ....................{ SETTERS                            }....................
#declare_function_with_stdin <<'/---'
#void reset_terminal_color(void)
#
#Reset foreground and background terminal colors to their defaults: under most
#terminals, white foreground on black background with regular typeface.
#/---
#function reset_terminal_color() {
#    output_string_sans_newline "${ZESHY_COLOR[reset]-}"
#}

#| color name              | description
#| reset                   | default foreground and background color
#|
#| white                   | white foreground color in regular typeface
#| grey                    | grey foreground color in regular typeface
#| black                   | black foreground color in regular typeface
#| red                     | red foreground color in regular typeface
#| green                   | green foreground color in regular typeface
#| blue                    | blue foreground color in regular typeface
#| yellow                  | yellow foreground color in regular typeface
#| magenta                 | magenta foreground color in regular typeface
#| cyan                    | cyan foreground color in regular typeface
#|
#| white_bold              | white foreground color in bold typeface
#| grey_bold               | grey foreground color in bold typeface
#| black_bold              | black foreground color in bold typeface
#| red_bold                | red foreground color in bold typeface
#| green_bold              | green foreground color in bold typeface
#| blue_bold               | blue foreground color in bold typeface
#| yellow_bold             | yellow foreground color in bold typeface
#| magenta_bold            | magenta foreground color in bold typeface
#| cyan_bold               | cyan foreground color in bold typeface
#|
#| white_italic            | white foreground color in italic typeface
#| grey_italic             | grey foreground color in italic typeface
#| black_italic            | black foreground color in italic typeface
#| red_italic              | red foreground color in italic typeface
#| green_italic            | green foreground color in italic typeface
#| blue_italic             | blue foreground color in italic typeface
#| yellow_italic           | yellow foreground color in italic typeface
#| magenta_italic          | magenta foreground color in italic typeface
#| cyan_italic             | cyan foreground color in italic typeface
#|
#| white_bold_italic       | white foreground color in bold italic typeface
#| grey_bold_italic        | grey foreground color in bold italic typeface
#| black_bold_italic       | black foreground color in bold italic typeface
#| red_bold_italic         | red foreground color in bold italic typeface
#| green_bold_italic       | green foreground color in bold italic typeface
#| blue_bold_italic        | blue foreground color in bold italic typeface
#| yellow_bold_italic      | yellow foreground color in bold italic typeface
#| magenta_bold_italic     | magenta foreground color in bold italic typeface
#| cyan_bold_italic        | cyan foreground color in bold italic typeface
#|
#| white_background        | white background color in regular typeface
#| grey_background         | grey background color in regular typeface
#| black_background        | black background color in regular typeface
#| red_background          | red background color in regular typeface
#| green_background        | green background color in regular typeface
#| blue_background         | blue background color in regular typeface
#| yellow_background       | yellow background color in regular typeface
#| magenta_background      | magenta background color in regular typeface
#| cyan_background         | cyan background color in regular typeface
#|
#| white_bold_background   | white background color in bold typeface
#| grey_bold_background    | grey background color in bold typeface
#| black_bold_background   | black background color in bold typeface
#| red_bold_background     | red background color in bold typeface
#| green_bold_background   | green background color in bold typeface
#| blue_bold_background    | blue background color in bold typeface
#| yellow_bold_background  | yellow background color in bold typeface
#| magenta_bold_background | magenta background color in bold typeface
#| cyan_bold_background    | cyan background color in bold typeface
#|===============================================================================
#declare_global '
#map ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_SUPERUSER
#
#Map color style names to prompt color names if the current user is the superuser
#(i.e., root) or ignore such names otherwise. See
#${ZESHY_PROMPT_STYLE_TO_COLOR_NAME} for further details.
#'
#ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_SUPERUSER=(
#    # startup_zeshy_terminal_prompt().
#    startup_zeshy_terminal_prompt.brace                   grey_bold
#    startup_zeshy_terminal_prompt.host                    red
#    startup_zeshy_terminal_prompt.user                    red_bold
#    startup_zeshy_terminal_prompt.path                    yellow
#    startup_zeshy_terminal_prompt.prior_command_succeeded yellow_bold
#    startup_zeshy_terminal_prompt.prior_command_failed    magenta_bold
#    startup_zeshy_terminal_prompt.input                   white_bold
#)
#
#declare_global '
#map ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_NONSUPERUSER
#
#Map color style names to prompt color names if the current user is the superuser
#(i.e., root) or ignore such names otherwise. See
#${ZESHY_PROMPT_STYLE_TO_COLOR_NAME} for further details.
#'
#ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_NONSUPERUSER=(
#    # startup_zeshy_terminal_prompt().
#    startup_zeshy_terminal_prompt.brace                   grey_bold
#    startup_zeshy_terminal_prompt.host                    cyan
#    startup_zeshy_terminal_prompt.user                    cyan_bold
#    startup_zeshy_terminal_prompt.path                    blue
#    startup_zeshy_terminal_prompt.prior_command_succeeded blue_bold
#    startup_zeshy_terminal_prompt.prior_command_failed    red_bold
#    startup_zeshy_terminal_prompt.input                   white_bold
#)

    #FUXME: Add a new function append_map_to_map() implementing such
    #functionality.

    # If the current user is the superuser, add superuser-specific prompt color
    # styles to such global; otherwise, add non-superuser-specific prompt color
    # styles to such global.
#   if is_superuser; then
#       ZESHY_PROMPT_STYLE_TO_COLOR_NAME+=(
#           ${(kv@)ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_SUPERUSER} )
#   else
#   fi

#       set_map_to_map ZESHY_COLOR        ZESHY_COLOR_2
#       set_map_to_map ZESHY_COLOR_PROMPT ZESHY_COLOR_PROMPT_2
#       set_map_to_map ZESHY_STYLE_TO_COLOR  ZESHY_STYLE_TO_COLOR_2
#   # If the current terminal supports at least the canonical eight colors,
#   # assume such terminal to be monochrome (i.e., colorless).
#   else # elif (( terminal_color_count >= 8 )); then
#       set_map_to_map ZESHY_COLOR        ZESHY_COLOR_8
#       set_map_to_map ZESHY_COLOR_PROMPT ZESHY_COLOR_PROMPT_8
#       set_map_to_map ZESHY_STYLE_TO_COLOR  ZESHY_STYLE_TO_COLOR_8

#/==============================v===============================================\
#| color style name             | application                                   |
#>==============================+===============================================<
#| punctuation                  | punctuation with no semantic meaning          |
#| punctuation_semantic         | punctuation with semantic meaning             |
#>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<
#| say_caller                   | caller name printed by say(), cry(), etc.     |
#\==============================^===============================================/

#abstracting all colors prefixing common substrings of output
#(e.g., punctuation) to . 
#FUXME: Interesting. We have no incentive to use underscore rather than space
#here, do we? The latter remains both easier to type and read. Woops! False. zsh
#handles spaces in keys... poorly. Pass.
#FUXME: Completely document *ALL* supported color names, after ensuring the
#implementation works as desired.
#FUXME: Reduce to either run_hook_on_zeshy_startup_if_interactive() or
#run_hook_on_zeshy_startup_if_stdout_terminal(). Probably the
#latter, I should think, which is more general; the former's too specific.
#   print "ZESHY_COLOR[red]: ${ZESHY_COLOR[red]}hmm"
    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_no_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #precompile_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
#   precompile_zeshy_terminal_color_8

#declare_function '
#void precompile_zeshy_terminal_color_8(void)
#
#Define color globals for terminals supporting between 8 to 255 colors.
#'
#function precompile_zeshy_terminal_color_8() {

#       color_background_name="${color_name}_background"
#   for color_name (${color_names[@]} grey) {
#       ZESHY_COLOR_PROMPT[${color_name}]="%{${ZESHY_COLOR[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BACKGROUND[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_BOLD[${color_name}]="%{${ZESHY_COLOR_BOLD[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_BOLD_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_ITALIC[${color_name}]="%{${ZESHY_COLOR_ITALIC[${color_name}]}%}"
#   }

    # Define foreground greyscale colors. The default definitions assign
    # ${ZESHY_COLOR_BLACK} a somewhat unreadable quasi-black color value and
    # ${ZESHY_COLOR_WHITE} a somewhat grey rather than white color value.
#   ZESHY_COLOR[black]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[normal]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[black_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
#   ZESHY_COLOR[grey]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"

    #FUXME: Defer to global list ${ZESHY_COLOR_NAMES}, instead.
    # List of all such color names, excluding pseudo-color "grey".
#   list color_names
#   color_names=( white black red green blue yellow magenta cyan )

#FUXME: Hmmm; we appear to never set this. Do so here!
#declare_global '
#string ZESHY_COLOR_PROMPT_RESET
#
#Prompt escape code resetting foreground and background colors to defaults.
#'

# Declare and document reset colors.
#declare_global '
#string ZESHY_COLOR_RESET
#
#ANSI escape code resetting foreground and background colors to defaults.
#'

# Declare and document general purpose colors.
#declare_global '
#map ZESHY_COLOR
#
#Map lowercase color name to ANSI escape code foregrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_WEAK
#
#Map lowercase color name to ANSI escape code foregrounding such color weakly.
#'
#declare_global '
#map ZESHY_COLOR_BOLD
#
#Map lowercase color name to ANSI escape code foregrounding such color brightly.
#'
#declare_global '
#map ZESHY_COLOR_ITALIC
#
#Map lowercase color name to ANSI escape code foregrounding such color italicized.
#'
#declare_global '
#map ZESHY_COLOR_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_BOLD_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color brightly.
#'

# Declare and document prompt-specific colors.
#declare_global '
#map ZESHY_COLOR_PROMPT
#
#Map lowercase color name to prompt escape foregrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_WEAK
#
#Map lowercase color name to prompt escape foregrounding such color weakly.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_BOLD
#
#Map lowercase color name to prompt escape foregrounding such color brightly.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_ITALIC
#
#Map lowercase color name to prompt escape foregrounding such color italicized.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_BOLD_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color brightly.
#'

#FUXME: I've given a great deal of thought to this. Unfortunately, the current
#approach is demonstrably bad. For one, separating colors between maps precludes
#convenient dynamic usage resembling the following:
#
#   string ZESHY_COLOR_NAME_PUNCTUATION='grey_bold'
#   print "test${ZESHY_COLOR[${ZESHY_COLOR_NAME_PUNCTUATION}]}: yay!"
#
#I assume you see what we did there? We could have chosen
#ZESHY_COLOR_NAME_PUNCTUATION to be any composite of a color and color
#attributes, including: "grey", "grey_italic", "grey_bold_italic", "grey_weak",
#"grey_weak_background", and so on. As one can see, that's an enormous number of
#keys for each color... but not a single key more than we currently have,
#dispersed as they are across ten or so map globals. Centralize, my Self.
#
#That's great, but that's not the sole reason. By centralizing all colors into a
#single map, we *VASTLY* simplify startup logic for initializing ${ZESHY_COLOR}.
#On an 8-color terminal? No problem; just perform a *SINGLE MAP COPY*:
#
#   ZESHY_COLOR=( "${ZESHY_COLOR_8[@]}" )
#
#Done. Without such approach, we'd need a positively obscene number of maps --
#basically, ten or see for each number of terminal colors threshold. We're
#talking in upwards of fourty maps, which is simply obscenity. A different way
#is possible, friends.

    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_2_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #precompile_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
# Avoid confining such function to interactive shells and/or shells whose
# standard output is attached to a terminal device. Sufficiently many CLI
# applications are now color-aware (e.g., "less", "vim") that outputting color
# when running non-interactively is largely a non-issue.
#   die_unless_shell_interactive
# Moreover, I've always found such behavior
# exceedingly annoying in other applications (e.g., "ls"), and don't see.
#FUXME: Honestly, "_BOLD" makes little sense. It's not bold; it's *BRIGHTER*.
#Rename ZESHY_COLOR_BOLD to ZESHY_COLOR_BRIGHT and so forth. Likewise, rename
#"_WEAK" to "_FAINT" for orthogonality. (Don't forget "ansi_weak" to "ansi_faint",
#too.)

#FUXME: Map ${ZESHY_ANSI_SGR} suggests we could profitably implement _FAINT and
#_STANDOUT versions, as well. Test us up! *YES*. Great: the "italic" attribute
#is implemented as italics under many terminals. We absolutely want that. :)
#   remove_string_glob_matches "${*}" "${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_GLOB}"
#   print_string "${*//${~ZESHY_ZSH_COLOR_GLOB}/}"
#FUXME: Rename to remove_string_ansi_color().
#FUXME: Rename to remove_string_zsh_color().
#   print_string "${*//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}/}"
#Glob matching the 2-byte ANSI Select Graphic Rendition (SGR) prefixing all
#color-specific ANSI escape codes. Dismantled, this is:
# Handle all terminal color functionality *OTHER* than defining such colors. See
# "00-setup/" for the latter.
