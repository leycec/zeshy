#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle shell completion styles.
-/-

#FIXME: Complex but sweet auto-complete styles (complete with animated GIF intro!):
#    https://github.com/hchbaw/auto-fu.zsh/

# ....................{ CONFIGURERS                        }....................
declare_function_with_stdin <<'/---'
void configure_shell_completions(void)

Interactively configure shell completion styles.
/---
function configure_shell_completions() {
    die_if_args
    compinstall
}

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_startup startup_zeshy_completions

#FIXME: O.K.; this is obviously beyond suboptimal. For starters, by running
#"compinit -i -d" below, we're coercively overwriting the completion
#configuration on each zeshy startup. It's slow, it's unnecessary, and (worse)
#it erases any configuration the user previously cached by calling
#configure_completions(). Reform this logic to do the following:
#
#* If a cached completions file already exists, simply call "compinit -i" w/o
#  option "-d" on such file. Perhaps create a new function
#  source_zeshy_completions() or some such to encapsulate such functionality.
#* Otherwise, perform the current initialization logic below.
#
#Of course, this raises a question: when upgrading Zeshy, should we force such
#initialization logic again? On the one hand, this erases the user's
#configuration (again); on the other hand, without doing so, the user will never
#see improvement in Zeshy's completion system. Clearly, we want to segregate the
#two: one or more files for user-configured completions and one file for Zeshy
#completions.
#
#Of course, it would be nice if user overlays could contribute completions to
#the canonical Zeshy completion file as well. I'd quite like to avoid adding
#hook system for completions. Instead, it seems that it should suffice to do
#the following:
#
#* Perform all zstyle commands in a function added to Zeshy startup in the
#  conventional way (e.g., with a call to run_hook_on_zeshy_startup()).
#* Perform the final call to "compinit -i -d" in another function added to the
#  very end of Zeshy startup. We currently have no means of doing so, but I
#  don't particularly see why we couldn't. The most extensible way of doing so,
#  though it smacks of crude overengineering, would be to have
#  ${ZESHY_COMMANDS_TO_STARTUP_ZESHY} be a recursive list of lists of lists of ... of
#  strings rather than the simple list of strings that it currently is. By
#  default, the first element of ${ZESHY_COMMANDS_TO_STARTUP_ZESHY} could be the name of
#  a list consisting only of strings, equivalent to the current
#  ${ZESHY_COMMANDS_TO_STARTUP_ZESHY}. Then merely append a second name of a second list
#  consisting only of strings to ${ZESHY_COMMANDS_TO_STARTUP_ZESHY}, perhaps calling it
#  ${ZESHY_COMMANDS_TO_STARTUP_ZESHY_FOR_STYLES}. That said, that's *PRETTY* heavy.
#
#Oh, very well. Let's just add a bloody
#run_hook_on_zeshy_startup_styles() function and rename the existing
#run_hook_on_zeshy_startup() to run_hook_on_zeshy_startup() as it was
#previously. We'll need a corresponding precompile_zeshy_startup_styles() synthesizer,
#of course, resembling the current precompile_zeshy_startup(). Then, just call above:
#
#    run_hook_on_zeshy_startup startup_zeshy_styles
#
#Oh, wait. This is all *BLOODY NONSENSE.* Why? Because I can just *MANUALLY*
#insert a call to "compinit -i -d" at the very of precompile_zeshy_startup(). It may
#not be terribly glamarous, but it beats the heck out of the absurd discussion
#above.
#
#In this manner, any zstyle commands performed in plugins would be performed
#*AFTER* default Zeshy style commands but before the final "compinit -i -d".
#
#Hmmmm; interesting. We could implement overlay directories:
#
#* "always", unchanged from its current use.
#* "always_on_entering", with contents run prior to those of "always". Hence,
#  rename "always/00-startup" to such directory.
#* "always_on_leaving", with contents run after those not merely of "always"
#  but of *ALL* overlays beneath this overlay. In other words, such directory
#  is sourced immediately after popping off its overlay from the overlay stack
#  during the search for overlays pertinent to the current user.
#
#O.K.; now *THAT* is pretty sweet. It's sensible; it's algorithmic; it requires
#no horrific API additions or extreme changes elsewhere. I'm not entirely sold
#on the directory names, but that's easily remediable. For example, how about:
#
#* "always_before" and "always_after". I'm not happy with the lexicographic sort
#  order implied, however. The former should be sorted before the latter.
#* "always_on_entrance" and "always_on_exit". Not terribly explanatory. Or are they?
#* "always_earlier" and "always_later".
#* "always_early" and "always_late". *PROBABLY* my favorite thus far. Helpful
#  lexicographic sort order and mildly humerous explanatory names. Can't go wrong.
#  They're also *MUCH* more concise than "always_on_entering" and
#  "always_on_leaving", which becomes increasingly important as overlays become
#  increasingly nested.
#
#Pretty sweet. Like it. Something of this sort will clearly become essential at
#some point, to permit Zeshy to respond to user plugins after loading such
#plugins prior to Zeshy digest recompilation. It makes sense and it's clean. We
#won't need to leverage either terribly often, but both appear indispensible
#when we do need to.

declare_function_with_stdin <<'/---'
void startup_zeshy_completions(void)

Reload previously configured and cached shell completion styles.
/---
function startup_zeshy_completions() {
    # Validate sanity.
    die_if_args

    #FIXME: It'd be great to encapsulate such bizarre "zstyle" syntax in a
    #handful of utility functions. That said, I first have to *LEARN* such
    #bizarre syntax... *sigh*

    # Define default completions.
    zstyle ':completion:*' completer _oldlist _complete _match _approximate _prefix
    zstyle ':completion:*' expand suffix
    zstyle ':completion:*' format '[completing %d}'
    zstyle ':completion:*' ignore-parents parent pwd
    zstyle ':completion:*' insert-unambiguous true
    zstyle ':completion:*' list-colors ''
    zstyle ':completion:*' list-prompt %SAt %p: Hit tab for more, or the character to insert%s
    zstyle ':completion:*' match-original both
    zstyle ':completion:*' max-errors 1
    zstyle ':completion:*' menu select=long-list select=0
    zstyle ':completion:*' prompt '[corrected %e}'
    zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
    zstyle ':completion:*' verbose true

    # Match case-insensitively.
    zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'r:|[._-]=** r:|=**'

    # Complete tab completions with an active menu rather than passive list.
    zstyle ':completion:*' menu select=2

    #FIXME: Define a new set_list_to_string_split_on_colons() function.
    # Colorize tab completions. While "list-colors" expects a zsh-style list of
    # colors, global string ${LS_COLORS} expands to a colon-delimited string of
    # colors. Hence, convert the latter to the former.
    list ls_colors
#   print_message 'initializing "ls" completions...'
    set_list_to_string_split_on_string ls_colors "$(get_list_colors)" ':'
    zstyle ':completion:*:default' list-colors "${ls_colors[@]}"
    #zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
    #zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'

    #FIXME: Contemplate enabling, if zsh begins failing to rehash the command hash
    #often enough.
    # Recache the command hash of all $PATH-accessible executables on every
    # command line, obviating the need for "hash -rf" when installing new
    # commands.
#   zstyle ":completion:*:commands" rehash 1

    # Ignore completion functions for commands we don't have.
    zstyle ':completion:*:functions' ignored-patterns '_*'

    # When tab completing pathnames, strip the trailing slash. (Nice for "ln".)
    zstyle ':completion:*' squeeze-slashes true

    # Improve "killall" completion.
    zstyle ':completion:*:killall:*' command 'ps -u $USER -o cmd'

    # When tab completing for "cd", ignore the current and parent paths.
    # zstyle ':completion:*:cd:*' ignore-parents parent pwd

    # Initialize such completions.
    startup_zeshy_completions_initialize
}

declare_function_with_stdin <<'/---'
void startup_zeshy_completions_initialize(void)

Initialize all previously defined completions. Cache such initialization to
disk to avoid costly re-initialization from scratch under subsequent shells.
/---
function startup_zeshy_completions_initialize() {
    # Validate sanity.
    die_if_args
#   print_message "initializing completions..."

    # If loading zeshy's user directory, cache completions to such directory.
    if { is_dir "${ZESHY_DOT_DIR}" } {
        # Cache completion results for expensive completion functions (e.g.,
        # _apt(), _dpkg()).
        make_dir_if_not_found "${ZESHY_USER_COMPLETION_RESULTS_DIR}"
        zstyle ':completion::complete:*' use-cache on
        zstyle ':completion::complete:*' cache-path "${ZESHY_USER_COMPLETION_RESULTS_DIR}"

        #FIXME: compinit() is an old-school zsh function and hence should be run
        #under run_code_under_zsh_defaults() both here and below.

        # Initialize completions and cache such initialization *AFTER* defining
        # completions to avoid interactive errors on shell execution resembling:
        #
        #     zsh compinit: insecure directories, run compaudit for list.
        #     Ignore insecure directories and continue [y] or abort compinit [n]?
        compinit -d "${ZESHY_USER_COMPLETION_STARTUP_FILE}"
    # If ignoring zeshy's user directory, initialize but do not cache
    # completions.
    } else {
        compinit
    }
}

# --------------------( WASTELANDS                         )--------------------
#       compinit -i -d "${ZESHY_USER_COMPLETION_STARTUP_FILE}"
#   zstyle ':completion:*:default' list-colors "${(s.:.)LS_COLORS}"
    #FUXME: Hmmm; this isn't quite right, clearly. Since the above cache path
    #is empty, it's clear the above syntax is incorrect; zsh is probably writing
    #to some insecure shared location (e.g., "/tmp/zsh"), in which case we most
    #definitely want to fix this.
