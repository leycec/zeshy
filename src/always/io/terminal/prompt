#!/usr/bin/env zsh
# ====================[ prompt                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle interactive shell prompts.
#
# --------------------( SEE ALSO                           )--------------------
# http://aperiodic.net/phil/prompt/
#   Phillip Gold's fairly phenomenal "ZSH Prompt" treatise.
#
# --------------------( TODO                               )--------------------
# * Incorporate the following other prompt scripts:
#  * Has a fantastic series of functions for setting the terminal title!
#    http://www.semicomplete.com/misc/rcfiles/zshrc

#FIXME: Fairly cool (and very fast) command-line syntax highlighting of zsh
#while you type it, using Pygments:
#
#    https://bitbucket.org/ZyX_I/zsh-pygments-highlighting/src
#
#The traditional alternative to the above is a script entitled
#zsh-syntax-highlighting (available on Github), which is purportedly slow-as-
#blazes, to the point of unusability (particularly on long multi-lines). The
#above script suffers no such delusional slowness.

# ....................{ SPLASH                             }....................
# Display introductory "splash" text. This is a line or two of text displayed
# prior to displaying the shell prompt, on initial start-up of the shell.
#
# This text is defined and displayed according to ZSH shell prompt syntax.
# Thus, see "info zsh" for details.

# void precmd()
#
# Modifies the current shell environment prior to printing the current prompt.
# zsh runs this function immediately after the process for the previous command
# completes but immediately before printing another prompt for the next command.
#precmd() {
#}

# void preexec(string command_name, string command_arg_1, ...)
#
# Modifies the current shell environment prior to running the passed command.
# zsh runs this function immediately after the current user inputs a command at
# the current prompt and then inputs <Enter>, but immediately before executing
# the command.

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_startup_if_shell_interactive\
    startup_zeshy_terminal_prompt

declare_function '
void startup_zeshy_terminal_prompt(void)

Define prompt strings for the current interactive shell. This includes:

* ${PROMPT}, the default leftmost prompt string.
* ${PROMPT2}, the leftmost prompt string for continuation lines.
* ${PROMPT3}, the leftmost prompt string for "select" loops.
* ${PROMPT4}, the leftmost prompt string for runtime traces.
* ${RPROMPT}, the default rightmost prompt string.
* ${SPROMPT}, the leftmost prompt string for spelling mistake corrections.
'
function startup_zeshy_terminal_prompt() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Set superuser-specific colors if the current user is the superuser or
    # non-superuser-specific colors otherwise.
    string prefix
    if is_current_user_superuser
    then prefix='startup_zeshy_terminal_prompt.superuser.'
    else prefix='startup_zeshy_terminal_prompt.nonsuperuser.'
    fi

    #FIXME: Define a new print_prompt() function printing the current prompt(s).
    #Don't bother with implementing a "vared PS1" wrapper; that hardly makes
    #sense, given the current prompt implementation.

    # Define (and export) the ANSI shell prompt. To view this prompt as colorized
    # output, type "print -P $PS1"; and to view and edit this prompt as plaintext
    # source, type "vared PS1".
    #
    # This text is defined and displayed according to ZSH shell prompt syntax.
    # See "info zsh" for details.
    PROMPT=''

    # Print the current hostname and username.
    PROMPT+="${ZESHY_PROMPT_COLOR_STYLE[${prefix}brace]-}[${ZESHY_PROMPT_COLOR_STYLE[${prefix}host]-}%m ${ZESHY_PROMPT_COLOR_STYLE[${prefix}user]-}%n${ZESHY_PROMPT_COLOR_STYLE[${prefix}brace]-}}"

    # Print the current path.
    PROMPT+="${ZESHY_PROMPT_COLOR_STYLE[${prefix}path]-}%~"

    # Print an indication of whether the prior command succeeded or failed.
    PROMPT+="%(1/?%(0??${ZESHY_PROMPT_COLOR_STYLE[${prefix}prior_command_succeeded]-}/?${ZESHY_PROMPT_COLOR_STYLE[${prefix}prior_command_failed]-}!)?)"

    # Set colors for subsequent command line input.
    PROMPT+="${ZESHY_PROMPT_COLOR_STYLE[${prefix}input]-}"

    # Set no rightmost prompt, for the moment.
    RPROMPT=
}

# --------------------( WASTELANDS                         )--------------------
#   print -Pn -- "${ZESHY_COLOR[reset]-}"
#FUXME: Integrate with a new "zsh/hook" component. According to "man zshall",
#zsh has builtin support for global arrays ${precmd_functions},
#${preexec_functions}, and so on, so all such component needs provide are
#appropriate append_* and prepend_* functions -- ideally with more human-
#readable names than "precmd" and "preexec".

    # Set superuser-specific colors if the current user is the superuser or
    # non-superuser-specific colors otherwise.
#   string prefix
#   if is_current_user_superuser
#   then prefix='startup_zeshy_terminal_prompt.superuser.'
#   else prefix='startup_zeshy_terminal_prompt.nonsuperuser.'
#   fi

#   string color_command color_machine color_path color_exit_status_nonzero
#%B
    #FUXME: Extract into color styles.
    # Define user-specific colors to be used in prompts below.
#   if is_current_user_superuser; then
#       color_command="${ZESHY_PROMPT_COLOR[grey]}"
#       color_machine="${ZESHY_PROMPT_COLOR[red]}"
#       color_path="${ZESHY_PROMPT_COLOR[white]}"
#       color_exit_status_nonzero="${ZESHY_PROMPT_COLOR[magenta]}"
#   else
#       color_command="${ZESHY_PROMPT_COLOR[white_bold]}"
#       color_machine="${ZESHY_PROMPT_COLOR[cyan]}"
#       color_path="${ZESHY_PROMPT_COLOR[green]}"
#       color_exit_status_nonzero="${ZESHY_PROMPT_COLOR[red]}"
#   fi

    # Define (and export) the ANSI shell prompt. To view this prompt as colorized
    # output, type "print -P $PS1"; and to view and edit this prompt as plaintext
    # source, type "vared PS1".
    #
    # This text is defined and displayed according to ZSH shell prompt syntax.
    # See "info zsh" for details.
#   PROMPT=''
#   PROMPT+="${color_command}[${color_machine}%m %B%n${color_command}}"   # user
#   PROMPT+="${color_path}%~"                                             # path
#   PROMPT+="%B%(1/?%(0??${color_path}/?${color_exit_status_nonzero}!)?)" # last process failed?
#   PROMPT+="${color_command}"                                            # input

    #FUXME: This can be simplified by noting the only difference between the root
    #and non-root prompts are the colors and that, therefore, this difference may
    #be abstracted out by defining these colors in a pre-prompt zsh function.

    # Coerce command output to be bold white, regardless of the previous
    # color output by the prior prompt.
#   export RPROMPT=
#   print "PS1: ${PS1}"
#       color_command=${ZESHY_PROMPT_COLOR_BLACK_BOLD}
#   export PS1
    #export PS1="%(!?${ZESHY_COLOR_BLACK_BOLD}[${ZESHY_COLOR_RED}%m %B%n${ZESHY_COLOR_BLACK_BOLD}}${ZESHY_COLOR_WHITE}%~%B%(1/?%(0??${ZESHY_COLOR_WHITE}/?${ZESHY_COLOR_RED}!)?)${ZESHY_COLOR_BLACK_BOLD}?${ZESHY_COLOR_WHITE_BOLD}[${ZESHY_COLOR_CYAN}%m %B%n${ZESHY_COLOR_WHITE_BOLD}}${ZESHY_COLOR_GREEN}%~%B%(1/?%(0??${ZESHY_COLOR_GREEN}/?${ZESHY_COLOR_RED}!)?)${ZESHY_COLOR_WHITE_BOLD})"

#FUXME: Obsolete.
# * "${PS1}", the core shell prompt variable, in a root-aware manner.
# * Splash message, terse introductory text welcoming the current user to Zeshy.
# * Help message, verbose synopsizing Zeshy functionality, issues, and usage
