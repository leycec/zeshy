#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *output paging* (e.g., `more`, `less`).
-/-

#FIXME: When *NOT* paging, visually demarcate wrapped lines (ideally with color
#or perhaps simply with a simple prefix). So, rather than printing:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
#odes=497142 mode=755
#
#  Instead, printing:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ^-> odes=497142 mode=755
#
#  Or perhaps simply:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ...odes=497142 mode=755
#
#  Or the slightly cleverer:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr...
# ..._inodes=497142 mode=755
#
#Actually, no. That reads awkwardly. One "..." is sufficient, I should think.
#Happily, "yppy" already has appropriate Unicode for the former arrows. In
#either case, I prefer a prefixing space on the wrapped line.

# ....................{ PAGERS                             }....................
declare_function_with_stdin <<'/---'
string page_string(string text1, string text2, ...)

Page the passed string with the current user's preferred pager (e.g., `less`)
if such string exceeds the current terminal height or print such string without
paging otherwise. This function thus pages on an as-needed basis, providing a
pseudo-intelligent context-sensitive pager.
/---
function page_string() {
    page_string_if_needed "${@}" or print_string "${*}"
}

#FIXME: As a slight improvement, make paging a bit "fuzzy." I've noticed that
#my eye, at least, would prefer paging not merely on text that's strictly too
#high but on text that's *SUFFICIENTLY* high. Sufficiently, is subjective, of
#course, so this should probably be user-configurable. I'm contemplating a
#default of 75% for such user-configurable global -- say:
#
#    ZESHY_PAGE_IF_TEXT_TO_TERMINAL_HEIGHT_PERCENT=75
#
#Then, page if the text height is greater than or equal to
#(( $(get_terminal_height) * ZESHY_PAGE_IF_TEXT_TO_TERMINAL_HEIGHT_PERCENT / 100 )).
#Should work great, yes?
#FIXME: Actually, it'd be better to just *CLEAR* the screen prior to printing
#such sufficiently tall text. The issue with tall text that still fits on the
#screen is not that such text isn't paged; it's that such text starts at a
#line number other than 1, which my eye (at least) expects for tall text.

declare_function_with_stdin <<'/---'
string page_string_if_needed(string text1, string text2, ...)

If the passed string exceeds the current terminal's dimensions, print such
string with the current user's preferred pager; otherwise, return false.
/---
function page_string_if_needed() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string\
        text="${*}"\
        pager_path\
        pager_name\
        pager_options_list_name
    integer\
        text_height line_sans_ansi_width terminal_height terminal_width_plus_one
    list command lines

    # If this function is *NOT* paging to a terminal, return such string.
    is_stdout_terminal or return_string "${text}"

    # Split such string on newline into lines.
    set_list_to_string_lines lines "${text}"

    # Determine whether such output's logical line length (i.e., accounting for
    # implicit wrapping of long lines) exceeds the terminal height or physical
    # line width the terminal width. The algorithm resembles
    # get_displayed_line_length(), but differs by immediately stopping iteration
    # on exceeding terminal height or width rather than continuing to accumulate
    # total line length. This reduces an otherwise O(N) algorithm to effectively
    # O(1), assuming non-ludicrous terminal height and width.
    text_height="$(get_list_size lines)"
    terminal_height="$(get_terminal_height)"

    # Terminal width plus one to avoid treating maximally long lines as wrapped.
    terminal_width_plus_one=$(( $(get_terminal_width) + 1 ))
#   print_message "text_height: ${text_height}\nterminal_height: ${terminal_height}"

    # ${text_height} gives only the number of lines in such string without
    # considering line wrapping. Even if such number does not exceed the
    # terminal height, such number incremented by the number of additional
    # wrapped lines in such string *COULD* still exceed the terminal height. In
    # the latter case, such string requires paging.
    if (( text_height <= terminal_height )) {
        string line line_sans_ansi
        for    line ("${lines[@]}") {
            # Remove ANSI color codes prior to testing line length. See
            # get_string_length_printable_sans_ansi_colors() for further details.
            line_sans_ansi_width="${(m)#${line//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}}}"
    #       print_message "line width (sans ANSI): ${line_sans_ansi_width}"

            # Increment the number of lines required to display such text by the
            # number of wrapped lines by which the current line exceeds the terminal
            # width (i.e., by the number of additional wrapped lines in this line).
            (( text_height += line_sans_ansi_width / terminal_width_plus_one ))
            if (( text_height > terminal_height )) { break }
        }
    }
#   print_message "text_height: ${text_height}\nterminal_height: ${terminal_height}"
#   print_message "text_width: ${text_width}\nterminal_width_plus_one: ${terminal_width_plus_one}"

    # If the terminal suffices to display output without paging, do not page.
    if (( text_height <= terminal_height )) { return_false }
#   print_message "line length: ${text_height}\nterminal height: ${terminal_height}"

    # Absolute path of the pager command preferred by the current user.
    pager_path="$(get_pager_path)"

    # Command to be run.
    command=( "${pager_path}" )

    # Pager name capitalized for use below.
    pager_name="$(capitalize_string "$(get_path_basename "${pager_path}")")"

    # List of pager options specific to such pager.
    pager_options_list_name="ZESHY_${pager_name}_OPTIONS"
    if { is_list "${pager_options_list_name}" } {
        command+=( "${(@P)pager_options_list_name}" )
    }

    # Page such text.
    output_string "${text}" | "${command[@]}"
}

# ....................{ PAGERS ~ stdin                     }....................
declare_function_with_stdin <<'/---'
string page_stdin(void)

Page standard input with the current user''s preferred pager (e.g., `less`) if
such input exceeds the current terminal height or print such input without
paging otherwise. This function is typically piped standard output from a block
of related commands to be paged together: e.g.,

.page_stdin()
==========================================
[source]
------------------------------------------
>>> { lsblk; lscpu; lsmod; lsof; lspci; lsusb } | page_stdin
------------------------------------------
==========================================

See page_string() for further details.
/---
function page_stdin() {
    # Validate passed arguments.
    die_if_args
    die_if_stdin_empty

    # All previously read lines of standard input.
    string stdin

    # Currently read line of standard input.
    string stdin_line

    # Incrementally read each line of standard input and for each such line,
    # print such line to standard output and append such line to the string
    # accumulating such input. While slightly more complex than the conventional
    # blocking implementation capturing all standard input at once (e.g.,
    # "$(< /dev/stdin)"), this non-blocking implementation is preferable for
    # paging output from non-trivial commands not expected to end immediately.
    # Dismantled, this is:
    #
    # * "IFS=", preventing read() from splitting read input on field separators.
    # * "-r", preserving input characters (e.g., backslashes are not escapes).
    # * "-E", copying read input to standard output.
    while { IFS= read -r -E stdin_line } {
        stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
    }

    # If required, page such input.
    page_string_if_needed "${stdin}"
}

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
string run_command_paged(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command with standard output and error piped to the current
pager if such output exceeds either the current terminal height or width or as
is (i.e., without paging) otherwise. Hence, this is an intelligent pager.

Customary pager commands block on standard input, thus delaying output until
after the input command completes operation. Resource-intensive commands not
completing immediately (e.g., `ls -R *`) thus block paging with no
intermediate output until such commands eventually complete. To rectify such
interface woes, this function immediately prints all output as received from
the passed command to standard error prior to paging such output, as needed.
/---
function run_command_paged() {
    # If not called from a terminal, run such command without paging.
    if { not is_stdout_terminal } {
        run_command "${@}"
    # If passed piped input and no arguments, page such input.
    } elif { is_args_0 and is_stdin_pipe } {
        page_string
    # Otherwise, run the passed command with redirection.
    } else {
        # Validate passed arguments.
        die_unless_args 'expected one command'
#       print_string "run_command_paged: ${@}..."

        # Run such command and capture its output. Dismantled, this is:
        string output; run_command_and_set_string_to_stdout "${@}" output

        # Page such output, ignoring a false return value if such output needs
        # no paging.
        page_string_if_needed "${output}" or ignore_exit_status
    }
}

# --------------------( WASTELANDS                         )--------------------
        # For efficiency,
        # manually implement the equivalent of the following:
        #
        #     >>> line_sans_ansi_width="$(\
        #     ...     get_string_length_printable_sans_ansi_colors "${line}")"

#FUXME: Rename to page_string_if_needed(). The exact conditions under which a
#string should be paged are implementation details that should be kept out of
#the function name.
        # Run such command and capture its output. Dismantled, this is:
        #
        # * "1>&1", preserving standard output prior to redirection below.
        # * "1>&2", redirecting standard output to error. Since command
        #   substitution only captures the former, this immediately prints all
        #   output produced by running such command.
        # * "2>&1", redirecting standard error to output. Since command
        #   substitution only captures the latter, only such redirection
        #   captures standard error.
        #
        # Avoid the following efficient and certainly simpler alternative, which
        # unfortunately discards non-zero exit status from run():
        #
        #   run_command "${@}" 1>&1 1>&2 | page_stdin_if_needed or true
#       string output; output="$(run_command "${@}" 1>&1 1>&2 2>&1)"
#       string output; output="$(run_command_and_set_string_to_stdout "${@}")"

#FUXME: Rename to get_pager_path_path().
# and return_exit_status
#   is_stdout_terminal or {
#       print_string "${@}"
#       return_true
#   }
#FUXME: Rename to page_string_if_needed(). Pretty sweet adjective in this
#case and frankly the best I've come up with.

#FUXME: Rename to page_string(). Since there's no possibility of a corresponding
#curse_string_paged(), just truncate us up. This also helps with the absurdly
#long function name below.

    # * "or true", ignoring such function call when returning false, since the
    #   prior "1>&2" redirection already successfully printed such output.
#       page_string "$(get_stdin_piped)"
#   get_and_set_string_global_if_unset_or_empty_to_evaluation
#   set_string_if_unset_or_empty_to_evaluation\
#       PAGER '$(get_pathable_path_first less more)'
#   print_string "${PAGER}"

#function get_string_global_and_set_if_unset_or_empty_to_evaluation() {
#    die_unless_arg 'expected one string variable name'
#    string __variable_name__="${1}"
#    declare_string_global "${__variable_name__}"
#    set_string_if_unset_or_empty_to_evaluation\
#        "${__variable_name__}" '$(get_pathable_path_first less more)'
#    print_string "${__variable_name__}"
#}

        #FUXME: Not quite right. Try prefixing or suffixing 2>&1.
        #FUXME: Woops. This erroneously discards non-zero exit status from
        #run(). We only want to discard non-zero exit status from
        #print_...(). Hmmmm. Frak this. Revert to the prior logic, which
        #actually worked perfectly.
#       run "${@}" 1>&1 1>&2 | page_stdin_if_needed or
#           true
#       string output; set_string_to_stdin_piped output
#       page_string "${output}"
#       line_sans_ansi_width="$(get_string_length "$(remove_ansi_color_codes "${line}")")"
#       text_width=${#$(remove_ansi_color_codes "${line}")}
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
#       run "${@}" 1>&1 1>&2 2>&1 | page_stdin_if_needed

#   print_message 'here!' 
#   is_stdin_pipe and {
#       print_message 'received piped input:'
#       print_message "$(< /dev/stdin)"
#       print_message 'yikes'
#       close_stdin
#       print_message 'yikes'
#       is -p /dev/stdin si and print_message 'pipe"s alive!!!!'
#       print_message 'yikes'
#       is_stdin_pipe and print_message 'pipe"s alive!!!!'
#       print_message 'yikes'
#   }
#   print_message 'no, here!' 
    # If passed piped input and...
#   string output
#   if is_stdin_pipe; then
#       print_message "received piped input: $(get_stdin_piped)"
        # ...no arguments, capture such print_string without running a command.
        # Duplicate the behavior of the print_string capturing below by printing such
        # print_string to standard error.
#       if is_args_0; then
#           set_string_to_stdin_piped output
#           page_string "${output}"
        # ...at least one argument, run such arguments as a command and pipe the
        # input piped to this function to such command. See below for details.
#       else
            #FUXME: Not quite right. Revise run() to implicitly check for piped
            #input and, if available, to close such input after use. That would
            #condense the following two conditional blocks into one.
#           run_command_with_stdin_piped run "${@}" 1>&1 1>&2 2>&1 |
#               page_string_if_needed
#           output="$(run_command_with_stdin_piped run "${@}" 1>&1 1>&2 2>&1)"

            # Per the "CAVEAT" described under Zeshy Pipe, manually ensure
            # is_stdin_pipe() now returns false.
#           close_stdin
#       fi
    #FUXME: Hmm; the documentation no longer reflects the reality. Fixmeup.
    # Otherwise, run the passed command with redirection. Dismantled, this is:
    #
    # * "2>&2", preserving standard error prior to its subsequent redirection.
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
    # * "1>&1", preserving standard print_string prior to its subsequent redirection.
    # * "1>&2", redirecting standard print_string to error. Since command substitution
    #   only captures the former, this immediately prints all print_string produced by
    #   running such command.
#   else
#       die_unless_args 'expected one command'
#       print_string "run_command_paged: ${@}..."
#       run "${@}" 1>&1 1>&2 2>&1 | page_stdin_if_needed
#   fi
#           die_if_args 'expected no command when passed piped input'
#           output="$(get_stdin_piped)"
#           curse_string "${output}"
#           page_string_if_needed "${output}"

#FUXME: Woops! We've dramatically simplified this by now paging on *ANY*
#line wrapping. That means we know longer need to determine displayed page
#length. Clean up documentation.
#FUXME: Actually, while this is decent, it'd be far better to:
#
#* Revert back to the prior logic of only paging when total displayed line
#  length exceeds terminal height *AND*
#   noop "${PAGER:="$(get_pathable_path_first less more)"}"

#   integer terminal_width_plus_one
#   (( terminal_width_plus_one = terminal_width + 1 ))
    # * Wrapping Accounting for line wrapping 
    # * Output width (i.e., the length of the longest print_string line) exceeds
    #   terminal width.
    # Accumulate wrapped line height and maximum line width until either exceeds
    # terminal height or width, at which point we know we need to page.#       (( text_height > terminal_height or
#          text_width  > terminal_width )) and break
#       print_string "line (width: ${text_width}) ${line}"
#       (( text_width > terminal_width )) and break
#   (( text_height > terminal_height or
#      text_width  > terminal_width  )) or return_true
