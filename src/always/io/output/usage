#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *usage printers* (i.e., functions documenting command-line interfaces,
usually in response to command-line options `-h` and `--help`).
-/-

# ....................{ PRINTERS                           }....................
#FIXME: Document. Oh, boy... For simplicity, let's largely document this by
#example, eh?

declare_function_with_stdin <<'/---'
string print_command_usage(
    string overview_map_name,
    string options_list_name1, string options_list_name2, ...)

Print *command usage* (i.e., a terse specification of such command's command-
line interface) from the passed overview map and zero or more options lists.
For readability, such usage will be dynamically paged if exceeding the height of
the current terminal: e.g.,

.print_command_usage()
==========================================
[source]
------------------------------------------
>>> print_command_usage ...
------------------------------------------
==========================================

== Overview Map ==

== Options Lists ==
/---
function print_command_usage() {
    # Validate passed arguments.
    die_unless_args\
        'Expected one overview map name and zero or more options list names.'

    # Page all output exceeding the height of the current terminal.
    {
        # Handle previously updated output state.
        start_stdout

        # Print the mandatory overview.
        output_command_usage_overview "${1}"

        # If at least one options list name was passed, print such options.
        if { is_args_2_or_more } {
            output_command_usage_options "${@[2,-1]}"
        }

        # Update output state in preparation for subsequent output.
        stop_stdout
    } | page_stdin
}

# ....................{ OUTPUTTERS                         }....................
declare_function_with_stdin <<'/---'
string output_command_usage_overview(string overview_map_name)

Print the *command usage overview* (i.e., a terse synopsis of such command's
command-line interface) from the passed map. This function is typically called
only by output_command_usage(). See such function for further details.
/---
function output_command_usage_overview() {
    # Validate passed arguments.
    die_unless_arg 'Expected one overview map name.'
    string\
        overview_map_name__pcuv="${1}"\
        command_name__pcuv\
        command_args__pcuv\
        command_synopsis__pcuv
    die_unless_map "${overview_map_name__pcuv}"
    shift_arg

    # Mandatory command to print usage for. If such map lacks such key, this
    # implicitly throws an exception.
    command_name__pcuv="$(get_map_key_value\
        "${overview_map_name__pcuv}" 'command')"

    # Print such command name.
    output_string_sans_newline\
        "${ZESHY_STYLE_TO_COLOR[print_usage.usage]-}Usage${ZESHY_STYLE_TO_COLOR[print_usage.usage_colon]-}: ${ZESHY_STYLE_TO_COLOR[print_usage.command_name]-}${command_name__pcuv}"

    # If such map contains optional command arguments, print such arguments.
    if { command_args__pcuv="$(get_map_key_value_if_found\
        "${overview_map_name__pcuv}" 'args')" } {
        #FIXME: It'd be nice to extend replace_string_matches_glob_with_string()
        #to accept *MULTIPLE* glob string pairs. This is certainly feasible and
        #should remain reasonably efficient, given a single eval() statement.
        #(No looping required, I should imagine.)
        #FIXME: It'd be nice to perform a modest amount of pretty printing in
        #the event that such arguments exceed the width of the current line.
        #Shouldn't be terribly difficult; just requires a bit of consideration.

        # Print such arguments, prefixing all braces, ellipses, and words with
        # their corresponding color styles.
        output_string_sans_newline\
            " ${${${command_args__pcuv//(#m)[\[\]]/${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]-}${MATCH}}//.../${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]-}...}//(#m)[[:alpha:]]##/${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]-}${MATCH}}"
    }

    # Complete the usage line.
    output_newline

    # If such map contains an optional command synopsis, print such synopsis.
    if { command_synopsis__pcuv="$(get_map_key_value_if_found\
        "${overview_map_name__pcuv}" 'synopsis')" } {
        # Line wrap such synopsis.
        command_synopsis__pcuv="$(get_string_wrapped\
            "${command_synopsis__pcuv}")"

        #FIXME: Abstract out such string replacements to a new function as above.

        # Print such synopsis, prefixing the command name and all uppercase words
        # of at least two characters with their corresponding color styles.
        output_newline
        output_string\
            "${ZESHY_STYLE_TO_COLOR[print_usage.synopsis]-}${${command_synopsis__pcuv//${command_name__pcuv}/${ZESHY_STYLE_TO_COLOR[print_usage.synopsis_command_name]-}${command_name__pcuv}${ZESHY_STYLE_TO_COLOR[print_usage.synopsis]-}}//(#m)[[:upper:]](#c2,)/${ZESHY_STYLE_TO_COLOR[print_usage.synopsis_arg_name]-}${MATCH}${ZESHY_STYLE_TO_COLOR[print_usage.synopsis]-}}"
    }
}

declare_function_with_stdin <<'/---'
string output_command_usage_options(
    string options_list_name1, string options_list_name2, ...)

Print the *command usage options* (i.e., a terse synopsis of such command's
command-line options) from the passed lists. This function is typically called
only by output_command_usage(). See such function for further details.
/---
function output_command_usage_options() {
    # Validate passed arguments.
    die_unless_args 'Expected one or more options list names.'
    string\
        options_list_name__pcuo\
        option_indentation__pcuo='  '\
        option_short__pcuo\
        option_short_colored__pcuo\
        option_long__pcuo\
        option_long_colored_pcu\
        option_text__pcuo\
        option_text_line__pcuo\
        option_text_pcre_wrapper__pcuo\
        ZPCRE_OP
    integer\
        terminal_width__pcuo\
        option_names_width__pcuo\
        option_names_length__pcuo\
        option_text_width__pcuo\
        options_list_size__pcuo

    # List of text for the current option wrapped into newline-delimited lines.
    list option_text_lines__pcuo

    # Width in characters of the current terminal.
    terminal_width__pcuo="$(get_terminal_width)"

    # Width in characters of the option names area (i.e., the portion of each
    # line allotted to short and long options names and arguments),
    # corresponding to one third of the current terminal width. Avoid decimal
    # approximations of one third (e.g., "0.33"), which usually fail to ensure
    # that "$(( 1 * (1/3.) == 1 ))". To ensure floating point rather than
    # integer division, suffix either "1" or "3" by ".".
    option_names_width__pcuo=$(( terminal_width__pcuo * (1/3.) ))

    # Width in characters of the option text area (i.e., the portion of each
    # line allotted to options descriptions), corresponding to two thirds of the
    # current terminal width.
    option_text_width__pcuo=$((\
        terminal_width__pcuo - option_names_width__pcuo ))

    # If either such width is less than 1, throw an exception.
    die_unless_integer_positive "${option_names_width__pcuo}"\
        "Option name width ${option_names_width__pcuo} non-positive."
    die_unless_integer_positive "${option_text_width__pcuo}"\
        "Option text width ${option_text_width__pcuo} non-positive."

    # PCRE permitting line wrapping of option text. Compile such PCRE *AFTER*
    # wrapping the synopsis above, which also internally compiles a PCRE
    # conflicting with this PCRE's compilation below. See
    # for_string_matches_pcre() for further details.
    pcre_compile --\
        "$(get_pcre_wrapping_at_line_length ${option_text_width__pcuo})"
    pcre_study

    # For each options list, print all options in such list.
    for options_list_name__pcuo ("${@}") {
        # If such list does not exist, throw an exception. See die_unless_list()
        # for further details.
        is "${(tP)options_list_name__pcuo-}" ==\
            ${~ZESHY_VARIABLE_TYPE_GLOB_LIST} si or
            die "List \"${options_list_name__pcuo}\" undefined."

        # Size of such list. See get_list_size() for further details.
        output_strings_newlined "${options_list_name__pcuo}: ${(@P)options_list_name__pcuo}"
        options_list_size__pcuo="${#${(@P)options_list_name__pcuo}}"

        # If such size is *NOT* at least 4 and (excluding the leading heading) a
        # multiple of three, throw an exception.
        ((   options_list_size__pcuo >= 4 &&
            (options_list_size__pcuo - 1) / 3. == 1 )) or {
            print_list "${options_list_name__pcuo}"
            die "List \"${options_list_name__pcuo}\" contains ${options_list_size__pcuo} elements rather than a heading and one or more triples."
        }

        # Print such options' heading.
        output_newline
        output_string "${ZESHY_STYLE_TO_COLOR[print_usage.heading_name]-}${${(@P)options_list_name__pcuo}[1]}${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]-}:"

        # For each trifecta of short and long options and option text, print
        # the holy triumvurate of shame!
        for option_short__pcuo option_long__pcuo option_text__pcuo (
            "${${(@P)options_list_name__pcuo}[2,-1]}") {
            # If a short option was defined, format such option.
            if is -n "${option_short__pcuo}" si {
                # If such option is longer than a character, throw an exception.
                # See die_unless_character() for further details.
                (( ${#option_short__pcuo} == 1 )) or\
                    die "Short option \"${option_short__pcuo}\" not a character."

                # If such option is prefixed by an optional dash, remove such
                # dash before prefixing such option by a mandatory dash below.
                option_short__pcuo="${option_short__pcuo#-}"

                # Prefix the first optional space and argument in such option
                # with corresponding color styles.
                option_short_colored__pcuo="${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]-}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]-}${option_short__pcuo/(#m) */${ZESHY_STYLE_TO_COLOR[print_usage.option_arg]-}${MATCH}}"

                # Prefix such option by a dash, to simplify logic below.
                option_short__pcuo="-${option_short__pcuo}"
            # Else, no such option was defined. Empty the corresponding string.
            } else {
                option_short_colored__pcuo=''
            }

            # If a long option was defined, format such option (as above).
            if is -n "${option_long__pcuo}" si {
                option_long__pcuo="${option_long__pcuo#--}"
                option_long_colored__pcuo="${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]-}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]-}${option_long__pcuo}/(#b)=(*)/${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]-}=${ZESHY_STYLE_TO_COLOR[print_usage.option_arg]-}${match[1]}}"
                option_long__pcuo="--${option_long__pcuo}"
            # Else, no such option was defined. Empty the corresponding string.
            } else {
                option_long_colored__pcuo=''
            }

            # If option text was defined, wrap such text into a list of lines.
            option_text_lines__pcuo=()
            if is -n "${option_text__pcuo}" si {
                # Wrap such text with the previously compiled PCRE. See
                # for_string_matches_pcre() and
                # get_string_wrapped_at_line_length() for further details.
                ZPCRE_OP='0 0'
                while { pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
                    "${option_text__pcuo}" } {
                    option_text_lines__pcuo+="${ZESHY_STYLE_TO_COLOR[print_usage.option_synopsis]-}${match[1]}"
                }
            }

            # If a short option was defined, print such option.
            if is -n "${option_short__pcuo}" si {
                # Print such option.
                output_string_sans_newline\
                    "${option_indentation__pcuo}${option_short_colored__pcuo}"

                # If a long option was also defined, print a delimiting comma
                # followed by such option.
                if is -n "${option_long__pcuo}" si {
                    # Print a delimiting comma.
                    output_string_sans_newline\
                        "${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]-}, "

                    # Length of concatenated short and long options. See
                    # get_string_length() for further details.
                    option_names_length__pcuo="${#${${option_indentation__pcuo}${option_short__pcuo}, ${option_long__pcuo}}}"

                    # If such options fit on a single line, do so.
                    if (( option_names_length__pcuo <= option_names_width__pcuo )) {
                        # Print the long option, padded on the right by
                        # sufficient whitespace to ensure well-formatted
                        # columns. Such strings contain ANSI color codes and
                        # hence cannot be reliably padded by expansion under
                        # either parameter expansion flags "(l...)" or "(r...)".
                        # Instead, simply repeat the desired number of spaces by
                        # either such flag. See repeat_string() for further
                        # details.
                        #
                        # Print also the first line of options text (defaulting
                        # to the empty string), delimited by a newline.
                        output_string\
                            "${option_long_colored__pcuo}${(l:$(( option_names_width__pcuo - option_names_length__pcuo )):):-}${option_text_lines__pcuo[1]-}"

                        # For each additional line of options text that exists,
                        # print full padding followed by such line, delimited
                        # by a newline. Do *NOT* quote this list slice.
                        for option_text_line__pcuo\
                            (${option_text_lines__pcuo[2,-1]}) {
                            output_string\
                                "${(l:${option_names_width__pcuo}:):-}${option_text_line__pcuo}"
                        }
                    # Else, such options only fit on separate lines. Shift the
                    # long option to the next line, indented to the right.
                    } else {
                        # Print sufficient padding followed by the first line
                        # of options text (defaulting to the empty string),
                        # delimited by a newline. Note that while the length of
                        # the short option is constant and hence could be
                        # reduced to a magic number, recomputing such length
                        # does little tangible harm.
                        output_string\
                            "${(l:$(( option_names_width__pcuo - ${#${${option_indentation__pcuo}${option_short__pcuo},}} )):):-}${option_text_lines__pcuo[1]-}"

                        # Print the indented long option followed by sufficient
                        # padding and the second line of options text
                        # (defaulting to the empty string), delimited by a
                        # newline.
                        output_string_sans_newline\
                            "${option_indentation__pcuo}${option_long_colored__pcuo}"

                        # If no more lines of options text exist, print a
                        # newline.
                        if (( ${#option_text_line__pcuo} < 2 )) {
                            output_newline
                        # Else, print such lines.
                        } else {
                            # Length of the long option.
                            option_names_length__pcuo="${#${${option_indentation__pcuo}${option_long__pcuo}}}"

                            # If such option fits on a single line, print the
                            # next line following such option.
                            if (( option_names_length__pcuo <= option_names_width__pcuo )) {
                                output_string\
                                    "${(l:$(( option_names_width__pcuo - ${#${${option_indentation__pcuo}${option_long__pcuo}}} )):):-}${option_text_lines__pcuo[2]-}"

                            #FIXME: This is hardly ideal. Options text lines
                            #should be contiguous, if not necessarily left-
                            #aligned to the same margin. To do so here, print
                            #spaces rather than a newline here followed by a
                            #*PORTION* of the next line. Naturally, this
                            #requires rewrapping the third line and all
                            #subsequent lines of options text, if such lines
                            #exist. Annoying, though certainly feasible. See to it!

                            # Else, print a newline followed by the next line.
                            } else {
                                output_newline
                                output_string\
                                    "${(l:${option_names_width__pcuo}:):-}${option_text_lines__pcuo[2]-}"
                            }

                            # For each additional line of options text that exists,
                            # print full padding followed by such line (as above).
                            for option_text_line__pcuo\
                                (${option_text_lines__pcuo[3,-1]}) {
                                output_string "${(l:${option_names_width__pcuo}:):-}${option_text_line__pcuo}"
                            }
                        }
                    }
                # Else, only a short option was defined.
                } else {
                    # Print sufficient padding followed by all lines of options
                    # text (as above).
                    output_string\
                        "${(l:$(( option_names_width__pcuo - ${#${${option_indentation__pcuo}${option_short__pcuo}}} )):):-}${option_text_lines__pcuo[1]-}"
                    for option_text_line__pcuo (${option_text_lines__pcuo[2,-1]}) {
                        output_string\
                            "${(l:${option_names_width__pcuo}:):-}${option_text_line__pcuo}"
                    }
                }
            # Else, no short option was defined. If only a long option was
            # defined, print such option (as above).
            } elif is -n "${option_long__pcuo}" si {
                output_string_sans_newline\
                    "${option_indentation__pcuo}${option_long_colored__pcuo}"
                option_names_length__pcuo="${#${${option_indentation__pcuo}${option_long__pcuo}}}"

                if (( ${#option_text_line__pcuo} == 0 )) {
                    output_newline
                } else {
                    if (( option_names_length__pcuo <= option_names_width__pcuo )) {
                        output_string\
                            "${(l:$(( option_names_width__pcuo - ${#${${option_indentation__pcuo}${option_long__pcuo}}} )):):-}${option_text_lines__pcuo[1]-}"
                    } else {
                        output_newline
                        output_string\
                            "${(l:${option_names_width__pcuo}:):-}${option_text_lines__pcuo[1]-}"
                    }

                    for option_text_line__pcuo\
                        (${option_text_lines__pcuo[2,-1]}) {
                        output_string\
                            "${(l:${option_names_width__pcuo}:):-}${option_text_line__pcuo}"
                    }
                }
            # Else, no short or long options were defined. Since this
            # constitutes a fatal error, throw an exception.
            } else {
                die "No short or long options defined for current option."
            }
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
        # Sanitize the current terminal in preparation for subsequent output.
#       stop_stdout
        # Update state in preparation for the next printer function.
                #FUXME: If such option exceeds the total width of the options
                #"area", what we do depends. If:
                #
                #* A short option was also defined, then this long option should
                #  reside indented by three characters right on the next line.
                #* Else, the following option description should be shifted to the
                #  next line.
                #
                #Rather different operations, but the resulting effect is...
                #rather pleasing.

#       options_heading__pcuo="$(get_list_head "${options_list_name__pcuo}")"
#       output_newline
#       output_string "${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}${options_heading__pcuo}${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:"

#   option_text_pcre_wrapper__pcuo="$(get_pcre_wrapping_at_line_length\
#       ${option_text_width__pcuo})"

    # Compile such PCRE. See for_string_matches_pcre() for further details.
#   pcre_compile -- "${option_text_pcre_wrapper__pcuo}"

    # Indentation prefixing the option name at the head of each line.
#   string option_indentation__pcuo='  '

                # If such option is prefixed by two optional dashs, remove such
                # dashes before prefixing such option by two mandatory dashes.
#               option_long__pcuo="${option_long__pcuo#--}"

                # Prefix the first optional equals sign and argument in such
                # option with corresponding color styles.
#               option_long_colored__pcuo="${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}${option_long__pcuo}/(#b)=(*)/${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}=${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}${match[1]}}"

                # Prefix such option by two dashes, to simplify logic below.
#               option_long__pcuo="--${option_long__pcuo}"
            #FUXME: After paging to page_stdin(), we no longer need to print the
            #current usage string. (Nice!)
            # Else, no short or long options were defined. Since this
            # constitutes a fatal error, throw an exception.
#           } else {
#               die "no short or long options defined for current option; usage string is:${ZESHY_ASCII_NEWLINE}${usage__pcuo}"

    #FUXME: Rather than appending to ${usage__pcu} here, shouldn't we simply
    #output text as we construct it and page the entire "for" loop via
    #page_stdin()? That would seem to reduce the discernable downtime for the
    #current user, as well as slightly simplify things. Hmm; I suppose we don't
    #really want ${usage_pcu} at all, then! Just wrap the whole function in a
    #"{...} | page_stdin" block (after performing initial exception handling).
    #FUXME: Be sure to use output_string_sans_newline() where appropriate, below!
    # Print such usage paged.
#   page_string "${usage__pcuo}"

#FUXME: Consider splitting into two functions: print_command_usage_overview()
#and print_command_usage_options().

    #FUXME: Excise!
    # Print such usage.
#    print_string "${ZESHY_STYLE_TO_COLOR[print_usage.usage]}Usage${ZESHY_STYLE_TO_COLOR[print_usage.usage_colon]}: ${ZESHY_STYLE_TO_COLOR[print_usage.command_name]}zeshy ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}OPTION${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}... ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}FILE ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}ARGUMENT${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}...${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]
#
#${ZESHY_STYLE_TO_COLOR[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
#as a zeshy zsh shell script passed the passed ARGUMENTs.
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Main options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}i${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}interactive      ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}open an interactive non-login zsh shell
#}
#
#    # Print such usage.
#    print_string "${ZESHY_STYLE_TO_COLOR[print_usage.usage]}Usage${ZESHY_STYLE_TO_COLOR[print_usage.usage_colon]}: ${ZESHY_STYLE_TO_COLOR[print_usage.command_name]}zeshy ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}OPTION${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}... ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}FILE ${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}[${ZESHY_STYLE_TO_COLOR[print_usage.arg_name]}ARGUMENT${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]${ZESHY_STYLE_TO_COLOR[print_usage.arg_ellipsis]}...${ZESHY_STYLE_TO_COLOR[print_usage.arg_brace]}]
#
#${ZESHY_STYLE_TO_COLOR[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
#as a zeshy zsh shell script passed the passed ARGUMENTs.
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Main options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}i${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}interactive      ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}open an interactive non-login zsh shell
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}l${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}login            ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}open an interactive login zsh shell
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}h${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}help             ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}print this help string and exit
#      ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}version          ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}print a version string and exit
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]},  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--                 ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}stop parsing options
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Parameterized options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}c ${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}COMMAND${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]},            ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}run the passed zeshy shell command (e.g., \"is_dir /\")
#     ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}command${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}=${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}COMMAND
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}o ${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}OPTION${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]},             ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}enable the passed zsh shell option (\"man zshoptions\")
#     ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}option${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}=${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}OPTION
#
#${ZESHY_STYLE_TO_COLOR[print_usage.heading_title]}Startup options${ZESHY_STYLE_TO_COLOR[print_usage.heading_colon]}:
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}-${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}v${ZESHY_STYLE_TO_COLOR[print_usage.option_comma]}, ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}verbose          ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}print debug statements during zeshy startup
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}zeshy-dot-dir${ZESHY_STYLE_TO_COLOR[print_usage.option_equals]}=${ZESHY_STYLE_TO_COLOR[print_usage.option_value]}PATH   ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}change zeshy's dot directory (defaults to \"~/.zeshy\")
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}no-zeshy-dot-dir     ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}ignore zeshy's dot directory and files therein; hence,
#                            run zeshy with default settings and no digest file
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}compile-digest       ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}recompile zeshy's digest, even if up-to-date
#  ${ZESHY_STYLE_TO_COLOR[print_usage.option_dash]}--${ZESHY_STYLE_TO_COLOR[print_usage.option_name]}compile-digest-if-zeshy-home-changed
#                         ${ZESHY_STYLE_TO_COLOR[print_usage.option_text]}recompile zeshy's digest if zeshy's codebase changed"

            #FUXME: Excise.
            # Else, no option text was defined. To simplify logic below,
            # initialize such list to only a single newline.
#           } else {
#               option_text_lines__pcu=( "${ZESHY_ASCII_NEWLINE}" )
#           }

                #FUXME: This should dynamically append as much whitespace is
                #required to ensure well-formatted columns. We'll need to get
                #the string length of ${option_short__pcu} sans ANSI colors,
                #then subtract the total width of the options "area" by such
                #length. Shouldn't be terribly hard.
#               usage__pcu+="${option_names__pcu}"

                        # Length of short option only. While such length 
#                       option_names_length__pcu="${#${  ${option_short__pcu},}}"

#See align_string_to_length_right() for
                        # further details.
                    #FUXME: There's a far more efficient way. Just retain the
                    #original unformatted option names! We'll need two new
                    #string locals above. *shrug*
                    # Length of short and long options if (hypothetically)
                    # fitting on a single line. See
                    # get_string_length_printable_sans_ansi() for further
                    # details.
#                   option_names_length__pcu="${#${${option_names__pcu}${option_long__pcu}//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}}}"

#               ="$(get_string_wrapped_at_line_length\
#                   "${option_text__pcu}" ${option_text_width})"
        #FUXME: Actually, we really need a 
        #FUXME: Implement such exception handler.

        #FUXME: Implement such iterator. We'll want to 
#       for_list_items_in_range\
#           "${options_list_name__pcu}" 2 -1\
#           option_short__pcu option_long__pcu option_text__pcu\
#           ''
#       die_unless_list "${options_list_name__pcu}"

        #FUXME: Not right, obviously. Parse such string apart. Actually, just
        #use a series of global string replacements. Should be fairly simple.
#       overview__pcu+=" ${command_args__pcu}"

    # If such map lacks mandatory key-value pairs, throw an exception.
#       'v' 'verbose'           'print optional debug statements'
#       '' 'release'            'switch to zeshy''s optimized digest (default)'
#       '' 'debug'              'switch to zeshy''s developer digest'
