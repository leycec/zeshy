#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle high-level *printer functions* (i.e., functions printing strings, while
maintaining globals tracking standard output state). Such state includes:

* The modification time of standard output at the time of the most recent call
  to a `zeshy` printer function (e.g., print_string()).
* The filename and line number at which such function was defined.
______________<heredoc?>______________

#FIXME: *SWEET*. The existing tracking nomenclature is exceedingly awkward. I
#consequently propose renaming:
#
#* print_whitespace_if_needed()      to handle_stdout_tracking().
#* update_terminal_stdout_tracking() to update_stdout_tracking().
#* reset_terminal_stdout_tracking()  to reset_stdout_tracking().
#
#Remove update_stdout_tracking() and reset_stdout_tracking(). They're just
#overkill; it's not clear such a distinction will ever be useful.

# ....................{ GLOBALS                            }....................
declare_global_with_stdin float ZESHY_STDOUT_PRIOR_MTIME <<'/---'
Modification time of standard output at the time of the most recent call to
update_stdout_tracking() or 0 if such function has yet to be called.
/---

declare_global_with_stdin string ZESHY_STDOUT_PRIOR_SCRIPT_LINE <<'/---'
Unique identifier of the previous runnable (e.g., print_message()) to have most
recently called update_stdout_tracking() or the empty string if such
function has yet to be called. Such identifier is the topmost element of stack
${funcfiletrace} at the time of such call.

`zsh` tracks call stack state with two list globals: ${funcname} and
${funcfiletrace}. Since ${funcname} elements are runnable names, such list
distinguishes between calls to different runnables but _not_ between different
calls to the same runnable. Since ${funcfiletrace} elements are filename and
line pairs signifying a runnable called on such line, such list distinguishes
between all calls and hence subsumes ${funcname} for purposes of uniquely
identifying runnables on the call stack.
/---

# ....................{ RESETTERS                          }....................
#FIXME: To ensure such globals are compiled to zeshy's user digest files in
#their initial empty states, reset_stdout_tracking() should be called as the
#*ABSOLUTELY* last precompile_zeshy() hook function to be called. Arguably, this
#calls for a new hook type:
#
#    function run_hook_before_zeshy_define_startup_functions() { ... }
#
#Like run_hook_on_zeshy_precompile(), such hook must be explicitly handled at the
#top-level by parcel "compile". Such hook is widely useful and will certainly be
#of use elsewhere to (attempt to) ensure that aliases and globals to be compiled
#into startup functions (e.g., startup_zeshy_globals()) are assigned the desired
#initial values.

declare_function_with_stdin <<'/---'
void reset_stdout_tracking(void)

Reset global tracking state for `zeshy` printer functions, including
${ZESHY_STDOUT_PRIOR_MTIME} and ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}. See
update_stdout_tracking() further details.
/---
function reset_stdout_tracking() {
    # Reset such globals.
    die_if_args
    ZESHY_STDOUT_PRIOR_MTIME=0
    ZESHY_STDOUT_PRIOR_SCRIPT_LINE=
}

declare_function_with_stdin <<'/---'
void reset_terminal_stdout_tracking(void)

Reset global tracking state for `zeshy` printer functions _and_ color attributes
for the current terminal to such terminal's defaults, in the correct order. See
reset_terminal_color() and reset_stdout_tracking() for further details.
/---
function reset_terminal_stdout_tracking() {
    # Unlike update_output_state_and_reset_terminal_color(), output state and
    # terminal colors may be reset in either order.
    die_if_args
    reset_terminal_color
    reset_stdout_tracking
}

# ....................{ UPDATERS                           }....................
declare_function_with_stdin <<'/---'
void update_stdout_tracking(void)

Update global tracking state for `zeshy` printer functions, including
${ZESHY_STDOUT_PRIOR_MTIME} and ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}. Such
state assists subsequent calls to print_whitespace_if_needed() in deciding
whether prior output should be delimited from subsequent output with whitespace.
/---
function update_stdout_tracking() {
    # Validate sanity.
    die_if_args
    # When debugging, note that it's not genuinely possible to safely print
    # ${ZESHY_STDOUT_PRIOR_MTIME}. Why? Because merely printing such float
    # changes the return value of get_stdout_mtime(), guaranteeing the next call
    # to print_whitespace_if_needed() to erroneously print whitespace. (Ugh.)
#   output_string "resetting ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2

    # Store the modification time of standard output.
    set_float_to_stdout_mtime ZESHY_STDOUT_PRIOR_MTIME

    # Store the caller name (hopefully, a printer function).
    ZESHY_STDOUT_PRIOR_SCRIPT_LINE="${funcfiletrace[-2]-}"
#   print "resetting ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
}

declare_function_with_stdin <<'/---'
void update_terminal_stdout_tracking(void)

Update global tracking state for `zeshy` printer functions _and_
reset color attributes for the current terminal to such terminal's defaults, in
the correct order. See reset_terminal_color() and update_stdout_tracking() for
further details.
/---
function update_terminal_stdout_tracking() {
    # Reset terminal color *BEFORE* updating output state, as the former
    # necessarily modifies standard output that the latter tests.
    die_if_args
    reset_terminal_color
    update_stdout_tracking
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_whitespace_if_needed(void)

Print whitespace separating subsequent from prior shell output _and_ reset color
attributes for the current terminal to such terminal's defaults. Only print such
whitespace if:

* _All of the following hold_:
** The current shell previously called at least one `zeshy`-specific printer
   function (e.g., print_string(), print_heading()), a prerequisite of the
   condition below.
** The current function was _not_ called directly from the command line (i.e.,
   was called by another function), a prerequisite of the condition below.
** The function calling the current function differs from the most recently
   called printer function. If such functions are the same, their output should
   usually be conjoined rather than separated by whitespace; if such functions
   differ, however, separating their output with whitespace usually improves
   readability and aesthetics.
* _Or_:
** The current modification time of standard output (in seconds since the Unix
   epoch) differs from the previous such time recorded by the most recently
   called printer function, implying that another runnable run at least one
   second before the current call but after the most recently called printer
   function has printed to standard output without calling
   update_stdout_tracking() to update such time. In theory, all runnables
   should update such time after printing to standard output; in practice, the
   ``regulatory burden'' imposed by such a rule guarantees its unlikelihood.
   While this condition fails to detect runnables run in the same second as the
   current call which printed to standard output without updating such time, it
   does reliably detect older such runnables. This condition is a convenience
   fallback and should _not_ be counted upon.
/---
function print_whitespace_if_needed() {
    # Validate sanity.
    die_if_args
#   output_string "funcfiletrace[2]: ${funcfiletrace[2]-}\nZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}"
#   print_call_stack

    # Sanitize the current terminal in preparation for subsequent output,
    # regardless of whether whitespace is subsequently printed.
    reset_terminal_color

    # Prefer an "if"- to "and"-style conditional to avoid returning false.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler).
    #
    # Avoid comparing nonextant variables rather than defaulting such variables
    # to seemingly sane default values (e.g., null). The latter behaves
    # unpredictably. For example, if ${funcfiletrace[2]} is set but
    # ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE} is not, defaulting the latter to a
    # seemingly sane default value erroneously guarantees delimiting whitespace
    # will be printed.
    #
    # Subtleties abound, ribald bald acolytes.
    if is -n "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}" and
        "${funcfiletrace[-2]-$'\0'}" !=\
        "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" si or {
        # Sadly, this is the only reliable means of obtaining such time.
        float stdout_mtime; set_float_to_stdout_mtime stdout_mtime
        (( ${+ZESHY_STDOUT_PRIOR_MTIME} &&
              ZESHY_STDOUT_PRIOR_MTIME != stdout_mtime ))
    } {
#       float stdout_mtime; set_float_to_stdout_mtime stdout_mtime; output_string "funcfiletrace[-2]: ${funcfiletrace[-2]-}; ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}; ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}; stdout_mtime: ${stdout_mtime}" 1>&2
        output_newline
    }
}

# ....................{ PRINTERS ~ newline                 }....................
#FIXME: What the heck is this? I fail to see any demonstrable benefit here. In
#fact, this function *SHOULD* be calling print_whitespace_if_needed() to serve
#as a genuine printer function, in which case the implementation makes utterly
#no sense. Replace all instances of this function will output_newline().
declare_function_with_stdin <<'/---'
string print_newline(void)

Print a blank line to standard output.
/---
function print_newline() {
    die_if_args
    output_newline
    update_stdout_tracking
}

# ....................{ PRINTERS ~ stdin                   }....................
#FIXME: This function actually called anywhere? Not terribly sure of the point
#of this function, honestly. Replace with get_stdin() or output_stdin(), ideally.
declare_function_with_stdin <<'/---'
string print_stdin[stdin: string input]

Get standard input piped to the current shell. Since subshells do not inherit
piped input, avoid calling this function from subshells (e.g., as
`$(get_stdin_piped)`). Consider calling is_stdin_nonempty() before this function
to ensure such input exists: e.g.,

.print_stdin()
==========================================
[source]
------------------------------------------
>>> 
>>> function pachamama() {
...     if { is_stdin_nonempty } {
...         print_stdin
...     } else {
...         print_string "${@}"
...     }
... }
>>> print_string tawantinsuyu | pachamama
tawantinsuyu
>>> pachamama tawantinsuyu
tawantinsuyu
------------------------------------------
==========================================
/---
function print_stdin() {
    # Validate sanity.
    die_if_args
    die_if_stdin_empty

    # Print such input.
    get_stdin

    # Close such input, ensuring is_stdin_nonempty() subsequently returns false.
    close_stdin

    # Store printer function globals, if needed.
    update_stdout_tracking
}

# ....................{ PRINTERS                           }....................
# No print_string*() functions call prepend_args_with_stdin_if_piped(),
# as doing so often invites obscene issues. When called by a caller receiving
# piped input, print_string*() functions silently capturing and closing such
# input before the caller can do so break such caller in subtle and *VERY*
# difficult to debug ways. Moreover, there are no to few reasonable scenarios in
# which print_string*() functions would be piped rather than merely passed input
# strings. For straightforward safety, avoid inviting such wayward breakage.

declare_function_with_stdin <<'/---'
string print_string(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline.
Unlike low-level builtins echo() and print(), this and most other printer
functions print embedded escape sequences as is rather than converting such
sequences to the corresponding characters. Such conversions often mangle
arbitrary output and hence are generally unhelpful. See
print_string_with_escapes() for further details.

Avoid calling such low-level builtins, which behave unexpectedly dangerously
when passed hyphen-prefixed strings: e.g.,

.print_string() versus print()
==========================================
[source]
------------------------------------------
>>> string lammoth="-z" morgoth="rm -rf *"

# Bad! Never do this, unless guaranteed no hyphens prefix such string.
# If hyphens do prefix such string, zsh treats the first word of such
# string as options to print(). This can be extremely unsafe, as this
# example demonstrates.
>>> print "${lammoth}" "${morgoth}"
>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

# Good. Always do this, instead.
>>> print_string "${lammoth}" "${morgoth}"
-z rm -rf *    # That's more like it.
------------------------------------------
==========================================
/---
function print_string() {
    die_unless_args 'expected at least one string'
    output_string "${*}"
    update_stdout_tracking
}

#FIXME: Unconvinced this to be a helpful function. Certainly, the name is not
#helpful at all. Grep the codebase for where this is actually called from.
declare_function_with_stdin <<'/---'
string curse_string(string text1, string text2, ...)

Print the passed strings to standard error with default trailing newline. See
print_string() for further details.
/---
function curse_string() {
    die_unless_args 'expected at least one string'
    output_string "${*}" 1>&2
    update_stdout_tracking
}

# ....................{ PRINTERS ~ string                  }....................
#FIXME: Given the current implementation, this function name's a bit of a
#misnomer. Rename to... what? I mean, ideally, shouldn't *THIS* function become
#the new print_string() and the existing print_string() and curse_string()
#functions simply excised? I reckon that's probably the way forward -- but to
#get there, we'll need to make darn sure that most existing calls to
#print_string() be renamed to return_string() instead.

declare_function_with_stdin <<'/---'
string print_string_colored(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) to standard output
suffixed by a newline while handling and tracking state for standard output.
Specifically:

. Reset color attributes for the current terminal to such terminal's defaults.
. Print whitespace delimiting the passed strings from prior terminal output,
  if the global tracking state for standard output indicates such output. See
  print_whitespace_if_needed() for further details.
. Print such strings in **raw mode** (i.e., printing embedded escape sequences
  such as `\n` as is rather than converting such sequences to the corresponding
  characters). See output_string() for further details.
. Update global tracking state for standard output. See
  update_terminal_stdout_tracking() for further details.
. Reset color attributes for the current terminal again.

== Comparison ==

Unlike low-level general-purpose output aliases (e.g., output_string()) and
builtins (e.g., echo(), print()) intended to be called by any script or
function, this function is intended to be called only by high-level printer
functions (e.g., print_message()). While such aliases are generally helpful,
avoid calling such builtins, which often behave unsafely (e.g., when passed
hyphen-prefixed strings): e.g.,

.print_string() versus print()
==========================================
[source]
------------------------------------------
>>> string lammoth="-z" morgoth="rm -rf *"

# Bad! Never do this, unless guaranteed no hyphens prefix such string.
# If hyphens do prefix such string, zsh treats the first word of such
# string as options to print(). This can be extremely unsafe, as this
# example demonstrates.
>>> print "${lammoth}" "${morgoth}"
>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

# Good. Always do this, instead.
>>> print_string "${lammoth}" "${morgoth}"
-z rm -rf *    # That's more like it.
------------------------------------------
==========================================
/---
function print_string_colored() {
    # Handle previously updated standard output tracking.
    print_whitespace_if_needed

    # Print such string.
    output_string "${*}"

    # Update standard output tracking in preparation for subsequent handling.
    update_terminal_stdout_tracking
}

declare_function_with_stdin <<'/---'
string print_string_sans_newline(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) to standard output
suffixed by no newline while handling and tracking state for standard output.
See print_string() for further details.
/---
function print_string_sans_newline() {
    # Handle previously updated standard output tracking.
    print_whitespace_if_needed

    # Print such string sans newline suffix.
    output_string_sans_newline "${*}"

    # Update standard output tracking in preparation for subsequent handling.
    update_terminal_stdout_tracking
}

# --------------------( WASTELANDS                         )--------------------
    # Validate passed arguments.
#   die_unless_args 'expected at least one string'

#declare_function_with_stdin <<'/---'
#string print_string(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline.
#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,
#
#.print_string() versus print()
#==========================================
#[source]
#------------------------------------------
#>>> string lammoth="-z" morgoth="rm -rf *"
#
## Bad! Never do this, unless guaranteed no hyphens prefix such string.
## If hyphens do prefix such string, zsh treats the first word of such
## string as options to print(). This can be extremely unsafe, as this
## example demonstrates.
#>>> print "${lammoth}" "${morgoth}"
#>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!
#
## Good. Always do this, instead.
#>>> print_string "${lammoth}" "${morgoth}"
#-z rm -rf *    # That's more like it.
#------------------------------------------
#==========================================
#/---
#function print_string() {
#    die_unless_args 'expected at least one string'
#    output_string "${*}"
#    update_stdout_tracking
#}


#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,

#Unlike such low-level
#aliases and builtins, this function:
# subject to the conditions of print_whitespace_if_needed().
#suffixed by a newline in a color-aware manner. Prefix and suffix such output
#with ANSI color codes resetting color attributes to terminal-specific defaults.

    #FUXME: It'd be far more symmetric to simply call
    #reset_terminal_stdout_tracking() here, which incidentally would probably
    #also simplify caller logic. Grep where this function is used and see
    #whether or not all calls to this function are preceded by
    #print_whitespace_if_needed() (as I suspect they are). Since that function
    #already calls reset_terminal_color() internally, we can *GREATLY* simplify
    #such logic by simply shifting all such calls to
    #print_whitespace_if_needed() into this function right here, replacing
    #reset_terminal_color() here with a call to such function.

#FUXME: Is this function still called anywhere? The implementation is rather
#ungainly and, arguably, erroneous by design.
#declare_function_with_stdin <<'/---'
#string print_string_sans_newline(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#without trailing newline. See print_string() for further details.
#/---
#function print_string_sans_newline() {
    # Validate passed arguments.
#   die_unless_args 'expected at least one string'
#   string text="${*}"

    # Print such string unnewlined.
#   output_string_sans_newline "${text}"

    #FUXME: This is patently nonsense, now that we test the mtime of
    #"/dev/stdout" with nanosecond resolution. Indeed, it would be safer to
    #*ALWAYS* call update_stdout_tracking(), which updates the last
    #recorded mtime of "/dev/stdout". But, honestly, this function just doesn't
    #work, because ${ZESHY_OUTPUT_STATE_RUNNABLE_ID} will be this function if
    #we call update_stdout_tracking(), guaranteeing the next call to
    #print_whitespace_if_needed() will simply *ALWAYS* print such whitespace,
    #which is the opposite effect of what we want.
    #FUXME: We could introduce a new global set by this function and tested by
    #print_whitespace_if_needed() to avoid such complexities; but, really, this
    #is all *EXTREME* overkill. Excise this function, I should think.

    # Unlike output printed by most printer functions, output printed by this
    # function can conceivably be the empty string. In such case, to avoid
    # printing an unwanted newline on the next call to a printer function, the
    # call stack root must not be reset. Since strings consisting of only ANSI
    # color codes are effectively the empty string, test for emptiness after
    # excluding such codes.
#   if (( $(get_string_length_printable_sans_ansi_colors "${text}") )) {
#       print -r "string \"${text}\" length: $(get_string_length_printable_sans_ansi_colors "${text}")"
#       update_stdout_tracking
#   }
#}

#FUXME: O.K.; we need to manually sift through the codebase and change all
#current calls to print_string() for purposes of returning values to
#return_string() instead. The former now performs additional logic conflicting
#with mere value returning; the latter does not. Unavoidable, I'm afraid. As a
#positive bonus, however, the codebase will be moderately more readable.

#FUXME: Should probably be initialized to 0 and the global below to "" when
#serialized into zeshy's user digest file. Unsure how to reliably accomplish
#that. Perhaps perform such initialization in a *VERY* late precompilation hook
#function? Alternately, we should probably just have a list global declared at
#the "src/compile" level of the names of all globals to be initialized to "="
#(i.e., the empty string) immediately before compilation into the digest. This
#is necessary for all globals tracking transient state and hence likely to be
#useful elsewhere in the future.

# (( ${+ZESHY_STDOUT_PRIOR_MTIME} == 0 )) or {
#${+ZESHY_STDOUT_PRIOR_MTIME} == 0 ||
#       ${ZESHY_STDOUT_PRIOR_MTIME-0} &&

    #FUXME: Hyphens are also acceptable delimiters, yes?
    #FUXME: We should probably preserve newlines, yes?

#       print_newline
#      (( ${ZESHY_STDOUT_PRIOR_MTIME-0} &&\
#           ZESHY_STDOUT_PRIOR_MTIME != $(get_stdout_mtime) )) {
    #FUXME: O.K.; I've hunted down why this doesn't work as advertised. It's
    #exceptionally subtle but certainly solvable. Basically, it boils down to
    #get_stdout_mtime(): it's an inherently stupid function, because getters are
    #only ever called as process substitutions, which in this case always
    #returns the stdout of the subshell (a pipe!) rather than the stdout of the
    #current shell (typically, a pseudo-terminal). We need to *EXCISE*
    #get_stdout_mtime() and make a new alias set_float_to_stdout_mtime():
    #
    #alias set_float_to_stdout_mtime='{
    #   # Do the typical thing here, getting all of stdin into a single local
    #   # variable named:
    #   string float_name__sftso
    #   die_unless_variable_float "${float_name__sftso}"
    #
    #   # Resolve "/dev/fd/1" to a non-symbolic absolute path. Assuming the
    #   # current shell to be a pseudo-terminal, "/dev/fd/1" is typically a
    #   # symbolic link to the device for such terminal (e.g., "/dev/pts/7").
    #   # Referring to standard output by such resolved rather than symbolic
    #   # path is essential; we run the command getting standard output's mtime
    #   # from a process substitution in which symbolic path "/dev/fd/1" refers
    #   # to a shell pipe rather than the desired pseudo-terminal.
    #   #
    #   # Sadly, the only safe means of resolving such path is as below.
    #   # Replacing the first pipeline subcommand with a call to
    #   # canonicalize_path() uselessly returns "/dev/fd/1" without resolving
    #   # such path. Likewise, replacing the second pipeline subcommand with a
    #   # process substitution has the same effect. (My inveterate Gods, but
    #   # this is subtle.)
    #   string stdout_filename__sftso
    #   output_string "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}"(:A) |
    #       set_string_to_stdin stdout_filename__sftso
    #
    #   # Set such float to such path's mtime. See set_float_to_float() for
    #   # further details.
    #   get_path_mtime "${stdout_filename__sftso}" |
    #       set_float_to_stdin "${float_name__sftso}"
    #} <<<'
    #
    #Craziness, but it works. Shift to "05-alias/io/standard". *shakes head*
    #FUXME: We need to add a new set_float_to_stdin() to "always/io/standard",
    #which then requires a new set_float_to_float() in
    #"always/variable/float/float". It's all trivial -- just needs to be done!
    #FUXME: Alternatively, we could just make a new
    #set_variable_to_stdin() function. It's not to have the strict typing of
    #set_string_to_stdin() elsewhere, but it's really just an inefficiency here.
    #Then, we could just call set_scalar_to_stdin() above twice. Hmmm...
    #actually, that gains us effectively nothing. There are *ONLY* three scalar
    #types, so we'd might as well support them all type-safely. Honestly, any
    #inefficiency here is minor compared to the weight of zeshy as a whole.
    #O.K.; go with the original plan above!
    # When debugging, note that it's not genuinely possible to print
    # ${ZESHY_STDOUT_PRIOR_MTIME}. Why? Because merely printing

#   output_string "resetting ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
#   output_string "resetting ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}; ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
    #FUXME: Sadly, we need to drop the ${ZESHY_STDOUT_PRIOR_MTIME} testing.
    #Why? Because, with a coarse granularity of only seconds, this function
    #effectively reduces to a random number generator: sometimes it prints
    #delimiting whitespace as expected, sometimes it doesn't. This is terrible.
    #However, document the current solution for posterity.
    #FUXME: *WAIT*. Any kernel worth running zsh on should support nanosecond-
    #resolution mtimes; see:
    #  http://stackoverflow.com/questions/7206014/get-a-nanosecond-precise-atime-mtime-ctime-fields-for-file-stat
    #
    #zsh appears to have integrated a patch; see:
    #  http://www.zsh.org/mla/workers/2007/msg00972.html
    #FUXME: Ah-ha! While zsh currently supplies no means of retrieving
    #nanosecond-resolution times via zstat(), the system-specific stat() command
    #does *IF* passed option "-c '%y====%Y'": e.g.,
    #
    #  >>> stat --dereference --printf '%y\0%Y' /dev/fd/1
    #  2013-05-22 19:39:01.436503138 -04001369265941
    #
    #Awesome, no? We'll need to parse the actual nanosecond mtime back together
    #from such string. For the above, for example, such mtime is:
    #
    #  1369265941.436503138
    #
    #By saving such value to a float, "viola!" Nanosecond-resolution times.
    #FUXME: Since the output of "-c '%y'" is system- and user-specific, we
    #should simply round such time to the nearest integer if it fails to match
    #the above specification: e.g.,
    #
    #  1369265941.0

    #FUXME: We should be using the test operator "-om" in place of...
    # Ensure each tested variable exists before testing such
    # variable's
    # To avoid returning success when both string variables are
    # undefined, default undefined string variables to a value that zsh
    # operation guarantees such variables to *NEVER* be set to (i.e., null).
    #
    # Subtleties abound, ribald bald acolytes.
#   if is "${funcfiletrace[2]-$'\0'}" !=\
#         "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-$'\0'}" si or

#-n "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}" and
#       "${#funcfiletrace}" -ge 2 and
#
#${+ZESHY_STDOUT_PRIOR_MTIME} &&\
#FUXME: Excise everywhere, shifting documentation above where applicable. I
#recall only referencing this global in this component. Check on that...
#declare_global_with_stdin <<'/---'
#string ZESHY_PRINT_CALL_STACK_ROOT
#
#Most recent call stack root to have called a high-level print function (e.g.,
#print_message(), print_warning()) or the empty string if no such function has
#been called, where "call stack root" is the first zsh function, script, or
#command line to have initiated the current call stack.
#
#Specifically, this string is the first element of list global ${funcfiletrace}
#at the time of the most recent call to a high-level print function as recorded
#by print_whitespace_if_needed(). zsh tracks call stack state with
#two list globals: ${funcname} and ${funcfiletrace}. The former distinguishes
#between calls to different functions and scripts but *NOT* between different
#calls to the same function or script or between different command lines. The
#latter distinguishes between all such calls, hence subsuming the former. Given
#only a filename and line, inspecting such line usually furnishes the function
#name called on such line. Therefore, each element of ${funcfiletrace} uniquely
#identifies the corresponding call in the call stack. Since the first element of
#such list corresponds to the caller responsible for initiating the entire call
#stack, such element effectively differentiates such stack from subsequent call
#stacks initiated by other callers.
#
#See print_whitespace_if_needed() for further details.
#/---
#
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., print_string()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#print_whitespace_if_needed() should thus print a delimiting newline.
#If standard output for the current shell is attached to a terminal, set the
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., print_string()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#print_whitespace_if_needed() should thus print a delimiting newline.
#      (( ZESHY_STDOUT_PRIOR_MTIME )) and
    #FUXME: Convert to an "if" statement and attempt to remove the trailing
    #return_true().

    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
    #
    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler). Subtleties abound, dear acolytes.
#   print "printing newline if equals: ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT-}; funcfiletrace[-1]: ${funcfiletrace[-1]}" 1>&2; print_call_stack 1>&2
#   is "${ZESHY_PRINT_CALL_STACK_ROOT-}" == "${funcfiletrace[-1]}" si and
#       print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    # Succeed regardless of whether such newline was printed.
#   return_true
# the following conditions all hold 
    #FUXME: This isn't quite right, and one can readily see why when
    #uncommenting the print() statement below: a granularity of seconds is
    #simply too low to reliably detect changes. Ideally, "mtime" would be
    #recorded in milli- or nanoseconds. Since it isn't, another approach is
    #required. 

#FUXME: Adjust the conditions under which a newline is printed to the following:
#
#* If ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE} is unequal to the currently called printer
#  function name (e.g., "print_message"),
#* If ${ZESHY_STDOUT_PRIOR_MTIME} is non-empty (or non-zero, if we
#  decide to use an integer as we probably should) *AND* unequal to the
#  current mtime for "/dev/fd/1" *AND*
#* Then and only then print a newline.
#See 
#Print a blank line to standard output if at least one Zeshy print function has
#already been called under the current call stack root (i.e., called either by
#such root or by a function or script transitively called by such root). This
#function is typically called by high-level Zeshy print functions (e.g.,
#print_message()) to print a newline delimiting subsequent from previous output.
#See ${ZESHY_PRINT_CALL_STACK_ROOT} for further details.
    # * Standard output for the current shell is attached to either a terminal
    #   or pipe (e.g., page_stdin()) (thus avoiding printing a newline when
    #   ,
    #if { is_stdout_terminal_or_pipe } and
#FUXME: Rename to update_printer_globals(). Hmm, perhaps
#update_stdout_tracking() or set_last_print_globals()?
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_STDOUT_MTIME.
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_NAME.
#FUXME: Do we actually call this anywhere? And if so, why? All such calls
#should probably simply be expanding output_string_sans_newline(). Grep the
#codebase.
    # Succeed regardless of whether such root was reset.
#   return_true
# (e.g., newlines, nulls, strings, lists).
# ....................{ PRINTERS ~ separated               }....................
#FUXME: Such functions should internally depend on new functions of new
#component "variable/string/separate", which actually perform the calling of
#builtin print(). Consider function names:
#
#* concatenate_strings() or unseparate_strings(). Probably the former; the
#  latter is simply odd. Right. Every language needs a concatenate function,
#  so... this is ours!
#* separate_strings_with_newline() or delimit_strings_by_newline(). The former.
#* separate_strings_with_null().
#FUXME: Rename this function to print_strings_concatenated().
#declare_function_with_stdin <<'/---'
#string print_strings_unseparated(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline and
#_not_ internally delimited by ${IFS}, the internal field separator: e.g.,
#
#.print_strings_unseparated()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_unseparated "Where Alph," "the sacred river," "ran"
#Where Alph,the sacred river,ran
#------------------------------------------
#==========================================
#/---
#function print_strings_unseparated() {
#    # Temporarily set global string ${IFS} to the empty string. Since zsh
#    # implicitly delimits lists interpolated with the "*" operator when double-
#    # quoted with such global, the following commands print the passed arguments
#    # undelimited. This incantation was astonishingly difficult to discover.
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}"  # if not double-quoted, zsh oddly ignores ${IFS}
#    update_stdout_tracking
#}

#declare_function_with_stdin <<'/---'
#string print_strings_newlined(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited by newlines: e.g.,
#
#.print_strings_newlined()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_newlined sludge elf transmuter
#sludge
#elf
#transmuter
#------------------------------------------
#==========================================
#/---
#function print_strings_newlined() {
#    die_unless_args 'expected at least one string'
#    print -lr -- "${@}"
#    update_stdout_tracking
#}
#
#declare_function_with_stdin <<'/---'
#string print_strings_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
#
#.print_strings_nulled()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_nulled "Through caverns" "measureless to" "man"
#Through caverns\0measureless to\0man
#------------------------------------------
#==========================================
#/---
#function print_strings_nulled() {
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}"
#    update_stdout_tracking
#}

#       ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#       print "resetting ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT}" 1>&2; print_call_stack 1>&2
    # Succeed regardless of whether such root was set.
#   return_true
    # If standard output for the current shell is attached to either a terminal
    # or pipe (e.g., page_stdin()), store such globals.
    #
    # Prefer an "if"- to "and"-style conditional to avoid returning false.
#   if { is_stdout_terminal_or_pipe } {

#FUXME: Rename to print_strings_unseparated() or print_strings_undelimited()?
#Yes, I rather like the latter. Though, the former is a bit more readable...
#FUXME: Rename to print_string_unnewlined() or perhaps simply
#output_string_sans_newline(). Yeah; the latter is pretty sweet.
#Print the passed strings to standard output without delimitation:
#FUXME: Hmm; this should really be called print_string_with_escapes(). Function
#name print_string_with_escapes() implies something completely different (i.e., that
#all shell-reserved characters will be printed escaped).

# common escapes escaped (i.e., converted to the corresponding characters):
# Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
# Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
# (i.e., such that a newline separates each such string from the next)
    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
#   if is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}"
#   then print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    #FUXME: This is now redundant, as the subsequent print_string_colored()
    #function sets this.

    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required. Instead, replace the previously recorded
    # call stack root with the current.
#   else ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#   fi

#Prefix the next string to be output with whitespace delimiting such string from
#previously output strings if at least one such string has already been output
#under the current call stack root. This function manages string global
#${ZESHY_PRINT_CALL_STACK_ROOT} on behalf of the caller, usually a high-level
#print function (e.g., print_message(), print_header()).
#
#FUXME: A bit unintuitive. Not sure either is terribly better, but how about
#renaming to print_string_no_newline() or print_string_newlineless() or
#output_string_sans_newline(). The latter coincides with print_strings_unseparated()
#and thus strikes me as the best bet.
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    print_message "${*}" | output_string_sans_newline
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   output_string_sans_newline "$(print_message "${*}")"
#   output_string_sans_newline "$(print_warning "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#declare_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_with_escapes().
#'
#function curse_string_escaped() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#declare_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, zsh oddly ignores ${IFS}
#}

#declare_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#declare_function '
#void curse_newline(void)
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to output_string_sans_newline(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#declare_function '
#void curse_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#declare_function '
#string print_string_colored_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See print_string_colored() for further details.
#'
#function print_string_colored_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   print_warning -> print_warning      curse_string -> outcry
#   print_message -> print_message      print_string -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
