#!/usr/bin/env zsh
# ====================[ heading                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle heading output (i.e., output split into topically related sections
# prefixed by a heading describing such section).

# ....................{ PRINTERS                           }....................
document_function '
string say_heading(string text1, string text2, ...)

Print the passed strings as a heading.
'
function say_heading() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string heading="${*}"

    # Relevant integer lengths.
    integer terminal_width heading_length
    terminal_width="$(get_terminal_width)"
    heading_length="$(get_string_length "${heading}")"

    # Number of characters preceding such heading, when centering such heading
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures when the
    # terminal width and heading length are of differing parity that the heading
    # will be offset to the left one character from the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    integer west_character_count; west_character_count=$((\
        (${terminal_width} - ${heading_length}) / 2 ))

    #FIXME: It'd be great to eventually support the subdivision of the border
    #into appropriate subsections: e.g.,
    #
    #     ====~~~-{ heading }--~~~===
    #
    #The principal annoyance there, of course, is that for each possible
    #subdivision you add, you have to add the corresponding number of
    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
    #concoct a single governing equation determining how many characters of each
    #subdivision to print, even in edge cases of small terminal lines: e.g.,
    #
    #     ~-{ heading }-~

    # If such number is at least 2, such heading is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such heading remain for a border. Since this suffices for simple
    # ANSI art, print such heading preceded by a colorfully aesthetic border.
    if (( west_character_count >= 2 )); then
        # Number of border characters (e.g., "-") preceding and succeeding such
        # heading, respectively. Such numbers are always nonnegative (>= 0).
        integer west_outline_count east_outline_count
        (( west_outline_count = east_outline_count = west_character_count - 2 ))

        # If such heading length and terminal width have different parity (i.e.,
        # one is even and the other odd), 1 additional character of space to the
        # right of such heading remains for a border; allocate such space!
        is_integer_parity_equals ${terminal_width} ${heading_length} or
            east_outline_count+=1

        # Border characters (e.g., "-") preceding and succeeding such heading.
        string west_outline east_outline
        west_outline="$(repeat_string '-' ${west_outline_count})"
        east_outline="$(repeat_string '-' ${east_outline_count})"

        # Border colors.
        string\
            color_outline="${ZESHY_COLOR[grey]}"\
            color_divider="${ZESHY_COLOR_BOLD[green]}"\
            color_heading="${ZESHY_COLOR[green]}"

        # Print such heading.
        print_string\
            "${color_outline}${west_outline}${color_divider}{ ${color_heading}${heading} ${color_divider}}${color_outline}${east_outline}"
    # If such number is 1, such heading's length is either 2 or 3 characters
    # less than such width. Hence, 1 character to the left of and either 1 or 2
    # characters to the right of such heading remain for a border. This isn't
    # terribly much. In the absence of anything better to do, print such heading
    # offset from the beginning of the terminal line by 1 character.
    elif (( west_character_count == 1 ))
    then print_string " ${heading}"
    # Else such number is nonpositive (i.e., less than or equal to 0).
    #
    # If such number is negative, such heading exceeds such terminal in length.
    # In the absence of anything better to do, print such heading as is. While
    # this guarantees such heading to wrap around at least once, truncating such
    # heading to the current terminal width often produces worse results.
    #
    # If such number is 0, such heading's length is either the terminal width or
    # one character less than such width. In the former case, no space remains
    # for a border; in the latter case, only one character of space remains,
    # hardly enough for even delimiting whitespace. In the absence of anything
    # better to do, again print such heading as is.
    #
    # For efficiency, unify the above two cases.
    else  # guard condition:  elif (( prior_character_count <= 0 ))
        print_string "${heading}"
    fi
}

# ....................{ PRINTERS ~ sections                }....................
#FIXME: Admit it: this is pretty sucky output. Let's prettify this, please! Try
#calling output() rather than say() with output resembling:
#
#=====================[ output                             ]====================
#
#Clearly, the output should scale with terminal width. If terminal width is too
#small (say, <= 20), forego the desired heuristic and just output the passed
#section. Hmm... or not? Let's not edge case, for now. Just assume everything
#works. 8) O.K.; here we go:
#
#* Divide terminal width by 4, apportioning the left and right banners each 1/4
#  the width and the middle section 2/4 (1/2) the width.
#* Don't worry about centering output. We'd rather columns line up vertically.
#* And...that's it, really. Shouldn't be too cumbersome, nay? The slightly hard
#  part is ensuring that, if the terminal width is not cleanly divisible by 4:
#  * Round all divisions *DOWN*, for safety.
#  * Add the difference of the terminal width and the summation of the three
#    widths (i.e., left banner, right banner, section header) back to the
#    section header. That should do us right, no?
#* Naturally, it'd be nice to colorify this, too. All things come.
#FIXME: Print the actual headings with print_banner_titled(), as discussed in
#the "output" component.

#FIXME: Eliminate the distinction between say_first_section() and
#say_next_section() by replacing such functions with a single
#say_heading() function. This function internally retains the name of the last
#function that called this function (e.g., with a global string
#${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}). If such name is empty or different
#than the current function that called this function, print a first section
#heading; otherwise, print a next section heading. In either case, cache the
#current caller function name for use in the next call to this function. Pretty
#simple, actually.
#Ah, wait; that's not *quite* right. We actually need to search up the callstack
#for ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}; it's not enough to just assume
#that if the function directly calling this function differs, then we're in a
#new logical block of headings. Anyway, not terribly difficult. Be fun to write
#some callstack search routines, eh?
#Ah! Wait. Yes, we could implement such implicit searching, but it seems
#increasingly error-prone. Instead, the function prototype should resemble:
#
# string say_heading(
#   string heading, string heading_group = "$(get_caller_function_name)")
#
#Implement get_caller_name() as a function (not alias!) looking two up on the
#caller stack. This should work without error if the caller is in fact a global
#script; just return the script name, for example.
#
#The heading group is an arbitrary name distinguishing this "group" of headings
#from other such groups, defaulting to the caller name. Callers performing
#complex logic should pass a different heading group... Hmm. This is all well
#and good, but perhaps we should provide additional functions, as well:
#
# string set_heading_group(string heading_group = "$(get_caller_function_name)")
# string unset_heading_group()
#
#These set a global string ${ZESHY_HEADING_GROUP}. Then, slightly change
#say_heading() to:
#
# string say_heading(
#   string heading,
#   string heading_group = "${ZESHY_HEADING_GROUP:-$(get_caller_function_name)}")
#
#say_heading() then internally compares the passed heading_group (with the above
#default) to its cached ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME} (which should
#probably be ${ZESHY_HEADING_GROUP_PRIOR}). If different... well, you know the game.
#
#Sweet. That seems just right. Simple functions can just call say_heading() with
#one argument without needing to call set_heading_group() or
#unset_heading_group(). More complex functions can just call say_heading() with
#two arguments. And truly complex groups of functions can call set_heading_group()
#prior to calling say_heading() with one argument prior to calling
#unset_heading_group().
#
#Hmmm; set_heading_group() and unset_heading_group() might cause too many head-
#aches, hmm? Just calling say_heading() with two arguments should suffice for
#an initial implementation, no? Ah; wait. We really just need the following:
#
# string say_heading(string heading)
# string set_heading_group(string heading_group = "$(get_caller_function_name)")
# string unset_heading_group()
#
#Tada! Flash. Crash. Bamb.

document_function '
string say_first_section(string header1, string header2, ...)

Print the passed strings as the header of a section (i.e., a contiguous block
of related output). Sections demarcate print_string into logical blocks, each
preceded by a terse header synopsizing such block. To ensure aesthetic output,
call this function *ONLY* on the first such section and say_next_section()
on all remaining sections.
'
function say_first_section() {
    say "[${@}]"
}

document_function '
string say_first_section(string header1, string header2, ...)

Print the passed strings as the header of any section other than the first.
'
function say_next_section() {
    print_newline
    say_first_section "${@}"
}

# --------------------( WASTELANDS                        )--------------------
#           color_outline="${ZESHY_COLOR[blue]}"\
#           color_outline="${ZESHY_COLOR[grey]}"\
#           color_divider="${ZESHY_COLOR_BOLD[grey]}"\
#           print_string "incremented right border to ${east_outline_count} characters"
