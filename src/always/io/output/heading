#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_with_stdin <<'______________<heredoc?>______________'
Handle high-level functions printing headings.
______________<heredoc?>______________

# ....................{ PRINTERS ~ hard rule               }....................
#FIXME: Not necessarily the best parcel for such function, as it's a tad lower-
#level.
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_hard_rule(void)

Print a hard rule (i.e., horizontal line) to standard output.
________________<heredoc?>________________
function print_hard_rule() {
    # Validate sanity.
    die_if_args
    string hard_rule
    character character_hard_rule

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
    if { is_encoding_utf8 } {
        character_hard_rule='═'
    } else {
        character_hard_rule='='
    }

    # Print such rule.
    hard_rule="$(repeat_string "${character_hard_rule}" $(get_terminal_width))"
    print_string_colored "${ZESHY_COLOR_STYLE[print_hard_rule]}${hard_rule}"
}

# ....................{ PRINTERS ~ heading                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_heading(string heading1 = "", string heading2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard output as a section heading.
See print_message() for further details.
________________<heredoc?>________________
function print_heading() {
    # Heading to be printed, concatenated from passed arguments.
    string heading="${*}"

    # If the current call stack has already called a high-level print function,
    # print delimiting whitespace.
    print_newline_if_call_stack_root_same

    # Lengths of the current terminal and heading. The latter excludes non-
    # printable characters, including ANSI color escapes.
    integer terminal_width heading_length
    terminal_width="$(get_terminal_width)"
    heading_length="$(get_string_length_printable_sans_ansi_colors\
        "${heading}")"

    # Number of characters preceding such heading, when centering such heading
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures when the
    # terminal width and heading length are of differing parity that the heading
    # will be offset to the left one character from the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    integer character_count_left; character_count_left=$((\
        (${terminal_width} - ${heading_length}) / 2 ))

    #FIXME: It'd be great to eventually support the subdivision of the border
    #into appropriate subsections: e.g.,
    #
    #     ====~~~-{ heading }--~~~===
    #
    #The principal annoyance there, of course, is that for each possible
    #subdivision you add, you have to add the corresponding number of
    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
    #concoct a single governing equation determining how many characters of each
    #subdivision to print, even in edge cases of small terminal lines: e.g.,
    #
    #     ~-{ heading }-~

    # If such number is at least 2, such heading is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such heading remain for a border. Since this suffices for simple
    # ANSI art, print such heading preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
    if (( character_count_left >= 2 )) {
        # Number of border characters (e.g., "-") preceding and succeeding such
        # heading, respectively. Such numbers are always nonnegative (>= 0).
        integer border_count_left border_count_right
        (( border_count_left = border_count_right = character_count_left - 2 ))

        # If such heading length and terminal width have different parity (i.e.,
        # one is even and the other odd), 1 additional character of space to the
        # right of such heading remains for a border; allocate such space!
        is_integer_parity_equals ${terminal_width} ${heading_length} or
            border_count_right+=1

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" heading
        #   titles to adjacent borders).
        character\
            character_border\
            character_joiner_left='{ '\
            character_joiner_right=' }'

        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
        if { is_encoding_utf8 } {
            character_border='─'
        } else {
            character_border='-'
        }

        # Left and right borders consisting of such characters.
        string left_border right_border
        left_border="$( repeat_string "${character_border}" ${border_count_left})"
        right_border="$(repeat_string "${character_border}" ${border_count_right})"

        # Print such heading.
        print_string_colored\
            "${ZESHY_COLOR_STYLE[print_heading.border]}${left_border}${ZESHY_COLOR_STYLE[print_heading.joiner]}${character_joiner_left}${ZESHY_COLOR_STYLE[print_heading.heading]}${heading}${ZESHY_COLOR_STYLE[print_heading.joiner]}${character_joiner_right}${ZESHY_COLOR_STYLE[print_heading.border]}${right_border}"
    # If such number is 1, such heading's length is either 2 or 3 characters
    # less than such width. Hence, 1 character to the left of and either 1 or 2
    # characters to the right of such heading remain for a border. This isn't
    # terribly much. In the absence of anything better to do, print such heading
    # offset from the beginning of the terminal line by 1 character.
    } elif (( character_count_left == 1 )) {
        print_string " ${heading}"
    # Else such number is nonpositive (i.e., less than or equal to 0).
    #
    # If such number is negative, such heading exceeds such terminal in length.
    # In the absence of anything better to do, print such heading as is. While
    # this guarantees such heading to wrap around at least once, truncating such
    # heading to the current terminal width often produces worse results.
    #
    # If such number is 0, such heading's length is either the terminal width or
    # one character less than such width. In the former case, no space remains
    # for a border; in the latter case, only one character of space remains,
    # hardly enough for even delimiting whitespace. In the absence of anything
    # better to do, again print such heading as is.
    #
    # For both efficiency and simplicity, unify both such cases here.
    } else {  # guard condition :: elif (( character_count_left <= 0 ))
        print_string "${heading}"
    }
}

#FIXME: In lieu of unit tests, this will do.
#function sayh() {
##   print_call_stack
#    print_string 'upended'  # should be two newlines after this!
#    print_heading 'dancing to'
#    print 'life'
#    brayman
#    print_heading 'road to'
#    print 'ubar'
#}
#function brayman() {
#    print_heading 'beyond'
#    print 'genesis'
#    print_heading 'ein'
#    print 'lichtschein'
#}

# --------------------( WASTELANDS                         )--------------------
