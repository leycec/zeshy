#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle interactive shell prompts.

== See Also ==

* Phillip Gold's http://aperiodic.net/phil/prompt[zsh prompt treatise] --
  arguably, a precursor to modern `zsh` configuration frameworks.
/---

#FIXME: Use the "vcs_info" zsh module for displaying VCS-specific metadata in a
#VCS- agnostic fashion.
#FIXME: Incorporate the following other prompt scripts:
#Has a fantastic series of functions for setting the terminal title!
#http://www.semicomplete.com/misc/rcfiles/zshrc
#FIXME: Fairly cool (and very fast) command-line syntax highlighting of zsh
#while you type it, using Pygments:
#
#    https://bitbucket.org/ZyX_I/zsh-pygments-highlighting/src
#
#The traditional alternative to the above is a script entitled
#zsh-syntax-highlighting (available on Github), which is purportedly slow-as-
#blazes, to the point of unusability (particularly on long multi-lines). The
#above script suffers no such delusional slowness.
#FIXME: Ridiculously cool dynamic prompt, embedding such interesting iota as
#average CPU load, average of all CPU and motherboard heat sensors, whether or
#not the current user has write access to the current directory, great git
#integration, and so forth:
#
#    https://github.com/nojhan/liquidprompt
#
#I'm not terribly fond of the way it dynamically shifts a single-line prompt
#right, frankly. To integrate such ideas this with our current prompt, I
#imagine we'd like to have a prefixing prompt line containing such factotum.
#Such dynamism is hardly essential, but does seem substantially interesting.
#(Indeed, I'd also like to display remaining disk space on the partition
#containing the current directory as a percentage, which "liquidprompt" appears
#not to support. I can imagine why: it's not exactly straightforward. Then
#again, none of this functionality is! I can't imagine authoring such a behemoth
#in raw bash or zsh, honestly.)

# ....................{ SPLASH                             }....................
# Display introductory "splash" text. This is a line or two of text displayed
# prior to displaying the shell prompt, on initial start-up of the shell.
#
# This text is defined and displayed according to ZSH shell prompt syntax.
# Thus, see "info zsh" for details.

# void precmd()
#
# Modifies the current shell environment prior to printing the current prompt.
# zsh runs this function immediately after the process for the previous command
# completes but immediately before printing another prompt for the next command.
#precmd() {
#}

# void preexec(string command_name, string command_arg_1, ...)
#
# Modifies the current shell environment prior to running the passed command.
# zsh runs this function immediately after the current user inputs a command at
# the current prompt and then inputs <Enter>, but immediately before executing
# the command.

# ....................{ STARTUP                            }....................
run_hook_on_zeshy_startup_if_interactive\
    startup_zeshy_terminal_prompt

declare_function '
void startup_zeshy_terminal_prompt(void)

Define prompt strings for the current interactive shell. This includes:

* ${PROMPT}, the default leftmost prompt string.
* ${PROMPT2}, the leftmost prompt string for continuation lines.
* ${PROMPT3}, the leftmost prompt string for "select" loops.
* ${PROMPT4}, the leftmost prompt string for runtime traces.
* ${RPROMPT}, the default rightmost prompt string.
* ${SPROMPT}, the leftmost prompt string for spelling mistake corrections.
'
function startup_zeshy_terminal_prompt() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Set superuser-specific colors if the current user is the superuser or
    # non-superuser-specific colors otherwise.
    string prefix
    if is_superuser
    then prefix='startup_zeshy_terminal_prompt.superuser.'
    else prefix='startup_zeshy_terminal_prompt.nonsuperuser.'
    fi

    #FIXME: Define a new print_prompt() function printing the current prompt(s).
    #Don't bother with implementing a "vared PS1" wrapper; that hardly makes
    #sense, given the current prompt implementation.

    # Define (and export) the ANSI shell prompt. To view this prompt as colorized
    # output, type "print -P $PS1"; and to view and edit this prompt as plaintext
    # source, type "vared PS1".
    #
    # This text is defined and displayed according to ZSH shell prompt syntax.
    # See "info zsh" for details.
    PROMPT=''

    # Print the current hostname and username.
    PROMPT+="${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}brace]-}[${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}host]-}%m ${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}user]-}%n${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}brace]-}}"

    # Print the current path.
    PROMPT+="${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}path]-}%~"

    # Print an indication of whether the prior command succeeded or failed.
    PROMPT+="%(1/?%(0??${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}prior_command_succeeded]-}/?${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}prior_command_failed]-}!)?)"

    # Set colors for subsequent command line input.
    PROMPT+="${ZESHY_STYLE_TO_COLOR_PROMPT[${prefix}input]-}"

    # Set no rightmost prompt, for the moment.
    RPROMPT=
}

# --------------------( WASTELANDS                         )--------------------
#   print -Pn -- "${ZESHY_STYLE_TO_COLOR[color.reset]-}"
#FUXME: Integrate with a new "zsh/hook" component. According to "man zshall",
#zsh has builtin support for global arrays ${precmd_functions},
#${preexec_functions}, and so on, so all such component needs provide are
#appropriate append_* and prepend_* functions -- ideally with more human-
#readable names than "precmd" and "preexec".

    # Set superuser-specific colors if the current user is the superuser or
    # non-superuser-specific colors otherwise.
#   string prefix
#   if is_superuser
#   then prefix='startup_zeshy_terminal_prompt.superuser.'
#   else prefix='startup_zeshy_terminal_prompt.nonsuperuser.'
#   fi

#   string color_command color_machine color_path color_status_nonzero
#%B
    #FUXME: Extract into color styles.
    # Define user-specific colors to be used in prompts below.
#   if is_superuser; then
#       color_command="${ZESHY_COLOR_PROMPT[grey]}"
#       color_machine="${ZESHY_COLOR_PROMPT[red]}"
#       color_path="${ZESHY_COLOR_PROMPT[white]}"
#       color_status_nonzero="${ZESHY_COLOR_PROMPT[magenta]}"
#   else
#       color_command="${ZESHY_COLOR_PROMPT[white_bold]}"
#       color_machine="${ZESHY_COLOR_PROMPT[cyan]}"
#       color_path="${ZESHY_COLOR_PROMPT[green]}"
#       color_status_nonzero="${ZESHY_COLOR_PROMPT[red]}"
#   fi

    # Define (and export) the ANSI shell prompt. To view this prompt as colorized
    # output, type "print -P $PS1"; and to view and edit this prompt as plaintext
    # source, type "vared PS1".
    #
    # This text is defined and displayed according to ZSH shell prompt syntax.
    # See "info zsh" for details.
#   PROMPT=''
#   PROMPT+="${color_command}[${color_machine}%m %B%n${color_command}}"   # user
#   PROMPT+="${color_path}%~"                                             # path
#   PROMPT+="%B%(1/?%(0??${color_path}/?${color_status_nonzero}!)?)" # last process failed?
#   PROMPT+="${color_command}"                                            # input

    #FUXME: This can be simplified by noting the only difference between the root
    #and non-root prompts are the colors and that, therefore, this difference may
    #be abstracted out by defining these colors in a pre-prompt zsh function.

    # Coerce command output to be bold white, regardless of the previous
    # color output by the prior prompt.
#   export RPROMPT=
#   print "PS1: ${PS1}"
#       color_command=${ZESHY_COLOR_PROMPT_BLACK_BOLD}
#   export PS1
    #export PS1="%(!?${ZESHY_COLOR_BLACK_BOLD}[${ZESHY_COLOR_RED}%m %B%n${ZESHY_COLOR_BLACK_BOLD}}${ZESHY_COLOR_WHITE}%~%B%(1/?%(0??${ZESHY_COLOR_WHITE}/?${ZESHY_COLOR_RED}!)?)${ZESHY_COLOR_BLACK_BOLD}?${ZESHY_COLOR_WHITE_BOLD}[${ZESHY_COLOR_CYAN}%m %B%n${ZESHY_COLOR_WHITE_BOLD}}${ZESHY_COLOR_GREEN}%~%B%(1/?%(0??${ZESHY_COLOR_GREEN}/?${ZESHY_COLOR_RED}!)?)${ZESHY_COLOR_WHITE_BOLD})"

#FUXME: Obsolete.
# * "${PS1}", the core shell prompt variable, in a root-aware manner.
# * Splash message, terse introductory text welcoming the current user to Zeshy.
# * Help message, verbose synopsizing Zeshy functionality, issues, and usage
