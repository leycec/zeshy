#!/usr/bin/env zsh
# ====================[ section                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle sectioned output (i.e., output split into topically related sections).

# ....................{ PRINTERS ~ sections                }....................
#FIXME: Admit it: this is pretty sucky output. Let's prettify this, please! Try
#calling output() rather than say() with output resembling:
#
#=====================[ output                             ]====================
#
#Clearly, the output should scale with terminal width. If terminal width is too
#small (say, <= 20), forego the desired heuristic and just output the passed
#section. Hmm... or not? Let's not edge case, for now. Just assume everything
#works. 8) O.K.; here we go:
#
#* Divide terminal width by 4, apportioning the left and right banners each 1/4
#  the width and the middle section 2/4 (1/2) the width.
#* Don't worry about centering output. We'd rather columns line up vertically.
#* And...that's it, really. Shouldn't be too cumbersome, nay? The slightly hard
#  part is ensuring that, if the terminal width is not cleanly divisible by 4:
#  * Round all divisions *DOWN*, for safety.
#  * Add the difference of the terminal width and the summation of the three
#    widths (i.e., left banner, right banner, section header) back to the
#    section header. That should do us right, no?
#* Naturally, it'd be nice to colorify this, too. All things come.
#FIXME: Print the actual headings with print_banner_titled(), as discussed in
#the "output" component.

#FIXME: Eliminate the distinction between say_first_section() and
#say_next_section() by replacing such functions with a single
#say_heading() function. This function internally retains the name of the last
#function that called this function (e.g., with a global string
#${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}). If such name is empty or different
#than the current function that called this function, print a first section
#heading; otherwise, print a next section heading. In either case, cache the
#current caller function name for use in the next call to this function. Pretty
#simple, actually.
#Ah, wait; that's not *quite* right. We actually need to search up the callstack
#for ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}; it's not enough to just assume
#that if the function directly calling this function differs, then we're in a
#new logical block of headings. Anyway, not terribly difficult. Be fun to write
#some callstack search routines, eh?
#Ah! Wait. Yes, we could implement such implicit searching, but it seems
#increasingly error-prone. Instead, the function prototype should resemble:
#
# string say_heading(
#   string heading, string heading_group = "$(get_caller_function_name)")
#
#Implement get_caller_name() as a function (not alias!) looking two up on the
#caller stack. This should work without error if the caller is in fact a global
#script; just return the script name, for example.
#
#The heading group is an arbitrary name distinguishing this "group" of headings
#from other such groups, defaulting to the caller name. Callers performing
#complex logic should pass a different heading group... Hmm. This is all well
#and good, but perhaps we should provide additional functions, as well:
#
# string set_heading_group(string heading_group = "$(get_caller_function_name)")
# string unset_heading_group()
#
#These set a global string ${ZESHY_HEADING_GROUP}. Then, slightly change
#say_heading() to:
#
# string say_heading(
#   string heading,
#   string heading_group = "${ZESHY_HEADING_GROUP:-$(get_caller_function_name)}")
#
#say_heading() then internally compares the passed heading_group (with the above
#default) to its cached ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME} (which should
#probably be ${ZESHY_HEADING_GROUP_PRIOR}). If different... well, you know the game.
#
#Sweet. That seems just right. Simple functions can just call say_heading() with
#one argument without needing to call set_heading_group() or
#unset_heading_group(). More complex functions can just call say_heading() with
#two arguments. And truly complex groups of functions can call set_heading_group()
#prior to calling say_heading() with one argument prior to calling
#unset_heading_group().
#
#Hmmm; set_heading_group() and unset_heading_group() might cause too many head-
#aches, hmm? Just calling say_heading() with two arguments should suffice for
#an initial implementation, no? Ah; wait. We really just need the following:
#
# string say_heading(string heading)
# string set_heading_group(string heading_group = "$(get_caller_function_name)")
# string unset_heading_group()
#
#Tada! Flash. Crash. Bamb.

document_function '
string say_first_section(string header1, string header2, ...)

Print the passed strings as the header of a section (i.e., a contiguous block
of related output). Sections demarcate print_string into logical blocks, each
preceded by a terse header synopsizing such block. To ensure aesthetic output,
call this function *ONLY* on the first such section and say_next_section()
on all remaining sections.
'
function say_first_section() {
    say "[${@}]"
}

document_function '
string say_first_section(string header1, string header2, ...)

Print the passed strings as the header of any section other than the first.
'
function say_next_section() {
    print_newline
    say_first_section "${@}"
}

# --------------------( WASTELANDS                        )--------------------
