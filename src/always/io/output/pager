#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: This could use some sprucing up.
declare_parcel_as_script_with_stdin <<'---'
Handle *output paging* (e.g., `more`, `less`).
---

#FIXME: When *NOT* paging, visually demarcate wrapped lines (ideally with color
#or perhaps simply with a simple prefix). So, rather than printing:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
#odes=497142 mode=755
#
#  Instead, printing:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ^-> odes=497142 mode=755
#
#  Or perhaps simply:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ...odes=497142 mode=755
#
#  Or the slightly cleverer:
#
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr...
# ..._inodes=497142 mode=755
#
#Actually, no. That reads awkwardly. One "..." is sufficient, I should think.
#Happily, "yppy" already has appropriate Unicode for the former arrows. In
#either case, I prefer a prefixing space on the wrapped line.

# ....................{ PAGERS                             }....................
declare_function_with_stdin <<'/---'
string page_string(string text1, string text2, ...)

Page the passed string with the current user's preferred pager (e.g., `less`)
if such string exceeds the current terminal height or print such string without
paging otherwise. This function thus pages on an as-needed basis, providing a
pseudo-intelligent context-sensitive pager.
/---
function page_string() {
    if { not page_string_if_needed "${@}" } {
        output_string "${*}"
    }
}

#FIXME: As a slight improvement, make paging a bit "fuzzy." I've noticed that
#my eye, at least, would prefer paging not merely on text that's strictly too
#high but on text that's *SUFFICIENTLY* high. Sufficiently, is subjective, of
#course, so this should probably be user-configurable. I'm contemplating a
#default of 75% for such user-configurable global -- say:
#
#    ZESHY_PAGE_IF_TEXT_TO_TERMINAL_HEIGHT_PERCENT=75
#
#Then, page if the text height is greater than or equal to
#(( $(get_terminal_height) * ZESHY_PAGE_IF_TEXT_TO_TERMINAL_HEIGHT_PERCENT / 100 )).
#Should work great, yes?
#FIXME: Actually, it'd be better to just *CLEAR* the screen prior to printing
#such sufficiently tall text. The issue with tall text that still fits on the
#screen is not that such text isn't paged; it's that such text starts at a
#line number other than 1, which my eye (at least) expects for tall text.

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] page_string_if_needed(
    string text1, string text2, ...)

Conditionally *page* (i.e., pipe to the current user's preferred pager) the
passed string. Specifically:

* If standard output for the current shell is _not_ attached to a terminal
  device, return failure.
* Else if such string exceeds the dimensions of such terminal, page such string
  and return success.
* Else, return failure.
/---
function page_string_if_needed() {
    # Validate passed arguments.
    die_unless_args 'Expected one or more strings.'
    string\
        text="${*}"\
        pager_path\
        pager_name\
        pager_options_list_name
    integer\
        text_height line_sans_ansi_width terminal_height terminal_width_plus_one
    list command lines

    # If standard output is *NOT* a terminal, return failure.
    if { not is_stdout_terminal } { return_false }

    # Split such string on newline into lines.
    set_list_to_string_lines lines "${text}"

    # Determine whether such output's logical line length (i.e., accounting for
    # implicit wrapping of long lines) exceeds the terminal height or physical
    # line width the terminal width. The algorithm resembles
    # get_displayed_line_length(), but differs by immediately stopping iteration
    # on exceeding terminal height or width rather than continuing to accumulate
    # total line length. This reduces an otherwise O(N) algorithm to effectively
    # O(1), assuming non-ludicrous terminal height and width.
#   print_list lines
    text_height="$(get_list_size lines)"
    terminal_height="$(get_terminal_height)"

    # Terminal width plus one to avoid treating maximally long lines as wrapped.
    terminal_width_plus_one=$(( $(get_terminal_width) + 1 ))
#   print "text_height: ${text_height}\nterminal_height: ${terminal_height}"

    # ${text_height} gives only the number of lines in such string without
    # considering line wrapping. Even if such number does not exceed the
    # terminal height, such number incremented by the number of additional
    # wrapped lines in such string *COULD* still exceed the terminal height. In
    # the latter case, such string requires paging.
    if (( text_height <= terminal_height )) {
        string line line_sans_ansi
        for    line ("${lines[@]}") {
            # Remove ANSI color codes prior to testing line length. See
            # get_string_length_printable_sans_ansi_colors() for further details.
            line_sans_ansi_width="${(m)#${line//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}}}"
#           print "line width (sans ANSI): ${line_sans_ansi_width}"

            # Increment the number of lines required to display such text by the
            # number of wrapped lines by which the current line exceeds the terminal
            # width (i.e., by the number of additional wrapped lines in this line).
            text_height+=$(( line_sans_ansi_width / terminal_width_plus_one ))

            # If such number exceeds the terminal height, we have definitively
            # determined such string to require paging -- and may thus stop.
            if (( text_height > terminal_height )) { break }
        }
    }
#   print "text_height: ${text_height}\nterminal_height: ${terminal_height}\nline_sans_ansi_width: ${line_sans_ansi_width}\nterminal_width_plus_one: ${terminal_width_plus_one}"

    # If the terminal suffices to display output without paging, return failure.
    if (( text_height <= terminal_height )) { return_false }
#   print "line length: ${text_height}\nterminal height: ${terminal_height}"
    # Absolute path of the pager command preferred by the current user.
    pager_path="$(get_pager_path)"

    # Command to be run.
    command=( "${pager_path}" )

    # Pager name capitalized for use below.
    pager_name="$(capitalize_string "$(get_path_basename "${pager_path}")")"

    # List of pager options specific to such pager.
    pager_options_list_name="ZESHY_${pager_name}_OPTIONS"
    if { is_list "${pager_options_list_name}" } {
        command+=( "${(@P)pager_options_list_name}" )
    }

    # Page such text.
    output_string "${text}" | "${command[@]}"
}

# ....................{ PAGERS ~ stdin                     }....................
declare_function_with_stdin <<'/---'
string page_stdin[stdin: string text]

Page standard input with the current user's preferred pager (e.g., `less`) if
such input exceeds the current terminal height or print such input unpaged
otherwise. This function is typically piped standard output from a block
of related commands to be paged together. See page_string() for further details: e.g.,

.page_stdin()
==========================================
[source]
------------------------------------------
>>> { lsblk; lscpu; lsmod; lsof; lspci; lsusb } | page_stdin
------------------------------------------
==========================================
/---
function page_stdin() {
    # Validate passed arguments. Avoid throwing an exception if standard output
    # is *NOT* attached to a terminal, as page_string_if_needed() already
    # handles such condition appropriately.
    die_if_args

    # All prior read lines of standard input.
    string stdin

    # Currently read line of standard input.
    string stdin_line

    # Incrementally read each line of standard input and for each such line,
    # print such line to standard output and append such line to the string
    # accumulating such input. While slightly more complex than the conventional
    # blocking implementation capturing all standard input at once (e.g.,
    # "$(< /dev/stdin)"), this non-blocking implementation is preferable for
    # paging output from non-trivial commands not expected to end immediately.
    # Dismantled, this is:
    #
    # * "IFS=", preventing read() from splitting read input on field separators.
    # * "-r", preserving input characters (e.g., backslashes are not escapes).
    # * "-E", copying read input to standard output.
#   while { IFS= read -rE stdin_line } {
    while { IFS= read -r stdin_line } {
        # Copy such line to standard output. In theory, this should also be
        # achievable by passing option "-E" to read() above, instructing such
        # call to perform such copy itself. In practice, read() suffixes such
        # copy with an an erroneous blank line. To avoid such nonsense, do it
        # ourselves instead.
        output_string "${stdin_line}"

        #FIXME: This is *EXCESSIVELY* inefficient. Which is to say, it's dumb.
        #Instead, just do this inside the loop:
        #
        #   stdin+="${stdin_line}${ZESHY_ASCII_NEWLINE}"
        #
        #Then, after looping, if we *REALLY* don't want the suffixing newline:
        #
        #   stdin="${stdin[1,-2]}"
        #
        #That's it. *facepalm*

        # If this is any line *EXCEPT* the first, prefix such line by a newline.
        # Since this is the common case, test for this first. For efficiency,
        # inline such test.
        if is -n "${stdin}" si {
            stdin+="${ZESHY_ASCII_NEWLINE}${stdin_line}"
        # Else, this is the first line. Append such line as is.
        } else {
            stdin+="${stdin_line}"
        }
#       print "stdin line read: ${stdin_line}"
    }
#   print "stdin read: ${stdin}"

    # If required, page such input. Since the prior iterator already printed
    # such input to standard output, avoid doing so again here.
    page_string_if_needed "${stdin}" or ignore_exit_status
}

#FIXME: In lieu of unit tests...
#function pins() {
#    print 'ok' | page_stdin
#    print '================'
#    print 'ok\nko' | page_stdin
#    print '================'
#    print 'ok\nko\nokko' | page_stdin
#    print '================'
#    string yoko; yoko="$(print 'ok\nko\nokko' | page_stdin)"
#    print "yoko: ${yoko}"
#}

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
string run_code_paged(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command with standard output and error piped to the current
pager if such output exceeds either the current terminal height or width or as
is (i.e., without paging) otherwise. Hence, this is an intelligent pager.

Customary pager commands block on standard input, thus delaying output until
after the input command completes operation. Resource-intensive commands not
completing immediately (e.g., `ls -R *`) thus block paging with no
intermediate output until such commands eventually complete. To rectify such
interface woes, this function immediately prints all output as received from
the passed command to standard error prior to paging such output, as needed.
/---
function run_code_paged() {
    # If not called from a terminal, run such command without paging.
    if { not is_stdout_terminal } {
        run_code "${@}"
    # Else, run the passed command with redirection.
    } else {
        # Validate passed arguments.
        die_unless_args 'Expected one or more commands.'
        string output
#       print_string "run_code_paged: ${@}..."

        # Run such command and capture standard output from such command.
        run_code_and_set_string_to_stdout "${@}" output

        # Page such output, ignoring failure if such output requires no paging.
        page_string_if_needed "${output}" or ignore_exit_status
    }
}

#FIXME: In lieu of unit tests...
#function fata() {
##    # This command induces an eventual infinite loop in get_stdin_until_eot()
##    # if we've mucked that function up. Nice way to reliably test it, anyway.
###   run_code_paged command ls -l --color /usr/portage/distfiles
##    list_path_verbosely /usr/portage/distfiles
#     grep_path /usr/portage Gentoo
#}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Revert back to the commented code after it's reliably working.
#       run_code "${@}"

        #FUXME: Great! This *ACTUALLY* works, implying that our current
        #implementation of get_stdin_until_eot() is *VERY* broken. Replace
        #such function with get_stdin_until_eot_working() immediately; then
        #revert to the above function call. That's it!
#       string string_name__rcassto="output" redirection__rcassto="1>&1 1>&p"
#       string string_name__rcassto="output" redirection__rcassto="1>&1"

        # Coprocess outputting all standard input piped to such subshell until
        # receiving a line containing only an EOT character. See such function
        # for further details.
#       open_coprocess get_stdin_until_eot_working
#       open_coprocess set_string_to_stdin_until_eot "${string_name__rcassto}"

#       {
            # Run such command. To prevent the passed redirection from conflicting
            # with redirections already embedded in such command, explicitly
            # segregate the former from the latter with "{" and "}" delimiters.
    #       output_string "variable: ${string_name__rcassto}; command: ${@}"
#           run_code '{' "${@}" '} '${redirection__rcassto}
#           print 'We never get here, do we?'

            # Write a line containing only the EOT character to such function,
            # which should now successfully return.
#           output_string_to_coprocess "${ZESHY_ASCII_EOT}"

            # Set the passed string to all standard error cached via such coprocess.
            # To quote modern culture, "Shit just got real."
#           set_string_to_coprocess_output "${string_name__rcassto}"
#       } always close_coprocess
#       print "output: ${output}"

#FUXME: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#We appear to have a critical error on our hands, folks. It's pretty easy to
#replicate, too: just type "ll /usr/portage/distfiles". That's it. Guess what
#happens? The *ENTIRE* shell freezes indeterminately. I'm not kidding. That's
#terrible and it needs to be fixed immediately. Clearly, we're failing to handle
#signals sanely.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#   output_string "read!"
#   output_string "${line}"
#FUXME: O.K.; we don't actually need this. It appears that a string local in the
#function body below suffices.
#declare_global_with_stdin string ZESHY_COPROCESS_STDIN_CACHE <<'/---'
#string ZESHY_COPROCESS_STDIN_CACHE
#/---
    # Clear the cache in the coprocess subshell.
#   ZESHY_COPROCESS_STDIN_CACHE=""

    # Output all lines of standard input back to the caller until either
    # reaching the end of such input or a line containing only an EOT character.
    # See page_stdin() for related logic.
    #
    # Critically, cache such lines to a string local to be output all-at-once
    # after getting all such lines. Do *NOT* output such lines via incremental calls to builtin
    # print(). While doing so behaves as expected on "small" input,
    # induces a spin weight on sufficiently large input when called from a
    # pipeline or coprocess.

        # If this is any line *EXCEPT* the first, prefix such line by a newline.
        # Since this is the common case, test for this first. For efficiency,
        # inline such test.
#       if is -n "${ZESHY_COPROCESS_STDIN_CACHE}" si {
#           ZESHY_COPROCESS_STDIN_CACHE+="${ZESHY_ASCII_NEWLINE}${stdin_line}"
        # Else, this is the first line. Append such line as is.
#       } else {
#           ZESHY_COPROCESS_STDIN_CACHE+="${stdin_line}"
#       }

    # Dismantled, this is:
    #
    # * "IFS=", preventing read() from splitting input on field separators.
    # * "-r", preserving input characters (e.g., backslashes do not escape).
    #
    # If passed piped input and no arguments, page such input.
#   } elif { is_args_0 and is_stdin_pipe } {
#       page_stdin

#If the passed string exceeds the current terminal's dimensions, print such
#string with the current user's preferred pager; otherwise, return false.
#>>> { lsblk; lscpu; lsmod; lsof; lspci; lsusb } | page_stdin

#   die_unless_stdin_readable_sans_blocking

# while { is_stdin_readable_sans_blocking and IFS= read -r -E stdin_line } {
        # For efficiency,
        # manually implement the equivalent of the following:
        #
        #     >>> line_sans_ansi_width="$(\
        #     ...     get_string_length_printable_sans_ansi_colors "${line}")"

#FUXME: Rename to page_string_if_needed(). The exact conditions under which a
#string should be paged are implementation details that should be kept out of
#the function name.
        # Run such command and capture its output. Dismantled, this is:
        #
        # * "1>&1", preserving standard output prior to redirection below.
        # * "1>&2", redirecting standard output to error. Since command
        #   substitution only captures the former, this immediately prints all
        #   output produced by running such command.
        # * "2>&1", redirecting standard error to output. Since command
        #   substitution only captures the latter, only such redirection
        #   captures standard error.
        #
        # Avoid the following efficient and certainly simpler alternative, which
        # unfortunately discards non-zero exit status from run():
        #
        #   run_code "${@}" 1>&1 1>&2 | page_stdin_if_needed or true
#       string output; output="$(run_code "${@}" 1>&1 1>&2 2>&1)"
#       string output; output="$(run_code_and_set_string_to_stdout "${@}")"

#FUXME: Rename to get_pager_path_path().
# and return_exit_status
#   is_stdout_terminal or {
#       print_string "${@}"
#       return_true
#   }
#FUXME: Rename to page_string_if_needed(). Pretty sweet adjective in this
#case and frankly the best I've come up with.

#FUXME: Rename to page_string(). Since there's no possibility of a corresponding
#curse_string_paged(), just truncate us up. This also helps with the absurdly
#long function name below.

    # * "or true", ignoring such function call when returning false, since the
    #   prior "1>&2" redirection already successfully printed such output.
#       page_string "$(get_stdin_piped)"
#   get_and_set_string_global_if_unset_or_empty_to_evaluation
#   set_string_if_unset_or_empty_to_evaluation\
#       PAGER '$(get_pathable_path_first less more)'
#   print_string "${PAGER}"

#function get_string_global_and_set_if_unset_or_empty_to_evaluation() {
#    die_unless_arg 'expected one string variable name'
#    string __variable_name__="${1}"
#    declare_string_global "${__variable_name__}"
#    set_string_if_unset_or_empty_to_evaluation\
#        "${__variable_name__}" '$(get_pathable_path_first less more)'
#    print_string "${__variable_name__}"
#}

        #FUXME: Not quite right. Try prefixing or suffixing 2>&1.
        #FUXME: Woops. This erroneously discards non-zero exit status from
        #run(). We only want to discard non-zero exit status from
        #print_...(). Hmmmm. Frak this. Revert to the prior logic, which
        #actually worked perfectly.
#       run "${@}" 1>&1 1>&2 | page_stdin_if_needed or
#           true
#       string output; set_string_to_stdin_piped output
#       page_string "${output}"
#       line_sans_ansi_width="$(get_string_length "$(remove_ansi_color_codes "${line}")")"
#       text_width=${#$(remove_ansi_color_codes "${line}")}
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
#       run "${@}" 1>&1 1>&2 2>&1 | page_stdin_if_needed

#   print_message 'here!' 
#   is_stdin_pipe and {
#       print_message 'received piped input:'
#       print_message "$(< /dev/stdin)"
#       print_message 'yikes'
#       close_stdin
#       print_message 'yikes'
#       is -p /dev/stdin si and print_message 'pipe"s alive!!!!'
#       print_message 'yikes'
#       is_stdin_pipe and print_message 'pipe"s alive!!!!'
#       print_message 'yikes'
#   }
#   print_message 'no, here!' 
    # If passed piped input and...
#   string output
#   if is_stdin_pipe; then
#       print_message "received piped input: $(get_stdin_piped)"
        # ...no arguments, capture such print_string without running a command.
        # Duplicate the behavior of the print_string capturing below by printing such
        # print_string to standard error.
#       if is_args_0; then
#           set_string_to_stdin_piped output
#           page_string "${output}"
        # ...at least one argument, run such arguments as a command and pipe the
        # input piped to this function to such command. See below for details.
#       else
            #FUXME: Not quite right. Revise run() to implicitly check for piped
            #input and, if available, to close such input after use. That would
            #condense the following two conditional blocks into one.
#           run_code_with_stdin_piped run "${@}" 1>&1 1>&2 2>&1 |
#               page_string_if_needed
#           output="$(run_code_with_stdin_piped run "${@}" 1>&1 1>&2 2>&1)"

            # Per the "CAVEAT" described under Zeshy Pipe, manually ensure
            # is_stdin_pipe() now returns false.
#           close_stdin
#       fi
    #FUXME: Hmm; the documentation no longer reflects the reality. Fixmeup.
    # Otherwise, run the passed command with redirection. Dismantled, this is:
    #
    # * "2>&2", preserving standard error prior to its subsequent redirection.
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
    # * "1>&1", preserving standard print_string prior to its subsequent redirection.
    # * "1>&2", redirecting standard print_string to error. Since command substitution
    #   only captures the former, this immediately prints all print_string produced by
    #   running such command.
#   else
#       die_unless_args 'expected one command'
#       print_string "run_code_paged: ${@}..."
#       run "${@}" 1>&1 1>&2 2>&1 | page_stdin_if_needed
#   fi
#           die_if_args 'expected no command when passed piped input'
#           output="$(get_stdin_piped)"
#           curse_string "${output}"
#           page_string_if_needed "${output}"

#FUXME: Woops! We've dramatically simplified this by now paging on *ANY*
#line wrapping. That means we know longer need to determine displayed page
#length. Clean up documentation.
#FUXME: Actually, while this is decent, it'd be far better to:
#
#* Revert back to the prior logic of only paging when total displayed line
#  length exceeds terminal height *AND*
#   noop "${PAGER:="$(get_pathable_path_first less more)"}"

#   integer terminal_width_plus_one
#   (( terminal_width_plus_one = terminal_width + 1 ))
    # * Wrapping Accounting for line wrapping 
    # * Output width (i.e., the length of the longest print_string line) exceeds
    #   terminal width.
    # Accumulate wrapped line height and maximum line width until either exceeds
    # terminal height or width, at which point we know we need to page.#       (( text_height > terminal_height or
#          text_width  > terminal_width )) and break
#       print_string "line (width: ${text_width}) ${line}"
#       (( text_width > terminal_width )) and break
#   (( text_height > terminal_height or
#      text_width  > terminal_width  )) or return_true
