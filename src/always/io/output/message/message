#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle non-erroneous message output.
-/-

#FIXME: The distinction between print_message() and print_message_wrapped() is
#blatantly nonsensical. *EVERY* message should be implicitly wrapped. The
#caller shouldn't have to decide which of the two functions to call based on
#some arbitrary and inconsistent measure of whether the message being passed is
#sufficiently long to possibly require wrapping. I mean, really.
#FIXME: Such wrapping refactoring should also be extended to errors and warnings.
#FIXME: There currently exists a subtle, but important, bug in our wrapping PCRE:
#if the current word is a single word containing no hyphen, such word will
#probably be ignored by the wrapping implementation and not output at all! Ug.
#FIXME: The current get_print_message_prefix()-based implementation is somewhat
#oversimplistic. Ideally, we'd probably prefer Unicode-based output resembling:
#
#------\
#info()| This is a single-line message.
#------/
#------\
#      | This is a three-line message.
#info()| Rather swell, isn't it?
#      | I should dare say so!
#------/
#
#This obviates the need for prefixing whitespace, which is rather nice.
#Interestingly, obviating such need effectively obviates our current need for
#tracking standard output state *ENTIRELY*, suggesting we could profitably...
#oh, perhaps not, actually. We often have code printing multiple single-line
#messages: e.g.,
#
#   print_message 'doing something...'
#   do --something
#
#   print_message 'doing something else...'
#   do --something else
#
#Ideally, such output should be rendered as:
#
#/----------------------------------[ info() ]---------------------------------\
#| doing something...                                                          |
#| doing something else...                                                     |
#\-----------------------------------------------------------------------------/
#
#Rather than as:
#
#/----------------------------------[ info() ]---------------------------------\
#| doing something...                                                          |
#\-----------------------------------------------------------------------------/
#/----------------------------------[ info() ]---------------------------------\
#| doing something else...                                                     |
#\-----------------------------------------------------------------------------/
#
#Sadly, I'm not entirely sure how to effect that. Oh, wait; yes, I *AM* sure. If
#the current terminal accepts VT100 escape codes (as under pretty much every zsh
#installation), we can do the following in, say, start_stdout_printing_box():
#
#* If VT100 support is available *AND* the prior and current printers are the
#  same *AND* standard output has not changed since the last call to such
#  printer, then and only then *ERASE* the previous output line (which will
#  necessarily be the bottom edge of a box).
#
#FIXME: It'd probably be simpler to encapsulate such check in a new print_box()
#function rather than separate start_stdout_printing_box() and
#start_stdout_printing_box() functions. Make it so!
#FIXME: Note the need for a new start_stdout_printing_box() function, to be
#called by print_message(), print_error(), and print_warning(). All other print
#functions should continue to call the existing start_stdout_printing_delimited()
#function, whose implementation should be simplified a bit. Since no other print
#functions care about whether or not the prior and current functions were the
#same, start_stdout_printing_delimited() should always prefix such output with delimiting
#whitespace if standard output has changed since the last call to such a print
#function. (In other words, just drop the current checking for function name
#equality.)
#FIXME: Consider prefixing messages under cron with: "["$(date +'%F %T')"].

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_print_message_prefix(void)

Get the contextual label with which to prefix each line of message output.
/---
function get_print_message_prefix() {
    # Validate sanity.
    die_if_args

    # Prefix with which to label such message.
#   string message_label; message_label="$(get_call_stack_root_basename)"

    # See print_string() for further details.
    return_string "${ZESHY_COLOR[reset]-}${ZESHY_COLOR_STYLE[print_message.caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[print_message.colon]-}: ${ZESHY_COLOR_STYLE[print_message.message]-}${ZESHY_COLOR[reset]-}"
#   output_string "$(get_call_stack_root_basename)"
#   output_string "${ZESHY_COLOR[reset]-}${ZESHY_COLOR_STYLE[print_message.caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[print_message.colon]-}: ${ZESHY_COLOR_STYLE[print_message.message]-}${ZESHY_COLOR[reset]-}"
#   output_string "${message_label}: "
#   output_string "${ZESHY_COLOR[reset]-}${ZESHY_COLOR_STYLE[print_message.caller]-}${message_label}${ZESHY_COLOR_STYLE[print_message.colon]-}: ${ZESHY_COLOR_STYLE[print_message.message]-}${ZESHY_COLOR[reset]-}"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_message(string message1 = "", string message2, ...)

Print the passed strings (defaulting to the empty string) as an informative
message suffixed by a newline. See print_string() for further details.
/---
function print_message() {
    print_string "$(get_print_message_prefix)${*}"
}

declare_function_with_stdin <<'/---'
string print_message_sans_newline(
    string message1 = "", string message2, ...)

Print the passed strings (defaulting to the empty string) as an informative
message suffixed by no newline. See print_message() for further details.
/---
function print_message_sans_newline() {
    print_string_sans_newline "$(get_print_message_prefix)${*}"
}

declare_function_with_stdin <<'/---'
string print_message_interactively(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard output as a non-erroneous
message if the current shell is interactive or the empty string otherwise. See
print_message() for further details.
/---
function print_message_interactively() {
    # Implement such conditional with an "if"- rather than "and"-based
    # statement, as the latter returns non-zero exit status when noninteractive.
    if { is_shell_interactive } { print_message "${*}" }
}

# ....................{ PRINTERS ~ wrap                    }....................
#FIXME: Create warning and error analogues of this function. Yum!
#FIXME: The more I consider it, the more I wonder if this function shouldn't
#simply be renamed print_message() and the existing print_message() excised.
#After all, isn't line wrapping *ALWAYS* desirable? Given such wrapping,
#however, I wonder if a new vertically oriented prefix might be in order: e.g.,
#
#  zeshy| The oppressed are allowed once every few years to decide which
#  zeshy| particular representatives of the oppressing class shall represent and
#  zeshy| repress them in parliament.
#
#Honestly, pipe is probably *NOT* the best delimiter. Contemplate UTF-8.
declare_function_with_stdin <<'/---'
string print_message_wrapped(string message1 = "", string message2, ...)

Print the passed strings (defaulting to the empty string) wrapped to the current
terminal width, prefixing each resulting line with an informative label (e.g.,
`zeshy: `). See print_string_wrapped_with_line_prefix() for further details:
e.g.,

.print_message_wrapped()
==========================================
[source]
------------------------------------------
>>> string on_kodos_and_kang=\
...    "The oppressed are allowed once every few years"\
...    "to decide which particular representatives of the oppressing class"\
...    "shall represent and repress them in parliament."
>>> print_message_wrapped "${on_kodos_and_kang}"
zeshy: The oppressed are allowed once every few years to decide which
zeshy: particular representatives of the oppressing class shall represent and
zeshy: repress them in parliament.
------------------------------------------
==========================================
/---
function print_message_wrapped() {
    print_string_wrapped_with_line_prefix "${*}" "$(get_print_message_prefix)"
}

# ....................{ EXCEPTIONS                         }....................
#FIXME: Interestingly, we don't actually want all exceptions to be handled. We
#always want *UNEXPECTED* exceptions to be handled. Expected exceptions,
#however, should only be handled if the current user's Zeshy configuration
#requests such handling, which should be disabled by default. The canonical
#example of an expected exception is an external command wrapped by a Zeshy
#function returning non-zero exit status on failing to find a match (e.g.,
#"command grep" wrapped by grep_path()). Note that even in this case, of course,
#not all errors emitted by "command grep" are expected: only on failing to find
#a match, which must be explicitly tested for. This suggests a new helper
#function die_unhandled(), which (as expected) does everything die() does but
#excludes only the call to handle_exception(). Since this reduplicates a great
#deal of intricate code, perhaps die() and die_unhandled() can simply delegate
#to an internal utility function with prototype:
#
# string die_handled_if(
#   string error_message = '', boolean is_handling_exception)
#
#Obviously, such functions should be shifted to a new component in the proper
#Zeshy codebase: say, "shell/exception".
#FIXME: While such functionality is essential for oddball corner-cases (e.g.,
#"grep"), what we generally want is a simple way of squelching exceptions when
#the current shell is interactive *AND* the current call stack ends with a
#particular function that was called by some other particular function earlier
#in such stack. This could possibly be implemented as a global map from the
#former to latter, which function die() and associates would need to respect.
#Consider the following definition:
#
#map_global_export\
#    ZESHY_EXCEPTION_HIDE_IF_INTERACTIVELY_THROWN_BY_FUNCTION_NAMES
#
#Ah; wait. The "_INTERACTIVELY" is redundant, since such code paths can only
#come about as interactive alias expansions. Also, it's not specifically
#function names -- it's runnable names. Reduce to:
#
#map_global_export\
#    ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES
#
#Define such global as follows:
#
#ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES=(
#    'ls' 'l'
#    'ls' 'ls'
#    'grep' 'g'
#    'grep' 'grep'
#    'grep' 'gr'
#    ...
#)
#
#Now, that's in a great format for consumption by die_*() functions. But it's
#not really the greatest for definition; given the tenuous nature of interactive
#aliases, we really want to automate definition of such global. This should,
#naturally, be done by the alias_cli_abbreviation() and
#alias_cli_substitution() functions. (O.K.; I suppose alias_cli()
#applies as well.) Under alias_cli_substitution(), it's easy to set two such
#entries: for both, the key is the command name being substituted; for the
#first, the value is the same name; for the second, the value is such
#substitution's abbreviation (if any!). Under alias_cli_abbreviation(),
#thing's are a bit less automated: we'll need to improve
#alias_cli_abbreviation() to accept an optional second argument specifying the
#name of the core underlying external command that such abbreviation eventually
#runs. Hence, this:
#
#    alias_cli_abbreviation {cal}endar{q}uarter='print_calendar_quarter'
#
#...would need to be expanded to this:
#
#    alias_cli_abbreviation {cal}endar{q}uarter='print_calendar_quarter' cal
#
#This then adds a single entry to the above global resembling this:
#
#    ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES+='cal' 'calq'
#
#There's really no other sensible way to handle abbreviations. This works, it's
#only a minor nuisance; let's go-goggogogogo-go!
#
#The first steps, clearly, will be automating alias_cli_substitution() to
#perform such definition and die() to respect such definition (possibly subject
#to a user-configurable boolean enabling or disabling such functionality). After
#getting that to work, then contemplate the extension of such logic to
#alias_cli_abbreviation(). Such global could (possibly) be called:
#
#    boolean_global_export ZESHY_IS_HANDLING_ERROR_IF_THROWN_BY_NONHANDLING_RUNNABLES
#
#Hmm; what about:
#
#    boolean_global_export ZESHY_IS_ERROR_HANDLED_IF_HIDDEN
#    ZESHY_IS_ERROR_HANDLED_IF_HIDDEN=${ZESHY_BOOLEAN_FALSE}
#
#Much better. >)

# string die_unhandled(string error_message = '')
#function die_unhandled() {
#    #FIXME: Implement such function. Unsure this is the best name, to be honest.
#    die_handled_if "${@}" ${ZESHY_BOOLEAN_FALSE}
#}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to print_message_sans_newline(). (Yes, this is called elsewhere.)
#FUXME: Documentation not quite right, assuming we've implemented conditional
#logic to avoid prefixing adjacent output of the same type with delimiting
#whitespace (e.g., multiple print_message() calls in a row).
#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#message. If at least one `zeshy` print function has already been called under
#the current call stack root, prefix such message with delimiting whitespace.

#   print_string_sans_newline "$(print_message "${@}")"
# and decorated by user-configured colors to standard output 
#   print_message_sans_newline_prefix "${@}"
#declare_function_with_stdin <<'/---'
#string print_message_sans_newline_prefix(
#    string message1 = "", string message2, ...)
#
#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#message. Do _not_ prefix such message with delimiting whitespace, regardless of
#whether at least one `zeshy` print function has already been called under the
#current stack root.
#/---
#function print_message_sans_newline_prefix() {
#    print_string "$(get_print_message_prefix)${*}"
#}

    #FUXME: Just for testing. Eliminate this after we get worky.
#   typeset -f get_call_stack_root_basename &>/dev/null or
#       die "get_call_stack_root_basename() undefined"

#...    "Readers may more closely recognize our own culture in [Erich] Fromm's"\
#...    "description of the Dobus, Kwaikutl, Aztecs, and others he put into the"\
#...    "category of \"destructive.\" These cultures, he said, are"\
#...    "\"characterized by much interpersonal violence, destructiveness,"\
#...    "aggression, and cruelty, both within the tribe and against others, a"\
#...    "pleasure in war, maliciousness, and treachery. The whole atmosphere of"\
#...    "life is one of hostility, tension, and fear. Usually there is a great"\
#...    "deal of competition, great emphasis on private property (if not in"\
#...    "material things then in symbols), strict hierarchies, and a
#...    "considerable amount of war-making.\""
#...    "It all comes down to how a culture handles wealth. If a culture manages
#...     it through what [Ruth] Benedict called a \"siphon system,\" whereby
#...     wealth is constantly siphoned from rich to poor, the society as a whole
#...     and its members as individuals will be, for obvious reasons, secure.
#...     They will not need to hoard wealth. Since this generosity is manifested
#...     not only monetarily but in all aspects of life, they will also not need
#...     to act out their now-nonexistent insecurities in other ways."
#zeshy: The history of all hitherto existing society is the history of class
#zeshy: struggles.

#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard output as a non-erroneous
#block of messages. While print_message() prefixes only the first message line
#with an informative label (e.g., `zeshy: `), this function:
#
#. Splits such block into substrings of length equal to the current terminal
#  width subtracted by the length of such label (for all substrings except the
#  last, which only has at most such length).
#. Prints each such substring prefixed by such label and suffixed by a newline.
#
#See print_message() for further details: e.g.,

#FUXME: Fix documentation. I'm also unconvinced "block" is the correct term,
#here *OR* above. How about print_string_wrapped_with_line_prefix()?
#   for (( line_index_start = 0, line_index_end = line_length;
#          line_index_start <= text_length;
#          line_index_start += line_length,
#          line_index_end   += line_length )) {
#       output_string\
#           "${prefix}${text[${line_index_start},${line_index_end}]}"
#   }

    #FUXME: Hmm. Split such block into chunks of length
    #(( terminal_width - message_prefix_length )). If such length is negative,
    #split instead into chunks of length ${terminal_width}.
    #FUXME: Just iterate manually rather than splitting into a list. The last
    #line will probably require special handling.

#the output of the next call to a function.
# Handle high-level print functions (e.g., messages, warnings, and errors).
#If at least one such string has already been printed under the current call
#stack root, prefix such message with delimiting whitespace.
# If at least one such string has already been printed under the current call
#stack root, prefix such message by a newline.
#FUXME: ZESHY_PRINT_CALL_STACK_ROOT handling currently falls down if output is
#printed prior to calling the first high-level print function. There's really no
#good way around this; in fact, extensive googling suggests the only reasonable
#method would be to write a new "zeshy" wrapper script teeing all zeshy output
#to some user-specific temporary file and then testing whether or not such file
#is of size 0 or not. Of course, we'd have to truncate such file to 0 on
#detecting a new call stack; and, of course, such files might either constitute
#a security risk or consume the entirety of the disk. In other words, it's an
#absurdly stupid solution. Which is to say, there *IS* no good solution, and we
#should document this fact somewhere. (Probably above, under a new "CAVEATS"
#section.) What we *CAN* do, however, is modify print_string() to *ALWAYS* set
#ZESHY_PRINT_CALL_STACK_ROOT to the current call stack root. This is a simple
#and hence efficient assignment requiring only a single list lookup. Don't
#bother testing such global prior to assignment; the combined test + assignment
#is far more expensive than the mere assignment. In other words, just do *AFTER*
#successfully printing:
#
#    ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#
#FUXME: O.K.; that's great, except we'll need do so in *EVERY* function of
#component "output", ideally wrapped in a function call. (No need for an alias,
#obviously.) I'm perfectly fine with that. It just needs doing.

#Hence, this string is the first element of array global ${funcfiletrace} at the
#time of the most recent call to high-level print function.
#
#is always
#if one carefully considers it, given a
#filename and file line 
#
#To guarantee uniqueness
#typically, command line. To
#guarantee 
#
#For both
#uniqueness While there
#
#Name of the most recent function or script to have called a Zeshy print function
#internally tracking such state (e.g., print_heading(), print_message()) or the
#empty string if no such function has been called. Such functions set this name
#to that of the caller when the current call stack does *NOT* contain this name''s
#current value, resetting such state. Alternatively, callers may explicitly set
#this name to a caller of their choosing by calling set_print_function_caller().
#
#In either case, this name notifies each call to a concerned Zeshy print function
#of whether or not this constitutes the first call to such a function by such
#caller. If this is the first call, such function does *NOT* prefix output with
#delimiting whitespace; otherwise, such function does prefix output with
#delimiting whitespace.
#
#For example, suppose the current user calls make_grub2_boot_image() from the
#command line and that such function calls print_heading(). Since the call stack
#cannot contain this name''s current value (whatever that was),  thus setting this
#name to "make_grub2_boot_image".  thus setting this name to
#"make_grub2_boot_image", before calling make_initramfs() that then calls
#print_heading(). As the current call stack contains this name''s current value,
#print_heading() 
#
#this name is currently "make_grub2_boot_image" and function
#make_initramfs() calls print_heading(), then since make_grub2_boot_image() transitively calls make_initramfs(), such heading
#is in the current output group and will be printed accordingly.
#
#A heading is in the current output group if the current caller is either such
#group or transitively called by such group. For example, if the current caller
#is make_initramfs() and the current output group is make_grub2_boot_image() (as
#signified by "is ${ZESHY_PRINT_CALLER} == ''make_grub2_boot_image''"), then
#since make_grub2_boot_image() transitively calls make_initramfs(), such heading
#is in the current output group and will be printed accordingly.

#FUXME: I'm unconvinced this works, actually. Consider calling
#make_grub2_boot_image() twice from the command line. The second go around,
#this name will be "make_grub2_boot_image", thus inducing print_heading() to
#prefix the first heading output by the second call to make_grub2_boot_image()
#with a newline. *sigh*
#...well, that's a tremendously obvious flaw in the rough. This clearly won't
#work reliably as advertised -- any of it. Ah; wait. I know how to amend this.
#*phew* Bit annoying, but if we just... Hmmmm. Yikes. Technically, we can do
#this, but won't we have to hash the contents of *BOTH* ${funcstack} and the
#${funcfiletrace}? Hmmmm. Technically, we could efficiently compact both lists
#into a single string with:
#
#   # We'll need to do this manually, both for efficiency and to avoid
#   # permuting the call stack. Exclude the current call, for subsequent
#   # comparability.
#   "${(j:$'\0':)funcstack[1,-2]}\0\0${(j:$'\0':)funcfiletrace[1,-2]}"
#
#Should be *REASONABLY* efficient, assuming the call stack isn't recursively
#stupidly deep. (If it is, this probably dies a flaming death... but then, no
#one reasonable should be doing recursion in zsh, yes?)
#
#O.K.; so what that "hashed" string does is allow us to reliably answer the
#question: is the current call to a print function the first in its "group"?
#Specifically, if:
#
#* ${ZESHY_PRINT_CALL_STACK_ROOT} is on the current call stack (which is
#  fairly efficiently determined given typical call stack depths) and...
#  * "${(j:$'\0':)funcstack[1,${caller_index}]}\0\0${(j:$'\0':)funcfiletrace[1,${caller_index}]}"
#    is the same as the previously cached value above, where "${caller_index}"
#    is the integer found on such stack, then this is *NOT* the first call to a
#    print function by the current caller.
#* Else, this is.
#
#I wish I could say that it's simple, but it's not. It should, however, reliably
#work, thanks in part to zsh's incrementing the "line" number on each function
#called from the command line (guaranteeing different calls hash to different
#strings above). For sanity, we'll probably want to embed the above string hashing
#in an alias -- which can then be conveniently called from both
#set_print_function_caller() and print_heading() and friends. What's particularly
#brilliant about the whole thing is that it implicitly tracks *ANY* Zeshy print
#function. Hence, if one function calls print_heading() that then calls another
#function that calls print_message(), the latter call will be smart enough to note
#it to *NOT* be the first call to such a print function. Wow, great! Utterly no
#idea how I'll ever document this monstrosity, but it should certainly work. Now
#for a tea break.
#FUXME: Use a herestring-style alias. Shouldn't be terribly much overhead, given
#the short string lengths involved... and way more reliable.
#FUXME: Ah-ha! This is *ALL* extreme overkill, though the method above does point
#to the correct way. Note that we only want to track output for each call hierarchy
#rooted at the same root caller: that is, each discrete call stack rooted at some
#caller tracks whether output has been printed for that call stack or not. But this
#is painfully simple to track: rather than all of this "caller_name" and "heading_group"
#nonsense, just record the following string in a global variable:
#
#    "${funcstack[1]}\0${funcfiletrace[-1]}"
#
#That's it. Then, on each call to a print function, simply test such variable for
#equality with the same string re-evaluated at the current context. If they're the
#same, then this is another call to the same call hierarchy, so *PRINT A NEWLINE*;
#else, this is the first call to a new call hierarchy, so set such global variable
#to such string's evaluation. Painfully simple, no?
#FUXME: I believe we can dispense with at least
#${ZESHY_PRINT_CALLER_IS_PRINTED} and possibly also
#set_print_function_caller().
#FUXME: Right. Since we'll be leveraging such functionality in multiple places,
#abstract out into a function entitled, say... print_message_prefix().
#FUXME: Merge the contents of this file with "message", for obvious reasons.

# Print the passed heading (defaulting to the empty string). See
# ${ZESHY_PRINT_CALL_STACK_ROOT} for further discussion.
# or print no such such whitespace otherwise.
#   is_string_nonempty ZESHY_PRINT_CALL_STACK_ROOT and is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT}" "${funcfiletrace[-1]}"

    # If *NOT* called directly from the command line, this function was called
    # by another function or script. Determine whether the heading just passed
    # by such caller is in the current output group.
#   is_caller and {
#       print "ZESHY_PRINT_CALL_STACK_ROOT=${ZESHY_PRINT_CALL_STACK_ROOT}"
#       print "ZESHY_PRINT_CALLER_IS_PRINTED=${ZESHY_PRINT_CALLER_IS_PRINTED}"
        # If such heading is in the current output group (i.e., if the current
        # caller or some transitive parent of such caller on the call stack
        # is such group), determine whether or not a heading has been printed
        # in such group. See ${ZESHY_PRINT_CALL_STACK_ROOT} for further discussion.
#       if is_string_nonempty "${ZESHY_PRINT_CALL_STACK_ROOT}" and
#           is_call_stack_contains "${ZESHY_PRINT_CALL_STACK_ROOT}"; then
            # If some heading has already been printed for such group, delimit
            # the heading to be printed below from prior output with whitespace.
#           is_boolean_false "${ZESHY_PRINT_CALLER_IS_PRINTED}" or {
#               print 'non-first heading!'
#               print_newline
#           }
        # Else, such heading is *NOT* in the current output group. Start a new
        # group with same name as the caller.
#       else
#           print "setting new output group to \"$(get_caller_name)\""
#           ZESHY_PRINT_CALL_STACK_ROOT="$(get_caller_name)"
#       fi

        # Notify subsequent calls to this function that a heading has been
        # printed for such group. While we could set such boolean for the
        # specific cases necessitating its setting rather than for all cases
        # indiscriminantly, this approach invites fewer subtleties. Trust us.
#       ZESHY_PRINT_CALLER_IS_PRINTED=${ZESHY_BOOLEAN_TRUE}
#   }

# ....................{ STARTERS                           }....................
#FUXME: Improve documentation, please.
#declare_function '
#void set_print_function_caller(string caller_name="$(get_caller_name)")
#
#Set the current output caller (defaulting to the calling function or script).
#See ${ZESHY_PRINT_CALL_STACK_ROOT} for further discussion.
#'
#function set_print_function_caller() {
#    die_unless_args_0_to_1 'expected optional group name'
#    ZESHY_PRINT_CALL_STACK_ROOT="${1:-$(get_caller_name)}"
#    ZESHY_PRINT_CALLER_IS_PRINTED=${ZESHY_BOOLEAN_FALSE}
#}

#declare_global '
#boolean ZESHY_PRINT_CALLER_IS_PRINTED
#
#If true, at least one heading has been printed for the current output group.
#See ${ZESHY_PRINT_CALL_STACK_ROOT} for further discussion.
#'

#FUXME: Rename set_print_function_caller() to something a bit more fitting, and
#note that such function should really *NEVER* be called by any functions except
#print_*() functions.
#See such function for further details.
#printing a heading in the current output group, print_heading() precedes such
#heading by delimiting whitespace *UNLESS* this is the first heading to be
#printed for such group (i.e., no such heading has been printed yet). When
#printing a heading *NOT* in the current output group, print_heading() closes the
#previous group and opens a new group with same name as the caller.

#The output group of two or more headings is simply the topmost function
#or script either directly printing such headings by calling print_heading() or
#indirectly printing such headings by calling other functions and scripts calling
#print_heading().
#
#In the former case, no output group need be explicitly set, as print_heading()
#implicitly sets the current output group to that of the caller. (See below.)
#In the latter case, a output group must be explicitly set by calling
#set_print_function_caller(). (See such function for further details.)

# ....................{ PRINTERS ~ sections                }....................
#FUXME: Eliminate the distinction between say_first_section() and
#say_next_section() by replacing such functions with a single
#print_heading() function. This function internally retains the name of the last
#function that called this function (e.g., with a global string
#${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}). If such name is empty or different
#than the current function that called this function, print a first section
#heading; otherwise, print a next section heading. In either case, cache the
#current caller function name for use in the next call to this function. Pretty
#simple, actually.
#Ah, wait; that's not *quite* right. We actually need to search up the callstack
#for ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}; it's not enough to just assume
#that if the function directly calling this function differs, then we're in a
#new logical block of headings. Anyway, not terribly difficult. Be fun to write
#some callstack search routines, eh?
#Ah! Wait. Yes, we could implement such implicit searching, but it seems
#increasingly error-prone. Instead, the function prototype should resemble:
#
# string print_heading(
#   string heading, string heading_group = "$(get_caller_function_name)")
#
#Implement get_caller_name() as a function (not alias!) looking two up on the
#caller stack. This should work without error if the caller is in fact a global
#script; just return the script name, for example.
#
#The output group is an arbitrary name distinguishing this "group" of headings
#from other such groups, defaulting to the caller name. Callers performing
#complex logic should pass a different output group... Hmm. This is all well
#and good, but perhaps we should provide additional functions, as well:
#
# string set_print_function_caller(string heading_group = "$(get_caller_function_name)")
# string unset_print_function_caller()
#
#These set a global string ${ZESHY_PRINT_CALLER}. Then, slightly change
#print_heading() to:
#
# string print_heading(
#   string heading,
#   string heading_group = "${ZESHY_PRINT_CALLER:-$(get_caller_function_name)}")
#
#print_heading() then internally compares the passed heading_group (with the above
#default) to its cached ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME} (which should
#probably be ${ZESHY_PRINT_CALLER_PRIOR}). If different... well, you know the game.
#
#Sweet. That seems just right. Simple functions can just call print_heading() with
#one argument without needing to call set_print_function_caller() or
#unset_print_function_caller(). More complex functions can just call print_heading() with
#two arguments. And truly complex groups of functions can call set_print_function_caller()
#prior to calling print_heading() with one argument prior to calling
#unset_print_function_caller().
#
#Hmmm; set_print_function_caller() and unset_print_function_caller() might cause too many head-
#aches, hmm? Just calling print_heading() with two arguments should suffice for
#an initial implementation, no? Ah; wait. We really just need the following:
#
# string print_heading(string heading)
# string set_print_function_caller(string heading_group = "$(get_caller_function_name)")
# string unset_print_function_caller()
#
#Tada! Flash. Crash. Bamb.
#FUXME: Hmmm. Heading groups seem a tad overkill, actually. *AS WELL AS NON-
#TRIVIAL* to interact with properly, as it's the caller's responsibility to then
#ensure calling unset_print_function_caller() in an "} always {...}" block surrounding
#such code. Right. You know, the prior search-up-the-call-stack method is
#actually pretty rockin'. We'll just need to define an additional separate
#function setting ${ZESHY_HEADING_CALL_STACK_ROOT} to the caller name and then search
#for such caller in the call stack on subsequent calls to print_heading(). No need
#for set_print_function_caller() and set_print_function_caller() or for passing an optional
#output group parameter to print_heading(). *SWEEEET*.

#declare_function '
#string say_first_section(string header1, string header2, ...)
#
#Print the passed strings as the header of a section (i.e., a contiguous block
#of related output). Sections demarcate print_string into logical blocks, each
#preceded by a terse header synopsizing such block. To ensure aesthetic output,
#call this function *ONLY* on the first such section and say_next_section()
#on all remaining sections.
#'
#function say_first_section() {
#    print_message "[${@}]"
#}

#declare_function '
#string say_first_section(string header1, string header2, ...)
#
#Print the passed strings as the header of any section other than the first.
#'
#function say_next_section() {
#    print_newline
#    say_first_section "${@}"
#}

        # Border colors.
#       string\
#           color_border="${ZESHY_COLOR[blue]}"\
#           color_joiner="${ZESHY_COLOR[blue_bold]}"\
#           color_heading="${ZESHY_COLOR[grey_bold]}"

            # If no heading has been printed for such group, this is the first.
            # Inform future calls to this function that a heading has now been
            # printed for such group.
#           if is_boolean_false "${ZESHY_PRINT_CALLER_IS_PRINTED}"
#           then
#               print 'first heading!'
#               ZESHY_PRINT_CALLER_IS_PRINTED=${ZESHY_BOOLEAN_TRUE}
            # Else, some heading has been printed for such group. Since this is
            # not the first, delimit such heading from prior with whitespace.
#           else
#               print 'non-first heading!'
#               print_newline
#           fi

#           else is_heading_first=${ZESHY_BOOLEAN_FALSE}

    # If true, such heading is the first to be printed for the current heading
    # group. To simplify logic below, defaults to true.
#   boolean is_heading_first=${ZESHY_BOOLEAN_TRUE}

    # If such heading is *NOT* the first to be printed for the current heading
    # group, delimit such heading from prior headings with whitespace.
#   is_boolean_false "${is_heading_first}" and print_newline

    # Else, this function was called directly from the command line. While edge
    # case, such unlikelihood must be accounted for.
#   else is_heading_first=${ZESHY_BOOLEAN_TRUE}
#   fi

    # Validate passed arguments.
#   die_unless_args 'expected at least one string'
# false, thus preceding headings by such whitespace.
    # If this function has been called at least once, string global
    # ${ZESHY_PRINT_CALLER} should have been set by such call. In
    # such case, search the current call stack for a function or script with
    # such name. See ${ZESHY_PRINT_CALLER} for further details.
#in the call stack under which all  transitively calling responsible for 
#
#Name of the most recent output group to track state for calls to print_heading()
#or the empty string if no such group .
#Name of the function or script to most recently called print_heading().
#On subsequent calls, print_heading() searches the current call stack for a
#function or script with such name. If found, the passed heading cannot be the
#first heading to be printed for such caller; else the passed heading *IS* the
#first heading to be printed for such caller. print_heading() prints such heading
#accordingly (e.g., prefixing non-first headings with blank newlines).
#string ZESHY_PRINT_CALLER
#           character_border='━'
#           character_joiner_left='❴'
#           character_joiner_right='❵'
#           character_border='━⁆⦃❴᚜{'
#           character_border='━━ hello ᚜'
#           character_joiner_left='{'
#           character_joiner_left='⦃'
#           character_joiner_right='⦄'
#           color_heading="${ZESHY_COLOR[green]}"
#           color_joiner="${ZESHY_COLOR_BOLD[green]}"\
#in deciding whether a passed heading is the first to have been printed for the
#caches such name to assist subsequent calls to print_heading() in deciding whether
#a passed heading is the first to have been printed for the
#function or script currently calling print_heading(),
#
#, which
#uses such name to determine whether or not a passed heading is the first to
#have been printed for such function or script.
#
#heading to be . in subsequent calls to print_heading().

#Name of the most recent function or script to have called print_heading().

#FUXME: Admit it: this is pretty sucky output. Let's prettify this, please! Try
#calling output() rather than say() with output resembling:
#
#=====================[ output                             ]====================
#
#Clearly, the output should scale with terminal width. If terminal width is too
#small (say, <= 20), forego the desired heuristic and just output the passed
#section. Hmm... or not? Let's not edge case, for now. Just assume everything
#works. 8) O.K.; here we go:
#
#* Divide terminal width by 4, apportioning the left and right banners each 1/4
#  the width and the middle section 2/4 (1/2) the width.
#* Don't worry about centering output. We'd rather columns line up vertically.
#* And...that's it, really. Shouldn't be too cumbersome, nay? The slightly hard
#  part is ensuring that, if the terminal width is not cleanly divisible by 4:
#  * Round all divisions *DOWN*, for safety.
#  * Add the difference of the terminal width and the summation of the three
#    widths (i.e., left banner, right banner, section header) back to the
#    section header. That should do us right, no?
#* Naturally, it'd be nice to colorify this, too. All things come.
#FUXME: Print the actual headings with output_hard_rule_titled(), as discussed in
#the "output" component.

#           color_outline="${ZESHY_COLOR[blue]}"\
#           color_outline="${ZESHY_COLOR[grey]}"\
#           color_divider="${ZESHY_COLOR_BOLD[grey]}"\
#           print_string "incremented right border to ${east_outline_count} characters"

#FUXME: I must admit, I'm no longer enamoured with such nomenclature. Consider
#renaming say() to print_message (), cry() to print_warning(), output_hard_rule() back
#to output_hard_rule(), and so on elsewhere. The distinction between "print" and
#"say" has been largely unhelpful and rather confusing, given that functions
#such as print_call_stack() now print colored output. I mean, what, would we
#rename functions from "print_" to "say_" on the implementation changing to
#color output? No, of course not! So, the distinction really doesn't mean
#anything anymore. Strike it, sir.

# with thematic embellishment (e.g., colors).
# The say() and cry() functions defined here appear after and hence override
# the previously defined functions of the same name defined by "main".

#FUXME: Cumbersome. Not only is accessing such colors in a safe manner
#excrutiatingly awkward, verbose, and slightly slow (e.g.,
#"${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}"), it's also unnecessary:
#simply declare a new map global ${ZESHY_COLOR_STYLE} initialized on Zeshy
#*STARTUP AFTER* declaring ${ZESHY_COLOR} as follows:
#
#ZESHY_COLOR_STYLE=(
#   ignorable   "${ZESHY_COLOR[grey]}"
#   incidental  "${ZESHY_COLOR[grey_bold]}"
#   caller_name "${ZESHY_COLOR[blue]}"
#)
#
#Obviously, only *GLOBALLY* applicable styles should go in here. Should be quite
#fast to initialize, using only zsh parameter expansions. *SIGNIFICANTLY* easier
#to access; for example, say()'s implementation now resembles:
#
#    print_string "${ZESHY_COLOR_STYLE[caller_name]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[ignorable]-}: ${ZESHY_COLOR[white_bold]-}${*}"
#
#FUXME: O.K., so, the obvious is patently awesome. But I wonder if we can do any
#better? In particular, I'd like ZESHY_COLOR_STYLE to be user configurable. I
#mean, why should users have to setup their own discrete theme just to be able to
#tweak a single color? That said, the obvious issue arises that ${ZESHY_COLOR}
#will not have been initialized at configuration sourcing time; hence, we'd have
#to list only color *names*, perhaps in a separate map resembling:
#
#ZESHY_COLOR_STYLE_NAME_TO_COLOR_NAME=(
#   ignorable   grey
#   incidental  grey_bold
#   caller_name blue
#)
#
#We'd have to then parse that to initialize ${ZESHY_COLOR_STYLE}, which arguably
#becomes a bit less efficient. It's probably fine to do so at Zeshy startup for
#now, but in the future tense we might consider defining individual global maps
#ZESHY_COLOR_STYLE_2, ZESHY_COLOR_STYLE_8, and so on copied all-at-once into
#ZESHY_COLOR_STYLE, much as for ZESHY_COLOR and siblings. Mhhhm; yes. Should
#work perfectly, ya-ya!
#
#Throw the above map into a new configuration file
#"if_config/if_shell_interactive/00-color", and away we go! :-0

#   print_string "${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}$(get_call_stack_root_basename)${ZESHY_COLOR[${ZESHY_COLOR_NAME_IGNORABLE-z}]-}: ${ZESHY_COLOR[yellow_bold]-}${*}" 1>&2
#   print_string "${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}$(get_call_stack_root_basename)${ZESHY_COLOR[${ZESHY_COLOR_NAME_IGNORABLE-z}]-}: ${ZESHY_COLOR[white_bold]-}${*}"
#declare_global '
#string ZESHY_COLOR_NAME_CALLER_NAME
#
#Name of the color used for caller names (e.g., printed by say() and cry()). Such
#name is any key of map global ${ZESHY_COLOR}.
#'
#ZESHY_COLOR_NAME_CALLER_NAME='blue'
#
#declare_global '
#string ZESHY_COLOR_NAME_IGNORABLE
#
#Name of the color used for ignorable strings (e.g., spurious punctuation). Such
#name is any key of map global ${ZESHY_COLOR}.
#'
#ZESHY_COLOR_NAME_IGNORABLE='grey'

#FUXME: Odd. Under root, but *NOT* customary users, this version is *NOT*
#overriding the original version defined under "main". What the...? Right.
#Pretty obvious: since "main" defines say(), the difference of functions defined
#after and before sourcing the Zeshy codebase fails to include say() (i.e.,
#say() was defined both after and before such sourcing). My only question is:
#how was this *EVER* working? It really shouldn't have been, right? Assuming
#that to be the issue, what would a *REASONABLE* solution be? I'd rather not
#hard-code function names in the "compile" differencing code, but unsure whether
#a sane alternative exists.
#FUXME: Define a new output_hard_rule_titled() function accepting a banner, printing
#such title centered in such banner.
    # Dismantled, this is:
    #
    # * "(l:..::..:)", expanding to the second argument padded (i.e., repeated)
    #   to the length specified with the first argument.
    # Define a placeholder variable to avoid "parameter not set" warnings below.
#   string placeholder
#       "${ZESHY_COLOR[grey]}${(l:$(get_terminal_width)::${character_banner}:)placeholder}"
    # Character constituting such banner.
#FUXME: Incidentally, we *REALLY* want a print_message_interactively() function. It's long
#past time, so make it so!
#   print_warning "${*}" |& output_string_sans_newline 1>&2
