#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle error, exception, and warning output.
______________<heredoc?>______________

#FIXME: The current overly simplistic get_print_message_prefix()-based approach
#should be jettisoned in favor of a Unicode box-drawing based approach: e.g.,
#
#/------------------------------[ zsh_gone_bad() ]-----------------------------\
#| An error has been thrown. It is a horrible error, but others are probably   |
#| worse.                                                                      |
#\-----------------------------------------------------------------------------/
#
#What's particularly nice about such an approach is that it inherently delimits
#prior from subsequent output. Indeed, we needn't even prefix such output with
#delimiting whitespace anymore, which is particularly nice.

# ....................{ PRINTERS ~ error                   }....................
declare_function_with_stdin <<'/---'
[stderr: string] print_error(string message1 = "", string message2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard error as an error message.
See print_message() for further details.
/---
function print_error() {
    print_string "${ZESHY_STYLE_TO_COLOR[print_error.caller]-}$(get_call_stack_root_basename)${ZESHY_STYLE_TO_COLOR[print_error.colon]-}: ${ZESHY_STYLE_TO_COLOR[print_error.message]-}${*}" 1>&2
}

declare_function_with_stdin <<'/---'
[stderr: string] print_error_exit_status(integer exit_status)

Print a description of the passed non-zero exit status to standard error. This
function is intended to be called only by die_with_exit_status(), whose
implementation guarantees state assumed by this function (e.g., a call stack
containing at least three callers).
/---
function print_error_exit_status() {
    # Validate passed arguments.
    die_unless_arg 'expected one exit status'
    string exit_status="${1}" caller_caller_name
    die_unless_integer_nonnegative "${exit_status}"

    #FIXME: Actually, this is terrible. For too many fragile assumptions that
    #just don't pan out in reality. The simplest fix is to simply search the
    #call stack from the caller of this function up the call stack until finding
    #a caller *NOT* matching the following glob:
    #
    #    ('TRAPZERR'|'die'('_'*|))
    #
    #Such caller is basically guaranteed to be as close to the desired runnable
    #name as we can get, and should suffice for 99% of cases. It's also rather
    #efficient to do, given list index flags. I'm dead certain we perform a
    #similar search on the call stack elsewhere, as well. Grep us up!

    # Get the caller's caller's name (i.e., the name of the runnable running the
    # runnable calling this function). Assuming this function to have been
    # called by die_with_exit_status() as is typically the case, the current
    # call stack contains at least three and typically four stack frames:
    #
    # * ${funcstack[1]}, this function.
    # * ${funcstack[2]}, the die_with_exit_status() function.
    # * ${funcstack[3]}, the caller. This is typically either the
    #   intermediate zeshy-specific TRAPZERR() or die() functions.
    # * ${funcstack[4]}, the caller's caller. Assuming ${funcstack[3]} to be
    #   either TRAPZERR() or die(), this is the actual "caller."
    #
    # If this is the case, the fourth stack frame identifies the desired caller.
    if (( ${#funcstack} >= 4 )) {
        caller_caller_name="${funcstack[4]}"
    # Else, the call stack contains three or fewer stack frames. While
    # unexpected, this is certainly permissible (e.g., to avoid recursively
    # throwing exceptions from exception handlers). Arbitrarily select the last
    # such frame to identify the desired caller.
    } else {
        caller_caller_name="${funcstack[-1]}"
    }

    #FIXME: Style names are no longer quite right (e.g., "print_error.colon").
    #Define new "print_error_exit_status."-prefixed styles specific to this
    #function.
    #FIXME: Clearly, only output "()" if such caller is a function rather than
    #script. It would be foolish to duplicate the similar functionality of
    #output_call_stack() already doing so; hence, abstract such functionality
    #into a new function print_runnable_name() to be called both here and in
    #output_call_stack(). Nice!

    # Print such status. Avoid redirecting to standard error, as the caller
    # (typically die_with_exit_status()) is assumed to already do so.
    print_string "${ZESHY_STYLE_TO_COLOR[print_error.caller]-}${caller_caller_name}${ZESHY_STYLE_TO_COLOR[print_error.colon]-}() ${ZESHY_STYLE_TO_COLOR[print_error.message]-}failed with exit status ${exit_status}"
}

# ....................{ PRINTERS ~ warning                 }....................
declare_function_with_stdin <<'/---'
[stderr: string] print_warning(string message1 = "", string message2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard error as a warning message.
See print_message() for further details.
/---
function print_warning() {
    # Avoid calling "print -u2 -- "${message}". While such a command appears
    # superficially identical to the following command, passing the desired file
    # descriptor as an argument fails to preserve interleaving with prior
    # commands printing to file descriptor 1 (i.e., standard out).
    print_string "${ZESHY_STYLE_TO_COLOR[print_warning.caller]-}$(get_call_stack_root_basename)${ZESHY_STYLE_TO_COLOR[print_warning.colon]-}: ${ZESHY_STYLE_TO_COLOR[print_warning.message]-}${*}" 1>&2
}

# --------------------( WASTELANDS                         )--------------------
    # Size of the current call stack, including the call to this function.
    # Avoid calling get_call_stack_size(), which tends to behave erratically
    # when called from within an exception handler.
#   integer call_stack_size=${#funcstack}

#   if (( call_stack_size >= 4 )) {
#       if is "${funcstack[3]}" == ('TRAPZERR'|'die') si {
#           caller_caller_name="${funcstack[4]}"
#       } else {
#           #FUXME: Doesn't this also constitute an error condition?
#           print "caller caller name: ${funcstack[3]}\ncaller caller caller name: ${funcstack[4]}"
#           caller_caller_name="${funcstack[3]}"
#       }
#   #FUXME: Doesn't this also constitute an error condition?
#   } elif (( call_stack_size == 3 )) {
#       caller_caller_name="${funcstack[3]}"
#   } elif (( call_stack_size == 2 )) {
#       die "print_error_exit_status() called by ${funcstack[2]}() rather than die_with_exit_status()"
#   } else {  # elif (( call_stack_size == 1 )) {
#       print "call stack size: ${#funcstack}; ${call_stack_size}\nfuncstack[2]: ${funcstack[2]}"
#       die "print_error_exit_status() not callable directly from the CLI"
#   }

#; call_stack_size="$(get_call_stack_size)"
#declare_function_with_stdin <<'/---'
#string print_warning_sans_newline_suffix(
#    string message1 = "", string message2, ...)
#
#Print the passed strings (defaulting to the empty string) suffixed by no newline
#and decorated by user-configured colors to standard error as a warning message.
#See print_warning() for further details.
#/---
#function print_warning_sans_newline_suffix() {
#    print_string_sans_newline_suffix "$(print_warning "${@}" 2>&1)" 1>&2
#}
