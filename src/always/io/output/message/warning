#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *warning printers* (i.e., functions printing nonfatal warning messages).
/---

# ....................{ PRINTERS                           }....................
#FIXME: Add example. See print_message().
declare_function_with_stdin <<'/---'
[stderr: string] print_warning(string message1 = "", ...)

Print the passed strings (defaulting to the empty string) as a warning entitled
under the name of the runnable originating the current call stack to standard
error. See print_message() for further details.
/---
function print_warning() {
    {
        print_string_titled_in_style_caller "${*}"\
            "$(output_call_stack_title_in_style_caller) Warning"
    } to_stderr:
}

declare_function_with_stdin <<'/---'
string :print_warning_item(string item1, ...)

Print the passed string(s) as an itemized warning, wrapped to the width of the
current terminal but neither prefixed by a heading or suffixed by a footer. See
print_message_item() for further details.
/---
function :print_warning_item() {
    die_unless_args 'Expected one or more strings.'
    :print_stderr_start
    { wrap_string_in_style_caller "${*}" } to_stderr:
    :print_stderr_stop
}

#FIXME: In lieu of unit tests...
#function waro() {
#    print_warning 'Writing down my infinity. Writing for all eternity. Eliminate inner parenthesis. Now combine like terms remembering to watch negative signs.'
#}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Still not quite right. We want the "Warning" printed in the
    #"print_warning.heading.text" style. This *REALLY* suggests a shift to a
    #refactored function resembling:
    #
    #   "$(output_call_stack_title_with_suffix ' Warning')" } to_stderr
    #
    #This then allows us to provide a generalized function for use in
    #print_exception() resembling:
    #
    #   "$(output_call_stack_lists_title_with_suffix\
    #       ZESHY_EXCEPTION_FUNCSTACK\
    #       ZESHY_EXCEPTION_FUNCSOURCETRACE\
    #       ' Exception')"
    #
    #O.K.; make it so. This *REALLY* doesn't work otherwise.
#    { print_string_titled_in_style_caller "${*}"\
#        "$(output_call_stack_root_basename_in_style\
#            'print_warning.heading.runnable.') Warning" } to_stderr

# (i.e., as
#output by output_call_stack_root_runnable())

#   print_string_titled_in_style_caller "${*}" "$(output_call_stack_root_in_style)" 1>&2
    # To ensure Avoid calling run_code_to_stderr()
#Print the passed strings (defaulting to the empty string) suffixed by a newline
#and decorated by user-configured colors to standard error as a warning message.
    # Avoid calling "print -u2 -- "${message}". While such a command appears
    # superficially identical to the following command, passing the desired file
    # descriptor as an argument fails to preserve interleaving with prior
    # commands printing to file descriptor 1 (i.e., standard out).
#   print_string "${ZESHY_STYLE_TO_COLOR[print_warning.caller]-}$(output_call_stack_root_in_style)${ZESHY_STYLE_TO_COLOR[print_warning.colon]-}: ${ZESHY_STYLE_TO_COLOR[print_warning.message]-}${*}" 1>&2
