#!/usr/bin/env zsh
# ====================[ message                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle output messages, warnings, and errors.

# ....................{ PRINTERS                           }....................
#FIXME: Consider prefixing messages under cron with: "["$(date +'%F %T')"].

document_function '
string print_message(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard output as a message.
'
function print_message() {
    print_string_colored "${ZESHY_COLOR_STYLE[print_message.caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[print_message.colon]-}: ${ZESHY_COLOR_STYLE[print_message.message]-}${*}"
}

document_function '
string print_warning(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard error as a warning.
'
function print_warning() {
    # Avoid calling "print -u2 -- "${message}". While such a command appears
    # superficially identical to the following command, passing the desired file
    # descriptor as an argument fails to preserve interleaving with prior
    # commands printing to file descriptor 1 (i.e., standard out).
    print_string_colored "${ZESHY_COLOR_STYLE[print_warning.caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[print_warning.colon]-}: ${ZESHY_COLOR_STYLE[print_warning.message]-}${*}" 1>&2
}

# ....................{ PRINTERS ~ error                   }....................
document_function '
string print_error(string message1 = "", string message2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
and decorated by user-configured colors to standard error as an error message.
'
function print_error() {
    print_string_colored "${ZESHY_COLOR_STYLE[print_error.caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[print_error.colon]-}: ${ZESHY_COLOR_STYLE[print_error.message]-}${*}" 1>&2
}

#FIXME: Rename to print_error_exit_status().
document_function '
string print_error_exit_status(integer exit_status)

Print a description of the passed non-zero exit status to standard output. This
function is intended to be called only by die_with_exit_status(), whose
implementation guarantees state assumed by this function (e.g., a call stack
containing at least three callers).
'
function print_error_exit_status() {
    # Validate passed arguments.
    die_unless_arg 'expected one exit status'
    string exit_status="${1}"
    die_unless_integer_nonnegative "${exit_status}"

    # Size of the current call stack, including the call to this function.
    integer call_stack_size; call_stack_size="$(get_call_stack_size)"

    # Caller's caller's name (i.e., the name of the function or script calling
    # the function or script calling this function). Assuming this function to
    # have been called by die_with_exit_status(), the current call stack
    # contains at least three and typically four stack frames:
    #
    # * ${funcstack[1]}, this function.
    # * ${funcstack[2]}, the die_with_exit_status() function.
    # * ${funcstack[3]}, the caller. This is typically either the
    #   intermediate Zeshy-specific TRAPZERR() or die() functions.
    # * ${funcstack[4]}, the caller's caller. Assuming ${funcstack[2]} to be
    #   either TRAPZERR() or die(), this is the actual "caller."
    string caller_caller_name
    if (( call_stack_size >= 4 )) and is "${funcstack[3]}" == (TRAPZERR|die) si
    then caller_caller_name="${funcstack[4]}"
    elif (( call_stack_size == 3 ))
    then caller_caller_name="${funcstack[3]}"
    else die "not called by die_with_exit_status()"
    fi

    # Print such status. Avoid redirecting to standard error, as
    # die_with_exit_status() already does so.
    print_string_colored "${ZESHY_COLOR_STYLE[print_error.caller]-}${caller_caller_name}${ZESHY_COLOR_STYLE[print_error.colon]-}: ${ZESHY_COLOR_STYLE[print_error.message]-}failed with exit status ${exit_status}"
}

# ....................{ PRINTERS ~ newline                 }....................
document_function '
string print_message_unnewlined(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by no newline
to standard output, typically with thematic embellishment (e.g., colors).
'
function print_message_unnewlined() {
    print_string_unnewlined "$(print_message "${*}")"
}

document_function '
string print_warning_unnewlined(string text1, string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by no newline
to standard error, typically with thematic embellishment (e.g., colors).
'
function print_warning_unnewlined() {
    print_string_unnewlined "$(print_warning "${*}" 2>&1)" 1>&2
}

# ....................{ PRINTERS ~ interactive             }....................
document_function '
string print_message_interactively(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard output if the current shell is interactive or silently return
without printing anything otherwise. See say() for further details.
'
function print_message_interactively() {
    is_shell_interactive and print_message "${@}"
}

# ....................{ PRINTERS ~ hard rule               }....................
document_function '
string print_hard_rule(void)

Print a hard rule (i.e., horizontal line) to standard output.
'
function print_hard_rule() {
    # Validate sanity.
    die_if_args
    string hard_rule character_hard_rule

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
    if is_locale_character_encoding_utf8
    then character_hard_rule='‚ïê'
    else character_hard_rule='='
    fi

    # Print such rule.
    hard_rule="$(repeat_string "${character_hard_rule}" $(get_terminal_width))"
    print_string_colored "${ZESHY_COLOR_STYLE[print_hard_rule]}${hard_rule}"
}

# ....................{ EXCEPTIONS                         }....................
#FIXME: Interestingly, we don't actually want all exceptions to be handled. We
#always want *UNEXPECTED* exceptions to be handled. Expected exceptions,
#however, should only be handled if the current user's Zeshy configuration
#requests such handling, which should be disabled by default. The canonical
#example of an expected exception is an external command wrapped by a Zeshy
#function returning non-zero exit status on failing to find a match (e.g.,
#"command grep" wrapped by grep_path()). Note that even in this case, of course,
#not all errors emitted by "command grep" are expected: only on failing to find
#a match, which must be explicitly tested for. This suggests a new helper
#function die_unhandled(), which (as expected) does everything die() does but
#excludes only the call to handle_exception(). Since this reduplicates a great
#deal of intricate code, perhaps die() and die_unhandled() can simply delegate
#to an internal utility function with prototype:
#
# string die_handled_if(
#   string error_message = '', boolean is_handling_exception)
#
#Obviously, such functions should be shifted to a new component in the proper
#Zeshy codebase: say, "shell/exception".
#FIXME: While such functionality is essential for oddball corner-cases (e.g.,
#"grep"), what we generally want is a simple way of squelching exceptions when
#the current shell is interactive *AND* the current call stack ends with a
#particular function that was called by some other particular function earlier
#in such stack. This could possibly be implemented as a global map from the
#former to latter, which function die() and associates would need to respect.
#Consider the following definition:
#
#map_global_export\
#    ZESHY_EXCEPTION_HIDE_IF_INTERACTIVELY_THROWN_BY_FUNCTION_NAMES
#
#Ah; wait. The "_INTERACTIVELY" is redundant, since such code paths can only
#come about as interactive alias expansions. Also, it's not specifically
#function names -- it's runnable names. Reduce to:
#
#map_global_export\
#    ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES
#
#Define such global as follows:
#
#ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES=(
#    'ls' 'l'
#    'ls' 'ls'
#    'grep' 'g'
#    'grep' 'grep'
#    'grep' 'gr'
#    ...
#)
#
#Now, that's in a great format for consumption by die_*() functions. But it's
#not really the greatest for definition; given the tenuous nature of interactive
#aliases, we really want to automate definition of such global. This should,
#naturally, be done by the interactive_abbreviation() and
#interactive_substitution() functions. (O.K.; I suppose interactive_alias()
#applies as well.) Under interactive_substitution(), it's easy to set two such
#entries: for both, the key is the command name being substituted; for the
#first, the value is the same name; for the second, the value is such
#substitution's abbreviation (if any!). Under interactive_abbreviation(),
#thing's are a bit less automated: we'll need to improve
#interactive_abbreviation() to accept an optional second argument specifying the
#name of the core underlying external command that such abbreviation eventually
#runs. Hence, this:
#
#    interactive_abbreviation {cal}endar{q}uarter='print_calendar_quarter'
#
#...would need to be expanded to this:
#
#    interactive_abbreviation {cal}endar{q}uarter='print_calendar_quarter' cal
#
#This then adds a single entry to the above global resembling this:
#
#    ZESHY_EXCEPTION_HIDE_IF_THROWN_BY_RUNNABLE_NAMES+='cal' 'calq'
#
#There's really no other sensible way to handle abbreviations. This works, it's
#only a minor nuisance; let's go-goggogogogo-go!
#
#The first steps, clearly, will be automating interactive_substitution() to
#perform such definition and die() to respect such definition (possibly subject
#to a user-configurable boolean enabling or disabling such functionality). After
#getting that to work, then contemplate the extension of such logic to
#interactive_abbreviation(). Such global could (possibly) be called:
#
#    boolean_global_export ZESHY_IS_HANDLING_ERROR_IF_THROWN_BY_NONHANDLING_RUNNABLES
#
#Hmm; what about:
#
#    boolean_global_export ZESHY_IS_ERROR_HANDLED_IF_HIDDEN
#    ZESHY_IS_ERROR_HANDLED_IF_HIDDEN=${ZESHY_BOOLEAN_FALSE}
#
#Much better. >)

# string die_unhandled(string error_message = '')
#function die_unhandled() {
#    #FIXME: Implement such function. Unsure this is the best name, to be honest.
#    die_handled_if "${@}" ${ZESHY_BOOLEAN_FALSE}
#}

# --------------------( WASTELANDS                         )--------------------
#FUXME: I must admit, I'm no longer enamoured with such nomenclature. Consider
#renaming say() to print_message (), cry() to print_warning(), print_hard_rule() back
#to print_hard_rule(), and so on elsewhere. The distinction between "print" and
#"say" has been largely unhelpful and rather confusing, given that functions
#such as print_call_stack() now print colored output. I mean, what, would we
#rename functions from "print_" to "say_" on the implementation changing to
#color output? No, of course not! So, the distinction really doesn't mean
#anything anymore. Strike it, sir.

# with thematic embellishment (e.g., colors).
# The say() and cry() functions defined here appear after and hence override
# the previously defined functions of the same name defined by "main".

#FUXME: Cumbersome. Not only is accessing such colors in a safe manner
#excrutiatingly awkward, verbose, and slightly slow (e.g.,
#"${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}"), it's also unnecessary:
#simply declare a new map global ${ZESHY_COLOR_STYLE} initialized on Zeshy
#*STARTUP AFTER* declaring ${ZESHY_COLOR} as follows:
#
#ZESHY_COLOR_STYLE=(
#   ignorable   "${ZESHY_COLOR[grey]}"
#   incidental  "${ZESHY_COLOR[grey_bold]}"
#   caller_name "${ZESHY_COLOR[blue]}"
#)
#
#Obviously, only *GLOBALLY* applicable styles should go in here. Should be quite
#fast to initialize, using only zsh parameter expansions. *SIGNIFICANTLY* easier
#to access; for example, say()'s implementation now resembles:
#
#    print_string_colored "${ZESHY_COLOR_STYLE[caller_name]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[ignorable]-}: ${ZESHY_COLOR[white_bold]-}${*}"
#
#FUXME: O.K., so, the obvious is patently awesome. But I wonder if we can do any
#better? In particular, I'd like ZESHY_COLOR_STYLE to be user configurable. I
#mean, why should users have to setup their own discrete theme just to be able to
#tweak a single color? That said, the obvious issue arises that ${ZESHY_COLOR}
#will not have been initialized at configuration sourcing time; hence, we'd have
#to list only color *names*, perhaps in a separate map resembling:
#
#ZESHY_COLOR_STYLE_NAME_TO_COLOR_NAME=(
#   ignorable   grey
#   incidental  grey_bold
#   caller_name blue
#)
#
#We'd have to then parse that to initialize ${ZESHY_COLOR_STYLE}, which arguably
#becomes a bit less efficient. It's probably fine to do so at Zeshy startup for
#now, but in the future tense we might consider defining individual global maps
#ZESHY_COLOR_STYLE_2, ZESHY_COLOR_STYLE_8, and so on copied all-at-once into
#ZESHY_COLOR_STYLE, much as for ZESHY_COLOR and siblings. Mhhhm; yes. Should
#work perfectly, ya-ya!
#
#Throw the above map into a new configuration file
#"if_config/if_shell_interactive/00-color", and away we go! :-0

#   print_string_colored "${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}$(get_call_stack_root_basename)${ZESHY_COLOR[${ZESHY_COLOR_NAME_IGNORABLE-z}]-}: ${ZESHY_COLOR[yellow_bold]-}${*}" 1>&2
#   print_string_colored "${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}$(get_call_stack_root_basename)${ZESHY_COLOR[${ZESHY_COLOR_NAME_IGNORABLE-z}]-}: ${ZESHY_COLOR[white_bold]-}${*}"
#document_global '
#string ZESHY_COLOR_NAME_CALLER_NAME
#
#Name of the color used for caller names (e.g., printed by say() and cry()). Such
#name is any key of map global ${ZESHY_COLOR}.
#'
#ZESHY_COLOR_NAME_CALLER_NAME='blue'
#
#document_global '
#string ZESHY_COLOR_NAME_IGNORABLE
#
#Name of the color used for ignorable strings (e.g., spurious punctuation). Such
#name is any key of map global ${ZESHY_COLOR}.
#'
#ZESHY_COLOR_NAME_IGNORABLE='grey'

#FUXME: Odd. Under root, but *NOT* customary users, this version is *NOT*
#overriding the original version defined under "main". What the...? Right.
#Pretty obvious: since "main" defines say(), the difference of functions defined
#after and before sourcing the Zeshy codebase fails to include say() (i.e.,
#say() was defined both after and before such sourcing). My only question is:
#how was this *EVER* working? It really shouldn't have been, right? Assuming
#that to be the issue, what would a *REASONABLE* solution be? I'd rather not
#hard-code function names in the "compile" differencing code, but unsure whether
#a sane alternative exists.
#FUXME: Define a new print_hard_rule_titled() function accepting a banner, printing
#such title centered in such banner.
    # Dismantled, this is:
    #
    # * "(l:..::..:)", expanding to the second argument padded (i.e., repeated)
    #   to the length specified with the first argument.
    # Define a placeholder variable to avoid "parameter not set" warnings below.
#   string placeholder
#       "${ZESHY_COLOR[grey]}${(l:$(get_terminal_width)::${character_banner}:)placeholder}"
    # Character constituting such banner.
#FUXME: Incidentally, we *REALLY* want a print_message_interactively() function. It's long
#past time, so make it so!
#   print_warning "${*}" |& print_string_unnewlined 1>&2
