#!/usr/bin/env zsh
# ====================[ output                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle standard output and error in a theme-aware manner (e.g., colorfully).

# ....................{ SAYERS                             }....................
# The say() and cry() functions defined here appear after and hence override
# the previously defined functions of the same name defined by "main".

#FIXME: Consider prefixing messages under cron with: "["$(date +'%F %T')"].
#FIXME: Odd. Under root, but *NOT* customary users, this version is *NOT*
#overriding the original version defined under "main". What the...? Right.
#Pretty obvious: since "main" defines say(), the difference of functions defined
#after and before sourcing the Zeshy codebase fails to include say() (i.e.,
#say() was defined both after and before such sourcing). My only question is:
#how was this *EVER* working? It really shouldn't have been, right? Assuming
#that to be the issue, what would a *REASONABLE* solution be? I'd rather not
#hard-code function names in the "compile" differencing code, but unsure whether
#a sane alternative exists.

document_function '
string say(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard output, typically with thematic embellishment (e.g., colors).
'
function say() {
    print_string_colored "${ZESHY_COLOR[white]-}$(get_call_stack_root_basename)${ZESHY_COLOR[grey]-}: ${ZESHY_COLOR_BOLD[white]-}${*}"
}

document_function '
string cry(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard error, typically with thematic embellishment (e.g., colors).
'
function cry() {
    # Avoid calling "print -u2 -- "${message}". While such a command appears
    # superficially identical to the following command, passing the desired file
    # descriptor as an argument fails to preserve interleaving with prior
    # commands printing to file descriptor 1 (i.e., standard out).
    print_string_colored "${ZESHY_COLOR[yellow]-}$(get_call_stack_root_basename)${ZESHY_COLOR[grey]-}: ${ZESHY_COLOR_BOLD[yellow]-}${*}" 1>&2
}

# ....................{ SAYERS ~ newline                   }....................
document_function '
string say_nonnewlined(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by no newline
to standard output, typically with thematic embellishment (e.g., colors).
'
function say_nonnewlined() {
    print_string_nonnewlined "$(say "${*}")"
}

document_function '
string cry_nonnewlined(string text1, string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by no newline
to standard error, typically with thematic embellishment (e.g., colors).
'
function cry_nonnewlined() {
    print_string_nonnewlined "$(cry "${*}" 2>&1)" 1>&2
}

# ....................{ SAYERS ~ interactive               }....................
document_function '
string say_interactively(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard output if the current shell is interactive or silently return
without printing anything otherwise. See say() for further details.
'
function say_interactively() {
    is_shell_interactive and say "${@}"
}

# ....................{ SAYERS ~ banner                    }....................
document_function '
string say_banner(void)

Print a single-line banner to standard output.
'
function say_banner() {
    # Validate sanity.
    die_if_args
    string banner character_banner

    # If the current locale encodes to UTF-8, prefer such character.
    if is_locale_character_encoding_utf8
    then character_banner='═'
    # Else, default to a portable ASCII character.
    else character_banner='='
    fi

    # Print such banner.
    banner="$(repeat_string "${character_banner}" $(get_terminal_width))"
    print_string_colored "${ZESHY_COLOR[blue]}${banner}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Define a new say_banner_titled() function accepting a banner, printing
#such title centered in such banner.
    # Dismantled, this is:
    #
    # * "(l:..::..:)", expanding to the second argument padded (i.e., repeated)
    #   to the length specified with the first argument.
    # Define a placeholder variable to avoid "parameter not set" warnings below.
#   string placeholder
#       "${ZESHY_COLOR[grey]}${(l:$(get_terminal_width)::${character_banner}:)placeholder}"
    # Character constituting such banner.
#FUXME: Incidentally, we *REALLY* want a say_interactively() function. It's long
#past time, so make it so!
#   cry "${*}" |& print_string_nonnewlined 1>&2
