#!/usr/bin/env zsh
# ====================[ output                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle standard output and error in a theme-aware manner (e.g., colorfully).

# ....................{ GLOBALS                            }....................
#FIXME: Cumbersome. Not only is accessing such colors in a safe manner
#excrutiatingly awkward, verbose, and slightly slow (e.g.,
#"${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}"), it's also unnecessary:
#simply declare a new map global ${ZESHY_COLOR_STYLE} initialized on Zeshy
#*STARTUP AFTER* declaring ${ZESHY_COLOR} as follows:
#
#ZESHY_COLOR_STYLE=(
#   ignorable   "${ZESHY_COLOR[grey]}"
#   incidental  "${ZESHY_COLOR[grey_bold]}"
#   caller_name "${ZESHY_COLOR[blue]}"
#)
#
#Obviously, only *GLOBALLY* applicable styles should go in here. Should be quite
#fast to initialize, using only zsh parameter expansions. *SIGNIFICANTLY* easier
#to access; for example, say()'s implementation now resembles:
#
#    print_string_colored "${ZESHY_COLOR_STYLE[caller_name]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[ignorable]-}: ${ZESHY_COLOR[white_bold]-}${*}"
#
#FIXME: O.K., so, the obvious is patently awesome. But I wonder if we can do any
#better? In particular, I'd like ZESHY_COLOR_STYLE to be user configurable. I
#mean, why should users have to setup their own discrete theme just to be able to
#tweak a single color? That said, the obvious issue arises that ${ZESHY_COLOR}
#will not have been initialized at configuration sourcing time; hence, we'd have
#to list only color *names*, perhaps in a separate map resembling:
#
#ZESHY_COLOR_STYLE_NAME_TO_COLOR_NAME=(
#   ignorable   grey
#   incidental  grey_bold
#   caller_name blue
#)
#
#We'd have to then parse that to initialize ${ZESHY_COLOR_STYLE}, which arguably
#becomes a bit less efficient. It's probably fine to do so at Zeshy startup for
#now, but in the future tense we might consider defining individual global maps
#ZESHY_COLOR_STYLE_2, ZESHY_COLOR_STYLE_8, and so on copied all-at-once into
#ZESHY_COLOR_STYLE, much as for ZESHY_COLOR and siblings. Mhhhm; yes. Should
#work perfectly, ya-ya!
#
#Throw the above map into a new configuration file
#"if_config/if_shell_interactive/00-color", and away we go! :-0

# ....................{ SAYERS                             }....................
# The say() and cry() functions defined here appear after and hence override
# the previously defined functions of the same name defined by "main".

#FIXME: Consider prefixing messages under cron with: "["$(date +'%F %T')"].

document_function '
string say(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard output, typically with thematic embellishment (e.g., colors).
'
function say() {
    print_string_colored "${ZESHY_COLOR_STYLE[say_caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[punctuation]-}: ${ZESHY_COLOR[white_bold]-}${*}"
}

document_function '
string cry(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard error, typically with thematic embellishment (e.g., colors).
'
function cry() {
    # Avoid calling "print -u2 -- "${message}". While such a command appears
    # superficially identical to the following command, passing the desired file
    # descriptor as an argument fails to preserve interleaving with prior
    # commands printing to file descriptor 1 (i.e., standard out).
    print_string_colored "${ZESHY_COLOR_STYLE[say_caller]-}$(get_call_stack_root_basename)${ZESHY_COLOR_STYLE[punctuation]-}: ${ZESHY_COLOR[yellow_bold]-}${*}"
}

# ....................{ SAYERS ~ newline                   }....................
document_function '
string say_nonnewlined(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by no newline
to standard output, typically with thematic embellishment (e.g., colors).
'
function say_nonnewlined() {
    print_string_nonnewlined "$(say "${*}")"
}

document_function '
string cry_nonnewlined(string text1, string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by no newline
to standard error, typically with thematic embellishment (e.g., colors).
'
function cry_nonnewlined() {
    print_string_nonnewlined "$(cry "${*}" 2>&1)" 1>&2
}

# ....................{ SAYERS ~ interactive               }....................
document_function '
string say_interactively(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) suffixed by a newline
to standard output if the current shell is interactive or silently return
without printing anything otherwise. See say() for further details.
'
function say_interactively() {
    is_shell_interactive and say "${@}"
}

# ....................{ SAYERS ~ banner                    }....................
document_function '
string say_banner(void)

Print a single-line banner to standard output.
'
function say_banner() {
    # Validate sanity.
    die_if_args
    string banner character_banner

    # If the current locale encodes to UTF-8, prefer such character.
    if is_locale_character_encoding_utf8
    then character_banner='â•'
    # Else, default to a portable ASCII character.
    else character_banner='='
    fi

    # Print such banner.
    banner="$(repeat_string "${character_banner}" $(get_terminal_width))"
    print_string_colored "${ZESHY_COLOR[blue]}${banner}"
}

# --------------------( WASTELANDS                         )--------------------
#   print_string_colored "${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}$(get_call_stack_root_basename)${ZESHY_COLOR[${ZESHY_COLOR_NAME_IGNORABLE-z}]-}: ${ZESHY_COLOR[yellow_bold]-}${*}" 1>&2
#   print_string_colored "${ZESHY_COLOR[${ZESHY_COLOR_NAME_CALLER_NAME-z}]-}$(get_call_stack_root_basename)${ZESHY_COLOR[${ZESHY_COLOR_NAME_IGNORABLE-z}]-}: ${ZESHY_COLOR[white_bold]-}${*}"
#document_global '
#string ZESHY_COLOR_NAME_CALLER_NAME
#
#Name of the color used for caller names (e.g., printed by say() and cry()). Such
#name is any key of map global ${ZESHY_COLOR}.
#'
#ZESHY_COLOR_NAME_CALLER_NAME='blue'
#
#document_global '
#string ZESHY_COLOR_NAME_IGNORABLE
#
#Name of the color used for ignorable strings (e.g., spurious punctuation). Such
#name is any key of map global ${ZESHY_COLOR}.
#'
#ZESHY_COLOR_NAME_IGNORABLE='grey'

#FUXME: Odd. Under root, but *NOT* customary users, this version is *NOT*
#overriding the original version defined under "main". What the...? Right.
#Pretty obvious: since "main" defines say(), the difference of functions defined
#after and before sourcing the Zeshy codebase fails to include say() (i.e.,
#say() was defined both after and before such sourcing). My only question is:
#how was this *EVER* working? It really shouldn't have been, right? Assuming
#that to be the issue, what would a *REASONABLE* solution be? I'd rather not
#hard-code function names in the "compile" differencing code, but unsure whether
#a sane alternative exists.
#FUXME: Define a new say_banner_titled() function accepting a banner, printing
#such title centered in such banner.
    # Dismantled, this is:
    #
    # * "(l:..::..:)", expanding to the second argument padded (i.e., repeated)
    #   to the length specified with the first argument.
    # Define a placeholder variable to avoid "parameter not set" warnings below.
#   string placeholder
#       "${ZESHY_COLOR[grey]}${(l:$(get_terminal_width)::${character_banner}:)placeholder}"
    # Character constituting such banner.
#FUXME: Incidentally, we *REALLY* want a say_interactively() function. It's long
#past time, so make it so!
#   cry "${*}" |& print_string_nonnewlined 1>&2
