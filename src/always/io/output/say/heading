#!/usr/bin/env zsh
# ====================[ heading                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle heading output (i.e., output split into topically related sections
# prefixed by a heading describing such section).

# ....................{ GLOBALS                            }....................
document_global '
string ZESHY_HEADING_GROUP_NAME

Name of the most recent heading group tracking internal state for say_heading()
or the empty string if neither say_heading() or set_heading_group() have been
called. The heading group of two or more headings is simply the topmost function
or script either directly printing such headings by calling say_heading() or
indirectly printing such headings by calling other functions and scripts calling
say_heading().

In the former case, no heading group need be explicitly set, as say_heading()
implicitly sets the current heading group to that of the caller. (See below.)
In the latter case, a heading group must be explicitly set by calling
set_heading_group(). (See such function for further details.)

In either case, the heading group notifies each call to say_heading() of whether
or not such call is printing a heading in the current heading group or not. When
printing a heading in the current heading group, say_heading() precedes such
heading by delimiting whitespace *UNLESS* this is the first heading to be
printed for such group (i.e., no such heading has been printed yet). When
printing a heading *NOT* in the current heading group, say_heading() closes the
previous group and opens a new group with same name as the caller.

A heading is in the current heading group if the current caller is either such
group or transitively called by such group. For example, if the current caller
is make_initramfs() and the current heading group is make_grub2_boot_image() (as
signified by "is ${ZESHY_HEADING_GROUP} == ''make_grub2_boot_image''"), then
since make_grub2_boot_image() transitively calls make_initramfs(), such heading
is in the current heading group and will be printed accordingly.
'

document_global '
boolean ZESHY_HEADING_GROUP_IS_PRINTED

If true, at least one heading has been printed for the current heading group.
See ${ZESHY_HEADING_GROUP_NAME} for further discussion.
'

# ....................{ STARTERS                           }....................
#FIXME: Improve documentation, please.
document_function '
void set_heading_group(string heading_group_name="$(get_caller_name)")

Set the current heading group (defaulting to the calling function or script).
See ${ZESHY_HEADING_GROUP_NAME} for further discussion.
'
function set_heading_group() {
    die_unless_args_0_to_1 'expected optional group name'
    ZESHY_HEADING_GROUP_NAME="${1:-$(get_caller_name)}"
    ZESHY_HEADING_GROUP_IS_PRINTED=${ZESHY_BOOLEAN_FALSE}
}

# ....................{ PRINTERS                           }....................
#FIXME: Improve documentation, please.
document_function '
string say_heading(string text1 = "", string text2, ...)

Print the passed heading (defaulting to the empty string) in the current heading
group. See ${ZESHY_HEADING_GROUP_NAME} for further discussion.
'
function say_heading() {
    # Heading to be printed, concatenated from passed arguments.
    string heading="${*}"

    # If *NOT* called directly from the command line, this function was called
    # by another function or script. Determine whether the heading just passed
    # by such caller is in the current heading group.
    is_caller and {
#       print "ZESHY_HEADING_GROUP_NAME=${ZESHY_HEADING_GROUP_NAME}"
#       print "ZESHY_HEADING_GROUP_IS_PRINTED=${ZESHY_HEADING_GROUP_IS_PRINTED}"
        # If such heading is in the current heading group (i.e., if the current
        # caller or some transitive parent of such caller on the call stack
        # is such group), determine whether or not a heading has been printed
        # in such group. See ${ZESHY_HEADING_GROUP_NAME} for further discussion.
        if is_string_nonempty "${ZESHY_HEADING_GROUP_NAME}" and
            is_call_stack_contains "${ZESHY_HEADING_GROUP_NAME}"; then
            # If some heading has already been printed for such group, delimit
            # the heading to be printed below from prior output with whitespace.
            is_boolean_false "${ZESHY_HEADING_GROUP_IS_PRINTED}" or {
#               print 'non-first heading!'
                print_newline
            }
        # Else, such heading is *NOT* in the current heading group. Start a new
        # group with same name as the caller.
        else
#           print "setting new heading group to \"$(get_caller_name)\""
            set_heading_group "$(get_caller_name)"
        fi

        # Notify subsequent calls to this function that a heading has been
        # printed for such group. While we could set such boolean for the
        # specific cases necessitating its setting rather than for all cases
        # indiscriminantly, this approach invites fewer subtleties. Trust us.
        ZESHY_HEADING_GROUP_IS_PRINTED=${ZESHY_BOOLEAN_TRUE}
    }

    # Relevant integer lengths.
    integer terminal_width heading_length
    terminal_width="$(get_terminal_width)"
    heading_length="$(get_string_length "${heading}")"

    # Number of characters preceding such heading, when centering such heading
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures when the
    # terminal width and heading length are of differing parity that the heading
    # will be offset to the left one character from the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    integer character_count_left; character_count_left=$((\
        (${terminal_width} - ${heading_length}) / 2 ))

    #FIXME: It'd be great to eventually support the subdivision of the border
    #into appropriate subsections: e.g.,
    #
    #     ====~~~-{ heading }--~~~===
    #
    #The principal annoyance there, of course, is that for each possible
    #subdivision you add, you have to add the corresponding number of
    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
    #concoct a single governing equation determining how many characters of each
    #subdivision to print, even in edge cases of small terminal lines: e.g.,
    #
    #     ~-{ heading }-~

    # If such number is at least 2, such heading is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such heading remain for a border. Since this suffices for simple
    # ANSI art, print such heading preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
    if (( character_count_left >= 2 )); then
        # Number of border characters (e.g., "-") preceding and succeeding such
        # heading, respectively. Such numbers are always nonnegative (>= 0).
        integer border_count_left border_count_right
        (( border_count_left = border_count_right = character_count_left - 2 ))

        # If such heading length and terminal width have different parity (i.e.,
        # one is even and the other odd), 1 additional character of space to the
        # right of such heading remains for a border; allocate such space!
        is_integer_parity_equals ${terminal_width} ${heading_length} or
            border_count_right+=1

        # Character constituting both left and right borders.
        string character_border

        # Character constituting both left and right joiners (i.e., character
        # "joining" heading titles to adjacent borders).
        string character_joiner_left character_joiner_right

        # If the current locale encodes to UTF-8, prefer such characters.
        if is_locale_character_encoding_utf8; then
            character_border='─'
            character_joiner_left='{ '  # nothing better, I'm afraid
            character_joiner_right=' }'
        # Else, default to portable ASCII characters.
        else
            character_border='-'
            character_joiner_left='{ '
            character_joiner_right=' }'
        fi

        # Left and right borders consisting of such characters.
        string left_border right_border
        left_border="$( repeat_string "${character_border}" ${border_count_left})"
        right_border="$(repeat_string "${character_border}" ${border_count_right})"

        # Border colors.
        string\
            color_border="${ZESHY_COLOR[blue]}"\
            color_joiner="${ZESHY_COLOR[blue_bold]}"\
            color_heading="${ZESHY_COLOR[grey_bold]}"

        # Print such heading.
        print_string_colored\
            "${color_border}${left_border}${color_joiner}${character_joiner_left}${color_heading}${heading}${color_joiner}${character_joiner_right}${color_border}${right_border}"
    # If such number is 1, such heading's length is either 2 or 3 characters
    # less than such width. Hence, 1 character to the left of and either 1 or 2
    # characters to the right of such heading remain for a border. This isn't
    # terribly much. In the absence of anything better to do, print such heading
    # offset from the beginning of the terminal line by 1 character.
    elif (( character_count_left == 1 ))
    then print_string " ${heading}"
    # Else such number is nonpositive (i.e., less than or equal to 0).
    #
    # If such number is negative, such heading exceeds such terminal in length.
    # In the absence of anything better to do, print such heading as is. While
    # this guarantees such heading to wrap around at least once, truncating such
    # heading to the current terminal width often produces worse results.
    #
    # If such number is 0, such heading's length is either the terminal width or
    # one character less than such width. In the former case, no space remains
    # for a border; in the latter case, only one character of space remains,
    # hardly enough for even delimiting whitespace. In the absence of anything
    # better to do, again print such heading as is.
    #
    # For efficiency, unify the above two cases.
    else  # guard condition :: elif (( character_count_left <= 0 ))
        print_string "${heading}"
    fi
}

#FIXME: In lieu of unit tests, this will do.
#function sayh() {
#    set_heading_group
#    say_heading 'dancing to'
#    print 'life'
#    brayman
#    say_heading 'road to'
#    print 'ubar'
#}
#function brayman() {
#    say_heading 'beyond'
#    print 'genesis'
#    say_heading 'ein'
#    print 'lichtschein'
#}

# ....................{ PRINTERS ~ sections                }....................
#FIXME: Eliminate the distinction between say_first_section() and
#say_next_section() by replacing such functions with a single
#say_heading() function. This function internally retains the name of the last
#function that called this function (e.g., with a global string
#${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}). If such name is empty or different
#than the current function that called this function, print a first section
#heading; otherwise, print a next section heading. In either case, cache the
#current caller function name for use in the next call to this function. Pretty
#simple, actually.
#Ah, wait; that's not *quite* right. We actually need to search up the callstack
#for ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME}; it's not enough to just assume
#that if the function directly calling this function differs, then we're in a
#new logical block of headings. Anyway, not terribly difficult. Be fun to write
#some callstack search routines, eh?
#Ah! Wait. Yes, we could implement such implicit searching, but it seems
#increasingly error-prone. Instead, the function prototype should resemble:
#
# string say_heading(
#   string heading, string heading_group = "$(get_caller_function_name)")
#
#Implement get_caller_name() as a function (not alias!) looking two up on the
#caller stack. This should work without error if the caller is in fact a global
#script; just return the script name, for example.
#
#The heading group is an arbitrary name distinguishing this "group" of headings
#from other such groups, defaulting to the caller name. Callers performing
#complex logic should pass a different heading group... Hmm. This is all well
#and good, but perhaps we should provide additional functions, as well:
#
# string set_heading_group(string heading_group = "$(get_caller_function_name)")
# string unset_heading_group()
#
#These set a global string ${ZESHY_HEADING_GROUP}. Then, slightly change
#say_heading() to:
#
# string say_heading(
#   string heading,
#   string heading_group = "${ZESHY_HEADING_GROUP:-$(get_caller_function_name)}")
#
#say_heading() then internally compares the passed heading_group (with the above
#default) to its cached ${ZESHY_SAY_HEADING_CALLER_FUNCTION_NAME} (which should
#probably be ${ZESHY_HEADING_GROUP_PRIOR}). If different... well, you know the game.
#
#Sweet. That seems just right. Simple functions can just call say_heading() with
#one argument without needing to call set_heading_group() or
#unset_heading_group(). More complex functions can just call say_heading() with
#two arguments. And truly complex groups of functions can call set_heading_group()
#prior to calling say_heading() with one argument prior to calling
#unset_heading_group().
#
#Hmmm; set_heading_group() and unset_heading_group() might cause too many head-
#aches, hmm? Just calling say_heading() with two arguments should suffice for
#an initial implementation, no? Ah; wait. We really just need the following:
#
# string say_heading(string heading)
# string set_heading_group(string heading_group = "$(get_caller_function_name)")
# string unset_heading_group()
#
#Tada! Flash. Crash. Bamb.
#FIXME: Hmmm. Heading groups seem a tad overkill, actually. *AS WELL AS NON-
#TRIVIAL* to interact with properly, as it's the caller's responsibility to then
#ensure calling unset_heading_group() in an "} always {...}" block surrounding
#such code. Right. You know, the prior search-up-the-call-stack method is
#actually pretty rockin'. We'll just need to define an additional separate
#function setting ${ZESHY_HEADING_CALLER_NAME} to the caller name and then search
#for such caller in the call stack on subsequent calls to say_heading(). No need
#for set_heading_group() and set_heading_group() or for passing an optional
#heading group parameter to say_heading(). *SWEEEET*.

document_function '
string say_first_section(string header1, string header2, ...)

Print the passed strings as the header of a section (i.e., a contiguous block
of related output). Sections demarcate print_string into logical blocks, each
preceded by a terse header synopsizing such block. To ensure aesthetic output,
call this function *ONLY* on the first such section and say_next_section()
on all remaining sections.
'
function say_first_section() {
    say "[${@}]"
}

document_function '
string say_first_section(string header1, string header2, ...)

Print the passed strings as the header of any section other than the first.
'
function say_next_section() {
    print_newline
    say_first_section "${@}"
}

# --------------------( WASTELANDS                        )--------------------
            # If no heading has been printed for such group, this is the first.
            # Inform future calls to this function that a heading has now been
            # printed for such group.
#           if is_boolean_false "${ZESHY_HEADING_GROUP_IS_PRINTED}"
#           then
#               print 'first heading!'
                ZESHY_HEADING_GROUP_IS_PRINTED=${ZESHY_BOOLEAN_TRUE}
            # Else, some heading has been printed for such group. Since this is
            # not the first, delimit such heading from prior with whitespace.
#           else
#               print 'non-first heading!'
#               print_newline
#           fi

#           else is_heading_first=${ZESHY_BOOLEAN_FALSE}

    # If true, such heading is the first to be printed for the current heading
    # group. To simplify logic below, defaults to true.
#   boolean is_heading_first=${ZESHY_BOOLEAN_TRUE}

    # If such heading is *NOT* the first to be printed for the current heading
    # group, delimit such heading from prior headings with whitespace.
#   is_boolean_false "${is_heading_first}" and print_newline

    # Else, this function was called directly from the command line. While edge
    # case, such unlikelihood must be accounted for.
#   else is_heading_first=${ZESHY_BOOLEAN_TRUE}
#   fi

    # Validate passed arguments.
#   die_unless_args 'expected at least one string'
# false, thus preceding headings by such whitespace.
    # If this function has been called at least once, string global
    # ${ZESHY_HEADING_GROUP} should have been set by such call. In
    # such case, search the current call stack for a function or script with
    # such name. See ${ZESHY_HEADING_GROUP} for further details.
#in the call stack under which all  transitively calling responsible for 
#
#Name of the most recent heading group to track state for calls to say_heading()
#or the empty string if no such group .
#Name of the function or script to most recently called say_heading().
#On subsequent calls, say_heading() searches the current call stack for a
#function or script with such name. If found, the passed heading cannot be the
#first heading to be printed for such caller; else the passed heading *IS* the
#first heading to be printed for such caller. say_heading() prints such heading
#accordingly (e.g., prefixing non-first headings with blank newlines).
#string ZESHY_HEADING_GROUP
#           character_border='━'
#           character_joiner_left='❴'
#           character_joiner_right='❵'
#           character_border='━⁆⦃❴᚜{'
#           character_border='━━ hello ᚜'
#           character_joiner_left='{'
#           character_joiner_left='⦃'
#           character_joiner_right='⦄'
#           color_heading="${ZESHY_COLOR[green]}"
#           color_joiner="${ZESHY_COLOR_BOLD[green]}"\
#in deciding whether a passed heading is the first to have been printed for the
#caches such name to assist subsequent calls to say_heading() in deciding whether
#a passed heading is the first to have been printed for the
#function or script currently calling say_heading(),
#
#, which
#uses such name to determine whether or not a passed heading is the first to
#have been printed for such function or script.
#
#heading to be . in subsequent calls to say_heading().

#Name of the most recent function or script to have called say_heading().

#FUXME: Admit it: this is pretty sucky output. Let's prettify this, please! Try
#calling output() rather than say() with output resembling:
#
#=====================[ output                             ]====================
#
#Clearly, the output should scale with terminal width. If terminal width is too
#small (say, <= 20), forego the desired heuristic and just output the passed
#section. Hmm... or not? Let's not edge case, for now. Just assume everything
#works. 8) O.K.; here we go:
#
#* Divide terminal width by 4, apportioning the left and right banners each 1/4
#  the width and the middle section 2/4 (1/2) the width.
#* Don't worry about centering output. We'd rather columns line up vertically.
#* And...that's it, really. Shouldn't be too cumbersome, nay? The slightly hard
#  part is ensuring that, if the terminal width is not cleanly divisible by 4:
#  * Round all divisions *DOWN*, for safety.
#  * Add the difference of the terminal width and the summation of the three
#    widths (i.e., left banner, right banner, section header) back to the
#    section header. That should do us right, no?
#* Naturally, it'd be nice to colorify this, too. All things come.
#FUXME: Print the actual headings with say_banner_titled(), as discussed in
#the "output" component.

#           color_outline="${ZESHY_COLOR[blue]}"\
#           color_outline="${ZESHY_COLOR[grey]}"\
#           color_divider="${ZESHY_COLOR_BOLD[grey]}"\
#           print_string "incremented right border to ${east_outline_count} characters"
