#!/usr/bin/env zsh
# ====================[ output                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle low-level print functions (e.g., newlines, nulls, strings, lists).

#FIXME: O.K.; we need to manually sift through the codebase and change all
#current calls to print_string() for purposes of returning values to
#return_string() instead. The former now performs additional logic conflicting
#with mere value returning; the latter does not. Unavoidable, I'm afraid. As a
#positive bonus, however, the codebase will be moderately more readable.

# ....................{ GLOBALS                            }....................
declare_global_with_stdin <<'________________<heredoc?>________________'
integer ZESHY_PRINTER_STDOUT_MTIME
________________<heredoc?>________________

declare_global_with_stdin <<'________________<heredoc?>________________'
string ZESHY_PRINTER_NAME
________________<heredoc?>________________

#FIXME: Excise everywhere, shifting documentation above where applicable. I
#recall only referencing this global in this component. Check on that...
declare_global_with_stdin <<'________________<heredoc?>________________'
string ZESHY_PRINT_CALL_STACK_ROOT

Most recent call stack root to have called a high-level print function (e.g.,
print_message(), print_warning()) or the empty string if no such function has
been called, where "call stack root" is the first zsh function, script, or
command line to have initiated the current call stack.

Specifically, this string is the first element of list global ${funcfiletrace}
at the time of the most recent call to a high-level print function as recorded
by print_newline_if_call_stack_root_same(). zsh tracks call stack state with
two list globals: ${funcname} and ${funcfiletrace}. The former distinguishes
between calls to different functions and scripts but *NOT* between different
calls to the same function or script or between different command lines. The
latter distinguishes between all such calls, hence subsuming the former. Given
only a filename and line, inspecting such line usually furnishes the function
name called on such line. Therefore, each element of ${funcfiletrace} uniquely
identifies the corresponding call in the call stack. Since the first element of
such list corresponds to the caller responsible for initiating the entire call
stack, such element effectively differentiates such stack from subsequent call
stacks initiated by other callers.

See print_newline_if_call_stack_root_same() for further details.
________________<heredoc?>________________

# ....................{ SETTERS                            }....................
#FIXME: Rename to set_printer_globals_if_needed().
#FIXME: Rewrite documentation.
declare_function_with_stdin <<'________________<heredoc?>________________'
void reset_print_call_stack_root(void)

If standard output for the current shell is attached to a terminal, set the
stored call stack root specific to Zeshy print functions to the current call
stack root. This function is typically called by low-level Zeshy print functions
(e.g., print_string()) to notify subsequently called high-level print functions
(e.g., print_message()) that at least one such print function has already been
called under the current call stack root and that
print_newline_if_call_stack_root_same() should thus print a delimiting newline.
________________<heredoc?>________________
function reset_print_call_stack_root() {
    # Validate sanity.
    die_if_args

    # Store the modification time for such output. Use
    # ${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH} rather than
    # ${ZESHY_STDOUT_PATH} for such purposes, as Linux updates such time for
    # the former but not latter on output. Technically, we can also use the
    # canonicalization of ${ZESHY_STDOUT_PATH} for such purposes; since this
    # is both less efficient and without benefit, we prefer the former path.
    ZESHY_PRINTER_STDOUT_MTIME="$(\
        get_path_mtime "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}")"

    # Store the caller name.
    ZESHY_PRINTER_NAME="${funcfiletrace[2]}"
    print "resetting ZESHY_PRINTER_STDOUT_MTIME: ${ZESHY_PRINTER_STDOUT_MTIME}; ZESHY_PRINTER_NAME: ${ZESHY_PRINTER_NAME}" 1>&2
}

# ....................{ PRINTERS ~ newline                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_newline(void)

Print a blank line to standard output.
________________<heredoc?>________________
function print_newline() {
    die_if_args
    print
    reset_print_call_stack_root
}

#FIXME: Rename to print_newline_if_needed().
#FIXME: Adjust the conditions under which a newline is printed to the following:
#
#* If ${ZESHY_PRINTER_NAME} is unequal to the currently called printer
#  function name (e.g., "print_message"),
#* If ${ZESHY_PRINTER_STDOUT_MTIME} is non-empty (or non-zero, if we
#  decide to use an integer as we probably should) *AND* unequal to the
#  current mtime for "/dev/fd/1" *AND*
#* Then and only then print a newline.
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_newline_if_call_stack_root_same(void)

Print a blank line to standard output if at least one Zeshy print function has
already been called under the current call stack root (i.e., called either by
such root or by a function or script transitively called by such root). This
function is typically called by high-level Zeshy print functions (e.g.,
print_message()) to print a newline delimiting subsequent from previous output.
See ${ZESHY_PRINT_CALL_STACK_ROOT} for further details.
________________<heredoc?>________________
function print_newline_if_call_stack_root_same() {
    # Validate sanity.
    die_if_args
#   print_call_stack

    # If:
    #
    # * Standard output for the current shell is attached to either a terminal
    #   or pipe (e.g., page_stdin()) (thus avoiding printing a newline when
    #   ,
    # * The current shell previously called a Zeshy-specific printer function,
    # * The previously and currently called printer functions differ,
    # * The modification time of standard output at the time of the previously
    #   and currently called printer functions differ, called printer function 
    # * printer functions differ,
    #
    # Prefer an "if"- to "and"-style conditional to avoid returning false.
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler). Subtleties abound, dear acolytes.
    if { is_stdout_terminal_or_pipe } and
        is -n "${ZESHY_PRINTER_NAME-}" and
              "${ZESHY_PRINTER_NAME-}" == "${funcfiletrace[2]}" and\
          "${ZESHY_PRINTER_STDOUT_MTIME-0}" -ne\
          "$(get_path_mtime "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}")" si {
    }

#      (( ZESHY_PRINTER_STDOUT_MTIME )) and
    #FIXME: Convert to an "if" statement and attempt to remove the trailing
    #return_true().

    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
    #
    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler). Subtleties abound, dear acolytes.
#   print "printing newline if equals: ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT-}; funcfiletrace[-1]: ${funcfiletrace[-1]}" 1>&2; print_call_stack 1>&2
#   is "${ZESHY_PRINT_CALL_STACK_ROOT-}" == "${funcfiletrace[-1]}" si and
#       print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    # Succeed regardless of whether such newline was printed.
#   return_true
}

# ....................{ PRINTERS ~ stdin                   }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void print_stdin(void)

Get standard input piped to the current shell. Since subshells do not inherit
piped input, avoid calling this function from subshells (e.g., as
`$(get_stdin_piped)`). Consider calling is_stdin_nonempty() before this function
to ensure such input exists: e.g.,

.print_stdin()
==========================================
[source]
------------------------------------------
>>> function pachamama() {
...     if { is_stdin_nonempty } {
...         print_stdin
...     } else {
...         print_string "${@}"
...     }
... }
>>> print_string tawantinsuyu | pachamama
tawantinsuyu
>>> pachamama tawantinsuyu
tawantinsuyu
------------------------------------------
==========================================
________________<heredoc?>________________
function print_stdin() {
    # Validate sanity.
    die_if_args
    die_if_stdin_empty

    # Print such input.
    < "${ZESHY_STDIN_PATH}"

    # Close such input, ensuring is_stdin_nonempty() subsequently returns false.
    close_stdin

    # Store printer function globals, if needed.
    reset_print_call_stack_root
}

# ....................{ PRINTERS                           }....................
# No print_string*() functions call prepend_args_with_stdin_if_piped(),
# as doing so often invites obscene issues. When called by a caller receiving
# piped input, print_string*() functions silently capturing and closing such
# input before the caller can do so break such caller in subtle and *VERY*
# difficult to debug ways. Moreover, there are no to few reasonable scenarios in
# which print_string*() functions would be piped rather than merely passed input
# strings. For straightforward safety, avoid inviting such wayward breakage.

declare_function_with_stdin <<'________________<heredoc?>________________'
string print_string(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline.
Unlike low-level builtins echo() and print(), this and most other printer
functions print embedded escape sequences as is rather than converting such
sequences to the corresponding characters. Such conversions often mangle
arbitrary output and hence are generally unhelpful. See
print_string_with_escapes() for further details.

Avoid calling such low-level builtins, which behave unexpectedly dangerously
when passed hyphen-prefixed strings: e.g.,

.print_string() versus print()
==========================================
[source]
------------------------------------------
>>> string lammoth="-z" morgoth="rm -rf *"

# Bad! Never do this, unless guaranteed no hyphens prefix such string.
# If hyphens do prefix such string, zsh treats the first word of such
# string as options to print(). This can be extremely unsafe, as this
# example demonstrates.
>>> print "${lammoth}" "${morgoth}"
>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

# Good. Always do this, instead.
>>> print_string "${lammoth}" "${morgoth}"
-z rm -rf *    # That's more like it.
------------------------------------------
==========================================
________________<heredoc?>________________
function print_string() {
    die_unless_args 'expected at least one string'
    print -r -- "${*}"
    reset_print_call_stack_root
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string curse_string(string text1, string text2, ...)

Print the passed strings to standard error with default trailing newline. See
print_string() for further details.
________________<heredoc?>________________
function curse_string() {
    die_unless_args 'expected at least one string'
    print -r -- "${*}" 1>&2
    reset_print_call_stack_root
}

# ....................{ PRINTERS ~ string                  }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_string_colored(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline in a
color-aware manner. Prefix and suffix such output with ANSI color codes
resetting color attributes to terminal-specific defaults.
________________<heredoc?>________________
function print_string_colored() {
    die_unless_args 'expected at least one string'
    print -r -- "${ZESHY_COLOR[reset]-}${*}${ZESHY_COLOR[reset]-}"
    reset_print_call_stack_root
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string print_string_sans_newline(string text1, string text2, ...)

Print the passed strings to standard output with no default trailing newline.
________________<heredoc?>________________
function print_string_sans_newline() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string text="${*}"

    # Print such string unnewlined.
    print -nr -- "${text}"

    # Unlike output printed by most printer functions, output printed by this
    # function can conceivably be the empty string. In such case, to avoid
    # printing an unwanted newline on the next call to a printer function, the
    # call stack root must not be reset. Since strings consisting of only ANSI
    # color codes are effectively the empty string, test for emptiness after
    # excluding such codes.
    (( $(get_string_length_printable_sans_ansi_colors "${text}") )) and {
#       print -r "string \"${text}\" length: $(get_string_length_printable_sans_ansi_colors "${text}")"
        reset_print_call_stack_root
    }

    # Succeed regardless of whether such root was reset.
    return_true
}

#FIXME: Still a poor name. How about print_string_recognizing_escapes()?
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_string_with_escapes(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline and
recognizing all escape sequences recognized by low-level builtins echo() and
print(). These include:

* `\a`, a bell character.
* `\b`, a backspace.
* `\c`, suppressing the final newline.
* `\e`, a escape.
* `\f`, a form feed.
* `\n`, a newline.
* `\r`, a carriage return.
* `\t`, a horizontal tab.
* `\v`, a vertical tab.
* `\\`, a backslash.
* `\0NNN`, the character with octal value NNN.
* `\xNN`, the character with hexadecimal value NN.
* `\C-X`, producing the control character corresponding to character X. Namely:
** `\C-@`, control character NUL (null).
** `\C-?`, control character DEL (delete).
* `\X`, where `X` is any character _not_ listed above, escaping and hence
  printing `X` as is.

For example:

.print_string_with_escapes()
==========================================
[source]
------------------------------------------
>>> string morning_window="\nTHEY are rattling breakfast plates...\n"
>>> print_string_with_escapes "${morning_window}"

THEY are rattling breakfast plates...

>>> print_string "${morning_window}"
\nTHEY are rattling breakfast plates...\n
------------------------------------------
==========================================
________________<heredoc?>________________
function print_string_with_escapes() {
    die_unless_args 'expected at least one string'
    print -- "${*}"
    reset_print_call_stack_root
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ PRINTERS ~ separated               }....................
#FUXME: Such functions should internally depend on new functions of new
#component "variable/string/separate", which actually perform the calling of
#builtin print(). Consider function names:
#
#* concatenate_strings() or unseparate_strings(). Probably the former; the
#  latter is simply odd. Right. Every language needs a concatenate function,
#  so... this is ours!
#* separate_strings_with_newline() or delimit_strings_by_newline(). The former.
#* separate_strings_with_null().
#FUXME: Rename this function to print_strings_concatenated().
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string print_strings_unseparated(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline and
#_not_ internally delimited by ${IFS}, the internal field separator: e.g.,
#
#.print_strings_unseparated()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_unseparated "Where Alph," "the sacred river," "ran"
#Where Alph,the sacred river,ran
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function print_strings_unseparated() {
#    # Temporarily set global string ${IFS} to the empty string. Since zsh
#    # implicitly delimits lists interpolated with the "*" operator when double-
#    # quoted with such global, the following commands print the passed arguments
#    # undelimited. This incantation was astonishingly difficult to discover.
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}"  # if not double-quoted, zsh oddly ignores ${IFS}
#    reset_print_call_stack_root
#}

#declare_function_with_stdin <<'________________<heredoc?>________________'
#string print_strings_newlined(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited by newlines: e.g.,
#
#.print_strings_newlined()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_newlined sludge elf transmuter
#sludge
#elf
#transmuter
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function print_strings_newlined() {
#    die_unless_args 'expected at least one string'
#    print -lr -- "${@}"
#    reset_print_call_stack_root
#}
#
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string print_strings_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
#
#.print_strings_nulled()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_nulled "Through caverns" "measureless to" "man"
#Through caverns\0measureless to\0man
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function print_strings_nulled() {
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}"
#    reset_print_call_stack_root
#}

#       ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#       print "resetting ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT}" 1>&2; print_call_stack 1>&2
    # Succeed regardless of whether such root was set.
#   return_true
    # If standard output for the current shell is attached to either a terminal
    # or pipe (e.g., page_stdin()), store such globals.
    #
    # Prefer an "if"- to "and"-style conditional to avoid returning false.
#   if { is_stdout_terminal_or_pipe } {

#FUXME: Rename to print_strings_unseparated() or print_strings_undelimited()?
#Yes, I rather like the latter. Though, the former is a bit more readable...
#FUXME: Rename to print_string_unnewlined() or perhaps simply
#print_string_sans_newline(). Yeah; the latter is pretty sweet.
#Print the passed strings to standard output without delimitation:
#FUXME: Hmm; this should really be called print_string_with_escapes(). Function
#name print_string_with_escapes() implies something completely different (i.e., that
#all shell-reserved characters will be printed escaped).

# common escapes escaped (i.e., converted to the corresponding characters):
# Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
# Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
# (i.e., such that a newline separates each such string from the next)
    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
#   if is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}"
#   then print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    #FUXME: This is now redundant, as the subsequent print_string_colored()
    #function sets this.

    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required. Instead, replace the previously recorded
    # call stack root with the current.
#   else ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#   fi

#Prefix the next string to be output with whitespace delimiting such string from
#previously output strings if at least one such string has already been output
#under the current call stack root. This function manages string global
#${ZESHY_PRINT_CALL_STACK_ROOT} on behalf of the caller, usually a high-level
#print function (e.g., print_message(), print_header()).
#
#FUXME: A bit unintuitive. Not sure either is terribly better, but how about
#renaming to print_string_no_newline() or print_string_newlineless() or
#print_string_sans_newline(). The latter coincides with print_strings_unseparated()
#and thus strikes me as the best bet.
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    print_message "${*}" | print_string_sans_newline
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   print_string_sans_newline "$(print_message "${*}")"
#   print_string_sans_newline "$(print_warning "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#declare_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_with_escapes().
#'
#function curse_string_escaped() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#declare_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, zsh oddly ignores ${IFS}
#}

#declare_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#declare_function '
#void curse_newline(void)
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to print_string_sans_newline(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#declare_function '
#void curse_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#declare_function '
#string print_string_colored_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See print_string_colored() for further details.
#'
#function print_string_colored_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   print_warning -> print_warning      curse_string -> outcry
#   print_message -> print_message      print_string -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
