#!/usr/bin/env zsh
# ====================[ print_string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle standard print_string and error.

# ....................{ PRINTERS                           }....................
document_function '
void print_string(string text1, string text2, ...)

Print the passed strings to standard print_string with default trailing newline.
Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
Avoid calling echo() or print(), which fail on hyphen-prefixed strings: e.g.,

    >>> string lammoth="-z" morgoth="rm -rf *"

    # Bad! Never do this, unless guaranteed no hyphens prefix such string.
    # If hyphens do prefix such string, Zsh treats the first word of such
    # string as options to print(). This can be extremely unsafe, as this
    # example demonstrates.
    >>> print "${lammoth}" "${morgoth}"
    >>> rm -rf *   # Don''t accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

    # Good. Always do this, instead.
    >>> print_string "${lammoth}" "${morgoth}"
    -z rm -rf *    # That''s more like it.
'
function print_string() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -r -- "${*}"
}

document_function '
void curse_string(string text1, string text2, ...)

Print the passed strings to standard error with default trailing newline.
Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
'
function curse_string() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -r -- "${*}" 1>&2
}

# ....................{ PRINTERS ~ color                   }....................
#FIXME: Define a new print_banner_titled() function accepting a banner, printing
#such title centered in such banner.
document_function '
string print_banner(void)

Print a single-line banner to standard output.
'
function print_banner() {
    # Validate passed arguments, defining a placeholder variable to avoid
    # "parameter not set" warnings below.
    die_if_args
    string placeholder

    # Dismantled, this is:
    #
    # * "(l:..::..:)", expanding to the second argument padded (i.e., repeated)
    #   to the length specified with the first argument.
    print_string_colored\
        "${ZESHY_COLOR[grey]}${(l:$(get_terminal_width)::=:)placeholder}"
}

document_function '
void print_string_colored(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline in a
color-aware manner. Prefix and suffix such output with ANSI color codes
resetting color attributes to terminal-specific defaults.
'
function print_string_colored() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -r -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
}

# ....................{ PRINTERS ~ escape                  }....................
document_function '
void print_string_escaped(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline and
all escapes escaped (i.e., converted to the corresponding characters): e.g.,

    >>> string morning_window="\nTHEY are rattling breakfast plates...\n"
    >>> print_string_escaped "${morning_window}"

    THEY are rattling breakfast plates...

    >>> print_string "${morning_window}"
    \nTHEY are rattling breakfast plates...\n
'
function print_string_escaped() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -- "${*}"
}

# ....................{ PRINTERS ~ delimiter               }....................
document_function '
void print_string_nulled(string text1, string text2, ...)

Print the passed strings to standard output delimited and terminated by nulls.
Suffix each such string with character "\0", in other words: e.g.,

    >>> print_string_nulled "Through caverns" "measureless to" "man"
    Through caverns\0measureless to\0man
'
function print_string_nulled() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -Nr -- "${@}"
}

document_function '
void print_string_undelimited(string text1, string text2, ...)

Print the passed strings to standard output without delimitation: e.g.,

    >>> print_string_undelimited "Where Alph," "the sacred river," "ran"
    Where Alph,the sacred river,ran
'
function print_string_undelimited() {
    # Temporarily set global string ${IFS} to the empty string. Since Zsh
    # implicitly delimits lists interpolated with the "*" operator when double-
    # quoted with such global, the following commands print the passed arguments
    # undelimited. This incantation was astonishingly difficult to discover.
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    string IFS=
    print -r -- "${*}"  # if not double-quoted, Zsh oddly ignores ${IFS}
}

# ....................{ PRINTERS ~ newline                 }....................
document_function '
void print_newline(void)

Print a blank line to standard output.
'
function print_newline() {
    die_if_args
    print
}

document_function '
void print_string_nonnewlined(string text1, string text2, ...)

Print the passed strings to standard output with no default trailing newline.
'
function print_string_nonnewlined() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -nr -- "${*}"
}

document_function '
void print_string_newlined(string text1, string text2, ...)

Print the passed strings to standard output delimited by newlines (i.e., such
that a newline separates each such string from the next): e.g.,

    >>> print_string_newlined sludge elf transmuter
    sludge
    elf
    transmuter
'
function print_string_newlined() {
    prepend_args_with_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print -lr -- "${@}"
}

document_function '
void print_list_newlined(
  string list_name,
  integer start_index = 1, integer end_index = -1)

Print the elements between the passed start and end indices (defaulting to the
first and last elements) of the list with the passed name to standard output
delimited by newlines. If no indices are passed, all elements are printed; if
one index is passed, only that index is passed. Negative indices are offset
from the end: e.g.,

    >>> list runes; runes=( abyss crypt pan tomb vaults )
    >>> print_list_newlined runes
    abyss
    crypt
    pan
    tomb
    vaults
    >>> print_list_newlined runes 3
    pan
    >>> print_list_newlined runes 3 -1
    pan
    tomb
    vaults
'
function print_list_newlined() {
    # Validate passed arguments.
    prepend_args_with_standard_input_if_piped
    die_unless_args_1_to_3\
        'expected one list name and optional start and end indices'
    string\
        list_name__pldbn="${1}"\
        index_first__pldbn="${2:-1}" index_last__pldbn="${3:--1}"

    #FIXME: Uncomment this when it's working again. It's currently not, so...
#   check_list_args "${list_name}" __index_first__ __index_last__

    # Output such list.
#   print "beg: ${beg_index}\nend: ${end_index}"
    print -lr --\
        "${${(@P)list_name__pldbn}[${index_first__pldbn},${index_last__pldbn}]}"
}

# ....................{ SAYERS                             }....................
# The say() and cry() functions defined here appear after and hence override
# the previously defined functions of the same name defined by "main".

document_function '
void say(string message = "")

Print the passed message to standard output with default trailing newline in a
theme-aware manner (e.g., with color on color terminals).
'
function say() {
    print_string_colored "${ZESHY_COLOR_BOLD[green]-}$(get_call_stack_root_basename)${ZESHY_COLOR_BOLD[grey]-}: ${ZESHY_COLOR_BOLD[white]-}${*}"
}

document_function '
void cry(string message = "")

Print the passed warning to standard error with default trailing newline in a
theme-aware manner (e.g., with color on color terminals).
'
function cry() {
    # Avoid calling "print -u2 -- "${message}". While such a command appears
    # superficially identical to the following command, passing the desired file
    # descriptor as an argument fails to preserve interleaving with prior
    # commands printing to file descriptor 1 (i.e., standard out).
    print_string_colored "${ZESHY_COLOR_BOLD[green]-}$(get_call_stack_root_basename)${ZESHY_COLOR_BOLD[grey]-}: ${ZESHY_COLOR_BOLD[yellow]-}${*}" 1>&2
}

# ....................{ SAYERS ~ newline                   }....................
document_function '
void say_nonnewlined(string text1, string text2, ...)

Print the passed message to standard output with no default trailing newline in
a theme-aware manner (e.g., with color on color terminals).
'
function say_nonnewlined() {
    say "${*}" | print_string_nonnewlined
}

document_function '
void cry_nonnewlined(string text1, string text2, ...)

Print the passed warning to standard error with no default trailing newline in a
theme-aware manner (e.g., with color on color terminals).
'
function cry_nonnewlined() {
    cry "${*}" |& print_string_nonnewlined 1>&2
}

# --------------------( WASTELANDS                         )--------------------
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    say "${*}" | print_string_nonnewlined
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   print_string_nonnewlined "$(say "${*}")"
#   print_string_nonnewlined "$(cry "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#document_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_escaped().
#'
#function curse_string_escaped() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#document_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, Zsh oddly ignores ${IFS}
#}

#document_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#document_function '
#void curse_newline(void)
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to print_string_nonnewlined(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#document_function '
#void curse_string_nonnewlined(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_nonnewlined() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#document_function '
#void print_string_colored_nonnewlined(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See print_string_colored() for further details.
#'
#function print_string_colored_nonnewlined() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   cry -> cry      curse_string -> outcry
#   say -> say      print_string -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
