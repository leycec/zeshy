#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle low-level *printers* (i.e., functions printing strings).
______________<heredoc?>______________

#FIXME: O.K.; we need to manually sift through the codebase and change all
#current calls to print_string() for purposes of returning values to
#return_string() instead. The former now performs additional logic conflicting
#with mere value returning; the latter does not. Unavoidable, I'm afraid. As a
#positive bonus, however, the codebase will be moderately more readable.

# ....................{ GLOBALS                            }....................
#FIXME: Should probably be initialized to 0 and the global below to "" when
#serialized into zeshy's user digest file. Unsure how to reliably accomplish
#that. Perhaps perform such initialization in a *VERY* late precompilation hook
#function? Alternately, we should probably just have a list global declared at
#the "src/compile" level of the names of all globals to be initialized to "="
#(i.e., the empty string) immediately before compilation into the digest. This
#is necessary for all globals tracking transient state and hence likely to be
#useful elsewhere in the future.

declare_global_with_stdin float ZESHY_PRINT_PRIOR_STDOUT_MTIME <<'/---'
Modification time of standard output at the time of the most recent call to
update_print_prior_globals() or 0 if such function has yet to be called.
/---

declare_global_with_stdin string ZESHY_PRINT_PRIOR_RUNNABLE_ID <<'/---'
Unique identifier of the previous runnable (e.g., print_message()) to have most
recently called update_print_prior_globals() or the empty string if such
function has yet to be called. Such identifier is the topmost element of stack
${funcfiletrace} at the time of such call.

`zsh` tracks call stack state with two list globals: ${funcname} and
${funcfiletrace}. Since ${funcname} elements are runnable names, such list
distinguishes between calls to different runnables but _not_ between different
calls to the same runnable. Since ${funcfiletrace} elements are filename and
line pairs signifying a runnable called on such line, such list distinguishes
between all calls and hence subsumes ${funcname} for purposes of uniquely
identifying runnables on the call stack.
/---

# ....................{ GLOBALS ~ trackers                 }....................
declare_function_with_stdin <<'/---'
void reset_print_prior_globals(void)

Reset globals tracking state for `zeshy` printer functions, including
${ZESHY_PRINT_PRIOR_STDOUT_MTIME} and ${ZESHY_PRINT_PRIOR_RUNNABLE_ID}. See
update_print_prior_globals() further details.
/---
function reset_print_prior_globals() {
    # Validate sanity.
    die_if_args

    # Reset such globals.
    ZESHY_PRINT_PRIOR_STDOUT_MTIME=0
    ZESHY_PRINT_PRIOR_RUNNABLE_ID=
}

declare_function_with_stdin <<'/---'
void update_print_prior_globals(void)

Update globals tracking state for `zeshy` printer functions, including
${ZESHY_PRINT_PRIOR_STDOUT_MTIME} and ${ZESHY_PRINT_PRIOR_RUNNABLE_ID}. Such
state assists subsequent calls to print_whitespace_if_needed() in deciding
whether prior output should be delimited from subsequent output with whitespace.
/---
function update_print_prior_globals() {
    # Validate sanity.
    die_if_args
    # When debugging, note that it's not genuinely possible to safely print
    # ${ZESHY_PRINT_PRIOR_STDOUT_MTIME}. Why? Because merely printing such float
    # changes the return value of get_stdout_mtime(), guaranteeing the next call
    # to print_whitespace_if_needed() to erroneously print whitespace. (Ugh.)
    output_string "resetting ZESHY_PRINT_PRIOR_RUNNABLE_ID: ${ZESHY_PRINT_PRIOR_RUNNABLE_ID}" 1>&2

    # Store the modification time of standard output.
    ZESHY_PRINT_PRIOR_STDOUT_MTIME="$(get_stdout_mtime)"

    # Store the caller name (hopefully, a printer function).
    ZESHY_PRINT_PRIOR_RUNNABLE_ID="${funcfiletrace[-2]-}"
#   print "resetting ZESHY_PRINT_PRIOR_RUNNABLE_ID: ${ZESHY_PRINT_PRIOR_RUNNABLE_ID}" 1>&2
}

declare_function_with_stdin <<'/---'
string print_whitespace_if_needed(void)

Print whitespace separating subsequent from prior shell output if:

* All of the following hold:
** The current shell previously called at least one `zeshy`-specific printer
   function (e.g., print_string(), print_heading()), a prerequisite of the
   condition below.
** The current function was _not_ called directly from the command line (i.e.,
   was called by another function), a prerequisite of the condition below.
** The function calling the current function differs from the most recently
   called printer function. If such functions are the same, their output should
   usually be conjoined rather than separated by whitespace; if such functions
   differ, however, separating their output with whitespace usually improves
   readability and aesthetics.
* Or:
** The current modification time of standard output (in seconds since the Unix
   epoch) differs from the previous such time recorded by the most recently
   called printer function, implying that another runnable run at least one
   second before the current call but after the most recently called printer
   function has printed to standard output without calling
   update_print_prior_globals() to update such time. In theory, all runnables
   should update such time after printing to standard output; in practice, the
   ``regulatory burden'' imposed by such a rule guarantees its unlikelihood.
   While this condition fails to detect runnables run in the same second as the
   current call which printed to standard output without updating such time, it
   does reliably detect older such runnables. This condition is a convenience
   fallback and should _not_ be counted upon.
/---
function print_whitespace_if_needed() {
    # Validate sanity.
    die_if_args
#   output_string "funcfiletrace[2]: ${funcfiletrace[2]-}\nZESHY_PRINT_PRIOR_RUNNABLE_ID: ${ZESHY_PRINT_PRIOR_RUNNABLE_ID-}"
#   print_call_stack

    #FIXME: O.K.; I've hunted down why this doesn't work as advertised. It's
    #exceptionally subtle but certainly solvable. Basically, it boils down to
    #get_stdout_mtime(): it's an inherently stupid function, because getters are
    #only ever called as process substitutions, which in this case always
    #returns the stdout of the subshell (a pipe!) rather than the stdout of the
    #current shell (typically, a pseudo-terminal). We need to *EXCISE*
    #get_stdout_mtime() and make a new alias set_float_to_stdout_mtime():
    #
    #alias set_float_to_stdout_mtime='{
    #   # Do the typical thing here, getting all of stdin into a single local
    #   # variable named:
    #   string float_name__sftso
    #   die_unless_variable_float "${float_name__sftso}"
    #
    #   # Resolve "/dev/fd/1" to a non-symbolic absolute path. Assuming the
    #   # current shell to be a pseudo-terminal, "/dev/fd/1" is typically a
    #   # symbolic link to the device for such terminal (e.g., "/dev/pts/7").
    #   # Referring to standard output by such resolved rather than symbolic
    #   # path is essential; we run the command getting standard output's mtime
    #   # from a process substitution in which symbolic path "/dev/fd/1" refers
    #   # to a shell pipe rather than the desired pseudo-terminal.
    #   #
    #   # Sadly, the only safe means of resolving such path is as below.
    #   # Replacing the first pipeline subcommand with a call to
    #   # canonicalize_path() uselessly returns "/dev/fd/1" without resolving
    #   # such path. Likewise, replacing the second pipeline subcommand with a
    #   # process substitution has the same effect. (My inveterate Gods, but
    #   # this is subtle.)
    #   string stdout_filename__sftso
    #   output_string "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}"(:A) |
    #       set_string_to_stdin stdout_filename__sftso
    #
    #   # Set such float to such path's mtime. See set_float_to_float() for
    #   # further details.
    #   get_path_mtime "${stdout_filename__sftso}" |
    #       set_float_to_stdin "${float_name__sftso}"
    #} <<<'
    #
    #Craziness, but it works. Shift to "05-alias/io/standard". *shakes head*
    #FIXME: We need to add a new set_float_to_stdin() to "always/io/standard",
    #which then requires a new set_float_to_float() in
    #"always/variable/float/float". It's all trivial -- just needs to be done!
    #FIXME: Alternatively, we could just make a new
    #set_variable_to_stdin() function. It's not to have the strict typing of
    #set_string_to_stdin() elsewhere, but it's really just an inefficiency here.
    #Then, we could just call set_scalar_to_stdin() above twice. Hmmm...
    #actually, that gains us effectively nothing. There are *ONLY* three scalar
    #types, so we'd might as well support them all type-safely. Honestly, any
    #inefficiency here is minor compared to the weight of zeshy as a whole.
    #O.K.; go with the original plan above!

    # Prefer an "if"- to "and"-style conditional to avoid returning false.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler).
    #
    # Avoid comparing nonextant variables rather than defaulting such variables
    # to seemingly sane default values (e.g., null). The latter behaves
    # unpredictably. For example, if ${funcfiletrace[2]} is set but
    # ${ZESHY_PRINT_PRIOR_RUNNABLE_ID} is not, defaulting the latter to a
    # seemingly sane default value erroneously guarantees delimiting whitespace
    # will be printed.
    #
    # Subtleties abound, ribald bald acolytes.
    if is -n "${ZESHY_PRINT_PRIOR_RUNNABLE_ID-}" and
         "${funcfiletrace[-2]-$'\0'}" !=\
         "${ZESHY_PRINT_PRIOR_RUNNABLE_ID}" si or
       (( ${ZESHY_PRINT_PRIOR_STDOUT_MTIME-0} &&\
            ZESHY_PRINT_PRIOR_STDOUT_MTIME != $(get_stdout_mtime) )) {
        output_string "funcfiletrace[-2]: ${funcfiletrace[-2]-}; ZESHY_PRINT_PRIOR_RUNNABLE_ID: ${ZESHY_PRINT_PRIOR_RUNNABLE_ID-}; ZESHY_PRINT_PRIOR_STDOUT_MTIME: ${ZESHY_PRINT_PRIOR_STDOUT_MTIME}; get_stdout_mtime: $(get_stdout_mtime)" 1>&2
        output_newline
#       print_newline
    }
}

# ....................{ PRINTERS ~ newline                 }....................
declare_function_with_stdin <<'/---'
string print_newline(void)

Print a blank line to standard output.
/---
function print_newline() {
    die_if_args
    output_newline
    update_print_prior_globals
}

# ....................{ PRINTERS ~ stdin                   }....................
declare_function_with_stdin <<'/---'
string print_stdin[stdin: string input]

Get standard input piped to the current shell. Since subshells do not inherit
piped input, avoid calling this function from subshells (e.g., as
`$(get_stdin_piped)`). Consider calling is_stdin_nonempty() before this function
to ensure such input exists: e.g.,

.print_stdin()
==========================================
[source]
------------------------------------------
>>> function pachamama() {
...     if { is_stdin_nonempty } {
...         print_stdin
...     } else {
...         print_string "${@}"
...     }
... }
>>> print_string tawantinsuyu | pachamama
tawantinsuyu
>>> pachamama tawantinsuyu
tawantinsuyu
------------------------------------------
==========================================
/---
function print_stdin() {
    # Validate sanity.
    die_if_args
    die_if_stdin_empty

    # Print such input.
    < "${ZESHY_STDIN_PATH}"

    # Close such input, ensuring is_stdin_nonempty() subsequently returns false.
    close_stdin

    # Store printer function globals, if needed.
    update_print_prior_globals
}

# ....................{ PRINTERS                           }....................
# No print_string*() functions call prepend_args_with_stdin_if_piped(),
# as doing so often invites obscene issues. When called by a caller receiving
# piped input, print_string*() functions silently capturing and closing such
# input before the caller can do so break such caller in subtle and *VERY*
# difficult to debug ways. Moreover, there are no to few reasonable scenarios in
# which print_string*() functions would be piped rather than merely passed input
# strings. For straightforward safety, avoid inviting such wayward breakage.

declare_function_with_stdin <<'/---'
string print_string(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline.
Unlike low-level builtins echo() and print(), this and most other printer
functions print embedded escape sequences as is rather than converting such
sequences to the corresponding characters. Such conversions often mangle
arbitrary output and hence are generally unhelpful. See
print_string_with_escapes() for further details.

Avoid calling such low-level builtins, which behave unexpectedly dangerously
when passed hyphen-prefixed strings: e.g.,

.print_string() versus print()
==========================================
[source]
------------------------------------------
>>> string lammoth="-z" morgoth="rm -rf *"

# Bad! Never do this, unless guaranteed no hyphens prefix such string.
# If hyphens do prefix such string, zsh treats the first word of such
# string as options to print(). This can be extremely unsafe, as this
# example demonstrates.
>>> print "${lammoth}" "${morgoth}"
>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

# Good. Always do this, instead.
>>> print_string "${lammoth}" "${morgoth}"
-z rm -rf *    # That's more like it.
------------------------------------------
==========================================
/---
function print_string() {
    die_unless_args 'expected at least one string'
    output_string "${*}"
    update_print_prior_globals
}

#FIXME: Unconvinced this to be a helpful function. Certainly, the name is not
#helpful at all. Grep the codebase for where this is actually called from.
declare_function_with_stdin <<'/---'
string curse_string(string text1, string text2, ...)

Print the passed strings to standard error with default trailing newline. See
print_string() for further details.
/---
function curse_string() {
    die_unless_args 'expected at least one string'
    output_string "${*}" 1>&2
    update_print_prior_globals
}

# ....................{ PRINTERS ~ string                  }....................
declare_function_with_stdin <<'/---'
string print_string_colored(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) to standard output
with trailing newline in a color-aware manner. Prefix and suffix such output
with ANSI color codes resetting color attributes to terminal-specific defaults.
See print_string() for further details.
/---
function print_string_colored() {
    die_unless_args 'expected at least one string'
    output_string "${ZESHY_COLOR[reset]-}${*}${ZESHY_COLOR[reset]-}"
    update_print_prior_globals
}

declare_function_with_stdin <<'/---'
string print_string_sans_newline(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) to standard output
without trailing newline. See print_string() for further details.
/---
function print_string_sans_newline() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string text="${*}"

    # Print such string unnewlined.
    output_string_sans_newline "${text}"

    # Unlike output printed by most printer functions, output printed by this
    # function can conceivably be the empty string. In such case, to avoid
    # printing an unwanted newline on the next call to a printer function, the
    # call stack root must not be reset. Since strings consisting of only ANSI
    # color codes are effectively the empty string, test for emptiness after
    # excluding such codes.
    if (( $(get_string_length_printable_sans_ansi_colors "${text}") )) {
#       print -r "string \"${text}\" length: $(get_string_length_printable_sans_ansi_colors "${text}")"
        update_print_prior_globals
    }
}

# ....................{ PRINTERS ~ wrap                    }....................
declare_function_with_stdin <<'/---'
string print_string_wrapped_with_line_prefix(string text, string line_prefix)

Print the passed string wrapped to the current terminal width, prefixing each
resulting line with the passed prefix. Specifically:

. Split such string into substrings satisfying the following constraints:
** Each substring is suffixed by either whitespace or the end of such string.
** Each substring is no longer than the current terminal width subtracted by the
   length of such prefix.
. Print each substring prefixed by such prefix and suffixed by a newline.

For example:

.print_string_wrapped_with_line_prefix()
==========================================
[source]
------------------------------------------
>>> print_string_wrapped_with_line_prefix\
...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
...    "man hired armed guards to keep anyone from eating his fish. The many"\
...    "people who sit next to the empty river starve to death. But they do"\
...    "not die of starvation. They die of a belief. Everyone believes that"\
...    "the man atop the box owns the fish. The soldiers believe it, and they"\
...    "will kill to protect the illusion. The others believe it enough that"\
...    "they are willing to starve. But the truth is that there is a box,"\
...    "there is an emptied river, there is a man sitting atop the box, there"\
...    "are guns, and there are starving people." box
box: The box is full of salmon, and a man sits atop the box. Long ago this man
box: hired armed guards to keep anyone from eating his fish. The many people who
box: sit next to the empty river starve to death. But they do not die of
box: starvation. They die of a belief. Everyone believes that the man atop the
box: box owns the fish. The soldiers believe it, and they will kill to protect
box: the illusion. The others believe it enough that they are willing to starve.
box: But the truth is that there is a box, there is an emptied river, there is a
box: man sitting atop the box, there are guns, and there are starving people.
------------------------------------------
==========================================
/---
function print_string_block_with_line_prefix() {
    # Validate passed arguments.
    string text="${1}" line_prefix="${2}"

    # Lengths of the current terminal, message text, and message prefix. The
    # latter lengths exclude non-printable characters, including ANSI escapes.
    integer terminal_width text_length line_prefix_length
    terminal_width="$(get_terminal_width)"
    text_length="$(get_string_length_printable_sans_ansi_colors\
        "${text}")"
    line_prefix_length="$(get_string_length_printable_sans_ansi_colors\
        "${prefix}")"

    # Maximum length of each text substring to be printed on each output line.
    integer line_length_maximum
    line_length_maximum=$(( terminal_width - prefix_length ))

    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    line_pcre='(.{1,'${line_length_maximum}'}*)(?:[[:space:]]|$)'

    # Sanitize the current terminal in preparation for subsequent output.
    output_string "${ZESHY_COLOR[reset]-}"

    # If required, print delimiting prefixing whitespace.
    print_whitespace_if_needed

    # For each text substring to be printed on each output line, print such
    # substring prefixed by the message prefix and suffixed by newline.
    for_string_pcre_matches "${text}" "${line_pcre}"\
        'output_string "${line_prefix}${match[1]}"'

    # Sanitize the current terminal in preparation for subsequent output.
    output_string "${ZESHY_COLOR[reset]-}"
    update_print_prior_globals
}

# --------------------( WASTELANDS                         )--------------------
    # When debugging, note that it's not genuinely possible to print
    # ${ZESHY_PRINT_PRIOR_STDOUT_MTIME}. Why? Because merely printing
#   output_string "resetting ZESHY_PRINT_PRIOR_RUNNABLE_ID: ${ZESHY_PRINT_PRIOR_RUNNABLE_ID}" 1>&2
#   output_string "resetting ZESHY_PRINT_PRIOR_STDOUT_MTIME: ${ZESHY_PRINT_PRIOR_STDOUT_MTIME}; ZESHY_PRINT_PRIOR_RUNNABLE_ID: ${ZESHY_PRINT_PRIOR_RUNNABLE_ID}" 1>&2
    #FUXME: Sadly, we need to drop the ${ZESHY_PRINT_PRIOR_STDOUT_MTIME} testing.
    #Why? Because, with a coarse granularity of only seconds, this function
    #effectively reduces to a random number generator: sometimes it prints
    #delimiting whitespace as expected, sometimes it doesn't. This is terrible.
    #However, document the current solution for posterity.
    #FUXME: *WAIT*. Any kernel worth running zsh on should support nanosecond-
    #resolution mtimes; see:
    #  http://stackoverflow.com/questions/7206014/get-a-nanosecond-precise-atime-mtime-ctime-fields-for-file-stat
    #
    #zsh appears to have integrated a patch; see:
    #  http://www.zsh.org/mla/workers/2007/msg00972.html
    #FUXME: Ah-ha! While zsh currently supplies no means of retrieving
    #nanosecond-resolution times via zstat(), the system-specific stat() command
    #does *IF* passed option "-c '%y====%Y'": e.g.,
    #
    #  >>> stat --dereference --printf '%y\0%Y' /dev/fd/1
    #  2013-05-22 19:39:01.436503138 -04001369265941
    #
    #Awesome, no? We'll need to parse the actual nanosecond mtime back together
    #from such string. For the above, for example, such mtime is:
    #
    #  1369265941.436503138
    #
    #By saving such value to a float, "viola!" Nanosecond-resolution times.
    #FUXME: Since the output of "-c '%y'" is system- and user-specific, we
    #should simply round such time to the nearest integer if it fails to match
    #the above specification: e.g.,
    #
    #  1369265941.0

    #FUXME: We should be using the test operator "-om" in place of...
    # Ensure each tested variable exists before testing such
    # variable's
    # To avoid returning success when both string variables are
    # undefined, default undefined string variables to a value that zsh
    # operation guarantees such variables to *NEVER* be set to (i.e., null).
    #
    # Subtleties abound, ribald bald acolytes.
#   if is "${funcfiletrace[2]-$'\0'}" !=\
#         "${ZESHY_PRINT_PRIOR_RUNNABLE_ID-$'\0'}" si or

#-n "${ZESHY_PRINT_PRIOR_RUNNABLE_ID-}" and
#       "${#funcfiletrace}" -ge 2 and
#
#${+ZESHY_PRINT_PRIOR_STDOUT_MTIME} &&\
#FUXME: Excise everywhere, shifting documentation above where applicable. I
#recall only referencing this global in this component. Check on that...
#declare_global_with_stdin <<'/---'
#string ZESHY_PRINT_CALL_STACK_ROOT
#
#Most recent call stack root to have called a high-level print function (e.g.,
#print_message(), print_warning()) or the empty string if no such function has
#been called, where "call stack root" is the first zsh function, script, or
#command line to have initiated the current call stack.
#
#Specifically, this string is the first element of list global ${funcfiletrace}
#at the time of the most recent call to a high-level print function as recorded
#by print_whitespace_if_needed(). zsh tracks call stack state with
#two list globals: ${funcname} and ${funcfiletrace}. The former distinguishes
#between calls to different functions and scripts but *NOT* between different
#calls to the same function or script or between different command lines. The
#latter distinguishes between all such calls, hence subsuming the former. Given
#only a filename and line, inspecting such line usually furnishes the function
#name called on such line. Therefore, each element of ${funcfiletrace} uniquely
#identifies the corresponding call in the call stack. Since the first element of
#such list corresponds to the caller responsible for initiating the entire call
#stack, such element effectively differentiates such stack from subsequent call
#stacks initiated by other callers.
#
#See print_whitespace_if_needed() for further details.
#/---
#
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., print_string()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#print_whitespace_if_needed() should thus print a delimiting newline.
#If standard output for the current shell is attached to a terminal, set the
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., print_string()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#print_whitespace_if_needed() should thus print a delimiting newline.
#      (( ZESHY_PRINT_PRIOR_STDOUT_MTIME )) and
    #FUXME: Convert to an "if" statement and attempt to remove the trailing
    #return_true().

    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
    #
    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler). Subtleties abound, dear acolytes.
#   print "printing newline if equals: ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT-}; funcfiletrace[-1]: ${funcfiletrace[-1]}" 1>&2; print_call_stack 1>&2
#   is "${ZESHY_PRINT_CALL_STACK_ROOT-}" == "${funcfiletrace[-1]}" si and
#       print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    # Succeed regardless of whether such newline was printed.
#   return_true
# the following conditions all hold 
    #FUXME: This isn't quite right, and one can readily see why when
    #uncommenting the print() statement below: a granularity of seconds is
    #simply too low to reliably detect changes. Ideally, "mtime" would be
    #recorded in milli- or nanoseconds. Since it isn't, another approach is
    #required. 

#FUXME: Adjust the conditions under which a newline is printed to the following:
#
#* If ${ZESHY_PRINT_PRIOR_RUNNABLE_ID} is unequal to the currently called printer
#  function name (e.g., "print_message"),
#* If ${ZESHY_PRINT_PRIOR_STDOUT_MTIME} is non-empty (or non-zero, if we
#  decide to use an integer as we probably should) *AND* unequal to the
#  current mtime for "/dev/fd/1" *AND*
#* Then and only then print a newline.
#See 
#Print a blank line to standard output if at least one Zeshy print function has
#already been called under the current call stack root (i.e., called either by
#such root or by a function or script transitively called by such root). This
#function is typically called by high-level Zeshy print functions (e.g.,
#print_message()) to print a newline delimiting subsequent from previous output.
#See ${ZESHY_PRINT_CALL_STACK_ROOT} for further details.
    # * Standard output for the current shell is attached to either a terminal
    #   or pipe (e.g., page_stdin()) (thus avoiding printing a newline when
    #   ,
    #if { is_stdout_terminal_or_pipe } and
#FUXME: Rename to update_printer_globals(). Hmm, perhaps
#update_print_prior_globals() or set_last_print_globals()?
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_STDOUT_MTIME.
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_NAME.
#FUXME: Do we actually call this anywhere? And if so, why? All such calls
#should probably simply be expanding output_string_sans_newline(). Grep the
#codebase.
    # Succeed regardless of whether such root was reset.
#   return_true
# (e.g., newlines, nulls, strings, lists).
# ....................{ PRINTERS ~ separated               }....................
#FUXME: Such functions should internally depend on new functions of new
#component "variable/string/separate", which actually perform the calling of
#builtin print(). Consider function names:
#
#* concatenate_strings() or unseparate_strings(). Probably the former; the
#  latter is simply odd. Right. Every language needs a concatenate function,
#  so... this is ours!
#* separate_strings_with_newline() or delimit_strings_by_newline(). The former.
#* separate_strings_with_null().
#FUXME: Rename this function to print_strings_concatenated().
#declare_function_with_stdin <<'/---'
#string print_strings_unseparated(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline and
#_not_ internally delimited by ${IFS}, the internal field separator: e.g.,
#
#.print_strings_unseparated()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_unseparated "Where Alph," "the sacred river," "ran"
#Where Alph,the sacred river,ran
#------------------------------------------
#==========================================
#/---
#function print_strings_unseparated() {
#    # Temporarily set global string ${IFS} to the empty string. Since zsh
#    # implicitly delimits lists interpolated with the "*" operator when double-
#    # quoted with such global, the following commands print the passed arguments
#    # undelimited. This incantation was astonishingly difficult to discover.
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}"  # if not double-quoted, zsh oddly ignores ${IFS}
#    update_print_prior_globals
#}

#declare_function_with_stdin <<'/---'
#string print_strings_newlined(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited by newlines: e.g.,
#
#.print_strings_newlined()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_newlined sludge elf transmuter
#sludge
#elf
#transmuter
#------------------------------------------
#==========================================
#/---
#function print_strings_newlined() {
#    die_unless_args 'expected at least one string'
#    print -lr -- "${@}"
#    update_print_prior_globals
#}
#
#declare_function_with_stdin <<'/---'
#string print_strings_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
#
#.print_strings_nulled()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_nulled "Through caverns" "measureless to" "man"
#Through caverns\0measureless to\0man
#------------------------------------------
#==========================================
#/---
#function print_strings_nulled() {
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}"
#    update_print_prior_globals
#}

#       ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#       print "resetting ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT}" 1>&2; print_call_stack 1>&2
    # Succeed regardless of whether such root was set.
#   return_true
    # If standard output for the current shell is attached to either a terminal
    # or pipe (e.g., page_stdin()), store such globals.
    #
    # Prefer an "if"- to "and"-style conditional to avoid returning false.
#   if { is_stdout_terminal_or_pipe } {

#FUXME: Rename to print_strings_unseparated() or print_strings_undelimited()?
#Yes, I rather like the latter. Though, the former is a bit more readable...
#FUXME: Rename to print_string_unnewlined() or perhaps simply
#output_string_sans_newline(). Yeah; the latter is pretty sweet.
#Print the passed strings to standard output without delimitation:
#FUXME: Hmm; this should really be called print_string_with_escapes(). Function
#name print_string_with_escapes() implies something completely different (i.e., that
#all shell-reserved characters will be printed escaped).

# common escapes escaped (i.e., converted to the corresponding characters):
# Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
# Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
# (i.e., such that a newline separates each such string from the next)
    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
#   if is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}"
#   then print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    #FUXME: This is now redundant, as the subsequent print_string_colored()
    #function sets this.

    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required. Instead, replace the previously recorded
    # call stack root with the current.
#   else ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#   fi

#Prefix the next string to be output with whitespace delimiting such string from
#previously output strings if at least one such string has already been output
#under the current call stack root. This function manages string global
#${ZESHY_PRINT_CALL_STACK_ROOT} on behalf of the caller, usually a high-level
#print function (e.g., print_message(), print_header()).
#
#FUXME: A bit unintuitive. Not sure either is terribly better, but how about
#renaming to print_string_no_newline() or print_string_newlineless() or
#output_string_sans_newline(). The latter coincides with print_strings_unseparated()
#and thus strikes me as the best bet.
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    print_message "${*}" | output_string_sans_newline
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   output_string_sans_newline "$(print_message "${*}")"
#   output_string_sans_newline "$(print_warning "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#declare_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_with_escapes().
#'
#function curse_string_escaped() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#declare_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, zsh oddly ignores ${IFS}
#}

#declare_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#declare_function '
#void curse_newline(void)
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to output_string_sans_newline(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#declare_function '
#void curse_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#declare_function '
#string print_string_colored_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See print_string_colored() for further details.
#'
#function print_string_colored_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   print_warning -> print_warning      curse_string -> outcry
#   print_message -> print_message      print_string -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
