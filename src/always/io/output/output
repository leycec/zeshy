#!/usr/bin/env zsh
# ====================[ output                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle low-level print functions (e.g., newlines, nulls, strings, lists).

# ....................{ GLOBALS                            }....................
document_global '
string ZESHY_PRINT_CALL_STACK_ROOT

Most recent call stack root to have called a high-level print function (e.g.,
print_message(), print_warning()) or the empty string if no such function has
been called, where "call stack root" is the first zsh function, script, or
command line to have initiated the current call stack.

Specifically, this string is the first element of list global ${funcfiletrace}
at the time of the most recent call to a high-level print function as recorded
by print_newline_if_call_stack_root_same(). zsh tracks call stack state with
two list globals: ${funcname} and ${funcfiletrace}. The former distinguishes
between calls to different functions and scripts but *NOT* between different
calls to the same function or script or between different command lines. The
latter distinguishes between all such calls, hence subsuming the former. Given
only a filename and line, inspecting such line usually furnishes the function
name called on such line. Therefore, each element of ${funcfiletrace} uniquely
identifies the corresponding call in the call stack. Since the first element of
such list corresponds to the caller responsible for initiating the entire call
stack, such element effectively differentiates such stack from subsequent call
stacks initiated by other callers.

See print_newline_if_call_stack_root_same() for further details.
'

# ....................{ SETTERS                            }....................
document_function '
void reset_print_call_stack_root(void)

Set the stored call stack root specific to Zeshy print functions to the current
call stack root. This function is typically called by low-level Zeshy print
functions (e.g., print_string()) to notify subsequently called high-level print
functions (e.g., print_message()) that at least one such print function has
already been called under the current call stack root and that
print_newline_if_call_stack_root_same() should thus print a delimiting newline.
'
function reset_print_call_stack_root() {
    die_if_args
    ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
}

# ....................{ PRINTERS ~ blank line              }....................
document_function '
string print_newline(void)

Print a blank line to standard output.
'
function print_newline() {
    die_if_args
    print
    reset_print_call_stack_root
}

document_function '
string print_newline_if_call_stack_root_same(void)

Print a blank line to standard output if at least one Zeshy print function has
already been called under the current call stack root (i.e., called either by
such root or by a function or script transitively called by such root). This
function is typically called by high-level Zeshy print functions (e.g.,
print_message()) to print a newline delimiting subsequent from previous output.
See ${ZESHY_PRINT_CALL_STACK_ROOT} for further details.
'
function print_newline_if_call_stack_root_same() {
    # Validate sanity.
    die_if_args
#   print_call_stack

    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
    #
    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required.
    is_string_equals\
        "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}" and
        print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"
}

# ....................{ PRINTERS ~ string                  }....................
# No print_string*() functions call prepend_args_with_standard_input_if_piped(),
# as doing so often invites obscene issues. When called by a caller receiving
# piped input, print_string*() functions silently capturing and closing such
# input before the caller can do so break such caller in subtle and *VERY*
# difficult to debug ways. Moreover, there are no to few reasonable scenarios in
# which print_string*() functions would be piped rather than merely passed input
# strings. For straightforward safety, avoid inviting such wayward breakage.

document_function '
string print_string(string text1, string text2, ...)

Print the passed strings to standard print_string with default trailing newline.
Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
Avoid calling echo() or print(), which fail on hyphen-prefixed strings: e.g.,

    >>> string lammoth="-z" morgoth="rm -rf *"

    # Bad! Never do this, unless guaranteed no hyphens prefix such string.
    # If hyphens do prefix such string, zsh treats the first word of such
    # string as options to print(). This can be extremely unsafe, as this
    # example demonstrates.
    >>> print "${lammoth}" "${morgoth}"
    >>> rm -rf *   # Don''t accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

    # Good. Always do this, instead.
    >>> print_string "${lammoth}" "${morgoth}"
    -z rm -rf *    # That''s more like it.
'
function print_string() {
    die_unless_args 'expected at least one string'
    print -r -- "${*}"
    reset_print_call_stack_root
}

document_function '
string curse_string(string text1, string text2, ...)

Print the passed strings to standard error with default trailing newline.
Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
'
function curse_string() {
    die_unless_args 'expected at least one string'
    print -r -- "${*}" 1>&2
    reset_print_call_stack_root
}

document_function '
string print_string_colored(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline in a
color-aware manner. Prefix and suffix such output with ANSI color codes
resetting color attributes to terminal-specific defaults.
'
function print_string_colored() {
    die_unless_args 'expected at least one string'
    print -r -- "${ZESHY_COLOR[reset]-}${*}${ZESHY_COLOR[reset]-}"
    reset_print_call_stack_root
}

document_function '
string print_string_escaped(string text1, string text2, ...)

Print the passed strings to standard output with default trailing newline and
all escapes escaped (i.e., converted to the corresponding characters): e.g.,

    >>> string morning_window="\nTHEY are rattling breakfast plates...\n"
    >>> print_string_escaped "${morning_window}"

    THEY are rattling breakfast plates...

    >>> print_string "${morning_window}"
    \nTHEY are rattling breakfast plates...\n
'
function print_string_escaped() {
    die_unless_args 'expected at least one string'
    print -- "${*}"
    reset_print_call_stack_root
}

# ....................{ PRINTERS ~ delimited               }....................
document_function '
string print_string_undelimited(string text1, string text2, ...)

Print the passed strings to standard output without delimitation: e.g.,

    >>> print_string_undelimited "Where Alph," "the sacred river," "ran"
    Where Alph,the sacred river,ran
'
function print_string_undelimited() {
    # Temporarily set global string ${IFS} to the empty string. Since zsh
    # implicitly delimits lists interpolated with the "*" operator when double-
    # quoted with such global, the following commands print the passed arguments
    # undelimited. This incantation was astonishingly difficult to discover.
    die_unless_args 'expected at least one string'
    string IFS=
    print -r -- "${*}"  # if not double-quoted, zsh oddly ignores ${IFS}
    reset_print_call_stack_root
}

document_function '
string print_string_nulled(string text1, string text2, ...)

Print the passed strings to standard output delimited and terminated by nulls.
Suffix each such string with character "\0", in other words: e.g.,

    >>> print_string_nulled "Through caverns" "measureless to" "man"
    Through caverns\0measureless to\0man
'
function print_string_nulled() {
    die_unless_args 'expected at least one string'
    print -Nr -- "${@}"
    reset_print_call_stack_root
}

# ....................{ PRINTERS ~ newlined                }....................
document_function '
string print_string_sans_newline_suffix(string text1, string text2, ...)

Print the passed strings to standard output with no default trailing newline.
'
function print_string_sans_newline_suffix() {
    die_unless_args 'expected at least one string'
    print -nr -- "${*}"
    reset_print_call_stack_root
}

document_function '
string print_string_newlined(string text1, string text2, ...)

Print the passed strings to standard output delimited by newlines (i.e., such
that a newline separates each such string from the next): e.g.,

    >>> print_string_newlined sludge elf transmuter
    sludge
    elf
    transmuter
'
function print_string_newlined() {
    die_unless_args 'expected at least one string'
    print -lr -- "${@}"
    reset_print_call_stack_root
}

document_function '
string print_list_newlined(
  string list_name,
  integer start_index = 1, integer end_index = -1)

Print the elements between the passed start and end indices (defaulting to the
first and last elements) of the list with the passed name to standard output
delimited by newlines. If no indices are passed, all elements are printed; if
one index is passed, only that index is passed. Negative indices are offset
from the end: e.g.,

    >>> list runes; runes=( abyss crypt pan tomb vaults )
    >>> print_list_newlined runes
    abyss
    crypt
    pan
    tomb
    vaults
    >>> print_list_newlined runes 3
    pan
    >>> print_list_newlined runes 3 -1
    pan
    tomb
    vaults
'
function print_list_newlined() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one list name and optional start and end indices'
    string list_name__pln="${1}"\
         index_first__pln="${2:-1}" index_last__pln="${3:--1}"

    #FIXME: Uncomment this when it's working again. It's currently not, so...
#   check_list_args "${list_name}" __index_first__ __index_last__

    # Output such list.
#   print "beg: ${beg_index}\nend: ${end_index}"
    print -lr --\
        "${${(@P)list_name__pln}[${index_first__pln},${index_last__pln}]}"
    reset_print_call_stack_root
}

# --------------------( WASTELANDS                         )--------------------
    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
#   if is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}"
#   then print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    #FUXME: This is now redundant, as the subsequent print_string_colored()
    #function sets this.

    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required. Instead, replace the previously recorded
    # call stack root with the current.
#   else ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#   fi

#Prefix the next string to be output with whitespace delimiting such string from
#previously output strings if at least one such string has already been output
#under the current call stack root. This function manages string global
#${ZESHY_PRINT_CALL_STACK_ROOT} on behalf of the caller, usually a high-level
#print function (e.g., print_message(), print_header()).
#
#FUXME: A bit unintuitive. Not sure either is terribly better, but how about
#renaming to print_string_no_newline() or print_string_newlineless() or
#print_string_sans_newline_suffix(). The latter coincides with print_string_undelimited()
#and thus strikes me as the best bet.
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    print_message "${*}" | print_string_sans_newline_suffix
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   print_string_sans_newline_suffix "$(print_message "${*}")"
#   print_string_sans_newline_suffix "$(print_warning "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#document_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_escaped().
#'
#function curse_string_escaped() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#document_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, zsh oddly ignores ${IFS}
#}

#document_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#document_function '
#void curse_newline(void)
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to print_string_sans_newline_suffix(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#document_function '
#void curse_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_sans_newline_suffix() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#document_function '
#string print_string_colored_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See print_string_colored() for further details.
#'
#function print_string_colored_sans_newline_suffix() {
#    prepend_args_with_standard_input_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   print_warning -> print_warning      curse_string -> outcry
#   print_message -> print_message      print_string -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
