#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle *printer functions* (i.e., functions printing strings).

== Nomenclature ==

In conventional languages, standard output and error serve only as streams to
which only human-readable strings intended for end users are printed. However,
in shell languages and hence `zeshy`, standard output and error serve as that
_and_ as sinks to which machine-readable strings intended for command
substitution are printed.

To manage such complexities, `zeshy` supports three broad classes of functions
for writing to standard output and error -- each with a corresponding
nomenclature for easier identification. In increasing order of abstraction and
functionality, these are:

* *Getters*, low-level functions returning strings to callers by writing to a
  subshell's standard output from command substitution (e.g.,
  `float time; time="$(get_time)"`). Most such functions are prefixed by `get_`;
  some, however, are prefixed by a verb specific to their function (e.g.,
  canonicalize_path()).
* *Outputters*, mid-level functions printing strings by writing to the current
  shell's standard output and/or error. Such functions _may_ embellish such
  strings with terminal-specific colors (e.g., 8-color ANSI) and locale-specific
  encodings (e.g., UTF-8) configured by the current user, but otherwise behave
  straightforwardly. All such functions are prefixed by `output_`, and most by
  `output_string_`.
* *Printers*, high-level functions printing strings by writing to the current
  shell's standard output and/or error. Like outputters, printers embellish such
  strings with settings configured by the current user. Unlike outputters,
  printers additionally behave in a context-aware manner, including:
  * If such output is preceded by prior output, printing vertical whitespace
    delimiting all prior and subsequent output.
  * If such output is attached to a terminal device _and_ exceeds the height of
    such terminal, paging such output with the current user's preferred pager
    (e.g., `less`, `more`).
  +
  All such functions are prefixed by `print_`.

Hence, while printer functions handle repetitive and often error-prone
contextual tasks on behalf of the caller, getter and outputter functions do
_not_. Likewise, while printer and outputter functions are rarely called from
command substitutions, getter functions are _always_.
______________<heredoc?>______________

# ....................{ OUTPUTTERS                         }....................
declare_function_with_stdin <<'/---'
string output_line_horizontal(void)

Print a *hard rule* (i.e., horizontal line) to standard output.
/---
function output_line_horizontal() {
    # Validate sanity.
    die_if_args
    string rule

    # Print such rule.
    rule="$(repeat_string\
         "${ZESHY_STYLE_TO_TEXT[output_line_horizontal.border]-}"\
        $(get_terminal_width))"
    output_string\
        "${ZESHY_STYLE_TO_COLOR[output_line_horizontal.border]-}${rule}${ZESHY_STYLE_TO_COLOR[color.reset]-}"
}

# ....................{ PRINTERS                           }....................
#FIXME: Actually, this is nonsense. By the above definition, *ALL* printers
#should page output. But that would render this function nonsensical. Honestly,
#let's just rename this back to output_string_colored().
declare_function_with_stdin <<'/---'
string print_string(string text1 = "", string text2, ...)

Print the passed strings (defaulting to the empty string) to standard output
suffixed by a newline, while sanitizing the current terminal for such output.
Specifically:

. Reset color attributes for the current terminal to such terminal's defaults.
. Print such strings in **raw mode** (i.e., printing embedded escape sequences
  such as `\n` as is rather than converting such sequences to the corresponding
  characters). See output_string() for further details.
. Reset color attributes for the current terminal again.

== Comparison with Low-level Runnables ==

Unlike low-level general-purpose output aliases (e.g., output_string()) and
builtins (e.g., echo(), print()) intended to be called by any script or
function, this function is intended to be called only by high-level printer
functions (e.g., print_message()). While such aliases are generally helpful,
avoid calling such builtins, which often behave unsafely (e.g., when passed
hyphen-prefixed strings): e.g.,

.print_string() versus print()
==========================================
[source]
------------------------------------------
>>> string lammoth="-z" morgoth="rm -rf *"

# Bad! Never do this, unless guaranteed no hyphens prefix such string.
# If hyphens do prefix such string, zsh treats the first word of such
# string as options to print(). This can be extremely unsafe, as this
# example demonstrates.
>>> print "${lammoth}" "${morgoth}"
>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!

# Good. Always do this, instead.
>>> print_string "${lammoth}" "${morgoth}"
-z rm -rf *    # That's more like it.
------------------------------------------
==========================================
/---
function print_string() {
    start_stdout
    output_string "${*}"
    stop_stdout
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: This should either page output or be removed. Hence, let's probably just
#remove this.
#declare_function_with_stdin <<'/---'
#string print_string_with_newline_prefix_if_needed(
#    string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by a newline, while handling and tracking state for standard output
#_and_ sanitizing the current terminal for such output. Specifically:
#
#. Handle output tracking state by print a newline delimiting such strings from
#  prior terminal output, if such output exists. See
#  start_stdout_delimited() for further details.
#. Print such strings in raw mode, resetting color attributes for the current
#  terminal both before and after. See print_string() for further details.
#. Update output tracking state. See stop_stdout() for further details.
#/---
#function print_string_with_newline_prefix_if_needed() {
#    start_stdout_delimited
#    output_string "${*}"
#    stop_stdout_delimited
#}

#FUXME: Document the very tangible differences between (in increasing order of
#abstraction and functionality) getters, outputters, and printers.

#Handle low-level *printer functions* (i.e., functions printing strings in a
#manner independent of globals tracking output state). See @{track} for further
#details.

#FUXME: Actually, this is fairly terrible. If we care enough to want to print a
#string in a "colored" manner, then we care enough to simply call print_string()
#instead. Replace all calls to this function with calls to print_string()
#instead; then excise this function.
#declare_function_with_stdin <<'/---'
#string output_string_colored(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by a newline _without_ handling or tracking state for standard output.
#Specifically:
#
#. Reset color attributes for the current terminal to such terminal's defaults.
#. Print such strings in **raw mode** (i.e., printing embedded escape sequences
#  such as `\n` as is rather than converting such sequences to the corresponding
#  characters). See output_string() for further details.
#. Reset color attributes for the current terminal again.
#
#See print_string() for further details.
#/---
#function output_string_colored() {
#    reset_terminal_color
#    output_string "${*}"
#    reset_terminal_color
#}

#FUXME: Right. Rename the existing parcel "io/output/output" to
#"io/output/print" and shift the following output_*() functions to a new parcel
#"io/output/output".
#FUXME: Rename to output_line_horizontal(). The caller requires fine control over
#prefixing and suffixing whitespace; in this case, such whitespace cannot be
#reliably automated away.
#FUXME: Not necessarily the best parcel for such function, as it's a tad lower-
#level.
#FUXME: Shouldn't we suffix rather than prefix such output with delimiting
#whitespace, unlike most printer functions? If so, we'll need to call a new
#print_string_*() variant.

#declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
#Handle high-level *printer functions* (i.e., functions printing strings in a
#manner dependent on globals tracking output state). See @{track} for further
#details.
#______________<heredoc?>______________

# Such state includes:
#
#* The modification time of standard output at the time of the most recent call
#  to a `zeshy` printer function (e.g., print_string()).
#* The filename and line number at which such function was defined.

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#   if { is_locale_encoding_utf8 } {
#       hard_rule_character='‚ïê'
#   } else {
#       hard_rule_character='='
#   }

#FUXME: Rename to ZESHY_OUTPUT_PRIOR_MTIME_STDOUT.
#FUXME: This is actually redundant, for the simple reason that any function call
#updating the prior globals ${ZESHY_OUTPUT_PRIOR_MTIME_STDOUT} and
#${ZESHY_OUTPUT_PRIOR_MTIME_STDERR} (e.g., print_message()) is signalling that
#the output for the next such call should *NOT* be prefixed by a newline. Why?
#Because, by updating such globals, the mtimes for "/dev/stdout" and
#"/dev/stderr" is guaranteed to equal such globals, in which case no newline
#prefix will be printed. But even if this were not the case, a larger issue
#remains: this global is fundamentally unreliable. It blithely assumes that the
#${funcfiletrace[2]} accurately identifies the name of the high-level caller
#printer function ultimately responsible for calling
#start_stdout_delimited(). Naturally, this is only
#ocassionally true. Fixing this would require searching the call stack for...
#what, exactly? The Hindu Godesses only know.
#
#tl;dr
#=====
#Excise this to eliminate redundancy.
#declare_global_with_stdin string ZESHY_STDOUT_PRIOR_SCRIPT_LINE <<'/---'
#Unique identifier of the previous runnable (e.g., print_message()) to have most
#recently called update_stdout_tracking() or the empty string if such
#function has yet to be called. Such identifier is the topmost element of stack
#${funcfiletrace} at the time of such call.
#
#`zsh` tracks call stack state with two list globals: ${funcname} and
#${funcfiletrace}. Since ${funcname} elements are runnable names, such list
#distinguishes between calls to different runnables but _not_ between different
#calls to the same runnable. Since ${funcfiletrace} elements are filename and
#line pairs signifying a runnable called on such line, such list distinguishes
#between all calls and hence subsumes ${funcname} for purposes of uniquely
#identifying runnables on the call stack.
#/---

    # Prefer an "if"- to "and"-style conditional to avoid returning false.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler).
    #
    # Avoid comparing nonextant variables rather than defaulting such variables
    # to seemingly sane default values (e.g., null). The latter behaves
    # unpredictably. For example, if ${funcfiletrace[2]} is set but
    # ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE} is not, defaulting the latter to a
    # seemingly sane default value erroneously guarantees delimiting whitespace
    # will be printed.
    #
    # Subtleties abound, ribald bald acolytes.
#   if is -n "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}" and
#       "${funcfiletrace[2]-$'\0'}" !=\
#            "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" si or {
        # Sadly, this is the only reliable means of obtaining such time.
#       float stdout_mtime; set_float_to_stdout_mtime stdout_mtime
#       (( ${ZESHY_STDOUT_PRIOR_MTIME-0} &&
#            ZESHY_STDOUT_PRIOR_MTIME != stdout_mtime ))
#   } {
#       float stdout_mtime; set_float_to_stdout_mtime stdout_mtime; output_string_to_stderr "funcfiletrace[2]: ${funcfiletrace[2]-}; ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}; ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}; stdout_mtime: ${stdout_mtime}"

#FUXME: Rename to ZESHY_OUTPUT_PRIOR_SCRIPT_LINE.

#   output_string "funcfiletrace[-2]: ${funcfiletrace[-2]-}\nZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}"

#       "${funcfiletrace[-2]-$'\0'}" !=\
#FUXME: Rename to print_string_sans_newline_suffix().
#FUXME: Likewise, rename output_string_sans_newline_suffix() to
#output_string_sans_newline_suffix().
#declare_function_with_stdin <<'/---'
#string print_string_sans_newline_suffix(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#suffixed by no newline while handling and tracking state for standard output.
#See print_string() for further details.
#/---
#function print_string_sans_newline_suffix() {
#    start_stdout
#    output_string_sans_newline_suffix "${*}"
#    stop_stdout
#}

#FUXME: Wait. We never call this anywhere, and I'm fairly certain we'll never
#need to, either. Excise!

# ....................{ PRINTERS ~ stdin                   }....................
#FUXME: This function actually called anywhere? Not terribly sure of the point
#of this function, honestly. Replace with get_stdin() or output_stdin(), ideally.
#declare_function_with_stdin <<'/---'
#string print_stdin[stdin: string input]
#
#Get standard input piped to the current shell. Since subshells do not inherit
#piped input, avoid calling this function from subshells (e.g., as
#`$(get_stdin_piped)`). Consider calling is_stdin_readable_sans_blocking() before this function
#to ensure such input exists: e.g.,
#
#.print_stdin()
#==========================================
#[source]
#------------------------------------------
#>>> 
#>>> function pachamama() {
#...     if { is_stdin_readable_sans_blocking } {
#...         print_stdin
#...     } else {
#...         print_string "${@}"
#...     }
#... }
#>>> print_string tawantinsuyu | pachamama
#tawantinsuyu
#>>> pachamama tawantinsuyu
#tawantinsuyu
#------------------------------------------
#==========================================
#/---
#function print_stdin() {
#    # Validate sanity.
#    die_if_args
#    die_unless_stdin_readable_sans_blocking
#
#    # Print such input.
#    get_stdin
#
#    # Close such input, ensuring is_stdin_readable_sans_blocking() subsequently returns false.
#    close_stdin
#
#    # Store printer function globals, if needed.
#    update_stdout_tracking
#}

#FUXME: Actually call this elsewhere (e.g., print_message()).
#FUXME: Fix documentation.
    # Mobilize printing on the current terminal.
    # Print such string sans newline suffix.
    # Finalize printing on the current terminal.

#FUXME: No longer convinced we require update_stdout_tracking(). We still need
#stop_stdout() for resetting terminal colors and settings --
#but as for update_stdout_tracking(), what's the point? Since we are inevitably
#going to perform message wrapping in print_message(), etc., there's no longer a
#need to prevent delimiting output with a newline when such output is output by
#the same printer function as the most recent output.
#FUXME: Excising update_stdout_tracking() allows us to dramatically simplify the
#implementation of start_stdout_delimited() as well, which is certainly nice.
#The only condition such function should now test is stdout mtime.
#FUXME: Contemplate excising this. Do we still expand this anywhere?

    # Handle previously updated standard output tracking.
#   start_stdout_delimited
    # Update standard output tracking in preparation for subsequent handling.
#   stop_stdout
# ....................{ PRINTERS                           }....................
#FUXME: Unconvinced this to be a helpful function. Certainly, the name is not
#helpful at all. Grep the codebase for where this is actually called from.
#declare_function_with_stdin <<'/---'
#string curse_string(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline. See
#print_string() for further details.
#/---
#function curse_string() {
#    die_unless_args 'expected at least one string'
#    output_string "${*}" 1>&2
#    update_stdout_tracking
#}

# No print_string*() functions call prepend_args_with_stdin_if_piped(),
# as doing so often invites obscene issues. When called by a caller receiving
# piped input, print_string*() functions silently capturing and closing such
# input before the caller can do so break such caller in subtle and *VERY*
# difficult to debug ways. Moreover, there are no to few reasonable scenarios in
# which print_string*() functions would be piped rather than merely passed input
# strings. For straightforward safety, avoid inviting such wayward breakage.

#declare_function_with_stdin <<'/---'
#string print_string(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline.
#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,
#
#.print_string() versus print()
#==========================================
#[source]
#------------------------------------------
#>>> string lammoth="-z" morgoth="rm -rf *"
#
## Bad! Never do this, unless guaranteed no hyphens prefix such string.
## If hyphens do prefix such string, zsh treats the first word of such
## string as options to print(). This can be extremely unsafe, as this
## example demonstrates.
#>>> print "${lammoth}" "${morgoth}"
#>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!
#
## Good. Always do this, instead.
#>>> print_string "${lammoth}" "${morgoth}"
#-z rm -rf *    # That's more like it.
#------------------------------------------
#==========================================
#/---
#function print_string() {
#    die_unless_args 'expected at least one string'
#    output_string "${*}"
#    update_stdout_tracking
#}

#FUXME: Given the current implementation, this function name's a bit of a
#misnomer. Rename to... what? I mean, ideally, shouldn't *THIS* function become
#the new print_string() and the existing print_string() and curse_string()
#functions simply excised? I reckon that's probably the way forward -- but to
#get there, we'll need to make darn sure that most existing calls to
#print_string() be renamed to return_string() instead.

#FUXME: *SWEET*. The existing tracking nomenclature is exceedingly awkward. I
#consequently propose renaming:
#
#* start_stdout_delimited()      to handle_stdout_tracking().
#* stop_stdout() to update_stdout_tracking().
#* reset_output()  to reset_stdout_tracking().
#
#Remove update_stdout_tracking() and reset_stdout_tracking(). They're just
#overkill; it's not clear such a distinction will ever be useful.
#FUXME: Consider instead renaming:  instead to:
#
#* start_stdout_delimited()      to vivify_stdout_tracking().
#* start_stdout_delimited()      to initiate_output().
#* stop_stdout() to finalize_output().
#
#Hmm. What about simply start_stdout_delimited() and stop_stdout()?
#FUXME: Right... Simply start_stdout_delimited() and stop_stdout(), I
#should think.

# ....................{ PRINTERS ~ newline                 }....................
#FUXME: What the heck is this? I fail to see any demonstrable benefit here. In
#fact, this function *SHOULD* be calling start_stdout_delimited() to serve
#as a genuine printer function, in which case the implementation makes utterly
#no sense. Replace all instances of this function will output_newline().
#declare_function_with_stdin <<'/---'
#string print_newline(void)
#
#Print a blank line to standard output.
#/---
#function print_newline() {
#    die_if_args
#    output_newline
#    update_stdout_tracking
#}

    # Validate passed arguments.
#   die_unless_args 'expected at least one string'

#declare_function_with_stdin <<'/---'
#string print_string(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline.
#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,
#
#.print_string() versus print()
#==========================================
#[source]
#------------------------------------------
#>>> string lammoth="-z" morgoth="rm -rf *"
#
## Bad! Never do this, unless guaranteed no hyphens prefix such string.
## If hyphens do prefix such string, zsh treats the first word of such
## string as options to print(). This can be extremely unsafe, as this
## example demonstrates.
#>>> print "${lammoth}" "${morgoth}"
#>>> rm -rf *   # Don't accidentally hit <Enter> here. WHAT, YOU JUST DID!?!
#
## Good. Always do this, instead.
#>>> print_string "${lammoth}" "${morgoth}"
#-z rm -rf *    # That's more like it.
#------------------------------------------
#==========================================
#/---
#function print_string() {
#    die_unless_args 'expected at least one string'
#    output_string "${*}"
#    update_stdout_tracking
#}


#Unlike low-level builtins echo() and print(), this and most other printer
#functions print embedded escape sequences as is rather than converting such
#sequences to the corresponding characters. Such conversions often mangle
#arbitrary output and hence are generally unhelpful. See
#print_string_with_escapes() for further details.
#
#Avoid calling such low-level builtins, which behave unexpectedly dangerously
#when passed hyphen-prefixed strings: e.g.,

#Unlike such low-level
#aliases and builtins, this function:
# subject to the conditions of start_stdout_delimited().
#suffixed by a newline in a color-aware manner. Prefix and suffix such output
#with ANSI color codes resetting color attributes to terminal-specific defaults.

    #FUXME: It'd be far more symmetric to simply call
    #reset_output() here, which incidentally would probably
    #also simplify caller logic. Grep where this function is used and see
    #whether or not all calls to this function are preceded by
    #start_stdout_delimited() (as I suspect they are). Since that function
    #already calls reset_terminal_color() internally, we can *GREATLY* simplify
    #such logic by simply shifting all such calls to
    #start_stdout_delimited() into this function right here, replacing
    #reset_terminal_color() here with a call to such function.

#FUXME: Is this function still called anywhere? The implementation is rather
#ungainly and, arguably, erroneous by design.
#declare_function_with_stdin <<'/---'
#string print_string_sans_newline_suffix(string text1 = "", string text2, ...)
#
#Print the passed strings (defaulting to the empty string) to standard output
#without trailing newline. See print_string() for further details.
#/---
#function print_string_sans_newline_suffix() {
    # Validate passed arguments.
#   die_unless_args 'expected at least one string'
#   string text="${*}"

    # Print such string unnewlined.
#   output_string_sans_newline_suffix "${text}"

    #FUXME: This is patently nonsense, now that we test the mtime of
    #"/dev/stdout" with nanosecond resolution. Indeed, it would be safer to
    #*ALWAYS* call update_stdout_tracking(), which updates the last
    #recorded mtime of "/dev/stdout". But, honestly, this function just doesn't
    #work, because ${ZESHY_OUTPUT_STATE_RUNNABLE_ID} will be this function if
    #we call update_stdout_tracking(), guaranteeing the next call to
    #start_stdout_delimited() will simply *ALWAYS* print such whitespace,
    #which is the opposite effect of what we want.
    #FUXME: We could introduce a new global set by this function and tested by
    #start_stdout_delimited() to avoid such complexities; but, really, this
    #is all *EXTREME* overkill. Excise this function, I should think.

    # Unlike output printed by most printer functions, output printed by this
    # function can conceivably be the empty string. In such case, to avoid
    # printing an unwanted newline on the next call to a printer function, the
    # call stack root must not be reset. Since strings consisting of only ANSI
    # color codes are effectively the empty string, test for emptiness after
    # excluding such codes.
#   if (( $(get_string_length_printable_sans_ansi_colors "${text}") )) {
#       print -r "string \"${text}\" length: $(get_string_length_printable_sans_ansi_colors "${text}")"
#       update_stdout_tracking
#   }
#}

#FUXME: O.K.; we need to manually sift through the codebase and change all
#current calls to print_string() for purposes of returning values to
#return_string() instead. The former now performs additional logic conflicting
#with mere value returning; the latter does not. Unavoidable, I'm afraid. As a
#positive bonus, however, the codebase will be moderately more readable.

#FUXME: Should probably be initialized to 0 and the global below to "" when
#serialized into zeshy's user digest file. Unsure how to reliably accomplish
#that. Perhaps perform such initialization in a *VERY* late precompilation hook
#function? Alternately, we should probably just have a list global declared at
#the "src/compile" level of the names of all globals to be initialized to "="
#(i.e., the empty string) immediately before compilation into the digest. This
#is necessary for all globals tracking transient state and hence likely to be
#useful elsewhere in the future.

# (( ${+ZESHY_STDOUT_PRIOR_MTIME} == 0 )) or {
#${+ZESHY_STDOUT_PRIOR_MTIME} == 0 ||
#       ${ZESHY_STDOUT_PRIOR_MTIME-0} &&

    #FUXME: Hyphens are also acceptable delimiters, yes?
    #FUXME: We should probably preserve newlines, yes?

#       print_newline
#      (( ${ZESHY_STDOUT_PRIOR_MTIME-0} &&\
#           ZESHY_STDOUT_PRIOR_MTIME != $(get_stdout_mtime) )) {
    #FUXME: O.K.; I've hunted down why this doesn't work as advertised. It's
    #exceptionally subtle but certainly solvable. Basically, it boils down to
    #get_stdout_mtime(): it's an inherently stupid function, because getters are
    #only ever called as process substitutions, which in this case always
    #returns the stdout of the subshell (a pipe!) rather than the stdout of the
    #current shell (typically, a pseudo-terminal). We need to *EXCISE*
    #get_stdout_mtime() and make a new alias set_float_to_stdout_mtime():
    #
    #alias set_float_to_stdout_mtime='{
    #   # Do the typical thing here, getting all of stdin into a single local
    #   # variable named:
    #   string float_name__sftso
    #   die_unless_variable_float "${float_name__sftso}"
    #
    #   # Resolve "/dev/fd/1" to a non-symbolic absolute path. Assuming the
    #   # current shell to be a pseudo-terminal, "/dev/fd/1" is typically a
    #   # symbolic link to the device for such terminal (e.g., "/dev/pts/7").
    #   # Referring to standard output by such resolved rather than symbolic
    #   # path is essential; we run the command getting standard output's mtime
    #   # from a process substitution in which symbolic path "/dev/fd/1" refers
    #   # to a shell pipe rather than the desired pseudo-terminal.
    #   #
    #   # Sadly, the only safe means of resolving such path is as below.
    #   # Replacing the first pipeline subcommand with a call to
    #   # canonicalize_path() uselessly returns "/dev/fd/1" without resolving
    #   # such path. Likewise, replacing the second pipeline subcommand with a
    #   # process substitution has the same effect. (My inveterate Gods, but
    #   # this is subtle.)
    #   string stdout_filename__sftso
    #   output_string "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}"(:A) |
    #       set_string_to_stdin_pipe stdout_filename__sftso
    #
    #   # Set such float to such path's mtime. See set_float_to_float() for
    #   # further details.
    #   get_path_mtime "${stdout_filename__sftso}" |
    #       set_float_to_stdin_pipe "${float_name__sftso}"
    #} <<<'
    #
    #Craziness, but it works. Shift to "05-alias/io/standard". *shakes head*
    #FUXME: We need to add a new set_float_to_stdin_pipe() to "always/io/standard",
    #which then requires a new set_float_to_float() in
    #"always/variable/float/float". It's all trivial -- just needs to be done!
    #FUXME: Alternatively, we could just make a new
    #set_variable_to_stdin_pipe() function. It's not to have the strict typing of
    #set_string_to_stdin_pipe() elsewhere, but it's really just an inefficiency here.
    #Then, we could just call set_scalar_to_stdin() above twice. Hmmm...
    #actually, that gains us effectively nothing. There are *ONLY* three scalar
    #types, so we'd might as well support them all type-safely. Honestly, any
    #inefficiency here is minor compared to the weight of zeshy as a whole.
    #O.K.; go with the original plan above!
    # When debugging, note that it's not genuinely possible to print
    # ${ZESHY_STDOUT_PRIOR_MTIME}. Why? Because merely printing

#   output_string "resetting ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
#   output_string "resetting ZESHY_STDOUT_PRIOR_MTIME: ${ZESHY_STDOUT_PRIOR_MTIME}; ZESHY_STDOUT_PRIOR_SCRIPT_LINE: ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE}" 1>&2
    #FUXME: Sadly, we need to drop the ${ZESHY_STDOUT_PRIOR_MTIME} testing.
    #Why? Because, with a coarse granularity of only seconds, this function
    #effectively reduces to a random number generator: sometimes it prints
    #delimiting whitespace as expected, sometimes it doesn't. This is terrible.
    #However, document the current solution for posterity.
    #FUXME: *WAIT*. Any kernel worth running zsh on should support nanosecond-
    #resolution mtimes; see:
    #  http://stackoverflow.com/questions/7206014/get-a-nanosecond-precise-atime-mtime-ctime-fields-for-file-stat
    #
    #zsh appears to have integrated a patch; see:
    #  http://www.zsh.org/mla/workers/2007/msg00972.html
    #FUXME: Ah-ha! While zsh currently supplies no means of retrieving
    #nanosecond-resolution times via zstat(), the system-specific stat() command
    #does *IF* passed option "-c '%y====%Y'": e.g.,
    #
    #  >>> stat --dereference --printf '%y\0%Y' /dev/fd/1
    #  2013-05-22 19:39:01.436503138 -04001369265941
    #
    #Awesome, no? We'll need to parse the actual nanosecond mtime back together
    #from such string. For the above, for example, such mtime is:
    #
    #  1369265941.436503138
    #
    #By saving such value to a float, "viola!" Nanosecond-resolution times.
    #FUXME: Since the output of "-c '%y'" is system- and user-specific, we
    #should simply round such time to the nearest integer if it fails to match
    #the above specification: e.g.,
    #
    #  1369265941.0

    #FUXME: We should be using the test operator "-om" in place of...
    # Ensure each tested variable exists before testing such
    # variable's
    # To avoid returning success when both string variables are
    # undefined, default undefined string variables to a value that zsh
    # operation guarantees such variables to *NEVER* be set to (i.e., null).
    #
    # Subtleties abound, ribald bald acolytes.
#   if is "${funcfiletrace[2]-$'\0'}" !=\
#         "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-$'\0'}" si or

#-n "${ZESHY_STDOUT_PRIOR_SCRIPT_LINE-}" and
#       "${#funcfiletrace}" -ge 2 and
#
#${+ZESHY_STDOUT_PRIOR_MTIME} &&\
#FUXME: Excise everywhere, shifting documentation above where applicable. I
#recall only referencing this global in this component. Check on that...
#declare_global_with_stdin <<'/---'
#string ZESHY_PRINT_CALL_STACK_ROOT
#
#Most recent call stack root to have called a high-level print function (e.g.,
#print_message(), print_warning()) or the empty string if no such function has
#been called, where "call stack root" is the first zsh function, script, or
#command line to have initiated the current call stack.
#
#Specifically, this string is the first element of list global ${funcfiletrace}
#at the time of the most recent call to a high-level print function as recorded
#by start_stdout_delimited(). zsh tracks call stack state with
#two list globals: ${funcname} and ${funcfiletrace}. The former distinguishes
#between calls to different functions and scripts but *NOT* between different
#calls to the same function or script or between different command lines. The
#latter distinguishes between all such calls, hence subsuming the former. Given
#only a filename and line, inspecting such line usually furnishes the function
#name called on such line. Therefore, each element of ${funcfiletrace} uniquely
#identifies the corresponding call in the call stack. Since the first element of
#such list corresponds to the caller responsible for initiating the entire call
#stack, such element effectively differentiates such stack from subsequent call
#stacks initiated by other callers.
#
#See start_stdout_delimited() for further details.
#/---
#
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., print_string()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#start_stdout_delimited() should thus print a delimiting newline.
#If standard output for the current shell is attached to a terminal, set the
#stored call stack root specific to `zeshy` printer functions to the current call
#stack root. This function is typically called by low-level `zeshy` printer functions
#(e.g., print_string()) to notify subsequently called high-level print functions
#(e.g., print_message()) that at least one such print function has already been
#called under the current call stack root and that
#start_stdout_delimited() should thus print a delimiting newline.
#      (( ZESHY_STDOUT_PRIOR_MTIME )) and
    #FUXME: Convert to an "if" statement and attempt to remove the trailing
    #return_true().

    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
    #
    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required.
    #
    # Prefer explicit string equality testing to calling is_string_equals(), as
    # the latter behaves poorly when either such string expands to the empty
    # string (as curiously appears to be the case when called from an exception
    # handler). Subtleties abound, dear acolytes.
#   print "printing newline if equals: ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT-}; funcfiletrace[-1]: ${funcfiletrace[-1]}" 1>&2; output_call_stack 1>&2
#   is "${ZESHY_PRINT_CALL_STACK_ROOT-}" == "${funcfiletrace[-1]}" si and
#       print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    # Succeed regardless of whether such newline was printed.
#   return_true
# the following conditions all hold 
    #FUXME: This isn't quite right, and one can readily see why when
    #uncommenting the print() statement below: a granularity of seconds is
    #simply too low to reliably detect changes. Ideally, "mtime" would be
    #recorded in milli- or nanoseconds. Since it isn't, another approach is
    #required. 

#FUXME: Adjust the conditions under which a newline is printed to the following:
#
#* If ${ZESHY_STDOUT_PRIOR_SCRIPT_LINE} is unequal to the currently called printer
#  function name (e.g., "print_message"),
#* If ${ZESHY_STDOUT_PRIOR_MTIME} is non-empty (or non-zero, if we
#  decide to use an integer as we probably should) *AND* unequal to the
#  current mtime for "/dev/fd/1" *AND*
#* Then and only then print a newline.
#See 
#Print a blank line to standard output if at least one Zeshy print function has
#already been called under the current call stack root (i.e., called either by
#such root or by a function or script transitively called by such root). This
#function is typically called by high-level Zeshy print functions (e.g.,
#print_message()) to print a newline delimiting subsequent from previous output.
#See ${ZESHY_PRINT_CALL_STACK_ROOT} for further details.
    # * Standard output for the current shell is attached to either a terminal
    #   or pipe (e.g., page_stdin()) (thus avoiding printing a newline when
    #   ,
    #if { is_stdout_terminal_or_pipe } and
#FUXME: Rename to update_printer_globals(). Hmm, perhaps
#update_stdout_tracking() or set_last_print_globals()?
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_STDOUT_MTIME.
#FUXME: Rename to ZESHY_FUNCTION_PRINTER_NAME.
#FUXME: Do we actually call this anywhere? And if so, why? All such calls
#should probably simply be expanding output_string_sans_newline_suffix(). Grep the
#codebase.
    # Succeed regardless of whether such root was reset.
#   return_true
# (e.g., newlines, nulls, strings, lists).
# ....................{ PRINTERS ~ separated               }....................
#FUXME: Such functions should internally depend on new functions of new
#component "variable/string/separate", which actually perform the calling of
#builtin print(). Consider function names:
#
#* concatenate_strings() or unseparate_strings(). Probably the former; the
#  latter is simply odd. Right. Every language needs a concatenate function,
#  so... this is ours!
#* separate_strings_with_newline() or delimit_strings_by_newline(). The former.
#* separate_strings_with_null().
#FUXME: Rename this function to print_strings_concatenated().
#declare_function_with_stdin <<'/---'
#string print_strings_unseparated(string text1, string text2, ...)
#
#Print the passed strings to standard output with default trailing newline and
#_not_ internally delimited by ${IFS}, the internal field separator: e.g.,
#
#.print_strings_unseparated()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_unseparated "Where Alph," "the sacred river," "ran"
#Where Alph,the sacred river,ran
#------------------------------------------
#==========================================
#/---
#function print_strings_unseparated() {
#    # Temporarily set global string ${IFS} to the empty string. Since zsh
#    # implicitly delimits lists interpolated with the "*" operator when double-
#    # quoted with such global, the following commands print the passed arguments
#    # undelimited. This incantation was astonishingly difficult to discover.
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}"  # if not double-quoted, zsh oddly ignores ${IFS}
#    update_stdout_tracking
#}

#declare_function_with_stdin <<'/---'
#string print_strings_newlined(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited by newlines: e.g.,
#
#.print_strings_newlined()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_newlined sludge elf transmuter
#sludge
#elf
#transmuter
#------------------------------------------
#==========================================
#/---
#function print_strings_newlined() {
#    die_unless_args 'expected at least one string'
#    print -lr -- "${@}"
#    update_stdout_tracking
#}
#
#declare_function_with_stdin <<'/---'
#string print_strings_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
#
#.print_strings_nulled()
#==========================================
#[source]
#------------------------------------------
#>>> print_strings_nulled "Through caverns" "measureless to" "man"
#Through caverns\0measureless to\0man
#------------------------------------------
#==========================================
#/---
#function print_strings_nulled() {
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}"
#    update_stdout_tracking
#}

#       ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#       print "resetting ZESHY_PRINT_CALL_STACK_ROOT: ${ZESHY_PRINT_CALL_STACK_ROOT}" 1>&2; output_call_stack 1>&2
    # Succeed regardless of whether such root was set.
#   return_true
    # If standard output for the current shell is attached to either a terminal
    # or pipe (e.g., page_stdin()), store such globals.
    #
    # Prefer an "if"- to "and"-style conditional to avoid returning false.
#   if { is_stdout_terminal_or_pipe } {

#FUXME: Rename to print_strings_unseparated() or print_strings_undelimited()?
#Yes, I rather like the latter. Though, the former is a bit more readable...
#FUXME: Rename to print_string_unnewlined() or perhaps simply
#output_string_sans_newline_suffix(). Yeah; the latter is pretty sweet.
#Print the passed strings to standard output without delimitation:
#FUXME: Hmm; this should really be called print_string_with_escapes(). Function
#name print_string_with_escapes() implies something completely different (i.e., that
#all shell-reserved characters will be printed escaped).

# common escapes escaped (i.e., converted to the corresponding characters):
# Unlike say(), print no theme-specific nonsense (e.g., ANSI color codes).
# Unlike cry(), print no theme-specific nonsense (e.g., ANSI color codes).
# (i.e., such that a newline separates each such string from the next)
    # If the previously recorded call stack root (defaulting to the empty string
    # if not previously recorded) is the current call stack root, at least one
    # message has already been output under such call stack, so this function
    # must prefix the current message to be output with whitespace.
#   if is_string_equals\
#       "${ZESHY_PRINT_CALL_STACK_ROOT-}" "${funcfiletrace[-1]}"
#   then print_newline
#       print "printing newline; call stack ends: ${funcfiletrace[-1]} / ${funcfiletrace[-1]}"

    #FUXME: This is now redundant, as the subsequent print_string()
    #function sets this.

    # Else the previously recorded call stack root and current call stack root
    # differ, suggesting no message has been output under such call stack, so no
    # prefixing whitespace is required. Instead, replace the previously recorded
    # call stack root with the current.
#   else ZESHY_PRINT_CALL_STACK_ROOT="${funcfiletrace[-1]}"
#   fi

#Prefix the next string to be output with whitespace delimiting such string from
#previously output strings if at least one such string has already been output
#under the current call stack root. This function manages string global
#${ZESHY_PRINT_CALL_STACK_ROOT} on behalf of the caller, usually a high-level
#print function (e.g., print_message(), print_header()).
#
#FUXME: A bit unintuitive. Not sure either is terribly better, but how about
#renaming to print_string_no_newline() or print_string_newlineless() or
#output_string_sans_newline_suffix(). The latter coincides with print_strings_unseparated()
#and thus strikes me as the best bet.
# demarcating subsequent from prior lines
#FUXME: This function strikes me as a poor idea. Functions should not, ideally,
#handle such aesthetic-dependent behavior. Cut everywhere.
#FUXME: Actually, it's a fine idea: it's just the nomen
    #FUXME: Bit more natural to call as a pipe: e.g.,
    #    print_message "${*}" | output_string_sans_newline_suffix
    #We'll need to add pipe support to such functions. Since this is something
    #we want to do anyway, it's hard to see complaints.
#   output_string_sans_newline_suffix "$(print_message "${*}")"
#   output_string_sans_newline_suffix "$(print_warning "${*}" 2>&1)" 1>&2
#FUXME: How often do the curse_*() functions come up? Grep the codebase. I
#suspect the answer is "never", or near enough, in which case we should excise
#everything except curse_string(). The whole thing's nonsensical code
#duplication, anyway, as any curse_*() function is implemented simply by calling
#the corresponding print_*() function appended by "1>&2". What could be simpler?

#declare_function '
#void curse_string_escaped(string text1, string text2, ...)
#
#Print the passed strings to standard error with default trailing newline and
#all escapes escaped, as with print_string_with_escapes().
#'
#function curse_string_escaped() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -- "${*}" 1>&2
#}

#declare_function '
#void curse_string_undelimited(string text1, string text2, ...)
#
#Print the passed strings to standard error without delimitation: e.g.,
#
#    >>> curse_string_undelimited "Through caverns" "measureless to" "man"
#    Through cavernsmeasureless toman
#'
#function curse_string_undelimited() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    string IFS=
#    print -r -- "${*}" 1>&2  # if not double-quoted, zsh oddly ignores ${IFS}
#}

#declare_function '
#void curse_string_nulled(string text1, string text2, ...)
#
#Print the passed strings to standard output delimited and terminated by nulls.
#See curse_string_nulled for details.
#'
#function curse_string_nulled() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -Nr -- "${@}" 1>&2
#}

#declare_function '
#void curse_newline(void)
#
#Print a blank line to standard error.
#'
#function curse_newline() {
#    die_if_args
#    print 1>&2
#}
#FUXME: Rename to output_string_sans_newline_suffix(). Every other alternative is absurdly
#and frankly stupidly verbose (e.g., "unsuffixed_by_newline",
#"without_newline"). Since "newline" is increasingly used as a verb (e.g., "That
#text shouldn't be newlined."), I don't see why we can't coin a derivative
#neologism from that: non-newline! Google shows a large number of hits for
#"non-newline" as a noun, so... There we go.
#declare_function '
#void curse_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard error with no default trailing newline.
#'
#function curse_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${*}" 1>&2
#}

#declare_function '
#string print_string_sans_newline_suffix(string text1, string text2, ...)
#
#Print the passed strings to standard output in a color-aware manner with *NO*
#trailing newline. See print_string() for further details.
#'
#function print_string_sans_newline_suffix() {
#    prepend_args_with_stdin_if_piped
#    die_unless_args 'expected at least one string'
#    print -nr -- "${ZESHY_COLOR_RESET-}${*}${ZESHY_COLOR_RESET-}"
#}

#   print "stdin: $(< /dev/stdin)"
#FUXME: Rename to print_nondelimited(); similarly, below. While Google shows an
#effectively equal number of hits for both undelimited and non-delimited, the
#latter is much more consistent with nomenclature elsewhere.
#FUXME: Rename to print_with_delimiter_newline(); similarly, below.
# * Rename "cry" to "cry" and "outcry" to simply "outcry". Likewise,
#   rename "say" to "put" and "output" to simply "output". Truly, for this is
#   Awesome Incarnate.
# * Alternatively, rename "outcry" to "decry", "say" to "vow", and "output"
#   to "devow". Personally, I prefer the "out"-prefixed forms, as that cleanly
#   suggests an input_*() family of functions to accept input.
# * O.K.; how about this. The "cry" forms are quite perfect, but the "say"
#   forms... I quite like "output" to "output", but "say" to "put"? It reads
#   awkwardly, to put it mildly. Let's go non-orthogonal here, for readability.
#   How about "say" to "say", which coincides nicely with "cry"? Then we have:
#
#   print_warning -> print_warning      curse_string -> outcry
#   print_message -> print_message      print_string -> output
# * I'm strongly in favor of:
#   output() or stsay() or msay()
#   outcry() or ???????()
#   Yeah, output() and outcry() read quite well.
