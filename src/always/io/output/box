#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Revise documentation.
declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle ...
______________<heredoc?>______________

# ....................{ PRINTERS                           }....................
#FIXME: Oh, wait! We can get the 'color_style_category' just by calling
#"$(get_caller)", so don't bother explicitly passing it. (Let's simplify life a
#tad, in other words.)
#FIXME: Revise documentation, naturally.
declare_function_with_stdin <<'/---'
string print_string_boxed_with_color_style_prefix(
    string text, string color_style_category)

Print the passed string wrapped to the current terminal width, prefixing each
resulting line with the passed prefix. Specifically:

. Split such string into substrings satisfying the following constraints:
** Each substring is suffixed by either whitespace or the end of such string.
** Each substring is no longer than the current terminal width subtracted by the
   length of such prefix.
. Print each substring prefixed by such prefix and suffixed by a newline.

For example:

.print_string_boxed_with_color_style_prefix()
==========================================
[source]
------------------------------------------
>>> string on_boxes=\
...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
...    "man hired armed guards to keep anyone from eating his fish. The many"\
...    "people who sit next to the empty river starve to death. But they do"\
...    "not die of starvation. They die of a belief. Everyone believes that"\
...    "the man atop the box owns the fish. The soldiers believe it, and they"\
...    "will kill to protect the illusion. The others believe it enough that"\
...    "they are willing to starve. But the truth is that there is a box,"\
...    "there is an emptied river, there is a man sitting atop the box, there"\
...    "are guns, and there are starving people."
>>> print_string_wrapped_with_line_prefix "${on_boxes}" box
box: The box is full of salmon, and a man sits atop the box. Long ago this man
box: hired armed guards to keep anyone from eating his fish. The many people who
box: sit next to the empty river starve to death. But they do not die of
box: starvation. They die of a belief. Everyone believes that the man atop the
box: box owns the fish. The soldiers believe it, and they will kill to protect
box: the illusion. The others believe it enough that they are willing to starve.
box: But the truth is that there is a box, there is an emptied river, there is a
box: man sitting atop the box, there are guns, and there are starving people.
------------------------------------------
==========================================
/---
function print_string_boxed_with_color_style_prefix() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one color style prefix'
    string text="${1}" color_style_prefix="${2}"
    integer\
        terminal_width\
        text_length\
        line_length\
        line_prefix_length\

    # Width in characters of the current terminal.
    terminal_width="$(get_terminal_width)"

    # If such width is sufficiently small, it's not feasible to print both a box
    # and at least one character in such box. In such cases, print such string
    # as is and immediately return.
    if (( terminal_width <= 5 )) {
        print_string "${text}"
        return_true
    }

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
    if { is_encoding_utf8 } {
        border_north='═'
        border_south='─'
        border_west='│'
        border_east='│'
        border_north_west='╒'
        border_north_east='╕'
        border_south_west='╰'
        border_south_east='╯'
    } else {
        border_north='-'
        border_south='-'
        border_west='|'
        border_east='|'
        border_north_west='/'
        border_north_east='\'
        border_south_west='\'
        border_south_east='/'
    }

    #FIXME: It'd be silly to reimplement a method printing a box header, given
    #the already sufficiently complex print_heading() function. We'll need to
    #generalize such function to call a new "driver" function, doing the lion's
    #share of printing work -- say, print_string_centered_with_border().
    #FIXME: Interestingly, given such function, we can instantly a new
    #print_string_centered() to simply call such function with a map whose
    #border characters all simply expand to a single space. Nice.

    # Length of such text, excluding non-printable characters and sequences.
    text_length="$(get_string_length_printable_sans_ansi_colors "${text}")"

    # Maximum length of each text substring to be printed on each output line.
    line_length=$(( terminal_width - prefix_length ))

    #FIXME: Create such function, which should simply call
    #reset_terminal_color() currently (but which subsequently could be made to
    #perform additional functionality).
    # If required, print delimiting prefixing whitespace.
#   start_stdout_printing

    # For each text substring to be printed on each output line, print such
    # substring prefixed by the message prefix and suffixed by at least a
    # newline. See get_string_wrapped_at_line_length() for further details.
    for_string_pcre_matches\
        "${text}" "$(get_pcre_wrapping_at_line_length "${line_length}")"\
        '# Prefix the current line by such prefix.
        output_string_sans_newline "${line_prefix}"

        # Print such line.
        if is -n "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}" si {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}"
        } else {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_UNDELIMITED}']}-"
        }'

    # Sanitize the current terminal in preparation for subsequent output.
    stop_stdout_printing
}

# ....................{ PRINTERS ~ heading                 }....................
#FIXME: Reimplement to simply call print_string_centered_with_border().
declare_function_with_stdin <<'/---'
string print_heading(string heading1 = "", string heading2, ...)

Print the passed strings (defaulting to the empty string) as a section heading
suffixed by a newline to standard output. See print_string() for further
details.
/---
function print_heading() {
    # Heading to be printed, concatenated from passed arguments.
    string heading="${*}"
    integer terminal_width heading_length character_count_left

    # If the current call stack has already called a high-level print function,
    # print delimiting whitespace.
    start_stdout_printing_delimited

    # Lengths of the current terminal and heading. The latter excludes non-
    # printable characters, including ANSI color escapes.
    terminal_width="$(get_terminal_width)"
    heading_length="$(get_string_length_printable_sans_ansi_colors\
        "${heading}")"

    # Number of characters preceding such heading, when centering such heading
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures when the
    # terminal width and heading length are of differing parity that the heading
    # will be offset to the left one character from the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    (( character_count_left = (terminal_width - heading_length) / 2 ))

    #FIXME: It'd be great to eventually support the subdivision of the border
    #into appropriate subsections: e.g.,
    #
    #     ====~~~-{ heading }--~~~===
    #
    #The principal annoyance there, of course, is that for each possible
    #subdivision you add, you have to add the corresponding number of
    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
    #concoct a single governing equation determining how many characters of each
    #subdivision to print, even in edge cases of small terminal lines: e.g.,
    #
    #     ~-{ heading }-~
    #FIXME: Actually, we'd probably just want to subdivide the *COLORS* of a
    #single-character border into a gradient. Don't change the characters;
    #change the colors.

    # If such number is at least 2, such heading is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such heading remain for a border. Since this suffices for simple
    # ANSI art, print such heading preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
    if (( character_count_left >= 2 )) {
        # Number of border characters (e.g., "-") preceding and succeeding such
        # heading, respectively. Such numbers are always nonnegative (>= 0).
        integer border_count_left border_count_right
        (( border_count_left = border_count_right = character_count_left - 2 ))

        # If such heading length and terminal width have different parity (i.e.,
        # one is even and the other odd), 1 additional character of space to the
        # right of such heading remains for a border; allocate such space!
        if { not is_integer_parity_equals\
            ${terminal_width} ${heading_length} } {
            border_count_right+=1
        }

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" heading
        #   titles to adjacent borders).
        character\
            character_border\
            character_joiner_left='{ '\
            character_joiner_right=' }'

        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
        if { is_encoding_utf8 } {
            character_border='─'
        } else {
            character_border='-'
        }

        # Left and right borders consisting of such characters.
        string left_border right_border
        left_border="$( repeat_string "${character_border}" ${border_count_left})"
        right_border="$(repeat_string "${character_border}" ${border_count_right})"

        # Print such heading.
        print_string\
            "${ZESHY_COLOR_STYLE[print_heading.border]-}${left_border}${ZESHY_COLOR_STYLE[print_heading.joiner]-}${character_joiner_left}${ZESHY_COLOR_STYLE[print_heading.heading]-}${heading}${ZESHY_COLOR_STYLE[print_heading.joiner]-}${character_joiner_right}${ZESHY_COLOR_STYLE[print_heading.border]-}${right_border}"
    # If such number is 1, such heading's length is either 2 or 3 characters
    # less than such width. Hence, 1 character to the left of and either 1 or 2
    # characters to the right of such heading remain for a border. This isn't
    # terribly much. In the absence of anything better to do, print such heading
    # offset from the beginning of the terminal line by 1 character.
    } elif (( character_count_left == 1 )) {
        print_string " ${heading}"
    # Else such number is nonpositive (i.e., less than or equal to 0).
    #
    # If such number is negative, such heading exceeds such terminal in length.
    # In the absence of anything better to do, print such heading as is. While
    # this guarantees such heading to wrap around at least once, truncating such
    # heading to the current terminal width often produces worse results.
    #
    # If such number is 0, such heading's length is either the terminal width or
    # one character less than such width. In the former case, no space remains
    # for a border; in the latter case, only one character of space remains,
    # hardly enough for even delimiting whitespace. In the absence of anything
    # better to do, again print such heading as is.
    #
    # For both efficiency and simplicity, unify both such cases here.
    } else {  # guard condition :: elif (( character_count_left <= 0 ))
        print_string "${heading}"
    }
}

#FIXME: Document me.
#FIXME: It'd be great to eventually support the subdivision of the border
#into appropriate subsections: e.g.,
#
#     ====~~~-{ text }--~~~===
#
#The principal annoyance there, of course, is that for each possible
#subdivision you add, you have to add the corresponding number of
#conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#concoct a single governing equation determining how many characters of each
#subdivision to print, even in edge cases of small terminal lines: e.g.,
#
#     ~-{ text }-~
#FIXME: Actually, we'd probably just want to subdivide the *COLORS* of the
#single-character border into a gradient. Don't change the characters;
#change the colors. This is both simpler and more aesthetically pleasing.
function print_string_centered_with_map() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected at least one string and one map name'
    string\
        text__pscwb\
        map_name__pscwb="${@[-1]}"
    integer\
        terminal_width__pscwb\
        text_length__pscwb\
        character_count_left__pscwb
    pop_arg

    # Localize such map into local variables of this function.
    die_unless_map_keys "${map_name__pscwb}"\
        'color_style_prefix'
    localize_map "${map_name__pscwb}"

    # String to be printed, concatenated from remaining arguments.
    text__pscwb="${*}"

    # Width in characters of the current terminal.
    terminal_width="$(get_terminal_width)"

    # Length of such text, excluding non-printable characters and sequences.
    text_length="$(get_string_length_printable_sans_ansi_colors "${text}")"

    # Number of characters preceding such text, when centering such text
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures that, when
    # the terminal width and text length are of differing parity, the text will
    # be offset to the left by one character of the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    (( character_count_left = (terminal_width - text_length) / 2 ))

    # If such number is at least 2, such text is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such text remain for a border. Since this suffices for simple
    # border art, print such text preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
    if (( character_count_left >= 2 )) {
        # Number of border characters (e.g., "-") preceding and succeeding such
        # text, respectively. Such numbers are always nonnegative (>= 0).
        integer border_count_left border_count_right
        (( border_count_left = border_count_right = character_count_left - 2 ))

        # If such text length and terminal width have different parity (i.e.,
        # one is even and the other odd), 1 additional character of space to the
        # right of such text remains for a border; allocate such space!
        is_integer_parity_equals ${terminal_width} ${text_length} or
            (( border_count_right++ ))

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" text
        #   titles to adjacent borders).
        string\
            left_border\
            right_border\
            character_border\
            character_joiner_left='{ '\
            character_joiner_right=' }'

        # If the current locale encodes to UTF-8, print UTF-8; else, ASCII.
        if { is_encoding_utf8 } {
            character_border='─'
        } else {
            character_border='-'
        }

        # Left and right borders consisting of such characters.
        left_border="$( repeat_string "${character_border}" ${border_count_left})"
        right_border="$(repeat_string "${character_border}" ${border_count_right})"

        # Print such text.
        print_string\
            "${ZESHY_COLOR_STYLE[print_text.border]-}${left_border}${ZESHY_COLOR_STYLE[print_text.joiner]-}${character_joiner_left}${ZESHY_COLOR_STYLE[print_text.text]-}${text}${ZESHY_COLOR_STYLE[print_text.joiner]-}${character_joiner_right}${ZESHY_COLOR_STYLE[print_text.border]-}${right_border}"
    # If such number is 1, such text's length is either 2 or 3 characters
    # less than such width. Hence, 1 character to the left of and either 1 or 2
    # characters to the right of such text remain for a border. This isn't
    # terribly much. In the absence of anything better to do, print such text
    # offset from the beginning of the terminal line by 1 character.
    } elif (( character_count_left == 1 )) {
        print_string " ${text}"
    # Else such number is nonpositive (i.e., less than or equal to 0).
    #
    # If such number is negative, such text exceeds such terminal in length.
    # In the absence of anything better to do, print such text as is. While
    # this guarantees such text to wrap around at least once, truncating such
    # text to the current terminal width often produces worse results.
    #
    # If such number is 0, such text's length is either the terminal width or
    # one character less than such width. In the former case, no space remains
    # for a border; in the latter case, only one character of space remains,
    # hardly enough for even delimiting whitespace. In the absence of anything
    # better to do, again print such text as is.
    #
    # For both efficiency and simplicity, unify both such cases here.
    } else {  # guard condition :: elif (( character_count_left <= 0 ))
        print_string "${text}"
    }
}

#FIXME: In lieu of unit tests, this will do.
#function sayh() {
##   print_call_stack
#    print_string 'upended'  # should be two newlines after this!
#    print_heading 'dancing to'
#    print 'life'
#    brayman
#    print_heading 'road to'
#    print 'ubar'
#}
#function brayman() {
#    print_heading 'beyond'
#    print 'genesis'
#    print_heading 'ein'
#    print 'lichtschein'
#}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Actually, we want to pass a map name, where the map is structured:
#
#     "${map_name}"=(
#         'color_style_category' 'print_message'
#     )
#. This PCRE assumes *multiline matching*
#(i.e., the `.` quantifier matches all characters _except_ newline) and hence
#should only be used under such matching
# Match
    # multiline to prevent "." from matching newlines.
    # Return such string.
#   return_string "${text_wrapped}"

#Wouldn't you like to see a positive LSD story on the news? To base your decision on information rather than scare tactics and superstition? Perhaps? Wouldn't that be interesting? Just for once?
#   "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."

    # PCRE wrapping lines to such length.
#   pcre_wrapping_lines="$(get_pcre_wrapping_at_line_length "${line_length}")"

    #FUXME: Abstract into a string global.
    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    # Dismantled, this is:
    #
    # * "\G", anchoring such match immediately after the end of the prior match.
    # * "\h*+", matching ignorable horizontal whitespace (i.e., non-newline)
    #   without backtracking, for efficiency.
    # * "(?:...)", matching either:
    #   * "\n", a newline, in which case ${match[1]} will be the empty string,
    #     ensuring an equivalent of 'output_string "${match[1]}"' will simply
    #     reprint the matched newline.
    #   * "(.{...})", a line's worth of text to ${match[1]}, optionally:
    #     * "(-)", capturing a hyphen suffix to ${match[2]}.
    # * "(?(2)|(?:...))", matching either:
    #   * If a hyphen suffix previously matched, then nothing else.
    #   * Else, mandatory horizontal whitespace, a newline, or the string end.
    #     In any case, such suffix will typically be converted into a newline.
#   line_pcre='\G\h*+(?:\n|(.{1,'${line_length}'}(-)?)(?(2)|(?:\h+|$))'
    # * "(?:...)", matching such line's delimiter as either:

#Minimizing Line Count versus Right Raggedness 
#a maximal line's worth  substring. To ensure human-readable output, wrap at
#word endings by requiring such substring be suffixed by either whitespace
#or the end of such string.
