#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Revise documentation.
declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle ...
______________<heredoc?>______________

# ....................{ PRINTERS                           }....................
#FIXME: Oh, wait! We can get the 'color_style_category' just by calling
#"$(get_caller)", so don't bother explicitly passing it. (Let's simplify life a
#tad, in other words.)
#FIXME: Revise documentation, naturally.
declare_function_with_stdin <<'/---'
string print_string_boxed_with_color_style_prefix(
    string text, string color_style_category)

Print the passed string wrapped to the current terminal width, prefixing each
resulting line with the passed prefix. Specifically:

. Split such string into substrings satisfying the following constraints:
** Each substring is suffixed by either whitespace or the end of such string.
** Each substring is no longer than the current terminal width subtracted by the
   length of such prefix.
. Print each substring prefixed by such prefix and suffixed by a newline.

For example:

.print_string_boxed_with_color_style_prefix()
==========================================
[source]
------------------------------------------
>>> string on_boxes=\
...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
...    "man hired armed guards to keep anyone from eating his fish. The many"\
...    "people who sit next to the empty river starve to death. But they do"\
...    "not die of starvation. They die of a belief. Everyone believes that"\
...    "the man atop the box owns the fish. The soldiers believe it, and they"\
...    "will kill to protect the illusion. The others believe it enough that"\
...    "they are willing to starve. But the truth is that there is a box,"\
...    "there is an emptied river, there is a man sitting atop the box, there"\
...    "are guns, and there are starving people."
>>> print_string_wrapped_with_line_prefix "${on_boxes}" box
box: The box is full of salmon, and a man sits atop the box. Long ago this man
box: hired armed guards to keep anyone from eating his fish. The many people who
box: sit next to the empty river starve to death. But they do not die of
box: starvation. They die of a belief. Everyone believes that the man atop the
box: box owns the fish. The soldiers believe it, and they will kill to protect
box: the illusion. The others believe it enough that they are willing to starve.
box: But the truth is that there is a box, there is an emptied river, there is a
box: man sitting atop the box, there are guns, and there are starving people.
------------------------------------------
==========================================
/---
function print_string_boxed_with_color_style_prefix() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one color style prefix'
    string text="${1}" color_style_prefix="${2}"
    integer\
        terminal_width\
        text_length\
        line_length\
        line_prefix_length\

    # Width in characters of the current terminal.
    terminal_width="$(get_terminal_width)"

    # If such width is sufficiently small, it's not feasible to print both a box
    # and at least one character in such box. In such cases, print such string
    # as is and immediately return.
    if (( terminal_width <= 5 )) {
        print_string "${text}"
        return_true
    }

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
    if { is_encoding_utf8 } {
        border_north='═'
        border_south='─'
        border_west='│'
        border_east='│'
        border_north_west='╒'
        border_north_east='╕'
        border_south_west='╰'
        border_south_east='╯'
    } else {
        border_north='-'
        border_south='-'
        border_west='|'
        border_east='|'
        border_north_west='/'
        border_north_east='\'
        border_south_west='\'
        border_south_east='/'
    }

    #FIXME: It'd be silly to reimplement a method printing a box header, given
    #the already sufficiently complex print_heading() function. We'll need to
    #generalize such function to call a new "driver" function, doing the lion's
    #share of printing work -- say, print_string_centered_with_border().
    #FIXME: Interestingly, given such function, we can instantly a new
    #print_string_centered() to simply call such function with a map whose
    #border characters all simply expand to a single space. Nice.

    # Length of such text, excluding non-printable characters and sequences.
    text_length="$(get_string_length_printable_sans_ansi_colors "${text}")"

    # Maximum length of each text substring to be printed on each output line.
    line_length=$(( terminal_width - prefix_length ))

    #FIXME: Create such function, which should simply call
    #reset_terminal_color() currently (but which subsequently could be made to
    #perform additional functionality).
    # If required, print delimiting prefixing whitespace.
#   start_stdout_printing

    # For each text substring to be printed on each output line, print such
    # substring prefixed by the message prefix and suffixed by at least a
    # newline. See get_string_wrapped_at_line_length() for further details.
    for_string_pcre_matches\
        "${text}" "$(get_pcre_wrapping_at_line_length "${line_length}")"\
        '# Prefix the current line by such prefix.
        output_string_sans_newline "${line_prefix}"

        # Print such line.
        if is -n "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}" si {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}"
        } else {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_UNDELIMITED}']}-"
        }'

    # Sanitize the current terminal in preparation for subsequent output.
    stop_stdout_printing
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Actually, we want to pass a map name, where the map is structured:
#
#     "${map_name}"=(
#         'color_style_category' 'print_message'
#     )
#. This PCRE assumes *multiline matching*
#(i.e., the `.` quantifier matches all characters _except_ newline) and hence
#should only be used under such matching
# Match
    # multiline to prevent "." from matching newlines.
    # Return such string.
#   return_string "${text_wrapped}"

#Wouldn't you like to see a positive LSD story on the news? To base your decision on information rather than scare tactics and superstition? Perhaps? Wouldn't that be interesting? Just for once?
#   "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."

    # PCRE wrapping lines to such length.
#   pcre_wrapping_lines="$(get_pcre_wrapping_at_line_length "${line_length}")"

    #FUXME: Abstract into a string global.
    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    # Dismantled, this is:
    #
    # * "\G", anchoring such match immediately after the end of the prior match.
    # * "\h*+", matching ignorable horizontal whitespace (i.e., non-newline)
    #   without backtracking, for efficiency.
    # * "(?:...)", matching either:
    #   * "\n", a newline, in which case ${match[1]} will be the empty string,
    #     ensuring an equivalent of 'output_string "${match[1]}"' will simply
    #     reprint the matched newline.
    #   * "(.{...})", a line's worth of text to ${match[1]}, optionally:
    #     * "(-)", capturing a hyphen suffix to ${match[2]}.
    # * "(?(2)|(?:...))", matching either:
    #   * If a hyphen suffix previously matched, then nothing else.
    #   * Else, mandatory horizontal whitespace, a newline, or the string end.
    #     In any case, such suffix will typically be converted into a newline.
#   line_pcre='\G\h*+(?:\n|(.{1,'${line_length}'}(-)?)(?(2)|(?:\h+|$))'
    # * "(?:...)", matching such line's delimiter as either:

#Minimizing Line Count versus Right Raggedness 
#a maximal line's worth  substring. To ensure human-readable output, wrap at
#word endings by requiring such substring be suffixed by either whitespace
#or the end of such string.
