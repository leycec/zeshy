#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Revise documentation.
declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle ...
______________<heredoc?>______________

# ....................{ PRINTERS                           }....................
#FIXME: Oh, wait! We can get the 'color_style_category' just by calling
#"$(get_caller)", so don't bother explicitly passing it. (Let's simplify life a
#tad, in other words.)
#FIXME: Revise documentation, naturally.
declare_function_with_stdin <<'/---'
string print_string_boxed_with_color_style_prefix(
    string text, string color_style_category)

Print the passed string wrapped to the current terminal width, prefixing each
resulting line with the passed prefix. Specifically:

. Split such string into substrings satisfying the following constraints:
** Each substring is suffixed by either whitespace or the end of such string.
** Each substring is no longer than the current terminal width subtracted by the
   length of such prefix.
. Print each substring prefixed by such prefix and suffixed by a newline.

For example:

.print_string_boxed_with_color_style_prefix()
==========================================
[source]
------------------------------------------
>>> string on_boxes=\
...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
...    "man hired armed guards to keep anyone from eating his fish. The many"\
...    "people who sit next to the empty river starve to death. But they do"\
...    "not die of starvation. They die of a belief. Everyone believes that"\
...    "the man atop the box owns the fish. The soldiers believe it, and they"\
...    "will kill to protect the illusion. The others believe it enough that"\
...    "they are willing to starve. But the truth is that there is a box,"\
...    "there is an emptied river, there is a man sitting atop the box, there"\
...    "are guns, and there are starving people."
>>> print_string_wrapped_with_line_prefix "${on_boxes}" box
box: The box is full of salmon, and a man sits atop the box. Long ago this man
box: hired armed guards to keep anyone from eating his fish. The many people who
box: sit next to the empty river starve to death. But they do not die of
box: starvation. They die of a belief. Everyone believes that the man atop the
box: box owns the fish. The soldiers believe it, and they will kill to protect
box: the illusion. The others believe it enough that they are willing to starve.
box: But the truth is that there is a box, there is an emptied river, there is a
box: man sitting atop the box, there are guns, and there are starving people.
------------------------------------------
==========================================
/---
function print_string_boxed_with_color_style_prefix() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one color style prefix'
    string text="${1}" color_style_prefix="${2}"
    integer\
        terminal_width\
        text_length\
        line_length\
        line_prefix_length\

    # Width in characters of the current terminal.
    terminal_width="$(get_terminal_width)"

    # If such width is sufficiently small, it's not feasible to print both a box
    # and at least one character in such box. In such cases, print such string
    # as is and immediately return.
    if (( terminal_width <= 5 )) {
        print_string "${text}"
        return_true
    }

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
    if { is_encoding_utf8 } {
        border_north='═'
        border_south='─'
        border_west='│'
        border_east='│'
        border_north_west='╒'
        border_north_east='╕'
        border_south_west='╰'
        border_south_east='╯'
    } else {
        border_north='-'
        border_south='-'
        border_west='|'
        border_east='|'
        border_north_west='/'
        border_north_east='\'
        border_south_west='\'
        border_south_east='/'
    }

    #FIXME: It'd be silly to reimplement a method printing a box header, given
    #the already sufficiently complex print_heading() function. We'll need to
    #generalize such function to call a new "driver" function, doing the lion's
    #share of printing work -- say, print_string_centered_with_border().
    #FIXME: Interestingly, given such function, we can instantly a new
    #print_string_centered() to simply call such function with a map whose
    #border characters all simply expand to a single space. Nice.

    # Length of such text, excluding non-printable characters and sequences.
    text_length="$(get_string_length_printable_sans_ansi_colors "${text}")"

    # Maximum length of each text substring to be printed on each output line.
    line_length=$(( terminal_width - prefix_length ))

    #FIXME: Create such function, which should simply call
    #reset_terminal_color() currently (but which subsequently could be made to
    #perform additional functionality).
    # If required, print delimiting prefixing whitespace.
#   start_stdout_printing

    # For each text substring to be printed on each output line, print such
    # substring prefixed by the message prefix and suffixed by at least a
    # newline. See get_string_wrapped_at_line_length() for further details.
    for_string_pcre_matches\
        "${text}" "$(get_pcre_wrapping_at_line_length "${line_length}")"\
        '# Prefix the current line by such prefix.
        output_string_sans_newline "${line_prefix}"

        # Print such line.
        if is -n "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}" si {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}"
        } else {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_UNDELIMITED}']}-"
        }'

    # Sanitize the current terminal in preparation for subsequent output.
    stop_stdout_printing
}

# ....................{ PRINTERS ~ heading                 }....................
#FIXME: Reimplement to simply call print_string_centered_with_border().
declare_function_with_stdin <<'/---'
string print_heading(string heading1 = "", string heading2, ...)

Print the passed strings (defaulting to the empty string) as a section heading
suffixed by a newline to standard output. See print_string() for further
details.
/---
function print_heading() {
    map map_attributes; map_attributes=(
        #
        # ────────{ hello }─────────
        #
        # ────────╢ hello ╟─────────
        #
        # ────────┨ hello ┠─────────
        #
        # ────────╼ hello ╾─────────
        #
        'border_left_utf8'   '─'
        'border_left_ascii'  '-'
        'border_right_utf8'  '─'
        'border_right_ascii' '-'
        'joiner_left_utf8'   '╼ '
        'joiner_left_ascii'  '{ '
        'joiner_right_utf8'  ' ╾'
        'joiner_right_ascii' ' }'
    )
    print_string_centered_with_map_attributes "${*}" 'map_attributes'

    #-----------------------

    # Heading to be printed, concatenated from passed arguments.
    string heading="${*}"
    integer terminal_width heading_length character_count_left

    # If the current call stack has already called a high-level print function,
    # print delimiting whitespace.
    start_stdout_printing_delimited

    # Lengths of the current terminal and heading. The latter excludes non-
    # printable characters, including ANSI color escapes.
    terminal_width="$(get_terminal_width)"
    heading_length="$(get_string_length_printable_sans_ansi_colors\
        "${heading}")"

    # Number of characters preceding such heading, when centering such heading
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures when the
    # terminal width and heading length are of differing parity that the heading
    # will be offset to the left one character from the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    (( character_count_left = (terminal_width - heading_length) / 2 ))

    #FIXME: It'd be great to eventually support the subdivision of the border
    #into appropriate subsections: e.g.,
    #
    #     ====~~~-{ heading }--~~~===
    #
    #The principal annoyance there, of course, is that for each possible
    #subdivision you add, you have to add the corresponding number of
    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
    #concoct a single governing equation determining how many characters of each
    #subdivision to print, even in edge cases of small terminal lines: e.g.,
    #
    #     ~-{ heading }-~
    #FIXME: Actually, we'd probably just want to subdivide the *COLORS* of a
    #single-character border into a gradient. Don't change the characters;
    #change the colors.

    # If such number is at least 2, such heading is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such heading remain for a border. Since this suffices for simple
    # ANSI art, print such heading preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
    if (( character_count_left >= 2 )) {
        # Number of border characters (e.g., "-") preceding and succeeding such
        # heading, respectively. Such numbers are always nonnegative (>= 0).
        integer border_count_left border_count_right
        (( border_count_left = border_count_right = character_count_left - 2 ))

        # If such heading length and terminal width have different parity (i.e.,
        # one is even and the other odd), 1 additional character of space to the
        # right of such heading remains for a border; allocate such space!
        if { not is_integer_parity_equals\
            ${terminal_width} ${heading_length} } {
            border_count_right+=1
        }

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" heading
        #   titles to adjacent borders).
        character\
            character_border\
            character_joiner_left='{ '\
            character_joiner_right=' }'

        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
        if { is_encoding_utf8 } {
            character_border='─'
        } else {
            character_border='-'
        }

        # Left and right borders consisting of such characters.
        string left_border right_border
        left_border="$( repeat_string "${character_border}" ${border_count_left})"
        right_border="$(repeat_string "${character_border}" ${border_count_right})"

        # Print such heading.
        print_string\
            "${ZESHY_COLOR_STYLE[print_heading.border]-}${left_border}${ZESHY_COLOR_STYLE[print_heading.joiner]-}${character_joiner_left}${ZESHY_COLOR_STYLE[print_heading.heading]-}${heading}${ZESHY_COLOR_STYLE[print_heading.joiner]-}${character_joiner_right}${ZESHY_COLOR_STYLE[print_heading.border]-}${right_border}"
    # If such number is 1, such heading's length is either 2 or 3 characters
    # less than such width. Hence, 1 character to the left of and either 1 or 2
    # characters to the right of such heading remain for a border. This isn't
    # terribly much. In the absence of anything better to do, print such heading
    # offset from the beginning of the terminal line by 1 character.
    } elif (( character_count_left == 1 )) {
        print_string " ${heading}"
    # Else such number is nonpositive (i.e., less than or equal to 0).
    #
    # If such number is negative, such heading exceeds such terminal in length.
    # In the absence of anything better to do, print such heading as is. While
    # this guarantees such heading to wrap around at least once, truncating such
    # heading to the current terminal width often produces worse results.
    #
    # If such number is 0, such heading's length is either the terminal width or
    # one character less than such width. In the former case, no space remains
    # for a border; in the latter case, only one character of space remains,
    # hardly enough for even delimiting whitespace. In the absence of anything
    # better to do, again print such heading as is.
    #
    # For both efficiency and simplicity, unify both such cases here.
    } else {  # guard condition :: elif (( character_count_left <= 0 ))
        print_string "${heading}"
    }
}

# ....................{ GETTERS                            }....................
#FIXME: Document me.
#FIXME: It'd be great to eventually support the subdivision of the border
#into appropriate subsections: e.g.,
#
#     ====~~~-{ text }--~~~===
#
#The principal annoyance there, of course, is that for each possible
#subdivision you add, you have to add the corresponding number of
#conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#concoct a single governing equation determining how many characters of each
#subdivision to print, even in edge cases of small terminal lines: e.g.,
#
#     ~-{ text }-~
#FIXME: Actually, we'd probably just want to subdivide the *COLORS* of the
#single-character border into a gradient. Don't change the characters;
#change the colors. This is both simpler and more aesthetically pleasing,
#particularly under 256-color terminals.

declare_function_with_stdin <<'/---'
string get_string_centered_with_map_attributes(
    string text1, string text2, ..., string map_name)

Substrings constituting:

* Left and right corners (i.e., first and last substrings, respectively),
  defaulting to the empty string.
* Left and right borders (i.e., substrings preceding and following
  adjacent corners), defaulting to a space.
* Left and right joiners (i.e., substrings "joining" borders to adjacent
  text), defaulting to the empty string.
/---
function get_string_centered_with_map_attributes() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected at least one string and one map name'
    string\
        text__pscwm\
        map_name__pscwm="${@[-1]}"\
        color_style_prefx__pscwm
    integer\
        terminal_width__pscwm\
        text_length__pscwm\
        left_length__pscwm\
        right_length__pscwm
    pop_arg

    # String to be printed, concatenated from remaining arguments.
    text__pscwm="${*}"

    # Width in characters of the current terminal.
    terminal_width__pscwm="$(get_terminal_width)"

    # Length of such text, excluding non-printable characters and sequences.
    text_length__pscwm="$(get_string_length_printable_sans_ansi_colors\
        "${text__pscwm}")"

    # Number of characters preceding such text, when centering such text
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures that, when
    # the terminal width and text length are of differing parity, the text will
    # be offset to the left by one character of the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    (( left_length__pscwm =\
        (terminal_width__pscwm - text_length__pscwm) / 2 ))

    # If such number is less than 1, the current terminal is insufficiently
    # wide to border such text. Print such text as is and immediately return.
    if (( left_length__pscwm <= 1 )) {
        # If such number is 1, such text's length is either 2 or 3 characters
        # less than such width. Hence, 1 character to the left of and either 1 or 2
        # characters to the right of such text remain for a border. This isn't
        # terribly much. In the absence of anything better to do, print such text
        # offset from the beginning of the terminal line by 1 character.
        if (( left_length__pscwm == 1 )) {
            output_string_sans_newline ' '
        # Else such number is nonpositive (i.e., less than or equal to 0).
        #
        # If such number is negative, such text exceeds such terminal in length.
        # In the absence of anything better to do, print such text as is. While
        # this guarantees such text to wrap around at least once, truncating such
        # text to the current terminal width often produces worse results.
        #
        # If such number is 0, such text's length is either the terminal width or
        # one character less than such width. In the former case, no space remains
        # for a border; in the latter case, only one character of space remains,
        # hardly enough for even delimiting whitespace. In the absence of anything
        # better to do, again print such text as is.
        #
        # For both efficiency and simplicity, unify both such cases here.
        }   # } elif (( left_length__pscwm <= 0 )) { }

        output_string "${text__pscwm}"
        return_true
    }

    # Localize all keys of such map into string locals suffixed by "__lm".
#   die_unless_map_keys "${map_name__pscwm}"\
#       'color_style_prefix'
    localize_map "${map_name__pscwm}"

    # Prefix for all color style names expanded below, defaulting to the name
    # of the caller suffixed by "." (e.g., "print_heading."). Should no such
    # styles exist, such styles will simply be ignored. Since get_caller() must
    # be called in the current function, such initialization must be performed
    # manually rather than by set_string_if_unset_to_evaluation().
    is_variable color_style_prefix__lm or {
        string color_style_prefix__lm; color_style_prefix__lm="$(get_caller)."
    }

    # Substrings to be printed below.
    string\
        corner_left__pscwm\
        corner_right__pscwm\
        border_left__pscwm\
        border_right__pscwm\
        joiner_left__pscwm\
        joiner_right__pscwm\
        borderline_left__pscwm\
        borderline_right__pscwm\
        space_left__pscwm\
        space_right__pscwm

    # Lengths of such substrings.
    integer\
        corner_left_length__pscwm\
        corner_right_length__pscwm\
        border_left_length__pscwm\
        border_right_length__pscwm\
        joiner_left_length__pscwm\
        joiner_right_length__pscwm\
        borderline_left_count__pscwm\
        borderline_right_count__pscwm\
        space_left_length__pscwm\
        space_right_length__pscwm

    # If the current locale encodes to UTF-8, prefer UTF-8 substrings.
    # Default unset border substrings to a single space and all other
    # substrings to the empty string.
    if { is_encoding_utf8 } {
         corner_left__pscwm="${corner_left_utf8__lm-}"
        corner_right__pscwm="${corner_right_utf8__lm-}"
         border_left__pscwm="${border_left_utf8__lm- }"
        border_right__pscwm="${border_right_utf8__lm- }"
         joiner_left__pscwm="${joiner_left_utf8__lm-}"
        joiner_right__pscwm="${joiner_right_utf8__lm-}"
    # Else, fallback to ASCII substrings.
    } else {
         corner_left__pscwm="${corner_left_ascii__lm-}"
        corner_right__pscwm="${corner_right_ascii__lm-}"
         border_left__pscwm="${border_left_ascii__lm- }"
        border_right__pscwm="${border_right_ascii__lm- }"
         joiner_left__pscwm="${joiner_left_ascii__lm-}"
        joiner_right__pscwm="${joiner_right_ascii__lm-}"
    }

    # Multibyte lengths of all such substrings. For efficiency, inline
    # such implementation. See get_string_length_printable() for further
    # details.
     corner_left_length__pscwm="${(m)#corner_left__pscwm}"
    corner_right_length__pscwm="${(m)#corner_right__pscwm}"
     border_left_length__pscwm="${(m)#border_left__pscwm}"
    border_right_length__pscwm="${(m)#border_right__pscwm}"
     joiner_left_length__pscwm="${(m)#joiner_left__pscwm}"
    joiner_right_length__pscwm="${(m)#joiner_right__pscwm}"

    # Number of times to repeat the left and right border substrings to
    # produce a borderline filling as much of the space between the
    # corresponding corner and joiner substrings as possible. If such
    # substring is a single character, this is always possible; else, this
    # is only possible if the length of such substring evenly divides the
    # length of such space.
    (( borderline_left_count__pscwm =\
        (left_length__pscwm -\
        corner_left_length__pscwm -\
        joiner_left_length__pscwm) /\
        border_left_length__pscwm ))
    (( borderline_right_count__pscwm =\
        (right_length__pscwm -\
        corner_right_length__pscwm -\
        joiner_right_length__pscwm) /\
        border_right_length__pscwm ))

    # If either such number is negative, the current terminal is sufficiently
    # wide to print such text but *NOT* such corners, borders, and joiners. Any
    # number of possible responses to such problem exist. For convenience, we
    # currently adopt the simplest: reduce all corners and joiners on each
    # problem side to the empty string and recalculate the corresponding number,
    # which should now be nonnegative.
    if (( borderline_left_count__pscwm < 0 )) {
        (( corner_left_length__pscwm = joiner_left_length__pscwm = 0 ))
        (( borderline_left_count__pscwm =\
            left_length__pscwm / border_left_length__pscwm ))
        die_unless_integer_nonnegative "${borderline_left_count__pscwm}"
    }
    if (( borderline_right_count__pscwm < 0 )) {
        (( corner_right_length__pscwm = joiner_right_length__pscwm = 0 ))
        (( borderline_right_count__pscwm =\
            right_length__pscwm / border_right_length__pscwm ))
        die_unless_integer_nonnegative "${borderline_right_count__pscwm}"
    }

    # If such text length and terminal width have different parity (i.e.,
    # one is even and the other odd), such text cannot be evenly centered in
    # the current terminal and hence must be offset either one character to the
    # left or right of "true" center. For subjectively (and entirely marginally)
    # better aesthetics, offset such text to the left.
    #
    # If additionally the right border substring is a single character, such
    # offsetting is best achieved by extending such border to the right by a
    # single character; else, such offsetting will be achieved below by
    # appending a space after such text.
    if (( border_right_length__pscwm == 1 )) and
        { not is_integer_parity_equals\
            ${terminal_width__pscwm} ${text_length__pscwm} } {
        (( borderline_right_count__pscwm++ ))
    }

    # Number of space characters to precede and follow such text. Such
    # characters are required *ONLY* if the corresponding border substring
    # is longer than a single character and cannot perfectly fill the space
    # allotted to such border, as discussed above.
    (( space_left_length__pscwm = left_length__pscwm -\
        (borderline_left_length__pscwm  * borderline_left_count__pscwm) ))
    (( space_right_length__pscwm = right_length__pscwm -\
        (borderline_right_length__pscwm * borderline_right_count__pscwm) ))

    # Left and right border lines.
    borderline_left__pscwm="$( repeat_string "${border_left__pscwm}"  ${borderline_left_count__pscwm})"
    borderline_right__pscwm="$(repeat_string "${border_right__pscwm}" ${borderline_right_count__pscwm})"

    # Left and right space fillers.
    space_left__pscwm="$( repeat_string ' ' ${space_left_length__pscwm})"
    space_right__pscwm="$(repeat_string ' ' ${space_right_length__pscwm})"

    # Print such text.
    output_string\
        "${ZESHY_COLOR_STYLE[${color_style_prefix__lm}border]-}${border_line_left__pscwm}${ZESHY_COLOR_STYLE[${color_style_prefix__lm}joiner]-}${character_joiner_left__pscwm}${ZESHY_COLOR_STYLE[${color_style_prefix__lm}text]-}${space_left__pscwm}${text__pscwm}${space_right__pscwm}${ZESHY_COLOR_STYLE[${color_style_prefix__lm}joiner]-}${character_joiner_right__pscwm}${ZESHY_COLOR_STYLE[${color_style_prefix__lm}border]-}${border_line_right__pscwm}"
}

#FIXME: In lieu of unit tests, this will do.
#function sayh() {
##   print_call_stack
#    print_string 'upended'  # should be two newlines after this!
#    print_heading 'dancing to'
#    print 'life'
#    brayman
#    print_heading 'road to'
#    print 'ubar'
#}
#function brayman() {
#    print_heading 'beyond'
#    print 'genesis'
#    print_heading 'ein'
#    print 'lichtschein'
#}

# --------------------( WASTELANDS                         )--------------------
    # suggesting either the left or right extend such border by another character. While the left border
    # could instead be extended in this way, extending the right border
    # produces a subjectively (and entirely marginally) better aesthetic.
    # If such number is at least 2, such text is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such text remain for a border. Since this suffices for simple
    # border art, print such text preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
#   if (( left_count__pscwm >= 2 )) {

#   string color_style_prefix__lm="${color_style_prefix__lm}-$(get_caller).}"
# these numbers are typically 0.
        #FUXME: If the length of either border substring is greater than 1, it's
        #feasible such length may not perfectly divide the allotted space, in
        #which case... what? Well, we should probably just fill the remaining
        #space immediately adjacent to such text with horizontal whitespace.

        #FUXME: Just inline such calls below. This is extreme overkill.
        #FUXME: Actually, we need to reuse the border l

#       (( borderline_left_count__pscwm = border_count_right__pscwm =\
#           character_count_left__pscwm - 2 ))
        # Number of border characters preceding and succeeding such text,
        # respectively. Such numbers are always nonnegative (i.e., >= 0).

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" text
        #   titles to adjacent borders).
#       string\
#           character_border__pscwm\
#           character_joiner_left__pscwm='{ '\
#           character_joiner_right__pscwm=' }'

        # Default unpassed substrings to the empty string space.
#declare_function_with_stdin <<'/---'
#string print_heading(string heading1 = "", string heading2, ...)
#
#Print the passed strings (defaulting to the empty string) as a section heading
#suffixed by a newline to standard output. See print_string() for further
#details.
#/---
#function print_heading() {
#    # Heading to be printed, concatenated from passed arguments.
#    string heading="${*}"
#    integer terminal_width heading_length character_count_left
#
#    # If the current call stack has already called a high-level print function,
#    # print delimiting whitespace.
#    start_stdout_printing_delimited
#
#    # Lengths of the current terminal and heading. The latter excludes non-
#    # printable characters, including ANSI color escapes.
#    terminal_width="$(get_terminal_width)"
#    heading_length="$(get_string_length_printable_sans_ansi_colors\
#        "${heading}")"
#
#    # Number of characters preceding such heading, when centering such heading
#    # in the middle of an output terminal line. By design, assigning a floating
#    # point value to an integer variable implicitly rounds such value down to
#    # the nearest whole integer. In this case, such rounding ensures when the
#    # terminal width and heading length are of differing parity that the heading
#    # will be offset to the left one character from the true "center": e.g.,
#    #
#    #     # Centering a 4-character string on a 9-character wide terminal.
#    #     123456789   # terminal width indices; note "5" to be the center
#    #       test      # string offset to the left 1 character from center
#    (( character_count_left = (terminal_width - heading_length) / 2 ))
#
#    #FUXME: It'd be great to eventually support the subdivision of the border
#    #into appropriate subsections: e.g.,
#    #
#    #     ====~~~-{ heading }--~~~===
#    #
#    #The principal annoyance there, of course, is that for each possible
#    #subdivision you add, you have to add the corresponding number of
#    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#    #concoct a single governing equation determining how many characters of each
#    #subdivision to print, even in edge cases of small terminal lines: e.g.,
#    #
#    #     ~-{ heading }-~
#    #FUXME: Actually, we'd probably just want to subdivide the *COLORS* of a
#    #single-character border into a gradient. Don't change the characters;
#    #change the colors.
#
#    # If such number is at least 2, such heading is at least 4 characters less
#    # than such width. Hence, at least 2 characters to the left of *AND* to the
#    # right of such heading remain for a border. Since this suffices for simple
#    # ANSI art, print such heading preceded by a colorfully aesthetic border.
#    # While it would be nice to split this conditional into a separate function,
#    # dependency on multiple local variables above makes this a bad proposition.
#    if (( character_count_left >= 2 )) {
#        # Number of border characters (e.g., "-") preceding and succeeding such
#        # heading, respectively. Such numbers are always nonnegative (>= 0).
#        integer border_count_left border_count_right
#        (( border_count_left = border_count_right = character_count_left - 2 ))
#
#        # If such heading length and terminal width have different parity (i.e.,
#        # one is even and the other odd), 1 additional character of space to the
#        # right of such heading remains for a border; allocate such space!
#        if { not is_integer_parity_equals\
#            ${terminal_width} ${heading_length} } {
#            border_count_right+=1
#        }
#
#        # Characters constituting:
#        #
#        # * Both left and right borders.
#        # * Both left and right joiners (i.e., character "joining" heading
#        #   titles to adjacent borders).
#        character\
#            character_border\
#            character_joiner_left='{ '\
#            character_joiner_right=' }'
#
#        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#        if { is_encoding_utf8 } {
#            character_border='─'
#        } else {
#            character_border='-'
#        }
#
#        # Left and right borders consisting of such characters.
#        string left_border right_border
#        left_border="$( repeat_string "${character_border}" ${border_count_left})"
#        right_border="$(repeat_string "${character_border}" ${border_count_right})"
#
#        # Print such heading.
#        print_string\
#            "${ZESHY_COLOR_STYLE[print_heading.border]-}${left_border}${ZESHY_COLOR_STYLE[print_heading.joiner]-}${character_joiner_left}${ZESHY_COLOR_STYLE[print_heading.heading]-}${heading}${ZESHY_COLOR_STYLE[print_heading.joiner]-}${character_joiner_right}${ZESHY_COLOR_STYLE[print_heading.border]-}${right_border}"
#    # If such number is 1, such heading's length is either 2 or 3 characters
#    # less than such width. Hence, 1 character to the left of and either 1 or 2
#    # characters to the right of such heading remain for a border. This isn't
#    # terribly much. In the absence of anything better to do, print such heading
#    # offset from the beginning of the terminal line by 1 character.
#    } elif (( character_count_left == 1 )) {
#        print_string " ${heading}"
#    # Else such number is nonpositive (i.e., less than or equal to 0).
#    #
#    # If such number is negative, such heading exceeds such terminal in length.
#    # In the absence of anything better to do, print such heading as is. While
#    # this guarantees such heading to wrap around at least once, truncating such
#    # heading to the current terminal width often produces worse results.
#    #
#    # If such number is 0, such heading's length is either the terminal width or
#    # one character less than such width. In the former case, no space remains
#    # for a border; in the latter case, only one character of space remains,
#    # hardly enough for even delimiting whitespace. In the absence of anything
#    # better to do, again print such heading as is.
#    #
#    # For both efficiency and simplicity, unify both such cases here.
#    } else {  # guard condition :: elif (( character_count_left <= 0 ))
#        print_string "${heading}"
#    }
#}


#FUXME: Actually, we want to pass a map name, where the map is structured:
#
#     "${map_name}"=(
#         'color_style_category' 'print_message'
#     )
#. This PCRE assumes *multiline matching*
#(i.e., the `.` quantifier matches all characters _except_ newline) and hence
#should only be used under such matching
# Match
    # multiline to prevent "." from matching newlines.
    # Return such string.
#   return_string "${text_wrapped}"

#Wouldn't you like to see a positive LSD story on the news? To base your decision on information rather than scare tactics and superstition? Perhaps? Wouldn't that be interesting? Just for once?
#   "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."

    # PCRE wrapping lines to such length.
#   pcre_wrapping_lines="$(get_pcre_wrapping_at_line_length "${line_length}")"

    #FUXME: Abstract into a string global.
    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    # Dismantled, this is:
    #
    # * "\G", anchoring such match immediately after the end of the prior match.
    # * "\h*+", matching ignorable horizontal whitespace (i.e., non-newline)
    #   without backtracking, for efficiency.
    # * "(?:...)", matching either:
    #   * "\n", a newline, in which case ${match[1]} will be the empty string,
    #     ensuring an equivalent of 'output_string "${match[1]}"' will simply
    #     reprint the matched newline.
    #   * "(.{...})", a line's worth of text to ${match[1]}, optionally:
    #     * "(-)", capturing a hyphen suffix to ${match[2]}.
    # * "(?(2)|(?:...))", matching either:
    #   * If a hyphen suffix previously matched, then nothing else.
    #   * Else, mandatory horizontal whitespace, a newline, or the string end.
    #     In any case, such suffix will typically be converted into a newline.
#   line_pcre='\G\h*+(?:\n|(.{1,'${line_length}'}(-)?)(?(2)|(?:\h+|$))'
    # * "(?:...)", matching such line's delimiter as either:

#Minimizing Line Count versus Right Raggedness 
#a maximal line's worth  substring. To ensure human-readable output, wrap at
#word endings by requiring such substring be suffixed by either whitespace
#or the end of such string.
