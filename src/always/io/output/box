#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Revise documentation.
declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle ...
______________<heredoc?>______________

#FIXME: It'd be great to eventually support the subdivision of the border
#into appropriate subsections: e.g.,
#
#     ====~~~-{ text }--~~~===
#
#The principal annoyance there, of course, is that for each possible
#subdivision you add, you have to add the corresponding number of
#conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#concoct a single governing equation determining how many characters of each
#subdivision to print, even in edge cases of small terminal lines: e.g.,
#
#     ~-{ text }-~
#FIXME: Actually, we'd probably just want to subdivide the *COLORS* of the
#single-character border into a gradient. Don't change the characters;
#change the colors. This is both simpler and more aesthetically pleasing,
#particularly under 256-color terminals.

# ....................{ PRINTERS                           }....................
#FIXME: Oh, wait! We can get the 'color_style_category' just by calling
#"$(get_caller)", so don't bother explicitly passing it. (Let's simplify life a
#tad, in other words.)
#FIXME: Revise documentation, naturally.
declare_function_with_stdin <<'/---'
string print_string_boxed_with_color_style_prefix(
    string text, string color_style_category)

Print the passed string wrapped to the current terminal width, prefixing each
resulting line with the passed prefix. Specifically:

. Split such string into substrings satisfying the following constraints:
** Each substring is suffixed by either whitespace or the end of such string.
** Each substring is no longer than the current terminal width subtracted by the
   length of such prefix.
. Print each substring prefixed by such prefix and suffixed by a newline.

For example:

.print_string_boxed_with_color_style_prefix()
==========================================
[source]
------------------------------------------
>>> string on_boxes=\
...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
...    "man hired armed guards to keep anyone from eating his fish. The many"\
...    "people who sit next to the empty river starve to death. But they do"\
...    "not die of starvation. They die of a belief. Everyone believes that"\
...    "the man atop the box owns the fish. The soldiers believe it, and they"\
...    "will kill to protect the illusion. The others believe it enough that"\
...    "they are willing to starve. But the truth is that there is a box,"\
...    "there is an emptied river, there is a man sitting atop the box, there"\
...    "are guns, and there are starving people."
>>> print_string_wrapped_with_line_prefix "${on_boxes}" box
box: The box is full of salmon, and a man sits atop the box. Long ago this man
box: hired armed guards to keep anyone from eating his fish. The many people who
box: sit next to the empty river starve to death. But they do not die of
box: starvation. They die of a belief. Everyone believes that the man atop the
box: box owns the fish. The soldiers believe it, and they will kill to protect
box: the illusion. The others believe it enough that they are willing to starve.
box: But the truth is that there is a box, there is an emptied river, there is a
box: man sitting atop the box, there are guns, and there are starving people.
------------------------------------------
==========================================
/---
function print_string_boxed_with_color_style_prefix() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one color style prefix'
    string text="${1}" color_style_prefix="${2}"
    integer\
        terminal_width\
        text_length\
        line_length\
        line_prefix_length\

    # Width in characters of the current terminal.
    terminal_width="$(get_terminal_width)"

    # If such width is sufficiently small, it's not feasible to print both a box
    # and at least one character in such box. In such cases, print such string
    # as is and immediately return.
    if (( terminal_width <= 5 )) {
        print_string "${text}"
        return_true
    }

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
    if { is_locale_encoding_utf8 } {
        border_north='═'
        border_south='─'
        border_west='│'
        border_east='│'
        border_north_west='╒'
        border_north_east='╕'
        border_south_west='╰'
        border_south_east='╯'
    } else {
        border_north='-'
        border_south='-'
        border_west='|'
        border_east='|'
        border_north_west='/'
        border_north_east='\'
        border_south_west='\'
        border_south_east='/'
    }

    #FIXME: It'd be silly to reimplement a method printing a box header, given
    #the already sufficiently complex print_heading() function. We'll need to
    #generalize such function to call a new "driver" function, doing the lion's
    #share of printing work -- say, print_string_centered_with_border().
    #FIXME: Interestingly, given such function, we can instantly a new
    #print_string_centered() to simply call such function with a map whose
    #border characters all simply expand to a single space. Nice.

    # Length of such text, excluding non-printable characters and sequences.
    text_length="$(get_string_length_printable_sans_ansi_colors "${text}")"

    # Maximum length of each text substring to be printed on each output line.
    line_length=$(( terminal_width - prefix_length ))

    #FIXME: Create such function, which should simply call
    #reset_terminal_color() currently (but which subsequently could be made to
    #perform additional functionality).
    # If required, print delimiting prefixing whitespace.
#   start_output

    # For each text substring to be printed on each output line, print such
    # substring prefixed by the message prefix and suffixed by at least a
    # newline. See get_string_wrapped_at_line_length() for further details.
    for_string_pcre_matches\
        "${text}" "$(get_pcre_wrapping_at_line_length "${line_length}")"\
        '# Prefix the current line by such prefix.
        output_string_sans_newline "${line_prefix}"

        # Print such line.
        if is -n "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}" si {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}"
        } else {
            output_string "${match['${ZESHY_PCRE_WRAPPING_INDEX_UNDELIMITED}']}-"
        }'

    # Sanitize the current terminal in preparation for subsequent output.
    stop_output
}

# ....................{ PRINTERS ~ heading                 }....................
declare_function_with_stdin <<'/---'
string print_heading(string heading1 = "", string heading2, ...)

Print the passed strings (defaulting to the empty string) as a centered heading
suffixed by a newline to standard output. See print_string() for further
details.
/---
function print_heading() {
    center_string_with_style_prefix "${*}"
}

# ....................{ CENTERERS                          }....................
declare_function_with_stdin <<'/---'
string center_string(string text1, string text2, ...)

Center the passed string to the width of the current terminal: e.g.,

.center_string()
==========================================
[source]
------------------------------------------
>>> string on_preventative_care=\
...    "\"So you think our medicine's pretty primitive?\"
...     \"That's the wrong word. It isn't primitive. It's fifty percent terrific
...     and fifty percent non-existent. Marvellous antibiotics — but absolutely
...     no methods for increasing resistance, so that antibiotics won't be
...     necessary. Fantastic operations — but when it comes to teaching people
...     the way of going through life without having to be chopped up,
...     absolutely nothing. And it's the same all along the line. Alpha Plus for
...     patching you up when you've started to fall apart; but Delta Minus for
...     keeping you healthy. Apart from sewerage systems and synthetic vitamins,
...     you don't seem to do anything at all about prevention. And yet you've
...     got a proverb: prevention is better than cure.\""
>>> center_string "$(get_string_word "${on_preventative_care}" -1)"
                                    cure."
------------------------------------------
==========================================
/---
function center_string() {
    center_string_with_style_prefix "${*}"
}

#FIXME: Complete such documentation.
declare_function_with_stdin <<'/---'
string center_string_with_style_prefix(
    string text, string style_prefix = "$(get_caller).")

Center the passed string with the styles prefixed by the passed style prefix
(defaulting to the dot-suffixed name of the caller). As configured by the
current user and theme, such styles identify the colors and string literals with
which to aesthetically embellish the passed string. If such styles do not exist,
this function defaults to simply centering such string without embellishment.

== Styles ==

This function applies all of the following styles that are existing keys of maps
${ZESHY_STYLE_TO_COLOR} (identifying the colors to be output).
${ZESHY_STYLE_TO_TEXT} (identifying the string literals to be output):

* Left and right corners (i.e., first and last substrings, respectively),
  defaulting to the empty string.
* Left and right borders (i.e., substrings preceding and following
  adjacent corners), defaulting to a space.
* Left and right joiners (i.e., substrings "joining" borders to adjacent
  text), defaulting to the empty string.
/---
function center_string_with_style_prefix() {
    # Validate passed arguments.
    die_unless_args_1_to_2 'expected one string and optional style prefix'
    string text="${1}" style_prefix
    style_prefix="$(get_caller)."
    integer\
        terminal_width\
        text_length\
        left_length\
        right_length

    # Width in characters of the current terminal.
    terminal_width="$(get_terminal_width)"

    # Length of such text, excluding non-printable characters and sequences.
    text_length="$(get_string_length_printable_sans_ansi_colors "${text}")"

    # Number of characters preceding such text, when centering such text
    # in the middle of an output terminal line. By design, assigning a floating
    # point value to an integer variable implicitly rounds such value down to
    # the nearest whole integer. In this case, such rounding ensures that, when
    # the terminal width and text length are of differing parity, the text will
    # be offset to the left by one character of the true "center": e.g.,
    #
    #     # Centering a 4-character string on a 9-character wide terminal.
    #     123456789   # terminal width indices; note "5" to be the center
    #       test      # string offset to the left 1 character from center
    left_length=$((\
        (terminal_width - text_length) / 2 ))

    # Number of characters following such text, defined to be the number of
    # characters on a terminal line neither preceding or containing such text.
    right_length=$((\
        terminal_width - text_length - left_length ))

    # If such number is less than 1, the current terminal is insufficiently
    # wide to border such text. Print such text as is and immediately return.
    if (( left_length <= 1 )) {
        # If such number is 1, such text's length is either 2 or 3 characters
        # less than such width. Hence, 1 character to the left of and either 1 or 2
        # characters to the right of such text remain for a border. This isn't
        # terribly much. In the absence of anything better to do, print such text
        # offset from the beginning of the terminal line by 1 character.
        if (( left_length == 1 )) {
            output_string_sans_newline ' '
        # Else such number is nonpositive (i.e., less than or equal to 0).
        #
        # If such number is negative, such text exceeds such terminal in length.
        # In the absence of anything better to do, print such text as is. While
        # this guarantees such text to wrap around at least once, truncating such
        # text to the current terminal width often produces worse results.
        #
        # If such number is 0, such text's length is either the terminal width or
        # one character less than such width. In the former case, no space remains
        # for a border; in the latter case, only one character of space remains,
        # hardly enough for even delimiting whitespace. In the absence of anything
        # better to do, again print such text as is.
        #
        # For both efficiency and simplicity, unify both such cases here.
        }   # } elif (( left_length <= 0 )) { }

        output_string "${text}"
        return_true
    }

    # Localize all keys of such map into string locals suffixed by "__lm".
    localize_map "${map_name}"

    # Prefix for all color style names expanded below, defaulting to the name
    # of the caller suffixed by "." (e.g., "print_heading."). Should no such
    # styles exist, such styles will simply be ignored. Since get_caller() must
    # be called in the current function, such initialization must be performed
    # manually rather than by set_string_if_unset_to_evaluation().
    is_variable color_style_prefix__lm or {
        string color_style_prefix__lm; color_style_prefix__lm="$(get_caller)."
    }

    # Substrings to be printed below.
    string\
        corner_left\
        corner_right\
        border_left\
        border_right\
        joiner_left\
        joiner_right\
        borderline_left\
        borderline_right\
        space_left\
        space_right

    # Lengths of such substrings.
    integer\
        corner_left_length\
        corner_right_length\
        border_left_length\
        border_right_length\
        joiner_left_length\
        joiner_right_length\
        borderline_left_count\
        borderline_right_count\
        space_left_length\
        space_right_length

    # If the current locale encodes to UTF-8, prefer UTF-8 substrings.
    # Default unset border substrings to a single space and all other
    # substrings to the empty string.
    if { is_locale_encoding_utf8 } {
         corner_left="${corner_left_utf8__lm-}"
        corner_right="${corner_right_utf8__lm-}"
         border_left="${border_left_utf8__lm- }"
        border_right="${border_right_utf8__lm- }"
         joiner_left="${joiner_left_utf8__lm-}"
        joiner_right="${joiner_right_utf8__lm-}"
    # Else, fallback to ASCII substrings.
    } else {
         corner_left="${corner_left_ascii__lm-}"
        corner_right="${corner_right_ascii__lm-}"
         border_left="${border_left_ascii__lm- }"
        border_right="${border_right_ascii__lm- }"
         joiner_left="${joiner_left_ascii__lm-}"
        joiner_right="${joiner_right_ascii__lm-}"
    }

    # Multibyte lengths of all such substrings. For efficiency, inline
    # such implementation. See get_string_length_printable() for further
    # details.
     corner_left_length="${(m)#corner_left}"
    corner_right_length="${(m)#corner_right}"
     border_left_length="${(m)#border_left}"
    border_right_length="${(m)#border_right}"
     joiner_left_length="${(m)#joiner_left}"
    joiner_right_length="${(m)#joiner_right}"
#   print "right_length: ${right_length}\ncorner_right_length: ${corner_right_length}\njoiner_right_length: ${joiner_right_length}\nborder_right_length: ${border_right_length}"

    # If either border substrings are empty, throw an exception. Note that
    # corner and joiner substrings are optional and hence do not require such
    # exception handling.
    die_unless_integer_positive "${border_left_length}"\
        'expected nonempty left border string'
    die_unless_integer_positive "${border_right_length}"\
        'expected nonempty right border string'

    # Number of times to repeat the left and right border substrings to
    # produce a borderline filling as much of the space between the
    # corresponding corner and joiner substrings as possible. If such
    # substring is a single character, this is always possible; else, this
    # is only possible if the length of such substring evenly divides the
    # length of such space.
    borderline_left_count=$((\
        (left_length -\
        corner_left_length -\
        joiner_left_length) /\
        border_left_length ))
    borderline_right_count=$((\
        (right_length -\
        corner_right_length -\
        joiner_right_length) /\
        border_right_length ))
#   print ok
#   print ko

    # If either such number is negative, the current terminal is sufficiently
    # wide to print such text but *NOT* such corners, borders, and joiners. Any
    # number of possible responses to such problem exist. For convenience, we
    # currently adopt the simplest: reduce all corners and joiners on each
    # problem side to the empty string and recalculate the corresponding number,
    # which should now be nonnegative.
    if (( borderline_left_count < 0 )) {
        corner_left_length=0
        joiner_left_length=0
        borderline_left_count=$((\
            left_length / border_left_length ))
    }
    if (( borderline_right_count < 0 )) {
        corner_right_length=0
        joiner_right_length=0
        borderline_right_count=$((\
            right_length / border_right_length ))
    }

    # Number of space characters to precede and follow such text. Such
    # characters are required *ONLY* if the corresponding border substring
    # is longer than a single character and cannot perfectly fill the space
    # allotted to such border, as discussed above.
    space_left_length=$(( left_length -\
        (borderline_left_count *  border_left_length ) ))
    space_right_length=$(( right_length -\
        (borderline_right_count * border_right_length ) ))
    print "left_length: ${left_length}\ncorner_left_length: ${corner_left_length}\njoiner_left_length: ${joiner_left_length}\nborder_left_length: ${border_left_length}\nborderline_left_count: ${borderline_left_count}\nspace_left_length: ${space_left_length}\n\nright_length: ${right_length}\ncorner_right_length: ${corner_right_length}\njoiner_right_length: ${joiner_right_length}\nborder_right_length: ${border_right_length}\nborderline_right_count: ${borderline_right_count}\nspace_right_length: ${space_right_length}"

    # If either such numbers are negative, throw an exception. Note that
    # corner and joiner substrings are optional and hence do not require such
    # exception handling.
    die_unless_integer_nonnegative "${space_left_length}"\
        'left whitespace string length negative'
    die_unless_integer_nonnegative "${space_right_length}"\
        'right whitespace string length negative'

    # Left and right border lines.
    borderline_left="$( repeat_string "${border_left}"  ${borderline_left_count})"
    borderline_right="$(repeat_string "${border_right}" ${borderline_right_count})"

    # Left and right space fillers.
    space_left="$( repeat_string ' ' ${space_left_length})"
    space_right="$(repeat_string ' ' ${space_right_length})"

    # Print such text.
    output_string\
        "${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}corner]-}${corner_left}${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}border]-}${borderline_left}${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}joiner]-}${joiner_left}${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}text]-}${space_left}${text}${space_right}${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}joiner]-}${joiner_right}${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}border]-}${borderline_right}${ZESHY_STYLE_TO_COLOR[${color_style_prefix__lm}corner]-}${corner_right}"
}

#FIXME: In lieu of unit tests, this will do.
#function sayh() {
##   print_call_stack
#    print_string 'upended'  # should be two newlines after this!
#    print_heading 'dancing to'
#    print 'life'
#    brayman
#    print_heading 'road to'
#    print 'ubar'
#}
function bray() {
    print_heading 'beyond'
    print 'genesis'
    print_heading 'ein'
    print 'lichtschein'
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Once we get this working, there's a far better alternative generalizing
#substring choices in the same manner that ${ZESHY_STYLE_TO_COLOR} generalizes
#color choices. In order:
#
#* Create a new *EMPTY* parcel tree "src/if_theme/vanilla", as before.
#* Shift "src/if_config/color" to "src/if_config/theme/color".
#* Create a new parcel            "src/if_config/theme/text".
#* Add two new map globals to the latter such parcel:
#  * ${ZESHY_STYLE_TO_TEXT_ASCII}.
#  * ${ZESHY_STYLE_TO_TEXT_UTF8}.
#* Rename map global ${ZESHY_STYLE_TO_COLOR} to ${ZESHY_STYLE_TO_COLOR_NAME}, in
#  keeping with such nomenclature.
#* Replace the last parameter to this function with
#  'string style_prefix = "$(get_caller)."'. This thus reduces most functions
#  calling this function to simply the function call only the passed text: e.g.,
#
#    # This works even *WITHOUT* defining any color styles for
#    # "print_string_centered", thanks to helpful defaults.
#    function print_string_centered() {
#        get_string_centered_with_map_attributes "${*}"
#    }
#
#    # This works assuming we convert passed arguments to map attributes: e.g.,
#    # ZESHY_STYLE_TO_TEXT_ASCII=(
#    #     'print_heading.border_left' '-'
#    # )
#    function print_heading() {
#        get_string_centered_with_map_attributes "${*}"
#    }
#
#The answer to the question "What are zeshy styles?" is thus "Unique strings
#index maps in parcels under src/if_config/theme/".
#FUXME: Reimplement to simply call print_string_centered_with_border().

#   map map_attributes; map_attributes=(
        # Popular alternative schemes:
        #
        # ────────{ hello }─────────
        #
        # ────────╢ hello ╟─────────
        #
        # ────────┨ hello ┠─────────
        #
        # ┠───────╼ hello ╾────────┨
        #
        # ├───────╼ hello ╾────────┤
        #
        # ┎───────╼ hello ╾────────┒
        #
        # ────────╼ hello ╾─────────
        #
#       'border_left_utf8'   '─'
#       'border_left_ascii'  '-'
#       'border_right_utf8'  '─'
#       'border_right_ascii' '-'
#       'joiner_left_utf8'   '╼ '
#       'joiner_left_ascii'  '{ '
#       'joiner_right_utf8'  ' ╾'
#       'joiner_right_ascii' ' }'
#   )
#   get_string_centered_with_map_attributes "${*}" 'map_attributes'

    # String to be printed, concatenated from remaining arguments.
#   text="${*}"

    # If such text length and terminal width have different parity (i.e.,
    # one is even and the other odd), such text cannot be evenly centered in
    # the current terminal and hence must be offset either one character to the
    # left or right of "true" center. For subjectively (and entirely marginally)
    # better aesthetics, offset such text to the left.
    #
    # If additionally the right border substring is a single character, such
    # offsetting is best achieved by extending such border to the right by a
    # single character; else, such offsetting will be achieved below by
    # appending a space after such text.
#   if (( border_right_length__pscwm == 1 )) and
#       { not is_integer_parity_equals\
#           ${terminal_width__pscwm} ${text_length__pscwm} } {
#       borderline_right_count__pscwm+=1
#   }

#   die_unless_map_keys "${map_name__pscwm}"\
#       'color_style_prefix'
#       die_unless_integer_nonnegative "${borderline_left_count__pscwm}"\
#           ''
#       die_unless_integer_nonnegative "${borderline_right_count__pscwm}"\

    # suggesting either the left or right extend such border by another character. While the left border
    # could instead be extended in this way, extending the right border
    # produces a subjectively (and entirely marginally) better aesthetic.
    # If such number is at least 2, such text is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such text remain for a border. Since this suffices for simple
    # border art, print such text preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
#   if (( left_count__pscwm >= 2 )) {

#   string color_style_prefix__lm="${color_style_prefix__lm}-$(get_caller).}"
# these numbers are typically 0.
        #FUXME: If the length of either border substring is greater than 1, it's
        #feasible such length may not perfectly divide the allotted space, in
        #which case... what? Well, we should probably just fill the remaining
        #space immediately adjacent to such text with horizontal whitespace.

        #FUXME: Just inline such calls below. This is extreme overkill.
        #FUXME: Actually, we need to reuse the border l

#       (( borderline_left_count__pscwm = border_count_right__pscwm =\
#           character_count_left__pscwm - 2 ))
        # Number of border characters preceding and succeeding such text,
        # respectively. Such numbers are always nonnegative (i.e., >= 0).

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" text
        #   titles to adjacent borders).
#       string\
#           character_border__pscwm\
#           character_joiner_left__pscwm='{ '\
#           character_joiner_right__pscwm=' }'

        # Default unpassed substrings to the empty string space.
#declare_function_with_stdin <<'/---'
#string print_heading(string heading1 = "", string heading2, ...)
#
#Print the passed strings (defaulting to the empty string) as a section heading
#suffixed by a newline to standard output. See print_string() for further
#details.
#/---
#function print_heading() {
#    # Heading to be printed, concatenated from passed arguments.
#    string heading="${*}"
#    integer terminal_width heading_length character_count_left
#
#    # If the current call stack has already called a high-level print function,
#    # print delimiting whitespace.
#    start_output_delimited
#
#    # Lengths of the current terminal and heading. The latter excludes non-
#    # printable characters, including ANSI color escapes.
#    terminal_width="$(get_terminal_width)"
#    heading_length="$(get_string_length_printable_sans_ansi_colors\
#        "${heading}")"
#
#    # Number of characters preceding such heading, when centering such heading
#    # in the middle of an output terminal line. By design, assigning a floating
#    # point value to an integer variable implicitly rounds such value down to
#    # the nearest whole integer. In this case, such rounding ensures when the
#    # terminal width and heading length are of differing parity that the heading
#    # will be offset to the left one character from the true "center": e.g.,
#    #
#    #     # Centering a 4-character string on a 9-character wide terminal.
#    #     123456789   # terminal width indices; note "5" to be the center
#    #       test      # string offset to the left 1 character from center
#    (( character_count_left = (terminal_width - heading_length) / 2 ))
#
#    #FUXME: It'd be great to eventually support the subdivision of the border
#    #into appropriate subsections: e.g.,
#    #
#    #     ====~~~-{ heading }--~~~===
#    #
#    #The principal annoyance there, of course, is that for each possible
#    #subdivision you add, you have to add the corresponding number of
#    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#    #concoct a single governing equation determining how many characters of each
#    #subdivision to print, even in edge cases of small terminal lines: e.g.,
#    #
#    #     ~-{ heading }-~
#    #FUXME: Actually, we'd probably just want to subdivide the *COLORS* of a
#    #single-character border into a gradient. Don't change the characters;
#    #change the colors.
#
#    # If such number is at least 2, such heading is at least 4 characters less
#    # than such width. Hence, at least 2 characters to the left of *AND* to the
#    # right of such heading remain for a border. Since this suffices for simple
#    # ANSI art, print such heading preceded by a colorfully aesthetic border.
#    # While it would be nice to split this conditional into a separate function,
#    # dependency on multiple local variables above makes this a bad proposition.
#    if (( character_count_left >= 2 )) {
#        # Number of border characters (e.g., "-") preceding and succeeding such
#        # heading, respectively. Such numbers are always nonnegative (>= 0).
#        integer border_count_left border_count_right
#        (( border_count_left = border_count_right = character_count_left - 2 ))
#
#        # If such heading length and terminal width have different parity (i.e.,
#        # one is even and the other odd), 1 additional character of space to the
#        # right of such heading remains for a border; allocate such space!
#        if { not is_integer_parity_equals\
#            ${terminal_width} ${heading_length} } {
#            border_count_right+=1
#        }
#
#        # Characters constituting:
#        #
#        # * Both left and right borders.
#        # * Both left and right joiners (i.e., character "joining" heading
#        #   titles to adjacent borders).
#        character\
#            character_border\
#            character_joiner_left='{ '\
#            character_joiner_right=' }'
#
#        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#        if { is_locale_encoding_utf8 } {
#            character_border='─'
#        } else {
#            character_border='-'
#        }
#
#        # Left and right borders consisting of such characters.
#        string left_border right_border
#        left_border="$( repeat_string "${character_border}" ${border_count_left})"
#        right_border="$(repeat_string "${character_border}" ${border_count_right})"
#
#        # Print such heading.
#        print_string\
#            "${ZESHY_STYLE_TO_COLOR[print_heading.border]-}${left_border}${ZESHY_STYLE_TO_COLOR[print_heading.joiner]-}${character_joiner_left}${ZESHY_STYLE_TO_COLOR[print_heading.heading]-}${heading}${ZESHY_STYLE_TO_COLOR[print_heading.joiner]-}${character_joiner_right}${ZESHY_STYLE_TO_COLOR[print_heading.border]-}${right_border}"
#    # If such number is 1, such heading's length is either 2 or 3 characters
#    # less than such width. Hence, 1 character to the left of and either 1 or 2
#    # characters to the right of such heading remain for a border. This isn't
#    # terribly much. In the absence of anything better to do, print such heading
#    # offset from the beginning of the terminal line by 1 character.
#    } elif (( character_count_left == 1 )) {
#        print_string " ${heading}"
#    # Else such number is nonpositive (i.e., less than or equal to 0).
#    #
#    # If such number is negative, such heading exceeds such terminal in length.
#    # In the absence of anything better to do, print such heading as is. While
#    # this guarantees such heading to wrap around at least once, truncating such
#    # heading to the current terminal width often produces worse results.
#    #
#    # If such number is 0, such heading's length is either the terminal width or
#    # one character less than such width. In the former case, no space remains
#    # for a border; in the latter case, only one character of space remains,
#    # hardly enough for even delimiting whitespace. In the absence of anything
#    # better to do, again print such heading as is.
#    #
#    # For both efficiency and simplicity, unify both such cases here.
#    } else {  # guard condition :: elif (( character_count_left <= 0 ))
#        print_string "${heading}"
#    }
#}


#FUXME: Actually, we want to pass a map name, where the map is structured:
#
#     "${map_name}"=(
#         'color_style_category' 'print_message'
#     )
#. This PCRE assumes *multiline matching*
#(i.e., the `.` quantifier matches all characters _except_ newline) and hence
#should only be used under such matching
# Match
    # multiline to prevent "." from matching newlines.
    # Return such string.
#   return_string "${text_wrapped}"

#Wouldn't you like to see a positive LSD story on the news? To base your decision on information rather than scare tactics and superstition? Perhaps? Wouldn't that be interesting? Just for once?
#   "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."

    # PCRE wrapping lines to such length.
#   pcre_wrapping_lines="$(get_pcre_wrapping_at_line_length "${line_length}")"

    #FUXME: Abstract into a string global.
    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    # Dismantled, this is:
    #
    # * "\G", anchoring such match immediately after the end of the prior match.
    # * "\h*+", matching ignorable horizontal whitespace (i.e., non-newline)
    #   without backtracking, for efficiency.
    # * "(?:...)", matching either:
    #   * "\n", a newline, in which case ${match[1]} will be the empty string,
    #     ensuring an equivalent of 'output_string "${match[1]}"' will simply
    #     reprint the matched newline.
    #   * "(.{...})", a line's worth of text to ${match[1]}, optionally:
    #     * "(-)", capturing a hyphen suffix to ${match[2]}.
    # * "(?(2)|(?:...))", matching either:
    #   * If a hyphen suffix previously matched, then nothing else.
    #   * Else, mandatory horizontal whitespace, a newline, or the string end.
    #     In any case, such suffix will typically be converted into a newline.
#   line_pcre='\G\h*+(?:\n|(.{1,'${line_length}'}(-)?)(?(2)|(?:\h+|$))'
    # * "(?:...)", matching such line's delimiter as either:

#Minimizing Line Count versus Right Raggedness 
#a maximal line's worth  substring. To ensure human-readable output, wrap at
#word endings by requiring such substring be suffixed by either whitespace
#or the end of such string.
