#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *horizontal lines* (i.e., singe-line strings constructed from user-
configurable styles, typically spanning the width of the current terminal).
/---

#FIXME: Globally rename "_in_style" to "_in_style" everywhere.
#FIXME: O.K.; the "(get_caller)." idea turns out to have been less than stellar,
#largely as different functions want different defaults. In some cases, it's
#"(get_caller)."; in others, "(get_caller).stack" or what have you. In others
#still, such as output_line(), it's *NO* such defaults but simply
#"output_line.". So what do we do about this? I see two distinct types of
#functions we currently bundle under the same rubric:
#
#* Non-caller-dependent outputters (e.g., output_line()), whose nomenclature
#  should be the most concise of such functions, reflecting the lack of
#  dependency on external sources.
#* Caller-dependent outputters (e.g., output_call_stack_lists_title()), whose
#  nomenclature should be *LENGTHENED* to reflect such dependency. For example,
#  how about output_call_stack_lists_title_in_style_caller() rather than the
#  current output_call_stack_lists_title()? While the suffix is certainly up for
#  discussion, this is absolutely the way forward. Rename existing functions
#  before this spirals beyond our meagre focus.
#
#Of course, in the latter case, it's not necessarily clear that we *NEED* any
#such function. After all, it's trivial for the caller to simply pass "${0}." in
#most such cases. There are non-trivial exceptions, of course, which do
#genuinely deserve discrete functions: print_string_titled_in_style_caller_in_style_caller().
#But in most cases, we could probably profitably remove the current trivial
#versions of such functions.
#FIXME: Add examples, as ever.

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_string_to_line_of_length_in_style(
    string string_name,
    integer length,
    string style_prefix)

Set the passed string variable to a horizontal line of the passed length, using
user-configurable styles prefixed by the passed prefix. See
set_string_to_string_centered_to_width_in_style() for further details.
/---
function set_string_to_line_of_length_in_style() {
    die_unless_args_3\
        'Expected one string name, one length, and one style prefix.'
    set_string_to_string_centered_to_width_in_style\
        "${1}" '' "${@[2,3]}"
}

# ....................{ OUTPUTTERS                         }....................
declare_function_with_stdin <<'/---'
string output_line(void)

Output a horizontal line spanning the width of the current terminal, using user-
configurable styles prefixed by `output_line.`. See
output_line_of_length_in_style() for further details.
/---
function output_line() {
    die_if_args
    output_line_in_style "output_line."
}

declare_function_with_stdin <<'/---'
string output_line_in_style(string style_prefix)

Output a horizontal line spanning the width of the current terminal, using user-
configurable styles prefixed by the passed prefix. See
output_line_of_length_in_style() for further details.
/---
function output_line_in_style() {
    die_unless_arg 'Expected one style prefix.'
    output_line_of_length_in_style "$(get_terminal_width)" "${1}"
}

declare_function_with_stdin <<'/---'
string output_line_of_length_in_style(
    integer length, string style_prefix)

Output a horizontal line of the passed length, using user-configurable styles
prefixed by the passed prefix. See
center_string_to_width_in_style() for further details.
/---
function output_line_of_length_in_style() {
    die_unless_args_2 'Expected one length and one style prefix.'
    center_string_to_width_in_style '' "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Improper. Default to new styles "output_line." instead. When a
#caller calls this function, they expect a line to be output. That's it.
#Plain. Simple. No caller-defined nonsense.
# the the dot-suffixed caller's name (i.e., `$(get_caller).`)

    # Validate sanity.
#    die_unless_args_2 'Expected one length and one style prefix.'
#    string line
#
#    # Set and output such line.
#    set_string_to_line_of_length_in_style line "${@}"
#    output_string "${line}"

    #FUXME: This now smacks of overcomplexity. Thanks to
    #set_string_to_string_ansiless_repeated_to_length(), we can (and should)
    #seemlessly repeat substrings not perfectly filling the allotted length.
    #This implies that we don't really need or want any excess space characters
    #and hence no variables ${space_left_length} or ${space_right_length} below.
    #Jeez! Shame we didn't concoct such function earlier. Contemplate excising
    #all or most of this, I should think.

    # Number of times to repeat the left and right border substrings to
    # produce a borderline filling as much of the space between the
    # corresponding corner and joiner substrings as possible. If such
    # substring is a single character, this is always possible; else, this
    # is only possible if the length of such substring evenly divides the
    # length of such space.
#   borderline_left_count=$((  border_left_length  / border_left_length ))
#   borderline_right_count=$(( border_right_length / border_right_length ))

    #FUXME: Excise.
    # Number of space characters to precede and follow such text. Such
    # characters are required *ONLY* if the corresponding border substring
    # is longer than a single character and cannot perfectly fill the space
    # allotted to such border, as discussed above.
#    space_left_length=$(( border_left_length -\
#        (borderline_left_count *  border_left_length) ))
#    space_right_length=$(( border_right_length -\
#        (borderline_right_count * border_right_length) ))
##   print "left_length: ${left_length}\ncorner_left_length: ${corner_left_length}\njoiner_left_length: ${joiner_left_length}\nborder_left_length: ${border_left_length}\nborderline_left_count: ${borderline_left_count}\nspace_left_length: ${space_left_length}\n\nright_length: ${right_length}\ncorner_right_length: ${corner_right_length}\njoiner_right_length: ${joiner_right_length}\nborder_right_length: ${border_right_length}\nborderline_right_count: ${borderline_right_count}\nspace_right_length: ${space_right_length}"

    #FUXME: Excise.
    # If either such numbers are negative, throw an exception. Note that
    # corner and joiner substrings are optional and hence do not require such
    # exception handling.
#    die_unless_integer_nonnegative "${space_left_length}"\
#        'Left whitespace string length negative.'
#    die_unless_integer_nonnegative "${space_right_length}"\
#        'Right whitespace string length negative.'

    #FUXME: Refactor to simply call
    #set_string_to_string_ansiless_repeated_to_length().
    # Left and right border lines.
#    borderline_left="$( repeat_string "${border_left}"  ${borderline_left_count})"
#    borderline_right="$(repeat_string "${border_right}" ${borderline_right_count})"

    #FUXME: Excise.
    # Left and right space fillers.
#    space_left="$( repeat_string ' ' ${space_left_length})"
#    space_right="$(repeat_string ' ' ${space_right_length})"

    #FUXME: Such variables must exclude ANSI escape sequences! Shift such
    #sequences to the prior left corner and prior left joiner, respectively.
    #FUXME: Rename such variables, please.

    # If the number of characters preceding such text is less than 1, the
    # current terminal is insufficiently wide to border such text. Print such
    # text as is and immediately return.
#    if (( cipher_left_length <= 1 )) {
#        # Text to be returned.
#        string text_centered
#
#        # Color such text.
#        text_centered+="${ZESHY_STYLE_TO_COLOR[${style_prefix}text]-}"
#
#        # If such number is 1, such text's length is either 2 or 3 characters
#        # less than such width. Hence, 1 character to the left of and either 1 or 2
#        # characters to the right of such text remain for a border. This isn't
#        # terribly much. In the absence of anything better to do, print such text
#        # offset from the beginning of the terminal line by 1 character.
#        if (( cipher_left_length == 1 )) {
#            text_centered+=' '
#        # Else such number is nonpositive (i.e., less than or equal to 0).
#        #
#        # If such number is negative, such text exceeds such terminal in length.
#        # In the absence of anything better to do, print such text as is. While
#        # this guarantees such text to wrap around at least once, truncating such
#        # text to the current terminal width often produces worse results.
#        #
#        # If such number is 0, such text's length is either the terminal width or
#        # one character less than such width. In the former case, no space remains
#        # for a border; in the latter case, only one character of space remains,
#        # hardly enough for even delimiting whitespace. In the absence of anything
#        # better to do, again print such text as is.
#        #
#        # For both efficiency and simplicity, unify both such cases here.
#        } # elif (( left_length <= 0 )) { }
#
#        # Return such text.
#        text_centered+="${text}"
#        return_string  "${text}"
#    }

    #FUXME: Actually, if the length of such string exceeds the terminal width,
    #it turns out to be quite a bit better aesthetically to prefix and suffix
    #such string with *ONLY* the appropriate corner styles (but not border or
    #joiner styles). This helps to visually distinguish long lines as either
    #(typically) headers or footers, despite their length.
    #FUXME: Actually, printing a single corner, border, and joiner for both the
    #left and right sides should do nicely, I should think. Which is to say,
    #simply floor such substrings to ensure their length is never less than 1.
    #FUXME: Simplify as documented above by simply flooring the prior lengths to 1.

    # If either such number is negative, the current terminal is sufficiently
    # wide to print such text but *NOT* such corners, borders, and joiners. Any
    # number of possible responses to such problem exist. For convenience, we
    # currently adopt the simplest: reduce all corners and joiners on each
    # problem side to the empty string and recalculate the corresponding number,
    # which should now be nonnegative.
#   if (( border_left_length < 0 )) {
#        corner_left=''
#        joiner_left=''
#        corner_left_length=0
#        joiner_left_length=0
#        border_left_length="${left_length}"
#   }
#   if (( border_right_length < 0 )) {
#        corner_right=''
#        joiner_right=''
#        corner_right_length=0
#        joiner_right_length=0
#        border_right_length="${right_length}"
#   }

#   text_length="$(get_string_length_printable "${text}")"
    #FUXME: Permit caller to set such width. We'll need a new function
    #center_string_to_width_in_style() called by this
    #function. Yum! yum.

# if either are
    # empty. (Since corner and joiner substrings are optional, such exception
    # handling applies only to border substrings.)
# If the length of such string
#exceeds such width, such string will be printed ``as is'' (i.e., without
#prefixing or suffixing such string by styles documented below).

#       output_string "ok${(l:$(( text_line_length - ${(m)#text_line})):: :):-}ko"
        # Construct such line.
#       if is -n "${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}" si {
#           text_line="${text_color}${match['${ZESHY_PCRE_WRAPPING_INDEX_DELIMITED}']}"
#       } else {
#           text_line="${text_color}${match['${ZESHY_PCRE_WRAPPING_INDEX_UNDELIMITED}']}-"
#       }

    # Length of such text, excluding non-printable characters and sequences.
#   text_length="$(get_string_length_printable "${text}")"
#       text_length\
#       line_prefix_length\

    # If such width is sufficiently small, it's not feasible to print both a box
    # and at least one character in such box. In such cases, print such string
    # as is and immediately return.
#   if (( terminal_width <= 5 )) {
#       return_string "${text}"
#   }

# substring to be printed on each output line.

    #FUXME: Create such function, which should simply call
    #reset_terminal_color() currently (but which subsequently could be made to
    #perform additional functionality).
    # If required, print delimiting prefixing whitespace.
#   start_stdout

    #FUXME: It'd be silly to reimplement a method printing a box header, given
    #the already sufficiently complex print_message_heading() function. We'll need to
    #generalize such function to call a new "driver" function, doing the lion's
    #share of printing work -- say, print_string_centered_with_border().
    #FUXME: Interestingly, given such function, we can instantly a new
    #print_string_centered() to simply call such function with a map whose
    #border characters all simply expand to a single space. Nice.

    # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#   if { is_locale_encoding_utf8 } {
#       border_north='═'
#       border_south='─'
#       border_west='│'
#       border_east='│'
#       border_north_west='╒'
#       border_north_east='╕'
#       border_south_west='╰'
#       border_south_east='╯'
#   } else {
#       border_north='-'
#       border_south='-'
#       border_west='|'
#       border_east='|'
#       border_north_west='/'
#       border_north_east='\'
#       border_south_west='\'
#       border_south_east='/'
#   }

#Print the passed string wrapped to the current terminal width, prefixing each
#resulting line with the passed prefix. Specifically:
#
#. Split such string into substrings satisfying the following constraints:
#** Each substring is suffixed by either whitespace or the end of such string.
#** Each substring is no longer than the current terminal width subtracted by the
#   length of such prefix.
#. Print each substring prefixed by such prefix and suffixed by a newline.
#
#For example:
#
#.print_string_boxed_with_color_style_prefix()
#==========================================
#[source]
#------------------------------------------
#>>> string on_boxes=\
#...    "The box is full of salmon, and a man sits atop the box. Long ago this"\
#...    "man hired armed guards to keep anyone from eating his fish. The many"\
#...    "people who sit next to the empty river starve to death. But they do"\
#...    "not die of starvation. They die of a belief. Everyone believes that"\
#...    "the man atop the box owns the fish. The soldiers believe it, and they"\
#...    "will kill to protect the illusion. The others believe it enough that"\
#...    "they are willing to starve. But the truth is that there is a box,"\
#...    "there is an emptied river, there is a man sitting atop the box, there"\
#...    "are guns, and there are starving people."
#>>> print_string_wrapped_with_line_prefix "${on_boxes}" box
#box: The box is full of salmon, and a man sits atop the box. Long ago this man
#box: hired armed guards to keep anyone from eating his fish. The many people who
#box: sit next to the empty river starve to death. But they do not die of
#box: starvation. They die of a belief. Everyone believes that the man atop the
#box: box owns the fish. The soldiers believe it, and they will kill to protect
#box: the illusion. The others believe it enough that they are willing to starve.
#box: But the truth is that there is a box, there is an emptied river, there is a
#box: man sitting atop the box, there are guns, and there are starving people.
#------------------------------------------
#==========================================

#(i.e., substrings "joining" borders to adjacent text)
#If such styles do not exist,
#this function defaults to simply centering such string without embellishment.
#
#This function supports a variety of color and text styles.
#all of the following styles that are existing keys of maps
#${ZESHY_STYLE_TO_COLOR} (identifying the colors to be output) and
#${ZESHY_STYLE_TO_TEXT} (identifying the string literals to be output):

#As configured by the
#current user and theme, such styles identify the colors and string literals with
#which to aesthetically embellish the passed string. If such styles do not exist,
#this function defaults to simply centering such string without embellishment.

#string print_string_centered_and_string_wrapped_in_style(

#FUXME: Oh, wait! We can get the 'color_style_category' just by calling
#"$(get_caller)", so don't bother explicitly passing it. (Let's simplify life a
#tad, in other words.)
#FUXME: It'd be great to eventually support the subdivision of the border
#into appropriate subsections: e.g.,
#
#     ====~~~-{ text }--~~~===
#
#The principal annoyance there, of course, is that for each possible
#subdivision you add, you have to add the corresponding number of
#conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#concoct a single governing equation determining how many characters of each
#subdivision to print, even in edge cases of small terminal lines: e.g.,
#
#     ~-{ text }-~
#FUXME: Actually, we'd probably just want to subdivide the *COLORS* of the
#single-character border into a gradient. Don't change the characters;
#change the colors. This is both simpler and more aesthetically pleasing,
#particularly under 256-color terminals.

    # If either such number is negative, the current terminal is sufficiently
    # wide to print such text but *NOT* such corners, borders, and joiners. Any
    # number of possible responses to such problem exist. For convenience, we
    # currently adopt the simplest: reduce all corners and joiners on each
    # problem side to the empty string and recalculate the corresponding number,
    # which should now be nonnegative.
#   if (( borderline_left_count < 0 )) {
#       corner_left_length=0
#       joiner_left_length=0
#       borderline_left_count=$(( left_length / border_left_length ))
#   }
#   if (( borderline_right_count < 0 )) {
#       corner_right_length=0
#       joiner_right_length=0
#       borderline_right_count=$(( right_length / border_right_length ))
#   }

    # If the current locale encodes to UTF-8, prefer UTF-8 substrings.
    # Default unset border substrings to a single space and all other
    # substrings to the empty string.
#   if { is_locale_encoding_utf8 } {
#        corner_left="${ZESHY_STYLE_TO_TEXT.corner_left_utf8__lm-}"
#       corner_right="${corner_right_utf8__lm-}"
#        border_left="${border_left_utf8__lm- }"
#       border_right="${border_right_utf8__lm- }"
#        joiner_left="${joiner_left_utf8__lm-}"
#       joiner_right="${joiner_right_utf8__lm-}"
    # Else, fallback to ASCII substrings.
#   } else {
#        corner_left="${corner_left_ascii__lm-}"
#       corner_right="${corner_right_ascii__lm-}"
#        border_left="${border_left_ascii__lm- }"
#       border_right="${border_right_ascii__lm- }"
#        joiner_left="${joiner_left_ascii__lm-}"
#       joiner_right="${joiner_right_ascii__lm-}"
#   }

    # Localize all keys of such map into string locals suffixed by "__lm".
#   localize_map "${map_name}"

    # Prefix for all color style names expanded below, defaulting to the name
    # of the caller suffixed by "." (e.g., "print_message_heading."). Should no such
    # styles exist, such styles will simply be ignored. Since get_caller() must
    # be called in the current function, such initialization must be performed
    # manually rather than by set_string_if_unset_to_evaluation().
#   is_variable color_style_prefix__lm or {
#       string color_style_prefix__lm; color_style_prefix__lm="$(get_caller)."
#   }

#FUXME: Once we get this working, there's a far better alternative generalizing
#substring choices in the same manner that ${ZESHY_STYLE_TO_COLOR} generalizes
#color choices. In order:
#
#* Create a new *EMPTY* parcel tree "src/if_theme/vanilla", as before.
#* Shift "src/if_config/color" to "src/if_config/theme/color".
#* Create a new parcel            "src/if_config/theme/text".
#* Add two new map globals to the latter such parcel:
#  * ${ZESHY_STYLE_TO_TEXT_ASCII}.
#  * ${ZESHY_STYLE_TO_TEXT_UTF8}.
#* Rename map global ${ZESHY_STYLE_TO_COLOR} to ${ZESHY_STYLE_TO_COLOR_NAMES}, in
#  keeping with such nomenclature.
#* Replace the last parameter to this function with
#  'string style_prefix = "$(get_caller)."'. This thus reduces most functions
#  calling this function to simply the function call only the passed text: e.g.,
#
#    # This works even *WITHOUT* defining any color styles for
#    # "print_string_centered", thanks to helpful defaults.
#    function print_string_centered() {
#        get_string_centered_with_map_attributes "${*}"
#    }
#
#    # This works assuming we convert passed arguments to map attributes: e.g.,
#    # ZESHY_STYLE_TO_TEXT_ASCII=(
#    #     'print_message_heading.border_left' '-'
#    # )
#    function print_message_heading() {
#        get_string_centered_with_map_attributes "${*}"
#    }
#
#The answer to the question "What are zeshy styles?" is thus "Unique strings
#index maps in parcels under src/if_config/theme/".
#FUXME: Reimplement to simply call print_string_centered_with_border().

#   map map_attributes; map_attributes=(
        # Popular alternative schemes:
        #
        # ────────{ hello }─────────
        #
        # ────────╢ hello ╟─────────
        #
        # ────────┨ hello ┠─────────
        #
        # ┠───────╼ hello ╾────────┨
        #
        # ├───────╼ hello ╾────────┤
        #
        # ┎───────╼ hello ╾────────┒
        #
        # ────────╼ hello ╾─────────
        #
#       'border_left_utf8'   '─'
#       'border_left_ascii'  '-'
#       'border_right_utf8'  '─'
#       'border_right_ascii' '-'
#       'joiner_left_utf8'   '╼ '
#       'joiner_left_ascii'  '{ '
#       'joiner_right_utf8'  ' ╾'
#       'joiner_right_ascii' ' }'
#   )
#   get_string_centered_with_map_attributes "${*}" 'map_attributes'

    # String to be printed, concatenated from remaining arguments.
#   text="${*}"

    # If such text length and terminal width have different parity (i.e.,
    # one is even and the other odd), such text cannot be evenly centered in
    # the current terminal and hence must be offset either one character to the
    # left or right of "true" center. For subjectively (and entirely marginally)
    # better aesthetics, offset such text to the left.
    #
    # If additionally the right border substring is a single character, such
    # offsetting is best achieved by extending such border to the right by a
    # single character; else, such offsetting will be achieved below by
    # appending a space after such text.
#   if (( border_right_length__pscwm == 1 )) and
#       { not is_integer_parity_equals\
#           ${terminal_width__pscwm} ${text_length__pscwm} } {
#       borderline_right_count__pscwm+=1
#   }

#   die_unless_map_keys "${map_name__pscwm}"\
#       'color_style_prefix'
#       die_unless_integer_nonnegative "${borderline_left_count__pscwm}"\
#           ''
#       die_unless_integer_nonnegative "${borderline_right_count__pscwm}"\

    # suggesting either the left or right extend such border by another character. While the left border
    # could instead be extended in this way, extending the right border
    # produces a subjectively (and entirely marginally) better aesthetic.
    # If such number is at least 2, such text is at least 4 characters less
    # than such width. Hence, at least 2 characters to the left of *AND* to the
    # right of such text remain for a border. Since this suffices for simple
    # border art, print such text preceded by a colorfully aesthetic border.
    # While it would be nice to split this conditional into a separate function,
    # dependency on multiple local variables above makes this a bad proposition.
#   if (( left_count__pscwm >= 2 )) {

#   string color_style_prefix__lm="${color_style_prefix__lm}-$(get_caller).}"
# these numbers are typically 0.
        #FUXME: If the length of either border substring is greater than 1, it's
        #feasible such length may not perfectly divide the allotted space, in
        #which case... what? Well, we should probably just fill the remaining
        #space immediately adjacent to such text with horizontal whitespace.

        #FUXME: Just inline such calls below. This is extreme overkill.
        #FUXME: Actually, we need to reuse the border l

#       (( borderline_left_count__pscwm = border_count_right__pscwm =\
#           character_count_left__pscwm - 2 ))
        # Number of border characters preceding and succeeding such text,
        # respectively. Such numbers are always nonnegative (i.e., >= 0).

        # Characters constituting:
        #
        # * Both left and right borders.
        # * Both left and right joiners (i.e., character "joining" text
        #   titles to adjacent borders).
#       string\
#           character_border__pscwm\
#           character_joiner_left__pscwm='{ '\
#           character_joiner_right__pscwm=' }'

        # Default unpassed substrings to the empty string space.
#declare_function_with_stdin <<'/---'
#string print_message_heading(string heading1 = "", string heading2, ...)
#
#Print the passed strings (defaulting to the empty string) as a section heading
#suffixed by a newline to standard output. See print_string() for further
#details.
#/---
#function print_message_heading() {
#    # Heading to be printed, concatenated from passed arguments.
#    string heading="${*}"
#    integer terminal_width heading_length character_count_left
#
#    # If the current call stack has already called a high-level print function,
#    # print delimiting whitespace.
#    start_stdout
#
#    # Lengths of the current terminal and heading. The latter excludes non-
#    # printable characters, including ANSI color escapes.
#    terminal_width="$(get_terminal_width)"
#    heading_length="$(get_string_length_printable\
#        "${heading}")"
#
#    # Number of characters preceding such heading, when centering such heading
#    # in the middle of an output terminal line. By design, assigning a floating
#    # point value to an integer variable implicitly rounds such value down to
#    # the nearest whole integer. In this case, such rounding ensures when the
#    # terminal width and heading length are of differing parity that the heading
#    # will be offset to the left one character from the true "center": e.g.,
#    #
#    #     # Centering a 4-character string on a 9-character wide terminal.
#    #     123456789   # terminal width indices; note "5" to be the center
#    #       test      # string offset to the left 1 character from center
#    (( character_count_left = (terminal_width - heading_length) / 2 ))
#
#    #FUXME: It'd be great to eventually support the subdivision of the border
#    #into appropriate subsections: e.g.,
#    #
#    #     ====~~~-{ heading }--~~~===
#    #
#    #The principal annoyance there, of course, is that for each possible
#    #subdivision you add, you have to add the corresponding number of
#    #conditionals below. Hmmm; or perhaps not? Hmmm. Right. We should be able to
#    #concoct a single governing equation determining how many characters of each
#    #subdivision to print, even in edge cases of small terminal lines: e.g.,
#    #
#    #     ~-{ heading }-~
#    #FUXME: Actually, we'd probably just want to subdivide the *COLORS* of a
#    #single-character border into a gradient. Don't change the characters;
#    #change the colors.
#
#    # If such number is at least 2, such heading is at least 4 characters less
#    # than such width. Hence, at least 2 characters to the left of *AND* to the
#    # right of such heading remain for a border. Since this suffices for simple
#    # ANSI art, print such heading preceded by a colorfully aesthetic border.
#    # While it would be nice to split this conditional into a separate function,
#    # dependency on multiple local variables above makes this a bad proposition.
#    if (( character_count_left >= 2 )) {
#        # Number of border characters (e.g., "-") preceding and succeeding such
#        # heading, respectively. Such numbers are always nonnegative (>= 0).
#        integer border_count_left border_count_right
#        (( border_count_left = border_count_right = character_count_left - 2 ))
#
#        # If such heading length and terminal width have different parity (i.e.,
#        # one is even and the other odd), 1 additional character of space to the
#        # right of such heading remains for a border; allocate such space!
#        if { not is_integer_parity_equals\
#            ${terminal_width} ${heading_length} } {
#            border_count_right+=1
#        }
#
#        # Characters constituting:
#        #
#        # * Both left and right borders.
#        # * Both left and right joiners (i.e., character "joining" heading
#        #   titles to adjacent borders).
#        character\
#            character_border\
#            character_joiner_left='{ '\
#            character_joiner_right=' }'
#
#        # If the current locale encodes to UTF-8, output UTF-8; else, ASCII.
#        if { is_locale_encoding_utf8 } {
#            character_border='─'
#        } else {
#            character_border='-'
#        }
#
#        # Left and right borders consisting of such characters.
#        string left_border right_border
#        left_border="$( repeat_string "${character_border}" ${border_count_left})"
#        right_border="$(repeat_string "${character_border}" ${border_count_right})"
#
#        # Print such heading.
#        print_string\
#            "${ZESHY_STYLE_TO_COLOR[print_message_heading.border]-}${left_border}${ZESHY_STYLE_TO_COLOR[print_message_heading.joiner]-}${character_joiner_left}${ZESHY_STYLE_TO_COLOR[print_message_heading.heading]-}${heading}${ZESHY_STYLE_TO_COLOR[print_message_heading.joiner]-}${character_joiner_right}${ZESHY_STYLE_TO_COLOR[print_message_heading.border]-}${right_border}"
#    # If such number is 1, such heading's length is either 2 or 3 characters
#    # less than such width. Hence, 1 character to the left of and either 1 or 2
#    # characters to the right of such heading remain for a border. This isn't
#    # terribly much. In the absence of anything better to do, print such heading
#    # offset from the beginning of the terminal line by 1 character.
#    } elif (( character_count_left == 1 )) {
#        print_string " ${heading}"
#    # Else such number is nonpositive (i.e., less than or equal to 0).
#    #
#    # If such number is negative, such heading exceeds such terminal in length.
#    # In the absence of anything better to do, print such heading as is. While
#    # this guarantees such heading to wrap around at least once, truncating such
#    # heading to the current terminal width often produces worse results.
#    #
#    # If such number is 0, such heading's length is either the terminal width or
#    # one character less than such width. In the former case, no space remains
#    # for a border; in the latter case, only one character of space remains,
#    # hardly enough for even delimiting whitespace. In the absence of anything
#    # better to do, again print such heading as is.
#    #
#    # For both efficiency and simplicity, unify both such cases here.
#    } else {  # guard condition :: elif (( character_count_left <= 0 ))
#        print_string "${heading}"
#    }
#}


#FUXME: Actually, we want to pass a map name, where the map is structured:
#
#     "${map_name}"=(
#         'color_style_category' 'print_message'
#     )
#. This PCRE assumes *multiline matching*
#(i.e., the `.` quantifier matches all characters _except_ newline) and hence
#should only be used under such matching
# Match
    # multiline to prevent "." from matching newlines.
    # Return such string.
#   return_string "${text_wrapped}"

#Wouldn't you like to see a positive LSD story on the news? To base your decision on information rather than scare tactics and superstition? Perhaps? Wouldn't that be interesting? Just for once?
#   "Today, a young man on acid realized that all matter is merely energy condensed to a slow vibration – that we are all one consciousness experiencing itself subjectively. There's no such thing as death, life is only a dream, and we're the imagination of ourselves. Here's Tom with the weather."

    # PCRE wrapping lines to such length.
#   pcre_wrapping_lines="$(get_pcre_wrapping_at_line_length "${line_length}")"

    #FUXME: Abstract into a string global.
    # PCRE matching such a substring. To ensure human-readable output, wrap at
    # word endings by requiring such substring be suffixed by either whitespace
    # or the end of such string. To accept zsh code embedded in such input,
    # avoid character classes "\w" and "\W" matching spoken language words.
    # Dismantled, this is:
    #
    # * "\G", anchoring such match immediately after the end of the prior match.
    # * "\h*+", matching ignorable horizontal whitespace (i.e., non-newline)
    #   without backtracking, for efficiency.
    # * "(?:...)", matching either:
    #   * "\n", a newline, in which case ${match[1]} will be the empty string,
    #     ensuring an equivalent of 'output_string "${match[1]}"' will simply
    #     reprint the matched newline.
    #   * "(.{...})", a line's worth of text to ${match[1]}, optionally:
    #     * "(-)", capturing a hyphen suffix to ${match[2]}.
    # * "(?(2)|(?:...))", matching either:
    #   * If a hyphen suffix previously matched, then nothing else.
    #   * Else, mandatory horizontal whitespace, a newline, or the string end.
    #     In any case, such suffix will typically be converted into a newline.
#   line_pcre='\G\h*+(?:\n|(.{1,'${line_length}'}(-)?)(?(2)|(?:\h+|$))'
    # * "(?:...)", matching such line's delimiter as either:

#Minimizing Line Count versus Right Raggedness 
#a maximal line's worth  substring. To ensure human-readable output, wrap at
#word endings by requiring such substring be suffixed by either whitespace
#or the end of such string.
