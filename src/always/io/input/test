#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *interactive input testers* (i.e., functions testing such input).
-/-

# ....................{ TESTERS ~ character                }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_input_character_yes(void)

Return success if a single character interactively entered by the current user
is the default affirmative answer for the current locale (e.g., `y` or `Y`,
assuming English) or failure otherwise, blocking until a character is entered.
/---
function is_input_character_yes() {
    # Validate passed arguments.
    die_if_args
    die_unless_stdin_terminal

    # Test such answer. Since such answer has (usually) been output to the
    # current terminal as "y" or "Y", avoid outputting such answer again.
    run_command_silent read -eq
}

#FIXME: "[yn]" is locale-specific and hence requires localization.
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] is_query_character_yes(string query)

Return success if the next character interactively input by the current user is
the default positive response to yes/no questions for the current locale (e.g.,
`y` or `Y`, assuming English) or failure otherwise. Print the passed query
before requesting such input. Block until a character is input.
/---
function is_query_character_yes() {
    # Validate passed arguments.
    die_unless_arg 'expected one query'
    string query="${1}" response

    # Lists of positive and negative responses to such query.
    list_name characters_yes characters_no
    set_list_to_locale_characters_yes characters_yes
    set_list_to_locale_characters_no  characters_no

    # Print such query and set such string to the current user's response.
    set_string_to_query_character_for_choices_default_and_other\
        response "${query}" characters_yes characters_no

    # Test such answer.
    is_string_matches_pcre "${response}" "$(get_locale_pcre_yes)"
}

#FIXME: Shift to @{set}.
declare_function_with_stdin <<'/---'
string set_string_to_query_character_for_choices_default_and_other(
    string string_name,
    string query,
    string list_name_choice_default,
    string list_name_choice_other)

Set the passed string variable to the next character interactively input by
the current user. Before blocking for such character (i.e., before requesting
such input), this function prints:

* The passed query as a message item (i.e., by calling print_message_item()).
  Assuming the length of such query is less than the width of the current
  terminal, such query will be printed on a single line terminated by a trailing
  newline.
* An input prompt consisting of the passed lists of:
** *Default choices* (i.e., the set of non-newline characters the caller assumes
   the user to have input if a newline was input).
** *Non-default choices* (i.e., the set of non-newline characters the caller
   also accepts, as alternatives to the prior default choices).

This function does _not_ enforce or test such choices. Rather, it simply prints
such choices with the appropriate `zeshy` styles configured by the current user.
Such styles are keys of both the user-configurable map ${ZESHY_STYLE_TO_COLOR}
(specifying colors to be output) and ${ZESHY_STYLE_TO_TEXT} (specifying string
literals to be output) prefixed by `set_string_to_query_character.prompt.`.
/---
function set_string_to_query_character() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string name, one query, one list name of default characters, and one list name of non-default characters'
    die_unless_stdin_terminal
    string\
        string_name__sstqc="${1}"\
        query__sstqc="${2}"\
        list_name_choice_default__sstqc="${3}"\
        list_name_choice_other__sstqc="${4}"\
        style_prefix__sstqc
        border_left__sstqc\
        parens_left__sstqc\
        parens_right__sstqc\
        choice_default__sstqc\
        choice_other__sstqc\
        choice_delimiter__sstqc\
        input__sstqc
    die_unless_list list_name_choice_default__sstqc
    die_unless_list list_name_choice_other__sstqc

    # Print such question and get such answer.
    set_string_to_query_character answer\
        "${question}${choice_parens_left}${choice_other}${choice_default}${choice_parens_right}"

    # Print such query.
    print_message_item "${query__sstqc}"

    # String prefixing prompt styles referenced below.
    style_prefix__sstqc='set_string_to_query_character.prompt.'

    #FIXME: Don't bother handling small terminal widths, at the moment. Ideally,
    #we should probably avoid printing the left border if the combined length of
    #such border, parens, and choices exceeds the current terminal width. But
    #this seems a mute triviality, really.

    # Prompt substrings to be printed.
    border_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}border_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}border_left]-}"
    parens_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_left]-[}"
    parens_right__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_right]-] }"
    choice_default__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_default]-}$(join_list list_name_choice_default__sstqc)"
    choice_other__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_other]-}$(join_list list_name_choice_other__sstqc)"
    choice_delimiter__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_delimiter]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}choice_delimiter]-/}"
    input__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}input]-}"

    # Print a prompt for user input.
    output_string_sans_newline "${border_left__sstqc}${parens_left__sstqc}${choice_default__sstqc}${choice_delimiter__sstqc}${choice_other__sstqc}${parens_right__sstqc}${input__sstqc}"

    # Block on such character and set such string.
    set_string_to_input_character "${string_name__sstqc}"

    # If such character is *NOT* a newline, print a trailing newline.
    if { not is_string_equals\
        "${(P)string_name__sstqc}" "${ZESHY_ASCII_NEWLINE}" } {
        output_newline
    }
}

# ....................{ TESTERS ~ line                     }....................
#FIXME: "[YES/no]" is locale-specific and hence requires localization.
declare_function_with_stdin <<'/---'
[status: boolean] is_query_line_yes(
    string question,
    string answers = " [YES/no] ",
    string answer_yes = "YES")

Return success if a *single line* (i.e., newline-delimited string otherwise
containing no newlines) interactively entered by the current user is the default
affirmative answer for the current locale (e.g., `YES`, assuming English) or
failure otherwise, printing the passed question before receiving such input and
blocking until the first newline is entered.

This stronger alternative to is_query_character_yes() is
intended for questions whose confirmation carries permanent potentially harmful
consequences (e.g., data loss).
/---
function is_query_line_yes() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional answers, and optional yes answer'
    die_unless_stdin_terminal
    string\
        question="${1}"\
        answers="${2:- ${ZESHY_COLOR[grey]}[${ZESHY_COLOR[blue]}YES${ZESHY_COLOR[grey]}/${ZESHY_COLOR[blue_bold]}no${ZESHY_COLOR[grey]}] }"\
        answer_yes="${3:-YES}"\
        answer

    # Print such question and get such answer.
    set_string_to_query_line answer "${question}${answers}"

    # Test such answer.
    is_string_equals "${answer}" "${answer_yes}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Improve documentation, including styles referenced by this function.
#   print_query_prompt\
#       "${list_name_choice_default__sstqc}"\
#       "${list_name_choice_other__sstqc}"
#* `set_string_to_query_character.prompt.border_left`, styling the *left prompt
#  border* (i.e., the first substring to be printed), defaulting to the empty
#  string.
#* `set_string_to_query_character.prompt.${style_prefix}border_continued_left` and
#  `${style_prefix}border_continued_right`, styling the left and right borders of
#  all lines wrapped from such string except the first such line, defaulting to
#  the values of `${style_prefix}border_left` and `${style_prefix}border_right`.
#* `set_string_to_query_character.prompt.input`, styling the input character.

    # Validate passed arguments.
#   die_unless_args_1_to_3\
#       'expected one question, optional answers, and optional yes answer'
#   die_unless_stdin_terminal
#   string\
#       question="${1}"\
#       answer\
#       style_prefix\
#       choice_parens_left\
#       choice_parens_right\
#       choice_default\
#       choice_other

    #FUXME: This is terrible. Embed such characters into the current function.
    #Incidentally, I recall a builtin zsh mechanism for obtaining such
    #characters from "glibc". Grep through "io/locale" a bit, eh? It'd be nice
    #to get such functionality up. Ah, yes! I dimly recall. We use the same
    #mechanism for obtaining the character used to delimit thousand places in
    #sufficiently long integers.

    # Characters to be input.
#   answer_yes='y'
#   answer_no='n'

    #FUXME: Not quite right. The " [yn] " should be shifted to the following input line,
    #immediately preceding the character to be input. We'll probably need to extend
    #set_string_to_query_character() into a new function
    #set_string_to_query_character_and_choices(). The choices
    #passed to such function should be simple uncolored strings (e.g., "y",
    #"n"). I suppose the first such passed string could be taken to be the
    #default and all subsequent such passed strings non-default alternatives.
    #Such function should delimit such alternatives with a new style
    #"${style_prefix}choice_delimiter", defaulting to the empty string.

    # Substrings to be printed.
#   choice_parens_left="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_parens_left]- [}"
#   choice_parens_right="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_parens_right]-] }"
#   choice_default="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_default]-}${answer_no}"
#   choice_other="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_other]-}${answer_yes}"

    # Print such question and get such answer.
#   set_string_to_query_character answer\
#       "${question}${choice_parens_left}${choice_other}${choice_default}${choice_parens_right}"

    # Test such answer.
#   is_string_equals_caselessly "${answer}" "${answer_yes}"
#}

#   answer_yes="${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_other]-y}"
#   answer_no="${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_default]-n}"

#FUXME: Rename to is_query_character_yes().
#FUXME: Rename to is_query_line_yes().

#FUXME: Not fond of default values. Extract the main implementation into a new
#is_input_character_for_question_equals().
#   string answers = " [yn] ",
#   character answer_yes = "y")

#function is_query_character_yes() {
#    # Validate passed arguments.
#    die_unless_args_1_to_3\
#        'expected one question, optional answers, and optional yes answer'
#    die_unless_stdin_terminal
#    string\
#        question="${1}"\
#        answers="${2:- ${ZESHY_COLOR[is_query_character_yes.parens_left]}[${ZESHY_COLOR[blue]}y${ZESHY_COLOR[blue_bold]}n${ZESHY_COLOR[grey]}] }"\
#        answer_yes="${3:-y}"\
#        answer
#
#    # Print such question and get such answer.
#    set_string_to_query_character answer "${question}${answers}"
#
#    # Test such answer.
#    is_string_equals_caselessly "${answer}" "${answer_yes}"
#}

#FUXME: Rename "answer" to "answer" everywhere below.
