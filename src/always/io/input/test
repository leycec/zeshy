#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle interactive standard input *testers* (i.e., functions testing such
input).
-/-

# ....................{ TESTERS ~ character                }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_input_character_yes(void)

Return success if a single character interactively entered by the current user
is the default affirmative answer for the current locale (e.g., `y` or `Y`,
assuming English) or failure otherwise, blocking until a character is entered.
/---
function is_input_character_yes() {
    # Validate passed arguments.
    die_if_args
    die_unless_stdin_terminal

    # Test such answer. Since such answer has (usually) been output to the
    # current terminal as "y" or "Y", avoid outputting such answer again.
    run_command_silent read -eq
}

#FIXME: "[yn]" is locale-specific and hence requires localization.
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] is_input_character_yes_for_question(
    string question)

Return success if a single character interactively entered by the current user
is the default affirmative answer for the current locale (e.g., `y` or `Y`,
assuming English) or failure otherwise, printing the passed question before
receiving such input and blocking until a character is entered.
/---
function is_input_character_yes_for_question() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional answers, and optional yes answer'
    die_unless_stdin_terminal
    string\
        question="${1}"\
        answer\
        style_prefix\
        choice_parens_left\
        choice_parens_right\
        choice_default\
        choice_other

    # String prefixing styles referenced below.
    style_prefix='is_input_character_yes_for_question.'

    #FIXME: This is terrible. Embed such characters into the current function.
    #Incidentally, I recall a builtin zsh mechanism for obtaining such
    #characters from "glibc". Grep through "io/locale" a bit, eh? It'd be nice
    #to get such functionality up. Ah, yes! I dimly recall. We use the same
    #mechanism for obtaining the character used to delimit thousand places in
    #sufficiently long integers.

    # Characters to be input.
    answer_yes="${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_other]-y}"
    answer_no="${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_default]-n}"

    #FIXME: Not quite right. The " [yn] " should be shifted to the following input line,
    #immediately preceding the character to be input. We'll probably need to extend
    #set_string_to_input_character_for_question() into a new function
    #set_string_to_input_character_for_question_and_choices(). The choices
    #passed to such function should be simple uncolored strings (e.g., "y",
    #"n"). I suppose the first such passed string could be taken to be the
    #default and all subsequent such passed strings non-default alternatives.
    #Such function should delimit such alternatives with a new style
    #"${style_prefix}choice_delimiter", defaulting to the empty string.

    # Substrings to be printed.
    choice_parens_left="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_parens_left]- [}"
    choice_parens_right="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix}choice_parens_right]-] }"
    choice_default="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_default]-}${answer_no}"
    choice_other="${ZESHY_STYLE_TO_COLOR[${style_prefix}choice_other]-}${answer_yes}"

    # Print such question and get such answer.
    set_string_to_input_character_for_question answer\
        "${question}${choice_parens_left}${choice_other}${choice_default}${choice_parens_right}"

    # Test such answer.
    is_string_equals_caselessly "${answer}" "${answer_yes}"
}

# ....................{ TESTERS ~ line                     }....................
#FIXME: "[YES/no]" is locale-specific and hence requires localization.
declare_function_with_stdin <<'/---'
[status: boolean] is_input_line_yes_for_question(
    string question,
    string answers = " [YES/no] ",
    string answer_yes = "YES")

Return success if a *single line* (i.e., newline-delimited string otherwise
containing no newlines) interactively entered by the current user is the default
affirmative answer for the current locale (e.g., `YES`, assuming English) or
failure otherwise, printing the passed question before receiving such input and
blocking until the first newline is entered.

This stronger alternative to is_input_character_yes_for_question() is
intended for questions whose confirmation carries permanent potentially harmful
consequences (e.g., data loss).
/---
function is_input_line_yes_for_question() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional answers, and optional yes answer'
    die_unless_stdin_terminal
    string\
        question="${1}"\
        answers="${2:- ${ZESHY_COLOR[grey]}[${ZESHY_COLOR[blue]}YES${ZESHY_COLOR[grey]}/${ZESHY_COLOR[blue_bold]}no${ZESHY_COLOR[grey]}] }"\
        answer_yes="${3:-YES}"\
        answer

    # Print such question and get such answer.
    set_string_to_input_line_for_question answer "${question}${answers}"

    # Test such answer.
    is_string_equals "${answer}" "${answer_yes}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Not fond of default values. Extract the main implementation into a new
#is_input_character_for_question_equals().
#   string answers = " [yn] ",
#   character answer_yes = "y")

#function is_input_character_yes_for_question() {
#    # Validate passed arguments.
#    die_unless_args_1_to_3\
#        'expected one question, optional answers, and optional yes answer'
#    die_unless_stdin_terminal
#    string\
#        question="${1}"\
#        answers="${2:- ${ZESHY_COLOR[is_input_character_yes_for_question.parens_left]}[${ZESHY_COLOR[blue]}y${ZESHY_COLOR[blue_bold]}n${ZESHY_COLOR[grey]}] }"\
#        answer_yes="${3:-y}"\
#        answer
#
#    # Print such question and get such answer.
#    set_string_to_input_character_for_question answer "${question}${answers}"
#
#    # Test such answer.
#    is_string_equals_caselessly "${answer}" "${answer_yes}"
#}

#FUXME: Rename "answer" to "answer" everywhere below.
