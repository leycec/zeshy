#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *interactive input setters* (i.e., functions setting caller-specified
variables to such input).
-/-

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_string_to_input_character(string string_name)

Set the passed string variable to a single character interactively entered by
the current user. Block until _any_ character is entered.
/---
function set_string_to_input_character() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    die_unless_stdin_terminal
    string string_name__sstic="${1}"
    die_unless_variable_string "${string_name__sstic}"

    # Block on and set such character.
    read -k -- "${string_name__sstic}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
}

declare_function_with_stdin <<'/---'
void set_string_to_input_line(string string_name)

Set the passed string variable to a *single line* (i.e., a newline-delimited
string otherwise containing no newlines) interactively entered by the current
user. Block until the first newline is entered.
/---
function set_string_to_input_line() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    die_unless_stdin_terminal
    string string_name__sstil="${1}"
    die_unless_variable_string "${string_name__sstil}"

    # Block on and set such string.
    read -r -- "${string_name__sstil}"
}

# ....................{ SETTERS ~ query                    }....................
declare_function_with_stdin <<'/---'
string set_string_to_query_character_for_choices_default_and_nondefault(
    string string_name,
    string query,
    string list_name_choice_default,
    string list_name_choice_nondefault)

Set the passed string variable to the next character interactively input by
the current user. Before blocking for such character (i.e., before requesting
such input), this function prints:

* The passed query as a message item (i.e., by calling print_message_item()).
  Assuming the length of such query is less than the width of the current
  terminal, such query will be printed on a single line terminated by a trailing
  newline.
* An input prompt consisting of the passed lists of:
** *Default choices* (i.e., the set of non-newline characters the caller assumes
   the user to have input if a newline was input).
** *Non-default choices* (i.e., the set of non-newline characters the caller
   also accepts, as alternatives to the prior default choices).

This function does _not_ enforce or test such choices. Rather, it simply prints
such choices with the appropriate `zeshy` styles configured by the current user.
Such styles are keys of both the user-configurable map ${ZESHY_STYLE_TO_COLOR}
(specifying colors to be output) and ${ZESHY_STYLE_TO_TEXT} (specifying string
literals to be output) prefixed by `set_string_to_query_character.prompt.`.
/---
function set_string_to_query_character_for_choices_default_and_nondefault() {
    # Validate sanity.
    die_unless_args_4\
        'Expected one string name, one query, one list name of default characters, and one list name of non-default characters.'
    die_unless_stdin_terminal
    string\
        string_name__sstqc="${1}"\
        query__sstqc="${2}"\
        list_name_choice_default__sstqc="${3}"\
        list_name_choice_nondefault__sstqc="${4}"\
        style_prefix__sstqc\
        color_choice_default__sstqc\
        color_choice_nondefault__sstqc\
        border_left__sstqc\
        joiner_left__sstqc\
        parens_left__sstqc\
        parens_right__sstqc\
        choice_default__sstqc\
        choice_nondefault__sstqc\
        choice_separator__sstqc\
        choice_fork__sstqc\
        input__sstqc
    die_unless_lists\
        "${list_name_choice_default__sstqc}"\
        "${list_name_choice_nondefault__sstqc}"
#   print "default choices: ${(@P)list_name_choice_default__sstqc}\nnon-default choices: ${(@P)list_name_choice_nondefault__sstqc}"

    # Print such query.
    print_message_item "${query__sstqc}"

    # String prefixing prompt styles referenced below.
    style_prefix__sstqc='set_string_to_query_character.prompt.'

    #FIXME: Don't bother handling small terminal widths, at the moment. Ideally,
    #we should probably avoid printing the left border if the combined length of
    #such border, parens, and choices exceeds the current terminal width. But
    #this seems a mute triviality, really.

    # Prompt colors.
    color_choice_default__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_default]-}"
    color_choice_nondefault__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_nondefault]-}"

    # Prompt substrings.
    border_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}border_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}border_left]-}"
    joiner_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}joiner_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}joiner_left]-}"
    parens_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_left]-[}"
    parens_right__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_right]-] }"
    choice_separator__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_separator]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}choice_separator]-,}"
    choice_default__sstqc="${color_choice_default__sstqc}$(join_list_on_string "${list_name_choice_default__sstqc}" "${choice_separator__sstqc}${color_choice_default__sstqc}")"
    choice_nondefault__sstqc="${color_choice_nondefault__sstqc}$(join_list_on_string "${list_name_choice_nondefault__sstqc}" "${choice_separator__sstqc}${color_choice_nondefault__sstqc}")"
    choice_fork__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_fork]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}choice_fork]-/}"
    input__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}input]-}"

    # Print a prompt for user input.
    output_string_sans_newline_suffix\
        "${border_left__sstqc}${joiner_left__sstqc}${parens_left__sstqc}${choice_default__sstqc}${choice_fork__sstqc}${choice_nondefault__sstqc}${parens_right__sstqc}${input__sstqc}"

    # Block on such character and set such string.
    set_string_to_input_character "${string_name__sstqc}"

    # If such character is *NOT* a newline, print a trailing newline.
    if { not is_string_equals\
        "${(P)string_name__sstqc}" "${ZESHY_ASCII_NEWLINE}" } {
        output_newline
    }
}

#FIXME: Requires strong revision, as above.
declare_function_with_stdin <<'/---'
string set_string_to_query_line(string string_name, string question)

Set the passed string variable to a *single line* (i.e., a newline-delimited
string otherwise containing no newlines) interactively entered by the current
user, printing the passed question before receiving such input. Block until
the first newline is entered.
/---
function set_string_to_query_line() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one question.'
    die_unless_stdin_terminal
    string string_name__sstql="${1}" question__sstql="${2}"

    # Print such question.
    print_message_item "${question__sstql}"

    # Block on such line and set such string.
    set_string_to_input_line "${string_name__sstql}"
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: To eliminate redundancy, these and the styles below should simply
        #expand common string locals in an anonymous function.
#        set_string_to_query_line.prompt.border_left       blue:bold
#        set_string_to_query_line.prompt.parens_left       grey
#        set_string_to_query_line.prompt.parens_right      grey
#        set_string_to_query_line.prompt.choice_default    cyan:bold
#        set_string_to_query_line.prompt.choice_nondefault cyan:italic
#        set_string_to_query_line.prompt.choice_delimiter  grey:bold
#        set_string_to_query_line.prompt.input             white:bold

    # Print such question and get such answer.
#   set_string_to_query_character answer\
#       "${question}${choice_parens_left}${choice_nondefault}${choice_default}${choice_parens_right}"

#declare_function_with_stdin <<'/---'
#string set_string_to_query_character(
#    string string_name, string question)
#
#Set the passed string variable to a single character interactively entered by
#the current user, printing the passed question before receiving such input.
#Block until _any_ character is entered.
#/---
#function set_string_to_query_character() {
#    # Validate sanity.
#    die_unless_args_2 'expected one string name and one question'
#    die_unless_stdin_terminal
#    string string_name__ssticfq="${1}" question__ssticfq="${2}"
#
#    # Print such question.
#    print_message_sans_newline "${question__ssticfq}"
#
#    # Block on such character and set such string.
#    set_string_to_input_character "${string_name__ssticfq}"
#
#    # Print a trailing newline unless such character is a newline.
#    is_string_equals "${(P)string_name__ssticfq}" "${ZESHY_ASCII_NEWLINE}" or
#        output_newline
#}
