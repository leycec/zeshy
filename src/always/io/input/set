#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *interactive input setters* (i.e., functions setting caller-specified
variables to such input).
-/-

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
string set_string_to_query_character_for_choices_default_and_other(
    string string_name,
    string query,
    string list_name_choice_default,
    string list_name_choice_other)

Set the passed string variable to the next character interactively input by
the current user. Before blocking for such character (i.e., before requesting
such input), this function prints:

* The passed query as a message item (i.e., by calling print_message_item()).
  Assuming the length of such query is less than the width of the current
  terminal, such query will be printed on a single line terminated by a trailing
  newline.
* An input prompt consisting of the passed lists of:
** *Default choices* (i.e., the set of non-newline characters the caller assumes
   the user to have input if a newline was input).
** *Non-default choices* (i.e., the set of non-newline characters the caller
   also accepts, as alternatives to the prior default choices).

This function does _not_ enforce or test such choices. Rather, it simply prints
such choices with the appropriate `zeshy` styles configured by the current user.
Such styles are keys of both the user-configurable map ${ZESHY_STYLE_TO_COLOR}
(specifying colors to be output) and ${ZESHY_STYLE_TO_TEXT} (specifying string
literals to be output) prefixed by `set_string_to_query_character.prompt.`.
/---
function set_string_to_query_character_for_choices_default_and_other() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string name, one query, one list name of default characters, and one list name of non-default characters'
    die_unless_stdin_terminal
    string\
        string_name__sstqc="${1}"\
        query__sstqc="${2}"\
        list_name_choice_default__sstqc="${3}"\
        list_name_choice_other__sstqc="${4}"\
        style_prefix__sstqc
        border_left__sstqc\
        parens_left__sstqc\
        parens_right__sstqc\
        choice_default__sstqc\
        choice_other__sstqc\
        choice_delimiter__sstqc\
        input__sstqc
    die_unless_list list_name_choice_default__sstqc
    die_unless_list list_name_choice_other__sstqc

    # Print such question and get such answer.
    set_string_to_query_character answer\
        "${question}${choice_parens_left}${choice_other}${choice_default}${choice_parens_right}"

    # Print such query.
    print_message_item "${query__sstqc}"

    # String prefixing prompt styles referenced below.
    style_prefix__sstqc='set_string_to_query_character.prompt.'

    #FIXME: Don't bother handling small terminal widths, at the moment. Ideally,
    #we should probably avoid printing the left border if the combined length of
    #such border, parens, and choices exceeds the current terminal width. But
    #this seems a mute triviality, really.

    # Prompt substrings to be printed.
    border_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}border_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}border_left]-}"
    parens_left__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_left]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_left]-[}"
    parens_right__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}parens_right]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}parens_right]-] }"
    choice_default__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_default]-}$(join_list list_name_choice_default__sstqc)"
    choice_other__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_other]-}$(join_list list_name_choice_other__sstqc)"
    choice_delimiter__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}choice_delimiter]-}${ZESHY_STYLE_TO_TEXT[${style_prefix__sstqc}choice_delimiter]-/}"
    input__sstqc="${ZESHY_STYLE_TO_COLOR[${style_prefix__sstqc}input]-}"

    # Print a prompt for user input.
    output_string_sans_newline_suffix "${border_left__sstqc}${parens_left__sstqc}${choice_default__sstqc}${choice_delimiter__sstqc}${choice_other__sstqc}${parens_right__sstqc}${input__sstqc}"

    # Block on such character and set such string.
    set_string_to_input_character "${string_name__sstqc}"

    # If such character is *NOT* a newline, print a trailing newline.
    if { not is_string_equals\
        "${(P)string_name__sstqc}" "${ZESHY_ASCII_NEWLINE}" } {
        output_newline
    }
}

declare_function_with_stdin <<'/---'
void set_string_to_input_character(string string_name)

Set the passed string variable to a single character interactively entered by
the current user. Block until _any_ character is entered.
/---
function set_string_to_input_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_unless_stdin_terminal
    string string_name__sstic="${1}"
    die_unless_variable_string "${string_name__sstic}"

    # Block on and set such character.
    read -k -- "${string_name__sstic}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
}

declare_function_with_stdin <<'/---'
void set_string_to_input_line(string string_name)

Set the passed string variable to a *single line* (i.e., a newline-delimited
string otherwise containing no newlines) interactively entered by the current
user. Block until the first newline is entered.
/---
function set_string_to_input_line() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_unless_stdin_terminal
    string string_name__sstil="${1}"
    die_unless_variable_string "${string_name__sstil}"

    # Block on and set such string.
    read -- "${string_name__sstil}"
}

# ....................{ SETTERS ~ question                 }....................
declare_function_with_stdin <<'/---'
string set_string_to_query_line(
    string string_name, string question)

Set the passed string variable to a *single line* (i.e., a newline-delimited
string otherwise containing no newlines) interactively entered by the current
user, printing the passed question before receiving such input. Block until
the first newline is entered.
/---
function set_string_to_query_line() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one question'
    die_unless_stdin_terminal
    string string_name__ssticfq="${1}" question__ssticfq="${2}"

    # Print such question.
    print_message_sans_newline "${question__ssticfq}"

    # Block on such line and set such string.
    set_string_to_input_line "${string_name__ssticfq}"
}

# --------------------( WASTELANDS                         )--------------------
#declare_function_with_stdin <<'/---'
#string set_string_to_query_character(
#    string string_name, string question)
#
#Set the passed string variable to a single character interactively entered by
#the current user, printing the passed question before receiving such input.
#Block until _any_ character is entered.
#/---
#function set_string_to_query_character() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one string name and one question'
#    die_unless_stdin_terminal
#    string string_name__ssticfq="${1}" question__ssticfq="${2}"
#
#    # Print such question.
#    print_message_sans_newline "${question__ssticfq}"
#
#    # Block on such character and set such string.
#    set_string_to_input_character "${string_name__ssticfq}"
#
#    # Print a trailing newline unless such character is a newline.
#    is_string_equals "${(P)string_name__ssticfq}" "${ZESHY_ASCII_NEWLINE}" or
#        output_newline
#}
