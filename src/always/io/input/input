#!/usr/bin/env zsh
# ====================[ input                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle interactive standard input.

# ....................{ TESTERS                            }....................
document_function '
boolean is_input_character_y_or_Y(void)

Return true if the current user interactively enters either "y" or "Y" on
standard input.
'
function is_input_character_y_or_Y() {
    die_if_args
    die_unless_shell_interactive
    read -eq
}

# ....................{ TESTERS ~ asked                    }....................
document_function '
boolean is_input_line_YES_asked(string question)

Return false unless the current user  interactive yes or no question suffixed by "[YES/no]", returning
false unless the user responds with exactly "YES". This alternative
to is_input_character_y_or_Y_asked() is intended for questions whose confirmation may have strongly
harmful consequences (e.g., data loss).
'
function is_input_line_YES_asked() {
    # Validate passed arguments and print the passed prompt.
    die_unless_arg 'expected one question'
    die_unless_shell_interactive
    say_no_newline "${1} [YES/no] "

    # Block on newline-delimited user input.
    is_string_equals "$(input_line)" 'YES'
}

document_function '
boolean is_input_character_y_or_Y_asked(string question)

Ask the current user a yes or no question suffixed by "[yn]", returning false
unless the user responds with either "y" or "Y".
'
function is_input_character_y_or_Y_asked() {
    die_unless_arg 'expected one question'
    die_unless_shell_interactive
    say_no_newline "${1} [yn] "
    is_input_character_y_or_Y
}

# ....................{ SETTERS                            }....................
document_function '
string set_string_to_input_line(string variable_name)

Set the passed string variable to a newline-delimited string interactively
entered by the current user on standard input.
'
function set_string_to_input_line() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    die_unless_shell_interactive
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Request such line.
    read "${string_name}"
}

document_function '
string set_string_to_input_character(string variable_name)

Set the passed string variable to a single-character string interactively
entered by the current user on standard input.
'
function set_string_to_input_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    die_unless_shell_interactive
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Request such character.
    read -k "${string_name}"
}

# ....................{ INPUTTERS                          }....................
document_function '
string input_line(void)

Request the current user interactively enter a newline-delimited string on
standard input.
'
function input_line() {
    die_if_args
    die_unless_shell_interactive
    read -e
}

document_function '
string input_character(void)

Request the current user interactively enter a single-character string on
standard input.
'
function input_character() {
    die_if_args
    die_unless_shell_interactive
    read -ek
}

# ....................{ INPUTTERS ~ asked                  }....................
document_function '
void input_character_asked(string prompt = "press any key to continue.\n")

Ask the current user to type a single character. This function blocks until
the user does so and then returns true.
'
function input_character_asked() {
    # Validate passed arguments and print the passed prompt.
    die_unless_args_0_to_1 'expected optional prompt'
    die_unless_shell_interactive
    say_no_newline "${1:-press any key to continue.\n}"

    # Block on single-character user input, printing a trailing newline unless
    # the user input a newline.
    is_string_equals "$(input_character)" "${ZESHY_CHARACTER_NEWLINE}" or
        print_newline
}

# --------------------( WASTELANDS                         )--------------------
#   string answer; answer="$(input_character)"
#   is "${answer}" == '\n' si or print_newline
#   string answer; answer="$(input_line)"
#   is_string_equals "${answer}" 'YES'
#FUXME: Terrible nomenclature. No sane get_*() function blocks on user input.
#Rename to input_string() and input_character(), respectively. Simple!
# Get an interactively entered string from standard input.
# Get a string interactively entered by the current user on standard input.
