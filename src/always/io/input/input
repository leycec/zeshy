#!/usr/bin/env zsh
# ====================[ input                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle interactive standard input.

# ....................{ TESTERS                            }....................
#FIXME: Rename to is_input_yes(), in keeping with component nomenclature.
document_function '
boolean is_response_yes(void)

Block until the current user interactively enters a character, returning true if
such character is either "y" or "Y". Avoid returning such character.
'
function is_response_yes() {
    # Validate passed arguments.
    die_if_args
    die_unless_standard_input_terminal

    # Test such response. Since such response has (usually) been output to the
    # current terminal as "y" or "Y", avoid outputting such response again.
    run_command_silent read -eq
}

# ....................{ TESTERS ~ question                 }....................
#FIXME: "[yn]" is locale-specific and hence requires localization.
document_function '
boolean is_response_yes_for_question(
    string question,
    string responses = " [yn] ",
    character response_yes = "y")

Print the passed question suffixed by the passed possible responses to standard
output and block until the current user interactively enters a character,
returning true if such character case-insensitively equals the passed yes
character. If performing potentially harmful operations on
confirmation, consider calling is_response_yes_strongly_for_question() instead.
'
function is_response_yes_for_question() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional responses, and optional yes response'
    die_unless_standard_input_terminal
    string\
        question="${1}"\
        responses="${2:- ${ZESHY_COLOR[grey]}[${ZESHY_COLOR[blue]}y${ZESHY_COLOR[blue_bold]}n${ZESHY_COLOR[grey]}] }"\
        response_yes="${3:-y}"\
        response

    # Print such question and get such response.
    set_string_to_input_character_for_question\
        response "${question}${responses}"

    # Test such response.
    is_string_equals_caselessly "${response}" "${response_yes}"
}

#FIXME: "[YES/no]" is locale-specific and hence requires localization.
document_function '
boolean is_response_yes_strongly_for_question(
    string question,
    string responses = " [YES/no] ",
    string response_yes = "YES")

Print the passed question suffixed by the passed possible responses to
standard output and block until the current user interactively enters a
newline-delimited string, returning true if such string is the passed yes
response excluding delimiting newline. This "stronger" alternative to
is_response_yes_for_question() is intended for questions whose confirmation has
potentially harmful consequences (e.g., permanent data loss or corruption).
'
function is_response_yes_strongly_for_question() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional responses, and optional yes response'
    die_unless_standard_input_terminal
    string\
        question="${1}"\
        responses="${2:- ${ZESHY_COLOR[grey]}[${ZESHY_COLOR[blue]}YES${ZESHY_COLOR[grey]}/${ZESHY_COLOR[blue_bold]}no${ZESHY_COLOR[grey]}] }"\
        response_yes="${3:-YES}"\
        response

    # Print such question and get such response.
    set_string_to_input_line_for_question response "${question}${responses}"

    # Test such response.
    is_string_equals "${response}" "${response_yes}"
}

# ....................{ SETTERS                            }....................
document_function '
string set_string_to_input_line(string string_name)

Set the passed string to a newline-delimited string interactively entered by the
current user.
'
function set_string_to_input_line() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_unless_standard_input_terminal
    string string_name__sstil="${1}"
    die_unless_variable_string "${string_name__sstil}"

    # Block on and set such string.
    read "${string_name__sstil}"
}

document_function '
string set_string_to_input_character(string string_name)

Set the passed string to a character interactively entered by the current user.
'
function set_string_to_input_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_unless_standard_input_terminal
    string string_name__sstic="${1}"
    die_unless_variable_string "${string_name__sstic}"

    # Block on and set such character.
    read -k "${string_name__sstic}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
}

# ....................{ SETTERS ~ question                 }....................
document_function '
string set_string_to_input_character_for_question(
    string string_name, string question)

Print the passed question, block until the current user interactively enters a
character, and set the passed character to such character.
'
function set_string_to_input_character_for_question() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one question'
    die_unless_standard_input_terminal
    string string_name__ssticfq="${1}" question__ssticfq="${2}"

    # Print such question.
    print_message_sans_newline_suffix "${question__ssticfq}"

    # Block on such character and set such string.
    set_string_to_input_character "${string_name__ssticfq}"

    # Print a trailing newline unless such character is a newline.
    is_string_equals "${(P)string_name__ssticfq}" "${ZESHY_ASCII_NEWLINE}"\
        or print_newline
}

document_function '
string set_string_to_input_line_for_question(
    string string_name, string question)

Print the passed question, block until the current user interactively enters a
newline-delimited string, and set the passed line to such string.
'
function set_string_to_input_line_for_question() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one question'
    die_unless_standard_input_terminal
    string string_name__ssticfq="${1}" question__ssticfq="${2}"

    # Print such question.
    print_message_sans_newline_suffix "${question__ssticfq}"

    # Block on such line and set such string.
    set_string_to_input_line "${string_name__ssticfq}"
}

# ....................{ INPUTTERS                          }....................
# Due to newline-related subtleties, there intentionally exists no corresponding
# input_character(). Ideally, such function would simply run "read -rk".
# Unfortunately, "read -ek" returns a character *UNLESS* a newline was read, in
# which case it returns the empty string. Since this violates user expectations,
# set_string_to_input_character() must be called instead. Unfortunately, when
# capturing subprocess output (e.g., with "string c=$(input_character)"), zsh
# appears to silently consume not merely the last newline of output but *ALL*
# newlines suffixing such output. Hence, output captured by calling this
# function returns a character *UNLESS* a newline was read. Sounds familiar,
# doesn't it? In short, there exists no reasonable means of returning a single
# newline. While cumbersome, consider calling set_string_to_input_character()
# instead.

document_function '
string input_line(void)

Block until the current user interactively enters a newline-delimited string
and return such string.
'
function input_line() {
    # Validate sanity.
    die_if_args
    die_unless_standard_input_terminal

    # Block on and return such string.
    read -e
}

# ....................{ INPUTTERS ~ question               }....................
document_function '
void input_character_ignored_for_question(
    string question = "press any key to continue. ")

Print the passed question, block until the current user interactively enters any
character, and return the empty string. Do *NOT* return such character.
'
function input_character_ignored_for_question() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional question'
    die_unless_standard_input_terminal
    string question="${1:-${ZESHY_COLOR[cyan_bold]}press any key to continue${ZESHY_COLOR[grey]}. }"

    # Print such question.
    print_message_sans_newline_suffix "${question}"

    # Block on and set such character.
    string response; set_string_to_input_character response

    # Print a trailing newline unless such character is a newline.
    is_string_equals "${response}" "${ZESHY_ASCII_NEWLINE}" si or
        print_newline
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Hmm. O.K.; should probably be a setter to avoid such complications.
#Excise everything below. Alas!
#document_function '
#string input_character_for_question(string question)
#
#Print the passed question to standard error, block until the current user
#interactively enters a character, and return such character. (While printing
#such question to standard output would be preferable, doing so precludes
#returning such character as st
#'
#function input_character_for_question() {
#    # Validate passed arguments.
#    die_unless_args_1 'expected one question'
#    die_unless_standard_input_terminal
#
#    # Print such question to standard error.
#    run_command_into_stderr print_message_sans_newline_suffix "${1}"
#
#    # Block on and return such character, printing a trailing newline unless
#    # such character is a newline.
#    string response="$(input_character)"
#    print_string "${response}"
#    is_string_equals "${response}" "${ZESHY_ASCII_NEWLINE}" or print_newline
#}
#
#document_function '
#string input_line_for_question(string question)
#
#Print the passed question, block until the current user interactively enters any
#line, and return such line.
#'
#function input_line_for_question() {
#    # Validate passed arguments and print the passed question.
#    die_unless_args_1 'expected one question'
#    die_unless_standard_input_terminal
#    run_command_into_stderr print_message_sans_newline_suffix "${1}"
#
#    # Block on and return such line.
#    input_line
#}

#   is_string_equals "$(input_character)" "${ZESHY_ASCII_NEWLINE}" or {
#   is "$(input_character)" == "${ZESHY_ASCII_NEWLINE}" si or {
#   string response="$(input_character)"
#       print -r "response (length ${#response}): ${response}"
#       print 'printing newline'
#document_function '
#character input_character(void)
#
#Block until the current user interactively enters a character and return such
#character.
#'
#function input_character() {
#    # Validate sanity.
#    die_if_args
#    die_unless_standard_input_terminal
#
#    # Block on and set such character. Unfortunately, "read -ek" returns a
#    # character unless such character was a newline, in which case it returns
#    # the empty string. Since this violates user expectations, call
#    # set_string_to_input_character() instead.
#    string response
#    set_string_to_input_character response
#
#    # Return such character.
#    print_string "${response}"
#}
    # Block on and set such character. Unfortunately, option "-k" for builtin
    # read() returns a character unless a newline was entered, in which case
    # read() returns the empty string. Since this violates most user
    # expectations, test such return value and in the latter case return such
    # newline rather than the empty string.
#   read -k "${string_name__sstic}"

    # If empty, force such character to a newline (as discussed above).
#   print -r "response (length ${#response}): ${response}"
#   is_string_nonempty "${(P)string_name__sstic}" or
#       set_string_to_string "${string_name__sstic}" "${ZESHY_ASCII_NEWLINE}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
    # Print such question and input and test such response.
#   is_string_equals\
#       "$(input_line_for_question "${question}${responses}")"\
#       "${response_yes}"#run_command_into_stderr
    #FUXME: Should probably be die_unless_standard_input_terminal() both here
    #and below.
    #FUXME: Actually, this only applies if is_stdout_terminal(); if
    #instead this function is called as "$(is_response_yes)", then 
#   print_message_sans_newline_suffix "${question}${responses}"
    #FUXME: For type safety, define and call a new
    #is_character_equals_caselessly(). (Incidentally, we probably want not only
    #a new "character" component under "variable/string/" but a new "character"
    #type similar to our current emulation for booleans.)

#FUXME: Rename to input_character_ignored_for_question() and document the fact
#such character is squelched. Such function should simply internally call
#input_character_ignored_for_question() and throw away the result. How about:
#
#    noop "$(input_character_ignored_for_question "${1:-press any key to continue.\n}")"
    # Validate passed arguments and print the passed question.
#   die_unless_args_0_to_1 'expected optional question'
#   die_unless_standard_input_terminal
#   print_message_sans_newline_suffix "${1:-press any key to continue.\n}"

    # Block on single-character user input, printing a trailing newline unless
    # the user input a newline.
#   is_string_equals "$(input_character)" "${ZESHY_ASCII_NEWLINE}" or
#       print_newline

    # Validate passed arguments and print such prompt.
#   die_unless_arg 'expected one question'
#   die_unless_standard_input_terminal
#   print_message_sans_newline_suffix "${1} [yn] "

    # Block on single-character user input.
#   is_response_yes

#FUXME: "YES" is locale-specific and hence requires localization.
#document_function '
#boolean is_response_yes_strongly(void)
#
#Block until the current user interactively enters a newline-delimited string,
#returning true if such string is exactly "YES".
#'
#function is_response_yes_strongly() {
#    die_if_args
#    die_unless_standard_input_terminal
#    is_string_equals "$(input_line)" 'YES'
#}

    #FUXME: Generalize into a new is_response_yes_strong() function.
#Ask the current user a yes or no question , returning false
#unless the user responds with either "y" or "Y".
#Actually, that's really not
#the best nomenclature; how about request_character_for_question().
#FUXME: Rename to one of the following:
#
#* is_input_yes().
#* is_response_yes().
#* is_user_input_yes().
#* is_user_response_yes().
#
#Right. "response" is a blatantly better verb here. Since read() technically
#reads from *ANY* input stream, is_user_response_yes() isn't strictly the case.
#Hence, is_response_yes() strikes me as the ideal choice.

#   string answer; answer="$(input_character)"
#   is "${answer}" == '\n' si or print_newline
#   string answer; answer="$(input_line)"
#   is_string_equals "${answer}" 'YES'
#FUXME: Terrible nomenclature. No sane get_*() function blocks on user input.
#Rename to input_string() and input_character(), respectively. Simple!
# Get an interactively entered string from standard input.
# Get a string interactively entered by the current user on standard input.
