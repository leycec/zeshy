#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle interactive standard input.
-/-

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_string_to_input_character(string string_name)

Set the passed string variable to a single character interactively entered by
the current user. Block until _any_ character is entered.
/---
function set_string_to_input_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_unless_stdin_terminal
    string string_name__sstic="${1}"
    die_unless_variable_string "${string_name__sstic}"

    # Block on and set such character.
    read -k -- "${string_name__sstic}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
}

declare_function_with_stdin <<'/---'
void set_string_to_input_line(string string_name)

Set the passed string variable to a *single line* (i.e., a newline-delimited
string otherwise containing no newlines) interactively entered by the current
user. Block until the first newline is entered.
/---
function set_string_to_input_line() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_unless_stdin_terminal
    string string_name__sstil="${1}"
    die_unless_variable_string "${string_name__sstil}"

    # Block on and set such string.
    read -- "${string_name__sstil}"
}

# ....................{ SETTERS ~ question                 }....................
declare_function_with_stdin <<'/---'
string set_string_to_input_character_for_question(
    string string_name, string question)

Set the passed string variable to a single character interactively entered by
the current user, printing the passed question before receiving such input.
Block until _any_ character is entered.
/---
function set_string_to_input_character_for_question() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one question'
    die_unless_stdin_terminal
    string string_name__ssticfq="${1}" question__ssticfq="${2}"

    # Print such question.
    print_message_sans_newline "${question__ssticfq}"

    # Block on such character and set such string.
    set_string_to_input_character "${string_name__ssticfq}"

    # Print a trailing newline unless such character is a newline.
    is_string_equals "${(P)string_name__ssticfq}" "${ZESHY_ASCII_NEWLINE}" or
        output_newline
}

declare_function_with_stdin <<'/---'
string set_string_to_input_line_for_question(
    string string_name, string question)

Set the passed string variable to a *single line* (i.e., a newline-delimited
string otherwise containing no newlines) interactively entered by the current
user, printing the passed question before receiving such input. Block until
the first newline is entered.
/---
function set_string_to_input_line_for_question() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one question'
    die_unless_stdin_terminal
    string string_name__ssticfq="${1}" question__ssticfq="${2}"

    # Print such question.
    print_message_sans_newline "${question__ssticfq}"

    # Block on such line and set such string.
    set_string_to_input_line "${string_name__ssticfq}"
}

# ....................{ INPUTTERS                          }....................
# Due to newline-related subtleties, there intentionally exists no corresponding
# input_character(). Ideally, such function would simply run "read -rk".
# Unfortunately, "read -ek" returns a character *UNLESS* a newline was read, in
# which case it returns the empty string. Since this violates user expectations,
# set_string_to_input_character() must be called instead. Unfortunately, when
# capturing subprocess output (e.g., with "string c=$(input_character)"), zsh
# appears to silently consume not merely the last newline of output but *ALL*
# newlines suffixing such output. Hence, output captured by calling this
# function returns a character *UNLESS* a newline was read. Sounds familiar,
# doesn't it? In short, there exists no reasonable means of returning a single
# newline. While cumbersome, consider calling set_string_to_input_character()
# instead.

declare_function_with_stdin <<'/---'
string input_line(void)

Get a *single line* (i.e., a newline-delimited string otherwise containing no
newlines) interactively entered by the current user. Block until the first
newline is entered.
/---
function input_line() {
    # Validate sanity.
    die_if_args
    die_unless_stdin_terminal

    # Block on and return such string.
    read -e
}

#FIXME: Such question requires localization.
declare_function_with_stdin <<'/---'
string input_character_ignored_for_question(
    string question = "press any key to continue. ")

Print the passed question. Block until the current user interactively enters
_any_ character, but neither return or output such character.
/---
function input_character_ignored_for_question() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional question'
    die_unless_stdin_terminal
    string\
        question="${1:-${ZESHY_COLOR[cyan_bold]}press any key to continue${ZESHY_COLOR[grey]}. }"\
        response

    # Print such question.
    print_message_sans_newline "${question}"

    # Block on and set such character.
    set_string_to_input_character response

    # Print a trailing newline unless such character is a newline.
    is_string_equals "${response}" "${ZESHY_ASCII_NEWLINE}" si or output_newline
}

# --------------------( WASTELANDS                         )--------------------
#, in keeping with nomenclature.

#current user interactively enters a character equal to
#either `y` or `Y` or failure otherwise. Block until a character is entered, but
#neither return or output such character.

#Print the passed question suffixed by the passed possible responses to standard
#output and block until the current user interactively enters a character,
#returning true if such character case-insensitively equals the passed yes
#character. If performing potentially harmful operations on
#confirmation, consider calling is_input_line_yes_for_question() instead.

#Print the passed question suffixed by the passed possible responses to
#standard output and block until the current user interactively enters a
#newline-delimited string, returning success if such string is the passed yes
#response excluding delimiting newline or failure otherwise. This ``stronger''
#alternative to is_input_character_yes_for_question() is intended for questions whose
#confirmation carries potentially harmful consequences (e.g., permanent data loss
#or corruption).

#Set the passed string to a character interactively entered by the current user.
#'
#Print the passed question, block until the current user interactively enters a
#character, and set the passed character to such character.
#Print the passed question, block until the current user interactively enters a
#newline-delimited string, and set the passed line to such string.
#Block until the current user interactively enters a newline-delimited string
#return such string.

#, blocking until the current user interactively enters
#_any_ character. Neither return or output such character.

#Block until the current user interactively enters a character, returning true if
#such character is either `y` or `Y`. Avoid returning such character.

#FUXME: Hmm. O.K.; should probably be a setter to avoid such complications.
#Excise everything below. Alas!
#declare_function '
#string input_character_for_question(string question)
#
#Print the passed question to standard error, block until the current user
#interactively enters a character, and return such character. (While printing
#such question to standard output would be preferable, doing so precludes
#returning such character as st
#'
#function input_character_for_question() {
#    # Validate passed arguments.
#    die_unless_args_1 'expected one question'
#    die_unless_stdin_terminal
#
#    # Print such question to standard error.
#    run_command_into_stderr print_message_sans_newline "${1}"
#
#    # Block on and return such character, printing a trailing newline unless
#    # such character is a newline.
#    string response="$(input_character)"
#    print_string "${response}"
#    is_string_equals "${response}" "${ZESHY_ASCII_NEWLINE}" or print_newline
#}
#
#declare_function '
#string input_line_for_question(string question)
#
#Print the passed question, block until the current user interactively enters any
#line, and return such line.
#'
#function input_line_for_question() {
#    # Validate passed arguments and print the passed question.
#    die_unless_args_1 'expected one question'
#    die_unless_stdin_terminal
#    run_command_into_stderr print_message_sans_newline "${1}"
#
#    # Block on and return such line.
#    input_line
#}

#   is_string_equals "$(input_character)" "${ZESHY_ASCII_NEWLINE}" or {
#   is "$(input_character)" == "${ZESHY_ASCII_NEWLINE}" si or {
#   string response="$(input_character)"
#       print -r "response (length ${#response}): ${response}"
#       print 'printing newline'
#declare_function '
#character input_character(void)
#
#Block until the current user interactively enters a character and return such
#character.
#'
#function input_character() {
#    # Validate sanity.
#    die_if_args
#    die_unless_stdin_terminal
#
#    # Block on and set such character. Unfortunately, "read -ek" returns a
#    # character unless such character was a newline, in which case it returns
#    # the empty string. Since this violates user expectations, call
#    # set_string_to_input_character() instead.
#    string response
#    set_string_to_input_character response
#
#    # Return such character.
#    print_string "${response}"
#}
    # Block on and set such character. Unfortunately, option "-k" for builtin
    # read() returns a character unless a newline was entered, in which case
    # read() returns the empty string. Since this violates most user
    # expectations, test such return value and in the latter case return such
    # newline rather than the empty string.
#   read -k "${string_name__sstic}"

    # If empty, force such character to a newline (as discussed above).
#   print -r "response (length ${#response}): ${response}"
#   is_string_nonempty "${(P)string_name__sstic}" or
#       set_string_to_string "${string_name__sstic}" "${ZESHY_ASCII_NEWLINE}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
    # Print such question and input and test such response.
#   is_string_equals\
#       "$(input_line_for_question "${question}${responses}")"\
#       "${response_yes}"#run_command_into_stderr
    #FUXME: Should probably be die_unless_stdin_terminal() both here
    #and below.
    #FUXME: Actually, this only applies if is_stdout_terminal(); if
    #instead this function is called as "$(is_input_character_yes)", then 
#   print_message_sans_newline "${question}${responses}"
    #FUXME: For type safety, define and call a new
    #is_character_equals_caselessly(). (Incidentally, we probably want not only
    #a new "character" component under "variable/string/" but a new "character"
    #type similar to our current emulation for booleans.)

#FUXME: Rename to input_character_ignored_for_question() and document the fact
#such character is squelched. Such function should simply internally call
#input_character_ignored_for_question() and throw away the result. How about:
#
#    noop "$(input_character_ignored_for_question "${1:-press any key to continue.\n}")"
    # Validate passed arguments and print the passed question.
#   die_unless_args_0_to_1 'expected optional question'
#   die_unless_stdin_terminal
#   print_message_sans_newline "${1:-press any key to continue.\n}"

    # Block on single-character user input, printing a trailing newline unless
    # the user input a newline.
#   is_string_equals "$(input_character)" "${ZESHY_ASCII_NEWLINE}" or
#       print_newline

    # Validate passed arguments and print such prompt.
#   die_unless_arg 'expected one question'
#   die_unless_stdin_terminal
#   print_message_sans_newline "${1} [yn] "

    # Block on single-character user input.
#   is_input_character_yes

#FUXME: "YES" is locale-specific and hence requires localization.
#declare_function '
#boolean is_input_character_yes_strongly(void)
#
#Block until the current user interactively enters a newline-delimited string,
#returning true if such string is exactly "YES".
#'
#function is_input_character_yes_strongly() {
#    die_if_args
#    die_unless_stdin_terminal
#    is_string_equals "$(input_line)" 'YES'
#}

    #FUXME: Generalize into a new is_input_character_yes_strong() function.
#Ask the current user a yes or no question , returning false
#unless the user responds with either "y" or "Y".
#Actually, that's really not
#the best nomenclature; how about request_character_for_question().
#FUXME: Rename to one of the following:
#
#* is_input_yes().
#* is_input_character_yes().
#* is_user_input_yes().
#* is_user_response_yes().
#
#Right. "response" is a blatantly better verb here. Since read() technically
#reads from *ANY* input stream, is_user_response_yes() isn't strictly the case.
#Hence, is_input_character_yes() strikes me as the ideal choice.

#   string answer; answer="$(input_character)"
#   is "${answer}" == '\n' si or print_newline
#   string answer; answer="$(input_line)"
#   is_string_equals "${answer}" 'YES'
#FUXME: Terrible nomenclature. No sane get_*() function blocks on user input.
#Rename to input_string() and input_character(), respectively. Simple!
# Get an interactively entered string from standard input.
# Get a string interactively entered by the current user on standard input.
