#!/usr/bin/env zsh
# ====================[ input                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle interactive standard input.

# ....................{ TESTERS                            }....................
document_function '
boolean is_response_yes(void)

Block until the current user interactively enters a character, returning true if
such character is either "y" or "Y".
'
function is_response_yes() {
    die_if_args
    die_unless_shell_interactive
    read -eq
}

# ....................{ TESTERS ~ question                 }....................
#FIXME: "[yn]" is locale-specific and hence requires localization.
document_function '
boolean is_response_yes_for_question(
    string question,
    string responses = " [yn] ",
    character response_yes = "y")

Print the passed question suffixed by the passed possible responses to standard
output and block until the current user interactively enters a character,
returning true if such character case-insensitively equals the passed yes
character. If performing potentially harmful operations on
confirmation, consider calling is_response_yes_strongly_for_question() instead.
'
function is_response_yes_for_question() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional responses, and optional yes response'
    die_unless_shell_interactive
    string\
        question="${1}"\
        responses="${2:- [YES/no] }"\
        response_yes="${3:-y}"
#   say_nonnewlined "${question}${responses}"

    # Print such question and input and test such response.
    is_string_equals_caselessly\
        "$(input_character_for_question "${question}${responses}")"\
        "${response_yes}"
}

#FIXME: "[YES/no]" is locale-specific and hence requires localization.
document_function '
boolean is_response_yes_strongly_for_question(
    string question,
    string responses = " [YES/no] ",
    string response_yes = "YES")

Print the passed question suffixed by the passed possible responses to
standard output and block until the current user interactively enters a
newline-delimited string, returning true if such string is the passed yes
response excluding delimiting newline. This "stronger" alternative to
is_response_yes_for_question() is intended for questions whose confirmation has
potentially harmful consequences (e.g., permanent data loss or corruption).
'
function is_response_yes_strongly_for_question() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one question, optional responses, and optional yes response'
    die_unless_shell_interactive
    string\
        question="${1}"\
        responses="${2:- [YES/no] }"\
        response_yes="${3:-YES}"

    # Print such question and input and test such response.
    is_string_equals\
        "$(input_line_for_question "${question}${responses}")"\
        "${response_yes}"
}

# ....................{ SETTERS                            }....................
document_function '
string set_string_to_input_line(string variable_name)

Set the passed variable to the next newline-delimited string interactively
entered by the current user.
'
function set_string_to_input_line() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    die_unless_shell_interactive
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Input such line.
    read "${string_name}"
}

document_function '
string set_string_to_input_character(string variable_name)

Set the passed variable to the next character interactively entered by the
current user.
'
function set_string_to_input_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    die_unless_shell_interactive
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Input such character.
    read -k "${string_name}"
}

# ....................{ INPUTTERS                          }....................
document_function '
string input_character(void)

Block until the current user interactively enters a character.
'
function input_character() {
    die_if_args
    die_unless_shell_interactive
    read -ek
}

document_function '
string input_line(void)

Block until the current user interactively enters a newline-delimited string.
'
function input_line() {
    die_if_args
    die_unless_shell_interactive
    read -e
}

# ....................{ INPUTTERS ~ question               }....................
document_function '
string input_character_for_question(string question)

Print the passed question, block until the current user interactively enters any
character, and return such character.
'
function input_character_for_question() {
    # Validate passed arguments and print the passed question.
    die_unless_args_1 'expected one question'
    die_unless_shell_interactive
    say_nonnewlined "${1}"

    # Block on and return such character, printing a trailing newline unless
    # such character is a newline.
    string response="$(input_character)"
    print_string "${response}"
    is_string_equals "${response}" "${ZESHY_CHARACTER_NEWLINE}" or print_newline
}

document_function '
void input_character_ignored_for_question(
    string question = "press any key to continue.\n")

Print the passed question, block until the current user interactively enters any
character, and return the empty string (i.e., *NOT* returning such character).
'
function input_character_ignored_for_question() {
    die_unless_args_0_to_1 'expected optional question'
    string question="${1:-press any key to continue.\n}"
    noop "$(input_character_for_question "${question}")"
}

document_function '
string input_line_for_question(string question)

Print the passed question, block until the current user interactively enters any
line, and return such line.
'
function input_line_for_question() {
    # Validate passed arguments and print the passed question.
    die_unless_args_1 'expected one question'
    die_unless_shell_interactive
    say_nonnewlined "${1}"

    # Block on and return such line.
    input_line
}

# --------------------( WASTELANDS                         )--------------------
#   say_nonnewlined "${question}${responses}"
    #FUXME: For type safety, define and call a new
    #is_character_equals_caselessly(). (Incidentally, we probably want not only
    #a new "character" component under "variable/string/" but a new "character"
    #type similar to our current emulation for booleans.)

#FUXME: Rename to input_character_ignored_for_question() and document the fact
#such character is squelched. Such function should simply internally call
#input_character_ignored_for_question() and throw away the result. How about:
#
#    noop "$(input_character_ignored_for_question "${1:-press any key to continue.\n}")"
    # Validate passed arguments and print the passed question.
#   die_unless_args_0_to_1 'expected optional question'
#   die_unless_shell_interactive
#   say_nonnewlined "${1:-press any key to continue.\n}"

    # Block on single-character user input, printing a trailing newline unless
    # the user input a newline.
#   is_string_equals "$(input_character)" "${ZESHY_CHARACTER_NEWLINE}" or
#       print_newline

    # Validate passed arguments and print such prompt.
#   die_unless_arg 'expected one question'
#   die_unless_shell_interactive
#   say_nonnewlined "${1} [yn] "

    # Block on single-character user input.
#   is_response_yes

#FUXME: "YES" is locale-specific and hence requires localization.
#document_function '
#boolean is_response_yes_strongly(void)
#
#Block until the current user interactively enters a newline-delimited string,
#returning true if such string is exactly "YES".
#'
#function is_response_yes_strongly() {
#    die_if_args
#    die_unless_shell_interactive
#    is_string_equals "$(input_line)" 'YES'
#}

    #FUXME: Generalize into a new is_response_yes_strong() function.
#Ask the current user a yes or no question , returning false
#unless the user responds with either "y" or "Y".
#Actually, that's really not
#the best nomenclature; how about request_character_for_question().
#FUXME: Rename to one of the following:
#
#* is_input_yes().
#* is_response_yes().
#* is_user_input_yes().
#* is_user_response_yes().
#
#Right. "response" is a blatantly better verb here. Since read() technically
#reads from *ANY* input stream, is_user_response_yes() isn't strictly the case.
#Hence, is_response_yes() strikes me as the ideal choice.

#   string answer; answer="$(input_character)"
#   is "${answer}" == '\n' si or print_newline
#   string answer; answer="$(input_line)"
#   is_string_equals "${answer}" 'YES'
#FUXME: Terrible nomenclature. No sane get_*() function blocks on user input.
#Rename to input_string() and input_character(), respectively. Simple!
# Get an interactively entered string from standard input.
# Get a string interactively entered by the current user on standard input.
