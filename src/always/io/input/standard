#!/usr/bin/env zsh
# ====================[ standard                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle standard input.
#
# --------------------( CAVEATS                            )--------------------
# Since standard file descriptors are shell-specific, avoid calling functions
# defined by this component from a subshell; rather, only call such functions
# from the current shell.
#
# Calling functions defined by this component from a subshell fails to close the
# corresponding file descriptor in the current shell; subsequent commands in the
# current shell thus erroneously see such descriptor as an open file when in
# fact such file is empty and should have been closed. To amend this, always
# call close_standard_input() when calling such functions from a subshell.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_standard_input_piped(
#   string error_message = '"/dev/stdin" not an open pipe')
#
# Throw an exception unless standard input to the current shell is a pipe.
function die_unless_standard_input_piped() {
    die_unless_args_0_to_1 'expected optional error message'
    is_standard_input_piped or die "${1:-\"/dev/stdin\" not an open pipe}"
}

# void die_unless_standard_input_readable(
#   string error_message = '"/dev/stdin" not openly readable')
#
# Throw an exception unless standard input to the current shell is open and
# readable.
function die_unless_standard_input_readable() {
    die_unless_args_0_to_1 'expected optional error message'
    is_standard_input_readable or
        die "${1:-\"/dev/stdin\" not openly readable}"
}

# ....................{ TESTERS                            }....................
# boolean is_standard_input_piped(void)
#
# Return true if standard input to the current shell is a pipe. Equivalently,
# return true if the current shell is a pipeline-specific subshell.
function is_standard_input_piped() {
    die_if_args
    is -p /dev/stdin si
}

# boolean is_standard_input_readable(void)
#
# Return true if standard input to the current shell is open and readable.
function is_standard_input_readable() {
    die_if_args
    is -r /dev/stdin si
}

# ....................{ GETTERS                            }....................
# void get_standard_input_piped(void)
#
# Get standard input piped to the current shell. Since subshells do not inherit
# piped input, *AVOID CALLING THIS FUNCTION FROM A SUBSHELL* (e.g., as
# "$(get_standard_input_piped)"). Consider calling is_standard_input_piped() before calling this
# function to test whether or not such input exists: e.g.,
#
#     >>> pachamama() {
#     ...     if is_standard_input_piped
#     ...     then get_standard_input_piped
#     ...     else print_string "${@}"
#     ...     fi
#     ... }
#     >>> print_string tawantinsuyu | pachamama
#     tawantinsuyu
#     >>> pachamama tawantinsuyu
#     tawantinsuyu
function get_standard_input_piped() {
    # Validate sanity.
    die_if_args
    die_unless_standard_input_piped

    # Get all output previously written to piped standard input.
    command cat /dev/stdin

    # Close such pipe, ensuring is_standard_input_piped() now returns false.
    close_standard_input
}

# --------------------( WASTELANDS                         )--------------------
# Handle traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_standard_input() after calling piped input functions in a
#   subshell.

#FUXME: This component doesn't really belong here. A common component named
#"standard_input" elsewhere is a much better fit.

#such shell is running any command after the first in a pipe.
# ....................{ SETTERS                            }....................
#FUXME: Silly. Clearly, a vestige from when we thought we needed such
#functionality as an alias. Cut everywhere.
# void set_string_to_standard_input_piped(string variable_name)
#
# Set the variable with the passed name to all standard input piped to the
# current shell. Consider calling is_standard_input_piped() before calling this function
# to test whether or not such input exists: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if is_standard_input_piped
#     ...     then set_string_to_standard_input_piped hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     print_string ${hojas}
#     ... }
#     >>> print_string pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#function set_string_to_standard_input_piped() {
#    # Validate passed arguments.
#    die_unless_args_1 'expected one variable name'
#    die_unless_standard_input_piped
#    string string_name="${1}"
#    die_unless_string "${string_name}"
#
#    # Capture piped input into the passed variable.
#    set_string ${string_name} "$(< /dev/stdin)"
#
#    # Close standard input, ensuring is_standard_input_piped() now returns false.
#    close_standard_input
#}

#   string piped_input
#   set_string_to_standard_input_piped piped_input
#   print_string "${piped_input}"
# ....................{ RUNNERS                            }....................
# string call_with_piped_input(
#   string function_name, string function_arg1, string function_arg1, ...)
#
# Call the passed function by piping the standard input piped to the current
# function or script to such function.
#
# In theory, run_with_piped_input() subsumes this function's functionality;
# in practice, run_with_piped_input() requires function arguments be quote
# protected and hence is more cumbersome to call than this function. Prefer this function calling run_with_piped_input() when calling functions with quoted arguments,
#call_with_piped_input() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_standard_input_piped() now returns false.
#    close_standard_input
#}

# string run_with_piped_input(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_standard_input_piped() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     is_standard_input_piped and run_with_piped_input cat or print_string "${@}" cat
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
#run_with_piped_input() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_standard_input_piped() now returns false.
#    close_standard_input
#}

    #FUXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)
#   noop ${(P)string_name::=$(< /dev/stdin)}
#   noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}="$(< /dev/stdin)"

#FUXME: Rename set_with_piped_input(), coinciding with run_with_piped_input().
#FUXME: No reason this can't also be made a run-style function. It should call
#close_standard_input(), as expected.
#   exec 0<&-
#FUXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_standard_input(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_standard_input() {
#    die_if_args
#    exec 0<&-
#}

# void close_standard_output(void)
#
# Close the standard print_string file descriptor (1) and named pipe ("/dev/stdout").
#close_standard_output() {
#    die_if_args
#    exec 1>&-
#}

# void close_standard_error(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_standard_error() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";
