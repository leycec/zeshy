#!/usr/bin/env zsh
# ====================[ ascii                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the ASCII (American Standard Code for Information Interchange)
# encoding.

# ....................{ GLOBALS                            }....................
# Character constants to be interpolated into unprinted strings (e.g., globs,
# regular expressions). zsh interprets escaped characters such as \n (newline)
# and \t (tab) as "special" only when passed to the echo() or print() builtins;
# in all other cases, zsh passes such characters as is (i.e., without
# interpretation) through to the underlying builtins. Embedding such characters
# in $'...'-style quotes (as below) circumvents this, inducing zsh to interpret
# such characters regardless of which builtin finally receives them.

#FIXME: Rename to ${ZESHY_ASCII_NEWLINE}.
document_global '
character ZESHY_CHARACTER_NEWLINE

Newline character. While builtins echo() and print() do recognize "\n" as a
newline, all other cases require cumbersome $''\n''-style expressions. This
global obviates such awkwardness.
'
ZESHY_CHARACTER_NEWLINE=$'\n'

#FIXME: Rename to ${ZESHY_ASCII_TAB}.
document_global '
character ZESHY_CHARACTER_TAB

Tab character. While builtins echo() and print() do recognize "\t" as a
newline, all other cases require cumbersome $''\t''-style expressions. This
global obviates such awkwardness.
'
ZESHY_CHARACTER_TAB=$'\t'

# ....................{ GLOBALS ~ list                     }....................
#FIXME: Rename to ${ZESHY_ASCII_PRINTABLES_PHYSICAL}.
document_global '
list ZESHY_CHARACTERS_ASCII_PHYSICAL

List of all physical ASCII characters (i.e., all printable ASCII characters
excluding space, and hence characters 0x21 through 0x70 in hexadecimal).
'

# ....................{ MAKERS                             }....................
append_make_zeshy_command make_zeshy_encoding_ascii

document_function '
void make_zeshy_encoding_ascii(void)

Define ASCII-specific globals to be compiled into Zeshy''s user digest file.
'
function make_zeshy_encoding_ascii() {
    # Validate sanity.
    die_if_args

    #FIXME: Implement a for loop on integers from 0x21 to 0x70, basically
    #calling convert_hexadecimal_to_character() on each iteration. For
    #efficiency, we'll probably have to implement
    #convert_hexadecimal_to_character() manually in such loop. If memory serves,
    #however, this should be painlessly easy. Huh-a!
#   ZESHY_CHARACTERS_ASCII_PHYSICAL+=
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: "man zshexpn" suggests "Any character, or the matching pairs `(...)',
#`{...}', `[...]', or `<...>', may be used in place of a colon as delimiters,
#...". Note the "Any character." Is this genuinely the case? O.K.; right. Yes,
#actually! However, when braces are used, they *MUST* be paired (i.e., one can't
#write "${(j(:()list}"). To simplify use, set this list to *ALL* printable ASCII
#characters excluding brace characters. To do so, it may be instructive to
#define a make_zeshy_*() function executed at compile time. Contemplate.
#FUXME: Actually... no. Just use all printable ASCII characters. Rename this to
#ZESHY_CHARACTERS_ASCII_PRINTABLE, and away we go.
#List of all possible parameter expansion delimiter characters (e.g., the ":" in
#"${(l:42::~:)the_answer_to_the_ultimate_question_of_life}").
#'
#ZESHY_PARAMETER_EXPANSION_DELIMITERS=(
#    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '-' '^' '&' '*'
#    '-' '_' '\' '|' '/' '?'
#)
