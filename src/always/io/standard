#!/usr/bin/env zsh
# ====================[ standard                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle standard input and output.
#
# --------------------( CAVEATS                            )--------------------
# Standard file descriptors are shell-specific. Hence, avoid calling functions
# operating on such descriptors from subshells. Since doing so fails to both
# operate on and close the expected descriptor in the current shell, subsequent
# commands run by such shell erroneously perceive such descriptor to be open
# after having been closed under the subshell.

# ....................{ EXCEPTIONS ~ input                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void {die_if_stdin_empty, die_unless_stdin_nonempty}(
    string error_message = "expected standard input")

Throw an exception with the passed message unless standard input for the current
shell is non-empty. See is_stdin_nonempty() for further details.
________________<heredoc?>________________
function die_if_stdin_empty die_unless_stdin_nonempty() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdin_nonempty or die "${1:-expected standard input}"
}

#FIXME: Rename to die_unless_stdin_pipe(). Or perhaps not. Search for similar
#nomenclature elsewhere.
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_stdin_piped(
    string error_message = "expected piped standard input")

Throw an exception with the passed message unless standard input to the current
shell is a pipe. See is_stdin_piped() for further details.
________________<heredoc?>________________
function die_unless_stdin_piped() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdin_piped or die "${1:-expected piped standard input}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_stdin_terminal(
    string error_message = "expected standard input read from a terminal")

Throw an exception with the passed message unless standard input for the current
shell is a terminal. See is_stdin_terminal() for further details.
________________<heredoc?>________________
function die_unless_stdin_terminal() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdin_terminal or
        die "${1:-expected standard input read from a terminal}"
}

# ....................{ EXCEPTIONS ~ output                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_stdout_terminal(
    string error_message = "expected standard output printing to a terminal")

Throw an exception with the passed message unless standard output for the
current shell is a terminal. See is_stdout_terminal() for further details.
________________<heredoc?>________________
function die_unless_stdout_terminal() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdout_terminal or
        die "${1:-expected standard output printing to a terminal}"
}

# ....................{ TESTERS ~ input                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_stdin_nonempty(void)

Return true if standard input to the current shell is non-empty (i.e., if
standard input currently contains at least one character to be read). Consider
calling either this function or die_if_stdin_empty() before reading
from standard input; if such input is empty, zsh quietly blocks when reading
from standard input. This is usually unexpected and hence Bad (TM).
________________<heredoc?>________________
function is_stdin_nonempty() {
    # If standard input to the current shell is written to via file descriptor
    # "/dev/stdin", "read -t 0" returns true without blocking on or consuming
    # such input; else, such command returns false. Since such input may have
    # been piped to such shell instead, running only such command does *NOT*
    # suffice to prove no such input. Thus, also test for piped standard input.
    die_if_args
    read -t 0 or is_stdin_piped
}

#FIXME: Rename to is_stdin_pipe().
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_stdin_piped(void)

Return true if standard input to the current shell is a pipe (i.e., if the
current shell is a pipeline-specific subshell).
________________<heredoc?>________________
function is_stdin_piped() {
    die_if_args
    is -p "${ZESHY_STDIN_PATH}" si
}

# ....................{ TESTERS ~ terminal                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_stdin_terminal(void)

Return true if the current shell's standard input is attached to a terminal.
________________<heredoc?>________________
function is_stdin_terminal() {
    die_if_args
    is -t 0 si
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_stdout_terminal(void)

Return true if the current shell's standard output is attached to a terminal.
________________<heredoc?>________________
function is_stdout_terminal() {
    die_if_args
    is -t 1 si
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_stdout_terminal_or_pipe(void)

Return true if the current shell's standard output is attached to either a
terminal or pipe (e.g., to page_stdin()).
________________<heredoc?>________________
function is_stdout_terminal_or_pipe() {
    die_if_args
    is -t 1 or -p "${ZESHY_STDOUT_PATH}" si
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_stderr_terminal(void)

Return true if the current shell's standard error is attached to a terminal.
________________<heredoc?>________________
function is_stderr_terminal() {
    die_if_args
    is -t 2 si
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_string_to_stdin[args: string string_name, stdin: string input]

Set the passed string to standard input: e.g.,

.set_string_to_stdin()
==========================================
[source]
------------------------------------------
>>> string the_apostle
>>> set_string_to_stdin the_apostle <<<'in triumph'
>>> print_string "${the_apostle}"
in triumph
------------------------------------------
==========================================

Since subshells do _not_ inherit parent shell file descriptors, there exists no
convenience alias or function get_stdin().
________________<heredoc?>________________
function set_string_to_stdin() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_if_stdin_empty

    # Set such string.
    set_string_to_string "${1}" "$(< "${ZESHY_STDIN_PATH}")"

    # Close such input, ensuring is_stdin_nonempty() subsequently returns false.
    close_stdin
}

# --------------------( WASTELANDS                         )--------------------
#Since subshells do _not_ inherit file descriptors from their parent shell, there
#exists no corresponding get_
#   string string_name__ssts="${1}"
#   die_unless_string "${string_name__ssts}"
# Avoid calling functions
# operating on such descriptors from subshells.
#
# Calling functions defined by this component from a subshell fails to close the
# corresponding file descriptor in the current shell; subsequent commands in the
# current shell thus erroneously see such descriptor as an open file when in
# fact such file is empty and should have been closed. To amend this, always
# call close_stdin() when calling such functions from a subshell.
# rather, only call such functions
# from the current shell#
#FUXME: Poorly named function, since it should never be called as a conventional
#getter. Rename to print_stdin(). Not sure we require the "_piped"
#distinction, yes? In which case, excise the call to
#die_unless_stdin_piped() below.

# Handle traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_stdin() after calling piped input functions in a
#   subshell.

#FUXME: This component doesn't really belong here. A common component named
#"standard_input" elsewhere is a much better fit.

#such shell is running any command after the first in a pipe.
# ....................{ SETTERS                            }....................
#FUXME: Silly. Clearly, a vestige from when we thought we needed such
#functionality as an alias. Cut everywhere.
# void set_string_to_stdin_piped(string variable_name)
#
# Set the variable with the passed name to all standard input piped to the
# current shell. Consider calling is_stdin_piped() before calling this function
# to test whether or not such input exists: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if is_stdin_piped
#     ...     then set_string_to_stdin_piped hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     print_string ${hojas}
#     ... }
#     >>> print_string pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#function set_string_to_stdin_piped() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one variable name'
#    die_unless_stdin_piped
#    string string_name="${1}"
#    die_unless_variable_string "${string_name}"
#
#    # Capture piped input into the passed variable.
#    set_string_to_string ${string_name} "$(< /dev/stdin)"
#
#    # Close standard input, ensuring is_stdin_piped() now returns false.
#    close_stdin
#}

#   string piped_input
#   set_string_to_stdin_piped piped_input
#   print_string "${piped_input}"
# ....................{ RUNNERS                            }....................
# string call_with_piped_input(
#   string function_name, string function_arg1, string function_arg1, ...)
#
# Call the passed function by piping the standard input piped to the current
# function or script to such function.
#
# In theory, run_command_with_stdin_piped() subsumes this function's functionality;
# in practice, run_command_with_stdin_piped() requires function arguments be quote
# protected and hence is more cumbersome to call than this function. Prefer this function calling run_command_with_stdin_piped() when calling functions with quoted arguments,
#call_with_piped_input() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_stdin_piped() now returns false.
#    close_stdin
#}

# string run_command_with_stdin_piped(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_stdin_piped() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     is_stdin_piped and run_command_with_stdin_piped cat or print_string "${@}" cat
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
#run_command_with_stdin_piped() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_stdin_piped() now returns false.
#    close_stdin
#}

    #FUXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)
#   noop ${(P)string_name::=$(< /dev/stdin)}
#   noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}="$(< /dev/stdin)"

#FUXME: Rename set_with_piped_input(), coinciding with run_command_with_stdin_piped().
#FUXME: No reason this can't also be made a run-style function. It should call
#close_stdin(), as expected.
#   exec 0<&-
#FUXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_stdin(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_stdin() {
#    die_if_args
#    exec 0<&-
#}

# void close_stdout(void)
#
# Close the standard print_string file descriptor (1) and named pipe ("/dev/stdout").
#close_stdout() {
#    die_if_args
#    exec 1>&-
#}

# void close_stderr(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_stderr() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";
