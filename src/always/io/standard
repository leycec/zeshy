#!/usr/bin/env zsh
# ====================[ standard                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle standard input and output.
#
# --------------------( CAVEATS                            )--------------------
# Standard file descriptors are shell-specific. Hence, avoid calling functions
# operating on such descriptors from subshells. Since doing so fails to both
# operate on and close the expected descriptor in the current shell, subsequent
# commands run by such shell erroneously perceive such descriptor to be open
# after having been closed under the subshell.

# ....................{ EXCEPTIONS ~ input                 }....................
document_function '
void die_if_standard_input_empty(
  string error_message = "\"/dev/stdin\" empty")

Throw an exception unless standard input to the current shell is non-empty. See
is_standard_input_nonempty() for further details.
'
function die_if_standard_input_empty() {
    die_unless_args_0_to_1 'expected optional error message'
    is_standard_input_nonempty or die "${1:-\"/dev/stdin\" empty}"
}

document_function '
void die_unless_standard_input_piped(
  string error_message = "\"/dev/stdin\" not an open pipe")

Throw an exception unless standard input to the current shell is a pipe. See
is_standard_input_piped() for further details.
'
function die_unless_standard_input_piped() {
    die_unless_args_0_to_1 'expected optional error message'
    is_standard_input_piped or die "${1:-\"/dev/stdin\" not an open pipe}"
}

document_function '
void die_unless_standard_input_terminal(
  string error_message = "current shell not reading from a terminal")

Throw an exception unless standard input to the current shell is a terminal.
'
function die_unless_standard_input_terminal() {
    die_unless_args_0_to_1 'expected optional error message'
    is_standard_input_terminal or
        die "${1:-current shell not reading from a terminal}"
}

# ....................{ EXCEPTIONS ~ output                }....................
document_function '
void die_unless_standard_output_terminal(
  string error_message = "current shell not printing to a terminal")

Throw an exception unless standard output to the current shell is a terminal.
'
function die_unless_standard_output_terminal() {
    die_unless_args_0_to_1 'expected optional error message'
    is_standard_output_terminal or
        die "${1:-current shell not printing to a terminal}"
}

# ....................{ TESTERS ~ input                    }....................
document_function '
boolean is_standard_input_nonempty(void)

Return true if standard input to the current shell is non-empty (i.e., if
standard input currently contains at least one character to be read). Consider
calling either this function or die_if_standard_input_empty() before reading
from standard input; if such input is empty, zsh quietly blocks when reading
from standard input. This is usually unexpected and hence Bad (TM).
'
function is_standard_input_nonempty() {
    # Helpfully, "read -t 0" returns such boolean without blocking on or
    # consuming such input. (Viva la zsh!)
    die_if_args
    read -t ${ZESHY_FILE_DESCRIPTOR_STANDARD_INPUT}
}

document_function '
boolean is_standard_input_piped(void)

Return true if standard input to the current shell is a pipe (i.e., if the
current shell is a pipeline-specific subshell).
'
function is_standard_input_piped() {
    die_if_args
    is -p /dev/stdin si
}

document_function '
boolean is_standard_input_terminal(void)

Return true if standard input for the current shell is a terminal.
'
function is_standard_input_terminal() {
    die_if_args
    is -t ${ZESHY_FILE_DESCRIPTOR_STANDARD_INPUT} si
}

# ....................{ TESTERS ~ output                   }....................
document_function '
boolean is_standard_output_terminal(void)

Return true if standard output for the current shell is a terminal.
'
function is_standard_output_terminal() {
    die_if_args
    is -t ${ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT} si
}

# ....................{ GETTERS                            }....................
document_function '
void print_standard_input(void)

Get standard input piped to the current shell. Since subshells do not inherit
piped input, *AVOID CALLING THIS FUNCTION FROM A SUBSHELL* (e.g., as
"$(get_standard_input_piped)"). Consider calling is_standard_input_nonempty()
before calling this function to ensure such input exists: e.g.,

  >>> function pachamama() {
  ...     if is_standard_input_nonempty
  ...     then print_standard_input
  ...     else print_string "${@}"
  ...     fi
  ... }
  >>> print_string tawantinsuyu | pachamama
  tawantinsuyu
  >>> pachamama tawantinsuyu
  tawantinsuyu
'
function print_standard_input() {
    # Validate sanity.
    die_if_args
    die_if_standard_input_empty

    # Print such input.
    command cat /dev/stdin

    # Close such input, ensuring is_standard_input_*() functions return false.
    close_standard_input
}

# --------------------( WASTELANDS                         )--------------------
# Avoid calling functions
# operating on such descriptors from subshells.
#
# Calling functions defined by this component from a subshell fails to close the
# corresponding file descriptor in the current shell; subsequent commands in the
# current shell thus erroneously see such descriptor as an open file when in
# fact such file is empty and should have been closed. To amend this, always
# call close_standard_input() when calling such functions from a subshell.
# rather, only call such functions
# from the current shell#
#FUXME: Poorly named function, since it should never be called as a conventional
#getter. Rename to print_standard_input(). Not sure we require the "_piped"
#distinction, yes? In which case, excise the call to
#die_unless_standard_input_piped() below.

# Handle traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_standard_input() after calling piped input functions in a
#   subshell.

#FUXME: This component doesn't really belong here. A common component named
#"standard_input" elsewhere is a much better fit.

#such shell is running any command after the first in a pipe.
# ....................{ SETTERS                            }....................
#FUXME: Silly. Clearly, a vestige from when we thought we needed such
#functionality as an alias. Cut everywhere.
# void set_string_to_standard_input_piped(string variable_name)
#
# Set the variable with the passed name to all standard input piped to the
# current shell. Consider calling is_standard_input_piped() before calling this function
# to test whether or not such input exists: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if is_standard_input_piped
#     ...     then set_string_to_standard_input_piped hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     print_string ${hojas}
#     ... }
#     >>> print_string pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#function set_string_to_standard_input_piped() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one variable name'
#    die_unless_standard_input_piped
#    string string_name="${1}"
#    die_unless_string "${string_name}"
#
#    # Capture piped input into the passed variable.
#    set_string ${string_name} "$(< /dev/stdin)"
#
#    # Close standard input, ensuring is_standard_input_piped() now returns false.
#    close_standard_input
#}

#   string piped_input
#   set_string_to_standard_input_piped piped_input
#   print_string "${piped_input}"
# ....................{ RUNNERS                            }....................
# string call_with_piped_input(
#   string function_name, string function_arg1, string function_arg1, ...)
#
# Call the passed function by piping the standard input piped to the current
# function or script to such function.
#
# In theory, run_with_standard_input_piped() subsumes this function's functionality;
# in practice, run_with_standard_input_piped() requires function arguments be quote
# protected and hence is more cumbersome to call than this function. Prefer this function calling run_with_standard_input_piped() when calling functions with quoted arguments,
#call_with_piped_input() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_standard_input_piped() now returns false.
#    close_standard_input
#}

# string run_with_standard_input_piped(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_standard_input_piped() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     is_standard_input_piped and run_with_standard_input_piped cat or print_string "${@}" cat
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
#run_with_standard_input_piped() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_standard_input_piped() now returns false.
#    close_standard_input
#}

    #FUXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)
#   noop ${(P)string_name::=$(< /dev/stdin)}
#   noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}="$(< /dev/stdin)"

#FUXME: Rename set_with_piped_input(), coinciding with run_with_standard_input_piped().
#FUXME: No reason this can't also be made a run-style function. It should call
#close_standard_input(), as expected.
#   exec 0<&-
#FUXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_standard_input(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_standard_input() {
#    die_if_args
#    exec 0<&-
#}

# void close_standard_output(void)
#
# Close the standard print_string file descriptor (1) and named pipe ("/dev/stdout").
#close_standard_output() {
#    die_if_args
#    exec 1>&-
#}

# void close_standard_error(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_standard_error() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";
