#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle standard input and output.

== Caveats ==

Standard file descriptors are shell-specific. Hence, avoid calling functions
operating on such descriptors from subshells. Since doing so fails to both
operate on and close the expected descriptor in the current shell, subsequent
commands run by such shell erroneously perceive such descriptor to be open
after having been closed under the subshell.
-/-

# ....................{ EXCEPTIONS ~ input                 }....................
declare_function_with_stdin <<'-\-'
void {die_if_stdin_empty, die_unless_stdin_nonempty}(
    string error_message = "expected standard input")

Throw an exception with the passed message unless standard input for the current
shell is nonempty. See is_stdin_nonempty() for further details.
-\-
function die_if_stdin_empty die_unless_stdin_nonempty() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdin_nonempty or die "${1:-expected standard input}"
}

#FIXME: Rename to die_unless_stdin_pipe(). A noun complies much better with
#nomenclature elsewhere (e.g., is_stdin_terminal_or_pipe()).
declare_function_with_stdin <<'-\-'
void die_unless_stdin_pipe(
    string error_message = "expected piped standard input")

Throw an exception with the passed message unless standard input to the current
shell is a pipe. See is_stdin_pipe() for further details.
-\-
function die_unless_stdin_pipe() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdin_pipe or die "${1:-expected piped standard input}"
}

declare_function_with_stdin <<'-\-'
void die_unless_stdin_terminal(
    string error_message = "expected standard input read from a terminal")

Throw an exception with the passed message unless standard input for the current
shell is a terminal. See is_stdin_terminal() for further details.
-\-
function die_unless_stdin_terminal() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdin_terminal or
        die "${1:-expected standard input read from a terminal}"
}

# ....................{ EXCEPTIONS ~ output                }....................
declare_function_with_stdin <<'-\-'
void die_unless_stdout_terminal(
    string error_message = "expected standard output printing to a terminal")

Throw an exception with the passed message unless standard output for the
current shell is a terminal. See is_stdout_terminal() for further details.
-\-
function die_unless_stdout_terminal() {
    die_unless_args_0_to_1 'expected optional error message'
    is_stdout_terminal or
        die "${1:-expected standard output printing to a terminal}"
}

# ....................{ TESTERS ~ input                    }....................
declare_function_with_stdin <<'-\-'
[status: boolean] is_stdin_nonempty(void)

Return success if standard input to the current shell is nonempty (i.e., if
standard input currently contains at least one character to be read). Consider
calling either this function or die_if_stdin_empty() before reading
from standard input; if such input is empty, `zsh` quietly blocks when reading
from standard input, which is horribly bad.
-\-
function is_stdin_nonempty() {
    # If standard input to the current shell is written to via file descriptor
    # "/dev/stdin", "read -t 0" returns true without blocking on or consuming
    # such input; else, such command returns false. Since such input may have
    # been piped to such shell instead, running only such command does *NOT*
    # suffice to prove no such input. Thus, also test for piped standard input.
    die_if_args
    read -t 0 or is_stdin_pipe
}

#FIXME: Rename to is_stdin_pipe().
declare_function_with_stdin <<'-\-'
[status: boolean] is_stdin_pipe(void)

Return success if standard input to the current shell is a pipe (i.e., if the
current shell is a pipeline-specific subshell).
-\-
function is_stdin_pipe() {
    die_if_args
    is -p "${ZESHY_STDIN_PATH}" si
}

# ....................{ TESTERS ~ terminal                 }....................
declare_function_with_stdin <<'-\-'
[status: boolean] is_stdin_terminal(void)

Return success if the current shell's standard input is attached to a terminal.
-\-
function is_stdin_terminal() {
    die_if_args
    is -t 0 si
}

declare_function_with_stdin <<'-\-'
[status: boolean] is_stdout_terminal(void)

Return success if the current shell's standard output is attached to a terminal.
-\-
function is_stdout_terminal() {
    die_if_args
    is -t 1 si
}

declare_function_with_stdin <<'-\-'
[status: boolean] is_stdout_terminal_or_pipe(void)

Return success if the current shell's standard output is attached to either a
terminal or pipe (e.g., to page_stdin()).
-\-
function is_stdout_terminal_or_pipe() {
    die_if_args
    is -t 1 or -p "${ZESHY_STDOUT_PATH}" si
}

declare_function_with_stdin <<'-\-'
[status: boolean] is_stderr_terminal(void)

Return success if the current shell's standard error is attached to a terminal.
-\-
function is_stderr_terminal() {
    die_if_args
    is -t 2 si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'-\-'
integer get_stdout_mtime(void)

Get the modification time of standard output specific to the current shell
(i.e., the time at which such shell last write output to such file descriptor).
By precedent, such time is in seconds since the Unix epoch.
-\-
function get_stdout_mtime() {
    die_if_args

    #FIXME: This strikes me as stupidly system-specific. Why not just bite the
    #bullet and canonicalize ${ZESHY_STDOUT_PATH} every call to this function?
    #If efficiency becomes a concern, just inline such call. Right?
    # Get such time. Use
    # ${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH} rather than
    # ${ZESHY_STDOUT_PATH} for such purposes, as Linux updates such time for
    # the former but not latter on output. Technically, we can also use the
    # canonicalization of ${ZESHY_STDOUT_PATH} for such purposes; since this
    # is both less efficient and without benefit, we prefer the former path.
    get_path_mtime "${ZESHY_STDOUT_FILE_DESCRIPTOR_PATH}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'-\-'
void set_string_to_stdin[args: string string_name, stdin: string input]

Set the passed string to standard input: e.g.,

.set_string_to_stdin()
==========================================
[source]
------------------------------------------
>>> string the_apostle
>>> set_string_to_stdin the_apostle <<<'in triumph'
>>> print_string "${the_apostle}"
in triumph
------------------------------------------
==========================================

Since subshells do _not_ inherit parent shell file descriptors, there exists no
convenience alias or function get_stdin().
-\-
function set_string_to_stdin() {
    # Validate passed arguments.
    die_unless_arg 'expected one string name'
    die_if_stdin_empty

    # Set such string.
    set_string_to_string "${1}" "$(< "${ZESHY_STDIN_PATH}")"

    # Close such input, ensuring is_stdin_nonempty() subsequently returns false.
    close_stdin
}

# --------------------( WASTELANDS                         )--------------------
#Since subshells do _not_ inherit file descriptors from their parent shell, there
#exists no corresponding get_
#   string string_name__ssts="${1}"
#   die_unless_string "${string_name__ssts}"
# Avoid calling functions
# operating on such descriptors from subshells.
#
# Calling functions defined by this component from a subshell fails to close the
# corresponding file descriptor in the current shell; subsequent commands in the
# current shell thus erroneously see such descriptor as an open file when in
# fact such file is empty and should have been closed. To amend this, always
# call close_stdin() when calling such functions from a subshell.
# rather, only call such functions
# from the current shell#
#FUXME: Poorly named function, since it should never be called as a conventional
#getter. Rename to print_stdin(). Not sure we require the "_piped"
#distinction, yes? In which case, excise the call to
#die_unless_stdin_pipe() below.

# Handle traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_stdin() after calling piped input functions in a
#   subshell.

#FUXME: This component doesn't really belong here. A common component named
#"standard_input" elsewhere is a much better fit.

#such shell is running any command after the first in a pipe.
# ....................{ SETTERS                            }....................
#FUXME: Silly. Clearly, a vestige from when we thought we needed such
#functionality as an alias. Cut everywhere.
# void set_string_to_stdin_piped(string variable_name)
#
# Set the variable with the passed name to all standard input piped to the
# current shell. Consider calling is_stdin_pipe() before calling this function
# to test whether or not such input exists: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if is_stdin_pipe
#     ...     then set_string_to_stdin_piped hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     print_string ${hojas}
#     ... }
#     >>> print_string pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#function set_string_to_stdin_piped() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one variable name'
#    die_unless_stdin_pipe
#    string string_name="${1}"
#    die_unless_variable_string "${string_name}"
#
#    # Capture piped input into the passed variable.
#    set_string_to_string ${string_name} "$(< /dev/stdin)"
#
#    # Close standard input, ensuring is_stdin_pipe() now returns false.
#    close_stdin
#}

#   string piped_input
#   set_string_to_stdin_piped piped_input
#   print_string "${piped_input}"
# ....................{ RUNNERS                            }....................
# string call_with_piped_input(
#   string function_name, string function_arg1, string function_arg1, ...)
#
# Call the passed function by piping the standard input piped to the current
# function or script to such function.
#
# In theory, run_command_with_stdin_piped() subsumes this function's functionality;
# in practice, run_command_with_stdin_piped() requires function arguments be quote
# protected and hence is more cumbersome to call than this function. Prefer this function calling run_command_with_stdin_piped() when calling functions with quoted arguments,
#call_with_piped_input() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_stdin_pipe() now returns false.
#    close_stdin
#}

# string run_command_with_stdin_piped(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_stdin_pipe() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     is_stdin_pipe and run_command_with_stdin_piped cat or print_string "${@}" cat
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
#run_command_with_stdin_piped() {
    # Validate and run passed arguments.
#    die_unless_args 'expected one command'
#    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_stdin_pipe() now returns false.
#    close_stdin
#}

    #FUXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)
#   noop ${(P)string_name::=$(< /dev/stdin)}
#   noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}="$(< /dev/stdin)"

#FUXME: Rename set_with_piped_input(), coinciding with run_command_with_stdin_piped().
#FUXME: No reason this can't also be made a run-style function. It should call
#close_stdin(), as expected.
#   exec 0<&-
#FUXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_stdin(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_stdin() {
#    die_if_args
#    exec 0<&-
#}

# void close_stdout(void)
#
# Close the standard print_string file descriptor (1) and named pipe ("/dev/stdout").
#close_stdout() {
#    die_if_args
#    exec 1>&-
#}

# void close_stderr(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_stderr() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";
