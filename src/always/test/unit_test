#!/usr/bin/env zsh
# ====================[ unit_test                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle unit tests and suites of such tests.
#
# --------------------( SEE ALSO                           )--------------------
# https://code.google.com/p/shunit2
#   An alternative Bash unit testing framework inspired by xUnit.

#FIXME: See "src/main" for extensive documentation on The Way Forward.
#
# ....................{ UNIT TESTERS                       }....................
#FIXME: Shift to "zeshy/unit_test".
# void unit_test_zeshy(void)
#
# Run all Zeshy unit tests.
function unit_test_zeshy() {
    #FIXME: O.K.; now this is cool. We want this framework to define a function:
    unit_test_functions_matching 'unit_test_zeshy_*'
    #FIXME: Then, each Zeshy unit test should begin with test_zeshy_*(). While
    #it would be "cool" to interleave unit tests with regular functions, we
    #should probably consider segregating them. The only comment online I see
    #regarding interleaving is (wait for it) by Bruce Eckel. No surprise,
    #really. I like it, actually. Let's do it. It'll bloat the codebase up,
    #but... *shrug* Also, don't bother including documentation for unit tests.
    #The Zeshy help system should be able to dynamically "synthesize" help if
    #anyone asks for it: e.g., for a test_zeshy_split_string_lines_to_list()
    #function, "Unit tests the split_string_lines_to_list() function." Simple!
    #Since we're not including documentation, such unit tests should be concise
    #enough to make the endeavor not horrifically unreadable. Go-go-go!
}

# string unit_test_functions_matching(string glob)
#
# Run all functions with names matching the passed glob as a unit test suite.
function unit_test_functions_matching() {
    # Validate passed arguments, capitalizing the local variable receiving the
    # passed glob to denote such glob readable by child functions.
    die_unless_one_arg 'expected one glob'
    string ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB="${1}"

    # List of all function names matching the passed glob.
    list test_function_names
    set_list_to_function_names_matching\
        test_function_names "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}"

    # Name of the function being tested by the current unit test.
    string tested_function_name

    #FIXME: Replace with call to glob function returning match group, if found.
    # If the passed glob is prefixed by a substring of alphanumeric characters
    # (e.g., substring "test_zeshy_" of glob "test_zeshy_*"), store such prefix
    # for use below.
    string tested_function_name_prefix
    is "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}" == ([[:alnum:]]##)* si and {
        tested_function_name_prefix="${match[1]}"
    }

    # Iteratively run each such function as a unit test.
    string tested_function_name
    for test_function_name ("${test_function_name[@]}") {
        is_nonempty "${tested_function_name_prefix}" and {
            tested_function_name="$(remove_string_prefix\
                "${test_function_name}" "${tested_function_name_prefix}")"
            is_function "${tested_function_name}" or
                tested_function_name=
        }

        #FIXME: Abstract test output out to a set of new "terminal/theme/output"
        #functions: say,
        #
        #    string say_test(string message)
        #    string say_test_passed(void)
        #    string say_test_failed(void)
        #
        #Note that say_test() will need to set a global boolean noting Zeshy to
        #now be in a testing state and say_test_passed() and say_test_failed() to
        #unset such boolean. Ah! Nice. That may not be strictly necessary. What
        #will be necessary, however, is to have say_test() temporarily redirect
        #stdout to a file, named pipe, or (ideally) coprocessed variable (e.g.,
        #">(ZESHY_STANDARD_OUTPUT)") and then to have say_test_passed() and
        #say_test_failed() restore stdout *AND* print the contents of
        #"${ZESHY_STANDARD_OUTPUT}" after printing either "ok" or "FAIL". Oh, and
        #we'll want to redirect stderr as well, of course. Sweet; research.
        if is_nonempty "${tested_function_name}"
        then say_test "unit testing ${tested_function_name}()... "
        else say_test "calling ${function_name}()... "
        fi
    }
}

function say_test() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one string'
    output "${1}()... "

    #FIXME: Rename "ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT" to "ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT"
    #or perhaps "ZESHY_FILE_DESCRIPTOR_FOR_STANDARD_OUTPUT"
    #or perhaps "ZESHY_FD_STANDARD_OUTPUT"? Hmm. I do like the longest one...
    integer ZESHY_FILE_DESCRIPTOR_FOR_STANDARD_OUTPUT_OF_TEST
    ${ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT}
}

#unit testing is_function()... FAIL
#unit testing is_function()... pass
#unit testing unit_test_zeshy_is_alias()... FAIL
#unit testing unit_test_zeshy_is_function()... ok
#calling unit_test_zeshy_is_function()... ok
#calling unit_test_zeshy_set_list_to_string_split_on()... OK
#running unit_test_zeshy_set_strings_to_split_string_on()... OK

# ....................{ GETTERS                            }....................
function get_caller_unit_test() {
    die_unless_string ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB
}

# ....................{ PASSERS                            }....................
# void pass_unit_test_if_command_succeeds(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Mark the current unit test as successful if the passed command succeeds (i.e.,
# exits with status code 0).
function pass_unit_test_if_command_succeeds() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one command'

    #FIXME: First, we need some means of acquiring the unit test function name.
    #How 'bout a simple walk up the call stack from this function to the nearest
    #parent function matching "(unit_)#test_*". Ah! No; I get it. The
    #unit_test_functions_matching() function should store the passed glob to a
    #temporary global (destroyed at the end of such function) -- say,
    #${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}. Actually, to make life safe and
    #simple, destroy **ALL** globals matching "ZESHY_UNIT_TEST_*" at the end of
    #such function. Then, this function should test each function name up the
    #call stack against such glob. Incredibly simple, actually.

    # Run such command.
    if run "${@}"
    then
    else
    fi
}

# void pass_unit_test_if_command_fails(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Mark the current unit test as successful if the passed command fails (i.e.,
# exits with non-zero status).
function pass_unit_test_if_command_fails() {
}

# void pass_unit_test_if_command_exit_status(
#   string command_name, string command_arg1, string command_arg2, ...,
#   integer exit_status)
#
# Mark the current unit test as successful if the passed command exits with the
# passed status.
function pass_unit_test_if_command_exit_status() {
}

# ....................{ FAILERS                            }....................

# --------------------( WASTELANDS                         )--------------------
#       tested_function_name="$(remove_prefix "${test_function_name}")"
    #FIXME: Replace with call to glob function returning match group, if found.
    # If the passed glob is prefixed by a substring of alphanumeric characters
    # (e.g., substring "test_zeshy_" of glob "test_zeshy_*"), store such prefix
    # for use below.
#   string test_function_name_prefix
#   is "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}" == ([[:alnum:]]##)* si and {
#       test_function_name_prefix="${match[1]}"
#   }

#FIXME: Add a new "zeshy/test" file defining Zeshy unit tests leveraging
#functions defined below, with top-level test_zeshy() function calling all such
#unit tests. Each such unit test should itself be encapsulated by a single...
#actually, that strikes me as horribly heavy-weight. Let's go with the
#following:

    #FIXME: Prints all function names matching such glob, newline-delimited. Use
    #this to collect the set of all functions to be run into a list. Perhaps use
    #the split_string_lines_to_list() function. Also, this one-liner is
    #exceedingly useful; split into a new function:
    #set_list_to_function_names_matching()
#   typeset -fm '+' "${glob}"
