#!/usr/bin/env zsh
# ====================[ unit_test                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define a unit testing framework.
#
# --------------------( SEE ALSO                           )--------------------
# https://code.google.com/p/shunit2
#   An alternative Bash unit testing framework inspired by xUnit.

#FIXME: Add a new "zeshy/test" file defining Zeshy unit tests leveraging
#functions defined below, with top-level test_zeshy() function calling all such
#unit tests. Each such unit test should itself be encapsulated by a single...
#actually, that strikes me as horribly heavy-weight. Let's go with the
#following:

# ....................{ UNIT TESTERS                       }....................
#FIXME: Shift to "zeshy/test". (No, not "zeshy/unit_test", due to function naming.)
# void test_zeshy(void)
#
# Run all Zeshy unit tests.
function test_zeshy() {
    #FIXME: O.K.; now this is cool. We want this framework to define a function:
    unit_test_functions_matching 'test_zeshy_*'
    #FIXME: Then, each Zeshy unit test should begin with test_zeshy_*(). While
    #it would be "cool" to interleave unit tests with regular functions, we
    #should probably consider segregating them. The only comment online I see
    #regarding interleaving is (wait for it) by Bruce Eckel. No surprise,
    #really. I like it, actually. Let's do it. It'll bloat the codebase up,
    #but... *shrug* Also, don't bother including documentation for unit tests.
    #The Zeshy help system should be able to dynamically "synthesize" help if
    #anyone asks for it: e.g., for a test_zeshy_split_string_lines_to_list()
    #function, "Unit tests the split_string_lines_to_list() function." Simple!
    #Since we're not including documentation, such unit tests should be concise
    #enough to make the endeavor not horrifically unreadable. Go-go-go!
}

# string unit_test_functions_matching(string glob)
#
# Run all functions with names matching the passed glob as a unit test suite.
function unit_test_functions_matching() {
    # Validate passed arguments, capitalizing the local variable receiving the
    # passed glob to denote such glob readable by child functions.
    die_unless_one_arg 'expected one glob'
    string ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB="${1}"

    # List of all function names matching the passed glob.
    list test_function_names
    set_list_to_function_names_matching\
        test_function_names "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}"

    # Name of the function being tested by the current unit test.
    string tested_function_name

    #FIXME: Replace with call to glob function returning match group, if found.
    # If the passed glob is prefixed by a substring of alphanumeric characters
    # (e.g., substring "test_zeshy_" of glob "test_zeshy_*"), store such prefix
    # for use below.
    string test_function_name_prefix
    is "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}" == ([[:alnum:]]##)* si and {
        test_function_name_prefix="${match[1]}"
    }

    # Iteratively run each such function as a unit test.
    for test_function_name ("${test_function_name[@]}") {
        tested_function_name="$(remove_prefix "${test_function_name}")"
        utter "${function_name}"
    }
}

# ....................{ GETTERS                            }....................
function get_caller_unit_test() {
    die_unless_string ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB
}

# ....................{ PASSERS                            }....................
# void pass_unit_test_if_command_succeeds(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Mark the current unit test as successful if the passed command succeeds (i.e.,
# exits with status code 0).
function pass_unit_test_if_command_succeeds() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one command'

    #FIXME: First, we need some means of acquiring the unit test function name.
    #How 'bout a simple walk up the call stack from this function to the nearest
    #parent function matching "(unit_)#test_*". Ah! No; I get it. The
    #unit_test_functions_matching() function should store the passed glob to a
    #temporary global (destroyed at the end of such function) -- say,
    #${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}. Actually, to make life safe and
    #simple, destroy **ALL** globals matching "ZESHY_UNIT_TEST_*" at the end of
    #such function. Then, this function should test each function name up the
    #call stack against such glob. Incredibly simple, actually.

    # Run such command.
    if run "${@}"
    then
    else
    fi
}

# void pass_unit_test_if_command_fails(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Mark the current unit test as successful if the passed command fails (i.e.,
# exits with non-zero status).
function pass_unit_test_if_command_fails() {
}

# void pass_unit_test_if_command_exit_status(
#   string command_name, string command_arg1, string command_arg2, ...,
#   integer exit_status)
#
# Mark the current unit test as successful if the passed command exits with the
# passed status.
function pass_unit_test_if_command_exit_status() {
}

# ....................{ FAILERS                            }....................

# --------------------( WASTELANDS                         )--------------------
    #FIXME: Prints all function names matching such glob, newline-delimited. Use
    #this to collect the set of all functions to be run into a list. Perhaps use
    #the split_string_lines_to_list() function. Also, this one-liner is
    #exceedingly useful; split into a new function:
    #set_list_to_function_names_matching()
#   typeset -fm '+' "${glob}"
