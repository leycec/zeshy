#!/usr/bin/env zsh
# ====================[ login                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle login shells (i.e., shells passed a first argument of "-"). Under
# Linux, login shells are typically run:
#
# * After authenticating user login credentials by...
# * A process running command "login" executed by...
# * A process running command "getty" executed by...
# * A process running command "init" executed by...
# * The current kernel.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_shell_login(string error_message = 'current shell non-login')
#
# Throw an exception unless the current shell is a login shell. See
function die_unless_shell_login() {
    die_unless_args_0_to_1 'expected optional error message'
    is_shell_login or die "${1:-current shell non-login}"
}

# ....................{ TESTERS                            }....................
# boolean is_shell_login(void)
#
# Return true if the first argument passed to the current shell was "-". The
# startup process running the "login" command typically passes such argument to
# startup shells on successful login.
function is_shell_login() {
    die_if_args
    is_shell_option_enabled login
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ MAIN                               }....................
#append_zeshy_startup_command_if_shell_login startup_zeshy_login

#FIXME: We really want to perform this at the topmost level -- probably in
#"src/config".
# void startup_zeshy_login(void)
#
# Configure the current shell with sane defaults appropriate for login shells.
# Specifically, if:
#
# * "/etc/profile.env" is an existing file, source such shell script. (Specific
#   to Gentoo Linux-based distributions and derivative friends.)
# * "/etc/profile.d/" is an existing directory, source all shell scripts under
#   such directory. (Supported by most Linux distributions excluding Debian-
#   based distributions, whose justifications are largely antiquated and in any
#   case blatantly superfluous:
#   http://www.debian.org/doc/debian-policy/ch-opersys.html#s9.9)
#function startup_zeshy_login() {
    # Validate sanity.
#    die_if_args

    #FIXME: We should only set such umasks only if the current umask remains the
    #default. If the user has changed the umask, then we clearly shouldn't change it
    #out from under them. Alternately, this should arguably be a configurable
    #option in... hmmmmm; we'd probably want a new "~/.zeshy/config/login", no?
#    if is_current_user_superuser
#    then set_path_creation_mask u=rwx,g=rx,o=rx
#    else set_path_creation_mask u=rwx,g=rx,o=
#    fi

    #FIXME: source_shell_script() probably shouldn't implicitly append ${FPATH}
    #to ${PATH}, which induces subtle bugs as below. Was the only reason for
    #doing this to force searches for scripts to run against both ${FPATH} and
    #${PATH}. Silly; stop doing such appending and call source_shell_script()
    #below.

    # If "/etc/profile.env" exists, source such script.
    #
    # Avoid calling source_shell_script(), which implicitly appends ${FPATH} to
    # ${PATH} and in this context permanently pollutes ${PATH}.
#    is_file '/etc/profile.env' and source '/etc/profile.env'

    # Configure global string ${PATH} and global list ${path} *AFTER* sourcing
    # all shell scripts expected to set default values for such globals.
#    startup_zeshy_login_globals_path

    # If "/etc/profile.d/" exists, source all Bourne shell scripts under such
    # directory. Since most distributions supply csh shell scripts under such
    # directory not readily sourceable by Zsh, avoid sourcing everything: e.g.,
    #
    #    for profile_script ( '/etc/profile.d/'*.[^.]#sh(.) ) {
#    is_dir '/etc/profile.d' and
#        for profile_script ( '/etc/profile.d/'*.sh ) {
#            source_shell_script "${profile_script}"
#        }
#}

# void startup_zeshy_login_globals_path(void)
#
# Configure global string ${PATH} and list ${path} with sane defaults.
#function startup_zeshy_login_globals_path() {
    # Validate sanity.
#    die_if_args
#   print "PATH: ${PATH}"

    #FIXME: I've decided the whole distinction between "/bin" and "/sbin" is
    #reprehensibly lame. I admit the underlying idea to be idealistically sound,
    #but it just falls down in the real world. In the real world, where we all
    #live, *MOST* "/sbin" commands are meaningfully executable by non-superusers
    #to read (but rarely write) system-wide metadata (e.g., IP address). Hence,
    #there's no meaningful reason to omit "/sbin" from a non-superuser ${PATH}.
    #Stop doing so.
    #FIXME: This also helpfully allows us to cleanup hard-coded references to
    #"/sbin" (e.g., "/sbin/ifconfig"). All such references should be hunted down
    #and summarily extinguished. If one thinks about it, hard-coding such
    #references is clearly a *DEPLORABLY ABOMINABLE IDEA*.
    #FIXME: Since adding "/sbin" to non-superuser paths somewhat goes against
    #the conventional Linux grain, document why we've done so. Both arguments
    #substantiante such reasoning.

    # Store the prior ${PATH} if any for subsequent interpolation.
#    string last_PATH
#    if is_current_user_superuser and is_variable_nonempty ROOTPATH
#    then last_PATH="${ROOTPATH}"
#    else last_PATH="${PATH}"
#    fi

    # Reset ${path} and hence ${PATH}. Avoid resetting ${PATH} directly via
    # "PATH=", which prefixes ${PATH} with an empty ":" on the first "path+=".
#    path=( )

    # Conditionally append system-wide paths.
#    append_PATH_with_dir_if_found\
#        '/usr/local/bin'\
#        '/usr/bin'\
#        '/bin'

    # If the superuser, conditionally append root-specific paths.
#    is_current_user_superuser and append_PATH_with_dir_if_found\
#        '/usr/local/sbin'\
#        '/usr/sbin'\
#        '/sbin'\
#        '/etc/init.d'

    # Append the prior $PATH.
#    PATH+=":${last_PATH}"

    # Append the user-specific "~/bin/".
#    append_PATH_with_dir_if_found "${HOME}/bin"
#}

    # Configure globals.
#   startup_zeshy_login_globals
#}

# void startup_zeshy_login_globals(void)
#
# Configure globals with sane defaults derived from canonical paths.
#function startup_zeshy_login_globals() {
    # Validate sanity.
#   die_if_args

# Unlike "/etc/env.d/" shell scripts performing simple variable
    # assignments, these scripts perform more complex (and therefore time- and space-consumptive)
    # functionality. Fortunately, however, there rarely tend to be many of them.
# Numerous Linux distributions
    # programmatically aggregate this file as follows:
    #
    # * Under Gentoo, "env-update" from the files in "/etc/env.d/".
    # * Under Exherbo, "eclectic env update" from the files in "/etc/env.d/".
    #FUXME: Hmm; shouldn't we execute all executable scripts under such
    #directory rather than merely Bourne shell scripts? .
# Configure sane user defaults appropriate to the current login shell.

#startup_zeshy_login_profile_defaults
#FUXME: Replace calls to "umask" with a new set_user_mask() function defaulting
#to calling "umask -S". Actually, detect whether the input is decimal or not and
#use the corresponding option. It just makes sense!
    #FUXME: Install "colorgcc", then test. Is this path current?
#       '/usr/lib/colorgcc/bin'\
#       is_dir "${dirname}" and is_path_readable "${dirname}" and
#       is not "${PATH}" =~ "(^|:)${dirname}($|:)" si and
    # Append Zeshy's "bin/".
#   string zeshy_bin_dir="${ZESHY_HOME}/bin"
#   append_PATH_with_dir_if_found "${zeshy_bin_dir}"

    # Append each command in Zeshy's "bin/command/" installed on this machine,
    # matching all subdirectories of that directory via the "(/)" modifier.
#   string zeshy_bin_command_name
#   for zeshy_bin_command_dir ("${zeshy_bin_dir}/command"/*(/)) {
#       zeshy_bin_command_name="$(get_path_basename "${zeshy_bin_command_dir}")"
#       is_installed "${zeshy_bin_command_name}" and
#           append_PATH_with_dir_if_found "${zeshy_bin_command_dir}"
#   }
# For each passed directory name, append such name onto ${PATH} if not already
# and for which the corresponding directory exists and is readable.
    #   string shell_options=${-}
    #   set -${shell_options}
    #   unset sh

    # Export!
#   export PATH

# ....................{ GLOBALS                            }....................
#set_profile_defaults_globals() {
#    # Maximum number of lines of Zsh command-line history to persist.
#    integer_global_export HISTSIZE="${HISTSIZE:-1024}"
#
#    # Maximum number of lines of Zsh command-line history to retain between logins.
#    integer_global_export SAVEHIST="${SAVEHIST:-1024}"
#
#    # Absolute path of the file persisting Zsh command-line history.
#    string_global_export  HISTFILE="${HISTFILE:-${ZESHY_DOT_DIR}/history}"
#}
