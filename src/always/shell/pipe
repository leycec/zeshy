#!/usr/bin/env zsh
# ====================[ pipe                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Pipe, handling traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_standard_input() after calling piped input functions in a
#   subshell.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_piped_input(string error_message = '"/dev/stdin" not a pipe')
#
# Throw an exception unless standard input to the current shell is a pipe.
die_unless_piped_input() {
    die_unless_at_most_one_arg 'expected optional error message'
    is_piped_input or die "${1:-\"/dev/stdin\" not a pipe}"
}

# ....................{ TESTS                              }....................
# boolean is_piped_input(void)
#
# Return true if standard input to the current shell is a pipe. Equivalently,
# return true if such shell is running any command after the first in a pipe.
is_piped_input() {
    die_if_args
    is -p /dev/stdin si
}

# ....................{ GETTERS                            }....................
# void get_piped_input_into(string variable_name)
#
# Get the standard input piped to the current shell as a string.
# Callers typically call is_piped_input() before calling this function to
# accept input from both pipes and passed arguments: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if is_piped_input
#     ...     then get_piped_input_into hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     sputter ${hojas}
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
get_piped_input_into() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one variable name'
    die_unless_piped_input
    string string_name="${1}"
    die_unless_string "${string_name}"

    #FIXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)

    # Capture standard input into the passed variable.
    noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}="$(< /dev/stdin)"

    # Close standard input, ensuring is_piped_input() now returns false.
    close_standard_input
}

# --------------------( WASTELANDS                         )--------------------
#   exec 0<&-
#FIXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_standard_input(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_standard_input() {
#    die_if_args
#    exec 0<&-
#}

# void close_standard_output(void)
#
# Close the standard output file descriptor (1) and named pipe ("/dev/stdout").
#close_standard_output() {
#    die_if_args
#    exec 1>&-
#}

# void close_standard_error(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_standard_error() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";
