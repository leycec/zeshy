#!/usr/bin/env zsh
# ====================[ syntax                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Shell Syntax, parsing pertinent Zsh grammar (e.g., variables, commands).
#
# --------------------( SEE ALSO                           )--------------------
# * http://stackoverflow.com/questions/2821043/allowed-characters-in-linux-environment-variable-names
#   Discussion of Zsh variable name syntax, complete with citations.

# ....................{ TESTS                              }....................
# boolean is_variable_name(string name)
#
# Return true if the passed string is a valid Zsh variable name: e.g.,
#
#     >>> is_variable_name 'COINTELPRO' and print "First Nations"
#     First Nations
#     >>> is_variable_name '-=MKULTRA?'  or print "Lysergic acid diethylamide"
#     Lysergic acid diethylamide
is_variable_name() {
    # Dismantled, this is:
    #
    # * "[a-zA-Z_]", matching the first character of a valid Zsh variable name.
    # * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
    die_unless_one_arg 'expected one string'
    is "${1}" == [a-zA-Z_][a-zA-Z0-9_]# si
}

# boolean is_variable_definition(string definition)
#
# Return true if the passed string is a valid Zsh variable definition: e.g.,
#
#     >>> is_variable_definition 'FALSE=flag' and print "Reichstag fire"
#     Reichstag fire
#     >>> is_variable_definition 'BLACK=flag'  or print "Iran-Contra affair"
#     Iran-Contra affair
is_variable_definition() {
    die_unless_one_arg 'expected one string'
    is "${1}" == [a-zA-Z_][a-zA-Z0-9_]#'='* si
}

# ....................{ GETTERS                            }....................
#FIXME: Modify get_command_path_if_found() to call this function.

# string get_command_line_name(string command_arg1, string command_arg2, ...)
#
# Get the name of the callable (e.g., command, alias, builtin, function) in
# command position of the passed command line. Command position is the first
# word of the concatenation of all passed arguments, excluding prefixing
# temporary global variable definitions: e.g.,
#
#     >>> get_command_line_name "LD_LIBRARY_PATH=/usr/lib/tor rtorrent"
#     rtorrent
get_command_line_name() {
    # Validate passed arguments.
    die_unless_args 'expected one command'
    string word

    # Find the first word *NOT* defining a global variable, leveraging Zsh
    # parameter expansions to split passed arguments into shell words.
    # Dismantled, this is:
    #
    # * "*", concatenating passed arguments into a scalar string.
    # * "(z)", splitting such string on shell word boundaries.
    for word ("${(z)*}") {
        is_variable_definition "${word}" or break
    }

    # Return such word.
    output "${word}"
}

# --------------------( WASTELANDS                         )--------------------
#, concatenated into a single string.
        # If this word defines a global variable, continue to the next; else,
        # break with this word. Dismantled, this is:
        # * "[a-zA-Z_]", matching the first character of a variable name.
        # * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
        # * '=', a "=" delimiter.
        # * "*", matching zero or more characters as the variable value.
#       is "${word}" == [a-zA-Z_][a-zA-Z0-9_]#'='* si or break
# Clearly, these
#functions should all be shifted to the same component.
#FIXME: Fails to account for prefixing temporary globals: e.g.,
#   LD_PATH="oeu=oeu" ssh -o hmm
#       is "${word}" == *?'='* si or break
# This function currently fails to return the expected name for exotic command
# lines containing pathological, but technically valid, syntax (e.g.,
# '"{!! This is a sadistic variable name !!}"="===" ls').
#   list words; words=( "${(z)*}" )
#   for word ("${words[@]}") {
#   string args; args="$(get_args)"
    # Exclude prefixing temporary global variable definitions.
    # Return the first shell word of remaining arguments.
#   get_word "${args}" 1
