#!/usr/bin/env zsh
# ====================[ source                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle Zsh script sourcing (i.e., importation).

# ....................{ SOURCERS ~ safely                  }....................
#FIXME: WAIT; WAIT; WAIT. This distinction between Zeshy and non-Zeshy is
#hideous. Why? Because *we* can programmatically determine which is required by
#simple analysis of the she-bang. (We need better she-bang functions, by the
#way.) If the she-bang ends in either "/zeshy" or " zeshy", we have a Zeshy
#script on our hands and need to just source it as is. Otherwise, we need to
#source it under emulation appropriate to that shell. Roll all of this into one
#common function named simply source_script().

# string source_zeshy_script(
#   string script_filename, string script_arg1, string script_arg2, ...)
#
# Source the passed Zeshy script with the passed arguments. Avoid calling this
# function with non-Zeshy shell scripts, which often behave unexpectedly under
# the default Zeshy shell environment. Zeshy implicitly throws an exception on a
# command returning non-zero exit status, rendering non-Zeshy shell scripts
# expecting conventional unsafe behavior inoperable. Consider calling
# source_script() instead, in such cases.
function source_zeshy_script() {
    die_unless_args 'expected one script filename and optional script arguments'
    source -- "${@}"
}

# string source_zeshy_scripts(
#   string script_filename1, string script_filename2, ...)
#
# Source the passed Zeshy scripts. See source_zeshy_script() for details.
function source_zeshy_scripts() {
    die_unless_args 'expected at least one script filename'
    for filename ("${@}") { source -- "${filename}" }
}

# ....................{ SOURCERS ~ safely                  }....................
#FIXME: Rename to source_script().
# string source_script_safely(
#   string script_filename, string script_arg1, string script_arg2, ...)
#
# Safely source the passed non-Zeshy script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than Zsh shell environment).
function source_script_safely() {
    # Validate passed arguments. If the passed filename is not absolute, resolve
    # its absolute path by iteratively searching the current working directory,
    # ${PATH}, and ${FPATH} (in that order).
    die_unless_args 'expected at least one filename'
    string shell='zsh' emulatable_shells='zsh|sh|ksh|csh' filename filetype
    filename="$(get_script_path "${1}")"
    filetype="$(get_file_type_if_found "${filename}")"
#   say "filename: ${filename}"
#   say "filetype: ${filetype}"

    # Identify the shell to be emulated. If the passed filename's type
    # identifies an emulatable shell, assume that.
    if is "${filetype}" == ${~emulatable_shells} si; then
        shell="${filetype}"
    # Otherwise, attempt to match the passed file's first line for a shebang
    # referencing an emulatable shell. When no such match, default to "zsh".
    else
        string shebang_regex="^#.*[/ ](${emulatable_shells})($| )" shebang_line

        #FIXME: Insufficient. Search, say, the first eight lines for a shebang.
        #This suggests a call pipeline resembling:
        #  shebang_line="$(get_text_file_contents_line_matching_pcre "$(get_text_file_lines "${filename}" 1 8)" "${shebang_regex}")"
        shebang_line="$(get_text_file_first_line "${filename}")"
        is_string_pcre_match "${shebang_line}" "${shebang_regex}" and
            shell="${match[1]}"
#       output "shebang_line: ${shebang_line}"
#       output "shell=${shell}"
    fi

    # Safely source the passed shell script. Dismantled, this is:
    #
    # * "-L", localizing the redefinition of TRAPZERR() to this function call.
    # * "-R", resetting shell options to the default expected by such shell.
    # * "TRAPZERR()", disabling exception raising on command and function
    #   failure. (External scripts except no such exceptions, by default.)
    #
    # Do not redefine TRAPINT(), since printing stack traces on user interrupts
    # is universally useful and not conflicting with script expectations.
    {
#       say "sourcing \"${@}\" under ${shell} emulation..."
        emulate -LR "${shell}"
        TRAPZERR() { return $(( 128 + ${1} )) }
        PATH="${PATH}:${FPATH}" source -- "${@}"
    }

    #FIXME: Hmm; this appears to be fixed under zsh 5.0.0. Verify.
    # Interestingly, Zsh fails to signal ZERR when the sourced script fails with
    # non-zero exit status. Let's signal ZERR ourselves, shall we?
#   integer exit_status=${?}
#   (( exit_status == ZESHY_SUCCESS_CODE )) or
#       die "\"${@}\" failed with exit status ${exit_status}"
}

# string source_script_safely_command_output(
#   string shell_name,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
function source_script_safely_command_output() {
    # Validate passed arguments.
    die_unless_at_least_two_args\
        'expected at least one shell name and one command name'
    string shell_name="${1}"
    shift_one_arg
    is "${shell_name}" == (zsh|sh|ksh|csh) si or
        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_installed "${command_name}"

    # Source safely.
    emulate -R "${shell_name}" -c "eval \$(${@})"
}

# ....................{ SOURCERS ~ once                    }....................
#FIXME: Poor verb choice. Rename to source_scripts_once().
# void requires(string filename1, string filename2, ...)
#
# Import all passed scripts.
function requires() {
    die_unless_args 'expected at least one script name'
    for script_name ("${@}") require "${script_name}"
}

#FIXME: Poor verb choice. Rename to source_script_once() and all functions below.
# void require(string pathname, string arguments)
#
# Conditionally import the passed file or directory, if not previously imported
# by this function or externally modified since such import. We pass the passed
# arguments to all files imported in this manner.
#
# If the passed path is relative, we look for such path first under the current
# working directory and then Zeshy's root directory (e.g., "/usr/share/zeshy/").
# We then resolve the exact Zeshy script(s) to be imported as follows:
#
# * If the passed path is an existing file, import such file.
# * If the passed path is an existing directory:
#   * Containing a file named "${ZESHY_MAIN_SCRIPT_BASENAME}", import such file.
#   * Otherwise, import all files such directory contains.
# * Otherwise, die.
#
# This function mimics the import() built-in of most high-level languages. To
# avoid conflict with ImageMagick's "import" command, we prefer "require".
#
# --------------------( VARIABLES                          )--------------------
# This function defines local variables, which imported scripts may safely
# access for informative path metadata: namely,
#
# * "zeshy_script_name", having the relative path to the imported script under
#   "${ZESHY_HOME}/src".
# * "zeshy_script_path", having the absolute path to the imported script.
# * "zeshy_script_mtime", having the modification time of the imported script.
#
# --------------------( EXAMPLES                           )--------------------
#     # Implicitly imports the Zeshy script "zeshy/os/.main".
#     >>> require zeshy/os
function require() {
    # Validate passed arguments.
    die_unless_at_least_one_arg\
        'expected one pathname and optional script options'
#   say "requireing ${1}..."

    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    string zeshy_script_name="${1}"; shift

    # Path to this script.
    string zeshy_script_path

    # If the passed script name is either an absolute path or an existing relative
    # path, try to import it as is.
    if is_path_absolute "${zeshy_script_name}" or
       is_path         "${zeshy_script_name}"
    then zeshy_script_path="${zeshy_script_name}"
    # Otherwise, try to import a Zeshy component having that script name.
    else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
    fi

    # Delegate to helper functions depending on path type.
    if is_dir "${zeshy_script_path}"
    then require_dir  "${zeshy_script_path}" "${@}"
    else require_file "${zeshy_script_path}" "${@}"
    fi
}

# void require_dir(string dirname, string arguments)
#
# Conditionally import the passed directory. See require() for details.
function require_dir() {
    # Validate passed arguments.
    die_unless_at_least_one_arg\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    die_unless_dir "${zeshy_script_dir}"
    string zeshy_main_script="${zeshy_script_dir}/${ZESHY_MAIN_SCRIPT_BASENAME}"

    # If this directory contains a main script, import only such script;
    # otherwise, import all children of such directory.
    if is_file "${zeshy_main_script}"
    then require_file         "${zeshy_main_script}" "${@}"
    else require_dir_children "${zeshy_script_dir}"  "${@}"
    fi
}

# void require_dir_children(string dirname, string arguments)
#
# Conditionally import all files and directories under the passed directory.
function require_dir_children() {
    # Validate passed arguments.
    die_unless_at_least_one_arg\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"; shift
    die_unless_dir "${zeshy_script_dir}"

    #FIXME: Hmmm; no need to include "zwc", I should think. No?
    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.(swp|zwc)", excluding files with filetype "swp" or "zwc".
    for zeshy_script_dir_child ( "${zeshy_script_dir}"/*(^D@)~*.(swp|zwc) ) {
        require "${zeshy_script_dir_child}" "${@}"
    }
}

#global_string ZESHY_CACHE_COMPILATION_DIR="${ZESHY_DOT_DIR}/compilation"
#FIXME: Add support for zcompile(). Pass "-M" if the passed file matches
# */zeshy/src/* and "-R" otherwise.
# void require_file(string filename, string arguments)
#
# Conditionally import the passed file. See require() for details.
function require_file() {
    # Validate passed arguments.
    die_unless_at_least_one_arg\
        'expected one filename and optional import options'
    string zeshy_script_path="${1}"; shift
    die_unless_file "${zeshy_script_path}"

    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path.
    zeshy_script_path="$(canonicalize_path "${zeshy_script_path}")"

    # Modification time of this script.
    integer zeshy_script_mtime
    zeshy_script_mtime="$(get_path_mtime "${zeshy_script_path}")"

    global_map ZESHY_REQUIRED_PATH_TO_MTIME

    # If this script has not yet been imported or has been but has changed since
    # being imported, (re)import this script.
    if is -z\
        "${ZESHY_REQUIRED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
        "${ZESHY_REQUIRED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
        "${zeshy_script_mtime}" si; then
        # If the script corresponds to a command-specific script under
        # "zeshy/command" excluding the top-level ".main" script, ensure this
        # command is actually installed.
        if is "${zeshy_script_path}" == */zeshy/command/* si; then
            string command_name="${zeshy_script_path#*/zeshy/command/}"
            is "${command_name}" == "${ZESHY_MAIN_SCRIPT_BASENAME}" si or
                die_unless_installed "${command_name}"
        fi

        # Record this script as being imported prior to doing so, thus
        # preventing infinitely recursive reimportation should this or another
        # script imported by this script attempt to import this script again.
        ZESHY_REQUIRED_PATH_TO_MTIME["${zeshy_script_path}"]="${zeshy_script_mtime}"

        #FIXME: Technically, this works. Sadly, Zsh exposes no explicit
        #mechanism for sourcing zcompiled scripts. (Odd, we know.) Rather, one
        #can only use such scripts with the fpath-enabled autoload mechanism.
        # Absolute path to the file caching the compilation of this script.
#       string zeshy_script_compiled_path="${ZESHY_CACHE_COMPILATION_DIR}${zeshy_script_path}.zwc"

        # If this script has not yet been compiled or has been but has changed since
        # being compiled, (re)compile this script.
#       if is not -f "${zeshy_script_compiled_path}" or\
#           ${zeshy_script_mtime} -ne\
#           $(get_path_mtime "${zeshy_script_compiled_path}") si; then
#           # zcompile() refuses to create directory structure, so do so for it.
#           make_dir_if_not_found "$(dirname "${zeshy_script_compiled_path}")"

#           say "compiling \"${zeshy_script_path}\" to \"${zeshy_script_compiled_path}\"..."
#           say "compiling \"${zeshy_script_path}\"..."
#           zcompile "${zeshy_script_compiled_path}" "${zeshy_script_path}"

            # Set the mtime of the compiled script to that of the uncompiled
            # script to ensure the above conditional fails on future imports.
#           set_path_mtime "${zeshy_script_compiled_path}" ${zeshy_script_mtime}
#       fi
#       source "${zeshy_script_compiled_path}" "${@}"

        # Do so.
        say "requiring \"${zeshy_script_path}\"..."
        source "${zeshy_script_path}" "${@}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
# void zeshy_initialize_imports(void)
#
# Initialize the imports dictionary, used by the require() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The require()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# Zeshy Shell requires we separate this initialization into a distinct function,
# for hitherto inexplicable reasons. (There be subtle dragons aboot.)
#zeshy_initialize_imports() {
#    die_if_args

#    # Explicitly empty the dictionary. This is irrelevant on the first call to
#    # this function, but definitely matters on subsequent calls!
#    global_map ZESHY_REQUIRED_PATH_TO_MTIME; ZESHY_REQUIRED_PATH_TO_MTIME=( )
#}

#   elif is_path          "${PWD}/${zeshy_script_name}"
#   then zeshy_script_path="${PWD}/${zeshy_script_name}"

    # Initialize the imports dictionary used by the zimport() function.
#   zeshy_initialize_imports

    # Inform the user that this script is being imported. This script is usually
    # sourced via the Zsh source() built-in rather than the Zeshy zimport()
    # function; thus, our failure to do this here would require callers do this
    # there, prior to their sourcing this script.
    #
    # Distinguish the former from the latter by noting whether the
    # "${zeshy_script_mtime}" variable has been set or not; if it has, this script
    # was sourced via zimport() rather than source().
#   is_undeclared 'zeshy_script_mtime' or say "loading \"${zeshy_core_path}\"..."
