#!/usr/bin/env zsh
# ====================[ profile                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Profile, establishing sane defaults on shell login.

# ....................{ MAIN                               }....................
# void set_profile_defaults(void)
#
# Establish default profile settings.
set_profile_defaults() {
    set_profile_defaults_properties
    set_profile_defaults_system
    set_profile_defaults_path
}

# ....................{ PROPERTIES                         }....................
#FIXME: We should only set such umasks only if the current umask remains the
#default. If the user has changed the umask, then we clearly shouldn't change it
#out from under them. Alternately, this should arguably be a configurable
#option in... hmmmmm; we'd probably want a new "~/.zeshy/config/login", no?
set_profile_defaults_properties() {
    if is_superuser
    then set_path_creation_mask u=rwx,g=rx,o=rx
    else set_path_creation_mask u=rwx,g=rx,o=
    fi
}

# ....................{ SYSTEM                             }....................
set_profile_defaults_system() {
    #FIXME: Hmm; shouldn't we execute all executable scripts under such
    #directory rather than merely Bourne shell scripts? Alas.

    # Import all shell scripts under "/etc/profile.d/", if that directory exists.
    # Unlike "/etc/env.d/" shell scripts, which perform simple variable assignments,
    # these scripts perform more complex (and therefore time- and space-consumptive)
    # functionality. Fortunately, however, there rarely tend to be many of them.
    is_dir '/etc/profile.d' and
        for profile_script ( '/etc/profile.d/'*.sh(.) ) {
            source_safely "${profile_script}"
        }

    # If "/etc/profile.env" exists, import it. Numerous Linux distributions
    # programmatically aggregate this file as follows:
    #
    # * Under Gentoo, "env-update" from the files in "/etc/env.d/".
    # * Under Exherbo, "eclectic env update" from the files in "/etc/env.d/".
    #
    # Avoid calling source_safely(), implicitly appending ${FPATH} to ${PATH}
    # and in this context permanently polluting ${PATH}.
    is_file '/etc/profile.env' and source '/etc/profile.env'
}

# ....................{ PATH                               }....................
# void set_profile_defaults_path(void)
#
# Set the ${PATH} for the current user.
set_profile_defaults_path() {
    # Validate sanity.
    die_if_args
#   print "PATH: ${PATH}"

    #FIXME: I've decided the whole distinction between "/bin" and "/sbin" is
    #reprehensibly lame. I admit the underlying idea to be idealistically sound,
    #but it just falls down in the real world. In the real world, where we all
    #live, *MOST* "/sbin" commands are meaningfully executable by non-superusers
    #to read (but rarely write) system-wide metadata (e.g., IP address). Hence,
    #there's no meaningful reason to omit "/sbin" from a non-superuser ${PATH}.
    #Stop doing so.
    #FIXME: This also helpfully allows us to cleanup hard-coded references to
    #"/sbin" (e.g., "/sbin/ifconfig"). All such references should be hunted down
    #and summarily extinguished. If one thinks about it, hard-coding such
    #references is clearly a *DEPLORABLY ABOMINABLE IDEA*.
    #FIXME: Since adding "/sbin" to non-superuser paths somewhat goes against
    #the conventional Linux grain, document why we've done so. Both arguments
    #substantiante such reasoning.

    # Store the prior ${PATH} if any for subsequent interpolation.
    string last_PATH
    if is_superuser and is_variable_nonempty ROOTPATH
    then last_PATH="${ROOTPATH}"
    else last_PATH="${PATH}"
    fi

    # Reset ${path} and hence ${PATH}. Avoid resetting ${PATH} directly via
    # "PATH=", which prefixes ${PATH} with an empty ":" on the first "path+=".
    path=( )

    # Conditionally append system-wide paths.
    append_PATH_with_dir_if_found\
        '/usr/local/bin'\
        '/usr/bin'\
        '/bin'

    # If the superuser, conditionally append root-specific paths.
    is_superuser and append_PATH_with_dir_if_found\
        '/usr/local/sbin'\
        '/usr/sbin'\
        '/sbin'\
        '/etc/init.d'

    # Append the prior $PATH.
    PATH+=":${last_PATH}"

    # Append the user-specific "~/bin/".
    append_PATH_with_dir_if_found "${HOME}/bin"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Replace calls to "umask" with a new set_user_mask() function defaulting
#to calling "umask -S". Actually, detect whether the input is decimal or not and
#use the corresponding option. It just makes sense!
    #FIXME: Install "colorgcc", then test. Is this path current?
#       '/usr/lib/colorgcc/bin'\
#       is_dir "${dirname}" and is_path_readable "${dirname}" and
#       is not "${PATH}" =~ "(^|:)${dirname}($|:)" si and
    # Append Zeshy's "bin/".
#   string zeshy_bin_dir="${ZESHY_HOME}/bin"
#   append_PATH_with_dir_if_found "${zeshy_bin_dir}"

    # Append each command in Zeshy's "bin/command/" installed on this machine,
    # matching all subdirectories of that directory via the "(/)" modifier.
#   string zeshy_bin_command_name
#   for zeshy_bin_command_dir ("${zeshy_bin_dir}/command"/*(/)) {
#       zeshy_bin_command_name="$(get_basename "${zeshy_bin_command_dir}")"
#       is_installed "${zeshy_bin_command_name}" and
#           append_PATH_with_dir_if_found "${zeshy_bin_command_dir}"
#   }
# For each passed directory name, append such name onto ${PATH} if not already
# and for which the corresponding directory exists and is readable.
    #   string shell_options=${-}
    #   set -${shell_options}
    #   unset sh

    # Export!
#   export PATH

# ....................{ GLOBALS                            }....................
#set_profile_defaults_globals() {
#    # Maximum number of lines of Zsh command-line history to persist.
#    global_integer HISTSIZE="${HISTSIZE:-1024}"
#
#    # Maximum number of lines of Zsh command-line history to retain between logins.
#    global_integer SAVEHIST="${SAVEHIST:-1024}"
#
#    # Absolute path of the file persisting Zsh command-line history.
#    global_string  HISTFILE="${HISTFILE:-${ZESHY_DOT_DIR}/history}"
#}
