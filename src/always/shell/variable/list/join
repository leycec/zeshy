#!/usr/bin/env zsh
# ====================[ join                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Convert lists to strings.

# ....................{ JOINERS                            }....................
# string join_list_undelimited(string list_name)
#
# Join the list with the passed name into a string with each list element
# undelimited (i.e., delimited by the empty string): e.g.,
#
#     >>> list herbert; herbert=( "Songs" "of a" "Sentient Flute" )
#     >>> join_list_undelimited herbert
#     Songsof aSentient Flute
function join_list_undelimited() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # See output_undelimited() for further details.
    string IFS=
    output "${(P)list_name}"
}

# ....................{ JOINERS ~ delimiter                }....................
# string join_list_on_delimiter(string list_name, string delimiter)
#
# Get a string suffixing each element except the last of the passed list with
# the passed delimiter. The delimiter may be of any length: e.g.,
#
#     >>> list heinlein; heinlein=( "The Moon" "Is" "a" "Harsh Mistress" )
#     >>> join_list_on_delimiter heinlein ", "
#     The Moon, Is, a, Harsh Mistress
function join_list_on_delimiter() {
    # Validate passed arguments.
    die_unless_two_args 'expected one list name and one delimiter'
    string list_name="${1}" __delimiter__="${2}"
    die_unless_list "${list_name}"

    # If the passed delimiter is a colon, delimit such delimiter by periods.
    # Delimited, this is:
    #
    # * "j.:.", joining on colons.
    # * "@P", expanding to the list with the passed name.
    if is "${__delimiter__}" == ':' si
    then output "${(j.:.@P)list_name}"
    # Otherwise, delimit such delimiter by colons. Since Zsh appears to
    # expand no parameters embedded in parameter expansion flags (e.g.,
    # "print ${(j:${delimiter}:)@}", joining list elements with the raw string
    # "${delimiter}" rather than the expansion of such parameter), wrap the
    # desired expression in an "eval" to force such expansion.
    else eval "output \"\${(j:${__delimiter__}:)${list_name}}\""
    fi
}

# string join_list_on_newline(string list_name)
#
# Get a string suffixing each element except the last of the passed list with
# a newline character: e.g.,
#
#     >>> list banks; banks=( Use of Weapons )
#     >>> join_list_on_newline banks
#     Use
#     of
#     Weapons
function join_list_on_newline() {
    die_unless_one_arg 'expected one list name'
    join_list_on_delimiter "${@}" "${ZESHY_CHARACTER_NEWLINE}"
}

# ....................{ JOINERS ~ delimiters               }....................
# string join_list_on_delimiters(
#   string list_name, string nonlast_delimiter,
#   string last_delimiter_if_three_or_more_elements,
#   string last_delimiter_if_two_elements = "${last_delimiter_if_three_or_more_elements}")
#
# Join the list with the passed name into a string with each list element
# excluding the last delimited by the first passed delimiter and the last list
# element delimited by the second passed delimiter. Delimiters may be of any
# length: e.g.,
#
#     >>> list pat_the_bunny
#     >>> pat_the_bunny=( 'The' 'Wingnut' 'Dishwashers' 'Union' )
#     >>> join_list_on_last_delimiter pat_the_bunny '+' '?'
#     The+Wingnut+Dishwashers?Union
function join_list_on_delimiters() {
    # Validate passed arguments.
    die_unless_three_or_four_args\
        'expected one list name, one non-last delimiter, one last delimiter if three or more list elements, and optional last delimiter if two list elements'
    string\
        list_name="${1}" __nonlast_delimiter__="${2}"\
        __last_delimiter_if_three_or_more__="${3}" __last_delimiter_if_two__
    __last_delimiter_if_two__="${4:-${__last_delimiter_if_three_or_more__}}"
    die_unless_list "${list_name}"
    integer list_size; list_size="$(get_list_size "${list_name}")"

    # Join the passed list depending on the size of such list.
    if (( list_size >= 3 )); then
        # Join all list elements excluding the last into a string. Note: DO NOT
        # DOUBLE-QUOTE SUCH LIST WHEN SETTING ${__list_sans_last_element__}, as
        # that aggregates such list elements into a single string. *shakes fist*
        list __list_sans_last_element__
        string __list_sans_last_element_string__
        __list_sans_last_element__=( ${${(@P)list_name}[1,-2]} )
#       say "lsle[@]: $__list_sans_last_element__[1]; $__list_sans_last_element__[2]"
        __list_sans_last_element_string__="$(join_list_on_delimiter\
            __list_sans_last_element__ "${__nonlast_delimiter__}")"

        # Join the last list element into such list.
        output "${__list_sans_last_element_string__}${__last_delimiter_if_three_or_more__}${${(@P)list_name}[-1]}"
#       output "${__list_sans_last_element_string__}"
    elif (( list_size == 2 ))
    then output "${${(@P)list_name}[1]}${__last_delimiter_if_two__}${${(@P)list_name}[2]}"
    else output "${${(@P)list_name}[1]}"
    fi
}

# string join_list_conjunctively(string text1, string text2, ...)
#
# Join the passed strings into a string conjunctively delimiting such strings
# (i.e., with the logical conjunction "and"). Specifically:
#
# # Double quote all passed strings.
# * Prefix all passed strings except the first and last with ", ".
# * Prefix the last passed string with ", and ".
# * Truncat the returned string to a sensible maximum (currently, 75% of the
#   current terminal width).
#
# Unlike most Zeshy functions operating on lists, this function excepts accepts
# list elements as positional arguments rather than as a variable name due to
# caller requirements: e.g.,
#
#     >>> join_list_conjunctively 'I mrethil' 'peliar' 'duiw laiss'
#     "I mrethil", "peliar", and "duiw laiss"
function join_list_conjunctively() {
    # Validate and join the passed arguments. Dismantled, this is:
    #
    # * "\"${^@}\"", double quoting each passed string.
    die_unless_args 'expected at least one string'
    list args; args=( "\"${^@}\"" )
    string text
    text="$(join_list_on_delimiters args ', ' ', and ' ' and ' )"

    #FIXME: Close, but not quite right. Ideally, we want to preserve human-
    #readable output when truncating. Humans expect output resembling:
    #     "I mrethil", "p...", ...
    #Rather than:
    #     "I mrethil", "peliar"...
    #Not terribly easy or readibly internationalizable, so I suppose I'm content
    #with this as is. For now...

    # Truncate the joined string to 75% of the current terminal's width, rounded
    # down to the nearest integer.
    integer max_length=80
    is_shell_terminal and max_length=$(( 0.75 * $(get_terminal_width) ))
    truncate_string "${text}" "${max_length}" '...'
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: How about join_list_on_delimiter(), instead?
#FIXME: Rename "list_elements" to "list_entries" everywhere. The latter gives
#more Google hits and is more concise. Double win! Actually, perhaps get_*()-
#style names wouldn't be more appropriate? Consider:
# string get_list_entries_joined_undelimited
#Ah, no; much too much of a mouthful. Good as is.
#FIXME: Actually, just drop the "_elements" everywhere. Excessive; unneeded. And
#reduce "with" to "on". That gives us final functions resembling:
#   join_list_on_delimiter()

#FIXME: We should probably just centralize split and join functions into a new
#component: say, "type/variable/list_and_string".
# See "string/string" for corresponding split_*() functions.

#FIXME: Rename to get_list_as_restorable_string() or
#get_restorable_string_from_list(). Perhaps 
# ....................{ JOINERS ~ lines                    }....................
#FIXME: Trivial. Delete?
# string join_list_to_lines(string list_name)
#
# Join the list with the passed name into a newline-delimited string: e.g.,
#
#     >>> list grok; grok=( "Stranger in" "a" "Strange Land" )
#     >>> join_list_to_lines grok
#     Stranger in
#     a
#     Strange Land
#function join_list_to_lines() {
#   die_unless_one_arg 'expected one list name'
#   join_list_on_delimiter "${1}" '\n'
#

#FIXME: The "_to_string" is redundant and renders function names cumbersome and
#unreadable. Replace with "_elements", which *isn't* redundant (e.g., renaming
#join_list_undelimited() to
#join_list_undelimited()).
#           "${(@P)__list_sans_last_element__}"\

#FIXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_one_or_two_args\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
#}

#FIXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_one_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_at_least_three_args; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_delimitermunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_two_args
#   then output "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else output "${1}"
#   fi

#FIXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the passed arguments.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FIXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_USER_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FIXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps output_restorable_list()? AH! Got it: convert_list_to_restorable_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which Zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FIXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_at_least_two_args\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_one_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_variable List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
