#!/usr/bin/env zsh
# ====================[ split                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Convert scalar strings to non-scalar lists.

# ....................{ SETTERS                            }....................
document_function '
string set_list_to_string_split_on_delimiter(
  string list_name, string text, character delimiter)

Split the passed string on all substrings of the passed delimiting character
into the passed list: e.g.,

  >>> list array
  >>> set_list_to_string_split_on_delimiter array "Obseqious/Deep/Join" "/"
  >>> print_string "${array[1]}"
  Obseqious
'
function set_list_to_string_split_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one delimiter'
    string list_name="${1}" __text__="${2}" __delimiter__="${3}"
    die_unless_list "${list_name}"
    die_unless_character __delimiter__

    # If the passed delimiter is a colon, delimit such delimiter by periods.
    if is "${__delimiter__}" == ':' si
    then set_list_to_evaluation "${list_name}" '${(s.:.)__text__}'
    # Otherwise, delimit such delimiter by colons.
    else set_list_to_evaluation "${list_name}"\
        "\${(s:${__delimiter__}:)__text__}"
    fi
}

document_function '
string set_list_to_string_split_on_characters(string list_name, string text)

Split the passed string on characters into the passed list. Since Zsh supports
character indexing and slicing out of the box, this function is useful only
where explicitly requiring list types: e.g.,

  >>> list chars
  >>> set_list_to_string_split_on_characters chars\
  ...   "Though I sang in my chains like the sea."
  >>> print_string ${chars[1]} ${chars[31]} ${chars[39]}
  T e a
'
function set_list_to_string_split_on_characters() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name="${1}" __text__="${2}"
    die_unless_list "${list_name}"

    # Split with a 0-width delimiter.
    set_list_to_evaluation "${list_name}" '${(s::)__text__}'
}

# ....................{ SETTERS ~ word                     }....................
document_function '
void set_list_to_standard_input_split_on_words(string list_name)

Split standard input on shell words into the passed list.

  >>> list fern
  >>> set_list_to_standard_input_split_on_words fern <<< "About the lilting"
  >>> print_string ${fern[2]}
  the
'
function set_list_to_standard_input_split_on_words() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"
    die_if_standard_input_empty

    # Set such list and close standard input.
    set_list_to_evaluation "${list_name}" '${(z)"$(< /dev/stdin)"}'
    close_standard_input
}

document_function '
string set_list_to_string_split_on_words(string list_name, string text)

Split the passed string on words into the passed list. Since Zsh supports list-
style character indexing and slicing out of the box, this function is useful
only where explicit list types are required: e.g.,

  >>> list hill
  >>> set_list_to_string_split_on_words hill "Time held me green and dying"
  >>> print_string ${hill[1]} ${hill[4]} ${hill[5]}
  Time green dying
'
function set_list_to_string_split_on_words() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name="${1}" __text__="${2}"
    die_unless_list "${list_name}"

    # Split with parameter expansion flag "(z)".
    set_list_to_evaluation "${list_name}" '${(z)__text__}'
}

# ....................{ SETTERS ~ string                   }....................
document_function '
void set_strings_to_string_split_on_delimiter(
  string variable_name1, string variable_name2, string text, string delimiter)

Split the passed string on the first substring of the passed delimiter into:

* The string with the former name to the substring preceding such delimiter.
* The string with the latter name to the substring following such delimiter.

The delimiter may be of any non-zero length: e.g.,

  >>> string pre suf
  >>> set_strings_to_string_split_on_delimiter pre suf "wol==hea==soc" "=="
  >>> print "prefix: ${pre}\nsuffix: ${suf}"
  prefix: wol
  suffix: hea==soc
'
function set_strings_to_string_split_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one prefix and one suffix variable name, one string, and one delimiter'
    string\
        prefix_name="${1}" suffix_name="${2}"\
        __text__="${3}" __delimiter__="${4}"
    die_unless_string "${prefix_name}"
    die_unless_string "${suffix_name}"
    die_unless_variable_nonempty __delimiter__

    # If such string contains no such delimiter, throw an exception.
    is_string_substring "${__text__}" "${__delimiter__}" or
        die "delimiter \"${__delimiter__}\" not found in \"${__text__}\""

    #FIXME: Conjoin into a single "//"-style match enabling "(#b)" to capture
    #the two groups, then set such strings with such groups. This also helps to
    #rid us of the unwieldy test above, assuming we detect such match failing
    #with non-zero exit status.
    #FIXME: Just use single "#" with "(#b)". See set_list_to_string_piped<>.
    # Split such string.
    set_string "${prefix_name}" "${__text__%%${__delimiter__}*}"
    set_string "${suffix_name}" "${__text__#*${__delimiter__}}"
}

# --------------------( WASTELANDS                         )--------------------
# string set_list_to_string_split_on_words(string list_name, string text)
#
# Split the passed string on words into the passed list. Since Zsh supports list-
# style character indexing and slicing out of the box, this function is useful
# only where explicit list types are required: e.g.,
#
#     >>> list words
#     >>> set_list_to_string_split_on_words words 'Time held me green and dying'
#     >>> print_string ${words[1]} ${words[4]} ${words[5]}
#     Time green dying
#function set_list_to_string_split_on_words() {
    # Validate passed arguments.
#    die_unless_args_2 'expected one list name and one string'
#    string list_name="${1}" __text__="${2}"
#    die_unless_list "${list_name}"

    # Split with parameter expansion flag "(z)".
#    set_list_to_evaluation "${list_name}" '${(z)__text__}'
#}
