#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle lists (i.e., arrays).
#
# --------------------( TODO                               )--------------------
# * Incorporate difference and intersect list operations from "src/load".
# * Incorporate set operations from:
#   http://www.catonmat.net/blog/set-operations-in-unix-shell

# ....................{ EXCEPTIONS                         }....................
# void die_unless_list(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a list")
#
# Die unless the passed variable is a list.
function die_unless_list() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_list "${variable_name}" or
        die "${2:-\"${variable_name}\" not a list}"
}

# void die_unless_list_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a non-empty list")
#
# Die unless the passed variable is a non-empty list.
function die_unless_list_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_list_nonempty "${variable_name}" or
        die "${2:-\"${variable_name}\" not a non-empty list}"
}

# ....................{ TESTERS                            }....................
# boolean is_list(string variable_name)
#
# Return true if the passed variable is a list (i.e., array).
function is_list() {
    # Global lists have type "list", local lists "list-local", and internal
    # structures (e.g., "${path}") "array" or "array-special".
    die_unless_one_arg 'expected one variable name'
    is_variable_type_match "${1}" '(list|array)*'
}

# boolean is_list_empty(string variable_name)
#
# Return true if the passed variable is an empty list.
function is_list_empty() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    is_list "${list_name}" and (( ${#${(@P)list_name}} == 0 ))
}

# boolean is_list_nonempty(string variable_name)
#
# Return true if the passed variable is a non-empty list.
function is_list_nonempty() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    is_list "${list_name}" and (( ${#${(@P)list_name}} ))
}

# boolean is_list_element(string list_name, string element)
#
# Return true if the passed list contains the passed element.
function is_list_element() {
    # Validate passed arguments.
    die_unless_two_args 'expected one list name and one element'
    string list_name="${1}"
    die_unless_list "${list_name}"

    #FIXME: This is extendable into an is_list_element_matching() function
    #by simple expanding ${2} as ${~2} here.
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * "${(M)", ":#", and "}", excluding all but the passed element.
    is_nonempty "${(M)${(@P)list_name}:#${2}}"
}

# ....................{ GETTERS                            }....................
# integer get_list_size(string list_name)
#
# Get the number of elements in the list with the passed name.
function get_list_size() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Get list size. Dismantled, this is:
    #
    # * '1', the passed list name.
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * '#', the size of this list.
    output_string ${#${(@P)list_name}}
}

# ....................{ SETTERS                            }....................
# void set_list_to_evaluation(string list_name, string code)
#
# Set the passed list to the dynamic evaluation of the passed code in a list
# context (i.e., in an expression "( ${code} )"): e.g.,
#
#     >>> list ndaa
#     >>> set_list_to_evaluation ndaa '${(z)$(uname -a)}'
#     >>> output_string "${ndaa[-1]}"
#     GNU/Linux
function set_list_to_evaluation() {
    # Validate passed arguments.
    die_unless_two_args 'expected one list name and one code snippet'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Set such list.
    eval "${list_name}=( ${2} )"
}

# ....................{ SETTERS ~ set                      }....................
# void set_list_to_list_difference(
#   string result_list_name, string left_list_name, string right_list_name)
#
# Difference the first and second passed lists into the third. Considering each
# such list a list set (i.e., ignoring duplicate elements) and abbreviating
# B="${left_list_name}", C="${right_list_name}", and A="${result_list_name}",
# this function implements the asymmetric set difference A = B - C of B and C:
# e.g.,
#
#     >>> list a
#     >>> list y; y=( 'slimy' 'things' 'did' 'crawl' 'with' 'legs' )
#     >>> list e; e=( 'upon' 'the' 'slimy' 'sea' )
#     >>> set_list_to_list_difference a y e
#     >>> output_string "${a[@]}"
#     things did crawl with legs
function set_list_to_list_difference() {
    # Validate passed arguments.
    die_unless_three_args\
        'expected one target list name and two source list names'
    string target_list_name="${1}" left_list_name="${2}" right_list_name="${3}"
    die_unless_list "${target_list_name}"
    die_unless_list "${left_list_name}"
    die_unless_list "${right_list_name}"

    # Difference. Bless your pithy soul, Zsh 5.0.0. Dismantled, this is:
    #
    # * "(@P)left_list_name", expanding all elements of the first passed list.
    # * ":|", excluding all elements of the second passed list.
    set_list_to_evaluation "${target_list_name}"\
        "\"\${(@P)left_list_name:|${right_list_name}}\""
}

# void set_list_to_list_intersection(
#   string target_list_name,
#   string source_list_name1, string source_list_name2, ...)
#
# Intersect all lists with the passed source names into the list with the passed
# target name. Considering each such list a list set (i.e., ignoring duplicate
# elements) and abbreviating BN="${source_list_nameN}" (e.g.,
# B1="${source_list_name1}") and A="${target_list_name}", this function
# performs the set intersection A = B1 & B2 & ... & BN of B1 through BN: e.g.,
#
#     >>> list a
#     >>> list y; y=( slimy things did crawl with legs )
#     >>> list e; e=( upon the slimy sea )
#     >>> list h; a=( and a thousand thousand slimy things )
#     >>> set_list_to_list_intersection a y e h
#     >>> print "${h[@]}"
#     slimy
function set_list_to_list_intersection() {
    # Validate passed arguments, popping the last such argument off as the
    # target list name. Hence, all remaining arguments are source list names.
    die_unless_at_least_three_args\
        'expected one target list name and at least two source list names'
    string\
        target_list_name="${@[1]}"\
        source_list_name1="${@[2]}" source_list_name2="${@[3]}"
    die_unless_list "${target_list_name}"
    die_unless_list "${source_list_name1}"
    die_unless_list "${source_list_name2}"
    shift_three_args

    # Intersect the first two source lists into the target list. Dismantled,
    # this is:
    #
    # * "${...:*...}", performing the symmetric set intersection of:
    #   * "(@P)1", the first source list.
    #   * "${2}", the name of the second source list.
    set_list_to_evaluation "${target_list_name}"\
        "\"\${(@P)source_list_name1:*${source_list_name2}}\""

    # Intersect each remaining source list with the target list back into the
    # target list. Bless your extreme utility, Zsh 5.x.x.
    for source_list_name ("${@}") {
        die_unless_list "${source_list_name}"
        set_list_to_evaluation "${target_list_name}"\
            "\"\${(@P)source_list_name:*${target_list_name}}\""
    }
}

# ....................{ SETTERS ~ prepend                  }....................
# void prepend_list_with_string(string list_name, string text)
#
# Add the passed string to the beginning of the passed list: e.g.,
#
#    >>> list khazad_dum; khazad_dum=( 'from ashes' 'and fire' 'be broken' )
#    >>> prepend_list_with_string khazad_dum 'a light from the shadows'
#    >>> output_string "${khazad_dum[1]} ${khazad_dum[2]}"
#    a light from the shadows from ashes
function prepend_list_with_string() {
    die_unless_two_args 'expected one list name and one string'
    string list_name="${1}" __text__="${2}"
    set_list_to_evaluation "${list_name}" '"${__text__}" "${list_name[@]}"'
}

# ....................{ CHECKERS                           }....................
#FIXME: Honestly, this is functionally useless as defined. We really want two
#separate functions, I should think:
#
#* die_unless_list_indices(), basically just check_list_args() renamed.
#* die_unless_list_index(), accepting and testing just one index.
#
#Also, accepting index names rather than values is simply odd; there doesn't
#appear to be any reasonable justification for this in the code, so just revert
#to proper values.

# void check_list_args(
#   string list_name, string start_index_name, string end_index_name)
#
# Check the passed list-centric variables for sanity and, if sane, set such
# variables to sensible defaults. Specifically:
#
# * Throw an exception if no list with the passed name exists.
# * Throw an exception if the variable with the passed start index is empty but
#   the variable with the passed end index is not.
# * If both the variables with the passed start and end indices are empty,
#   default the former to "1" (i.e., the first list index) and the latter to
#   "-1" (i.e., the last list index). Such indices thus span the entire list.
# * If only the variable with the passed end index is empty, default such
#   variable to the same value as that of the passed start index. Such indices
#   thus span the single list element for the passed start index.
# * Throw an exception if the variables with such start and end indices are not
#   non-zero integers bounded by [-list_size, list_size].
# * Throw an exception if the start index is greater than the end index.
#
# In short, this function guarantees bounded list indices.
function check_list_args() {
    # Validate sanity, intentionally obfuscating local variable names to avoid
    # unintentionally masking caller list names.
    die_unless_one_to_three_args\
        'expected one list name, one start index name, and one end index name'
    string\
        __list_name__="${1}" __list_size__ __beg_index__ __end_index__\
        __beg_index_name__="${2}" __end_index_name__="${3}"\
    __list_size__="$(get__list_size "${__list_name__}")"

    # Default indices.
    if is_empty "${__beg_index_name__}"; then
        die_if_nonempty_variable "${__end_index_name__}"\
            "start index \"${__beg_index_name__}\" empty but end index \"${__end_index_name__}\" non-empty"
        __beg_index__=1
        __end_index__=${__list_size__}
    elif is_empty "${__end_index_name__}"; then
        __beg_index__=${(P)__beg_index_name__}
        __end_index__=${__beg_index__}
    else
        __beg_index__=${(P)__beg_index_name__}
        __end_index__=${(P)__end_index_name__}
    fi
    die_unless_string_integer "${__beg_index__}"
    die_unless_string_integer "${__end_index__}"

    # Validate indices, converting negative to positive indices to simplify
    # comparison. Preserve original indices for pretty printing.
    integer _new_beg_index__=${__beg_index__} _new_end_index__=${__end_index__}
    (( _new_beg_index__ > 0 )) or (( _new_beg_index__ += __list_size__ + 1 ))
    (( _new_end_index__ > 0 )) or (( _new_end_index__ += __list_size__ + 1 ))
    (( 1 <= _new_beg_index__ && _new_beg_index__ <= __list_size__ )) or
        die "list index ${__beg_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
    (( 1 <= _new_end_index__ && _new_end_index__ <= __list_size__ )) or
        die "list index ${__end_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
    (( _new_beg_index__ <= _new_end_index__ )) or
        die "start index ${__beg_index__} > end index ${__end_index__}"

    # Since indices validate, set index variables to the prior defaults.
    set_string ${__beg_index_name__} ${_new_beg_index__}
    set_string ${__end_index_name__} ${_new_end_index__}
}

# ....................{ CONVERTERS                         }....................
# string convert_list_to_restorable_string(string list_name)
#
# Get a string corresponding to the contents of the list with the passed name.
# To losslessly restore such string into a list identical to such list, either:
#
# * Pipe the return value of this function to restore_list(), automatically
#   restoring such string into a local list named "list". (Easy; inflexible.)
# * Manually apply parameter expansion flag "(z)" to the return value of this
#   function in a list assignment to any list you like. (Harder; flexible.)
#
# For example: e.g.,
#
#   # Declare a function returning a restorable string.
#   >>> get_minerals() {
#   ...     list asbestos
#   ...     asbestos=( 'nephrite' 'porphyry' 'glauconite' 'mafic' )
#   ...     convert_list_to_restorable_string asbestos
#   ... }
#
#   # Automatically restore such string back into a local list named "list".
#   >>> get_minerals | restore_list
#   >>> output_string "${list[1]}"
#   nephrite
#
#   # Or (manually) restore such string back into a local list named... whatever
#   # you like, man!
#   >>> list quebec_resources; quebec_resources=( ${(z)"$(get_minerals)"} )
#   >>> output_string "${quebec_resources[-1]}"
#   mafic
function convert_list_to_restorable_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Dismantled, this is:
    #
    # * '1:-list' expands to the passed list name or 'list' if no such name
    #   was passed.
    # * 'P' transitively expands this name to the actual name of the desired
    #   associative list in the caller's scope.
    # * '@' interprets this expansion as a list rather than scalar.
    # * 'qq' protectively embeds all reserved shell characters in such names
    #   and values in single quotes.
    output_string "${(qq@P)list_name}"
}

# ....................{ REMOVERS                           }....................
#FIXME: Shift to "path" and complete implementation.
#function remove_list_paths_not_found() {
    # Filter non-extant paths from the passed paths. Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed path.
    # * "(e:...:), excluding paths failing the test:
    #   * '[[ -e "${REPLY}" ]]', succeeding only for extant paths.
#    set_args "${^@}"(e:'[[ -e "${REPLY}" ]]':)
#}

# --------------------( WASTELANDS                         )--------------------
# void write_script_file_with_variable(string filename, string variable_name)
#           "${(@P)__list_sans_last_element__}"\

#FIXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_one_or_two_args\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
#}

#FIXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_one_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_at_least_three_args; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_delimitermunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_two_args
#   then output_string "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else output_string "${1}"
#   fi

#FIXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the passed arguments.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FIXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_USER_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FIXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps output_restorable_list()? AH! Got it: convert_list_to_restorable_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which Zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FIXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_at_least_two_args\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_one_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_variable List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
