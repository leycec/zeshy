#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle globs matching list elements.

# ....................{ GETTERS                            }....................
# string get_list_match_first(string list_name, string glob_pattern)
#
# Get the first element of the passed list matching the passed glob or throw an
# exception if no element matches.
function get_list_match_first() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'

    # Return such element if found or throw an exception. Avoid subscript flag
    # "(r)", which expands to the empty string if no such element matches. Such
    # expansion is indistinguishable from a successful match, if the first such
    # match is the empty string (e.g., with glob "*").
    integer __index__
    if __index__="$(get_list_match_first_index_if_found "${@}")"
    then print_string "${${(@P)list_name}[${__index__}]}"
    else
        string list_name="${1}" __glob__="${2}"
        die "no element of list \"${list_name}\" matching \"${__glob__}\""
    fi
}

# string get_list_match_first_if_found(string list_name, string glob_pattern)
#
# Get the first element of the passed list matching the passed glob or return
# false if no element matches.
function get_list_match_first_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'

    # Return such element if found or false.
    integer __index__
    if __index__="$(get_list_match_first_index_if_found "${@}")"
    then print_string "${${(@P)list_name}[${__index__}]}"
    else return_false
    fi
}

# ....................{ GETTERS ~ index                    }....................
#FIXME: Once we validate this works as expected, implement the converse
#get_last_list_element_matching() function by using flag "(R)" where we
#currently use flag "(r)".

# integer get_list_match_first_index(string list_name, string glob)
#
# Get the 1-based index of the first element of the passed list matching the
# passed glob or throw an exception if no element matches.
function get_list_match_first_index() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'

    # Return such index if found or throw an exception.
    integer __index__
    if __index__="$(get_list_match_first_index_if_found "${@}")"
    then print_string "${__index__}"
    else
        string list_name="${1}" __glob__="${2}"
        die "no element of list \"${list_name}\" matching \"${__glob__}\""
    fi
}

# integer get_list_match_first_index_if_found(string list_name, string glob)
#
# Get the 1-based index of the first element of the passed list matching the
# passed glob or return false if no element matches.
function get_list_match_first_index_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'
    string list_name="${1}" __glob__="${2}"
    die_unless_list "${list_name}"

    # Get the first matching index. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'i', expanding to the index of the first element matching...
    # * "${~__glob__}", the passed glob as a glob.
    integer __index__
    __index__="${${(@P)list_name}[(i)${~__glob__}]}"

    # Return such index if found or false.
    (( __index__ <= $(get_list_size list_name) )) and
        print_string "${__index__}"
}

# integer get_list_match_first_index_after_index_if_found(
#   string list_name, string glob, string index)
#
# Get the 1-based index of the first element of the passed list matching the
# passed glob strictly *AFTER* the passed index or return false if no element
# matches.
function get_list_match_first_index_after_index_if_found() {
    # Validate passed arguments.
    die_unless_args_3 'expected one list name, one glob, and one index'
    string list_name="${1}" __glob__="${2}" __offset__="${3}" __list_size__
    die_unless_list "${list_name}"

    #FIXME: Call die_unless_list_index() instead.
    # Validate such index, permitting index 0 as well as normal 1-based indices.
    __list_size__="$(get_list_size "${list_name}")"
    (( __offset__ >= 0 && __offset__ < __list_size__ )) or
        die "list \"${list_name}\" index ${__offset__} not in [0, ${__list_size__})"

    # Begin searching at the next such index. Since Zsh supplies no builtin
    # means of finding from some index (subscript flag "(i)" always matches from
    # index 1), consider the following clever alternative:
    #
    # * Copy the *ENTIRE* subset of such list after such index into a new list.
    # * Search such list with subscript flag "(i)".
    # * Offset the matching index if found by the passed index.
    #
    # In the worst case, such copy duplicates such list. While unfortunate, this
    # is considerably faster (if memory intensive) than manual iteration.
    list __copy__
    __copy__=( "${${(@P)list_name}[$(( __offset__ + 1 )),]}" )
    integer __index__
    if __index__="$(get_list_match_first_index_if_found __copy__ "${__glob__}")"
    then print_string $(( __index__ + __offset__ ))
    else return_false
    fi
}

# ....................{ SETTERS                            }....................
# void set_list_to_list_matches(
#   string target_list_name, string source_list_name, string glob)
#
# Set the passed target list to the passed source list including only elements
# matching the passed glob.
function set_list_to_list_matches() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name, one source list name, and one glob'
    string list_name_target="${1}" list_name_source="${2}" __glob__="${3}"
    die_unless_list "${list_name_target}"
    die_unless_list "${list_name_source}"

    # Remove non-matching elements. Dismantled, this is:
    #
    # * "(M)" and ":#", removing all passed source list elements not matching...
    # * "${~glob}", the passed glob as a glob rather than raw string.
    set_list_to_evaluation "${list_name_target}"\
        "\${(M)${list_name_source}[@]:#\${~__glob__}}"
}

# void set_list_to_list_nonmatches(
#   string target_list_name, string source_list_name, string glob)
#
# Set the passed target list to the passed source list excluding all elements
# matching the passed glob.
function set_list_to_list_nonmatches() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name, one source list name, and one glob'
    string list_name_target="${1}" list_name_source="${2}" __glob__="${3}"
    die_unless_list "${list_name_target}"
    die_unless_list "${list_name_source}"

    # Remove matching elements. Dismantled, this is:
    #
    # * ":#", removing all passed source list elements matching...
    # * "${~glob}", the passed glob as a glob rather than raw string.
    set_list_to_evaluation "${list_name_target}"\
        "\${${list_name_source}[@]:#\${~__glob__}}"
}

# ....................{ SETTERS ~ position                 }....................
# void set_list_to_list_match_first_until_end(
#   string target_list_name, string source_list_name, string glob)
#
# Set the passed target list to all elements of the passed source list after and
# including the first element matching the passed glob. If no such element
# matches, throw an exception.
function set_list_to_list_match_first_until_end() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name, one source list name, and one glob'
    string list_name_target="${1}" list_name_source="${2}" __glob__="${3}"
    die_unless_list "${list_name_target}"
    die_unless_list "${list_name_source}"

    # Find the first matching index.
    integer __index__
    __index__="$(get_list_match_first_index_if_found\
        "${list_name_source}" "${__glob__}")" or
        die "no element of list \"${list_name_source}\" matching \"${__glob__}\""

    # Set such list.
    set_list_to_evaluation "${list_name_target}"\
        "\${${list_name_source}[${__index__},]}"
}

# void set_list_to_list_match_first_until_next(
#   string target_list_name,
#   string source_list_name,
#   string first_glob,
#   string next_glob = "${first_glob}")
#
# Set the passed target list to all elements of the passed source list both:
#
# * Following the first element matching the first passed glob, including such
#   element. If no such element matches, throw an exception.
# * Preceding the next element matching the second passed glob, excluding such
#   element. If no such element matches, include all remaining elements, thus
#   mimicking set_list_to_list_match_first_until_end().
function set_list_to_list_match_first_until_next() {
    # Validate passed arguments.
    die_unless_args_3_to_4\
        'expected one target list name, one source list name, one first glob, and optional next glob'
    string\
        list_name_target="${1}" list_name_source="${2}"\
        __glob_first__="${3}" __glob_next__
    __glob_next__="${4-${__glob_first__}}"
    die_unless_list "${list_name_target}"
    die_unless_list "${list_name_source}"

    # Find the first matching index.
    integer __index_first__ __index_next__
    __index_first__="$(get_list_match_first_index_if_found\
        "${list_name_source}" "${__glob_first__}")" or
        die "no element of list \"${list_name_source}\" matching \"${__glob_first__}\""

    # Find the next matching index. If no such match, default to the last index.
    if __index_next__="$(get_list_match_first_index_after_index_if_found\
        "${list_name_source}" "${__glob_next__}")"
    then (( --__index_next__ ))
    else __index_next__="$(get_list_size "${list_name_source}")"
    fi

    # Set such list.
    set_list_to_evaluation "${list_name_target}"\
        "\${${list_name_source}[${__index_first__},${__index_next__}]}"
}

# ....................{ REMOVERS                           }....................
# void remove_list_matches(string list_name, string glob)
#
# Remove all elements matching the passed glob from the passed list.
function remove_list_matches() {
    die_unless_args_2 'expected one list name and one glob'
    string list_name="${1}" __glob__="${2}"
    set_list_to_list_nonmatches "${list_name}" "${list_name}" "${glob}"
}

# void remove_list_nonmatches(string list_name, string glob)
#
# Remove all elements *NOT* matching the passed glob from the passed list.
function remove_list_nonmatches() {
    die_unless_args_2 'expected one list name and one glob'
    string list_name="${1}" __glob__="${2}"
    set_list_to_list_matches "${list_name}" "${list_name}" "${glob}"
}

# ....................{ REMOVERS ~ position                }....................
# void remove_list_nonmatches_before_and_after_inclusive(
#   string list_name,
#   string first_glob,
#   string next_glob = "${first_glob}")
#
# Remove all elements from the passed list either:
#
# * Preceding the first element matching the first passed glob, excluding such
#   element. If no such element matches, throw an exception.
# * Following the next element matching the second passed glob, including such
#   element. If no such element matches, remove no such elements, thus
#   mimicking remove_list_nonmatches_before().
function remove_list_nonmatches_before_and_after_inclusive() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one list name, one first glob, and optional next glob'
    string list_name="${1}"
    shift_one_arg

    # Remove such non-matches.
    set_list_to_list_match_first_until_next "${list_name}" "${list_name}" "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#   string text="${1}" glob_first="${2}" glob_next
#   glob_next="${4-${glob_first}}"
# void remove_list_nonmatches_before_match_first_or_match_next_and_after(
# after and
# including the first element matching the first passed glob until but
# excluding the next element matching the second passed glob. If no element
# matches the first passed glob, throw an exception. However, if no element
# matches the second passed glob, simply include all remaining elements, thus
# mimicking set_list_to_list_match_first_until_end().
    #FUXME: It might actually be more efficient to copy the entire subset of the
    #passed list following such index into a new temporary list for searching,
    #as "(i)" *WOULD* work on such temporary. Actually, yes... this is most
    #certainly more efficient.
#   for (( ++__index__; __index__ <= __list_size__; ++__index__ )) {
#       is_string_match\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    #FUXME: Not right. An empty element could in fact match a non-empty glob
    #(e.g., "*"), in which case testing emptiness does not suffice. Instead,
    #call get_list_match_first_index() and note this subtlety.
    # Get the first match. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'r', expanding to the first element matching...
    # * "${~glob}", the passed glob as a glob rather than raw string.
#   __element__="${${(@P)list_name}[(r)${~__glob__}]}"

    # Throw an exception if no element matches.
#   die_if_string_empty "${__element__}"\
#       "no element of list \"${list_name}\" matches \"${__glob__}\""

    # Otherwise, return such element.
#   print_string "${__element__}"
    # Find the first match.
#   integer __index__ __list_size__
#   __list_size__="$(get_list_size "${list_name}")"
#   for (( __index__ = 0; __index__ < __list_size__; ++__index__ )) {
#       is_string_match\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    # Throw an exception if no element matches.
#   (( __index__ < __list_size__ )) or
#       die "no element of list \"${list_name}\" matches \"${__glob__}\""

# void set_list_to_list_excluding_elements_preceding_match(
# void set_list_to_list_excluding_matches(
# void set_list_to_list_including_only_matches(
#FUXME: Order of function arguments is, arguably, somewhat ad hoc. Switch the
#source_list_name and glob arguments, perhaps?
# void remove_list_elements_matching(
#   string source_list_name, string glob,
#   string target_list_name = "${source_list_name}")
#
# Copy all elements of the passed source list *NOT* matching the passed glob
# into the passed target list (defaulting to the passed source list). If passed
# only two arguments, remove all matching source list elements "in-place." This
# function implements the inverse of retain_list_elements_matching().
#function set_list_to_list_without_elements_matching() {
#function remove_list_elements_matching() {
#   if is_args_2; then
#       list_name_source="${list_name_target}"
#       __glob__="${2}"
#   else
#       list_name_source="${2}"
#       __glob__="${3}"
#   fi
