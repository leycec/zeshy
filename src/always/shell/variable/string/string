#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string variables.

# ....................{ EXCEPTIONS                         }....................
#FIXME: For consistency, the following functions should be renamed
#die_unless_variable_string(), die_unless_variable_character(), and so on.
#Naturally, that implies similar renamings of list *TYPE TESTING* functions to
#die_unless_variable_list(), die_unless_variable_map(), is_variable_list(), and
#so on. *BUT STOP THERE.* Rename only functions testing variable types in this
#manner; all other existing functions (in particular, non-type testing list and
#map functions such as join_list_on_newline() and get_list_size()) *RETAIN THEIR
#EXISTING FUNCTION NAMES*. This gives us the best of all worlds: consistent
#naming for functions testing variable type, concise and consistent naming for
#list and map functions, and concise and consistent naming for string functions.
#
#This is good. It's a simple patch, so make it so.

document_function '
void die_unless_string(
  string variable_name,
  string error_message = "\"${variable_name}\" not a string")

Throw an exception unless the passed variable is a string.
'
function die_unless_string() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    is_string "${1}" or die "${2:-\"${1}\" not a string}"
}

document_function '
void die_unless_character(
  string variable_name,
  string error_message = "\"${variable_name}\" not a string or longer than one character")

Throw an exception unless the passed variable is a single-character string.
'
function die_unless_character() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    is_character "${1}" or
        die "${2:-\"${1}\" not a string or longer than one character}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_string(string variable_name)

Return true if the passed variable is a string.
'
function is_string() {
    die_unless_arg 'expected one variable name'
    is_variable_type_match "${1}" 'scalar*'
}

document_function '
boolean is_character(string variable_name)

Return true if the passed variable is a single-character string.
'
function is_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    string variable_name="${1}"

    # Test the passed variable.
    is_string "${variable_name}" and (( ${#${(P)variable_name}} == 1 ))
}

# ....................{ TESTERS ~ emptiness                }....................
document_function '
boolean is_string_empty(string text)

Return true if the passed string is empty.
'
function is_string_empty() {
    die_unless_arg 'expected one string'
    is -z "${1}" si
}

document_function '
boolean is_string_nonempty(string text)

Return true if the passed string is empty.
'
function is_string_nonempty() {
    die_unless_arg 'expected one string'
    is -n "${1}" si
}

# ....................{ TESTERS ~ text                     }....................
document_function '
boolean is_string_equals(string text1, string text2)

Return true if the two passed strings are identical.
'
function is_string_equals() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected two strings'
    is "${1}" == "${2}" si
}

document_function '
boolean is_string_substring(string text, string substring)

Return true if the passed string contains the passed substring.
'
function is_string_substring() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one substring'
    is "${1}" == *"${2}"* si
}

document_function '
boolean is_string_prefix(string text, string prefix)

Return true if the passed string is prefixed by the passed prefix.
'
function is_string_prefix() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one prefix'
    is "${1}" == "${2}"* si
}

document_function '
boolean is_string_suffix(string text, string suffix)

Return true if the passed string is suffixed by the passed suffix.
'
function is_string_suffix() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one suffix'
    is "${1}" == "${2}"* si
}

# ....................{ GETTERS                            }....................
document_function '
integer get_string_length(string text1, string text2, ...)

Get the total length of the passed strings in single-byte characters. If any
such string contains multibyte characters (e.g., UTF-8-encoded Unicode), this
may not be what you expect.
'
function get_string_length() {
    # Due to Zsh eccentricity, this expansion *CANNOT* be reduced to either
    # "${#*}", "${#@}", or "${#${@}}". However sensible such expansions may
    # seem, they all obstinately return the number of passed arguments. *sigh*
    die_unless_args 'expected at least one string'
    print_string "${#${*}}"
}

document_function '
integer get_string_length_multibyte(string text)

Get the length of the passed string in multibyte characters.
'
function get_string_length_multibyte() {
    die_unless_args 'expected at least one string'
    print_string "${(m)#${*}}"  # see get_string_length()
}

document_function '
integer get_string_length_multibyte_sans_ansi_color_codes(
  string text1, string text2, ...)

Get the total length of the passed strings in multibyte characters *AFTER*
removing ANSI color codes from such strings.
'
function get_string_length_multibyte_sans_ansi_color_codes() {
    die_unless_args 'expected at least one string'
    get_string_length_multibyte "$(remove_string_ansi_color_codes "${@}")"
}

# ....................{ GETTERS ~ count                    }....................
document_function '
string get_string_substring_count(string string, string substring)

Get the number of instances of the passed substring in the passed string:
e.g.,

  >>> get_string_substring_count "cult of radical consumerism" "c"
  3
'
function get_string_substring_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
    die_unless_args_2 'expected one string and one substring'
    string text="${1}" substring="${2}" string_sans_substring
    string_sans_substring="${text//${substring}}"
    print_string $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
}

# ....................{ GETTERS ~ columns                  }....................
#FIXME: It'd be nice to generalize this to accept arbitrary regular expressions
#against which to match (e.g., "\s+", matching column delimiters as any run of
#whitespace). Actually, that suggests a new complementary
#get_string_columns_matching_pcre() function.
#FIXME: It'd be nice to generalize this to multiple columns. We'll probably want
#to implement a for_each_string_line_match()-style function to do so -- say,
# string for_each_string_line_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_delimiter_class = '[:space:]')

document_function '
string get_string_column(
  string text,
  integer column_index,
  character column_delimiter_class = "[:space:]")

Get the column delimited by the passed delimiter character class (defaulting
to whitespace) with the passed 1-based index from the passed string: e.g.,

  >>> get_string_columns "
  ...     Capitalist society, however,
  ...     can only survive
  ...     by defying the
  ...     laws of thermodynamics,
  ...     through endlessly expanding
  ...     growth, buying and
  ...     using more of
  ...     everything, every year
  ...     and forever." 2
  society
  only
  defying
  of
  endlessly
  buying
  more
  every
  forever.

If requiring more than one column, consider calling
for_each_string_line_match_pcre(), whose generality is suitable to such tasks.
'
function get_string_column() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one column index, and optional column delimiter'
    list lines; lines=( ${(f)1} )
    string column_index="${2}" column_delimiter_class="${3:-[:space:]}"
    die_unless_string_integer_positive "${column_index}"
    die_unless_variable_nonempty column_delimiter_class

    # Glob expressions matching all columns preceding the passed column and
    # the passed column. Dismantled, this is:
    #
    # * "(...)", a non-match group matching a column including the suffixing
    #   column delimiter via:
    #   * "[^${column_delimiter}]#", zero or more characters excluding the
    #     column delimiter.
    #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
    # * "(#c${prior_column_index})", matching such columns up to but not
    #   including the passed column.
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible, for minor and
    #   probably immeasurable efficiency.
    # * "([^${column_delimiter}]#)", a match group matching the passed
    #   column excluding the suffixing column delimiter.
    string this_column_glob last_columns_glob
    this_column_glob="(#b)([^${column_delimiter_class}]#)(${column_delimiter_class}|(#e))"
    (( column_index > 1 )) and
        last_columns_glob="([^${column_delimiter_class}]#(${column_delimiter_class}|(#e)))(#c$(( column_index - 1 )))"
#       integer last_column_index=$(( ${column_index} - 1 ))
#       last_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"

    # Split the passed column.
    print_string_delimited_by_newline\
        ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
}

# ....................{ GETTERS ~ words                    }....................
document_function '
string get_string_word(string text, integer word_index)

Get the word corresponding to the passed 1-based index from the passed string.
'
function get_string_word() {
    die_unless_args_2 'expected one string and one index'
    print_string "${1[(w)${2:-1}]}"
}

document_function '
integer get_string_word_count(string text, string text2, ...)

Get the number of words in the passed string, aggregating each quoted
substring into one shell word. Hence, this is a shell-specific word count.
'
function get_string_word_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

document_function '
integer get_string_word_count_unquoted(string text1, string text2, ...)

Get the number of words in the passed string, *NOT* aggregating quoted
substrings. Hence, this is the conventional document word count.
'
function get_string_word_count_unquoted() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ SETTERS                            }....................
document_function '
void set_string(string variable_name, string text)

Set the passed variable to the passed string: e.g.,

  >>> string machine_elf="tyke" tyke
  >>> set_string "${machine_elf}" "self-transforming basketball"
  >>> print_string "${tyke}"
  self-transforming basketball
'
function set_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string.
    noop ${(P)string_name::=${2}}
}

document_function '
void set_string_if_unset(string variable_name, string text)

Set the passed variable if unset to the passed string: e.g.,

  >>> string gnomes_say="hooray" hooray
  >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
  >>> print_string "${hooray}"
  lesser lights of the Bardo
'
function set_string_if_unset() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string if unset.
    noop ${(P)string_name=${2}}
}

document_function '
void set_string_if_unset_or_empty(string variable_name, string text)

Set the passed variable if unset or empty to the passed string: e.g.,

  >>> string fifty_fourth_fragment="heraclitis" heraclitis=""
  >>> set_string_if_unset_or_empty "${fifty_fourth_fragment}" "Aeon"
  >>> print_string "${fifty_fourth_fragment}"
  Aeon
'
function set_string_if_unset_or_empty() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string if unset or empty.
    noop ${(P)string_name:=${2}}
}

document_function '
void set_string_if_unset_or_empty_to_evaluation(
  string string_name, string code)

Set the passed variable if unset or empty to the dynamic evaluation of the
passed code in a double-quoted context (i.e., in an expression "${code}").
'
function set_string_if_unset_or_empty_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string if unset or empty to such evaluation.
    is_variable_nonempty "${string_name}" or eval "${string_name}=\"${2}\""
}

# ....................{ CONVERTERS                         }....................
document_function '
string capitalize_string(string text1, string text2, ...)

Capitalize the first letter of each word of the passed strings: e.g.,

  >>> capitalize_string "phase two: ???" "phase three: profit"
  Phase Two: ??? Phase Three: Profit
'
function capitalize_string() {
    die_unless_args 'expected at least one string'
    print_string "${(C)*}"
}

document_function '
string lowercase_string(string text1, string text2, ...)

Convert the passed string to all lowercase_string: e.g.,

  >>> lowercase_string "The Wind in" "the Pillows"
  the wind in the pillows
'
function lowercase_string() {
    die_unless_args 'expected at least one string'
    print_string "${(L)*}"
}

document_function '
string uppercase_string(string text1, string text2, ...)

Convert the passed string to all uppercase_string: e.g.,

  >>> uppercase_string "The Pyre of" "My Loins"
  THE PYRE OF MY LOINS
'
function uppercase_string() {
    die_unless_args 'expected at least one string'
    print_string "${(U)*}"
}

# ....................{ MUNGERS                            }....................
document_function '
string prefix_string(string text, string prefix)

Prefix the passed string with the passed prefix, if not already: e.g.,

  >>> prefix_string "/creatures/collect/and/gather/" "/"
  /creatures/collect/and/gather/
'
function prefix_string() {
    die_unless_args_2 'expected one string and one prefix'
    print_string "${2}${1#${2}}"
}

document_function '
string suffix_string(string text, string suffix)

Suffix the passed string with the passed suffix, if not already: e.g.,

  >>> suffix_string "/habitat/failing/flailing/habits/" "/"
  /habitat/failing/flailing/habits/
'
function suffix_string() {
    die_unless_args_2 'expected one string and one suffix'
    print_string "${1%${2}}${2}"
}

document_function '
string repeat_string(string text, integer count)

Repeat the passed string the passed number of times: e.g.,

  >>> repeat_string "Slavoj Žižek" 5
  Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
'
function repeat_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one integer'
    string text="${1}" count="${2}"
    die_unless_variable_nonempty text
    die_unless_string_integer_positive "${count}"

    # Zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former command.
    # * Otherwise, run the latter command.
    if is_string_substring "${text}" ':'; then
        # Since printf() appends no implicit newline, do so.
        printf "${text}%.0s" {1..${count}}
        print_newline
    else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
    fi
}

document_function '
string tabulate_string(string text, string delimiter = " ")

Horizontally align the passed strings on the passed delimiter (defaulting to a
single space) into table columns.
'
function tabulate_string() {
    # Validate passed arguments, treating piped input as the passed string.
    set_args_to_standard_input_if_piped
    die_unless_args_1_to_2 'expected one string and optional delimiter'
    string text="${1}"

    # Tabulate.
    if is_args_1
    then print_string "${text}" | command column -t
    else print_string "${text}" | command column -t -s "${2}"
    fi
}

# ....................{ REMOVERS                           }....................
#FIXME: Rename to remove_string_substringss(). The current nomenclature implies
#removal of only one such substring, which is not the case.
document_function '
string remove_string_substrings(string text, string substring)

Remove all instances of the passed substring from the passed string: e.g.,

  >>> remove_string_substrings "thomas ligotti" "t"
  homas ligoi
'
function remove_string_substrings() {
    die_unless_args_2 'expected one string and one substring'
    print_string "${1//${2}}"
}

document_function '
string remove_string_prefix(string text, string prefix)

Remove the passed prefix from the passed string: e.g.,

  >>> remove_string_prefix "zealia brown" "zeal"
  ia brown
'
function remove_string_prefix() {
    die_unless_args_2 'expected one string and one prefix'
    print_string "${1##${2}}"
}

document_function '
string remove_string_suffix(string text, string suffix)

Remove the passed suffix from the passed string: e.g.,

  >>> remove_string_suffix "august derleth" "leth"
  august der
'
function remove_string_suffix() {
    die_unless_args_2 'expected one string and one suffix'
    print_string "${1%%${2}}"
}

document_function '
string truncate_string(
  string text, integer maximum_length, string text_suffix_if_truncated = '')

Truncate the passed string to the passed length, replacing the end of such
string with the passed suffix (defaulting to the empty string) if the passed
string exceeds such length: e.g.,

  >>> truncate_string "Fallujah" 7
  Falluja
  >>> truncate_string "Fallujah" 7 "..."
  Fall...
'
function truncate_string() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one length, and optional suffix'
    string text="${1}" max_length="${2}" text_suffix_if_truncated="${3:-}"
    die_unless_string_integer_positive "${max_length}"

    # If the passed string requires no truncation, return the same string.
    (( #text <= max_length )) and {
        print_string "${text}"
        return_true
    }

    # If a suffix was passed and the passed string is at least as long as such
    # suffix, truncate by replacing the end of the string with such suffix.
    if (( #text_suffix_if_truncated &&
          #text > #text_suffix_if_truncated )); then
        (( max_length -= #text_suffix_if_truncated ))
#       print "max_length: ${max_length}"
        print_string "${text[1,${max_length}]}${text_suffix_if_truncated}"
    # Otherwise, truncate without suffix replacement.
    else print_string "${text[1,${max_length}]}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#       integer suffix_length
#       suffix_length="$(get_string_length "${suffix_if_exceeding_max_length}")"
#       (( max_length >  suffix_length )) && {
#           (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
#           print_string "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
#           return_true
#       }
#   }

    # Otherwise, truncate without suffix replacement.
#   print_string "${text[1,${max_length}]}"

#FIXME: Bad. Remove entirely, replacing existing calls with
#die_unless_variable_nonempty().
# void die_unless_variable_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function die_unless_variable_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_variable_nonempty "${1}" or
#        die "${2:-\"${1}\" not a string or empty}"
#}

#FIXME: Bad. Remove entirely, replacing existing calls with
#is_variable_nonempty().
# boolean is_variable_nonempty(string variable_name)
#
# Return true if the passed variable is a nonempty string.
#function is_variable_nonempty() {
#    die_unless_arg 'expected one variable name'
#    string variable_name="${1}"
#    is_string "${variable_name}" and (( ${#${(P)variable_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"
# string get_string_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_delimiter = ' ')
#
# Get the columns delimited by the passed delimiter (defaulting to whitespace)
# having the passed 1-based indices from the passed string. This function is
# analogous to the "cut -f" command: e.g.,
#
#     >>> get_string_columns '
#     ...     Capitalist society, however,
#     ...     can only survive
#     ...     by defying the
#     ...     laws of thermodynamics,
#     ...     through endlessly expanding
#     ...     growth, buying and
#     ...     using more of
#     ...     everything, every year
#     ...     and forever.' 2
#     society
#     only
#     defying
#     of
#     endlessly
#     buying
#     more
#     every
#     forever.
#
# If passed:
#
# * One index, each print_string line directly provides that column.
# * Two or more indices, each print_string line lists such columns delimited by such
#   delimiter. Getting such columns then requires splitting such lines on such
#   delimiter (e.g., by calling set_list_to_string_split_on()).
#function get_string_columns() {
    # Validate passed arguments.
#    die_unless_args_3_or_more\
#        'expected one string, one column delimiter, and at least one column index'
#    string text="${1}"   column_delimiter="${2}"
#    die_unless_string column_delimiter
#    behead_args_2

    # If passed only one column index, such column is efficiently splittable
    # with pure Zsh. Do so, Sir Robin! Arguably, we needn't do so in Zsh; the
    # non-Zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
#    if is_args_1; then
        # Index of the column preceding the passed column.
#        die_unless_string_integer_positive "${1}"
#        integer last_column_index=$(( ${1} - 1 ))
#        list lines; lines=( ${(f)text} )

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column delimiter via:
        #   * "[^${column_delimiter}]#", zero or more characters excluding the
        #     column delimiter.
        #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_delimiter}]#)", a match group matching the passed
        #   column excluding the suffixing column delimiter.
#        string last_columns_glob this_column_glob
#        last_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"
#        this_column_glob="(#b)([^${column_delimiter}]#)(${column_delimiter}|(#e))"

        # Split the passed column.
#        print_string_delimited_by_newline\
#            ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure Zsh, the inefficiency (and complexity) of such hacks is fugly.
#    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
#        list   column_indices; column_indices=( "${@}" )
#        string column_indices_with_commas
#        column_indices_with_commas="$(join_list column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column delimiter.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such delimiter.
#        print_string "${text}" | cut -s\
#            -d "${column_delimiter}"\
#            -f "${column_indices_with_commas}"
#    fi
#}

#FIXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FIXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string is_string_substring(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    print_string "${*[(w)1]}"
#}

#       say "piped_input: $(get_standard_input_piped)"
#       text="$(get_standard_input_piped)"
    # Validate passed arguments.
#   print -lr -- "${(uf)@}"
#   print_string_delimited_by_newline ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           print_string ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FIXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize passed arguments.
#    die_unless_args_2_or_more\
#        'expected one line number and one or more strings'
#    die_unless_string_integer "${1}"
#    integer highlight_line_index="${1}" line_length
#    behead_arg
#    string text="${@}"

#FIXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list() to join_list_on() and
#join_join_list_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FIXME: Right. join_list() is simply too brief. join_join_list() reads
#better.

    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   curtail_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_NL_OPTIONS[@]}" )
#   print_string "${text}" | {
#       if is_shell_interactive
#       then "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FIXME: Implementable with pure-Zsh.
#   print_string "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_arg 'expected one string'
#   print_string "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_variable "${target_name_prefix}" or string ${target_name_prefix}
#   is_variable "${target_name_suffix}" or string ${target_name_suffix}
#   is_variable "${list_name}" or list "${list_name}"

#   die_unless_string "${target_name_prefix}"
#   die_unless_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
