#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string variables and values.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_string(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a string")
#
# Throw an exception unless the passed variable is a string.
function die_unless_string() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_string "${1}" or die "${2:-\"${1}\" not a string}"
}

# void die_unless_character(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a string or longer than one character")
#
# Throw an exception unless the passed variable is a single-character string.
function die_unless_character() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_character "${1}" or
        die "${2:-\"${1}\" not a string or longer than one character}"
}

# ....................{ TESTS                              }....................
# boolean is_string(string variable_name)
#
# Return true if the passed variable is a string.
function is_string() {
    die_unless_one_arg 'expected one variable name'
    is_variable_type_match "${1}" 'scalar*'
}

# boolean is_character(string variable_name)
#
# Return true if the passed variable is a single-character string.
function is_character() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}"

    # Test the passed variable.
    is_character "${variable_name}" and (( ${#${(P)variable_name}} == 1 ))
}

# ....................{ TESTS ~ match                      }....................
# boolean is_string_prefix(string text, string prefix)
#
# Return true if the passed string is prefixed by the passed prefix.
function is_string_prefix() {
    die_unless_two_args 'expected one string and one prefix'
    is "${1}" == "${2}"* si
}

# boolean is_string_suffix(string text, string suffix)
#
# Return true if the passed string is suffixed by the passed suffix.
function is_string_suffix() {
    die_unless_two_args 'expected one string and one suffix'
    is "${1}" == "${2}"* si
}

# boolean is_string_containing(string text, string substring)
#
# Return true if the passed string contains the passed substring.
function is_string_containing() {
    die_unless_two_args 'expected one string and one substring'
    is "${1}" == *"${2}"* si
}

# ....................{ GETTERS                            }....................
# integer get_string_length(string text1, string text2, ...)
#
# Get the total length of the passed strings in single-byte characters. If any
# such string contains multibyte characters (e.g., UTF-8-encoded Unicode), this
# may not be what you expect.
function get_string_length() {
    # Due to Zsh eccentricity, this expansion *CANNOT* be reduced to either
    # "${#*}", "${#@}", or "${#${@}}". However sensible such expansions may
    # seem, they all obstinately return the number of passed arguments. *sigh*
    die_unless_args 'expected at least one string'
    output "${#${*}}"
}

# integer get_string_length_multibyte(string text)
#
# Get the length of the passed string in multibyte characters.
function get_string_length_multibyte() {
    die_unless_args 'expected at least one string'
    output "${(m)#${*}}"  # see get_string_length()
}

# integer get_string_length_multibyte_sans_ansi_color_codes(
#   string text1, string text2, ...)
#
# Get the total length of the passed strings in multibyte characters *AFTER*
# removing ANSI color codes from such strings.
function get_string_length_multibyte_sans_ansi_color_codes() {
    die_unless_args 'expected at least one string'
    get_string_length_multibyte "$(remove_string_ansi_color_codes "${@}")"
}

# ....................{ GETTERS ~ count                    }....................
# string get_string_substring_count(string string, string substring)
#
# Get the number of instances of the passed substring in the passed string:
# e.g.,
#
#     >>> get_string_substring_count 'cult of radical consumerism' 'c'
#     3
function get_string_substring_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
    die_unless_two_args 'expected one string and one substring'
    string text="${1}" substring="${2}" string_sans_substring
    string_sans_substring="${text//${substring}}"
    output $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
}

# ....................{ GETTERS ~ columns                  }....................
#FIXME: It'd be nice to generalize this to accept arbitrary regular expressions
#against which to match (e.g., "\s+", matching column delimiters as any run of
#whitespace). Actually, that suggests a new complementary
#get_string_columns_matching_pcre() function.
#FIXME: It'd be nice to generalize this to multiple columns. We'll probably want
#to implement a for_each_string_line_match()-style function to do so -- say,
# string for_each_string_line_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_delimiter_class = '[:space:]')

# string get_string_column(
#   string text,
#   integer column_index,
#   character column_delimiter_class = '[:space:]')
#
# Get the column delimited by the passed delimiter character class (defaulting
# to whitespace) with the passed 1-based index from the passed string: e.g.,
#
#     >>> get_string_columns '
#     ...     Capitalist society, however,
#     ...     can only survive
#     ...     by defying the
#     ...     laws of thermodynamics,
#     ...     through endlessly expanding
#     ...     growth, buying and
#     ...     using more of
#     ...     everything, every year
#     ...     and forever.' 2
#     society
#     only
#     defying
#     of
#     endlessly
#     buying
#     more
#     every
#     forever.
#
# If requiring more than one column, consider calling
# for_each_string_pcre_line_match(), whose generality is suitable to such tasks.
function get_string_column() {
    # Validate passed arguments.
    die_unless_three_args\
        'expected one string, one column index, and optional column delimiter'
    list lines; lines=( ${(f)1} )
    string column_index="${2}" column_delimiter_class="${3:-[:space:]}"
    die_unless_string_integer_positive "${column_index}"
    die_unless_variable_nonempty column_delimiter_class

    # Glob expressions matching all columns preceding the passed column and
    # the passed column. Dismantled, this is:
    #
    # * "(...)", a non-match group matching a column including the suffixing
    #   column delimiter via:
    #   * "[^${column_delimiter}]#", zero or more characters excluding the
    #     column delimiter.
    #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
    # * "(#c${prior_column_index})", matching such columns up to but not
    #   including the passed column.
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible, for minor and
    #   probably immeasurable efficiency.
    # * "([^${column_delimiter}]#)", a match group matching the passed
    #   column excluding the suffixing column delimiter.
    string this_column_glob last_columns_glob
    this_column_glob="(#b)([^${column_delimiter_class}]#)(${column_delimiter_class}|(#e))"
    (( column_index > 1 )) and
        last_columns_glob="([^${column_delimiter_class}]#(${column_delimiter_class}|(#e)))(#c$(( column_index - 1 )))"
#       integer last_column_index=$(( ${column_index} - 1 ))
#       last_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"

    # Split the passed column.
    output_newline_delimited\
        ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
}

# ....................{ GETTERS ~ words                    }....................
# string get_string_word(string text, integer word_index)
#
# Get the word corresponding to the passed 1-based index from the passed string.
function get_string_word() {
    die_unless_two_args 'expected one string and one index'
    output "${1[(w)${2:-1}]}"
}

# integer get_string_word_count(string text, string text2, ...)
#
# Get the number of words in the passed string, aggregating each quoted
# substring into one shell word. Hence, this is a Zsh-specific word count.
function get_string_word_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

# integer get_string_word_count_unquoted(string text1, string text2, ...)
#
# Get the number of words in the passed string, *NOT* aggregating quoted
# substrings. Hence, this is the conventional document word count.
function get_string_word_count_unquoted() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ SETTERS                            }....................
# void set_string(string variable_name, string text)
#
# Set the passed variable to the passed string: e.g.,
#
#     >>> string machine_elf="tyke" tyke
#     >>> set_string "${machine_elf}" "self-transforming basketball"
#     >>> output "${tyke}"
#     self-transforming basketball
function set_string() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string.
    noop ${(P)string_name::=${2}}
}

# void set_string_if_unset(string variable_name, string text)
#
# Set the passed variable if unset to the passed string: e.g.,
#
#     >>> string gnomes_say='hooray' hooray
#     >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
#     >>> output "${hooray}"
#     lesser lights of the Bardo
function set_string_if_unset() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string if unset.
    noop ${(P)string_name=${2}}
}

# void set_string_if_unset_or_empty(string variable_name, string text)
#
# Set the passed variable if unset or empty to the passed string: e.g.,
#
#     >>> string fifty_fourth_fragment='heraclitis' heraclitis=""
#     >>> set_string_if_unset_or_empty "${fifty_fourth_fragment}" "Aeon"
#     >>> output "${fifty_fourth_fragment}"
#     Aeon
function set_string_if_unset_or_empty() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string if unset or empty.
    noop ${(P)string_name:=${2}}
}

# void set_string_if_unset_or_empty_to_evaluation(
#   string string_name, string code)
#
# Set the passed variable if unset or empty to the dynamic evaluation of the
# passed code in a double-quoted context (i.e., in an expression "${code}").
function set_string_if_unset_or_empty_to_evaluation() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one statement'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set such string if unset or empty to such evaluation.
    is_variable_nonempty "${string_name}" or eval "${string_name}=\"${2}\""
}

# ....................{ CONVERTERS                         }....................
# string capitalize_string(string text1, string text2, ...)
#
# Capitalize the first letter of each word of the passed strings: e.g.,
#
#     >>> capitalize_string "phase two: ???" "phase three: profit"
#     Phase Two: ??? Phase Three: Profit
function capitalize_string() {
    die_unless_args 'expected at least one string'
    output "${(C)*}"
}

# string lowercase_string(string text1, string text2, ...)
#
# Convert the passed string to all lowercase_string: e.g.,
#
#     >>> lowercase_string "The Wind in" "the Pillows"
#     the wind in the pillows
function lowercase_string() {
    die_unless_args 'expected at least one string'
    output "${(L)*}"
}

# string uppercase_string(string text1, string text2, ...)
#
# Convert the passed string to all uppercase_string: e.g.,
#
#     >>> uppercase_string "The Pyre of" "My Loins"
#     THE PYRE OF MY LOINS
function uppercase_string() {
    die_unless_args 'expected at least one string'
    output "${(U)*}"
}

# ....................{ MUNGERS                            }....................
# string prefix_string(string text, string prefix)
#
# Prefix the passed string with the passed prefix, if not already: e.g.,
#
#     >>> prefix_string '/creatures/collect/and/gather/' '/'
#     /creatures/collect/and/gather/
function prefix_string() {
    die_unless_two_args 'expected one string and one prefix'
    output "${2}${1#${2}}"
}

# string suffix_string(string text, string suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_string '/habitat/failing/flailing/habits/' '/'
#     /habitat/failing/flailing/habits/
function suffix_string() {
    die_unless_two_args 'expected one string and one suffix'
    output "${1%${2}}${2}"
}

# string repeat_string(string text, integer count)
#
# Repeat the passed string the passed number of times: e.g.,
#
#     >>> repeat_string "Slavoj Žižek" 5
#     Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
function repeat_string() {
    # Validate passed arguments.
    die_unless_two_args 'expected one string and one integer'
    string text="${1}" count="${2}"
    die_unless_variable_nonempty text
    die_unless_string_integer_positive "${count}"

    # Zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former command.
    # * Otherwise, run the latter command.
    if is_string_containing "${text}" ':'; then
        # Since printf() appends no implicit newline, do so.
        printf "${text}%.0s" {1..${count}}
        output_blank_line
    else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
    fi
}

# string tabulate_string(string text, string delimiter = ' ')
#
# Horizontally align the passed strings on the passed delimiter (defaulting to a
# single space) into table columns.
function tabulate_string() {
    # Validate passed arguments, treating piped input as the passed string.
    set_args_to_piped_input
    die_unless_one_or_two_args 'expected one string and optional delimiter'
    string text="${1}"

    # Tabulate.
    if is_one_arg
    then output "${text}" | column -t
    else output "${text}" | column -t -s "${2}"
    fi
}

# ....................{ REMOVERS                           }....................
# string remove_string_prefix(string text, string prefix)
#
# Remove the passed prefix from the passed string: e.g.,
#
#     >>> remove_string_prefix 'zealia brown' 'zeal'
#     ia brown
function remove_string_prefix() {
    die_unless_two_args 'expected one string and one prefix'
    output "${1##${2}}"
}

# string remove_string_suffix(string text, string suffix)
#
# Remove the passed suffix from the passed string: e.g.,
#
#     >>> remove_string_suffix 'august derleth' 'leth'
#     august der
function remove_string_suffix() {
    die_unless_two_args 'expected one string and one suffix'
    output "${1%%${2}}"
}

# string truncate_string(
#   string text, int maximum_length,
#   string suffix_if_exceeding_maximum_length = '')
#
# Truncate the passed string to the passed length, replacing the end of such
# string with the passed suffix (defaulting to the empty string) if the passed
# string exceeds such length: e.g.,
#
#     >>> truncate_string 'Fallujah' 7
#     Falluja
#     >>> truncate_string 'Fallujah' 7 '...'
#     Fall...
function truncate_string() {
    # Validate passed arguments.
    die_unless_two_or_three_args\
        'expected one string, one length, and optional suffix'
    string text="${1}" max_length="${2}" suffix_if_exceeding_max_length="${3:-}"
    die_unless_string_integer_positive "${max_length}"

    # If the passed string requires no truncation, return the same string.
    (( ${#text} <= max_length )) and {
        output "${text}"
        return_true
    }

    # If a suffix was passed and the passed string is at least as long as such
    # suffix, truncate by replacing the end of the string with such suffix.
    if is_nonempty "${suffix_if_exceeding_max_length}"; then
        integer suffix_length
        suffix_length=$(get_string_length "${suffix_if_exceeding_max_length}")
        if  (( max_length >  suffix_length )); then
            (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
            output "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
            return_true
        fi
    fi

    # Otherwise, truncate without suffix replacement.
    output "${text[1,${max_length}]}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Bad. Remove entirely, replacing existing calls with
#die_unless_variable_nonempty().
# void die_unless_variable_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function die_unless_variable_nonempty() {
#    die_unless_one_or_two_args\
#        'expected one variable name and optional error message'
#    is_variable_nonempty "${1}" or
#        die "${2:-\"${1}\" not a string or empty}"
#}

#FIXME: Bad. Remove entirely, replacing existing calls with
#is_variable_nonempty().
# boolean is_variable_nonempty(string variable_name)
#
# Return true if the passed variable is a nonempty string.
#function is_variable_nonempty() {
#    die_unless_one_arg 'expected one variable name'
#    string variable_name="${1}"
#    is_string "${variable_name}" and (( ${#${(P)variable_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"
# string get_string_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_delimiter = ' ')
#
# Get the columns delimited by the passed delimiter (defaulting to whitespace)
# having the passed 1-based indices from the passed string. This function is
# analogous to the "cut -f" command: e.g.,
#
#     >>> get_string_columns '
#     ...     Capitalist society, however,
#     ...     can only survive
#     ...     by defying the
#     ...     laws of thermodynamics,
#     ...     through endlessly expanding
#     ...     growth, buying and
#     ...     using more of
#     ...     everything, every year
#     ...     and forever.' 2
#     society
#     only
#     defying
#     of
#     endlessly
#     buying
#     more
#     every
#     forever.
#
# If passed:
#
# * One index, each output line directly provides that column.
# * Two or more indices, each output line lists such columns delimited by such
#   delimiter. Getting such columns then requires splitting such lines on such
#   delimiter (e.g., by calling set_list_to_string_split_on()).
#function get_string_columns() {
    # Validate passed arguments.
#    die_unless_at_least_three_args\
#        'expected one string, one column delimiter, and at least one column index'
#    string text="${1}"   column_delimiter="${2}"
#    die_unless_string column_delimiter
#    shift_two_args

    # If passed only one column index, such column is efficiently splittable
    # with pure Zsh. Do so, Sir Robin! Arguably, we needn't do so in Zsh; the
    # non-Zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
#    if is_one_arg; then
        # Index of the column preceding the passed column.
#        die_unless_string_integer_positive "${1}"
#        integer last_column_index=$(( ${1} - 1 ))
#        list lines; lines=( ${(f)text} )

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column delimiter via:
        #   * "[^${column_delimiter}]#", zero or more characters excluding the
        #     column delimiter.
        #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_delimiter}]#)", a match group matching the passed
        #   column excluding the suffixing column delimiter.
#        string last_columns_glob this_column_glob
#        last_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"
#        this_column_glob="(#b)([^${column_delimiter}]#)(${column_delimiter}|(#e))"

        # Split the passed column.
#        output_newline_delimited\
#            ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure Zsh, the inefficiency (and complexity) of such hacks is fugly.
#    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
#        list   column_indices; column_indices=( "${@}" )
#        string column_indices_with_commas
#        column_indices_with_commas="$(join_list_elements column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column delimiter.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such delimiter.
#        output "${text}" | cut -s\
#            -d "${column_delimiter}"\
#            -f "${column_indices_with_commas}"
#    fi
#}

#FIXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FIXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string is_string_containing(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    output "${*[(w)1]}"
#}

#       say "piped_input: $(get_piped_input)"
#       text="$(get_piped_input)"
    # Validate passed arguments.
#   print -lr -- "${(uf)@}"
#   output_newline_delimited ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           output ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FIXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize passed arguments.
#    die_unless_at_least_two_args\
#        'expected one line number and one or more strings'
#    die_unless_string_integer "${1}"
#    integer highlight_line_index="${1}" line_length
#    shift_one_arg
#    string text="${@}"

#FIXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list_elements() to join_list_with() and
#join_join_list_elements_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FIXME: Right. join_list_elements() is simply too brief. join_join_list_elements() reads
#better.

    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_one_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_NL_OPTIONS[@]}" )
#   output "${text}" | {
#       if is_shell_interactive
#       then "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_NON_INTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FIXME: Implementable with pure-Zsh.
#   output "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_one_arg 'expected one string'
#   output "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_variable "${target_name_prefix}" or string ${target_name_prefix}
#   is_variable "${target_name_suffix}" or string ${target_name_suffix}
#   is_variable "${list_name}" or list "${list_name}"

#   die_unless_string "${target_name_prefix}"
#   die_unless_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
