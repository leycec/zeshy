#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Match and substitute Zsh-specific extended glob expressions.
#
# --------------------( SEE ALSO                           )--------------------
# Section "FILENAME GENERATION" of "man zshexpn"
#     For an official reference on extended glob syntax.
#
# --------------------( TODO                               )--------------------
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

# ....................{ TESTERS                            }....................
# boolean is_string_match(string text, string glob)
#
# Return true if the passed string matches the passed glob: e.g.,
#
#     >>> is_string_match 'youshima' '[fuk]ushima' or print 'dai-ichi'
#     dai-ichi
function is_string_match() {
    die_unless_args_2 'expected one string and one glob'
    is "${1}" == ${~2} si
}

# boolean is_string_match_and_capture_groups(string text, string glob)
#
# Return true and capture groups into global list ${match} and string ${MATCH}
# if the passed string matches the passed glob. If capturing only one group,
# consider calling get_string_match_if_found() instead: e.g.,
#
#     >>> is_string_match_and_capture_groups 'hiroshima' '(???)oshima'
#     >>> output_string "${match[1]}"
#     hir
#     >>> get_string_match_if_found 'hiroshima' '(???)oshima'
#     hir
function is_string_match_and_capture_groups() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(get_glob_capturing_groups "${2}")"

    # Test such match.
    is "${text}" == ${~glob} si
}

#FIXME: Rename to is_string_has_glob_characters().
# boolean is_string_containing_glob_characters(string text)
#
# Return true if the passed string contains at least one glob-reserved
# character and hence must be quote protected to be matched as is when globbing.
function is_string_containing_glob_characters() {
    die_unless_args_1 'expected one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

# ....................{ GETTERS                            }....................
# string get_glob_capturing_groups(string glob)
#
# Convert the passed glob to a glob capturing match groups (i.e., saving "(" and
# ")"-delimited match groups in global list ${match}), if not already.
function get_glob_capturing_groups() {
    # Validate passed arguments.
    die_unless_args_1 'expected one glob'
    string glob="${1}"

    # If the passed glob contains no substring "(#b)" enabling match groups,
    # prefix such glob with such substring.
    is_string_containing "${glob}" '(#b)' or glob="(#b)${glob}"

    # And... we're good.
    output_string "${glob}"
}

# string get_glob_matching_lines(string glob)
#
# Convert the passed glob to a multiline glob (i.e., such that "^" and "$" also
# match newlines). While PCREs implicitly support multiline matching via option
# "-m", globs currently lack such support. Hence, this function is a fragile
# hack. Until such support improves, consider matching with multiline PCREs,
# instead.
function get_glob_matching_lines() {
    # Validate passed arguments.
    die_unless_args_1 'expected one glob'
    string glob="${1}"

    # Replace all instances of "*" with "[^$'\n']#", thus terminating line
    # matching on the first newline.
    glob="${glob//\*/[^${ZESHY_CHARACTER_NEWLINE}]#}"
#   glob="${glob//\*/[^$'\n']#}"

    # Prefix such glob with an expression either matching at the start of the
    # string or the first newline preceding such match.
    glob="((#s)|*${ZESHY_CHARACTER_NEWLINE})${glob}*"
#   glob="((#s)|*$'\n')${glob}*"

    # And... we're done.
    output_string "${glob}"
}

# ....................{ GETTERS ~ match                    }....................
# string get_string_match(
#   string text, string glob, integer group_index = 1)
#
# Get the match group with the passed 1-based index (defaulting to the first
# such group) resulting from matching the passed string against the passed glob
# or throw an exception if such string fails to match: e.g.,
#
#     >>> get_string_match 'Escape from the zombie food court' '*(z[^ ]##)*'
#     zombie
function get_string_match() {
    get_string_match_if_found "${@}" or
        die "\"${text}\" not matched by glob \"${glob}\""
}

# string get_string_match_if_found(
#   string text, string glob, integer group_index = 1)
#
# Get the match group with the passed 1-based index (defaulting to the first
# such group) resulting from matching the passed string against the passed glob
# or return false if such string fails to match: e.g.,
#
#     >>> get_string_match_if_found 'Hologram' '*(o?)(o?)(o?)*' 2 or print 'ug'
#     ug
function get_string_match_if_found() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional group index'
    string text="${1}" group_index="${3:-1}" glob
    die_unless_string_integer_positive "${group_index}"
    glob="$(get_glob_capturing_groups "${2}")"

    # Match such group. *AVOID* double-quoting such glob.
    if is "${text}" == ${~glob} si
    then output_string "${match[${group_index}]}"
    else return_false
    fi
}

# integer get_string_match_count(string text, string glob)
#
# Get the number of matches in the passed string of the passed glob: e.g.,
#
#     >>> get_string_match_count 'bosozoku' '[bsz]o'
#     3
function get_string_match_count() {
    # Validate passed arguments
    die_unless_args_2\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}"

    # If either the passed string or glob expression is empty, return 0.
    if is_string_empty "${text}" or is_string_empty "${glob}"; then
        output_string 0
    #FIXME: Extract into a new get_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
    elif not is_string_containing_glob_characters "${glob}"; then
        string text_matches_deleted="${text//${glob}/}"
        output_string $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, count with brute-force iteration. While Zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
    else
        integer match_count=-1
        string text_old
        until is "${text_old}" == "${text}" si; do
            (( ++match_count ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        output_string ${match_count}
    fi
}

# ....................{ REMOVERS                           }....................
# string remove_string_substrings_match(string text, string glob)
#
# Remove all substrings from the passed string matching the passed glob and
# return the resulting string: e.g.,
#
#     >>> remove_string_substrings_match 'rear_window' 'r??'
#     indow
function remove_string_substrings_match() {
    die_unless_args_2 'expected one string and one glob'
    output_string "${1//${~2}}"
}

# string remove_string_prefix_match(string text, string glob)
#
# Remove the longest prefix from the passed string matching the passed glob and
# return the resulting string: e.g.,
#
#     >>> remove_string_prefix_match 'north by northwest' '*n{o,d}?th'
#     west
function remove_string_prefix_match() {
    die_unless_args_2 'expected one string and one glob'
    output_string "${1##${~2}}"
}

# string remove_string_suffix_match(string text, string glob)
#
# Remove the longest suffix from the passed string matching the passed glob and
# return the resulting string: e.g.,
#
#     >>> remove_string_suffix_match 'dial.m.for.murder' '.m?????*'
#     dial.
function remove_string_suffix_match() {
    die_unless_args_2 'expected one string and one glob'
    output_string "${1%%${~2}}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: This needs a rename. It can currently be read in two very different
#ways, and the expected reading is *NOT* the actual reading. How about
#is_string_match_with_capturing_groups() or
#is_string_match_and_capture_groups()? I prefer the former, I reckon. The added
#"_with" makes all the difference for readability here.
#FUXME: Rename to enable_glob_group_capturing()?
#FUXME: Rename to enable_glob_line_matching()?
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.

    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FUXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
