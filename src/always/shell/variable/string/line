#!/usr/bin/env zsh
# ====================[ line                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle newline-delimited strings.

# ....................{ TESTERS                            }....................
# boolean is_string_line(string text, string line)
#
# Return true if the passed string contains the passed line, such that:
#
# * Such line is preceded either by a newline or the start of such string.
# * Such line is followed either by a newline or the end of such string.
function is_string_line() {
    # Validate passed arguments, treating piped input as the passed string.
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one line'

    # Attempt to match the passed line. Dismantled, this is:
    #
    # * "(|*$'\n')", matching either the start of the string or a newline.
    # * "(|$'\n'*)", matching either the end of the string or a newline.
    is "${1}" == (|*$'\n')"${2}"(|$'\n'*) si
}

# ....................{ TESTERS ~ pcre                     }....................
# boolean is_string_line_match_pcre(
#   string text, string pcre, string pcre_option1, string pcre_option2, ...)
#
# Return true if the passed string matches the passed PCRE with the passed PCRE
# options under multiline matching. See for_each_string_match_pcre() for further
# details.
function is_string_line_match_pcre() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one string, one regex, and optional regex options'
    string text="${1}" pcre; pcre="$(get_pcre_matching_lines "${2}")"
    behead_args_2

    # Match such PCRE.
    is_string_match_pcre "${text}" "${pcre}" "${@}" -m
}

# ....................{ GETTERS                            }....................
# string get_string_line(string text, integer line_index = 1)
#
# Get the line corresponding to the passed line number from the passed string.
# If positive, this is the nth line from the beginning starting at 1. Conversely
# if negative, this is the nth line from the end starting at -1.
function get_string_line() {
    die_unless_args_1_to_2\
        'expected one string and optional line number'
    string line_index=${2:-1}
    get_string_lines "${1}" ${line_index} ${line_index}
}

# string get_string_lines(
#   string text,
#   integer start_line_index = 1,
#   integer end_line_index = "$(get_string_line_count string)")
#
# Get the list of lines starting at the passed first line number (defaulting to
# the first line) and concluding at the passed last line number (defaulting to
# the last line) from the passed string.
function get_string_lines() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one string and optional start and end line numbers'
    list lines; lines=( "${(f)1}" )
    string beg_line_index="${2:-}" end_line_index="${3:-}"
    check_list_args lines beg_line_index end_line_index

    # Get such lines. Do *NOT* quote such expansion.
    print_string_newlined ${lines[${beg_line_index},${end_line_index}]}
}

# ....................{ GETTERS ~ count                    }....................
# integer get_string_line_count(string text1, string text2, ...)
#
# Get the total number of lines in the passed strings.
function get_string_line_count() {
    die_unless_args 'expected at least one string'
    list lines; lines=( "${(f)*}" )
    get_list_size lines
}

# integer get_string_line_match_pcre_count(
#   string text, string pcre, string pcre_option1, string pcre_option2, ...)
#
# Get the number of lines in the passed string matching the passed PCRE with
# the passed PCRE options under multiline matching. See
# for_each_string_match_pcre() for further details.
function get_string_line_match_pcre_count() {
    integer match_count=0
    for_each_string_line_match_pcre "${@}" '(( ++match_count ))'
    print_string ${match_count}
}

# ....................{ GETTERS ~ pcre                     }....................
# string get_string_line_match_pcre_first(
#   string text,
#   string pcre, string pcre_option1, string pcre_option2, ...,
#   integer group_index)
#
# Get the match group with the passed 1-based index from the first line matching
# the passed multiline PCRE with the passed PCRE options. This function returns
# the first line list_string_line_match_pcre() returns. See
# for_each_string_match_pcre() for further details.
function get_string_line_match_pcre_first() {
    # Validate passed arguments, popping off the trailing group index.
    die_unless_args_3_or_more\
        'expected one string, one regex, optional regex options, and one group index'
    string group_index="${@[-1]}"
    die_unless_integer_positive "${group_index}"
    curtail_arg

    # Match and break on the first such group.
    for_each_string_line_match_pcre "${@}"\
        "output \"\${match[${group_index}]}\"; break"
}

# ....................{ GETTERS ~ glob                     }....................
# string get_string_line_match_first_until_next(
#   string text,
#   string first_glob,
#   string next_glob = "${first_glob}")
#
# Get all lines from the passed string both:
#
# * Following the first line matching the first passed glob, including such
#   line. If no such line matches, throw an exception.
# * Preceding the next line matching the second passed glob, excluding such
#   line. If no such line matches, include all remaining lines, thus
#   get_string_line_match_first_until_end().
function get_string_line_match_first_until_next() {
    # Validate passed arguments, treating piped input as such string.
    prepend_args_with_standard_input_if_piped
    die_unless_args_2_to_3\
        'expected one string, one first glob, and optional next glob'
    string text="${1}"
    behead_arg

    # Split such string on newline delimiters into a list of lines.
    list lines
    set_list_to_string_lines lines "${text}"

    # Remove non-matching lines.
    remove_list_nonmatches_before_and_after_inclusive lines "${@}"

    # Join remaining lines into a newline-delimited string.
    print_string_newlined "${lines}"
}

# ....................{ LISTERS                            }....................
# string list_string_line_match_pcre(
#   string text,
#   string pcre, string pcre_option1, string pcre_option2, ...,
#   integer group_index)
#
# Get the match group with the passed 1-based index from each line matching the
# passed multiline PCRE with the passed PCRE options, delimited by newlines.
# See for_each_string_match_pcre() for further details.
function list_string_line_match_pcre() {
    # Validate passed arguments, popping off the trailing group index.
    die_unless_args_3_or_more\
        'expected one string, one regex, optional regex options, and one group index'
    string group_index="${@[-1]}"
    die_unless_integer_positive "${group_index}"
    curtail_arg

    # Match and break on the first such group.
    for_each_string_line_match_pcre "${@}"\
        "output \"\${match[${group_index}]}\""
}

# ....................{ ITERATORS                          }....................
# string for_each_string_line_match_pcre(
#   string text,
#   string pcre, string pcre_option1, string pcre_option2, ...,
#   string command)
#
# Run the passed command on each substring of the passed string matching the
# passed multiline PCRE with the passed PCRE options: e.g.,
#
#     >>> for_each_string_line_match_pcre 'P/Tr extinction event' 'ti?|?e[vx]'\
#     ...     'output $MATCH'
#      ex
#     tin
#     tio
#      ev
#
# See for_each_string_match_pcre() for further details.
function for_each_string_line_match_pcre() {
    # Validate passed arguments, treating piped input as the passed string and
    # removing all arguments except for the list of PCRE options if passed.
    prepend_args_with_standard_input_if_piped
    die_unless_args_3_or_more\
        'expected one string, one regex, optional regex options, and one command'
    string text="${1}" pcre command="${@[-1]}"
    pcre="$(get_pcre_matching_lines "${2}")"
    behead_args_2
    curtail_arg

    # Iterate such matches.
    for_each_string_match_pcre "${text}" "${pcre}" "${@}" -m "${command}"
}

# ....................{ SETTERS                            }....................
# string set_list_to_string_lines(string list_name, string text)
#
# Split the passed string on newlines into the passed list.
function set_list_to_string_lines() {
    # Validate passed arguments, treating piped input as the passed string.
    append_args_with_standard_input_if_piped
    die_unless_args_2 'expected one list name and one string'
    string list_name="${1}" __text__="${2}"

    # Split such string.
    set_list_to_evaluation "${list_name}" '${(f)__text__}'
}

# ....................{ NUMBERERS                          }....................
# string number_string_lines(string text)
#
# Prefix each line of the passed string with that line's number.
function number_string_lines() {
    print_string "${@}" |
        run_with_options ZESHY_NL_OPTIONS 'run_paged command nl'
}

#FIXME: Should probably be theme-specific.
#FIXME: Rename to number_string_lines_highlighting_line().
# string number_string_lines_highlighting(
#   string text, integer highlight_line_index)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
function number_string_lines_highlighting() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one line number'
    string text="${1}" line_index="${2}"
    die_if_empty "${text}"
    die_unless_integer_positive "${line_index}"

    #FIXME: Actually, it's trivial to convert negative to positive line numbers.
    # Validate passed arguments. Negative line numbers are impermissible.
    integer line_count; line_count="$(get_string_line_count "${text}")"
#   say "line length: ${line_count}"
    (( 1 <= line_index && line_index <= line_count )) or
        die "line number ${line_index} not in [1, ${line_count}]"

    # Number lines.
    print_string "${text}" | awk -vNRHI=${line_index} '
# If any line other than the highlight line, print the current line number
# followed by the line.
NR != NRHI { printf("%6d%7s%s\n", NR, "", $0) }
# If the highlight line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (See curse_call_stack() for similar logic.)
NR == NRHI {
    # Number of digits in the current line number.
    NRLEN = length(NR);
         if (NRLEN==1) {NRNOW = " <-~ " NR}
    else if (NRLEN==2) {NRNOW = "<-~ " NR}
    else if (NRLEN==3) {NRNOW = "<- " NR}
    else               {NRNOW = NR}       # if true, your string is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}'
}

# ....................{ REMOVERS                           }....................
# string remove_string_line_duplicates(string text1, string text2, ...)
#
# Remove all duplicate lines from the concatenation of the passed strings.
# Unlike conventional solutions (e.g., "sort -u", "sort | uniq -u"), this
# function preserves the line order of returned lines: e.g.,
#
#     >>> remove_string_line_duplicates 'the Perfect
#     ...   and
#     ...   the Perfect
#     ...   are one Perfect and not two;
#     ...   nay, are none!'
#     the Perfect
#     and
#     are one Perfect and not two;
#     nay, are none!
function remove_string_line_duplicates() {
    # Split passed strings into lines, remove duplicate lines, and join all
    # remaining lines back into a newline-delimited string. Dismantled, this is:
    #
    # * "f", splitting passed strings into lines.
    # * "u", excluding duplicate lines.
    set_args_to_standard_input_if_piped
    die_unless_args 'expected at least one string'
    print_string_newlined "${(uf)*}"   # this... this is ridiculous
}

# --------------------( WASTELANDS                         )--------------------
#   append_standard_input_piped_to_args
    # Validate passed arguments, treating piped input as the passed string.
#   string __error_message__='expected one list name and one string'\
#       __text__ list_name
#   if is_standard_input_piped; then
#       die_unless_arg "${__error_message__}"
#       set_string_to_standard_input_piped __text__
#       list_name="${1}"
#   else
#       die_unless_args_2 "${__error_message__}"
#       list_name="${1}"
#       __text__="${2}"
#   fi

    # Split such string.
#   set_list_to_evaluation ${list_name} '${(f)__text__}'
#   string text="${1}" line="${2}"
#   is "${text}" == (|*$'\n')"${line}"(|$'\n'*) si
    # Validate passed arguments, treating piped input as the passed string.
#   string text line error_message='expected one string and one line'
#   if is_standard_input_piped; then
#       die_unless_arg "${error_message}"
#       set_string_to_standard_input_piped text
#       line="${1}"
#   else
#       die_unless_args_2 "${error_message}"
#       text="${1}"
#       line="${2}"
#   fi

#   die_unless_args_2_to_3\
#       'expected one string, one first glob, and optional next glob'
    # Avoid naming the local string "lines" to avoid dynamic scope conflicts
    # with caller lists also named "lines". (O, how this hath bitten me hard.)
#       __text__="$(get_standard_input_piped)"
    #FIXME: Can we use a "noop ${(P)list_name::=( ${(f)text} )}"-style
    #technique here? I suspect not, but it does beg the question...
#   die_unless_list "${list_name}"
#   print_string "text: ${text}"
#   eval "${list_name}=( \${(f)__lines__} )"

# string get_first_lines(string text, int last_line_index = 1)
#
# Get the first n lines (defaulting to the first line) from the passed string.
#function get_first_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    get_string_lines "${1}" 1 ${2:-1}
#}

# string get_last_lines(
#   string text, int last_line_index = $(get_string_line_count string))
#
# Get the last n lines (defaulting to the last line) from the passed string.
#function get_last_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    string text="${1}" line_length
#    line_length="$(get_string_line_count "${text}")"
#    get_string_lines "${text}" ${2:-${line_length}} ${line_length}
#}
