#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle maps (i.e., associative arrays).

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a map")
#
# Die unless the variable with the passed name is a map.
die_unless_map() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_map "${variable_name}" or die "${2:-\"${variable_name}\" not a map}"
}

# void die_unless_map_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a non-empty map")
#
# Die unless the variable with the passed name is a non-empty map.
die_unless_map_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_map_nonempty "${variable_name}" or
        die "${2:-\"${variable_name}\" not a non-empty map}"
}

# ....................{ TESTS                              }....................
# boolean is_map(string variable_name)
#
# Return true if the passed variable is a map (i.e., associative array).
is_map() {
    # Global maps have type "association" and local maps "association-local".
    die_unless_one_arg 'expected one variable name'
    is_variable_type_match "${1}" 'association*'
}

# boolean is_map_key(string map_name, string key)
#
# Return true if the passed map contains the passed key.
is_map_key() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one key'
    string map_name="${1}" key="${2}"
    die_unless_map "${map_name}"

    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force Zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
    is_nonempty "${${(k@P)map_name}[(I)"$key"]}"
}

# ....................{ GETTERS                            }....................
# integer get_map_size(string map_name)
#
# Get the number of elements in the map with the passed name.
get_map_size() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one map name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Get map size.
    output ${#${(@P)map_name}}
}

# ....................{ CONVERTERS                         }....................
# string convert_map_to_restorable_string(string map_name)
#
# Get a string corresponding to the contents of the map with the passed name.
# See convert_list_to_restorable_string() for further details.
convert_map_to_restorable_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one map name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    output "${(qqkv@P)map_name}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
