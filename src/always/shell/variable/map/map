#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle maps (i.e., associative arrays).

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a map")
#
# Die unless the passed variable is a map.
function die_unless_map() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_map "${variable_name}" or die "${2:-\"${variable_name}\" not a map}"
}

# void die_unless_map_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a non-empty map")
#
# Die unless the passed variable is a non-empty map.
function die_unless_map_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_map_nonempty "${variable_name}" or
        die "${2:-\"${variable_name}\" not a non-empty map}"
}

# void die_unless_map_key(
#   string map_name,
#   string key,
#   string error_message = "\"${key}\" not a key of map \"${map_name}\"")
#
# Die unless the passed map contains the passed key.
function die_unless_map_key() {
    die_unless_args_2_to_3\
        'expected one map name, one key, and optional error message'
    string map_name="${1}" __key__="${2}"
    is_map_key "${map_name}" "${__key__}" or
        die "${2:-\"${__key__}\" not a key in map \"${map_name}\"}"
}

# ....................{ TESTERS                            }....................
# boolean is_map(string variable_name)
#
# Return true if the passed variable is a map (i.e., associative array).
function is_map() {
    # Global maps have type "association" and local maps "association-local".
    die_unless_args_1 'expected one variable name'
    is_variable_type_match "${1}" 'association*'
}

# boolean is_map_nonempty(string variable_name)
#
# Return true if the passed variable is a non-empty map.
function is_map_nonempty() {
    die_unless_args_1 'expected one variable name'
    string map_name="${1}"
    is_map "${map_name}" and (( ${#${(@P)map_name}} ))
}

# boolean is_map_key(string map_name, string key)
#
# Return true if the passed map contains the passed key.
function is_map_key() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name="${1}" __key__="${2}"
    die_unless_map "${map_name}"

    # Dismantled, this is:
    #
    # * 'P@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under the default shell option "NO_UNSET".
    is_nonempty "${(k)${(k@P)map_name}[(r)${__key__}]-}"
}

# ....................{ GETTERS                            }....................
# integer get_map_size(string map_name)
#
# Get the number of keys in the passed map.
function get_map_size() {
    # Validate passed arguments.
    die_unless_args_1 'expected one map name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Get map size.
    print_string ${#${(@P)map_name}}
}

# string get_map_key_value_if_found(string map_name, string key)
#
# Get the value the passed map associates with the passed key if such map
# contains such key or return false.
function get_map_key_value_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name="${1}" __key__="${2}"
    die_unless_map "${map_name}"

    # Get such value or return false. Oddly, the sensible expression
    # "${${(@P)map_name}[${__key__}]}" *ALWAYS* expands to the empty string.
    # So does every sensible permutation of such expression (e.g., adding "k").
    # It shouldn't; it certainly doesn't for lists. But since it does, we
    # necessarily resort to the usual "eval" kludge.
    #
    # Needless to say, this is shockingly difficult.
    if is_map_key "${map_name}" "${__key__}"
    then eval "print_string \${${map_name}[\${__key__}]}"
    else return_false
    fi
}

# ....................{ CONVERTERS                         }....................
# string convert_map_to_restorable_string(string map_name)
#
# Get a string corresponding to the contents of the map with the passed name.
# See convert_list_to_string() for further details.
function convert_map_to_restorable_string() {
    # Validate passed arguments.
    die_unless_args_1 'expected one map name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    print_string "${(qqkv@P)map_name}"
}

# --------------------( WASTELANDS                         )--------------------
# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # is_map_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_nonempty "${__
#   print_string ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force Zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
