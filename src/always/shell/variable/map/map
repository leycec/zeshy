#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle maps (i.e., associative arrays).

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_map(
  string variable_name,
  string error_message = "\"${variable_name}\" not a map")

Throw an exception unless the passed variable is a map.
'
function die_unless_map() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__dum="${1}"
    is_map "${variable_name__dum}" or
        die "${2:-\"${variable_name__dum}\" not a map}"
}

# ....................{ EXCEPTIONS ~ empty                 }....................
document_function '
void die_unless_map_nonempty(
  string map_name, string error_message = "\"${map_name}\" not a non-empty map")

Throw an exception unless the passed map is non-empty.
'
function die_unless_map_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string map_name__dumn="${1}"
    is_map_nonempty "${map_name__dumn}" or
        die "${2:-\"${map_name__dumn}\" not a non-empty map}"
}

# ....................{ EXCEPTIONS ~ key                   }....................
document_function '
void die_unless_map_key(
  string map_name,
  string key,
  string error_message = "\"${key}\" not a key of map \"${map_name}\"")

Throw an exception unless the passed map contains the passed key.
'
function die_unless_map_key() {
    die_unless_args_2_to_3\
        'expected one map name, one key, and optional error message'
    string map_name__dumk="${1}" key__dumk="${2}"
    is_map_key "${map_name__dumk}" "${key__dumk}" or
        die "${2:-\"${key__dumk}\" not a key of map \"${map_name__dumk}\"}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_map(string variable_name)

Return true if the passed variable is a map (i.e., associative array).
'
function is_map() {
    # Global maps have type "association" and local maps "association-local".
    die_unless_arg 'expected one variable name'
    is_variable_type_match "${1}" 'association*'
}

# ....................{ TESTERS ~ empty                    }....................
document_function '
boolean is_map_empty(string map_name)

Return true if the passed map is empty.
'
function is_map_empty() {
    not  is_map_nonempty "${@}"
}

document_function '
boolean is_map_nonempty(string map_name)

Return true if the passed map is non-empty.
'
function is_map_nonempty() {
    die_unless_arg 'expected one map name'
    string map_name__imn="${1}"
    is_map "${map_name__imn}" and (( ${#${(@P)map_name__imn}} ))
}

# ....................{ TESTERS ~ key                      }....................
document_function '
boolean is_map_key(string map_name, string key)

Return true if the passed map contains the passed key.
'
function is_map_key() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__imk="${1}" key__imk="${2}"
    die_unless_map "${map_name__imk}"

    # Dismantled, this is:
    #
    # * 'P@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Unfortunately, such technique fails to scale when the map name is
    # dynamically passed rather than previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
    is_string_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"
}

# ....................{ GETTERS                            }....................
document_function '
integer get_map_size(string map_name)

Get the number of keys in the passed map.
'
function get_map_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gms="${1}"
    die_unless_map "${map_name__gms}"

    # Get map size.
    print_string ${#${(@P)map_name__gms}}
}

# ....................{ GETTERS ~ key                      }....................

# ....................{ GETTERS ~ value                    }....................
document_function '
string get_map_key_value_if_found(string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or return false otherwise.
'
function get_map_key_value_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__gmkvif="${1}" key__gmkvif="${2}"
    die_unless_map "${map_name__gmkvif}"

    # Get such value or return false. Oddly, the sensible expression
    # "${${(@P)map_name}[${key____gmkvif}]}" always expands to the empty string
    # as does every sensible permutation of such expression (e.g., adding "k").
    # It shouldn't; it certainly doesn't for lists. But since it does, we
    # necessarily resort to the usual "eval" kludge.
    #
    # Needless to say, this is shockingly difficult.
    if is_map_key "${map_name__gmkvif}" "${key__gmkvif}"
    then eval "print_string \${${map_name__gmkvif}[\${key__gmkvif}]}"
    else return_false
    fi
}

# ....................{ CONVERTERS                         }....................
#FIXME: Shift to "00-alias/variable/map".
document_function '
string convert_map_to_string(string map_name)

Get a string corresponding to the contents of the map with the passed name.
See convert_list_to_string() for further details.
'
function convert_map_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__cvmts="${1}"
    die_unless_map "${map_name__cvmts}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    print_string "${(qqkv@P)map_name__cvmts}"
}

# ....................{ LISTERS ~ lexical                  }....................
document_function '
string list_map_keys_sorted_lexically_ascending(string map_name)

List all keys of the passed map sorted in lexical ascending order.
'
function list_map_keys_sorted_lexically_ascending() {
    # Validate passed arguments.
    die_unless_args_1 'expected one map name'
    string map_name__lmksla="${1}"
    die_unless_map "${map_name__lmksla}"

    # List such keys.
    print_string "${(ko@P)map_name__lmksla}"
}

document_function '
string list_map_keys_sorted_lexically_descending(string map_name)

List all keys of the passed map sorted in lexical descending order.
'
function list_map_keys_sorted_lexically_descending() {
    # Validate passed arguments.
    die_unless_args_1 'expected one map name'
    string map_name__lmksla="${1}"
    die_unless_map "${map_name__lmksla}"

    # List such keys.
    print_string "${(kO@P)map_name__lmksla}"
}

# --------------------( WASTELANDS                         )--------------------
#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#document_function '
#string list_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function list_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    die_unless_map "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # is_map_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_nonempty "${__
#   print_string ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force Zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
