#!/usr/bin/env zsh
# ====================[ variable                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Inspect variable names, types, values, and related metadata (e.g., frozen).
#
# --------------------( SEE ALSO                           )--------------------
# http://stackoverflow.com/questions/2821043/allowed-characters-in-linux-environment-variable-names
#   Discussion of Zsh variable name syntax, complete with citations.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_variable(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not set")
#
# Throw an exception unless the variable with the passed name is set.
function die_unless_variable() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_variable "${variable_name}" or die "${2:-\"${variable_name}\" not set}"
}

# void die_unless_variable_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not set or empty")
#
# Throw an exception unless the variable with the passed name is set to a non-
# empty value.
function die_unless_variable_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_variable_nonempty "${variable_name}" or
        die "${2:-\"${variable_name}\" not set or empty}"
}

# ....................{ TESTERS                            }....................
# boolean is_variable(string variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
function is_variable() {
    # Dismantled, this is:
    #
    # * "(P)1", referencing the variable with passed name.
    # * "+x", expanding to "x" if such variable is set or to the empty string
    #   otherwise. Since any arbitrary non-empty value will do, use "x". (Zsh
    #   precedent, and all.)
    # * "is -n ... si", true if such expansion is non-empty and thus the passed
    #   valiable is set.
    die_unless_one_arg 'expected one variable name'
    is -n "${(P)1+x}" si
}

# boolean is_variable_empty(string variable_name)
#
# Return true if the the passed variable is set to an empty value, defined
# depending on variable type as follows:
#
# * For string variables, "".
# * For integer variables, 0.
# * For float variables, 0.0.
# * For list and map variables, ().
function is_variable_empty() {
    die_unless_one_arg 'expected one variable name'
    not is_variable_nonempty "${1}"
}

# boolean is_variable_nonempty(string variable_name)
#
# Return true if the variable with the passed name is set to a non-empty value.
# See is_variable_empty() for the definition of "empty value."
function is_variable_nonempty() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}" variable_type

    # If such variable exists, test such variable's value for emptiness
    # depending on its type.
    is_variable "${variable_name}" and {
        variable_type="$(get_variable_type "${variable_name}")"
        case "${variable_type}" in
        integer*|float*) (( ${(P)variable_name} )) | return_exit_status;;
        *) is -n "${(P)variable_name}" si | return_exit_status;;
        esac
    }
}

# boolean is_variable_type_match(string variable_name, string glob)
#
# Return true if the type of the passed variable matches the passed glob: e.g.,
#
#     >>> global_map killstardo=( abominate ghostqueen )
#     >>> is_variable_type_match killstardo 'map*' and print 'MURDERFACE!!!!'
#     MURDERFACE!!!!
function is_variable_type_match() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one glob'
    string variable_name="${1}" variable_type glob="${2}"

    # If such variable exists, match its type against the passed glob.
    is_variable "${variable_name}" and {
        variable_type="$(get_variable_type "${variable_name}")"
#       output "variable type: ${variable_type}\nglob: ${glob}"
        is "${variable_type}" == ${~glob} si  # do not quote such glob!
    }
}

# ....................{ TESTERS ~ syntax                   }....................
# boolean is_variable_name(string name)
#
# Return true if the passed string is a valid Zsh variable name: e.g.,
#
#     >>> is_variable_name 'COINTELPRO' and print "First Nations"
#     First Nations
#     >>> is_variable_name '-=MKULTRA?'  or print "Lysergic acid diethylamide"
#     Lysergic acid diethylamide
function is_variable_name() {
    # Dismantled, this is:
    #
    # * "[a-zA-Z_]", matching the first character of a valid Zsh variable name.
    # * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
    die_unless_one_arg 'expected one string'
    is "${1}" == [a-zA-Z_][a-zA-Z0-9_]# si
}

# boolean is_variable_definition(string definition)
#
# Return true if the passed string is a valid Zsh variable definition: e.g.,
#
#     >>> is_variable_definition 'FALSE=flag' and print "Reichstag fire"
#     Reichstag fire
#     >>> is_variable_definition 'BLACK=flag'  or print "Iran-Contra affair"
#     Iran-Contra affair
function is_variable_definition() {
    die_unless_one_arg 'expected one string'
    is "${1}" == [a-zA-Z_][a-zA-Z0-9_]#'='* si
}

# ....................{ TESTS ~ scope                      }....................
# boolean is_variable_global(string variable_name)
#
# Return true if the passed global variable exists.
function is_variable_global() {
    die_unless_one_arg 'expected one variable name'
    string variable_type="${(tP)1}"  # see get_type()
    is_nonempty "${variable_type}" and
        is_string_suffix "${variable_type}" '-global'
}

# boolean is_variable_local(string variable_name)
#
# Return true if the passed local variable exists.
function is_variable_local() {
    die_unless_one_arg 'expected one variable name'
    string variable_type="${(tP)1}"  # see get_type()
    is_nonempty "${variable_type}" and
        is_string_suffix "${variable_type}" '-local'
}

# ....................{ GETTERS                            }....................
# string get_variable_type(string variable_name)
#
# Get the type of the passed variable (e.g., "string-local", "array-global").
function get_variable_type() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}"
    die_unless_variable "${variable_name}"

    # Dismantled, this is:
    #
    # * "P", expanding to the variable with the passed name.
    # * "t", expanding to the variable's type.
    output "${(tP)variable_name}"
}

# ....................{ GETTERS ~ first                    }....................
# string get_first_nonempty_variable(
#   string variable_name1, variable_name2, ...,
#   string error_message = "\"${^@}\" not defined or empty")
#
# Get the name of the first passed variable with non-empty value or throw an
# exception if no such variables have a non-empty value: e.g.,
#
#     >>> unset_variable INDICA SATIVA
#     >>> string SALVIA DIVINORUM='is no nostrum'
#     >>> get_first_nonempty_variable(INDICA SATIVA SALVIA DIVINORUM)
#     DIVINORUM
function get_first_nonempty_variable() {
    get_first_nonempty_variable_if_found "${@}" or
        die "$(join_list_elements_conjunctively "${@}") not defined or empty"
}

# string get_first_nonempty_variable_value(
#   string variable_name1, variable_name2, ...,
#   string error_message = "\"${^@}\" not defined or empty")
#
# Get the value of the first passed variable with non-empty value or throw an
# exception if no such variables have a non-empty value: e.g.,
#
#     >>> unset_variable INDICA SATIVA
#     >>> string SALVIA DIVINORUM='is no nostrum'
#     >>> get_first_nonempty_variable_value(INDICA SATIVA SALVIA DIVINORUM)
#     is no nostrum
function get_first_nonempty_variable_value() {
    get_first_nonempty_variable_value_if_found "${@}" or
        die "$(join_list_elements_conjunctively "${@}") not defined or empty"
}

# string get_first_nonempty_variable_if_found(
#   string variable_name1, variable_name2, ...)
#
# Get the name of the first passed variable with non-empty value or return false
# if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable FIVE MeO
#     >>> string DMT
#     >>> get_first_nonempty_variable_if_found(FIVE MeO DMT) or print "Tyke?"
#     Tyke?
function get_first_nonempty_variable_if_found() {
    die_unless_args 'expected at least one variable name'
    for variable_name ("${@}") {
        is_nonempty "${variable_name}" and {
            output "${variable_name}"
            return_true
        }
    }
    return_false
}

# string get_first_nonempty_variable_value_if_found(
#   string variable_name1, variable_name2, ...)
#
# Get the value of the first passed variable with non-empty value or return
# false if no such variables has a non-empty value: e.g.,
#
#     >>> unset_variable FIVE MeO
#     >>> string DMT="Crysanthemum."
#     >>> get_first_nonempty_variable_value_if_found(FIVE MeO DMT) or print "O"
#     Crysanthemum.
function get_first_nonempty_variable_value_if_found() {
    die_unless_args 'expected at least one variable name'
    for variable_name ("${@}") {
        is_nonempty "${variable_name}" and {
            output "${(P)variable_name}"
            return_true
        }
    }
    return_false
}

# ....................{ FREEZERS                           }....................
# void freeze_variable(string variable_name)
#
# Render the passed variable read-only (e.g., "const", "final").
function freeze_variable() {
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}"
    die_unless_variable "${variable_name}"
    typeset -r "${variable_name}"
}

# ....................{ WRITERS                            }....................
#FIXME: I'm somewhat unhappy with the nomenclature of the current write_*() and
#append_*() methods. Reconsider.
# void write_variable_to_script(
#   string variable_name1, string variable_name2, ...,
#   string filename)
#
# Serialize the passed variables to the passed file, overwriting the contents
# of such file with the current definitions of such variables. Call
# source_script() to deserialize such variables from such file.
function write_variable_to_script() {
    # Validate passed arguments.
    die_unless_at_least_two_args\
        'expected at least one variable name and one filename'
    string filename="${@[-1]}"
    pop_one_arg

    # Write such variables. Dismantled, this is:
    #
    # * "-p", printing the current definitions of such variables.
    # * ">!", forcefully overwriting such file if already extant.
    typeset -p "${@}" >! "${filename}"
}

# void append_variable_to_script(
#   string variable_name1, string variable_name2, ...,
#   string filename)
#
# Serialize the passed variables to the passed file, appending the contents
# of such file with the current definitions of such variables. Call
# source_script() to deserialize such variables from such file.
function append_variable_to_script() {
    # Validate passed arguments.
    die_unless_at_least_two_args\
        'expected at least one variable name and one filename'
    string filename="${@[-1]}"
    pop_one_arg

    # Append such variables. See write_variable_to_file() for details.
    typeset -p "${@}" >>! "${filename}"
}

# --------------------( WASTELANDS                         )--------------------
#   string variable_name="${1}" filename="${2}"
#   die_unless_variable "${variable_name}"

    # Write such variable. Dismantled, this is:
    #
    # * "-p", printing the current definition of such variable.
    # * ">!", forcefully overwriting such file if already extant.
#   typeset -p "${variable_name}" >! "${filename}"
# read_variables_from_file() to deserialize such variable from such file.
# ....................{ READERS                            }....................
# void read_variable_from_file(string variable_name, string filename)
#
# Deserialize the passed variable from the passed file, presumably written by a
# prior call to write_variable_to_file().
# set_variable_to_file_contents() to deserialize such variable from such file.
#function read_variable_from_file() {

#, concatenated into a single string.
        # If this word defines a global variable, continue to the next; else,
        # break with this word. Dismantled, this is:
        # * "[a-zA-Z_]", matching the first character of a variable name.
        # * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
        # * '=', a "=" delimiter.
        # * "*", matching zero or more characters as the variable value.
#       is "${word}" == [a-zA-Z_][a-zA-Z0-9_]#'='* si or break
# Clearly, these
#functions should all be shifted to the same component.
#FIXME: Fails to account for prefixing temporary globals: e.g.,
#   LD_PATH="oeu=oeu" ssh -o hmm
#       is "${word}" == *?'='* si or break
# This function currently fails to return the expected name for exotic command
# lines containing pathological, but technically valid, syntax (e.g.,
# '"{!! This is a sadistic variable name !!}"="===" ls').
#   list words; words=( "${(z)*}" )
#   for word ("${words[@]}") {
#   string args; args="$(get_args)"
    # Exclude prefixing temporary global variable definitions.
    # Return the first shell word of remaining arguments.
#   get_word "${args}" 1
        # If such variable's type is numeric, emptiness is equality with zero;
        # otherwise, emptiness is equality with the empty string.
#FIXME: Remove at least two of the following functions. I'm thinking
#get_first_nonempty_variable_or() and get_first_nonempty_variable_value_or().
#FIXME: Rename "_if_found" back to "_if_found" *EVERYWHERE*. Much more readable.

    # Validate passed arguments.
#   die_unless_one_arg 'expected one variable name'
#   string variable_name; variable_name="${1}"

    # If such variable exists, test such variable's value for emptiness
    # depending on its type.
#   is_variable "${variable_name}" and {
#       string variable_type; variable_type="$(get_variable_type)"

#       case "${variable_type}" in
        # If such variable's type is numeric, emptiness is equality with zero.
#       integer*|float*) (( "${(P)variable_name}" == 0 )) | return_exit_status;;
        # Otherwise, emptiness is equality with the empty string.
#       *) is -z "${(P)variable_name}" si | return_exit_status;;
#       esac
#   }

#FIXME: Such functions only return string values; rename to
#get_first_nonempty_variable_expansion_if_found().
    # If the passed variable is unset, expand to the empty string; otherwise,
    # expand as is. Return true if such expansion is non-empty.
#   is -n "${${(P)1-}#0}" si

# string get_first_nonempty_variable_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the name of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM HARMALA
#     >>> get_first_nonempty_variable_or('Thank you, Iran.' PEGANUM HARMALA)
#     Thank you, Iran.
#function get_first_nonempty_variable_or() {
#    die_unless_at_least_two_args\
#        'expected one default value and at least one variable name'
#    get_first_nonempty_variable_if_found "${@[2,-1]}" or output "${@[1]}"
#}

# string get_first_nonempty_variable_value_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the value of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM
#     >>> string HARMALA='Esfand svanta'
#     >>> get_first_nonempty_variable_value_or('Thank you.' PEGANUM HARMALA)
#     Esfand svanta
#function get_first_nonempty_variable_value_or() {
#    die_unless_at_least_two_args\
#        'expected one default value and at least one variable name'
#    get_first_nonempty_variable_value_if_found "${@[2,-1]}" or output "${@[1]}"
#}

    # If the passed variable is unset, expand to "x"; otherwise, expand as is.
    # Return true if such expansion is empty. Dismantled, this is:
    #
    # * "#0", removing a prefixing "0" if present and hence treating "0" as
    #   empty. By default, Zsh only treats the empty string as empty. Since
    #   integers are scalars that are *ALWAYS* some integer and hence never the
    #   empty string, integers would never be treated as empty without such fix.
#   is -z "${${(P)1-x}#0}" si

#       string*)
#       array*|association*) (( "${(P)variable_name}" == 0 ));;
# or throw an
# exception if no such object exists# void die_unless_unset(string variable_name, string error_message = 'already set')
#
# Throw an exception unless the variable with the passed name is unset.
#function die_unless_unset() {
#    die_unless_one_or_two_args\
#        'expected one variable name and optional error message'
#    string variable_name="${1}"
#    is_undeclared "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
#}

    # Validate passed arguments.
    # Iterate passed arguments for the first non-empty variable or return false.
# boolean is_variable(string text)
#
# Return true if the variable with the passed name is unset (i.e., undeclared).
#function is_variable() {
    # Negate the condition is_variable_declared() tests for.
#    die_unless_one_arg 'expected one variable name'
#    is -z "${(P)1+x}" si
#}

#FIXME: I'm no longer enamoured with our use of "set" in this context, which
#conflicts with our use of "set" when referring to list and map sets. Rather,
#let's rename the former uses of "set" with "defined": e.g.,
# string get_first_defined_nonempty_variable(...)

#FIXME: Uhm... what? I'm fairly certain we never call this. Doesn't is_declared()
#suffice? We probably want to replace this with a new is_global() function.
# boolean is_variable(string variable_name)
#
# Return true if there exists a variable with the passed name.
#is_variable() {
#    die_unless_one_arg 'expected one name'
#    is_nonempty "${(tP)1}"  # see get_type() for details
#}

#FIXME: Rename is_local().
#       string object_type
#       object_type="$(whence -w -- "${object_name}")" or true  # ignore errors

# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.
#FIXME: Uhm; shouldn't "_runnable" be "_callable" everywhere below? Do we really
#need a distinction between the two? Arguably, functions aren't runnable and
#commands and builtins aren't callable. Perhaps

# ....................{ DEPENDENCIES                       }....................
#FIXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os
