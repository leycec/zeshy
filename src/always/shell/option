#!/usr/bin/env zsh
# ====================[ option                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle shell options, as documented by "man zshoptions".

# ....................{ EXCEPTIONS                         }....................
# void die_unless_shell_option(
#   string option_name,
#   string error_message = "\"${option_name}\" not a shell option")
#
# Raise an exception unless the current shell is interactive.
function die_unless_shell_option() {
    die_unless_args_1_to_2\
        'expected one option name and optional error message'
    string option_name="${1}"
    is_shell_option "${option_name}" or\
        die "${2:-\"${option_name}\" not a shell option}"
}

# void die_unless_shell_interactive(
#   string error_message = 'shell non-interactive')
#
# Raise an exception unless the current shell is interactive.
function die_unless_shell_interactive() {
    die_unless_args_0_to_1 'expected optional error message'
    is_shell_interactive or die "${1:-shell non-interactive}"
}

# ....................{ TESTERS                            }....................
# boolean is_shell_option(string option_name)
#
# Return true if Zsh supports the passed option: e.g.,
#
#     >>> is_shell_option unpriveleged or output_string 'Welcome, bourgeoisie.'
#     Welcome, bourgeoisie.
function is_shell_option() {
    # The previous implementation for this function resembled:
    #
    #     run_quietly set +o local_options "${option_name}"
    #
    # While a clever solution, such implementation subtly fails when passed
    # options "privileged" or "restricted". As "man zshoptions" documents, the
    # option "local_options" localizes all options *EXCEPT* "privileged" or
    # "restricted", which remain unexpectedly globally set. Instead, employ an
    # even more insipidly! clever solution by noting "[[ -o ${option_name} ]]"
    # always returns in one of three possible ways:
    #
    # * When passed a valid option name currently enabled, such command prints
    #   nothing and returns zero exit status.
    # * When passed a valid option name currently disabled, such command prints
    #   nothing and returns non-zero exit status.
    # * When passed an invalid option name, such command prints
    #   "is_shell_option:2: no such option: ${option_name}" to standard error
    #   and returns non-zero exit status.
    #
    # Consequently, a shell option exists when such command either returns zero
    # exit status or prints nothing.
    die_unless_args_1 'expected one option name'
    noop "$(is -o "${option_name}" si 2>&1)" or is_string_empty "${output}"
}

# boolean is_shell_option_enabled(string option_name)
#
# Return true if the current shell enables the passed option. See
# "man zshoptions" for a list of such options: e.g.,
#
#     >>> is_shell_option_enabled priveleged or output_string 'Goodbye, proletariat.'
#     Goodbye, proletariat.
function is_shell_option_enabled() {
    die_unless_args_1 'expected one option name'
    string option_name="${1}"
    die_unless_shell_option "${option_name}"
    is -o "${option_name}" si
}

# boolean is_shell_interactive(void)
#
# Return true if standard input to the current shell *WAS* attached to a
# terminal device on initial execution of such shell. When testing whether
# standard input to the current shell is *CURRENTLY* attached to a terminal
# device, consider calling is_standard_input_terminal() instead. Standard input
# to the current shell could have been initially attached to a terminal device
# but since closed, in which case relying on the return value from this function
# would be problematic.
function is_shell_interactive() {
    # Avoid running "is_shell_option_enabled interactive". While correct, such
    # command is somewhat slower than merely testing this option directly. While
    # Zeshy typically ignores such efficiency concerns, this function is called
    # frequently enough to warrant minor optimizations.
    die_if_args
    is -o interactive si
}

# ....................{ SETTERS                            }....................
# void enable_shell_options(string option_name1, string option_name2, ...)
#
# Enable the passed Zsh options.
function enable_shell_option() {
    die_unless_args 'expected at least one option name'
    for option_name ("${@}") {
        die_unless_shell_option "${option_name}"
        set -o "${option_name}"
    }
}

# void disable_shell_option(string option_name1, string option_name2, ...)
#
# Disable the passed Zsh options.
function disable_shell_option() {
    die_unless_args 'expected at least one option name'
    for option_name ("${@}") {
        die_unless_shell_option "${option_name}"
        set -o "$(negate_shell_option "${option_name}")"
    }
}

# void negate_shell_option(string option_name)
#
# Negate the passed Zsh option. If such option is enabled, prefix such option
# with "no_"; if such option is disabled, remove such prefix from such option.
# As inexpressibly horrible edge cases, options "nomatch" and "notify" are
# considered enabled despite their "no" prefixes: e.g.,
#
#     >>> negate_shell_option nomatch
#     no_nomatch
#     >>> negate_shell_option no_notify
#     notify
function negate_shell_option() {
    die_unless_args 'expected at least one option name'
    string option_name="${1}" is_option_disabled
    die_unless_shell_option "${option_name}"

    # For comparability, lowercase such option and strip out underscores.
    option_name="$(remove_string_substring "${option_name}" '_')"
    option_name="$(lowercase_string "${option_name}")"

    # If such option is either "nomatch", "notify", "nonomatch", or "nonotify",
    # perform edge case handling.
    if is_string_match_capturing_groups\
        "${option_name}" '(no|)(nomatch|notify)'; then
        # If such option is disabled, enable such option.
        if is_string_nonempty "${match[1]}"
        then output_string "${match[2]}"
        # Otherwise, disable such option.
        else output_string "no_${match[2]}"
        fi
    # Otherwise, perform default handling.
    else
        # If such option is disabled, enable such option.
        string option_name_negated
        if option_name_negated="$(get_string_match_if_found\
            "${option_name}" 'no(*)')"
        then output_string "${option_name_negated}"
        # Otherwise, disable such option.
        else output_string "no_${option_name}"
        fi
    fi
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: This is called often enough, we should probably just cache the result as
#a *NON-EXPORTED* global variable of the current shell. The *NON-EXPORTED* is key.
#   string_global ZESHY_IS_SHELL_INTERACTIVE="${ZESHY_IS_SHELL_INTERACTIVE-$(run_quietly_getting_exit_status_as_boolean is_shell_option_enabled interactive)}"
#   is_boolean_true "${ZESHY_IS_SHELL_INTERACTIVE}"
#   die_unless_args_1 'expected one option name'
#   string option_name="${1}"
#   die_unless_shell_option "${option_name}"
#   set -o "${option_name}"
#       ${ZESHY_FILE_DESCRIPTOR_STANDARD_ERROR}>&${ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT})" or
#function isot() {
#    string option_name="${1}" output
#      not is_string_suffix "${output}" "no such option: ${option_name}"
#   if not output="$(is -o "${option_name}" si 2>&1)" and
#      is_string_suffix "${output}" "no such option: ${option_name}"
#   then return_false
#   elif print "output: ${output}"
#   else return_true
#   fi
#}

# See "man zshoptions" for a list
# of such options# and interactively reading commands from standard input.
# Technically, this could be
    # avoided by calling "set +o" only if the passed option is *NOT*
    # "privileged" or "restricted".
    #FIXME: Doesn't work. Best way appears to be capturing the output_string of a test
    #resembling "$(is -o "${option_name}" si)" for an error message resembling:
    #   zsh: no such option: oeuoeuo
    # Dismantled, this is:
    #
    # * "set +o", printing the passed option name if such option exists or
    #   returning false.
    # * "run_quietly", hiding such output_string while retaining such return status.
