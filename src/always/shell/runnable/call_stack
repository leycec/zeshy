#!/usr/bin/env zsh
# ====================[ call_stack                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the Zsh function and script call stack.

# ....................{ GETTERS                            }....................
# string get_call_stack_root_name(void)
#
# Get the name of the first Zsh function or script on the current call stack.
# This is always the oldest Zsh function or script on such stack and hence the
# root of the current call tree. If the call stack is empty (e.g., the current
# user called this function directly from the command line), this function
# simply returns "zeshy".
#
# This function returns an absolute path if the first object on the call stack
# is a script called by an absolute path. Where this is undesirable, consider
# calling get_call_stack_root_basename().
function get_call_stack_root_name() {
    # Validate sanity.
    die_if_args

    # Get such name.
    if is_list_nonempty funcstack
    then output "${funcstack[-1]}"
    else output 'zeshy'
    fi
}

# string get_call_stack_root_basename(void)
#
# Get the name of the first Zsh function or basename of the first Zsh script on
# the current call stack. (This function returns the basename of the string
# returned by get_call_stack_root_name(), in other words.)
function get_call_stack_root_basename() {
    die_if_args
    get_path_basename "$(get_call_stack_root_name)"
}

# --------------------( WASTELANDS                         )--------------------
        # If this name is an absolute path, return that path's basename.
#       if is_path_absolute "${funcstack[-1]}"
#       then output "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else output "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FIXME: Zeshify.
#   (( # == 0 )) || die 'expected no arguments'
    #FIXME: ${ZESHY_SCRIPT_NAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
#   if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
#       print -- "${ZESHY_SCRIPT_NAME}"

#FIXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
