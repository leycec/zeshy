#!/usr/bin/env zsh
# ====================[ command                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle executable commands in the current user's ${PATH}.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_installed(
#   string command_name,
#   string error_message = "\"${command_name}\" not found in $PATH")
#
# Throw an exception unless the passed command is in the current user's ${PATH}.
die_unless_installed() {
    die_unless_one_or_two_args\
        'expected one command name and optional error message'
    string command_name="${1}"
    is_installed "${command_name}" or
        die "${2:-\"${command_name}\" not found in \$PATH}"
}

# ....................{ TESTERS                            }....................
# boolean is_installed(string command_name)
#
# Return true if the passed command is in the current user's ${PATH}.
is_installed() {
    # Dismantled, this is:
    #
    # * "${1:c}", expanding to the absolute path of the passed command if such
    #   command exists or only the passed command itself otherwise.
    # * "is_path_executable", returning true if such path is executable.
    die_unless_one_arg 'expected one command name'
    is_path_executable "${1:c}"
}

# ....................{ GETTERS                            }....................
# string get_command_path(string command_name)
#
# Get the absolute path of the passed command if in the current user's ${PATH}
# or throw an exception.
get_command_path() {
    die_unless_one_arg 'expected one command name'
    string command_name="${1}"
    get_command_path_if_found "${command_name}" or
        die "\"${command_name}\" not found in \$PATH"
}

# string get_command_path_if_found(string command_name)
#
# Get the absolute path of the passed command if in the current user's ${PATH}
# or return false.
get_command_path_if_found() {
    # Absolute path of the command with the passed name. Dismantled, this is:
    #
    # * "1", expanding to the passed command name.
    # * ":t", excluding all but the basename of such name. This prevents this
    #   function from returning true when passed absolute paths not
    #   corresponding to commands in the $PATH (e.g.,
    #   "get_command_path_if_found /tmp").
    # * ":c", expanding to the absolute path of such command.
    die_unless_one_arg 'expected one command name'
    string command_pathname="${1:t:c}"

    # If such path is absolute and hence exists, return such path; else, fail.
    if is_path_absolute "${command_pathname}"
    then output "${command_pathname}"
    else return_false
    fi
}

# ....................{ GETTERS ~ first                    }....................
# string get_first_command_path(string command_name1, string command_name2, ...)
#
# Get the absolute path of the first command in the passed list in the current
# user's ${PATH} or throw an exception.
get_first_command_path() {
    get_first_command_path_if_found "${@}" or
        die "$(join_list_conjunctively "${@}") not found in \$PATH"
}

# string get_first_command_path_if_found(
#   string command_name1, string command_name2, ...)
#
# Get the absolute path of the first command in the passed list in the current
# user's ${PATH} or return false.
get_first_command_path_if_found() {
    die_unless_at_least_one_arg 'expected at least one command name'

    # Unfortunately, glob qualifiers accept only extant pathnames; hence, the
    # following call always fails (unless the current working directory contains
    # at least one of the passed commands as a path, in which case it
    # erroneously succeeds):
    #
    #   get_first_path_matching_glob_qualifiers\
    #       'found in $PATH' 'found in $PATH'\
    #       'e{whence -cp $REPLY}' "${@}"
    #
    # We adopt a concise alternative leveraging trickery. Dismantled, this is:
    #
    # * "${^@", expanding to each passed command name.
    # * ":t", excluding all but the basenames of such names.
    # * ":c", expanding to, for commands...
    #   * ...in the current user's $PATH, the absolute path of such commands.
    #   * ...otherwise, noop (i.e., the command name itself).
    # * ":#[^/]*", excluding all non-absolute paths and hence command names
    #   not in the current user's $PATH.
    #
    # See get_command_path() for further details.
    list command_pathnames; command_pathnames=( ${${^@:t:c}:#[^/]*} )
    is_list_nonempty command_pathnames and output "${command_pathnames[1]}"
}

# ....................{ APPENDERS                          }....................
# void append_PATH_with_dir_if_found(string dirname1, string dirname2, ...)
#
# Append each passed directory if found onto the ${PATH} and ${path} globals.
append_PATH_with_dir_if_found() {
    # Dismantled, this is:
    #
    # * "(/)", excluding non-extant paths and non-directories.
    die_unless_args 'expected at least one dirname'
    for dirname ( "${@}"(/) ) {
#       say "appending \"${dirname}\"..."
        path+="${dirname}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Rename append_PATH_with_dir_if_found(), in keeping with other append_*()
#names. Also quite a bit more explanatory.

    # Validate passed arguments.
#   typeset -U path
#   print "path: ${path}"

    # If no command has the passed name, print an error message and return
    # failure. To permit the caller to recover, do not raise a fatal error.

# ....................{ GETTERS ~ user                     }....................
# string get_editor_path(void)
#
# Get the (not necessarily absolute) path of the current user's editor command
# if set or a sane currently installed editor command, otherwise.
#get_pager_path() {
#    die_if_args
#    print "${EDITOR}"
#}

# string get_pager_path(void)
#
# Get the (not necessarily absolute) path of the current user's pager command.
#get_pager_path() {
#    die_if_args
#    print "${PAGER:-less}"
#}

#   if is_list_nonempty command_pathnames
#   then print "${command_pathnames[1]}"
#   else return_false
#   fi

#e{whence -cp $REPLY}
#    get_first_path_matching_glob_qualifiers\
#        'found in $PATH' 'found in $PATH'\
#        '(.)' "${^@}:t:c"
#       'e(REPLY=${REPLY:c})' "${@}"
#       'e{REPLY=$REPLY:t:c; [[ $REPLY == /* ]]}' "${@}"
#       "e{REPLY=\$(get_command_path_if_found \"\$REPLY\")}" "${@}"
#       "e{'is_installed \$REPLY'}" "${@}"
    # * "or true", preventing failure if at least one pathname is excluded.
#   list pathnames; pathnames=( ${^@}(${glob_qualifiers}) ) or true
#   eval "pathnames=( \${^@}(${glob_qualifiers}) ) or true"

    # If the list of passed pathnames contains at least one writable pathname,
    # print the first such match; otherwise, raise an exception.
#   if is_list_nonempty pathnames
#   then print "${pathnames[1]}"
#   else return_false
#   fi

#FIXME: *****WAIT*****. We can substantially improve every other function by
#rewriting to the implementation of which_dir_writable(). Also, which_files()
#should clearly simply defer to which_files_if_found() rather than
#reimplementing the whole shebang.

# * Compress which_commands() into which_command() and which_files() into
#   which_file(). (Simplify life, yes? No justifiable reason not to, really.)

# string which_commands(string command_name1, *command_name2, ...)
#
# Get the absolute path of the first command in the passed list of command names
# found in the ${PATH} or raise an exception if no such command is found: e.g.,
#
#     >>> which_commands Council_of_Nicea Constantinople zsh
#     /bin/zsh
# 
# This function is intended to automate selection of commands, in descending
# order of preference. (In the above example, the hypothetical
# "Council_of_Nicea" command would be selected before all following commands on
# systems having the command.)
#which_commands() {
#    die_unless_at_least_one_arg 'expected one command name'
#    
#    # Iteratively look for each command in the passed list.
#    string command_path
#    for command_name ("${@}") {
#        if command_path="$(run_with_unified_output which_command "${command_name}")"; then
#            print "${command_path}"
#            return_true
#        fi
#    }
#    
#    # Otherwise, no such command exists. Die? Die! Die.
#    string command_names=$(join_join_list_prefixing_last_with ', ' 'or ' "\"${^@}\"")
#    die "neither ${command_names} found in \$PATH"
#}

#     >>> which_files '/the_ancient.one' '/the_king_in.yellow' '/tmp'
#     /tmp#   die_unless_at_least_one_arg 'expected at least one dirname'

    # List of writable dirnames filtered from the list of passed pathnames.
    # Dismantled, this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(e{'...'}), excluding pathnames not matching the embedded test.
    # * "or true", preventing failure if at least one pathname is excluded.
#   list dirnames
#        dirnames=( ${^@}(e{'[[ -d $REPLY && -w $REPLY ]]'}) ) or true

    # If the list of passed pathnames contains at least one writable dirname,
    # print the first such match; otherwise, raise an exception.
#   if is_list_nonempty dirnames
#   then print "${dirnames[1]}"
#   else die "neither $(join_join_list_prefixing_last_with ', ' 'or ' "\"${^@}\"") found"
#   fi

    # Dismantled, this is:
    #
    # * "autoload_paths_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${autoload_name}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", removing non-extant paths.
    # * "(..)", listing all extant paths.
#   list autoload_paths
#   autoload_paths=( ${^${(P)autoload_paths_list_name}}/"${autoload_name}" )
