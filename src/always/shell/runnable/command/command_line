#!/usr/bin/env zsh
# ====================[ command_line                       ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle command lines formatted as either:
#
# * Strings whose separation into shell words produces a runnable command: e.g.,
#     string command_line="LC_ALL=C print_text_file 'Zapruder film'"
# * Lists with elements already separated into shell words whose expansion in
#   list order signifies a runnable command: e.g.,
#     list command_line
#     command_line=( LC_ALL=C print_text_file 'Zapruder film' )

# ....................{ TESTERS                            }....................
# boolean is_command_line_executable(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Return true if the passed command is executable as is without requiring
# dynamic evaluation by the run() function or "eval" builtin: e.g.,
#
#     >>> is_command_line_executable LC_ALL=C ls "Wounded Knee"
function is_command_line_executable() {
    die_unless_args 'expected one command'
    is_installed "$(get_command_line_runnable_name_in_command_position "${@}")"
#   is_installed "$(get_command_line_executable_name "${@}")"
#   is_installed "$(get_command_line_name_for_execution "${@}")"
}

# ....................{ GETTERS                            }....................
function get_command_line_runnable_name_in_command_position() {
    #FIXME: Implement me. Just return the first shell word in the passed strings.
}

#FIXME: Modify get_command_path_if_found() to call this function.
#FIXME: Rename to get_command_line_name_for_evaluation()? Hmm; no. Perhaps
#simply get_command_line_runnable_name().

# string get_command_line_name(string command_arg1, string command_arg2, ...)
#
# Get the name of the callable (e.g., command, alias, builtin, function) in
# command position of the passed command line. Command position is the first
# word of the concatenation of all passed arguments, excluding prefixing
# temporary global variable definitions: e.g.,
#
#     >>> get_command_line_name "LD_LIBRARY_PATH=/usr/lib/tor rtorrent"
#     rtorrent
function get_command_line_name() {
    # Validate passed arguments.
    die_unless_args 'expected one command'
    string word

    # Find the first word *NOT* defining a global variable, leveraging Zsh
    # parameter expansions to split passed arguments into shell words.
    # Dismantled, this is:
    #
    # * "*", concatenating passed arguments into a scalar string.
    # * "(z)", splitting such string on shell word boundaries.
    for word ("${(z)*}") {
        is_variable_definition "${word}" or break
    }

    # Return such word.
    output "${word}"
}

# --------------------( WASTELANDS                         )--------------------
