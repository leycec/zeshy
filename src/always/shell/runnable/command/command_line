#!/usr/bin/env zsh
# ====================[ command_line                       ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle command lines formatted as either:
#
# * Strings whose separation into shell words produces a runnable command: e.g.,
#     string command_line="LC_ALL=C print_text_file 'Zapruder film'"
# * Lists with elements already separated into shell words whose expansion in
#   list order signifies a runnable command: e.g.,
#     list command_line
#     command_line=( LC_ALL=C print_text_file 'Zapruder film' )

# ....................{ TESTERS                            }....................
# boolean is_command_line_executable(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Return true if the passed command is executable as is without requiring
# dynamic evaluation by the run() function or "eval" builtin: e.g.,
#
#     >>> is_command_line_executable ls 'Wounded Knee' or print 'Bury.'
#     >>> is_command_line_executable LC_ALL=C ls 'Wounded Knee' or print 'Bury.'
#     Bury.
function is_command_line_executable() {
    die_unless_args 'expected one command'
    is_installed "$(get_command_line_word_in_command_position "${@}")"
}

# ....................{ GETTERS                            }....................
# string get_command_line_word_in_command_position(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Get the first shell word of the passed command line, also referred to as the
# word in command position. This is the command Zsh runs when executing such
# command line as is (i.e., as "${@}" rather than "eval ${@}"), but may not
# necessarily correspond to the expected command. Where this is undesirable,
# consider calling get_command_line_runnable_name() instead: e.g.,
#
#     >>> list command_line; command_line=( LC_ALL=nl_piraten.PARTIJ rtorrent )
#     >>> get_command_line_word_in_command_position "${command_line[@]}"
#     LC_ALL=nl_piraten.PARTIJ
function get_command_line_word_in_command_position() {
    die_unless_args 'expected one command'
    get_string_word "${(z)*}" 1   # see get_command_line_runnable_name()
}

# string get_command_line_runnable_name(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Get the name of the runnable (e.g., command, alias, builtin, function) in
# command position of the passed command line. Command position is the first
# word of the concatenation of all passed arguments, excluding prefixing
# temporary global variable definitions: e.g.,
#
#     >>> get_command_line_runnable_name "LD_LIBRARY_PATH=/usr/lib/tor rtorrent"
#     rtorrent
function get_command_line_runnable_name() {
    # Validate passed arguments.
    die_unless_args 'expected one command'

    # Find the first word *NOT* defining a global variable, leveraging Zsh
    # parameter expansions to split passed arguments into shell words.
    # Dismantled, this is:
    #
    # * "*", concatenating passed arguments into a single string.
    # * "(z)", splitting such string on shell word boundaries.
    string word
    for word ("${(z)*}") {
        is_variable_definition "${word}" or break
    }

    # Return such word.
    output "${word}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Rename to get_command_line_runnable_name_for_evaluation()? Hmm; no. Perhaps
#simply get_command_line_runnable_name().
#FIXME: Modify get_command_path_if_found() to call this function.
#when is the first word of the concatenation of all passed arguments. :
# string get_command_line_shell_word_first(void)
# string get_command_line_command_position_word(void)
#   is_installed "$(get_command_line_executable_name "${@}")"
#   is_installed "$(get_command_line_runnable_name_for_execution "${@}")"
