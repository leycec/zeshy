#!/usr/bin/env zsh
# ====================[ define                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define Zeshy-specific interactive aliases active only when expanded directly
# from the command line of interactive shells. When expanded from any other
# context (i.e., other shell functions or scripts), interactive aliases either
# reduce to their alias name if such name is a pathable or throw an exception.
# See "handle" for all other interactive alias-related functionality.
#
# --------------------( MOTIVATION                         )--------------------
# Startup shell scripts and scripting frameworks often install the canonical
# alias "ll", listing paths in long format by expanding to "ls -l": e.g.,
#
#     # Alias producing greppable and hence shell script-friendly output.
#     alias ll="ls -l"
#
# While convenient, such alias suffers more than a few drawbacks:
#
# * Shell scripts calling "ll" behave as expected only if such alias retains a
#   shell script-friendly expansion. But such alias is readily editable into a
#   shell script-unfriendly expansion, suggesting no such guarantees: e.g.,
#
#     # Alias producing non-greppable and hence shell script-unfriendly output.
#     alias ll="ls -l --color=always --human-readable"
#
# * Shell scripts calling "ll" rather than "ls" behave as expected only under
#   the current shell environment and hence are inherently non-portable.
#   Different users and systems install different startup shell scripts and
#   scripting frameworks, suggesting no such guarantees: e.g.,
#
#     # Alias expanding to a non-"ls" command, producing unexpected output.
#     alias ll="long_long_integer"
#
# * Shell scripts defining a function ll() behave as expected only *NOT* under
#   the current shell environment. Since Zsh assigns aliases higher precedence
#   than functions, an externally defined alias "ll" supercedes any internally
#   defined function ll(): e.g.,
#
#     # Function overriden by the defined alias "ll".
#     ll() {
#         print 'If the caller defined an alias "ll", you'll never see this.'
#     }
#
# --------------------( SOLUTION                           )--------------------
# Interactive aliases solve such portability issues, to varying degrees. Like
# traditional aliases, interactive aliases are declared via "="-delimited
# syntax with which the alias name precedes the alias expansion delimited by an
# "=" character: e.g.,
#
#     # Identical to the prior definition but prefixed with "interactive_".
#     interactive_alias l="ls -l"
#
# Like traditional aliases, the various types of interactive aliases are defined
# by various Zeshy functions:
#
# * interactive_substitution(), substituting an existing Zsh builtin or external
#   command in ${PATH} with an interactive alias of the same name: e.g.,
#
#     # Substitute the external "ls" command with an interactive alias "ls"
#     # internally calling such command with helpful arguments.
#     interactive_substitution ls="ls --all --sort=version"
#
# * interactive_abbreviation(), abbreviating an existing Zsh builtin or external
#   command in ${PATH} with an interactive alias of a different name: e.g.,
#
#     # Abbreviate the external "ls" command with an interactive alias "l".
#     interactive_abbreviation l="ls"
#
# * interactive_alias(), a low-level helper function declaring an interactive
#   alias *NOT* substituting or abbreviating an existing Zsh builtin or external
#   command in ${PATH}. However, most interactive aliases substitute or
#   abbreviate such builtins or commands! For improved portability and safety,
#   consider calling the high-level functions interactive_substitution() or
#   interactive_abbreviation() instead.
#
# --------------------( CONSTRAINTS                        )--------------------
# Interactive substitutions and abbreviations are interactive aliases imposing
# additional runtime constraints, for safety. All interactive aliases should be
# declared as either substitutions or abbreviations, ideally. Zeshy throws an
# exception on attempting to:
#
# * Define either an interactive:
#   * Substitution of a non-existing command. (Substitutions always replace
#     existing commands, thus preventing declaration of interactive aliases
#     inapplicable to the current system and user.)
#   * Abbreviation of an existing alias, function, or command. (Abbreviations
#     never shadow existing callables, unlike typical aliases.)
# * Call an interactive abbreviation non-interactively.
#
# Calling an interactive substitution non-interactively runs the substituted
# command as is, as if never shadowed by an interactive alias. In other words,
# "things just work as expected."
#
# --------------------( SYNTAX                             )--------------------
# Interactive aliases are declared with the customary "="-delimited syntax for
# plain, global, and suffix aliases, as the above examples demonstrate.
#
# Interactive substitutions and abbreviations (but not low-level aliases
# declared by directly calling interactive_alias()) additionally support
# embedded "{..}" expressions in alias names. Such expressions combine multiple
# interactive_substitution() and interactive_abbreviation() calls into a single
# call whose outcome depends on the current shell environment and system.
#
# Interactive substitutions interpret embedded "{..}" expressions as
# interactive abbreviations to be expanded to the same alias. If the implied
# interactive abbreviation name is already an existing command in the current
# user's ${PATH}, the function interactive_substitution() iteratively searches
# for the nearest abbreviation name *NOT* already an external command: e.g.,
#
#     # An interactive substitution containing embedded "{..}" expressions.
#     interactive_substitution {m}k{d}ir="mkdir --parents --verbose --"
#
#     # If no external command in the current user's ${PATH} is named "md", the
#     # above statement is equivalent to the following two statements.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#     interactive_abbreviation md="mkdir"
#
#     # Else if no external command is named "mkd", the above statement is
#     # equivalent to the following two statements.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#     interactive_abbreviation mkd="mkdir"  # "mkd" rather than "md", here
#
#     # Else if no external command is named "mkdi", the above statement is
#     # equivalent to the following two statements.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#     interactive_abbreviation mkdi="mkdir"  # "mkdi" rather than "md", here
#
#     # So, interactive_substitution() iteratively searches for the first name
#     # in the following list *NOT* already an external command in the current
#     # user's ${PATH}: "md", "mkd", and "mkdi". If all such names are already
#     # existing commands, interactive_substitution() prints a warning and
#     # simply reduces to the following one statement.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#
# Interactive abbreviations interpret embedded "{..}" expressions as the
# interactive abbreviation name to be expanded to. This is principally useful
# for generic safety, to accommodate heterogenous end user systems under which
# one has no control and hence could have conceivably installed commands with
# the same names as desired abbreviations: e.g.,
#
#     # Risky! This fails with warning if "rcs" is already an existing command.
#     interactive_abbreviation rcs="rc-status start"
#
#     # Safer. This fails with warning only if all of "rcs", "rcst", "rcsta",
#     # and "rcstar" are already existing commands.
#     interactive_abbreviation {rcs}tart="rc-status start"
#
# Ideally, all interactive substitutions and abbreviations (and hence all
# interactive aliases) should contain at least one "{..}" expression.
#
# --------------------( SYNTAX ~ algorithm                 )--------------------
# Interactive substitutions and abbreviations parse "{..}" expressions according
# to a simple exhaustive algorithm, which for each iteration:
#
# * Concatenates all "{"- and "}"-delimited substrings in the original alias
#   name into an implied abbreviation name: e.g.,
#
#   # In this iteration, the implied abbreviation name is "md".
#   interactive_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
# * If the implied abbreviation name is not already an existing command name,
#   creates such abbreviation; otherwise, shifts the leftmost "}" right by one
#   character in the original alias name unless prior to the last character of
#   such name in which case prints a warning: e.g.,
#
#   # First test whether "md" is already an existing command. If not, run:
#   interactive_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
#   # Else, test whether "mkd" is already an existing command. If not, run:
#   interactive_abbreviation {mk}{d}ir="mkdir --parents --verbose --"
#
#   # Else, test whether "mkdi" is already an existing command. If not, run:
#   interactive_abbreviation {mkdi}ir="mkdir --parents --verbose --"
#
#   # Else, all such names already exist. Emit a vile warning.
#   cry 'interactive abbreviations "md", "mkd", and "mkdi" already existing commands'
#
# --------------------( CAVEATS                            )--------------------
# Zeshy requires such functionality before compiling its digest, sadly. Since
# Zeshy confines most functionality to its digest, no function below may call
# Zeshy functions. All functions below must manually implement Zeshy functions
# defined elsewhere!
#
# Zeshy implements interactive aliases as functions rather than genuine aliases.
# This solves the prior problem of Zsh assigning aliases higher precedence
# than functions, but could potentially trip up the unawares. (In practice, the
# difference between aliases and functions tends to be negligible. Usually,
# anyway!)
#
# --------------------( TODO                               )--------------------
# * Genius! (Or, at the least, modestly clever. Oh, very well: it's merely
#   obvious.) We can dramatically improve efficiency and reliability by
#   partitioning the digest file into two such files:
#   * One compiling the gamut of all Zeshy functions and active interactively.
#   * The other compiling all Zeshy functions *EXCEPT* interactive aliases and
#     active non-interactively. (This is easy; just prepend a second call to a
#     Zeshy compilation function with temporary disabling of such globals via
#     ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS= and
#     ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS=).
#   Override the Zsh hook called immediately:
#   * Before evaluation of a new user-input interactive command to prepend the
#     ${FPATH} with the prior digest file, excising the latter digest file if
#     already prepended.
#   * After evaluation of a new user-input interactive command to prepend the
#     ${FPATH} with the latter digest file, excising the former digest file if
#     already prepended.
#   All of this assumes Zsh exposes sufficient hooks, of course. It may not. It
#   probably doesn't, in fact. But if it does... coolness is ours, baby.
# * Technically, we can support interactive aliases on functions -- but only
#   in somewhat roundabout fashion. We would need detect this to be an alias on a
#   function (easy), then define a new function with the same implementation as the
#   function to be replaced by such alias but with a new name, say,
#   "${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#   us a function implementation which we could then eval into a new function with
#   such placeholder name?), then replace the old with the new function name in the
#   alias expansion (easy). It's a bit involved, but nothing too intractable.

# ....................{ GLOBALS                            }....................
document_global '
map ZESHY_INTERACTIVE_ALIAS_NAME_TO_EXPANSION

Map from interactive alias name to corresponding expansion. Each call to
interactive_alias(), interactive_abbreviation(), and interactive_substitution()
adds the selected alias name and passed expansion to this map.
'
ZESHY_INTERACTIVE_ALIAS_NAME_TO_EXPANSION=()

document_global '
map ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION

Map from interactive abbreviation name to corresponding expansion. Each call to
interactive_abbreviation() and interactive_substitution() (if embedding a "{"-
and "}"-delimited abbreviation name in the passed alias name) adds the selected
abbreviation name and passed expansion to this map.
'
ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION=()

document_global '
map ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION

Map from interactive substitution name to corresponding expansion. Each call to
interactive_substitution() adds the passed substitution name sans "{"- and "}"-
delimited abbreviation name and passed expansion to this map.
'
ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION=()

# ....................{ ABBREVIATORS                       }....................
document_function '
void interactive_abbreviation(string alias_specification)

Define an interactive abbreviation from the passed "="-delimited specification.
Interactive abbreviations are interactive aliases (and hence intended to be
called only directly from the command line) subject to two additional
constraints:

* Interactive abbreviations *NEVER* replace existing runnables (i.e., external
  commands or Zsh aliases, builtins, or functions). If the passed alias name
  duplicates the name of an existing runnable, print a warning to standard error
  and return with zero exit status without defining such alias: e.g.,

  >>> interactive_abbreviation ls="print Lysergic acid diethylamide"
  zeshy: interactive abbreviation "ls" already a defined command:
  /bin/ls

* Interactive abbreviations *ALWAYS* throw exceptions when expanded from non-
  interactive shells or shell scripts: e.g.,

  >>> interactive_abbreviation ptm="print Thunnus maccoyii"
  >>> ptm
  Thunnus maccoyii
  >>> () { ptm }
  ptm: interactive abbreviation "ptm" cannot be called non-interactively
  ptm: "ptm" failed with exit status 1

Interactive abbreviations thus differ from both interactive substitutions and
Zsh aliases, which always replace existing runnables without warning. Consider
calling interactive_substitution() if such functionality is preferable: e.g.,

  # This is probably not a terribly good idea.
  >>> interactive_substitution ls="print Lysergic acid diethylamide"
  >>> ls
  print Lysergic acid diethylamide
'
function interactive_abbreviation() {
    string ZESHY_ALIAS_TYPE='abbreviation'
    interactive_alias "${@}"
}

# ....................{ SUBSTITUTORS                       }....................
document_function '
void interactive_substitution(string alias_specification)

Define an interactive substitution from the passed "="-delimited specification.
Interactive substitutions are interactive aliases (and hence intended to be
called only directly from the command line) subject to one additional
constraint:

* Interactive substitutions *ONLY* replace existing runnables (i.e., external
  commands or Zsh aliases, builtins, or functions). If the passed alias name is
  *NOT* the name of an existing runnable, print a warning to standard error
  and return with zero exit status without defining such alias: e.g.,

  >>> interactive_substitution wine="print Trichocereus pachanoi"
  zeshy: interactive substitution "wine" not a defined command or builtin

Interactive substitutions thus differ from both interactive abbreviations and
Zsh aliases. The former never replace existing runnables; the latter always
replace existing runnables but never throw exceptions if such runnable does not
already exist. Consider calling interactive_abbreviation() or
interactive_alias() if such functionality is preferable.
'
function interactive_substitution() {
    string ZESHY_ALIAS_TYPE='substitution'
    interactive_alias "${@}"
}

# ....................{ HELPERS                            }....................
document_function '
void interactive_alias(string alias_specification)

Define an interactive alias from the passed "="-delimited specification. Like
normal aliases, interactive aliases are defined with "="-style syntax. Unlike
normal aliases, which are expandable from both interactive shells and non-
interactive shell scripts, interactive aliases are expandable from only
interactive shells. Attempting to expand interactive aliases from non-
interactive shells calls the unexpanded name of such alias, instead: e.g.,


  # Alias print() to print arguments in lexicographic order when interactive.
  >>> print T M D
  T M D
  >>> interactive_alias print="print -o"
  >>> print T M D
  D M T
  # Run print() from a non-interactive subshell. Note the normal behavior.
  >>> (print T M D)
  T M D

Due to implementation details, interactive aliases cannot expand functions of
the same name. Doing so would silently replace the prior defined function with
the interactive alias, thus inducing "command not found" errors on alias
expansion. If passed an interactive alias name of the same name as an existing
function, this function throws an exception: e.g.,

  >>> function 4-HO-MET() { print_string "${1} is colour" }
  >>> interactive_alias 4-HO-MET="4-HO-MET Methylcybin"
  zeshy: interactive abbreviation "4-HO-MET" already a defined function:
  4-HO-MET() { print_string "${1} is colour" }
'
function interactive_alias() {
    # Validate passed arguments, splitting the "="-delimited alias name and
    # expansion split from all passed strings. Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
    die_unless_args
    string\
        alias_name="${*%%[[:space:]]#\=*}"\
        alias_expansion="${*#*\=[[:space:]]#}"\
        alias_name_type command_name\
        alias_expansion_if_interactive alias_expansion_if_non_interactive\
        alias_logic_if_interactive alias_logic_if_non_interactive
#   print "args: ${*%%=*}"

    # Type of interactive alias to be defined, defaulting to "alias" if not
    # already set by the caller. Recognized types include:
    #
    # * "substitution", only set by interactive_substitution().
    # * "abbreviation", only set by interactive_abbreviation().
    # * "alias", only set by this function.
    string ZESHY_ALIAS_TYPE="${ZESHY_ALIAS_TYPE:-alias}"
#   is "${ZESHY_ALIAS_TYPE}" == abbreviation si and print "alias type: ${ZESHY_ALIAS_TYPE}\nalias name: ${alias_name}\nalias expansion: ${alias_expansion}" 1>&2
#   is "${alias_name}" == '{acr}oread' si and { print "acroread!"; curse_call_stack }

    # Validate passed arguments.
    is "${ZESHY_ALIAS_TYPE}" == (substitution|abbreviation|alias) si or
        die "interactive alias type \"${ZESHY_ALIAS_TYPE}\" unrecognized"
    is "${alias_name}" == "${alias_expansion}" si and
        die "interactive ${ZESHY_ALIAS_TYPE} specifier \"${*}\" contains no '=' delimiter"
    (( #alias_name )) or
        die "interactive ${ZESHY_ALIAS_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
    (( #alias_expansion )) or
        die "interactive ${ZESHY_ALIAS_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

    # If such alias name contains at least one "{"- and "}"-delimited substring,
    # concatenating all such substrings provides the abbreviation name embedded
    # in such alias name (e.g., abbreviation "ichy" in alias "l{ich}mumm{y}").
    # Parse and possibly define such abbreviation.
    is "${alias_name}" == *'{'*'}'* si and interactive_alias_parse_embedding

    # If such alias name is already a declared...
    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # ...Zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_shell_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
        if is "${alias_name_type}" == 'function' si
        then die "interactive ${ZESHY_ALIAS_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"
        # ...any other callable (e.g., alias, builtin, command) and this is an
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
        elif is "${ZESHY_ALIAS_TYPE}" == 'abbreviation' si; then
            cry "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
            return_true
        # Otherwise, silently wrap such callable in the passed alias.
        fi
    # If such alias name is *NOT* already a declared callable and this is an
    # interactive substitution alias, there exists nothing to be substituted.
    # Throw an exception.
    elif is "${ZESHY_ALIAS_TYPE}" == 'substitution' si; then
        die "interactive substitution \"${alias_name}\" not a defined command or builtin"
    # Otherwise, declare such callable as the the passed alias.
    fi
#   is "${ZESHY_ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # If the first shell word such alias expands to equals its name but not an
    # existing command or builtin, the caller is probably attempting to
    # interactively alias a function of the same name: e.g.,
    #
    #  interactive_alias recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "interactive_alias recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
    command_name="${alias_expansion[(w)1]}"
    is "${alias_name}" == "${command_name}" si and
        not whence -- "${command_name}" &>/dev/null and
        die "interactive alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ZESHY_ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # If the first shell word such alias expands to is prefixed by "run_", assume
    # such word to be a Zeshy function transitively calling run() with arguments
    # requiring quote protection.
    if is "${command_name}" == 'run_'* si
    then alias_expansion_if_interactive="${alias_expansion} \"\${(q)@}\""
    # Otherwise, pass arguments to such expansion as is.
    else alias_expansion_if_interactive="${alias_expansion} \"\${@}\""
    fi

    # Interactive logic to be performed by the function definition below.
    alias_logic_if_interactive="
    if is_standard_input_piped
    then run_with_standard_input_piped ${alias_expansion_if_interactive}
    else ${alias_expansion_if_interactive}
    fi"

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing callable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
    if is "${alias_name_type}" == 'none' si
    then alias_logic_if_non_interactive="die 'interactive ${ZESHY_ALIAS_TYPE} \"${alias_name}\" cannot be called non-interactively'"
    else
        alias_expansion_if_non_interactive="${alias_name} \"\${@}\""
        alias_logic_if_non_interactive="
    if is_standard_input_piped
    then run_with_standard_input_piped ${alias_expansion_if_non_interactive}
    else ${alias_expansion_if_non_interactive}
    fi"
    fi

    # Define such alias as a function of the same name. Specifically:
    #
    # * Temporarily disable such function to prevent infinite recursion if
    #   such expansion transitively calls an alias, builtin, or command of the
    #   same name.
    # * If the current shell is interactive (thus excluding non-interactive
    #   scripts) and such function was called directly from the command line
    #   (thus excluding intermediate calls by interactively called functions),
    #   run the interactive expansion; else run the non-interactive expansion.
    # * Regardless of whether an exception is thrown, reenable such function.
    eval "function ${alias_name}() {
    {
        disable -f ${alias_name}
        if [[ -o interactive && \${#funcstack} -eq 1 ]]
        then ${alias_logic_if_interactive}
        else ${alias_logic_if_non_interactive}
        fi
    } always {
        enable -f ${alias_name}
    }
}"

    # Since such alias has now been successfully declared, record such success
    # by mapping the selected alias name to the passed alias expansion in the
    # global maps appropriate to such alias.
    ZESHY_INTERACTIVE_ALIAS_NAME_TO_EXPANSION[${alias_name}]="${alias_expansion}"
    if is "${ZESHY_ALIAS_TYPE}" == 'abbreviation' si
    then ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION[${alias_name}]="${alias_expansion}"
    elif is "${ZESHY_ALIAS_TYPE}" == 'substitution' si
    then ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION[${alias_name}]="${alias_expansion}"
    fi
}

document_function '
void interactive_alias_parse_embedding(void)

Parse "{"- and "}"-delimited substrings from the current interactive alias
name of the current type ("substitution" or "abbreviation") expanding to the
current alias expansion. Concatenating such substrings gives the interactive
abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
abbreviation "ichy"). If such type is:

* An abbreviation, return such abbreviation name.
* A substitution and:
  * If all possible extensions of the embedded abbreviation have been claimed
    by existing callables, print a warning and define no such abbreviation.
  * Otherwise, define such abbreviation to the passed expansion.
  * In either case, return such alias name stripped of "{" and "}" characters.

This function is a helper intended to be called only by interactive_alias(),
thus accepting no arguments and returning no values.
'
function interactive_alias_parse_embedding() {
    # Validate sanity.
    die_if_args

    # If such abbreviation is invalid, throw an exception.
    is "${ZESHY_ALIAS_TYPE-}" == 'alias' si and
        die "interactive ${ZESHY_ALIAS_TYPE} \"${alias_name}\" contains a \"{...}\" but is neither an abbreviation or substitution"
    is "${alias_name}" == \{[^\{\}]#\} si and
        die "interactive ${ZESHY_ALIAS_TYPE} \"${alias_name}\" contains a full \"{...}\""
    is "${alias_name}" == *\{\}* si and
        die "interactive ${ZESHY_ALIAS_TYPE} \"${alias_name}\" contains an empty \"{}\""
    is "${alias_name}" == *\{[^\}]# si and
        die "interactive ${ZESHY_ALIAS_TYPE} \"${alias_name}\" contains an unclosed '{'"

    # Copy of the passed alias name.
    string alias_name_copy="${alias_name}"

    # Abbreviation name parsed from ${alias_name_copy}.
    string abbre_name

    # Character succeeding the leftmost "}" in ${alias_name_copy}.
    string abbre_next_char

    # 1-based indices of the characters immediately preceding and succeeding
    # the leftmost "}" in ${alias_name_copy}.
    integer\
        abbre_last_char_index\
        abbre_next_char_index abbre_next_next_char_index

    # Iteratively shift the leftmost "}" in ${alias_name_copy} right one
    # character until either finding an abbreviation name claimed by no
    # existing callable or reaching the end of ${alias_name_copy}.
    while true; do
        abbre_name="${alias_name_copy//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       print_string_escaped "abbreviation: ${abbre_name}"
        whence -- "${abbre_name}" &>/dev/null or break

        # Find the index of the leftmost "}" in ${alias_name_copy} by
        # matching the first "{..}" in such copy. Dismantled, this is:
        #
        # * "#", matching from the beginning of ${alias_name_copy}.
        # * "(#m)", setting global integer ${MEND}, the 1-based index of
        #   the last character matched -- in this case, the leftmost "{".
        noop "${alias_name_copy#(#m)[^\{\}]#\{[^\{\}]##\}}"

        # If the index of the leftmost "}" is the last character in
        # ${alias_name_copy}, the prior iteration shifted such "}" to the
        # end of such copy and hence exhausted all characters. Return!
        (( abbre_next_char_index = MEND + 1 ))
        (( abbre_next_char_index < ${#alias_name_copy} )) or break

        # Otherwise, get the character succeeding the leftmost "}".
        (( abbre_last_char_index = MEND - 1 ))
#       print_string "abbre_next_char_index: ${abbre_next_char_index}"
        abbre_next_char="${alias_name_copy[${abbre_next_char_index}]}"

        # Shift the leftmost "}" in ${alias_name_copy} right one character.
        #
        # If the character succeeding the leftmost "}" is a "{", there exist
        # two adjacent "{..}" expressions (e.g., "{mk}{d}ir"). Do not shift
        # the "}" to the right of the "{" (e.g., "{mk{}d}ir"); rather, merge
        # the two expressions (e.g., "{mkd}ir").
        if is "${abbre_next_char}" == '{' si; then
            (( ++abbre_next_char_index ))
            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${alias_name_copy[${abbre_next_char_index},-1]}"
        # Otherwise, simply shift the leftmost "}" right one character.
        else
            (( abbre_next_next_char_index = abbre_next_char_index + 1 ))
            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${abbre_next_char}}${alias_name_copy[${abbre_next_next_char_index},-1]}"
        fi
#       print_string "new alias name: ${alias_name_copy}"
    done

    # If all possible abbreviation names have already been claimed by
    # existing callables and:
    #
    # * This is an interactive substitution, print a warning and define no
    #   such abbreviation.
    # * This is an interactive abbreviation, do nothing (i.e., attempt to
    #   use the entire alias name stripped of "{" and "}" characters as the
    #   abbreviation name).
    if (( abbre_next_char_index == #alias_name_copy )); then
        is "${ZESHY_ALIAS_TYPE}" == 'substitution' si and {
            string abbre_name_type
            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
            abbre_name_type="${$(whence -w -- "${abbre_name}")##*: }"
            cry "abbreviation \"${abbre_name}\" in interactive substitution \"${alias_name}\" already a defined ${abbre_name_type}:\n$(which "${abbre_name}")"
        }
    # If this is an interactive substitution, define an interactive
    # abbreviation of the above abbreviation name and same expansion as this
    # substitution. While this does recursively call interactive_alias(), such
    # call *NEVER* performs another recursive call. (Why? Listen closely: such
    # abbreviation name contains no "{" or "}" characters and hence no embedded
    # abbreviation. Since such recursive call never calls this function, the
    # recursion is guaranteed to "bottom out" after the first recursion.)
    elif is "${ZESHY_ALIAS_TYPE}" == 'substitution' si; then
#       print "abbreviating embedded ${abbre_name}=\"${alias_expansion}\"" 1>&2
        interactive_abbreviation ${abbre_name}="${alias_expansion}"
    # If this is an interactive abbreviation, set the alias name to be returned
    # to the above abbreviation name.
    else alias_name="${abbre_name}"
    fi

    # Strip "{" and "}" characters from the alias name to be returned.
    alias_name="${alias_name//[\{\}]}"
}

# --------------------( WASTELANDS                         )--------------------
# This component resides under "00-setup" to guarantee its importation prior to
# other Zeshy components during compilation of Zeshy's digest file. Typically,
# other Zeshy components call functions this component defines (e.g.,
# interactive_substitution()) in a global context.

    # If such alias is either an
    # interactive abbreviation or substitution as is usual, .
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Note: avoid calling die() or functions calling die() below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# algorithmically selected abbreviation name to this list.

#List of aliases to be expanded when run from an interactive shell. Each alias
#name (excluding embedded "{" and "}" characters) must be the name of an
#existing runnable. See ${ZESHY_INTERACTIVE_ABBREVIATIONS} for further details.

#Interactive abbreviations and substitutions are generally safer than and hence
#preferable to normal zsh aliases, for most uses.

    #   the next name until either finding a
    #   name not already taken by an existing runnable or exhausting all
    #   available choices, in which case Zeshy prints a warning.

#heuristics find the shortest desired alias name not already
#claimed by an existing runnable
#with "{"- and "}"-delimited substrings in the alias name
#
#embedding Zeshy-specific "heuristics."
#For all three 
#With normal zsh aliases, the substring left of the "=" specifies the alias name
#while the substring right of the "=" the alias expansion: e.g.,
#
#Normal zsh aliases have the familiar format
#"alias ${alias_name}=${alias_expansion}": e.g.,
#
#    alias this_is_the_alias_name="this --is --the -- alias expansion"
#
#With interactive abbreviations and substitutions, the substring left of the "="
#is a heuristic helping Zeshy to find the shortest desired alias name not already
#claimed by an existing runnable while the substring right of the "=" still defines the alias
#expansion as for normal aliases.
#see ${ZESHY_INTERACTIVE_SUBSTITUTIONS} for interactive aliases
#always replacing existing runnables.

# on the current system (i.e., not already the name of
#an existing alias, builtin, or function or external command in the current
#user''s ${PATH}),
#Interactive abbreviations *NEVER* replace existing runnables (i.e., external
#commands or zsh aliases, builtins, or functions). Hence, such abbreviations are
#appropriate for abbreviating but not replacing an existing 

#By contrast, interactive substitutions *ALWAYS* replace existing runnables. 

    #FUXME: It'd be great to add a new list ${ZESHY_INTERACTIVE_SUBSTITUTIONS}
    #with "="-delimited elements, which would allow us to do away with a few
    #currently extraneous "if_installed" components: e.g.,
    #ZESHY_INTERACTIVE_SUBSTITUTIONS=(
    #    {m}utt='mutt -y'
    #)
    #FUXME: Come to think, it'd be great to shift *ALL* current calls to
    #interactive_abbreviation() and interactive_substitution() into
    #"if_config/alias", thus rendering such aliases accessible to user
    #configuration (as well as cleaning up and simplifying the syntax). I'm
    #fully for it! Huz-zzah!


# See "help interactive_abbreviation" for further details on abbreviations.

#       interactive_substitution_if_pathable "${specification}"
#   for specification ("${ZESHY_INTERACTIVE_ABBREVIATIONS_IF_PATHABLE[@]}") {
#       interactive_abbreviation_if_pathable "${specification}"
#   }
#   ZESHY_INTERACTIVE_ABBREVIATIONS_IF_PATHABLE\
# List of interactive aliases in "="-delimited syntax to be expanded only if run
# from an interactive shell *AND* the alias name (excluding embedded "{" and "}"
# characters) is the name of an existing runnable on the current zsh system.
# See above for further details on such syntax.
#ZESHY_INTERACTIVE_ABBREVIATIONS_IF_PATHABLE=(
#)

#interactive_abbreviation ${subst_name}="${command_name}"

# operate slightly
# differently.
# intername alias 
# All "{"- and "}"-delimited substrings within alias
# names denote preferred abbreviation names. See
# interactive_abbreviation() for further details.
#
# For example, the single line "{v}im" listed below produces alias "v" running
# ViM when the current shell is interactive and the current ${PATH} contains
# "vim" (i.e., when ViM is installed). In effect, Zeshy converts this line to
# code resembling:
#
#     >>> is_shell_interactive and is_pathable vim and alias v='vim'

#   is "${ZESHY_ALIAS_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2

#Interactive abbreviations are thus suitable for abbreviating existing runnables
#with a unique name. See interactive_alias() for further details: e.g.,
#
#Interactive abbreviations refuse to replace existing runnables. Specifically,
#are interactive aliases (and hence intended to be
#called only directly from the command line) subject to an additional constraint:
#interactive abbreviations *NEVER* replace existing runnables (i.e., external
#commands or Zsh aliases, builtins, or functions).

#Interactive aliases are inactive in non-interactive scripts and
#functions, and hence helpful for applying human-readable options on that
#builtin or command when run directly by a human. This function fails if the
#builtin or command to be aliased does not exist. See
#interactive_alias_if_installed() for an alternative not failing in such cases.

# >>> print_noninteractively() { print "${@}" }
# >>> print_noninteractively T M D
# T M D
#The alias specification format is identical to that of normal aliases:
#   (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or return_true
#   (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or return_true

#whereas 
#if the passed alias name has the same name as some existing callable (e.g.,
#builtin, command), print a warning and return without defining such alias.

#Interactive abbreviations *NEVER* replace existing callables, but are
#otherwise identical to interactive aliases.
#If the current user has enabled the configuration global
#${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS},
#   ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS\
#   ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS
# ....................{ BOOLEANS ~ alias                   }....................

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FUXME: Actually, these are thoroughly obsolete. Stop using them everywhere and
#excise. Replace with proper granular support for "="-delimited aliases in
#configuration file "alias".
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# If non-empty, ...

# "1" if wrapping interactively run external commands (e.g., "cp", "grep", "ls")
# with corresponding Zeshy functions and "" otherwise. If enabled, Zeshy runs
# such commands with default options defined by the corresponding list below
# (e.g., wrapping interactively run "cp" commands with copy_path(), a Zeshy
# function passing "cp" the ZESHY_CP_OPTIONS list). If disabled, Zeshy runs
# such commands with no such defaults.
#
# For sanity, Zeshy never wraps core commands when run non-interactively (e.g.,
# "cp" when run from a script always executes "cp" with no such defaults).
#ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS=${ZESHY_BOOLEAN_TRUE}

#FUXME: Document.
#ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS=${ZESHY_BOOLEAN_TRUE}

    #   * Standard print_string is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
#&& -t ${ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT}

# ....................{ GLOBALS                            }....................
#FUXME: It'd be great to make this somehow configurable. Ah; obviously, this
#should go into a configuration file. I s'pose that was very obvious. How about
#simply "alias" at the top-level? Not convinced we need the
#add_interactive_gui_substitution() function, honestly; cut it to the wastes.
#Since there only exists one remaining small function, move such function to
#"interactive_alias".

#a similar
#   interactive substitution and abbreviation to the such strings run disowned
#   (e.g.,     # For each such name, if such name stripped of "{"- and "}"-delimited
    # substrings produces a currently installed command name, define such name
    # to interactively expand to such command name.
#"disowned" from the current
    # shell. GUI commands should almost always run "disowned" to prevent their
    # termination on termination of the parent shell.
# While GUI commands should avoid terminating on termination of their
# originating shell, CLI commands should always terminate on , this list typically lists .
# Such substitutions
# either were previously added to
# ${ZESHY_INTERACTIVE_SUBSTITUTIONS_RUN_DISOWNED} by prior calls to
# add_interactive_substitutions() or are hard-coded into this function.#
# Interactive substitution name embeds "{"- and "}"-delimited strings defining the corresponding
# interactive abbreviation name).
# by the embedded
# interactive substitution name. Typically, such commands are graphical.
# ....................{ ADDERS                             }....................
# void add_interactive_gui_substitution(
#   string substitution_name1, string substitution_name2, ...)
#
# Add the passed strings to list global
# ${ZESHY_INTERACTIVE_SUBSTITUTIONS_RUN_DISOWNED}, to be subsequently defined by
# startup_interactive_gui_substitutions() as interactive substitutions running
# GUI commands (i.e., disowned from the current shell).
#function add_interactive_gui_substitution() {
#    die_unless_args 'expected at least one substitution name'
#    ZESHY_INTERACTIVE_SUBSTITUTIONS_RUN_DISOWNED+=( "${@}" )
#}

    #FUXME: DeVeDe appears to fail under:
    #   {d}e{v}e{de}                   # DeVeDe DVD Creator.
    #Why?
    #FUXME: Declare as a "list_set_global" here and below, to preserve uniqueness.
# as interactive substitutions running
# interactive substitutions for a subset of hard-coded GUI commands.
#FUXME: It'd be nice to permit users to dynamically add aliases to such list.
#Since we already helpfully use a global_export variable below, we need only add a few
#helper functions to enable this.

#Of course, this begins to raise awkward timing issues, as well... Ah. No; it
#doesn't, really.

# Unlike Zeshy Interactive Alias, this component need not reside under
# "00-startup". It does, however, need be imported after importing Zeshy
# Interactive Alias. Thus, its filename.
        # If such command is installed, define such substitution.
# Thus, this component is a
# hard dependency of typical Zeshy components.
#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

#FIXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FIXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> interactive_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing callable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> interactive_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> interactive_substitution {m}k{d}ir='mkdir -v --'
#    >>> interactive_substitution {mkd}ir='mkdir -v --'
#    >>> interactive_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing interactive_abbreviation() or interactive_alias() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#FIXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

# Unlike traditional aliases, :
# substitution and abbreviation interactive aliases. 
#
# Interactive aliases are declarable with one of the following functions:
#
# the "interactive_alias"
# helper (as above), Zeshy recommends using the following  "interactive 
#
# While interactive aliases are declarable directly with the "interactive_alias"
# helper (as above), Zeshy recommends using the following  "interactive 
# There are two prominent types of interactive aliases.
#
# Like traditional aliases, there are two prominent types of interactive
# aliases: substitution and abbreviation interactive aliases. 
#
# Defer defining the following functions until having defined all prior aliases.
    # While the following block would ideally be encapsulated in a separate
    # function, its calling of interactive_abbreviation() and hence dynamic
    # evaluation of a new function definition would erroneously confine such
    # definition to the subshell
#       alias_name="$(parse_embedded_interactive_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"


#       print -r -- "${alias_name//[\{\}]}"
#       alias_name="$(parse_embedded_interactive_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"
# string parse_embedded_interactive_abbreviation(
#   string alias_type, string alias_name, string alias_expansion)
#
# Parse "{"- and "}"-delimited substrings from the passed interactive alias name
# of the passed type (either "substitution" or "abbreviation") expanding to the
# passed expansion. Concatenating such substrings provides the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing callables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
    # Validate passed arguments.
#   die_unless_args_3\
#       'expected one alias type, one alias name, and one alias expansion'
#   string alias_type="${1}" alias_name="${2}" alias_expansion="${3}"
#   print_string_escaped "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}"

#           match=()
#           (( abbre_first_char_index = ${mend[1]} - 1 ))
#           (( abbre_right_brace_index = MEND ))
    # Return unless the current user configuration enables substitutions.
    # Return unless the current user configuration enables abbreviations.
#   string alias_name="${*%%[[:space:]]#\=*}"
#   noop "${(S)alias_name//*\{(#b)(*?)\}*}"
#   if ; then
#   if is "${alias_name}" == *'{'(#b)(*?)'}'* si; then
#   if is -n "${(MS)alias_name//*\{(#b)(*?)\}*}" si; then
#   print_string "match attempt: ${(SI:1:)alias_name//*\{(#b)(*?)\}*}"
#   print_string "match attempt: ${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   match=()
#   noop "${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   if is -n "${match}" si; then
#       match=()
#       is "${alias_name}" == (#b)[^{}]#'{'([^{}]##)'}'[^{}]# si
#       is "${alias_name}" == ([^{}]#'{'(#b)([^{}]##)'}')## si
#       is "${alias_name}" == (#b)([^{}]#'{'([^{}]##)'}')## si
#       print_string "alias_name: ${alias_name}"
#       print "${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       print_string "embedding: ${match[*]}"
#       print_string "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       print_string "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       integer embedded_first_char_index=$(( ${mend[1]} - 1 ))
#       print_string "match: ${match[1]}; mend: ${mend[1]}"

#   string abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#   if is "${abbre_name}" != "${alias_name}" si; then
#       integer alias_name_length="${#alias_name}" abbre_next_char_index
#       print_string_escaped "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}\nalias name length: ${alias_name_length}"
#   else
#By design, the passed alias must be either an interactive abbreviation or
# substitution. #       while whence -- "${abbre_name}" 1>/dev/null 2>&1; do
#           (( abbre_next_char_index < 10 )) or break
                #FIXME: Should be handled by the above exception handling, no?
#               (( abbre_next_char_index < alias_name_length )) or
#                   die "interactive substitution \"${alias_name}\" contains an unclosed '{'"
    # If *NOT* a raw interactive alias (e.g., if either an interactive
    # substitution or abbreviation) and 
#           string abbre_name_definition
#           abbre_name_definition=""
#           cry "embedded abbreviation interactive substitution \"${alias_name}\" contains"

#           case "${interactive_alias_type}" in
            # ...this is an interactive substitution alias and the current user
            # prohibits substituting callables with such aliases, return!
#           substitution) return_true;;
#               is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#                   return_true
            # ...this an interactive abbreviation alias, return! Also, if the
            # current user prohibits abbreviating callables with such aliases,
            # print a warning indicating such abbreviation could not be defined.
#           elif is "${interactive_alias_type}" == 'abbreviation' si; then
#               is -n "${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}" si or
#                   cry "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#               return_true

    #FIXME: Document. I get it. We were trying to make the above
    #'interactive_alias print="print -o"' example work as expected. But, if you
    #think about it, that's pretty much impossible in the general case. For example,
    #'interactive_alias print="run_paged print -o"' pretty much fails under non-
    #interactivity with the naive assumption of the first word being the command to be
    #run. I'd say this needs dramatic generalization. Basically, the function should
    #strictly accept only one or two arguments; if passed, the second argument tells
    #what to run when non-interactive and otherwise defaults to the following:
    #
    #* If the alias name and first word of the alias expansion are the same and:
    #  * Such name is an existing function, throw an exception (as below) when run
    #    non-interactive.
    #  * Default to such name without arguments (as below) when non-interactive.
    #* Otherwise, default to such name without arguments (as below) when non-interactive.
    #
    #Oh, wait. The above FIXME handles such edge cases, so... simply default to:
    #
    #* If the first word of the alias expansion is a non-empty, non-alias, non-function
    #  (i.e., is a command, builtin, or reserved), such word.
    #* Else if the first word of the alias expansion matches the "run_"* glob and the
    #  second word of such expansion is a non-empty, non-alias, non-function, such word.
    #* Else if the alias name is a non-empty, non-alias, non-function, such name.
    #* Otherwise, throw an exception from within such function definition.
    #
    #Note that *': function' erroneously fails to match aliases. So, just glob
    #*': '(builtin|command|reserved) explicitly. *shrug*
    #
    #This default cleanly handles the prior examples. It won't work in all cases, of
    #course, which is why we permit parameters resembling:
    #
    #    interactive_alias print_up="do_something_curious print -o"' 'print'
    #
    #*ACTUALLY*, the more I think about, the more I realize the above heuristics only
    #apply to the case that the alias name is a non-function (e.g., external command);
    #in such case, the above heuristic can be seemlessly reduced to simply calling such
    #name. If, on the other hand, the alias name is an *ABBREVIATION*, then it should
    #*NEVER* be callable non-interactively; an exception should always be thrown. Since
    #this logic biffurcates cleanly between interactive_alias() and
    #interactive_abbreviation()... You know, why do we even have those two functions?
    #Any interactive alias for which the alias name is *NOT* already an existing non-
    #function is implicitly an abbreviation or something similar. I believe we can
    #dispense with interactive_abbreviation(), therefore.

    #FIXUP: We should probably throw an exception under cases such as:
    #
    #  interactive_alias recursive='recursive -not -ok'
    #  function recursive() { print 'uh oh'; }
    #
    #While recursion *USUALLY* works (due to our use of function disabling and
    #enabling below), it fails if the first word of the alias expansion expands
    #to a Zsh function of the same name as the alias. In the case above, such
    #function has yet to be defined. Hence, *UNLESS* such word has a non-empty,
    #non-function type, we assume its type to be function and throw an exception.

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.

#   then alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#interactive_alias ff="firefox"
    # The string to expand this alias to when called non-interactively.
#   if is "${alias_name}" == "${command_name}" and\
#      "$(whence -w "${command_name}")" == *': function' si
#   then alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
        #FIXME: Have my doubts about this logic; it feels... dubious. Too
        #clever, and arguably bug-prone. Let's ride bareback for a bit.
#       if is "${alias_name_type}" != 'function' si
#       then alias_expansion_if_non_interactive="${alias_name}"
#       else alias_expansion_if_non_interactive=
#       fi
#   else
#       alias_expansion_if_non_interactive="${command_name} \"\${@}\""
#       alias_logic_if_non_interactive="
#   if is_standard_input_piped
#   then run_with_standard_input_piped ${alias_expansion_if_non_interactive}
#   else ${alias_expansion_if_non_interactive}
#   fi"
#   fi

#FIXME: Implement me. Basically, disembowel interactive_alias(). ;]
#define_interactive_alias() {
#}

    #SUBSTITUTION
#   if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
#       if is "${alias_name_type}" == 'function' si; then
#           die "interactive substitution \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       else
#           is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#               return_true
#       fi
#   else
#       die "interactive substitution \"${alias_name}\" not found in \$PATH"
#   fi

    #ABBREVIATION
    # If a function, throw an exception. While Zsh does behave sensibly when
    # aliasing functions (e.g., "alias rm='rm -i'" behaves non-recursively),
    # interactive aliases are functions rather than aliases. Defining an
    # interactive alias of the same name as an existing function thus
    # silently overwrites such function, which is never helpful. Prohibit!
    # If anything other than a function (e.g., builtin, command),
    # emit a warning and return without redefining such builtin or command.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and
#       is "${alias_name_type}" != 'function' si and {
#       cry "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       return_true
#   }

    # If such alias name is an existing callable, either emit a warning or throw
    # an exception (depending on the type of such callable).
        # Definition of such callable and appropriate error message.
#       string alias_definition error_message
#       alias_definition=""

#FIXME: ${ZESHY_IS_WRAPPING_BUILTINS} is a rather poor name. Globally rename to
#${ZESHY_IS_WRAPPING_BUILTINS_WITH_INTERACTIVE_ALIASES}, please.

    # Alias name type, if the passed alias name is already declared to be an
    # alias, builtin, command, or function.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and {
        #FIXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
        #I suppose not! We don't call eval() in the function definition, and doing so
        #would introduce yet more bizarre edge-casing. Explicitly document why we
        #currently prohibit this. The current logic here suffices, in any case.

        # Die if already declared unless the current user requests wrapping such
        # types with interactive aliases. In particular, replacing a declared
        # Zsh alias or function with an interactive alias is largely senseless;
        # Zsh aliases and functions may always be implemented to account for
        # interactivity (e.g., by calling is_shell_interactive() or interactively()),
        # thus obviating the need for interactive aliases in such cases. Since
        # silently replacing declared Zsh aliases and functions seems an
        # inherently risky (and certainly useless) proposition, disallow it.
#       if   is "${alias_name_type}" == (builtin|reserved) si
#       then is -n "${ZESHY_IS_WRAPPING_BUILTINS-}" si or return_true
#       elif is "${alias_name_type}" == command si
#       then is -n "${ZESHY_IS_WRAPPING_COMMANDS-}" si or return_true
#       else die\
#           "interactive alias \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       fi
#   }

    #FIXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
    #I suppose not! We don't call eval() in the function definition, and doing so
    #would introduce yet more bizarre edge-casing. Explicitly document why we
    #currently prohibit this. The current logic here suffices, in any case.

    #   and functions with interactive aliases is senseless, as the
    #   former may always be implemented to account for
    #   interactivity (e.g., by calling is_shell_interactive() or interactively()),
    #   thus obviating the need for interactive aliases in such cases. Since
    #   silently replacing declared Zsh aliases and functions seems an
    #   inherently risky (and certainly useless) proposition, disallow it.

        #FIXME: Hmm; we can't say whether or not an alias is invalid without
        #expanding it to its expansion and then taking the name of 
    # Non-interactive logic to be performed by the function definition below.
#   if is -n "${alias_expansion_if_non_interactive}" si; then
#       alias_expansion_if_non_interactive+=' "${@}"'
#       alias_logic_if_non_interactive="
#   if is_standard_input_piped
#   then run_with_standard_input_piped ${alias_expansion_if_non_interactive}
#   else ${alias_expansion_if_non_interactive}
#   fi"
#   else alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#   fi

    # Otherwise, such alias name is either an existing Zsh function or has yet
    # to be declared. In the former case, we (optimistically) assume 
#FIXME: In the event of conflict with existing commands or builtins, it'd be
#great to
#FIXME: Excise this everywhere used. Since interactive_alias() now integrates
#such functionality directly, we no longer require this at all.
# bool is_zeshy_wrapping_core_commands(void)
#
# Return true if the current user requests Zeshy wrap interactively run core
# commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#is_zeshy_wrapping_core_commands() {
#    (( # == 0 )) or die 'no arguments expected'
#    [[ -n "${ZESHY_IS_WRAPPING_COMMANDS-}" ]]
#}

    # Die if the passed alias name is already a defined callable.
#   is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
#       die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"
    # Return true if the current user requests Zeshy wrap interactively run core
    # commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#   [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]

    #FIXME: Hmm; disabling the function makes piped calls such as:
    #cat /proc/cpuinfo|cat
    #...fail, which is clearly undesirable.
# void interactive_alias_of_core_command(string alias_specification)
#
# Declare the passed specification as an interactive alias if .
# See interactive_alias() for further details.
#interactive_alias_of_core_command() {
#    is_zeshy_wrapping_core_commands and
#    interactive_alias ls='list_path'
#}

# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.

#   print --\
#       '[[ -p /dev/stdin && ${#} -eq 0 ]] && '\
#       'set -- "${@}" "$(< /dev/stdin)"'"; (( ${1} )) || die"
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
#       "is -p /dev/stdin si and not (( ${1} )) and set -- "\

#       typeset command
#       if [[ -o interactive && \${#funcstack} -eq 1 ]]
#       then command=\"${(q)alias_expansion}\"
#       else command=\"${(q)alias_expansion_if_non_interactive}\"
#       fi
#       if is_standard_input_piped
#       then run_with_standard_input_piped \${command}
#       else                     \${command}
#       fi

#           if is_standard_input_piped
#           then run_with_standard_input_piped ${alias_expansion}
#           else ${alias_expansion}
#           fi
#       then ${alias_expansion}
#       else ${alias_expansion_if_not_interactive}
# bool is_standard_output_terminal(void)
#
# Return true if shell print_string is attached to a terminal device. Specifically,
# return true if the file descriptor for standard print_string is open and attached to
# a terminal. (Avoid testing standard input, as commands passed piped input may
# still be "attached" to a terminal.) Do not implement this as a function, as a
# functions tests theirs rather than their callers' file descriptors.
#alias is_standard_output_terminal='is -t ${ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT} si'

# bool is_terminal_color(void)
#
# Return true if the current shell is attached to a color-aware terminal device
# supporting at least the customary 8 colors (i.e., black, white, red, green,
# blue, yellow, magenta, and cyan).
#alias is_terminal_color='is_standard_output_terminal and (( terminfo[colors] >= 8 ))'

#alias die_unless_no_args=die_if_args

# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FIXME: Reads a bit awkwardly, and superfulous. Supplant everywhere with
#"not is_args".

# void prepend_args(string arg1, string arg2, ...)
#
# Prepend the passed arguments to the beginning of the current argument list.
#alias prepend_args='set_args "${@}"'

# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the "global_alias" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a Zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "map_global_export const set" expands to
#   "proclaim map_global_export const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., map_global, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       cry "\"${command_name}\" not a Zsh builtin or command in \$PATH"
#       return_failure
#   fi

# void interactive_alias_if_installed(string alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#interactive_alias_if_installed() {
#    FIXME: Rewrite. Only call interactive_alias if the passed command is installed.
#    interactive_alias "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FIXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#global_alias equals='-eq'
#global_alias deceeds='-lt'
#global_alias deceeds_or_equals='-le'
#global_alias exceeds='-gt'
#global_alias exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   list_global_export two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#global_alias const='-r'
