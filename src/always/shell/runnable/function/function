#!/usr/bin/env zsh
# ====================[ function                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Inspect function names, definitions, and related metadata.

# ....................{ TESTS                              }....................
# boolean is_function(string function_name)
#
# Return true if a function with the passed name exists.
function is_function() {
    die_unless_one_arg 'expected one function name'
    run_quietly typeset -f -- "${1}"
}

# ....................{ GETTERS                            }....................
# string get_functions_matching(string glob)
#
# Get all function names matching the passed glob, delimited by newlines: e.g.,
#
#     >>> get_functions_matching 'get_z*s*h*_version'
#     get_zeshy_version
#     get_zsh_version
function get_functions_matching() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one glob'

    # Match such glob. Dismantled, this is:
    #
    # * "-fm", matching only function names (rather than all "object" names).
    # * "+", printing only function names (rather than function definitions).
    typeset -fm '+' -- "${1}"
}

# ....................{ SETTERS                            }....................
# void set_list_to_function_names_matching(string list_name, string glob)
#
# Set the passed list to all function names matching the passed glob: e.g.,
#
#     >>> list function_names
#     >>> set_list_to_function_names_matching function_names 'test_z[aeou]shy'
#     >>> output ${function_names[1]}
#     test_zeshy
function set_list_to_function_names_matching() {
    # Validate passed arguments.
    die_unless_two_args 'expected one list name and one glob'
    string list_name="${1}" __glob__="${2}" function_names
    die_unless_list "${list_name}"

    # Match such glob.
    function_names="$(get_functions_matching "${__glob__}")"
    set_list_to_string_lines "${list_name}" "${function_names}"
}

# ....................{ NAMESPACES                         }....................
# void disable_function(string function_name1, string function_name2, ...)
#
# Globally disable the function with the passed name. This function remains
# defined but uncallable until reenabled with a call to enable_function().
function disable_function() {
    die_unless_args 'expected at least one function name'
    disable -f -- "${@}"
}

# void enable_function(string function_name)
#
# Globally re-enable the function with the passed name, presumably previously
# disabled with a call to disable_function().
function enable_function() {
    die_unless_args 'expected at least one function name'
    enable -f -- "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#   is "$(whence -w -- "${1}")" == *': function' si

# ....................{ GETTERS                            }....................
# string list_functions(void)
#
# List all currently declared Zsh function names delimited by newlines.
#list_functions() {
#    die_if_args
#    typeset -f +   # yes, this is mind-numbingly crazy
#}

# string output(int number)
#
# Return the passed integer from the current function.
#output() {
#    die_unless_one_arg 'expected one integer'
#    print -- "${1}"
#}

# string output(string text1, string text2, ...)
#
# Return the concatenation of the passed strings from the current function.
#output() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}
