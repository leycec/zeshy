#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Shell, handling core shell functionality: e.g.,
#
# * Command-line argument parsing fuctionality for specifying and obtaining
#   shell script arguments.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_interactive(char *error_message = 'not interactive')
#
# Raise an exception unless the current shell is interactive.
die_unless_interactive() {
    die_unless_at_most_one_arg 'expected optional error message'
    is_interactive or die "${1:-current shell not interactive}"
}

# ....................{ CALLABLES                          }....................
#FIXME: Also destroy all Zeshy-specific globals excluding "ZESHY_HOME".
# void undefine_callables_matching(string pattern = '*')
#
# Destroy all existing aliases and functions matching the passed pattern
# (defaulting to '*', implying all callables). This is, of course, fairly
# destructive but does guard against desynchronization issues resulting from
# modification to this Zeshy installation (e.g., when upgrading).
undefine_callables_matching() {
    die_unless_at_most_one_arg 'expected at most one pattern'
    string pattern="${1:-*}"
    unalias    -m "${pattern}"
    unfunction -m "${pattern}"
}

# ....................{ ARGUMENTS                          }....................
#FIXME: This no longer works as intended, due to TRAPZERR(). Contemplate. Ah.
#Yes. The simple solution is to require the parse_args() alias to feed into
#this command: e.g.,
#
#   parse_args d e -ad -crest: -wing:: | check_args_with_help_string 'Help!'
#
#Bit awkward, but nothing too onerous. Alternatively, couldn't we define the
#parse_args() alias to simply temporarily disable TRAPZERR() by.... hmm; I
#don't believe the disable() builtin accepts a command to be run, unfortunately.

# void check_args_with_help_string(char *help_message)
#
# Check the set of all parsed arguments for unknown options. If the caller
# passed at least one unknown option OR the "-h" or "--help" options, die with
# the passed help message. This function expects to be called immediately after
# calling the parse_args() function.
check_args_with_help_string() {
    # If the immediately prior command failed, assume that was a call to the
    # parse_args() function and enable a boolean noting this fact.
    is_ok and bool is_parse_args_failed=1

    # Localize passed arguments.
    die_unless_one_arg 'expected one help string'
    string help_message="${1}"

    # If the caller passed the "-h" or "--help" options, die without error.
    if (( "${+ARGS[-h]}" + "${+ARGS[--help]}" )); then
        sputter "${help_message}"
        exit_with_success
    # If the caller passed unknown options, die without error.
    elif (( "${+is_parse_args_failed}" )); then
        sputter "${help_message}"
        exit_with_failure
    fi
}

# ....................{ SCRIPTS                            }....................
# char *source_safely(
#   char *script_filename, char *script_arg1, char *script_arg2, ...)
#
# Safely source the passed shell script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than Zsh shell environment).
source_safely() {
    die_unless_args 'expected at least one filename'

    # Localize and validate arguments. If the passed filename is not absolute,
    # resolve its absolute path by iteratively searching the current working
    # directory, "${PATH}", and "${FPATH}" (in that order).
#   utter "passed: ${@}"
    string shell='zsh' emulatable_shells='zsh|sh|ksh|csh' filename filetype
    filename="$(get_script_path "${1}")"
    filetype="$(get_filetype_if_found "${filename}")"
#   utter "filename: ${filename}"
#   utter "filetype: ${filetype}"

    # Identify the shell to be emulated. If the passed filename's type
    # identifies an emulatable shell, assume that.
    if is "${filetype}" == ${~emulatable_shells} si; then
        shell="${filetype}"
    # Otherwise, attempt to match the passed file's first line for a shebang
    # referencing an emulatable shell. When no such match, default to "zsh".
    else
        string shebang_regex="^#.*[/ ](${emulatable_shells})($| )" shebang_line

        #FIXME: Insufficient. Search, say, the first eight lines for a shebang.
        #This suggests a call pipeline resembling:
        #  shebang_line="$(get_text_file_line_matching_pcre "$(get_text_file_lines "${filename}" 1 8)" "${shebang_regex}")"
        shebang_line="$(get_text_file_first_line "${filename}")"
        is_pcre_match "${shebang_line}" "${shebang_regex}" and
            shell="${match[1]}"
#       sputter "shebang_line: ${shebang_line}"
#       sputter "shell=${shell}"
    fi

    # Safely source the passed shell script. Dismantled, this is:
    #
    # * "-L", localizing the redefinition of TRAPZERR() to this function call.
    # * "-R", resetting shell options to the default expected by such shell.
    # * "TRAPZERR()", disabling exception raising on command and function
    #   failure. (External scripts except no such exceptions, by default.)
    # 
    # Do not redefine TRAPINT(), since printing stack traces on user interrupts
    # is universally useful and not conflicting with script expectations.
    {
#       utter "sourcing \"${@}\" under ${shell} emulation..."
        emulate -LR "${shell}"
        TRAPZERR() { return $(( 128 + ${1} )) }
        PATH="${PATH}:${FPATH}" source "${@}"
    }

    #FIXME: Hmm; this appears to be fixed under zsh 5.0.0. Nice, boys!
    # Interestingly, Zsh fails to signal ZERR when the sourced script fails with
    # non-zero exit status. Let's signal ZERR ourselves, shall we?
    integer exit_status=${?}
    (( exit_status == ZESHY_SUCCESS_CODE )) or
        die "\"${@}\" failed with exit status ${exit_status}"
}

# char *source_safely_command_output(
#   char *shell_name,
#   char *command_name, char *command_arg1, char *command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
source_safely_command_output() {
    # Localize and validate arguments.
    die_unless_at_least_two_args\
        'expected at least one shell name and one command name'
    string shell_name="${1}"
    shift_one_arg
    is "${shell_name}" == (zsh|sh|ksh|csh) si or
        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_installed "${command_name}"

    # Source safely.
    emulate -R "${shell_name}" -c "eval \$(${@})"
}

# ....................{ RELOADING                          }....................
# void reload_shell(void)
#
# Resource all Zsh startup scripts in the same order Zsh sources these scripts
# on initial login for the current user. This function is of principal use for
# Zeshy developers (making frequent changes to Zeshy itself) as well as Zsh
# dot-file hackers (making frequent changes to Zsh dot-files).
reload_shell() {
    die_if_args

    # Undefine all existing aliases and functions, thus forcing Zeshy to
    # reinitialize itself if re-sourced below.
    undefine_callables_matching

    # Source startup control scripts in the default Zsh order.
    for script_file (
        '/etc/zsh/zprofile'
        "${HOME}/.zprofile"
        '/etc/zsh/zshrc'
        "${HOME}/.zshrc"
        '/etc/zsh/zlogin'
        "${HOME}/.zlogin"
    ) {
        [[ -f "${script_file}" && -r "${script_file}" ]] &&
            source "${script_file}"
    }

    # Force successful exit status. The prior loop appears to occasionally set
    # error exit status despite succeeding, which lacking the following command
    # then returns such error from this function.
    return_true
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ RETURN VALUES                      }....................
# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FIXME: Call everywhere we currently call print() and sputter().

# char *sputter(int number)
#
# Return the passed integer from the current function.
#sputter() {
#    die_unless_one_arg 'expected one integer'
#    print -- "${1}"
#}

# char *sputter(char *string1, char *string2, ...)
#
# Return the concatenation of the passed strings from the current function.
#sputter() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}

    #FIXME: Extract out 'zsh|sh|ksh|csh' into a "get_emulatable_sh
#   string ZESHY_SCRIPT_NAME='redot'
#   false
#   TRAPZERR() {
#       # Save the return code of the prior command prior to overwriting this code
#       # by printing a stack trace.
#       typeset -i exit_status=${?}
#       print_stack_trace

#       # Terminate the current shell, returning the non-zero exit status of the prior
#       # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
#       # terminating the current shell on SIGZERR signals).
#       die_with ${exit_status}
#   }
#   false
#   source "${ZESHY_OVERLAY_ROOT}/main"
#   false
#   utter "sourced as ${script_shell}: ${@}"

#   # void source_if_found(char *filename)
#   #
#   # Source the passed filename if found and readable by the current user. Note
#   # this function definition calls no Zeshy-specific aliases or functions; the
#   # the above call to the undefine_callables() function has already killed them.
#   source_if_found() {
#       local script_name="${1}"
#       if [[ -f "${script_name}" && -r "${script_name}" ]]; then
#           print "redot: loading \"${script_name}\"..."
#           source "${script_name}"
#       fi
#   }

#   utter "reloading zeshy..."
#   utter "reloading user ${USER}..."
#
    # Force reimportation of all Zeshy components. Then, as the importations
    # below redefine all defined callables, destroy all such callables to
    # avoid desynchronization issues.
    #
    # Do this prior to calling the utter() function for obvious reasons.
#   _zeshy_initialize_imports
#   undefine_callables

#   die_unless_file "${script_filename}"
# elif is_file "${script_filename}"; then
#       match_first_group "${script_shebang_regex}" "${script_shebang}"

#
# * "-c", run the following command under such emulation.
#interactive_alias_if_installed au='aouauauauau'

#This is a no-op if the
# builtin or command to be aliased does not exist.
#
#   print "shell: ${script_shell}"
#   emulate -R ${script_shell} -c "ls"
#   emulate -R ${script_shell} -c "${@}"
#   emulate -LR "${script_shell}"
#   source ${@}

    # Disable shell strictness for the duration of the sourcing. External shell
    # scripts often assume laxness thus breaking under strictness.
#   setopt nounset            # attempting to expand unset parameters raises an error
#   setopt warn_create_global # attempting to set untyped parameters raises an error
 
    # Reenable shell strictness. 

#   of $(whence -w "${1}") =~ ': alias$' fo

#   if [[ "${type}" == none ]]; then
#       echo "not-found"
#   else
#   is "${variable_type}" or die "\"${1}\" not a variable"
#   if not is_array array; then local -A array; fi;
#   local array_name="${1:-array}"
#   die_unless_is_array "${array_name}"
#   echo "${(qqkv@P)array_name}"

#FIXME: Rename.
#alias Return_array='eval return_array'
#alias Obtain_array='eval obtain_array'
#alias Return_array='eval "$(return_array array)"'
#alias expand_stray_to_array='eval "$(obtain_array array ${stray})"'
#alias Obtain_array_from_command='eval "$(obtain_array array $(command))"'

    #FIXME: Die if return code is failure?
#   local command="${@}"
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"

#   echo "${${(qqkv@P)array_name}[@]}"
#   echo "${${(@qqkvP)array_name}[@]}"
#   "echo \"${${(@qqkvP)array_name}[@]}\""
#   echo "echo \"${${(@qqkvP)array_name}[@]}\""   # ; return_true"

#   echo "string_array=${@}"
#   echo "${array_name}="'"'"${(z)@}"'"'
#   echo "${array_name}=( ${(Q)${(z)@}} )"
#   echo "${array_name}=( \"${(Q@)${(z)string_array}}\" )"
#   echo "${array_name}=( ${(Q@)${(z)string_array}} )"
#   echo "${array_name}=( "${(Q@)${(z)@}}" )"

#obtain_array_from_command() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_args 'expected one array name and one runnable command'
#    local array_name="${1}"; shift
#    local command="${@}"
#
#    echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#
#    #FIXME: Die if return code is failure?
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#   echo "${array_name}=( ${(z)string_array} )"
#}

#oa() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_args 'expected one array name and one stringified array'
#    local string_array="${@}"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#    echo "${array_name}=( ${(z)string_array} )"
#}

    # * '@' splits the array of such words into (still quote-protected!) words.
    # * 'Q' strips the single quotes protectively added by the prior 'qq' flag.
    # * The second '@' refers to the passed 
# ....................{ PASS-BY-VALUE                      }....................
#FIXME: Document!
#return_value() {
#   [[ ${#} -ge 1 ]] || die 'expected at least one value'
#   echo "echo \"${@}\"; return ${ZESHY_SUCCESS_CODE}"
#}

# void PATH_append_if_root(char *pathname)
#
# Add the passed pathname to this user's "$PATH", if the above conditions hold
# and if this user is the superuser (i.e., root).
#PATH_append_if_root() {
#    is_superuser && PATH_append "${@}"
#}

# void redit(void)
#redit() {
#  if [ "$USER" = "root" ]
#  then sudo $EDITOR /etc/zsh/zshrc
#  else      $EDITOR $HOME/.zshrc
#  fi
#
#  redot
#}
