#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle core shell functionality.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_shell_interactive(
#   string error_message = 'shell not interactive')
#
# Raise an exception unless the current shell is interactive.
function die_unless_shell_interactive() {
    die_unless_no_or_one_arg 'expected optional error message'
    is_shell_interactive or die "${1:-shell not interactive}"
}

# ....................{ TESTERS                            }....................
#FIXME: Shift to new "option" file in this directory.
# void die_unless_shell_option(
#   string option_name,
#   string error_message = "\"${option_name}\" not a shell option")
#
# Raise an exception unless the current shell is interactive.
function die_unless_shell_option() {
    die_unless_one_or_two_args\
        'expected one option name and optional error message'
    string option_name="${1}"
    is_shell_option "${option_name}" or\
        die "${2:-\"${option_name}\" not a shell option}"
}

# boolean is_shell_option(string option_name)
#
# Return true if Zsh supports the passed option. See "man zshoptions" for a list
# of such options: e.g.,
#
#     >>> is_shell_option unpriveleged or output 'Welcome, bourgeoisie.'
#     Welcome, bourgeoisie.
function is_shell_option() {
    #FIXME: Doesn't work. Best way appears to be capturing the output of a test
    #resembling "$(is -o "${option_name}" si)" for an error message resembling:
    #   zsh: no such option: oeuoeuo
    # Dismantled, this is:
    #
    # * "set +o", printing the passed option name if such option exists or
    #   returning false.
    # * "run_quietly", hiding such output while retaining such return status.
    die_unless_one_arg 'expected one option name'
#   run_quietly set +o "${1}"
}

# boolean is_shell_option_enabled(string option_name)
#
# Return true if the current shell enables the passed option. See
# "man zshoptions" for a list of such options: e.g.,
#
#     >>> is_shell_option_enabled priveleged or
#     ...     output 'Welcome to the proletariat.'
#     Welcome to the proletariat.
function is_shell_option_enabled() {
    die_unless_one_arg 'expected one option name'
    string option_name="${1}"
    die_unless_shell_option "${option_name}"
    is -o "${option_name}" si
}

# boolean is_shell_interactive(void)
#
# Return true if the current shell is attached to a terminal device and
# interactively reading commands from standard input.
function is_shell_interactive() {
    die_if_args
    is_shell_option_enabled interactive
}

# ....................{ ARGUMENTS                          }....................
#FIXME: This no longer works as intended, due to TRAPZERR(). Contemplate. Ah.
#Yes. The simple solution is to require the parse_args() alias to feed into
#this command: e.g.,
#
#   parse_args d e -ad -crest: -wing:: | check_args_with_help_string 'Help!'
#
#Bit awkward, but nothing too onerous. Alternatively, couldn't we define the
#parse_args() alias to simply temporarily disable TRAPZERR() by.... hmm; I
#don't believe the disable() builtin accepts a command to be run, unfortunately.

# void check_args_with_help_string(string help_message)
#
# Check the set of all parsed arguments for unknown options. If the caller
# passed at least one unknown option OR the "-h" or "--help" options, die with
# the passed help message. This function expects to be called immediately after
# calling the parse_args() function.
function check_args_with_help_string() {
    # If the immediately prior command failed, assume that was a call to the
    # parse_args() function and enable a boolean noting this fact.
    is_ok and bool is_parse_args_failed=1

    # Localize passed arguments.
    die_unless_one_arg 'expected one help string'
    string help_message="${1}"

    # If the caller passed the "-h" or "--help" options, die without error.
    if (( "${+ARGS[-h]}" + "${+ARGS[--help]}" )); then
        output "${help_message}"
        exit_with_success
    # If the caller passed unknown options, die without error.
    elif (( "${+is_parse_args_failed}" )); then
        output "${help_message}"
        exit_with_failure
    fi
}

#FIXME: This is blithering nonsense, frankly. We're never likely to call this!
# string quote_protect(string arg1, string arg2, ...)
#
# Quote protect the passed arguments into a concatenated string escaping all
# shell-reserved characters in such arguments: e.g.,
#
#     >>> quote_protect '(Three Rings)' '[for the]' '{Elven-kings}'
#     \(Three\ Rings\) \[for\ the\] \{Elven-kings\}
function quote_protect() {
    die_unless_args 'expected at least one argument'
    output "${(q)@}"
}

# ....................{ RELOADING                          }....................
# void reload_shell(void)
#
# Resource all Zsh startup scripts in the same order Zsh sources these scripts
# on initial login for the current user. This function is of principal use for
# Zeshy developers (making frequent changes to Zeshy itself) as well as Zsh
# dot-file hackers (making frequent changes to Zsh dot-files).
function reload_shell() {
    # Validate sanity.
    die_if_args

    #FIXME: Doesn't really work, since we're not in a global context. *sigh*
    # Undefine all variables. For clear reasons, call this function prior to
    # undefining all functions.
#   undefine_globals_matching 'ZESHY_*'

    #FIXME: Poor name. How about undefine_runnables_matching()?
    # Undefine all aliases and functions, thus inducing Zeshy to reload itself
    # if sourced by a conventional Zsh startup script sourced below.
    undefine_runnables_matching '*'

    # Revert to default Zsh options, as customarily expected by startup scripts.
    emulate -LR zsh

    # Source startup scripts in the customary Zsh order.
    for script_file (
        '/etc/zsh/zprofile'
        "${HOME}/.zprofile"
        '/etc/zsh/zshrc'
        "${HOME}/.zshrc"
        '/etc/zsh/zlogin'
        "${HOME}/.zlogin"
    ) {
        [[ -f "${script_file}" ]] && source -- "${script_file}"
    }

    # Force successful exit status. The prior loop appears to occasionally set
    # error exit status despite succeeding, which lacking the following command
    # then returns such error from this function.
    return_true
}

# --------------------( WASTELANDS                         )--------------------
    #FIXME: Perhaps define a new is_shell_option() function.
#   is -o interactive si
    #FIXME: This appears to fail for read-only variables. Hack around this by
    #forcefully disabling the read-only flag for all matching variables. *shrug*
# (defaulting to '*', implying all runnables). This is, of course, fairly
# destructive but does guard against desynchronization issues resulting from
# modification to this Zeshy installation (e.g., when upgrading).
#FIXME: Also destroy all Zeshy-specific globals excluding "ZESHY_HOME".
#&& -r "${script_file}"
# * Command-line argument parsing fuctionality for specifying and obtaining
#   shell script arguments.
#   (( # == 0 )) || die 'expected no arguments'
#   [[ -o interactive ]]
# ....................{ RETURN VALUES                      }....................
# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FIXME: Call everywhere we currently call print() and output().

# string output(int number)
#
# Return the passed integer from the current function.
#output() {
#    die_unless_one_arg 'expected one integer'
#    print -- "${1}"
#}

# string output(string text1, string text2, ...)
#
# Return the concatenation of the passed strings from the current function.
#output() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}

    #FIXME: Extract out 'zsh|sh|ksh|csh' into a "get_emulatable_sh
#   string ZESHY_SCRIPT_NAME='redot'
#   false
#   TRAPZERR() {
#       # Save the return code of the prior command prior to overwriting this code
#       # by printing a stack trace.
#       typeset -i exit_status=${?}
#       print_call_stack

#       # Terminate the current shell, returning the non-zero exit status of the prior
#       # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
#       # terminating the current shell on SIGZERR signals).
#       die_with ${exit_status}
#   }
#   false
#   source "${ZESHY_OVERLAY_ROOT}/main"
#   false
#   say "sourced as ${script_shell}: ${@}"

#   # void source_if_found(string filename)
#   #
#   # Source the passed filename if found and readable by the current user. Note
#   # this function definition calls no Zeshy-specific aliases or functions; the
#   # the above call to the undefine_runnables() function has already killed them.
#   source_if_found() {
#       local script_name="${1}"
#       if [[ -f "${script_name}" && -r "${script_name}" ]]; then
#           print "redot: loading \"${script_name}\"..."
#           source "${script_name}"
#       fi
#   }

#   say "reloading zeshy..."
#   say "reloading user ${USER}..."
#
    # Force reimportation of all Zeshy components. Then, as the importations
    # below redefine all defined runnables, destroy all such runnables to
    # avoid desynchronization issues.
    #
    # Do this prior to calling the say() function for obvious reasons.
#   _zeshy_initialize_imports
#   undefine_runnables

#   die_unless_file "${script_filename}"
# elif is_file "${script_filename}"; then
#       match_first_group "${script_shebang_regex}" "${script_shebang}"

#
# * "-c", run the following command under such emulation.
#interactive_alias_if_installed au='aouauauauau'

#This is a no-op if the
# builtin or command to be aliased does not exist.
#
#   print "shell: ${script_shell}"
#   emulate -R ${script_shell} -c "ls"
#   emulate -R ${script_shell} -c "${@}"
#   emulate -LR "${script_shell}"
#   source ${@}

    # Disable shell strictness for the duration of the sourcing. External shell
    # scripts often assume laxness thus breaking under strictness.
#   setopt nounset            # attempting to expand unset parameters raises an error
#   setopt warn_create_global # attempting to set untyped parameters raises an error
 
    # Reenable shell strictness. 

#   of $(whence -w "${1}") =~ ': alias$' fo

#   if [[ "${type}" == none ]]; then
#       echo "not-found"
#   else
#   is "${variable_type}" or die "\"${1}\" not a variable"
#   if not is_array array; then local -A array; fi;
#   local array_name="${1:-array}"
#   die_unless_is_array "${array_name}"
#   echo "${(qqkv@P)array_name}"

#FIXME: Rename.
#alias Return_array='eval return_array'
#alias Obtain_array='eval obtain_array'
#alias Return_array='eval "$(return_array array)"'
#alias expand_stray_to_array='eval "$(obtain_array array ${stray})"'
#alias Obtain_array_from_command='eval "$(obtain_array array $(command))"'

    #FIXME: Die if return code is failure?
#   local command="${@}"
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"

#   echo "${${(qqkv@P)array_name}[@]}"
#   echo "${${(@qqkvP)array_name}[@]}"
#   "echo \"${${(@qqkvP)array_name}[@]}\""
#   echo "echo \"${${(@qqkvP)array_name}[@]}\""   # ; return_true"

#   echo "string_array=${@}"
#   echo "${array_name}="'"'"${(z)@}"'"'
#   echo "${array_name}=( ${(Q)${(z)@}} )"
#   echo "${array_name}=( \"${(Q@)${(z)string_array}}\" )"
#   echo "${array_name}=( ${(Q@)${(z)string_array}} )"
#   echo "${array_name}=( "${(Q@)${(z)@}}" )"

#obtain_array_from_command() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_args 'expected one array name and one runnable command'
#    local array_name="${1}"; shift
#    local command="${@}"
#
#    echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#
#    #FIXME: Die if return code is failure?
#   echo "local _zeshy_obtained_array_as_scalar=\$(${command}); "
#   echo "${array_name}=( "${(Q@)${(z)_zeshy_obtained_array_as_scalar}}" ); "
#   echo "unset _zeshy_obtained_array_as_scalar"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#   echo "${array_name}=( ${(z)string_array} )"
#}

#oa() {
#    #FIXME: Test to make sure the passed array name actually is. How?
#    die_unless_at_least_two_args 'expected one array name and one stringified array'
#    local string_array="${@}"
#
#    # Let's dismantle this, one to two parameter expansion flags at a time:
#    # * 'z' splits the passed string into a numeric array of words.
#    echo "${array_name}=( ${(z)string_array} )"
#}

    # * '@' splits the array of such words into (still quote-protected!) words.
    # * 'Q' strips the single quotes protectively added by the prior 'qq' flag.
    # * The second '@' refers to the passed 
# ....................{ PASS-BY-VALUE                      }....................
#FIXME: Document!
#return_value() {
#   [[ ${#} -ge 1 ]] || die 'expected at least one value'
#   echo "echo \"${@}\"; return ${ZESHY_EXIT_STATUS_SUCCESS}"
#}

# void PATH_append_if_root(string pathname)
#
# Add the passed pathname to this user's "$PATH", if the above conditions hold
# and if this user is the superuser (i.e., root).
#PATH_append_if_root() {
#    is_superuser && PATH_append "${@}"
#}

# void redit(void)
#redit() {
#  if [ "$USER" = "root" ]
#  then sudo $EDITOR /etc/zsh/zshrc
#  else      $EDITOR $HOME/.zshrc
#  fi
#
#  redot
#}
