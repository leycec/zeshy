#!/usr/bin/env zsh
# ====================[ run                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Run, handling command, builtin, and function execution.
#
# --------------------( TODO                               )--------------------
# * Document the fact that non-shell-reserved arguments passed to run()
#   should *ALWAYS* be quote-protected by the caller with "${(q)@}". I believe
#   we've already penned relevant documentation in the WASTELANDS, so just restore.
#   Also note that if the caller fails to quote-protect such arguments, this
#   function silently attempts to quote-protect such arguments on the caller's
#   behalf -- and usually, but not always, succeeds.
#   Actually, that's no longer how it works: we *ALWAYS* force one level of quote
#   protection if passed multiple arguments and none otherwise. Much less error
#   prone, and implies that passing only one argument is ideal (since that affords
#   the caller total control over quote protection).

# ....................{ EXCEPTIONS                         }....................
# void die_unless_runnable(
#   string name, string error_message = 'not runnable')
#
# Throw an exception unless a runnable (i.e., external command, Zsh alias,
# Zsh builtin, or Zsh function) with the passed name exists.
function die_unless_runnable() {
    die_unless_one_or_two_args\
        'expected one object name and optional error message'
    string name="${1}"
    is_runnable "${name}" or die "${2:-\"${name}\" not runnable}"
}

# ....................{ TESTS                              }....................
# bool is_runnable(string name)
#
# Return true if a runnable with the passed name exists.
function is_runnable() {
    die_unless_one_arg 'expected one name'
    run_quietly whence -- "${1}"
}

# ....................{ RUNNERS                            }....................
# string run(string command) --OR--
# string run(string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed strings concatenated as a single command. Technically, Zsh
# already runs strings as commands when in command position (i.e., when the
# first shell word of a command line): e.g.,
#
#     # Print the login message. Happily, this works as expected.
#     >>> list command_line; command_line=( cat /dev/issue )
#     >>> "${command_line[@]}"
#     Caution, feeble entity. You are entering \n.\O (\s \m \r) \t.
#
# Sadly, such execution fails on strings containing shell-reserved characters
# (e.g., "|", "<", ">"): e.g.,
#
#     # Print the first 16 characters of the login message. Unhappily, this does
#     # not work as expected. (Unless you correctly expected it to fail. Which
#     # it does -- in spades.)
#     >>> list command_line; command_line=( cat /etc/issue \| cut -c 1,16 )
#     >>> "${command_line[@]}"
#     cat: |: No such file or directory
#     cat: cut: No such file or directory
#
# This function amends such behavior by correctly running all strings as
# commands regardless of shell-reserved content: e.g.,
#
#     # Print the first 16 characters of the login message. Aaaand we have worky.
#     >>> list command_line; command_line=( cat /etc/issue \| cut -c 1,16 )
#     >>> run "${command_line[@]}"
#     Caution, feeble
#
# This function takes two seemingly similar but substantially different forms:
#
# * If passed one argument, this function evaluates such argument as the entire
#   command to be run. This requires the caller explicitly construct the entire
#   command line, including quote protection of command arguments containing
#   shell-reserved characters: e.g.,
#
#     # Run the entropic random number generator until generating a string
#     # containing shell-reserved characters.
#     >>> string command_line
#     >>> command_line="cat /dev/random \| grep -E '\{Eschaton Entombed\(\)\}'"
#     >>> run "${command_line}"
#     {Eschaton Entombed()}                   # it could happen...
#
#   This form preserves quote protection and hence is generally safer than the
#   next form, which silently strips one level of such protection. However,
#   this form is subject to a subtle caveat: when passing a single argument
#   interpolating a list, expand list elements with "${*}" rather than "${@}".
#   The former expands list elements in place; the latter appends all list
#   elements following the first as discrete arguments to this function: e.g.,
#
#     # Doubleplusungood. This is equivalent to:
#     #     run "dd | pv -t" "if=/dev/null" "of=/dev/sda"
#     >>> set_args dd if=/dev/null of=/dev/sda
#     >>> run "${@} | pv -t"       # you probably don't want to run this
#
#     # Ohsonice. This never does the wrong thing. (But you'll wish it did...)
#     >>> set_args dd if=/dev/null of=/dev/sda
#     >>> run "${*} | pv -t"       # you *REALLY* don't want to run this
#
# * If passed multiple arguments, this function evaluates the concatenation of
#   such arguments as the command to be run. This implicitly constructs the
#   command line on behalf of the caller (which is nice), but requires the
#   caller explicitly quote protect command arguments containing shell-reserved
#   characters (which is horrible): e.g.,
#
#     # Run the same command. Unhappily, this crashes and burns piquantly. Why?
#     # Because run() internally calls "eval" which silently strips one level
#     # of quote protection from the argument to "grep".
#     >>> list command_line
#     >>> command_line=( cat /dev/random \| grep -E '\{Eschaton Entombed\(\)\}' )
#     >>> run "${command_line[@]}"
#     grep: Entombed()}: No such file or directory
#
#     # Run the same command, explicitly quote protecting the argument to "grep".
#     # Happily, it works. Unhappily, it's user friendliness is.... questionable.
#     >>> list command_line
#     >>> command_line=( cat /dev/random \| grep -E ${(q):-\{Eschaton Entombed\(\)\}} )
#     >>> run "${command_line[@]}"
#     {Eschaton Entombed()}                   # it could happen... but will it?
#
# In either case, avoid passing commands that when run recursively call this
# function or the equivalent "eval" builtin. Each such call strips one level of
# quote protection, ultimately resulting in jaberwocky-style gibberish. To
# protect against such errors, this function avoids evaluating commands that
# either directly run "run" (i.e., this function) or functions prefixed with
# "run_" (e.g., "run_quietly", a function internally calling this function).
#
# tl;dr
# -----
# If passing a single argument, *NEVER INTERPOLATE "${@}" INTO SUCH ARGUMENT*.
# If passing multiple arguments, *ALWAYS QUOTE PROTECT PASSED ARGUMENTS WITH
# PARAMETER EXPANSION MODIFIER "(q)"*.
function run() {
    # Validate passed arguments.
    die_unless_args 'expected one command'

    # If piped input, pipe such input to the command to be run.
    is_piped_input and set_args -- run_with_piped_input "${@}"

    # If passed one argument, evaluate as is. Clearly, this is the ideal case.
    is_one_arg and {
#       sputter "run (single-arg eval): ${1}..."
        eval "${1}"
        return_true
    }

    # If the argument in command position is either this function name or a
    # "run_"-prefixed function name, assume such argument to be a call to a
    # Zeshy-specific function recursively calling this function. In such case,
    # do *NOT* "eval" such command as the recursive call to this function will
    # do so already. Since each "eval" strips one level of quotes from such
    # command, running such command as is avoids stripping quote protection.
    string command_name; command_name="$(get_command_line_name "${@}")"
    is "${command_name}" == run(|_?*) si and {
#       sputter "run (direct): ${@}... (last arg: ${@[-1]})"
        "${@}"
        return_true
    }

    # Otherwise, passed multiple arguments that *HOPEFULLY* run no command
    # internally calling either this function or the "eval" builtin.
    #
    # This branch previously conditionally quote protected all unescaped shell-
    # reserved characters in such arguments, thus handling arguments the caller
    # neglected to explicitly quote protect with "(q)". Unfortunately, such
    # cleverness was entirely too clever, munging Zsh statements like:
    #
    #       run "print $(ls /tmp)"
    #
    # Hence, we have elected to do nothing whatsoever, requiring the caller
    # quote protect user-passed arguments with "(q)".
    #
    # You have now entered the Clusterfuck Zone.
#   sputter "run (multiple-arg eval): ${args[@]}... (last arg: ${@[-1]})"
    eval "${@}"
}

# string run_if_runnable(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command if runnable (e.g., in the current ${PATH}).
function run_if_runnable() {
    die_unless_args 'expected one command'
    string command_name; command_name="$(get_command_line_name "${@}")"
    is_runnable "${command_name}" and run "${@}"
}

# ....................{ RUNNERS ~ output                   }....................
# void run_quietly_as(
#   string username,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command as the passed user quietly (i.e., squelching output).
function run_quietly_as() {
    run_as "${@}" &>/dev/null
}

# void run_quietly(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command quietly (i.e., squelching output).
function run_quietly() {
    run "${@}" &>/dev/null
}

# string run_with_unified_output(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command with standard error redirected to standard output, thus
# "unifying" all command output to standard output.
function run_with_unified_output() {
    run "${@}" 2>&1
}

# ....................{ RUNNERS ~ background               }....................
# void run_backgrounded(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command in the background.
function run_backgrounded() {
    run "${@}" &
}

# void run_disowned(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command disowned from the current shell and hence:
#
# * Not listed in the jobs table and hence "jobs" output.
# * Not receiving the HUP signal and hence terminating on termination of the
#   current shell.
function run_disowned() {
    # For safety, run disowned commands in new subshells. While negligibly
    # expensive, this avoids subtle termination issues associated with process
    # substitution of temporary files: e.g.,
    #
    #     # Hideous. This captures 64 random strings into a temporary file and
    #     # prints such file as a disowned job. What now? Let me tell you what
    #     # now. No shell owns such job and hence deletes such file after job
    #     # completion, resulting in gradual file accumulation.
    #     run cat =(head -64 /dev/urandom) &!
    #
    #     # Beautiful. This performs the same task in a new subshell as a
    #     # disowned job. While disowned, some subshell owns such job and hence
    #     # deletes such file after job completion.
    #     (run cat =(head -64 /dev/urandom)) &!
    (run "${@}") &!
}

# ....................{ RUNNERS ~ options                  }....................
# string run_with_options(
#   string command_prefix,
#   string list_options_name,
#   string command_arg1, string command_arg2, ...)
#
# Run the passed command with the passed options and arguments. Unlike most
# functions in the run*() family, this function requires the passed command be a
# single string. This function creates the command line to be run as follows:
#
# * Begin with the passed command.
# * Append the contents of the list with the passed name.
# * If interactive, append the contents of the list with name
#   "${list_options_name}_IF_INTERACTIVE"; otherwise, of the list with name
#   "${list_options_name}_IF_NON_INTERACTIVE".
# * Append "--", treating subsequent command arguments as non-options. This
#   precaution prevents treating option-like arguments as options (e.g., if a
#   file "-l" exists, "ls -- -l" lists that file while "ls -l" does not).
# * Append the passed command arguments. This completes the command line.
# * If this function was called with piped input, pipe such input to the command
#   line; otherwise, run the command line as is.
function run_with_options() {
    # Validate passed arguments.
    die_unless_at_least_two_args\
        'expected one command prefix, one list name, and optional command arguments'
    string\
        command_line_prefix="${1}"\
        options_list_name="${2}" interactive_options_list_name
    list command_line
    shift_two_args

    # Validate passed arguments, uppercasing the desired interactive list name
    # regardless of the original case of the passed list name.
    is_interactive and
        interactive_options_list_name="${(U)options_list_name}_IF_INTERACTIVE" or
        interactive_options_list_name="${(U)options_list_name}_IF_NON_INTERACTIVE"
    die_unless_list "${options_list_name}"
    die_unless_list "${interactive_options_list_name}"

    # If passed piped input, propagate such input to the desired command.
    is_piped_input and command_line=( cat '/dev/stdin' \| )

    # Dismantled, this is:
    #
    # * "(z)", splitting the passed command prefix into shell words.
    # * "(@P)", expanding the passed list name into the shell words of the
    #   corresponding external lists.
    command_line+=(
        "${(z)command_line_prefix}"
        "${(@P)options_list_name}"
        "${(@P)interactive_options_list_name}"
        -- "${@}"
    )

    # Run.
#   sputter "run_with_options: ${command_line[@]}..."
    run "${command_line[@]}"
}

# ....................{ RUNNERS ~ paged                    }....................
#FIXME: Woops! We've dramatically simplified this by now paging on *ANY*
#line wrapping. That means we know longer need to determine displayed page
#length. Clean up documentation.
#FIXME: Actually, while this is decent, it'd be far better to:
#
#* Revert back to the prior logic of only paging when total displayed line
#  length exceeds terminal height *AND*
#* When not paging, to visually demarcate wrapped lines (ideally with color? or
#  perhaps simply with a simple prefix). So, rather than printing:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
#odes=497142 mode=755
#  Instead, printing:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ^-> odes=497142 mode=755
#  Or perhaps simply:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ...odes=497142 mode=755
#  Or the slightly cleverer:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr...
# ..._inodes=497142 mode=755
#  Actually, no. That reads awkwardly. One "..." is sufficient, I should think.
#  Happily, "yppy" already has appropriate Unicode for the former arrows. In either case, I
#  prefer the prefixing space on the wrapped line.

# string run_paged(
#   string command_name, string command_arg1, string command_arg2, ...)  --OR--
#
# Run the passed command with standard output and error piped to the current
# pager if such output exceeds either the current terminal height or width or as
# is (i.e., without paging) otherwise. Hence, this is an intelligent pager.
#
# Customary pager commands block on standard input, thus delaying output until
# after the input command completes operation. Resource-intensive commands not
# completing immediately (e.g., "ls -R *") thus block paging with no
# intermediate output until such commands eventually complete. To rectify such
# interface woes, this function immediately prints all output as received from
# the passed command to standard error prior to paging such output, as needed.
function run_paged() {
    # If not attached to a terminal, run the passed command as is and
    # immediately return without paging.
    is_terminal or {
#       utter "not attached to a terminal"
        run "${@}"
        return_true
    }

    # If passed piped input and...
    string output
    if is_piped_input; then
#       utter "received piped input: $(get_piped_input)"
        # ...no arguments, capture such output without running a command.
        # Duplicate the behavior of the output capturing below by printing such
        # output to standard error.
        if is_no_args; then
#           die_if_args 'expected no command when passed piped input'
#           output="$(get_piped_input)"
            set_to_piped_input output
            accurse "${output}"
        # ...at least one argument, run such arguments as a command and pipe the
        # input piped to this function to such command. See below for details.
        else
            output="$(run_with_piped_input run "${@}" 1>&1 1>&2 2>&1)"

            # Per the "CAVEAT" described under Zeshy Pipe, manually ensure
            # is_piped_input() now returns false.
            close_standard_input
        fi
    #FIXME: Hmm; the documentation no longer reflects the reality. Fixmeup.
    # Otherwise, run the passed command with redirection. Dismantled, this is:
    #
    # * "2>&2", preserving standard error prior to its subsequent redirection.
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
    # * "1>&1", preserving standard output prior to its subsequent redirection.
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
    else
        die_unless_args 'expected one command'
#       sputter "run_paged: ${@}..."
        output="$(run "${@}" 1>&1 1>&2 2>&1)"
    fi

    # List of output lines.
    list lines
    split_lines_to_list "${output}" lines

    # Determine whether such output's logical line length (i.e., accounting for
    # implicit wrapping of long lines) exceeds the terminal height or physical
    # line width the terminal width. The algorithm resembles
    # get_displayed_line_length(), but differs by immediately stopping iteration
    # on exceeding terminal height or width rather than continuing to accumulate
    # total line length. This reduces an otherwise O(N) algorithm to effectively
    # O(1), assuming non-ludicrous terminal height and width.
    integer\
        output_height="${#lines}" output_width\
        terminal_height terminal_width
    terminal_height=$(get_terminal_height)
    terminal_width=$(get_terminal_width)
#   sputter "lines=${lines[@]}\noutput_height=${output_height}\nterminal_height=${terminal_height}"

    # If the output's line height does not exceed the terminal height, determine
    # whether or not its maximum line width exceeds the terminal width.
    # Accumulate wrapped line height and maximum line width until either exceeds
    # terminal height or width, at which point we know we need to page.
    (( output_height > terminal_height )) or for line ("${lines[@]}") {
        # Remove ANSI color codes prior to testing line length.
        output_width=${#$(remove_ansi_color_codes "${line}")}
#       sputter "line (width: ${output_width}) ${line}"
        (( output_width > terminal_width )) and break
    }
#   sputter "output_height: ${output_height}\nterminal_height: ${terminal_height}"
#   sputter "output_width: ${output_width}\nterminal_width: ${terminal_width}"

    # If the terminal suffices to display output without paging, do not page.
#   utter "line length: ${output_height}\nterminal height: ${terminal_height}"
    (( output_height > terminal_height )) or
    (( output_width  > terminal_width  )) or return_true

    # Pager command to be run.
    list pager; pager=( "${PAGER}" )

    # Pager command name capitalized for use below.
    string pager_command_name
    pager_command_name="$(capitalize_string "$(get_basename "${PAGER}")")"

    # List of pager options specific to such pager.
    string pager_options_list_name
    pager_options_list_name="ZESHY_${pager_command_name}_OPTIONS"
    is_list "${pager_options_list_name}" and
        pager+=( "${(@P)pager_options_list_name}" )

    # Page.
    sputter "${output}" | "${pager[@]}"
}

# ....................{ RUNNERS ~ priority                 }....................
# string run_quickly(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command "quickly" under prioritized CPU and I/O scheduling.
function run_quickly() {
    run_with_priorities\
        ${ZESHY_NICE_PRIORITY_LOW}\
        ${ZESHY_IONICE_CLASS_LOW}\
        ${ZESHY_IONICE_CLASS_PRIORITY_LOW}\
        "${@}"
}

# string run_slowly(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command "slowly" under deprioritized CPU and I/O scheduling.
function run_slowly() {
    run_with_priorities\
        ${ZESHY_NICE_PRIORITY_LOW}\
        ${ZESHY_IONICE_CLASS_LOW}\
        ${ZESHY_IONICE_CLASS_PRIORITY_LOW}\
        "${@}"
}

# string run_with_priorities(
#   int nice_priority, int ionice_class, int ionice_class_priority,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command under the passed "nice" and "ionice" priorities if
# "ionice" is under ${PATH} or the passed "nice" priority otherwise.
function run_with_priorities() {
    # Localize passed arguments.
    die_unless_args
    integer\
        nice_priority="${1}"\
        ionice_class="${2}"\
        ionice_class_priority="${3}"
    shift_three_args

    # Command line to be run, prefixed by commands prioritizing the passed
    # command. All systems provide "nice" but not necessarily "ionice".
    list command_line; command_line=( nice -n${nice_priority} )
    is_installed ionice and command_line+=( ionice
        -c${ionice_class}
        -n${ionice_class_priority}
    )

    # Run.
    command_line+=( "${@}" )
    run "${command_line[@]}"
}

# ....................{ RUNNERS ~ progress                 }....................
# string run_with_progress_timer(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command, printing a progress timer on standard error displaying
# how many seconds have elapsed since running such command. Consider calling
# this function on silent and/or slow commands (e.g., "ntpd -q -s",
# synchronizing the local system time against remote time servers but displaying
# no progress while doing so).
function run_with_progress_timer() {
    # Validate passed arguments.
    die_unless_args 'expected one command'

    #FIXME: If "pv" is *NOT* installed, are there any respectable alternatives?
    # Prefer "pv", the pipe viewer.
    if is_installed pv
    then run "${*} | pv -t"
#   then print "progress_time: ${@}"; run "${@} | pv -t"
    # Otherwise, simply run the passed command.
    else run "${@}"
    fi
}

# ....................{ RUNNERS ~ schedule                 }....................
# void run_every(
#   int seconds,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command every passed number of seconds.
function run_every() {
    # Localize passed arguments.
    die_unless_at_least_two_args\
        'expected one duration in seconds and one command'
    die_unless_positive_decimal "${1}"
    integer every_seconds=${1}
    shift_one_arg

    # If the passed command is an external command, run under "watch", a POSIX-
    # standard command with an efficiently aesthetic CLI supporting only
    # external commands.
    if is_installed "$(get_command_line_name "${@}")"
    then watch -n ${every_seconds} -x -- "${@}"
    # Otherwise, run under a mimic of the "watch" CLI.
    else
        # Until the user explicitly hits <Ctrl-C>, ...
        while true; do
            #FIXME: Append with a right-aligned timestamp, as under "watch".
            # Mimic the "watch" UI. For efficiency, call "echoti" directly.
            clear_terminal_screen
            sputter "Every ${every_seconds}s: ${@}\n"

            # Run and sleep. (Just like in real life.)
            run "${@}"
            sleep ${every_seconds}s
        done
    fi
}

# ....................{ RUNNERS ~ users                    }....................
# void run_as_superuser(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command as the superuser.
function run_as_superuser() {
    run_as root "${@}"
}

# void run_as(
#   string username,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command as the passed user.
function run_as() {
    # Localize passed arguments, stripping off the prefixing username.
    die_unless_at_least_two_args 'expected one username and one command'
    string username="${1}"
    shift_one_arg

    # If the user under which to run the passed command is the current user,
    # defer to the run() command and immediately return.
    is "${username}" == "$(get_username)" si and {
        run "${@}"
        return_true
    }

    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into Zsh-specific words.
#   sputter_unescaped "command line: ${@}"
    list command_line; command_line=( "${(z)@}" )
#   list command_line; command_line=( "${(Qz)@}" )

    #FIXME: Insufficient. Consider "LC_ALL=C ls".
    # Command name to run.
    string command_name="${command_line[1]}"

    #FIXME: Insufficient. Zsh builtins and functions should be executable as
    #other users, though it's probably non-trivial to do so. Perhaps prefix the
    #command line with "zeshy" and augment "bin/zeshy" to handle passed commands?
    die_unless_installed "${command_name}"

    # If the target user is the superuser, use "sudo" to take advantage of
    # password caching. Avoid "@", as that splits the command line into discrete
    # arguments. "sudo" and "su" can split their own arguments, thank you.
    if is_superuser "${username}" and is_installed sudo
    then sudo -E  "${command_line}"
    # Otherwise, use "su".
    else su -p -c "${command_line}" "${username}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
    # Otherwise, we've entered the Clusterfuck Zone. Zsh deals poorly with
    # quotes in "eval" strings. We can't simply brute-force quote-protection on
    # all passed arguments (e.g., "eval ${(q)@}"), as that overly quotes passed
    # arguments the caller expects to remain unquoted (e.g., "2>&1"). Instead,
    # we implement a crude shell parser selectively quote-protecting only non-
    # evaluatable strings *NOT* containing reserved characters. YES, THIS IS
    # AAAAAAAAAABSOLUTELY CRAZY. Fix this, kind Zsh developers. (Fix this now.)

# See above examples.
#
# Run the passed command. While Zsh and hence Zeshy already run strings as
# commands if in command position, strings containing shell-reserved characters
# (e.g., "|", "<", ">") do not run as expected. This function amends that.
#
# conditionally quote-protecting passed arguments as required: e.g.,
#
#   # Command to be run, split into multiple parts to make life troublesome.
#   >>> string command='cat /dev/random | grep'
#   >>> list grep_args; grep_args=( -E '\{Eschaton Entombed\(\)\}' )
#
#   # Doubleplusungood. Zsh parses the former as one composite command name and
#   # the pipe in the latter as a raw command argument. In either case, failure.
#   >>> ${command} ${grep_args[@]}          # bad!
#   >>> ${(z)command} ${(q)grep_args[@]}    # equally bad!
#
#   # Ohsonice. Run the expected command.
#   >>> run "${command}" "${grep_args[@]}"
#   {Eschaton Entombed()}                   # it could happen...
#
# This function suffers numerous pitfalls, which you don't usually but
# occasionally need to worry about. Beware the following impenetrable caveats:
#
# * When passing a single argument interpolated from a caller-provided list,
#   expand list elements with ${*} rather than ${@}. The former expands list
#   elements in place as expected; the latter expands list elements into
#   multiple arguments rather than a single argument, despite appearances: e.g.,
#
#   # Doubleplusungood. If "${@}" contains at least two elements, this passes
#   # run() such elements as discrete arguments and appends " | pv -t" onto the
#   # final such element. Probably not what you indiscretely expected, eh?
#   >>> run "${@} | pv -t"
#
#   # Ohsonice. This never does the wrong thing.
#   >>> run "${*} | pv -t"

    #FIXME: Not quite right. We should probably call "$(get_command_line_name)"
    #to get the name of the command in command position. *shrug, for the moment*
#   list command_line; command_line=( "${(z)@}" )
#   is "${command_line[1]}" == run(|_?*) si and {

    #FIXME: Shouldn't we be reusing the split apart "${command_line}" from above?
#   list args; args=( "${@}" )
#   list args; args=( "${(@)@[1,-1]}" )
#   list arg_words
#   sputter "run (multiple-arg eval): ${args[@]}... (last arg: ${@[-1]}) [before]"
#   for ((i = 1; i <= ${#args}; i++)) {
        #FIXME: Still not quite right. Basically, we should be forcefully escaping
        #*ALL* unescaped shell-reserved characters -- not merely ", ', and " ". If
        #the caller would rather no such characters be escaped, then they need to
        #pass one and only one argument. Basically, this function has three
        #different modes of operation; we need succinctly document all three, above.
        #
        #*WAAAAAIT*. Wait just a minute. Is all of this extreme effort effectively
        #equivalent to just calling:
        #    "${@}"
        #I mean, we're effectively prohibiting reserved shell characters anyway.
        #So... I don't see the difference. Simply running "${@}" is obviously a
        #vast improvement over the computationally expensive and admittedly
        #error-prone logic below. In fact, reducing to "${@}" allows us to
        #completely remove the above run_*() logic. Also nice.
        #
        #Yes. This strikes me as the way to go. The eval() builtin basically
        #breaks down completely when passed multiple arguments and hence cannot
        #be called reliably in such cases. So, don't. Just run "${@}" as is
        #if passed multiple arguments to sidestep such issues entirely.
        #
        #Nice. I've just verified running "${@}" works as expected with builtins.
        #What're we waiting for...?
        #
        #Actually, I'm glad I waited. Drop this entire "for" loop. The remainder
        #of this function remains the same. This is the best we can do, I'm afraid.
        #Unfortunately, this sort of ad-hoc dynamic quote protection works in the
        #average case but generally fails: e.g., if passed "$(ls hello)", we don't
        #want to quote protect the space in such argument. Hence, stop doing this
        #altogether. *shrug*

        # Quote protection flag "(q)" escapes all shell-reserved characters
        # (e.g., "<", "&", "|"). While useful, such protection conflicts with
        # caller expectations. In this case, callers expect us to interpret
        # such characters according to their shell-reserved meaning rather than
        # as escaped characters. Hence, escape only the proper subset of shell-
        # reserved characters not conflicting with such expectations: namely,
        # single spaces, single quotes, and double quotes. Do so only when such
        # character has not already been escaped (i.e., prefixed with "\").
        #
        # Dismantled, this is:
        #
        # * "${args[${i}]//", globally replacing in the current argument.
        # * "(#b)", enabling back references (i.e., match groups).
        # * "(...|)", matching as group 1 either:
        #   * "(#s)", the beginning of the string.
        #   * "[^\\]", any character other than a "\" escape.
        # * "([ \'\"]), matching as group 2 the character to be escaped.
        #
        # *SUCH REPLACEMENT IS INDELIBLY, INCREDIBLY FRAGILE*. Since this
        # function comprises the heart of Zeshy operation, take care when
        # revising such replacement to account for all possible cases. In
        # particular, see list_path_concisely(). Attempt calling such function
        # with filenames containing both spaces and unbalanced quotes when
        # passing arguments as both "${@}" and "${(q)@}". Such replacement
        # should succeed under both protected and non-protected arguments.
#       sputter "run (multiple-arg eval): fixing up argument ${i} \"${args[${i}]}\"..."
#       args[${i}]="${args[${i}]//(#b)((#s)|[^\\])([ \'\"])/${match[1]}\\${match[2]}}"
#       arg_words=( "${(z)args[${i}]}" )
#       (( ${#arg_words} > 1 )) and {
#           sputter "run: fixing up \"${args[${i}]}\"..."
#           args[${i}]="${(q)args[${i}]}"
#       }

        #FIXME: Clearly, this fails to match all possible shell strings. It
        #should, however, suffice with immediate needs.
        #FIXME: Does this accomodate "is" and "si" in passed arguments? We
        #may need to perform an eval to expand aliases, here.
        #FIXME: Seems inherently dangerous, actually. Filenames containing
        #reserved characters as well as spaces or quotes certainly require
        #quote protection as well. Hmmm.

        # If the current argument contains at least one reserved shell
        # string (i.e., "<", ">", "||", "&&", or "$" when not preceded by an
        # escaping "\\" and not enclosed in quotes), ignore such argument.
        # Quoting such argument destroys its shell interpretation.
#       is "${args[${i}]}" == (|*[^\\])(*[\<\>\|\&\$\(\)\[\]\{\}]*) si and
#       is "${args[${i}]}" != (\'*\'|\"*\"|\`*\`) si and continue

        # If the current argument cannot be evaluated, quote such argument
        # and ensure the result can be. Avoid calling Zeshy functions here
        # (e.g., run_quietly()), as such functions transitively call this
        # function. (Ugh!)
#       eval ": ${args[${i}]}" 1>/dev/null 2>&1 or {
#           utter "fixing up ${args[${i}]}"
#           args[${i}]="${(q)args[${i}]}"
#           eval ": ${args[${i}]}" 1>/dev/null 2>&1 or
#               die "command \"${@}\" argument \"${arg}\" invalid"
#       }
#   }
#   eval ${(q)@}
#   eval ${@}
#   ${@}
#   return $?

    #FIXME: This works, but is rather clumsy. For one, it fails to account for
    #user-defined functions calling run(). For another, it's slow and abjectly
    #error-prone. How about reducing this to:
    #
    #   string run_function_glob='run(|_*)'
    #
    #This simply and effectively matches user-defined functions, assuming they
    #prefix such functions with "run_". This does not, however, match all of our
    #functions. We'll need to systematically rename them all, I'm afraid (e.g.,
    #run_quickly() to run_run_quickly()). Arguably, this is a good move *ANYWAY*.
    #Consistency assists readability, and makes it explicit exactly what's
    #happening when you call such functions.

    # If running a Zeshy function recursively calling this function, do *NOT*
    # "eval" the passed command as the second call to this function will do so
    # already. Since each "eval" strips one level of quotes from such command,
    # running such command as is avoids stripping of quote protection.
#   string run_function_glob='(run(|_as|as_superuser|_every|_paged|_with_options|_with_priorities)|run_quickly|run_quietly(|_as)|run_slowly|run_with_unified_output)'
#   list command_line; command_line=( "${(z)@}" )
#   is "${command_line[1]}" == ${~run_function_glob} si and {

#       list command_line; command_line=( "${@}" )
#       sputter "run_paged: ${command_line[@]}..."
    #FIXME: Ugh. Broken. We need to ignore VT100 commands. I've been
    #searching for a Zsh-specific solution, but have yet to find anything. Ah!
    #It's not Zsh, but it'll do: sed!
    #http://www.commandlinefu.com/commands/view/3584/remove-color-codes-special-characters-with-sed
    #Looks like this should get us close. Let's research it a bit:
    #sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
    #sed -r "s/\x1B\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g"
    #I suspect the second is more accurate. Again, research.
#       output_width=${#"$(remove_ansi_color_codes "${line}")"}
#       line="$(remove_ansi_color_codes "${line}")"
#       output_width=${#line}

        #FIXME: Excise this frivolous check after all's well above.
#       exec {/dev/stdin}>&-
#       exec 0<&-
#       is_piped_input and die 'uh-oh; still piped input!'
    # Terminal width plus one to avoid treating maximally long lines as wrapped.
# terminal_width_plus_one
# (( terminal_width_plus_one = terminal_width + 1 ))
        # Test line height.
#       (( line_height += line_width / terminal_width ))
#       (( line_height > terminal_height )) and break
#   (( wrapped_line_height > terminal_height )) or {
#       (( line_width > maximum_line_width && maximum_line_width = line_width ))
#       (( maximum_line_width > terminal_width )) and break
    # Localize passed arguments. Do *NOT* call die_unless_at_least_two_args(),
    # as such function suffixes the argument list with piped input. While this
    # is typically what we want, this function already pipes piped input to the
    # command to be run... Suffixing the argument list passes such input to such
    # command twice, therefore. Which is blatantly bad.
#   (( # >= 2 )) or
#       die 'expected one command prefix, one list name, and zero or more command arguments'
#       args[${i}]="${args[${i}]//(#b)([ \'\"])/\\${match[1]}}"

        #FIXME: O.K.; this works, but it's all a bit shoddy. Test this by
        #editing list_path_concisely(), adding back "${(q)@}" and seeing whether
        #things survive! We may need to be a bit less zealous.
        #FIXME: This should probably avoid escaping already escaped characters
        #(e.g., "\ "). Use a method similar to below, I'd imagine.
#       args[${i}]="${args[${i}]//(#b)(^|[^\\])([ \'\"])/${match[1]}\\${match[2]}}"
#       args[${i}]="${${args[${i}]// /\\ }//'}"
#       arg_words=( "${=args[${i}]}" )
    #FIXME: Generalize to a run_with_options() approach. Also, we currently pass
    #"-x" to prevent "watch" from running the passed command under "sh -c", which
    #will rarely behave as expected from a Zeshy perspective. However, that means
    #we actually need to prefix such command with "zsh -c" if a zsh builtin or
    #die if a Zeshy-specific function. Or, would Zsh shells spawned by the
    #"watch" command inherit Zeshy functions? Hmmmmm; test us up. Also,
    #"--color" doesn't really work. That's O.K., but don't expect miracles.
    #(Color support is a Gentoo patch courtesy Debian, so there you go...)

#       string output; output="$(run "${@}" 2>&2 2>&1 1>&1 1>&2)"

#   eval ${command_line[@]}
#   eval "${(q)command_line[@]}"

    # If passed at least one non-option argument, append such arguments.
#   is_args and is "${1}" != [\<\|]* si and command_line+=( -- "${@}" )
#   is_args and {
#       if is "${1}" == [\>\<\|]* si
#       then command_line+=(    "${@}" )
#       else command_line+=( -- "${@}" )
#       else command_line+=( -- "${(q)@}" )
#       fi
#   }

#. Note
# that preserving escapes and quotes (e.g., "\ ", "'''") in command arguments
# requires protecting arguments with "(q)" prior to calling this function#|\$\{*\))|(\$\(*\)
#       for arg ("${args}") {
#           noop "${args[${i}]}" or {
#           if not eval "print -- ${args[${i}]}" 1>/dev/null 2>&1 or {
#               utter "fixing up ${args[${i}]}"
#               args[${i}]="${(q)args[${i}]}"
#               eval "print -- ${args[${i}]}" 1>/dev/null 2>&1 or
#                   die "command \"${@}\" argument \"${arg}\" invalid"
#           }
#                  eval "print -- ${(q)args[${i}]} true" 1>/dev/null 2>&1; then
#              eval "print -- ${args[${i}]} true" 1>/dev/null 2>&1 or {
#              eval "print -- ${args[${i}]}" 1>/dev/null 2>&1 or {
#           if is "${args[${i}]}" != [\'\"]* si and
#              is "${args[${i}]}" != *[\<\>\|]* si and
#              not eval "print -- ${args[${i}]}" 1>/dev/null 2>&1; then
#               utter "fixing up ${args[${i}]}"
#               args[${i}]="${(q)args[${i}]}"
#               eval "print -- ${args[${i}]} true" 1>/dev/null 2>&1 or
#                   die "command \"${@}\" argument \"${arg}\" invalid"
#           fi

    # If one argument was passed, such argument signifies a command line to be
    # run. Otherwise, only the concatenation of such arguments signifies the
    # line. In the latter case, embedded escapes and quotes (e.g., "\ ", "'''")
    # in such arguments must be preserved in the expansion with "(q)".
#   if is_one_arg
#   then eval "${1}"
#   else eval "${@}"
#   else eval "${(q)@}"
#   fi

#FIXME: Pretty silly. We don't use this. Consider excising. Actually, it could
#be helpful to generalize this to something like:
#   return_exit_status_if_false
# int one_if(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command run_quietly (i.e., squelching output) and, if exiting
# with success, return "1"; otherwise, return the empty string: e.g.,
#
#     >>> integer IS_MUTT_INSTALLED=$(one_if is_installed mutt)
#     >>> is_nonzero "${IS_MUTT_INSTALLED}" and print '"mutt" is installed'
#     "mutt" is installed
#one_if() {
#    run_quietly "${@}" and return 1 or return_true
#}

# that preserving escapes and quotes (e.g., "\ ", "'''") in command arguments
# requires protecting arguments with "(q)" prior to calling this function: e.g.,
#
#   # Command to be run.
#   >>> list command_line
#   >>> command_line=( screen -list | grep --count ' )
#
#   # Command arguments to be passed to "grep".
#   >>> list grep_args; grep_args=( --count 'eschaton' )
#   sputter_unescaped "last... \"${command_line[-1]}\"..."
#   eval command ls -l "${command_line[-1]}"
#   eval run_paged command ls -l "${command_line[-1]}"
#   run_it run_paged command ls -l "${command_line[-1]}"
#   run ${command_line[@]}

#FIXME: This function should really be cleaved into two: all of the user-
#specific logic shifted into run_as() and only the eval() retained in this
#function. That shouldn't leave terribly much here... which is good. You know;
#the more I consider it, the more I wonder if run() shouldn't simply be a
#straightforward alias for 'alias'. That would single-handedly eliminate all of
#the "(q)" nonsense... and thereby break everything! The solution is simple:
#
#* Create a new "alias run='eval'" alias.
#* Transition all existing run() calls to run().
#* Rename run() to run_as(), probably with slight implementation changes.

#FIXME: This function should really be cleaved into two: all of the user-
#specific logic shifted into run_as() and only the eval() retained in this
#function. That shouldn't leave terribly much here... which is good. You know;
#the more I consider it, the more I wonder if run() shouldn't simply be a
#straightforward alias for 'alias'. That would single-handedly eliminate all of
#the "(q)" nonsense... and thereby break everything! The solution is simple:
#
#* Create a new "alias run='eval'" alias.
#* Transition all existing run() calls to run().
#* Rename run() to run_as(), probably with slight implementation changes.

# void run(string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed builtin or command, ideally quote-protected to avoid premature
# parsing of shell-specific syntax (e.g., pipes, redirections). Where passing a
# parameter expansion to this function, force such protection with "(q)": e.g.,
#
#   # Good! Manually quote-protect with single or double quotes.
#   >>> run 'screen -list | grep --count eschaton'
#   969
#
#   # Good! Automatically quote-protect with parameter expansion flag "(q)".
#   >>> string command=$(screen -list | grep --count singularity)
#   >>> run "${(q)command}"
#   696
#
#   # Doubleplusungood. Zsh parses the pipe prior to calling run().
#   >>> run screen -list | grep --count eschaton
#run() {
#    die_unless_args 'expected one or more command strings'

    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into Zsh-specific words.
#   print "command line: ${@}"
#    list command_line; command_line=( "${(Qz)@}" )
#   list command; command=( "${(Qz)@}" )
#   print "second arg: ${command_line[2]}"
    
    # Command name to run as the first word of such command line.
#   string command_name="${(Q)command_line[1]}"
#    string command_name="${command_line[1]}"
    
    # A string conditionally defined to (in order):
    #
    # * If a Zsh alias, function, or builtin has the command name, that name.
    # * Otherwise, if the current $PATH contains the command name, the absolute
    #   path to that command.
    # * Otherwise, raise an exception.
#    string command_path
#    command_path="$(whence "${command_name}")" or
#        die "\"${command_name}\" not found in \$PATH"

    # If the passed command has not been overridden by a shell alias or
    # function, run it as a command. Do not call the customary is_installed()
    # function, as that does not test whether or not a command is overridden.
#    if is_absolute_path "${command_path}"; then
        # If running this command under a different user, do so.
#        if is_set_nonempty 'ZESHY_RUN_AS' and
#           is "${ZESHY_RUN_AS}" != "${USER}" si; then
            # If the target user is the superuser, use "sudo" to take
            # advantage of password caching. Do *NOT* use the "(@)" expansion in
            # either of the following two commands, as that would split the line
            # into discrete command arguments.
#            if is "${ZESHY_RUN_AS}" == root si and is_installed sudo; then
#               echo "sudoing as ${ZESHY_RUN_AS}: ${command}"
#                sudo -E "${command_line}"
            # Otherwise, use "su".
#            else
#               echo "suing as ${ZESHY_RUN_AS}: ${command}"
#                su --preserve-environment\
#                   --command "${command_line}" "${ZESHY_RUN_AS}"
#            fi
        # Otherwise, run this command as the current user. Use the "[@]"
        # expansion here, as calling the command manually requires we split the
        # line into discrete command arguments. Evaluate this command to ensure
        # the shell correctly handles shell constructs (e.g., "|").
#        else
##           print "evaling: ${command_line[@]}"
#            eval "${command_line[@]}"
#        fi
    #FIXME: Incomplete. How does one run a builtin as another user? Implement.
    # Otherwise, the passed command must be a shell built-in. Evaluate it!
#    else
#       print "evaling: ${command_line[@]}"
#        eval "${command_line[@]}"
#    fi
#}
    # If the second-to-last passed argument is "--", treat the last passed
    # argument as a command line suffix to be appended to the command line.
#   if is_at_least_two_args and is "${@[-2]}" == '--' si; then
#       command_line_suffix="${@[-1]}"
#       pop_two_args
#   fi

    #FIXME: This isn't quite right. The reason why, of course, is long lines.
    #Technically, such lines contain a single newline; when displayed, such
    #lines implicitly force more than a single newline. To account for this,
    #we'll need add a new function get_displayed_line_length() to
    #"shell/terminal". Its implication returns an integer as follows:
    #
    #* For each physical line in the passed string, increment line length by one.
    #* For each 80th character (or what have you) in each physical line in the
    #  passed string, increment line length by one. A simple calculation
    #  obtains this:
    # If not outputting to a terminal of height less than the height of the
    # output produced by this command, immediately return.

#   is_terminal and
#     (( $(get_displayed_line_length "${output}") >  )) or
#     return_true

    # Localize passed arguments.
#   list lines; lines=( "${(f)@}" )

    #FIXME: Is this really the most efficient means of propagating pipes?
#   then run "print -- $(< /dev/stdin)' | ${(q)command_line[@]}"

#   die_unless_at_least_two_args\

# string testify(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command, converting raised exceptions to non-zero exit status.
# This function is particularly helpful for propagating exceptions thrown by
# subshells up the call stack of the current shell. (By default, Zsh does *NOT*
# propagate such exceptions.)
# reliably capturing the standard
# output of exception-throwing functions: e.g.,
#
#     # Bad. Regardless of whether get_first_file() throws an exception, the
#     # declaration of "first_file" silently succeeds.
#     >>> string first_file="$(testify get_first_file /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#     
#     # Good. If get_first_file() throws an exception, the declaration of
#     # "first_file" explicitly fails by propagating such exception.
#     >>> string first_file="$(testify get_first_file /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#testify() {
#    {
#        run "${(q)@}" 2>&1
#    } always {
#        integer exit_status=${?}
#        (( ${exit_status} )) and exit ${exit_status}
#    }
#}

    #FIXME: ...we appear to no longer require the "Q". (Naturally, I have no
    #firm idea why.)

#   string command_line="$(get_command_line "${@}")"

# Note, commands should be passed as quoted strings to prevent the calling
# shell from evaluating pipes, redirections, et al. prior to passing the
# command. (See the run() function, above.)

    #FIXME: This only strips one dash. How to strip more?
    # Strip prefixing dashes from this string to prevent the "basename" command
    # from intepreting such dashes as options to that command. This is actually
    # a real-world concern. By convention, for example, Linux prefixes login
    # shell command lines with one dash.
#   string process_command_line="${$(get_process_command_line)#-}"
#   string process_command_line="$(get_process_command_line)"
#   process_command_line="${process_command_line#-}"
