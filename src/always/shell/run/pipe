#!/usr/bin/env zsh
# ====================[ pipe                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Pipe, handling traditional and named pipes.
#
# --------------------( CAVEATS                            )--------------------
# * Prefer calling piped input functions from the current shell rather than a
#   subshell unless absolutely necessary. Calling such functions from a subshell
#   fails to close standard input in the current shell; subsequent commands in
#   the current shell thus erroneously see standard input to be an open pipe,
#   when in fact such pipe is empty and should have been closed. To fix this,
#   always call close_standard_input() after calling piped input functions in a
#   subshell.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_piped_input(string error_message = '"/dev/stdin" not a pipe')
#
# Throw an exception unless standard input to the current shell is a pipe.
die_unless_piped_input() {
    die_unless_at_most_one_arg 'expected optional error message'
    is_piped_input or die "${1:-\"/dev/stdin\" not a pipe}"
}

# ....................{ TESTS                              }....................
# boolean is_piped_input(void)
#
# Return true if standard input to the current shell is a pipe. Equivalently,
# return true if such shell is running any command after the first in a pipe.
is_piped_input() {
    die_if_args
    is -p /dev/stdin si
}

# ....................{ SETTERS                            }....................
# void set_to_piped_input(string variable_name)
#
# Set the variable with the passed name to all standard input piped to the
# current shell. Consider calling is_piped_input() before calling this function
# to test whether or not such input exists: e.g.,
#
#     >>> ska_maria() {
#     ...     string hojas
#     ...     if is_piped_input
#     ...     then set_to_piped_input hojas
#     ...     else hojas="${@}"
#     ...     fi
#     ...     sputter ${hojas}
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
set_to_piped_input() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one variable name'
    die_unless_piped_input
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Capture piped input into the passed variable.
    set_to_string ${string_name} "$(< /dev/stdin)"

    # Close standard input, ensuring is_piped_input() now returns false.
    close_standard_input
}

# ....................{ RUNNERS                            }....................
# string run_with_piped_input(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command by piping the standard input piped to the current
# function or script to such command. Typically, this alias is used in concert
# with the is_piped_input() alias to seemlessly propagate input: e.g.,
#
#     >>> salvia() {
#     ...     if is_piped_input
#     ...     then run_with_piped_input cat
#     ...     else print -- "${@}" cat
#     ...     fi
#     ... }
#     >>> print  divinorum | salvia
#     divinorum
#     >>> salvia divinorum
#     divinorum
run_with_piped_input() {
    # Validate and run passed arguments.
    die_unless_args 'expected one command'
    run cat '/dev/stdin' \| "${@}"

    # Close standard input, ensuring is_piped_input() now returns false.
    close_standard_input
}

# --------------------( WASTELANDS                         )--------------------
    #FIXME: We really want a new function set_string(), implemented resembling:
#set_string() {
#   noop ${(P)1::="${2}"}
#}
#This avoids an eval() and hence should be fairly efficient. (Of course, it
#imposes an additional function call... *shrug*)
#   noop ${(P)string_name::=$(< /dev/stdin)}
#   noop ${(P)string_name::="$(< /dev/stdin)"}
#   eval ${string_name}="$(< /dev/stdin)"

#FIXME: Rename set_with_piped_input(), coinciding with run_with_piped_input().
#FIXME: No reason this can't also be made a run-style function. It should call
#close_standard_input(), as expected.
#   exec 0<&-
#FIXME: Arguably, these functions may not belong here. Bizarre! They don't even
#work. Shifting to aliases... *sigh*
# --------------------( CLOSERS                            )--------------------
# void close_standard_input(void)
#
# Close the standard input file descriptor (0) and named pipe ("/dev/stdin").
#close_standard_input() {
#    die_if_args
#    exec 0<&-
#}

# void close_standard_output(void)
#
# Close the standard output file descriptor (1) and named pipe ("/dev/stdout").
#close_standard_output() {
#    die_if_args
#    exec 1>&-
#}

# void close_standard_error(void)
#
# Close the standard error file descriptor (2) and named pipe ("/dev/stderr").
#close_standard_error() {
#    die_if_args
#    exec 2>&-
#}

#   string output; output="$(< /dev/stdin)";
