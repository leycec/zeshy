#!/usr/bin/env zsh
# ====================[ zeshy                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define core Zeshy functionality.

# ....................{ TESTS                              }....................
# boolean is_zsh_version_at_least(string zsh_version)
#
# Return true the current version of Zsh is at least as recent as the passed
# version. See get_zsh_version() for further discussion.
is_zsh_version_at_least() {
    die_unless_one_arg 'expected one zsh version string'
    is-at-least "${1}"
}

# ....................{ GETTERS                            }....................
# float get_zeshy_version(void)
#
# Get the current version of Zeshy as a comparable floating point number.
get_zeshy_version() {
    die_if_args
    sputter 0.01
}

# string get_zsh_version(void)
#
# Get the current version of Zsh as an uncomparable string (e.g.,
# "4.8.17-dev0"). Since this string is not necessarily numeric, always call
# is_zsh_version_at_least() rather than brute-force comparison. This string is
# typically only useful for logging or printing to the screen.
get_zsh_version() {
    die_if_args
    sputter ${ZSH_VERSION}
}

# ....................{ COMPILERS                          }....................
# void recompile_zeshy(void)
#
# Recompile Zeshy's digest file and hence redefine all applicable autoloads.
recompile_zeshy() {
    # If compile_zeshy() is defined, call such function directly.
    if is_function compile_zeshy
    then compile_zeshy
    # Otherwise, Zeshy's optional Compile component has not yet been sourced. Do
    # so, which also implicitly calls compile_zeshy().
    else source_zeshy_component 'compile'
    fi
}

# ....................{ SETUP                              }....................
setup_zeshy() {
    setup_zeshy_version
    is_interactive and
        setup_if_interactive or
        setup_if_non_interactive
    setup_if_installed
}

#FIXME: First, this should actually "interactively usher the current user into
#the upgrade process." To do so, we'll need a new difference_files() command
#invoking some underlying "vimdiff" (only if the current EDITOR == "vim"),
#"diff", and so on command to diff the user's current config against Zeshy's
#new config. I have two thoughts on this:
#
# 1. We could avoid all diffing by having the user write into a "config.local"
#    or "config-local" file in "~/.zeshy" rather than "config". (Actually, why
#    not let it just be their choice?) O.K.; so, here's how we roll:
#    * When rewriting the Zeshy version file, stamp the Zeshy config file with
#      the same mtime.
#    * If the Zeshy version file is ever outdated (i.e., Zeshy was upgraded),
#      compare the mtime of that file with that of the Zeshy config file. If
#      the latter is newer, the user modified it, so we need to run a diff;
#      otherwise, silently delete the Zeshy config file and let Zeshy re-
#      fabricate it for us.
#    * The user can opt to always have such config file silently deleted by
#      simply always using "config.local", instead. The downside is that
#      global variables may change names and they won't necessarily notice
#      immediately. (Or other such desynchronizations.) But probably worth it.
#    * Zeshy Global will need to look for "config.local" and, if extant,
#      source it *AFTER* sourcing "config". Fairly simple, eh?

# void setup_zeshy_version(void)
#
# Ensure the cached Zeshy version corresponds to the current Zeshy version. If
# not, interactively usher the current user into the upgrade process.
setup_zeshy_version() {
    is_file "${ZESHY_USER_VERSION_FILE}" or
        get_zeshy_version > "${ZESHY_USER_VERSION_FILE}"
}

#FIXME: Eventually, we'll have to add a setup hooks list and functions for
#adding setup hooks to such list. This is a hard requisite, as users may like to
#add new components not explicitly conceived of here. Assuming such a framework,
#no explicit tests are required here. It's also much easier to maintain, since
#it couples setup logic to the components implementing such functions.

# Conditionally setup non-interactive commands, if installed.
setup_if_installed() {
    run_if_runnable setup_x
    setup_interactive_gui_substitutions
}

# ....................{ SETUP ~ interactive                }....................
# If this shell is attached to a terminal device, set terminal-specific options.
setup_if_interactive() {
    setup_mimetypes
    setup_terminal
    setup_theme_key_bindings
    setup_theme_styles
    setup_theme_prompt
    setup_if_interactive_globals
    setup_if_interactive_installed
}

setup_if_interactive_globals() {
    # Absolute paths of the preferred command-line editor and pager.
    global_string\
        EDITOR="${EDITOR:-"$(get_first_command_path emacs vim nano ed)"}"\
        PAGER="${PAGER:-"$(get_first_command_path less more)"}"
    global_string VISUAL="${VISUAL:-${EDITOR}}"
}

# Conditionally setup interactive-only commands, if installed.
setup_if_interactive_installed() {
    is_installed keychain and setup_keychain
}

# ....................{ SETUP ~ non-interactive            }....................
setup_if_non_interactive() {
#   print "process command name: $(get_process_command_name)"
}

# --------------------( WASTELANDS                         )--------------------
    # Set the default script name prior to all other logic, as any logic
    # raising an error requires this name for logging that error. Only do this
    # if the current process is not an interactive Zsh shell as, in that case,
    # the get_script_name() function dynamically inspects the script name from
    # the function call stack.
    # Strip the filetype from this script's basename, if present.
#   global_string ZESHY_SCRIPT_NAME="${$(get_process_command_name)%%.*}"

    # Default the script name to "zeshy", if "zsh".
#   is "${ZESHY_SCRIPT_NAME}" == zsh si and ZESHY_SCRIPT_NAME=zeshy
