#!/usr/bin/env zsh
# ====================[ zeshy                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define core Zeshy functionality.

# ....................{ TESTERS                            }....................
# boolean is_zsh_version_at_least(string zsh_version)
#
# Return true the current version of Zsh is at least as recent as the passed
# version. See get_zsh_version() for further discussion.
function is_zsh_version_at_least() {
    die_unless_args_1 'expected one zsh version string'
    is-at-least "${1}"
}

# ....................{ GETTERS                            }....................
# float get_zeshy_version(void)
#
# Get the current version of Zeshy as a comparable floating point number.
function get_zeshy_version() {
    die_if_args
    output_string 0.01
}

# string get_zsh_version(void)
#
# Get the current version of Zsh as an uncomparable string (e.g.,
# "4.8.17-dev0"). Since this string is not necessarily numeric, always call
# is_zsh_version_at_least() rather than brute-force comparison. This string is
# typically only useful for logging or printing to the screen.
function get_zsh_version() {
    die_if_args
    output_string ${ZSH_VERSION}
}

# ....................{ GETTERS ~ paths                    }....................
#FIXME: Rename to get_user_zeshy_dir(), in keeping with global names.
# string get_user_zeshy_dot_dir(string username = "$(get_current_user)")
#
# Get the absolute path of the Zeshy dot directory for the passed user
# (defaulting to the current user): e.g.,
#
#     >>> get_user_zeshy_dot_dir lydia
#     /home/lydia/.zeshy
function get_user_zeshy_dot_dir() {
    die_unless_args_0_to_1 'expected optional username'
    output_string "$(get_user_home "${1}")/${ZESHY_USER_DIR_BASENAME}"
}

# ....................{ COMPILERS                          }....................
# void recompile_zeshy(void)
#
# Recompile Zeshy's digest file and hence redefine all applicable autoloads.
function recompile_zeshy() {
    # Validate sanity.
    die_if_args

    # If compile_zeshy() is defined, call such function directly.
    if is_function compile_zeshy
    then compile_zeshy
    # Else Zeshy's optional "compile" component has not yet been sourced. Do so,
    # thus implicitly calling compile_zeshy().
    else source_zeshy_script compile
    fi
}

# ....................{ PRINTERS                           }....................
# string print_zeshy_version(void)
#
# Print a human-readable synopsis of the current version of Zeshy.
function print_zeshy_version() {
    die_if_args
    say "$(get_zeshy_version)"
}

# ....................{ STARTUP                            }....................
append_zeshy_startup_command startup_zeshy_version

#FIXME: First, this should actually "interactively usher the current user into
#the upgrade process." To do so, we'll need a new difference_files() command
#invoking some underlying "vimdiff" (only if the current EDITOR == "vim"),
#"diff", and so on command to diff the user's current config against Zeshy's
#new config. I have two thoughts on this:
#
# 1. We could avoid all diffing by having the user write into a "config.local"
#    or "config-local" file in "~/.zeshy" rather than "config". (Actually, why
#    not let it just be their choice?) O.K.; so, here's how we roll:
#    * When rewriting the Zeshy version file, stamp the Zeshy config file with
#      the same mtime.
#    * If the Zeshy version file is ever outdated (i.e., Zeshy was upgraded),
#      compare the mtime of that file with that of the Zeshy config file. If
#      the latter is newer, the user modified it, so we need to run a diff;
#      otherwise, silently delete the Zeshy config file and let Zeshy re-
#      fabricate it for us.
#    * The user can opt to always have such config file silently deleted by
#      simply always using "config.local", instead. The downside is that
#      global variables may change names and they won't necessarily notice
#      immediately. (Or other such desynchronizations.) But probably worth it.
#    * Zeshy Global will need to look for "config.local" and, if extant,
#      source it *AFTER* sourcing "config". Fairly simple, eh?

# void startup_zeshy_version(void)
#
# Ensure the cached Zeshy version corresponds to the current Zeshy version. If
# not, interactively usher the current user into the upgrade process.
function startup_zeshy_version() {
    is_file "${ZESHY_USER_VERSION_FILE}" or
        get_zeshy_version > "${ZESHY_USER_VERSION_FILE}"
}

# ....................{ SETUP                              }....................
function setup_zeshy() {
    if is_shell_interactive
    then setup_if_interactive
    else noop
    fi
}

# ....................{ SETUP ~ interactive                }....................
# If this shell is attached to a terminal device, set terminal-specific options.
function setup_if_interactive() {
#   setup_mimetypes
#   setup_terminal
#   setup_theme_key_bindings
#   setup_theme_styles
    setup_theme_prompt
    setup_if_interactive_globals
    setup_if_interactive_installed
}

function setup_if_interactive_globals() {
    # Call getter functions internally caching globals quietly. Since we just
    # want to cache such globals here, discard function output.
    run_quietly get_pager_command

    # Absolute paths of the preferred command-line editor and pager.
    string_global\
        EDITOR="${EDITOR:-"$(get_first_command_path emacs vim nano ed)"}"
    string_global_export VISUAL="${VISUAL:-${EDITOR}}"
}

# Conditionally setup interactive-only commands, if installed.
function setup_if_interactive_installed() {
    is_installed keychain and setup_keychain
}

# --------------------( WASTELANDS                         )--------------------
#   setup_if_installed
# Conditionally setup non-interactive commands, if installed.
#function setup_if_installed() {
#    run_if_runnable setup_x
#}

#FIXME: Eventually, we'll have to add a setup hooks list and functions for
#adding setup hooks to such list. This is a hard requisite, as users may like to
#add new components not explicitly conceived of here. Assuming such a framework,
#no explicit tests are required here. It's also much easier to maintain, since
#it couples setup logic to the components implementing such functions.

# ....................{ SETUP ~ non-interactive            }....................
#function setup_if_non_interactive() {
#   print "process command name: $(get_process_command_name)"
#}

#   setup_interactive_gui_substitutions
#   else source "${ZESHY_HOME}/compile"
    #FIXME: Shift setting of "PAGER" to "terminal/output/pager".
#       PAGER="${PAGER:-"$(get_first_command_path less more)"}"
    # Set the default script name prior to all other logic, as any logic
    # raising an error requires this name for logging that error. Only do this
    # if the current process is not an interactive Zsh shell as, in that case,
    # the get_call_stack_root_basename() function dynamically inspects the script name from
    # the function call stack.
    # Strip the filetype from this script's basename, if present.
#   string_global_export ZESHY_SCRIPT_NAME="${$(get_process_command_name)%%.*}"

    # Default the script name to "zeshy", if "zsh".
#   is "${ZESHY_SCRIPT_NAME}" == zsh si and ZESHY_SCRIPT_NAME=zeshy
