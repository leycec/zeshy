#!/usr/bin/env zsh
# ====================[ help                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define an interactive help system for publishing Zeshy documentation.
#
# --------------------( TODO                               )--------------------

#FIXME: Woops. Turns out... this was all a bit of a c0ckup, including the
#current means with which we define alias, function, and global documentation.
#The core thrust of it is that Zeshy needs to formalize such documentation with
#one function call per Zeshy alias, function, and global to functions defined
#under "always/00-startup" associating the passed documentation with the passed
#alias, function, or global name: e.g.,
#
# string set_alias_documentation(string alias_name, string documentation)
# string set_function_documentation(string documentation)
# string set_global_documentation(string global_name, string documentation)
#
#Or ideally the more concise:
#
# string document_alias(string alias_name, string documentation)
# string document_function(string documentation) --OR--
# string document_function(string function_name, string documentation)
# string document_global(string global_name, string documentation)
#
#Note the function name needn't be passed, since it's readily parseable from
#the passed documentation.
#
#For alias and global names, we should *ADDITIONALLY* define convenience
#functions both defining and setting documentation for such aliases and globals
#in one fell swoop: e.g.,
#
# string list_global_export_documented(string documentation, string list_name)
# string string_global_export_documented(string documentation, string specifier)
#
#...where "specifier" is the typical "="-delimited variable typeset: e.g.,
#
#   string_global_export_documented 'Thisizniceglobal.' ZESHY_STRANG='Hmm.'
#
#We can't do this for functions, for obvious reasons. So, prefix all function
#definitions with a call to document_function(), using a literal heredoc so as
#to avoid unwanted interpolation: e.g.,
#
#   document_function <<'EOD'
#   string nice_function(void)
#
#   Oh.... what a nice function!
#   EOD
#   function nice_function() {
#       print 'This is all yer gettin'.'
#   }
#
#It's not quite Python's built-in support for docstrings, but, frankly, I've
#always felt such support to be extreme syntactic sugar anyway. The above
#method *ROCKS*: it's intuitive, it's concise, it's optional, and it still
#allows for conventional "#"-prefixed comments. Such comments won't be picked up
#as documentation, implying implementation-specific commentary can now be
#separated from function documentation without concern (e.g., "#FIXME" comments).

# * It seems fairly silly to reparse Zeshy scripts on each call to
#   print_zeshy_help(). Clearly, we should persist successfully parsed
#   documentation as a "map_global_export" to a script under "~/.zeshy/cache" --
#   perhaps entirely overwriting the map previously written to such script after
#   every successful parse? Hmm; actually, while that would probably work
#   perfectly fine as a first implementation, we would do considerably better to
#   simply append the newly parsed documentation as a new entry to such file.
#   That's actually quite straightforward... hmm; or is it? Yes! I think.
#   Using "${mapfile}", right? How about something resembling:
#   mapfile[${doc_cache_file}][-1]="\"${function_name}\" \"${(q)function_docs}\"
#)"
#   The idea here is to replace the suffixing ")" with the new entry. You know
#   what? This is overengineering. Probably more efficient and certainly
#   simpler to just overwrite such cache each time. *shrug* Let's ignore this
#   until it actually becomes a discernable bottleneck.
# * In any case, what's great about the cache idea is that we could (and *MUST*,
#   actually) seed such cache with initial values for synthesized functions
#   created during compilation that don't actually exist and hence can't be
#   tangibly parsed. See make_zeshy_functions() in "src/compile".
#   * *AH!* Wait. That would work, but it's terribly heavyweight; all we have to
#     do is define such functions with empty definitions in some placeholder
#     Zeshy script in the root overlay. Their only purpose is to provide
#     documentation; their empty definitions will be immediately overwritten by
#     make_zeshy_functions(). Yes... much cleaner.

#FIXME: The search algorithm for finding the exact documentation in a file
#corresponding to a function is actually not terribly hard:
#
#1. Find the function definition in such file. Assuming there exists only one
#   such definition, which there should, this is the first string matching
#   "^function ${function_name}\(\)$" in such file.
#2. If the line immediately preceding such definition matches "^# .*$", then:
#   a. Search backwards one line at a time, prepending each line to a list of
#      such lines *UNTIL* a line fails to match "^#( .*)?$".
#   b. Search forwards one line at a time starting at the line that fails to
#      match, shifting off each line that fails to match
#      "^# [a-z_]+ ${function_name}\(.*$" from such list *UNTIL* matching such
#      line.
#   c. Such list now contains the desired in-order documentation. Tad
#      complicated, but well within the scope of reasonable feasibility. Note
#      it's not safe to simply begin searching for the first line matching
#      "^# [a-z_]+ ${function_name}\(.*$" in the file, due to "#FIXME" comments,
#      "TODO" sections, and the fact that "# also that_function()." Also happens
#      to match.
#3. Otherwise, no documentation has been authored for such function yet. Throw
#   an exception.

# ....................{ ALIASES                            }....................
interactive_abbreviation {h}elp='print_zeshy_help'

# ....................{ GETTERS                            }....................
#FIXME: Shift elsewhere -- perhaps a new "zeshy/script" component. Hmm;
#alternately, we could simply rename this to
#get_zeshy_runnable_script(). It's concise; I like it. (Not entirely sure a new
#component is warranted for merely one function... We're heavyweight enough!)
# string get_zeshy_script_defining_runnable(string runnable_name)
#
# Get the absolute path of the Zeshy component defining the passed runnable.
function get_zeshy_script_defining_runnable() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one runnable name'
    string runnable_name="${1}"
    die_unless_zeshy_runnable "${runnable_name}"

    #FIXME: Implement map lookup here!
    die 'implement me'
}

# ....................{ PRINTERS                           }....................
#FIXME: Actually, it'd be great to accept general object names: which is to say,
#*ALSO* accept global variable names. We document such variables and hence
#should expose such documentation via the same interface here. While runnables
#and variables occupy different Zsh namespaces and hence could theoretically
#collide, no Zeshy runnables share the same name as a Zeshy variable; hence,
#searching for both is unambiguous here. That said, third-party Zeshy plugins
#could theoretically define poorly named runnables or variables contravening
#such standardization; so, conceivably we should search for and page both.

# string print_zeshy_help(string runnable_name)
#
# Print help documentation for the passed Zeshy-specific runnable (i.e., Zeshy
# alias or function).
function print_zeshy_help() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one runnable name'
    string\
        runnable_name="${1}" script_filename script_text\
        newline line_glob help_text
    die_unless_zeshy_runnable "${runnable_name}"

    # Get the absolute path of the Zeshy component defining such runnable.
    script_filename="$(get_zeshy_script_defining_runnable "${runnable_name}")"

    # Get the text contents of such component.
    script_text="$(get_file_text "${script_filename}")"

    # Newline character, abbreviated for ease of use.
    newline="${ZESHY_CHARACTER_NEWLINE}"

    # Glob matching any number of non-newline characters followed by a newline,
    # thus matching the rest of a line.
    line_glob="[^${newline}]#${newline}"

    # If such runnable is a function, collect such function's documentation.
    if is_function "${runnable_name}"; then
        if is "${script_text}" ==\
            *${newline}${newline}('#'${~line_glob})#(#b)('# '[a-z_]##" ${runnable_name}("${~line_glob})(('#'${~line_glob})#)"function ${runnable_name}() {"* si
        #FIXME: It'd be *EXCEPTIONALLY* nice to colorize output.
        then help_text="${match[1]}${match[2]}"
        else die "${runnable_name}() undocumented, unfortunately"
        fi
    # Else such runnable is an alias; collect such alias' documentation.
    else
        #FIXME: Don't bother implementing me, yet; get function help working
        #first, please.
        noop
    fi

    #FIXME: Strip off substrings matching "^# " and "^#$" from each line. It'd
    #be great to define a new remove_string_line_prefix_matches() function, probably
    #leveraging a new remove_list_prefix_matches() function. Though, wouldn't a
    #slightly simpler remove_string_line_matches() function suffice?

    #FIXME: We should actually page such documentation normalized to the current
    #terminal width. "nroff" should help, no? Be nice to define a utility
    #function implementing repagination: perhaps called "paginate_string", yes?
    # Page such help documentation.
    output_string_paged "${help_text}"
}

# --------------------( WASTELANDS                         )--------------------
    # Since we should never get here, throw an exception.
#   is_alias "${function_name}".
#   die "\"${runnable_name}\" neither an alias or function, unexpectedly"
