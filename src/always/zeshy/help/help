#!/usr/bin/env zsh
# ====================[ help                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define an interactive help system for publishing Zeshy documentation.
#
# --------------------( TODO                               )--------------------
# * O.K.; help strings should be documented in zsh's built-in run-help format,
#   printed by typing <Esc-h>. This appears to involve "perl", but I can't quite
#   be sure yet. See the preamble for "man zshcontrib." O.K.; there's a perl
#   script at "/usr/share/zsh/5.0.0/Util/helpfiles" run like so:
#      man zshbuiltins | colcrt - | helpfiles
#   That (somehow) splits apart the manpage subsection specific to each zsh
#   builtin into a help file for such builtin subsequently accessed when typing
#   <Esc-h>. Interestingly, <Esc-h> is bound by default in the ZLE to run a
#   function run-help(). So, replacing such function with a Zeshy-specific
#   function suffices to implement such help. The perl script above provides a
#   helpful default implementation for such function. It'd be nice to redefine
#   this script as pure-Zeshy, honestly. It's not terribly heavy-weight: only
#   about 100 lines of genuine line parsing code, all readily Zeshifiable. Since
#   speed is not an issue (we only need to slurp "man zshbuiltins" once on every
#   zsh update -- right; so, we'll need a bit of caching, I suppose), it's !very
#   doable.
# * Hmm; scratch that. For the moment, just rely on "helpfiles". We'll still
#   need to implement caching ourselves, but that's no worry.
# * Woops! Obviously, <Esc-h> doesn't work under Vi[M] emulation. We can still
#   test it as root, but... Hmm. We'll need to selectively redefine such
#   binding under such emulation. *sigh*
# * O.K.; I'd love to implement this, but it's all a bit heavy for the moment.
#   Just push on ahead with the current implementation, keeping in mind that it
#   would be helpful to eventually support run-help().
# * However, I'll note that this is all a bit overkill, for the moment. We'd
#   need to rewrite documentation in the "man" nroff format... hmm; wait. No; no
#   documentation-rewriting required. The sample run-help() function above
#   simply invokes "more" on individual files. Frankly, both "man" and "info"
#   suck, so I'm disinclined to want to format documentation in their formats.
#   Fortunately, it looks like we won't need to!

#FIXME: We probably want to "gzip" each individual documentation string, to
#reduce both load times on shell startup and runtime memory consumption. Is
#"gzip" the ideal solution for short runs of English text? It's certainly the
#most widespread; but, perhaps LZMA-based compression can do substantially
#better.
#FIXME: That said, even gzipping is a temporary solution. Ideally, in the long
#run, we want to use an entirely disk-based zsh-fueled key-value store and just
#perform on-disk lookups on each call to print_zeshy_help(). That's a
#demonstrably superior solution, long-term. Research whether there exist
#key-value store implementations in bash and zsh. Even if there do, such
#solutions are unlikely to be optimal. Research the theory underlying efficient
#key-value stores. Perhaps take a look at Tokyo Cabinet and friends?
#FIXME: *OH*. There appears to be an optional zsh "db" interface to "gdbm".
#That would certainly be ideal. Unfortunately, my local installation doesn't
#appear to have compiled support for it despite having enabled USE flag "gdbm";
#research! Ah; nope. zsh only supports "gdbm" to the extent that it caches
#completions against GDBM; that's it. No front-facing module, I'm afraid. Bash
#also fails to provide built-in support for "gdbm".
#FIXME: O.K. I'm convinced. "bkvs" implements a rudimentary filesystem-based
#key-value store in pure-Bash. What do you think? It only consists of one file,
#so it's tremendously lightweight. See:
#https://code.google.com/p/bkvs/source/browse/bkvs
#It seems quite a fun idea; we could certainly devote three directories
#"~/.zeshy/cache/documentation/{alias,function,global}" to three different
#filesystem-based stores corresponding to the three fundamental zsh namespaces.
#Naturally, just initialize with "command rm -r" prior to sourcing during
#compilation. I'll be honest: this kicks the heck out of the above in-memory
#map idea.
#FIXME: Interesting. We could just "tar.gz" the whole thing rather than
#implement such store as a directory. (Perhaps provide both? They serve different
#purposes.) Nice! Yes. This is probably the way to go; tar supports extraction of
#the exact desired file: e.g.,
#  tar -xzf foo.tar.gz blah.txt
#There we go. Have each documentation string as an individual file in a
#compressed tarball. Bam! Sweeeeeeeet. We'll naturally need to construct such
#archive during compilation. Shouldn't be terribly difficult:
#
#* Create a new temporary directory "documentation" under "~/.zeshy/tmp".
#  * Yes, this path; don't bother with "/tmp" or "~/tmp", as the logic needs to
#    be simplified to work cleanly and concisely under the limited subset of Zeshy
#    we have available during compilation.
#* Have document_function() write each documentation string as a new file to such
#  temporary directory.
#* Tarball the entire directory into
#  "~/.zeshy/cache/documentation/functions.tar.gz". It'd be nice to choose the
#  optimal format available under the current system for indexed text retrieval.
#  (Is any format optimal for such purposes?)
#
#FIXME: Ah-ha! Consideration of indexing led me to "dar", a substantially
#improved "tar" supporting implicit fast file retrieval via indexing. That said,
#just make "dar" an optional but recommended dependency: use "dar" if available;
#otherwise, default to "tar".
#FIXME: That said, the "zeshy" ebuild should force-install "dar" to ensure
#optimum behavior. There's a stable "dar" ebuild, so... there you go! Speaking
#of, perhaps we should get crackin' on that "zeshy" ebuild, eh?

# ....................{ PRINTERS                           }....................
#FIXME: Shift to a new "usage" component, as this really doesn't belong here.
document_function '
string print_zeshy_help_usage(void)

Print a human-readable synopsis of all command-line options accepted by the
"zeshy" wrapper script.
'
function print_zeshy_help_usage() {
    # Validate sanity.
    die_if_args

    #FIXME: Option printing is somewhat cumbersome and certainly repetitive. It
    #would be advantageous to abstract such printing into a series of arrays
    #iteractively parsed to dynamically construct such output. Probably easiest
    #to harvest the set of such options from actual output rather than the
    #implementation below, for obvious reasons!
    #FIXME: Actually, it'd be great to abstract this into a template callable by
    #third-party Zeshy scripts for use in printing help usage. The great thing
    #about that is the consistency of output: all Zeshy scripts including Zeshy
    #itself would share the same help output format. In such case, perhaps
    #rename "print_zeshy_help_usage" everywhere to simply print_usage(), yes?
    #We'll have to contemplate the data structure format. It certainly won't be
    #simple, but should be as simple as possible.

    # Print such usage.
    print_string_colored "${ZESHY_COLOR_STYLE[print_usage.usage]}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]}: ${ZESHY_COLOR_STYLE[print_usage.command_name]}zeshy ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}OPTION${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}... ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}FILE ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}ARGUMENT${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]

${ZESHY_COLOR_STYLE[print_usage.usage_text]}Open a new zsh shell running Zeshy. If passed an optional FILE, source such path
as a Zeshy zsh shell script passed the passed ARGUMENTs.

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Main options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}i${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}interactive      ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive non-login zsh shell
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}l${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}login            ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive login zsh shell
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}h${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}help             ${ZESHY_COLOR_STYLE[print_usage.option_text]}print this help string and exit
      ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}version          ${ZESHY_COLOR_STYLE[print_usage.option_text]}print a version string and exit
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_comma]},  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--                 ${ZESHY_COLOR_STYLE[print_usage.option_text]}stop parsing options

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Parameterized options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}c ${ZESHY_COLOR_STYLE[print_usage.option_value]}COMMAND${ZESHY_COLOR_STYLE[print_usage.option_comma]},            ${ZESHY_COLOR_STYLE[print_usage.option_text]}run the passed Zeshy shell command (e.g., \"is_dir /\")
     ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}command${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}COMMAND
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}o ${ZESHY_COLOR_STYLE[print_usage.option_value]}OPTION${ZESHY_COLOR_STYLE[print_usage.option_comma]},             ${ZESHY_COLOR_STYLE[print_usage.option_text]}enable the passed zsh shell option (\"man zshoptions\")
     ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}option${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}OPTION

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Startup options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}v${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}verbose          ${ZESHY_COLOR_STYLE[print_usage.option_text]}print debug statements during Zeshy startup
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}zeshy-dot-dir${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}PATH   ${ZESHY_COLOR_STYLE[print_usage.option_text]}change Zeshy's dot directory (defaults to \"~/.zeshy\")
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}no-zeshy-dot-dir     ${ZESHY_COLOR_STYLE[print_usage.option_text]}ignore Zeshy's dot directory and files therein; hence,
                            run Zeshy with default settings and no digest file
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}compile-digest       ${ZESHY_COLOR_STYLE[print_usage.option_text]}recompile Zeshy's digest, even if up-to-date
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}compile-digest-if-zeshy-home-changed
                         ${ZESHY_COLOR_STYLE[print_usage.option_text]}recompile Zeshy's digest if Zeshy's codebase changed"
}

#FIXME: Define print_alias_documentation() and print_global_documentation().
document_function '
string print_function_documentation(string function_name)

Print documentation for the passed function . If no previous call to
document_function() defined such documentation, throw an exception.
'
#FIXME: Actually implement me!
function print_function_documentation() {
}

#FIXME: Actually, it'd be great to accept general object names: which is to say,
#*ALSO* accept global variable names. We document such variables and hence
#should expose such documentation via the same interface here. While runnables
#and variables occupy different zsh namespaces and hence could theoretically
#collide, no Zeshy runnables share the same name as a Zeshy variable; hence,
#searching for both is unambiguous here. That said, third-party Zeshy plugins
#could theoretically define poorly named runnables or variables contravening
#such standardization; so, conceivably we should search for and page both, much
#as we currently do for ebuild names and description.

document_function '
string print_zeshy_help(string runnable_name)

Print help documentation for the passed Zeshy-specific runnable (i.e., Zeshy
alias or function).
'
function print_zeshy_help() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one runnable name'
    string\
        runnable_name="${1}" script_filename script_text\
        newline line_glob help_text
    die_unless_zeshy_runnable "${runnable_name}"

    # Get the absolute path of the Zeshy component defining such runnable.
    script_filename="$(get_zeshy_script_defining_runnable "${runnable_name}")"

    # Get the text contents of such component.
    script_text="$(get_file_text "${script_filename}")"

    # Newline character, abbreviated for ease of use.
    newline="${ZESHY_ASCII_NEWLINE}"

    # Glob matching any number of non-newline characters followed by a newline,
    # thus matching the rest of a line.
    line_glob="[^${newline}]#${newline}"

    # If such runnable is a function, collect such function's documentation.
    if is_function "${runnable_name}"; then
        if is "${script_text}" ==\
            *${newline}${newline}('#'${~line_glob})#(#b)('# '[a-z_]##" ${runnable_name}("${~line_glob})(('#'${~line_glob})#)"function ${runnable_name}() {"* si
        #FIXME: It'd be *EXCEPTIONALLY* nice to colorize output.
        then help_text="${match[1]}${match[2]}"
        else die "${runnable_name}() undocumented, unfortunately"
        fi
    # Else such runnable is an alias; collect such alias' documentation.
    else
        #FIXME: Don't bother implementing me, yet; get function help working
        #first, please.
        noop
    fi

    #FIXME: Strip off substrings matching "^# " and "^#$" from each line. It'd
    #be great to define a new remove_string_line_prefix_matches() function, probably
    #leveraging a new remove_list_prefix_matches() function. Though, wouldn't a
    #slightly simpler remove_string_line_matches() function suffice?

    #FIXME: We should actually page such documentation normalized to the current
    #terminal width. "nroff" should help, no? Be nice to define a utility
    #function implementing repagination: perhaps called "paginate_string", yes?
    # Page such help documentation.
    page_string "${help_text}"
}

# ....................{ MAKERS                             }....................
run_hook_on_zeshy_precompile precompile_zeshy_documentation

document_function '
void precompile_zeshy_documentation(void)

Compile Zeshy''s documentation after compiling Zeshy''s digest file and hence
calling all applicable documentation functions in the current codebase (e.g.,
document_function()). For efficiency, serialize documentation to an on-disk key
value store mapping Zeshy''s alias, global, and function names to previously set
documentation strings.
'
function precompile_zeshy_documentation() {
    # Validate sanity.
    die_if_args
    string documentation

    #FIXME: Make key-value stores here. First, we'll need to add a new global
    #path to "src/if_config/zeshy"... O.K.; we've got the requisite globals. Now
    #we'll need a rudimentary working directory-based key-value store.
    #FIXME: We'll need to *NON-RECURSIVELY* remove all *PLAIN FILES* in each
    #such directory, first. Since this is potentially dangerous, we should
    #*ABSOLUTELY* create a new "always/zeshy/dot_dir" component handling such
    #operations. How about a function in such component entitled
    #remove_zeshy_dot_dir_subdir_files()? Such function should perform sanity
    #checks, including:
    #
    #* The passed subdirectory is *ACTUALLY* a subdirectory of the current
    #  user's Zeshy dot directory.
    #* Ah-ha! Here's the best check: we should forcefully change the mtime of
    #  both the subdirectory and all files in such subdirectory at the end of
    #  *THIS* function to the same mtime as the current Zeshy digest file.
    #  *ONLY* delete files with such mtime. Yes! That's great. Exceptionally
    #  safe. We'll probably want a corresponding function in
    #  "always/zeshy/dot_dir" to do so, perhaps named something like
    #  synchronize_zeshy_dot_dir_path_modification_time() accepting only one
    #  argument -- the path whose mtime is to be synchronized. This function
    #  should, in turn, depend on a new "path/time" function accepting two
    #  paths -- a source path to get the mtime from and a target path whose
    #  mtime will be set to that of the former. Sweetness. How about
    #  set_path_modification_time_from_path()?
    #* Don't worry about matching only plain files -- just non-directory files
    #  suffices. The above checks are decently strong and should prevent all
    #  accidental mischief.

    # Make one key-value store for each type namespace.
#   make_key_value_store_dir "${ZESHY_DOT_CACHE_DOCUMENTATION_FUNCTION_DIR}"

    # For each documented function, ...
    for function_name (${(k)ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}) {
#       print "function_name: ${function_name}"
        # Strip prefixing and suffixing whitespace from such documentation.
        # Dismantled, this is:
        #
        # * "//", greedily removing all matched substrings.
        # * "(#s)", matching the start of such string.
        # * "(#e)", matching the end of such string.
        # * "[[:space:]]##", matching one or more whitespace characters.
        documentation="${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name}]//((#s)[[:space:]]##|[[:space:]]##(#e))}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Since we have the entirety of Zeshy at our disposal here, it would
    #be quite nice (not to mention appropriate) to colorify the output.
    # Colorize such usage.
#   string color_punctuation="${ZESHY_COLOR[grey_bold]}"
#   string\
#       color_help_title="${ZESHY_COLOR[grey_bold]}"\
#       color_help_colon="${ZESHY_COLOR[${ZESHY_COLOR_IGNORABLE}]}"\
#       color_help_description="${ZESHY_COLOR[white_bold_italic]}"\
#       color_command_name="${ZESHY_COLOR[cyan_bold]}"\
#       color_arg_brace="${ZESHY_COLOR[cyan]}"\
#       color_arg_name="${ZESHY_COLOR[cyan_bold]}"\
#       color_arg_ellipsis="${color_punctuation}"\
#       color_heading_title="${ZESHY_COLOR[magenta_bold]}"\
#       color_heading_colon="${color_punctuation}"\
#       color_option_dash="${ZESHY_COLOR[blue]}"\
#       color_option_name="${ZESHY_COLOR[blue_bold]}"\
#       color_option_equals="${ZESHY_COLOR[green]}"\
#       color_option_value="${ZESHY_COLOR[green_bold]}"\
#       color_option_comma="${color_punctuation}"\
#       color_option_description="${ZESHY_COLOR[white_italic]}"

#Consider renaming to simply print_zeshy_usage()
#FUXME: Woops. Turns out... this was all a bit of a c0ckup, including the
#current means with which we define alias, function, and global documentation.
#The core thrust of it is that Zeshy needs to formalize such documentation with
#one function call per Zeshy alias, function, and global to functions defined
#under "always/00-startup" associating the passed documentation with the passed
#alias, function, or global name: e.g.,
#
# string set_alias_documentation(string alias_name, string documentation)
# string set_function_documentation(string documentation)
# string set_global_documentation(string global_name, string documentation)
#
#Or ideally the more concise:
#
# string document_alias(string alias_name, string documentation)
# string document_function(string documentation) --OR--
# string document_function(string function_name, string documentation)
# string document_global(string global_name, string documentation)
#
#Note the function name needn't be passed, since it's readily parseable from
#the passed documentation.
#
#For alias and global names, we should *ADDITIONALLY* define convenience
#functions both defining and setting documentation for such aliases and globals
#in one fell swoop: e.g.,
#
# string list_global_export_documented(string documentation, string list_name)
# string string_global_export_documented(string documentation, string specifier)
#
#...where "specifier" is the typical "="-delimited variable typeset: e.g.,
#
#   string_global_export_documented 'Thisizniceglobal.' ZESHY_STRANG='Hmm.'
#
#We can't do this for functions, for obvious reasons. So, prefix all function
#definitions with a call to document_function(), using a literal heredoc so as
#to avoid unwanted interpolation: e.g.,
#
#   document_function <<'EOD'
#   string nice_function(void)
#
#   Oh.... what a nice function!
#   EOD
#   function nice_function() {
#       print 'This is all yer gettin'.'
#   }
#
#It's not quite Python's built-in support for docstrings, but, frankly, I've
#always felt such support to be extreme syntactic sugar anyway. The above
#method *ROCKS*: it's intuitive, it's concise, it's optional, and it still
#allows for conventional "#"-prefixed comments. Such comments won't be picked up
#as documentation, implying implementation-specific commentary can now be
#separated from function documentation without concern (e.g., "#FUXME" comments).
# * It seems fairly silly to reparse Zeshy scripts on each call to
#   print_zeshy_help(). Clearly, we should persist successfully parsed
#   documentation as a "map_global_export" to a script under "~/.zeshy/cache" --
#   perhaps entirely overwriting the map previously written to such script after
#   every successful parse? Hmm; actually, while that would probably work
#   perfectly fine as a first implementation, we would do considerably better to
#   simply append the newly parsed documentation as a new entry to such file.
#   That's actually quite straightforward... hmm; or is it? Yes! I think.
#   Using "${mapfile}", right? How about something resembling:
#   mapfile[${doc_cache_file}][-1]="\"${function_name}\" \"${(q)function_docs}\"
#)"
#   The idea here is to replace the suffixing ")" with the new entry. You know
#   what? This is overengineering. Probably more efficient and certainly
#   simpler to just overwrite such cache each time. *shrug* Let's ignore this
#   until it actually becomes a discernable bottleneck.
# * In any case, what's great about the cache idea is that we could (and *MUST*,
#   actually) seed such cache with initial values for synthesized functions
#   created during compilation that don't actually exist and hence can't be
#   tangibly parsed. See precompile_zeshy_functions() in "src/compile".
#   * *AH!* Wait. That would work, but it's terribly heavyweight; all we have to
#     do is define such functions with empty definitions in some placeholder
#     Zeshy script in the root overlay. Their only purpose is to provide
#     documentation; their empty definitions will be immediately overwritten by
#     precompile_zeshy_functions(). Yes... much cleaner.

#FUXME: The search algorithm for finding the exact documentation in a file
#corresponding to a function is actually not terribly hard:
#
#1. Find the function definition in such file. Assuming there exists only one
#   such definition, which there should, this is the first string matching
#   "^function ${function_name}\(\)$" in such file.
#2. If the line immediately preceding such definition matches "^# .*$", then:
#   a. Search backwards one line at a time, prepending each line to a list of
#      such lines *UNTIL* a line fails to match "^#( .*)?$".
#   b. Search forwards one line at a time starting at the line that fails to
#      match, shifting off each line that fails to match
#      "^# [a-z_]+ ${function_name}\(.*$" from such list *UNTIL* matching such
#      line.
#   c. Such list now contains the desired in-order documentation. Tad
#      complicated, but well within the scope of reasonable feasibility. Note
#      it's not safe to simply begin searching for the first line matching
#      "^# [a-z_]+ ${function_name}\(.*$" in the file, due to "#FUXME" comments,
#      "TODO" sections, and the fact that "# also that_function()." Also happens
#      to match.
#3. Otherwise, no documentation has been authored for such function yet. Throw
#   an exception.

#Open a Zeshy-fortified zsh shell with the passed OPTIONs. Source the optionally
#passed FILE as a Zeshy script passed the passed ARGUMENTs.
# ....................{ GETTERS                            }....................
#FUXME: Shift elsewhere -- perhaps a new "zeshy/script" component. Hmm;
#alternately, we could simply rename this to
#get_zeshy_runnable_script(). It's concise; I like it. (Not entirely sure a new
#component is warranted for merely one function... We're heavyweight enough!)

# string get_zeshy_script_defining_runnable(string runnable_name)
#
# Get the absolute path of the Zeshy component defining the passed runnable.
#function get_zeshy_script_defining_runnable() {
#    # Validate passed arguments.
#    die_unless_one_arg 'expected one runnable name'
#    string runnable_name="${1}"
#    die_unless_zeshy_runnable "${runnable_name}"
#
#    #FUXME: Implement map lookup here!
#    die 'implement me'
#}

#Even if zsh did, however, there exist no guarantees
#it is unclear whether requiring zsh be
#compiled with support for such store as an external Zeshy dependency
#Print the documentation previously associated with the passed function by a call
#to document_function() call.

#Help options:
#  load zeshy by recursively sourcing the zeshy codebase
#                            rather than autoloading a (re)compiled digest file
    # Since we should never get here, throw an exception.
#   is_alias "${function_name}".
#   die "\"${runnable_name}\" neither an alias or function, unexpectedly"
