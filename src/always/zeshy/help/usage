#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle `zeshy` usage messages, usually in response to unrecognized command-line
options _or_ options `-h` or `--help`.
-/-

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_zeshy_help_usage(void)

Print a human-readable synopsis of all command-line options accepted by `zeshy`.
/---
function print_zeshy_help_usage() {
    # Validate sanity.
    die_if_args

    #FIXME: Option printing is somewhat cumbersome and certainly repetitive. It
    #would be advantageous to abstract such printing into a series of arrays
    #iteractively parsed to dynamically construct such output. Probably easiest
    #to harvest the set of such options from actual output rather than the
    #implementation below, for obvious reasons!
    #FIXME: Actually, it'd be great to abstract this into a template callable by
    #third-party zeshy scripts for use in printing help usage. The great thing
    #about that is the consistency of output: all zeshy scripts including zeshy
    #itself would share the same help output format. In such case, perhaps
    #rename "print_zeshy_help_usage" everywhere to simply print_usage(), yes?
    #We'll have to contemplate the data structure format. It certainly won't be
    #simple, but should be as simple as possible.

    # Data structures passed to print_command_usage() below.
    map usage_overview; usage_overview=(
        command 'zeshy'
        args    '[OPTION]... [FILE [ARGUMENT]...]'
        synopsis
'Open a new zsh shell running zeshy. If passed an optional FILE, source such path
as a zeshy zsh shell script passed the passed ARGUMENTs.'
    )

    list usage_options_main; usage_options_main=(
        'Main options'
        'i' 'interactive' 'open an interactive non-login shell'
        'l' 'login'       'open an interactive login shell'
        'h' 'help'        'print this help string and exit'
        ''  'version'     'print a version string and exit'
        'v' 'verbose'     'print debug statements (same as --debug)'
        ''  '--'          'stop parsing options'
    )

    list usage_options_parameterized; usage_options_parameterized=(
        'Parameterized options'
        'c COMMAND' 'command=COMMAND' 'run the passed zeshy shell command (e.g., "is_dir /")'
        'o OPTION'  'option=OPTION'   'enable the passed zsh shell option ("man zshoptions")'
    )

    list usage_options_startup; usage_options_startup=(
        'Startup options'
        '' 'zeshy-dot-dir=PATH' 'change zeshy''s dot directory (defaults to "~/.zeshy")'
        '' 'release'            'switch to zeshy''s optimized digest (default)'
        '' 'debug'              'switch to zeshy''s developer digest'
        '' 'compile-digest'     'recompile zeshy''s digest (even if already up-to-date)'
        '' 'compile-digest-if-zeshy-changed'
                                'recompile zeshy''s digest if zeshy''s codebase changed'
    )

    # Print such usage.
    print_command_usage\
        usage_overview\
        usage_options_main usage_options_parameterized usage_options_startup
}

#FIXME: Document. Oh, boy... For simplicity, let's largely document this by
#example, eh?

function print_command_usage() {
    # Validate passed arguments.
    die_unless_args\
        'expected one overview map name and zero or more options list names'
    string\
        overview_map_name__pcu="${1}"\
        usage__pcu\
        command_name__pcu\
        command_args__pcu\
        command_synopsis__pcu
    die_unless_map "${overview_map_name__pcu}"
    shift_arg

    # Mandatory command to print usage for. If such map lacks such key, this
    # implicitly throws an exception.
    command_name__pcu="$(get_map_key_value\
        "${overview_map_name__pcu}" 'command')"

    # Colored string describing such map.
    usage__pcu+="${ZESHY_COLOR_STYLE[print_usage.usage]-}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]-}: ${ZESHY_COLOR_STYLE[print_usage.command_name]-}${command_name__pcu}"

    # If such map contains optional command arguments, append such arguments.
    if { command_args__pcu="$(get_map_key_value_if_found\
        "${overview_map_name__pcu}" 'args')" } {
        #FIXME: It'd be nice to extend replace_string_glob_matches_with_string()
        #to accept *MULTIPLE* glob string pairs. This is certainly feasible and
        #should remain reasonably efficient, given a single eval() statement.
        #(No looping required, I should imagine.)
        #FIXME: It'd be nice to perform a modest amount of pretty printing in
        #the event that such arguments exceed the width of the current line.
        #Shouldn't be terribly difficult; just requires a bit of consideration.

        # Prefix all braces, ellipses, and words in such arguments with their
        # corresponding color styles. Append the result to the current string.
        usage__pcu+=" ${${${command_args__pcu//(#m)[\[\]]/${ZESHY_COLOR_STYLE[print_usage.arg_brace]}${match[1]}}//.../${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...}//(#m)[[:alpha:]]##/${ZESHY_COLOR_STYLE[print_usage.arg_name]}${match[1]}}"
    }

    # This completes the usage line.
    usage__pcu+="${ZESHY_ASCII_NEWLINE}"

    # If such map contains an optional command synopsis, append such synopsis.
    if { command_synopsis__pcu="$(get_map_key_value_if_found\
        "${overview_map_name__pcu}" 'synopsis')" } {
        usage__pcu+="${ZESHY_ASCII_NEWLINE}${ZESHY_COLOR_STYLE[print_usage.usage_text]}${command_synopsis__pcu}${ZESHY_ASCII_NEWLINE}"
    }

    # For each options list, append all options in such list.
    string\
        options_list_name__pcu\
        options_heading__pcu\
        option_short__pcu\
        option_long__pcu\
        option_text__pcu
    integer options_list_size__pcu
    for options_list_name__pcu ("${@}") {
        # Size of such list.
        options_list_size__pcu="$(get_list_size "${options_list_name__pcu}")"

        # If such size is *NOT* at least 4 and (excluding the leading heading) a
        # multiple of three, throw an exception.
        ((   options_list_size__pcu >= 4 &&
            (options_list_size__pcu - 1) / 3. == 1 )) or die\
            "list \"${options_list_name__pcu}\" contains ${options_list_size__pcu} elements rather than a heading and one or more triples"

        # Append the heading for such options.
        options_heading__pcu="$(get_list_head "${options_list_name__pcu}")"
        usage__pcu+="${ZESHY_ASCII_NEWLINE}${ZESHY_COLOR_STYLE[print_usage.heading_title]}${options_heading__pcu}${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:${ZESHY_ASCII_NEWLINE}"

        # For each trifecta of short and long options and option text, append
        # the holy triumvurate of shame!
        for option_short__pcu option_long__pcu option_text__pcu (
            "${${(@P)options_list_name__pcu}[2,-1]}") {
            # If such option has a short version, append such version.
            if is -n "${option_short__pcu}" si {
                usage__pcu+="  -${option_short__pcu#-}"
            }
        }
    }

    # Print such usage paged.
    page_string "${usage__pcu}"

    #FIXME: Excise!
    # Print such usage.
    print_string_colored "${ZESHY_COLOR_STYLE[print_usage.usage]}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]}: ${ZESHY_COLOR_STYLE[print_usage.command_name]}zeshy ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}OPTION${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}... ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}FILE ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}ARGUMENT${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]

${ZESHY_COLOR_STYLE[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
as a zeshy zsh shell script passed the passed ARGUMENTs.

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Main options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}i${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}interactive      ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive non-login zsh shell
}

    # Print such usage.
    print_string_colored "${ZESHY_COLOR_STYLE[print_usage.usage]}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]}: ${ZESHY_COLOR_STYLE[print_usage.command_name]}zeshy ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}OPTION${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}... ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}FILE ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}ARGUMENT${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]

${ZESHY_COLOR_STYLE[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
as a zeshy zsh shell script passed the passed ARGUMENTs.

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Main options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}i${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}interactive      ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive non-login zsh shell
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}l${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}login            ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive login zsh shell
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}h${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}help             ${ZESHY_COLOR_STYLE[print_usage.option_text]}print this help string and exit
      ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}version          ${ZESHY_COLOR_STYLE[print_usage.option_text]}print a version string and exit
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_comma]},  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--                 ${ZESHY_COLOR_STYLE[print_usage.option_text]}stop parsing options

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Parameterized options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}c ${ZESHY_COLOR_STYLE[print_usage.option_value]}COMMAND${ZESHY_COLOR_STYLE[print_usage.option_comma]},            ${ZESHY_COLOR_STYLE[print_usage.option_text]}run the passed zeshy shell command (e.g., \"is_dir /\")
     ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}command${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}COMMAND
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}o ${ZESHY_COLOR_STYLE[print_usage.option_value]}OPTION${ZESHY_COLOR_STYLE[print_usage.option_comma]},             ${ZESHY_COLOR_STYLE[print_usage.option_text]}enable the passed zsh shell option (\"man zshoptions\")
     ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}option${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}OPTION

${ZESHY_COLOR_STYLE[print_usage.heading_title]}Startup options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}v${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}verbose          ${ZESHY_COLOR_STYLE[print_usage.option_text]}print debug statements during zeshy startup
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}zeshy-dot-dir${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}PATH   ${ZESHY_COLOR_STYLE[print_usage.option_text]}change zeshy's dot directory (defaults to \"~/.zeshy\")
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}no-zeshy-dot-dir     ${ZESHY_COLOR_STYLE[print_usage.option_text]}ignore zeshy's dot directory and files therein; hence,
                            run zeshy with default settings and no digest file
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}compile-digest       ${ZESHY_COLOR_STYLE[print_usage.option_text]}recompile zeshy's digest, even if up-to-date
  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}compile-digest-if-zeshy-home-changed
                         ${ZESHY_COLOR_STYLE[print_usage.option_text]}recompile zeshy's digest if zeshy's codebase changed"
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Actually, we really need a 
        #FUXME: Implement such exception handler.

        #FUXME: Implement such iterator. We'll want to 
#       for_list_elements_in_range\
#           "${options_list_name__pcu}" 2 -1\
#           option_short__pcu option_long__pcu option_text__pcu\
#           ''
#       die_unless_list "${options_list_name__pcu}"

        #FUXME: Not right, obviously. Parse such string apart. Actually, just
        #use a series of global string replacements. Should be fairly simple.
#       overview__pcu+=" ${command_args__pcu}"

    # If such map lacks mandatory key-value pairs, throw an exception.
#       'v' 'verbose'           'print optional debug statements'
#       '' 'release'            'switch to zeshy''s optimized digest (default)'
#       '' 'debug'              'switch to zeshy''s developer digest'
