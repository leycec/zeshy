#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle `zeshy` usage messages, usually in response to unrecognized command-line
options _or_ options `-h` or `--help`.
-/-

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_zeshy_help_usage(void)

Print a human-readable synopsis of all command-line options accepted by `zeshy`.
/---
function print_zeshy_help_usage() {
    # Validate sanity.
    die_if_args

    #FIXME: Option printing is somewhat cumbersome and certainly repetitive. It
    #would be advantageous to abstract such printing into a series of arrays
    #iteractively parsed to dynamically construct such output. Probably easiest
    #to harvest the set of such options from actual output rather than the
    #implementation below, for obvious reasons!
    #FIXME: Actually, it'd be great to abstract this into a template callable by
    #third-party zeshy scripts for use in printing help usage. The great thing
    #about that is the consistency of output: all zeshy scripts including zeshy
    #itself would share the same help output format. In such case, perhaps
    #rename "print_zeshy_help_usage" everywhere to simply print_usage(), yes?
    #We'll have to contemplate the data structure format. It certainly won't be
    #simple, but should be as simple as possible.

    # Data structures passed to print_command_usage() below.
    map usage_overview; usage_overview=(
        command  'zeshy'
        args     '[OPTION]... [FILE [ARGUMENT]...]'
        synopsis 'Open a new zsh shell running zeshy. If passed an optional FILE, source such path as a zeshy shell script passed the passed ARGUMENTs.'
    )

    list usage_options_main; usage_options_main=(
        'Main options'
        'i' 'interactive' 'open an interactive non-login shell'
        'l' 'login'       'open an interactive login shell'
        'h' 'help'        'print this help string and exit'
        ''  'version'     'print a version string and exit'
        'v' 'verbose'     'print debug statements (same as --debug)'
        ''  '--'          'cease parsing options'
    )

    list usage_options_parameterized; usage_options_parameterized=(
        'Parameterized options'
        'c COMMAND' 'command=COMMAND' 'run the passed zeshy shell command (e.g., "is_dir /")'
        'o OPTION'  'option=OPTION'   'enable the passed zsh shell option ("man zshoptions")'
    )

    list usage_options_startup; usage_options_startup=(
        'Startup options'
        '' 'zeshy-dot-dir=PATH' 'change zeshy''s dot directory (defaults to "~/.zeshy")'
        '' 'release'            'switch to zeshy''s optimized digest (default)'
        '' 'debug'              'switch to zeshy''s developer digest'
        '' 'compile-digest'     'recompile zeshy''s digest (even if already up-to-date)'
        '' 'compile-digest-if-zeshy-changed'
                                'recompile zeshy''s digest if zeshy''s codebase changed'
    )

    # Print such usage.
    print_command_usage\
        usage_overview\
        usage_options_main usage_options_parameterized usage_options_startup
}

#FIXME: Document. Oh, boy... For simplicity, let's largely document this by
#example, eh?
#FIXME: Consider splitting into two functions: print_command_usage_overview()
#and print_command_usage_options().

declare_function_with_stdin <<'/---'
string print_command_usage(
    string overview_map_name,
    string options_list_name1, string options_list_name2, ...)

Print *command usage* (i.e., a string documenting the command-line interface for
such command) from the passed overview map and options lists: e.g.,

.print_command_usage()
==========================================
[source]
------------------------------------------
>>> print_command_usage ...
------------------------------------------
==========================================

== Overview Map ==

== Options Lists ==
/---
function print_command_usage() {
    # Validate passed arguments.
    die_unless_args\
        'expected one overview map name and zero or more options list names'
    string\
        overview_map_name__pcu="${1}"\
        usage__pcu\
        command_name__pcu\
        command_args__pcu\
        command_synopsis__pcu\
        option_text_pcre_wrapper__pcu\
        ZPCRE_OP
    integer terminal_width__pcu option_name_width__pcu option_text_width__pcu
    die_unless_map "${overview_map_name__pcu}"
    shift_arg

    # Width in characters of the current terminal.
    terminal_width__pcu="$(get_terminal_width)"

    # Width in characters of the option names area (i.e., the portion of each
    # line allotted to short and long options names and arguments),
    # corresponding to one third of the current terminal width. Avoid decimal
    # approximations of one third (e.g., "0.33"), which usually fail to ensure
    # that "$(( 1 * (1/3.) == 1 ))". To ensure floating point rather than
    # integer division, suffix either "1" or "3" by ".".
    option_name_width__pcu=$(( terminal_width__pcu * (1/3.) ))

    # Width in characters of the option text area (i.e., the portion of each
    # line allotted to options descriptions), corresponding to two thirds of the
    # current terminal width.
    option_text_width__pcu=$(( terminal_width__pcu - option_name_width__pcu ))

    # If either such width is less than 1, throw an exception.
    die_unless_integer_positive "${option_name_width__pcu}"\
        "option name width ${option_name_width__pcu} non-positive"
    die_unless_integer_positive "${option_text_width__pcu}"\
        "option text width ${option_text_width__pcu} non-positive"

    # Mandatory command to print usage for. If such map lacks such key, this
    # implicitly throws an exception.
    command_name__pcu="$(get_map_key_value\
        "${overview_map_name__pcu}" 'command')"

    # Colored string describing such map.
    usage__pcu+="${ZESHY_COLOR_STYLE[print_usage.usage]-}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]-}: ${ZESHY_COLOR_STYLE[print_usage.command_name]-}${command_name__pcu}"

    # If such map contains optional command arguments, append such arguments.
    if { command_args__pcu="$(get_map_key_value_if_found\
        "${overview_map_name__pcu}" 'args')" } {
        #FIXME: It'd be nice to extend replace_string_glob_matches_with_string()
        #to accept *MULTIPLE* glob string pairs. This is certainly feasible and
        #should remain reasonably efficient, given a single eval() statement.
        #(No looping required, I should imagine.)
        #FIXME: It'd be nice to perform a modest amount of pretty printing in
        #the event that such arguments exceed the width of the current line.
        #Shouldn't be terribly difficult; just requires a bit of consideration.

        # Prefix all braces, ellipses, and words in such arguments with their
        # corresponding color styles. Append the result.
        usage__pcu+=" ${${${command_args__pcu//(#m)[\[\]]/${ZESHY_COLOR_STYLE[print_usage.arg_brace]}${MATCH}}//.../${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...}//(#m)[[:alpha:]]##/${ZESHY_COLOR_STYLE[print_usage.arg_name]}${MATCH}}"
    }

    # Complete the usage line.
    usage__pcu+="${ZESHY_ASCII_NEWLINE}"

    # If such map contains an optional command synopsis, append such synopsis.
    if { command_synopsis__pcu="$(get_map_key_value_if_found\
        "${overview_map_name__pcu}" 'synopsis')" } {
        # Line wrap such synopsis.
        command_synopsis__pcu="$(get_string_wrapped "${command_synopsis__pcu}")"

        # Append such synopsis.
        usage__pcu+="${ZESHY_ASCII_NEWLINE}${ZESHY_COLOR_STYLE[print_usage.usage_text]}${command_synopsis__pcu}${ZESHY_ASCII_NEWLINE}"
    }

    # PCRE permitting line wrapping of option text. Compile such PCRE *AFTER*
    # wrapping the synopsis above, which also internally compiles a PCRE
    # conflicting with this PCRE's compilation below.
    option_text_pcre_wrapper__pcu="$(get_pcre_wrapping_at_line_length\
        ${option_text_width__pcu})"

    # Compile such PCRE. See for_string_pcre_matches() for further details.
    pcre_compile -- "${option_text_pcre_wrapper__pcu}"
    pcre_study

    # List of text for the current option wrapped into newline-delimited lines.
    list option_text_lines__pcu

    # Indentation prefixing the option name at the head of each line.
    string option_indentation__pcu='  '

    #FIXME: Rather than appending to ${usage__pcu} here, shouldn't we simply
    #output text as we construct it and page the entire "for" loop via
    #page_stdin()? That would seem to reduce the discernable downtime for the
    #current user, as well as slightly simplify things. Hmm; I suppose we don't
    #really want ${usage_pcu} at all, then! Just wrap the whole function in a
    #"{...} | page_stdin" block (after performing initial exception handling).
    #FIXME: Be sure to use output_string_sans_newline() where appropriate, below!

    # For each options list, append all options in such list.
    string\
        options_list_name__pcu\
        options_heading__pcu\
        option_short__pcu\
        option_short_colored__pcu\
        option_long__pcu\
        option_long_colored_pcu\
        option_text__pcu\
        option_text_line__pcu
    integer options_list_size__pcu option_name_length__pcu
    for options_list_name__pcu ("${@}") {
        # Size of such list.
        options_list_size__pcu="$(get_list_size "${options_list_name__pcu}")"

        # If such size is *NOT* at least 4 and (excluding the leading heading) a
        # multiple of three, throw an exception.
        ((   options_list_size__pcu >= 4 &&
            (options_list_size__pcu - 1) / 3. == 1 )) or die\
            "list \"${options_list_name__pcu}\" contains ${options_list_size__pcu} elements rather than a heading and one or more triples"

        # Append the heading for such options.
        options_heading__pcu="$(get_list_head "${options_list_name__pcu}")"
        usage__pcu+="${ZESHY_ASCII_NEWLINE}${ZESHY_COLOR_STYLE[print_usage.heading_title]}${options_heading__pcu}${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:${ZESHY_ASCII_NEWLINE}"

        # For each trifecta of short and long options and option text, append
        # the holy triumvurate of shame!
        for option_short__pcu option_long__pcu option_text__pcu (
            "${${(@P)options_list_name__pcu}[2,-1]}") {
            # If a short option was defined, format such option.
            if is -n "${option_short__pcu}" si {
                die_unless_character "${option_short__pcu}"\
                    "short option \"${option_short__pcu}\" not a character"

                # If such option is prefixed by an optional dash, remove such
                # dash before prefixing such option by a mandatory dash below.
                option_short__pcu="${option_short__pcu#-}"

                # Prefix the first optional space and argument in such option
                # with corresponding color styles.
                option_short_colored__pcu="${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}${option_short__pcu/(#m) */${ZESHY_COLOR_STYLE[print_usage.option_value]}${MATCH}}"

                # Prefix such option by a dash, to simplify logic below.
                option_short__pcu="-${option_short__pcu}"
            # Else, no such option was defined. Empty the corresponding string.
            } else {
                option_short_colored__pcu=''
            }

            # If a long option was defined, format such option.
            if is -n "${option_long__pcu}" si {
                # If such option is prefixed by two optional dashs, remove such
                # dashes before prefixing such option by two mandatory dashes.
                option_long__pcu="${option_long__pcu#--}"

                # Prefix the first optional equals sign and argument in such
                # option with corresponding color styles.
                option_long_colored__pcu="${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}${option_long__pcu}/(#b)=(*)/${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}${match[1]}}"

                # Prefix such option by two dashes, to simplify logic below.
                option_long__pcu="--${option_long__pcu}"
            # Else, no such option was defined. Empty the corresponding string.
            } else {
                option_long_colored__pcu=''
            }

            # If option text was defined, wrap such text into a list of lines.
            option_text_lines__pcu=()
            if is -n "${option_text__pcu}" si {
                # Wrap such text with the previously compiled PCRE. See
                # for_string_pcre_matches() and
                # get_string_wrapped_at_line_length() for further details.
                ZPCRE_OP='0 0'
                while { pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
                    "${option_text__pcu}" } {
                    option_text_lines__pcu+="${ZESHY_COLOR_STYLE[print_usage.option_text]}${match[1]}"
                }
            }

            # If a short option was defined, append such option.
            if is -n "${option_short__pcu}" si {
                # Append such option.
                usage__pcu+="${option_indentation__pcu}${option_short_colored__pcu}"

                #FIXME: If such option exceeds the total width of the options
                #"area", what we do depends. If:
                #
                #* A short option was also defined, then this long option should
                #  reside indented by three characters right on the next line.
                #* Else, the following option description should be shifted to the
                #  next line.
                #
                #Rather different operations, but the resulting effect is...
                #rather pleasing.

                # If a long option was also defined, append a delimiting comma
                # followed by such option.
                if is -n "${option_long__pcu}" si {
                    # Append a delimiting comma.
                    usage__pcu+="${ZESHY_COLOR_STYLE[print_usage.option_comma]}, "

                    # Length of concatenated short and long options. See
                    # get_string_length() for further details.
                    option_name_length__pcu="${#${${option_indentation__pcu}${option_short__pcu}, ${option_long__pcu}}}"

                    # If such options fit on a single line, do so.
                    if (( option_name_length__pcu <= option_name_width__pcu )) {
                        # Append the long option, padded on the right by
                        # sufficient whitespace to ensure well-formatted
                        # columns. Such strings contain ANSI color codes and
                        # hence cannot be reliably padded by expansion under
                        # either parameter expansion flags "(l...)" or "(r...)".
                        # Instead, simply repeat the desired number of spaces by
                        # either such flag. See repeat_string() for further
                        # details.
                        #
                        # Append also the first line of options text (defaulting
                        # to the empty string), delimited by a newline.
                        usage__pcu+="${option_long_colored__pcu}${(l:$(( option_name_width__pcu - option_name_length__pcu )):):-}${option_text_lines__pcu[1]-}${ZESHY_ASCII_NEWLINE}"

                        # For each additional line of options text that exists,
                        # append full padding followed by such line, delimited
                        # by a newline. Do *NOT* quote this list slice.
                        for option_text_line__pcu\
                            (${option_text_lines__pcu[2,-1]}) {
                            usage__pcu+="${(l:${option_name_width__pcu}:):-}${option_text_line__pcu}${ZESHY_ASCII_NEWLINE}"
                        }
                    # Else, such options only fit on separate lines. Shift the
                    # long option to the next line, indented to the right.
                    } else {
                        # Append sufficient padding followed by the first line
                        # of options text (defaulting to the empty string),
                        # delimited by a newline. Note that while the length of
                        # the short option is constant and hence could be
                        # reduced to a magic number, recomputing such length
                        # does little tangible harm.
                        #
                        # Append the indented long option followed by sufficient
                        # padding and the second line of options text
                        # (defaulting to the empty string), delimited by a
                        # newline.
                        usage__pcu+="${(l:$(( option_name_width__pcu - ${#${${option_indentation__pcu}${option_short__pcu},}} )):):-}${option_text_lines__pcu[1]-}${ZESHY_ASCII_NEWLINE}${option_indentation__pcu}${option_long_colored__pcu}"

                        # If no more lines of options text exist, append a
                        # newline.
                        if (( ${#option_text_line__pcu} < 2 )) {
                            usage__pcu+="${ZESHY_ASCII_NEWLINE}"
                        # Else, append such lines.
                        } else {
                            # Length of the long option.
                            option_name_length__pcu="${#${${option_indentation__pcu}${option_long__pcu}}}"

                            # If such option fits on a single line, append the
                            # next line following such option.
                            if (( option_name_length__pcu <= option_name_width__pcu )) {
                                usage__pcu+="${(l:$(( option_name_width__pcu - ${#${${option_indentation__pcu}${option_long__pcu}}} )):):-}${option_text_lines__pcu[2]-}${ZESHY_ASCII_NEWLINE}"
                            #FIXME: This is hardly ideal. Options text lines
                            #should be contiguous, if not necessarily left-
                            #aligned to the same margin. To do so here, append
                            #spaces rather than a newline here followed by a
                            #*PORTION* of the next line. Naturally, this
                            #requires rewrapping the third line and all
                            #subsequent lines of options text, if such lines
                            #exist. Annoying, though certainly feasible. See to it!

                            # Else, append a newline followed by the next line.
                            } else {
                                usage__pcu+="${ZESHY_ASCII_NEWLINE}${(l:${option_name_width__pcu}:):-}${option_text_lines__pcu[2]-}${ZESHY_ASCII_NEWLINE}"
                            }

                            # For each additional line of options text that exists,
                            # append full padding followed by such line (as above).
                            for option_text_line__pcu\
                                (${option_text_lines__pcu[3,-1]}) {
                                usage__pcu+="${(l:${option_name_width__pcu}:):-}${option_text_line__pcu}${ZESHY_ASCII_NEWLINE}"
                            }
                        }
                    }
                # Else, only a short option was defined.
                } else {
                    # Append sufficient padding followed by all lines of options
                    # text (as above).
                    usage__pcu+="${(l:$(( option_name_width__pcu - ${#${${option_indentation__pcu}${option_short__pcu}}} )):):-}${option_text_lines__pcu[1]-}${ZESHY_ASCII_NEWLINE}"
                    for option_text_line__pcu (${option_text_lines__pcu[2,-1]}) {
                        usage__pcu+="${(l:${option_name_width__pcu}:):-}${option_text_line__pcu}${ZESHY_ASCII_NEWLINE}"
                    }
                }
            # Else, no short option was defined.
            #
            # If only a long option was defined, append such option (as above).
            } elif is -n "${option_long__pcu}" si {
                usage__pcu+="${option_indentation__pcu}${option_long_colored__pcu}"
                option_name_length__pcu="${#${${option_indentation__pcu}${option_long__pcu}}}"

                if (( ${#option_text_line__pcu} == 0 )) {
                    usage__pcu+="${ZESHY_ASCII_NEWLINE}"
                } else {
                    if (( option_name_length__pcu <= option_name_width__pcu )) {
                        usage__pcu+="${(l:$(( option_name_width__pcu - ${#${${option_indentation__pcu}${option_long__pcu}}} )):):-}${option_text_lines__pcu[1]-}${ZESHY_ASCII_NEWLINE}"
                    } else {
                        usage__pcu+="${ZESHY_ASCII_NEWLINE}${(l:${option_name_width__pcu}:):-}${option_text_lines__pcu[1]-}${ZESHY_ASCII_NEWLINE}"
                    }

                    for option_text_line__pcu\
                        (${option_text_lines__pcu[2,-1]}) {
                        usage__pcu+="${(l:${option_name_width__pcu}:):-}${option_text_line__pcu}${ZESHY_ASCII_NEWLINE}"
                    }
                }
            #FIXME: After paging to page_stdin(), we no longer need to print the
            #current usage string. (Nice!)

            # Else, no short or long options were defined. Since this
            # constitutes a fatal error, throw an exception.
            } else {
                die "no short or long options defined for current option; usage string is:${ZESHY_ASCII_NEWLINE}${usage__pcu}"
            }
        }
    }

    # Print such usage paged.
    page_string "${usage__pcu}"

}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Excise!
    # Print such usage.
#    print_string_colored "${ZESHY_COLOR_STYLE[print_usage.usage]}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]}: ${ZESHY_COLOR_STYLE[print_usage.command_name]}zeshy ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}OPTION${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}... ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}FILE ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}ARGUMENT${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]
#
#${ZESHY_COLOR_STYLE[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
#as a zeshy zsh shell script passed the passed ARGUMENTs.
#
#${ZESHY_COLOR_STYLE[print_usage.heading_title]}Main options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}i${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}interactive      ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive non-login zsh shell
#}
#
#    # Print such usage.
#    print_string_colored "${ZESHY_COLOR_STYLE[print_usage.usage]}Usage${ZESHY_COLOR_STYLE[print_usage.usage_colon]}: ${ZESHY_COLOR_STYLE[print_usage.command_name]}zeshy ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}OPTION${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}... ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}FILE ${ZESHY_COLOR_STYLE[print_usage.arg_brace]}[${ZESHY_COLOR_STYLE[print_usage.arg_name]}ARGUMENT${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]${ZESHY_COLOR_STYLE[print_usage.arg_ellipsis]}...${ZESHY_COLOR_STYLE[print_usage.arg_brace]}]
#
#${ZESHY_COLOR_STYLE[print_usage.usage_text]}Open a new zsh shell running zeshy. If passed an optional FILE, source such path
#as a zeshy zsh shell script passed the passed ARGUMENTs.
#
#${ZESHY_COLOR_STYLE[print_usage.heading_title]}Main options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}i${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}interactive      ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive non-login zsh shell
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}l${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}login            ${ZESHY_COLOR_STYLE[print_usage.option_text]}open an interactive login zsh shell
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}h${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}help             ${ZESHY_COLOR_STYLE[print_usage.option_text]}print this help string and exit
#      ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}version          ${ZESHY_COLOR_STYLE[print_usage.option_text]}print a version string and exit
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_comma]},  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--                 ${ZESHY_COLOR_STYLE[print_usage.option_text]}stop parsing options
#
#${ZESHY_COLOR_STYLE[print_usage.heading_title]}Parameterized options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}c ${ZESHY_COLOR_STYLE[print_usage.option_value]}COMMAND${ZESHY_COLOR_STYLE[print_usage.option_comma]},            ${ZESHY_COLOR_STYLE[print_usage.option_text]}run the passed zeshy shell command (e.g., \"is_dir /\")
#     ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}command${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}COMMAND
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}o ${ZESHY_COLOR_STYLE[print_usage.option_value]}OPTION${ZESHY_COLOR_STYLE[print_usage.option_comma]},             ${ZESHY_COLOR_STYLE[print_usage.option_text]}enable the passed zsh shell option (\"man zshoptions\")
#     ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}option${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}OPTION
#
#${ZESHY_COLOR_STYLE[print_usage.heading_title]}Startup options${ZESHY_COLOR_STYLE[print_usage.heading_colon]}:
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}-${ZESHY_COLOR_STYLE[print_usage.option_name]}v${ZESHY_COLOR_STYLE[print_usage.option_comma]}, ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}verbose          ${ZESHY_COLOR_STYLE[print_usage.option_text]}print debug statements during zeshy startup
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}zeshy-dot-dir${ZESHY_COLOR_STYLE[print_usage.option_equals]}=${ZESHY_COLOR_STYLE[print_usage.option_value]}PATH   ${ZESHY_COLOR_STYLE[print_usage.option_text]}change zeshy's dot directory (defaults to \"~/.zeshy\")
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}no-zeshy-dot-dir     ${ZESHY_COLOR_STYLE[print_usage.option_text]}ignore zeshy's dot directory and files therein; hence,
#                            run zeshy with default settings and no digest file
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}compile-digest       ${ZESHY_COLOR_STYLE[print_usage.option_text]}recompile zeshy's digest, even if up-to-date
#  ${ZESHY_COLOR_STYLE[print_usage.option_dash]}--${ZESHY_COLOR_STYLE[print_usage.option_name]}compile-digest-if-zeshy-home-changed
#                         ${ZESHY_COLOR_STYLE[print_usage.option_text]}recompile zeshy's digest if zeshy's codebase changed"

            #FUXME: Excise.
            # Else, no option text was defined. To simplify logic below,
            # initialize such list to only a single newline.
#           } else {
#               option_text_lines__pcu=( "${ZESHY_ASCII_NEWLINE}" )
#           }

                #FUXME: This should dynamically append as much whitespace is
                #required to ensure well-formatted columns. We'll need to get
                #the string length of ${option_short__pcu} sans ANSI colors,
                #then subtract the total width of the options "area" by such
                #length. Shouldn't be terribly hard.
#               usage__pcu+="${option_name__pcu}"

                        # Length of short option only. While such length 
#                       option_name_length__pcu="${#${  ${option_short__pcu},}}"

#See align_string_to_length_right() for
                        # further details.
                    #FUXME: There's a far more efficient way. Just retain the
                    #original unformatted option names! We'll need two new
                    #string locals above. *shrug*
                    # Length of short and long options if (hypothetically)
                    # fitting on a single line. See
                    # get_string_length_printable_sans_ansi_colors() for further
                    # details.
#                   option_name_length__pcu="${#${${option_name__pcu}${option_long__pcu}//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}}}"

#               ="$(get_string_wrapped_at_line_length\
#                   "${option_text__pcu}" ${option_text_width})"
        #FUXME: Actually, we really need a 
        #FUXME: Implement such exception handler.

        #FUXME: Implement such iterator. We'll want to 
#       for_list_elements_in_range\
#           "${options_list_name__pcu}" 2 -1\
#           option_short__pcu option_long__pcu option_text__pcu\
#           ''
#       die_unless_list "${options_list_name__pcu}"

        #FUXME: Not right, obviously. Parse such string apart. Actually, just
        #use a series of global string replacements. Should be fairly simple.
#       overview__pcu+=" ${command_args__pcu}"

    # If such map lacks mandatory key-value pairs, throw an exception.
#       'v' 'verbose'           'print optional debug statements'
#       '' 'release'            'switch to zeshy''s optimized digest (default)'
#       '' 'debug'              'switch to zeshy''s developer digest'
