#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle unit tests and suites of such tests.

== See Also ==

* https://code.google.com/p/shunit2[shunit2], a `bash` unit testing framework
  inspired by xUnit.
-/-

#FIXME: Note that "zsh" internally uses a unit test syntax called "ztst". We
#should probably google a bit about this before unrolling our own. Perhaps we
#can simply reuse "ztst"?
#FIXME: See "src/main" for extensive documentation on The Way Forward.

# ....................{ UNIT TESTERS                       }....................
#FIXME: Shift to "zeshy/unit_test".
declare_function_with_stdin <<'/---'
string unit_test_zeshy(void)

Run all `zeshy` unit tests.
/---
function unit_test_zeshy() {
    #FIXME: O.K.; now this is cool. We want this framework to define a function:
    unit_test_functions_matching 'unit_test_zeshy_*'
    #FIXME: Then, each Zeshy unit test should begin with test_zeshy_*(). While
    #it would be "cool" to interleave unit tests with regular functions, we
    #should probably consider segregating them. The only comment online I see
    #regarding interleaving is (wait for it) by Bruce Eckel. No surprise,
    #really. I like it, actually. Let's do it. It'll bloat the codebase up,
    #but... *shrug* Also, don't bother including documentation for unit tests.
    #The Zeshy help system should be able to dynamically "synthesize" help if
    #anyone asks for it: e.g., for a test_zeshy_split_string_lines_to_list()
    #function, "Unit tests the split_string_lines_to_list() function." Simple!
    #Since we're not including documentation, such unit tests should be concise
    #enough to make the endeavor not horrifically unreadable. Go-go-go!
}

#FIXME: Rename to unit_test_functions_matching_glob().
declare_function_with_stdin <<'/---'
string unit_test_functions_matching(string glob)

Run all functions with names matching the passed glob as a unit test suite.
/---
function unit_test_functions_matching() {
    # Validate passed arguments, capitalizing the local variable receiving the
    # passed glob to denote such glob readable by child functions.
    die_unless_arg 'expected one glob'
    string ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB="${1}"

    # List of all function names matching the passed glob.
    list test_function_names
    set_list_to_function_matches\
        test_function_names "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}"

    # Name of the function being tested by the current unit test.
    string tested_function_name

    #FIXME: Replace with call to glob function returning match group, if found.
    # If the passed glob is prefixed by a substring of alphanumeric characters
    # (e.g., substring "test_zeshy_" of glob "test_zeshy_*"), store such prefix
    # for use below.
    string tested_function_name_prefix
    if { is_string_matches_glob\
        "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}" ([[:alnum:]]##)* } {
        tested_function_name_prefix="${match[1]}"
    }

    # Iteratively run each such function as a unit test.
    string test_function_name tested_function_name
    for    test_function_name ("${test_function_name[@]}") {
        if is -n "${tested_function_name_prefix}" si {
            tested_function_name="$(remove_string_prefix\
                "${test_function_name}" "${tested_function_name_prefix}")"
            is_function "${tested_function_name}" or
                tested_function_name=
        }

        #FIXME: Abstract test print_string out to a set of new "terminal/theme/output"
        #functions: say,
        #
        #    string say_test(string message)
        #    string say_test_passed(void)
        #    string say_test_failed(void)
        #
        #Note that say_test() will need to set a global boolean noting Zeshy to
        #now be in a testing state and say_test_passed() and say_test_failed() to
        #unset such boolean. Ah! Nice. That may not be strictly necessary. What
        #will be necessary, however, is to have say_test() temporarily redirect
        #stdout to a file, named pipe, or (ideally) coprocessed variable (e.g.,
        #">(ZESHY_STANDARD_OUTPUT)") and then to have say_test_passed() and
        #say_test_failed() restore stdout *AND* print the contents of
        #"${ZESHY_STANDARD_OUTPUT}" after printing either "ok" or "FAIL". Oh, and
        #we'll want to redirect stderr as well, of course. Sweet; research.
        if is -n "${tested_function_name}" si {
            print_message_test "unit testing ${tested_function_name}()... "
        } else {
            print_message_test "calling ${function_name}()... "
        }
    }
}

function print_message_test() {
    # Validate passed arguments.
    die_unless_arg 'expected one string'
    print_message "${1}()... "
}

#FIXME: Possible desirable unit testing scaffold output:
#
#  unit testing is_function()... FAIL
#  unit testing is_function()... pass
#  unit testing unit_test_zeshy_is_alias()... FAIL
#  unit testing unit_test_zeshy_is_function()... ok
#  calling unit_test_zeshy_is_function()... ok
#  calling unit_test_zeshy_set_list_to_string_split_on()... OK
#  running unit_test_zeshy_set_strings_to_split_string_on()... OK

# ....................{ GETTERS                            }....................
function get_caller_unit_test() {
    die_unless_variable_string ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB
}

# ....................{ PASSERS                            }....................
declare_function_with_stdin <<'/---'
void pass_unit_test_if_command_succeeds(
    string command_name, string command_arg1, string command_arg2, ...)

Mark the current unit test successful if the passed command *succeeds* (i.e.,
returns zero exit status).
/---
function pass_unit_test_if_command_succeeds() {
    # Validate passed arguments.
    die_unless_arg 'expected one command'

    #FIXME: First, we need some means of acquiring the unit test function name.
    #How 'bout a simple walk up the call stack from this function to the nearest
    #parent function matching "(unit_)#test_*". Ah! No; I get it. The
    #unit_test_functions_matching() function should store the passed glob to a
    #temporary global (destroyed at the end of such function) -- say,
    #${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}. Actually, to make life safe and
    #simple, destroy **ALL** globals matching "ZESHY_UNIT_TEST_*" at the end of
    #such function. Then, this function should test each function name up the
    #call stack against such glob. Incredibly simple, actually.

    # Run such command.
    if { run_command "${@}" } {
    } else {
    }
}

declare_function_with_stdin <<'/---'
void pass_unit_test_if_command_fails(
    string command_name, string command_arg1, string command_arg2, ...)

Mark the current unit test successful if the passed command fails (i.e.,
returns nonzero exit status).
/---
function pass_unit_test_if_command_fails() {
}

declare_function_with_stdin <<'/---'
void pass_unit_test_if_command_exit_status(
    string command_name, string command_arg1, string command_arg2, ...,
    integer exit_status)

Mark the current unit test successful if the passed command returns the passed
exit status.
/---
function pass_unit_test_if_command_exit_status() {
}

# ....................{ FAILERS                            }....................

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Rename "ZESHY_STDOUT_FILE_DESCRIPTOR" to "ZESHY_STDOUT_FILE_DESCRIPTOR"
    #or perhaps "ZESHY_FILE_DESCRIPTOR_FOR_STANDARD_OUTPUT"
    #or perhaps "ZESHY_FD_STANDARD_OUTPUT"? Hmm. I do like the longest one...
#   integer ZESHY_FILE_DESCRIPTOR_FOR_STANDARD_OUTPUT_OF_TEST
#   ${ZESHY_STDOUT_FILE_DESCRIPTOR}

#       tested_function_name="$(remove_prefix "${test_function_name}")"
    #FUXME: Replace with call to glob function returning match group, if found.
    # If the passed glob is prefixed by a substring of alphanumeric characters
    # (e.g., substring "test_zeshy_" of glob "test_zeshy_*"), store such prefix
    # for use below.
#   string test_function_name_prefix
#   is "${ZESHY_UNIT_TEST_FUNCTIONS_MATCHING_GLOB}" == ([[:alnum:]]##)* si and {
#       test_function_name_prefix="${match[1]}"
#   }

#FUXME: Add a new "zeshy/test" file defining Zeshy unit tests leveraging
#functions defined below, with top-level test_zeshy() function calling all such
#unit tests. Each such unit test should itself be encapsulated by a single...
#actually, that strikes me as horribly heavy-weight. Let's go with the
#following:

    #FUXME: Prints all function names matching such glob, newline-delimited. Use
    #this to collect the set of all functions to be run into a list. Perhaps use
    #the split_string_lines_to_list() function. Also, this one-liner is
    #exceedingly useful; split into a new function:
    #set_list_to_function_matches()
#   typeset -fm '+' "${glob}"
