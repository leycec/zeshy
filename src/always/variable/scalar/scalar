#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *scalar left-hand sides* (i.e., expressions syntactically valid as the
left-hand sides of scalar assigments). See is_scalar() for further details.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_scalar:(
    string expression,
    string error_message =
        "Expression \"${expression}\" not a scalar left-hand side.")
/---
function die_unless_scalar:() {
    die_unless_args_1_to_2 'Expected one expression and optional error message.'
    string expression="${1}"
    is_scalar: "${expression}" or die\
        ${2-Expression \"${expression}\" not a scalar left-hand side.}
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_scalar:(string expression)

Report success if the passed expression is a *scalar left-hand side* (i.e.,
valid as the left-hand side of scalar assigments), including:

* Scalar variable names (e.g., `vituperative_portrayal_of_weak_and_vulnerable`).
* List indexation (e.g., `fecund_bone_yard_of_gossip_poison_and_lies[96]`).
* Map indexation (e.g., `distracted_by[vapid celebrity claptrap]`).
/---
function is_scalar:() {
    #FIXME: Match the variable name from such LHS and verify whether it exists.
    die_unless_arg 'Expected one expression.'
    is "${1}" == ${~ZESHY_VARIABLE_NAME_GLOB}(|'['?*']') si
}

# ....................{ REPLACERS                          }....................
declare_function_with_stdin <<'/---'
void replace_scalar_text_matching_pcre_by_text:(
     string scalar_lhs,
     string pcre,
     string replacement_substring)

Globally replace all substrings in the passed *scalar left-hand side* (i.e., an
expression valid as the left-hand side of scalar assigments) matching the passed
PCRE with the passed replacement substring. See is_scalar:() for further
details: e.g.,

.replace_scalar_text_matching_pcre_by_text:()
==========================================
[source]
------------------------------------------
>>> map on_civil_disobedience; on_civil_disobedience=(
...     "The Problem is Civil Obedience"
...     "I start from the supposition that the world is topsy-turvy, that things
...      are all wrong, that the wrong people are in jail and the wrong people
...      are out of jail, that the wrong people are in power and the wrong
...      people are out of power, that the wealth is distributed in this country
...      and the world in such a way as not simply to require small reform but
...      to require a drastic reallocation of wealth. I start from the
...      supposition that we don't have to say too much about this because all
...      we have to do is think about the state of the world today and realize
...      that things are all upside down." )
>>> replace_scalar_text_matching_pcre_by_text:\
...      'on_civil_disobedience[The Problem is Civil Obedience]'\
...      '\bthat [^:punct:]++([:punct:])'\
...      'that our problem is civil obedience${match[1]}'
>>> output_string "${on_civil_disobedience[The Problem is Civil Obedience]}"
I start from the supposition that our problem is civil obedience, that our
problem is civil obedience, that our problem is civil obedience, that our
problem is civil obedience, that our problem is civil obedience. I start from the
supposition that our problem is civil obedience.
------------------------------------------
==========================================

== Replacement Expansion ==

Such replacement is dynamically expanded in the context of each replacement and
hence may contain references to:

* Currently matched substring `${MATCH}`.
* Currently captured groups `${match[${group_index}]}` for all valid group
  indices `${group_index}`.
/---
function replace_scalar_text_matching_pcre_by_text:() {
    # This function is creatively inspired by "regexp-replace" from the zsh
    # distribution. Since this function is transitively called by
    # replace_file_text_matching_pcre_by_text:(), avoid extraneous string copies
    # (and hence copies of text file contents) at all costs.
    #
    # Validate sanity.
    die_unless_args_3\
        'Expected one scalar left-hand side, one PCRE, and one replacement substring.'
    string\
        scalar__rltmpbt="${1}"\
        pcre__rltmpbt="${2}"\
        replacement__rltmpbt="${3}"\
        text_old__rltmpbt\
        text_new__rltmpbt
    die_unless_scalar: "${scalar__rltmpbt}"

    # Original text for such scalar. For efficiency, the iteration below modifies
    # such text "in-place."
    text_old__rltmpbt="${(P)scalar__rltmpbt}"

    # While there exist substrings matching such PCRE in the original text...
    while is "${text_old__rltmpbt}" =~ "${pcre__rltmpbt}" si {
        # If such substring is empty, throw an exception. This avoids infinite
        # loops on perverse PCREs matching only zero-width assertions or the
        # empty string.
        (( ${#MATCH} )) or die\
            'PCRE "'${pcre__rltmpbt}'" erroneously matched the empty string.'

        # Append the replaced text by the portion of the original text preceding
        # such match followed by such replacement dynamically expanded in the
        # current context.
        text_new__rltmpbt+="${text_old__rltmpbt[1,MBEGIN-1]}${(e)replacement__rltmpbt}"

        # Reduce the original text to the portion following such match.
        text_old__rltmpbt="${text_old__rltmpbt[MEND+1,-1]}"
    }

    # Set such scalar to such replaced text followed by all remaining original
    # text. To avoid extraneous string copies, inline such implementation.
    eval ${scalar__rltmpbt}'="${text_new__rltmpbt}${text_old__rltmpbt}"'
}

#FIXME: In lieu of unit tests...
#function lymo() {
#    string scalar_new scalar_old='““““quote_double_right”””””quote_single_left‘‘‘‘‘quote_single_right’’’’’’border_top┈┈┈┈┈┈border_bottom┈┈┈┈┈┈┈border_left┋┋┋┋┋┋┋border_right┋┋┋┋┋┋┋'
#    scalar_new="${scalar_old}"
#    replace_scalar_text_matching_pcre_by_text:\
#        scalar_new '(quote_|border_).*?(quote_|border_)' '${match[1]}???${match[2]}'
#    print "old: ${scalar_old}\nnew: ${scalar_new}"
#}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: It'd be great if we could syntactically validate such LHS to
    #actually be a valid scalar LHS. So far as I can conceive, the following glob
    #should do it:
    #
    #    is "${expression}" == ${~ZESHY_VARIABLE_NAME_GLOB}(|'['?*']') si
    #
    #Encapsulate this into a new die_unless_lhs_scalar() function. We could even
    #match the variable from such LHS and verify whether it exists -- though,
    #perhaps that's a bit much? *shrug*

# == Scalar Left-hand Sides ==
# 
# Valid scalar left-hand sides include:
# 
# * Scalar variable names (e.g., `vituperative_portrayal_of_weak_and_vulnerable`).
# * List indexation (e.g., `fecund_bone_yard_of_gossip_poison_and_lies[96]`).
# * Map indexation (e.g., `distracted_by[vapid celebrity claptrap]`).
