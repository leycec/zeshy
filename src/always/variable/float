#!/usr/bin/env zsh
# ====================[ float                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle floats (i.e., floating point numbers approximating real numbers).

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_float(
    string value,
    string error_message = "\${value}\" not a float")

Throw an exception with the passed message unless the passed string is a float.
See is_float() for further details.
________________<heredoc?>________________
function die_unless_float() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string text="${1}"
    is_float "${text}" or die "${2:-\"${text}\" not a float}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_float(string value)

Return success if the passed string is a float (i.e., a string consisting of an
optional negative sign, one or more digits, a decimal point, and optional
digits).
________________<heredoc?>________________
function is_float() {
    # See is_integer() for further details.
    die_unless_arg 'expected one string'
    is "${1}" == (|-)<->.(|<->) si
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
float round_float(float number, integer precision = 0)

Round the passed float to the passed number of decimal places (defaulting to 0
and hence rounding to a whole integer).
________________<heredoc?>________________
function round_float() {
    # Validate passed arguments.
    die_unless_args_1_to_2 'expected one float and optional precision'
    string number="${1}" precision="${2:-0}"
    die_unless_float "${number}"
    die_unless_integer_nonnegative "${precision}"

    # Round such float.
    printf "%.${precision}f\n" ${number}
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Also implement genuine die_unless_float() and is_float() methods.
#(Pilfer the implementation from the "integer" component.)
