#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string repeaters* (i.e., functions repeating strings, typically for
ensuring padded, aligned, and/or otherwise structured output).
/---

# ....................{ REPEATERS                          }....................
declare_function_with_stdin <<'/---'
string repeat_string(string text, integer count)

Repeat the passed string the passed number of times: e.g.,

.repeat_string()
==========================================
[source]
------------------------------------------
>>> repeat_string "Slavoj Žižek" 6
Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
------------------------------------------
==========================================
/---
function repeat_string() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one integer.'
    string text="${1}" count="${2}" token
    die_unless_integer_nonnegative "${count}"

    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; the technique below assumes a strictly positive
    # count, actually repeating such string twice rather than printing the empty
    # string when passed a count of 0.
    (( count )) or report_success

    # Technically, there exist a multitude of techniques for repeating strings.
    # The technique implemented here is _not_ necessarily the most efficient for
    # edge-case strings but has the distinct benefit of behaving as expected for
    # all strings regardless of content. The (arguably) more popular alternative
    # to this technique leverages parameter expansion flags "(l...)" or "(r...)"
    # as follows:
    #
    #    # If such text does *NOT* contain at least one parameter expansion token,
    #    # prefer token- to printf()-based repetition. The latter expands the
    #    # expression "{1..${count}}" to ${count} number of integer arguments and
    #    # hence fails to efficiently scale to large counts.
    #    if { set_character_to_string_parameter_expansion_token_if_found\
    #            token "${text}" } {
    #        # Desired length *AFTER* repeating such string below. See
    #        # get_string_ansiless_length_printable() for further details.
    #        integer length=$(( count * ${(m)#text} ))
    #
    #        # Repeat such string. Since such string's length is guaranteed to divide
    #        # the total length computed above, repeating such string in either a
    #        # rightmost (i.e., ${(r...):-}) or leftmost (i.e., ${(l...):-}) manner
    #        # produces the same result. For orthogonality with related functionality
    #        # (e.g., set_string_to_string_padded_to_length()), repeat in a
    #        # rightmost manner.
    #        eval 'output_string ${(r'${token}${length}${token}${token}${text}${token}'):-}'
    #    }
    #
    # Unfortunately, such parameter expansion flags fail to account for non-
    # printable ANSI escape sequences when calculating such length, rendering
    # such technique erroneous for strings containing such sequences. While the
    # prior conditional *COULD* be improved to detect such strings and avoid
    # applying such technique to such strings, the cost of such detection and
    # the necessity of finding a suitable parameter expansion token quickly
    # overwhelms any efficiency gains of the technique itself.
    #
    # Instead, implement printf()-based repetition.

    # For safety, escape printf()-reserved percent signs in such string. For
    # efficiency, inline such implementation. See escape_string_for_printf() for
    # further details.
    printf -- "${text//\%/%%}%.0s" {1..${count}}

    # Since printf() appends no newline by default, do so.
    output_newline
}

#FIXME: In lieu of unit tests...
#function baso() {
#    repeat_string "${ZESHY_STYLE_TO_COLOR[color.red]}bo${ZESHY_STYLE_TO_COLOR[color.white]}lo" 7
#}

# --------------------( WASTELANDS                         )--------------------
    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; all of the implementations below assume a
    # positive count. The printf()-based implementation, for example, actually
    # repeats the desired string twice rather than printing the empty string
    # when passed a count of 0.
#   (( count )) or report_success

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_string_to_string_padded_to_length().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If such text does *NOT* contain at least one parameter expansion token,
    # prefer token- to printf()-based repetition. The latter expands the
    # expression "{1..${count}}" to ${count} number of integer arguments as
    # well as requiring command substitution and hence fails to efficiently
    # scale to large counts.
#    if { set_character_to_string_parameter_expansion_token_if_found\
#            token "${text}" } {
#        integer text_length result_length
#
#        # Length of such string excluding ANSI escape sequences.
#        set_integer_to_string_length_printable text_length "${text}"
#        
#        # Desired length *AFTER* repeating such string below.
#        result_length=$(( count * text_length ))
#        print "text: ${text}; text length: ${text_length}; result length: ${result_length}"
#
#        # Repeat such string. Since such string's length is guaranteed to divide
#        # the total length computed above, repeating such string in either a
#        # rightmost (i.e., ${(r...):-}) or leftmost (i.e., ${(l...):-}) manner
#        # produces the same result. For orthogonality with related functionality
#        # (e.g., set_string_to_string_padded_to_length()), repeat in a
#        # rightmost manner.
#        eval 'output_string ${(r'${token}${result_length}${token}${token}${text}${token}'):-}'

#       return_string "${ZESHY_ASCII_NEWLINE}"

# ....................{ SETTERS                            }....................
#FUXME: If any function begged for examples, this would be it.
#declare_function_with_stdin <<'/---'
#void set_string_to_string_padded_to_length(
#    string string_name,
#    string padding,
#    integer length)
#
#Set the passed string variable to the passed padding repeated until producing a
#string of exactly the passed length. If such length is _not_ evenly divided by
#the length of such padding, the last repetition of such padding will be
#truncated on the right by as many characters as needed to guarantee producing a
#string of exactly the passed length.
#/---
#function set_string_to_string_padded_to_length() {
#    # Validate sanity.
#    die_unless_args_3\
#        'Expected one string name, one padding string, and one length.'
#    string\
#        string_name__sstsptl="${1}"\
#        padding__sstsptl="${2}"\
#        length__sstsptl="${3}"
#    die_unless_string_nonempty\
#        "${padding__sstsptl}" 'Expected nonempty padding.'
#    die_unless_integer_nonnegative "${length__sstsptl}"
#
#    # If such padding's length evenly divides such length, life is simple.
#    if (( length__sstsptl )) {
#    }
#}
