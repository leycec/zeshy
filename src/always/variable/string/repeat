#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string repeaters* (i.e., functions repeating strings, typically for
ensuring padded, aligned, and/or otherwise structured output).
/---

# ....................{ REPEATERS                          }....................
declare_function_with_stdin <<'/---'
string repeat_string(string text, integer count)

Repeat the passed string the passed number of times: e.g.,

.repeat_string()
==========================================
[source]
------------------------------------------
>>> repeat_string "Slavoj Žižek" 6
Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
------------------------------------------
==========================================
/---
function repeat_string() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_string_to_string_padded_to_length().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args_2 'Expected one string and one integer.'
    string text="${1}" count="${2}" token
    die_unless_integer_nonnegative "${count}"

    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; all of the implementations below assume a
    # positive count. The printf()-based implementation, for example, actually
    # repeats the desired string twice rather than printing the empty string
    # when passed a count of 0.
    (( count )) or report_success

    # If such text does *NOT* contain at least one parameter expansion token,
    # prefer token- to printf()-based repetition. The latter expands the
    # expression "{1..${count}}" to ${count} number of integer arguments and
    # hence fails to efficiently scale to large counts.
    if { token="$(get_string_parameter_expansion_token_if_found "${text}")" } {
        # Total string length after repeating such string below. See
        # get_string_length_printable() for further details.
        integer result_length=$(( count * ${(m)#text} ))

        # Repeat such string. Since such string's length is guaranteed to divide
        # the total length computed above, repeating such string in either a
        # rightmost (i.e., ${(r...):-}) or leftmost (i.e., ${(l...):-}) manner
        # produces the same result. For orthogonality with related functionality
        # (e.g., set_string_to_string_padded_to_length()), repeat in a
        # rightmost manner.
        eval "return_string\
            \${(r${token}${result_length}${token}${token}${text}${token}):-}"
    # Else, perform printf()-based repetition.
    } else {
        # For safety, escape percent signs in such string.
        printf -- "$(escape_string_for_printf "${text}")%.0s" {1..${count}}

        # Since printf() appends no newline by default, do so.
        output_string
    }
}

# --------------------( WASTELANDS                         )--------------------
#       return_string "${ZESHY_ASCII_NEWLINE}"

# ....................{ SETTERS                            }....................
#FUXME: If any function begged for examples, this would be it.
#declare_function_with_stdin <<'/---'
#void set_string_to_string_padded_to_length(
#    string string_name,
#    string padding,
#    integer length)
#
#Set the passed string variable to the passed padding repeated until producing a
#string of exactly the passed length. If such length is _not_ evenly divided by
#the length of such padding, the last repetition of such padding will be
#truncated on the right by as many characters as needed to guarantee producing a
#string of exactly the passed length.
#/---
#function set_string_to_string_padded_to_length() {
#    # Validate sanity.
#    die_unless_args_3\
#        'Expected one string name, one padding string, and one length.'
#    string\
#        string_name__sstsptl="${1}"\
#        padding__sstsptl="${2}"\
#        length__sstsptl="${3}"
#    die_unless_string_nonempty\
#        "${padding__sstsptl}" 'Expected nonempty padding.'
#    die_unless_integer_nonnegative "${length__sstsptl}"
#
#    # If such padding's length evenly divides such length, life is simple.
#    if (( length__sstsptl )) {
#    }
#}
