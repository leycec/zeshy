#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string variables.

# ....................{ EXCEPTIONS                         }....................
document_function '
boolean die_unless_string_nonempty(string text, string exception_message)

Throw an exception with the passed message unless the passed string is empty.
'
function die_unless_string_nonempty() {
    die_unless_args_2 'expected one string and one exception message'
    is_string_nonempty "${1}" or die "${2}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_string_empty(string text)

Return true if the passed string is empty.
'
function is_string_empty() {
    die_unless_arg 'expected one string'
    is -z "${1}" si
}

document_function '
boolean is_string_nonempty(string text)

Return true if the passed string is empty.
'
function is_string_nonempty() {
    die_unless_arg 'expected one string'
    is -n "${1}" si
}

# ....................{ TESTERS ~ equality                 }....................
document_function '
boolean is_string_equals(string text1, string text2)

Return true if the two passed strings are identical.
'
function is_string_equals() {
    append_args_with_standard_input_if_piped
    die_unless_args_2 'expected two strings'
    is "${1}" == "${2}" si
}

document_function '
boolean is_string_equals_caselessly(string text1, string text2)

Return true if the two passed strings are case-insensitively identical (i.e.,
identical when ignoring case).
'
function is_string_equals_caselessly() {
    append_args_with_standard_input_if_piped
    die_unless_args_2 'expected two strings'
    is "${1}" == (#i)"${2}" si
}

# ....................{ TESTERS ~ containment              }....................
#FIXME: Contemplate renaming back to is_string_contains(), which reads much more
#naturally than this. Search for other instances of "_substring" in function
#names; perhaps we had a respectable reason for adopting such nomenclature?
#FIXME: Yeah. This is great. Rename back to is_string_contains(), in keeping
#with the existing is_string_equals() nomenclature. But the *REAL* reason is
#much more compelling: because we have numerous other functions elsewhere testing
#containment, each currently with their own domain-specific nomenclature
#(e.g., is_list_element()). *THIS IS NONSENSE.* All containment testers should
#share the same nomenclature: _contains(). Why? Because anything else induces
#thinking on trying to remember the domain-specific noun for testing that
#particular type of containment, which ends up being just horrible. (Even I
#can't keep it straight.) Hence, rename is_list_element() to is_list_contains()
#as well.
document_function '
boolean is_string_substring(string text, string substring)

Return true if the passed string contains the passed substring.
'
function is_string_substring() {
    append_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one substring'
    is "${1}" == *"${2}"* si
}

document_function '
boolean is_string_prefix(string text, string prefix)

Return true if the passed string is prefixed by the passed prefix.
'
function is_string_prefix() {
    append_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one prefix'
    is "${1}" == "${2}"* si
}

document_function '
boolean is_string_suffix(string text, string suffix)

Return true if the passed string is suffixed by the passed suffix.
'
function is_string_suffix() {
    append_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one suffix'
    is "${1}" == "${2}"* si
}

# ....................{ GETTERS                            }....................
document_function '
integer get_string_length(string text1, string text2, ...)

Get the total length of the passed strings in single-byte characters. Consider
calling get_string_length_multibyte() instead if any such string contains
multibyte characters (e.g., UTF-8-encoded Unicode).
'
function get_string_length() {
    # Due to zsh eccentricity, this expansion *CANNOT* be reduced to either
    # "${#*}", "${#@}", or "${#${@}}". However sensible such expansions may
    # seem, they all obstinately return the number of passed arguments. *sigh*
    # (Don't get us wrong: we know why such reductions fail. They gall, though!)
    die_unless_args 'expected at least one string'
    print_string "${#${*}}"
}

document_function '
integer get_string_length_multibyte(string text)

Get the length of the passed string in multibyte characters.
'
function get_string_length_multibyte() {
    die_unless_args 'expected at least one string'
    print_string "${(m)#${*}}"  # see get_string_length()
}

# ....................{ GETTERS ~ count                    }....................
document_function '
string get_string_substring_count(string string, string substring)

Get the number of instances of the passed substring in the passed string: e.g.,

    >>> get_string_substring_count "cult of radical consumerism" "c"
    3
'
function get_string_substring_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
    die_unless_args_2 'expected one string and one substring'
    string text="${1}" substring="${2}" string_sans_substring
    string_sans_substring="${text//${substring}}"
    print_string $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
}

# ....................{ GETTERS ~ words                    }....................
document_function '
string get_string_word(string text, integer word_index)

Get the word corresponding to the passed 1-based index from the passed string.
'
function get_string_word() {
    die_unless_args_2 'expected one string and one index'
    print_string "${1[(w)${2:-1}]}"
}

document_function '
integer get_string_word_count(string text, string text2, ...)

Get the number of words in the passed string, aggregating each quoted
substring into one shell word. Hence, this is a shell-specific word count.
'
function get_string_word_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

document_function '
integer get_string_word_count_unquoted(string text1, string text2, ...)

Get the number of words in the passed string, *NOT* aggregating quoted
substrings. Hence, this is the conventional document word count.
'
function get_string_word_count_unquoted() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ SETTERS                            }....................
document_function '
void set_string(string variable_name, string text)

Set the passed variable to the passed string: e.g.,

    >>> string machine_elf="tyke" tyke
    >>> set_string "${machine_elf}" "self-transforming basketball"
    >>> print_string "${tyke}"
    self-transforming basketball
'
function set_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_variable_string "${string_name}"

    # Set such string.
    noop ${(P)string_name::=${2}}
}

document_function '
void set_string_if_unset(string variable_name, string text)

Set the passed variable if unset to the passed string: e.g.,

    >>> string gnomes_say="hooray" hooray
    >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
    >>> print_string "${hooray}"
    lesser lights of the Bardo
'
function set_string_if_unset() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_variable_string "${string_name}"

    # Set such string if unset.
    noop ${(P)string_name=${2}}
}

document_function '
void set_string_if_unset_or_empty(string variable_name, string text)

Set the passed variable if unset or empty to the passed string: e.g.,

    >>> string fifty_fourth_fragment="heraclitis" heraclitis=""
    >>> set_string_if_unset_or_empty "${fifty_fourth_fragment}" "Aeon"
    >>> print_string "${fifty_fourth_fragment}"
    Aeon
'
function set_string_if_unset_or_empty() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_variable_string "${string_name}"

    # Set such string if unset or empty.
    noop ${(P)string_name:=${2}}
}

document_function '
void set_string_if_unset_or_empty_to_evaluation(
  string string_name, string code)

Set the passed variable if unset or empty to the dynamic evaluation of the
passed code in a double-quoted context (i.e., in an expression "${code}").
'
function set_string_if_unset_or_empty_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name="${1}"
    die_unless_variable_string "${string_name}"

    # Set such string if unset or empty to such evaluation.
    is_string_nonempty "${string_name}" or eval "${string_name}=\"${2}\""
}

# ....................{ CONVERTERS                         }....................
document_function '
string capitalize_string(string text1, string text2, ...)

Capitalize the first letter of each word of the passed strings: e.g.,

    >>> capitalize_string "phase two: ???" "phase three: profit"
    Phase Two: ??? Phase Three: Profit
'
function capitalize_string() {
    die_unless_args 'expected at least one string'
    print_string "${(C)*}"
}

document_function '
string lowercase_string(string text1, string text2, ...)

Convert the passed string to all lowercase_string: e.g.,

    >>> lowercase_string "The Wind in" "the Pillows"
    the wind in the pillows
'
function lowercase_string() {
    die_unless_args 'expected at least one string'
    print_string "${(L)*}"
}

document_function '
string uppercase_string(string text1, string text2, ...)

Convert the passed string to all uppercase_string: e.g.,

    >>> uppercase_string "The Pyre of" "My Loins"
    THE PYRE OF MY LOINS
'
function uppercase_string() {
    die_unless_args 'expected at least one string'
    print_string "${(U)*}"
}

# ....................{ MUNGERS                            }....................
document_function '
string prefix_string(string text, string prefix)

Prefix the passed string with the passed prefix, if not already: e.g.,

    >>> prefix_string "/creatures/collect/and/gather/" "/"
    /creatures/collect/and/gather/
'
function prefix_string() {
    die_unless_args_2 'expected one string and one prefix'
    print_string "${2}${1#${2}}"
}

document_function '
string suffix_string(string text, string suffix)

Suffix the passed string with the passed suffix, if not already: e.g.,

    >>> suffix_string "/habitat/failing/flailing/habits/" "/"
    /habitat/failing/flailing/habits/
'
function suffix_string() {
    die_unless_args_2 'expected one string and one suffix'
    print_string "${1%${2}}${2}"
}

document_function '
string repeat_string(string text, integer count)

Repeat the passed string the passed number of times: e.g.,

    >>> repeat_string "Slavoj Žižek" 5
    Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
'
function repeat_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one integer'
    string text="${1}" count="${2}"
    die_unless_string_nonempty "${text}" 'passed empty string'
    die_unless_integer_nonnegative "${count}"

    #FIXME: This can be dramatically improved upon by recalling that
    #set_list_to_string_split_on_delimiter() currently concocts an impressive
    #algorithm for efficiently finding the first available free token (e.g.,
    #":", ".", "'", '"', and so on). Generalize such algorithm into a new
    #function accepting only a single string and:
    #
    #* If an available free token exists for such string, returning non-zero
    #  exit status and printing such token;
    #* Otherwise, returning zero exit status and printing nothing.
    #
    #Assuming such function to be sensibly named
    #get_string_parameter_expansion_token(), call such function as follows:
    #
    #    string token
    #    if token="$(get_string_parameter_expansion_token "${text}")"
    #    then # ...do something with the token!
    #    else # ...otherwise try to find another way to do it or just die.
    #    fi
    #
    #Awesomeness!

    # zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former slower command.
    # * Otherwise, run the latter faster command.
    if is_string_substring "${text}" ':'; then
        # Since printf() appends no newline by default, do so.
        printf "${text}%.0s" {1..${count}}
        print_newline
    else
        # Total length of the repeated result, below.
        integer result_length
        (( result_length = count * $(get_string_length "${text}") ))

        # Print such result.
        eval "print -- \${(l:\${result_length}::${text}:):-}"
    fi
}

# ....................{ REMOVERS                           }....................
document_function '
string remove_string_substrings(string text, string substring)

Remove all instances of the passed substring from the passed string: e.g.,

    >>> remove_string_substrings "thomas ligotti" "t"
    homas ligoi
'
function remove_string_substrings() {
    die_unless_args_2 'expected one string and one substring'
    print_string "${1//${2}}"
}

document_function '
string remove_string_prefix(string text, string prefix)

Remove the passed prefix from the passed string: e.g.,

    >>> remove_string_prefix "zealia brown" "zeal"
    ia brown
'
function remove_string_prefix() {
    die_unless_args_2 'expected one string and one prefix'
    print_string "${1##${2}}"
}

document_function '
string remove_string_suffix(string text, string suffix)

Remove the passed suffix from the passed string: e.g.,

    >>> remove_string_suffix "august derleth" "leth"
    august der
'
function remove_string_suffix() {
    die_unless_args_2 'expected one string and one suffix'
    print_string "${1%%${2}}"
}

document_function '
string truncate_string(
  string text, integer maximum_length, string text_suffix_if_truncated = '')

Truncate the passed string to the passed length, replacing the end of such
string with the passed suffix (defaulting to the empty string) if the passed
string exceeds such length: e.g.,

    >>> truncate_string "Fallujah" 7
    Falluja
    >>> truncate_string "Fallujah" 7 "..."
    Fall...
'
function truncate_string() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one length, and optional suffix'
    string text="${1}" max_length="${2}" text_suffix_if_truncated="${3:-}"
    die_unless_integer_positive "${max_length}"

    # If the passed string requires no truncation, return the same string.
    (( #text <= max_length )) and {
        print_string "${text}"
        return_true
    }

    # If a suffix was passed and the passed string is at least as long as such
    # suffix, truncate by replacing the end of the string with such suffix.
    if (( #text_suffix_if_truncated &&
          #text > #text_suffix_if_truncated )); then
        (( max_length -= #text_suffix_if_truncated ))
#       print "max_length: ${max_length}"
        print_string "${text[1,${max_length}]}${text_suffix_if_truncated}"
    # Otherwise, truncate without suffix replacement.
    else print_string "${text[1,${max_length}]}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#       print "result length: ${result_length}"
#   else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
#FUXME: Rename to remove_string_substrings(). The current nomenclature implies
#removal of only one such substring, which is not the case.
#FUXME: For consistency, the following functions should be renamed
#die_unless_variable_string(), die_unless_variable_character(), and so on.
#Naturally, that implies similar renamings of list *TYPE TESTING* functions to
#die_unless_variable_list(), die_unless_variable_map(), is_variable_list(), and
#so on. *BUT STOP THERE.* Rename only functions testing variable types in this
#manner; all other existing functions (in particular, non-type testing list and
#map functions such as join_list_on_newline() and get_list_size()) *RETAIN THEIR
#EXISTING FUNCTION NAMES*. This gives us the best of all worlds: consistent
#naming for functions testing variable type, concise and consistent naming for
#list and map functions, and concise and consistent naming for string functions.
#
#This is good. It's a simple patch, so make it so.

#       integer suffix_length
#       suffix_length="$(get_string_length "${suffix_if_exceeding_max_length}")"
#       (( max_length >  suffix_length )) && {
#           (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
#           print_string "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
#           return_true
#       }
#   }

    # Otherwise, truncate without suffix replacement.
#   print_string "${text[1,${max_length}]}"

#FUXME: Bad. Remove entirely, replacing existing calls with
#die_unless_variable_nonempty().
# void die_unless_variable_nonempty(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function die_unless_variable_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_variable_nonempty "${1}" or
#        die "${2:-\"${1}\" not a string or empty}"
#}

#FUXME: Bad. Remove entirely, replacing existing calls with
#is_variable_nonempty().
# boolean is_variable_nonempty(string variable_name)
#
# Return true if the passed variable is a nonempty string.
#function is_variable_nonempty() {
#    die_unless_arg 'expected one variable name'
#    string variable_name="${1}"
#    is_variable_string "${variable_name}" and (( ${#${(P)variable_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"

#FUXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FUXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string is_string_substring(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    print_string "${*[(w)1]}"
#}

#       say "piped_input: $(get_standard_input_piped)"
#       text="$(get_standard_input_piped)"
    # Validate passed arguments.
#   print -lr -- "${(uf)@}"
#   print_string_newlined ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           print_string ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FUXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize passed arguments.
#    die_unless_args_2_or_more\
#        'expected one line number and one or more strings'
#    die_unless_integer "${1}"
#    integer highlight_line_index="${1}" line_length
#    behead_arg
#    string text="${@}"

#FUXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list() to join_list_on() and
#join_join_list_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FUXME: Right. join_list() is simply too brief. join_join_list() reads
#better.

    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   curtail_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_NL_OPTIONS[@]}" )
#   print_string "${text}" | {
#       if is_shell_interactive
#       then "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FUXME: Implementable with pure-Zsh.
#   print_string "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_arg 'expected one string'
#   print_string "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_variable "${target_name_prefix}" or string ${target_name_prefix}
#   is_variable "${target_name_suffix}" or string ${target_name_suffix}
#   is_variable "${list_name}" or list "${list_name}"

#   die_unless_variable_string "${target_name_prefix}"
#   die_unless_variable_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
