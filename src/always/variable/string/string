#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string variables.

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_length(string text1, string text2, ...)

Get the total length of the passed strings in single-byte characters. Consider
calling get_string_length_printable() instead if any such string contains
multibyte characters (e.g., UTF-8-encoded Unicode).
________________<heredoc?>________________
function get_string_length() {
    # Due to zsh eccentricity, this expansion *CANNOT* be reduced to either
    # "${#*}", "${#@}", or "${#${@}}". However sensible such expansions may
    # seem, they all obstinately return the number of passed arguments. *sigh*
    # (Don't get us wrong: we know why such reductions fail. They gall, though!)
    #
    # Reducing this expansion to "${#${*}}" successfully returns the string
    # length in all cases *EXCEPT* when the empty string is passed, in which
    # case such expansion erroneously returns 1 rather than 0. Strangely,
    # assigning passed arguments to a local variable before testing the length
    # of such variable corrects this edge case.
    die_unless_args 'expected at least one string'
    string text="${*}"
    return_string "${#text}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_length_printable(string text)

Get the length of the passed string in printable multibyte characters, thus
treating control characters (e.g., newline, tab) as 0 characters for counting
purposes. Unfortunately, zsh currently provides no builtin means for counting
such characters as 1 character: e.g.,

.get_string_length_printable()
==========================================
[source]
------------------------------------------
>>> get_string_length_printable "${ZESHY_ASCII_NEWLINE}"
0
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_length_printable() {
    # See get_string_length() for discussion.
    die_unless_args 'expected at least one string'
    string text="${*}"
    return_string "${(m)#text}"
}

# ....................{ GETTERS ~ count                    }....................
#FIXME: Rename to get_string_substrings_count().
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_substrings_count(string text, string substring)

Get the number of instances of the passed substring in the passed string: e.g.,

.get_string_substrings_count()
==========================================
[source]
------------------------------------------
>>> string welcome_to_our_fortress_tall="
...     Military intelligence, two words combined that can't make sense."
>>> get_string_substrings_count "${welcome_to_our_fortress_tall}" 'in'
2
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_substrings_count() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one substring'
    string text="${1}" substring="${2}"

    # Remove such substrings from such string.
    string text_with_substrings_removed; text_with_substrings_removed="$(\
        remove_string_substrings "${text}" "${substring}")"

    # Get the number of such substrings by differencing the lengths of such
    # string and such string with all such substrings removed, divided by the
    # length of such substring. For efficiency, avoid calling
    # get_string_length().
    return_string\
        $(( (${#text} - ${#text_with_substrings_removed}) / ${#substring} ))
}

# ....................{ MUNGERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string reverse_string(string text1, string text2, ...)

Reverse the passed strings: e.g.,

.reverse_string()
==========================================
[source]
------------------------------------------
>>> reverse_string 'Steve Cutts: "And Then Man Came"'
"emaC naM nehT dnA" :sttuC evetS
------------------------------------------
==========================================
________________<heredoc?>________________
function reverse_string() {
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... something.
    die_unless_args 'expected at least one string'
    list chars chars_reversed

    # Split such strings on characters.
    set_list_to_string_characters chars "${*}"

    # Reverse such list.
    set_list_to_list_reversed chars_reversed chars

    # Concatenate such list elements.
    join_list chars_reversed
}

# ....................{ MUNGERS ~ case                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string capitalize_string(string text1, string text2, ...)

Capitalize the first letter of each word of the passed strings: e.g.,

.capitalize_string()
==========================================
[source]
------------------------------------------
>>> capitalize_string "phase two: ???" "phase three: profit"
Phase Two: ??? Phase Three: Profit
------------------------------------------
==========================================
________________<heredoc?>________________
function capitalize_string() {
    die_unless_args 'expected at least one string'
    return_string "${(C)*}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string lowercase_string(string text1, string text2, ...)

Convert the passed string to all lowercase: e.g.,

.lowercase_string()
==========================================
[source]
------------------------------------------
>>> lowercase_string "The Wind in" "the Pillows"
the wind in the pillows
------------------------------------------
==========================================
________________<heredoc?>________________
function lowercase_string() {
    die_unless_args 'expected at least one string'
    return_string "${(L)*}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string uppercase_string(string text1, string text2, ...)

Convert the passed string to all uppercase: e.g.,

.uppercase_string()
==========================================
[source]
------------------------------------------
>>> uppercase_string "The Pyre of" "My Loins"
THE PYRE OF MY LOINS
------------------------------------------
==========================================
________________<heredoc?>________________
function uppercase_string() {
    die_unless_args 'expected at least one string'
    return_string "${(U)*}"
}

# ....................{ MUNGERS ~ fix                      }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string prefix_string(string text, string prefix)

Prefix the passed string with the passed prefix, if not already: e.g.,

.prefix_string()
==========================================
[source]
------------------------------------------
>>> prefix_string "/creatures/collect/and/gather/" "/"
/creatures/collect/and/gather/
------------------------------------------
==========================================
________________<heredoc?>________________
function prefix_string() {
    die_unless_args_2 'expected one string and one prefix'
    return_string "${2}${1#${2}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string suffix_string(string text, string suffix)

Suffix the passed string with the passed suffix, if not already: e.g.,

.suffix_string()
==========================================
[source]
------------------------------------------
>>> suffix_string "/habitat/failing/flailing/habits/" "/"
/habitat/failing/flailing/habits/
------------------------------------------
==========================================
________________<heredoc?>________________
function suffix_string() {
    die_unless_args_2 'expected one string and one suffix'
    return_string "${1%${2}}${2}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string repeat_string(string text, integer count)

Repeat the passed string the passed number of times: e.g.,

.repeat_string()
==========================================
[source]
------------------------------------------
>>> repeat_string "Slavoj Žižek" 5
Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
------------------------------------------
==========================================
________________<heredoc?>________________
function repeat_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one integer'
    string text="${1}" count="${2}" token
    die_unless_integer_nonnegative "${count}"

    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; all of the implementations below assume a
    # positive count. The printf()-based implementation, for example, actually
    # repeats the desired string twice rather than printing the empty string
    # when passed a count of 0.
    (( count )) or return_true

    # If such text does *NOT* contain at least one parameter expansion token,
    # prefer token- to printf()-based repetition. The latter expands the
    # expression "{1..${count}}" to ${count} number of integer arguments and
    # hence fails to efficiently scale to large counts.
    if { token="$(get_string_parameter_expansion_token_if_found "${text}")" } {
        # Total string length after repeating such string below.
        integer result_length
        (( result_length = count * $(get_string_length "${text}") ))

        # Repeat such string.
        eval "return_string \${(l${token}${result_length}${token}${token}${text}${token}):-}"
    # Else, perform printf()-based repetition.
    } else {
        # For safety, escape percent signs in such string.
        printf -- "$(escape_string_for_printf "${text}")%.0s" {1..${count}}

        # Since printf() appends no newline by default, do so.
        output_string "${ZESHY_ASCII_NEWLINE}"
    }
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string remove_string_substrings(string text, string substring)

Remove all instances of the passed substring from the passed string: e.g.,

.remove_string_substrings()
==========================================
[source]
------------------------------------------
>>> remove_string_substrings "thomas ligotti" "t"
homas ligoi
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_substrings() {
    die_unless_args_2 'expected one string and one substring'
    return_string "${1//${2}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string remove_string_prefix(string text, string prefix)

Remove the passed prefix from the passed string: e.g.,

.remove_string_prefix()
==========================================
[source]
------------------------------------------
>>> remove_string_prefix "zealia brown" "zeal"
ia brown
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_prefix() {
    die_unless_args_2 'expected one string and one prefix'
    return_string "${1##${2}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string remove_string_suffix(string text, string suffix)

Remove the passed suffix from the passed string: e.g.,

.remove_string_suffix()
==========================================
[source]
------------------------------------------
>>> remove_string_suffix "august derleth" "leth"
august der
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_suffix() {
    die_unless_args_2 'expected one string and one suffix'
    return_string "${1%%${2}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string truncate_string(
  string text, integer maximum_length, string text_suffix_if_truncated = "")

Truncate the passed string to the passed length, replacing the end of such
string with the passed suffix (defaulting to the empty string) if the passed
string exceeds such length: e.g.,

.truncate_string()
==========================================
[source]
------------------------------------------
>>> truncate_string "Fallujah" 7
Falluja
>>> truncate_string "Fallujah" 7 "..."
Fall...
------------------------------------------
==========================================
________________<heredoc?>________________
function truncate_string() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one length, and optional suffix'
    string text="${1}" max_length="${2}" text_suffix_if_truncated="${3:-}"
    die_unless_integer_positive "${max_length}"

    # If the passed string requires no truncation, return the same string.
    (( ${#text} <= max_length )) and return_string "${text}"

    # If a suffix was passed and the passed string is at least as long as such
    # suffix, truncate by replacing the end of the string with such suffix.
    if (( ${#text_suffix_if_truncated} &&
          ${#text} > ${#text_suffix_if_truncated} )) {
        (( max_length -= #text_suffix_if_truncated ))
#       print "max_length: ${max_length}"
        return_string "${text[1,${max_length}]}${text_suffix_if_truncated}"
    # Otherwise, truncate without suffix replacement.
    } else {
        return_string "${text[1,${max_length}]}"
    }
}

# ....................{ TABULATORS                         }....................
#FIXME: Rename to tabulate_string_on_string().
declare_function_with_stdin <<'________________<heredoc?>________________'
string tabulate_string_on_separator(string text, character separator)

Tabulate the passed string on one or more characters matching the passed
separator character into horizontally aligned columns.
________________<heredoc?>________________
function tabulate_string_on_separator() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one separator'
    string text="${1}" separator="${2}"
    die_unless_character "${separator}"

    # Tabulate such string.
    output_string "${text}" | command column -t -s "${separator}"
}

# ....................{ TABULATORS ~ whitespace            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string tabulate_string_on_whitespace(string text1, string text2, ...)

Tabulate the passed strings on one or more whitespace characters into
horizontally aligned columns.
________________<heredoc?>________________
function tabulate_string_on_whitespace() {
    die_unless_args 'expected at least one string'
    output_string "${*}" | command column -t
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string tabulate_stdin_on_whitespace[stdin: string input]

Tabulate standard input on one or more whitespace characters into horizontally
aligned columns.
________________<heredoc?>________________
function tabulate_stdin_on_whitespace() {
    die_unless_stdin_nonempty
    < "${ZESHY_STDIN_PATH}" | command column -t
}

# --------------------( WASTELANDS                         )--------------------
    # zsh implements string repetition in one of two ways:
    #
    # * With the "l" parameter expansion flag, as below.
    # * With the printf() builtin, as below.
    #
    # While the former fails in the unlikely event such text contains all
    # possible parameter expansion tokens, the 
    # avoids the multiplication of the former, it also
    # expands the expression "{1..${count}}" to all integers in such range and
    # hence fails to efficiently scale to large counts. On the other hand, the
    # latter . Prefer the  We reconcile these differences as follows:
    #
    # * If such text does *NOT* contain at least one such token, perform the
    #   latter with such token.
    # * Else, perform the former.
#FUXME: Contemplate renaming back to is_string_contains(), which reads much more
#naturally than this. Search for other instances of "_substring" in function
#names; perhaps we had a respectable reason for adopting such nomenclature?
#FUXME: Yeah. This is great. Rename back to is_string_contains(), in keeping
#with the existing is_string_equals() nomenclature. But the *REAL* reason is
#much more compelling: because we have numerous other functions elsewhere testing
#containment, each currently with their own domain-specific nomenclature
#(e.g., is_list_contains()). *THIS IS NONSENSE.* All containment testers should
#share the same nomenclature: _contains(). Why? Because anything else induces
#thinking on trying to remember the domain-specific noun for testing that
#particular type of containment, which ends up being just horrible. (Even I
#can't keep it straight.) Hence, rename is_list_contains() to is_list_contains()
#as well.
    #FUXME: This can be dramatically improved upon by recalling that
    #set_list_to_string_split_on_string() currently concocts an impressive
    #algorithm for efficiently finding the first available free token (e.g.,
    #":", ".", "'", '"', and so on). Generalize such algorithm into a new
    #function accepting only a single string and:
    #
    #* If an available free token exists for such string, returning non-zero
    #  exit status and printing such token;
    #* Otherwise, returning zero exit status and printing nothing.
    #
    #Assuming such function to be sensibly named
    #get_string_parameter_expansion_token(), call such function as follows:
    #
    #    string token
    #    if token="$(get_string_parameter_expansion_token "${text}")"
    #    then # ...do something with the token!
    #    else # ...otherwise try to find another way to do it or just die.
    #    fi
    #
    #Awesomeness!

    # zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former slower command.
    # * Otherwise, run the latter faster command.
#   if { is_string_contains "${text}" ':' } {
        # Since printf() appends no newline by default, do so.
#       printf -- "${text}%.0s" {1..${count}}
#       return_string "${ZESHY_ASCII_NEWLINE}"
#   } else {
        # Total length of the repeated result, below.
#       integer result_length
#       (( result_length = count * $(get_string_length "${text}") ))

        # Print such result.
#       eval "return_string \${(l:\${result_length}::${text}:):-}"
#   }

#   die_unless_string_nonempty "${text}" 'string to be repeated empty'
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... something.
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string get_string_substring_count(string string, string substring)
#
#Get the number of instances of the passed substring in the passed string: e.g.,
#
#.get_string_substring_count()
#==========================================
#[source]
#------------------------------------------
#>>> get_string_substring_count "cult of radical consumerism" "c"
#3
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function get_string_substring_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
#   die_unless_args_2 'expected one string and one substring'
#   string text="${1}" substring="${2}" string_sans_substring
#   string_sans_substring="${text//${substring}}"
#   return_string $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
#}

#FUXME: Rename to set_string_if_unset_to_string().
#declare_function '
#void set_string_if_unset(string string_name, string text)
#
#Set the passed variable if unset to the passed string: e.g.,
#
#    >>> string gnomes_say="hooray" hooray
#    >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
#    >>> print_string "${hooray}"
#    lesser lights of the Bardo
#'
#function set_string_if_unset() {
#    die_unless_args_2 'expected one variable name and one string'
#    noop ${(P)1=${2}}
#}

#declare_function '
#integer get_string_length_printable(string text)
#
#Get the number of  length of the passed string in multibyte characters.
#'
#function get_string_length_printable() {
#    # While parameter flag "(mm)" counts multibyte characters, parameter flag
#    # "(m)" counts only printable multibyte characters, thus ignoring control
#    # characters (e.g., newline). See get_string_length() for further caveats.
#    die_unless_args 'expected at least one string'
#    print_string "${(mm)#${*}}"
#}

#       print "result length: ${result_length}"
#   else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
#FUXME: Rename to remove_string_substrings(). The current nomenclature implies
#removal of only one such substring, which is not the case.
#FUXME: For consistency, the following functions should be renamed
#die_unless_variable_string(), die_unless_character(), and so on.
#Naturally, that implies similar renamings of list *TYPE TESTING* functions to
#die_unless_variable_list(), die_unless_variable_map(), is_variable_list(), and
#so on. *BUT STOP THERE.* Rename only functions testing variable types in this
#manner; all other existing functions (in particular, non-type testing list and
#map functions such as join_list_on_newline() and get_list_size()) *RETAIN THEIR
#EXISTING FUNCTION NAMES*. This gives us the best of all worlds: consistent
#naming for functions testing variable type, concise and consistent naming for
#list and map functions, and concise and consistent naming for string functions.
#
#This is good. It's a simple patch, so make it so.

#       integer suffix_length
#       suffix_length="$(get_string_length "${suffix_if_exceeding_max_length}")"
#       (( max_length >  suffix_length )) && {
#           (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
#           print_string "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
#           return_true
#       }
#   }

    # Otherwise, truncate without suffix replacement.
#   print_string "${text[1,${max_length}]}"

#FUXME: Bad. Remove entirely, replacing existing calls with
#die_unless_variable_nonempty().
# void die_unless_variable_nonempty(
#   string string_name,
#   string error_message = "\"${string_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function die_unless_variable_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_variable_nonempty "${1}" or
#        die "${2:-\"${1}\" not a string or empty}"
#}

#FUXME: Bad. Remove entirely, replacing existing calls with
#is_variable_nonempty().
# boolean is_variable_nonempty(string string_name)
#
# Return true if the passed variable is a nonempty string.
#function is_variable_nonempty() {
#    die_unless_arg 'expected one variable name'
#    string string_name="${1}"
#    is_variable_string "${string_name}" and (( ${#${(P)string_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"

#FUXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FUXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string is_string_contains(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    print_string "${*[(w)1]}"
#}

#       print_message "piped_input: $(get_stdin_piped)"
#       text="$(get_stdin_piped)"
    # Validate passed arguments.
#   print -lr -- "${(uf)@}"
#   print_strings_newlined ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           print_string ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FUXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize passed arguments.
#    die_unless_args_2_or_more\
#        'expected one line number and one or more strings'
#    die_unless_integer "${1}"
#    integer highlight_line_index="${1}" line_length
#    shift_arg
#    string text="${@}"

#FUXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list() to join_list_on() and
#join_join_list_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FUXME: Right. join_list() is simply too brief. join_join_list() reads
#better.

    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_NL_OPTIONS[@]}" )
#   print_string "${text}" | {
#       if is_shell_interactive
#       then "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FUXME: Implementable with pure-zsh.
#   print_string "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_arg 'expected one string'
#   print_string "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_string_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_variable "${target_name_prefix}" or string ${target_name_prefix}
#   is_variable "${target_name_suffix}" or string ${target_name_suffix}
#   is_variable "${list_name}" or list "${list_name}"

#   die_unless_variable_string "${target_name_prefix}"
#   die_unless_variable_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
