#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'---'
Handle supplementary string functionality.
---

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_string_length(string text1, string text2, ...)

Get the total length of the passed strings in single-byte characters. Consider
calling get_string_length_printable() instead if any such string contains
multibyte characters (e.g., UTF-8-encoded Unicode): e.g.,

.get_string_length()
==========================================
[source]
------------------------------------------
>>> string on_worrisome_rides=\
...    "The world is like a ride in an amusement park, and when you choose to go
...     on it you think it's real because that's how powerful our minds are. The
...     ride goes up and down, around and around, it has thrills and chills, and
...     it's very brightly colored, and it's very loud, and it's fun for a
...     while. Many people have been on the ride a long time, and they begin to
...     wonder, \"Hey, is this real, or is this just a ride?\" And other people
...     have remembered, and they come back to us and say, \"Hey, don't worry;
...     don't be afraid, ever, because this is just a ride.\" And we kill those
...     people. \"Shut him up! I've got a lot invested in this ride, shut him
...     up! Look at my furrows of worry, look at my big bank account, and my
...     family. This has to be real.\""
>>> string on_better_rides=\
...    "It's just a ride. But we always kill the good guys who try and tell us
...     that, you ever notice that? And let the demons run amok. But it doesn't
...     matter, because it's just a ride. And we can change it any time we want.
...     It's only a choice. No effort, no work, no job, no savings of money.
...     Just a simple choice, right now, between fear and love. The eyes of fear
...     want you to put bigger locks on your doors, buy guns, close yourself
...     off. The eyes of love instead see all of us as one. Here's what we can
...     do to change the world, right now, to a better ride. Take all that money
...     we spend on weapons and defenses each year and instead spend it feeding
...     and clothing and educating the poor of the world, which it would pay for
...     many times over, not one human being excluded, and we could explore
...     space, together, both inner and outer, forever, in peace."
>>> get_string_length "${on_worrisome_rides}" "${on_better_rides}"
1578
------------------------------------------
/---
function get_string_length() {
    # Due to zsh eccentricity, this expansion *CANNOT* be reduced to either
    # "${#*}", "${#@}", or "${#${@}}". However sensible such expansions may
    # seem, they all obstinately return the number of passed arguments. *sigh*
    # (Don't get us wrong: we know why such reductions fail. They gall, though.)
    #
    # Reducing this expansion to "${#${*}}" successfully returns the string
    # length in all cases *EXCEPT* when the empty string is passed, in which
    # case such expansion erroneously returns 1 rather than 0. Strangely,
    # assigning passed arguments to a local variable before testing the length
    # of such variable corrects this edge case.
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    output_string ${#text}
}

declare_function_with_stdin <<'/---'
integer get_string_length_printable(string text)

Get the length of the passed string in printable multibyte characters, thus
treating *control characters* (e.g., newline, tab) as 0 characters for counting
purposes. Unfortunately, `zsh` currently provides no builtin means for counting
such characters as 1 character: e.g.,

.get_string_length_printable()
==========================================
[source]
------------------------------------------
>>> string on_informed_decisions=\
...     "Wouldn't you like to see a positive LSD story on the news? To base your
...      decision on information rather than scare tactics and superstition?
...      Perhaps? Wouldn't that be interesting? Just for once?"
>>> string on_the_holographic_principle=\
...     "\"Today, a young man on acid realized that all matter is merely energy
...      condensed to a slow vibration – that we are all one consciousness
...      experiencing itself subjectively. There's no such thing as death, life
...      is only a dream, and we're the imagination of ourselves. Here's Tom
...      with the weather.\""
>>> get_string_length_printable\
...     "${on_informed_decisions}" "${on_the_holographic_principle}"
481
>>> get_string_length_printable "${ZESHY_ASCII_NEWLINE}"
0
>>> get_string_length_printable "${ZESHY_ASCII_NEWLINE}Gnosis"
6
------------------------------------------
==========================================
/---
function get_string_length_printable() {
    # See get_string_length() for discussion.
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    output_string ${(m)#text}
}

# ....................{ GETTERS ~ count                    }....................
#FIXME: "Count" is a verb as well as noun. Hence, rename this function to
#count_string_text() *AND* rename all other function names matching
#*"_count"* similarly.

declare_function_with_stdin <<'/---'
integer get_string_text_count(string text, string substring)

Get the number of instances of the passed substring in the passed string: e.g.,

.get_string_text_count()
==========================================
[source]
------------------------------------------
>>> string on_war_as_peace=\
...    "Launch the Polaris.
...     The end doesn't scare us.
...     The warheads will all rust in peace.
...     Eradication of
...     Earth's population loves
...     Polaris."
>>> get_string_text_count "${on_war_as_peace}" 'ar'
3
------------------------------------------
==========================================
/---
function get_string_text_count() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one string and one substring.'
    string text="${1}" substring="${2}" text_with_substrings_removed

    # Remove such substrings from such string.
    text_with_substrings_removed="$(\
        remove_string_text "${text}" "${substring}")"

    # Get the number of such substrings by differencing the lengths of such
    # string and such string with all such substrings removed, divided by the
    # length of such substring. For efficiency, avoid calling
    # get_string_length().
    output_string\
        $(( (${#text} - ${#text_with_substrings_removed}) / ${#substring} ))
}

# ....................{ MUNGERS                            }....................
declare_function_with_stdin <<'/---'
string reverse_string(string text1, string text2, ...)

Reverse the passed strings: e.g.,

.reverse_string()
==========================================
[source]
------------------------------------------
>>> reverse_string "Satan, oscillate my metallic sonatas!"
!satanos cillatem ym etallicso ,nataS
>>> reverse_string "Mr. Owl ate my metal worm..."
...mrow latem ym eta lwO .rM
>>> reverse_string "Rats live on no evil star."
.rats live on no evil staR
------------------------------------------
==========================================
/---
function reverse_string() {
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... something.
    die_unless_args 'Expected at least one string.'
    list chars chars_reversed

    # Split such strings on characters.
    set_list_to_string_characters chars "${*}"

    # Reverse such list.
    set_list_to_list_reversed chars_reversed chars

    # Concatenate such list elements.
    join_list chars_reversed
}

# ....................{ MUNGERS ~ case                     }....................
declare_function_with_stdin <<'/---'
string capitalize_string(string text1, string text2, ...)

Capitalize the first letter of each word of the passed strings: e.g.,

.capitalize_string()
==========================================
[source]
------------------------------------------
>>> string on_modernity=\
...    "Why are we sad and miserable?  Because our modern culture has failed.
...     We are all failures. The world around us has failed to sustain our
...     humanity, our spirituality. The deep woe inside black metal is about
...     fear, that we can never return to the mythic pastoral world that we
...     crave on a deep subconscious level... for modernity has transformed us –
...     our minds, bodies and spirit – into an alien life form, one not suited
...     to life on Earth without the mediating forces of technology, culture,
...     and organized religion. We are weak and pitiful in our strength over the
...     Earth. In conquering, we have destroyed ourselves."
>>> capitalize_string "${on_modernity}"
Why Are We Sad And Miserable? Because Our Modern Culture Has Failed.
We Are All Failures. The World Around Us Has Failed To Sustain Our
Humanity, Our Spirituality. The Deep Woe Inside Black Metal Is About
Fear, That We Can Never Return To The Mythic Pastoral World That We
Crave On A Deep Subconscious Level... For Modernity Has Transformed Us –
Our Minds, Bodies And Spirit – Into An Alien Life Form, One Not Suited
To Life On Earth Without The Mediating Forces Of Technology, Culture,
And Organized Religion. We Are Weak And Pitiful In Our Strength Over The
Earth. In Conquering, We Have Destroyed Ourselves.
------------------------------------------
==========================================
/---
function capitalize_string() {
    die_unless_args 'Expected at least one string.'
    output_string "${(C)*}"
}

declare_function_with_stdin <<'/---'
string lowercase_string(string text1, string text2, ...)

Convert the passed string to all lowercase: e.g.,

.lowercase_string()
==========================================
[source]
------------------------------------------
>>> string on_air_pollution_warnings=\
...    "Awakened in the morning
...     To more air pollution warnings.
...     Still we sleepwalk off to work
...     While our nervous systems jerk."
>>> lowercase_string "${on_air_pollution_warnings}"
awakened in the morning
to more air pollution warnings.
still we sleepwalk off to work
while our nervous systems jerk
------------------------------------------
==========================================
/---
function lowercase_string() {
    die_unless_args 'Expected at least one string.'
    output_string "${(L)*}"
}

declare_function_with_stdin <<'/---'
string uppercase_string(string text1, string text2, ...)

Convert the passed string to all uppercase: e.g.,

.uppercase_string()
==========================================
[source]
------------------------------------------
>>> string on_body_parts=\
...    "We know how to and sure as shit we'll win.
...     War is peace. (Sure, man.)
...     A retreat for the damned;
...     A playground for the demented;
...     A haven for those who walk this world
...     Bereft of heart and soul.
...     Love and war – they say all is fair.
...     Take his life
...     But won't take his hair.
...     Your body has parts your
...     Country can spare.
...     By the way, son,
...     Here's your wheelchair."
>>> uppercase_string "${on_body_parts}"
WE KNOW HOW TO AND SURE AS SHIT WE'LL WIN.
WAR IS PEACE. (SURE, MAN.)
A RETREAT FOR THE DAMNED;
A PLAYGROUND FOR THE DEMENTED;
A HAVEN FOR THOSE WHO WALK THIS WORLD
BEREFT OF HEART AND SOUL.
LOVE AND WAR – THEY SAY ALL IS FAIR.
TAKE HIS LIFE
BUT WON'T TAKE HIS HAIR.
YOUR BODY HAS PARTS YOUR
COUNTRY CAN SPARE.
BY THE WAY, SON,
HERE'S YOUR WHEELCHAIR.
------------------------------------------
==========================================
/---
function uppercase_string() {
    die_unless_args 'Expected at least one string.'
    output_string "${(U)*}"
}

# ....................{ MUNGERS ~ fix                      }....................
declare_function_with_stdin <<'/---'
string prefix_string(string text, string prefix)

Prefix the passed string with the passed prefix, if not already: e.g.,

.prefix_string()
==========================================
[source]
------------------------------------------
>>> string on_soldiers=\
...    "You don't hate! Only the unloved hate — the unloved and the unnatural."
>>> prefix_string "${on_soldiers}"\
...    "Soldiers! Don't give yourselves to brutes — men who despise you! Enslave
...     you! Who regiment your lives, tell you what to do, what to think or what
...     to feel! Who drill you, diet you, treat you like cattle, use you as
...     cannon fodder! Don't give yourselves to these unnatural men — machine
...     men with machine minds and machine hearts! You are not machines! You are
...     not cattle! You are men! You have the love of humanity in your hearts."
Soldiers! Don't give yourselves to brutes — men who despise you! Enslave
you! Who regiment your lives, tell you what to do, what to think or what
to feel! Who drill you, diet you, treat you like cattle, use you as
cannon fodder! Don't give yourselves to these unnatural men — machine
men with machine minds and machine hearts! You are not machines! You are
not cattle! You are men! You have the love of humanity in your hearts.
You don't hate! Only the unloved hate — the unloved and the unnatural.
------------------------------------------
==========================================
/---
function prefix_string() {
    die_unless_args_2 'Expected one string and one prefix.'
    output_string "${2}${1#${2}}"
}

declare_function_with_stdin <<'/---'
string suffix_string(string text, string suffix)

Suffix the passed string with the passed suffix, if not already: e.g.,

.suffix_string()
==========================================
[source]
------------------------------------------
>>> string on_ashcans_and_unobtainable_dollars=\
...    "Moloch the incomprehensible prison! Moloch the crossbone soulless jail-
...     house and Congress of sorrows! Moloch whose buildings are judg-
...     ment! Moloch the vast stone of war! Moloch the stunned govern-
...     ments!"
>>> suffix_string "${on_ashcans_and_unobtainable_dollars}"\
...    "Moloch whose mind is pure machinery! Moloch whose blood is running
...     money! Moloch whose fingers are ten armies! Moloch whose breast
...     is a cannibal dynamo!  Moloch whose ear is a smoking tomb!"
Moloch the incomprehensible prison! Moloch the crossbone soulless jail-
 house and Congress of sorrows! Moloch whose buildings are judg-
 ment! Moloch the vast stone of war! Moloch the stunned govern-
 ments!
Moloch whose mind is pure machinery! Moloch whose blood is running
 money! Moloch whose fingers are ten armies! Moloch whose breast
 is a cannibal dynamo!  Moloch whose ear is a smoking tomb!
------------------------------------------
==========================================
/---
function suffix_string() {
    die_unless_args_2 'Expected one string and one suffix.'
    output_string "${1%${2}}${2}"
}

declare_function_with_stdin <<'/---'
string repeat_string(string text, integer count)

Repeat the passed string the passed number of times: e.g.,

.repeat_string()
==========================================
[source]
------------------------------------------
>>> repeat_string "Slavoj Žižek" 6
Slavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj ŽižekSlavoj Žižek
------------------------------------------
==========================================
/---
function repeat_string() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one string and one integer.'
    string text="${1}" count="${2}" token
    die_unless_integer_nonnegative "${count}"

    # If such count is 0, return the empty string. This isn't simply a trivial
    # edge-case optimization; all of the implementations below assume a
    # positive count. The printf()-based implementation, for example, actually
    # repeats the desired string twice rather than printing the empty string
    # when passed a count of 0.
    (( count )) or report_success

    # If such text does *NOT* contain at least one parameter expansion token,
    # prefer token- to printf()-based repetition. The latter expands the
    # expression "{1..${count}}" to ${count} number of integer arguments and
    # hence fails to efficiently scale to large counts.
    if { token="$(get_string_parameter_expansion_token_if_found "${text}")" } {
        # Total string length after repeating such string below.
        integer result_length
        (( result_length = count * $(get_string_length "${text}") ))

        # Repeat such string.
        eval "return_string \${(l${token}${result_length}${token}${token}${text}${token}):-}"
    # Else, perform printf()-based repetition.
    } else {
        # For safety, escape percent signs in such string.
        printf -- "$(escape_string_for_printf "${text}")%.0s" {1..${count}}

        # Since printf() appends no newline by default, do so.
        return_string "${ZESHY_ASCII_NEWLINE}"
    }
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
string remove_string_text(string text, string substring)

Remove all instances of the passed substring from the passed string and return
such string: e.g.,

.remove_string_text()
==========================================
[source]
------------------------------------------
>>> string on_the_rocks_of_time=\
...    "Moloch! Moloch! Robot apartments! invisible suburbs! skeleton treasuries!
...      blind capitals! demonic industries! spectral nations! invincible mad houses
...      granite cocks! monstrous bombs!
...     They broke their backs lifting Moloch to Heaven! Pavements, trees, radios,
...      tons! lifting the city to Heaven which exists and is everywhere about us!"
>>> remove_string_text "${on_the_rocks_of_time}" "Moloch"
! ! Robot apartments! invisible suburbs! skeleton treasuries!
 blind capitals! demonic industries! spectral nations! invincible mad houses
 granite cocks! monstrous bombs!
They broke their backs lifting to Heaven! Pavements, trees, radios,
 tons! lifting the city to Heaven which exists and is everywhere about us!
------------------------------------------
==========================================
/---
function remove_string_text() {
    die_unless_args_2 'Expected one string and one substring.'
    output_string "${1//${2}}"
}

declare_function_with_stdin <<'/---'
string remove_string_prefix(string text, string prefix)

Remove the passed prefix from the passed string if such prefix prefixes such
string or leave such string as is. In either case, return such string: e.g.,

.remove_string_prefix()
==========================================
[source]
------------------------------------------
>>> string on_the_heavy_judger_of_men=\
...    "Moloch whose eyes are a thousand blind windows! Moloch whose skyscrap-
...     ers stand in the long streets like endless Jehovahs! Moloch whose
...     factories dream and croak in the fog! Moloch whose smokestacks and
...     antennae crown the cities!"
>>> remove_string_prefix "${on_the_heavy_judger_of_men}"\
...    "Moloch whose eyes are a thousand blind windows!"
Moloch whose skyscrap-
 ers stand in the long streets like endless Jehovahs! Moloch whose
 factories dream and croak in the fog! Moloch whose smokestacks and
 antennae crown the cities!
------------------------------------------
==========================================
/---
function remove_string_prefix() {
    die_unless_args_2 'Expected one string and one prefix.'
    output_string "${1##${2}}"
}

declare_function_with_stdin <<'/---'
string remove_string_suffix(string text, string suffix)

Remove the passed suffix from the passed string if such suffix suffixes such
string or leave such string as is. In either case, return such string: e.g.,

.remove_string_suffix()
==========================================
[source]
------------------------------------------
>>> string on_light_streaming_out_of_the_sky=\
...    "Moloch whose love is endless oil and stone! Moloch whose soul is electricity
...     and banks! Moloch whose poverty is the specter of genius! Moloch
...     whose fate is a cloud of sexless hydrogen! Moloch whose name is the
...     Mind!"
>>> remove_string_suffix "${on_light_streaming_out_of_the_sky}" "Mind!"
Moloch whose love is endless oil and stone! Moloch whose soul is electricity
 and banks! Moloch whose poverty is the specter of genius! Moloch
 whose fate is a cloud of sexless hydrogen! Moloch whose name is the
------------------------------------------
==========================================
/---
function remove_string_suffix() {
    die_unless_args_2 'Expected one string and one suffix.'
    output_string "${1%%${2}}"
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_stdin_readable_sans_blocking

#...    "As for politics, I'm an anarchist. I hate governments and rules and
#...     fetters. Can't stand caged animals. People must be free."

#...     \"Military intelligence\": two words combined that can't make sense."
#FUXME: Rename to truncate_string_to_length().
#FUXME: Optional arguments are terrible. Split a new
#truncate_string_to_length_and_append_suffix() from this. (To be honest, pretty much
#*EVERY* call to this function should be passing a suffix, so renaming this to
#such function should fix us up tidely.)
#FUXME: You know what -- shouldn't pretty *EVERY* call to this function be
#replaced with the above truncate_string_for_message(), in which case this function
#can simply (and happily!) be deleted?

#declare_function_with_stdin <<'/---'
#string truncate_string(
#    string text, integer maximum_length, string text_suffix_if_truncated = "")
#
#Truncate the passed string to the passed length, replacing the end of such
#string with the passed suffix (defaulting to the empty string) if the passed
#string exceeds such length: e.g.,
#
#.truncate_string()
#==========================================
#[source]
#------------------------------------------
#>>> truncate_string "Fallujah" 7
#Falluja
#>>> truncate_string "Fallujah" 7 "..."
#Fall...
#------------------------------------------
#==========================================
#/---
#function truncate_string() {
#    # Validate passed arguments.
#    die_unless_args_2_to_3\
#        'expected one string, one length, and optional suffix'
#    string text="${1}" max_length="${2}" text_suffix_if_truncated="${3:-}"
#    die_unless_integer_positive "${max_length}"
#
#    # If the passed string requires no truncation, return the same string.
#    (( ${#text} <= max_length )) and return_string "${text}"
#
#    # If a suffix was passed and the passed string is at least as long as such
#    # suffix, truncate by replacing the end of the string with such suffix.
#    if (( ${#text_suffix_if_truncated} &&
#          ${#text} > ${#text_suffix_if_truncated} )) {
#        (( max_length -= ${#text_suffix_if_truncated} ))
##       print "max_length: ${max_length}"
#        return_string "${text[1,${max_length}]}${text_suffix_if_truncated}"
#    # Otherwise, truncate without suffix replacement.
#    } else {
#        return_string "${text[1,${max_length}]}"
#    }
#}

# likely to produce aesthetic or human-readable output
# (Truncating after punctuation rather than indiscriminately improves aesthetics.)
#[^.,;!?]##
    #FUXME: Close, but not quite right. Ideally, we want to preserve human-
    #readable list output when truncating. Humans expect output resembling:
    #     "I mrethil", "p...", ...
    #Rather than:
    #     "I mrethil", "peliar"...
    #Not terribly easy or readibly internationalizable, so I suppose I'm content
    #with this as is. For now...

    # zsh implements string repetition in one of two ways:
    #
    # * With the "l" parameter expansion flag, as below.
    # * With the printf() builtin, as below.
    #
    # While the former fails in the unlikely event such text contains all
    # possible parameter expansion tokens, the 
    # avoids the multiplication of the former, it also
    # expands the expression "{1..${count}}" to all integers in such range and
    # hence fails to efficiently scale to large counts. On the other hand, the
    # latter . Prefer the  We reconcile these differences as follows:
    #
    # * If such text does *NOT* contain at least one such token, perform the
    #   latter with such token.
    # * Else, perform the former.
#FUXME: Contemplate renaming back to is_string_contains(), which reads much more
#naturally than this. Search for other instances of "_substring" in function
#names; perhaps we had a respectable reason for adopting such nomenclature?
#FUXME: Yeah. This is great. Rename back to is_string_contains(), in keeping
#with the existing is_string_equals() nomenclature. But the *REAL* reason is
#much more compelling: because we have numerous other functions elsewhere testing
#containment, each currently with their own domain-specific nomenclature
#(e.g., is_list_contains()). *THIS IS NONSENSE.* All containment testers should
#share the same nomenclature: _contains(). Why? Because anything else induces
#thinking on trying to remember the domain-specific noun for testing that
#particular type of containment, which ends up being just horrible. (Even I
#can't keep it straight.) Hence, rename is_list_contains() to is_list_contains()
#as well.
    #FUXME: This can be dramatically improved upon by recalling that
    #set_list_to_string_split_on_string() currently concocts an impressive
    #algorithm for efficiently finding the first available free token (e.g.,
    #":", ".", "'", '"', and so on). Generalize such algorithm into a new
    #function accepting only a single string and:
    #
    #* If an available free token exists for such string, returning non-zero
    #  exit status and printing such token;
    #* Otherwise, returning zero exit status and printing nothing.
    #
    #Assuming such function to be sensibly named
    #get_string_parameter_expansion_token(), call such function as follows:
    #
    #    string token
    #    if token="$(get_string_parameter_expansion_token "${text}")"
    #    then # ...do something with the token!
    #    else # ...otherwise try to find another way to do it or just die.
    #    fi
    #
    #Awesomeness!

    # zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former slower command.
    # * Otherwise, run the latter faster command.
#   if { is_string_contains "${text}" ':' } {
        # Since printf() appends no newline by default, do so.
#       printf -- "${text}%.0s" {1..${count}}
#       return_string "${ZESHY_ASCII_NEWLINE}"
#   } else {
        # Total length of the repeated result, below.
#       integer result_length
#       (( result_length = count * $(get_string_length "${text}") ))

        # Print such result.
#       eval "return_string \${(l:\${result_length}::${text}:):-}"
#   }

#   die_unless_string_nonempty "${text}" 'string to be repeated empty'
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... something.
#declare_function_with_stdin <<'/---'
#string get_string_text_count(string string, string substring)
#
#Get the number of instances of the passed substring in the passed string: e.g.,
#
#.get_string_text_count()
#==========================================
#[source]
#------------------------------------------
#>>> get_string_text_count "cult of radical consumerism" "c"
#3
#------------------------------------------
#==========================================
#/---
#function get_string_text_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
#   die_unless_args_2 'expected one string and one substring'
#   string text="${1}" substring="${2}" string_sans_substring
#   string_sans_substring="${text//${substring}}"
#   return_string $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
#}

#FUXME: Rename to set_string_if_unset_to_string().
#declare_function '
#void set_string_if_unset(string string_name, string text)
#
#Set the passed variable if unset to the passed string: e.g.,
#
#    >>> string gnomes_say="hooray" hooray
#    >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
#    >>> print_string "${hooray}"
#    lesser lights of the Bardo
#'
#function set_string_if_unset() {
#    die_unless_args_2 'expected one variable name and one string'
#    noop ${(P)1=${2}}
#}

#declare_function '
#integer get_string_length_printable(string text)
#
#Get the number of  length of the passed string in multibyte characters.
#'
#function get_string_length_printable() {
#    # While parameter flag "(mm)" counts multibyte characters, parameter flag
#    # "(m)" counts only printable multibyte characters, thus ignoring control
#    # characters (e.g., newline). See get_string_length() for further caveats.
#    die_unless_args 'expected at least one string'
#    print_string "${(mm)#${*}}"
#}

#       print "result length: ${result_length}"
#   else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
#FUXME: Rename to remove_string_text(). The current nomenclature implies
#removal of only one such substring, which is not the case.
#FUXME: For consistency, the following functions should be renamed
#die_unless_variable_string(), die_unless_character(), and so on.
#Naturally, that implies similar renamings of list *TYPE TESTING* functions to
#die_unless_variable_list(), die_unless_variable_map(), is_variable_list(), and
#so on. *BUT STOP THERE.* Rename only functions testing variable types in this
#manner; all other existing functions (in particular, non-type testing list and
#map functions such as join_list_on_newline() and get_list_size()) *RETAIN THEIR
#EXISTING FUNCTION NAMES*. This gives us the best of all worlds: consistent
#naming for functions testing variable type, concise and consistent naming for
#list and map functions, and concise and consistent naming for string functions.
#
#This is good. It's a simple patch, so make it so.

#       integer suffix_length
#       suffix_length="$(get_string_length "${suffix_if_exceeding_max_length}")"
#       (( max_length >  suffix_length )) && {
#           (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
#           print_string "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
#           report_success
#       }
#   }

    # Otherwise, truncate without suffix replacement.
#   print_string "${text[1,${max_length}]}"

#FUXME: Bad. Remove entirely, replacing existing calls with
#die_unless_variable_nonempty().
# void die_unless_variable_nonempty(
#   string string_name,
#   string error_message = "\"${string_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function die_unless_variable_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_variable_nonempty "${1}" or
#        die "${2:-\"${1}\" not a string or empty}"
#}

#FUXME: Bad. Remove entirely, replacing existing calls with
#is_variable_nonempty().
# boolean is_variable_nonempty(string string_name)
#
# Return true if the passed variable is a nonempty string.
#function is_variable_nonempty() {
#    die_unless_arg 'expected one variable name'
#    string string_name="${1}"
#    is_variable_string "${string_name}" and (( ${#${(P)string_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"

#FUXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FUXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string is_string_contains(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    print_string "${*[(w)1]}"
#}

#       print_message "piped_input: $(get_stdin_piped)"
#       text="$(get_stdin_piped)"
    # Validate passed arguments.
#   print -lr -- "${(uf)@}"
#   print_strings_newlined ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           print_string ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FUXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize passed arguments.
#    die_unless_args_2_or_more\
#        'expected one line number and one or more strings'
#    die_unless_integer "${1}"
#    integer highlight_line_index="${1}" line_length
#    shift_arg
#    string text="${@}"

#FUXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list() to join_list_on() and
#join_join_list_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FUXME: Right. join_list() is simply too brief. join_join_list() reads
#better.

    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_OPTIONS_NL[@]}" )
#   print_string "${text}" | {
#       if is_shell_interactive
#       then "${nl[@]}" "${ZESHY_OPTIONS_NL_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_OPTIONS_NL_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FUXME: Implementable with pure-zsh.
#   print_string "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_arg 'expected one string'
#   print_string "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_string_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_variable "${target_name_prefix}" or string ${target_name_prefix}
#   is_variable "${target_name_suffix}" or string ${target_name_suffix}
#   is_variable "${list_name}" or list "${list_name}"

#   die_unless_variable_string "${target_name_prefix}"
#   die_unless_variable_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
