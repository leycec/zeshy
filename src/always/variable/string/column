#!/usr/bin/env zsh
# ====================[ column                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string columns (i.e., line-centric horizontally aligned substrings).

# ....................{ GETTERS                            }....................
#FIXME: It'd be nice to generalize this to accept arbitrary glob expressions
#with which to match column delimiters (e.g., "[[:space:]]+", matching column
#delimiters as any run of whitespace). Actually, that suggests a new
#complementary get_string_column_match() function. Hmm... but how would such
#match be inverted for counting purposes? I suppose there'd be no efficient
#means of doing so, eh?
#FIXME: It'd be nice to generalize this to multiple columns. We'll probably want
#to implement a for_each_string_line_match()-style function to do so -- say,
# string for_each_string_line_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_delimiter_class = '[:space:]')

document_function '
string get_string_column(
  string text,
  integer column_index,
  character column_delimiter_class = "[:space:]")

Get the column with the passed 1-based index delimited by one or more characters
of the passed zsh-specific character class (defaulting to whitespace) from the
passed string. See set_list_to_string_column() for further details.
'
function get_string_column() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one column index, and optional column delimiter'

    # Defer to set_list_to_string_column().
    list column
    set_list_to_string_column column "${@}"
    print_list_newlined column
}

# ....................{ SETTERS                            }....................
document_function '
string set_list_to_string_column(
  string list_name,
  string text,
  integer column_index,
  character column_delimiter_class = "[:space:]")

Set the passed list to the column with the passed 1-based index delimited by one
or more characters of the passed zsh-specific character class (defaulting to
whitespace) from the passed string, split on newlines. For efficiency, this
function leverages character classes rather than globs or PCREs. See subsection
"Glob Operators" of "man zshexpn" for details on such classes: e.g.,

    >>> list zombie_food_court
    >>> set_list_to_string_column zombie_food_court "
    ...     Capitalist society, however,
    ...     can only survive
    ...     by defying the
    ...     laws of thermodynamics,
    ...     through endlessly expanding
    ...     growth, buying and
    ...     using more of
    ...     everything, every year
    ...     and forever." 2 "a-zA-Z"
    >>> print_string "${zombie_food_court[-1]}"
    forever

If requiring more than one column, consider calling
for_each_string_line_match_pcre(), whose generality is ideal for such tasks.
'
function set_list_to_string_column() {
    # Validate passed arguments, splitting such string on lines.
    die_unless_args_3_or_4\
        'expected one list name, one string, one column index, and optional column delimiter'
    string\
        list_name="${1}"\
        column_index="${3}"\
        column_delimiter_class="${4:-[:space:]}"
    die_unless_list "${list_name}"
    die_unless_integer_positive "${column_index}"
    die_unless_string_nonempty "${column_delimiter_class}"\
        'column delimiter character class empty'

    # Split such string on newlines.
    list lines; lines=( ${(f)2} )

    # Glob expression matching all columns preceding the desired column. If the
    # desired column is the first column, this is the empty string; otherwise,
    # this is:
    #
    # * "[^${column_delimiter}]#", matching zero or more non-column delimiter
    #   characters.
    # * "([${column_delimiter}]##|(#e))", matching one or more column delimiter
    #   characters or newline, whichever appears first.
    # * "(#c$(( column_index - 1 )))", matching all columns up to but not
    #   including the desired column.
    string columns_glob_previous
    (( column_index >= 2 )) and
        columns_glob_previous="([^${column_delimiter_class}]#([${column_delimiter_class}]##|(#e)))(#c$(( column_index - 1 )))"

    # Glob expression matching the desired column. Dismantled, this is:
    #
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible to avoid capturing
    #   columns preceding such column.
    string column_glob_desired
    column_glob_desired="(#b)([^${column_delimiter_class}]#)([${column_delimiter_class}]|(#e))"

    # Set such list.
    set_list_to_evaluation "${list_name}"
        '${lines/${~columns_glob_previous}${~column_glob_desired}*/$match[1]}'
}

# ....................{ TABULATORS                         }....................
document_function '
string tabulate_string(string text, character delimiter = " ")

Tabulate the passed string on one or more characters matching the passed
delimiter (defaulting to a space) into horizontally aligned columns.
'
function tabulate_string() {
    # Validate passed arguments, treating piped input as such string.
    set_args_to_stdin_if_piped
    die_unless_args_1_to_2 'expected one string and optional delimiter'
    string text="${1}"

    # Tabulate such strings.
    if is_arg
    then print_string "${text}" | command column -t
    else print_string "${text}" | command column -t -s "${2}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Not fond of optional arguments. Split into two functions:
#string tabulate_string(string text1, string text2, ...)
#string tabulate_string_on_delimiter(string text, string delimiter = " ")

#, for minor and probably immeasurable efficiency.
    # * "([^${column_delimiter}]#)", capturing the passed
    #   column excluding the suffixing column delimiter.
#       integer last_column_index=$(( ${column_index} - 1 ))
#       columns_glob_previous="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"
#FUXME: Rename to get_string_column_with_column_delimiter_class
# string get_string_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_delimiter = ' ')
#
# Get the columns delimited by the passed delimiter (defaulting to whitespace)
# having the passed 1-based indices from the passed string. This function is
# analogous to the "cut -f" command: e.g.,
#
# If passed:
#
# * One index, each print_string line directly provides that column.
# * Two or more indices, each print_string line lists such columns delimited by such
#   delimiter. Getting such columns then requires splitting such lines on such
#   delimiter (e.g., by calling set_list_to_string_split_on()).
#function get_string_columns() {
    # Validate passed arguments.
#    die_unless_args_3_or_more\
#        'expected one string, one column delimiter, and at least one column index'
#    string text="${1}"   column_delimiter="${2}"
#    die_unless_variable_string column_delimiter
#    shift_args_2

    # If passed only one column index, such column is efficiently splittable
    # with pure zsh. Do so, Sir Robin! Arguably, we needn't do so in zsh; the
    # non-zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
#    if is_args_1; then
        # Index of the column preceding the passed column.
#        die_unless_integer_positive "${1}"
#        integer last_column_index=$(( ${1} - 1 ))
#        list lines; lines=( ${(f)text} )

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column delimiter via:
        #   * "[^${column_delimiter}]#", zero or more characters excluding the
        #     column delimiter.
        #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_delimiter}]#)", a match group matching the passed
        #   column excluding the suffixing column delimiter.
#        string last_columns_glob this_column_glob
#        last_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"
#        this_column_glob="(#b)([^${column_delimiter}]#)(${column_delimiter}|(#e))"

        # Split the passed column.
#        print_string_newlined\
#            ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure zsh, the inefficiency (and complexity) of such hacks is fugly.
#    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
#        list   column_indices; column_indices=( "${@}" )
#        string column_indices_with_commas
#        column_indices_with_commas="$(join_list column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column delimiter.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such delimiter.
#        print_string "${text}" | cut -s\
#            -d "${column_delimiter}"\
#            -f "${column_indices_with_commas}"
#    fi
#}
