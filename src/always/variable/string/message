#!/usr/bin/env zsh
# ====================[ message                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string messages (i.e., strings used for composing and printing brief,
# human-readable messages).

# ....................{ TRUNCATERS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string truncate_string_for_message(string text1, string text2, ...)

Truncate the passed string for use in composing brief, human-readable messages.
To avoid line wrapping, truncate such string to approximately a third the width
of the current terminal in a manner consistent with English punctuation: e.g.,

.truncate_string_for_message()
==========================================
[source]
------------------------------------------
>>> string the_new_scum="
...     These are the new streets of this city, where the New Scum try to live.
...     You and me. And here in these streets are the things that we want: sex
...     and birth, votes and traits, money and guilt, television and teddy
...     bears. But all we've actually got is each other. You decide what that
...     means."
>>> print_message\
...     "aphorism \"$(truncate_string_for_message "${the_new_scum}")\" not an affectation"
zeshy: aphorism "These are the new streets of this city, ..." not an affectation
------------------------------------------
==========================================
________________<heredoc?>________________
function truncate_string_for_message() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string text="${*}" suffix
    integer length length_max length_suffix

    # String length.
    length="$(get_string_length "${text}")"

    #FIXME: Testing is_stdout_terminal() is infeasible, as this function is
    #intended to be called from subshells. What does zsh report the terminal
    #width to be when operating headlessly (e.g., from cron jobs)? Investigate.
    #I suspect ${COLUMNS} is probably 0 in such cases. Hopefully!

    # Truncation length. If standard output for the current shell is attached to
    # a terminal, truncate to a third of the current terminal's width rounded
    # down to the nearest integer; else, default to something sensibly "short."
    #if { is_stdout_terminal } {
        length_max=$(( 0.33 * $(get_terminal_width) ))
    #} else {
    #    length_max=40
    #}

    # If the passed string requires no truncation, return the same string.
    (( length <= length_max )) and return_string "${text}"

    # Else, truncate such string. Since brute-force truncation alone is unlikely
    # to produce aesthetically human-readable output, attempt to find a better
    # truncation point below.
    text="${text[1,${length_max}]}"

    # Suffix to be appended to the truncated string.
    suffix='...'

    # Suffix length.
    length_suffix="$(get_string_length "${suffix}")"

    # If the passed string is at least as long as such suffix, such string may
    # be truncated in a human-readable manner.
    if  (( length > length_suffix )) {
        # If the truncation of such string contains either list- or sentence-
        # delimiting punctuation (i.e., punctuation commonly delimiting lists or
        # sentences in English), this identifies an ideal truncation point.
        # Replace the text after the last such punctuation with such suffix.
        if { is_string_glob_matches_capturing_groups\
            "${text}" (*[.,;!?])* } {
            # Technically, this could produce a string at most three characters
            # longer than the desired truncation length. Since that length is
            # largely arbitrary, however, this should be ignorable.
            return_string "${match[1]} ${suffix}"
        # Else, such string contains no easily indentifiable truncation point.
        # Simply replace the end of string with such suffix.
        } else {
            (( length_max -= length_suffix ))
            return_string "${text}${suffix}"
        }
    # Else, such string is shorter than such suffix. Simply return it as is.
    } else {
        return_string "${text}"
    }
}

# ....................{ JOINERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string join_strings_for_message(string text1, string text2, ...)

Join the passed strings into a string for use in composing brief, human-readable
messages consistent with English punctuation. Specifically:

* Double quote all passed strings.
* Prefix all passed strings except the first and last with `, `.
* Prefix the last passed string with `, and `.
* Concatenate such strings truncated to the width of the current terminal.

For example: e.g.,

.join_strings_for_message()
==========================================
[source]
------------------------------------------
>>> list puritanism; puritanism=(
...     "The haunting fear that someone" "somewhere" "may be happy." )
>>> print_message "$(join_strings_for_message "${puritanism[@]}")
zeshy: "The haunting fear that someone", "somewhere", and "may be happy."
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings_for_message() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'

    # Join such strings. Dismantled, this is:
    #
    # * "\"${^@}\"", double quoting each passed string.
    list args; args=( "\"${^@}\"" )
    truncate_string_for_message\
        "$(join_list_on_strings args ', ' ', and ' ' and ' )"
}

# --------------------( WASTELANDS                         )--------------------
#>>> list central_reactionary_germ_cell; central_reactionary_germ_cell=(
#...     "At first the child has" "to submit to" "the structure of the"
#...     "authoritarian miniature state" "the family"
#...     "this makes it capable of" "later subordination to the"
#...     "general authoritarian system." )

#Unlike most functions operating on lists, this function excepts accepts list
#elements as positional arguments rather than a variable name (largely due to
#caller requirements elsewhere): e.g.,

#To avoid line wrapping, truncate such string to approximately a third the width
#of the current terminal in a manner consistent with English punctuation: e.g.,
#
#Join the passed strings into a string for use in a message to be printed directly to
#standard output or error conjunctively delimiting such strings
#(i.e., with the logical conjunction ``and''). Specifically:
    # Truncate such strings.
#   truncate_string "${*}" "${length_max}" '...'

    # Truncation length. If standard output for the current shell is attached to
    # a terminal, truncate to a third of the current terminal's width rounded
    # down to the nearest integer; else, default to something sensibly "short."
#   if { is_stdout_terminal } {
#       length_max=$(( 0.33 * $(get_terminal_width) ))
#   } else {
#       length_max=40
#   }

#directly to standard output or error
#the returned string to a sensible maximum (currently, 75% of the
#  current terminal width).
    # Truncate the joined string to 33% of the current terminal's width, rounded
    # down to the nearest integer.
#   integer max_length=80
#   is_stdout_terminal and max_length=$(( 0.75 * $(get_terminal_width) ))
#   truncate_string "${text}" "${max_length}" '...'

#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
