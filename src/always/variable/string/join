#!/usr/bin/env zsh
# ====================[ join                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string joining (i.e., concatenation).

# ....................{ JOINERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string join_strings(string text1, string text2, ...)

Concatenate the passed strings with no separation between such strings: e.g.,

.concatenate_strings()
==========================================
[source]
------------------------------------------
>>> concatenate_strings "Where Alph," "the sacred river," "ran"
Where Alph,the sacred river,ran
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings() {
    # Temporarily set global string ${IFS} to the empty string. Since zsh
    # implicitly delimits lists interpolated with the "*" operator when double-
    # quoted with such global, the following commands print the passed arguments
    # undelimited. This incantation was astonishingly difficult to discover. In
    # particular, note that if such operator is *NOT* double-quoted, zsh ignores
    # ${IFS}. *ruefully shakes head*
    die_unless_args 'expected at least one string'
    IFS='' output_string "${*}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string join_strings_on_newline(string text1, string text2, ...)

Separate the passed strings with newline characters: e.g.,

.join_strings_on_newline()
==========================================
[source]
------------------------------------------
>>> join_strings_on_newline "Through caverns" measureless "to man"
Through caverns
measureless
to man
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings_on_newline() {
    die_unless_args 'expected at least one string'
    print -lr -- "${@}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string join_strings_on_null(string text1, string text2, ...)

Separate the passed strings with null characters (i.e., "\0"): e.g.,

.join_strings_on_null()
==========================================
[source]
------------------------------------------
>>> join_strings_on_null "Down to" "a sunless" sea.
Down to\0a sunless\0sea.
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings_on_null() {
    die_unless_args 'expected at least one string'
    print -Nr -- "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#the returned string to a sensible maximum (currently, 75% of the
#  current terminal width).
    # Truncate the joined string to 33% of the current terminal's width, rounded
    # down to the nearest integer.
#   integer max_length=80
#   is_stdout_terminal and max_length=$(( 0.75 * $(get_terminal_width) ))
#   truncate_string "${text}" "${max_length}" '...'

#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
