#!/usr/bin/env zsh
# ====================[ join                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string joining (i.e., concatenation).

# ....................{ JOINERS                            }....................
declare_function_by_stdin <<'________________<heredoc?>________________'
string join_strings(string text1, string text2, ...)

Concatenate the passed strings with no separation between such strings: e.g.,

.concatenate_strings()
==========================================
[source]
------------------------------------------
>>> concatenate_strings "Where Alph," "the sacred river," "ran"
Where Alph,the sacred river,ran
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings() {
    # Temporarily set global string ${IFS} to the empty string. Since zsh
    # implicitly delimits lists interpolated with the "*" operator when double-
    # quoted with such global, the following commands print the passed arguments
    # undelimited. This incantation was astonishingly difficult to discover. In
    # particular, note that if such operator is *NOT* double-quoted, zsh ignores
    # ${IFS}. *ruefully shakes head*
    die_unless_args 'expected at least one string'
    IFS='' output_string "${*}"
}

declare_function_by_stdin <<'________________<heredoc?>________________'
string join_strings_on_newline(string text1, string text2, ...)

Separate the passed strings with newline characters: e.g.,

.join_strings_on_newline()
==========================================
[source]
------------------------------------------
>>> join_strings_on_newline "Through caverns" measureless "to man"
Through caverns
measureless
to man
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings_on_newline() {
    die_unless_args 'expected at least one string'
    print -lr -- "${@}"
}

declare_function_by_stdin <<'________________<heredoc?>________________'
string join_strings_on_null(string text1, string text2, ...)

Separate the passed strings with null characters (i.e., "\0"): e.g.,

.join_strings_on_null()
==========================================
[source]
------------------------------------------
>>> join_strings_on_null "Down to" "a sunless" sea.
Down to\0a sunless\0sea.
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings_on_null() {
    die_unless_args 'expected at least one string'
    print -Nr -- "${@}"
}

# ....................{ JOINERS ~ conjunctive              }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string join_strings_conjunctively(string text1, string text2, ...)

Join the passed strings into a string conjunctively delimiting such strings
(i.e., with the logical conjunction ``and''). Specifically:

* Double quote all passed strings.
* Prefix all passed strings except the first and last with `, `.
* Prefix the last passed string with `, and `.
* Truncat the returned string to a sensible maximum (currently, 75% of the
  current terminal width).

Unlike most functions operating on lists, this function excepts accepts list
elements as positional arguments rather than a variable name (largely due to
caller requirements elsewhere): e.g.,

.join_strings_conjunctively()
==========================================
[source]
------------------------------------------
>>> join_strings_conjunctively "I mrethil" peliar "duiw laiss"
"I mrethil", "peliar", and "duiw laiss"
------------------------------------------
==========================================
________________<heredoc?>________________
function join_strings_conjunctively() {
    # Validate and join the passed arguments. Dismantled, this is:
    #
    # * "\"${^@}\"", double quoting each passed string.
    die_unless_args 'expected at least one string'
    list args; args=( "\"${^@}\"" )
    string text
    text="$(join_list_on_strings args ', ' ', and ' ' and ' )"

    #FIXME: Close, but not quite right. Ideally, we want to preserve human-
    #readable print_string when truncating. Humans expect print_string resembling:
    #     "I mrethil", "p...", ...
    #Rather than:
    #     "I mrethil", "peliar"...
    #Not terribly easy or readibly internationalizable, so I suppose I'm content
    #with this as is. For now...

    # Truncate the joined string to 75% of the current terminal's width, rounded
    # down to the nearest integer.
    integer max_length=80
    is_stdout_terminal and max_length=$(( 0.75 * $(get_terminal_width) ))
    truncate_string "${text}" "${max_length}" '...'
}

# --------------------( WASTELANDS                         )--------------------
#Print the passed strings to standard output delimited and terminated by nulls.
#Suffix each such string with character "\0", in other words: e.g.,
