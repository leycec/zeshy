#!/usr/bin/env zsh
# ====================[ column                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string columns (i.e., line-oriented horizontally aligned substrings).

# ....................{ GETTERS                            }....................
#FIXME: It'd be nice to generalize this to accept arbitrary glob expressions
#with which to match column separators (e.g., "[[:space:]]+", matching column
#separators as any run of whitespace). Actually, that suggests a new
#complementary get_string_column_match() function. Hmm... but how would such
#match be inverted for counting purposes? I suppose there'd be no efficient
#means of doing so, eh?
#FIXME: Ah! We probably want to reimplement such functions with multiline PCREs,
#which should offer substantially better efficiency, generality, and safety.
#The current glob-based implementation splits the passed string into lines,
#clearly slower than multiline matching.
#FIXME: Rename this component to "variable/string/pcre/column".

#FIXME: It'd be nice to generalize this to multiple columns. We'll probably want
#to implement a for_each_string_line_match()-style function to do so -- say,
# string for_each_string_line_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_separator_class = '[:space:]')

#FIXME: Rename to get_string_column_index(). While I had originally preferred
#get_string_column_with_index(), such nomenclature leads to unwieldy function
#names elsewhere (e.g., get_string_line_with_column_with_index_equals(): ugh!).
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_column(
    string text,
    integer column_index,
    string column_separator_class = "[:space:]")

Get the column with the passed 1-based index delimited by one or more characters
of the passed `zsh`-specific character class (defaulting to "[:space:]", matching
all whitespace characters) from the passed string. See
set_list_to_string_column() for further details.
________________<heredoc?>________________
function get_string_column() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one column index, and optional column separator'

    # Get such column.
    list column; set_list_to_string_column column "${@}"
    join_list_on_newline column
}

# ....................{ SETTERS                            }....................
#FIXME: Rename to set_list_to_string_column_with_index().
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_column(
    string list_name,
    string text,
    integer column_index,
    character column_separator_class = "[:space:]")

Set the passed list to the column with the passed 1-based index delimited by one
or more characters of the passed `zsh`-specific character class (defaulting to
"[:space:]", matching all whitespace characters) from the passed string, split on
newlines. For efficiency, this function leverages character classes rather than
globs or PCREs. See subsection ``Glob Operators'' of `man zshexpn` for details on
such classes: e.g.,

.set_list_to_string_column()
==========================================
[source]
------------------------------------------
>>> list zombie_food_court
>>> set_list_to_string_column zombie_food_court "
...     Capitalist society, however,
...     can only survive
...     by defying the
...     laws of thermodynamics,
...     through endlessly expanding
...     growth, buying and
...     using more of
...     everything, every year
...     and forever." 2 "a-zA-Z"
>>> print_string "${zombie_food_court[-1]}"
forever
------------------------------------------
==========================================

If requiring more than one column, consider calling
for_string_line_matches_pcre(), whose generality is ideal for such tasks.
________________<heredoc?>________________
function set_list_to_string_column() {
    # Validate passed arguments, splitting such string on lines.
    die_unless_args_3_or_4\
        'expected one list name, one string, one column index, and optional column separator'
    string\
        list_name__sltsc="${1}"\
        text__sltsc="${2}"\
        column_index__sltsc="${3}"\
        column_separator_class__sltsc="${4:-[:space:]}"
    die_unless_list "${list_name__sltsc}"
    die_unless_integer_positive "${column_index__sltsc}"
    die_unless_string_nonempty "${column_separator_class__sltsc}"\
        'column separator class empty'

    # Glob expression matching all columns preceding the desired column. If the
    # desired column is the first column, this is the empty string; otherwise,
    # this is:
    #
    # * "[^${column_separator}]#", matching zero or more non-column separator
    #   characters.
    # * "([${column_separator}]##|(#e))", matching one or more column separator
    #   characters or newline, whichever appears first.
    # * "(#c$(( column_index - 1 )))", matching all columns up to but not
    #   including the desired column.
    string glob_columns_prior__sltsc
    (( column_index__sltsc >= 2 )) and
        glob_columns_prior="([^${column_separator_class__sltsc}]#([${column_separator_class__sltsc}]##|(#e)))(#c$(( column_index__sltsc - 1 )))"

    # Glob expression matching the desired column. Dismantled, this is:
    #
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible to avoid capturing
    #   columns preceding such column.
    string glob_column__sltsc
    glob_column__sltsc="(#b)([^${column_separator_class__sltsc}]#)([${column_separator_class__sltsc}]|(#e))"

    # Split such string on newlines.
    list lines__sltsc; lines__sltsc=( ${(f)text__sltsc} )

    # Set such list.
    eval "${list_name__sltsc}=(\
        \${lines__sltsc/\${~glob_columns_prior__sltsc}\${~glob_column__sltsc}*/\${match[1]}} )"
}

# ....................{ ITERATORS                          }....................
#FIXME: Generalize to a new simpler function for_string_lines(),
#which would provide each such line as ${MATCH} (...and perhaps also ${LINE}).
#FIXME: Document examples.
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_columns_split_on_whitespace(
    string text, integer column_count, string command)

Run the passed command for each line of the passed string containing at most the
passed number of whitespace-delimited columns. See
for_string_line_columns_split_on_pcre() for further details: e.g.,

.for_string_line_columns_split_on_whitespace()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_columns_split_on_whitespace() {
    # Validate passed arguments.
    die_unless_args_3 'expected one string, one column count, and one command'

    # Iterate such matches. Match whitespace column delimiters with PCRE
    # character class "[:blank:]" rather than "[:space:]"; the latter
    # unhelpfully matches newline, while the former does not.
    for_string_line_columns_split_on_pcre_class "${1}" "${2}" [:blank:] "${3}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string for_string_line_columns_split_on_pcre_class(
    string text,
    integer column_count,
    string column_separator_pcre_class,
    string command)

Run the passed command for each line of the passed string containing at most the
passed number of columns separated by substrings matching the passed PCRE
character class (e.g., `[:blank:]`, matching whitespace-delimited columns).

.for_string_line_columns_split_on_pcre_class()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================

[WARNING]
If the passed PCRE character class matches newlines either explicitly (e.g.,
`\n\t\v `, `[:space:]`) or implicitly (e.g., `[^a-z]`, `[a-z:^alpha:]`), throw
an exception. While the PCRE this function internally constructs from such class
could be altered to accomodate such classes (e.g., with negative lookahead
assertions), doing so reduces the efficiency of such PCRE -- for little gain.

This function is an efficient alternative to the more general
for_string_line_columns_split_on_pcre(), which matches column separators with a
full PCRE. See such function for further details.
________________<heredoc?>________________
function for_string_line_columns_split_on_pcre_class() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string, one column count, one column separator character class, and one command'
    string\
        text="${1}"\
        column_count="${2}"\
        column_separator_class="${3}"\
        command="${4}"
    die_unless_integer_positive "${column_count}"
    die_unless_string_nonempty "${column_separator_class}"\
        'expected non-empty column separator PCRE character class'
    die_unless_string_nonempty "${command}" 'expected non-empty command'

    # If such class matches newlines, throw an exception.
    is_string_matches_pcre\
        "${ZESHY_ASCII_NEWLINE}" "[${column_separator_class}]" and
        die "column separator character class \"${column_separator_class}\" matches newlines"

    # PCRE fragment capturing a single column suffixed by either the string end
    # or column separator. Dismantled, this is:
    #
    # * "([^...]*+)", possessively capturing a longest (possibly empty)
    #   substring of characters *NOT* in such class as the next column.
    #   Possessive matching is simply greedy matching with backtracking
    #   disabled, improving efficiency where not requiring backtracking. This is
    #   usually the case where matching longest substrings of characters.
    # * "(?:$|[...]++)", matching without capturing either the string end or a
    #   column separator.
    string pcre_column="([^${column_separator_class}]*+)(?:$|[${column_separator_class}]++)"

    # PCRE capturing all such columns on a single line. Anchor such PCRE to the
    # beginning of the string and and each string line with "^".
    string pcre_columns
    pcre_columns="^$(repeat_string "${pcre_column}" "${column_count}")"

    # Iterate such matches with such PCRE in multiline mode.
    for_string_matches_pcre_multiline "${text}" "${pcre_columns}" "${command}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string for_string_line_columns_split_on_pcre(
    string text,
    integer column_count,
    string column_separator_pcre,
    string command)

Run the passed command for each line of the passed string containing at most the
passed number of columns separated by substrings matching the passed PCRE (e.g.,
`[[:space:]]++`, matching whitespace-delimited columns). This function provides
such command access to the following canonical match globals:

* ${MATCH}, a string global expanding to the currently iterated line.
* ${match}, a list global expanding to each column of such line (e.g.,
  '${match[1]}`, expanding to the first column of the currently iterated line).

For example:

.for_string_line_columns_split_on_pcre()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================

If the passed PCRE matches newlines either explicitly (e.g.,
`[[:punct:][:space:]]++`) or implicitly (e.g., `[[0-9:^alpha:]]{3,6}`), throw an
exception. This prevents the last column separator from erroneously consuming a
terminating newline and hence preventing the next line from matching.

[WARNING]
If the passed PCRE matches newlines either explicitly (e.g., `[[:space:]]++`) or
implicitly (e.g., `[[0-9:^alpha:]]{3,6}`), this function's behaviour is
undefined. In such case, the expression matching the last column separator for a
line may erroneously consume terminating newlines and hence prevent the next
line from matching. For safety, this function throws an exception on detecting a
PCRE matching a single newline. Since such detection does _not_ suffice to match
PCREs matching strings containing newlines rather than a single newline, callers
should take care to avoid passing such PCREs.
________________<heredoc?>________________
function for_string_line_columns_split_on_pcre() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string, one column count, one column separator PCRE, and one command'
    string\
        text="${1}"\
        column_count="${2}"\
        column_separator_pcre="${3}"\
        command="${4}"
    die_unless_integer_positive "${column_count}"
    die_unless_string_nonempty "${column_separator_pcre}"\
        'expected non-empty column separator PCRE'
    die_unless_string_nonempty "${command}" 'expected non-empty command'

    # If such PCRE matches single newlines, throw an exception. Unlike
    # for_string_line_columns_split_on_pcre_class(), this does *NOT* prevent
    # such PCRE from matching other characters and then a newline. Short of
    # testing every possible string containing a newline, this is the best we
    # can reasonably do.
    is_string_matches_pcre\
        "${ZESHY_ASCII_NEWLINE}" "${column_separator_pcre}" and
        die "column separator PCRE \"${column_separator_pcre}\" matches newlines"

    # PCRE fragment capturing a single column suffixed either by the string end
    # or column separator.
    string pcre_column="((?:(?!${column_separator_pcre}).)*?)${column_separator_pcre}"

    # PCRE capturing all such columns on a single line. Anchor such PCRE to the
    # beginning of the string and and each string line with "^".
    string pcre_columns
    pcre_columns="^$(repeat_string "${pcre_column}" "${column_count}")"

    # Iterate such matches with such PCRE in multiline mode.
    for_string_matches_pcre_multiline "${text}" "${pcre_columns}" "${command}"
}

# ....................{ TABULATORS                         }....................
#FIXME: Rename to tabulate_string_on_string().
declare_function_with_stdin <<'________________<heredoc?>________________'
string tabulate_string_on_separator(string text, character separator)

Tabulate the passed string on one or more characters matching the passed
separator character into horizontally aligned columns.
________________<heredoc?>________________
function tabulate_string_on_separator() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one separator'
    string text="${1}" separator="${2}"
    die_unless_character "${separator}"

    # Tabulate such string.
    output_string "${text}" | command column -t -s "${separator}"
}

# ....................{ TABULATORS ~ whitespace            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string tabulate_string_on_whitespace(string text1, string text2, ...)

Tabulate the passed strings on one or more whitespace characters into
horizontally aligned columns.
________________<heredoc?>________________
function tabulate_string_on_whitespace() {
    die_unless_args 'expected at least one string'
    output_string "${*}" | command column -t
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string tabulate_stdin_on_whitespace[stdin: string input]

Tabulate standard input on one or more whitespace characters into horizontally
aligned columns.
________________<heredoc?>________________
function tabulate_stdin_on_whitespace() {
    die_unless_stdin_nonempty
    < "${ZESHY_STDIN_PATH}" | command column -t
}

# --------------------( WASTELANDS                         )--------------------
#Dismantled, this is:
    #
    # * "^", anchoring such PCRE to the string beginning and each string line.
#In such case, the PCRE this function internally
#constructs from such PCRE to match the last column separator could erroneously
#consume the newline prefixing the next line and hence prevent such line from
#matching. In short, unexpectedly bad things may (and probably will) happen.
#
#If such PCRE matches only characters in a single PCRE character class, consider
#calling for_string_line_columns_split_on_pcre_class() instead

#[WARNING]
#If the passed PCRE matches newlines (e.g., `[[:space:]]++`), this function's
#behaviour is undefined. In such case, the PCRE this function internally
#constructs from such PCRE to match the last column separator could erroneously
#consume the newline prefixing the next line and hence prevent such line from
#matching. In short, unexpectedly bad things may (and probably will) happen.
#For example:

#[WARNING]
#==========================================
#If the passed PCRE character class matches newlines (e.g., `\n\t\v `,
#`[:space:]`), this function's behaviour is undefined. For safety, this function
#throws an exception when detecting such a class. Since such detection is hardly
#perfect, callers should explicitly avoid passing such classes. Note that
#negative character classes (e.g., `[^a-z]`, `[:^alpha:]`) implicitly match
#newlines and hence are also prohibited.
#
#While the PCRE this function internally constructs from such class could be
#altered (e.g., with negative lookahead assertion) to accomodate such classes,
#doing so would substantially reduce the efficiency of such PCRE -- for little
#gain, in most cases.
#==========================================

    # If such class matches newlines, throw an exception. Technically, this
    # test fails to match all possible classes matching newlines (e.g.,
    # "[\012]", matching only newlines with an octal specifier; "[\x00-\x31]",
    # matching all control characters including newline with a hexadecimal
    # range). While unfortunate, fully checking such condition is infeasible.
    # Since this function's documentation explicitly warns of this constraint,
    # laxness is probably acceptable.
#   is_string_matches "${column_separator_pcre_class}"\
#       ('^'*|*('\n'|'[:'('ascii'|'cntrl'|'space')':]'|'[:^'*':]')*) and
#       die "column separator PCRE character class \"${column_separator_pcre_class}\" matches newlines"

# split from such line on such PCRE (and hence containing
#neither leading or trailing substrings matching such PCRE)
#$(convert_string_to_pcre_multiline\
    # Attempt to match the string end before attempting
    #     to match such column separator; this prevents such PCRE from consuming
    #     more than a line's worth of characters when such separator's class
    #     also matches newlines (e.g., "\n\t\v ", "[:space:]").
    # For safety, prevent character classes from matching newline and hence
    # consuming more than a line's worth of characters.
#While the PCRE
    # constructed below could be modified with negative lookahead assertions to
    # accomodate newline-matching character classes, doing so may substantially
    # reduce the efficiency of such PCRE -- with little gain, in most cases.
#FUXME: Also implement a more efficient generalization,
#for_string_line_columns_split_on_pcre_class(), accepting a PCRE character class
#rather than a genuine PCRE. In fact, let's implement this first. :}
#.such command, string global
#${MATCH} expands to the current line and list global ${match} to each column of
#such line, split from such line on whitespace (and hence containing neither
#leading or trailing whitespace)
#Set  splitting each such
#line on whitespace into match global
#This function provides such command access to match globals
#${MATCH}, ${MBEGIN}, and ${MEND}
#*columned string* (i.e.,
#newline-delimited string with each such line split on .

#   print -- "$(< ${ZESHY_STDIN_PATH})" | command column -t
#FUXME: Not fond of optional arguments. Split into two functions:
#string tabulate_string(string text1, string text2, ...)
#string tabulate_string_on_separator(string text, string separator = " ")

#, for minor and probably immeasurable efficiency.
    # * "([^${column_separator}]#)", capturing the passed
    #   column excluding the suffixing column separator.
#       integer last_column_index=$(( ${column_index} - 1 ))
#       columns_glob_previous="([^${column_separator}]#(${column_separator}|(#e)))(#c${last_column_index})"
#FUXME: Rename to get_string_column_with_column_separator_class
# string get_string_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_separator = ' ')
#
# Get the columns delimited by the passed separator (defaulting to whitespace)
# having the passed 1-based indices from the passed string. This function is
# analogous to the "cut -f" command: e.g.,
#
# If passed:
#
# * One index, each print_string line directly provides that column.
# * Two or more indices, each print_string line lists such columns delimited by such
#   separator. Getting such columns then requires splitting such lines on such
#   separator (e.g., by calling set_list_to_string_split_on()).
#function get_string_columns() {
    # Validate passed arguments.
#    die_unless_args_3_or_more\
#        'expected one string, one column separator, and at least one column index'
#    string text="${1}"   column_separator="${2}"
#    die_unless_variable_string column_separator
#    shift_args_2

    # If passed only one column index, such column is efficiently splittable
    # with pure zsh. Do so, Sir Robin! Arguably, we needn't do so in zsh; the
    # non-zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
#    if is_args_1; then
        # Index of the column preceding the passed column.
#        die_unless_integer_positive "${1}"
#        integer last_column_index=$(( ${1} - 1 ))
#        list lines; lines=( ${(f)text} )

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column separator via:
        #   * "[^${column_separator}]#", zero or more characters excluding the
        #     column separator.
        #   * "(${column_separator}|(#e))", a column separator or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_separator}]#)", a match group matching the passed
        #   column excluding the suffixing column separator.
#        string last_columns_glob this_column_glob
#        last_columns_glob="([^${column_separator}]#(${column_separator}|(#e)))(#c${last_column_index})"
#        this_column_glob="(#b)([^${column_separator}]#)(${column_separator}|(#e))"

        # Split the passed column.
#        print_strings_newlined\
#            ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure zsh, the inefficiency (and complexity) of such hacks is fugly.
#    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
#        list   column_indices; column_indices=( "${@}" )
#        string column_indices_with_commas
#        column_indices_with_commas="$(join_list column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column separator.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such separator.
#        print_string "${text}" | cut -s\
#            -d "${column_separator}"\
#            -f "${column_indices_with_commas}"
#    fi
#}
