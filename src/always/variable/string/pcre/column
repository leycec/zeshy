#!/usr/bin/env zsh
# ====================[ column                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle PCRE-matched columns (i.e., horizontally aligned substrings on a line).

#FIXME: This component and its companion under "glob/" might be better renamed
#"field" and all uses of "column" to "field" as well. Field is a more general
#concept and better applicable here. Columns are strictly horizontally aligned;
#but, we don't particularly care about their alignment here.
#FIXME: *ACTUALLY*, column is a better name. Yes, it does imply horizontal
#alignment, which doesn't apply here. But it *ALSO* implies all fields of the
#same index, which it's practically impossible to capture with "fields". What
#reads better: get_string_lines_word() or
#get_string_fields_with_index_split_on_whitespace()? O.K.; I suppose
#get_string_fields_with_index_split_on_whitespace() does.
#FIXME: Right. That settles it. Go-go "fields".
#FIXME: Hmmmm. The whole "_split_on_whitespace" thing, while precise, is *WAY*
#too overly verbose. We pretty much want to eliminate that from every function
#suffix.

# ....................{ SETTERS                            }....................
#FIXME: Rename to set_list_to_string_column_index_split_on_whitespace().
#FIXME: Excise the fourth passed argument. Fixup documentation and
#implementation, which should now defer to
#for_string_columns_split_on_whitespace().
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_column(
    string list_name,
    string text,
    integer column_index,
    character column_separator_class = "[:space:]")

Set the passed list to the column with the passed 1-based index delimited by one
or more characters of the passed `zsh`-specific character class (defaulting to
"[:space:]", matching all whitespace characters) from the passed string, split on
newlines. For efficiency, this function leverages character classes rather than
globs or PCREs. See subsection ``Glob Operators'' of `man zshexpn` for details on
such classes: e.g.,

.set_list_to_string_column()
==========================================
[source]
------------------------------------------
>>> string escape_from="
...     Capitalist society, however,
...     can only survive
...     by defying the
...     laws of thermodynamics,
...     through endlessly expanding
...     growth, buying and
...     using more of
...     everything, every year
...     and forever."
>>> list zombie_food_court
>>> set_list_to_string_column\
...     zombie_food_court "${escape_from}" 2
>>> print_string "${zombie_food_court[@]}"
society, only defying of endlessly buying more every forever.
------------------------------------------
==========================================

If requiring more than one column, consider calling
for_string_pcre_multiline_matches(), whose generality is ideal for such tasks.
________________<heredoc?>________________
function set_list_to_string_column() {
    # Validate passed arguments, splitting such string on lines.
    die_unless_args_3_or_4\
        'expected one list name, one string, one column index, and optional column separator'
    string\
        list_name__sltsc="${1}"\
        text__sltsc="${2}"\
        column_index__sltsc="${3}"\
        column_separator_class__sltsc="${4:-[:space:]}"
    die_unless_list "${list_name__sltsc}"
    die_unless_integer_positive "${column_index__sltsc}"
    die_unless_string_nonempty "${column_separator_class__sltsc}"\
        'column separator class empty'

    # Glob expression matching all columns preceding the desired column. If the
    # desired column is the first column, this is the empty string; otherwise,
    # this is:
    #
    # * "[^${column_separator}]#", matching zero or more non-column separator
    #   characters.
    # * "([${column_separator}]##|(#e))", matching one or more column separator
    #   characters or newline, whichever appears first.
    # * "(#c$(( column_index - 1 )))", matching all columns up to but not
    #   including the desired column.
    string glob_columns_prior__sltsc
    (( column_index__sltsc >= 2 )) and
        glob_columns_prior="([^${ZESHY_ASCII_NEWLINE}${column_separator_class__sltsc}]#([${column_separator_class__sltsc}]##|(#e)))(#c$(( column_index__sltsc - 1 )))"

    # Glob expression matching the desired column. Dismantled, this is:
    #
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible to avoid capturing
    #   columns preceding such column.
    string glob_column__sltsc
    glob_column__sltsc="(#b)([^${ZESHY_ASCII_NEWLINE}${column_separator_class__sltsc}]#)([${column_separator_class__sltsc}]|(#e))"

    # Split such string on newlines.
    list lines__sltsc; lines__sltsc=( ${(f)text__sltsc} )

    # Set such list.
    eval "${list_name__sltsc}=(\
        \${lines__sltsc/\${~glob_columns_prior__sltsc}\${~glob_column__sltsc}*/\${match[1]}} )"
}

# ....................{ ITERATORS                          }....................
#FIXME: Right. I thought we'd need a sensible generalization *NOT* requiring
#a field count to be passed and... well, there it is in "string/word". Requiring
#a field count be passed to these iterators is simply silly. But how can we
#reasonably generalize this? I'm thinking the following:
#
#* Have for_string_words_split_on_pcre_class() accept only two arguments.
#* Such function should internally match the first line from the passed
#  string and...
#  * Dynamically split such string with the passed PCRE class. This, of
#    course, requires a call to for_string_pcre_matches(), which is both
#    mildly humorous *AND* heavyweight. *shrug*
#  * Wait. We only need to count the number of word separators! Ah-ha.
#    Well, that's a bit less heavyweight: just call
#    get_string_pcre_match_count(). (Of course, that internally just calls
#    for_string_pcre_matches(), but... *shrug*).
#  * Actually, we don't even need to pre-split the first line off. Since
#    such class *CANNOT* match newlines... ah. No. We do need to, I think.
#    In any case, this is pretty swag.
#
#I don't see a way around it, however. The alternative of having to pass in
#a field count on every call is... well, both silly and horrible. I mean,
#"awk" doesn't require that, and we want this to be at least marginally
#comparable.
#
#Note this assumes the first line of such text to contain a representative
#number of words. *DOCUMENT THIS ASSUMPTION*, please. (To improve the
#robustness of this assumption, we could actually perform the above logic twice
#-- once on the first line and once on the second, if there *IS* a second line.
#Compare the resulting number of words. If they differ, print a warning but
#continue anyway. Nice idea, anyway, yes? Hmmm; or perhaps overkill. I should
#note that if any line provides *FEWER* words than the first provides, an
#exception is thrown since such line fails to match. So, let's just not worry
#about this now, eh?)

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_columns_split_on_pcre_class(
    string text,
    string column_separator_pcre_class,
    string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each column of such line into an element of list
global ${match}. Split such column on any substring of one or more characters
matching the passed PCRE character class (e.g., `[:blank:]`, matching
whitespace-delimited columns): e.g.,

.for_string_columns_split_on_pcre_class()
==========================================
[source]
------------------------------------------
>>> string in_suspicion_we_trust="
...     Wherever you go, whatever you do, whoever you are, you are under
...     surveillance. Because you are a potential criminal, perhaps you secretly
...     doubt the sanctity of corporate property, or the validity of laws made
...     by the rich to govern the poor, or the soundness of capitalism itself â€“
...     we can't afford to assume you don't. That's why there are video cameras
...     pointing at every cashier and police cars circling every block. Left to
...     itself, a state of disorder and inequity returns to equilibrium; our job
...     is to perpetuate this one indefinitely."
>>> for_string_columns_split_on_pcre_class "${in_suspicion_we_trust}" '.,;'\
...     'output_string "${match[1]}"'
Where you go
surveillance
doubt the sanctity of corporate property
by the rich to govern the poor
we can't afford to assume you don't
pointing at every cashier and police cars circling every block
itself
is to perpetuate this one indefinitely
------------------------------------------
==========================================

This function is an efficient alternative to for_string_columns_split_on_pcre(),
which matches column separators by PCREs. See such function for further details.

== Caveats ==

Avoid delimiting the passed PCRE character class with `[` and `]` characters
(e.g., `a-zA-Z0-9` rather than `[a-zA-Z0-9]`) _unless_ such class is a named
character class (e.g., `[:punct:]` rather than `:punct:`).

Ensure such class does *not* match newlines, either explicitly (e.g., `\n\t\v `,
`[:space:]`) or implicitly (e.g., `^a-z`, `a-z[:^alpha:]`). This function throws
an exception when passed such a class. While the PCRE this function internally
constructs from such class could be edited to accomodate such classes (e.g.,
with negative lookahead assertions), doing so would comparatively reduce the
efficiency of such PCRE -- for little gain.
________________<heredoc?>________________
function for_string_columns_split_on_pcre_class() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string, one column count, one column separator character class, and one command'
    string\
        text="${1}"\
        column_count="${2}"\
        column_separator_class="${3}"\
        command="${4}"\
        pcre_column\
        pcre_column_separator\
        pcre_column_separated\
        pcre_columns_sans_last\
        pcre_columns
    die_unless_integer_positive "${column_count}"
    die_unless_string_nonempty "${column_separator_class}"\
        'expected non-empty column separator PCRE character class'
    die_unless_string_nonempty "${command}" 'expected non-empty command'

    # If such class matches newlines, throw an exception.
    is_string_pcre_matches\
        "${ZESHY_ASCII_NEWLINE}" "[${column_separator_class}]" and
        die "column separator character class \"${column_separator_class}\" matches newlines"

    # PCRE capturing a column. Dismantled, this is:
    #
    # * "([^...]*+)", possessively capturing a longest (possibly empty)
    #   substring of characters *NOT* in such class as the next column.
    #   Possessive matching is simply greedy matching with backtracking
    #   disabled, improving efficiency where not requiring backtracking. This is
    #   usually the case where matching longest substrings of characters. Prefix
    #   such negation with "\n" to avoid matching newlines.
    pcre_column="([^\n${column_separator_class}]*+)"

    # PCRE capturing a column separator. Dismantled, this is:
    #
    # * "([^...]*+)", possessively matching a longest non-empty substring of
    #   characters in such class as the separator for the prior column.
    pcre_column_separator="[${column_separator_class}]++"

    # PCRE optionally matching a column suffixed by such separator.
    pcre_column_separated="(?:${pcre_column}${pcre_column_separator})?"

    # PCRE matching all such columns excluding the last on a single line.
    pcre_columns_sans_last="$(repeat_string "${pcre_column_separated}" "$(( column_count - 1 ))")"

    # PCRE capturing the unmatched remainder of the current line. Match non-
    # greedily to prefer matching columns if possible first.
    pcre_remainder="(.*?)"

    # PCRE capturing all such columns on a single line. Dismantled, this is:
    #
    # * "^", anchoring to the beginning of both the string and string lines.
    # * "(?:$|...(.*))", matching an optional trailing column separator and
    #   capturing any remaining text on such line into the last match group.
    # * "$", anchoring to the end of both the string and string lines.
    pcre_columns="^${pcre_columns_sans_last}${pcre_column}(${pcre_column_separator}${pcre_remainder})?$"

    # Iterate such matches with such PCRE in multiline mode.
    for_string_pcre_matches_multiline "${text}" "${pcre_columns}" "${command}"
}

#FIXME: Rename caller functions.
function for_string_line_fields_bounded_split_on_pcres_field_and_separator() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string, one field PCRE, one field separator PCRE, and one command'
    string\
        text="${1}"\
        column_pcre="${2}"\
        column_separator_pcre="${3}"\
        command="${4}"\
        line_first\
        pcre_column\
        pcre_column_separator\
        pcre_column_separated\
        pcre_columns_sans_last\
        pcre_remainder\
        pcre_columns
    die_unless_integer_positive "${column_count}"
    die_unless_string_nonempty "${column_pcre}"\
        'expected non-empty column PCRE'
    die_unless_string_nonempty "${column_separator_pcre}"\
        'expected non-empty column separator PCRE'
    die_unless_string_nonempty "${command}" 'expected non-empty command'

    # If such PCRE matches single newlines, throw an exception. Unlike
    # for_string_columns_split_on_pcre_class(), this does *NOT* prevent
    # such PCRE from matching other characters and then a newline. Short of
    # testing every possible string containing a newline, this is the best we
    # can reasonably do.
    is_string_pcre_matches\
        "${ZESHY_ASCII_NEWLINE}" "${column_separator_pcre}" and
        die "column separator PCRE \"${column_separator_pcre}\" matches newlines"

    # Count the number of fields in the first line of such string.
    line_first; line_first="$(get_string_line "${text}" 1)"

#* Have for_string_words_split_on_pcre_class() accept only two arguments.
#* Such function should internally match the first line from the passed
#  string and...
#  * Dynamically split such string with the passed PCRE class. This, of
#    course, requires a call to for_string_pcre_matches(), which is both
#    mildly humorous *AND* heavyweight. *shrug*
#  * Wait. We only need to count the number of word separators! Ah-ha.
#    Well, that's a bit less heavyweight: just call
#    get_string_pcre_match_count(). (Of course, that internally just calls
#    for_string_pcre_matches(), but... *shrug*).
#  * Actually, we don't even need to pre-split the first line off. Since
#    such class *CANNOT* match newlines... ah. No. We do need to, I think.
#    In any case, this is pretty swag.

    # PCRE capturing a column. Dismantled, this is:
    #
    # * "([^...]*+)", possessively capturing a longest (possibly empty)
    #   substring of characters *NOT* in such class as the next column.
    #   Possessive matching is simply greedy matching with backtracking
    #   disabled, improving efficiency where not requiring backtracking. This is
    #   usually the case where matching longest substrings of characters. Prefix
    #   such negation with "\n" to avoid matching newlines.
    pcre_column="([^\n${column_separator_class}]*+)"

    # PCRE capturing a column separator. Dismantled, this is:
    #
    # * "([^...]*+)", possessively matching a longest non-empty substring of
    #   characters in such class as the separator for the prior column.
    pcre_column_separator="[${column_separator_class}]++"

    # PCRE optionally matching a column suffixed by such separator.
    pcre_column_separated="(?:${pcre_column}${pcre_column_separator})?"

    # PCRE matching all such columns excluding the last on a single line.
    pcre_columns_sans_last="$(repeat_string "${pcre_column_separated}" "$(( column_count - 1 ))")"

    # PCRE capturing the unmatched remainder of the current line. Match non-
    # greedily to prefer matching columns if possible first.
    pcre_remainder="(.*?)"

    # PCRE capturing all such columns on a single line. Dismantled, this is:
    #
    # * "^", anchoring to the beginning of both the string and string lines.
    # * "(?:$|...(.*))", matching an optional trailing column separator and
    #   capturing any remaining text on such line into the last match group.
    # * "$", anchoring to the end of both the string and string lines.
    pcre_columns="^${pcre_columns_sans_last}${pcre_column}(${pcre_column_separator}${pcre_remainder})?$"

    # Iterate such matches with such PCRE in multiline mode.
    for_string_pcre_matches_multiline "${text}" "${pcre_columns}" "${command}"
}

#FIXME: Examples would be nice.
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_columns_split_on_pcre(
    string text,
    string column_separator_pcre,
    string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each column of such line into an element of list
global ${match}. Split such column on any substring of one or more characters
matching the passed PCRE (e.g., `[[:blank:]]++`, matching whitespace-delimited
columns): e.g.,

For each line, all columns except the last must be suffixed by the column
separator (i.e., substring matching the passed PCRE). In an attempt to accept
slightly malformed strings, the last column may be suffixed by an optional
separator itself suffixed by an optional substring _not_ matching such
separator (i.e., a substring matching the remainder of the line). In such case,
such remainder is captured into an additional match group
`${match[$(( ${column_count} + 1 ))]}`. Hence, each line matches at most the
passed number of columns plus one, where the last ``column'' is a pseudo-column
matching the remainder of the line not matched by a genuine column. Such column
should _not_ be generally relied upon.

This function offers a pure-`zsh` alternative to conventional column processors,
including `awk` and cohorts (e.g., `gawk`, `nawk`): e.g.,

.for_string_columns_split_on_pcre()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================

== Caveats ==

Ensure the passed PCRE does *not* match newlines, either explicitly (e.g.,
`[[:space:]]++`) or implicitly (e.g., `[[0-9:^alpha:]]{3,6}`). This function
throws an exception when passed a PCRE matching a single newline. Since such
detection does _not_ suffice to match all PCREs matching newlines, callers
should avoid passing such PCREs. (This function behaves erratically when passed
such PCREs, as the expression matching a line's last column separator could in
such cases consume newlines and hence more than such line).

________________<heredoc?>________________
function for_string_columns_split_on_pcre() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string, one column count, one column separator PCRE, and one command'
    string\
        text="${1}"\
        column_count="${2}"\
        pcre_column_separator="${3}"\
        command="${4}"\
        pcre_column\
        pcre_column_separated\
        pcre_columns_sans_last\
        pcre_columns
    die_unless_integer_positive "${column_count}"
    die_unless_string_nonempty "${column_separator_pcre}"\
        'expected non-empty column separator PCRE'
    die_unless_string_nonempty "${command}" 'expected non-empty command'

    # If such PCRE matches single newlines, throw an exception. Unlike
    # for_string_columns_split_on_pcre_class(), this does *NOT* prevent
    # such PCRE from matching other characters and then a newline. Short of
    # testing every possible string containing a newline, this is the best we
    # can reasonably do.
    is_string_pcre_matches\
        "${ZESHY_ASCII_NEWLINE}" "${column_separator_pcre}" and
        die "column separator PCRE \"${column_separator_pcre}\" matches newlines"

    # Construct a PCRE capturing all such columns on a single line. See
    # for_string_columns_split_on_pcre_class() for further details.
    pcre_column="(.*?)"
    pcre_column_separated="${pcre_column}${pcre_column_separator}"
    pcre_columns_sans_last="$(repeat_string "${pcre_column_separated}" "$(( column_count - 1 ))")"
    pcre_remainder="(.*)"
    pcre_columns="^${pcre_columns_sans_last}${pcre_column}(${pcre_column_separator}${pcre_remainder})?$"

    # Iterate such matches with such PCRE in multiline mode.
    for_string_pcre_matches_multiline "${text}" "${pcre_columns}" "${command}"
}

# --------------------( WASTELANDS                         )--------------------
#[WARNING]
#If the passed PCRE matches newlines either explicitly (e.g., `[[:space:]]++`) or
#implicitly (e.g., `[[0-9:^alpha:]]{3,6}`), this function's behaviour is
#undefined. In such case, the expression matching the last column separator for a
#line may erroneously consume terminating newlines and hence prevent the next
#line from matching. For safety, this function throws an exception on detecting a
#PCRE matching a single newline. Since such detection does _not_ suffice to match
#PCREs matching strings containing newlines rather than a single newline, callers
#should take care to avoid passing such PCREs.

#Run the passed command for each line of the passed string containing at most the
#passed number of columns separated by substrings matching the passed PCRE (e.g.,
#, matching whitespace-delimited columns). This function provides
#such command access to the following canonical match globals:
#
#* ${MATCH}, a string global expanding to the currently iterated line.
#* ${match}, a list global expanding to each column of such line (e.g.,
#  '${match[1]}`, expanding to the first column of the currently iterated line).

#[WARNING]
#FUXME: Even more pressingly than above, we need to make *EVERY* column optional.
#Hence, where no column is matched, everything falls into the fallback bucket.
#This is really essential; strictness is simply not helpful in the real world.
#FUXME: It'd be nice to generalize this to accept arbitrary glob expressions
#with which to match column separators (e.g., "[[:space:]]+", matching column
#separators as any run of whitespace). Actually, that suggests a new
#complementary get_string_column_match() function. Hmm... but how would such
#match be inverted for counting purposes? I suppose there'd be no efficient
#means of doing so, eh?
#FUXME: It'd be nice to generalize this to multiple columns. We'll probably want
#to implement a for_each_string_line_match()-style function to do so -- say,
# string for_each_string_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_separator_class = '[:space:]')

#FUXME: Rename to get_string_lines_word(). While I had originally preferred
#get_string_column_with_index(), such nomenclature leads to unwieldy function
#names elsewhere (e.g., get_string_line_with_column_with_index_equals(): ugh!).
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string get_string_lines_word(
#    string text,
#    integer column_index,
#    string column_separator_class = "[:space:]")
#
#Get the column with the passed 1-based index delimited by one or more characters
#of the passed `zsh`-specific character class (defaulting to "[:space:]", matching
#all whitespace characters) from the passed string. See
#set_list_to_string_column() for further details.
#________________<heredoc?>________________
#function get_string_lines_word() {
#    # Validate passed arguments.
#    die_unless_args_3\
#        'expected one string, one column index, and optional column separator'
#
#    # Get such column.
#    list column; set_list_to_string_column column "${@}"
#    join_list_on_newline column
#}

#FUXME: Rename to for_string_columns_split_on_whitespace(). (Of *COURSE* it's
#line-based. Anything else would be nonsensical.) Similarly below.
    # Iterate such matches with such glob. Since such glob is anchored to the
    # beginning of each string line, prefix such string with a newline to mimic
    # the zero-width PCRE assertion "^". While we could also anchor to the
    # beginning of each string line or such string with
    # "((#s)|${ZESHY_ASCII_NEWLINE})", such pattern captures such newline into
    # the first match group if prefixed by "(#b)". Since
    # for_string_glob_matches_capturing_groups() does exactly that, the ad-hoc
    # solution presented here is 

    # PCRE fragment capturing a single column suffixed either by the string end
    # or column separator.
#   string pcre_column="((?:(?!${column_separator_pcre}).)*?)${column_separator_pcre}"

    # * "$", anchoring to the end of both the string and string lines.
#   pcre_column="((?:(?!${column_separator_pcre}).)*)"
#If the passed PCRE matches newlines either explicitly (e.g.,
#`[[:punct:][:space:]]++`) or implicitly (e.g., `[[0-9:^alpha:]]{3,6}`), throw an
#exception. This prevents the last column separator from erroneously consuming a
#terminating newline and hence preventing the next line from matching.

#This function attempts to accept slightly malformed strings. If the last column
#of any line is suffixed by an optional separator itself suffixed by an additional
#substring _not_ matching the passed PCRE, this function readily captures such
#substring into match group `${match[$(( ${column_count} + 1 ))]}`
#Columns captured into ${match} are guaranteed _not_ to contain column
#separators. The last column may  to be neither prefixed or suffixed by
#the last column is suffixed by a substring matching such class, successfully
#match but do _not_ ignore such character class

#Dismantled, this is:
    #
    # * "^", anchoring such PCRE to the string beginning and each string line.
#In such case, the PCRE this function internally
#constructs from such PCRE to match the last column separator could erroneously
#consume the newline prefixing the next line and hence prevent such line from
#matching. In short, unexpectedly bad things may (and probably will) happen.
#
#If such PCRE matches only characters in a single PCRE character class, consider
#calling for_string_columns_split_on_pcre_class() instead

#[WARNING]
#If the passed PCRE matches newlines (e.g., `[[:space:]]++`), this function's
#behaviour is undefined. In such case, the PCRE this function internally
#constructs from such PCRE to match the last column separator could erroneously
#consume the newline prefixing the next line and hence prevent such line from
#matching. In short, unexpectedly bad things may (and probably will) happen.
#For example:

#[WARNING]
#==========================================
#If the passed PCRE character class matches newlines (e.g., `\n\t\v `,
#`[:space:]`), this function's behaviour is undefined. For safety, this function
#throws an exception when detecting such a class. Since such detection is hardly
#perfect, callers should explicitly avoid passing such classes. Note that
#negative character classes (e.g., `[^a-z]`, `[:^alpha:]`) implicitly match
#newlines and hence are also prohibited.
#
#While the PCRE this function internally constructs from such class could be
#altered (e.g., with negative lookahead assertion) to accomodate such classes,
#doing so would substantially reduce the efficiency of such PCRE -- for little
#gain, in most cases.
#==========================================

    # If such class matches newlines, throw an exception. Technically, this
    # test fails to match all possible classes matching newlines (e.g.,
    # "[\012]", matching only newlines with an octal specifier; "[\x00-\x31]",
    # matching all control characters including newline with a hexadecimal
    # range). While unfortunate, fully checking such condition is infeasible.
    # Since this function's documentation explicitly warns of this constraint,
    # laxness is probably acceptable.
#   is_string_glob_matches "${column_separator_pcre_class}"\
#       ('^'*|*('\n'|'[:'('ascii'|'cntrl'|'space')':]'|'[:^'*':]')*) and
#       die "column separator PCRE character class \"${column_separator_pcre_class}\" matches newlines"

# split from such line on such PCRE (and hence containing
#neither leading or trailing substrings matching such PCRE)
#$(convert_string_to_pcre_multiline\
    # Attempt to match the string end before attempting
    #     to match such column separator; this prevents such PCRE from consuming
    #     more than a line's worth of characters when such separator's class
    #     also matches newlines (e.g., "\n\t\v ", "[:space:]").
    # For safety, prevent character classes from matching newline and hence
    # consuming more than a line's worth of characters.
#While the PCRE
    # constructed below could be modified with negative lookahead assertions to
    # accomodate newline-matching character classes, doing so may substantially
    # reduce the efficiency of such PCRE -- with little gain, in most cases.
#FUXME: Also implement a more efficient generalization,
#for_string_columns_split_on_pcre_class(), accepting a PCRE character class
#rather than a genuine PCRE. In fact, let's implement this first. :}
#.such command, string global
#${MATCH} expands to the current line and list global ${match} to each column of
#such line, split from such line on whitespace (and hence containing neither
#leading or trailing whitespace)
#Set  splitting each such
#line on whitespace into match global
#This function provides such command access to match globals
#${MATCH}, ${MBEGIN}, and ${MEND}
#*columned string* (i.e.,
#newline-delimited string with each such line split on .

#   print -- "$(< ${ZESHY_STDIN_PATH})" | command column -t
#FUXME: Not fond of optional arguments. Split into two functions:
#string tabulate_string(string text1, string text2, ...)
#string tabulate_string_on_separator(string text, string separator = " ")

#, for minor and probably immeasurable efficiency.
    # * "([^${column_separator}]#)", capturing the passed
    #   column excluding the suffixing column separator.
#       integer last_column_index=$(( ${column_index} - 1 ))
#       columns_glob_previous="([^${column_separator}]#(${column_separator}|(#e)))(#c${last_column_index})"
#FUXME: Rename to get_string_column_with_column_separator_class
# string get_string_columns(
#   string text,
#   integer column_index1, integer column_index2, ...,
#   character column_separator = ' ')
#
# Get the columns delimited by the passed separator (defaulting to whitespace)
# having the passed 1-based indices from the passed string. This function is
# analogous to the "cut -f" command: e.g.,
#
# If passed:
#
# * One index, each print_string line directly provides that column.
# * Two or more indices, each print_string line lists such columns delimited by such
#   separator. Getting such columns then requires splitting such lines on such
#   separator (e.g., by calling set_list_to_string_split_on()).
#function get_string_columns() {
    # Validate passed arguments.
#    die_unless_args_3_or_more\
#        'expected one string, one column separator, and at least one column index'
#    string text="${1}"   column_separator="${2}"
#    die_unless_variable_string column_separator
#    shift_args_2

    # If passed only one column index, such column is efficiently splittable
    # with pure zsh. Do so, Sir Robin! Arguably, we needn't do so in zsh; the
    # non-zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
#    if is_args_1; then
        # Index of the column preceding the passed column.
#        die_unless_integer_positive "${1}"
#        integer last_column_index=$(( ${1} - 1 ))
#        list lines; lines=( ${(f)text} )

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column separator via:
        #   * "[^${column_separator}]#", zero or more characters excluding the
        #     column separator.
        #   * "(${column_separator}|(#e))", a column separator or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_separator}]#)", a match group matching the passed
        #   column excluding the suffixing column separator.
#        string last_columns_glob this_column_glob
#        last_columns_glob="([^${column_separator}]#(${column_separator}|(#e)))(#c${last_column_index})"
#        this_column_glob="(#b)([^${column_separator}]#)(${column_separator}|(#e))"

        # Split the passed column.
#        print_strings_newlined\
#            ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure zsh, the inefficiency (and complexity) of such hacks is fugly.
#    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
#        list   column_indices; column_indices=( "${@}" )
#        string column_indices_with_commas
#        column_indices_with_commas="$(join_list column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column separator.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such separator.
#        print_string "${text}" | cut -s\
#            -d "${column_separator}"\
#            -f "${column_indices_with_commas}"
#    fi
#}
