#!/usr/bin/env zsh
# ====================[ line                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle line-oriented PCREs.

#FIXME: Behavior has been corrected. Fix up all prior calls to such functions!

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_string_pcre_multiline_matches(
    string text, string pcre)

Return success the passed string matches the passed PCRE in multiline mode. See
for_string_pcre_matches() for further details.
/---
function is_string_pcre_multiline_matches() {
    die_unless_args_2 'expected one string and one PCRE'
    is_string_pcre_matches\
        "${1}" "$(convert_string_to_pcre_multiline "${2}")"
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_string_pcre_multiline_matches_indexed().
declare_function_with_stdin <<'/---'
string get_string_pcre_multiline_match_index_all(
    string text, string pcre, integer group_index)

List the substring captured to the passed 1-based group index from each line
matching the passed PCRE in multiline mode, delimiting each such substring by a
newline. Ensure each output line contains only a single match by anchoring such
PCRE to the current line. Specifically:

* Explicitly prefix and suffix such PCRE with zero-width assertions `^` and `$`.
* Avoid both negative character types (e.g., `\D`, `\W`) and classes (e.g.,
  `[[:^alpha:]]`, `[^[:punct:]]`) in such PCRE, which _always_ match newlines if
  possible and hence consume more than a single line of text.

See for_string_pcre_matches() for further details: e.g.,

.get_string_pcre_multiline_match_index_all()
==========================================
[source]
------------------------------------------
>>> string i_seem_to_be_a_verb="
...     I live on Earth at present,
...     and I don't know what I am.
...     I know that I am not a category.
...     I am not a thing—a noun.
...     I seem to be a verb,
...     an evolutionary process—
...     an integral function of the universe."
>>> get_string_pcre_multiline_match_index_all "${i_seem_to_be_a_verb}"\
...     '^I (\w++).*$' 1
live
know
am
seem
------------------------------------------
==========================================
/---
function get_string_pcre_multiline_match_index_all() {
    # Validate passed arguments, popping off the trailing group index.
    die_unless_args_3 'expected one string, one PCRE, and one group index'
    string group_index="${3]}"
    die_unless_integer_positive "${group_index}"
    pop_arg

    # Match and break on the first such group.
    for_string_pcre_multiline_matches "${@}"\
        "output_string \"\${match[${group_index}]}\""
}

#FIXME: Rename to get_string_pcre_multiline_match_indexed_first().
declare_function_with_stdin <<'/---'
string get_string_pcre_multiline_match_index_first(
    string text, string pcre, integer group_index)

Get the substring captured to the passed 1-based group index from the first line
matching the passed PCRE in multiline mode. (Equivalently, return the first line
that get_string_pcre_multiline_match_index_all() matches). See such function for
further details: e.g.,

.get_string_pcre_multiline_match_index_first()
==========================================
[source]
------------------------------------------
>>> string syllabus_of_condemned_opinions="
...     There is no
...     supreme, omniscient, all foreseeing Deity distinct from the universe.
...     God is the same thing as Nature and therefore subject to change.
...     He becomes God in the world and man;
...     all things are God and have the very substance of God."
>>> get_string_pcre_multiline_match_index_first\
...     "${syllabus_of_condemned_opinions}" '^.*?all (\w++).*$' 1
foreseeing
------------------------------------------
==========================================
/---
function get_string_pcre_multiline_match_index_first() {
    # Validate passed arguments, popping off the trailing group index.
    die_unless_args_3 'expected one string, one PCRE, and one group index'
    string group_index="${3}"
    die_unless_integer_positive "${group_index}"
    pop_arg

    # Match and break on the first such group.
    for_string_pcre_multiline_matches "${@}"\
        "output_string \"\${match[${group_index}]}\"; break"
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'/---'
integer get_string_pcre_multiline_match_count(string text, string pcre)

Get the number of lines in the passed string matching the passed PCRE in
multiline mode. See for_string_pcre_matches() for further details.
/---
function get_string_pcre_multiline_match_count() {
    integer match_count=0
    for_string_pcre_multiline_matches "${@}" '(( ++match_count ))'
    return_string ${match_count}
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string convert_string_to_pcre_multiline(string pcre)

Enable multiline matching in the passed PCRE. This prefixes such PCRE with
`(?m)`, inducing `^` and `$` to match newline characters as well as the string
start and end, respectively.
/---
function convert_string_to_pcre_multiline() {
    # If such PCRE already contains "(?m)", prefixing yet another does no harm.
    die_unless_arg 'expected one PCRE'
    return_string "(?m)${1}"
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'/---'
string for_string_pcre_multiline_matches(
    string text, string pcre, string command)

Run the passed command for each match of the passed string with the passed PCRE
in multiline mode. See for_string_pcre_matches() for further details: e.g.,

.for_string_pcre_multiline_matches()
==========================================
[source]
------------------------------------------
>>> string aphorisms_against_work=\
...    "Laziness is a comedy in which we can all play a part,
...     a veritable field of sunblown flowers
...     where the unruly colors of
...     the universe dance with the wind."
>>> for_string_pcre_multiline_matches "${aphorisms_against_work}"\
...     '^.*\b(a|the)\b.*$'\
...     'output_string ${match[1]}: ${MATCH}'
a: Laziness is a comedy in which we can all play a part,
a: a veritable field of sunblown flowers
the: where the unruly colors of
the: the universe dance with the wind.
------------------------------------------
==========================================
/---
function for_string_pcre_multiline_matches() {
    die_unless_args_3 'expected one string, one PCRE, and one command'
    for_string_pcre_matches\
        "${1}" "$(convert_string_to_pcre_multiline "${2}")" "${3}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: As with all line-oriented functions at the moment, this doesn't work as
#intended. Contemplate.
#FUXME: Rename to for_string_pcre_multiline_matches().
#FUXME: Uhm; this is erroneously named now. Revert back to
#get_string_pcre_multiline_match(). *sigh*
#FUXME: The whole PCRE options thing is a bit heavyweight *AND* unnecessary, as
#such options can simple be embedded in such PCRE (e.g., "(?m)" rather than
#"-m"). In fact, doing so is quite a bit safer *AND* more efficient, as passing
#a PCRE then suffices to pass all such options.

#Consider anchoring such PCRE to lines rather arbitrary substrings lines rather than the entire string To , this function:
#* Enables multiline matching by prefixing such PCRE with "(?m)".
#* Anchors 

#FUXME: Terrible idea. Impossible to implement reliably.
#declare_function_with_stdin <<'/---'
#<globbable> string convert_string_to_pcre_matching_lines(string pcre)
#
#Convert the passed PCRE to a *line-oriented PCRE* prefixed with `(?m)^.*?` if
#not already prefixed with equivalent expressions. Note that:
#
#* `(?m)` enables multiline matching, inducing `^` and `$` to match a newline as
#  well as the string start and end, respectively.
#* `^.*?` anchors such string to either a newline or the string start.
#/---
#function convert_string_to_pcre_matching_lines() {
#    # If such PCRE already contains "(?m)", prefixing yet another does no harm.
#    die_unless_arg 'expected one PCRE'
#    string pcre="${1}"
#
#    # If the passed regex is not explicitly anchored to newlines with "^", add
#    # such anchor.
#    is "${pcre[1]}" == '^' si or {
#        if is "${pcre}" == '.*'* si {
#            pcre="^${pcre}"
#        } else {
#            pcre="^.*?${pcre}"
#        }
#    }
#
#    # Enable multiline matching *AFTER* the above prefixes. See
#    # convert_string_to_pcre_multiline() for further details.
#    return_string "(?m)${pcre}"
#}

# --------------------( TODO                               )--------------------
# * Uhm; the "[[ ... =~ ... ]]" operator sets globals "${MATCH}" and "${match}"
#   on success, thus providing a far more concise and probably efficient
#   alternative to our current implementation. That said, the current
#   implementation does permit the user of caller-specific variables, which is
#   nice. Hence, we could improve the match() function with an optimization in
#   the case the caller accepts the default variable names. For further details,
#   see section "Conditional Expressions" under "info zsh".
# * Provide a glob-specific equivalent to the get_*match() family of functions.
#   The (M) flag to #- and %-style matches appears to support this, if crudely.
#   convert_string_to_pcre_enabling_option "${1}" m
    # Validate passed arguments.
#   string pcre="${1}"

    # If such PCRE already contains option "m", return such PCRE as is.
#   if is_pcre_enabling_option "${pcre}" 'm' si {
#       return_string "${pcre}"
    # Else, return such PCRE prefixed with such option.
#   } else {
#       return_string "(?m)${pcre}"
#   }

    #FUXME: Stop this. It's simply not safe. In fact, it's blatantly stupid.
    # If the passed regex is not explicitly anchored to newlines with a "^"
    # prefix and "$" suffix, add such anchors.
#   is "${pcre[1]}"  == '^' si or pcre="^.*?${pcre}"
#   is "${pcre[-1]}" == '$' si or pcre="${pcre}.*?$"

    # Validate passed arguments, treating piped input as the passed string and
    # removing all arguments except for the list of PCRE options if passed.
#Such options include zero or more of the following:
#
#* `-i`, matching case-insensitively. By default, matches are case-sensitive.
#* `-m`, matching multiline-aware such that:
#** `^` matches either a newline or the string start. By default, `^` matches
#   only the string start.
#** `$` matches either a newline or the string end. By default, `$` matches only
#   the string end.
#* `-s`, permitting `.` to match all characters including newline. By default,
#  `.` matches all characters excluding newline.
#* `-x`, matching an extended PCRE ignoring whitespace and `#` comments. By
#  default, whitespace and `#` are significant and hence matched ``as is.''

#   if { is_args_0 } {
#       is "${text}" =~ "${pcre}" si and return_exit_status_silent
    # Else, manually compile the passed PCRE with the passed PCRE options
    # and match with such compiled PCRE.
#   } else {
#       print "pcre_compile \"${pcre_options}\" -- \"${pcre}\""
#       pcre_compile "${@}" -- "${pcre}"
#       pcre_study
#       pcre_match -- "${text}" and return_exit_status_silent

#       print_string "matched: ${match[@]}"
#Such globals are a proper subset of those that globs enabling globbing flags
#`(#b)` and `(#m)` set: . (Specifically, such globs also set

#Match globals accessible to such command include:
#   string_global_export ZPCRE_OP='0 0'
    # If the passed PCRE is empty, die. If the passed string is empty, noop.
#   is_string_empty "${text}" and return_true

#   integer match_count=0
#   is_stdin_pipe and run_command_with_stdin_piped\
#       for_string_pcre_matches "${@}" '(( ++match_count ))' or
#       for_string_pcre_matches "${@}" '(( ++match_count ))'
#   print_string ${match_count}

#FUXME: Use in place of for_string_pcre_matches(), above.
#   string error_message='expected one string, one PCRE, and optional regex options'

    # If piped input, pipe such input to get_string_pcre_match_count().
#   if is_stdin_pipe; then
#       die_unless_args "${error_message}"
#       string pcre; pcre="$(convert_string_to_pcre_multiline "${1}")"
#       shift_arg
#       run_command_with_stdin_piped get_string_pcre_match_count "${pcre}" "${@}" -m
    # Otherwise, call get_string_pcre_match_count() as expected.
#   else
#       die_unless_args_2_or_more "${error_message}"
#       string text="${1}" pcre; pcre="$(convert_string_to_pcre_multiline "${2}")"
#       shift_args_2
#       get_string_pcre_match_count "${text}" "${pcre}" "${@}" -m
#   fi

#FUXME: The order of arguments seems a bit... off. The command should be passed
#*LAST*, which reads much more intuitively, actually resembling a proper loop: e.g.,
#
#   for_string_pcre_matches "${text}" "${pcre}" "${@}" -m\
#       "output \"\${match[${group_index}]}\"; break"

#'expected non-empty regex'
#   string error_message='expected one command, one string, one PCRE, and optional regex options'
#   die_unless_args "${error_message}"
#   string command="${1}" text pcre
#   shift_arg
#   print_string "command: ${command}"

    # If passed piped input, such input is the string to be matched.
#   if is_stdin_pipe; then
#       die_unless_args_1_to_2 "${error_message}"
#       set_string_to_stdin_piped text
#       pcre="${1}"
#       shift_arg
    # Otherwise, the second passed argument is the string to be matched.
#   else
#       die_unless_args_2_to_3 "${error_message}"
#       text="${1}"
#       pcre="${2}"
#       shift_args_2
#   fi
#   print_string_with_escapes "text: ${text}\npcre: ${pcre}"

    # If passed piped input, treat such input as the passed string.
#   if is_stdin_pipe; then
#       set_string_to_stdin_piped text
#       pcre="${1}"
#       shift_arg
    # Otherwise, treat the first passed argument as the passed string.
#   else
#       text="${1}"
#       pcre="${2}"
#       shift_args_2
#   fi

        # Shift off the leading PCRE and iterate such matches.
        # Shift off the leading PCRE and iterate such matches.
# all arguments except for the list of PCRE options if passed.

    #FUXME: Throw an exception unless the passed PCRE contains a match group. We
    #probably want a new die_unless_pcre_containing_match_group() function.

# Groups matched by non-multiline PCREs cannot reliably be delimited by
# newlines, as matches may themselves contain newlines; so, no corresponding
# get_string_pcre_match() function exists. Instead, consider calling
# for_string_pcre_matches() for such logic.

# For efficiency, this function returns the first line returned by get_string_pcre_multiline_match()
# in an efficient manner (i.e., by immediately halting on such line).
#   list pcre_options; pcre_options=( "${@}" )
#   for_string_pcre_matches "output matches: \${match[@]}; break 2"\
#       "output \${match[${group_index}]}; break 2" "${text}" "${@}" -m
#   substring (e.g., "${match[1]}" expands to the first match group). As caveat,
#   note this *REQUIRES* embedding "(#b)" prior to such match groups in the
#   passed PCRE. For efficiency, this function does not embed "(#b)" by default.

#FUXME: Shift to "list".
#get_list_elements() {
#    die_unless_args 'expected at least one list index'
#
#    for index ("${@}") {
#    }
#}

#       '(( ${#match} )) and print_string ${match[@]} or print_string ${MATCH}'\

#FUXME: We really want to eliminate the *_multiline() functions. Nice idea, but
#there are simply too many useful permutations (e.g., multiline_caseless,
#multiline_extended). Rather, use a similar mechanism as the
#get_string_pcre_match_count() function whereby options are passed after all other
#parameters. (Somewhat awkward, but... *shrug*)

    # If piped input, convert such input to passed arguments.
#   if is_stdin_pipe; then
#       die_unless_arg 'expected one PCRE and optional regex options'
#       set_args "$(get_stdin_piped)" "${@}"
#   fi

    # Localize passed arguments.
#   die_unless_args_2_or_more\
#       'expected one string, one PCRE, and optional regex options'
#   string text="${1}" pcre
#   pcre="$(convert_string_to_pcre_multiline "${2}")"
#   shift_args_2

    # Count.
#   get_string_pcre_match_count "${pcre}" "${@}" -m
# ....................{ MATCHES                            }....................
#FUXME: Good name; just a comment to myself: list_ is better than get_ here.
#Since we're matching on lines, we can safely return a newline-delimited string.
#That said, it's not terribly orthogonal; perhaps return_list(), instead?
#
#FUXME: Completely rewrite. First, note that I've already stored the current
#implementation of this function in the WASTELANDS. Second, stop accepting
#"match_variable_name" and "group_array_name"; instead, force use of $MATCH and
#$match. The alternative is simply unreadable, unmanageable, and exceptionally
#confusing when read as a function call. Third, shift to a function parameter
#style as in the above functions. This reduces the function to something very
#sensible. Oh, and support is_stdin_pipe() and get_stdin_piped(), as above.

# void match_pcre(
#   string regular_expression, string text = null,
#   string match_variable_name = "MATCH", string group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints print_string in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}"
#     1
#match_pcre() {
    # Parse parameters.
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
#    string regex="${1}" text="${2}"\
#        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, zsh requires this regardless of whether we intend
    # to actually reuse this match.)
#    if is_variable 'ZESHY_MATCH_OPTIONS'; then
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
#        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
#            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
#    else
#        pcre_compile "${regex}" or
#            die "\"${regex}\" not a valid regular expression"
#    fi

    # Match.
#    pcre_match -v "${match_variable_name}" -a "${group_array_name}" -- "${text}"
#}

# void match_pcre_multiline(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) in a multi-line fashion (e.g., matching '^' and '$' at both newline and
# the beginning and end of the string, respectively). In all other respects,
# this function is identical to the match() function.
#match_pcre_multiline() {
#    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
#    match_pcre "${@}"
#}

# ....................{ MATCHES ~ by groups                }....................
# string match_pcre_first_group(...)
#
# Return the first group to successfully match in the passed string against the
# passed regex. If no group matched, fail. See match() comments for further
# details: e.g.,
#
#     >>> match_first_group '(\d)$' '1984'
#     4
#match_pcre_first_group() {
    # Match.
#    match_pcre "${@}"

    # If at least one group matched, return the first such group.
#    string group_array_name="${4:-match}"
#    is_variable "${group_array_name}" si and
#        print_string "${${(@P)group_array_name}[1]}"
#   is -n "${(@P)group_array_name}" si and print "${${(@P)group_array_name}[1]}"
#}

# void match_pcre_multiline_first_group(...)
#
# Return the first group to successfully match in the passed string against the
# passed regex, in a multi-line fashion (e.g., matching '^' and '$' at both
# newline and the beginning and end of the string). If no group matched, fail.
#
# This function is otherwise identical to the match_multiline() function.
#match_pcre_multiline_first_group() {
#    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
#    match_pcre_first_group "${@}"
#}

# ....................{ MATCHES ~ by lines                 }....................
# string match_pcre_first_line(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the first matched line, if at least one such line matched,
# or the empty string otherwise.
#
# In all other respects, this function is identical to the match() function.
# In particular, note groups may still be obtained via the "${match}" array.
#match_pcre_first_line() {
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'

    # Guarantee the passed regular expression roots itself to single rather than
    # multiple lines (i.e., begins with '^' and ends with '$').
#    string regex="${1}"
#    shift_arg

    # No, I don't know why the former requires a '.' while the latter does not.
    # I'm sure there's a highly rational reason within the musty bowels of ZSH.
#   print "regex: "${regex}
#    is "${regex}" == ^.* si or regex="^.*${regex}"
#    is "${regex}" == *$  si or regex="${regex}.*$"
#   print "regex: "${regex}

    # Pack this modified regular expression back into the array of all passed
    # arguments, for convenience.
#    set_args "${regex}" "${@}"

    # Match.
#    match_pcre_multiline "${@}"

    # Print the first matching line.
#    string match_string_name="${3:-MATCH}"
#    print_string "${(P)match_string_name}"
#}

# ....................{ SETTERS                            }....................
# int append_pcre_match_to(
#   list *matches_name,
#   string text, string pcre, string pcre_option1, string pcre_option2, ...)

# Append all match groups...
# Set the list with the passed name to .
# Get the number of substrings in the passed string matching the passed PCRE
# with the passed PCRE options: e.g.,
#
#     >>> list pcre_matches
#     >>> set_pcre_match_to pcre_matches 'Xanadu  # XaXaXaXaXaXa' '([Xn]a)' -x
#     >>> print ${pcre_matches[-1]}
#     na
#append_pcre_match_to() {
#    die_unless_args_2_or_more\
#        'expected one list name, one string, one PCRE, and optional regex options'
#    string matches_name="${1}"
#    die_unless_list "${matches_name}"

#    for_string_pcre_matches 'matches_name+=(( ${MATCH} ))' "${@}"
#   eval '${matches_name}=( )
#}

#get_string_pcre_matches_count_old() {
    # Localize passed arguments.
#    string text pcre
#    if is_stdin_pipe; then
#        die_unless_args_1_to_2\
#            'expected one PCRE and optional regex options'
#        text="$(get_stdin_piped)"
#        pcre="${1}"
#        shift_arg
#    else
#        die_unless_args_2_to_3\
#            'expected one string, one PCRE, and optional regex options'
#        text="${1}"
#        pcre="${2}"
#        shift_args_2
#    fi
#    list pcre_options; pcre_options=( "${@}" )

    # If either the passed string or PCRE is empty, return 0.
#    { is_string_empty "${text}" or is_string_empty "${pcre}" } and print_string 0

    # Compile the passed PCRE for optimum matching with the passed options.
#    pcre_compile "${pcre_options[@]}" -- "${pcre}"
#    pcre_study

    # Count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while matching
    # until no matches remain yields the number of matches. Dismantled, this is:
    #
    # * "ZPCRE_OP='0 0'", initializing a zsh global tracking the first and last
    #   0-based byte indices of the currently matched substring in ${text}.
    # * "pcre_match", matching the next substring given:
    #   * "-b", tracking indices in the ${ZPCRE_OP} global.
    #   * "-n", starting matching at the passed string index:
    #     * "${ZPCRE_OP[(w)2]}", expanding to the byte immediately following the
    #       last byte index of the previously matched substring.
#    integer pcre_match_count=0
#    string_global_export ZPCRE_OP='0 0'
#    while pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"; do
#        (( ++pcre_match_count ))
#    done
#    print_string ${pcre_match_count}
#}

#FUXME: This shares nearly the same implementation as get_string_pcre_match().
#Clearly, what we need is a helper function passed the same arguments as this
#function with an additional first argument specifying the command to be
#evaluated in each "while" loop iteration. Say, run_command_on_pcre_match()?

    #FUXME: Hmm; we should probably anchor the passed PCRE with "^.*" and ".*$"
    #unless already beginning with "^" and ending with "$". Otherwise, we're not
    #actually matching within lines. Too much work, for the present.
    #FUXME: Silly. get_string_pcre_match_count() should be revised to accept piped
    #stdin, and this revised to pass_piped_stdin_to() and manual dying on args.
    # If the string was passed to this function from piped standard input, then
    # die_unless_args_2() erroneously reversed the argument order. Reverse it
    # back. Otherwise, we're good to go.
#   die_unless_args_2 'expected one string and one PCRE'
#   then get_string_pcre_match_count "${@[-1]}" "${@[1,-2]}" -m

# void match_pcre(
#   string regular_expression, string text = null,
#   string match_variable_name = "MATCH", string group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints print_string in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}" 
#     1
#match_pcre() {
    # Parse parameters.
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
#    string regex="${1}" text="${2}"\
#        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, zsh requires this regardless of whether we intend
    # to actually reuse this match.)
#    if is_variable 'ZESHY_MATCH_OPTIONS'; then 
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
#        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
#            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
#    else
#        pcre_compile "${regex}" or
#            die "\"${regex}\" not a valid regular expression"
#    fi
    
    # Match.
#    pcre_match -v "${match_variable_name}" -a "${group_array_name}" -- "${text}"
#}

#FUXME: This is uniformly terrible, any way you dice it. Slice this apart.
# string get_enabling_multiline(...)
#
# Get all lines matching the passed regex. Unlike most Zeshy matching
# functions, this function uses "grep" rather than the "zsh/pcre" module as the
# latter provides no efficient means of obtaining non-overlapping matches.
#
# Unfortunately, this implies groups to be inaccessible.
#get_enabling_multiline() {
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
#   local regexp="${1}" string="${2}"
#    print_string "${2}" | grep --perl-regexp "${1}"
#}

#   print "arg1: ${1}\narg2: ${2}"

# int get_enabling_multiline_count(...)
#
# Return the number of lines matching the passed regex. See the
# get_enabling_multiline() function for caveats.
#get_enabling_multiline_count() {
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
##    print_string "${2}" | grep --perl-regexp --count "${1}"
#}

#   pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"
#   print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#   pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"
#   print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#       print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#   while (pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}") {
#       (( pcre_match_count++ ))
#   }
# int get_string_pcre_match_count(string pcre_options, string text, string pcre)
#   string error_message='expected optional options, one string, and one PCRE'
#   die_unless_args "${error_message}"
#   if si "${1[1]}" == '-' si; then
#       die_unless_args_3 "${error_message}"
#   else
#       die_unless_args_2 "${error_message}"
#   fi

#FUXME: This is horrible. IT'S ALL HORRIBLE! Use pure zsh expressions rather
#than this nonsense. There exists no guarantee that grep's "--perl-regexp" are
#anything like zsh's. The implementation should resemble that of
#get_match_count(). (Yes, I've searched for better ways. They don't exist.)
#
#That said; it'd be a shame to jettison this. Instead, just shift the existing
#function into Zeshy Grep, perhaps renamed to get_grep_match_count(...).

# See also the get_integer_of_glob_matches() function, which behaves similarly
# but less efficiently -- matching via multiple glob rather than one regular
# expression.

# --------------------( CONVENTIONS                        )--------------------
# All regular expressions matched by this component are Perl-compatible regular
# expressions (PCRE), unless otherwise stated. Thus, we abbreviate such regular
# expressions "regexes."
# 
# All functions defined by this component accept the same number and type of
# parameters as the core match() function, unless otherwise stated. Thus, we
# abbreviate such parameters "...". 
#
# ....................{ GROUPS ~ last                      }....................
#FUXME: Does this actually work? And even if it does, we really should be using
#the ZSH "pcre" facility to guarantee as-expected interpretation of the regex.
# string match_last_group(string regular_expression, string text)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the last matched group, if at least one such group matched.
#match_last_group() {
#    die_unless_args_2_or_more\
#        'expected exactly one regular expression and one string'
#        
#    # Parse parameters.
#    string regexp="${1}" string="${2}"
#
#    # Match. For simplicity, use "grep" rather than zsh's "pcre" module.
#    try "echo '${string}' | tac | grep --perl-regexp -m 1 '${regexp}'"
#}

    #FUXME: Uncommenting this causes *HORRIBLE, UTTERLY IMPOSSIBLE TO DEBUG*
    #issues. And it shouldn't. But there it is.
    # Localize the group array.
#   typeset -Ag ${group_array_name}

    # Retrieve the first group.
#   string first_group_name="${group_array_name}[1]"

    # If this match matched at least one group, return that. Otherwise, nil.
#   print "first_group_name: ${first_group_name}"
#   string first_group="${(P)first_group_name}"
#   print "first_group: ${first_group}"

    # If there exists at least one group, print the first and return success;
    # otherwise, print nothing and return failure.
#   is_string_nonempty "${first_group}" and print "${first_group}"

#   local regexp="${1}" string="${2}"
#   try "get_enabling_multiline '${@}' | get_string_line_count"
#   try "echo '${string}' | sed 's/${regex}/${regex}\n/g' | grep --perl-regexp --count '${regex}'"
#   return
#       die "\"${string}\" not matched by regular expression \"${regex}\""
    # If the passed regex contains no groups, embed that regex in a group
    # matching the entire prior regex.
#   [[ "${1}" == *\(*\)* ]] || set -- "(${regex})" "${@}"

    # Match.
#   match "${@}" || return ${?}
#   echo "${#match}"

    # Print the number of matches.
#   local group_array_name="${4:-match}"
#   print "${(P)#group_array_name}"

