#!/usr/bin/env zsh
# ====================[ pcre                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle Perl-compatible Regular Expressions (PCREs).
#
# --------------------( CAVEATS                            )--------------------
# * While glob-specific functions are declared to be `<globbable>` and hence
#   permit globs to be unquoted, PCRE-specific functions are _not_ and hence
#   require PCREs to be single-quoted. Avoid double-quoting PCREs, which often
#   contain `\`-prefixed expressions treated by `zsh` as character escapes
#   implicitly deleting each such `\`.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_string_pcre_matches(string text, string pcre)

Return success if the passed string matches the passed PCRE. See
for_string_pcre_matches() for further details.
________________<heredoc?>________________
function is_string_pcre_matches() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one PCRE'
    string text="${1}" pcre="${2}"

    # Match such string. While calling pcre_compile(), pcre_study(), and
    # pcre_match() would suffice to perform such match, operator "=~" does so
    # concisely and equally efficiently (in most cases).
    is "${text}" =~ "${pcre}" si
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_pcre_match_count(
    string text, string pcre)

Get the number of substrings in the passed string matching the passed PCRE. See
for_string_pcre_matches() for further details: e.g.,

.get_string_pcre_match_count()
==========================================
[source]
------------------------------------------
>>> get_string_pcre_match_count "anthropocene tropes" '(?x)
...     # An extended PCRE matching both "ropo" and "rope".
...     rop[aeiou]'
2
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_pcre_match_count() {
    integer match_count=0
    for_string_pcre_matches "${@}" '(( ++match_count ))'
    return_string ${match_count}
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_pcre_matches(string text, string pcre, string command)

Run the passed command for each substring of the passed string matching the
passed PCRE: e.g.,

.for_string_pcre_matches()
==========================================
[source]
------------------------------------------
>>> string will_durant=\
...    "The great snare of thought is uncritical acceptance of irrational
...     assumptions."
>>> for_string_pcre_matches "${will_durant}"\
...     '(?im)(?|th([eo])|^?(?) |?(?|c(c)|r(r)|s(s)))'\
...     'output_string "${MATCH}" ("${match[1]}")'
The (e)
tho (o)
is (s)
acc (c)
of (f)
irr (r)
ass (s)
------------------------------------------
==========================================

== PCRE Syntax ==

`zsh` performs PCRE matching by linking against the system-wide PCRE library
implemented in pure C and hence supports _all_ features of such library:

* Perfect emulation of Perl- and Python-specific regular expression syntax,
  including syntax specific to the most recently released version of Perl.
* Partial emulation of .NET-, Oniguruma-, and JavaScript-specific regular
  expression syntax.
* Just-in-time (JIT) optimization.
* UTF-8-driven Unicode character properties and extended grapheme clusters.
* Arbitrarily recursive patterns capable of matching fully balanced parentheses.
* Greedy and non-greedy quantifiers for controlling match length.
* Atomic groups and possessive quantifiers for preventing backtracking.
* Backtracking control verbs for controlling backtracking behaviour.
* Named and numbered subpatterns, including duplicates for resetting branches.
* Absolute and relative back references and subroutine calls.
* Positive and negative lookahead and lookbehind assertions.
* Conditional subpatterns for testing subpattern and recursion matches.

Such library is sufficiently powerful, expressive, and efficient to implement
non-regular context-free text parsers in pure `zsh` -- as `zeshy` itself does
elsewhere (e.g., parsing help documentation strings). For further details, see
the following documentation:

* http://www.pcre.org/pcre.txt[PCRE *.txt], concatenating all PCRE man pages
  into a single plaintext file. This is arguably the optimal means of searching
  PCRE documentation for specific features, phrases, or syntax.
* `man pcre`, indexing other PCRE man pages.

=== PCRE-internal Options ===

Like most regular expression implementations, the PCRE library supports numerous
options for modifying PCRE matching on a PCRE-specific basis -- including common
options for enabling caseless, multiline, and extended matching. While the
underlying `zsh/pcre` module interfacing with such library supports passing such
options as `-`-prefixed options to builtin pcre_compile() (e.g.,
`pcre_compile -m ^$`, a multiline PCRE matching both the empty string and blank
lines), this function requires such options be embedded directly into PCREs with
syntax `(?${options})`, where `${options}` is a string of one or more of the
following characters:

* `i`, enabling caseless (i.e., case-insensitive) matching. By default, matches
  are case-sensitive.
* `m`, enabling multiline matching such that:
** `^` matches either a newline or the string start. By default, `^` matches
   only the string start.
** `$` matches either a newline or the string end. By default, `$` matches only
   the string end.
* `s`, permitting `.` to match all characters _including_ newline. By default,
  `.` matches all characters _excluding_ newline.
* `x`, enabling extended matching by ignoring:
** All whitespace characters neither escaped or in a character class. By
   default, whitespace is significant.
** All characters between an unescaped `#` not in a character class and the next
   newline, thus ignoring comments. By default, `#` characters are matched
   literally.
* `J`, permitting subpattern names to be duplicated, typically used for so-
  called ``branch resets.'' By default, subpattern names must be unique.
* `U`, inverting quantifier greediness such that quantifiers _not_ suffixed by
  `?` are non-greedy and quantifiers suffixed by `?` are greedy. By default,
  quantifiers _not_ suffixed by `?` are greedy and quantifiers suffixed by `?`
  are non-greedy.

Either prefixing or suffixing a PCRE with such options suffices to globally
enable such options on the full PCRE.

== PCRE Globals ==

On each successful match, the passed command may access the following globals:

* ${MATCH}, a string global expanding to the currently matched substring.
* ${match}, a list global containing each match group captured within such
  substring (e.g., `${match[1]}`, the first match group).

Note that globs enabling globbing flags `(#b)` and `(#m)` (e.g., by calling
convert_string_to_glob_capturing_groups_and_substrings()) set similar globals,
as well as several others _not_ set for PCRE matches (i.e., ${mbegin}, ${mend},
${MBEGIN}, ${MEND}). Since the latter globals are largely unhelpful, this tends
not to be an issue.
________________<heredoc?>________________
function for_string_pcre_matches() {
    # Validate passed arguments.
    die_unless_args_3 'expected one string, one PCRE, and one command'
    string text="${1}" pcre="${2}" command="${3}"
    die_unless_string_nonempty pcre 'expected non-empty PCRE'

    # Localize string and list match globals, in case such glob enables "(#b)".
    string MATCH MBEGIN MEND
    list   match mbegin mend

    # Compile this PCRE for optimum matching with the passed options.
    pcre_compile -- "${pcre}"
    pcre_study

    # Iterate such matches. Dismantled, this is:
    #
    # * "ZPCRE_OP='0 0'", a zsh string global tracking the first and last
    #   0-based byte indices of the currently matched substring in ${text}.
    # * "pcre_match", matching the next substring given:
    #   * "-b", tracking indices in the ${ZPCRE_OP} global.
    #   * "-n", starting matching at the passed string index:
    #     * "${ZPCRE_OP[(w)2]}", expanding to the byte immediately following the
    #       last byte index of the previously matched substring.
    #
    # For efficiency, evaluate the loop once rather than on each loop iteration.
    string ZPCRE_OP='0 0'
    eval "while { pcre_match -b -n \${ZPCRE_OP[(w)2]} -- \"\${text}\" } {
        ${command}
    }"
}

# --------------------( WASTELANDS                         )--------------------
    # If passed no PCRE options, operator "=~" provides concise PCRE matching.
    # Implement such conditionals with binary operators rather than an "if"
    # statement, as the latter squelches exit status of such tests.
#   { is_args_0 and is "${text}" =~ "${pcre}" si } or
    # Else, manually compile the passed PCRE with the passed PCRE options
    # and match with such compiled PCRE.
#   {
#       print "pcre_compile \"${pcre_options}\" -- \"${pcre}\""
#       pcre_compile -- "${pcre}"
#       pcre_study
#       pcre_match -- "${text}"
#   }

#.for_string_pcre_matches()
#==========================================
#[source]
#------------------------------------------
#>>> for_string_pcre_matches "Holocene extinction event" ([Hl](o)|e[nvx])\
#...     'print -- "${MATCH}" "${match[1]}"'
#Ho o
#lo o
#en
#ex
#ev
#en
#------------------------------------------
#==========================================

#FUXME: Uhm; this is erroneously named now. Revert back to
#get_string_pcre_multiline_match(). *sigh*
#FUXME: The whole PCRE options thing is a bit heavyweight *AND* unnecessary, as
#such options can simple be embedded in such PCRE (e.g., "(?m)" rather than
#"-m"). In fact, doing so is quite a bit safer *AND* more efficient, as passing
#a PCRE then suffices to pass all such options.

#Consider anchoring such PCRE to lines rather arbitrary substrings lines rather than the entire string To , this function:
#* Enables multiline matching by prefixing such PCRE with "(?m)".
#* Anchors 

#FUXME: Terrible idea. Impossible to implement reliably.
#declare_function_with_stdin <<'________________<heredoc?>________________'
#<globbable> string convert_string_to_pcre_matching_lines(string pcre)
#
#Convert the passed PCRE to a *line-oriented PCRE* prefixed with `(?m)^.*?` if
#not already prefixed with equivalent expressions. Note that:
#
#* `(?m)` enables multiline matching, inducing `^` and `$` to match a newline as
#  well as the string start and end, respectively.
#* `^.*?` anchors such string to either a newline or the string start.
#________________<heredoc?>________________
#function convert_string_to_pcre_matching_lines() {
#    # If such PCRE already contains "(?m)", prefixing yet another does no harm.
#    die_unless_arg 'expected one PCRE'
#    string pcre="${1}"
#
#    # If the passed regex is not explicitly anchored to newlines with "^", add
#    # such anchor.
#    is "${pcre[1]}" == '^' si or {
#        if is "${pcre}" == '.*'* si {
#            pcre="^${pcre}"
#        } else {
#            pcre="^.*?${pcre}"
#        }
#    }
#
#    # Enable multiline matching *AFTER* the above prefixes. See
#    # convert_string_to_pcre_multiline() for further details.
#    return_string "(?m)${pcre}"
#}

# --------------------( TODO                               )--------------------
# * Uhm; the "[[ ... =~ ... ]]" operator sets globals "${MATCH}" and "${match}"
#   on success, thus providing a far more concise and probably efficient
#   alternative to our current implementation. That said, the current
#   implementation does permit the user of caller-specific variables, which is
#   nice. Hence, we could improve the match() function with an optimization in
#   the case the caller accepts the default variable names. For further details,
#   see section "Conditional Expressions" under "info zsh".
# * Provide a glob-specific equivalent to the get_*match() family of functions.
#   The (M) flag to #- and %-style matches appears to support this, if crudely.
#   convert_string_to_pcre_enabling_option "${1}" m
    # Validate passed arguments.
#   string pcre="${1}"

    # If such PCRE already contains option "m", return such PCRE as is.
#   if is_pcre_enabling_option "${pcre}" 'm' si {
#       return_string "${pcre}"
    # Else, return such PCRE prefixed with such option.
#   } else {
#       return_string "(?m)${pcre}"
#   }

    #FUXME: Stop this. It's simply not safe. In fact, it's blatantly stupid.
    # If the passed regex is not explicitly anchored to newlines with a "^"
    # prefix and "$" suffix, add such anchors.
#   is "${pcre[1]}"  == '^' si or pcre="^.*?${pcre}"
#   is "${pcre[-1]}" == '$' si or pcre="${pcre}.*?$"

    # Validate passed arguments, treating piped input as the passed string and
    # removing all arguments except for the list of PCRE options if passed.
#Such options include zero or more of the following:
#
#* `-i`, matching case-insensitively. By default, matches are case-sensitive.
#* `-m`, matching multiline-aware such that:
#** `^` matches either a newline or the string start. By default, `^` matches
#   only the string start.
#** `$` matches either a newline or the string end. By default, `$` matches only
#   the string end.
#* `-s`, permitting `.` to match all characters including newline. By default,
#  `.` matches all characters excluding newline.
#* `-x`, matching an extended PCRE ignoring whitespace and `#` comments. By
#  default, whitespace and `#` are significant and hence matched ``as is.''

#   if { is_args_0 } {
#       is "${text}" =~ "${pcre}" si | return_exit_status
    # Else, manually compile the passed PCRE with the passed PCRE options
    # and match with such compiled PCRE.
#   } else {
#       print "pcre_compile \"${pcre_options}\" -- \"${pcre}\""
#       pcre_compile "${@}" -- "${pcre}"
#       pcre_study
#       pcre_match -- "${text}" | return_exit_status

#       print_string "matched: ${match[@]}"
#Such globals are a proper subset of those that globs enabling globbing flags
#`(#b)` and `(#m)` set: . (Specifically, such globs also set

#Match globals accessible to such command include:
#   string_global_export ZPCRE_OP='0 0'
    # If the passed PCRE is empty, die. If the passed string is empty, noop.
#   is_string_empty "${text}" and return_true

#   integer match_count=0
#   is_stdin_piped and run_command_with_stdin_piped\
#       for_string_pcre_matches "${@}" '(( ++match_count ))' or
#       for_string_pcre_matches "${@}" '(( ++match_count ))'
#   print_string ${match_count}

#FUXME: Use in place of for_string_pcre_matches(), above.
#   string error_message='expected one string, one PCRE, and optional regex options'

    # If piped input, pipe such input to get_string_pcre_match_count().
#   if is_stdin_piped; then
#       die_unless_args "${error_message}"
#       string pcre; pcre="$(convert_string_to_pcre_multiline "${1}")"
#       shift_arg
#       run_command_with_stdin_piped get_string_pcre_match_count "${pcre}" "${@}" -m
    # Otherwise, call get_string_pcre_match_count() as expected.
#   else
#       die_unless_args_2_or_more "${error_message}"
#       string text="${1}" pcre; pcre="$(convert_string_to_pcre_multiline "${2}")"
#       shift_args_2
#       get_string_pcre_match_count "${text}" "${pcre}" "${@}" -m
#   fi

#FUXME: The order of arguments seems a bit... off. The command should be passed
#*LAST*, which reads much more intuitively, actually resembling a proper loop: e.g.,
#
#   for_string_pcre_matches "${text}" "${pcre}" "${@}" -m\
#       "output \"\${match[${group_index}]}\"; break"

#'expected non-empty regex'
#   string error_message='expected one command, one string, one PCRE, and optional regex options'
#   die_unless_args "${error_message}"
#   string command="${1}" text pcre
#   shift_arg
#   print_string "command: ${command}"

    # If passed piped input, such input is the string to be matched.
#   if is_stdin_piped; then
#       die_unless_args_1_to_2 "${error_message}"
#       set_string_to_stdin_piped text
#       pcre="${1}"
#       shift_arg
    # Otherwise, the second passed argument is the string to be matched.
#   else
#       die_unless_args_2_to_3 "${error_message}"
#       text="${1}"
#       pcre="${2}"
#       shift_args_2
#   fi
#   print_string_with_escapes "text: ${text}\npcre: ${pcre}"

    # If passed piped input, treat such input as the passed string.
#   if is_stdin_piped; then
#       set_string_to_stdin_piped text
#       pcre="${1}"
#       shift_arg
    # Otherwise, treat the first passed argument as the passed string.
#   else
#       text="${1}"
#       pcre="${2}"
#       shift_args_2
#   fi

        # Shift off the leading PCRE and iterate such matches.
        # Shift off the leading PCRE and iterate such matches.
# all arguments except for the list of PCRE options if passed.

    #FUXME: Throw an exception unless the passed PCRE contains a match group. We
    #probably want a new die_unless_pcre_containing_match_group() function.

# Groups matched by non-multiline PCREs cannot reliably be delimited by
# newlines, as matches may themselves contain newlines; so, no corresponding
# get_string_pcre_match() function exists. Instead, consider calling
# for_string_pcre_matches() for such logic.

# For efficiency, this function returns the first line returned by get_string_pcre_multiline_match()
# in an efficient manner (i.e., by immediately halting on such line).
#   list pcre_options; pcre_options=( "${@}" )
#   for_string_pcre_matches "output matches: \${match[@]}; break 2"\
#       "output \${match[${group_index}]}; break 2" "${text}" "${@}" -m
#   substring (e.g., "${match[1]}" expands to the first match group). As caveat,
#   note this *REQUIRES* embedding "(#b)" prior to such match groups in the
#   passed PCRE. For efficiency, this function does not embed "(#b)" by default.

#FUXME: Shift to "list".
#get_list_elements() {
#    die_unless_args 'expected at least one list index'
#
#    for index ("${@}") {
#    }
#}

#       '(( ${#match} )) and print_string ${match[@]} or print_string ${MATCH}'\

#FUXME: We really want to eliminate the *_multiline() functions. Nice idea, but
#there are simply too many useful permutations (e.g., multiline_caseless,
#multiline_extended). Rather, use a similar mechanism as the
#get_string_pcre_match_count() function whereby options are passed after all other
#parameters. (Somewhat awkward, but... *shrug*)

    # If piped input, convert such input to passed arguments.
#   if is_stdin_piped; then
#       die_unless_arg 'expected one PCRE and optional regex options'
#       set_args "$(get_stdin_piped)" "${@}"
#   fi

    # Localize passed arguments.
#   die_unless_args_2_or_more\
#       'expected one string, one PCRE, and optional regex options'
#   string text="${1}" pcre
#   pcre="$(convert_string_to_pcre_multiline "${2}")"
#   shift_args_2

    # Count.
#   get_string_pcre_match_count "${pcre}" "${@}" -m
# ....................{ MATCHES                            }....................
#FUXME: Good name; just a comment to myself: list_ is better than get_ here.
#Since we're matching on lines, we can safely return a newline-delimited string.
#That said, it's not terribly orthogonal; perhaps return_list(), instead?
#
#FUXME: Completely rewrite. First, note that I've already stored the current
#implementation of this function in the WASTELANDS. Second, stop accepting
#"match_variable_name" and "group_array_name"; instead, force use of $MATCH and
#$match. The alternative is simply unreadable, unmanageable, and exceptionally
#confusing when read as a function call. Third, shift to a function parameter
#style as in the above functions. This reduces the function to something very
#sensible. Oh, and support is_stdin_piped() and get_stdin_piped(), as above.

# void match_pcre(
#   string regular_expression, string text = null,
#   string match_variable_name = "MATCH", string group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints print_string in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}"
#     1
#match_pcre() {
    # Parse parameters.
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
#    string regex="${1}" text="${2}"\
#        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, zsh requires this regardless of whether we intend
    # to actually reuse this match.)
#    if is_variable 'ZESHY_MATCH_OPTIONS'; then
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
#        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
#            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
#    else
#        pcre_compile "${regex}" or
#            die "\"${regex}\" not a valid regular expression"
#    fi

    # Match.
#    pcre_match -v "${match_variable_name}" -a "${group_array_name}" -- "${text}"
#}

# void match_pcre_multiline(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) in a multi-line fashion (e.g., matching '^' and '$' at both newline and
# the beginning and end of the string, respectively). In all other respects,
# this function is identical to the match() function.
#match_pcre_multiline() {
#    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
#    match_pcre "${@}"
#}

# ....................{ MATCHES ~ by groups                }....................
# string match_pcre_first_group(...)
#
# Return the first group to successfully match in the passed string against the
# passed regex. If no group matched, fail. See match() comments for further
# details: e.g.,
#
#     >>> match_first_group '(\d)$' '1984'
#     4
#match_pcre_first_group() {
    # Match.
#    match_pcre "${@}"

    # If at least one group matched, return the first such group.
#    string group_array_name="${4:-match}"
#    is_variable "${group_array_name}" si and
#        print_string "${${(@P)group_array_name}[1]}"
#   is -n "${(@P)group_array_name}" si and print "${${(@P)group_array_name}[1]}"
#}

# void match_pcre_multiline_first_group(...)
#
# Return the first group to successfully match in the passed string against the
# passed regex, in a multi-line fashion (e.g., matching '^' and '$' at both
# newline and the beginning and end of the string). If no group matched, fail.
#
# This function is otherwise identical to the match_multiline() function.
#match_pcre_multiline_first_group() {
#    list ZESHY_MATCH_OPTIONS; ZESHY_MATCH_OPTIONS=( -m )
#    match_pcre_first_group "${@}"
#}

# ....................{ MATCHES ~ by lines                 }....................
# string match_pcre_first_line(...)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the first matched line, if at least one such line matched,
# or the empty string otherwise.
#
# In all other respects, this function is identical to the match() function.
# In particular, note groups may still be obtained via the "${match}" array.
#match_pcre_first_line() {
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'

    # Guarantee the passed regular expression roots itself to single rather than
    # multiple lines (i.e., begins with '^' and ends with '$').
#    string regex="${1}"
#    shift_arg

    # No, I don't know why the former requires a '.' while the latter does not.
    # I'm sure there's a highly rational reason within the musty bowels of ZSH.
#   print "regex: "${regex}
#    is "${regex}" == ^.* si or regex="^.*${regex}"
#    is "${regex}" == *$  si or regex="${regex}.*$"
#   print "regex: "${regex}

    # Pack this modified regular expression back into the array of all passed
    # arguments, for convenience.
#    set_args "${regex}" "${@}"

    # Match.
#    match_pcre_multiline "${@}"

    # Print the first matching line.
#    string match_string_name="${3:-MATCH}"
#    print_string "${(P)match_string_name}"
#}

# ....................{ SETTERS                            }....................
# int append_pcre_match_to(
#   list *matches_name,
#   string text, string pcre, string pcre_option1, string pcre_option2, ...)

# Append all match groups...
# Set the list with the passed name to .
# Get the number of substrings in the passed string matching the passed PCRE
# with the passed PCRE options: e.g.,
#
#     >>> list pcre_matches
#     >>> set_pcre_match_to pcre_matches 'Xanadu  # XaXaXaXaXaXa' '([Xn]a)' -x
#     >>> print ${pcre_matches[-1]}
#     na
#append_pcre_match_to() {
#    die_unless_args_2_or_more\
#        'expected one list name, one string, one PCRE, and optional regex options'
#    string matches_name="${1}"
#    die_unless_list "${matches_name}"

#    for_string_pcre_matches 'matches_name+=(( ${MATCH} ))' "${@}"
#   eval '${matches_name}=( )
#}

#get_string_pcre_matches_count_old() {
    # Localize passed arguments.
#    string text pcre
#    if is_stdin_piped; then
#        die_unless_args_1_to_2\
#            'expected one PCRE and optional regex options'
#        text="$(get_stdin_piped)"
#        pcre="${1}"
#        shift_arg
#    else
#        die_unless_args_2_to_3\
#            'expected one string, one PCRE, and optional regex options'
#        text="${1}"
#        pcre="${2}"
#        shift_args_2
#    fi
#    list pcre_options; pcre_options=( "${@}" )

    # If either the passed string or PCRE is empty, return 0.
#    { is_string_empty "${text}" or is_string_empty "${pcre}" } and print_string 0

    # Compile the passed PCRE for optimum matching with the passed options.
#    pcre_compile "${pcre_options[@]}" -- "${pcre}"
#    pcre_study

    # Count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while matching
    # until no matches remain yields the number of matches. Dismantled, this is:
    #
    # * "ZPCRE_OP='0 0'", initializing a zsh global tracking the first and last
    #   0-based byte indices of the currently matched substring in ${text}.
    # * "pcre_match", matching the next substring given:
    #   * "-b", tracking indices in the ${ZPCRE_OP} global.
    #   * "-n", starting matching at the passed string index:
    #     * "${ZPCRE_OP[(w)2]}", expanding to the byte immediately following the
    #       last byte index of the previously matched substring.
#    integer pcre_match_count=0
#    string_global_export ZPCRE_OP='0 0'
#    while pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"; do
#        (( ++pcre_match_count ))
#    done
#    print_string ${pcre_match_count}
#}

#FUXME: This shares nearly the same implementation as get_string_pcre_match().
#Clearly, what we need is a helper function passed the same arguments as this
#function with an additional first argument specifying the command to be
#evaluated in each "while" loop iteration. Say, run_command_on_pcre_match()?

    #FUXME: Hmm; we should probably anchor the passed PCRE with "^.*" and ".*$"
    #unless already beginning with "^" and ending with "$". Otherwise, we're not
    #actually matching within lines. Too much work, for the present.
    #FUXME: Silly. get_string_pcre_match_count() should be revised to accept piped
    #stdin, and this revised to pass_piped_stdin_to() and manual dying on args.
    # If the string was passed to this function from piped standard input, then
    # die_unless_args_2() erroneously reversed the argument order. Reverse it
    # back. Otherwise, we're good to go.
#   die_unless_args_2 'expected one string and one PCRE'
#   then get_string_pcre_match_count "${@[-1]}" "${@[1,-2]}" -m

# void match_pcre(
#   string regular_expression, string text = null,
#   string match_variable_name = "MATCH", string group_array_name = "match")
#
# Match the passed string or stdin if no such string is passed against the
# passed Perl-compatible regular expression (PCRE). This function returns
# failure if this string does not match and success otherwise, as well as
# setting match group-specific variables in the latter case:
#
# * The name of the scalar variable to which this function puts the whole match,
#   defaulting to the global variable "${MATCH}".
# * The name of the array variable to which this function puts all match groups,
#   defaulting to the global variable "${match}".
#
# This function never prints print_string in either case. Hence if you require the
# exact text matched, you must either access the above match group-specific
# variables or call a helper function defined by Zeshy Regex.
#
# This function also accepts a hidden "fifth parameter": the global variable
# "${ZESHY_MATCH_OPTIONS}", which when set causes this function to pass those
# options to the pcre_compile() built-in when compiling the passed pattern.
#
# For convenience, this function also accepts "stdin"-style piped input rather
# than an explicit passed string: e.g.,
#
#     >>> print 1776 | match '^\d'
#     >>> print "${MATCH}" 
#     1
#match_pcre() {
    # Parse parameters.
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
#    string regex="${1}" text="${2}"\
#        match_variable_name="${3:-MATCH}" group_array_name="${4:-match}"
#   print "pattern: "${(q)regex}" | string: ${string} | match_variable_name: ${match_variable_name} | group_array_name: ${group_array_name} "
#   print "mo: ${ZESHY_MATCH_OPTIONS[@]}"

    # Compile the match. (Yes, zsh requires this regardless of whether we intend
    # to actually reuse this match.)
#    if is_variable 'ZESHY_MATCH_OPTIONS'; then 
#       print "ZESHY_MATCH_OPTIONS: ${ZESHY_MATCH_OPTIONS}"
#       pcre_compile -m "${pattern}" ||
#        pcre_compile "${ZESHY_MATCH_OPTIONS[@]}" "${regex}" or
#            die "\"${regex}\" not a valid regular expression under match options \"${ZESHY_MATCH_OPTIONS[@]}\""
#    else
#        pcre_compile "${regex}" or
#            die "\"${regex}\" not a valid regular expression"
#    fi
    
    # Match.
#    pcre_match -v "${match_variable_name}" -a "${group_array_name}" -- "${text}"
#}

#FUXME: This is uniformly terrible, any way you dice it. Slice this apart.
# string get_enabling_multiline(...)
#
# Get all lines matching the passed regex. Unlike most Zeshy matching
# functions, this function uses "grep" rather than the "zsh/pcre" module as the
# latter provides no efficient means of obtaining non-overlapping matches.
#
# Unfortunately, this implies groups to be inaccessible.
#get_enabling_multiline() {
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
#   local regexp="${1}" string="${2}"
#    print_string "${2}" | grep --perl-regexp "${1}"
#}

#   print "arg1: ${1}\narg2: ${2}"

# int get_enabling_multiline_count(...)
#
# Return the number of lines matching the passed regex. See the
# get_enabling_multiline() function for caveats.
#get_enabling_multiline_count() {
#    die_unless_args_2_or_more\
#        'expected at least one regular expression and one string'
##    print_string "${2}" | grep --perl-regexp --count "${1}"
#}

#   pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"
#   print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#   pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}"
#   print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#       print "pmc: ${pcre_match_count}\nop: ${ZPCRE_OP[(w)2]}"
#   while (pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${text}") {
#       (( pcre_match_count++ ))
#   }
# int get_string_pcre_match_count(string pcre_options, string text, string pcre)
#   string error_message='expected optional options, one string, and one PCRE'
#   die_unless_args "${error_message}"
#   if si "${1[1]}" == '-' si; then
#       die_unless_args_3 "${error_message}"
#   else
#       die_unless_args_2 "${error_message}"
#   fi

#FUXME: This is horrible. IT'S ALL HORRIBLE! Use pure zsh expressions rather
#than this nonsense. There exists no guarantee that grep's "--perl-regexp" are
#anything like zsh's. The implementation should resemble that of
#get_match_count(). (Yes, I've searched for better ways. They don't exist.)
#
#That said; it'd be a shame to jettison this. Instead, just shift the existing
#function into Zeshy Grep, perhaps renamed to get_grep_match_count(...).

# See also the get_integer_of_glob_matches() function, which behaves similarly
# but less efficiently -- matching via multiple glob rather than one regular
# expression.

# --------------------( CONVENTIONS                        )--------------------
# All regular expressions matched by this component are Perl-compatible regular
# expressions (PCRE), unless otherwise stated. Thus, we abbreviate such regular
# expressions "regexes."
# 
# All functions defined by this component accept the same number and type of
# parameters as the core match() function, unless otherwise stated. Thus, we
# abbreviate such parameters "...". 
#
# ....................{ GROUPS ~ last                      }....................
#FUXME: Does this actually work? And even if it does, we really should be using
#the ZSH "pcre" facility to guarantee as-expected interpretation of the regex.
# string match_last_group(string regular_expression, string text)
#
# Match the passed string against the passed Perl-compatible regular expression
# (PCRE) and return the last matched group, if at least one such group matched.
#match_last_group() {
#    die_unless_args_2_or_more\
#        'expected exactly one regular expression and one string'
#        
#    # Parse parameters.
#    string regexp="${1}" string="${2}"
#
#    # Match. For simplicity, use "grep" rather than zsh's "pcre" module.
#    try "echo '${string}' | tac | grep --perl-regexp -m 1 '${regexp}'"
#}

    #FUXME: Uncommenting this causes *HORRIBLE, UTTERLY IMPOSSIBLE TO DEBUG*
    #issues. And it shouldn't. But there it is.
    # Localize the group array.
#   typeset -Ag ${group_array_name}

    # Retrieve the first group.
#   string first_group_name="${group_array_name}[1]"

    # If this match matched at least one group, return that. Otherwise, nil.
#   print "first_group_name: ${first_group_name}"
#   string first_group="${(P)first_group_name}"
#   print "first_group: ${first_group}"

    # If there exists at least one group, print the first and return success;
    # otherwise, print nothing and return failure.
#   is_string_nonempty "${first_group}" and print "${first_group}"

#   local regexp="${1}" string="${2}"
#   try "get_enabling_multiline '${@}' | get_string_line_count"
#   try "echo '${string}' | sed 's/${regex}/${regex}\n/g' | grep --perl-regexp --count '${regex}'"
#   return
#       die "\"${string}\" not matched by regular expression \"${regex}\""
    # If the passed regex contains no groups, embed that regex in a group
    # matching the entire prior regex.
#   [[ "${1}" == *\(*\)* ]] || set -- "(${regex})" "${@}"

    # Match.
#   match "${@}" || return ${?}
#   echo "${#match}"

    # Print the number of matches.
#   local group_array_name="${4:-match}"
#   print "${(P)#group_array_name}"
