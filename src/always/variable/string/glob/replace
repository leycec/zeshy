#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *glob replacers* (i.e., functions replacing substrings matching globs).
-/-

# ....................{ REPLACERS                          }....................
#FIXME: It's unclear just how to extend this function to a new function
#supporting expansions depending on the passed glob: e.g., "${match[1]}".
#Does parameter expansion prefix "~" suffice or do we need a genuine "eval"
#statement? I suspect the latter, in which case such function should be
#named replace_string_matches_with_evaluation(), but investigate.

declare_function_with_stdin <<'/---'
<globbable> string replace_string_matches_glob_with_string(
    string text, string glob, string replacement)

Get the passed string, with all substrings matching the passed glob replaced by
the passed replacement substring: e.g.,

.replace_string_matches_glob_with_string()
==========================================
[source]
------------------------------------------
>>> string on_social_sins=\
...    "Seven social sins: politics without principles, wealth without work,
...     pleasure without conscience, knowledge without character, commerce
...     without morality, science without humanity, and worship without
...     sacrifice."
>>> replace_string_matches_glob_with_string\
...     "${on_social_sins}" w[^ ]t([[:space:]]) 'sans${MATCH[1]}'
Seven social sins: politics sans principles, wealth sans work,
pleasure sans conscience, knowledge sans character, commerce
sans morality, science sans humanity, and worship sans
sacrifice.
------------------------------------------
==========================================
/---
function replace_string_matches_glob_with_string() {
    die_unless_args_3 'expected one string, one glob, and one replacement'
    return_string "${1//${~2}/${3}}"
}

declare_function_with_stdin <<'/---'
string replace_string_boxing_with_spaces(string text1, string text2, ...)

Replace all *boxing* (i.e., substrings consisting of a newline followed by zero
or more horizontal whitespace characters) in the passed string with single
spaces. This function enables other functions (e.g., print_message_unboxed()) to
accept human-readable string arguments internally split with newlines and
indentation, internally converted to machine-readable `zsh` format by reducing
such newlines and indentation to single spaces: e.g.,

.replace_string_boxing_with_spaces()
==========================================
[source]
------------------------------------------
>>> string on_separation=\
...    "Men often hate each other because they fear each other; they fear each
...     other because they don't know each other; they don't know each other
...     because they cannot communicate; they cannot communicate because they
...     are separated."
>>> replace_string_boxing_with_spaces "${on_separation}"
Men often hate each other because they fear each other; they fear each other because they don't know each other; they don't know each other because they cannot communicate; they cannot communicate because they are separated.
------------------------------------------
==========================================
/---
function replace_string_boxing_with_spaces() {
    die_unless_args 'expected at least one string'
    replace_string_matches_glob_with_string "${*}"\
        "${ZESHY_ASCII_NEWLINE}[[:blank:]]#" ' '
}

# --------------------( WASTELANDS                         )--------------------
