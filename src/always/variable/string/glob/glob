#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle zsh extended glob expressions.
#
# --------------------( SEE ALSO                           )--------------------
# Section "FILENAME GENERATION" of "man zshexpn"
#     Extended glob syntax official reference.
#
# --------------------( TODO                               )--------------------
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

#FIXME: Ah-ha! While the current approach of single-quoting passed globs
#certainly works, wouldn't it be preferable if we could just pass globs as is
#(i.e., unquoted)? Turns out, we can! At least, I *THINK* we can. It requires
#testing, but "man zshmisc" suggests that prefixing each call to a function
#accepting such globs with "noglob " disables implicit filename globbing of
#shell words and hence permits passing unquoted globs. (This must be how the
#canonical catch() function works...) Naturally, writing "noglob " everywhere
#would be silly -- so we implement the same clever hack catch() implements.
#Namely, we alias the same name to expand to itself prefixed by "noglob ": e.g.,
#
#    alias is_string_matches='noglob is_string_matches'
#
#And we should be good to go. Thanks to digest magic, just add each such alias
#*IMMEDIATELY BEFORE THE FUNCTION IT EXPANDS*, below. This will help us to
#maintain all of this abominable machinery, which I must say... ROCKS!

#FIXME: Hmm. Niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiice. It turns out it *IS*
#possible to match globs iteratively in a manner similar to that of regular
#expressions. Should be fairly efficient, as well. First, note that parameter
#expansion "${string//(#m)${~glob}/${MATCH}}" is a noop iteratively replacing
#all substrings matching glob ${glob} with themselves. That isn't terribly
#useful, but note that this is generalizable into a similar parameter
#expansion "${string//(#m)${~glob}/$(run_command_on_match "${command}" "${MATCH}"; print_string "${MATCH}")}". Now *THIS* is clever. Unsure why I didn't think of it earlier,
#honestly. For each match, pass such match to helper function
#run_command_on_match() evaluating the passed "${command}", presumably passed
#the current match with standard output and error redirected to the bit bucket
#(to avoid mucking up the current match). Then, assuming such evaluation does
#not throw an exception, print such match, thus avoiding changing such string.
#Ah! Note that if we run the simpler parameter expansion
#"noop ${string//(#m)${~glob}/$(run_command_on_match "${command}" "${MATCH}")}",
#we achieve the same effect! No need to worry about whether or not we replace
#matched substrings, since we don't bother assigning the resulting string. Nice.
#In fact, it might even (slightly) improve efficiency to just replace all
#matches with the empty string (e.g., ";print;"), resulting in a smaller
#temporary string to be retained in-memory.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> [status: boolean] is_string_matches(string text, string glob)

Return true if the passed string matches the passed glob: e.g.,

.is_string_matches()
==========================================
[source]
------------------------------------------
>>> is_string_matches "youshima" [fuk]ushima or print_string "dai-ichi"
dai-ichi
------------------------------------------
==========================================
________________<heredoc?>________________
function is_string_matches() {
    die_unless_args_2 'expected one string and one glob'
    is "${1}" == ${~2} si
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> [status: boolean] is_string_matches_capturing_groups(
    string text, string glob)

Return true and set match groups if the passed string matches the passed glob.
In such case, access such groups after calling this function with the following
list globals:

* `${match}`, each element the substring captured by the match group with the
  same list index or the empty string if no such substring was captured (e.g.,
  `${match[1]}`, the substring captured by the first match group).
* `${mbegin}`, each element the index of the passed string at which the
  substring captured by the match group with the same list index begins (e.g.,
  `${mbegin[1]}`, the string index at which the first match group begins).
* `${mend}`, each element the index of the passed string at which the substring
  captured by the match group with the same list index ends (e.g., `${mend[1]}`,
  the string index at which the first match group ends).

If capturing only one such group, consider calling
get_string_match_group_if_matched() instead: e.g.,

.is_string_matches_capturing_groups()
==========================================
[source]
------------------------------------------
>>> is_string_matches_capturing_groups "hiroshima" (???)oshima
>>> print_string "${match[1]}"
hir
>>> get_string_match_group_if_matched        "hiroshima" (???)oshima
hir
------------------------------------------
==========================================
________________<heredoc?>________________
function is_string_matches_capturing_groups() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(convert_string_to_glob_capturing_groups "${2}")"

    # Test such match. Avoid quoting such glob.
    is "${text}" == ${~glob} si
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_string_contains_glob_characters(string text)

Return true if the passed string contains a glob-reserved character, effectively
including most ASCII punctuation (e.g., `[`, `<`, `(`, `|`, `+`, `*`, `?`, `#`).
________________<heredoc?>________________
function is_string_contains_glob_characters() {
    die_unless_arg 'expected one string'
    is_string_matches "${1}" *[\[\]\<\>\(\)\|+*?#~^]*
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> integer get_string_matches_count(string text, string glob)

Get the number of matches in the passed string of the passed glob: e.g.,

.get_string_matches_count()
==========================================
[source]
------------------------------------------
>>> get_string_matches_count "bosozoku" [bsz]o
3
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_matches_count() {
    # Validate passed arguments
    die_unless_args_2\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}"

    # If either such string or glob is empty, there can be no possible matches.
    if is -z "${text}" or -z "${glob}" si {
        return_string 0
    # If such glob contains no glob-reserved characters, such glob is a string
    # literal. Get the number of instances of such literal in such string.
    } elif { not is_string_contains_glob_characters "${glob}" } {
        return_string "$(get_string_substrings_count "${text}" "${glob}")"
    # Else, count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
    } else {
        integer match_count=-1
        string text_old

        # For efficiency, avoid calling is_string_equals().
        until { is "${text_old}" == "${text}" si } {
            (( ++match_count ))
            text_old="${text}"
            text="${text/${~glob}/}"
        }

        return_string ${match_count}
    }
}

# ....................{ GETTERS ~ group                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string get_string_match_group(
    string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or throw an exception if such string fails to match: e.g.,

.get_string_match_group()
==========================================
[source]
------------------------------------------
>>> get_string_match_group "Escape from the zombie food court" *(z[^ ]##)*
zombie
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_match_group() {
    get_string_match_group_if_matched "${@}" or
        die "\"${text}\" not matched by glob \"${glob}\""
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> [stdout: string, status: boolean] get_string_match_group_if_matched(
    string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or return false if such string fails to match: e.g.,

.get_string_match_group_if_matched()
==========================================
[source]
------------------------------------------
>>> get_string_match_group_if_matched "Hologram" *(o?)(o?)(o?)* 2 or
...     print_string "Meat space versus the parallel universe"
Meat space versus the parallel universe
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_match_group_if_matched() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional group index'
    string text="${1}" glob group_index="${3:-1}"
    die_unless_integer_positive "${group_index}"
    glob="$(convert_string_to_glob_capturing_groups "${2}")"

    # If such string matches, return such group. Avoid double-quoting such glob.
    if is "${text}" == ${~glob} si {
        return_string "${match[${group_index}]}"
    # Else, return failure.
    } else {
        return_false
    }
}

# ....................{ CONVERTERS                         }....................
#FIXME: This isn't right *AT ALL*. I do believe it's feasible, but it will
#require considerably more effort than we've gone to here. Do *NOT* replace "*"
#characters if prefixed by "\", if embedded in a character class "[...]" (which
#itself is non-trivial to match, if one considers it), or if embedded in a
#single- or double-quoted string. Hence, this requires an at least ad-hoc
#parsing effort. *sigh*
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string convert_string_to_glob_matching_lines(string glob)

Convert the passed glob to a multiline glob (i.e., such that `(#s)` and `(#e)`
also match newlines). While PCREs support multiline matching with option `-m`,
globs currently lack such support. Hence, this function is somewhat of a fragile
hack. Until such support improves, consider multiline PCREs instead.
________________<heredoc?>________________
function convert_string_to_glob_matching_lines() {
    # Validate passed arguments.
    die_unless_arg 'expected one glob'
    string glob="${1}"

    # Replace all instances of "*" with "[^$'\n']#", thus terminating line
    # matching on the first newline.
    glob="${glob//\*/[^${ZESHY_ASCII_NEWLINE}]#}"
#   glob="${glob//\*/[^$'\n']#}"

    # Prefix such glob with an expression either matching at the start of the
    # string or the first newline preceding such match.
    glob="((#s)|*${ZESHY_ASCII_NEWLINE})${glob}*"
#   glob="((#s)|*$'\n')${glob}*"

    # Return such glob.
    return_string "${glob}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string convert_string_to_glob_capturing_groups(string glob)

Convert the passed glob to a glob setting match groups, if not already doing so.
When successfully matching, such glob sets list globals `${match}`, `${mbegin}`,
and `${mend}` containing matched groups. See is_string_matches_capturing_groups()
for further details.
________________<heredoc?>________________
function convert_string_to_glob_capturing_groups() {
    # Validate passed arguments.
    die_unless_arg 'expected one glob'
    string glob="${1}"

    # If such glob does not contain glob flag "(#b)" enabling match groups,
    # prefix such glob with "(#b)" to do so.
    is_string_contains "${glob}" (#b) or glob="(#b)${glob}"

    # Return such glob.
    return_string "${glob}"
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string remove_string_matches(string text, string glob)

Remove all substrings from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_matches()
==========================================
[source]
------------------------------------------
>>> remove_string_matches "rear_window" r??
indow
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_matches() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1//${~2}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string remove_string_match_if_prefix(string text, string glob)

Remove the longest prefix from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_match_if_prefix()
==========================================
[source]
------------------------------------------
>>> remove_string_match_if_prefix "north by northwest" *n{o,d}?th
west
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_match_if_prefix() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1##${~2}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string remove_string_match_if_suffix(string text, string glob)

Remove the longest suffix from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_match_if_suffix()
==========================================
[source]
------------------------------------------
>>> remove_string_match_if_suffix "dial.m.for.murder" .m?????*
dial.
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_match_if_suffix() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1%%${~2}}"
}

# ....................{ REPLACERS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string replace_string_matches_with_string(
    string text, string glob, string replacement)

Replace all substrings from the passed string matching the passed glob with the
passed replacement string: e.g.,

.replace_string_matches_with_string()
==========================================
[source]
------------------------------------------
>>> replace_string_matches_with_string "Waterloo and Recovered" ?r "ur"
Waturloo and Recovured
------------------------------------------
==========================================
________________<heredoc?>________________
function replace_string_matches_with_string() {
    #FIXME: It's unclear just how to extend this function to a new function
    #supporting expansions depending on the passed glob: e.g., "${match[1]}".
    #Does parameter expansion prefix "~" suffice or do we need a genuine "eval"
    #statement? I suspect the latter, in which case such function should be
    #named replace_string_matches_with_evaluation(), but investigate.

    die_unless_args_3 'expected one string, one glob, and one replacement'
    return_string "${1//${~2}/${3}}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to convert_string_to_glob_matching_lines(), in keeping with
#convert_string_to_pcre_matching_lines() nomenclature.
#FUXME: Rename to convert_string_to_glob_capturing_groups() or
#convert_string_to_glob_matching_groups(). Hmmm; the former's a bit more verbose
#but much more explanatory and hence preferable. I mean, every glob "matches
#groups" already, so the latter conveys no meaningful information.
    #FUXME: Extract into a new get_string_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_substrings_count "${text}" "${glob}")"
#       string text_matches_deleted="${text//${glob}/}"
#       return_string $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))

# (i.e., saving `(` and
#`)`-delimited match groups in global list ${match})
#   if is "${text}" == ${~glob} si
#FUXME: Rename to get_string_match_group(). The current function name is
#exceptionally ambiguous; after all, there could be multiple means of specifying
#which match to retrieve, of which group indices are merely the most obvious.
    #FUXME: Verify whether this suffices for instances of "${match[1]}" and so
    #forth in the replacement. I strongly suspect not (...in fact, let us say,
    #obviously not), in which case we require a separate
    #replace_string_match_with_evaluation() function.
#FUXME: I've never enjoyed pretending such functions to be getters. Rename to
#convert_string_to_glob_capturing_groups().
#FUXME: Rename to convert_string_to_glob_matching_lines()... or perhaps simply
#convert_string_to_glob_matching_lines(). Yes! The latter. Perfect.
# Such strings must be quote protected to be matched as specified when globbing.
#FUXME: No longer convinced this function is a good idea. The principle issue is
#quoting, which plays poorly with and in any case obstructs construction of
#string globs. Excise this function.

#FUXME: This needs a rename. It can currently be read in two very different
#ways, and the expected reading is *NOT* the actual reading. How about
#is_string_matches_with_capturing_groups() or
#is_string_matches_capturing_groups()? I prefer the former, I reckon. The added
#"_with" makes all the difference for readability here.
#FUXME: Rename to enable_glob_group_capturing()?
#FUXME: Rename to enable_glob_line_matching()?
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.

    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FUXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
