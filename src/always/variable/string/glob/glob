#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle `zsh`-specific extended glob expressions.

== See Also ==

* Section "FILENAME GENERATION" of `man zshexpn`, documenting glob syntax.
-/-

#FIXME: Also, note that glob expressions *CAN* match at the beginning and end of
#strings: flags "s" and "e" in the same section as above. Between this and
#backreferencing, I believe we've largely obsoleted our need for regular
#expression matching in the Zeshy codebase and should probably substitute all
#such matching with more efficient and certainly elegant glob matching.

#FIXME: O.K.; the current nomenclature of prefixing only PCRE matching functions
#is no longer tenable. Why? For one, it's unclear which actually *IS* more
#efficient. In some cases, the PCRE version is clearly more efficient (e.g.,
#for_string_pcre_matches(), which unlike for_string_glob_matches() does *NOT* fork a
#subshell for each match). We need to manually suffix all of the below with
#"_glob". I know; I know. But it just needs to be done.

#FIXME: Ah-ha! While the current approach of single-quoting passed globs
#certainly works, wouldn't it be preferable if we could just pass globs as is
#(i.e., unquoted)? Turns out, we can! At least, I *THINK* we can. It requires
#testing, but "man zshmisc" suggests that prefixing each call to a function
#accepting such globs with "noglob " disables implicit filename globbing of
#shell words and hence permits passing unquoted globs. (This must be how the
#canonical catch() function works...) Naturally, writing "noglob " everywhere
#would be silly -- so we implement the same clever hack catch() implements.
#Namely, we alias the same name to expand to itself prefixed by "noglob ": e.g.,
#
#    alias is_string_glob_matches='noglob is_string_glob_matches'
#
#And we should be good to go. Thanks to digest magic, just add each such alias
#*IMMEDIATELY BEFORE THE FUNCTION IT EXPANDS*, below. This will help us to
#maintain all of this abominable machinery, which I must say... ROCKS!

# ....................{ GLOBALS                            }....................
#FIXME: Replace current magic strings with these everywhere.
declare_global_with_stdin string ZESHY_GLOB_CAPTURE_MATCH='(#m)' <<'/---'
Globbing flag capturing the current match into string global ${MATCH}.
/---

declare_global_with_stdin string ZESHY_GLOB_CAPTURE_GROUPS='(#b)' <<'/---'
Globbing flag capturing each subsequent parenthesised group into the
corresponding element of list global ${match}.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
<globbable> void die_unless_string_glob_matches(
    string text,
    string glob,
    string error_message =
        "string \"${text}\" not matched by glob \"${glob}\"")

Throw an exception with the passed message unless the passed string matches the
passed glob. See is_string_glob_matches() for further details.
/---
function die_unless_string_glob_matches() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional error message'
    string text="${1}" glob="${2}"
#   output_string $'\n'"glob: ${glob}"

    # Test such match.
    is_string_glob_matches "${text}" "${glob}" or
        die "${3:-string \"${text}\" not matched by glob \"${glob}\"}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_string_glob_matches(string text, string glob)

Return success if the passed string matches the passed glob and, in such case,
set match globals ${MATCH}, ${MBEGIN}, and ${MEND} but _not_ necessarily
${match}, ${mbegin}, or ${mend}; the latter (slightly) reduce match efficiency.
Consider calling is_string_glob_matches_capturing_groups() or prefix such glob
with `(#b)` to set all such globals: e.g.,

.is_string_glob_matches()
==========================================
[source]
------------------------------------------
>>> string on_law; on_law=\
...    "If you reason instead of repeating what is taught you; if you analyze
...     the law and strip off those cloudy fictions with which it has been
...     draped in order to conceal its real origin, which is the right of the
...     stronger, and its substance, which has ever been the consecration of
...     all the tyrannies handed down to mankind through its long and bloody
...     history; when you have comprehended this, your contempt for the law will
...     be profound indeed. You will understand that to remain the servant of
...     the written law is to place yourself every day in opposition to the law
...     of conscience, and to make a bargain on the wrong side; and, since this
...     struggle cannot go on forever, you will either silence your conscience
...     and become a scoundrel, or you will break with tradition, and you will
...     work with us for the utter destruction of all this injustice, economic,
...     social and political."
>>> is_string_glob_matches "${on_law}" ut(#c2,)?r*d?str?ct??n and print_string\
...    "Men lived thousands of years before the first States were constituted."
Men lived thousands of years before the first States were constituted.
------------------------------------------
==========================================
/---
function is_string_glob_matches() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(convert_string_to_glob_capturing_substrings "${2}")"
#   output_string "glob: ${glob}"

    # Test such match. Avoid quoting such glob.
    is "${text}" == ${~glob} si
}

declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_string_glob_matches_capturing_groups(
    string text, string glob)

Return success if the passed string matches the passed glob and, in such case,
set match globals ${MATCH}, ${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and
${mend}. If capturing only one match group, consider calling
get_string_match_group_first() or
get_string_match_group_first_if_matched() instead. See
convert_string_to_glob_capturing_groups_and_substrings() for further details:
e.g.,

.is_string_glob_matches_capturing_groups() vs. get_string_match_group_*if_matched()
==========================================
[source]
------------------------------------------
>>> is_string_glob_matches_capturing_groups "hiroshima" (???)oshima
>>> print_string "${match[1]}"
hir
>>> get_string_match_group_first_if_matched "hiroshima" (???)oshima
hir
>>> get_string_glob_match_index_if_matched  "hiroshima" (???)oshima 1
hir
------------------------------------------
==========================================
/---
function is_string_glob_matches_capturing_groups() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(convert_string_to_glob_capturing_groups_and_substrings "${2}")"

    # Test such match. Avoid quoting such glob.
    is "${text}" == ${~glob} si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> integer get_string_glob_match_count(string text, string glob)

Get the number of substrings in the passed string matching the passed glob: e.g.,

.get_string_glob_match_count()
==========================================
[source]
------------------------------------------
>>> get_string_glob_match_count "bosozoku" [bsz]o
3
------------------------------------------
==========================================
/---
function get_string_glob_match_count() {
    integer match_count=0
    for_string_glob_matches "${@}" '(( ++match_count ))'
    return_string ${match_count}
}

# ....................{ GETTERS ~ group                    }....................
declare_function_with_stdin <<'/---'
<globbable> string get_string_glob_match_index(
    string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or throw an exception if such string fails to match: e.g.,

.get_string_glob_match_index()
==========================================
[source]
------------------------------------------
>>> get_string_glob_match_index "Escape from the zombie food court" *(z[^ ]##)*
zombie
------------------------------------------
==========================================
/---
function get_string_glob_match_index() {
    get_string_glob_match_index_if_matched "${@}" or {
        string text="${1}" glob="${2}"
        die "\"${text}\" not matched by glob \"${glob}\""
    }
}

#FIXME: Rename to get_string_glob_match_index_if_found().
declare_function_with_stdin <<'/---'
<globbable> [stdout: string, status: boolean]
    get_string_glob_match_index_if_matched(
        string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or return false if such string fails to match: e.g.,

.get_string_glob_match_index_if_matched()
==========================================
[source]
------------------------------------------
>>> get_string_glob_match_index_if_matched "Hologram" *(o?)(o?)(o?)* 2 or
...     print_string "Meat space versus the parallel universe"
Meat space versus the parallel universe
------------------------------------------
==========================================
/---
function get_string_glob_match_index_if_matched() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional group index'
    string text="${1}" glob group_index="${3:-1}"
    die_unless_integer_positive "${group_index}"
    glob="$(convert_string_to_glob_capturing_groups_and_substrings "${2}")"

    # If such string matches, return such group. Avoid double-quoting such glob.
    if is "${text}" == ${~glob} si {
        return_string "${match[${group_index}]}"
    # Else, return failure.
    } else {
        return_false
    }
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_substrings(string glob)

Convert the passed glob to capture matched substrings, if not already doing so.
On each successful match, such glob sets the following canonical globals:

* ${MATCH}, a string global expanding to the currently matched substring.
* ${MBEGIN}, an integer global expanding to the 1-based index of the matched
  string at which such substring starts.
* ${MEND}, an integer global expanding to the 1-based index of the matched
  string at which such substring ends.

Specifically, this function prefixes the passed glob with globbing flag `(#m)`
if such glob does not already contain such flag.
/---
function convert_string_to_glob_capturing_substrings() {
    # If such glob already contains "(#m)", prefixing yet another does no harm.
    die_unless_arg 'expected one glob'
    return_string "${ZESHY_GLOB_CAPTURE_MATCH}${1}"
}

declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_groups(string glob)

Convert the passed glob to capture match groups, if not already doing so. On
each successful match, such glob sets the following canonical globals:

* ${match}, a list global containing each match group captured within such
  substring (e.g., `${match[1]}`, the first match group).
* ${mbegin}, a list global containing each 1-based index of the matched string
  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
  at which the first match group starts).
* ${mend}, a list global containing each 1-based index of the matched string
  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
  at which the first match group ends).

Specifically, this function prefixes the passed glob with globbing flag `(#b)`
if such glob does not already contain such flag.
/---
function convert_string_to_glob_capturing_groups() {
    # Validate passed arguments.
    die_unless_arg 'expected one glob'
    string glob="${1}"

    # If such glob does *NOT* already enable globbing flag "(#b)", prefix such
    # glob with such flag. Such logic contrasts with that of
    # convert_string_to_glob_capturing_substrings(), which always prefixes its
    # glob with flag "(#m)". While the position of "(#m)" within a glob is
    # irrelevant, the position of "(#b)" within a glob is relevant and hence
    # must not be changed if already present.
    if is "${glob}" != *"${ZESHY_GLOB_CAPTURE_GROUPS}"* si {
        return_string   "${ZESHY_GLOB_CAPTURE_GROUPS}${glob}"
    # Else, do not.
    } else {
        return_string "${glob}"
    }
}

declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_groups_and_substrings(
    string glob)

Convert the passed glob to capture match groups _and_ matched substrings, if not
already doing so. On each successful match, such glob sets the following
canonical globals:

* All list globals set by convert_string_to_glob_capturing_groups() (i.e.,
  ${match}, ${mbegin}, and ${mend}). See such function for further details.
* All string globals set by convert_string_to_glob_capturing_substrings() (i.e.,
  ${MATCH}, ${MBEGIN}, and ${MEND}). See such function for further details.

Specifically, this function prefixes the passed glob with globbing flags
`(#b)(#m)` if such glob does not already contain such flags. According to `zsh`
documentation:

[quote, `man zshexpn`]
____________________________________________________________________
Unlike backreferences _(i.e., match groups)_, there is no speed penalty for
using match references _(i.e., matched substrings)_.
____________________________________________________________________

Hence, if capturing match groups, it costs us nothing and conceivably gains us
something to also capture matched substrings.
/---
function convert_string_to_glob_capturing_groups_and_substrings() {
    # Validate passed arguments. For efficiency, inline the call to
    # convert_string_to_glob_capturing_substring().
    die_unless_arg 'expected one glob'
    convert_string_to_glob_capturing_groups "${ZESHY_GLOB_CAPTURE_MATCH}${1}"
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
<globbable> string remove_string_glob_matches(string text, string glob)

Remove all substrings from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_glob_matches()
==========================================
[source]
------------------------------------------
>>> remove_string_glob_matches "rear_window" r??
indow
------------------------------------------
==========================================
/---
function remove_string_glob_matches() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1//${~2}}"
}

declare_function_with_stdin <<'/---'
<globbable> string remove_string_prefix_glob_match(string text, string glob)

Remove the longest prefix from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_prefix_glob_match()
==========================================
[source]
------------------------------------------
>>> remove_string_prefix_glob_match "north by northwest" *n{o,d}?th
west
------------------------------------------
==========================================
/---
function remove_string_prefix_glob_match() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1##${~2}}"
}

declare_function_with_stdin <<'/---'
<globbable> string remove_string_suffix_glob_match(string text, string glob)

Remove the longest suffix from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_suffix_glob_match()
==========================================
[source]
------------------------------------------
>>> remove_string_suffix_glob_match "dial.m.for.murder" .m?????*
dial.
------------------------------------------
==========================================
/---
function remove_string_suffix_glob_match() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1%%${~2}}"
}

# ....................{ REPLACERS                          }....................
declare_function_with_stdin <<'/---'
<globbable> string replace_string_glob_matches_with_string(
    string text, string glob, string replacement)

Replace all substrings from the passed string matching the passed glob with the
passed replacement string: e.g.,

.replace_string_glob_matches_with_string()
==========================================
[source]
------------------------------------------
>>> string secret_word="Waterloo and Recovered Christendom!"
>>> replace_string_glob_matches_with_string "${secret_word}" ?r "ur"
Waturloo and Recovured Christendom!
------------------------------------------
==========================================
/---
function replace_string_glob_matches_with_string() {
    #FIXME: It's unclear just how to extend this function to a new function
    #supporting expansions depending on the passed glob: e.g., "${match[1]}".
    #Does parameter expansion prefix "~" suffice or do we need a genuine "eval"
    #statement? I suspect the latter, in which case such function should be
    #named replace_string_matches_with_evaluation(), but investigate.

    die_unless_args_3 'expected one string, one glob, and one replacement'
    return_string "${1//${~2}/${3}}"
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'/---'
<globbable> string for_string_glob_matches(
    string text, string glob, string command)

Run the passed command for each substring of the passed string matching the
passed glob, capturing such substring into local string variable ${MATCH} and
such substring's start and end index in such string into local integer variables
${MBEGIN} and ${MEND}.

This function does _not_ implicitly capture parenthetical groups in such glob
into local list variable ${match} _or_ such groups' start and end indices in
such string into local list variables ${mbegin} and ${mend}, as such capturing
slightly reduces match efficiency. To capture groups, either call
for_string_glob_matches_capturing_groups() or explicitly prefix the first group
to be captured from such glob with `(#b)`: e.g.,

.for_string_glob_matches()
==========================================
[source]
------------------------------------------
>>> string on_proprietary_software="
...     I could have made money this way and perhaps amused myself writing code.
...     But I knew that at the end of my career, I would look back on years of
...     building walls to divide people, and feel I had spent my life making the
...     world a worse place."
>>> for_string_glob_matches "${on_proprietary_software}"\
...     I\ (#b)([[:WORD:]]##) 'output_string "${MATCH}" ("${match[1]}")'
I could (could)
I knew (knew)
I would (would)
I had (had)
------------------------------------------
==========================================
/---
function for_string_glob_matches() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize changes to this function to those below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_3 'expected one string, one glob, and one command'
    string text__fsgm="${1}" glob__fsgm="${2}" command__fsgm="${3}"
    die_unless_string_nonempty "${glob__fsgm}" 'expected non-empty glob'
    glob__fsgm="$(convert_string_to_glob_capturing_substrings "${glob__fsgm}")"

    # Localize string and list match globals, in case such glob enables "(#b)".
    string MATCH MBEGIN MEND
    list   match mbegin mend

    # Iterate such matches. While zsh provides no explicit mechanism for doing
    # so, cleverly misusing parameter expansion replacement suffices to do so.
    # Dismantled, this is:
    #
    # * "noop", discarding the result of such replacement.
    # * "//.../...", replacing each substring matching such glob with the output
    #   of running such command. By discarding such output, this has the effect
    #   of running such command for each such match. Great, and very efficient!
    eval "noop \"\${text__fsgm//\${~glob__fsgm}/\$(${command__fsgm})}\""
}

declare_function_with_stdin <<'/---'
<globbable> string for_string_glob_matches_nongreedy(
    string text, string glob, string command)

Run the passed command for each substring of the passed string matching the
passed glob *non-greedily* (i.e., matching shortest rather than longest possible
substrings), capturing such substring into local string variable ${MATCH} and
such substring's start and end index in such string into local integer variables
${MBEGIN} and ${MEND}. Specifically, coerce glob quantifiers `*`, `#`, and `##`
to match non-greedily. See for_string_glob_matches() for further details.
/---
function for_string_glob_matches_nongreedy() {
    # Specifying parameter expansion flag "(S)" enables non-greedy matching.
    # Sadly, this requires reimplementing for_string_glob_matches().
    die_unless_args_3 'expected one string, one glob, and one command'
    string text__fsgmn="${1}" glob__fsgmn="${2}" command__fsgmn="${3}"
    die_unless_string_nonempty "${glob__fsgmn}" 'expected non-empty glob'
    glob="$(convert_string_to_glob_capturing_substrings "${glob__fsgmn}")"
    string MATCH MBEGIN MEND
    list   match mbegin mend
    eval "noop \"\${(S)text__fsgmn//\${~glob__fsgmn}/\$(${command__fsgmn})}\""
}

# ....................{ ITERATORS ~ group                  }....................
declare_function_with_stdin <<'/---'
<globbable> string for_string_glob_matches_capturing_groups(
    string text, string glob, string command)

Run the passed command for each substring of the passed string matching the
passed glob. This function provides such command access to match globals
${MATCH}, ${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and ${mend} by prefixing such
glob with `(#m)(#b)` if not already. See for_string_glob_matches() for further
details.
/---
function for_string_glob_matches_capturing_groups() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize changes to this function to those below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_3 'expected one string, one glob, and one command'
    string text__fsgmcg="${1}" glob__fsgmcg="${2}" command__fsgmcg="${3}"
    die_unless_string_nonempty "${glob__fsgmcg}" 'expected non-empty glob'

    # Localize string and list match globals, in case such glob enables "(#b)".
    string MATCH MBEGIN MEND
    list   match mbegin mend

    # Iterate such matches.
    for_string_glob_matches\
        "${text__fsgmcg}"\
        "$(convert_string_to_glob_capturing_groups_and_substrings\
            "${glob__fsgmcg}")"\
        "${command__fsgmcg}"
}

declare_function_with_stdin <<'/---'
<globbable> string for_string_glob_matches_nongreedy_capturing_groups(
    string text, string glob, string command)

Run the passed command for each substring of the passed string matching the
passed glob non-greedily. This function provides such command access to match
globals ${MATCH}, ${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and ${mend} by
prefixing such glob with `(#m)(#b)` if not already. See for_string_glob_matches() and
for_string_glob_matches_nongreedy() for further details.
/---
function for_string_glob_matches_nongreedy_capturing_groups() {
    die_unless_args_3 'expected one string, one glob, and one command'
    string text__fsgmncg="${1}" glob__fsgmncg="${2}" command__fsgmncg="${3}"
    die_unless_string_nonempty "${glob__fsgmncg}" 'expected non-empty glob'
    string MATCH MBEGIN MEND
    list   match mbegin mend
    for_string_glob_matches_nongreedy\
        "${text__fsgmncg}"\
        "$(convert_string_to_glob_capturing_groups_and_substrings\
            "${glob__fsgmncg}")"\
        "${command__fsgmncg}"
}

# --------------------( WASTELANDS                         )--------------------
#slightly reduces match efficiency
#This function does _not_ necessarily provide such command access to
#${match}, ${mbegin}, or ${mend}, as doing so slightly reduces match efficiency.

    #FUXME: In fact, do this *EVERYWHERE* in this component. If there's no
    #performance impact (and there isn't), there's no compelling reason *NOT* to
    #do so.

    # Induce the passed glob to capture matched substrings.
#FUXME: Hmm. Niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiice. It turns out it *IS*
#possible to match globs iteratively in a manner similar to that of regular
#expressions. Should be fairly efficient, as well. First, note that parameter
#expansion "${string//(#m)${~glob}/${MATCH}}" is a noop iteratively replacing
#all substrings matching glob ${glob} with themselves. That isn't terribly
#useful, but note that this is generalizable into a similar parameter
#expansion "${string//(#m)${~glob}/$(run_command_on_match "${command}" "${MATCH}"; print_string "${MATCH}")}". Now *THIS* is clever. Unsure why I didn't think of it earlier,
#honestly. For each match, pass such match to helper function
#run_command_on_match() evaluating the passed "${command}", presumably passed
#the current match with standard output and error redirected to the bit bucket
#(to avoid mucking up the current match). Then, assuming such evaluation does
#not throw an exception, print such match, thus avoiding changing such string.
#Ah! Note that if we run the simpler parameter expansion
#"noop ${string//(#m)${~glob}/$(run_command_on_match "${command}" "${MATCH}")}",
#we achieve the same effect! No need to worry about whether or not we replace
#matched substrings, since we don't bother assigning the resulting string. Nice.
#In fact, it might even (slightly) improve efficiency to just replace all
#matches with the empty string (e.g., ";print;"), resulting in a smaller
#temporary string to be retained in-memory.

#declare_function_with_stdin <<'/---'
#[status: boolean] is_string_contains_glob_characters(string text)
#
#Return success if the passed string contains at least one glob-reserved
#character. This includes most ASCII punctuation (e.g., `[`, `<`, `(`, `|`, `+`).
#/---
#function is_string_contains_glob_characters() {
#    die_unless_arg 'expected one string'
#    is_string_glob_matches "${1}" *[\[\]\<\>\(\)\|+*?#~^]*
#}

    # Validate passed arguments
#   die_unless_args_2\
#       'expected one string and one glob expression'
#   string text="${1}" glob="${2}"

    #FUXME: Fairly silly, premature optimization. I mean, how often will an
    #empty string or glob or glob with no glob-reserved characters be passed?
    #This can all pretty much be reduced to a single command calling
    #for_string_match(). The implementation should resemble the corresponding
    #PCRE implementation. See such function!

    # If either such string or glob is empty, there can be no possible matches.
#   if is -z "${text}" or -z "${glob}" si {
#       return_string 0
    # If such glob contains no glob-reserved characters, such glob is a string
    # literal. Get the number of instances of such literal in such string.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_substrings_count "${text}" "${glob}")"
    # Else, count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
#   } else {
#       integer match_count=-1
#       string text_old

#       # For efficiency, avoid calling is_string_equals().
#       until { is "${text_old}" == "${text}" si } {
#           (( ++match_count ))
#           text_old="${text}"
#           text="${text/${~glob}/}"
#       }

#       return_string ${match_count}
#   }

#capture groups into canonical list globals (i.e., ${match}, ${mbegin}, ${mend})
#and substrings into canonical string globals (i.e., ${MATCH}, ${MBEGIN},
#${MEND}). .

#This function does _not_ implicitly capture match groups into canonical `zsh`
#globals (e.g., `${match}`). To perform such capturing, consider calling
#is_string_glob_matches_capturing_groups() instead.

#   die_unless_args_2 'expected one string and one glob'
#   is "${1}" == ${~2} si
#...     Personal success is not wrong. But it is limited in importance, and once
#...     you have enough of it it is a shame to keep striving for that, instead
#...     of for truth, beauty, or justice."
    # If not containing globbing flags "(#b)" or "(#m)", prefix such glob with
    # such strings. For efficiency, inline such tests.
#   is "${glob}" == *'(#b)'* si or glob="(#b)${glob}"
#   is "${glob}" == *'(#m)'* si or glob="(#m)${glob}"

    # Return such glob.
#   return_string "${glob}"

#   die_unless_arg 'expected one glob'
#   string glob="${1}"

    # If not containing globbing flag "(#m)", prefix such glob with such flag.
#   if is "${glob}" == *'(#m)'* si {
#       return_string "(#m)${glob}"
    # Else, do not.
#   } else {
#       return_string "${glob}"
#   }

#FUXME: Note that for_string_pcre_matches() documents similar globals. We should
#aggregate such documentation into a single function and cross-reference such
#function everywhere else.
#FUXME: Rename to is_string_matches_captivated() or
#is_string_matches_capturing(). The latter reads poorly, so... the former? Both
#read poorly, actually. How about is_string_glob_matches_capturing_groups()? Nice one!
#Actually, is_string_matches_captivatingly()... nah. Scratch that. Insanity. Go
#is_string_glob_matches_capturing_groups().
#FUXME: Call convert_string_to_glob_capturing_groups_and_substrings() internally
#for improved generality.

#* `${MATCH}`, a string global expanding to the entire matched substring.
#* `${match}`, a list global containing each match group captured within such
#  substring (e.g., `${match[1]}`, the first match group).
#* `${mbegin}`, a list global containing each 1-based index of the passed string
#  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
#  at which the first match group starts).
#* `${mend}`, a list global containing each 1-based index of the passed string
#  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
#  at which the first match group ends).

#When successfully matching, such glob sets list globals `${match}`, `${mbegin}`,
#and `${mend}` containing matched groups. See is_string_glob_matches_capturing_groups()
#for further details.

#In such case, access such groups after calling this function with the following
#list globals:
#
#* `${match}`, each element the substring captured by the match group with the
#  same list index or the empty string if no such substring was captured (e.g.,
#  `${match[1]}`, the substring captured by the first match group).
#* `${mbegin}`, each element the index of the passed string at which the
#  substring captured by the match group with the same list index begins (e.g.,
#  `${mbegin[1]}`, the string index at which the first match group begins).
#* `${mend}`, each element the index of the passed string at which the substring
#  captured by the match group with the same list index ends (e.g., `${mend[1]}`,
#  the string index at which the first match group ends).

#FUXME: Rename to convert_string_to_glob_matching_lines(), in keeping with
#convert_string_to_pcre_matching_lines() nomenclature.
#FUXME: Rename to convert_string_to_glob_capturing_groups() or
#convert_string_to_glob_matching_groups(). Hmmm; the former's a bit more verbose
#but much more explanatory and hence preferable. I mean, every glob "matches
#groups" already, so the latter conveys no meaningful information.
    #FUXME: Extract into a new get_string_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_substrings_count "${text}" "${glob}")"
#       string text_matches_deleted="${text//${glob}/}"
#       return_string $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))

# (i.e., saving `(` and
#`)`-delimited match groups in global list ${match})
#   if is "${text}" == ${~glob} si
#FUXME: Rename to get_string_glob_match_index(). The current function name is
#exceptionally ambiguous; after all, there could be multiple means of specifying
#which match to retrieve, of which group indices are merely the most obvious.
    #FUXME: Verify whether this suffices for instances of "${match[1]}" and so
    #forth in the replacement. I strongly suspect not (...in fact, let us say,
    #obviously not), in which case we require a separate
    #replace_string_match_with_evaluation() function.
#FUXME: I've never enjoyed pretending such functions to be getters. Rename to
#convert_string_to_glob_capturing_groups().
#FUXME: Rename to convert_string_to_glob_matching_lines()... or perhaps simply
#convert_string_to_glob_matching_lines(). Yes! The latter. Perfect.
# Such strings must be quote protected to be matched as specified when globbing.
#FUXME: No longer convinced this function is a good idea. The principle issue is
#quoting, which plays poorly with and in any case obstructs construction of
#string globs. Excise this function.

#FUXME: This needs a rename. It can currently be read in two very different
#ways, and the expected reading is *NOT* the actual reading. How about
#is_string_matches_capturing_groups_groups() or
#is_string_glob_matches_capturing_groups()? I prefer the former, I reckon. The added
#"_with" makes all the difference for readability here.
#FUXME: Rename to enable_glob_group_capturing()?
#FUXME: Rename to enable_glob_line_matching()?
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.

    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FUXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
