#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Match and substitute zsh-specific extended glob expressions.
#
# --------------------( SEE ALSO                           )--------------------
# Section "FILENAME GENERATION" of "man zshexpn"
#     Extended glob syntax official reference.
#
# --------------------( TODO                               )--------------------
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

# ....................{ TESTERS                            }....................
document_function '
boolean is_string_match(string text, string glob)

Return true if the passed string matches the passed glob: e.g.,

    >>> is_string_match "youshima" "[fuk]ushima" or print_string "dai-ichi"
    dai-ichi
'
function is_string_match() {
    die_unless_args_2 'expected one string and one glob'
    is "${1}" == ${~2} si
}

document_function '
boolean is_string_match_grouped(string text, string glob)

Return true and capture groups into global list ${match} and string ${MATCH}
if the passed string matches the passed glob. If capturing only one group,
consider calling get_string_match_group_if_found() instead: e.g.,

    >>> is_string_match_grouped "hiroshima" "(???)oshima"
    >>> print_string "${match[1]}"
    hir
    >>> get_string_match_group_if_found "hiroshima" "(???)oshima"
    hir
'
function is_string_match_grouped() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(convert_string_to_glob_grouped "${2}")"

    # Test such match. Avoid quoting such glob!
    is "${text}" == ${~glob} si
}

document_function '
boolean is_string_glob(string text)

Return true if the passed string contains a glob-reserved character, effectively
including most ASCII punctuation (e.g., "[", "<", "(", "|", "+", "*", "?", "#").
'
function is_string_glob() {
    die_unless_arg 'expected one string'
    is_string_match "${1}" '*[\[\]\<\>\(\)\|+*?#~^]*'
}

# ....................{ GETTERS                            }....................
document_function '
integer get_string_match_count(string text, string glob)

Get the number of matches in the passed string of the passed glob: e.g.,

    >>> get_string_match_count "bosozoku" "[bsz]o"
    3
'
function get_string_match_count() {
    # Validate passed arguments
    die_unless_args_2\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}"

    # If either the passed string or glob expression is empty, return 0.
    if is_string_empty "${text}" or is_string_empty "${glob}"; then
        print_string 0
    #FIXME: Extract into a new get_string_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
    elif not is_string_glob "${glob}"; then
        string text_matches_deleted="${text//${glob}/}"
        print_string $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
    else
        integer match_count=-1
        string text_old
        until is "${text_old}" == "${text}" si; do
            (( ++match_count ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        print_string ${match_count}
    fi
}

# ....................{ GETTERS ~ group                    }....................
document_function '
string get_string_match_group(
  string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or throw an exception if such string fails to match: e.g.,

    >>> get_string_match_group "Escape from the zombie food court" "*(z[^ ]##)*"
    zombie
'
function get_string_match_group() {
    get_string_match_group_if_found "${@}" or
        die "\"${text}\" not matched by glob \"${glob}\""
}

document_function '
string get_string_match_group_if_found(
  string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or return false if such string fails to match: e.g.,

    >>> get_string_match_group_if_found "Hologram" "*(o?)(o?)(o?)*" 2 or
    ...     print_string "Meat space versus the parallel universe"
    Meat space versus the parallel universe
'
function get_string_match_group_if_found() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional group index'
    string text="${1}" glob group_index="${3:-1}"
    glob="$(convert_string_to_glob_grouped "${2}")"
    die_unless_integer_positive "${group_index}"

    # Match such group. *AVOID* double-quoting such glob.
    if is_string_match "${text}" "${glob}"
    then print_string "${match[${group_index}]}"
    else return_false
    fi
}

# ....................{ GETTERS ~ line                     }....................
#FIXME: Implement get_string_lines_from_match_until_end(). Should be quite
#simple, though I don't believe such function can defer to this one.
document_function '
string get_string_lines_from_match_until_match(
  string text, string start_glob, string end_glob)

Get all lines from the passed string:

* Following the first line matching the first passed glob, including such
  line. If no such line matches, throw an exception.
* Preceding the next line matching the second passed glob, excluding such
  line. If no such line matches, include all remaining lines, thus emulating
  get_string_lines_from_match_until_end().
'
function get_string_lines_from_match_until_match() {
    # Validate passed arguments, treating piped input as such string.
    prepend_args_with_standard_input_if_piped
    die_unless_args_3\
        'expected one string, one starting glob, and one ending glob'
    string text="${1}"
    behead_arg

    # Split such string on newline delimiters into a list of lines.
    list lines
    set_list_to_string_lines lines "${text}"

    # Remove non-matching lines.
    remove_list_nonmatches_before_and_after_inclusive lines "${@}"

    # Join remaining lines into a newline-delimited string.
    print_string_newlined "${lines}"
}

# ....................{ CONVERTERS                         }....................
document_function '
string convert_string_to_glob_grouped(string glob)

Convert the passed glob to a glob capturing match groups (i.e., saving "(" and
")"-delimited match groups in global list ${match}), if not already.
'
function convert_string_to_glob_grouped() {
    # Validate passed arguments.
    die_unless_arg 'expected one glob'
    string glob="${1}"

    # If such glob does not contain glob flag "(#b)" enabling match groups,
    # prefix such glob with "(#b)" to do so.
    is_string_contains "${glob}" '(#b)' or glob="(#b)${glob}"

    # Return such glob.
    print_string "${glob}"
}

document_function '
string convert_string_to_glob_lines(string glob)

Convert the passed glob to a multiline glob (i.e., such that "^" and "$" also
match newlines). While PCREs implicitly support multiline matching via option
"-m", globs currently lack such support. Hence, this function is a fragile
hack. Until such support improves, consider matching with multiline PCREs,
instead.
'
function convert_string_to_glob_lines() {
    # Validate passed arguments.
    die_unless_arg 'expected one glob'
    string glob="${1}"

    # Replace all instances of "*" with "[^$'\n']#", thus terminating line
    # matching on the first newline.
    glob="${glob//\*/[^${ZESHY_CHARACTER_NEWLINE}]#}"
#   glob="${glob//\*/[^$'\n']#}"

    # Prefix such glob with an expression either matching at the start of the
    # string or the first newline preceding such match.
    glob="((#s)|*${ZESHY_CHARACTER_NEWLINE})${glob}*"
#   glob="((#s)|*$'\n')${glob}*"

    # And... we're done.
    print_string "${glob}"
}

# ....................{ REMOVERS                           }....................
document_function '
string remove_string_matches(string text, string glob)

Remove all substrings from the passed string matching the passed glob and
return the resulting string: e.g.,

    >>> remove_string_matches "rear_window" "r??"
    indow
'
function remove_string_matches() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one glob'
    print_string "${1//${~2}}"
}

document_function '
string remove_string_match_if_prefix(string text, string glob)

Remove the longest prefix from the passed string matching the passed glob and
return the resulting string: e.g.,

    >>> remove_string_match_if_prefix "north by northwest" "*n{o,d}?th"
    west
'
function remove_string_match_if_prefix() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one glob'
    print_string "${1##${~2}}"
}

document_function '
string remove_string_match_if_suffix(string text, string glob)

Remove the longest suffix from the passed string matching the passed glob and
return the resulting string: e.g.,

    >>> remove_string_match_if_suffix "dial.m.for.murder" ".m?????*"
    dial.
'
function remove_string_match_if_suffix() {
    prepend_args_with_standard_input_if_piped
    die_unless_args_2 'expected one string and one glob'
    print_string "${1%%${~2}}"
}

# ....................{ REPLACERS                          }....................
document_function '
string replace_string_matches_with_string(
  string text, string glob, string replacement)

Replace all substrings from the passed string matching the passed glob with the
passed replacement string: e.g.,

    >>> replace_string_matches_with_string "Waterloo and Recovered" "?r" "ur"
    Waturloo and Recovured
'
function replace_string_matches_with_string() {
    #FIXME: It's unclear just how to extend this function to a new function
    #supporting expansions depending on the passed glob: e.g., "${match[1]}".
    #Does parameter expansion prefix "~" suffice or do we need a genuine "eval"
    #statement? I suspect the latter, in which case such function should be
    #named replace_string_matches_with_evaluation(), but investigate.
    prepend_args_with_standard_input_if_piped
    die_unless_args_3 'expected one string, one glob, and one replacement'
    print_string "${1//${~2}/${3}}"
}

# --------------------( WASTELANDS                         )--------------------
#   if is "${text}" == ${~glob} si
#FUXME: Rename to get_string_match_group(). The current function name is
#exceptionally ambiguous; after all, there could be multiple means of specifying
#which match to retrieve, of which group indices are merely the most obvious.
    #FUXME: Verify whether this suffices for instances of "${match[1]}" and so
    #forth in the replacement. I strongly suspect not (...in fact, let us say,
    #obviously not), in which case we require a separate
    #replace_string_match_with_evaluation() function.
#FUXME: I've never enjoyed pretending such functions to be getters. Rename to
#convert_string_to_glob_grouped().
#FUXME: Rename to convert_string_to_glob_matching_lines()... or perhaps simply
#convert_string_to_glob_lines(). Yes! The latter. Perfect.
# Such strings must be quote protected to be matched as specified when globbing.
#FUXME: No longer convinced this function is a good idea. The principle issue is
#quoting, which plays poorly with and in any case obstructs construction of
#string globs. Excise this function.

#FUXME: This needs a rename. It can currently be read in two very different
#ways, and the expected reading is *NOT* the actual reading. How about
#is_string_match_with_capturing_groups() or
#is_string_match_grouped()? I prefer the former, I reckon. The added
#"_with" makes all the difference for readability here.
#FUXME: Rename to enable_glob_group_capturing()?
#FUXME: Rename to enable_glob_line_matching()?
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.

    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FUXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
