#!/usr/bin/env zsh
# ====================[ field                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *glob-matched fields* (i.e., substring-separated substrings on a line
# matched with glob or glob character classes).

# ....................{ ITERATORS                          }....................
# While there exists a for_string_line_fields_split_on_pcre() generalizing
# for_string_line_fields_split_on_pcre_class(), there exists no
# for_string_line_fields_split_on_glob() generalizing
# for_string_line_fields_split_on_glob_class_bounded(). The simplest explanation why is
# that globs have no equivalent to PCRE multiline mode. Without such mode,
# creating a column separator glob becomes an all but infeasible chore; and even
# where feasible risky, since such glob must be explicitly engineered to *NOT*
# match newlines. But that's not the only explanation why. Such a generalization
# requires some equivalent to PCRE negative lookahead assertions. While globs do
# support "(^...)"-driven glob negation, such negation consumes what it matches;
# hence, the closest glob equivalent for capturing a column would be
# "((^${~column_separator_glob})#)". However, notice the use of *TWO* capturing
# subpatterns. Since glob syntax provides no means of disabling match capturing,
# callers must ignore every other match. This becomes patently ridiculous
# quickly -- at which point it's difficult to justify the effort.

#FIXME: This has become slightly desynchronized with "pcre/field". In
#particular:
#
#* All fields should be optional.
#* An explicit count need not be passed: just parse the first line for the field
#  count.
#* An example should be provided.
#
#Honestly, it's a pain synchronizing these implementations. But nothing can
#be reasonably abstracted out into an even more general, lower-level function. I
#mean, "pcre/field" has already gone *REALLY* abstract. We'll just have to grit
#our teeth and do it. That, or just drop this function... Consider it.
declare_function_with_stdin <<'-\-'
<globbable> string for_string_line_fields_split_on_glob_class_bounded(
    string text,
    integer column_count,
    string column_separator_class,
    string command)

Run the passed command for each line of the passed string containing at most the
passed number of columns separated by substrings matching the passed glob
character class (e.g., `[:alnum:]`, matching alphanumeric-delimited columns).
Avoid delimiting such class with `[` and `]` characters _unless_ such class is a
named character class (e.g., `a-zA-Z0-9` rather than `[a-zA-Z0-9]`): e.g.,

.for_string_line_fields_split_on_glob_class_bounded()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================

[WARNING]
If the passed glob character class matches newlines either explicitly (e.g.,
`\n\t\v `, `[:space:]`) or implicitly (e.g., `^a-z[:alpha:]`), throw an
exception. Permitting such classes would erroneously match a portion of the line
following the current line into the last column of such line.
-\-
function for_string_line_fields_split_on_class() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one string, one column count, one column separator character class, and one command'
    string\
        text="${1}"\
        column_count="${2}"\
        column_separator_class="${3}"\
        command="${4}"\
        glob_column\
        glob_column_separator\
        glob_column_separated\
        glob_columns_sans_last\
        glob_columns
    die_unless_integer_positive "${column_count}"
    die_unless_string_nonempty "${column_separator_class}"\
        'expected non-empty column separator PCRE character class'
    die_unless_string_nonempty "${command}" 'expected non-empty command'

    # If such class matches newlines, throw an exception.
    is_string_pcre_matches\
        "${ZESHY_ASCII_NEWLINE}" "[${column_separator_class}]" and
        die "column separator character class \"${column_separator_class}\" matches newlines"

        glob_columns_prior="([^${ZESHY_ASCII_NEWLINE}${column_separator_class}]#(|(#e)))"

    # Glob expression matching the desired column. Dismantled, this is:
    #
    # * "(#b)", enabling back references (i.e., match groups) for all
    #   subsequent groups. Do this as late as possible to avoid capturing
    #   columns preceding such column.
    string glob_column__sltsc
    glob_column__sltsc="(#b)([^${column_separator_class__sltsc}]#)([${column_separator_class__sltsc}]|(#e))"

    # PCRE anchored to the beginning of either such string or each string line.
    glob_start="((#s)|${ZESHY_ASCII_NEWLINE})"

    # Construct a PCRE capturing all such columns on a single line. See
    # for_string_line_fields_split_on_pcre_class() for further details.
    glob_column="([^${ZESHY_ASCII_NEWLINE}${column_separator_class}]#)"
    glob_column_separator="[${column_separator_class__sltsc}]##"
    glob_column_separated="${glob_column}${glob_column_separator}"
    glob_columns_sans_last="$(repeat_string "${glob_column_separated}" "$(( column_count - 1 ))")"
    glob_remainder="([^${ZESHY_ASCII_NEWLINE}]#)"

    # To avoid capturing the beginning of each string line and hence disrupting
    # the column order as perceived by callers, begin capturing only *AFTER*
    # matching such beginning. Likewise, to avoid capturing the optional
    # trailing column separator, stop capturing *AFTER* matching the last
    # column. To capture the unmatched remainder of the current line, begin
    # capturing *AFTER* matching such optional trailing column separator.
    #
    # Surprisingly, this mostly works.
    glob_columns="${glob_start}(#b)${glob_columns_sans_last}${glob_column}(#B)(${glob_column_separator}(#b)${glob_remainder}|)"

    # Iterate such matches with such glob.
    for_string_glob_matches "${text}" "${glob_columns}" "${command}"
}

# --------------------( WASTELANDS                         )--------------------
