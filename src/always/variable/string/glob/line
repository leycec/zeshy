#!/usr/bin/env zsh
# ====================[ line                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle extended glob expressions matching newline-delimited strings.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> [status: boolean] is_string_line_glob_matches(
    string text, string glob)

Return success if some line of the passed string matches the passed glob: e.g.,

.is_string_line_matches()
==========================================
[source]
------------------------------------------
>>> string burnt_norton="
...     Dry the pool, dry concrete, brown edged,
...     And the pool was filled with water out of sunlight,
...     And the lotos rose, quietly, quietly,
...     The surface glittered out of heart of light,
...     And they were behind us, reflected in the pool.
...     Then a cloud passed, and the pool was empty.
...     Go, said the bird, for the leaves were full of children,
...     Hidden excitedly, containing laughter.
...     Go, go, go, said the bird: human kind
...     Cannot bear very much reality."
>>> is_string_line_matches "${burnt_norton}" *[Tt]ime*p(resen|as)t* or
...     print_string "Shall we follow?"
Shall we follow?
------------------------------------------
==========================================

== Alternatives ==

While PCRE syntax explicitly supports such line matching with PCRE option "-m",
`zsh` glob syntax supports no such option. This function simulates such option
by splitting such string on newline into a temporary list and then performing
such glob on such list elements, a remarkably inefficient matching approach
(particularly for long strings). Happily, there exist two alternatives.

=== PCRE-based Line Matching ===

Consider calling is_string_pcre_multiline_matches() instead with the corresponding
PCRE. Since glob and PCRE patterns are similar in both form and function, this is
arguably the easiest course of action: e.g.,

.is_string_line_matches() vs. is_string_pcre_multiline_matches()
==========================================
[source]
------------------------------------------
>>> is_string_pcre_multiline_matches "${burnt_norton}" ^.*[Tt]ime.*p(resen|as)t.*$ or
...     print_string "And all is always now."
And all is always now.
------------------------------------------
==========================================

=== Glob-based Line Matching ===

Consider calling is_string_glob_matches() instead with the corresponding string-
oriented glob. While non-trivial, converting line- to string-oriented globs is
generally (but _not_ always) feasible -- namely, with the following heuristics:

* Prefix such glob with `((#s)|*${ZESHY_ASCII_NEWLINE})`, matching either the
  string start or a newline.
* Suffix such glob with `((#e)|${ZESHY_ASCII_NEWLINE}*)`, matching either the
  string end or a newline.
* Replace all internal instances of `*` with `[^${ZESHY_ASCII_NEWLINE}]#`,
  matching any substring of zero or more characters other than a newline.
* Replace all internal instances of `?` with `[^${ZESHY_ASCII_NEWLINE}]`,
  matching any character other than a newline.

Such complexity renders PCRE-based line matching the preferable alternative, in
most cases. For example:

.is_string_line_matches() vs. is_string_glob_matches()
==========================================
[source]
------------------------------------------
>>> is_string_glob_matches "${burnt_norton}"\
...     ((#s)|*${ZESHY_ASCII_NEWLINE})[Tt]ime[^${ZESHY_ASCII_NEWLINE}]#p(resen|as)t((#e)|${ZESHY_ASCII_NEWLINE}*) or
...     print_string "At the still point of the turning world."
At the still point of the turning world.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_string_line_glob_matches() {
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob="${2}"

    # Split such string on newline.
    list lines; set_list_to_string_lines lines "${text}"

    # Match such lines against such glob.
    is_list_matches lines "${glob}"
}

# ....................{ GETTERS                            }....................
#FIXME: Implement get_string_lines_from_match_until_end(). Should be quite
#simple, though I don't believe such function can defer to this one.

declare_function_with_stdin <<'________________<heredoc?>________________'
<globbable> string
    get_string_lines_after_glob_match_inclusive_before_match_exclusive(
        string text, string start_glob, string end_glob)

Get all lines from the passed string:

* Following the first line matching the first passed glob, including such
  line. If no such line matches, throw an exception.
* Preceding the next line matching the second passed glob, excluding such
  line. If no such line matches, include all remaining lines, thus emulating
  get_string_lines_from_match_until_end().
________________<heredoc?>________________
function get_string_lines_after_glob_match_inclusive_before_match_exclusive() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one start glob, and one end glob'
    string text="${1}" start_glob="${2}" end_glob="${3}"

    # Split such string on newline.
    list lines; set_list_to_string_lines lines "${text}"

    # Remove non-matching lines.
    reduce_list_to_elements_after_match_inclusive_before_match_exclusive\
        lines "${start_glob}" "${end_glob}"

    # Join all remaining lines into a newline-delimited string.
    join_list_on_newline lines
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ CONVERTERS                         }....................
#FUXME: This isn't right *AT ALL*. I do believe it's feasible, but it will
#require considerably more effort than we've gone to here. Do *NOT* replace "*"
#characters if prefixed by "\", if embedded in a character class "[...]" (which
#itself is non-trivial to match, if one considers it), or if embedded in a
#single- or double-quoted string. Hence, this requires an at least ad-hoc
#parsing effort. *sigh*
#FUXME: No. If you consider it, this is basically impossible to implement in the
#general case. Consider "?", for example, which would also need be similarly
#replaced. It simply doesn't scale to the general case. Replace with line
#splitting into lists and list matching.
#declare_function_with_stdin <<'________________<heredoc?>________________'
#<globbable> string convert_string_to_glob_matching_lines(string glob)
#
#Convert the passed glob to a multiline glob (i.e., such that `(#s)` and `(#e)`
#also match newlines). While PCREs support multiline matching with option `-m`,
#globs currently lack such support. Hence, this function is somewhat of a fragile
#hack. Until such support improves, consider multiline PCREs instead.
#________________<heredoc?>________________
#function convert_string_to_glob_matching_lines() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one glob'
#    string glob="${1}"
#
#    # Replace all instances of "*" with "[^$'\n']#", thus terminating line
#    # matching on the first newline.
#    glob="${glob//\*/[^${ZESHY_ASCII_NEWLINE}]#}"
##   glob="${glob//\*/[^$'\n']#}"
#
#    # Prefix such glob with an expression either matching at the start of the
#    # string or the first newline preceding such match.
#    glob="((#s)|*${ZESHY_ASCII_NEWLINE})${glob}*"
##   glob="((#s)|*$'\n')${glob}*"
#
#    # Return such glob.
#    return_string "${glob}"
#}
#
#Since this is remarkably less efficient than
#PCRE-based line matching (particularly on long strings), there exist two 
#alternatives. consider either:
#FUXME: Rename to
#get_string_lines_after_match_inclusive_before_match_exclusive().
