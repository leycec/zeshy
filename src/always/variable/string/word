#!/usr/bin/env zsh
# ====================[ word                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string words (i.e., whitespace-delimited substrings).

# ....................{ GETTERS                            }....................
#FIXME: A working example would be great here.
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_word(string text, integer word_index)

Get the word with the passed 1-based index in the passed string: e.g.,

.get_string_word()
==========================================
[source]
------------------------------------------
>>> string ="
...     
...     
...     
>>> get_string_word "${}" -1
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_word() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one word index'
    string text="${1}" word_index="${2}"
    die_unless_integer "${word_index}"

    # Get such word.
    return_string "${text[(w)${word_index}]}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_lines_word(string text, integer column_index)

List each word with the passed 1-based index in each line of the passed string,
delimited by newline: e.g.,

.get_string_lines_word()
==========================================
[source]
------------------------------------------
>>> string gerard_piel="
...     We  are       waking from the   American Dream
...     to  realize   that   it   was   a        dream
...     few Americans lived  in   their waking   hours."
>>> get_string_lines_word "${gerard_piel}" -1
Dream
dream
hours.
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_lines_word() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one word index'
    string text="${1}" word_index="${2}"
    die_unless_integer "${word_index}"

    # Get such words.
    for_string_words "${text}" "output_string \"\${match[${word_index}]}\""
}

# ....................{ GETTERS ~ count                    }....................
#FIXME: Examples would be great here.
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_word_count(string text, string text2, ...)

Get the number of words in the passed string, aggregating each quoted
substring into one shell word. Hence, this is a shell-specific word count.
________________<heredoc?>________________
function get_string_word_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_word_count_unquoted(string text1, string text2, ...)

Get the number of words in the passed string _not_ aggregating quoted
substrings. Hence, this is the conventional English word count.
________________<heredoc?>________________
function get_string_word_count_unquoted() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ ITERATORS                          }....................
#FIXME: An example would be nice.
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_words(string text, string command)

Run the passed command for each line of the passed string with each whitespace-
delimited word of such line captured into list global ${match}. See
for_string_columns_split_on_pcre() for further details: e.g.,

.for_string_columns_split_on_whitespace()
==========================================
[source]
------------------------------------------
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_columns_split_on_whitespace() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one command'

    # Iterate such matches. Match whitespace column delimiters with PCRE
    # character class "[:blank:]" rather than "[:space:]"; the latter
    # unhelpfully matches newline, while the former does not.
    for_string_columns_split_on_pcre_class "${1}" [:blank:] "${2}"
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: This could probably be optimized by calling
    #for_string_columns_split_on_class() instead. I'm not
    #sure there's an equivalent glob class to "[:blank:]", but "\t " seems a
    #reasonable approximation. Note that it's not a good idea to implement
    #for_string_columns_split_on_glob(), as globs have no equivalent to
    #multiline mode. Note also that no "_capturing_groups" suffix is required,
    #since if you're not capturing groups, you can't capture columns, which
    #renders the whole affair nonsensical.

#FUXME: You know, this should arguably use "[${IFS}]" as the separator character
#class rather than "[:blank:]". A nice improvement -- and needful, actually. I
#mean, we can't reliably call the matched substrings "words" unless we do this.
#FUXME: No, wait. That doesn't work. ${IFS} contains newlines, which we'd have
#to manually strip off. Even then, it's not clear that "[${IFS}]" is actually a
#valid PCRE class. Ignore for now.

#containing at most the passed number of whitespace-delimited columns.

#FUXME: Generalize to a new simpler function for_string_lines(),
#which would provide each such line as ${MATCH} (...and perhaps also ${LINE}).
#FUXME: Ah! We probably want to reimplement such functions with multiline PCREs,
#which should offer substantially better efficiency, generality, and safety.
#The current glob-based implementation splits the passed string into lines,
#clearly slower than multiline matching.

