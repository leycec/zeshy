#!/usr/bin/env zsh
# ====================[ word                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *shell words* (i.e., substrings split from their parent string
# according to `zsh`- rather than ${IFS}-based string splitting rules).

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_word(string text, integer word_index)

Get the shell word with the passed 1-based index in the passed string: e.g.,

.get_string_word()
==========================================
[source]
------------------------------------------
>>> string methods_of_control="
...     People use the word \"natural.\" What is natural to me is these
...     botanical species which interact directly with the nervous system. What
...     I consider artificial is four years at Harvard, the Bible, Saint
...     Patrick's cathedral, and Sunday school teachings."
>>> get_string_word "${methods_of_control}" 5
"natural."
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_word() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one word index'
    string text="${1}" word_index="${2}"
    die_unless_integer "${word_index}"

    # Get such word.
    return_string "${text[(w)${word_index}]}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_lines_word(string text, integer column_index)

List each shell word with the passed 1-based index in each line of the passed
string, delimited by newlines: e.g.,

.get_string_lines_word()
==========================================
[source]
------------------------------------------
>>> string on_america="
...     We  are       waking from the   American Dream
...     to  realize   that   it   was   a        dream
...     few Americans lived  in   their waking   hours."
>>> get_string_lines_word "${on_america}" -1
Dream
dream
hours.
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_lines_word() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one word index'
    string text="${1}" word_index="${2}"
    die_unless_integer "${word_index}"

    # Get such words.
    for_string_line_words "${text}" "output_string \"\${match[${word_index}]}\""
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_word_count(string text, string text2, ...)

Get the number of shell words in the passed string. Despite the term ``word'',
this does _not_ correspond to the conventional human-readable word count: e.g.,

.get_string_word_count()
==========================================
[source]
------------------------------------------
>>> string on_cloudbusting=\
...    "\"On top of the world,
...     Looking over the edge,
...     You could see them coming.
...     You looked too small
...     In their big, black car,
...     To be a threat to the men in power.\""
>>> get_string_word_count "${on_cloudbusting}"
1
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_word_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_words(
    string text,
    line_string_name = 'LINE',
    word_list_name = 'word',
    string command)

Run the passed command for each line of the passed string, capturing such line
into the passed local string variable (defaulting to ${LINE}) and each shell
word of such line into an element of the passed local list variable (defaulting
to ${word}): e.g.,

.for_string_line_words()
==========================================
[source]
------------------------------------------
>>> string plan_plant_planet=\
...    "The process begins by declaring legitimate what we have denied for so
...     long. Let us declare nature to be legitimate. All plants should be
...     declared legal, and all animals for that matter. The notion of illegal
...     plants and animals is obnoxious and ridiculous."
>>> for_string_line_words "${plan_plant_planet}" 'output_string "${word[-3]}"'
denied
plants
notion
obnoxious
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_words() {
    # Validate passed arguments.
    die_unless_args_2_to_4\
        'expected one string, optional line string name, optional word list name, and one command'
    string\
        text="${1}"\
        line_string_name='LINE'\
        word_list_name='word'\
        command="${@[-1]}"
    is_args_3_to_4 and line_string_name="${2}"
    is_args_4      and word_list_name="${3}"
    die_unless_variable_names "${line_string_name}" "${word_list_name}"
    die_unless_string_nonempty "${command}" 'expected nonempty command'

    # List of currently matched words.
    list ${word_list_name}

    # Split each such line into words.
    for_string_lines "${text}" "${line_string_name}" "
        ${word_list_name}=( \"\${(z)${line_string_name}}\" )
        ${command}"
}

# --------------------( WASTELANDS                         )--------------------
# Splits words from the
    # current line ${MATCH} (captured by for_string_lines()) into ${match}.
# Handle shell words (i.e., substrings subject to `zsh`- rather than ${IFS}-
# based string splitting).
#
# Handle shell words (i.e., substrings delimited according to `zsh` string
# splitting rules rather than conventional ${IFS}-based string splitting).
# whitespace-delimited substrings).
#....    I have a secret love of chaos. There should be more of it. Do not...
#....    assume that order and stability are always good, in a society or in a
#....    universe. The old, the ossified, must always give way to new life and
#....    the birth of new things. Before the new things can be born the old must
#....    perish. This is a dangerous realization, because it tells us that we
#....    must eventually part with much of what is familiar to us. And that
#....    hurts. But that is part of the script of life."
    #FUXME: Actually, there's a much better implementation. The problem with
    #this one is that for_string_columns_split_on_pcre_class() constrains the
    #number of words in each line to the number in the first line. A bit
    #strange, no? For greater flexibility *AND* efficiency, instead:
    #
    #* Call a new function get_string_lines(), which should internally use
    #  either:
    #  * Parameter flag "(f)", if such string is short.
    #  * A PCRE, if such string is long. (To avoid creating a huge list.)
    #* For each ${MATCH}-ing line, manually split such line into ${match} with:
    #  "match=( ${(z)MATCH} ); ${command}"
    #
    #Not only is this faster, it also preserves the shell-based notion of "word".

    # Iterate such matches. Match whitespace column delimiters with PCRE
    # character class "[:blank:]" rather than "[:space:]"; the latter
    # unhelpfully matches newline, while the former does not.
#   for_string_columns_split_on_pcre_class "${1}" [:blank:] "${2}"

    # inline such splitting of the current line ${MATCH} into the current list
    # of words ${match}.
#...     \"He had a great capacity to arouse irrational hatred obviously,
#...     and that's because his ideas were radical in the most extreme sense of
#...     the word \"radical.\" His ideas have something to offend everybody, and
#...     he ended up becoming the only heretic in American history whose books
#...     were literally burned by the government.\"
#...     \"None of Dr. Leary's most important studies have either suffered
#...     refutation or enjoyed confirmation, because enacted law – statutes
#...     enacted after and because of Dr. Leary's research – makes it a crime for
#...     any other psychologists or psychiatrists to replicate such research.\""

    #FUXME: This could probably be optimized by calling
    #for_string_columns_split_on_class() instead. I'm not
    #sure there's an equivalent glob class to "[:blank:]", but "\t " seems a
    #reasonable approximation. Note that it's not a good idea to implement
    #for_string_columns_split_on_glob(), as globs have no equivalent to
    #multiline mode. Note also that no "_capturing_groups" suffix is required,
    #since if you're not capturing groups, you can't capture columns, which
    #renders the whole affair nonsensical.

#FUXME: You know, this should arguably use "[${IFS}]" as the separator character
#class rather than "[:blank:]". A nice improvement -- and needful, actually. I
#mean, we can't reliably call the matched substrings "words" unless we do this.
#FUXME: No, wait. That doesn't work. ${IFS} contains newlines, which we'd have
#to manually strip off. Even then, it's not clear that "[${IFS}]" is actually a
#valid PCRE class. Ignore for now.

#containing at most the passed number of whitespace-delimited columns.

#FUXME: Generalize to a new simpler function for_string_lines(),
#which would provide each such line as ${MATCH} (...and perhaps also ${LINE}).
#FUXME: Ah! We probably want to reimplement such functions with multiline PCREs,
#which should offer substantially better efficiency, generality, and safety.
#The current glob-based implementation splits the passed string into lines,
#clearly slower than multiline matching.

