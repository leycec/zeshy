#!/usr/bin/env zsh
# ====================[ word                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string words (i.e., whitespace-delimited substrings).

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_word(string text, integer word_index)

Get the word with the passed 1-based index in the passed string: e.g.,

.get_string_word()
==========================================
[source]
------------------------------------------
>>> string methods_of_control="
...     People use the word \"natural.\" What is natural to me is these
...     botanical species which interact directly with the nervous system. What
...     I consider artificial is four years at Harvard, the Bible, Saint
...     Patrick's cathedral, and Sunday school teachings."
>>> get_string_word "${methods_of_control}" 5
"natural."
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_word() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one word index'
    string text="${1}" word_index="${2}"
    die_unless_integer "${word_index}"

    # Get such word.
    return_string "${text[(w)${word_index}]}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_lines_word(string text, integer column_index)

List each word with the passed 1-based index in each line of the passed string,
delimited by newline: e.g.,

.get_string_lines_word()
==========================================
[source]
------------------------------------------
>>> string gerard_piel="
...     We  are       waking from the   American Dream
...     to  realize   that   it   was   a        dream
...     few Americans lived  in   their waking   hours."
>>> get_string_lines_word "${gerard_piel}" -1
Dream
dream
hours.
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_lines_word() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one word index'
    string text="${1}" word_index="${2}"
    die_unless_integer "${word_index}"

    # Get such words.
    for_string_line_words "${text}" "output_string \"\${match[${word_index}]}\""
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_word_count(string text, string text2, ...)

Get the number of words in the passed string, aggregating each quoted
substring into one shell word. Hence, this is a shell-specific word count: e.g.,

.get_string_word_count()
==========================================
[source]
------------------------------------------
>>> string cloudbusting="
...     \"On top of the world,
...       Looking over the edge,
...       You could see them coming.
...       You looked too small
...       In their big, black car,
...       To be a threat to the men in power.\""
>>> get_string_word_count "${cloudbusting}"
1
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_word_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_word_count_unquoted(string text1, string text2, ...)

Get the number of words in the passed string _not_ aggregating quoted
substrings. Hence, this is the conventional English word count: e.g.,

.get_string_word_count_unquoted()
==========================================
[source]
------------------------------------------
>>> string cloudbusted="
...     \"Timothy Leary spent five years in prison for unorthodox scientific
...     ideas. Ezra Pound spent 13 years in a nuthouse for unorthodox political
...     and economic ideas. Their books were not burned. Reich was not only
...     thrown in prison, but they chopped up all the scientific equipment in
...     his laboratory with axes and burned all of his books in an
...     incinerator.\""
>>> string cloudbusted="
>>> get_string_word_count_unquoted "${cloudbusted}"
59
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_word_count_unquoted() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_words(string text, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each shell word of such line into an element of
list global ${match}: e.g.,

.for_string_line_words()
==========================================
[source]
------------------------------------------
>>> string plan_plant_planet="
...       The process begins by declaring legitimate what we have denied for so
...     long. Let us declare nature to be legitimate. All plants should be
...     declared legal, and all animals for that matter. The notion of illegal
...     plants and animals is obnoxious and ridiculous."
>>> for_string_line_words "${plan_plant_planet}" 'output_string "${match[-3]}"'
denied
plants
notion
obnoxious
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_words() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one command'
    string text="${1}" command="${2}"

    # Words split from the currently matched line.
    list match

    # Split such string into words and iterate such words. Splits words from the
    # current line ${MATCH} (captured by for_string_lines()) into ${match}.
    for_string_lines "${text}" "match=( ${(z)MATCH} ); ${command}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_words_split_on_ifs(
    string text, string ifs, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each word of such line into an element of list
global ${match}. Split such words on any substring of one or more whitespace
characters _or_ one non-whitespace character between zero or more whitespace
characters, where such characters are defined by the passed internal field
separators (IFS). See ``IFS'' under `man zshparam` for further details: e.g.,

.for_string_line_words_split_on_ifs()
==========================================
[source]
------------------------------------------
>>> string on_philip_k_dick="
....    One time, when I was researching Gnosticism in the Britannica, I came
....    across mention of a Gnostic codex called \"The Unreal God and the
....    Aspects of His Nonexistent Universe,\" an idea which reduced me to
....    helpless laughter. What kind of person would write about something that
....    he knows doesn't exist, and how can something that doesn't exist have
....    aspects? But then I realized that I'd been writing about these matters
....    for over twenty-five years."
>>> for_string_line_words_split_on_ifs "${on_philip_k_dick}" ','\
...     '(( $(get_list_size match) > 1 )) and output_string "${match[1]}"'
One time
Aspects of His Nonexistent Universe
he knows doesn't exist
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_words_split_on_ifs() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one internal field separators string, and one command'
    string text="${1}" ifs="${2}" command="${3}"

    # Words split from the currently matched line.
    list match

    # Split such string into words and iterate such words. Splits words from the
    # current line ${MATCH} matched by for_string_lines() into ${match}. Since
    # parameter flag "(z)" does not by definition respect ${IFS}, defer to
    # parameter flag "=" instead.
    IFS="${ifs}" for_string_lines "${text}" "match=( ${=MATCH} ); ${command}"
}

# --------------------( WASTELANDS                         )--------------------
#....    I have a secret love of chaos. There should be more of it. Do not...
#....    assume that order and stability are always good, in a society or in a
#....    universe. The old, the ossified, must always give way to new life and
#....    the birth of new things. Before the new things can be born the old must
#....    perish. This is a dangerous realization, because it tells us that we
#....    must eventually part with much of what is familiar to us. And that
#....    hurts. But that is part of the script of life."
    #FUXME: Actually, there's a much better implementation. The problem with
    #this one is that for_string_columns_split_on_pcre_class() constrains the
    #number of words in each line to the number in the first line. A bit
    #strange, no? For greater flexibility *AND* efficiency, instead:
    #
    #* Call a new function get_string_lines(), which should internally use
    #  either:
    #  * Parameter flag "(f)", if such string is short.
    #  * A PCRE, if such string is long. (To avoid creating a huge list.)
    #* For each ${MATCH}-ing line, manually split such line into ${match} with:
    #  "match=( ${(z)MATCH} ); ${command}"
    #
    #Not only is this faster, it also preserves the shell-based notion of "word".

    # Iterate such matches. Match whitespace column delimiters with PCRE
    # character class "[:blank:]" rather than "[:space:]"; the latter
    # unhelpfully matches newline, while the former does not.
#   for_string_columns_split_on_pcre_class "${1}" [:blank:] "${2}"

    # inline such splitting of the current line ${MATCH} into the current list
    # of words ${match}.
#...     \"He had a great capacity to arouse irrational hatred obviously,
#...     and that's because his ideas were radical in the most extreme sense of
#...     the word \"radical.\" His ideas have something to offend everybody, and
#...     he ended up becoming the only heretic in American history whose books
#...     were literally burned by the government.\"
#...     \"None of Dr. Leary's most important studies have either suffered
#...     refutation or enjoyed confirmation, because enacted law – statutes
#...     enacted after and because of Dr. Leary's research – makes it a crime for
#...     any other psychologists or psychiatrists to replicate such research.\""

    #FUXME: This could probably be optimized by calling
    #for_string_columns_split_on_class() instead. I'm not
    #sure there's an equivalent glob class to "[:blank:]", but "\t " seems a
    #reasonable approximation. Note that it's not a good idea to implement
    #for_string_columns_split_on_glob(), as globs have no equivalent to
    #multiline mode. Note also that no "_capturing_groups" suffix is required,
    #since if you're not capturing groups, you can't capture columns, which
    #renders the whole affair nonsensical.

#FUXME: You know, this should arguably use "[${IFS}]" as the separator character
#class rather than "[:blank:]". A nice improvement -- and needful, actually. I
#mean, we can't reliably call the matched substrings "words" unless we do this.
#FUXME: No, wait. That doesn't work. ${IFS} contains newlines, which we'd have
#to manually strip off. Even then, it's not clear that "[${IFS}]" is actually a
#valid PCRE class. Ignore for now.

#containing at most the passed number of whitespace-delimited columns.

#FUXME: Generalize to a new simpler function for_string_lines(),
#which would provide each such line as ${MATCH} (...and perhaps also ${LINE}).
#FUXME: Ah! We probably want to reimplement such functions with multiline PCREs,
#which should offer substantially better efficiency, generality, and safety.
#The current glob-based implementation splits the passed string into lines,
#clearly slower than multiline matching.

