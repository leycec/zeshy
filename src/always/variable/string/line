#!/usr/bin/env zsh
# ====================[ line                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle newline-delimited strings.

# ....................{ TESTERS                            }....................
declare_function '
boolean is_string_line(string text, string line)

Return true if the passed string contains the passed line, such that:

* Such line is preceded either by a newline or the start of such string.
* Such line is followed either by a newline or the end of such string.
'
function is_string_line() {
    # Validate passed arguments, treating piped input as the passed string.
    prepend_args_with_stdin_if_piped
    die_unless_args_2 'expected one string and one line'

    # Attempt to match such line. Dismantled, this is:
    #
    # * "(|*...)", matching either the start of the string or a newline.
    # * "(|...*)", matching either the end of the string or a newline.
    is "${1}" ==\
        (|*${ZESHY_ASCII_NEWLINE})"${2}"(|${ZESHY_ASCII_NEWLINE}*) si
}

# ....................{ GETTERS                            }....................
declare_function '
string get_string_line(string text, integer line_index = 1)

Get the line corresponding to the passed line number from the passed string.
If positive, this is the nth line from the beginning starting at 1. Conversely
if negative, this is the nth line from the end starting at -1.
'
function get_string_line() {
    die_unless_args_1_to_2\
        'expected one string and optional line number'
    string line_index=${2:-1}
    get_string_lines "${1}" ${line_index} ${line_index}
}

declare_function '
string get_string_lines(
  string text,
  integer start_line_index = 1,
  integer end_line_index = "$(get_string_line_count string)")

Get the list of lines starting at the passed first line number (defaulting to
the first line) and concluding at the passed last line number (defaulting to
the last line) from the passed string.
'
function get_string_lines() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one string and optional start and end line numbers'
    list lines; lines=( "${(f)1}" )
    string beg_line_index="${2:-}" end_line_index="${3:-}"
    check_list_args lines beg_line_index end_line_index

    # Get such lines. Do *NOT* quote such expansion.
    print_string_newlined ${lines[${beg_line_index},${end_line_index}]}
}

# ....................{ GETTERS ~ count                    }....................
declare_function '
integer get_string_line_count(string text1, string text2, ...)

Get the total number of lines in the passed strings.
'
function get_string_line_count() {
    die_unless_args 'expected at least one string'
    list lines; lines=( "${(f)*}" )
    get_list_size lines
}

# ....................{ SETTERS                            }....................
declare_function '
string set_list_to_string_lines(string list_name, string text)

Split the passed string on newlines into the passed list.
'
function set_list_to_string_lines() {
    # Validate passed arguments, treating piped input as the passed string.
    append_args_with_stdin_if_piped
    die_unless_args_2 'expected one list name and one string'
    string list_name="${1}" __text__="${2}"

    # Split such string.
    set_list_to_evaluation "${list_name}" '${(f)__text__}'
}

# ....................{ NUMBERERS                          }....................
declare_function '
string number_string_lines(string text)

Prefix each line of the passed string with that line''s number.
'
function number_string_lines() {
    print_string "${@}" |
        run_command_with_options ZESHY_NL_OPTIONS 'run_command_paged command nl'
}

#FIXME: Rename to number_string_lines_highlighting_line().
declare_function '
string number_string_lines_highlighting(
  string text, integer highlight_line_index)

Prefix each line of the passed string with that line''s number and highlight
the passed line number. Since "nl" supports no highlighting, this function
accepts no "nl"-specific options.
'
function number_string_lines_highlighting() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one line number'
    string text="${1}" line_index="${2}"
    die_if_string_empty "${text}"
    die_unless_integer_positive "${line_index}"

    #FIXME: Actually, it's trivial to convert negative to positive line numbers.
    # Validate passed arguments. Negative line numbers are impermissible.
    integer line_count; line_count="$(get_string_line_count "${text}")"
#   print_message "line length: ${line_count}"
    (( 1 <= line_index && line_index <= line_count )) or
        die "line number ${line_index} not in [1, ${line_count}]"

    # Number lines.
    print_string "${text}" | awk -vNRHI=${line_index} '
# If any line other than the highlight line, print the current line number
# followed by the line.
NR != NRHI { printf("%6d%7s%s\n", NR, "", $0) }
# If the highlight line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (See curse_call_stack() for similar logic.)
NR == NRHI {
    # Number of digits in the current line number.
    NRLEN = length(NR);
         if (NRLEN==1) {NRNOW = " <-~ " NR}
    else if (NRLEN==2) {NRNOW = "<-~ " NR}
    else if (NRLEN==3) {NRNOW = "<- " NR}
    else               {NRNOW = NR}       # if true, your string is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}'
}

# ....................{ REMOVERS                           }....................
declare_function '
string remove_string_line_duplicates(string text1, string text2, ...)

Remove all duplicate lines from the concatenation of the passed strings.
Unlike conventional solutions (e.g., "sort -u", "sort | uniq -u"), this
function preserves the line order of returned lines: e.g.,

    >>> remove_string_line_duplicates "the Perfect
    ...   and
    ...   the Perfect
    ...   are one Perfect and not two;
    ...   nay, are none!"
    the Perfect
    and
    are one Perfect and not two;
    nay, are none!
'
function remove_string_line_duplicates() {
    # Split passed strings into lines, remove duplicate lines, and join all
    # remaining lines back into a newline-delimited string. Dismantled, this is:
    #
    # * "f", splitting passed strings into lines.
    # * "u", excluding duplicate lines.
    set_args_to_stdin_if_piped
    die_unless_args 'expected at least one string'
    print_string_newlined "${(uf)*}"   # this... this is ridiculous
}

# --------------------( WASTELANDS                         )--------------------
#   append_stdin_piped_to_args
    # Validate passed arguments, treating piped input as the passed string.
#   string __error_message__='expected one list name and one string'\
#       __text__ list_name
#   if is_stdin_piped; then
#       die_unless_arg "${__error_message__}"
#       set_string_to_stdin_piped __text__
#       list_name="${1}"
#   else
#       die_unless_args_2 "${__error_message__}"
#       list_name="${1}"
#       __text__="${2}"
#   fi

    # Split such string.
#   set_list_to_evaluation ${list_name} '${(f)__text__}'
#   string text="${1}" line="${2}"
#   is "${text}" == (|*$'\n')"${line}"(|$'\n'*) si
    # Validate passed arguments, treating piped input as the passed string.
#   string text line error_message='expected one string and one line'
#   if is_stdin_piped; then
#       die_unless_arg "${error_message}"
#       set_string_to_stdin_piped text
#       line="${1}"
#   else
#       die_unless_args_2 "${error_message}"
#       text="${1}"
#       line="${2}"
#   fi

#   die_unless_args_2_to_3\
#       'expected one string, one first glob, and optional next glob'
    # Avoid naming the local string "lines" to avoid dynamic scope conflicts
    # with caller lists also named "lines". (O, how this hath bitten me hard.)
#       __text__="$(get_stdin_piped)"
    #FIXME: Can we use a "noop ${(P)list_name::=( ${(f)text} )}"-style
    #technique here? I suspect not, but it does beg the question...
#   die_unless_list "${list_name}"
#   print_string "text: ${text}"
#   eval "${list_name}=( \${(f)__lines__} )"

# string get_first_lines(string text, int last_line_index = 1)
#
# Get the first n lines (defaulting to the first line) from the passed string.
#function get_first_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    get_string_lines "${1}" 1 ${2:-1}
#}

# string get_last_lines(
#   string text, int last_line_index = $(get_string_line_count string))
#
# Get the last n lines (defaulting to the last line) from the passed string.
#function get_last_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    string text="${1}" line_length
#    line_length="$(get_string_line_count "${text}")"
#    get_string_lines "${text}" ${2:-${line_length}} ${line_length}
#}
