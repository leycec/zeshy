#!/usr/bin/env zsh
# ====================[ line                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle newline-delimited strings.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_string_line(string text, string line)

Return success if the passed string contains the passed line: e.g.,

.is_string_line()
==========================================
[source]
------------------------------------------
>>> string on_right_causes="
...     Don't look for media-approved ideologically sound Right Causes where
...     there are none. Look out of the window instead, and do something about
...     what you see there."
>>> is_string_line "${on_right_causes}" "what you see there." or\
...     print "Never trust anything that bleeds for four days but doesn't die."
------------------------------------------
==========================================
________________<heredoc?>________________
function is_string_line() {
    # Validate passed arguments, treating piped input as the passed string.
    prepend_args_with_stdin_if_piped
    die_unless_args_2 'expected one string and one line'

    # Attempt to match such line. Dismantled, this is:
    #
    # * "(|*...)", matching either the start of the string or a newline.
    # * "(|...*)", matching either the end of the string or a newline.
    is "${1}" ==\
        (|*${ZESHY_ASCII_NEWLINE})"${2}"(|${ZESHY_ASCII_NEWLINE}*) si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_line(string text, integer line_number)

Get the line with the passed (possibly negative) 1-based line number from the
passed string: e.g.,

.get_string_line()
==========================================
[source]
------------------------------------------
>>> string on_commercial_culture="
...     This is what we wanted. It must have been. Because we all had the
...     fucking choice, didn't we? It is only our money that allows commercial
...     culture to flower. If we didn't want to live like this, we could have
...     changed it any time, by not paying for it. So let's celebrate by all
...     going out and buying the same burger."
>>> get_string_line "${on_commercial_culture}" -1
going out and buying the same burger
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_line() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one line number'
    string text="${1}" line_number=${2} glob_line
    die_unless_integer_nonzero "${line_number}"

    # If such line number is positive, get such line by matching without
    # capturing the required number of prior newlines and then capturing the
    # next line into ${match[1]}. (This is more efficient than list splitting.)
    (( line_number > 0 )) {
        # Glob matching a single line.
        glob_line="[^${ZESHY_ASCII_NEWLINE}]#"

        # Match the desired line or throw an exception if no such line exists.
        is_string_glob_matches\
            (${glob_line}${ZESHY_ASCII_NEWLINE})(#c${line_number})${ZESHY_GLOB_CAPTURE_GROUPS}(${glob_line})* or
            die "string \"$(truncate_string_for_exception_message "${text}")\" contains no line ${line_number}"
        #FIXME: We replicate the above truncate_string() behavior on numerous
        #exceptions. Replace with calls to a new
        #function truncate_string_for_exception_message().

        # Get such line.
        return_string "${match[1]}"
    # Else, such line number is negative. Applying the prior technique would
    # require first counting the number of lines in such string and then
    # converting the passed line number from negative to positive, reducing the
    # efficiency of such technique. Instead, just split such list.
    } else {
        # Split such string into lines.
        list lines; set_list_to_string_lines lines "${1}"
        die_unless_list_index lines "${line_number}"

        # Get such line.
        return_string "${lines[${line_number}]}"
    }
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string get_string_lines(
    string text, integer start_line_number, integer end_line_number)

Get all lines inclusively between the passed (possibly negative) 1-based line
numbers from the passed string: e.g.,

.get_string_lines()
==========================================
[source]
------------------------------------------
>>> string on_monoculture="
...     That's what a monoculture is. It's everywhere, and it's all the same.
...     And it takes up alien cultures and digests them and shits them out in a
...     homogenous building-block shape that fits seamlessly into the vast blank
...     wall of the monoculture. This is the future. This is what we built."
>>> get_string_lines "${on_monoculture}" -2 -1
homogenous building-block shape that fits seamlessly into the vast blank
wall of the monoculture. This is the future. This is what we built.
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_lines() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one start line number, and one end line number'
    string line_number_start="${2}" line_number_end="${3}"

    # Split such string into lines. While this certainly could be implemented by
    # glob matching as under get_string_line(), it's uncertain whether that
    # would actually be any faster than this.
    list lines; set_list_to_string_lines lines "${1}"
    die_unless_list_range lines "${line_number_start}" "${line_number_end}"

    # Join the desired lines back into a string. Do *NOT* quote such expansion.
    join_strings_on_newline ${lines[${line_number_start},${line_number_end}]}
}

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_line_count(string text1, string text2, ...)

Get the total number of lines in the passed strings: e.g.,

.get_string_line_count()
==========================================
[source]
------------------------------------------
>>> string on_presidential_candidates="
...     I always thought people were essentially bright. Distracted, sure, and
...     weak, and beaten, but never stupid. And then you show them, here's the
...     two people who want to be president. One is evil, but you can deal with
...     him, because he actually harbors beliefs. The other one will tell any
...     lie, wear any mask, to become president, and not only that, he fucking
...     hates you, and he's doing this just so he can make your lives hell. And
...     who do you think they vote for? Stupid."
>>> get_string_line_count "${on_presidential_candidates}"
7
------------------------------------------
==========================================

________________<heredoc?>________________
function get_string_line_count() {
    die_unless_args 'expected at least one string'
    list lines; lines=( "${(f)*}" )
    get_list_size lines
}

# ....................{ NUMBERERS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string number_string_lines(string text)

Prefix each line of the passed string with that line's number.
________________<heredoc?>________________
function number_string_lines() {
    output_string "${@}" |
        run_command_with_options ZESHY_NL_OPTIONS 'run_command_paged command nl'
}

#FIXME: Rename to number_string_lines_highlighting_line().
declare_function_with_stdin <<'________________<heredoc?>________________'
string number_string_lines_highlighting(
    string text, integer highlight_line_index)

Prefix each line of the passed string with that line's number and highlight
the passed line number. Since `nl` supports no highlighting, this function
accepts no `nl`-specific options.
________________<heredoc?>________________
function number_string_lines_highlighting() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one line number'
    string text="${1}" line_index="${2}"
    die_if_string_empty "${text}"
    die_unless_integer_positive "${line_index}"

    #FIXME: Actually, it's trivial to convert negative to positive line numbers.
    # Validate passed arguments. Negative line numbers are impermissible.
    integer line_count; line_count="$(get_string_line_count "${text}")"
#   print_message "line length: ${line_count}"
    (( 1 <= line_index && line_index <= line_count )) or
        die "line number ${line_index} not in [1, ${line_count}]"

    # Number lines.
    print_string "${text}" | awk -vNRHI=${line_index} '
# If any line other than the highlight line, print the current line number
# followed by the line.
NR != NRHI { printf("%6d%7s%s\n", NR, "", $0) }
# If the highlight line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (See curse_call_stack() for similar logic.)
NR == NRHI {
    # Number of digits in the current line number.
    NRLEN = length(NR);
         if (NRLEN==1) {NRNOW = " <-~ " NR}
    else if (NRLEN==2) {NRNOW = "<-~ " NR}
    else if (NRLEN==3) {NRNOW = "<- " NR}
    else               {NRNOW = NR}       # if true, your string is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}'
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string remove_string_line_duplicates(string text1, string text2, ...)

Remove all duplicate lines from the concatenation of the passed strings.
Unlike conventional solutions (e.g., `sort -u`, `sort | uniq -u`), this
function preserves the line order of returned lines: e.g.,

.remove_string_line_duplicates()
==========================================
[source]
------------------------------------------
>>> remove_string_line_duplicates "
...   the Perfect
...   and
...   the Perfect
...   are one Perfect
...   and not two;
...   nay, are none!"
the Perfect
and
are one Perfect
and not two;
nay, are none!
------------------------------------------
==========================================
________________<heredoc?>________________
function remove_string_line_duplicates() {
    # Split passed strings into lines, remove duplicate lines, and join all
    # remaining lines back into a newline-delimited string. Dismantled, this is:
    #
    # * "f", splitting passed strings into lines.
    # * "u", excluding duplicate lines.
    set_args_to_stdin_if_piped
    die_unless_args 'expected at least one string'
    join_strings_on_newline "${(uf)*}"    # this... this is ridiculous
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_lines(string text, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH}: e.g.,

.for_string_lines()
==========================================
[source]
------------------------------------------
>>> string little_man="
...     Because you have no memory for things that happened ten or twenty years
...     ago, you're still mouthing the same nonsense as two thousand years ago.
...     Worse, you cling with might and main to such absurdities as 'race,'
...     'class,' 'nation,' and the obligation to observe a religion and repress
...     your love."
>>> for_string_lines "${little_man}"\
...     'is_string_glob_matches "${MATCH}" *'you '* and output_string ${MATCH}'
Because you have no memory for things that happened ten or twenty years
Worse, you cling with might and main to such absurdities as 'race,'
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_lines() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one command'
    string text="${1}" command="${2}"

    # Currently matched line.
    string MATCH

    # If the string is sufficiently short, splitting such string on newlines
    # into a list of string lines *BEFORE* iterating such lines more
    # efficient than dynamically iterating PCRE line matches. While the latter
    # avoids both the space and time costs of splitting a string into a list,
    # the cost of PCRE line matching overwhelms such costs on "short" strings.
    #
    # Pending further tests, consider strings under 16KB to be short.
    if (( "${#text}" <= 16000 )) {
        # Split such string into lines and iterate such lines. For efficiency,
        # inline such splitting, evaluate the loop once rather than
        # on each loop iteration, and capture each line to ${MATCH}.
        eval "for MATCH (\"\${(f)text}\") {
            ${command}
        }"
    # Else, dynamically iterate PCRE line matches.
    } else {
        # PCRE matching implicitly captures each match (i.e., line) to ${MATCH}.
        for_string_pcre_multiline_matches "${text}" '^.*$' "${command}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    # While splitting such string into a list of lines and then indexing such
    # list by such number is certainly feasible, it's also rather inefficient.
    # Instead, get such line by matching without capturing the required number
    # of prior newlines and then capturing the next line into ${match[1]}.
#   get_string_lines "${1}" ${line_index} ${line_index}
#If positive, this is the nth line from the beginning starting at 1. Conversely
#if negative, this is the nth line from the end starting at -1.
#, such that:
#
#* Such line is preceded either by a newline or the start of such string.
#* Such line is followed either by a newline or the end of such string

#...     You had your choice between soaring to superhuman heights with Nietzsche
#...     and sinking into subhuman depths with Hitler. You shouted Heil! Heil!
#...     and chose the subhuman. You had the choice between Lenin's truly
#...     democratic constitution and Stalin's dictatorship. You chose Stalin's
#...     dictatorship... You had your choice between Marx's insight into the
#...     productivity of your living labor power, which alone creates the value
#...     of commodities and the idea of the State. You forgot the living energy
#...     of your labor and chose the idea of the State. In the French Revolution,
#...     you had your choice between the cruel Robespierre and the great Danton.
#...     You chose cruelty and sent greatness and goodness to the guillotine. In
#...     Germany you had your choice between Goring and Himmler on the one hand
#...     and Liebknecht, Landau, and Muhsam on the other. You made Himmler your
#...     police chief and murdered your great friends. You had your choice
#...     between Julius Streicher and Walter Rathenau. You murdered Rathenau. You
#...     had your choice between Lodge and Wilson. You murdered Wilson. You had
#...     your choice between the cruel Inquisition and Galileo's truth. You
#...     tortured and humiliated the great Galileo, from whose inventions you are
#...     still benefiting, and now, in the twentieth century, you have brought
#...     the methods of the Inquisition to a new flowering."
# for use by such command
#   append_stdin_piped_to_args
    # Validate passed arguments, treating piped input as the passed string.
#   string __error_message__='expected one list name and one string'\
#       __text__ list_name
#   if is_stdin_piped; then
#       die_unless_arg "${__error_message__}"
#       set_string_to_stdin_piped __text__
#       list_name="${1}"
#   else
#       die_unless_args_2 "${__error_message__}"
#       list_name="${1}"
#       __text__="${2}"
#   fi

    # Split such string.
#   set_list_to_evaluation ${list_name} '${(f)__text__}'
#   string text="${1}" line="${2}"
#   is "${text}" == (|*$'\n')"${line}"(|$'\n'*) si
    # Validate passed arguments, treating piped input as the passed string.
#   string text line error_message='expected one string and one line'
#   if is_stdin_piped; then
#       die_unless_arg "${error_message}"
#       set_string_to_stdin_piped text
#       line="${1}"
#   else
#       die_unless_args_2 "${error_message}"
#       text="${1}"
#       line="${2}"
#   fi

#   die_unless_args_2_to_3\
#       'expected one string, one first glob, and optional next glob'
    # Avoid naming the local string "lines" to avoid dynamic scope conflicts
    # with caller lists also named "lines". (O, how this hath bitten me hard.)
#       __text__="$(get_stdin_piped)"
    #FIXME: Can we use a "noop ${(P)list_name::=( ${(f)text} )}"-style
    #technique here? I suspect not, but it does beg the question...
#   die_unless_list "${list_name}"
#   print_string "text: ${text}"
#   eval "${list_name}=( \${(f)__lines__} )"

# string get_first_lines(string text, int last_line_index = 1)
#
# Get the first n lines (defaulting to the first line) from the passed string.
#function get_first_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    get_string_lines "${1}" 1 ${2:-1}
#}

# string get_last_lines(
#   string text, int last_line_index = $(get_string_line_count string))
#
# Get the last n lines (defaulting to the last line) from the passed string.
#function get_last_lines() {
#    die_unless_args_1_to_2\
#        'expected one string and optional last line number'
#    string text="${1}" line_length
#    line_length="$(get_string_line_count "${text}")"
#    get_string_lines "${text}" ${2:-${line_length}} ${line_length}
#}
