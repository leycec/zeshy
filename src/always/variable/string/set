#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string setters (i.e., functions setting string variables).

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_string_to_string(string string_name, string text)

Set the passed variable to the passed string: e.g.,

.set_string_to_string()
==========================================
[source]
------------------------------------------
>>> string machine_elf="tyke" tyke
>>> set_string_to_string "${machine_elf}" "self-transforming basketball"
>>> print_string "${tyke}"
self-transforming basketball
------------------------------------------
==========================================
________________<heredoc?>________________
function set_string_to_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one string'
    string string_name__ssts="${1}"
    die_unless_variable_string "${string_name__ssts}"

    # Set such string.
    noop ${(P)string_name__ssts::=${2}}
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_string_if_empty_to_string(string string_name, string text)

Set the passed variable if unset or empty to the passed string: e.g.,

.set_string_if_empty_to_string()
==========================================
[source]
------------------------------------------
>>> string fifty_fourth_fragment="heraclitis" heraclitis=""
>>> set_string_if_empty_to_string "${fifty_fourth_fragment}" "Aeon"
>>> print_string "${fifty_fourth_fragment}"
Aeon
------------------------------------------
==========================================
________________<heredoc?>________________
function set_string_if_empty_to_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one string'
    string string_name__ssiets="${1}"
    die_unless_variable_string "${string_name__ssiets}"

    # Set such string.
    noop ${(P)string_name__ssiets:=${2}}
}

# ....................{ SETTERS ~ evaluation               }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_string_to_evaluation(string string_name, string expression)

Set the passed string to the dynamic evaluation of the passed expression in a
double-quoted context (i.e., as "${expression}"): e.g.,

.set_string_to_evaluation()
==========================================
[source]
------------------------------------------
>>> cat /six/times
get up seven.
>>> string fall_down="prieur" prieur
>>> set_string_to_evaluation "${fall_down}" '$(cat /six/times)'
>>> print_string "${prieur}"
get up seven.
------------------------------------------
==========================================
________________<heredoc?>________________
function set_string_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name__sste="${1}"
    die_unless_variable_string "${string_name__sste}"

    # Set such string.
    eval "${string_name__sste}=\"${2}\""
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_string_if_empty_to_evaluation(
    string string_name, string expression)

Set the passed string if unset or empty to the dynamic evaluation of the
passed expression in a double-quoted context (i.e., as "${expression}"): e.g.,

.set_string_if_empty_to_evaluation()
==========================================
[source]
------------------------------------------
>>> cat /buddha
Three pounds of flax.
>>> string what_is_the="tozan" tozan
>>> set_string_if_empty_to_evaluation "${what_is_the}" '$(cat /buddha)'
>>> print_string "${tozan}"
Three pounds of flax.
------------------------------------------
==========================================
________________<heredoc?>________________
function set_string_if_empty_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name__ssiete="${1}"
    die_unless_variable_string "${string_name__ssiete}"

    # Set such string.
    eval "noop \${(P)string_name__ssiete:="${2}"}"
}

# ....................{ SETTERS ~ separator                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_strings_to_string_split_on_string(
    string string_name1, string string_name2, string text, string delimiter)

Split the substring of the passed string preceding the first instance of the
passed delimiter into the first passed list and the remainder (excluding the
passed delimiter) into the second passed list. Such delimiter may be of any non-
zero length. If such string contains no such delimiter, throw an exception:
e.g.,

.set_strings_to_string_split_on_string()
==========================================
[source]
------------------------------------------
>>> string pre suf
>>> set_strings_to_string_split_on_string pre suf "wol==hea==soc" "=="
>>> print "prefix: ${pre}\nsuffix: ${suf}"
prefix: wol
suffix: hea==soc
------------------------------------------
==========================================
________________<heredoc?>________________
function set_strings_to_string_split_on_string() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one prefix name, one suffix name, one string, and one delimiter'
    string\
        prefix_name__sstspod="${1}"\
        suffix_name__sstspod="${2}"\
        text__sstsps="${3}"\
        separator__sstsps="${4}"
    die_unless_variable_string "${prefix_name__sstsps}"
    die_unless_variable_string "${suffix_name__sstsps}"
    die_unless_string_nonempty "${separator__sstsps}" 'no separator passed'

    # If such string contains no such delimiter, throw an exception.
    is_string_contains "${text__sstsps}" "${separator__sstsps}" or
        die "\"${text__sstsps}\" contains no separator \"${separator__sstsps}\""

    #FIXME: Conjoin into a single "//"-style match enabling "(#b)" to capture
    #the two groups, then set such strings with such groups. This also helps to
    #rid us of the unwieldy test above, assuming we detect such match failing
    #with non-zero exit status.
    #FIXME: Just use single "#" with "(#b)". See set_list_to_string_piped().
    # Split such string.
    set_string_to_string "${prefix_name__sstsps}" "${text__sstsps%%${separator__sstsps}*}"
    set_string_to_string "${suffix_name__sstsps}" "${text__sstsps#*${separator__sstsps}}"
}
# --------------------( WASTELANDS                         )--------------------
