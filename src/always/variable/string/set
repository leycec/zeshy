#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *string setters* (i.e., functions setting string variables).
-/-

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_string_to_string(string string_name, string text)

Set the passed string variable to the passed string: e.g.,

.set_string_to_string()
==========================================
[source]
------------------------------------------
>>> string on_the_spirit_molecule on_the_mundane_plane=\
...    "There's this feeling which comes over your body: half arousal, half
...     anaesthesia. The air appears to suddenly have been sucked out of the
...     room because all the colors brighten visibly, as though some intervening
...     medium has been removed. And then there's a sound, like a piece of bread
...     wrapper or cellophane being scrunched up and thrown away. A friend of
...     mine says this is radio-entelechy leaving the anterior fontanelle at the
...     top of your head. I'm not sure I want to line up with that, but a
...     membrane is being ripped; something is being torn. And then there is a
...     total – what Mircea Eliade called in a wonderful phrase – \"a complete
...     rupture of the mundane plane.\" You know? That's like a hit and run
...     accident except the car came from hyperspace."
>>> set_string_to_string on_the_spirit_molecule "${on_the_mundane_plane}"
>>> get_string_line "${on_the_spirit_molecule}" -1
accident except the car came from hyperspace.
------------------------------------------
==========================================
/---
function set_string_to_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one string'
    string string_name__ssts="${1}"
    die_unless_variable_string "${string_name__ssts}"

    # Set such string.
    noop ${(P)string_name__ssts::=${2}}
}

declare_function_with_stdin <<'/---'
void set_string_if_empty_to_string(string string_name, string text)

Set the passed string variable if unset or empty to the passed string: e.g.,

.set_string_if_empty_to_string()
==========================================
[source]
------------------------------------------
>>> string on_dmt on_the_chrysanthemum=\
...    "A complete rupture of the mundane plane. And you fall back into this
...     hallucinogenic space. And what you see is a slowly rotating red and
...     orange kind of thing, which over the years we've nicknamed \"The
...     Chrysanthemum.\" And this represents some kind of disequilibrium state
...     that has its roots in the synapses. What's happening as you're watching
...     this Chrysanthemum is that millions and then hundreds of millions of
...     DMT molecules are rushing into these serotonin bond sites in the
...     synaptic cleft and disrupting the serotonin and switching the electron
...     spin resonance signature of these neural junctions in this \"other\"
...     direction... And then, if you've taken enough DMT, something happens
...     for which there are no words. A membrane is rent, and you are propelled
...     into this \"place.\" And language cannot describe it accurately.
...     Therefore I will inaccurately describe it. The rest is now lies."
>>> set_string_if_empty_to_string "${on_dmt}" "${on_the_chrysanthemum}"
>>> get_string_line "${on_dmt}" 1
A complete rupture of the mundane plane. And you fall back into this
------------------------------------------
==========================================
/---
function set_string_if_empty_to_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string name and one string'
    string string_name__ssiets="${1}"
    die_unless_variable_string "${string_name__ssiets}"

    # Set such string.
    noop ${(P)string_name__ssiets:=${2}}
}

# ....................{ SETTERS ~ evaluation               }....................
declare_function_with_stdin <<'/---'
void set_string_to_evaluation(string string_name, string expression)

Set the passed string variable to the dynamic evaluation of the passed
expression in a *double-quoted context* (i.e., as `"${expression}"`): e.g.,

.set_string_to_evaluation()
==========================================
[source]
------------------------------------------
>>> string on_tykes on_elves=\
...    "You burst into this space. It's lit, socketed lighting, some kind of
...     indirect lighting you can't quite locate. But what is astonishing and
...     immediately riveting is that in this place there are entities. There
...     are these things, which I call \"self-transforming machine elves.\" I
...     also call them \"self-dribbling basketballs.\" They are, but they are
...     none of these things. I mean, you have to understand: these are
...     metaphors in the truest sense, meaning they're lies! It's a jeweled
...     self-transforming basketball, a machine elf. I name them \"Tykes\",
...     because tyke is a word that means to me a small child. And I was
...     fascinated by the 54th fragment of Heraclitis where he says: \"The
...     Aeon is a child at play with colored balls." And when you burst into the
...     DMT space, this is the Aeon: it's a child, and it's at play with colored
...     balls, and I am in eternity, apparently, in the presence of this thing."
>>> set_string_to_evaluation "${on_tykes}" '$(output_string "'${on_elves}'")'
>>> get_string_line "${on_tykes}" -1
balls, and I am in eternity, apparently, in the presence of this thing.
------------------------------------------
==========================================
/---
function set_string_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name__sste="${1}"
    die_unless_variable_string "${string_name__sste}"

    # Set such string.
    eval "${string_name__sste}=\"${2}\""
}

declare_function_with_stdin <<'/---'
void set_string_if_empty_to_evaluation(
    string string_name, string expression)

Set the passed string variable if unset or empty to the dynamic evaluation of
the passed expression in a double-quoted context. See set_string_to_evaluation()
for further details: e.g.,

.set_string_if_empty_to_evaluation()
==========================================
[source]
------------------------------------------
>>> string on_the_lesser_lights_of_the_bardo on_faberge_eggs=\
...    "And then they proceed to sing objects into existence. Amazing objects.
...     Objects that are Fabergé Eggs. Things made of pearl, and metal, and
...     glass, and gel, and you. When you're shown one of these things, a single
...     one of them, you look at it. And you know without a shadow of a doubt,
...     in the moment of looking at this thing, that if it were right here,
...     right now, this world would go mad. It's like something from another
...     dimension. It's like an artifact from a flying saucer. It's like
...     something falling out of the mind of God. Such objects do not exist in
...     this universe. And yet you're looking at it. And they're clamoring for
...     your attention. \"Look at this! Look at this! Look at THIS!\" And they
...     pull these things. And each one, you look into it and it begins to open
...     into this wonder that you must fight. You say: \"No, don't look at it!
...     Look away from it! Because it's so wonderful that it's swamping my
...     objectivity and destroying my ability to function in this space.\""
>>> set_string_if_empty_to_evaluation "${on_the_lesser_lights_of_the_bardo}"\
...     '$(output_string "'${on_faberge_eggs}'")'
>>> get_string_line "${on_the_lesser_lights_of_the_bardo}" 1
And then they proceed to sing objects into existence. Amazing objects.
------------------------------------------
==========================================
/---
function set_string_if_empty_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name__ssiete="${1}"
    die_unless_variable_string "${string_name__ssiete}"

    # Set such string.
    eval "noop \${(P)string_name__ssiete:="${2}"}"
}

declare_function_with_stdin <<'/---'
void set_string_if_unset_to_evaluation(
    string string_name, string expression)

Set the passed string variable if unset to the dynamic evaluation of the passed
expression in a double-quoted context. See set_string_to_evaluation() for
further details: e.g.,

.set_string_if_unset_to_evaluation()
==========================================
[source]
------------------------------------------
>>> string on_the_lesser_lights_of_the_bardo on_faberge_eggs=\
...    ""
>>> set_string_if_empty_to_evaluation "${on_the_lesser_lights_of_the_bardo}"\
...     '$(output_string "'${on_faberge_eggs}'")'
>>> get_string_line "${on_the_lesser_lights_of_the_bardo}" 1
And then they proceed to sing objects into existence. Amazing objects.
------------------------------------------
==========================================
/---
function set_string_if_unset_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one statement'
    string string_name__ssiute="${1}"
    die_unless_variable_string "${string_name__ssiute}"

    # Set such string.
    eval "noop \${(P)string_name__ssiute="${2}"}"
}

# ....................{ SETTERS ~ separator                }....................
declare_function_with_stdin <<'/---'
void set_strings_to_string_split_on_string(
    string string_name1, string string_name2, string text, string delimiter)

Split the substring of the passed string preceding the first instance of the
passed delimiter into the first passed list and the remainder (excluding the
passed delimiter) into the second passed list. Such delimiter may be of any non-
zero length. If such string contains no such delimiter, throw an exception:
e.g.,

.set_strings_to_string_split_on_string()
==========================================
[source]
------------------------------------------
>>> string pre suf
>>> set_strings_to_string_split_on_string pre suf "wol==hea==soc" "=="
>>> print "prefix: ${pre}\nsuffix: ${suf}"
prefix: wol
suffix: hea==soc
------------------------------------------
==========================================
/---
function set_strings_to_string_split_on_string() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one prefix name, one suffix name, one string, and one delimiter'
    string\
        prefix_name__sstspod="${1}"\
        suffix_name__sstspod="${2}"\
        text__sstsps="${3}"\
        separator__sstsps="${4}"
    die_unless_variable_string "${prefix_name__sstsps}"
    die_unless_variable_string "${suffix_name__sstsps}"
    die_unless_string_nonempty "${separator__sstsps}" 'no separator passed'

    # If such string contains no such delimiter, throw an exception.
    is_string_contains "${text__sstsps}" "${separator__sstsps}" or
        die "\"${text__sstsps}\" contains no separator \"${separator__sstsps}\""

    #FIXME: Conjoin into a single "//"-style match enabling "(#b)" to capture
    #the two groups, then set such strings with such groups. This also helps to
    #rid us of the unwieldy test above, assuming we detect such match failing
    #with non-zero exit status.
    #FIXME: Just use single "#" with "(#b)". See set_list_to_stdin().
    # Split such string.
    set_string_to_string "${prefix_name__sstsps}" "${text__sstsps%%${separator__sstsps}*}"
    set_string_to_string "${suffix_name__sstsps}" "${text__sstsps#*${separator__sstsps}}"
}

# --------------------( WASTELANDS                         )--------------------
#>>> cat /buddha
#Three pounds of flax.
#>>> string what_is_the="tozan" tozan
#>>> set_string_if_empty_to_evaluation "${what_is_the}" '$(cat /buddha)'
#>>> print_string "${tozan}"
#Three pounds of flax.

#...    "A membrane is rent, and you are propelled into this place. And language
#...     cannot describe it accurately. Therefore I will inaccurately describe
#...     it. (The rest is now lies.) When you break into this space, you have
#...     several impressions simultaneously that are a kind of gestalt. First of
#...     all (and why, I don't know) you have the impression that you are
#...     underground - far underground. You can't say why, but there's just this feeling of immense weight above you but you're in a large space, a vaulted dome. People even call it "The DMT dome" I have said, had people say to me, "Have you been under the dome?" and I knew exactly what they meant. "
#
#And this is taking, you know, 30 or 40 seconds, and there's this rising
#...     hum, this ____nnnmmmmmMMMMMMMM^^^^^ That rising tone: the flying saucer
#...     tone of Hollywood B movies! You actually hear this thing. And then, if
#...     you've taken enough DMT – and it has to do entirely with physical
#...     capacity (\"Did you take, did you cross the threshold?\") – something
#...     happens for which there are no words. 
