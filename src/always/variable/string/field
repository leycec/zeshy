#!/usr/bin/env zsh
# ====================[ field                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *string fields* (i.e., substrings split from their parent string
# according to ${IFS}- rather than `zsh`-based string splitting rules).

# ....................{ GETTERS ~ count                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_string_field_count(string text1, string text2, ...)

Get the number of fields split on the current internal field separator ${IFS}
from the passed strings. Assuming ${IFS} retains its default value of all ASCII
whitespace characters, this counts the number of ``words'' (in the conventional
English sense) in such strings: e.g.,

.get_string_field_count()
==========================================
[source]
------------------------------------------
>>> string on_american_heresy="
...     \"Timothy Leary spent five years in prison for unorthodox scientific
...     ideas. Ezra Pound spent 13 years in a nuthouse for unorthodox political
...     and economic ideas. Their books were not burned. Reich was not only
...     thrown in prison, but they chopped up all the scientific equipment in
...     his laboratory with axes and burned all of his books in an
...     incinerator.\""
>>> get_string_field_count "${on_american_heresy}"
59
------------------------------------------
==========================================
________________<heredoc?>________________
function get_string_field_count() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_fields(string text, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each field of such line split on the current
internal field separator ${IFS} into an element of list global ${match}.
Assuming ${IFS} retains its default value of all ASCII whitespace characters,
each such field will be a ``word'' in the conventional English sense. See
for_string_line_fields_split_on_ifs() for further details: e.g.,

.for_string_line_fields()
==========================================
[source]
------------------------------------------
>>> string on_thralldom="
...     Just see these superfluous ones! Wealth they acquire and become poorer
...     thereby. Power they seek for, and above all, the lever of power, much
...     money — these impotent ones! See them clamber, these nimble apes! They
...     clamber over one another, and thus scuffle into the mud and the abyss.
...     Towards the throne they all strive: it is their madness — as if
...     happiness sat on the throne! Ofttimes sitteth filth on the throne. — and
...     ofttimes also the throne on filth."
>>> for_string_line_fields "${on_thralldom}" 'output_string "${match[-1]}"'
poorer
much
They
abyss,
if
and
filth.
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_fields() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one internal field separators string, and one command'
    string text="${1}" ifs="${2}" command="${3}"

    # Words split from the currently matched line.
    list match

    # Iterate lines, splitting fields from the current line ${MATCH} into the
    # list of fields ${match}. Since parameter flag "(z)" does not by definition
    # respect ${IFS}, defer to "=" instead.
    for_string_lines "${text}" "match=( \${=MATCH} ); ${command}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_fields_split_on_ifs(
    string text, string ifs, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each field of such line into an element of list
global ${match}. Split such fields on any substring of one or more whitespace
characters _or_ one non-whitespace character between zero or more whitespace
characters defined by the passed internal field separators (IFS). See ``IFS''
under `man zshparam` for further details: e.g.,

.for_string_line_fields_split_on_ifs()
==========================================
[source]
------------------------------------------
>>> string on_philip_k_dick="
...     One time, when I was researching Gnosticism in the Britannica, I came
...     across mention of a Gnostic codex called \"The Unreal God and the
...     Aspects of His Nonexistent Universe,\" an idea which reduced me to
...     helpless laughter. What kind of person would write about something that
...     he knows doesn't exist, and how can something that doesn't exist have
...     aspects? But then I realized that I'd been writing about these matters
...     for over twenty-five years."
>>> for_string_line_fields_split_on_ifs "${on_philip_k_dick}" ','\
...     '(( $(get_list_size match) > 1 )) and output_string "${match[1]}"'
One time
Aspects of His Nonexistent Universe
he knows doesn't exist
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_fields_split_on_ifs() {
    # Validate passed arguments.
    die_unless_args_3 'expected one string, one IFS, and one command'
    string ifs="${2}"
    die_unless_string_nonempty "${ifs}" 'non-empty IFS expected'

    # Iterate such fields.
    IFS="${ifs}" for_string_line_fields "${1}" "${2}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_fields_split_on_whitespace(string text, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each field of such line split on whitespace into
an element of list global ${match}. Each such field will be a ``word'' in the
conventional English sense. See for_string_line_fields_split_on_ifs() for
further details: e.g.,

.for_string_line_fields_split_on_whitespace()
==========================================
[source]
------------------------------------------
>>> string on_spending_time=\
...    "This spending of the best part of one's life earning money in order to
...     enjoy a questionable liberty during the least valuable part of it
...     reminds me of the Englishman who went to India to make a fortune first,
...     in order that he might return to England and live the life of a poet. He
...     should have gone up garret at once. \"What!\" exclaim a million Irishmen
...     starting up from all the shanties in the land, \"is not this railroad
...     which we have built a good thing?\" Yes, I answer, comparatively good,
...     that is, you might have done worse; but I wish, as you are brothers of
...     mine, that you could have spent your time better than digging in this
...     dirt."
>>> for_string_line_fields_split_on_whitespace "${on_spending_time}"\
...     'output_string "${match[-1]}"'
to
it
first,
He
Irishmen
railroad
good,
of
this
dirt.
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_fields_split_on_whitespace() {
    die_unless_args_2 'expected one string and one command'
    for_string_line_fields_split_on_ifs "${1}" "${ZESHY_IFS_DEFAULT}" "${2}"
}

# ....................{ ITERATORS ~ string                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_fields_split_on_character(
    string text, character separator, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each field of such line split on the passed
separator character into an element of list global ${match}: e.g.,

.for_string_line_fields_split_on_character()
==========================================
[source]
------------------------------------------
>>> string on_wilhelm_reich="
...     He had a great capacity to arouse irrational hatred obviously, and
...     that's because his ideas were radical in the most extreme sense of the
...     word \"radical.\" His ideas have something to offend everybody, and he
...     ended up becoming the only heretic in American history whose books were
...     literally burned by the government."
>>> for_string_line_fields_split_on_character "${on_wilhelm_reich}" ','\
...     '(( $(get_list_size match) == 2 )) and output_string "${match[2]}"'
 and
 and he
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_fields_split_on_character() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one field separator character, and one command'
    string separator="${2}"
    die_unless_character "${separator}"

    # Iterate such fields. Since such separator is a single character, a
    # corresponding parameter expansion token necessarily exists, rendering the
    # token-based splitting this call performs inherently reliable.
    for_string_line_fields_split_on_string "${1}" "${separator}" "${3}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_string_line_fields_split_on_string(
    string text, string separator, string command)

Run the passed command for each line of the passed string, capturing such line
into string global ${MATCH} and each field of such line split on the passed
separator string into an element of list global ${match}: e.g.,

.for_string_line_fields_split_on_string()
==========================================
[source]
------------------------------------------
#>>> string on_national_bankruptcy="
...      As the United States goes bankrupt trying to maintain its global
...      empire, and industrial civilization as a whole slides down the far side
...      of a dizzying range of depletion curves, it's becoming harder by the
...      day for Americans to make believe that the old saws of upward mobility
...      and an ever brighter future have any relevance to their own lives--and
...      yet those beliefs are central to the psychology, the self-image, and
...      the worldview of most Americans."
>>> for_string_line_fields_split_on_string "${on_national_bankruptcy}" ', '\
...     '(( $(get_list_size match) >= 2 )) and output_string "${match[2]}"'
and industrial civilization as a whole slides down the far side
it's becoming harder by the
the self-image
------------------------------------------
==========================================
________________<heredoc?>________________
function for_string_line_fields_split_on_string() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one field separator character, and one command'
    string text="${1}" separator="${2}" command="${3}" token
    die_unless_character "${separator}"

    # Parameter expansion token specific to such separator, if such token
    # exists. If such token does not exist, this implicitly throws an exception,
    # which we propagate by failing to catch such exception. Since there exists
    # no comparable efficient alternative to such splitting, this is the best to
    # be done. (The only alternative to such splitting remains
    # for_string_line_fields_split_on_pcre_bounded(), which while moderately
    # efficient requires the number of fields in each string line be bound by
    # some maxima. Since the manner of field splitting implemented here suffers
    # no such restriction, there is no comparable efficient alternative.)
    token="$(get_string_parameter_expansion_token_if_found "${separator}")"

    # Words split from the currently matched line.
    list match

    # Iterate lines, splitting fields from the current line ${MATCH} into the
    # list of fields ${match}. See set_list_to_string_split_on_string() for
    # further details.
    for_string_lines "${text}"\
        "match=( \${(s${token}${separator}${token})MATCH} ); ${command}"
}

# --------------------( WASTELANDS                         )--------------------
#Assuming the default ${IFS}
#splitting fields on whitespace, this corresponds to the conventional human-
#readable (rather than shell-specific) word count:
    # Parameter expansion token specific to such separator exists. Since such
    # separator is a single character, some such token must exist, rendering
    # token-based splitting reliable (in this case, at least).
#   token="$(get_string_parameter_expansion_token_if_found "${separator}")"

    # Words split from the currently matched line.
#   list match

    # Iterate lines, splitting fields from the current line ${MATCH} into the
    # list of fields ${match}. See set_list_to_string_split_on_string() for
    # further details.
#   for_string_lines "${text}"\
#       "match=( \${(s${token}${separator}${token})MATCH} ); ${command}"
    # Iterate such fields.
#   for_string_line_fields_split_on_ifs\
#       "${text}" "${separator}${separator}" "${command}"

# p _not_ aggregating quoted
#substrings. Hence, this is the conventional English word count: e.g.,
