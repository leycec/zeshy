#!/usr/bin/env zsh
# ====================[ test                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle list testers and exception throwing.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_lists(
    string variable_name1, string variable_name2, ...)

Throw an exception with a stock message unless all passed variables are lists.
________________<heredoc?>________________
function die_unless_lists() {
    die_unless_args 'expected at least one variable name'
    for variable_name__duls ("${@}") die_unless_list "${variable_name__duls}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_list_nonempty(
    string list_name,
    string error_message = "list \"${list_name}\" empty")

Throw an exception with the passed message unless the passed list is nonempty.
See is_list_nonempty() for further details.
________________<heredoc?>________________
function die_unless_list_nonempty() {
    die_unless_args_1_to_2\
        'expected one list name and optional error message'
    string list_name__duln="${1}"
    is_list_nonempty "${list_name__duln}" or
        die "${2:-list \"${list_name__duln}\" empty}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_list_index(
    string list_name, integer index,
    string error_message = "")

Throw an exception with the passed message unless the passed integer indexes the
passed list. See is_list_index() for further details.
________________<heredoc?>________________
function die_unless_list_index() {
    die_unless_args_2_to_3\
        'expected one variable name and optional error message'
    string list_name__duli="${1}" index__duli="${1}"
    is_list_index "${list_name__duli}" "${index__duli}" or {
        integer list_size__duli
        list_size__duli="$(get_list_size "${list_name__dule}")"
        die "${2:-\"${index__duli}\" not a valid index for list \"${list_name__duli}\" of size \"${list_size__duli}\"}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_contains(string list_name, string element)

Return true if the passed list contains the passed element.
________________<heredoc?>________________
function is_list_contains() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one element'
    string list_name__ile="${1}"
    die_unless_list "${list_name__ile}"

    #FIXME: Not necessarily convinced this to be the most efficient method.
    #Shouldn't the following also suffice - possibly more efficient?
    #
    #    (( ${${(@P)list_name__ile}[(ie)${2}]} <= $(get_list_size "${list_name__ile}") ))
    #FIXME: This is extendable into an is_list_contains_match() function
    #by simple expanding ${2} as ${~2} here. Add to "glob", however; not here.
    #Actually... the two should be together, wherever they reside, due to the
    #complexity of implementation. "glob" would be an appropriate destination,
    #I should think.

    # Find such element. Dismantled, this is:
    #
    # * '@P', expanding to such list.
    # * "${(M)...:#...}", excluding all but such element.
    #
    # Do *NOT* double-quote this parameter expansion. Doing so *ALWAYS* results
    # in the empty string and hence failure. (This is inordinantly odd, but...)
    # As double-quoting is right out, calling is_string_nonempty() is also out.
    # (Unquoted parameters expanding to the empty string expand to no argument,
    # thus inducing is_string_nonempty() to throw an exception.)
#   print "list element matched: ${(M)${(@P)list_name__ile}:#${2}}"
    is -n ${(M)${(@P)list_name__ile}:#${2}} si
}

#FIXME: In lieu of unit tests, this will do.
#function ico() {
#    list z; z=( hmm 'o eu' 3434 67 )
#    is_list_contains z 'o eu' and print 'z contains "o eu"'
#}

# ....................{ TESTERS ~ index                    }....................
#FIXME: Shift to new component "variable/list/index".
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_index(string list_name, integer index)

Return true if the passed index is a non-zero integer bounded by either [-N, -1]
or [1, N], where N is the size of the passed list: e.g.,

.is_list_index()
==========================================
[source]
------------------------------------------
>>> list poe; poe=( the masque of the red death )
>>> is_list_index poe -6 and print "Each man creates his own God for himself,"
Each man creates his own God for himself,
>>> is_list_index poe  0 or  print "He is not my master. Death has no master."
He is not my master. Death has no master.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_list_index() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one index'
    string list_name__ili="${1}" index__ili="${2}"
    die_unless_list "${list_name__ili}"
    die_unless_integer_nonzero "${index__ili}"

    # Get such list's size.
    integer list_size__ili
    list_size__ili="$(get_list_size "${list_name__ili}")"

    # Test such index. For efficiency, avoid calling is_integer_in_range().
    ((  (1 <= index__ili && index__ili <= list_size__ili) ||
        (-list_size__ili <= index__ili && index__ili <= -1) ))
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_range(
    string list_name, integer start_index, integer end_index)

Return true if the passed indices index the passed list and the first such index
is less than or equal to the second such index. To quantify such conditions:

* Let `N` be the size of the passed list.
* Let `X` be the first passed index.
* Let `Y` be the second passed index.
* If `X > 0`, let `X\' = X`; else, let `X\' = N + X + 1`.
* If `Y > 0`, let `Y\' = Y`; else, let `Y\' = N + Y + 1`.

Then this function returns true if the following conditions all hold:

* `1 <= X\'`.
* `X\' <= Y\'`.
* `Y\' <= N`.

For example:

.is_list_indices()
==========================================
[source]
------------------------------------------
>>> list roeg; roeg=( summer is icumen in, loudly sing cuckoo )
>>> is_list_range roeg -4 5 and print "...that here the old gods aren't dead."
...that here the old gods aren't dead.
>>> is_list_range roeg 4 -5 or print "Oh, he's dead. He can't complain."
Oh, he's dead. He can't complain.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_list_range() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one start index, and one end index'
    string\
        list_name__ilis="${1}" start_index__ilis="${2}" end_index__ilis="${3}"
    die_unless_list "${list_name__ilis}"
    die_unless_integer_nonzero "${start_index__ilis}"
    die_unless_integer_nonzero "${end_index__ilis}"

    # Get such list's size.
    integer list_size__ilis
    list_size__ilis="$(get_list_size "${list_name__ilis}")"

    # Convert negative to positive indices.
    ((  start_index__ilis < 0 &&\
        start_index__ilis = list_size__ilis + start_index__ilis + 1 ))
    ((  end_index__ilis < 0 &&\
        end_index__ilis = list_size__ilis + end_index__ilis + 1 ))

    # Test such indices. For efficiency, avoid calling is_integer_in_range().
    ((  1 <= start_index__ili &&\
        start_index__ili <= end_index__ili &&\
        end_index__ili <= list_size__ili ))
}

# ....................{ TESTERS ~ emptiness                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_empty(string list_name)

Return true if the passed list is empty.
________________<heredoc?>________________
function is_list_empty() {
    not  is_list_nonempty "${1}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_nonempty(string variable_name)

Return true if the passed list is nonempty.
________________<heredoc?>________________
function is_list_nonempty() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__iln="${1}"
    die_unless_list "${list_name__iln}"

    # Test such list's size.
    (( $(get_list_size "${list_name__iln}") ))
}

# --------------------( WASTELANDS                         )--------------------
