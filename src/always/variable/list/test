#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle list exceptions and tests.
/---

# ....................{ EXCEPTIONS                         }....................
# See parcel "variable/type" for die_unless_list().

declare_function_with_stdin <<'/---'
void die_unless_lists(string variable_name1, ...)

Throw an exception with a stock message unless all passed variables are lists.
/---
function die_unless_lists() {
    # Validate sanity.
    die_unless_args 'Expected one or more variable names.'

    # Test such variables.
    string variable_name__duls
    for    variable_name__duls ("${@}") {
        die_unless_list "${variable_name__duls}"
    }
}

declare_function_with_stdin <<'/---'
void die_unless_list_nonempty(
    string list_name,
    string error_message = "List \${${list_name}\} empty.")

Throw an exception with the passed message unless the passed list is nonempty.
See is_list_nonempty() for further details.
/---
function die_unless_list_nonempty() {
    die_unless_args_1_to_2\
        'Expected one list name and optional error message.'
    string list_name__duln="${1}"
    is_list_nonempty "${list_name__duln}" or
        die "${2:-List \$\{${list_name__duln}\} empty.}"
}

# ....................{ EXCEPTION ~ index                  }....................
declare_function_with_stdin <<'/---'
void die_unless_list_index(
    string list_name,
    integer index,
    string error_message = "List \$\{${list_name}\} index ${index} invalid.")

Throw an exception with the passed message unless the passed integer indexes the
passed list. See is_list_index() for further details.
/---
function die_unless_list_index() {
    # Validate sanity.
    die_unless_args_2_to_3\
        'Expected one list name, one index, and optional error message.'

    # Test such index.
    is_list_index "${@[1,2]}" or {
        string list_name__duli="${1}" index__duli="${2}"
        integer size__duli; size__duli="$(get_list_size "${list_name__duli}")"
        die "${3:-List \$\{${list_name__duli}\} index ${index__duli} not in [-${size__duli}, ${size__duli}].}"
    }
}

declare_function_with_stdin <<'/---'
void die_unless_list_range(
    string list_name,
    integer start_index,
    integer end_index,
    string error_message = "List \$\{${list_name}\} start index ${index_start__dulr} and end index ${index_end__dulr}] not in [-${size__dulr}, ${size__dulr}].")

Throw an exception with the passed message unless the passed integers
constitute a valid range of indices in the passed list. See is_list_range() for
further details.
/---
function die_unless_list_range() {
    # Validate sanity.
    die_unless_args_3_to_4\
        'Expected one list name, one start index, one end index, and optional error message.'

    # Test such range.
    is_list_range "${@[1,3]}" or {
        string\
            list_name__dulr="${1}"\
            index_start__dulr="${2}"\
            index_end__dulr="${3}"
        integer size__dulr; size__dulr="$(get_list_size "${list_name__dulr}")"
        die "${4:-List \$\{${list_name__dulr}\} start index ${index_start__dulr} and end index ${index_end__dulr}] not in [-${size__dulr}, ${size__dulr}].}"
    }
}

# ....................{ EXCEPTION ~ size                   }....................
#FIXME: *WAY* too specific. Generalize to just accept the desired list size as a
#passed parameter and rename to die_unless_list_size_at_least().
declare_function_with_stdin <<'/---'
void die_unless_list_size_2_or_more(
    string list_name,
    string error_message =
        "List \$\{${list_name}\} contains $(get_list_size "${list_name}") rather than 2 or more elements.")

Throw an exception with the passed message unless the passed list contains at
least two elements.
/---
function die_unless_list_size_2_or_more() {
    # Validate sanity.
    die_unless_args_1_to_2 'Expected one list name and optional error message.'
    string list_name__duls="${1}"
    integer list_size__duls

    # Size of such list.
    list_size__duls="$(get_list_size "${list_name__duls}")"

    # Test such size.
    (( list_size__duls >= 2 )) or
        die "${2:-List \$\{${list_name__duls}\} contains ${list_size__duls} rather than 2 or more elements.}"
}

# ....................{ TESTERS                            }....................
#FIXME: Rename is_list_item() to is_list_element().
declare_function_with_stdin <<'/---'
[status: boolean] {is_list_item, is_list_contains}(
    string list_name, string element)

Return success if the passed list contains the passed element.
/---
function is_list_item is_list_contains() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one element.'
    string list_name__ile="${1}"
    die_unless_list "${list_name__ile}"

    # Test such list. Dismantled, this is:
    #
    # * "(@P)", expanding to such list.
    # * "([(ie)...]", expanding to the first 1-based list index containing such
    #   element or the size of such list if *NOT* containing such element.
    # * "${#...}", expanding to the size of such list. For efficiency, inline
    #   such operation. See get_list_size() for further details.
    #
    # While there exist alternative methods for finding list elements, this is
    # arguably the most reliable and efficient. Alternatives include:
    #
    # * Manually iterating such list. Naturally, this is the slowest.
    # * Testing "is -n ${(M)${(@P)list_name__ile}:#${2}\} si". While faster than
    #   manual iteration, such test cannot distinguish between a nonextant
    #   element and an extent element expanding to the empty string. Such
    #   test is unreliable in the general case.
    (( ${${(@P)list_name__ile}[(ie)${2}]} <= ${#${(@P)list_name__ile}} ))
}

#FIXME: In lieu of unit tests, this will do.
#function ico() {
#    list z; z=( hmm 'o eu' 3434 67 )
#    is_list_contains z 'o eu' and print 'z contains "o eu"'
#}

# ....................{ TESTERS ~ emptiness                }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_list_empty(string list_name)

Return success if the passed list is empty.
/---
function is_list_empty() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    string list_name__ile="${1}"
    die_unless_list "${list_name__ile}"

    # Test such list's size. For efficiency, inline such test. See
    # get_list_size() for further details.
    (( ${#${(@P)list_name__ile}} == 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_list_nonempty(string variable_name)

Return success if the passed list is nonempty.
/---
function is_list_nonempty() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    string list_name__iln="${1}"
    die_unless_list "${list_name__iln}"

    # Test such list's size. For efficiency, inline such test. See
    # get_list_size() for further details.
    (( ${#${(@P)list_name__iln}} ))
}

# ....................{ TESTERS ~ index                    }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_list_index(string list_name, integer index)

Return success if the passed index is a non-zero integer bounded by either
`[-N, -1]` or `[1, N]`, where N is the size of the passed list: e.g.,

.is_list_index()
==========================================
[source]
------------------------------------------
>>> list poe; poe=( the masque of the red death )
>>> is_list_index poe -6 and print "Each man creates his own God for himself,"
Each man creates his own God for himself,
>>> is_list_index poe  0 or  print "He is not my master. Death has no master."
He is not my master. Death has no master.
------------------------------------------
==========================================
/---
function is_list_index() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one index.'
    string  list_name__ili="${1}" index__ili="${2}"
    integer list_size__ili
    die_unless_list "${list_name__ili}"
    die_unless_integer_nonzero "${index__ili}"

    # Get such list's size.
    list_size__ili="$(get_list_size "${list_name__ili}")"

    # Test such index. For efficiency, avoid calling is_integer_in_range().
    ((  (1 <= index__ili && index__ili <= list_size__ili) ||
        (-list_size__ili <= index__ili && index__ili <= -1) ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_list_range(
    string list_name, integer start_index, integer end_index)

Return success if the passed indices index the passed list and the first such
index is less than or equal to the second such index. To quantify such
conditions:

* Let `N` be the size of the passed list.
* Let `X` be the first passed index.
* Let `Y` be the second passed index.
* If `X > 0`, let `X\' = X`; else, let `X\' = N + X + 1`.
* If `Y > 0`, let `Y\' = Y`; else, let `Y\' = N + Y + 1`.

Then this function returns success only if the following conditions all hold:

* `1 <= X\'`.
* `X\' <= Y\'`.
* `Y\' <= N`.

For example:

.is_list_range()
==========================================
[source]
------------------------------------------
>>> list on_birthright=(
...     "If I should sell both my forenoons and afternoons to society, as most"
...     "appear to do, I am sure that for me there would be nothing left worth"
...     "living for. I trust that I shall never thus sell my birthright for a"
...     "mess of pottage. I wish to suggest that a man may be very industrious,"
...     "and yet not spend his time well. There is no more fatal blunderer than
...     "he who consumes the greater part of his life getting his living." )
>>> is_list_range on_birthright -4 5 and
...     print_string "You must get your living by loving."
You must get your living by loving.
>>> is_list_range on_birthright 4 -5 or
...     print_string "Read not the Times. Read the Eternities."
Read not the Times. Read the Eternities.
------------------------------------------
==========================================
/---
function is_list_range() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one list name, one start index, and one end index.'
    string\
        list_name__ilr="${1}" start_index__ilr="${2}" end_index__ilr="${3}"
    integer list_size__ilr
    die_unless_list "${list_name__ilr}"
    die_unless_integer_nonzero "${start_index__ilr}"
    die_unless_integer_nonzero "${end_index__ilr}"

    # Get such list's size.
    list_size__ilr="$(get_list_size "${list_name__ilr}")"

    # Convert negative to positive indices.
    if (( start_index__ilr < 0 )) {
        start_index__ilr=$(( list_size__ilr + start_index__ilr + 1 ))
    }
    if (( end_index__ilr < 0 )) {
        end_index__ilr=$(( list_size__ilr + end_index__ilr + 1 ))
    }
#   print "start index: ${start_index__ilr}\nend index: ${end_index__ilr}\nlist size: ${list_size__ilr}"
#   (( 1 <= start_index__ilr ))              and print "1 <= ${start_index__ilr}"
#   (( start_index__ilr <= end_index__ilr )) and print "${start_index__ilr} <= ${end_index__ilr}"
#   (( end_index__ilr <= list_size__ilr ))

    # Test such indices. For efficiency, avoid calling is_integer_in_range().
    (( 1 <= start_index__ilr &&\
            start_index__ilr <= end_index__ilr &&\
                                end_index__ilr <= list_size__ilr ))
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Not necessarily convinced this to be the most efficient method.
    #Shouldn't the following also suffice - possibly more efficient?
    #
    #    (( ${${(@P)list_name__ile}[(ie)${2}]} <= $(get_list_size "${list_name__ile}") ))
    #FUXME: This is extendable into an is_list_contains_match() function
    #by simple expanding ${2} as ${~2} here. Add to "glob", however; not here.
    #Actually... the two should be together, wherever they reside, due to the
    #complexity of implementation. "glob" would be an appropriate destination,
    #I should think.

    # Find such element. Dismantled, this is:
    #
    # * '@P', expanding to such list.
    # * "${(M)...:#...}", excluding all but such element.
    #
    # Do *NOT* double-quote this parameter expansion. Doing so *ALWAYS* results
    # in the empty string and hence failure. (This is inordinantly odd, but...)
    # As double-quoting is right out, calling is_string_nonempty() is also out.
    # (Unquoted parameters expanding to the empty string expand to no argument,
    # thus inducing is_string_nonempty() to throw an exception.)
#   print "list element matched: ${(M)${(@P)list_name__ile}:#${2}\}"
#   is -n ${(M)${(@P)list_name__ile}:#${2}\} si
#FUXME: Shift to new component "variable/list/index".
