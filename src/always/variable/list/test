#!/usr/bin/env zsh
# ====================[ test                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle list testers and exception throwing.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_lists(
    string variable_name1, string variable_name2, ...)

Throw an exception with a stock message unless all passed variables are lists.
________________<heredoc?>________________
function die_unless_lists() {
    die_unless_args 'expected at least one variable name'
    for variable_name__duls ("${@}") die_unless_list "${variable_name__duls}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_list_nonempty(
    string list_name,
    string error_message = "list \"${list_name}\" empty")

Throw an exception with the passed message unless the passed list is nonempty.
See is_list_nonempty() for further details.
________________<heredoc?>________________
function die_unless_list_nonempty() {
    die_unless_args_1_to_2\
        'expected one list name and optional error message'
    string list_name__duln="${1}"
    is_list_nonempty "${list_name__duln}" or
        die "${2:-list \"${list_name__duln}\" empty}"
}

# ....................{ EXCEPTION ~ index                  }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_list_index(
    string list_name, integer index,
    string error_message = "list \"${list_name}\" index ${index} for invalid")

Throw an exception with the passed message unless the passed integer indexes the
passed list. See is_list_index() for further details.
________________<heredoc?>________________
function die_unless_list_index() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one variable name and optional error message'

    # Test such index.
    is_list_index "${@}" or {
        string list_name__duli="${1}" index__duli="${2}"
        integer size__duli; size__duli="$(get_list_size "${list_name__duli}")"
        die "${2:-list \"${list_name__duli}\" index ${index__duli} not in [-${size__duli}, ${size__duli}]}"
    }
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_list_range(
    string list_name, integer start_index, integer end_index,
    string error_message = "list \"${list_name}\" range [${start_index}, ${end_index}] invalid")

Throw an exception with the passed message unless the passed integer rangees the
passed list. See is_list_range() for further details.
________________<heredoc?>________________
function die_unless_list_range() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one variable name and optional error message'

    # Test such range.
    is_list_range "${@}" or {
        string\
            list_name__dulr="${1}"\
            index_start__dulr="${2}"\
            index_end__dulr="${3}"
        integer size__dulr; size__dulr="$(get_list_size "${list_name__dulr}")"
        die "${2:-list \"${list_name}\" range [${index_start__dulr}, ${index_end__dulr}] not in [-${size__dulr}, ${size__dulr}]}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_contains(string list_name, string element)

Return success if the passed list contains the passed element.
________________<heredoc?>________________
function is_list_contains() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one element'
    string list_name__ile="${1}"
    die_unless_list "${list_name__ile}"

    # Test such list. Dismantled, this is:
    #
    # * "(@P)", expanding to such list.
    # * "([(ie)...]", expanding to the first 1-based list index containing such
    #   element or the size of such list if *NOT* containing such element.
    # * "${#...}", expanding to the size of such list. See get_list_size() for
    #   further details.
    #
    # While there exist alternative methods for finding list elements, this is
    # arguably the most reliable and efficient. Alternatives include:
    #
    # * Manually iterating such list. Naturally, this is the slowest.
    # * Testing "is -n ${(M)${(@P)list_name__ile}:#${2}} si". While faster than
    #   manual iteration, such test cannot distinguish between an extent element
    #   expanding to the empty string and a nonextant element.
    (( ${${(@P)list_name__ile}[(ie)${2}]} <= ${#${(@P)list_name__ile}} ))

}

#FIXME: In lieu of unit tests, this will do.
#function ico() {
#    list z; z=( hmm 'o eu' 3434 67 )
#    is_list_contains z 'o eu' and print 'z contains "o eu"'
#}

# ....................{ TESTERS ~ index                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_index(string list_name, integer index)

Return success if the passed index is a non-zero integer bounded by either
`[-N, -1]` or `[1, N]`, where N is the size of the passed list: e.g.,

.is_list_index()
==========================================
[source]
------------------------------------------
>>> list poe; poe=( the masque of the red death )
>>> is_list_index poe -6 and print "Each man creates his own God for himself,"
Each man creates his own God for himself,
>>> is_list_index poe  0 or  print "He is not my master. Death has no master."
He is not my master. Death has no master.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_list_index() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one index'
    string list_name__ili="${1}" index__ili="${2}"
    die_unless_list "${list_name__ili}"
    die_unless_integer_nonzero "${index__ili}"

    # Get such list's size.
    integer list_size__ili
    list_size__ili="$(get_list_size "${list_name__ili}")"

    # Test such index. For efficiency, avoid calling is_integer_in_range().
    ((  (1 <= index__ili && index__ili <= list_size__ili) ||
        (-list_size__ili <= index__ili && index__ili <= -1) ))
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_range(
    string list_name, integer start_index, integer end_index)

Return success if the passed indices index the passed list and the first such
index is less than or equal to the second such index. To quantify such
conditions:

* Let `N` be the size of the passed list.
* Let `X` be the first passed index.
* Let `Y` be the second passed index.
* If `X > 0`, let `X\' = X`; else, let `X\' = N + X + 1`.
* If `Y > 0`, let `Y\' = Y`; else, let `Y\' = N + Y + 1`.

Then this function returns success only if the following conditions all hold:

* `1 <= X\'`.
* `X\' <= Y\'`.
* `Y\' <= N`.

For example:

.is_list_range()
==========================================
[source]
------------------------------------------
>>> list on_birthright=(
...     "If I should sell both my forenoons and afternoons to society, as most"
...     "appear to do, I am sure that for me there would be nothing left worth"
...     "living for. I trust that I shall never thus sell my birthright for a"
...     "mess of pottage. I wish to suggest that a man may be very industrious,"
...     "and yet not spend his time well. There is no more fatal blunderer than
...     "he who consumes the greater part of his life getting his living." )
>>> is_list_range on_birthright -4 5 and
...     print_string "You must get your living by loving."
You must get your living by loving.
>>> is_list_range on_birthright 4 -5 or
...     print_string "Read not the Times. Read the Eternities."
Read not the Times. Read the Eternities.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_list_range() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one start index, and one end index'
    string\
        list_name__ilis="${1}" start_index__ilis="${2}" end_index__ilis="${3}"
    die_unless_list "${list_name__ilis}"
    die_unless_integer_nonzero "${start_index__ilis}"
    die_unless_integer_nonzero "${end_index__ilis}"

    # Get such list's size.
    integer list_size__ilis
    list_size__ilis="$(get_list_size "${list_name__ilis}")"

    # Convert negative to positive indices.
    ((  start_index__ilis < 0 &&\
        start_index__ilis = list_size__ilis + start_index__ilis + 1 ))
    ((  end_index__ilis < 0 &&\
        end_index__ilis = list_size__ilis + end_index__ilis + 1 ))

    # Test such indices. For efficiency, avoid calling is_integer_in_range().
    ((  1 <= start_index__ili &&\
        start_index__ili <= end_index__ili &&\
        end_index__ili <= list_size__ili ))
}

# ....................{ TESTERS ~ emptiness                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_empty(string list_name)

Return true if the passed list is empty.
________________<heredoc?>________________
function is_list_empty() {
    not  is_list_nonempty "${1}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_list_nonempty(string variable_name)

Return true if the passed list is nonempty.
________________<heredoc?>________________
function is_list_nonempty() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__iln="${1}"
    die_unless_list "${list_name__iln}"

    # Test such list's size.
    (( $(get_list_size "${list_name__iln}") ))
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Not necessarily convinced this to be the most efficient method.
    #Shouldn't the following also suffice - possibly more efficient?
    #
    #    (( ${${(@P)list_name__ile}[(ie)${2}]} <= $(get_list_size "${list_name__ile}") ))
    #FUXME: This is extendable into an is_list_contains_match() function
    #by simple expanding ${2} as ${~2} here. Add to "glob", however; not here.
    #Actually... the two should be together, wherever they reside, due to the
    #complexity of implementation. "glob" would be an appropriate destination,
    #I should think.

    # Find such element. Dismantled, this is:
    #
    # * '@P', expanding to such list.
    # * "${(M)...:#...}", excluding all but such element.
    #
    # Do *NOT* double-quote this parameter expansion. Doing so *ALWAYS* results
    # in the empty string and hence failure. (This is inordinantly odd, but...)
    # As double-quoting is right out, calling is_string_nonempty() is also out.
    # (Unquoted parameters expanding to the empty string expand to no argument,
    # thus inducing is_string_nonempty() to throw an exception.)
#   print "list element matched: ${(M)${(@P)list_name__ile}:#${2}}"
#   is -n ${(M)${(@P)list_name__ile}:#${2}} si
#FUXME: Shift to new component "variable/list/index".
