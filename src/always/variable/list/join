#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle conversion of non-scalar lists to scalar strings.
/---

# ....................{ JOINERS                            }....................
declare_function_with_stdin <<'/---'
string join_list(string list_name)

Join the list with the passed name into a string with each list element
undelimited (i.e., delimited by the empty string): e.g.,

.join_list()
==========================================
[source]
------------------------------------------
>>> list herbert; herbert=( "songs" "of a" "sentient flute" )
>>> join_list herbert
songsof asentient flute
------------------------------------------
==========================================
/---
function join_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__jl="${1}"
    die_unless_list "${list_name__jl}"

    # See concatenate_strings() for further details.
    string IFS=
    return_string "${(P)list_name__jl}"
}

# ....................{ JOINERS ~ delimiter                }....................
declare_function_with_stdin <<'/---'
string join_list_on_string(string list_name, string separator)

Join all elements of the passed list with the passed string, thus converting such
list to a string internally delimited by such string: e.g.,

.join_list_on_string()
==========================================
[source]
------------------------------------------
>>> list heinlein; heinlein=( "the moon" is a "harsh mistress" )
>>> join_list_on_string heinlein ", "
the moon, is, a, harsh mistress
------------------------------------------
==========================================
/---
function join_list_on_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one separator'
    string list_name__jlos="${1}" separator__jlos="${2}" token__jlos
    die_unless_list "${list_name__jlos}"

    # If a parameter expansion token specific to such separator exists, join
    # such list with parameter expansion flag "(j...)".
    if { token__jlos="$(get_string_parameter_expansion_token_if_found\
        "${separator__jlos}")" } {
        eval "return_string\
            \"\${(j${token__jlos}${separator__jlos}${token__jlos})${list_name__jlos}}\""
    #FIXME: Google us up a last-ditch alternative.
    # Else, throw an exception. While difficult to concieve a real-world join
    # separator containing all possible tokens, it certainly remains possible.
    } else {
        die "separator \"${separator__jlos}\" contains all possible paramater expansion tokens"
    }
}

declare_function_with_stdin <<'/---'
string join_list_on_newline(
    string list_name, integer start_index = 1, integer end_index = -1)

Join all elements of the passed list between the passed (possibly negative)
start and end indices (defaulting to the first and last such elements) with
newline, thus converting such list to a newline-delimited string: e.g.,

.join_list_on_newline()
==========================================
[source]
------------------------------------------
>>> list runes; runes=( abyss crypt pan tomb vaults )
>>> join_list_on_newline runes
abyss
crypt
pan
tomb
vaults
>>> join_list_on_newline runes 3 -2
pan
tomb
------------------------------------------
==========================================
/---
function join_list_on_newline() {
    # Validate passed arguments.
    die_unless_args_1_to_3\
        'expected one list name and optional start and end indices'
    string list_name__jlon="${1}"\
         index_start__jlon="${2:-1}" index_end__jlon="${3:--1}"
    die_unless_list_range "${index_start__jlon}" "${index_end__jlon}"

    # Join such list with print() rather than join_list_on_string(), as the
    # former does so more safely and efficiently.
    print -lr --\
        "${${(@P)list_name__jlon}[${index_start__jlon},${index_end__jlon}]}"
}

# ....................{ JOINERS ~ size                     }....................
#FIXME: Rename to join_list_on_strings_contextually() or perhaps the more
#explicit join_list_on_strings_depending_on_list_size(). Yes, I rather prefer
#the more explicit version, really. "contextually" just doesn't convey anything.
#FIXME: Documentation somewhat out-of-date.
declare_function_with_stdin <<'/---'
string join_list_on_strings(
    string list_name,
    string nonlast_delimiter,
    string last_delimiter_if_three_or_more_elements,
    string last_delimiter_if_two_elements = "${last_delimiter_if_three_or_more_elements}")

Join the list with the passed name into a string with each list element
excluding the last delimited by the first passed delimiter and the last list
element delimited by the second passed delimiter. Delimiters may be of any
length: e.g.,

.join_list_on_strings()
==========================================
[source]
------------------------------------------
>>> list pat_the_bunny
>>> pat_the_bunny=( the wingnut dishwashers union )
>>> join_list_on_last_delimiter pat_the_bunny "+" "?"
the+wingnut+dishwashers?union
------------------------------------------
==========================================
/---
function join_list_on_strings() {
    # Validate passed arguments.
    die_unless_args_3_to_4\
        'expected one list name, one non-last delimiter, one last delimiter if three or more list elements, and optional last delimiter if two list elements'
    string\
        list_name__jlwd="${1}" nonlast_delimiter__jlwd="${2}"\
        last_delimiter_if_three_or_more__jlwd="${3}" last_delimiter_if_two__jlwd
    last_delimiter_if_two__jlwd="${4:-${last_delimiter_if_three_or_more__jlwd}}"
    die_unless_list "${list_name__jlwd}"

    # Get such list's size.
    integer list_size__jlwd
    list_size__jlwd="$(get_list_size "${list_name__jlwd}")"

    # Join the passed list depending on the size of such list.
    if (( list_size__jlwd >= 3 )) {
        # Join all list elements excluding the last into a string. Note: DO NOT
        # DOUBLE-QUOTE SUCH LIST WHEN SETTING ${__list_sans_last_element__}, as
        # that aggregates such list elements into a single string. *shakes fist*
        list list_sans_last_element__jlwd
        string list_sans_last_element_string__jlwd
        list_sans_last_element__jlwd=( ${${(@P)list_name__jlwd}[1,-2]} )
#       print_message "lsle[@]: $__list_sans_last_element__[1]; $__list_sans_last_element__[2]"
        list_sans_last_element_string__="$(join_list_on_string\
            list_sans_last_element__jlwd "${nonlast_delimiter__jlwd}")"

        # Join the last list element into such list.
        return_string "${list_sans_last_element_string__jlwd}${last_delimiter_if_three_or_more__jlwd}${${(@P)list_name__jlwd}[-1]}"
#       return_string "${list_sans_last_element_string__}"
    } elif (( list_size__jlwd == 2 )) {
        return_string "${${(@P)list_name__jlwd}[1]}${last_delimiter_if_two__jlwd}${${(@P)list_name__jlwd}[2]}"
    } else {
        return_string "${${(@P)list_name__jlwd}[1]}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    # If the passed separator is a colon, delimit such separator by periods.
    # Delimited, this is:
    #
    # * "j.:.", joining on colons.
    # * "@P", expanding to the list with the passed name.
#   if is "${separator__jlos}" == ':' si {
#       return_string "${(j.:.@P)list_name__jlos}"
    # Else, delimit such separator by colons. Since zsh appears to
    # expand no parameters embedded in parameter expansion flags (e.g.,
    # "print ${(j:${separator}:)@}", joining list elements with the raw string
    # "${separator}" rather than the expansion of such parameter), wrap the
    # desired expression in an "eval" to force such expansion.
#   } else {
#       eval "return_string \"\${(j:${separator__jlos}:)${list_name__jlos}}\""
#   }
#Get a string suffixing each element except the last of the passed list with
#the passed delimiter. The delimiter may be of any length: e.g.,

#. Negative indices 
#If no indices are passed, all list elements are printed; if one
#index is passed, only that index is printed. Negative indices are offset against
#the last index
#FUXME: Rename to join_list_on_newline(). Actually, that function already
#exists! But this implementation is far more efficient. Hence, replace that with
#this and rename all calls to this to that. *sigh*
#FUXME: Rename to join_list_with_newline().
#declare_function '
#string join_list_on_newline(string list_name)
#
#Get a string suffixing each element except the last of the passed list with
#a newline character: e.g.,
#
#    >>> list banks; banks=( use of weapons )
#    >>> join_list_on_newline banks
#    use
#    of
#    weapons
#'
#function join_list_on_newline() {
#    die_unless_arg 'expected one list name'
#    join_list_on_string "${@}" "${ZESHY_ASCII_NEWLINE}"
#}

#FUXME: How about join_list_on_string(), instead?
#FUXME: Rename "list_elements" to "list_entries" everywhere. The latter gives
#more Google hits and is more concise. Double win! Actually, perhaps get_*()-
#style names wouldn't be more appropriate? Consider:
# string get_list_entries_joined_undelimited
#Ah, no; much too much of a mouthful. Good as is.
#FUXME: Actually, just drop the "_elements" everywhere. Excessive; unneeded. And
#reduce "with" to "on". That gives us final functions resembling:
#   join_list_on_string()

#FUXME: We should probably just centralize split and join functions into a new
#component: say, "type/variable/list_and_string".
# See "string/string" for corresponding split_*() functions.

#FUXME: Rename to get_list_as_restorable_string() or
#get_restorable_string_from_list(). Perhaps 
# ....................{ JOINERS ~ lines                    }....................
#FUXME: Trivial. Delete?
# string join_list_to_lines(string list_name)
#
# Join the list with the passed name into a newline-delimited string: e.g.,
#
#     >>> list grok; grok=( "Stranger in" "a" "Strange Land" )
#     >>> join_list_to_lines grok
#     Stranger in
#     a
#     Strange Land
#function join_list_to_lines() {
#   die_unless_arg 'expected one list name'
#   join_list_on_string "${1}" '\n'
#

#FUXME: The "_to_string" is redundant and renders function names cumbersome and
#unreadable. Replace with "_elements", which *isn't* redundant (e.g., renaming
#join_list() to
#join_list()).
#           "${(@P)__list_sans_last_element__}"\

#FUXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
#}

#FUXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_args_3_or_more; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_stringmunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_args_2
#   then print_string "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else print_string "${1}"
#   fi

#FUXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the passed arguments.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_USER_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FUXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps print_restorable_list()? AH! Got it: convert_list_to_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FUXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_args_2_or_more\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_variable List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
