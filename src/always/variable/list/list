#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *lists* (i.e., sequential arrays).
/---

#FIXME: Incorporate set operations from:
#   http://www.catonmat.net/blog/set-operations-in-unix-shell

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_list_size(string list_name)

Get the number of elements in the passed list.
/---
function get_list_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__gls="${1}"
    die_unless_list "${list_name__gls}"

    # Get such list's size. Dismantled, this is:
    #
    # * '@P', expanding the passed list name as a list.
    # * '#', expanding the size of such list.
    return_string ${#${(@P)list_name__gls}}
}

# ....................{ GETTERS ~ head                     }....................
declare_function_with_stdin <<'/---'
string get_list_head(string list_name)

Get the first element from the passed nonempty list.
/---
function get_list_head() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__glh="${1}"
    die_unless_list_nonempty "${list_name__glh}"

    # Get such element.
    return_string "${${(@P)list_name__glh}[1]}"
}

declare_function_with_stdin <<'/---'
string get_list_tail(string list_name)

Get the first element from the passed nonempty list.
/---
function get_list_tail() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__glt="${1}"
    die_unless_list_nonempty "${list_name__glt}"

    # Get such element.
    return_string "${${(@P)list_name__glt}[-1]}"
}

# ....................{ ADDERS                             }....................
declare_function_with_stdin <<'/---'
void prepend_list_with_string(
    string list_name,
    string text1, string text2, ...)

Concatenate the passed strings into a new list element prepended to the start of
the passed list: e.g.,

.prepend_list_with_string()
==========================================
[source]
------------------------------------------
>>> list khazad_dum; khazad_dum=( "from ashes" "and fire" "be broken" )
>>> prepend_list_with_string khazad_dum "a light" from "the shadows"
>>> print_string "${khazad_dum[1]}"
a light from the shadows
------------------------------------------
==========================================
/---
function prepend_list_with_string() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one list name and at least one string'
    string list_name__plws="${1}"
    die_unless_list "${list_name__plws}"

    # Prepend such list.
    eval "${list_name__plws}=( \"\${2}\" \"\${${list_name__plws}[@]}\" )"
}

declare_function_with_stdin <<'/---'
void append_list_with_string(
    string list_name,
    string text1, string text2, ...)

Concatenate the passed strings into a new list element appended to the end of
the passed list: e.g.,

.append_list_with_string()
==========================================
[source]
------------------------------------------
>>> list eater; eater=( "Oh! just," "subtle, and" "mighty opium!" )
>>> append_list_with_string eater "that to the hearts" "of rich and poor alike,"
>>> print_string "${eater[-1]}"
that to the hearts of rich and poor alike,
------------------------------------------
==========================================
/---
function append_list_with_string() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one list name and at least one string'
    string list_name__alws="${1}"
    die_unless_list "${list_name__alws}"

    # Append such list.
    eval "${list_name__alws}+=\"\${*}\""
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
void clear_list(string list_name)

Silently clear the passed list (i.e., remove all elements from such list): e.g.,

.clear_list()
==========================================
[source]
------------------------------------------
>>> list the_return; the_return=( "Slow on the leash, pallid the leash-men!" )
>>> clear_list    the_return
>>> get_list_size the_return
0
------------------------------------------
==========================================
/---
function clear_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__cl="${1}"
    die_unless_list "${list_name__cl}"

    # Clear such list.
    eval "${list_name__cl}=()"
}

declare_function_with_stdin <<'/---'
void shift_list(string list_name)

Silently remove the first element from the passed list: e.g.,

.shift_list()
==========================================
[source]
------------------------------------------
>>> list de_quincy; de_quincy=( suspiria de profundis )
>>> shift_list de_quincy
>>> print_string ${de_quincy[1]}
de
------------------------------------------
==========================================
/---
function shift_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__bl="${1}"
    die_unless_list_nonempty "${list_name__bl}"

    # Shift such list.
    eval "${list_name__cl}[1]=( )"
}

declare_function_with_stdin <<'/---'
void pop_list(string list_name)

Silently remove the last element from the passed list: e.g.,

.pop_list()
==========================================
[source]
------------------------------------------
>>> list lotophagi; lotophagi=( blue nymphaea cerulea )
>>> pop_list lotophagi
>>> print_string ${lotophagi[-1]}
nymphaea
------------------------------------------
==========================================
/---
function pop_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__cl="${1}"
    die_unless_list_nonempty "${list_name__cl}"

    # Pop such list.
    eval "${list_name__cl}[-1]=( )"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string print_list(string list_name)

Print the passed list in human-readable format.
/---
function print_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__pl="${1}"
    die_unless_list "${list_name__pl}"

    #FIXME: Colorize such list using ${ZESHY_COLOR_STYLES}. Not terribly hard...

    # Print such list.
    integer index__pl list_size__pl
    list_size__pl="$(get_list_size "${list_name__pl}")"
    for (( index__pl = 1; index__pl <= list_size__pl; index__pl++ )) {
        print_string_colored\
            "${index__pl}: ${${(P)list_name__pl}[${index__pl}]}"
    }
}

# ....................{ ITERATORS                          }....................
#FIXME: We probably want a new parcel "loop".

declare_function_with_stdin <<'/---'
string for_list_elements_sorted_lexically_ascending(
    string list_name,
    string element_string_name = "ELEMENT",
    string command)

Run the passed command for each element of the passed list in lexical ascending
order, setting the passed local variable (defaulting to `${ELEMENT}`) to each
such element: e.g.,

.for_list_elements_sorted_lexically_ascending()
==========================================
[source]
------------------------------------------
>>> list on_doublethink; on_doublethink=(
...     "His mind slid away into the labyrinthine world of doublethink. To know"
...     "and not to know, to be conscious of complete truthfulness while"
...     "telling carefully constructed lies, to hold simultaneously two"
...     "opinions which cancelled out, knowing them to be contradictory and"
...     "believing in both of them, to use logic against logic, to repudiate"
...     "morality while laying claim to it, to believe that democracy was"
...     "impossible and that the Party was the guardian of democracy, to forget,"
...     "whatever it was necessary to forget, then to draw it back into memory"
...     "again at the moment when it was needed, and then promptly to forget it"
...     "again, and above all, to apply the same process to the process itself"
...     "â€” that was the ultimate subtlety; consciously to induce"
...     "unconsciousness, and then, once again, to become unconscious of the act"
...     "of hypnosis you had just performed. Even to understand the word
...     "'doublethink' involved the use of doublethink." )
>>> for_list_elements_sorted_lexically_ascending on_doublethink doublethought\
...     'is_string_glob_matches "${doublethought}" [aoeui]* and
...         output_string "${doublethought}"'
and not to know, to be conscious of complete truthfulness while
again, and above all, to apply the same process to the process itself
again at the moment when it was needed, and then promptly to forget it
impossible and that the Party was the guardian of democracy, to forget,
of hypnosis you had just performed. Even to understand the word
opinions which cancelled out, knowing them to be contradictory and
unconsciousness, and then, once again, to become unconscious of the act
------------------------------------------
==========================================
/---
function for_list_elements_sorted_lexically_ascending() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize changes to for_list_elements_sorted_lexically_descending().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one list name, optional element name, and one command'
    string\
        list_name__flesla="${1}"\
        element_name__flesla='ELEMENT'\
        command__flesla="${@[-1]}"
    is_args_3 and element_name__flesla="${2}"
    die_unless_list "${list_name__flesla}"
    die_unless_variable_name "${element_name__flesla}"
    die_unless_string_nonempty "${command__flesla}" 'expected nonempty command'

    # Iterate such elements. For efficiency, evaluate once rather than on each
    # iteration. When paired with flag "v", flag "o" iterates all keys and
    # values and not simply keys in lexically ascending order. Since such
    # iteration is entirely unhelpful, there exists no corresponding
    # for_map_element_value_pairs_with_keys_sorted_lexically_ascending().
    eval "for ${element_name__flesla} (\"\${(o)${list_name__flesla}}\") {
        ${command__flesla}
    }"
}

declare_function_with_stdin <<'/---'
string for_list_elements_sorted_lexically_descending(
    string list_name,
    string element_string_name = "ELEMENT",
    string command)

Run the passed command for each element of the passed list in lexical descending
order, setting the passed local variable (defaulting to `${ELEMENT}`) to each
such element: e.g.,

.for_list_elements_sorted_lexically_descending()
==========================================
[source]
------------------------------------------
>>> list on_newspeak; on_newspeak=(
...     "It's a beautiful thing, the destruction of words. Of course the great"
...     "wastage is in the verbs and adjectives, but there are hundreds of"
...     "nouns that can be got rid of as well. It isn't only the synonyms; there"
...     "are also the antonyms. After all, what justification is there for a"
...     "word which is simply the opposite of some other word? A word contains"
...     "its opposite in itself. Take \"good\", for instance. If you have a word"
...     "like \"good\", what need is there for a word like \"bad\"? \"Ungood\""
...     "will do just as well â€” better, because it's an exact opposite, which"
...     "the other is not. Or again, if you want a stronger version of \"good\","
...     "what sense is there in having a whole string of vague useless words"
...     "like \"excellent\" and \"splendid\" and all the rest of them?"
...     "\"Plusgood\" covers the meaning, or \"doubleplusgood\" if you want
...     "something stronger still. Of course we use those forms already, but in"
...     "the final version of Newspeak there'll be nothing else. In the end the"
...     "whole notion of goodness and badness will be covered by only six words"
...     "â€” in reality, only one word. Don't you see the beauty of that,"
...     "Winston?" )
>>> for_list_elements_sorted_lexically_descending on_newspeak newspoken\
...     'is_string_glob_matches "${newspoken}" w* and
...         output_string "${newspoken}"'
word which is simply the opposite of some other word? A word contains
will do just as well â€” better, because it's an exact opposite, which
whole notion of goodness and badness will be covered by only six words
what sense is there in having a whole string of vague useless words
wastage is in the verbs and adjectives, but there are hundreds of
------------------------------------------
==========================================
/---
function for_list_elements_sorted_lexically_descending() {
    # See for_list_elements_sorted_lexically_ascending() for further details.
    die_unless_args_2_to_3\
        'expected one list name, optional element name, and one command'
    string\
        list_name__flesla="${1}"\
        element_name__flesla='ELEMENT'\
        command__flesla="${@[-1]}"
    is_args_3 and element_name__flesla="${2}"
    die_unless_list "${list_name__flesla}"
    die_unless_variable_name "${element_name__flesla}"
    die_unless_string_nonempty "${command__flesla}" 'expected nonempty command'
    eval "for ${element_name__flesla} (\"\${(O)${list_name__flesla}}\") {
        ${command__flesla}
    }"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Generalize a new remove_list_elements_in_range() function given the
#implementations below. Not terribly hard, just need to get around to it!
#   eval "${list_name__bl}=( \"\${${list_name__bl}[2,-1]}\" )"
# ....................{ CHECKERS                           }....................
#FUXME: Honestly, this is functionally useless as defined. We really want two
#separate functions, I should think:
#
#* die_unless_list_indices(), basically just check_list_args() renamed.
#* die_unless_list_index(), accepting and testing just one index.
#
#Also, accepting index names rather than values is simply odd; there doesn't
#appear to be any reasonable justification for this in the code, so just revert
#to proper values. That also dramatically simplifies the implementation.
#Honestly, sometimes... I don't even know. I mean,
#is_list_indices() can basically be implemented in terms of
#is_list_index(), which simplifies things even further.

#declare_function_with_stdin <<'/---'
#void check_list_args(
#  string list_name, string start_index_name, string end_index_name)
#
#Check the passed list-centric variables for sanity and, if sane, set such
#variables to sensible defaults. Specifically:
#
#* Throw an exception if no list with the passed name exists.
#* Throw an exception if the variable with the passed start index is empty but
#  the variable with the passed end index is not.
#* If both the variables with the passed start and end indices are empty,
#  default the former to "1" (i.e., the first list index) and the latter to
#  "-1" (i.e., the last list index). Such indices thus span the entire list.
#* If only the variable with the passed end index is empty, default such
#  variable to the same value as that of the passed start index. Such indices
#  thus span the single list element for the passed start index.
#* Throw an exception if the variables with such start and end indices are not
#  non-zero integers bounded by [-list_size, list_size].
#* Throw an exception if the start index is greater than the end index.
#
#In short, this function guarantees bounded list indices.
#/---
#function check_list_args() {
#    # Validate sanity, intentionally obfuscating local variable names to avoid
#    # unintentionally masking caller list names.
#    die_unless_args_1_to_3\
#        'expected one list name, one start index name, and one end index name'
#    string\
#        __list_name__="${1}" __list_size__ __beg_index__ __end_index__\
#        __beg_index_name__="${2}" __end_index_name__="${3}"\
#    __list_size__="$(get__list_size "${__list_name__}")"
#
#    # Default indices.
#    if is_string_empty "${__beg_index_name__}"; then
#        die_if_nonempty_variable "${__end_index_name__}"\
#            "start index \"${__beg_index_name__}\" empty but end index \"${__end_index_name__}\" non-empty"
#        __beg_index__=1
#        __end_index__=${__list_size__}
#    elif is_string_empty "${__end_index_name__}"; then
#        __beg_index__=${(P)__beg_index_name__}
#        __end_index__=${__beg_index__}
#    else
#        __beg_index__=${(P)__beg_index_name__}
#        __end_index__=${(P)__end_index_name__}
#    fi
#    die_unless_integer "${__beg_index__}"
#    die_unless_integer "${__end_index__}"
#
#    # Validate indices, converting negative to positive indices to simplify
#    # comparison. Preserve original indices for pretty printing.
#    integer _new_beg_index__=${__beg_index__} _new_end_index__=${__end_index__}
#    (( _new_beg_index__ > 0 )) or (( _new_beg_index__ += __list_size__ + 1 ))
#    (( _new_end_index__ > 0 )) or (( _new_end_index__ += __list_size__ + 1 ))
#    (( 1 <= _new_beg_index__ && _new_beg_index__ <= __list_size__ )) or
#        die "list index ${__beg_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
#    (( 1 <= _new_end_index__ && _new_end_index__ <= __list_size__ )) or
#        die "list index ${__end_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
#    (( _new_beg_index__ <= _new_end_index__ )) or
#        die "start index ${__beg_index__} > end index ${__end_index__}"
#
#    # Since indices validate, set index variables to the prior defaults.
#    set_string_to_string ${__beg_index_name__} ${_new_beg_index__}
#    set_string_to_string ${__end_index_name__} ${_new_end_index__}
#}
#
#Considering each such list a list set (i.e., ignoring duplicate elements) and
#abbreviating BN="${source_list_nameN}" (e.g., B1="${source_list_name1}") and
#A="${target_list_name}", this function performs the set intersection
#A = B1 & B2 & ... & BN of B1 through BN: e.g.,
#Considering each
#such list a list set (i.e., ignoring duplicate elements) and abbreviating
#B="${left_list_name}", C="${right_list_name}", and A="${result_list_name}",
#FUXME: Would probably be more appropriate as an alias, as that could also
#define such list if not already defined, streamlining code elsewhere.
# >>> set_list_to_string_converted asbestos "$(get_minerals)"
    #FUXME: Ensure all other remove functions call such function.
#
#* Pipe the return value of this function to restore_list(), automatically
#  restoring such string into a local list named "list". (Easy; inflexible.)
#* Manually apply parameter expansion flag "(z)" to the return value of this
#  function in a list assignment to any list you like. (Harder; flexible.)

  # Or (manually) restore such string back into a local list named... whatever
  # you like, man!
#  >>> list quebec_resources; quebec_resources=( ${(z)"$(get_minerals)"} )
#  >>> print_string "${quebec_resources[-1]}"
#  mafic

# void write_script_file_with_variable(string filename, string variable_name)
#           "${(@P)__list_sans_last_element__}"\

#FUXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
#}

#FUXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_args_3_or_more; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_stringmunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_args_2
#   then print_string "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else print_string "${1}"
#   fi

#FUXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the passed arguments.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_USER_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FUXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps print_restorable_list()? AH! Got it: convert_list_to_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FUXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_args_2_or_more\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_variable List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
