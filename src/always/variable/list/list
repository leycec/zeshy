#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle lists (i.e., arrays).
#
# --------------------( TODO                               )--------------------
# * Incorporate difference and intersect list operations from "src/load".
# * Incorporate set operations from:
#   http://www.catonmat.net/blog/set-operations-in-unix-shell

# ....................{ EXCEPTIONS                         }....................
declare_function '
void die_unless_lists(
  string variable_name1, string variable_name2, ...)

Throw an exception with a stock message unless all passed variables are lists.
'
function die_unless_lists() {
    die_unless_args 'expected at least one variable name'
    for variable_name__duls ("${@}") die_unless_list "${variable_name__duls}"
}

declare_function '
void die_unless_list_nonempty(
  string variable_name,
  string error_message = "\"${variable_name}\" not a non-empty list")

Throw an exception with the passed message unless the passed variable is a non-
empty list.
'
function die_unless_list_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__dule="${1}"
    is_list_nonempty "${variable_name__dule}" or
        die "${2:-\"${variable_name__dule}\" not a non-empty list}"
}

# ....................{ TESTERS                            }....................
declare_function '
boolean is_list_empty(string variable_name)

Return true if the passed variable is an empty list.
'
function is_list_empty() {
    not is_list_nonempty "${1}"
}

declare_function '
boolean is_list_nonempty(string variable_name)

Return true if the passed variable is a non-empty list.
'
function is_list_nonempty() {
#   print "args: ${@}"
    die_unless_arg 'expected one variable name'
    string list_name__iln="${1}"
    is_list "${list_name__iln}" and (( $(get_list_size "${list_name__iln}") ))
}

declare_function '
boolean is_list_contains(string list_name, string element)

Return true if the passed list contains the passed element.
'
function is_list_contains() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one element'
    string list_name__ile="${1}"
    die_unless_list "${list_name__ile}"

    #FIXME: Not necessarily convinced this to be the most efficient method.
    #Shouldn't the following also suffice - possibly more efficient?
    #
    #    (( ${${(@P)list_name__ile}[(ie)${2}]} <= $(get_list_size "${list_name__ile}") ))
    #FIXME: This is extendable into an is_list_contains_match() function
    #by simple expanding ${2} as ${~2} here. Add to "glob", however; not here.
    #Actually... the two should be together, wherever they reside, due to the
    #complexity of implementation. "glob" would be an appropriate destination,
    #I should think.

    # Find such element. Dismantled, this is:
    #
    # * '@P', expanding to such list.
    # * "${(M)...:#...}", excluding all but such element.
    #
    # Do *NOT* double-quote this parameter expansion. Doing so *ALWAYS* results
    # in the empty string and hence failure. (This is inordinantly odd, but...)
    # As double-quoting is right out, calling is_string_nonempty() is also out.
    # (Unquoted parameters expanding to the empty string expand to no argument,
    # thus inducing is_string_nonempty() to throw an exception.)
#   print "list element matched: ${(M)${(@P)list_name__ile}:#${2}}"
    is -n ${(M)${(@P)list_name__ile}:#${2}} si
}

#FIXME: In lieu of unit tests, this will do.
#function ico() {
#    list z; z=( hmm 'o eu' 3434 67 )
#    is_list_contains z 'o eu' and print 'z contains "o eu"'
#}

# ....................{ GETTERS                            }....................
declare_function '
integer get_list_size(string list_name)

Get the number of elements in the list with the passed name.
'
function get_list_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__gls="${1}"
    die_unless_list "${list_name__gls}"

    # Get list size. Dismantled, this is:
    #
    # * '1', the passed list name.
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * '#', the size of this list.
    print_string ${#${(@P)list_name__gls}}
}

# ....................{ CHECKERS                           }....................
#FIXME: Honestly, this is functionally useless as defined. We really want two
#separate functions, I should think:
#
#* die_unless_list_indices(), basically just check_list_args() renamed.
#* die_unless_list_index(), accepting and testing just one index.
#
#Also, accepting index names rather than values is simply odd; there doesn't
#appear to be any reasonable justification for this in the code, so just revert
#to proper values.

declare_function '
void check_list_args(
  string list_name, string start_index_name, string end_index_name)

Check the passed list-centric variables for sanity and, if sane, set such
variables to sensible defaults. Specifically:

* Throw an exception if no list with the passed name exists.
* Throw an exception if the variable with the passed start index is empty but
  the variable with the passed end index is not.
* If both the variables with the passed start and end indices are empty,
  default the former to "1" (i.e., the first list index) and the latter to
  "-1" (i.e., the last list index). Such indices thus span the entire list.
* If only the variable with the passed end index is empty, default such
  variable to the same value as that of the passed start index. Such indices
  thus span the single list element for the passed start index.
* Throw an exception if the variables with such start and end indices are not
  non-zero integers bounded by [-list_size, list_size].
* Throw an exception if the start index is greater than the end index.

In short, this function guarantees bounded list indices.
'
function check_list_args() {
    # Validate sanity, intentionally obfuscating local variable names to avoid
    # unintentionally masking caller list names.
    die_unless_args_1_to_3\
        'expected one list name, one start index name, and one end index name'
    string\
        __list_name__="${1}" __list_size__ __beg_index__ __end_index__\
        __beg_index_name__="${2}" __end_index_name__="${3}"\
    __list_size__="$(get__list_size "${__list_name__}")"

    # Default indices.
    if is_string_empty "${__beg_index_name__}"; then
        die_if_nonempty_variable "${__end_index_name__}"\
            "start index \"${__beg_index_name__}\" empty but end index \"${__end_index_name__}\" non-empty"
        __beg_index__=1
        __end_index__=${__list_size__}
    elif is_string_empty "${__end_index_name__}"; then
        __beg_index__=${(P)__beg_index_name__}
        __end_index__=${__beg_index__}
    else
        __beg_index__=${(P)__beg_index_name__}
        __end_index__=${(P)__end_index_name__}
    fi
    die_unless_integer "${__beg_index__}"
    die_unless_integer "${__end_index__}"

    # Validate indices, converting negative to positive indices to simplify
    # comparison. Preserve original indices for pretty printing.
    integer _new_beg_index__=${__beg_index__} _new_end_index__=${__end_index__}
    (( _new_beg_index__ > 0 )) or (( _new_beg_index__ += __list_size__ + 1 ))
    (( _new_end_index__ > 0 )) or (( _new_end_index__ += __list_size__ + 1 ))
    (( 1 <= _new_beg_index__ && _new_beg_index__ <= __list_size__ )) or
        die "list index ${__beg_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
    (( 1 <= _new_end_index__ && _new_end_index__ <= __list_size__ )) or
        die "list index ${__end_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
    (( _new_beg_index__ <= _new_end_index__ )) or
        die "start index ${__beg_index__} > end index ${__end_index__}"

    # Since indices validate, set index variables to the prior defaults.
    set_string_to_string ${__beg_index_name__} ${_new_beg_index__}
    set_string_to_string ${__end_index_name__} ${_new_end_index__}
}

# --------------------( WASTELANDS                         )--------------------
#Considering each such list a list set (i.e., ignoring duplicate elements) and
#abbreviating BN="${source_list_nameN}" (e.g., B1="${source_list_name1}") and
#A="${target_list_name}", this function performs the set intersection
#A = B1 & B2 & ... & BN of B1 through BN: e.g.,
#Considering each
#such list a list set (i.e., ignoring duplicate elements) and abbreviating
#B="${left_list_name}", C="${right_list_name}", and A="${result_list_name}",
#FUXME: Would probably be more appropriate as an alias, as that could also
#define such list if not already defined, streamlining code elsewhere.
# >>> set_list_to_string_converted asbestos "$(get_minerals)"
    #FUXME: Ensure all other remove functions call such function.
#
#* Pipe the return value of this function to restore_list(), automatically
#  restoring such string into a local list named "list". (Easy; inflexible.)
#* Manually apply parameter expansion flag "(z)" to the return value of this
#  function in a list assignment to any list you like. (Harder; flexible.)

  # Or (manually) restore such string back into a local list named... whatever
  # you like, man!
#  >>> list quebec_resources; quebec_resources=( ${(z)"$(get_minerals)"} )
#  >>> print_string "${quebec_resources[-1]}"
#  mafic

# void write_script_file_with_variable(string filename, string variable_name)
#           "${(@P)__list_sans_last_element__}"\

#FUXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
#}

#FUXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_args_at_least_3; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_delimitermunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_args_2
#   then print_string "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else print_string "${1}"
#   fi

#FUXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the passed arguments.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_DOT_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FUXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps print_restorable_list()? AH! Got it: convert_list_to_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FUXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_args_2_or_more\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_variable List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
