#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *list globs* (i.e., extended glob expressions matching list elements).
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_list_matches(string list_name, string glob)

Get the first element of the passed list matching the passed glob or throw an
exception if no element matches.
/---
function is_list_matches() {
    die_unless_args_2 'expected one list name and one glob'
    run_command_silent get_list_match_index_first_if_found "${(q)@}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> string get_list_match_first(string list_name, string glob)

Get the first element of the passed list matching the passed glob or throw an
exception if no element matches.
/---
function get_list_match_first() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'

    # Get such match if found or throw an exception.
    string match__glmf
    if {   match__glmf="$(get_list_match_first_if_found "${@}")" } {
        return_string "${match__glmf}"
    } else {
        string list_name__glmf="${1}" glob__glmf="${1}"
        die "list \"${list_name__glmf}\" contains no element matching \"${glob__glmf}\""
    }
}

declare_function_with_stdin <<'/---'
<globbable> [stdout: string, status: boolean] get_list_match_first_if_found(
    string list_name, string glob)

Get the first element of the passed list matching the passed glob or return
failure if no element matches.
/---
function get_list_match_first_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'
    string list_name__glmfif="${1}"

    # Get such element if found or fail. Since subscript flag "(r)" expands to
    # the empty string if no such element matches and hence is indistinguishable
    # from a successful match of the empty string (e.g., "*"), avoid such flag.
    integer index__glmfif
    if { index__glmfif="$(get_list_match_index_first_if_found "${@}")" } {
        return_string "${${(@P)list_name__glmfif}[${index__glmfif}]}"
    } else {
        return_false
    }
}

# ....................{ GETTERS ~ index                    }....................
declare_function_with_stdin <<'/---'
<globbable> integer get_list_match_index_first(string list_name, string glob)

Get the 1-based index of the first element of the passed list matching the
passed glob or throw an exception if no element matches.
/---
function get_list_match_index_first() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'

    # Get such match if found or throw an exception.
    string index__glmif
    if {   index__glmif="$(get_list_match_index_first_if_found "${@}")" } {
        return_string "${index__glmif}"
    } else {
        string list_name__glmif="${1}" glob__glmif="${1}"
        die "list \"${list_name__glmif}\" contains no element matching \"${glob__glmif}\""
    }
}

declare_function_with_stdin <<'/---'
[stdout: integer, status: boolean] get_list_match_index_first_if_found(
    string list_name, string glob)

Get the 1-based index of the first element of the passed list matching the
passed glob or return failure if no element matches.
/---
function get_list_match_index_first_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one glob'
    string list_name__glmifif="${1}" glob__glmifif="${2}"
    die_unless_list "${list_name__glmifif}"

    # Get the first matching index. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'i', expanding to the index of the first element matching...
    # * "${~glob__glmifif}", the passed glob as a glob rather than literal.
    integer index__glmifif
    index__glmifif="${${(@P)list_name__glmifif}[(i)${~glob__glmifif}]}"

    # Get such index if found or fail.
    (( index__glmifif <= $(get_list_size "${list_name__glmifif}") )) and
        return_string "${index__glmifif}"
}

declare_function_with_stdin <<'/---'
[stdout: integer, status: boolean]
    get_list_match_index_first_after_index_if_found(
    string list_name, string glob, string start_index)

Get the 1-based index of the first element of the passed list matching the
passed glob _after_ the passed index or return failure if no element matches.
/---
function get_list_match_index_first_after_index_if_found() {
    # Validate passed arguments.
    die_unless_args_3 'expected one list name, one glob, and one start index'
    string\
        list_name__glmifafif="${1}"\
        glob__glmifafif="${2}"\
        index_start__glmifafif="${3}"\
        list_size__glmifafif
    die_unless_list_index "${list_name__glmifafif}" "${index_start__glmifafif}"

    # Begin searching at the next such index. Since zsh supplies no builtin
    # means of finding from some index (subscript flag "(i)" always matches from
    # index 1), consider the following clever alternative:
    #
    # * Copy the *ENTIRE* subset of such list after such index into a new list.
    # * Search such list with subscript flag "(i)".
    # * Offset the matching index if found by the passed index.
    #
    # In the worst case, such copy duplicates such list. While unfortunate, this
    # is considerably faster (if memory intensive) than manual iteration.
    list copy__glmifafify; copy__glmifafif=(
        "${${(@P)list_name__glmifafif}[$(( index_start__glmifafif + 1 )),]}" )

    # Get such index if found or fail.
    integer index__glmifafif
    if { index__glmifafif="$(get_list_match_index_first_if_found\
        copy__glmifafif "${glob__glmifafif}")" } {
        return_string $(( index__glmifafif + index_start__glmifafif ))
    } else {
        return_false
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_matches(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to the passed source list including only elements
matching the passed glob.
/---
function set_list_to_list_matches() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name, one source list name, and one glob'
    string\
        list_name_target__sltlm="${1}"\
        list_name_source__sltlm="${2}"\
        glob__sltlm="${3}"
    die_unless_lists "${list_name_target__sltlm}" "${list_name_source__sltlm}"

    # Remove non-matching elements. Dismantled, this is:
    #
    # * "(M)" and ":#", removing all such source list elements not matching...
    # * "${~glob__sltlm}", such glob as a glob rather than literal.
    eval "${list_name_target__sltlm}=(\
        \${(M)${list_name_source__sltlm}[@]:#\${~glob__sltlm}} )"
}

declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_nonmatches(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to the passed source list excluding all elements
matching the passed glob.
/---
function set_list_to_list_nonmatches() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name, one source list name, and one glob'
    string\
        list_name_target__sltln="${1}"\
        list_name_source__sltln="${2}"\
        glob__sltln="${3}"
    die_unless_lists "${list_name_target__sltln}" "${list_name_source__sltln}"

    # Remove non-matching elements. Dismantled, this is:
    #
    # * ":#", removing all such source list elements matching...
    # * "${~glob__sltln}", such glob as a glob rather than literal.
    eval "${list_name_target__sltln}=(\
        \"\${${list_name_source__sltln}[@]:#\${~glob__sltln}}\" )"
}

# ....................{ SETTERS ~ position                 }....................
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_elements_after_match_inclusive(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all elements of the passed source list after and
including the first element matching the passed glob. If no such element
matches, throw an exception.
/---
function set_list_to_list_elements_after_match_inclusive() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name, one source list name, and one glob'
    string\
        list_name_target__sltleami="${1}"\
        list_name_source__sltleami="${2}"\
        glob__sltleami="${3}"
    die_unless_lists\
        "${list_name_target__sltleami}"\
        "${list_name_source__sltleami}"

    # Get the first matching index.
    integer index__sltleami
    index__sltleami="$(get_list_match_index_first\
        "${list_name_source__sltleami}" "${glob__sltleami}")"

    # Set such list.
    eval "${list_name_target}=(\
        \"\${${list_name_source__sltleami}[${index__sltleami},]}\" )"
}

declare_function_with_stdin <<'/---'
<globbable> void
    set_list_to_list_elements_after_match_inclusive_before_match_exclusive(
        string target_list_name,
        string source_list_name,
        string start_glob,
        string end_glob)

Set the passed target list to all elements of the passed source list both:

* Following the first element matching the first passed glob, including such
  element. If no such element matches, throw an exception.
* Preceding the next element matching the second passed glob, excluding such
  element. If no such element matches, include all remaining elements, thus
  mimicking set_list_to_list_elements_after_match_inclusive().
/---
function set_list_to_list_elements_after_match_inclusive_before_match_exclusive() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one target list name, one source list name, one start glob, and one end glob'
    string\
        list_name_target__sltlebmi="${1}"\
        list_name_source__sltlebmi="${2}"\
        glob_start__sltlebmi="${3}"\
        glob_end__sltlebmi="${4}"
    die_unless_lists\
        "${list_name_target__sltlebmi}"\
        "${list_name_source__sltlebmi}"

    # Get the first matching index.
    integer index_start__sltlebmi index_next__sltlebmi
    index_start__sltlebmi="$(get_list_match_index_first\
        "${list_name_source__sltlebmi}" "${glob_start__sltlebmi}")"

    # Get the next matching index if found.
    if { index_end__sltlebmi="$(get_list_match_index_first_after_index_if_found\
        "${list_name_source__sltlebmi}"\
        "${glob_start__sltlebmi}"\
        "${index_start__sltlebmi}")" } {
        # Since such match is exclusive, offset such index to the prior element.
        (( --index_end__sltlebmi ))
    # Else, default to the last index.
    } else {
        index_end__sltlebmi="$(get_list_size "${list_name_source__sltlebmi}")"
    }

    # Set such list.
    eval "${list_name_target__sltlebmi}=(\
        \"\${${list_name_source__sltlebmi}[${index_start__sltlebmi},${index_end__sltlebmi}]}\" )"
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
<globbable> void remove_list_matches(string list_name, string glob)

Remove all elements matching the passed glob from the passed list.
/---
function remove_list_matches() {
    die_unless_args_2 'expected one list name and one glob'
    set_list_to_list_nonmatches "${1}" "${1}" "${2}"
}

# ....................{ REDUCERS                           }....................
declare_function_with_stdin <<'/---'
<globbable> void reduce_list_to_matches(string list_name, string glob)

Reduce the passed list to only all elements matching the passed glob (i.e.,
remove all elements _not_ matching such glob from such list).
/---
function reduce_list_to_matches() {
    die_unless_args_2 'expected one list name and one glob'
    set_list_to_list_matches "${1}" "${1}" "${2}"
}

# ....................{ REDUCERS ~ position                }....................
declare_function_with_stdin <<'/---'
<globbable> void
    reduce_list_to_elements_after_match_inclusive_before_match_exclusive(
        string list_name, string start_glob, string end_glob)

Reduce the passed list to all elements both:

* Following the first element matching the first passed glob, including such
  element. If no such element matches, throw an exception.
* Preceding the next element matching the second passed glob, excluding such
  element. If no such element matches, include all remaining elements, thus
  mimicking set_list_to_list_elements_after_match_inclusive().
/---
function remove_list_nonmatches_before_and_after_inclusive() {
    die_unless_args_3\
        'expected one list name, one start glob, and one end glob'
    set_list_to_list_elements_after_match_inclusive_before_match_exclusive\
        "${1}" "${1}" "${2}" "${3}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Terrible name, really. Consider renaming to
#remove_list_elements_before_match_and_after_match() or
#reduce_list_to_elements_after_match_inclusive_before_match_exclusive(). Yes,
#the latter I should think.
#Equivalently, remove all elements from the passed list either:
#
#* Preceding the first element matching the first passed glob, excluding such
#  element. If no such element matches, throw an exception.
#* Following the next element matching the second passed glob, including such
#  element. If no such element matches, remove no such elements, thus
#  mimicking remove_list_nonmatches_before().
#   string list_name__rlebmaafm="${1}"
#   shift_arg

    # Remove such non-matches.
#   set_list_to_list_elements_after_match_inclusive_before_match_exclusive\
#       "${list_name__rlebmaafm}" "${list_name__rlebmaafm}" "${@}"

#FUXME: Rename to reduce_list_to_matches(). Trying to grok the current function
#name severely hurts my head. (A bad thing.)
# or die "list \"${list_name_source__sltleami}\" contains no element matching \"${glob__sltleami}\""
#FUXME: Rename to set_list_to_list_matches_first_until_next(). Scratch that. How
#about set_list_to_list_elements_after_match_until_match_inclusive() or simply
#set_list_to_list_elements_after_match_inclusive_before_match_exclusive()? Right. The latter reads
#particularly well.
#FUXME: Drop the optional default value here and elsewhere. Unhelpful and
#obfuscatory.

    #FUXME: Call die_unless_list_index() instead.
    # Validate such index, permitting index 0 as well as normal 1-based indices.
#   __list_size__="$(get_list_size "${list_name}")"
#   (( __offset__ >= 0 && __offset__ < __list_size__ )) or
#       die "list \"${list_name}\" index ${__offset__} not in [0, ${__list_size__})"

    #FUXME: Shouldn't this defer to get_list_match_index_first_if_found()?
    # Return such index if found or throw an exception.
#   integer __index__
#   if { __index__="$(get_list_match_index_first_if_found "${@}")" } {
#       return_string "${__index__}"
#   } else {
#       string list_name="${1}" __glob__="${2}"
#       die "no element of list \"${list_name}\" matching \"${__glob__}\""
#   }

#FUXME: Once we validate this works as expected, implement the converse
#get_last_list_element_matching() function by using flag "(R)" where we
#currently use flag "(r)".

    #FUXME: Shouldn't this defer to get_list_match_first_if_found()?
    # Return such element if found or throw an exception. Avoid subscript flag
    # "(r)", which expands to the empty string if no such element matches. Such
    # expansion is indistinguishable from a successful match, if the first such
    # match is the empty string (e.g., with glob "*").
#   integer __index__
#   if { __index__="$(get_list_match_index_first_if_found "${@}")" }
#       return_string "${${(@P)list_name}[${__index__}]}"
#   } else {
#       string list_name="${1}" __glob__="${2}"
#       die "no element of list \"${list_name}\" matching \"${__glob__}\""
#   }

#   string text="${1}" glob_first="${2}" glob_next
#   glob_next="${4-${glob_first}}"
# void remove_list_nonmatches_before_match_first_or_match_next_and_after(
# after and
# including the first element matching the first passed glob until but
# excluding the next element matching the second passed glob. If no element
# matches the first passed glob, throw an exception. However, if no element
# matches the second passed glob, simply include all remaining elements, thus
# mimicking set_list_to_list_elements_after_match_inclusive().
    #FUXME: It might actually be more efficient to copy the entire subset of the
    #passed list following such index into a new temporary list for searching,
    #as "(i)" *WOULD* work on such temporary. Actually, yes... this is most
    #certainly more efficient.
#   for (( ++__index__; __index__ <= __list_size__; ++__index__ )) {
#       is_string_matches_glob\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    #FUXME: Not right. An empty element could in fact match a non-empty glob
    #(e.g., "*"), in which case testing emptiness does not suffice. Instead,
    #call get_list_match_index_first() and note this subtlety.
    # Get the first match. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'r', expanding to the first element matching...
    # * "${~glob}", the passed glob as a glob rather than raw string.
#   __element__="${${(@P)list_name}[(r)${~__glob__}]}"

    # Throw an exception if no element matches.
#   die_if_string_empty "${__element__}"\
#       "no element of list \"${list_name}\" matches \"${__glob__}\""

    # Otherwise, return such element.
#   print_string "${__element__}"
    # Find the first match.
#   integer __index__ __list_size__
#   __list_size__="$(get_list_size "${list_name}")"
#   for (( __index__ = 0; __index__ < __list_size__; ++__index__ )) {
#       is_string_matches_glob\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    # Throw an exception if no element matches.
#   (( __index__ < __list_size__ )) or
#       die "no element of list \"${list_name}\" matches \"${__glob__}\""

# void set_list_to_list_excluding_elements_preceding_match(
# void set_list_to_list_excluding_matches(
# void set_list_to_list_including_only_matches(
#FUXME: Order of function arguments is, arguably, somewhat ad hoc. Switch the
#source_list_name and glob arguments, perhaps?
# void remove_list_elements_matching(
#   string source_list_name, string glob,
#   string target_list_name = "${source_list_name}")
#
# Copy all elements of the passed source list *NOT* matching the passed glob
# into the passed target list (defaulting to the passed source list). If passed
# only two arguments, remove all matching source list elements "in-place." This
# function implements the inverse of retain_list_elements_matching().
#function set_list_to_list_without_elements_matching() {
#function remove_list_elements_matching() {
#   if is_args_2; then
#       list_name_source="${list_name_target}"
#       __glob__="${2}"
#   else
#       list_name_source="${2}"
#       __glob__="${3}"
#   fi
