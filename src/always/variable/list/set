#!/usr/bin/env zsh
# ====================[ set                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle list setters (i.e., functions setting list variables).

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_list(string target_list_name, string source_list_name)

Set the passed target to the passed source list (i.e., copy the latter into the
former): e.g.,

.set_list_to_list()
==========================================
[source]
------------------------------------------
>>> list john_dee book_of_soyga; john_dee=( hieroglyphic monad )
>>> set_list_to_list john_dee book_of_soyga
>>> print_string "${book_of_soyga[2]}"
monad
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target list name and one source list name'
    string list_name_target__sltl="${1}" list_name_source__sltl="${2}"
    die_unless_lists "${list_name_target__sltl}" "${list_name_source__sltl}"

    # Copy such list.
    eval "${list_name_target__sltl}=( \"\${${list_name_source__sltl}[@]}\" )"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_list_reversed(
    string target_list_name, string source_list_name)

Set the passed target list to the reverse of the passed source list: e.g.,

.reverse_list()
==========================================
[source]
------------------------------------------
>>> list politizane politizane_reversed
>>> politizane=( wealth inequality in america )
>>> reverse_list politizane_reversed politizane
>>> print_string "${politizane_reversed}"
america in inequality wealth
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_reversed() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target list name and one source list name'
    string list_name_target__sltlr="${1}" list_name_source__sltlr="${2}"
    die_unless_lists "${list_name_target__sltlr}" "${list_name_source__sltlr}"

    # Reverse such list. Dismantled, this is:
    #
    # * "@P", expanding the source list.
    # * "Oa", reversing the order of list expansion.
    eval "${list_name_target__sltlr}=( \"${(Oa@P)list_name_source__sltlr}\" )"
}

# ....................{ SETTERS ~ character                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_split_on_character(
    string list_name, string text, character separator)

Split the passed string on the passed character into the passed list: e.g.,

.set_list_to_string_split_on_character()
==========================================
[source]
------------------------------------------
>>> string on_urbanity="
...     Shall I say, I have gone at dusk through narrow streets
...     And watched the smoke that rises from the pipes
...     Of lonely men in shirt-sleeves, leaning out of windows?...
...
...     I should have been a pair of ragged claws
...     Scuttling across the floors of silent seas."
>>> list under_inanity
>>> set_list_to_string_split_on_character under_inanity "${on_urbanity}" '.'
>>> print_string "empty fields: ${under_inanity[-3]}${under_inanity[-2]}"
empty fields:
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_split_on_character() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one separator character'
    string separator__sltssoc="${3}"
    die_unless_character "${separator__sltssoc}"

    # Split such string.
    set_list_to_string_split_on_string "${1}" "${2}" "${separator__sltssoc}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_split_on_character_1_or_more(
    string list_name, string text, character separator)

Split the passed string on one or more of the passed characters into the passed
list: e.g.,

.set_list_to_string_split_on_character_1_or_more()
==========================================
[source]
------------------------------------------
>>> string on_old_age="
...     I grow old ... I grow old ...
...     I shall wear the bottoms of my trousers rolled.
...
...     Shall I part my hair behind? Do I dare to eat a peach?
...     I shall wear white flannel trousers, and walk upon the beach.
...     I have heard the mermaids singing, each to each.
...
...     I do not think that they will sing to me."
>>> list under_inanity
>>> set_list_to_string_split_on_character_1_or_more\
...     under_golden_youth "${on_old_age}" '.'
>>> print_string "${under_golden_youth[2]}"
 I grow old
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_split_on_character_1_or_more() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one separator character'
    string\
        list_name__sltssoc1om="${1}"\
        text__sltssoc1om="${2}"\
        separator__sltssoc1om="${3}"
    die_unless_list "${list_name__sltssoc1om}"
    die_unless_character "${separator__sltssoc1om}"

    # Split such string by temporarily setting the internal field separator
    # (IFS) to such separator and passing read() such string on standard input
    # via here-string syntax. Dismantled, this is:
    #
    # * "IFS...", setting the internal field separator to such character,
    #   specified twice to prevent whitespace characters from being treated in a
    #   special manner. (See "IFS" under "man zshparam" for further details.)
    # * "-r", enabling raw mode, preventing read() from interpreting "\" at line
    #   ends as line continuations and "\" elsewhere as character escapes.
    # * "-d ''", preventing read() from halting until reading the entire string.
    #   By default, read() halts on reading a newline.
    # * "-A ...", writing all split substrings into such list.
    # * "<<< ...", passing such string on standard input as a "here document."
    IFS="${separator__sltssoc1om}${separator__sltssoc1om}"\
        read -r -d '' -A "${list_name__sltssoc1om}" <<<"${text__sltssoc1om}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_characters(string list_name, string text)

Split the passed string on characters into the passed list. zsh already supports
character indexing and slicing out of the box, so this function is useful only
where explicitly requiring list types: e.g.,

.set_list_to_string_characters()
==========================================
[source]
------------------------------------------
>>> list fern_hill
>>> set_list_to_string_characters fern_hill "though I sang in my chains"
>>> print_string "${fern_hill[21,26]}"
chains
>>> join_list fern_hill
though I sang in my chains
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_characters() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssoc="${1}" text__sltssoc="${2}"
    die_unless_list "${list_name__sltssoc}"

    # Split such string on the empty string. Paradoxical, yet successful.
    eval "${list_name__sltssoc}=( \${(s::)text__sltssoc} )"
}

# ....................{ SETTERS ~ word                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_words(string list_name, string text)

Split the passed string on words into the passed list. Since zsh supports word
indexing and slicing out of the box, this function is useful only where a list
is explicitly required: e.g.,

.set_list_to_string_words()
==========================================
[source]
------------------------------------------
>>> list thomas
>>> set_list_to_string_words thomas "time held me green and dying"
>>> print_string ${thomas[24,28]}
dying
>>> join_list_on_string thomas " "
time held me green and dying
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_words() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssow="${1}" text__sltssow="${2}"
    die_unless_list "${list_name__sltssow}"

    # Split with parameter expansion flag "(z)".
    eval "${list_name__sltssow}=( \${(z)text__sltssow} )"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_stdin_words(string list_name)

Split standard input on shell words into the passed list.

.set_list_to_stdin_words()
==========================================
[source]
------------------------------------------
>>> list fern_hill
>>> set_list_to_stdin_words fern_hill <<<\
...     "About the lilting house and happy as the grass was green,"
>>> print_string ${fern_hill[2]}
the
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_stdin_words() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltsisow="${1}"
    die_unless_list "${list_name__sltsisow}"
    die_unless_stdin_nonempty

    # Split such string. For efficiency, inline such implementation.
    eval "${list_name__sltsisow}=( \${(z)\$(< /dev/stdin)} )"

    # Close standard input.
    close_stdin
}

# ....................{ SETTERS ~ line                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_string_lines(string list_name, string text)

Split the passed string on newlines into the passed list.
________________<heredoc?>________________
function set_list_to_string_lines() {
    # Validate passed arguments, treating piped input as the passed string.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltsl="${1}" text__sltsl="${2}"

    # Split such string.
    eval "${list_name__sltsl}=( \${(f)text__sltsl} )"
}

# ....................{ SETTERS ~ string                   }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_split_on_string(
    string list_name, string text, string delimiter)

Split the passed string on the passed delimiter into the passed list. Such
delimiter may be of any length, including 0: e.g.,

.set_list_to_string_split_on_string()
==========================================
[source]
------------------------------------------
>>> string on_the_other_path="
...     \"I was surrounded by all these people hanging on my every word. It was
...     intoxicating — especially for a loner like me,\" Quijada said. \"For one
...     day, I got to play as an academic. I got to live this fantasy where I
...     took the other path in the garden. I got to see what it would have been
...     like if I had gone to graduate school and become a professional
...     linguist. The fates of the universe tore open a window to show me what
...     my life could have been. That night, I went back to my room, took a
...     shower, and burst into tears.\""
>>> list in_the_garden
>>> set_list_to_string_split_on_string in_the_garden "${on_the_other_path}" ', '
>>> print_string "${in_the_garden[-1]}"
and burst into tears."
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_split_on_string() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one separator string'
    string  token__sltssos\
        list_name__sltssos="${1}" text__sltssos="${2}" separator__sltssos="${3}"
    die_unless_list "${list_name__sltssos}"

    # If a parameter expansion token specific to such separator exists, split
    # such list with parameter expansion flag "(s...)".
    if { token__sltssos="$(get_string_parameter_expansion_token_if_found\
        "${separator__sltssos}")" } {
        eval "${list_name__sltssos}=(\
            \${(s${token__sltssos}${separator__sltssos}${token__sltssos})text__sltssos} )"
    # Else, split such list by non-greedily matching each shortest substring of
    # such string preceding such separator and appending such substring to such
    # list. Since this is the slowest such solution, defer to fallback use.
    } else {
        # Clear such list.
        clear_list "${list_name__sltssos}"

        # Split such string. For safety, escape all glob-reserved characters in
        # such separator.
        for_string_glob_matches_nongreedy_capturing_groups "${text__sltssos}"\
            (*)"$(escape_string "${separator__sltssos}")"\
            "${list_name__sltssos}+=\"\${match[1]}\""
    }
}

# ....................{ SETTERS ~ set                      }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_list_difference(
    string target_list_name,
    string source_left_list_name, string source_right_list_name)

Difference the second and third passed lists into the first. Formally, perform
the asymmetric set difference
`target_list = source_left_list - source_right_list`: e.g.,

.set_list_to_list_difference()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> set_list_to_list_difference a y e
>>> print_string "${a[@]}"
things did crawl with legs
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_difference() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name and two source list names'
    string\
        list_name_target__sltld="${1}"\
        list_name_left__sltld="${2}"\
        list_name_right__sltld="${3}"
    die_unless_lists\
        "${list_name_target__sltld}"\
        "${list_name_left__sltld}"\
        "${list_name_right__sltld}"

    # Difference such lists. Bless your pithy soul, zsh 5.x.x.
    eval "${list_name_target__sltld}=(\
        \${${list_name_left__sltld}:|${list_name_right__sltld}} )"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_list_intersection(
    string target_list_name,
    string source_list_name1, string source_list_name2, ...)

Intersect all passed lists excluding the first into the first. Formally, perform
the symmetric set intersection
`target_list = source_list_1 & source_list_2 & ...`: e.g.,

.set_list_to_list_intersection()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> list h; a=( and a thousand thousand slimy things )
>>> set_list_to_list_intersection a y e h
>>> print "${h[@]}"
slimy
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_intersection() {
    # Validate passed arguments, popping the last such argument off as the
    # target list name. Hence, all remaining arguments are source list names.
    die_unless_args_3_or_more\
        'expected one target list name and at least two source list names'
    string\
        list_name_target__sltli="${@[1]}"\
        list_name_source1__sltli="${@[2]}"\
        list_name_source2__sltli="${@[3]}"
    die_unless_lists\
        "${list_name_target__sltli}"\
        "${list_name_source1__sltli}"\
        "${list_name_source2__sltli}"
    shift_args 3

    # Intersect the first two source lists into the target list.
    eval "${list_name_target__sltli}=(\
        \${${list_name_source1__sltli}:*${list_name_source2__sltli}} )"

    # Intersect each remaining source list with the target list back into the
    # target list. Bless your extreme utility, zsh 5.x.x.
    for list_name_source__sltli ("${@}") {
        die_unless_list "${list_name_source__sltli}"
        eval "${list_name_target__sltli}=(\
            \${${list_name_source__sltli}:*${list_name_target__sltli}} )"
    }
}

# ....................{ SETTERS ~ split : file             }....................
#function set_list_to_file_text_split_on_string() {
#}

# --------------------( WASTELANDS                         )--------------------
#           'append_list_with_string "'${list_name__sltssos}'" "${match[1]}"'
#>>> string on_national_bankruptcy="
#...     As the United States goes bankrupt trying to maintain its global empire,
#...     and industrial civilization as a whole slides down the far side of a
#...     dizzying range of depletion curves, it's becoming harder by the day for
#...     Americans to make believe that the old saws of upward mobility and an
#...     ever brighter future have any relevance to their own lives--and yet
#...     those beliefs are central to the psychology, the self-image, and the
#...     worldview of most Americans."
#>>> list a_culture_of_make_believe
#>>> set_list_to_string_split_on_character_1_or_more\
#...     a_culture_of_make_believe "${on_national_bankruptcy}" '-'
#>>> print_string "${a_culture_of_make_believe[-2]}"
#and yet
#those beliefs are central to the psychology, the self

    # Else if such separator is a single character, split such list by
    # temporarily setting the internal field separator (IFS) to such separator
    # and passing read() such string on standard input as a "here document."
    # Dismantled, this is:
    #
    # * "IFS...", setting the internal field separator to such character,
    #   specified twice to prevent whitespace characters from being treated in a
    #   special manner. (See "IFS" under "man zshparam" for further details.)
    # * "-r", enabling raw mode, preventing read() from interpreting "\" at line
    #   ends as line continuations and "\" elsewhere as character escapes.
    # * "-d ''", preventing read() from halting until reading the entire string.
    #   By default, read() halts on reading a newline.
    # * "-A ...", writing all split substrings into such list.
    # * "<<< ...", passing such string on standard input as a "here document."
#   } elif { is_character "${separator__sltssos}" } {
#       IFS="${separator__sltssos}${separator__sltssos}"\
#           read -r -d '' -A "${list_name__sltssos}" <<< "${text__sltssos}"
#   }

        # For each shortest substring of such string preceding such separator,
        # append such substring to such list. For generality, escape all glob-
        #FUXME: Generalize into for_string_matches_nongreedily_with_capturing().
#       noop "${(S)text__sltssos//(#b)(*)${separator_escaped__sltssos}/$(\
#           append_list_with_string "${list_name__sltssos}" "${match[1]}")}"

        # Escape all PCRE-reserved characters in such separator.
#       string separator_escaped__sltssos
#       separator_escaped__sltssos="$(escape_string ${separator__sltssos})"
#           (#b)(*)"${separator_escaped__sltssos}"\

        # Append each split substring to such list. Since the prior conditional
        # failed, such separator is a string of length at least two and hence
        # must be negated with a negative lookahead assertion rather than a
        # negative character class. Since glob syntax does not support such
        # assertions, resort to to a PCRE.
#       for_string_pcre_matches "${text__sltssos}"\
#           "(.*?)${separator_escaped__sltssos}" -s\
#           'append_list_with_string "'${list_name__sltssos}'" "${match[1]}"'

    #FUXME: Implement this with PCRE-based iteration.
        # Append each split substring to such list. Since the prior conditional
        # failed, such separator is a string of length at least two and hence
        # must be negated with a negative lookahead assertion rather than a
        # negative character class. Since glob syntax does not support such
        # assertions, resort to to a PCRE. Dismantled, this is:
        # * "(...)*", capturing each substring preceding such separator to
        #   "${match[1]}" with:
        #   * "(?:(?!...).)*", matching the longest substring *NOT* containing
        #     such separator.
#           "((?:(?!${separator_escaped__sltssos}).)*)${separator_escaped__sltssos}"

#       noop "${text__sltssos//${separator__sltssos}/${list_name__sltssos}
#           )}"
        #FUXME: Implement a new function for_string_glob_matches() and call here.
        #FUXME: Fairly certain this is more efficiently implementable as follows:
        #IFS="${separator__sltssos}" 
    #FUXME: If get_string_parameter_expansion_token_if_found() returns false
    #(as occurs when such string contains all possible tokens), this function
    #throws an exception. Ideally, we would test for failure and, in such case,
    #defer to an external split command or more expensive zsh technique. If all
    #else fails, couldn't we implement this with PCRE-based iteration?
    #Naturally, we'd need to escape the passed separator... but, that doesn't
    #seem particularly difficult.

    #FUXME: O.K.; if the passed separator is only a single character, we can always
    #reliably use IFS to split strings. Else, we'll need to use the above PCRE
    #solution. The most efficient way to use IFS is as follows:
    #    read -r -d '' -A "${list_name__sltssos}" <<< "${text__sltssos}"
    #FUXME: Reliably restoring the IFS requires use of a loop. I'm thinking we
    #want a new set of functions reliably setting and restoring the IFS, yes?
    #We'll want to replace all current IFS uses with such functions, naturally.

# Dismantled, this is:
    # * "(@P)list_name_left", expanding all elements of the first passed list.
    # * ":|", excluding all elements of the second passed list.
    # Dismantled,
    # this is:
    #
    # * "${...:*...}", performing the symmetric set intersection of:
    #   * "(@P)1", the first source list.
    #   * "${2}", the name of the second source list.
#FUXME: An extraordinarily silly over-complexification obfuscating the simple,
#underlying implementation and damaging overall efficiency. Excise!
#declare_function_with_stdin <<'________________<heredoc?>________________'
#void set_list_to_evaluation(string list_name, string code)
#
#Set the passed list to the dynamic evaluation of the passed code in a list
#context (i.e., in an expression resembling `( ${code} )`): e.g.,
#
#.set_list_to_evaluation()
#==========================================
#[source]
#------------------------------------------
#>>> list ndaa
#>>> set_list_to_evaluation ndaa ''${(z)$(uname -a)}''
#>>> print_string "${ndaa[-1]}"
#GNU/Linux
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function set_list_to_evaluation() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one list name and one code snippet'
#    string list_name__slte="${1}"
#    die_unless_list "${list_name__slte}"
#
#    # Set such list.
#   print_string "set list ${list_name__slte}=( ${2} )"
#    eval "${list_name__slte}=( ${2} )"
#}

#FUXME: Rename to set_strings_to_string_split_on_string(). More readable and
#in keeping with nomenclature elsewhere.
#FUXME: Shift to "variable/string/separator".
    # If such delimiter contains no caret, efficiently default the split token
    # to a caret. Since caret is usually the least common punctuation character,
    # this condition is more likely to succeed than conditions on more common
    # punctuation characters and hence is optimized for the common case.
#   if { not is_string_contains "${separator__sltssod}" '^' } {
#       split_token__sltssod='^'
    #FUXME: This *GREAT* algorithm should be generalized into an external function.
    #It's insanely useful elsewhere, as I recently discovered in repeat_string().
    #See such function for documentation on doing so.
    #FUXME: For efficiency, globalize ${split_tokens__sltssod} into a global list.
    # Else, such delimiter contains a caret. To efficiently find the first
    # possible split token not already contained in such delimiter:
    #
    # * Define a list containing each possible split token as a list element.
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference the latter from the former list into a third list, thus
    #   containing each possible split token *NOT* a unique character of such
    #   delimiter.
    # * Arbitrarily select the first element of this third list as the split
    #   token. (Any element would do, but the first is... first!)
    #
    # This is considerably more efficient than iterative searching for the first
    # non-contained split token. In any case, this condition should rarely (if
    # ever) trigger.
#   } else {
        # List of all possible split tokens, excluding caret (which such string
        # has already been shown to contain).
#       list split_tokens__sltssod; split_tokens__sltssod=(
#           ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '-' '&' '*'
#           '-' '_' '\' '|' '/' '?'
#       )

        # List set of all unique delimiter characters. Only this list need be a
        # list set (i.e., no other lists need be list sets).
#       list_set separator_chars__sltssod
#       set_list_to_string_characters\
#           separator_chars__sltssod "${separator__sltssod}"

        # Difference the latter from the former into a third list.
#       list split_tokens_available__sltssod
#       set_list_to_list_difference\
#           split_tokens_available__sltssod\
#           split_tokens__sltssod\
#           separator_chars__sltssod

        # If no split token is available (i.e., the passed delimiter contains
        # all possible split tokens, an insane feat worthy of jeering applause),
        # throw an exception.
#       die_unless_list_nonempty split_tokens_available__sltssod\
#           "delimiter \"${separator__sltssod}\" contains all possible punctuation and hence split tokens"

        # Arbitrarily select the first available split token.
#       split_token__sltssod="${split_tokens_available__sltssod[1]}"
#   }

    # If the passed delimiter is a colon, delimit such delimiter by periods.
#   split_token__sltssod=''
#   if is_string_contains "${delimiter__sltssod}" ':'; then
#       set_list_to_evaluation "${list_name__sltssod}" '${(s.:.)text__sltssod}'
    # Otherwise, delimit such delimiter by colons.
#   else
#       set_list_to_evaluation "${list_name__sltssod}"\
#           "\${(s:${delimiter__sltssod}:)text__sltssod}"
#   fi
#   die_unless_character delimiter__sltssod
#FUXME: Generalize to strings longer than one character. Surely this is feasible
#with an iterative PCRE, no?
# string set_list_to_string_words(string list_name, string text)
#
# Split the passed string on words into the passed list. Since zsh supports list-
# style character indexing and slicing out of the box, this function is useful
# only where explicit list types are required: e.g.,
#
#     >>> list words
#     >>> set_list_to_string_words words 'Time held me green and dying'
#     >>> print_string ${words[1]} ${words[4]} ${words[5]}
#     Time green dying
#function set_list_to_string_words() {
    # Validate passed arguments.
#    die_unless_args_2 'expected one list name and one string'
#    string list_name="${1}" __text__="${2}"
#    die_unless_list "${list_name}"

    # Split with parameter expansion flag "(z)".
#    set_list_to_evaluation "${list_name}" '${(z)__text__}'
#}
