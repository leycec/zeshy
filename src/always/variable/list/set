#!/usr/bin/env zsh
# ====================[ set                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle list setters (i.e., functions setting list variables).

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_evaluation(string list_name, string code)

Set the passed list to the dynamic evaluation of the passed code in a list
context (i.e., in an expression resembling `( ${code} )`): e.g.,

.set_list_to_evaluation()
==========================================
[source]
------------------------------------------
>>> list ndaa
>>> set_list_to_evaluation ndaa ''${(z)$(uname -a)}''
>>> print_string "${ndaa[-1]}"
GNU/Linux
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one code snippet'
    string list_name__slte="${1}"
    die_unless_list "${list_name__slte}"

    # Set such list.
#   print_string "set list ${list_name__slte}=( ${2} )"
    eval "${list_name__slte}=( ${2} )"
}

# ....................{ SETTERS ~ character                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_characters(string list_name, string text)

Split the passed string on characters into the passed list. zsh already supports
character indexing and slicing out of the box, so this function is useful only
where explicitly requiring list types: e.g.,

.set_list_to_string_characters()
==========================================
[source]
------------------------------------------
>>> list hill
>>> set_list_to_string_characters hill "though I sang in my chains"
>>> print_string "${fern_hill[21,26]}"
chains
>>> join_list hill
though I sang in my chains
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_characters() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssoc="${1}" text__sltssoc="${2}"
    die_unless_list "${list_name__sltssoc}"

    # Split with a 0-width delimiter.
    set_list_to_evaluation "${list_name__sltssoc}" '${(s::)text__sltssoc}'
}

# ....................{ SETTERS ~ line                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_string_lines(string list_name, string text)

Split the passed string on newlines into the passed list.
________________<heredoc?>________________
function set_list_to_string_lines() {
    # Validate passed arguments, treating piped input as the passed string.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltsl="${1}" text__sltsl="${2}"

    # Split such string.
    set_list_to_evaluation "${list_name__sltsl}" '${(f)text__sltsl}'
}

# ....................{ SETTERS ~ word                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_stdin_words(string list_name)

Split standard input on shell words into the passed list.

.set_list_to_stdin_words()
==========================================
[source]
------------------------------------------
>>> list fern
>>> set_list_to_stdin_words fern <<< "about the lilting"
>>> print_string ${fern[2]}
the
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_stdin_words() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltsisow="${1}"
    die_unless_list "${list_name__sltsisow}"
    die_if_stdin_empty

    # Set such list and close standard input.
    set_list_to_evaluation "${list_name__sltsisow}" '${(z)"$(< /dev/stdin)"}'
    close_stdin
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_words(string list_name, string text)

Split the passed string on words into the passed list. Since zsh supports word
indexing and slicing out of the box, this function is useful only where a list
is explicitly required: e.g.,

.set_list_to_string_words()
==========================================
[source]
------------------------------------------
>>> list thomas
>>> set_list_to_string_words thomas "time held me green and dying"
>>> print_string ${thomas[24,28]}
dying
>>> join_list_on_delimiter thomas " "
time held me green and dying
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_words() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssow="${1}" text__sltssow="${2}"
    die_unless_list "${list_name__sltssow}"

    # Split with parameter expansion flag "(z)".
    set_list_to_evaluation "${list_name__sltssow}" '${(z)text__sltssow}'
}

# ....................{ SETTERS ~ list                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_list(string target_list_name, string source_list_name)

Set the passed target list to the passed source list (i.e., copy the latter into
the former): e.g.,

.set_list_to_list()
==========================================
[source]
------------------------------------------
>>> list john_dee book_of_soyga; john_dee=( hieroglyphic monad )
>>> set_list_to_list john_dee book_of_soyga
>>> print_string "${book_of_soyga[2]}"
monad
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list() {
    # Validate passed arguments.
    die_unless_args_2 'expected two list names'
    string list_name_target__sltl="${1}" list_name_source__sltl="${2}"
    die_unless_lists "${list_name_target__sltl}" "${list_name_source__sltl}"

    # Copy such list.
    set_list_to_evaluation\
         "${list_name_target__sltl}"\
        '"${(@P)list_name_source__sltl}"'
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_list_reversed(
    string target_list_name, string source_list_name)

Set the passed target list to the reverse of the passed source list: e.g.,

.reverse_list()
==========================================
[source]
------------------------------------------
>>> list politizane politizane_reversed
>>> politizane=( wealth inequality in america )
>>> reverse_list politizane_reversed politizane
>>> print_string "${politizane_reversed}"
america in inequality wealth
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_reversed() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target list name and one source list name'
    string list_name_target__rl="${1}" list_name_source__rl="${2}"

    # Reverse such list. Dismantled, this is:
    #
    # * "@P", expanding the source list.
    # * "Oa", reversing the order of list expansion.
    set_list_to_evaluation "${list_name_target__rl}"\
        "${(Oa@P)list_name_source__rl}"
}

# ....................{ SETTERS ~ set                      }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_list_difference(
    string target_list_name,
    string source_left_list_name, string source_right_list_name)

Difference the second and third passed lists into the first. Formally, perform
the asymmetric set difference
`target_list = source_left_list - source_right_list`: e.g.,

.set_list_to_list_difference()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> set_list_to_list_difference a y e
>>> print_string "${a[@]}"
things did crawl with legs
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_difference() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name and two source list names'
    string\
        list_name_target__sltld="${1}"\
        list_name_left__sltld="${2}"\
        list_name_right__sltld="${3}"
    die_unless_lists\
        "${list_name_target__sltld}"\
        "${list_name_left__sltld}"\
        "${list_name_right__sltld}"

    # Difference. Bless your pithy soul, zsh 5.x.x. Dismantled, this is:
    #
    # * "(@P)list_name_left", expanding all elements of the first passed list.
    # * ":|", excluding all elements of the second passed list.
    set_list_to_evaluation "${list_name_target__sltld}"\
        "\"\${(@P)list_name_left__sltld:|${list_name_right__sltld}}\""
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_list_intersection(
    string target_list_name,
    string source_list_name1, string source_list_name2, ...)

Intersect all passed lists excluding the first into the first. Formally, perform
the symmetric set intersection
`target_list = source_list_1 & source_list_2 & ...`: e.g.,

.set_list_to_list_intersection()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> list h; a=( and a thousand thousand slimy things )
>>> set_list_to_list_intersection a y e h
>>> print "${h[@]}"
slimy
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_intersection() {
    # Validate passed arguments, popping the last such argument off as the
    # target list name. Hence, all remaining arguments are source list names.
    die_unless_args_3_or_more\
        'expected one target list name and at least two source list names'
    string\
        list_name_target__sltli="${@[1]}"\
        list_name_source1__sltli="${@[2]}"\
        list_name_source2__sltli="${@[3]}"
    die_unless_list\
        "${list_name_target__sltli}"\
        "${list_name_source1__sltli}"\
        "${list_name_source2__sltli}"
    shift_args_3

    # Intersect the first two source lists into the target list. Dismantled,
    # this is:
    #
    # * "${...:*...}", performing the symmetric set intersection of:
    #   * "(@P)1", the first source list.
    #   * "${2}", the name of the second source list.
    set_list_to_evaluation "${list_name_target__sltli}"\
        "\"\${(@P)list_name_source1__sltli:*${list_name_source2__sltli}}\""

    # Intersect each remaining source list with the target list back into the
    # target list. Bless your extreme utility, zsh 5.x.x.
    for source_list_name__sltli ("${@}") {
        die_unless_list "${source_list_name__sltli}"
        set_list_to_evaluation "${list_name_target__sltli}"\
            "\"\${(@P)source_list_name__sltli:*${list_name_target__sltli}}\""
    }
}

# ....................{ SETTERS ~ separator                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_split_on_separator(
    string list_name, string text, string delimiter)

Split the passed string on the passed delimiter into the passed list. Such
delimiter may be of any length including 0: e.g.,

.set_list_to_string_split_on_separator()
==========================================
[source]
------------------------------------------
>>> list array
>>> set_list_to_string_split_on_separator array "obseqious/deep/join" "/"
>>> print_string "${array[1]}"
obseqious
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_split_on_separator() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one separator'
    string\
        list_name__sltssos="${1}" text__sltssos="${2}" separator__sltssos="${3}"
    die_unless_list "${list_name__sltssos}"

    #FIXME: If get_string_parameter_expansion_token_if_found() returns false
    #(as occurs when such string contains all possible tokens), this function
    #throws an exception. Ideally, we would test for failure and, in such case,
    #defer to an external split command or more expensive zsh technique. If all
    #else fails, couldn't we implement this with PCRE-based iteration?
    #Naturally, we'd need to escape the passed separator... but, that doesn't
    #seem particularly difficult.

    # Arbitrary parameter expansion token specific to such separator.
    string token__sltssos; token__sltssos="$(\
        get_string_parameter_expansion_token_if_found "${separator__sltssos}")"

    # Split such list.
    set_list_to_evaluation "${list_name__sltssos}"\
        "\${(s${token__sltssos}${separator__sltssos}${token__sltssos})text__sltssos}"
}

# ....................{ SETTERS ~ file                     }....................
function set_list_to_file_text_split_on_null() {
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to set_strings_to_string_split_on_separator(). More readable and
#in keeping with nomenclature elsewhere.
#FUXME: Shift to "variable/string/separator".
    # If such delimiter contains no caret, efficiently default the split token
    # to a caret. Since caret is usually the least common punctuation character,
    # this condition is more likely to succeed than conditions on more common
    # punctuation characters and hence is optimized for the common case.
#   if { not is_string_contains "${separator__sltssod}" '^' } {
#       split_token__sltssod='^'
    #FUXME: This *GREAT* algorithm should be generalized into an external function.
    #It's insanely useful elsewhere, as I recently discovered in repeat_string().
    #See such function for documentation on doing so.
    #FUXME: For efficiency, globalize ${split_tokens__sltssod} into a global list.
    # Else, such delimiter contains a caret. To efficiently find the first
    # possible split token not already contained in such delimiter:
    #
    # * Define a list containing each possible split token as a list element.
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference the latter from the former list into a third list, thus
    #   containing each possible split token *NOT* a unique character of such
    #   delimiter.
    # * Arbitrarily select the first element of this third list as the split
    #   token. (Any element would do, but the first is... first!)
    #
    # This is considerably more efficient than iterative searching for the first
    # non-contained split token. In any case, this condition should rarely (if
    # ever) trigger.
#   } else {
        # List of all possible split tokens, excluding caret (which such string
        # has already been shown to contain).
#       list split_tokens__sltssod; split_tokens__sltssod=(
#           ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '-' '&' '*'
#           '-' '_' '\' '|' '/' '?'
#       )

        # List set of all unique delimiter characters. Only this list need be a
        # list set (i.e., no other lists need be list sets).
#       list_set separator_chars__sltssod
#       set_list_to_string_characters\
#           separator_chars__sltssod "${separator__sltssod}"

        # Difference the latter from the former into a third list.
#       list split_tokens_available__sltssod
#       set_list_to_list_difference\
#           split_tokens_available__sltssod\
#           split_tokens__sltssod\
#           separator_chars__sltssod

        # If no split token is available (i.e., the passed delimiter contains
        # all possible split tokens, an insane feat worthy of jeering applause),
        # throw an exception.
#       die_unless_list_nonempty split_tokens_available__sltssod\
#           "delimiter \"${separator__sltssod}\" contains all possible punctuation and hence split tokens"

        # Arbitrarily select the first available split token.
#       split_token__sltssod="${split_tokens_available__sltssod[1]}"
#   }

    # If the passed delimiter is a colon, delimit such delimiter by periods.
#   split_token__sltssod=''
#   if is_string_contains "${delimiter__sltssod}" ':'; then
#       set_list_to_evaluation "${list_name__sltssod}" '${(s.:.)text__sltssod}'
    # Otherwise, delimit such delimiter by colons.
#   else
#       set_list_to_evaluation "${list_name__sltssod}"\
#           "\${(s:${delimiter__sltssod}:)text__sltssod}"
#   fi
#   die_unless_character delimiter__sltssod
#FUXME: Generalize to strings longer than one character. Surely this is feasible
#with an iterative PCRE, no?
# string set_list_to_string_words(string list_name, string text)
#
# Split the passed string on words into the passed list. Since zsh supports list-
# style character indexing and slicing out of the box, this function is useful
# only where explicit list types are required: e.g.,
#
#     >>> list words
#     >>> set_list_to_string_words words 'Time held me green and dying'
#     >>> print_string ${words[1]} ${words[4]} ${words[5]}
#     Time green dying
#function set_list_to_string_words() {
    # Validate passed arguments.
#    die_unless_args_2 'expected one list name and one string'
#    string list_name="${1}" __text__="${2}"
#    die_unless_list "${list_name}"

    # Split with parameter expansion flag "(z)".
#    set_list_to_evaluation "${list_name}" '${(z)__text__}'
#}
