#!/usr/bin/env zsh
# ====================[ set                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle list setters.

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_evaluation(string list_name, string code)

Set the passed list to the dynamic evaluation of the passed code in a list
context (i.e., in an expression resembling `( ${code} )`): e.g.,

.set_list_to_evaluation()
==========================================
[source]
------------------------------------------
>>> list ndaa
>>> set_list_to_evaluation ndaa ''${(z)$(uname -a)}''
>>> print_string "${ndaa[-1]}"
GNU/Linux
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one code snippet'
    string list_name__slte="${1}"
    die_unless_list "${list_name__slte}"

    # Set such list.
#   print_string "set list ${list_name__slte}=( ${2} )"
    eval "${list_name__slte}=( ${2} )"
}

# ....................{ SETTERS ~ character                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_characters(string list_name, string text)

Split the passed string on characters into the passed list. zsh already supports
character indexing and slicing out of the box, so this function is useful only
where explicitly requiring list types: e.g.,

.set_list_to_string_characters()
==========================================
[source]
------------------------------------------
>>> list hill
>>> set_list_to_string_characters hill "though I sang in my chains"
>>> print_string "${fern_hill[21,26]}"
chains
>>> join_list hill
though I sang in my chains
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_characters() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssoc="${1}" text__sltssoc="${2}"
    die_unless_list "${list_name__sltssoc}"

    # Split with a 0-width delimiter.
    set_list_to_evaluation "${list_name__sltssoc}" '${(s::)text__sltssoc}'
}

# ....................{ SETTERS ~ line                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_string_lines(string list_name, string text)

Split the passed string on newlines into the passed list.
________________<heredoc?>________________
function set_list_to_string_lines() {
    # Validate passed arguments, treating piped input as the passed string.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltsl="${1}" text__sltsl="${2}"

    # Split such string.
    set_list_to_evaluation "${list_name__sltsl}" '${(f)text__sltsl}'
}

# ....................{ SETTERS ~ word                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_stdin_words(string list_name)

Split standard input on shell words into the passed list.

.set_list_to_stdin_words()
==========================================
[source]
------------------------------------------
>>> list fern
>>> set_list_to_stdin_words fern <<< "about the lilting"
>>> print_string ${fern[2]}
the
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_stdin_words() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltsisow="${1}"
    die_unless_list "${list_name__sltsisow}"
    die_if_stdin_empty

    # Set such list and close standard input.
    set_list_to_evaluation "${list_name__sltsisow}" '${(z)"$(< /dev/stdin)"}'
    close_stdin
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_words(string list_name, string text)

Split the passed string on words into the passed list. Since zsh supports word
indexing and slicing out of the box, this function is useful only where a list
is explicitly required: e.g.,

.set_list_to_string_words()
==========================================
[source]
------------------------------------------
>>> list thomas
>>> set_list_to_string_words thomas "time held me green and dying"
>>> print_string ${thomas[24,28]}
dying
>>> join_list_on_delimiter thomas " "
time held me green and dying
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_words() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssow="${1}" text__sltssow="${2}"
    die_unless_list "${list_name__sltssow}"

    # Split with parameter expansion flag "(z)".
    set_list_to_evaluation "${list_name__sltssow}" '${(z)text__sltssow}'
}

# ....................{ SETTERS ~ list                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_list(string target_list_name, string source_list_name)

Set the passed target list to the passed source list (i.e., copy the latter into
the former): e.g.,

.set_list_to_list()
==========================================
[source]
------------------------------------------
>>> list john_dee book_of_soyga; john_dee=( hieroglyphic monad )
>>> set_list_to_list john_dee book_of_soyga
>>> print_string "${book_of_soyga[2]}"
monad
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list() {
    # Validate passed arguments.
    die_unless_args_2 'expected two list names'
    string list_name_target__sltl="${1}" list_name_source__sltl="${2}"
    die_unless_lists "${list_name_target__sltl}" "${list_name_source__sltl}"

    # Copy such list.
    set_list_to_evaluation\
         "${list_name_target__sltl}"\
        '"${(@P)list_name_source__sltl}"'
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_list_reversed(
    string target_list_name, string source_list_name)

Set the passed target list to the reverse of the passed source list: e.g.,

.reverse_list()
==========================================
[source]
------------------------------------------
>>> list politizane politizane_reversed
>>> politizane=( wealth inequality in america )
>>> reverse_list politizane_reversed politizane
>>> print_string "${politizane_reversed}"
america in inequality wealth
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_reversed() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target list name and one source list name'
    string list_name_target__rl="${1}" list_name_source__rl="${2}"

    # Reverse such list. Dismantled, this is:
    #
    # * "@P", expanding the source list.
    # * "Oa", reversing the order of list expansion.
    set_list_to_evaluation "${list_name_target__rl}"\
        "${(Oa@P)list_name_source__rl}"
}

# ....................{ SETTERS ~ set                      }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_list_difference(
    string target_list_name,
    string source_left_list_name, string source_right_list_name)

Difference the second and third passed lists into the first. Formally, perform
the asymmetric set difference
`target_list = source_left_list - source_right_list`: e.g.,

.set_list_to_list_difference()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> set_list_to_list_difference a y e
>>> print_string "${a[@]}"
things did crawl with legs
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_difference() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one target list name and two source list names'
    string\
        list_name_target__sltld="${1}"\
        list_name_left__sltld="${2}"\
        list_name_right__sltld="${3}"
    die_unless_lists\
        "${list_name_target__sltld}"\
        "${list_name_left__sltld}"\
        "${list_name_right__sltld}"

    # Difference. Bless your pithy soul, zsh 5.x.x. Dismantled, this is:
    #
    # * "(@P)list_name_left", expanding all elements of the first passed list.
    # * ":|", excluding all elements of the second passed list.
    set_list_to_evaluation "${list_name_target__sltld}"\
        "\"\${(@P)list_name_left__sltld:|${list_name_right__sltld}}\""
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_list_to_list_intersection(
    string target_list_name,
    string source_list_name1, string source_list_name2, ...)

Intersect all passed lists excluding the first into the first. Formally, perform
the symmetric set intersection
`target_list = source_list_1 & source_list_2 & ...`: e.g.,

.set_list_to_list_intersection()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> list h; a=( and a thousand thousand slimy things )
>>> set_list_to_list_intersection a y e h
>>> print "${h[@]}"
slimy
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_list_intersection() {
    # Validate passed arguments, popping the last such argument off as the
    # target list name. Hence, all remaining arguments are source list names.
    die_unless_args_3_or_more\
        'expected one target list name and at least two source list names'
    string\
        list_name_target__sltli="${@[1]}"\
        list_name_source1__sltli="${@[2]}"\
        list_name_source2__sltli="${@[3]}"
    die_unless_list\
        "${list_name_target__sltli}"\
        "${list_name_source1__sltli}"\
        "${list_name_source2__sltli}"
    shift_args_3

    # Intersect the first two source lists into the target list. Dismantled,
    # this is:
    #
    # * "${...:*...}", performing the symmetric set intersection of:
    #   * "(@P)1", the first source list.
    #   * "${2}", the name of the second source list.
    set_list_to_evaluation "${list_name_target__sltli}"\
        "\"\${(@P)list_name_source1__sltli:*${list_name_source2__sltli}}\""

    # Intersect each remaining source list with the target list back into the
    # target list. Bless your extreme utility, zsh 5.x.x.
    for source_list_name__sltli ("${@}") {
        die_unless_list "${source_list_name__sltli}"
        set_list_to_evaluation "${list_name_target__sltli}"\
            "\"\${(@P)source_list_name__sltli:*${list_name_target__sltli}}\""
    }
}

# ....................{ SETTERS ~ delimiter                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_list_to_string_split_on_delimiter(
    string list_name, string text, string delimiter)

Split the passed string on the passed delimiter into the passed list. Such
delimiter may be of any length including 0: e.g.,

.set_list_to_string_split_on_delimiter()
==========================================
[source]
------------------------------------------
>>> list array
>>> set_list_to_string_split_on_delimiter array "obseqious/deep/join" "/"
>>> print_string "${array[1]}"
obseqious
------------------------------------------
==========================================
________________<heredoc?>________________
function set_list_to_string_split_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one delimiter'
    string\
        list_name__sltssod="${1}"\
        string__sltssod="${2}"\
        delimiter__sltssod="${3}"\
        split_token__sltssod
    die_unless_list "${list_name__sltssod}"

    # If such delimiter contains no caret, efficiently default the split token
    # to a caret. Since caret is usually the least common punctuation character,
    # this condition is more likely to succeed than conditions on more common
    # punctuation characters and hence is optimized for the common case.
    if { not is_string_contains "${delimiter__sltssod}" '^' } {
        split_token__sltssod='^'
    #FIXME: This *GREAT* algorithm should be generalized into an external function.
    #It's insanely useful elsewhere, as I recently discovered in repeat_string().
    #See such function for documentation on doing so.
    #FIXME: For efficiency, globalize ${split_tokens__sltssod} into a global list.
    # Else, such delimiter contains a caret. To efficiently find the first
    # possible split token not already contained in such delimiter:
    #
    # * Define a list containing each possible split token as a list element.
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference the latter from the former list into a third list, thus
    #   containing each possible split token *NOT* a unique character of such
    #   delimiter.
    # * Arbitrarily select the first element of this third list as the split
    #   token. (Any element would do, but the first is... first!)
    #
    # This is considerably more efficient than iterative searching for the first
    # non-contained split token. In any case, this condition should rarely (if
    # ever) trigger.
    } else {
        # List of all possible split tokens, excluding caret (which such string
        # has already been shown to contain).
        list split_tokens__sltssod; split_tokens__sltssod=(
            ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '-' '&' '*'
            '-' '_' '\' '|' '/' '?'
        )

        # List set of all unique delimiter characters. Only this list need be a
        # list set (i.e., no other lists need be list sets).
        list_set delimiter_chars__sltssod
        set_list_to_string_characters\
            delimiter_chars__sltssod "${delimiter__sltssod}"

        # Difference the latter from the former into a third list.
        list split_tokens_available__sltssod
        set_list_to_list_difference\
            split_tokens_available__sltssod\
            split_tokens__sltssod\
            delimiter_chars__sltssod

        # If no split token is available (i.e., the passed delimiter contains
        # all possible split tokens, an insane feat worthy of jeering applause),
        # throw an exception.
        die_unless_list_nonempty split_tokens_available__sltssod\
            "delimiter \"${delimiter__sltssod}\" contains all possible punctuation and hence split tokens"

        # Arbitrarily select the first available split token.
        split_token__sltssod="${split_tokens_available__sltssod[1]}"
    }

    # Split such list.
    set_list_to_evaluation "${list_name__sltssod}"\
        "\${(s${split_token__sltssod}${delimiter__sltssod}${split_token__sltssod})string__sltssod}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void set_strings_to_string_split_on_delimiter(
    string string_name1, string string_name2, string text, string delimiter)

Split the substring of the passed string preceding the first instance of the
passed delimiter into the first passed list and the remainder (excluding the
passed delimiter) into the second passed list. Such delimiter may be of any non-
zero length. If such string contains no such delimiter, throw an exception:
e.g.,

.set_strings_to_string_split_on_delimiter()
==========================================
[source]
------------------------------------------
>>> string pre suf
>>> set_strings_to_string_split_on_delimiter pre suf "wol==hea==soc" "=="
>>> print "prefix: ${pre}\nsuffix: ${suf}"
prefix: wol
suffix: hea==soc
------------------------------------------
==========================================
________________<heredoc?>________________
function set_strings_to_string_split_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one prefix name, one suffix name, one string, and one delimiter'
    string\
        prefix_name__sstspod="${1}"\
        suffix_name__sstspod="${2}"\
        text__sstspd="${3}"\
        delimiter__sstspd="${4}"
    die_unless_variable_string "${prefix_name__sstspd}"
    die_unless_variable_string "${suffix_name__sstspd}"
    die_unless_string_nonempty "${delimiter__sstspd}" 'no delimiter passed'

    # If such string contains no such delimiter, throw an exception.
    is_string_contains "${text__sstspd}" "${delimiter__sstspd}" or
        die "delimiter \"${delimiter__sstspd}\" not found in \"${text__sstspd}\""

    #FIXME: Conjoin into a single "//"-style match enabling "(#b)" to capture
    #the two groups, then set such strings with such groups. This also helps to
    #rid us of the unwieldy test above, assuming we detect such match failing
    #with non-zero exit status.
    #FIXME: Just use single "#" with "(#b)". See set_list_to_string_piped<>.
    # Split such string.
    set_string_to_string "${prefix_name__sstspd}" "${text__sstspd%%${delimiter__sstspd}*}"
    set_string_to_string "${suffix_name__sstspd}" "${text__sstspd#*${delimiter__sstspd}}"
}

# ....................{ ADDERS                             }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void prepend_list_with_string(string list_name, string text)

Add the passed element to the beginning of the passed list: e.g.,

.prepend_list_with_string()
==========================================
[source]
------------------------------------------
>>> list khazad_dum; khazad_dum=( "from ashes" "and fire" "be broken" )
>>> prepend_list_with_string khazad_dum "a light from the shadows"
>>> print_string "${khazad_dum[1]}"
a light from the shadows
------------------------------------------
==========================================
________________<heredoc?>________________
function prepend_list_with_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__plws="${1}"
    die_unless_list "${list_name__plws}"

    # Prepend such list.
    set_list_to_evaluation "${list_name__plws}"\
        '"${2}" "${(@P)list_name__plws}"'
}

#FIXME: Fix example, kindly.
declare_function_with_stdin <<'________________<heredoc?>________________'
void append_list_with_string(string list_name, string text)

Add the passed element to the end of the passed list: e.g.,

.append_list_with_string()
==========================================
[source]
------------------------------------------
>>> list eater; eater=( "Oh! just," "subtle, and" "mighty opium!" )
>>> append_list_with_string eater "that to the hearts of rich and poor alike,"
>>> print_string "${eater[-1]}"
that to the hearts of rich and poor alike,
------------------------------------------
==========================================
________________<heredoc?>________________
function append_list_with_string() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__alws="${1}"
    die_unless_list "${list_name__alws}"

    # Append such list.
    eval "${list_name__alws}+=\"\${2}\""
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string shift_list(string list_name)

Remove the first element from the passed list: e.g.,

.shift_list()
==========================================
[source]
------------------------------------------
>>> list de_quincy; de_quincy=( suspiria de profundis )
>>> shift_list de_quincy
>>> print_string ${de_quincy[1]}
de
------------------------------------------
==========================================
________________<heredoc?>________________
function shift_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__bl="${1}"
    die_unless_list_nonempty "${list_name__bl}"

    # Behead such list.
    set_list_to_evaluation "${list_name__bl}" '"${list_name__bl[2,-1]}"'
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string pop_list(string list_name)

Remove the last element from the passed list: e.g.,

.pop_list()
==========================================
[source]
------------------------------------------
>>> list lotophagi; lotophagi=( blue nymphaea cerulea )
>>> pop_list lotophagi
>>> print_string ${lotophagi[-1]}
nymphaea
------------------------------------------
==========================================
________________<heredoc?>________________
function pop_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__cl="${1}"
    die_unless_list_nonempty "${list_name__cl}"

    # Curtail such list.
    eval "${list_name__cl}[-1]=( )"
}

# --------------------( WASTELANDS                         )--------------------
    # If the passed delimiter is a colon, delimit such delimiter by periods.
#   split_token__sltssod=''
#   if is_string_contains "${delimiter__sltssod}" ':'; then
#       set_list_to_evaluation "${list_name__sltssod}" '${(s.:.)text__sltssod}'
    # Otherwise, delimit such delimiter by colons.
#   else
#       set_list_to_evaluation "${list_name__sltssod}"\
#           "\${(s:${delimiter__sltssod}:)text__sltssod}"
#   fi
#   die_unless_character delimiter__sltssod
#FUXME: Generalize to strings longer than one character. Surely this is feasible
#with an iterative PCRE, no?
# string set_list_to_string_words(string list_name, string text)
#
# Split the passed string on words into the passed list. Since zsh supports list-
# style character indexing and slicing out of the box, this function is useful
# only where explicit list types are required: e.g.,
#
#     >>> list words
#     >>> set_list_to_string_words words 'Time held me green and dying'
#     >>> print_string ${words[1]} ${words[4]} ${words[5]}
#     Time green dying
#function set_list_to_string_words() {
    # Validate passed arguments.
#    die_unless_args_2 'expected one list name and one string'
#    string list_name="${1}" __text__="${2}"
#    die_unless_list "${list_name}"

    # Split with parameter expansion flag "(z)".
#    set_list_to_evaluation "${list_name}" '${(z)__text__}'
#}
