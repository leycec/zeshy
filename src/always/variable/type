#!/usr/bin/env zsh
# ====================[ type                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle variable types.

# ....................{ EXCEPTIONS                         }....................
# For efficiency, such functions inline their implementations rather than call
# is_variable_type_glob_matches() -- an overly heavyweight if useful tester for
# functions called as commonly as these.

declare_alias_with_stdin <<'-\-'
void die_unless_variable_float(
    string variable_name,
    string error_message = "variable \"${variable_name}\" not a float")

Throw an exception with the passed message unless the passed variable was
declared to be a float.
-\-
function die_unless_variable_float() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__duvf="${1}"

    # If such variable does not exist, throw an exception. See is_variable() for
    # further details.
    is -n "${(P)variable_name__duvf+x}" si or
        die "variable \"${variable_name__duvf}\" undefined"

    # If such variable is of improper type, throw an exception. See
    # is_variable_float() for further details.
    is "${(tP)variable_name__duvf}" == 'float'* si or
        die "${2:-variable \"${variable_name__duvf}\" not a float but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvf}")}"
}

declare_alias_with_stdin <<'-\-'
void die_unless_variable_integer(
    string variable_name,
    string error_message = "variable \"${variable_name}\" not an integer")

Throw an exception with the passed message unless the passed variable was
declared to be an integer.
-\-
function die_unless_variable_integer() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__duvi="${1}"

    # If such variable does not exist, throw an exception. See is_variable() for
    # further details.
    is -n "${(P)variable_name__duvi+x}" si or
        die "variable \"${variable_name__duvi}\" undefined"

    # If such variable is of improper type, throw an exception. See
    # is_variable_integer() for further details.
    is "${(tP)variable_name__duvi}" == 'integer'* si or
        die "${2:-variable \"${variable_name__duvi}\" not an integer but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvi}")}"
}

declare_alias_with_stdin <<'-\-'
void die_unless_variable_string(
    string variable_name,
    string error_message = "variable \"${variable_name}\" not a string")

Throw an exception with the passed message unless the passed variable was
declared to be a string.
-\-
function die_unless_variable_string() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__duvs="${1}"

    # If such variable does not exist, throw an exception. See is_variable() for
    # further details.
    is -n "${(P)variable_name__duvs+x}" si or
        die "variable \"${variable_name__duvs}\" undefined"

    # If such variable is of improper type, throw an exception. See
    # is_variable_string() for further details.
    is "${(tP)variable_name__duvs}" == 'scalar'* si or
        die "${2:-variable \"${variable_name__duvs}\" not a string but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvs}")}"
}

declare_alias_with_stdin <<'-\-'
void {die_unless_variable_list, die_unless_list}(
    string variable_name,
    string error_message = "variable \"${variable_name}\" not a list")

Throw an exception with the passed message unless the passed variable was
declared to be a list.
-\-
function die_unless_variable_list die_unless_list() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__duvl="${1}"

    # If such variable does not exist, throw an exception. See is_variable() for
    # further details.
    is -n "${(P)variable_name__duvl+x}" si or
        die "variable \"${variable_name__duvl}\" undefined"

    # If such variable is of improper type, throw an exception. See
    # is_variable_list() for further details.
    is "${(tP)variable_name__duvl}" == ('list'|'array')* si or
        die "${2:-variable \"${variable_name__duvl}\" not a list but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvl}")}"
}

declare_alias_with_stdin <<'-\-'
void {die_unless_variable_map, die_unless_map}(
    string variable_name,
    string error_message = "\"${variable_name}\" not a map")

Throw an exception with the passed message unless the passed variable was
declared to be a map.
-\-
function die_unless_variable_map die_unless_map() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string variable_name__duvm="${1}"

    # If such variable does not exist, throw an exception. See is_variable() for
    # further details.
    is -n "${(P)variable_name__duvm+x}" si or
        die "variable \"${variable_name__duvm}\" undefined"

    # If such variable is of improper type, throw an exception. See
    # is_variable_map() for further details.
    is "${(tP)variable_name__duvm}" == 'association'* si or
        die "${2:-variable \"${variable_name__duvm}\" not a map but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvm}")}"
}

# ....................{ TESTERS                            }....................
declare_alias_with_stdin <<'-\-'
<globbable> [status: boolean] is_variable_type_glob_matches(
    string variable_name, string glob)

Return success if the type of the passed variable matches the passed glob: e.g.,

.is_variable_type_glob_matches()
==========================================
[source]
------------------------------------------
>>> map on_industry=(
...     "If"    "a man walk in the woods for love of them half of each day,"
...     "he"    "is in danger of being regarded as a loafer; but if he spends"
...     "his"   "whole day as a speculator, shearing off those woods and making"
...     "Earth" "bald before her time, he is esteemed an industrious"
...     "and"   "enterprising citizen. As if a town had no interest in
...     "its"   "forests but to cut them down!" )
>>> is_variable_type_glob_matches on_industry "map*" and
...     print_string "You must get your living by loving."
You must get your living by loving.
------------------------------------------
==========================================
-\-
function is_variable_type_glob_matches() {
    # Validate passed arguments.
    die_unless_args_2 'expected one variable name and one glob'
    string variable_name__ivtm="${1}" glob__ivtm="${2}"
    die_unless_variable "${variable_name__ivtm}"

    # If such variable exists, match its type against the passed glob.
    is_variable "${variable_name__ivtm}" and is_string_glob_matches\
        "$(get_variable_type "${variable_name__ivtm}")"\
        "${glob__ivtm}"
}

# ....................{ TESTERS ~ type                     }....................
declare_alias_with_stdin <<'-\-'
[status: boolean] is_variable_float(string variable_name)

Return success if the passed variable was declared to be a float.
-\-
function is_variable_float() {
    die_unless_arg 'expected one variable name'
    is_variable_type_glob_matches "${1}" 'float*'
}

declare_alias_with_stdin <<'-\-'
[status: boolean] is_variable_integer(string variable_name)

Return success if the passed variable was declared to be an integer.
-\-
function is_variable_integer() {
    die_unless_arg 'expected one variable name'
    is_variable_type_glob_matches "${1}" 'integer*'
}

declare_alias_with_stdin <<'-\-'
[status: boolean] is_variable_string(string variable_name)

Return success if the passed variable was declared to be a string.
-\-
function is_variable_string() {
    die_unless_arg 'expected one variable name'
    is_variable_type_glob_matches "${1}" 'scalar*'
}

declare_alias_with_stdin <<'-\-'
[status: boolean] {is_variable_list, is_list}(string variable_name)

Return success if the passed variable was declared to be a *list* (i.e.,
sequential array).
-\-
function is_variable_list is_list() {
    die_unless_arg 'expected one variable name'
    is_variable_type_glob_matches "${1}" '(list|array)*'
}

declare_alias_with_stdin <<'-\-'
[status: boolean] {is_variable_map, is_map}(string variable_name)

Return success if the passed variable was declared to be a *map* (i.e.,
associative array).
-\-
function is_variable_map is_map() {
    die_unless_arg 'expected one variable name'
    is_variable_type_glob_matches "${1}" 'association*'
}

# ....................{ GETTERS                            }....................
declare_alias_with_stdin <<'-\-'
string get_variable_type(string variable_name)

Get the lowercase type of the passed variable. Type names follow `zsh` rather
than `zeshy` precedent, including:

* `association` for map variables.
* `array` and `array-special` for `zsh`-specific canonical list variables (e.g.,
  ${match}, ${path}).
* `float` for float variables.
* `integer` for integer variables.
* `list` for list variables.
* `scalar` for string variables.

If the passed variable was declared to be local rather than global, such type is
also suffixed by `-local`: e.g.,

.get_variable_type()
==========================================
[source]
------------------------------------------
>>> list on_employment; on_employment=(
...     "Most men would feel insulted if it were proposed to employ them in"
...     "throwing stones over a wall, and then in throwing them back, merely"
...     "that they might earn their wages. But many are no more worthily"
...     "employed now." )
>>> get_variable_type on_employment
array-local
------------------------------------------
==========================================
-\-
function get_variable_type() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    string variable_name__gvt="${1}"
    die_unless_variable "${variable_name__gvt}"

    # Get such type. Dismantled, this is:
    #
    # * "P", expanding to the variable with the passed name.
    # * "t", expanding such variable's type.
    return_string "${(tP)variable_name__gvt}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: These functions are called commonly enough that their implementations
#should be inlined. is_variable_type_glob_matches() is *FAR* too heavyweight a
#function to call so frequently.

#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvm="${1}"
#   is_map "${variable_name__duvm}" or
#       die "${2:-\"${variable_name__duvm}\" not a map}"

    # Validate passed arguments.
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvl="${1}"

    #FUXME: Quite helpful; replicate above and elsewhere. Actually, since such
    #code would more-or-less be exact duplicates, extricate into a helper function.

    # If such variable is not a list...
#   is_list "${variable_name__duvl}" or
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvs="${1}"
#   is_variable_string "${variable_name__duvs}" or
#       die "${2:-variable \"${variable_name__duvs}\" not a string}"
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvi="${1}"
#   is_variable_integer "${variable_name__duvi}" or
#       die "${2:-variable \"${variable_name__duvi}\" not an integer}"

        # If such variable exists, append such variable's current definition to
        # the exception's message.
#       string message=
#       is_variable "${variable_name__duvl}" and {
#           message+=" "
#           message+="${ZESHY_ASCII_NEWLINE}original type: $(get_variable_type "${variable_name__duvl}")"
#       }

        # Throw such exception.
#   is_variable_float "${variable_name__duvf}" or
#       die "${2:-\"${variable_name__duvf}\" not an float}"
    # Global lists have type "list", local lists "list-local", and zsh-specific
    # global lists (e.g., "${path}") "array" or "array-special".
    # Global maps have type "association" and local maps "association-local".
#By `zsh` precedent, such type is
#of the form `${typename}-${locality}`, where `${typename}` is such type (e.g.,
#`array`, `string`) and `${locality}` is either:
#
#* `global`, if such variable is global.
#* `local`, if such variable is local.
#
#For example:

# is_variable_type_glob_matches "${variable_name__duvl}" 'array-local' and message+='hmm!!!!!!!'
#   print -r -- "${(tP)variable_name__gvt}"
#       "${glob__ivtm}" or {
#       print_string "variable type not matching \"${glob__ivtm}\": $(get_variable_type "${variable_name__ivtm}")"
#   }
#FUXME: Add support for function name synonyms to declare_function().
#void die_unless_variable_list [or] die_unless_list(
#void die_unless_variable_list [or] die_unless_list(
#void die_unless_variable_list <or> die_unless_list(
#void die_unless_variable_list OR die_unless_list(
#void die_unless_variable_list --or-- die_unless_list(
#void die_unless_variable_list --OR-- die_unless_list(
#void die_unless_variable_list|die_unless_list(

#string die_unless_list_documentation='  string variable_name,
#  string error_message = "\"${variable_name}\" not a list")
#
#Throw an exception unless the passed variable is a list.
#'
#
#declare_function "
#void die_unless_list(
#"
