#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *variable serialization* (i.e., export to and import from on-disk files).
/---

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_variable_binding(string variable_name1, string variable_name2, ...)

Print *variable bindings* (i.e., declarations followed by definitions) for all
passed variables, in the passed order: e.g.,

.get_variable_binding()
==========================================
[source]
------------------------------------------
>>> get_string_length_printable "${ZESHY_ASCII_NEWLINE}"
0
------------------------------------------
==========================================
/---
function get_variable_binding() {
    # Validate sanity.
    die_unless_args 'expected one or more variable names'

    # For each such variable, both declare and define such variable.
    # Ideally, the following command would suffice to do so:
    #
    # >>> typeset -p -- "${@}"
    #
    # Unfortunately, such command suffers numerous deficiencies (arguably,
    # reportable zsh bugs):
    #
    # * It fails to annotate global variables with option "-g".
    # * It fails to quote nonscalar variable elements when such elements are
    #   single shell words: e.g.,
    #
    # >>> list l; l=( and or is )
    # zsh: parse error near `&&'
    #
    # Typically, quoting single shell words is safe. As the prior example
    # demonstrates, however, if such words are equal to global alias names,
    # then the result is typically a fatal parse error.
    #
    # Only manually iterating such variables suffices to amend such issues.

    # Options to be passed to "typeset" for the current variable.
    string typeset_options__wfwv

    # List containing quoted copies of the current list variable's elements.
    list variable_elements__wfwv

    string variable_name__wfwv
    for    variable_name__wfwv ("${@}") {
        # If such variable is global, pass option "-g" to "typeset" below.
        # If such variable does *NOT* exist, throw an exception.
        if { is_variable_global "${variable_name__wfwv}" } {
            typeset_options__wfwv='-g '
        # Else, pass no additional options to "typeset".
        } else {
            typeset_options__wfwv=''
        }

        # If such variable is a list, quote all list elements.
        if { is_variable_list "${variable_name__wfwv}" } {
            variable_elements__wfwv=( \"${^${(P)variable_name__wfwv}}\" )
            output_stdin <</---
typeset ${typeset_options__wfwv}-a ${variable_name__wfwv}
${variable_name__wfwv}=( ${variable_elements__wfwv[@]} )
/---
        # Else if such variable is a map, quote all map keys and values.
        } elif { is_variable_map "${variable_name__wfwv}" } {
            variable_elements__wfwv=( \"${^${(kvP)variable_name__wfwv}}\" )
            output_stdin <</---
typeset ${typeset_options__wfwv}-A ${variable_name__wfwv}
${variable_name__wfwv}=( ${variable_elements__wfwv[@]} )
/---
        # Else, such variable is scalar. If passing at least one option to
        # "typeset", "typeset -p" output must be modified to do so.
        # Dismantled, this is:
        #
        # * "/", performing such replacement at most once.
        # * "(#s)", matching only at the start of such output.
        } else {
            output_string "${"$(typeset -p -- "${variable_name__wfwv}"\
                )"/(#s)typeset /typeset ${typeset_options__wfwv}}"
        }
        # Else, such variable is scalar and "typeset" output suffices.
        } else {
            typeset -p -- "${variable_name__wfwv}"
        }
    }
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
void write_file_with_variable(
    string filename,
    string variable_name1, string variable_name2, ...)

Overwrite the passed file with the current definitions of the passed variables.
Since such definitions conform to `zsh` syntax, such file will be a sourceable
`zsh` script. Consider calling source_shell_script() to deserialize such file
back into such variables.
/---
function write_file_with_variable() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one or more variable names and one filename'
    string filename="${1}"
    shift_arg

    # Overwrite such file. Dismantled, this is:
    #
    # * ">!", forcefully overwriting such file if already extant.
    {
        # For safety, prefix such script with the canonical zsh shebang line.
        get_zsh_shebang_line

        # Print such variables' bindings (i.e., declarations and definitions).
        get_variable_binding "${@}"
    } >! "${filename}"
}

declare_function_with_stdin <<'/---'
void append_file_with_variable(
    string filename,
    string variable_name1, string variable_name2, ...)

Append the passed file with the current definitions of the passed variables.
See write_file_with_variable() for further details.
/---
function append_file_with_variable() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one or more variable names and one filename'
    string filename="${1}"
    shift_arg

    # If such file already exists, append such variables.
    if { is_file "${filename}" } {
        # Print such variables' bindings (i.e., declarations and definitions).
        # Avoid operator ">>!" here; such operator creates such file if not
        # already extant, which in this case would create a shell script *NOT*
        # prefixed with a shebang line. Using operator ">>" instead ensures an
        # exception will be thrown in the unlikely event such file is moved or
        # removed in between the prior conditional succeeding and this command
        # running.
        get_variable_binding "${@}" >> "${filename}"
    # Else, such file does not exist. Call write_file_with_variable() to prefix
    # the contents of such file with a shebang line.
    } else {
        write_file_with_variable "${filename}" "${@}"
    }
}

# --------------------( WASTELANDS                         )--------------------
# Naturally, such logic
    # admits a subtle race condition: if such file is created after the call to
    # is_file() but before the call to typeset(), such file will not necessarily
    # be prepended with a shebang line. While irksome, this is mostly acceptable.
#       typeset -p -- "${@}" >>! "${filename}"
