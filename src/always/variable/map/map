#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *maps* (i.e., associative arrays).
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_map_nonempty(
    string map_name,
    string error_message = "\"${map_name}\" not a nonempty map")

Throw an exception with the passed message unless the passed map is nonempty.
/---
function die_unless_map_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string map_name__dumn="${1}"
    is_map_nonempty "${map_name__dumn}" or
        die "${2:-\"${map_name__dumn}\" not a nonempty map}"
}

# ....................{ EXCEPTIONS ~ key                   }....................
declare_function_with_stdin <<'/---'
void die_unless_map_key(
    string map_name,
    string key,
    string error_message = "map \"${map_name}\" has no key \"${key}\"")

Throw an exception with the passed message unless the passed map contains the
passed key.
/---
function die_unless_map_key() {
    die_unless_args_2_to_3\
        'expected one map name, one key, and optional error message'
    string map_name__dumk="${1}" key__dumk="${2}"
    is_map_key "${map_name__dumk}" "${key__dumk}" or
        die "${2:-map \"${map_name__dumk}\" has no key \"${key__dumk}\"}"
}

# ....................{ TESTERS ~ empty                    }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_map_empty(string map_name)

Return success if the passed map is empty.
/---
function is_map_empty() {
    not  is_map_nonempty "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_map_nonempty(string map_name)

Return success if the passed map is nonempty.
/---
function is_map_nonempty() {
    die_unless_arg 'expected one map name'
    string map_name__imn="${1}"
    is_map "${map_name__imn}" and (( ${#${(@P)map_name__imn}} ))
}

# ....................{ TESTERS ~ key                      }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_map_key(
    string map_name,
    string key1, string key2, ...)

Return success if the passed map contains all passed keys.
/---
function is_map_key() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__imk="${1}"
    die_unless_map "${map_name__imk}"

    # Test such map. Ideally, such test would leverage indirect parameter
    # expansion rather than requiring an "eval" statement: e.g.,
    #
    #   is -z "${${(k@P)map_name__imk}[(ie)${2}]-}" si
    #
    # Unfortunately, indirect parameter expansion is currently broken with
    # respect to maps. "Well, there's always eval."
    #
    # If only one key was passed, avoid looping for efficiency.
    if { is_arg } {
        eval "(( \${+${map_name__imk}[\${2}]} )) and return_exit_status"
    # Else, more than one key was passed. For efficiency, embed the entire loop
    # in a similar "eval" statement.
    } else {
        # Remove the map name from the argument list.
        shift_arg

        # Test such map.
        eval "
        string key__imk
        for    key__imk (\"\${@}\") {
            (( \${+${map_name__imk}[\${key__imk}]} )) or return_false
        }
        return_true"
    }
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_map_size(string map_name)

Get the number of key-value pairs in the passed map. By definition, this is
equivalent to the number of keys and the number of values in such map: e.g.,

.get_map_size()
==========================================
[source]
------------------------------------------
>>> map on_compromise; on_compromise=(
...     "I'm"       "interested in living in a world that has more wild"
...     "salmon"    "every year than the year before. A world that has more"
...     "migratory" "songbirds every year than the year before. A world that"
...     "has"       "less dioxins and flame retardants in mothers' breast milk."
...     "A"         "world not being destroyed. A world where krill populations"
...     "aren't"    "collapsing. A world where there are not dead zones in the"
...     "oceans."   "A world not being systematically dismantled. I want to"
...     "live"      "in a world that is not being killed. I will do whatever it"
...     "takes"     "to get there." )
>>> get_map_size on_compromise
9
------------------------------------------
==========================================
/---
function get_map_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gms="${1}"
    die_unless_map "${map_name__gms}"

    # Get such map's size.
    output_string ${#${(k@P)map_name__gms}}
}

# ....................{ GETTERS ~ value                    }....................
declare_function_with_stdin <<'/---'
string get_map_key_value(string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or throw an exception otherwise: e.g.,

.get_map_key_value()
==========================================
[source]
------------------------------------------
>>> map on_easter_island; on_easter_island=(
...     "The"     "Easter Islanders, aware that they were almost completely"
...     "isolated "from the rest of the world, must surely have realised that"
...     "their"   "very existence depended on the limited resources of a small"
...     "island." "After all it was small enough for them to walk round the"
...     "entire"  "island in a day or so and see for themselves what"
...     "was"     "happening to the forests. Yet they were unable to devise a"
...     "system"  "that allowed them to find the right balance with"
...     "their"   "environment. Instead vital resources were steadily consumed"
...     "until"   "finally none were left. Indeed, at the very time when the"
...     "limitations" "of the island must have become starkly apparent the"
...     "competition" "between the clans for the available timber seems to have"
...     "intensified" "as more and more statues were carved and moved across"
...     "the"     "island in an attempt to secure prestige and status."
... )
>>> get_map_key_value on_easter_island their
environment. Instead vital resources were steadily consumed
------------------------------------------
==========================================
/---
function get_map_key_value() {
    get_map_key_value_if_found "${@}" or die_unless_map_key "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_map_key_value_if_found(
    string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or return failure otherwise: e.g.,

.get_map_key_value_if_found()
==========================================
[source]
------------------------------------------
>>> map on_economics; on_economics=(
...     "Economics" "is not value free, and no amount of abstraction can make"
...     "it"        "value free. The econometricians' search for equations that"
...     "will"      "explain the economy is forever doomed to frustration. It"
...     "is"        "often said that their models don't work, because, on the"
...     "one"       "hand, the variables are too many and, on the other, the"
...     "statistical" "data are too sparse. But the physical universe is as"
...     "various"     "as the economic universe (they are, to repeat, both"
...     "infinite),"  "and Newton had fewer data and less powerful means of"
...     "calculation" "than are at the disposal of Jan Tinbergen and his"
...     "econometrician" "followers. The difference is fundamental, and the"
...     "failure"     "to understand it reduces much of modern economics to a"
...     "game"        "that unfortunately has serious consequences."
... )
>>> get_map_key_value_if_found on_economics "invisible hand" or print_string\
...     "To be important, therefore, a hypothesis must be descriptively false in its assumptions."
To be important, therefore, a hypothesis must be descriptively false in its assumptions.
/---
function get_map_key_value_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__gmkvif="${1}" key__gmkvif="${2}"
    die_unless_map "${map_name__gmkvif}"

    # Get such value if found or return failure. Note the sensible expression
    # "${${(@P)map_name}[${key__gmkvif}]}" always expands to the empty string
    # as does every sensible permutation of such expression (e.g., adding "k").
    # It shouldn't; it certainly doesn't for lists. But since it does, we
    # necessarily resort to the usual "eval" kludge.
    #
    # Needless to say, this is shockingly difficult.
    if { is_map_key "${map_name__gmkvif}" "${key__gmkvif}" } {
        # For efficiency, avoid calling return_string() and hence copying such
        # key value unnecessarily.
        eval "output_string \"\${${map_name__gmkvif}[\${key__gmkvif}]}\""
        return_true
    } else {
        return_false
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_map_to_map(
    string target_map_name,
    string source_map_name1, string source_map_name2, ...)

Set the passed target map to the merger of the passed source maps, in the passed
order. Specifically, clear such target map and for each source map in the passed
order, copy all key-value pairs of such source map into such target map. Hence,
key-value pairs of source maps passed later take higher precedence than those of
source maps passed earlier. If only one source map is passed, this reduces to
simply setting such target map to such source map: e.g.,

.set_map_to_map()
==========================================
[source]
------------------------------------------
>>> map for_unity on_wants on_needs
>>> on_wants=(
...     "We"   "have developed speed, but"
...     "we"   "have shut ourselves in. Machinery that gives abundance has"
...     "left" "us in want. Our knowledge has made us cynical. Our cleverness,"
...     "hard" "and unkind. We think too much and feel too little." )
>>> on_needs=(
...     "More" "than machinery"
...     "we"   "need humanity. More than cleverness we need kindness"
...     "and"  "gentleness. Without these qualities, life will be violent and"
...     "all"  "will be lost." )
>>> set_map_to_map for_unity on_wants on_needs
>>> print_map for_unity
We: have developed speed, but
we: need humanity. More than cleverness we need kindness
left: us in want. Our knowledge has made us cynical. Our cleverness,
hard: and unkind. We think too much and feel too little.
More: than machinery
and: gentleness. Without these qualities, life will be violent and
all: will be lost.
------------------------------------------
/---
function set_map_to_map() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one target map name and at least one source map name'
    string map_name_target__smtms="${1}" map_name_source__smtms
    die_unless_map "${map_name_target__smtms}"
    shift_arg

    # If only one source map was passed, copy such map into such target map.
    # Since the for loop below would also suffice to copy such map, this is
    # merely a minor optimization.
    if { is_arg } {
        die_unless_map "${map_name_source__smtms}"
        eval "${map_name_target__smtm}=( \"\${(kv@P)map_name_source__smtm}\" )"
    # Else, two or more source maps were passed and hence must be iteratively
    # merged into such target map.
    } else {
        eval "
        ${map_name_target__smtms}=()
        for    map_name_source__smtms (\"\${@}\") {
            die_unless_map \"\${map_name_source__smtms}\"
            ${map_name_target__smtms}+=( \"\${(kv@P)map_name_source__smtms}\" )
        }"
    }
}

# ....................{ SETTERS ~ list                     }....................
declare_function_with_stdin <<'/---'
void set_map_to_list_set_inverted(string map_name, string list_set_name)

Set the passed map to the inversion of the passed list set, such that the keys
of such map are the elements of such list set and the values of such map are the
corresponding 1-based indices of such elements: e.g.,

.set_map_to_list_set_inverted()
==========================================
[source]
------------------------------------------
>>> map on_the_way_of_life
>>> list_set on_the_good_earth; on_the_good_earth=(
...     "We all want to help one another. Human beings are like that. We want"
...     "to live by each other's happiness — not by each other's misery. We"
...     "don't want to hate and despise one another. In this world there is"
...     "room for everyone. And the good earth is rich and can provide for"
...     "everyone. The way of life can be free and "beautiful, but we have lost"
...     "the way." )
>>> set_map_to_list_set_inverted on_the_way_of_life on_the_good_earth
>>> print_map on_the_way_of_life
We all want to help one another. Human beings are like that. We want: 1
to live by each other's happiness — not by each other's misery. We: 2
don't want to hate and despise one another. In this world there is: 3
room for everyone. And the good earth is rich and can provide for: 4
everyone. The way of life can be free and "beautiful, but we have lost: 5
the way.: 6
>>> print_string "${on_the_way_of_life[the way.]}"
6
------------------------------------------
/---
function set_map_to_list_set_inverted() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one list name'
    string map_name__smtli="${1}" list_set_name__smtli="${2}"
    die_unless_map "${map_name__smtli}"
    die_unless_list_set_set "${list_set_name__smtli}"

    # Get the size of such list set.
    integer list_set_size__smtli
    list_set_size__smtli="$(get_list_size "${list_set_name__smtli}")"

    # Set such map to such list set inverted.
    eval "
    integer list_set_index__smtli
    for ((  list_set_index__smtli = 1;
            list_set_index__smtli <= list_set_size__smtli;
            list_set_index__smtli++)) {
        ${map_name__smtli}[\${${list_set_name__smtli}[${list_set_index__smtli}]}]=${list_set_index__smtli}
    }"
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string convert_map_to_string(string map_name)

Get a string corresponding to the contents of the map with the passed name.
See convert_list_to_string() for further details.
/---
function convert_map_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__cvmts="${1}"
    die_unless_map "${map_name__cvmts}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    return_string "${(qqkv@P)map_name__cvmts}"
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string print_map(string map_name)

Print the passed map in human-readable form.
/---
function print_map() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__pm="${1}"
    die_unless_map "${map_name__pm}"

    #FIXME: Style with colors.
    #FIXME: Consider aligning keys into columns. Of course, this is only really
    #feasible if all keys are sufficiently short; even a single lengthy key
    #renders the entire effort unprintable. Nonetheless, it seems worth the
    #attempt, if all keys are sufficiently short.

    for_key_value_pairs "${map_name__pm}" '
        # If such key contains a colon or whitespace, quote such key. For
        # efficiency, inline such test.
        if is "${KEY}" == *[:[:space:]]* si {
            print_string "\"$(escape_string_double_quotes "${KEY}")\": ${VALUE}"
        # Else, print such key as is.
        } else {
            print_string "${KEY}: ${VALUE}"
        }'
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'/---'
string for_map_key_value_pairs(
    string map_name,
    string key_string_name = "KEY",
    string value_string_name = "VALUE",
    string command)

Run the passed command for each key of the passed map in arbitrary order,
setting the first passed local variable (defaulting to `${KEY}`) to each such
key and the second passed local variable (defaulting to `${VALUE}`) to the
value for such key: e.g.,

.for_map_key_value_pairs()
==========================================
[source]
------------------------------------------
>>> map on_flesh; on_flesh=(
...     '"Imagine,"' 'he said,'
...     '"All'       'the flesh that is eaten'
...     'The teeth'  'tearing into it'
...     'The tongue' 'tasting it''s savour'
...     'And'        'the hunger for that taste'
...     'Now'        'take away that flesh," he said,'
...     '"Take'      'away the teeth and the tongue'
...     'The taste'  'and the hunger'
...     'Take'       'away everything as it is'
...     'That'       'was my plan'
...     'My'         'own special plan for this world"' )
>>> for_map_key_value_pairs on_flesh laughter screams\
...     'is_string_prefix "${laughter}" "The" and
...         output_string "${laughter} -- ${screams}"'
The teeth -- tearing into it
The tongue -- tasting it's savour
The taste -- and the hunger
------------------------------------------
==========================================
/---
function for_map_key_value_pairs() {
    # Validate passed arguments.
    die_unless_args_2_to_4\
        'expected one map name, optional key name, optional value name, and one command'
    string\
        map_name__fmkvp="${1}"\
        key_name__fmkvp='KEY'\
        value_name__fmkvp='VALUE'\
        command__fmkvp="${@[-1]}"
    is_args_3_to_4 and key_name__fmkvp="${2}"
    is_args_4    and value_name__fmkvp="${3}"
    die_unless_map "${map_name__fmkvp}"
    die_unless_variable_names "${key_name__fmkvp}" "${value_name__fmkvp}"
    die_unless_string_nonempty "${command__fmkvp}" 'expected nonempty command'

    # Iterate such pairs. For efficiency, evaluate once rather than on each
    # iteration.
    eval "
    string ${key_name__fmkvp} ${value_name__fmkvp}
    for    ${key_name__fmkvp} ${value_name__fmkvp} (
        \"\${(kv@)${map_name__fmkvp}}\") {
        ${command__fmkvp}
    }"
}

# ....................{ ITERATORS ~ key                    }....................
declare_function_with_stdin <<'/---'
string for_map_keys(
    string map_name,
    string key_string_name = "KEY",
    string command)

Run the passed command for each key of the passed map in arbitrary order,
setting the passed local variable (defaulting to `${KEY}`) to each such key:
e.g.,

.for_map_keys()
==========================================
[source]
------------------------------------------
>>> map on_this_world; on_brainless_beacons=(
...     "When everyone"   "you have ever loved is finally gone"
...     "When everything" "you have ever wanted is finally done with"
...     "When all"        "of your nightmares are for a time obscured"
...     "As"              "by a shining brainless beacon"
...     "Or a blinding"   "eclipse of the many terrible shapes of this world"
...     "When you"        "are calm and joyful"
...     "And"             "finally entirely alone"
...     "Then"            "in a great new darkness"
...     "You"             "will finally execute your special plan" )
>>> for_map_keys on_brainless_beacons tiny_limbs\
...     'is_string_prefix "${tiny_limbs}" "When" and
...         output_string "${tiny_limbs} -- ${on_this_world[${tiny_limbs}]}"'
When everyone -- you have ever loved is finally gone
When everything -- you have ever wanted is finally done with
When all -- of your nightmares are for a time obscured
When you -- are calm and joyful
------------------------------------------
==========================================
/---
function for_map_keys() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one map name, optional key name, and one command'
    string map_name__fmk="${1}" key_name__fmk='KEY' command__fmk="${@[-1]}"
    is_args_3 and key_name__fmk="${2}"
    die_unless_map "${map_name__fmk}"
    die_unless_variable_name "${key_name__fmk}"
    die_unless_string_nonempty "${command__fmk}" 'expected nonempty command'

    # Iterate such keys. For efficiency, evaluate once rather than on each
    # iteration.
    eval "
    string ${key_name__fmk}
    for    ${key_name__fmk} (\"\${(k@)${map_name__fmk}}\") {
        ${command__fmk}
    }"
}

#FIXME: Actually, we *CAN* implement a comparable
#for_map_key_value_pairs_with_keys_sorted_lexically_ascending(). Such function
#should simply defer to this function, preceding the passed command in the
#loop body with something simply resembling:
#     ${value_name__fmkvpwksla}=\"\${${map_name__fmkvpwksla}[\${(P)key_name__fmkvpwksla}]}\"
# Sadly, implementing a comparable
# for_map_key_value_pairs_with_keys_sorted_lexically_ascending() is currently
# infeasible. See the function body for further details.
declare_function_with_stdin <<'/---'
string for_map_keys_sorted_lexically_ascending(
    string map_name,
    string key_string_name = "KEY",
    string command)

Run the passed command for each key of the passed map in lexical ascending
order, setting the passed local variable (defaulting to `${KEY}`) to each
such key: e.g.,

.for_map_keys_sorted_lexically_ascending()
==========================================
[source]
------------------------------------------
>>> map on_going_home; on_going_home=(
...     "Even"  "while I dreamed I prayed that what I saw was only fear and"
...     "no"    "foretelling, for I saw the last known landscape destroyed for"
...     "the"   "sake of the objective, the soil bludgeoned, the rock blasted."
...     "Those" "who had wanted to go home would never get there now." )
>>> for_map_keys_sorted_lexically_ascending on_going_home far_distance\
...     'is_string_glob_matches "${far_distance}" [Tt]h* and
...         output_string "${far_distance} / ${on_going_home[${far_distance}]}"'
the / sake of the objective, the soil bludgeoned, the rock blasted.
Those / who had wanted to go home would never get there now.
------------------------------------------
==========================================
/---
function for_map_keys_sorted_lexically_ascending() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize all changes to for_map_keys_sorted_lexically_descending().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one map name, optional key name, and one command'
    string\
        map_name__fmksla="${1}"\
        key_name__fmksla='KEY'\
        command__fmksla="${@[-1]}"
    is_args_3 and key_name__fmksla="${2}"
    die_unless_map "${map_name__fmksla}"
    die_unless_variable_name "${key_name__fmksla}"
    die_unless_string_nonempty "${command__fmksla}" 'expected nonempty command'

    # Iterate such keys. For efficiency, evaluate once rather than on each
    # iteration. When paired with flag "v", flag "o" iterates all keys and
    # values and not simply keys in lexically ascending order. Since such
    # iteration is entirely unhelpful, there exists no corresponding
    # for_map_key_value_pairs_with_keys_sorted_lexically_ascending().
    eval "
    string ${key_name__fmksla}
    for    ${key_name__fmksla} (\"\${(ok@)${map_name__fmksla}}\") {
        ${command__fmksla}
    }"
}

declare_function_with_stdin <<'/---'
string for_map_keys_sorted_lexically_descending(
    string map_name,
    string key_string_name = "KEY",
    string command)

Run the passed command for each key of the passed map in lexical descending
order, setting the passed local variable (defaulting to `${KEY}`) to each
such key: e.g.,

.for_map_keys_sorted_lexically_descending()
==========================================
[source]
------------------------------------------
>>> map on_the_objective; on_the_objective=(
...     "I"      "visited the offices where for the sake of the objective"
...     "the"    "planners planned at blank desks set in rows. I visited the"
...     "loud"   "factories where the machines were made that would drive"
...     "ever"   "forward toward the objective. I saw the forest reduced to"
...     "stumps" "and gullies; I saw the poisoned river, the mountain cast"
...     "into"   "the valley; I came to the city that nobody recognized because"
...     "it"     "looked like every other city. I saw the passages worn"
...     "by"     "the unnumbered footfalls of those whose eyes were fixed"
...     "upon"   "the objective." )
>>> for_map_keys_sorted_lexically_descending on_the_objective forgotten\
...     'is_string_glob_matches "${forgotten}" [Ii]* and
...         output_string "${forgotten} / ${on_the_objective[${forgotten}]}"'
I / visited the offices where for the sake of the objective
into / the valley; I came to the city that nobody recognized because
it / looked like every other city. I saw the passages worn
------------------------------------------
==========================================
/---
function for_map_keys_sorted_lexically_descending() {
    # See for_map_keys_sorted_lexically_ascending() for further details.
    die_unless_args_2_to_3\
        'expected one map name, optional key name, and one command'
    string\
        map_name__fmksld="${1}"\
        key_name__fmksld='KEY'\
        command__fmksld="${@[-1]}"
    is_args_3 and key_name__fmksld="${2}"
    die_unless_map "${map_name__fmksld}"
    die_unless_variable_name "${key_name__fmksld}"
    die_unless_string_nonempty "${command__fmksld}" 'expected nonempty command'
    eval "
    string ${key_name__fmksld}
    for    ${key_name__fmksld} (\"\${(Ok@)${map_name__fmksld}}\") {
        ${command__fmksld}
    }"
}

# --------------------( WASTELANDS                         )--------------------
#>>> map hollow_moon
#>>> list_set adams_curse; adams_curse=( We sat grown quiet at the name of love )
#>>> set_map_to_list_set_inverted hollow_moon adams_curse
#>>> print_map hollow_moon
#We: 1
#sat: 2
#grown: 3
#quiet: 4
#at: 5
#the: 6
#name: 7
#of: 8
#love: 9

    # . Clear such target map and for each such source map, copy such map's
    # key-value pairs into such target map. For efficiency, inline such logic.
#FUXME: Pure madness. Efficiency isn't a concern in this context. (When it is,
#the caller simply inlines such implementation.) Hence:
#
#* Excise this function.
#* Rename set_map_to_maps() to set_map_to_map().
#declare_function_with_stdin <<'/---'
#string set_map_to_map(string target_map_name, string source_map_name)
#
#Set the passed target to the passed source map (i.e., copy the latter into the
#former): e.g.,
#
#.set_map_to_map()
#==========================================
#[source]
#------------------------------------------
#>>> map in_this_world the_good_earth
#>>> the_good_earth=(
#...     "We all"  "want to help one another. Human beings are like that."
#...     "We want" "to live by each other's happiness — not by each other's"
#...     "misery." "We don't want to hate and despise one another."
#...     "In"      "this world there is room for everyone. And the good earth is"
#...     "rich"    "and can provide for everyone. The way of life can be free"
#...     "and"     "beautiful, but we have lost the way." )
#>>> set_map_to_map  in_this_world the_good_earth
#>>> print_string "${in_this_world[and]}"
#beautiful, but we have lost the way.
#------------------------------------------
#==========================================
#/---
#function set_map_to_map() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one target map name and one source map name'
#    string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
#    die_unless_map "${map_name_target__smtm}"
#    die_unless_map "${map_name_source__smtm}"
#
#    # Copy such map.
#    eval "${map_name_target__smtm}=( \"\${(kv@P)map_name_source__smtm}\" )"
#}

#       {
#       string map_name__gmkv="${1}" key__gmkv="${2}"
#       die "map \"${map_name__gmkv}\" has no key \"${key__gmkv}\""
#   }

    # Test such map, inlined for efficiency. Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'i', expanding to the index of such key if such map contains such key or
    #   the empty string otherwise.
    # * 'e', matching such key as a plain string rather than extended pattern.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#FUXME: To retain orthogonolity with the builtin for() iterator, the optional
#local variable names should *ALWAYS* be passed first. Hence, change this to:
#
#string for_map_key_value_pairs(
#    string key_string_name = "KEY",
#    string value_string_name = "VALUE",
#    string map_name,
#    string command)
# Since this overwrites all prior values for such keys within such
# target map, key-value pairs from later source maps take higher precedence than
# those from earlier source maps.
#FUXME: Excise. This should be called *NOWHERE*.
#declare_function '
#void set_map_to_evaluation(string map_name, string code)
#
#Set the passed map to the dynamic evaluation of the passed code in a map
#context (i.e., in an expression resembling "( ${code} )"): e.g.,
#
#    >>> map sopa
#    >>> set_map_to_evaluation sopa ''${:-stop officer perjury act}''
#    >>> print_string "${sopa[perjury]}"
#    act
#'
#function set_map_to_evaluation() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one code snippet'
#    string map_name__smte="${1}"
#    die_unless_map "${map_name__smte}"
#
#    # Set such map.
##   print_string "set map ${map_name__smte}=( ${2} )"
#    eval "${map_name__smte}=( ${2} )"
#}

# ....................{ GETTERS ~ key-value                }....................
#declare_function_with_stdin <<'/---'
#string get_map_key_values(string map_name)
#
#Get all key-value pairs of the passed map in arbitrary order, delimited by the
#current shell word separator(s) and hence suitable for iteration. Only call this
#function when *ALL* map values are guaranteed *NOT* to contain such separator
#(i.e., canonical global ${IFS}, defaulting to newline, space, and tab); if at
#least one map value could possibly contain such separator(s), consider iterating
#with get_map_keys() instead: e.g.,
#
#    >>> map lal_ded; lal_ded=( For ever we come, for ever we go )
#    >>> for lalla vakh ( $(get_map_keys lal_ded) ) {
#    ...     print_string "key: ${lalla} -- value: ${vakh}"
#    ... }
#    key: For -- value: ever
#    key: we -- value: come,
#    key: for -- value: ever
#    key: we -- value: go
#/---
#function get_map_key_values() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    die_unless_map "${map_name__gmk}"
#
#    # Get such pairs.
#    print_string "${(kv@P)map_name__gmk}"
#}

# ....................{ GETTERS ~ keys                     }....................
#FUXME: *THIS IS TERRIBLE*. So are the getters below, for the simple reason that
#they only work as documented when no key contains whitespace. What? That's pure
#nonsense. Instead, define a new family of for_map_keys*() iterators below and
#translate all existing calls to get_map_keys*() functions to such iterators.
#declare_function_with_stdin <<'/---'
#string get_map_keys(string map_name)
#
#List all keys of the passed map in arbitrary order, delimited by the current
#shell word separator(s) and hence suitable for iteration: e.g.,
#
#.get_map_keys()
#==========================================
#[source]
#------------------------------------------
#>>> map passchendaele; passchendaele=( the "old Lie" dulce et decorum est )
#>>> for dead ( $(get_map_keys passchendaele) ) {
#...     print_string "key: ${dead} -- value: ${passchendaele[${dead}]}"
#... }
#key: the -- value: old Lie
#key: dulce -- value: et
#key: decorum -- value: est
#------------------------------------------
#==========================================
#/---
#function get_map_keys() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    die_unless_map "${map_name__gmk}"
#
#    # Get such keys.
#    output_string "${(k@P)map_name__gmk}"
#}
#
#declare_function_with_stdin <<'/---'
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map in lexical ascending order, delimited by the
#current shell word separator(s) and hence suitable for iteration.
#/---
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    die_unless_map "${map_name__gmksla}"
#
#    # Sort such keys.
#    print_string "${(ko@P)map_name__gmksla}"
#}
#
#declare_function '
#string get_map_keys_sorted_lexically_descending(string map_name)
#
#Get all keys of the passed map in lexical descending order, delimited by the
#current shell word separator(s) and hence suitable for iteration
#'
#function get_map_keys_sorted_lexically_descending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    die_unless_map "${map_name__gmksla}"
#
#    # Sort such keys.
#    print_string "${(kO@P)map_name__gmksla}"
#}

#FUXME: O.K.; so, it'd be great to be able to specify names for such string
#locals. In the case of "io/color/color", for example, we want keys to be in
#string local ${color_style_name} and values to be in string local
#${color_name}. I'm generally intolerant of optional parameters -- but, here
#they really do seem to make sense. The function call remains equally readable
#with or without such parameters specified: e.g.,
#
#    for_map_key_value_pairs ZESHY_COLOR_8 color_style_name color_name\
#        'ZESHY_COLOR_2[${color_name}]='
#
#I dig it. Easy to support; easy to call. No need for separate functions, here.

#   if { is_args_3 } {
#       key_name="${2}"
#   }
#   elif { is_args_4 } {
#       key_name="${2}"
#       value_name="${3}"
#   }

    # Print such map.
#   for key (${(k)${(k@P)map_name__pm}}) {
#       # If such key contains a colon or whitespace, quote such key.
#       if { is_string_glob_matches "${key}" [:[:space:]] } {
#           print_string "\"$(escape_string_double_quotes "${key}")\": ${${(k@P)map_name__pm}[${key}]}"
#       # Else, print such key as is.
#       } else {
#           print_string "${key}: ${${(k@P)map_name__pm}[${key}]}"
#       }
#   }
    # Current key-value pair.
#   string KEY VALUE

#function yiyi() {
#    get_map_key_value_if_found ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "zsh"
#    print $(get_map_key_value_if_found ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "zsh")
#}

        #FUXME: Generalize quote escaping into a new function
        #escape_string_double_quotes(). It's complex enough to warrant such
        #generalization.
#           print_string "\"${key//\"/\\\"}\": ${${(k@P)map_name__pm}[${key}]}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#   is_string_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"

#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#declare_function '
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    die_unless_map "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # is_map_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_string_nonempty "${__
#   print_string ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_string_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
