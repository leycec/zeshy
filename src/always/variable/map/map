#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *maps* (i.e., associative arrays).
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_map_nonempty(
    string map_name,
    string error_message = "\$\{${map_name}\} not a nonempty map")

Throw an exception with the passed message unless the passed map is nonempty.
/---
function die_unless_map_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string map_name__dumn="${1}"
    is_map_nonempty "${map_name__dumn}" or
        die "${2:-\$\{${map_name__dumn}\} not a nonempty map}"
}

# ....................{ EXCEPTIONS ~ key                   }....................
declare_function_with_stdin <<'/---'
void die_unless_map_key(
    string map_name,
    string key,
    string error_message =
        "map \$\{${map_name__dumk}\} contains no key \"${key__dumk}\"")

Throw an exception with the passed message unless the passed map contains the
passed key. See is_map_key() for further details.
/---
function die_unless_map_key() {
    die_unless_args_2_to_3\
        'expected one map name, one key, and optional error message'
    string map_name__dumk="${1}" key__dumk="${2}"
    is_map_key "${map_name__dumk}" "${key__dumk}" or
        die "${3:-map \$\{${map_name__dumk}\} contains no key \"${key__dumk}\"}"
}

declare_function_with_stdin <<'/---'
void die_unless_map_keys(string map_name, string key1, string key2, ...)

Throw an exception with a stock message unless the passed map contains all
passed keys. See is_map_key() for further details.
/---
function die_unless_map_keys() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one map name and at least one key'
    string map_name__dumks="${1}" key__dumks
    shift_arg

    # To throw human-readable exception messages, iterate such map here.
    for key__dumks ("${@}") {
        die_unless_map_key "${map_name__dumks}" "${key__dumks}"
    }
}

# ....................{ TESTERS ~ empty                    }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_map_empty(string map_name)

Return success if the passed map is empty.
/---
function is_map_empty() {
    not  is_map_nonempty "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_map_nonempty(string map_name)

Return success if the passed map is nonempty.
/---
function is_map_nonempty() {
    die_unless_arg 'expected one map name'
    string map_name__imn="${1}"
    is_map "${map_name__imn}" and (( ${#${(@P)map_name__imn}} ))
}

# ....................{ TESTERS ~ key                      }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_map_key(string map_name, string key1, string key2, ...)

Return success if the passed map contains all passed keys: e.g.,

.is_map_key()
==========================================
[source]
------------------------------------------
>>> map on_lebensraum; on_lebensraum=(
...    "\"Solving"  "[our economic problems] wasn't difficult. To begin with, we"
...    "never"      "allowed ourselves to produce more children than we could"
...    "feed,"      "clothe, house, and educate into something like full"
...    "humanity."  "Not being overpopulated, we have plenty. But, although we"
...    "have"       "plenty, we've managed to resist the temptation that the"
...    "West"       "has now succumbed to — the temptation to overconsume. We"
...    "don't"      "give ourselves coronaries by guzzling six times as much"
...    "saturated"  "fat as we need. We don't hypnotize ourselves into believing"
...    "that"       "two television sets will make us twice as happy as one"
...    "television" "set. And finally we don't spend a quarter of the gross"
...    "national"   "product preparing for World War III or even World War's"
...    "baby"       "brother, Local War MMMCCCXXXIII. Armaments, universal debt,"
...    "and"        "planned obsolescence — those are the three pillars of"
...    "Western"    "prosperity. If war, waste, and moneylenders were abolished,"
...    "you'd"      "collapse. And while you people are overconsuming, the rest"
...    "of"         "the world sinks more and more deeply into chronic disaster."
...    "Ignorance," "militarism and breeding, these three — and the greatest of"
...    "these"      "is breeding. No hope, not the slightest possibility, of"
...    "solving"    "the economic problems until that's under control. As"
...    "population" "rushes up, prosperity goes down.\" He traced the descending"
...    "curve"      "with an outstretched finger. \"And as prosperity goes down,"
...    "discontent" "and rebellion,\" (the forefinger moved up again),"
...    "\"political" "ruthlessness and one-party rule, nationalism and"
...    "bellicosity" "begin to rise. Another ten or fifteen years of uninhibited"
...    "breeding,"   "and the whole world, from China to Peru via Africa and the"
...    "Middle"      "East, will be fairly crawling with Great Leaders, all"
...    "dedicated"   "to the suppression of freedom, all armed to the teeth by"
...    "Russia"      "or America or, better still, by both at once, all waving"
...    "flags,"      "all screaming for Lebensraum." )
>>> is_map_key on_lebensraum "humanity." "have" "saturated" and print_string
...     "In any race between human numbers and natural resources, time is against us."
In any race between human numbers and natural resources, time is against us.
------------------------------------------
==========================================
/---
function is_map_key() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one map name and at least one key'
    string map_name__imk="${1}"
    die_unless_map "${map_name__imk}"
    shift_arg

    # Test such map. Ideally, such test would leverage indirect parameter
    # expansion rather than requiring an "eval" statement: e.g.,
    #
    #   is -z "${${(k@P)map_name__imk}[(ie)${2}]-}" si
    #
    # Unfortunately, indirect parameter expansion is currently broken with
    # respect to maps. "Well, there's always eval."
    #
    # If only one key was passed, avoid looping for efficiency.
    if { is_arg } {
        eval '(( ${+'${map_name__imk}'[${1}]} )) and return_exit_status'
    # Else, more than one key was passed. For efficiency, embed the entire loop
    # in a similar "eval" statement.
    } else {
        # Test such map.
        eval '
        string key__imk
        for    key__imk ("${@}") {
            (( ${+'${map_name__imk}'[${key__imk}]} )) or return_false
        }' or return_false
        return_true
    }
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_map_size(string map_name)

Get the number of key-value pairs in the passed map. By definition, this is
equivalent to the number of keys and the number of values in such map: e.g.,

.get_map_size()
==========================================
[source]
------------------------------------------
>>> map on_compromise; on_compromise=(
...     "I'm"       "interested in living in a world that has more wild"
...     "salmon"    "every year than the year before. A world that has more"
...     "migratory" "songbirds every year than the year before. A world that"
...     "has"       "less dioxins and flame retardants in mothers' breast milk."
...     "A"         "world not being destroyed. A world where krill populations"
...     "aren't"    "collapsing. A world where there are not dead zones in the"
...     "oceans."   "A world not being systematically dismantled. I want to"
...     "live"      "in a world that is not being killed. I will do whatever it"
...     "takes"     "to get there." )
>>> get_map_size on_compromise
9
------------------------------------------
==========================================
/---
function get_map_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gms="${1}"
    die_unless_map "${map_name__gms}"

    # Get such map's size.
    output_string ${#${(k@P)map_name__gms}}
}

# ....................{ GETTERS ~ value                    }....................
declare_function_with_stdin <<'/---'
string get_map_key_value(string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or throw an exception otherwise: e.g.,

.get_map_key_value()
==========================================
[source]
------------------------------------------
>>> map on_easter_island; on_easter_island=(
...     "The"     "Easter Islanders, aware that they were almost completely"
...     "isolated "from the rest of the world, must surely have realised that"
...     "their"   "very existence depended on the limited resources of a small"
...     "island." "After all it was small enough for them to walk round the"
...     "entire"  "island in a day or so and see for themselves what"
...     "was"     "happening to the forests. Yet they were unable to devise a"
...     "system"  "that allowed them to find the right balance with"
...     "their"   "environment. Instead vital resources were steadily consumed"
...     "until"   "finally none were left. Indeed, at the very time when the"
...     "limitations" "of the island must have become starkly apparent the"
...     "competition" "between the clans for the available timber seems to have"
...     "intensified" "as more and more statues were carved and moved across"
...     "the"     "island in an attempt to secure prestige and status."
... )
>>> get_map_key_value on_easter_island their
environment. Instead vital resources were steadily consumed
------------------------------------------
==========================================
/---
function get_map_key_value() {
    get_map_key_value_if_found "${@}" or die_unless_map_key "${@}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_map_key_value_if_found(
    string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or return failure otherwise: e.g.,

.get_map_key_value_if_found()
==========================================
[source]
------------------------------------------
>>> map on_economics; on_economics=(
...     "Economics" "is not value free, and no amount of abstraction can make"
...     "it"        "value free. The econometricians' search for equations that"
...     "will"      "explain the economy is forever doomed to frustration. It"
...     "is"        "often said that their models don't work, because, on the"
...     "one"       "hand, the variables are too many and, on the other, the"
...     "statistical" "data are too sparse. But the physical universe is as"
...     "various"     "as the economic universe (they are, to repeat, both"
...     "infinite),"  "and Newton had fewer data and less powerful means of"
...     "calculation" "than are at the disposal of Jan Tinbergen and his"
...     "econometrician" "followers. The difference is fundamental, and the"
...     "failure"     "to understand it reduces much of modern economics to a"
...     "game"        "that unfortunately has serious consequences."
... )
>>> get_map_key_value_if_found on_economics "invisible hand" or print_string\
...     "To be important, therefore, a hypothesis must be descriptively false in its assumptions."
To be important, therefore, a hypothesis must be descriptively false in its assumptions.
/---
function get_map_key_value_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__gmkvif="${1}" key__gmkvif="${2}"
    die_unless_map "${map_name__gmkvif}"

    # Get such value if found or return failure. Note the sensible expression
    # "${${(@P)map_name}[${key__gmkvif}]}" always expands to the empty string
    # as does every sensible permutation of such expression (e.g., adding "k").
    # It shouldn't; it certainly doesn't for lists. But since it does, we
    # necessarily resort to the usual "eval" kludge.
    #
    # Needless to say, this is shockingly difficult.
    if { is_map_key "${map_name__gmkvif}" "${key__gmkvif}" } {
        # For efficiency, avoid calling return_string() and hence copying such
        # key value unnecessarily.
        eval "output_string \"\${${map_name__gmkvif}[\${key__gmkvif}]}\""
        return_true
    } else {
        return_false
    }
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string convert_map_to_string(string map_name)

Get a string corresponding to the contents of the map with the passed name.
See convert_list_to_string() for further details.
/---
function convert_map_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__cvmts="${1}"
    die_unless_map "${map_name__cvmts}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    return_string "${(qqkv@P)map_name__cvmts}"
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string print_map(string map_name)

Print the passed map in human-readable form.
/---
function print_map() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__pm="${1}"
    die_unless_map "${map_name__pm}"

    #FIXME: Style with colors.
    #FIXME: Convert to a for_map_keys()-based implementation to avoid extraneous
    #string copies.
    #FIXME: Consider aligning keys into columns. Of course, this is only really
    #feasible if all keys are sufficiently short; even a single lengthy key
    #renders the entire effort unprintable. Nonetheless, it seems worth the
    #attempt, if all keys are sufficiently short.

    # Page such output.
    {
        # Prefix such map with its name.
        print_message_heading "Map ${map_name__pm}"

        # Print such map.
        for_map_key_value_pairs "${map_name__pm}" '
            # If such key contains a colon or whitespace, quote such key. For
            # efficiency, inline such test.
            if is "${KEY}" == *[:[:space:]]* si {
                output_string "\"$(escape_string_double_quotes "${KEY}")\": ${VALUE}"
            # Else, print such key as is.
            } else {
                output_string "${KEY}: ${VALUE}"
            }'
    } | page_stdin
}

# --------------------( WASTELANDS                         )--------------------
    # Handle previously updated standard output tracking.
#   start_stdout_delimited

    # Update standard output tracking in preparation for subsequent handling.
#   stop_stdout

        # Remove the map name from the argument list.
#       shift_arg

#>>> map hollow_moon
#>>> list_set adams_curse; adams_curse=( We sat grown quiet at the name of love )
#>>> set_map_to_list_set_inverted hollow_moon adams_curse
#>>> print_map hollow_moon
#We: 1
#sat: 2
#grown: 3
#quiet: 4
#at: 5
#the: 6
#name: 7
#of: 8
#love: 9

    # . Clear such target map and for each such source map, copy such map's
    # key-value pairs into such target map. For efficiency, inline such logic.
#FUXME: Pure madness. Efficiency isn't a concern in this context. (When it is,
#the caller simply inlines such implementation.) Hence:
#
#* Excise this function.
#* Rename set_map_to_maps() to set_map_to_map().
#declare_function_with_stdin <<'/---'
#string set_map_to_map(string target_map_name, string source_map_name)
#
#Set the passed target to the passed source map (i.e., copy the latter into the
#former): e.g.,
#
#.set_map_to_map()
#==========================================
#[source]
#------------------------------------------
#>>> map in_this_world the_good_earth
#>>> the_good_earth=(
#...     "We all"  "want to help one another. Human beings are like that."
#...     "We want" "to live by each other's happiness — not by each other's"
#...     "misery." "We don't want to hate and despise one another."
#...     "In"      "this world there is room for everyone. And the good earth is"
#...     "rich"    "and can provide for everyone. The way of life can be free"
#...     "and"     "beautiful, but we have lost the way." )
#>>> set_map_to_map  in_this_world the_good_earth
#>>> print_string "${in_this_world[and]}"
#beautiful, but we have lost the way.
#------------------------------------------
#==========================================
#/---
#function set_map_to_map() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one target map name and one source map name'
#    string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
#    die_unless_map "${map_name_target__smtm}"
#    die_unless_map "${map_name_source__smtm}"
#
#    # Copy such map.
#    eval "${map_name_target__smtm}=( \"\${(kv@P)map_name_source__smtm}\" )"
#}

#       {
#       string map_name__gmkv="${1}" key__gmkv="${2}"
#       die "map \"${map_name__gmkv}\" has no key \"${key__gmkv}\""
#   }

    # Test such map, inlined for efficiency. Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'i', expanding to the index of such key if such map contains such key or
    #   the empty string otherwise.
    # * 'e', matching such key as a plain string rather than extended pattern.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#FUXME: To retain orthogonolity with the builtin for() iterator, the optional
#local variable names should *ALWAYS* be passed first. Hence, change this to:
#
#string for_map_key_value_pairs(
#    string key_string_name = "KEY",
#    string value_string_name = "VALUE",
#    string map_name,
#    string command)
# Since this overwrites all prior values for such keys within such
# target map, key-value pairs from later source maps take higher precedence than
# those from earlier source maps.
#FUXME: Excise. This should be called *NOWHERE*.
#declare_function '
#void set_map_to_evaluation(string map_name, string code)
#
#Set the passed map to the dynamic evaluation of the passed code in a map
#context (i.e., in an expression resembling "( ${code} )"): e.g.,
#
#    >>> map sopa
#    >>> set_map_to_evaluation sopa ''${:-stop officer perjury act}''
#    >>> print_string "${sopa[perjury]}"
#    act
#'
#function set_map_to_evaluation() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one code snippet'
#    string map_name__smte="${1}"
#    die_unless_map "${map_name__smte}"
#
#    # Set such map.
##   print_string "set map ${map_name__smte}=( ${2} )"
#    eval "${map_name__smte}=( ${2} )"
#}

# ....................{ GETTERS ~ key-value                }....................
#declare_function_with_stdin <<'/---'
#string get_map_key_values(string map_name)
#
#Get all key-value pairs of the passed map in arbitrary order, delimited by the
#current shell word separator(s) and hence suitable for iteration. Only call this
#function when *ALL* map values are guaranteed *NOT* to contain such separator
#(i.e., canonical global ${IFS}, defaulting to newline, space, and tab); if at
#least one map value could possibly contain such separator(s), consider iterating
#with get_map_keys() instead: e.g.,
#
#    >>> map lal_ded; lal_ded=( For ever we come, for ever we go )
#    >>> for lalla vakh ( $(get_map_keys lal_ded) ) {
#    ...     print_string "key: ${lalla} -- value: ${vakh}"
#    ... }
#    key: For -- value: ever
#    key: we -- value: come,
#    key: for -- value: ever
#    key: we -- value: go
#/---
#function get_map_key_values() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    die_unless_map "${map_name__gmk}"
#
#    # Get such pairs.
#    print_string "${(kv@P)map_name__gmk}"
#}

# ....................{ GETTERS ~ keys                     }....................
#FUXME: *THIS IS TERRIBLE*. So are the getters below, for the simple reason that
#they only work as documented when no key contains whitespace. What? That's pure
#nonsense. Instead, define a new family of for_map_keys*() iterators below and
#translate all existing calls to get_map_keys*() functions to such iterators.
#declare_function_with_stdin <<'/---'
#string get_map_keys(string map_name)
#
#List all keys of the passed map in arbitrary order, delimited by the current
#shell word separator(s) and hence suitable for iteration: e.g.,
#
#.get_map_keys()
#==========================================
#[source]
#------------------------------------------
#>>> map passchendaele; passchendaele=( the "old Lie" dulce et decorum est )
#>>> for dead ( $(get_map_keys passchendaele) ) {
#...     print_string "key: ${dead} -- value: ${passchendaele[${dead}]}"
#... }
#key: the -- value: old Lie
#key: dulce -- value: et
#key: decorum -- value: est
#------------------------------------------
#==========================================
#/---
#function get_map_keys() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    die_unless_map "${map_name__gmk}"
#
#    # Get such keys.
#    output_string "${(k@P)map_name__gmk}"
#}
#
#declare_function_with_stdin <<'/---'
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map in lexical ascending order, delimited by the
#current shell word separator(s) and hence suitable for iteration.
#/---
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    die_unless_map "${map_name__gmksla}"
#
#    # Sort such keys.
#    print_string "${(ko@P)map_name__gmksla}"
#}
#
#declare_function '
#string get_map_keys_sorted_lexically_descending(string map_name)
#
#Get all keys of the passed map in lexical descending order, delimited by the
#current shell word separator(s) and hence suitable for iteration
#'
#function get_map_keys_sorted_lexically_descending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    die_unless_map "${map_name__gmksla}"
#
#    # Sort such keys.
#    print_string "${(kO@P)map_name__gmksla}"
#}

#FUXME: O.K.; so, it'd be great to be able to specify names for such string
#locals. In the case of "io/color/color", for example, we want keys to be in
#string local ${color_style_name} and values to be in string local
#${color_name}. I'm generally intolerant of optional parameters -- but, here
#they really do seem to make sense. The function call remains equally readable
#with or without such parameters specified: e.g.,
#
#    for_map_key_value_pairs ZESHY_COLOR_8 color_style_name color_name\
#        'ZESHY_COLOR_2[${color_name}]='
#
#I dig it. Easy to support; easy to call. No need for separate functions, here.

#   if { is_args_3 } {
#       key_name="${2}"
#   }
#   elif { is_args_4 } {
#       key_name="${2}"
#       value_name="${3}"
#   }

    # Print such map.
#   for key (${(k)${(k@P)map_name__pm}}) {
#       # If such key contains a colon or whitespace, quote such key.
#       if { is_string_matches_glob "${key}" [:[:space:]] } {
#           print_string "\"$(escape_string_double_quotes "${key}")\": ${${(k@P)map_name__pm}[${key}]}"
#       # Else, print such key as is.
#       } else {
#           print_string "${key}: ${${(k@P)map_name__pm}[${key}]}"
#       }
#   }
    # Current key-value pair.
#   string KEY VALUE

#function yiyi() {
#    get_map_key_value_if_found ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "zsh"
#    print $(get_map_key_value_if_found ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "zsh")
#}

        #FUXME: Generalize quote escaping into a new function
        #escape_string_double_quotes(). It's complex enough to warrant such
        #generalization.
#           print_string "\"${key//\"/\\\"}\": ${${(k@P)map_name__pm}[${key}]}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#   is_string_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"

#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#declare_function '
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    die_unless_map "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # is_map_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_string_nonempty "${__
#   print_string ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_string_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
