#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle maps (i.e., associative arrays).

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_map_nonempty(
    string map_name,
    string error_message = "\"${map_name}\" not a nonempty map")

Throw an exception with the passed message unless the passed map is nonempty.
________________<heredoc?>________________
function die_unless_map_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string map_name__dumn="${1}"
    is_map_nonempty "${map_name__dumn}" or
        die "${2:-\"${map_name__dumn}\" not a nonempty map}"
}

# ....................{ EXCEPTIONS ~ key                   }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_map_key(
    string map_name,
    string key,
    string error_message = "map \"${map_name}\" contains no key \"${key}\"")

Throw an exception with the passed message unless the passed map contains the
passed key.
________________<heredoc?>________________
function die_unless_map_key() {
    die_unless_args_2_to_3\
        'expected one map name, one key, and optional error message'
    string map_name__dumk="${1}" key__dumk="${2}"
    is_map_key "${map_name__dumk}" "${key__dumk}" or
        die "${2:-\"${key__dumk}\" not a key of map \"${map_name__dumk}\"}"
}

# ....................{ TESTERS ~ empty                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_map_empty(string map_name)

Return success if the passed map is empty.
________________<heredoc?>________________
function is_map_empty() {
    not  is_map_nonempty "${@}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_map_nonempty(string map_name)

Return success if the passed map is nonempty.
________________<heredoc?>________________
function is_map_nonempty() {
    die_unless_arg 'expected one map name'
    string map_name__imn="${1}"
    is_map "${map_name__imn}" and (( ${#${(@P)map_name__imn}} ))
}

# ....................{ TESTERS ~ key                      }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_map_key(string map_name, string key)

Return success if the passed map contains the passed key.
________________<heredoc?>________________
function is_map_key() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__imk="${1}" key__imk="${2}"
    die_unless_map "${map_name__imk}"

    # Test such map, inlined for efficiency. Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'i', expanding to the index of such key if such map contains such key or
    #   the empty string otherwise.
    # * 'e', matching such key as a plain string rather than extended pattern.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
    is -z "${${(k@P)map_name__imk}[(ie)${key__imk}]-}" si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_map_size(string map_name)

Get the number of key-value pairs in the passed map. By definition, this is
equivalent to the number of keys and the number of values in such map: e.g.,

.get_map_size()
==========================================
[source]
------------------------------------------
>>> map on_compromise; on_compromise=(
...     "I'm"       "interested in living in a world that has more wild"
...     "salmon"    "every year than the year before. A world that has more"
...     "migratory" "songbirds every year than the year before. A world that"
...     "has"       "less dioxins and flame retardants in mothers' breast milk."
...     "A"         "world not being destroyed. A world where krill populations"
...     "aren't"    "collapsing. A world where there are not dead zones in the"
...     "oceans."   "A world not being systematically dismantled. I want to"
...     "live"      "in a world that is not being killed. I will do whatever it"
...     "takes"     "to get there." )
>>> get_map_size on_compromise
9
------------------------------------------
==========================================
________________<heredoc?>________________
function get_map_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gms="${1}"
    die_unless_map "${map_name__gms}"

    # Get such map's size.
    output_string ${#${(k@P)map_name__gms}}
}

# ....................{ GETTERS ~ value                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[stdout: string, status: boolean] get_map_key_value_if_found(
    string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or return failure otherwise.
________________<heredoc?>________________
function get_map_key_value_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__gmkvif="${1}" key__gmkvif="${2}"
    die_unless_map "${map_name__gmkvif}"

    # Get such value if found or return failure. Note the sensible expression
    # "${${(@P)map_name}[${key__gmkvif}]}" always expands to the empty string
    # as does every sensible permutation of such expression (e.g., adding "k").
    # It shouldn't; it certainly doesn't for lists. But since it does, we
    # necessarily resort to the usual "eval" kludge.
    #
    # Needless to say, this is shockingly difficult.
    if { is_map_key "${map_name__gmkvif}" "${key__gmkvif}" } {
        eval "return_string \"\${${map_name__gmkvif}[\${key__gmkvif}]}\""
    } else {
        return_false
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string set_map_to_map(string target_map_name, string source_map_name)

Set the passed target to the passed source map (i.e., copy the latter into the
former): e.g.,

.set_map_to_map()
==========================================
[source]
------------------------------------------
>>> map in_this_world the_good_earth
>>> the_good_earth=(
...     "We all"  "want to help one another. Human beings are like that."
...     "We want" "to live by each other's happiness â€” not by each other's"
...     "misery." "We don't want to hate and despise one another."
...     "In"      "this world there is room for everyone. And the good earth is"
...     "rich"    "and can provide for everyone. The way of life can be free"
...     "and"     "beautiful, but we have lost the way." )
>>> set_map_to_map  in_this_world the_good_earth
>>> print_string "${in_this_world[and]}"
beautiful, but we have lost the way.
------------------------------------------
==========================================
________________<heredoc?>________________
function set_map_to_map() {
    # Validate passed arguments.
    die_unless_args_2 'expected one target map name and one source map name'
    string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
    die_unless_map "${map_name_target__smtm}"
    die_unless_map "${map_name_source__smtm}"

    # Copy such map.
    eval "${map_name_target__smtm}=( \"\${(kv@P)map_name_source__smtm}\" )"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string set_map_to_maps(
    string target_map_name,
    string source_map_name1, string source_map_name2, ...)

Set the passed target map to the merger of the passed source maps in the passed
order. Specifically:

. Clear such target map.
. For each source map in the passed order, copy all key-value pairs of such map
  map into such target map. Hence, key-value pairs of source maps passed later
  take higher precedence than those of source maps passed earlier.

For example: e.g.,

.set_map_to_maps()
==========================================
[source]
------------------------------------------
>>> map for_unity on_wants on_needs
>>> on_wants=(
...     "We"   "have developed speed, but"
...     "we"   "have shut ourselves in. Machinery that gives abundance has"
...     "left" "us in want. Our knowledge has made us cynical. Our cleverness,"
...     "hard" "and unkind. We think too much and feel too little." )
>>> on_needs=(
...     "More" "than machinery"
...     "we"   "need humanity. More than cleverness we need kindness"
...     "and"  "gentleness. Without these qualities, life will be violent and"
...     "all"  "will be lost." )
>>> set_map_to_maps for_unity on_wants on_needs
>>> print_string "${for_unity[We]}" "${for_unity[we]}"
have developed speed, but
need humanity. More than cleverness we need kindness
------------------------------------------
________________<heredoc?>________________
function set_map_to_maps() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one target map name and at least one source map name'
    string map_name_target__smtms="${1}"
    die_unless_map "${map_name_target__smtms}"
    shift_arg

    # Clear such target map and for each such source map, copy such map's
    # key-value pairs into such target map. For efficiency, inline such logic.
    eval "  ${map_name_target__smtms}=()
        for map_name_source__smtms (\"\${@}\") {
            die_unless_map \"\${map_name_source__smtms}\"
            ${map_name_target__smtms}+=( \"\${(kv@P)map_name_source__smtms}\" )
        }"
}

# ....................{ SETTERS ~ list                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_map_to_list_set_inverted(string map_name, string list_set_name)

Set the passed map to the inversion of the passed list set, such that the keys
of such map are the elements of such list set and the values of such map are the
corresponding 1-based indices of such elements: e.g.,

.set_map_to_list_set_inverted()
==========================================
[source]
------------------------------------------
>>> map hollow_moon
>>> list_set adams_curse; adams_curse=( We sat grown quiet at the name of love )
>>> set_map_to_list_set_inverted hollow_moon adams_curse
>>> print_map hollow_moon
We: 1
sat: 2
grown: 3
quiet: 4
at: 5
the: 6
name: 7
of: 8
love: 9
------------------------------------------
________________<heredoc?>________________
function set_map_to_list_set_inverted() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one list name'
    string map_name__smtli="${1}" list_set_name__smtli="${2}"
    die_unless_map "${map_name__smtli}"
    die_unless_list_set_set "${list_set_name__smtli}"

    # Get the size of such list set.
    integer list_set_size__smtli
    list_set_size__smtli="$(get_list_size "${list_set_name__smtli}")"

    # Set such map to such list set inverted.
    for ((list_set_index__smtli = 1;
          list_set_index__smtli <= list_set_size__smtli;
          list_set_index__smtli++)) {
        eval "${map_name__smtli}[\${${list_set_name__smtli}[${list_set_index__smtli}]}]=${list_set_index__smtli}"
    }
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string convert_map_to_string(string map_name)

Get a string corresponding to the contents of the map with the passed name.
See convert_list_to_string() for further details.
________________<heredoc?>________________
function convert_map_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__cvmts="${1}"
    die_unless_map "${map_name__cvmts}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    print_string "${(qqkv@P)map_name__cvmts}"
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_map(string map_name)

Print the passed map in human-readable form.
________________<heredoc?>________________
function print_map() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__pm="${1}"
    die_unless_map "${map_name__pm}"

    #FIXME: Style with colors.
    #FIXME: Consider aligning keys into columns. Of course, this is only really
    #feasible if all keys are sufficiently short; even a single lengthy key
    #renders the entire effort unprintable. Nonetheless, it seems worth the
    #attempt, if all keys are sufficiently short.

    for_key_value_pairs "${map_name__pm}" '
        # If such key contains a colon or whitespace, quote such key. For
        # efficiency, inline such test.
        if is "${KEY}" == *[:[:space:]]* si {
            print_string "\"$(escape_string_double_quotes "${KEY}")\": ${VALUE}"
        # Else, print such key as is.
        } else {
            print_string "${KEY}: ${VALUE}"
        }'
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_map_key_value_pairs(
    string map_name,
    string key_string_name = "KEY",
    string value_string_name = "VALUE",
    string command)

Run the passed command for each key of the passed map in arbitrary order,
setting the first passed local variable (defaulting to `${KEY}`) to each such
key and the second passed local variable (defaulting to `${VALUE}`) to the
value for such key: e.g.,

.for_map_key_value_pairs()
==========================================
[source]
------------------------------------------
>>> map on_flesh; on_flesh=(
...     '"Imagine,"' 'he said,'
...     '"All'       'the flesh that is eaten'
...     'The teeth'  'tearing into it'
...     'The tongue' "tasting it's savour"
...     'And'        'the hunger for that taste'
...     'Now'        'take away that flesh," he said,'
...     '"Take'      'away the teeth and the tongue'
...     'The taste'  'and the hunger'
...     'Take'       'away everything as it is'
...     'That'       'was my plan'
...     'My'         'own special plan for this world"' )
>>> for_map_key_value_pairs on_flesh laughter screams\
...     'is_string_prefix "${laughter}" "The" and
...         output_string "${laughter} -- ${screams}"'
The teeth -- tearing into it
The tongue -- tasting it's savour
The taste -- and the hunger
------------------------------------------
==========================================
________________<heredoc?>________________
function for_map_key_value_pairs() {
    # Validate passed arguments.
    die_unless_args_2_to_4\
        'expected one map name, optional key name, optional value name, and one command'
    string\
        map_name__fmkvp="${1}"\
        key_name__fmkvp='KEY'\
        value_name__fmkvp='VALUE'\
        command__fmkvp="${@[-1]}"
    is_args_3_to_4 and key_name__fmkvp="${2}"
    is_args_4    and value_name__fmkvp="${3}"
    die_unless_map "${map_name__fmkvp}"
    die_unless_variable_names "${key_name__fmkvp}" "${value_name__fmkvp}"
    die_unless_string_nonempty "${command__fmkvp}" 'expected nonempty command'

    # Iterate such pairs. For efficiency, evaluate once rather than on each
    # iteration.
    eval "for ${key_name__fmkvp} ${value_name__fmkvp} (\"\${(kv@)${map_name__fmkvp}}\") {
        ${command__fmkvp}
    }"
}

# ....................{ ITERATORS ~ key                    }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_map_keys(
    string map_name,
    string key_string_name = "KEY",
    string command)

Run the passed command for each key of the passed map in arbitrary order,
setting the passed local variable (defaulting to `${KEY}`) to each such key:
e.g.,

.for_map_keys()
==========================================
[source]
------------------------------------------
>>> map on_this_world; on_brainless_beacons=(
...     "When everyone"   "you have ever loved is finally gone"
...     "When everything" "you have ever wanted is finally done with"
...     "When all"        "of your nightmares are for a time obscured"
...     "As"              "by a shining brainless beacon"
...     "Or a blinding"   "eclipse of the many terrible shapes of this world"
...     "When you"        "are calm and joyful"
...     "And"             "finally entirely alone"
...     "Then"            "in a great new darkness"
...     "You"             "will finally execute your special plan" )
>>> for_map_keys on_brainless_beacons tiny_limbs\
...     'is_string_prefix "${tiny_limbs}" "When" and
...         output_string "${tiny_limbs} -- ${on_this_world[${tiny_limbs}]}"'
When everyone -- you have ever loved is finally gone
When everything -- you have ever wanted is finally done with
When all -- of your nightmares are for a time obscured
When you -- are calm and joyful
------------------------------------------
==========================================
________________<heredoc?>________________
function for_map_keys() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one map name, optional key name, and one command'
    string map_name__fmk="${1}" key_name__fmk='KEY' command__fmk="${@[-1]}"
    is_args_3 and key_name__fmk="${2}"
    die_unless_map "${map_name__fmk}"
    die_unless_variable_name "${key_name__fmk}"
    die_unless_string_nonempty "${command__fmk}" 'expected nonempty command'

    # Iterate such keys. For efficiency, evaluate once rather than on each
    # iteration.
    eval "for ${key_name__fmk} (\"\${(k@)${map_name__fmk}}\") {
        ${command__fmk}
    }"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_map_keys_sorted_lexically_ascending(
    string map_name,
    string key_string_name = "KEY",
    string command)

Run the passed command for each key of the passed map in lexical ascending
order, setting the passed local variable (defaulting to `${KEY}`) to each
such key: e.g.,

.for_map_keys_sorted_lexically_ascending()
==========================================
[source]
------------------------------------------
>>> map on_going_home; on_going_home=(
...     "Even"  "while I dreamed I prayed that what I saw was only fear and"
...     "no"    "foretelling, for I saw the last known landscape destroyed for"
...     "the"   "sake of the objective, the soil bludgeoned, the rock blasted."
...     "Those" "who had wanted to go home would never get there now." )
>>> for_map_keys_sorted_lexically_ascending on_going_home far_distance\
...     'is_string_glob_matches "${far_distance}" [Tt]h* and
...         output_string "${far_distance} / ${on_going_home[${far_distance}]}"'
the / sake of the objective, the soil bludgeoned, the rock blasted.
Those / who had wanted to go home would never get there now.
------------------------------------------
==========================================
________________<heredoc?>________________
function for_map_keys_sorted_lexically_ascending() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize all changes to for_map_keys_sorted_lexically_descending().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one map name, optional key name, and one command'
    string\
        map_name__fmksla="${1}"\
        key_name__fmksla='KEY'\
        command__fmksla="${@[-1]}"
    is_args_3 and key_name__fmksla="${2}"
    die_unless_map "${map_name__fmksla}"
    die_unless_variable_name "${key_name__fmksla}"
    die_unless_string_nonempty "${command__fmksla}" 'expected nonempty command'

    # Iterate such keys. For efficiency, evaluate once rather than on each
    # iteration. When paired with flag "v", flag "o" iterates all keys and
    # values and not simply keys in lexically ascending order. Since such
    # iteration is entirely unhelpful, there exists no corresponding
    # for_map_key_value_pairs_with_keys_sorted_lexically_ascending().
    eval "for ${key_name__fmksla} (\"\${(ok@)${map_name__fmksla}}\") {
        ${command__fmksla}
    }"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_map_keys_sorted_lexically_descending(
    string map_name,
    string key_string_name = "KEY",
    string command)

Run the passed command for each key of the passed map in lexical descending
order, setting the passed local variable (defaulting to `${KEY}`) to each
such key: e.g.,

.for_map_keys_sorted_lexically_descending()
==========================================
[source]
------------------------------------------
>>> map on_the_objective; on_the_objective=(
...     "I"      "visited the offices where for the sake of the objective"
...     "the"    "planners planned at blank desks set in rows. I visited the"
...     "loud"   "factories where the machines were made that would drive"
...     "ever"   "forward toward the objective. I saw the forest reduced to"
...     "stumps" "and gullies; I saw the poisoned river, the mountain cast"
...     "into"   "the valley; I came to the city that nobody recognized because"
...     "it"     "looked like every other city. I saw the passages worn"
...     "by"     "the unnumbered footfalls of those whose eyes were fixed"
...     "upon"   "the objective." )
>>> for_map_keys_sorted_lexically_descending on_the_objective forgotten\
...     'is_string_glob_matches "${forgotten}" [Ii]* and
...         output_string "${forgotten} / ${on_the_objective[${forgotten}]}"'
I / visited the offices where for the sake of the objective
into / the valley; I came to the city that nobody recognized because
it / looked like every other city. I saw the passages worn
------------------------------------------
==========================================
________________<heredoc?>________________
function for_map_keys_sorted_lexically_descending() {
    # See for_map_keys_sorted_lexically_ascending() for further details.
    die_unless_args_2_to_3\
        'expected one map name, optional key name, and one command'
    string\
        map_name__fmksld="${1}"\
        key_name__fmksld='KEY'\
        command__fmksld="${@[-1]}"
    is_args_3 and key_name__fmksld="${2}"
    die_unless_map "${map_name__fmksld}"
    die_unless_variable_name "${key_name__fmksld}"
    die_unless_string_nonempty "${command__fmksld}" 'expected nonempty command'
    eval "for ${key_name__fmksld} (\"\${(Ok@)${map_name__fmksld}}\") {
        ${command__fmksld}
    }"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: To retain orthogonolity with the builtin for() iterator, the optional
#local variable names should *ALWAYS* be passed first. Hence, change this to:
#
#string for_map_key_value_pairs(
#    string key_string_name = "KEY",
#    string value_string_name = "VALUE",
#    string map_name,
#    string command)
# Since this overwrites all prior values for such keys within such
# target map, key-value pairs from later source maps take higher precedence than
# those from earlier source maps.
#FUXME: Excise. This should be called *NOWHERE*.
#declare_function '
#void set_map_to_evaluation(string map_name, string code)
#
#Set the passed map to the dynamic evaluation of the passed code in a map
#context (i.e., in an expression resembling "( ${code} )"): e.g.,
#
#    >>> map sopa
#    >>> set_map_to_evaluation sopa ''${:-stop officer perjury act}''
#    >>> print_string "${sopa[perjury]}"
#    act
#'
#function set_map_to_evaluation() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one code snippet'
#    string map_name__smte="${1}"
#    die_unless_map "${map_name__smte}"
#
#    # Set such map.
##   print_string "set map ${map_name__smte}=( ${2} )"
#    eval "${map_name__smte}=( ${2} )"
#}

# ....................{ GETTERS ~ key-value                }....................
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string get_map_key_values(string map_name)
#
#Get all key-value pairs of the passed map in arbitrary order, delimited by the
#current shell word separator(s) and hence suitable for iteration. Only call this
#function when *ALL* map values are guaranteed *NOT* to contain such separator
#(i.e., canonical global ${IFS}, defaulting to newline, space, and tab); if at
#least one map value could possibly contain such separator(s), consider iterating
#with get_map_keys() instead: e.g.,
#
#    >>> map lal_ded; lal_ded=( For ever we come, for ever we go )
#    >>> for lalla vakh ( $(get_map_keys lal_ded) ) {
#    ...     print_string "key: ${lalla} -- value: ${vakh}"
#    ... }
#    key: For -- value: ever
#    key: we -- value: come,
#    key: for -- value: ever
#    key: we -- value: go
#________________<heredoc?>________________
#function get_map_key_values() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    die_unless_map "${map_name__gmk}"
#
#    # Get such pairs.
#    print_string "${(kv@P)map_name__gmk}"
#}

# ....................{ GETTERS ~ keys                     }....................
#FUXME: *THIS IS TERRIBLE*. So are the getters below, for the simple reason that
#they only work as documented when no key contains whitespace. What? That's pure
#nonsense. Instead, define a new family of for_map_keys*() iterators below and
#translate all existing calls to get_map_keys*() functions to such iterators.
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string get_map_keys(string map_name)
#
#List all keys of the passed map in arbitrary order, delimited by the current
#shell word separator(s) and hence suitable for iteration: e.g.,
#
#.get_map_keys()
#==========================================
#[source]
#------------------------------------------
#>>> map passchendaele; passchendaele=( the "old Lie" dulce et decorum est )
#>>> for dead ( $(get_map_keys passchendaele) ) {
#...     print_string "key: ${dead} -- value: ${passchendaele[${dead}]}"
#... }
#key: the -- value: old Lie
#key: dulce -- value: et
#key: decorum -- value: est
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function get_map_keys() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    die_unless_map "${map_name__gmk}"
#
#    # Get such keys.
#    output_string "${(k@P)map_name__gmk}"
#}
#
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map in lexical ascending order, delimited by the
#current shell word separator(s) and hence suitable for iteration.
#________________<heredoc?>________________
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    die_unless_map "${map_name__gmksla}"
#
#    # Sort such keys.
#    print_string "${(ko@P)map_name__gmksla}"
#}
#
#declare_function '
#string get_map_keys_sorted_lexically_descending(string map_name)
#
#Get all keys of the passed map in lexical descending order, delimited by the
#current shell word separator(s) and hence suitable for iteration
#'
#function get_map_keys_sorted_lexically_descending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    die_unless_map "${map_name__gmksla}"
#
#    # Sort such keys.
#    print_string "${(kO@P)map_name__gmksla}"
#}

#FUXME: O.K.; so, it'd be great to be able to specify names for such string
#locals. In the case of "io/color/color", for example, we want keys to be in
#string local ${color_style_name} and values to be in string local
#${color_name}. I'm generally intolerant of optional parameters -- but, here
#they really do seem to make sense. The function call remains equally readable
#with or without such parameters specified: e.g.,
#
#    for_map_key_value_pairs ZESHY_COLOR_8 color_style_name color_name\
#        'ZESHY_COLOR_2[${color_name}]='
#
#I dig it. Easy to support; easy to call. No need for separate functions, here.

#   if { is_args_3 } {
#       key_name="${2}"
#   }
#   elif { is_args_4 } {
#       key_name="${2}"
#       value_name="${3}"
#   }

    # Print such map.
#   for key (${(k)${(k@P)map_name__pm}}) {
#       # If such key contains a colon or whitespace, quote such key.
#       if { is_string_glob_matches "${key}" [:[:space:]] } {
#           print_string "\"$(escape_string_double_quotes "${key}")\": ${${(k@P)map_name__pm}[${key}]}"
#       # Else, print such key as is.
#       } else {
#           print_string "${key}: ${${(k@P)map_name__pm}[${key}]}"
#       }
#   }
    # Current key-value pair.
#   string KEY VALUE

#function yiyi() {
#    get_map_key_value_if_found ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "zsh"
#    print $(get_map_key_value_if_found ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "zsh")
#}

        #FUXME: Generalize quote escaping into a new function
        #escape_string_double_quotes(). It's complex enough to warrant such
        #generalization.
#           print_string "\"${key//\"/\\\"}\": ${${(k@P)map_name__pm}[${key}]}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#   is_string_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"

#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#declare_function '
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    die_unless_map "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # is_map_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_string_nonempty "${__
#   print_string ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_string_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
