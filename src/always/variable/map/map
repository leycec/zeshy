#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle maps (i.e., associative arrays).

# ....................{ EXCEPTIONS                         }....................
declare_function '
void die_unless_map_nonempty(
  string map_name, string error_message = "\"${map_name}\" not a non-empty map")

Throw an exception unless the passed map is non-empty.
'
function die_unless_map_nonempty() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string map_name__dumn="${1}"
    is_map_nonempty "${map_name__dumn}" or
        die "${2:-\"${map_name__dumn}\" not a non-empty map}"
}

# ....................{ EXCEPTIONS ~ key                   }....................
declare_function '
void die_unless_map_key(
  string map_name,
  string key,
  string error_message = "\"${key}\" not a key of map \"${map_name}\"")

Throw an exception unless the passed map contains the passed key.
'
function die_unless_map_key() {
    die_unless_args_2_to_3\
        'expected one map name, one key, and optional error message'
    string map_name__dumk="${1}" key__dumk="${2}"
    is_map_key "${map_name__dumk}" "${key__dumk}" or
        die "${2:-\"${key__dumk}\" not a key of map \"${map_name__dumk}\"}"
}

# ....................{ TESTERS ~ empty                    }....................
declare_function '
boolean is_map_empty(string map_name)

Return true if the passed map is empty.
'
function is_map_empty() {
    not  is_map_nonempty "${@}"
}

declare_function '
boolean is_map_nonempty(string map_name)

Return true if the passed map is non-empty.
'
function is_map_nonempty() {
    die_unless_arg 'expected one map name'
    string map_name__imn="${1}"
    is_map "${map_name__imn}" and (( ${#${(@P)map_name__imn}} ))
}

# ....................{ TESTERS ~ key                      }....................
declare_function '
boolean is_map_key(string map_name, string key)

Return true if the passed map contains the passed key.
'
function is_map_key() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__imk="${1}" key__imk="${2}"
    die_unless_map "${map_name__imk}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'i', expanding to such key if such map contains such key or the empty
    #   string otherwise.
    # * 'e', matching such key as a plain string rather than extended pattern.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
    is_string_nonempty "${${(k@P)map_name__imk}[(ie)${key__imk}]-}"
}

# ....................{ GETTERS                            }....................
declare_function '
integer get_map_size(string map_name)

Get the number of keys in the passed map.
'
function get_map_size() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gms="${1}"
    die_unless_map "${map_name__gms}"

    # Get map size.
    print_string ${#${(@P)map_name__gms}}
}

# ....................{ GETTERS ~ keys                     }....................
declare_function '
string get_map_keys(string map_name)

Get all keys of the passed map in arbitrary order, delimited by the current
shell word separator(s) and hence suitable for iteration: e.g.,

    >>> map passchendaele; passchendaele=( the "old Lie" dulce et decorum est )
    >>> for dead ( $(get_map_keys passchendaele) ) {
    ...     print_string "key: ${dead} -- value: ${passchendaele[${dead}]}"
    ... }
    key: the -- value: old Lie
    key: dulce -- value: et
    key: decorum -- value: est
'
function get_map_keys() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gmk="${1}"
    die_unless_map "${map_name__gmk}"

    # Get such keys.
    print_string "${(k@P)map_name__gmk}"
}

#FIXME: Rename "get_map_keys_" to "get_map_keys_" everywhere.
declare_function '
string get_map_keys_sorted_lexically_ascending(string map_name)

Get all keys of the passed map in lexical ascending order, delimited by the
current shell word separator(s) and hence suitable for iteration.
'
function get_map_keys_sorted_lexically_ascending() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gmksla="${1}"
    die_unless_map "${map_name__gmksla}"

    # Sort such keys.
    print_string "${(ko@P)map_name__gmksla}"
}

declare_function '
string get_map_keys_sorted_lexically_descending(string map_name)

Get all keys of the passed map in lexical descending order, delimited by the
current shell word separator(s) and hence suitable for iteration
'
function get_map_keys_sorted_lexically_descending() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gmksla="${1}"
    die_unless_map "${map_name__gmksla}"

    # Sort such keys.
    print_string "${(kO@P)map_name__gmksla}"
}

# ....................{ GETTERS ~ value                    }....................
declare_function '
string get_map_key_value_if_found(string map_name, string key)

Get the value of the passed key in the passed map if such map contains such key
or return false otherwise.
'
function get_map_key_value_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one key'
    string map_name__gmkvif="${1}" key__gmkvif="${2}"
    die_unless_map "${map_name__gmkvif}"

    # Get such value or return false. Oddly, the sensible expression
    # "${${(@P)map_name}[${key____gmkvif}]}" always expands to the empty string
    # as does every sensible permutation of such expression (e.g., adding "k").
    # It shouldn't; it certainly doesn't for lists. But since it does, we
    # necessarily resort to the usual "eval" kludge.
    #
    # Needless to say, this is shockingly difficult.
    if is_map_key "${map_name__gmkvif}" "${key__gmkvif}"
    then eval "print_string \${${map_name__gmkvif}[\${key__gmkvif}]}"
    else return_false
    fi
}

# ....................{ GETTERS ~ key-value                }....................
declare_function '
string get_map_key_values(string map_name)

Get all key-value pairs of the passed map in arbitrary order, delimited by the
current shell word separator(s) and hence suitable for iteration. Only call this
function when *ALL* map values are guaranteed *NOT* to contain such separator
(i.e., canonical global ${IFS}, defaulting to newline, space, and tab); if at
least one map value could possibly contain such separator(s), consider iterating
with get_map_keys() instead: e.g.,

    >>> map lal_ded; lal_ded=( For ever we come, for ever we go )
    >>> for lalla vakh ( $(get_map_keys lal_ded) ) {
    ...     print_string "key: ${lalla} -- value: ${vakh}"
    ... }
    key: For -- value: ever
    key: we -- value: come,
    key: for -- value: ever
    key: we -- value: go
'
function get_map_key_values() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__gmk="${1}"
    die_unless_map "${map_name__gmk}"

    # Get such pairs.
    print_string "${(kv@P)map_name__gmk}"
}

# ....................{ SETTERS                            }....................
declare_function '
string set_map_to_map(string target_map_name, string source_map_name)

Copy the second into the first passed map: e.g.,

    >>> map subcomandante marcos; marcos=( a permanent autonomous zone )
    >>> set_map_to_map subcomandante marcos
    >>> print_string "${subcomandante[a]}"
    permanent
'
function set_map_to_map() {
    # Validate passed arguments.
    die_unless_args_2 'expected two map names'
    string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
    die_unless_map "${map_name_target__smtm}"
    die_unless_map "${map_name_source__smtm}"

    # Copy such map.
    set_map_to_evaluation\
         "${map_name_target__smtm}"\
        '"${(kv@P)map_name_source__smtm}"'
}

declare_function '
void set_map_to_evaluation(string map_name, string code)

Set the passed map to the dynamic evaluation of the passed code in a map
context (i.e., in an expression resembling "( ${code} )"): e.g.,

    >>> map sopa
    >>> set_map_to_evaluation sopa ''${:-stop officer perjury act}''
    >>> print_string "${sopa[perjury]}"
    act
'
function set_map_to_evaluation() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one code snippet'
    string map_name__smte="${1}"
    die_unless_map "${map_name__smte}"

    # Set such map.
#   print_string "set map ${map_name__smte}=( ${2} )"
    eval "${map_name__smte}=( ${2} )"
}

# ....................{ SETTERS ~ list                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void set_map_to_list_set_inverted(string map_name, string list_set_name)

Set the passed map to the inversion of the passed list set, such that the keys
of such map are the elements of such list set and the values of such map are the
corresponding 1-based indices of such elements: e.g.,

.set_map_to_list_set_inverted()
==========================================
[source]
------------------------------------------
>>> map hollow_moon
>>> list_set adams_curse; adams_curse=( We sat grown quiet at the name of love )
>>> set_map_to_list_set_inverted hollow_moon adams_curse
>>> print_map hollow_moon
We: 1
sat: 2
grown: 3
quiet: 4
at: 5
the: 6
name: 7
of: 8
love: 9
------------------------------------------
________________<heredoc?>________________
function set_map_to_list_set_inverted() {
    # Validate passed arguments.
    die_unless_args_2 'expected one map name and one list name'
    string map_name__smtli="${1}" list_set_name__smtli="${2}"
    die_unless_map "${map_name__smtli}"
    die_unless_list_set_set "${list_set_name__smtli}"

    # Get the size of such list set.
    integer list_set_size__smtli
    list_set_size__smtli="$(get_list_size "${list_set_name__smtli}")"

    # Set such map to such list set inverted.
    for ((list_set_index__smtli = 1;
          list_set_index__smtli <= list_set_size__smtli;
          list_set_index__smtli++)) {
        eval "${map_name__smtli}[\${${list_set_name__smtli}[${list_set_index__smtli}]}]=${list_set_index__smtli}"
    }
}

# ....................{ CONVERTERS                         }....................
#FIXME: Shift to "00-alias/variable/map".
declare_function '
string convert_map_to_string(string map_name)

Get a string corresponding to the contents of the map with the passed name.
See convert_list_to_string() for further details.
'
function convert_map_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__cvmts="${1}"
    die_unless_map "${map_name__cvmts}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    print_string "${(qqkv@P)map_name__cvmts}"
}

# ....................{ CONVERTERS                         }....................
declare_function '
string print_map(string map_name)

Pretty print the passed map.
'
function print_map() {
    # Validate passed arguments.
    die_unless_arg 'expected one map name'
    string map_name__pm="${1}"
    die_unless_map "${map_name__pm}"

    #FIXME: Style with colors.
    #FIXME: Consider aligning keys into columns. Of course, this is only really
    #feasible if all keys are sufficiently short; even a single lengthy key
    #renders the entire effort unprintable. Nonetheless, it seems worth the
    #attempt, if all keys are sufficiently short.

    # Print such map.
    for key (${(k)${(k@P)map_name__pm}}) {
        # If such key contains a colon or whitespace, quote such key.
        if { is_string_match "${key}" [:[:space:]] } {
            print_string "\"$(escape_string_double_quotes "${key}")\": ${${(k@P)map_name__pm}[${key}]}"
        # Else, print such key as is.
        } else {
            print_string "${key}: ${${(k@P)map_name__pm}[${key}]}"
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Generalize quote escaping into a new function
        #escape_string_double_quotes(). It's complex enough to warrant such
        #generalization.
#           print_string "\"${key//\"/\\\"}\": ${${(k@P)map_name__pm}[${key}]}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#   is_string_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"

#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#declare_function '
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    die_unless_map "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # is_map_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_string_nonempty "${__
#   print_string ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_string_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
