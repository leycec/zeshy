#!/usr/bin/env zsh
# ====================[ character                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle character variables and values.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_character(
  string value,
  string error_message = "\"${variable_name}\" not a character")

Throw an exception with the passed message unless the passed string is a
character. See is_character() for further details.
'
function die_unless_character() {
    die_unless_args_1_to_2\
        'expected one variable name and optional error message'
    string value="${1}"
    is_character "${value}" or die "${2:-\"${value}\" not a character}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_character(string value)

Return true if the passed string is either a single- or multibyte character
(i.e., either a single or multibyte string of length 1). Due to zsh constraints,
this function incorrectly returns false for non-ASCII, non-printable multibyte
characters (e.g., Unicode code point U+00A0, a non-breaking space). While this
this is probably fine for most purposes, your shell mileage may vary.
'
function is_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one string'
    string value="${1}"

    # While zsh has no builtin support for getting string length in multibyte
    # characters, it does support getting string length in printable multibyte
    # characters. With a dash of perscipacity, the following thus suffices:
    #
    # * If such string's byte length is 1, this is an ASCII character.
    # * Else, this is either:
    #   * An empty string of length 0.
    #   * An ASCII string of length greater than 1.
    #   * A multibyte string of length greater than or equal to 1.
    # * In the latter case, if such string's printable length is 1, this is a
    #   printable multibyte character. While this excludes non-ASCII, non-
    #   printable multibyte characters from consideration as "characters", there
    #   genuinely isn't much we can do about this at the moment. *shrug*
    (( $(get_string_length "${value}") == 1 ||
       $(get_string_length_printable "${value}") == 1 ))
}

# ....................{ CONVERTERS ~ from                  }....................
document_function '
decimal convert_character_to_decimal(character value)

Convert the passed character to the corresponding UTF-8 code (and hence ASCII,
if such character is ASCII) in base 10 decimal format: e.g.,

    >>> convert_character_to_decimal "${ZESHY_CHARACTER_NEWLINE}"
    10
'
function convert_character_to_decimal() {
    # Validate passed arguments.
    die_unless_arg 'expected one character'
    string value="${1}"
    die_unless_character "${value}"

    # Convert such character with an absurdly concise one-liner.
    print_string $(( #value ))
}

document_function '
hexadecimal convert_character_to_hexadecimal(character value)

Convert the passed character to the corresponding UTF-8 code (and hence ASCII,
if such character is ASCII) in base 16 hexadecimal format: e.g.,

    >>> convert_character_to_hexadecimal "${ZESHY_CHARACTER_NEWLINE}"
    0x0A
'
function convert_character_to_hexadecimal() {
    # Defer to convert_character_to_decimal().
    die_unless_arg 'expected one character'
    convert_decimal_to_hexadecimal "$(convert_character_to_decimal "${1}")"
}

# ....................{ CONVERTERS ~ to                    }....................
document_function '
string convert_decimal_to_character(decimal value)

Convert the passed UTF-8 code (and hence ASCII, if such character is ASCII) in
base 10 decimal format to the corresponding character: e.g.,

    >>> convert_decimal_to_character 69
    E
'
function convert_decimal_to_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one character'
    string value="${1}"
    die_unless_integer "${value}"

    # Convert such integer with an absurdly concise one-liner.
    print_string "${(#)value}"
}

document_function '
string convert_hexadecimal_to_character(hexadecimal value)

Convert the passed UTF-8 code (and hence ASCII, if such character is ASCII) in
base 16 hexadecimal format to the corresponding character: e.g.,

    >>> convert_hexadecimal_to_character 0x45
    E
'
function convert_hexadecimal_to_character() {
    # Validate passed arguments.
    die_unless_arg 'expected one character'
    string value="${1}"
    die_unless_hexadecimal "${value}"

    # Convert such integer with the *SAME* absurdly concise one-liner as above.
    # Wicked, bro.
    print_string "${(#)value}"
}

# --------------------( WASTELANDS                         )--------------------
    # Test such variable. Support multibyte character encodings by
    # calling get_string_length_printable() rather than get_string_length().
#FUXME: Rename to die_unless_character(). (There might be a real
#"character" type, someday.)
