#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *characters* (i.e., strings of multibyte length 1).
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_character(
    string text,
    string error_message = "\"${text}\" not a character.")

Throw an exception with the passed message unless the passed string is a
character. See is_character() for further details.
/---
function die_unless_character() {
    die_unless_args_1_to_2\
        'Expected one variable name and optional error message.'
    string value="${1}"
    is_character "${value}" or die "${2:-\"${value}\" not a character.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_character(string text)

Return success if the passed string is either a single- or multibyte character
(i.e., either a single- or multibyte string of length 1). By `zsh` constraints,
this function incorrectly returns false for non-ASCII, non-printable multibyte
characters (e.g., Unicode code point U+00A0, a non-breaking space). While this
this is probably fine for most purposes, your shell mileage may vary.
/---
function is_character() {
    # Validate passed arguments.
    die_unless_arg 'Expected one string.'
    string value="${1}"

    # While zsh has no builtin support for getting string length in multibyte
    # characters, it does support getting string length in printable multibyte
    # characters. With a dash of perscipacity, the following thus suffices:
    #
    # * If such string's byte length is 1, this is an ASCII character.
    # * Else, this is either:
    #   * An empty string of length 0.
    #   * An ASCII string of length greater than 1.
    #   * A multibyte string of length greater than or equal to 1.
    # * In the latter case, if such string's printable length is 1, this is a
    #   printable multibyte character. While this excludes non-ASCII, non-
    #   printable multibyte characters from consideration as "characters", there
    #   genuinely isn't much we can do about this at the moment. *shrug*
    (( $(get_string_length "${value}") == 1 ||
       $(get_string_length_printable "${value}") == 1 ))
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
character get_character_random_alphanumeric(void)

Get a random *alphanumeric character* (i.e., character in the character class
`[a-zA-Z0-9]`): e.g.,

.get_character_random_alphanumeric()
==========================================
[source]
------------------------------------------
>>> get_character_random_alphanumeric
6
>>> get_character_random_alphanumeric
O
>>> get_character_random_alphanumeric
Z
------------------------------------------
==========================================
/---
function get_character_random() {
    # Validate sanity.
    die_if_args

    #FIXME: Implement! For efficiency, just modulo ${RANDOM} into a new list global
    #${ZESHY_CHARACTERS_ALPHANUMERIC}. Sweet, no?
}

# --------------------( WASTELANDS                         )--------------------
    # Test such variable. Support multibyte character encodings by
    # calling get_string_length_printable() rather than get_string_length().
#FUXME: Rename to die_unless_character(). (There might be a real
#"character" type, someday.)
