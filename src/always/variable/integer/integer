#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle integer variables.

== Caveats ==

As `doc/README.dev` discusses, integer variables suffer numerous deficiencies:
particularly forced casting of non-integer types to 0 and forced rounding down
of float types, all without error or warning. Since string variables suffer no
such deficiencies and implicitly support integer values, consider declaring
integers to be of type string instead. In either case, this component
seemlessly handles integer values and hence both types.
-/-

# --------------------( CAVEATS                            )--------------------
#FIXME: Copy the integer-specific caveats in "doc/README.dev" here, to be
#incorporated into zeshy's formal documentation.

# ....................{ EXCEPTIONS                         }....................
#FIXME: Actually, this function only matches decimal integers. Hence, rename
#this function to die_unless_decimal() and create a new die_unless_integer()
#function properly matching *ALL* integer strings. Such functions needs to match
#both "0x"- and "16#"-style base prefixes.
declare_function_with_stdin <<'/---'
void die_unless_integer(
    string value,
    string error_message = "\"${value}\" not an integer")

Throw an exception with the passed message unless the passed string is an
integer. See is_integer() for further details.
/---
function die_unless_integer() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string value="${1}"
    is_integer "${value}" or die "${2:-\"${value}\" not an integer}"
}

declare_function_with_stdin <<'/---'
void die_unless_integers(string value1, string value2, ...)

Throw an exception with a stock message unless all passed strings are integers.
See is_integer() for further details.
/---
function die_unless_integers() {
    die_unless_args 'expected at least one string'
    for value ("${@}") die_unless_integer "${value}"
}

# ....................{ EXCEPTIONS ~ emptiness             }....................
declare_function_with_stdin <<'/---'
void die_unless_integer_nonzero(
    string integer,
    string error_message = "\"${integer}\" not a nonzero integer")

Throw an exception with the passed message unless the passed string is a
positive integer. See is_integer_positive() for further details.
/---
function die_unless_integer_nonzero() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string integer="${1}"
    is_integer_nonzero "${integer}" or
        die "${2:-\"${integer}\" not a nonzero integer}"
}

# ....................{ EXCEPTIONS ~ sign                  }....................
declare_function_with_stdin <<'/---'
void die_unless_integer_positive(
    string integer,
    string error_message = "\"${integer}\" not a positive integer")

Throw an exception with the passed message unless the passed string is a
positive integer. See is_integer_positive() for further details.
/---
function die_unless_integer_positive() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    is_integer_positive "${1}" or
        die "${2:-\"${1}\" not a positive integer}"
}

declare_function_with_stdin <<'/---'
void die_unless_integer_negative(
    string integer,
    string error_message = "\"${integer}\" not a negative integer")

Throw an exception with the passed message unless the passed string is a
negative integer. See is_integer_negative() for further details.
/---
function die_unless_integer_negative() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string number="${1}"
    is_integer_negative "${number}" or
        die "${2:-\"${number}\" not a negative integer}"
}

declare_function_with_stdin <<'/---'
void die_unless_integer_nonnegative(
    string integer,
    string error_message = "\"${integer}\" not a nonnegative integer")

Throw an exception with the passed message unless the passed string is a
nonnegative integer. See is_integer_nonnegative() for further details.
/---
function die_unless_integer_nonnegative() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string number="${1}"
    is_integer_nonnegative "${number}" or
        die "${2:-\"${number}\" not a nonnegative integer}"
}

declare_function_with_stdin <<'/---'
void die_unless_integer_nonpositive(
    string integer,
    string error_message = "\"${integer}\" not a nonpositive integer")

Throw an exception with the passed message unless the passed string is an
nonpositive integer. See is_integer_nonpositive() for further details.
/---
function die_unless_integer_nonpositive() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string number="${1}"
    is_integer_nonpositive "${number}" or
        die "${2:-\"${number}\" not a nonpositive integer}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_integer(string value)

Return success if the passed string is an *integer* (i.e., string consisting of
optional negative sign and one or more digits).
/---
function is_integer() {
    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, zsh-ism.
    die_unless_arg 'expected one string'
    is "${1}" == ('-'|)<-> si
#   print_call_stack
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_nonzero(integer value)

Return success if the passed integer is *nonzero* (i.e., any integer except 0).
/---
function is_integer_nonzero() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such integer.
    (( number ))
}

# ....................{ TESTERS ~ sign                     }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_integer_positive(string integer)

Return success if the passed string is a positive integer.
/---
function is_integer_positive() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such integer.
    (( number > 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_negative(string integer)

Return success if the passed string is a negative integer.
/---
function is_integer_negative() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such integer.
    (( number < 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_nonnegative(string integer)

Return success if the passed string is a *nonnegative integer* (i.e., integer
either 0 or positive).
/---
function is_integer_nonnegative() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such integer.
    (( number >= 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_nonpositive(string integer)

Return success if the passed string is a *nonpositive integer* (i.e., integer
either 0 or negative).
/---
function is_integer_nonpositive() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such integer.
    (( number <= 0 ))
}

# ....................{ TESTERS ~ parity                   }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_integer_even(integer number)

Return success if the passed integer is even.
/---
function is_integer_even() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such parity.
    not (( number & 1 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_odd(integer number)

Return success if the passed integer is odd.
/---
function is_integer_odd() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such parity.
    (( number & 1 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_parity_equals(integer number1, integer number2)

Return success if the passed integers share the same *parity* (i.e., are either
both even or both odd).
/---
function is_integer_parity_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected two integers'
    string number1="${1}" number2="${2}"
    die_unless_integer "${number1}"
    die_unless_integer "${number2}"

    # Test such parity by recalling two integers share the same parity if and
    # only if their sum is even.
    is_integer_even $(( number1 + number2 ))
}

# ....................{ SETTERS                            }....................
#FIXME: Rename to set_integer_to_integer().
declare_function_with_stdin <<'/---'
void set_integer(string integer_name, integer number)

Set the passed integer to the passed value.
/---
function set_integer() {
    # Validate passed arguments.
    die_unless_args_2 'expected one integer name and one integer'
    string integer_name__si="${1}"
    die_unless_variable_integer "${integer_name__si}"

    # Set such integer.
    noop ${(P)integer_name__si::=${2}}
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string convert_integer_to_string_localized(integer number)

Convert the passed integer to a human-readable string specific to the current
locale (e.g., comma-separating each thousandths place in English locales): e.g.,

.convert_integer_to_string_localized()
==========================================
[source]
------------------------------------------
>>> convert_integer_to_string_localized $(round_float $((4.54 * 10**9)))
4,540,000,000
------------------------------------------
==========================================
/---
# If GNU printf() is available, defer to such command, efficiently implementing
# such conversion with proper localization.
if { is_pathable_gnu printf } {
    function convert_integer_to_string_localized() {
        die_unless_arg 'expected one integer'
        string number="${1}"
        die_unless_integer "${number}"
        printf "%'d\n" "${number}"   # Solid gold, mate.
    }
# Else, implement such conversion in pure zsh.
} else {
    function convert_integer_to_string_localized() {
        # Validate passed arguments.
        die_unless_arg 'expected one integer'
        string number="${1}"
        die_unless_integer "${number}"

        # Thousands separator specific to the current locale.
        string thousands_separator="$(get_locale_string_thousands_separator)"

        # Reverse such integer.
        number="$(reverse_string "${number}")"

        # Suffix every set of three digits with such separator.
        number="${x//(#b)([0-9](#c3))/${match[1]}${thousands_separator}}"

        # If the number of digits in such integer is a multiple of three, the
        # prior replacement appended an superfluous separator. Excise it.
        number="$(remove_string_suffix "${number}" "${thousands_separator}")"

        # Reverse such string back to its original form.
        reverse_string "${number}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Incorrect. *ALL* such functions should die unless the passed integer is
#actually an integer, as only that accords with caller expectations. Note
#interestingly that that also induces correct behavior when called by a
#die_unless_*() function (i.e., an exception is thrown, and in fact a more
#appropriately named exception). See "parity" below for what such
#implementations should resemble.

#FUXME: Rename to convert_integer_to_string_separated_by_commas().
#FUXME: Actually, this should be localized and hence renamed to
#convert_integer_to_string_localized(). Not all locales delimit with commas, as
#we well know. Come to think, this might *ALREADY* be localized in such fashion.
#Research what "awk" actually does with the "'" in "%'d".
    #FUXME: Localize this. Not terribly hard, since zsh module "localeinfo"
    #provides map value "${localeinfo[THOUSEP]}" providing such string.
#       print "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
#   die_unless_arg 'expected one string'
#   is "${1}" == '-'<-> si   # mildly clever optimization
#   string integer_min="${1:-0}" integer_max="${2:-32767}"
#FUXME: Rename "_integer" to "_integer" everywhere.
# ....................{ TESTERS ~ value                    }....................
#FUXME: Bad. Accept string values rather than variable names, as is the standard
#for scalar types. Of course, in that case, we'd might as well just shift all
#"string/integer" functionality here, renaming "string_integer" to simply
#"integer" everywhere. *ACTUALLY, THAT SOUNDS LIKE A BLOODY BRILLIANT IDEA.*
#Make it so, ensign.
#declare_function '
#boolean is_integer_positive(string variable_name)
#
#Return true if the passed variable is an integer > 0.
#'
#function is_integer_positive() {
#    die_unless_arg 'expected one string'
#    string variable_name__iip="${1}"
#    is_variable_integer "${variable_name__iip}" and (( ${(P)variable_name__iip} > 0 ))
#}

#declare_function '
#boolean is_integer_nonnegative(string variable_name)
#
#Return true if the passed variable is an integer >= 0.
#'
#function is_integer_nonnegative() {
#    die_unless_arg 'expected one string'
#    string variable_name__iin="${1}"
#    is_variable_integer "${variable_name_iin}" and (( ${(P)variable_name__iin} >= 0 ))
#}

#FUXME: Excise.
#declare_function '
#void die_unless_integer_positive(
#  string variable_name,
##  string error_message = "\"${variable_name}\" not a positive integer")
#
#Throw an exception unless the passed variable is an integer > 0.
#'
#function die_unless_integer_positive() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duip="${1}"
#    is_integer_positive "${variable_name__duip}" or
#        die "${2:-\"${variable_name__duip}\" not a positive integer}"
#}

#FUXME: Excise.
#declare_function '
#void die_unless_integer_nonnegative(
#  string variable_name,
#  string error_message = "\"${variable_name}\" not a nonnegative integer")
#
#Throw an exception unless the passed variable is an integer >= 0.
#'
#function die_unless_integer_nonnegative() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duin="${1}"
#    is_integer_nonnegative "${variable_name__duin}" or
#        die "${2:-\"${variable_name__duin}\" not a nonnegative integer}"
#}

#FUXME: This now strikes me as rather wrong. Lists and maps are a reasonable
#rule to nomenclature rules as they can only be accessed by named; integers,
#floats, and other scalar types however are always accessible by their expanded
#values. Consequently, it strikes me as *MUCH* more intuitive to rename
#die_unless_integer() and is_integer() to die_unless_variable_integer() and
#is_variable_integer(). Then excise the is_integer_*() functions; they're
#superfulous, really. Replace them with calls to similar is_integer_*()
#functions -- *WHICH BY THE WAY SHOULD THEMSELVES BE RENAMED BACK TO
#is_integer_*() BUT STILL OPERATE ON EXPANDED STRING SCALARS* and probably
#consequently shifted back into this component.
#
#O.K.; so, we have two nomenclature styles insofar as variables are concerned:
#
#* Scalar-specific functions accepting typeless scalar values.
#* Non-scalar-specific functions accepting typed variable names.
#
#This is perfectly fine and in fact necessary. But don't confuse the two. Stay
#consistent. Let's fix this up, eh? We should document this design decision
#somewhere -- it's rather core.
#FUXME: Actually, consistency *ABSOLUTELY* takes precedence. Ignore all of the
#above.

# (i.e., constrained to natural numbers and
# negatives of such numbers)
