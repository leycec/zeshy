#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Copy the integer-specific caveats in "doc/README.dev" here, to be
#incorporated into zeshy's formal documentation.
declare_parcel_as_script_with_stdin <<'/---'
Handle integer functionality _not_ handled by the prior parcel of the same name.

== Caveats ==

As `doc/README.dev` discusses, integer variables suffer numerous deficiencies,
including forced casting of non-integer types to 0 _and_ forced rounding down
of float types without error or warning. Since string variables suffer no such
deficiencies and implicitly support integer values, consider declaring integers
to be of type string instead. In either case, this component seemlessly handles
integer values and hence both types.
/---

# Such functions are either not required at the top-level or call functions
# unavailable at such level and hence do not reside in the prior parcel of the
# same name.

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
void get_integer_maximum(integer number1, ...)

Get the largest of the passed integers: e.g.,

.get_integer_maximum()
==========================================
[source]
------------------------------------------
>>> get_integer_maximum 4 8 15 16 23 42
42
------------------------------------------
==========================================
/---
function get_integer_maximum() {
    # Validate sanity.
    die_unless_args 'Expected one or more integers.'
    die_unless_integers "${@}"

    # Dismantled, this is:
    #
    # * "(On)", sorting such integers in descending order.
    # * "[1]", returning the first such integer.
    output_string "${${(On)@}[1]}"
}

declare_function_with_stdin <<'/---'
void get_integer_minimum(integer number1, ...)

Get the largest of the passed integers: e.g.,

.get_integer_minimum()
==========================================
[source]
------------------------------------------
>>> get_integer_minimum 4 6 8 10 12 14 16 18 20 22 24 26 28 30 36 38 42
4
------------------------------------------
==========================================
/---
function get_integer_minimum() {
    # Validate sanity.
    die_unless_args 'Expected one or more integers.'
    die_unless_integers "${@}"

    # Dismantled, this is:
    #
    # * "(on)", sorting such integers in ascending order.
    # * "[1]", returning the first such integer.
    output_string "${${(on)@}[1]}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_integer_to_integer(string integer_name, integer number)

Set the passed integer variable to the passed integer value: e.g.,

.set_integer_to_integer()
==========================================
[source]
------------------------------------------
>>> integer euler_gompertz_constant_fixed
>>> set_integer_to_integer
...     euler_gompertz_constant_fixed 59634736232319407434107849936927937
>>> print_string "${euler_gompertz_constant_fixed}"
59634736232319407434107849936927937
------------------------------------------
==========================================
/---
function set_integer_to_integer() {
    # Validate sanity.
    die_unless_args_2 'Expected one integer name and one integer.'
    string integer_name__siti="${1}" number="${2}"
    die_unless_variable_integer "${integer_name__siti}"
    die_unless_integer "${number}"

    # Set such integer.
    noop ${(P)integer_name__siti::=${number}}
}

# ....................{ CONVERTERS                         }....................
#FIXME: Rename to localize_integer(). This is reasonably important, as we'll be
#adding different forms of integer localization (e.g.,
#localize_integer_currency()).

declare_function_with_stdin <<'/---'
string convert_integer_to_string_localized(integer number)

Localize the passed integer into a human-readable string specific to the current
locale. For English locales, this comma-separates thousandths places: e.g.,

.convert_integer_to_string_localized()
==========================================
[source]
------------------------------------------
>>> convert_integer_to_string_localized $(round_float $((4.54 * 10**9)))
4,540,000,000
------------------------------------------
==========================================
/---
# If GNU printf() is available, defer to such command, efficiently implementing
# such conversion with proper localization.
if { is_pathable_gnu printf } {
    function convert_integer_to_string_localized() {
        die_unless_arg 'Expected one integer.'
        string number="${1}"
        die_unless_integer "${number}"
        command printf "%'d\n" "${number}"   # Solid gold, mate.
    }
# Else, implement such conversion in pure zsh.
} else {
    function convert_integer_to_string_localized() {
        # Validate sanity.
        die_unless_arg 'Expected one integer.'
        string number="${1}" separator
        die_unless_integer "${number}"

        # Thousandths separator specific to the current locale.
        separator="$(get_locale_delimiter_thousands)"

        # Reverse such integer as a string.
        number="$(reverse_string "${number}")"

        # Suffix every set of three digits with such separator.
        number="${x//(#b)([0-9](#c3))/${match[1]}${separator}}"

        # If the number of digits in such integer is a multiple of three, the
        # prior replacement appended an superfluous separator. Excise it.
        number="$(remove_string_suffix "${number}" "${separator}")"

        # Reverse such string back into an integer.
        reverse_string "${number}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    # the first such integer.
    # If the passed number of arguments is sufficiently small, explicitly
    # searching such integers for the maximum is more efficient than forking a
    # "sort" process sorting such integers in descending order and and returning
    # the first such integer.
    #
    # Ideally, zsh itself would offer some means of 
    # While sorting such integers and returning the first
    # such integer would offer an optimal implementation, zsh currently only
    # supports sorting of nonnegative integers.
    #
    # Since the passed integers may
    # contain negative integers, fall back to an explicit search.

#FUXME: Incorrect. *ALL* such functions should die unless the passed integer is
#actually an integer, as only that accords with caller expectations. Note
#interestingly that that also induces correct behavior when called by a
#die_unless_*() function (i.e., an exception is thrown, and in fact a more
#appropriately named exception). See "parity" below for what such
#implementations should resemble.

#FUXME: Rename to convert_integer_to_string_separated_by_commas().
#FUXME: Actually, this should be localized and hence renamed to
#convert_integer_to_string_localized(). Not all locales delimit with commas, as
#we well know. Come to think, this might *ALREADY* be localized in such fashion.
#Research what "awk" actually does with the "'" in "%'d".
    #FUXME: Localize this. Not terribly hard, since zsh module "localeinfo"
    #provides map value "${localeinfo[THOUSEP]}" providing such string.
#       print "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
#   die_unless_arg 'expected one string'
#   is "${1}" == '-'<-> si   # mildly clever optimization
#   string integer_min="${1:-0}" integer_max="${2:-32767}"
#FUXME: Rename "_integer" to "_integer" everywhere.
# ....................{ TESTERS ~ value                    }....................
#FUXME: Bad. Accept string values rather than variable names, as is the standard
#for scalar types. Of course, in that case, we'd might as well just shift all
#"string/integer" functionality here, renaming "string_integer" to simply
#"integer" everywhere. *ACTUALLY, THAT SOUNDS LIKE A BLOODY BRILLIANT IDEA.*
#Make it so, ensign.
#declare_function '
#boolean is_integer_positive(string variable_name)
#
#Report true if the passed variable is an integer > 0.
#'
#function is_integer_positive() {
#    die_unless_arg 'expected one string'
#    string variable_name__iip="${1}"
#    is_variable_integer "${variable_name__iip}" and (( ${(P)variable_name__iip} > 0 ))
#}

#declare_function '
#boolean is_integer_nonnegative(string variable_name)
#
#Report true if the passed variable is an integer >= 0.
#'
#function is_integer_nonnegative() {
#    die_unless_arg 'expected one string'
#    string variable_name__iin="${1}"
#    is_variable_integer "${variable_name_iin}" and (( ${(P)variable_name__iin} >= 0 ))
#}

#FUXME: Excise.
#declare_function '
#void die_unless_integer_positive(
#  string variable_name,
##  string error_message = "\"${variable_name}\" not a positive integer")
#
#Throw an exception unless the passed variable is an integer > 0.
#'
#function die_unless_integer_positive() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duip="${1}"
#    is_integer_positive "${variable_name__duip}" or
#        die "${2:-\"${variable_name__duip}\" not a positive integer}"
#}

#FUXME: Excise.
#declare_function '
#void die_unless_integer_nonnegative(
#  string variable_name,
#  string error_message = "\"${variable_name}\" not a nonnegative integer")
#
#Throw an exception unless the passed variable is an integer >= 0.
#'
#function die_unless_integer_nonnegative() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duin="${1}"
#    is_integer_nonnegative "${variable_name__duin}" or
#        die "${2:-\"${variable_name__duin}\" not a nonnegative integer}"
#}

#FUXME: This now strikes me as rather wrong. Lists and maps are a reasonable
#rule to nomenclature rules as they can only be accessed by named; integers,
#floats, and other scalar types however are always accessible by their expanded
#values. Consequently, it strikes me as *MUCH* more intuitive to rename
#die_unless_integer() and is_integer() to die_unless_variable_integer() and
#is_variable_integer(). Then excise the is_integer_*() functions; they're
#superfulous, really. Replace them with calls to similar is_integer_*()
#functions -- *WHICH BY THE WAY SHOULD THEMSELVES BE RENAMED BACK TO
#is_integer_*() BUT STILL OPERATE ON EXPANDED STRING SCALARS* and probably
#consequently shifted back into this component.
#
#O.K.; so, we have two nomenclature styles insofar as variables are concerned:
#
#* Scalar-specific functions accepting typeless scalar values.
#* Non-scalar-specific functions accepting typed variable names.
#
#This is perfectly fine and in fact necessary. But don't confuse the two. Stay
#consistent. Let's fix this up, eh? We should document this design decision
#somewhere -- it's rather core.
#FUXME: Actually, consistency *ABSOLUTELY* takes precedence. Ignore all of the
#above.

# (i.e., constrained to natural numbers and
# negatives of such numbers)
