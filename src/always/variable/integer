#!/usr/bin/env zsh
# ====================[ integer                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle integer variables and values.
#
# --------------------( CAVEATS                            )--------------------
# As "doc/README.dev" discusses, integer variables suffer numerous deficiencies:
# particularly forced casting of non-integer types to 0 and forced rounding down
# of float types, all without error or warning. Since string variables suffer no
# such deficiencies and implicitly support integer values, consider declaring
# integers to be of type string instead. In either case, this component
# seemlessly handles integer values and hence both types.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_integer(
  string value,
  string error_message = "\"${value}\" not an integer")

Throw an exception unless the passed string is an integer. See
is_integer() for further details.
'
function die_unless_integer() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    is_integer "${1}" or die "${2:-\"${1}\" not an integer}"
}

document_function '
void die_unless_integer_positive(
  string value,
  string error_message = "\"${value}\" not a positive integer")

Throw an exception unless the passed string is a positive integer.
'
function die_unless_integer_positive() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    is_integer_positive "${1}" or die "${2:-\"${1}\" not a positive integer}"
}

document_function '
void die_unless_integer_negative(
  string value,
  string error_message = "\"${value}\" not a negative integer")

Throw an exception unless the passed string is a negative integer.
'
function die_unless_integer_negative() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    is_integer_negative "${1}" or die "${2:-\"${1}\" not a negative integer}"
}

document_function '
void die_unless_integer_nonnegative(
  string value,
  string error_message = "\"${value}\" not a nonnegative integer")

Throw an exception unless the passed string is a nonnegative integer.
'
function die_unless_integer_nonnegative() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    is_integer_nonnegative "${1}" or
        die "${2:-\"${1}\" not a nonnegative integer}"
}

document_function '
void die_unless_integer_nonpositive(
  string value,
  string error_message = "\"${value}\" not a nonpositive integer")

Throw an exception unless the passed string is an integer <= 0.
'
function die_unless_integer_nonpositive() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    is_integer_nonpositive "${1}" or
        die "${2:-\"${1}\" not a nonpositive integer}"
}

document_function '
void die_unless_integer_ranging(
  string value, integer lower_bound, integer upper_bound,
  string error_message = "\"${value}\" not an integer in [${lower_bound}, ${upper_bound}]}")

Throw an exception unless the passed string is an integer between the passed
inclusive lower and upper integer bounds.
'
function die_unless_integer_ranging() {
    die_unless_args_3_to_4\
        'expected one string and optional error message'
    string value="${1}" lower_bound="${2}" upper_bound="${3}"
    is_integer_ranging "${value}" "${lower_bound}" "${upper_bound}" or
        die "${4:-\"${value}\" not an integer in [${lower_bound}, ${upper_bound}]}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_integer(string value)

Return true if the passed string is an integer (i.e., a string consisting of
an optional negative sign and one or more digits).
'
function is_integer() {
    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, Zsh-ism.
    die_unless_arg 'expected one string'
    is "${1}" == ('-'|)<-> si
}

#FIXME: Incorrect. *ALL* such functions should die unless the passed integer is
#actually an integer, as only that accords with caller expectations. Note
#interestingly that that also induces correct behavior when called by a
#die_unless_*() function (i.e., an exception is thrown, and in fact a more
#appropriately named exception). See "parity" below for what such
#implementations should resemble.
document_function '
boolean is_integer_positive(string value)

Return true if the passed string is a positive integer.
'
function is_integer_positive() {
    die_unless_arg 'expected one string'
    string value="${1}"
    is_integer "${value}" and (( value > 0 ))
}

document_function '
boolean is_integer_negative(string value)

Return true if the passed string is a negative integer.
'
function is_integer_negative() {
    die_unless_arg 'expected one string'
    is "${1}" == '-'<-> si   # mildly clever optimization
}

document_function '
boolean is_integer_nonnegative(string value)

Return true if the passed string is a nonnegative integer (i.e., an integer
either 0 or positive).
'
function is_integer_nonnegative() {
    die_unless_arg 'expected one string'
    is "${1}" == <-> si   # mildly clever optimization
}

document_function '
boolean is_integer_nonpositive(string value)

Return true if the passed string is a nonpositive integer (i.e., an integer
either 0 or negative).
'
function is_integer_nonpositive() {
    die_unless_arg 'expected one string'
    string value="${1}"
    is_integer "${value}" and (( value <= 0 ))
}

document_function '
boolean is_integer_ranging(
  string value, integer lower_bound, integer upper_bound)

Return true if the passed string is an value bounded by the passed inclusive
lower and upper bounds.
'
function is_integer_ranging() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one string, one lower bound, and one upper bound'
    string value="${1}" lower_bound="${2}" upper_bound="${3}"
    die_unless_integer "${lower_bound}"
    die_unless_integer "${upper_bound}"
    (( "${lower_bound}" <= "${upper_bound}" )) or
        die "lower bound \"${lower_bound}\" > upper bound \"${upper_bound}\""

    # Test such string.
    is_integer "${value}" and
        (( lower_bound <= value && value <= upper_bound ))
}

# ....................{ TESTERS ~ parity                   }....................
document_function '
boolean is_integer_even(integer number)

Return true if the passed integer is even.
'
function is_integer_even() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such parity.
    not (( number & 1 ))
}

document_function '
boolean is_integer_odd(integer number)

Return true if the passed integer is odd.
'
function is_integer_odd() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string number="${1}"
    die_unless_integer "${number}"

    # Test such parity.
    (( number & 1 ))
}

document_function '
boolean is_integer_parity_equals(integer number1, integer number2)

Return true if the passed integers share the same parity (i.e., are either both
even or both odd).
'
function is_integer_parity_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected two integers'
    string number1="${1}" number2="${2}"
    die_unless_integer "${number1}"
    die_unless_integer "${number2}"

    # Test such parity by recalling two integers share the same parity if and
    # only if their sum is even.
    is_integer_even $(( number1 + number2 ))
}

# ....................{ GETTERS                            }....................
document_function '
integer get_integers_ranging(integer start_integer, integer end_integer)

Get a list inclusively ranging over the passed start and end integers: e.g.,

    >>> get_integers_ranging 6 9
    6 7 8 9
'
function get_integers_ranging() {
    die_unless_args_2 'expected one start integer and one end integer'
    string beg_integer="${1}" end_integer="${2}"
    die_unless_integer "${beg_integer}"
    die_unless_integer "${end_integer}"
    print_string {${beg_integer}..${end_integer}}
}

#FIXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html

document_function '
integer get_integer_random(integer minimum = 0, integer maximum = 32767)

Get a random integer bounded inclusively by the passed minimum and maximum.
'
function get_integer_random() {
    # Validate passed arguments.
    die_unless_args_0_to_2\
        'expected optional minimum and maximum integers'
    string min_integer="${1:-0}" max_integer="${2:-32767}"
    die_unless_integer "${min_integer}"
    die_unless_integer "${max_integer}"

    #FIXME: Raise an exception if the passed "max" is larger than 32767? We can
    #fake larger ranges by simply multiplying with float arithmetic and capping
    #the print_string to the desired max, which seems preferable.

    # The current time in seconds since the first expansion of ${SECONDS} to six
    # fractional string places of accuracy: the maximum under Linux.
    float_with_fractional_digit_length 6 seconds="${SECONDS}"

    # Prior to returning a random number, force Zsh's internal random number
    # generator to iterate to the next such number by reseeding with such time
    # discarding the separating string place ".". Failure to do so returns the
    # same initial number of such sequence on each call to this function.
    RANDOM=${seconds/./}

    # Randomize.
    print_string\
        $[(${RANDOM} % (${max_integer} - ${min_integer} + 1)) + ${min_integer}]
}

# ....................{ SETTERS                            }....................
document_function '
void set_integer(string integer_name, integer number)

Set the passed integer to the passed value.
'
function set_integer() {
    # Validate passed arguments.
    die_unless_args_2 'expected one integer name and one integer'
    string integer_name__si="${1}"
    die_unless_variable_integer "${integer_name__si}"

    # Set such integer.
    noop ${(P)integer_name__si::=${2}}
}

# ....................{ CONVERTERS                         }....................
document_function '
string convert_integer_to_comma_separated_string(integer number)

Convert the passed integer to a comma-separated string: e.g.,

    >>> convert_integer_to_comma_separated_string 1776
    1,776
'
function convert_integer_to_comma_separated_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string integer="${1}"
    die_unless_integer "${integer}"

    # Unlike Zsh's printf(), awk's printf() happily supports comma delimitation.
    print_string "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename "_integer" to "_integer" everywhere.
# ....................{ TESTERS ~ value                    }....................
#FUXME: Bad. Accept string values rather than variable names, as is the standard
#for scalar types. Of course, in that case, we'd might as well just shift all
#"string/integer" functionality here, renaming "string_integer" to simply
#"integer" everywhere. *ACTUALLY, THAT SOUNDS LIKE A BLOODY BRILLIANT IDEA.*
#Make it so, ensign.
#document_function '
#boolean is_integer_positive(string variable_name)
#
#Return true if the passed variable is an integer > 0.
#'
#function is_integer_positive() {
#    die_unless_arg 'expected one string'
#    string variable_name__iip="${1}"
#    is_variable_integer "${variable_name__iip}" and (( ${(P)variable_name__iip} > 0 ))
#}

#document_function '
#boolean is_integer_nonnegative(string variable_name)
#
#Return true if the passed variable is an integer >= 0.
#'
#function is_integer_nonnegative() {
#    die_unless_arg 'expected one string'
#    string variable_name__iin="${1}"
#    is_variable_integer "${variable_name_iin}" and (( ${(P)variable_name__iin} >= 0 ))
#}

#FUXME: Excise.
#document_function '
#void die_unless_integer_positive(
#  string variable_name,
##  string error_message = "\"${variable_name}\" not a positive integer")
#
#Throw an exception unless the passed variable is an integer > 0.
#'
#function die_unless_integer_positive() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duip="${1}"
#    is_integer_positive "${variable_name__duip}" or
#        die "${2:-\"${variable_name__duip}\" not a positive integer}"
#}

#FUXME: Excise.
#document_function '
#void die_unless_integer_nonnegative(
#  string variable_name,
#  string error_message = "\"${variable_name}\" not a nonnegative integer")
#
#Throw an exception unless the passed variable is an integer >= 0.
#'
#function die_unless_integer_nonnegative() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duin="${1}"
#    is_integer_nonnegative "${variable_name__duin}" or
#        die "${2:-\"${variable_name__duin}\" not a nonnegative integer}"
#}

#FUXME: This now strikes me as rather wrong. Lists and maps are a reasonable
#rule to nomenclature rules as they can only be accessed by named; integers,
#floats, and other scalar types however are always accessible by their expanded
#values. Consequently, it strikes me as *MUCH* more intuitive to rename
#die_unless_integer() and is_integer() to die_unless_variable_integer() and
#is_variable_integer(). Then excise the is_integer_*() functions; they're
#superfulous, really. Replace them with calls to similar is_integer_*()
#functions -- *WHICH BY THE WAY SHOULD THEMSELVES BE RENAMED BACK TO
#is_integer_*() BUT STILL OPERATE ON EXPANDED STRING SCALARS* and probably
#consequently shifted back into this component.
#
#O.K.; so, we have two nomenclature styles insofar as variables are concerned:
#
#* Scalar-specific functions accepting typeless scalar values.
#* Non-scalar-specific functions accepting typed variable names.
#
#This is perfectly fine and in fact necessary. But don't confuse the two. Stay
#consistent. Let's fix this up, eh? We should document this design decision
#somewhere -- it's rather core.
#FUXME: Actually, consistency *ABSOLUTELY* takes precedence. Ignore all of the
#above.

# (i.e., constrained to natural numbers and
# negatives of such numbers)
