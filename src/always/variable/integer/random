#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle random integer generators.
-/-

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_integer_random_in_range(integer minimum, integer maximum)

Get a random integer in the passed inclusive range: e.g.,

.get_integer_random_in_range()
==========================================
[source]
------------------------------------------
>>> get_integer_random_in_range 0x0DDBA11 0x60DDE55
0x1D0112E
------------------------------------------
==========================================
/---
# If the current shell provides rand48(), prefer such function to integer
# ${RANDOM}. The former is more reliable, efficient, and accurate.
if { is_math_function_rand48 } {
#   print 'get_integer_random_in_range: adopting rand48()-based implementation'
    function get_integer_random_in_range() {
        # Validate passed arguments.
        die_unless_args_2 'Expected one minimum integer and one maximum integer.'
        string minimum="${1}" maximum="${2}"
        die_unless_integer_at_most "${minimum}" "${maximum}"

        # rand48() always returns a float in [0.0, 1.0). Adjust accordingly.
        output_string $(( minimum + int(rand48() * (maximum - minimum + 1)) ))
    }
# Else, fallback to integer ${RANDOM}. Such global is strictly in [0, 32767]
# *AND* requires reseeding on each expansion, complicating the implementation.
} else {
#   print 'get_integer_random_in_range: falling back to ${RANDOM}-based implementation'
    function get_integer_random_in_range() {
        # Validate passed arguments.
        die_unless_args_2 'Expected one minimum integer and one maximum integer.'
        string minimum="${1}" maximum="${2}"
        die_unless_integer_at_most "${minimum}" "${maximum}"

        #FIXME: Obtaining nanoseconds would be far preferable, but again
        #gets into portability issues. *shrug*
        # The current time in seconds since the first expansion of ${SECONDS} to six
        # fractional string places of accuracy: the maximum under Linux.
        float_with_fractional_digit_length 6 seconds="${SECONDS}"

        # Prior to returning a random number, force zsh's internal random number
        # generator to iterate to the next such number by reseeding with such time
        # discarding the separating string place ".". Failure to do so returns the
        # same initial number of such sequence on each call to this function.
        RANDOM=${seconds/./}

        # If such range is within that provided by ${RANDOM} (i.e., in
        # [0, 32767], the positive end of the range provided by a 2-byte signed
        # short), modulo ${RANDOM} itself to produce a random integer in
        # [0, maximum - minimum], where maximum - minimum + 1 is the number of
        # possible integers in such range. Adding the minimum shifts this to
        # [minimum, maximum], as expected.
        if (( minimum >= 0 && maximum <= 32767 )) {
            return_string $(( minimum + (RANDOM % (maximum - minimum + 1)) ))
        # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
        # transformation as above, noting that the end bound is inclusive in
        # this case rather than exclusive and hence off by 1.
        } else {
            float random; random=$(( RANDOM / 32767 ))
            return_string $(( minimum + int(random * (maximum - minimum)) ))
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ PRECOMPILERS                       }....................
#run_hook_on_zeshy_precompile precompile_zeshy_get_integer_random_in_range

#declare_function_with_stdin <<'/---'
#void precompile_zeshy_get_integer_random_in_range(void)
#
#Define get_integer_random_in_range() before compiling Zeshy''s user digest file.
#Implement such function to call rand48() if zsh was compiled with support for
#erand48() or to expand integer ${RANDOM} otherwise.
#/---
#function precompile_zeshy_get_integer_random_in_range() {
#    # Validate sanity.
#    die_if_args
#
#}

# Define such function at precompile time, below.

# Wrap such test in an "eval" statement to allow redirection to the bitbucket.
#function get_integer_random_in_range() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one minimum and one maximum integers'
#    string minimum="${1}" maximum="${2}"
#    die_unless_integers "${minimum}" "${maximum}"
#
#    # Number of possible integers in the passed range.
#    integer count; count=$(( maximum - minimum + 1 ))
#
#    # If the current shell provides rand48(), prefer such function to canonical
#    # global integer ${RANDOM}. The former's accuracy, efficiency, and
#    # reliability are markedly superior. Since rand48() always returns a float
#    # in [0.0, 1.0), the implementation is quite simple.
#    if is_math_function_rand48
#    then print_string $(( minimum + int(rand48() * (maximum - minimum + 1)) ))
#    else
#        # The current time in seconds since the first expansion of ${SECONDS} to six
#        # fractional string places of accuracy: the maximum under Linux.
#        float_with_fractional_digit_length 6 seconds="${SECONDS}"
#
#        #FIXME: Replace with a corresponding Zeshy function call.
#        # Prior to returning a random number, force zsh's internal random number
#        # generator to iterate to the next such number by reseeding with such time
#        # discarding the separating string place ".". Failure to do so returns the
#        # same initial number of such sequence on each call to this function.
#        RANDOM=${seconds/./}
#
#        # If such range is within that provided by ${RANDOM} (i.e., in
#        # [0, 32767], the positive end of the range provided by a 2-byte signed
#        # short), modulo ${RANDOM} itself to produce a random integer in
#        # [0, maximum - minimum], where maximum - minimum + 1 is the number of
#        # possible integers in such range. Adding the minimum shifts this to
#        # [minimum, maximum], as expected.
#        if (( minimum >= 0 || maximum <= 32767 ))
#        then print_string $(( minimum + (RANDOM % (maximum - minimum + 1)) ))
#        # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
#        # transformation as above, noting that the end bound is inclusive in
#        # this case rather than exclusive and hence off by 1.
#        else
#            float random; random=$(( RANDOM / 32767 ))
#            print_string $(( minimum + int(random * (maximum - minimum)) ))
#        fi
#    fi
#}

        #FUXME: Raise an exception if the passed "max" is larger than 32767? We can
        #fake larger ranges by simply multiplying with float arithmetic and capping
        #the print_string to the desired max, which seems preferable.

#FUXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html

