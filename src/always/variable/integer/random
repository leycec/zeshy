#!/usr/bin/env zsh
# ====================[ integer                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle random integer generators.

# ....................{ TESTERS                            }....................
document_function '
boolean is_math_function_rand48(void)

Return true if zsh was compiled with support for erand48(), an optional function
typically defined by the current system''s mathematical library (e.g., "libm").
'
function is_math_function_rand48() {
    # Sadly, zsh provides no direct means of testing for such math support.
    # Happily, a venerate hack exists. Since rand48() if defined *ALWAYS*
    # returns a float in [0.0, 1.0), the expression "(( rand48() >= 0.0 ))" only
    # fails under shells not defining such function.
    die_if_args

    # Since this function is often called prior to calling startup_zeshy(),
    # which autoloads zsh modules, load the module defining rand48() here.
    load_zsh_module zsh/mathfunc

    # Test such function, squelching errors should such function not exist.
    run_command_silently '(( rand48() >= 0.0 ))'
#   eval '(( rand48() >= 0.0 ))'
}

# ....................{ GETTERS                            }....................
# Define such function at precompile time, below.
document_function '
integer get_integer_random_between(integer minimum, integer maximum)

Get a random integer in the passed inclusive range: e.g.,

    >>> get_integer_random_between 0x0DDBA11 0x60DDE55
    0x1D0112E
'

# ....................{ PRECOMPILERS                       }....................
run_hook_on_zeshy_precompile precompile_zeshy_get_integer_random_between

document_function '
void precompile_zeshy_get_integer_random_between(void)

Define get_integer_random_between() before compiling Zeshy''s user digest file.
Implement such function to call rand48() if zsh was compiled with support for
erand48() or to expand integer ${RANDOM} otherwise.
'
function precompile_zeshy_get_integer_random_between() {
    # Validate sanity.
    die_if_args

    # If the current shell provides rand48(), prefer such function to integer
    # ${RANDOM}. The former is more reliable, efficient, and accurate.
    if is_math_function_rand48; then
#       print 'get_integer_random_between: adopting rand48()-based implementation'
        function get_integer_random_between() {
            # Validate passed arguments.
            die_unless_args_2 'expected one minimum and one maximum integers'
            string minimum="${1}" maximum="${2}"
            die_unless_integers "${minimum}" "${maximum}"

            # rand48() always returns a float in [0.0, 1.0). Adjust accordingly.
            print_string $(( minimum + int(rand48() * (maximum - minimum + 1)) ))
        }
    # Else, fallback to integer ${RANDOM}. Such global is strictly in [0, 32767]
    # *AND* requires reseeding on each expansion, complicating the
    # implementation.
    else
#       print 'get_integer_random_between: falling back to ${RANDOM}-based implementation'
        function get_integer_random_between() {
            # Validate passed arguments.
            die_unless_args_2 'expected one minimum and one maximum integers'
            string minimum="${1}" maximum="${2}"
            die_unless_integers "${minimum}" "${maximum}"

            #FIXME: Obtaining nanoseconds would be far preferable, but again
            #gets into portability issues. *shrug*
            # The current time in seconds since the first expansion of ${SECONDS} to six
            # fractional string places of accuracy: the maximum under Linux.
            float_with_fractional_digit_length 6 seconds="${SECONDS}"

            #FIXME: Replace with a corresponding Zeshy function call.
            # Prior to returning a random number, force zsh's internal random number
            # generator to iterate to the next such number by reseeding with such time
            # discarding the separating string place ".". Failure to do so returns the
            # same initial number of such sequence on each call to this function.
            RANDOM=${seconds/./}

            # If such range is within that provided by ${RANDOM} (i.e., in
            # [0, 32767], the positive end of the range provided by a 2-byte signed
            # short), modulo ${RANDOM} itself to produce a random integer in
            # [0, maximum - minimum], where maximum - minimum + 1 is the number of
            # possible integers in such range. Adding the minimum shifts this to
            # [minimum, maximum], as expected.
            if (( minimum >= 0 && maximum <= 32767 ))
            then print_string $(( minimum + (RANDOM % (maximum - minimum + 1)) ))
            # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
            # transformation as above, noting that the end bound is inclusive in
            # this case rather than exclusive and hence off by 1.
            else
                float random; random=$(( RANDOM / 32767 ))
                print_string $(( minimum + int(random * (maximum - minimum)) ))
            fi
        }
    fi
}

# --------------------( WASTELANDS                         )--------------------
# Wrap such test in an "eval" statement to allow redirection to the bitbucket.
#function get_integer_random_between() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one minimum and one maximum integers'
#    string minimum="${1}" maximum="${2}"
#    die_unless_integers "${minimum}" "${maximum}"
#
#    # Number of possible integers in the passed range.
#    integer count; count=$(( maximum - minimum + 1 ))
#
#    # If the current shell provides rand48(), prefer such function to canonical
#    # global integer ${RANDOM}. The former's accuracy, efficiency, and
#    # reliability are markedly superior. Since rand48() always returns a float
#    # in [0.0, 1.0), the implementation is quite simple.
#    if is_math_function_rand48
#    then print_string $(( minimum + int(rand48() * (maximum - minimum + 1)) ))
#    else
#        # The current time in seconds since the first expansion of ${SECONDS} to six
#        # fractional string places of accuracy: the maximum under Linux.
#        float_with_fractional_digit_length 6 seconds="${SECONDS}"
#
#        #FIXME: Replace with a corresponding Zeshy function call.
#        # Prior to returning a random number, force zsh's internal random number
#        # generator to iterate to the next such number by reseeding with such time
#        # discarding the separating string place ".". Failure to do so returns the
#        # same initial number of such sequence on each call to this function.
#        RANDOM=${seconds/./}
#
#        # If such range is within that provided by ${RANDOM} (i.e., in
#        # [0, 32767], the positive end of the range provided by a 2-byte signed
#        # short), modulo ${RANDOM} itself to produce a random integer in
#        # [0, maximum - minimum], where maximum - minimum + 1 is the number of
#        # possible integers in such range. Adding the minimum shifts this to
#        # [minimum, maximum], as expected.
#        if (( minimum >= 0 || maximum <= 32767 ))
#        then print_string $(( minimum + (RANDOM % (maximum - minimum + 1)) ))
#        # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
#        # transformation as above, noting that the end bound is inclusive in
#        # this case rather than exclusive and hence off by 1.
#        else
#            float random; random=$(( RANDOM / 32767 ))
#            print_string $(( minimum + int(random * (maximum - minimum)) ))
#        fi
#    fi
#}

        #FUXME: Raise an exception if the passed "max" is larger than 32767? We can
        #fake larger ranges by simply multiplying with float arithmetic and capping
        #the print_string to the desired max, which seems preferable.

#FUXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html

