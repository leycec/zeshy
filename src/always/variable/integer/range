#!/usr/bin/env zsh
# ====================[ range                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle integer ranges.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void {die_unless_integer_at_least, die_unless_integer_exceeds_or_equals}(
    integer number, integer minimum,
    string error_message = "${number} less than ${minimum}")

Throw an exception with the passed message unless the first passed integer is
greater than or equal to the second passed integer.
________________<heredoc?>________________
function die_unless_integer_at_least die_unless_integer_exceeds_or_equals() {
    die_unless_args_2_to_3\
        'expected one integer, one integer minimum, and optional error message'
    string number="${1}" number_minimum="${2}"
    is_integer_at_least "${number}" "${number_minimum}" or
        die "${3:-${number} less than ${number_minimum}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void {die_unless_integer_at_most, die_unless_integer_deceeds_or_equals}(
    integer number, integer maximum,
    string error_message = "${number} greater than ${maximum}")

Throw an exception with the passed message unless the first passed integer is
less than or equal to the second passed integer.
________________<heredoc?>________________
function die_unless_integer_at_most die_unless_integer_deceeds_or_equals() {
    die_unless_args_2_to_3\
        'expected one integer, one integer minimum, and optional error message'
    string number="${1}" number_maximum="${2}"
    is_integer_at_most "${number}" "${number_maximum}" or
        die "${3:-${number} greater than ${number_maximum}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_integer_in_range(
    integer number, integer minimum, integer maximum,
    string error_message = "${number} not in [${minimum}, ${maximum}]}")

Throw an exception with the passed message unless the passed string is an
integer in the passed range. See is_integer_in_range() for further details.
________________<heredoc?>________________

function die_unless_integer_in_range() {
    die_unless_args_3_to_4\
        'expected one integer, one integer minimum, one integer maximum, and optional error message'
    string number="${1}" number_minimum="${2}" number_maximum="${3}"
    is_integer_in_range "${number}" "${number_minimum}" "${number_maximum}" or
        die "${4:-${number} not in [${number_minimum}, ${number_maximum}]}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] {is_integer_at_least, is_integer_exceeds_or_equals}(
    integer number, integer minimum)

Return success if the first passed integer is greater than or equal to the
second passed integer.
________________<heredoc?>________________
function is_integer_at_least is_integer_exceeds_or_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected two integers'
    string left="${1}" right="${2}"
    die_unless_integers "${left}" "${right}"

    # Test such integer.
    (( left >= right ))
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] {is_integer_at_most, is_integer_deceeds_or_equals}(
    integer number, integer maximum)

Return success if the first passed integer is less than or equal to the second
passed integer.
________________<heredoc?>________________
function is_integer_at_most is_integer_deceeds_or_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected two integers'
    string left="${1}" right="${2}"
    die_unless_integers "${left}" "${right}"

    # Test such integer.
    (( left <= right ))
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_integer_in_range(
    integer number, integer minimum, integer maximum)

Return success if the passed integer is in the passed range (i.e., greater than
or equal to the passed minimum and less than or equal to the passed maximum):
e.g.,

.is_integer_in_range()
==========================================
[source]
------------------------------------------
>>> is_integer_in_range 1776 1694 1913 and print_string\
...    "If history shows anything, it is that there's no better way to justify
...     relations founded on violence, to make such relations seem moral, than
...     by reframing them in the language of debt — above all, because it
...     immediately makes it seem that it's the victim who's doing something
...     wrong."
If history shows anything, it is that there's no better way to justify
relations founded on violence, to make such relations seem moral, than
by reframing them in the language of debt — above all, because it
immediately makes it seem that it's the victim who's doing something
wrong.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_integer_in_range() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one integer, one integer minimum, and one integer maximum'
    string number="${1}" minimum="${2}" maximum="${3}"
    die_unless_integers "${number}" "${minimum}" "${maximum}"
    (( "${minimum}" <= "${maximum}" )) or
        die "minimum \"${minimum}\" greater than maximum \"${maximum}\""

    # Test such integer.
    (( minimum <= number && number <= maximum ))
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_integers_in_range(). If the passed range is sufficiently
#large, this silently terminates the current shell, which is terrible. This
#appears to be somewhere between 100,000 to 1,000,000 elements. Hence, if such
#range is larger than 100000, just throw an exception. There's really no point
#in ever listing that many integers anyway, so this is a helpful reality check
#as well.
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_integers_in_range(integer minimum, integer maximum)

List all integers in the passed inclusive range, delimited by spaces: e.g.,

.get_integers_in_range()
==========================================
[source]
------------------------------------------
>>> get_integers_in_range 19450806 19450809
19450806 19450807 19450808 19450809
------------------------------------------
==========================================
________________<heredoc?>________________
function get_integers_in_range() {
    die_unless_args_2 'expected one minimum integer and one maximum integer'
    get_integers_in_range_with_step "${1}" "${2}" 1
}

declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_integers_in_range_with_step(
    integer start, integer end, integer step)

List all integers incremented by the passed ``step'' starting with the first
passed integer and stopping with the second passed integer, delimited by spaces.
See for_integers_in_range_with_step() for further details: e.g.,

.get_integers_in_range_with_step()
==========================================
[source]
------------------------------------------
>>> get_integers_in_range_with_step1 19551101 19750430 300000
19551101 19581101 19611101 19641101 19671101 19701101 19731101
------------------------------------------
==========================================
________________<heredoc?>________________
function get_integers_in_range_with_step() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one start integer, one end integer, and one step'
    string start="${1}" end="${2}" step="${3}"
    die_unless_integers "${start}" "${end}" "${step}"

    # See for_integers_in_range_with_step() for further details.
    if (( step > 0 )) {
        die_unless_integer_at_most "${start}" "${stop}"
    } elif (( step < 0 )) {
        die_unless_integer_at_least "${start}" "${stop}"
    } else {
        die 'expected nonzero step'
    }

    # If such range exceeds an experimentally (if non-rigorously) verified
    # maximum, throw an exception. Since attempting to make a list of integers
    # in such range induces zsh to silently terminate the current shell,
    # throwing an exception is the lesser of two certain evils.
    (( abs((stop - start) / step) >= 100000 )) and
        die "range [${start}, ${stop}] with step ${step} exceeds zsh limits"

    # Get such integers.
    output_string {${start}..${end}..${step}}
}

# ....................{ ITERATORS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_integers_in_range(
    integer minimum,
    integer maximum,
    string integer_name = 'INTEGER',
    string command)

Run the passed command for each integer in the passed range in ascending order,
setting the passed integer local (defaulting to `${INTEGER}`) to each such
integer starting with the passed minimum and stopping at the passed maximum:
e.g.,

.for_integers_in_range()
==========================================
[source]
------------------------------------------
>>> for_integers_in_range 1869 1929 reconstruction_year\
...     '(( reconstruction_year % 10 )) or output_string ${reconstruction_year}'
1870
1880
1890
1900
1910
1920
------------------------------------------
==========================================
________________<heredoc?>________________
function for_integers_in_range() {
    die_unless_args_3_or_4\
        'expected one minimum integer, one maximum integer, optional integer name, and one command'
    for_integers_in_range_with_step "${1}" "${2}" 1 "${@[3,]}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string for_integers_in_range_with_step(
    integer start,
    integer stop,
    integer step,
    string integer_name = 'INTEGER',
    string command)

Run the passed command for each integer in the passed range, setting the passed
integer local (defaulting to `${INTEGER}`) to each such integer incremented by
the passed ``step'' starting with the first passed integer and stopping with the
second passed integer. If such step is:

* Positive, the starting integer must be less than or equal to the stopping
  integer. In such case, integers are incremented in ascending order.
* Negative, the starting integer must be greater than or equal to the stopping
  integer. In such case, integers are incremented in descending order.

In either case, unless such step evenly divides the absolute difference of such
starting and stopping integers, the last integer to be incremented strictly
precedes such stopping integer. For example:

.for_integers_in_range_with_step()
==========================================
[source]
------------------------------------------
>>> for_integers_in_range_with_step 541 747 42 plague_year\
...     'output_string ${plague_year}'
541
583
625
667
709
>>> for_integers_in_range_with_step 1844 1346 -84 plague_year\
...     'output_string ${plague_year}'
1844
1760
1676
1592
1508
1424
1340
------------------------------------------
==========================================
________________<heredoc?>________________
function for_integers_in_range_with_step() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize changes with get_integers_in_range_with_step().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_4_or_5\
        'expected one integer start, one integer stop, one integer step, optional integer name, and one command'
    string\
        start="${1}"\
        stop="${2}"\
        step="${3}"\
        integer_name='INTEGER'\
        command="${@[-1]}"
    is_args_5 and integer_name="${4}"
    die_unless_integers "${start}" "${stop}" "${step}"
    die_unless_string_nonempty "${integer_name}" 'expected nonempty integer name'
    die_unless_string_nonempty "${command}" 'expected nonempty command'

    # If such step is positive, ensure such start is less than such stop.
    if (( step > 0 )) {
        die_unless_integer_at_most "${start}" "${stop}"
    # If such step is negative, ensure such start is greater than such stop.
    } elif (( step < 0 )) {
        die_unless_integer_at_least "${start}" "${stop}"
    # Else, such step is zero. To avoid infinite loops, throw an exception.
    } else {
        die 'expected nonzero step'
    }

    # If such range is sufficiently small, make and iterate an ordered list of
    # all integers in such range. Practical (if non-rigorous) experimentation
    # demonstrates that making lists an order of magnitude larger induces
    # discernable slowdown and lists at least two orders of magnitude larger
    # termination of the current shell. In either case, the costs are
    # unacceptable. See "BRACE EXPANSION" under "man zshexpn" for further
    # details on the brace operator "..".
    if (( abs((stop - start) / step) <= 10000 )) {
        # If such step is negative, the brace operator ".." requires positive
        # steps to behave as expected. Simply negating such step suffices.
        (( step < 0 && step = -step ))

        # Iterate such integers.
        eval "for ${integer_name} ({${start}..${stop}..${step}}) {
            ${command}
        }"
    # Else, such range is sufficiently large to require a just-in-time
    # alternative avoiding list construction: namely, for loop iteration.
    #
    # If such step is positive, iterate upwards.
    } elif (( step < 0 )) {
        eval "for ((
            ${integer_name}=${start};
            ${integer_name} <= ${stop};
            ${integer_name}+=${step} )) {
            ${command}
        }"
    # Else, such step is negative; iterate downwards.
    } else {
        eval "for ((
            ${integer_name}=${start};
            ${integer_name} >= ${stop};
            ${integer_name}+=${step} )) {
            ${command}
        }"
    }
}

# --------------------( WASTELANDS                         )--------------------
#   string start="${1}" end="${2}"
#   die_unless_integers "${start}" "${end}"

    # Get such integers.
#   output_string {${start}..${end}}

#   string start="${1}" stop="${2}" integer_name='INTEGER' command="${@[-1]}"
#   is_args_4 and key_name="${3}"
#   die_unless_integer_deceeds "${start}" "${stop}"
#   die_unless_string_nonempty "${integer_name}" 'expected nonempty integer name'
#   die_unless_string_nonempty "${command}" 'expected nonempty command'

    # If such range is sufficiently small, make and iterate an ordered list of
    # all integers in such range. Practical (if non-rigorous) experimentation
    # demonstrates that making lists an order of magnitude larger induces
    # discernable slowdown and lists at least two orders of magnitude larger
    # termination of the current shell. In either case, such unacceptable costs
    # must be explicitly avoided.
    #
    # See "BRACE EXPANSION" under "man zshexpn" for further details on the brace
    # operator "..".
#   if (( abs((stop - start) / step) <= 10000 )) {
#       eval "for ${integer_name} ({${start}..${stop}}) {
#           ${command}
#       }"
#   # Else, such range is sufficiently large to require a just-in-time
#   # alternative avoiding list construction: namely, for loop iteration.
#   } else {
#       #FUXME: This only works for *INCREASING* iteration.
#       eval "for ((
#           ${integer_name}=${start};
#           ${integer_name} <= ${stop};
#           ${integer_name}+=${step} )) {
#           ${command}
#       }"
#   }

    # Iterate such integers. See "BRACE EXPANSION" under "man zshexpn" for
    # further details on the brace operator "..".
#   eval "for ${integer_name} ({${start}..${stop}..${step}}) {
#       ${command}
#   }"

#FUXME: Rename to get_integers_in_range(). Actually, this isn't terribly
#helpful. This function is a poor idea for the same reason that the equivalent
#Python functions were poor ideas. We *REALLY* want an iterator, instead -- say,
#for_integers_in_range(). Note also that we'll want an additional function
#for_integers_in_range_with_step() accepting an additional third integer
#specifying how much to add to the initial integer each increment. How about
#for_integers_in_range_incremented() instead? Nah; I prefer "_with_step", as
#that explicitly specifies a sensible noun. Right. Now, note that
#for_integers_in_range() can simply call
#for_integers_in_range_with_step() with a step of "1". Note also that
#for_integers_in_range_with_step() should be implemented so as to accept the
#start larger than the end *ONLY* if passed a negative step. All around
#sweetness, no?
#FUXME: Poor names, now that I contemplate it. Rename to
#die_unless_integer_greater_than_or_equals() and likewise. Sweet name, no? Ah!
#Actually, there's better: exceeds. What's great is this permits us to employ my
#favorite foundling neologism, deceeds, as its antonym. So, go with:
#die_unless_integer_exceeds_or_equals()
