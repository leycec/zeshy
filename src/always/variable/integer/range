#!/usr/bin/env zsh
# ====================[ range                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle integer ranges.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void {die_unless_integer_at_least, die_unless_integer_exceeds_or_equals}(
    integer number, integer minimum,
    string error_message = "${number} less than ${minimum}")

Throw an exception with the passed message unless the first passed integer is
greater than or equal to the second passed integer.
________________<heredoc?>________________
function die_unless_integer_at_least die_unless_integer_exceeds_or_equals() {
    die_unless_args_2_to_3\
        'expected one integer, one integer minimum, and optional error message'
    string number="${1}" number_minimum="${2}"
    is_integer_at_least "${number}" "${number_minimum}" or
        die "${3:-${number} less than ${number_minimum}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void {die_unless_integer_at_most, die_unless_integer_deceeds_or_equals}(
    integer number, integer maximum,
    string error_message = "${number} greater than ${maximum}")

Throw an exception with the passed message unless the first passed integer is
less than or equal to the second passed integer.
________________<heredoc?>________________
function die_unless_integer_at_most die_unless_integer_deceeds_or_equals() {
    die_unless_args_2_to_3\
        'expected one integer, one integer minimum, and optional error message'
    string number="${1}" number_maximum="${2}"
    is_integer_at_most "${number}" "${number_maximum}" or
        die "${3:-${number} greater than ${number_maximum}}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_integer_in_range(
    integer number, integer minimum, integer maximum,
    string error_message = "${number} not in [${minimum}, ${maximum}]}")

Throw an exception with the passed message unless the passed string is an
integer in the passed range. See is_integer_in_range() for further details.
________________<heredoc?>________________

function die_unless_integer_in_range() {
    die_unless_args_3_to_4\
        'expected one integer, one integer minimum, one integer maximum, and optional error message'
    string number="${1}" number_minimum="${2}" number_maximum="${3}"
    is_integer_in_range "${number}" "${number_minimum}" "${number_maximum}" or
        die "${4:-${number} not in [${number_minimum}, ${number_maximum}]}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] {is_integer_at_least, is_integer_exceeds_or_equals}(
    integer number, integer minimum)

Return success if the first passed integer is greater than or equal to the
second passed integer.
________________<heredoc?>________________
function is_integer_at_least is_integer_exceeds_or_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected two integers'
    string left="${1}" right="${2}"
    die_unless_integers "${left}" "${right}"

    # Test such integer.
    (( left >= right ))
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] {is_integer_at_most, is_integer_deceeds_or_equals}(
    integer number, integer maximum)

Return success if the first passed integer is less than or equal to the second
passed integer.
________________<heredoc?>________________
function is_integer_at_most is_integer_deceeds_or_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected two integers'
    string left="${1}" right="${2}"
    die_unless_integers "${left}" "${right}"

    # Test such integer.
    (( left <= right ))
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_integer_in_range(
    integer number, integer minimum, integer maximum)

Return success if the passed integer is in the passed range (i.e., greater than
or equal to the passed minimum and less than or equal to the passed maximum):
e.g.,

.is_integer_in_range()
==========================================
[source]
------------------------------------------
>>> is_integer_in_range 1776 1694 1913 and print_string\
...    "If history shows anything, it is that there's no better way to justify
...     relations founded on violence, to make such relations seem moral, than
...     by reframing them in the language of debt — above all, because it
...     immediately makes it seem that it's the victim who's doing something
...     wrong."
If history shows anything, it is that there's no better way to justify
relations founded on violence, to make such relations seem moral, than
by reframing them in the language of debt — above all, because it
immediately makes it seem that it's the victim who's doing something
wrong.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_integer_in_range() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one integer, one integer minimum, and one integer maximum'
    string number="${1}" minimum="${2}" maximum="${3}"
    die_unless_integers "${number}" "${minimum}" "${maximum}"
    (( "${minimum}" <= "${maximum}" )) or
        die "minimum \"${minimum}\" greater than maximum \"${maximum}\""

    # Test such integer.
    (( minimum <= number && number <= maximum ))
}

# ....................{ GETTERS                            }....................
#FIXME: Excise, replacing wherever called with for_integers_in_range().
declare_function_with_stdin <<'________________<heredoc?>________________'
integer get_integers_between(integer start, integer end)

Get all integers in the passed inclusive range, delimited by whitespace: e.g.,

.get_integers_between()
==========================================
[source]
------------------------------------------
>>> get_integers_between 6 9
6 7 8 9
------------------------------------------
==========================================
________________<heredoc?>________________
function get_integers_between() {
    # Validate passed arguments.
    die_unless_args_2 'expected one start integer and one end integer'
    string start="${1}" end="${2}"
    die_unless_integers "${start}" die_unless_integer "${end}"

    # Get such integers.
    print_string {${start}..${end}}
}

# ....................{ ITERATORS                          }....................
#FIXME: Document! :)
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_integers_in_range(
    integer minimum,
    integer maximum,
    string integer_name = 'INTEGER',
    string command)

________________<heredoc?>________________
function for_integers_in_range() {
    # Validate passed arguments.
    die_unless_args_3_or_4\
        'expected one integer minimum, one integer maximum, optional integer name, and one command'
    string start="${1}" stop="${2}" integer_name='INTEGER' command="${@[-1]}"
    is_args_4 and key_name="${3}"
    die_unless_integer_deceeds "${start}" "${stop}"
    die_unless_string_nonempty "${integer_name}" 'expected nonempty integer name'
    die_unless_string_nonempty "${command}" 'expected nonempty command'

    # Iterate such integers. See "BRACE EXPANSION" under "man zshexpn" for
    # further details on the brace operator "..".
    eval "for ${integer_name} ({${start}..${stop}}) {
        ${command}
    }"
}

#FIXME: Document! :)
declare_function_with_stdin <<'________________<heredoc?>________________'
string for_integers_in_range_with_step(
    integer start,
    integer stop,
    integer step,
    string integer_name = 'INTEGER',
    string command)

________________<heredoc?>________________
function for_integers_in_range_with_step() {
    # Validate passed arguments.
    die_unless_args_4_or_5\
        'expected one integer start, one integer stop, one integer step, optional integer name, and one command'
    string\
        start="${1}"\
        stop="${2}"\
        step="${3}"\
        integer_name='INTEGER'\
        command="${@[-1]}"
    is_args_5 and key_name="${4}"
    die_unless_integers "${start}" "${stop}" "${step}"
    die_unless_string_nonempty "${integer_name}" 'expected nonempty integer name'
    die_unless_string_nonempty "${command}" 'expected nonempty command'

    # If such step is positive, ensure such start is less than such stop.
    if (( step > 0 )) {
        die_unless_integer_deceeds "${start}" "${stop}"
    # If such step is negative, ensure such start is greater than such stop.
    # Additionally, the brace operator ".." requires positive steps to behave as
    # expected, simply negate such step.
    } elif (( step < 0 )) {
        die_unless_integer_exceeds "${start}" "${stop}"
        (( step = -step ))
    # Else, such step is zero. To avoid infinite loops, throw an exception.
    } else {
        die 'expected nonzero step'
    }

    # Iterate such integers. See "BRACE EXPANSION" under "man zshexpn" for
    # further details on the brace operator "..".
    eval "for ${integer_name} ({${start}..${stop}..${step}}) {
        ${command}
    }"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to get_integers_in_range(). Actually, this isn't terribly
#helpful. This function is a poor idea for the same reason that the equivalent
#Python functions were poor ideas. We *REALLY* want an iterator, instead -- say,
#for_integers_in_range(). Note also that we'll want an additional function
#for_integers_in_range_with_step() accepting an additional third integer
#specifying how much to add to the initial integer each increment. How about
#for_integers_in_range_incremented() instead? Nah; I prefer "_with_step", as
#that explicitly specifies a sensible noun. Right. Now, note that
#for_integers_in_range() can simply call
#for_integers_in_range_with_step() with a step of "1". Note also that
#for_integers_in_range_with_step() should be implemented so as to accept the
#start larger than the end *ONLY* if passed a negative step. All around
#sweetness, no?
#FUXME: Poor names, now that I contemplate it. Rename to
#die_unless_integer_greater_than_or_equals() and likewise. Sweet name, no? Ah!
#Actually, there's better: exceeds. What's great is this permits us to employ my
#favorite foundling neologism, deceeds, as its antonym. So, go with:
#die_unless_integer_exceeds_or_equals()
