#!/usr/bin/env zsh
# ====================[ hexadecimal                        ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle hexadecimal strings (i.e., base 16 integers signifying values 10
# through 15 as characters 'A' through 'F').

# ....................{ EXCEPTIONS                         }....................
#FIXME: Define new type aliases resembling:
#
#    alias decimal="integer_in_base 10"
#    alias hexadecimal="integer_in_base 16"
#
#While redundant, the former improves orthogonality: namely, there's a
#convert_hexadecimal_to_decimal() function and a hexadecimal "type" but no
#decimal "type". Fix that.
declare_function '
void die_unless_hexadecimal(
  string value,
  string error_message = "\"${value}\" not a hexadecimal string")

Throw an exception with the passed message unless the passed string is an
integer in base 16 hexidecimal format. See is_hexadecimal() for further details.
'
function die_unless_hexadecimal() {
    die_unless_args_1_to_2\
        'expected one string and optional error message'
    string value="${1}"
    is_hexadecimal "${value}" or
        die "${2:-\"${value}\" not a hexadecimal string}"
}

# ....................{ TESTERS                            }....................
declare_function '
boolean is_hexadecimal(string value)

Return true if the passed string is an integer in base 16 hexadecimal format,
prefixed by either "0x" or "16#" (e.g., "0xFEEDBEEF", "16#DEADFACE"): e.g.,

    >>> is_hexadecimal "0xBADF00D" and print_string\
    ...     "They are his Court, and in his name they defraud and govern."
    They are his Court, and in his name they defraud and govern.
'
function is_hexadecimal() {
    die_unless_arg 'expected one string'
    is_string_match "${1}" '(0x|16\#)[[:xdigit:]]##'
}

# ....................{ CONVERTERS ~ decimal               }....................
declare_function '
string convert_decimal_to_hexadecimal(string value)

Convert the passed base 10 string integer to hexadecimal format: e.g.,

    >>> convert_decimal_to_hexadecimal 3405691582
    0xCAFEBABE
'
function convert_decimal_to_hexadecimal() {
    # Validate passed arguments.
    die_unless_arg 'expected one integer'
    string decimal="${1}"
    die_unless_integer "${decimal}"

    # Convert such decimal.
    print_string $(( [#16] ${decimal} ))
}

declare_function '
string convert_hexadecimal_to_decimal(string hexadecimal)

Convert the passed base 16 integer in hexadecimal format to base 10: e.g.,

    >>> convert_hexadecimal_to_decimal 0xBADF00D
    195948557
'
function convert_hexadecimal_to_decimal() {
    # Validate passed arguments.
    die_unless_arg 'expected one hexadecimal string'
    string hexadecimal="${1}"
    die_unless_hexadecimal "${hexadecimal}"

    # Convert such hexadecimal.
    print_string $(( [#10] ${hexadecimal} ))
}

# --------------------( WASTELANDS                         )--------------------
#   is_string_match "${1}" '(0x|[[:digit:]]##\#)[[:xdigit:]]##'
# Temporarily enable shell option "c_bases" to ensure
    # such output is prefixed with "0x".
#    enable_shell_option_locally c_bases
#    integer_in_base 16 hexadecimal="${decimal}"
#    print_string "${hexadecimal}"

    # Convert such hexadecimal. Unlike convert_decimal_to_hexadecimal(), builtin
    # print() does not require shell option "c_bases" to do so.
#   integer_in_base 10 decimal="${hexadecimal}"
#   print_string $(( [#10] ${hexadecimal} ))

#FUXME: Ambiguous, as integers may be in any base. Rename to
#convert_decimal_to_hexadecimal().
#FUXME: Rename to die_unless_hexadecimal(), adopting the same nomenclature as
#booleans as characters.
#string base 16 string hexadecimal to integer format:
