#!/usr/bin/env zsh
# ====================[ split                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Convert scalar strings to non-scalar lists.

#FIXME: Shift set_list_to_string_lines() here, wherever it's shuffled off to...

# ....................{ SETTERS                            }....................
document_function '
string set_list_to_string_split_on_delimiter(
  string list_name, string text, string delimiter)

Split the passed string on the passed delimiter into the passed list. Such
delimiter may be of any length including 0: e.g.,

    >>> list array
    >>> set_list_to_string_split_on_delimiter array "obseqious/deep/join" "/"
    >>> print_string "${array[1]}"
    obseqious
'
function set_list_to_string_split_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_3\
        'expected one list name, one string, and one delimiter'
    string\
        list_name__sltssod="${1}"\
        string__sltssod="${2}"\
        delimiter__sltssod="${3}"\
        split_token__sltssod
    die_unless_list "${list_name__sltssod}"

    # If such delimiter contains no caret, efficiently default the split token
    # to a caret. Since caret is usually the least common punctuation character,
    # this condition is more likely to succeed than conditions on more common
    # punctuation characters and hence is optimized for the common case.
    if is "${delimiter__sltssod}" != *'^'* si
    then split_token__sltssod='^'
    #FIXME: This *GREAT* algorithm should be generalized into an external function.
    #It's insanely useful elsewhere, as I recently discovered in repeat_string().
    #See such function for documentation on doing so.
    #FIXME: For efficiency, globalize ${split_tokens__sltssod} into a global list.
    # Else, such delimiter contains a caret. To efficiently find the first
    # possible split token not already contained in such delimiter:
    #
    # * Define a list containing each possible split token as a list element.
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference the latter from the former list into a third list, thus
    #   containing each possible split token *NOT* a unique character of such
    #   delimiter.
    # * Arbitrarily select the first element of this third list as the split
    #   token. (Any element would do, but the first is... first!)
    #
    # This is considerably more efficient than iterative searching for the first
    # non-contained split token. In any case, this condition should rarely (if
    # ever) trigger.
    else
        # List of all possible split tokens, excluding caret (which such string
        # has already been shown to contain).
        list split_tokens__sltssod; split_tokens__sltssod=(
            ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '-' '&' '*'
            '-' '_' '\' '|' '/' '?'
        )

        # List set of all unique delimiter characters. Only this list need be a
        # list set (i.e., no other lists need be list sets).
        list_set delimiter_chars__sltssod
        set_list_to_string_split_on_characters\
            delimiter_chars__sltssod "${delimiter__sltssod}"

        # Difference the latter from the former into a third list.
        list split_tokens_available__sltssod
        set_list_to_list_difference\
            split_tokens_available__sltssod\
            split_tokens__sltssod\
            delimiter_chars__sltssod

        # If no split token is available (i.e., the passed delimiter contains
        # all possible split tokens, an insane feat worthy of jeering applause),
        # throw an exception.
        die_unless_list_nonempty split_tokens_available__sltssod\
            "delimiter \"${delimiter__sltssod}\" contains all possible punctuation and hence split tokens"

        # Arbitrarily select the first available split token.
        split_token__sltssod="${split_tokens_available__sltssod[1]}"
    fi

    # Split such list.
    set_list_to_evaluation "${list_name__sltssod}"\
        "\${(s${split_token__sltssod}${delimiter__sltssod}${split_token__sltssod})string__sltssod}"
}

#FIXME: Rename to set_list_to_string_characters().
document_function '
string set_list_to_string_split_on_characters(string list_name, string text)

Split the passed string on characters into the passed list. zsh already supports
character indexing and slicing out of the box, so this function is useful only
where explicitly requiring list types: e.g.,

    >>> list hill
    >>> set_list_to_string_split_on_characters hill "though I sang in my chains"
    >>> print_string "${fern_hill[21,26]}"
    chains
    >>> join_list hill
    though I sang in my chains
'
function set_list_to_string_split_on_characters() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssoc="${1}" text__sltssoc="${2}"
    die_unless_list "${list_name__sltssoc}"

    # Split with a 0-width delimiter.
    set_list_to_evaluation "${list_name__sltssoc}" '${(s::)text__sltssoc}'
}

# ....................{ SETTERS ~ word                     }....................
#FIXME: Rename to set_list_to_standard_input_words().
document_function '
void set_list_to_standard_input_split_on_words(string list_name)

Split standard input on shell words into the passed list.

    >>> list fern
    >>> set_list_to_standard_input_split_on_words fern <<< "about the lilting"
    >>> print_string ${fern[2]}
    the
'
function set_list_to_standard_input_split_on_words() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltsisow="${1}"
    die_unless_list "${list_name__sltsisow}"
    die_if_standard_input_empty

    # Set such list and close standard input.
    set_list_to_evaluation "${list_name__sltsisow}" '${(z)"$(< /dev/stdin)"}'
    close_standard_input
}

#FIXME: Rename to set_list_to_string_words().
document_function '
string set_list_to_string_split_on_words(string list_name, string text)

Split the passed string on words into the passed list. Since zsh supports word
indexing and slicing out of the box, this function is useful only where a list
is explicitly required: e.g.,

    >>> list thomas
    >>> set_list_to_string_split_on_words thomas "time held me green and dying"
    >>> print_string ${thomas[24,28]}
    dying
    >>> join_list_on_delimiter thomas " "
    time held me green and dying
'
function set_list_to_string_split_on_words() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one string'
    string list_name__sltssow="${1}" text__sltssow="${2}"
    die_unless_list "${list_name__sltssow}"

    # Split with parameter expansion flag "(z)".
    set_list_to_evaluation "${list_name__sltssow}" '${(z)text__sltssow}'
}

# ....................{ SETTERS ~ string                   }....................
document_function '
void set_strings_to_string_split_on_delimiter(
  string string_name1, string string_name2, string text, string delimiter)

Split the substring of the passed string preceding the first instance of the
passed delimiter into the first passed list and the remainder (excluding the
passed delimiter) into the second passed list. Such delimiter may be of any non-
zero length. If such string contains no such delimiter, throw an exception:
e.g.,

    >>> string pre suf
    >>> set_strings_to_string_split_on_delimiter pre suf "wol==hea==soc" "=="
    >>> print "prefix: ${pre}\nsuffix: ${suf}"
    prefix: wol
    suffix: hea==soc
'
function set_strings_to_string_split_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_4\
        'expected one prefix name, one suffix name, one string, and one delimiter'
    string\
        prefix_name__sstspod="${1}"\
        suffix_name__sstspod="${2}"\
        text__sstspd="${3}"\
        delimiter__sstspd="${4}"
    die_unless_variable_string "${prefix_name__sstspd}"
    die_unless_variable_string "${suffix_name__sstspd}"
    die_unless_string_nonempty "${delimiter__sstspd}" 'no delimiter passed'

    # If such string contains no such delimiter, throw an exception.
    is_string_contains "${text__sstspd}" "${delimiter__sstspd}" or
        die "delimiter \"${delimiter__sstspd}\" not found in \"${text__sstspd}\""

    #FIXME: Conjoin into a single "//"-style match enabling "(#b)" to capture
    #the two groups, then set such strings with such groups. This also helps to
    #rid us of the unwieldy test above, assuming we detect such match failing
    #with non-zero exit status.
    #FIXME: Just use single "#" with "(#b)". See set_list_to_string_piped<>.
    # Split such string.
    set_string_to_string "${prefix_name__sstspd}" "${text__sstspd%%${delimiter__sstspd}*}"
    set_string_to_string "${suffix_name__sstspd}" "${text__sstspd#*${delimiter__sstspd}}"
}

# --------------------( WASTELANDS                         )--------------------
    # If the passed delimiter is a colon, delimit such delimiter by periods.
#   split_token__sltssod=''
#   if is_string_contains "${delimiter__sltssod}" ':'; then
#       set_list_to_evaluation "${list_name__sltssod}" '${(s.:.)text__sltssod}'
    # Otherwise, delimit such delimiter by colons.
#   else
#       set_list_to_evaluation "${list_name__sltssod}"\
#           "\${(s:${delimiter__sltssod}:)text__sltssod}"
#   fi
#   die_unless_character delimiter__sltssod
#FUXME: Generalize to strings longer than one character. Surely this is feasible
#with an iterative PCRE, no?
# string set_list_to_string_split_on_words(string list_name, string text)
#
# Split the passed string on words into the passed list. Since zsh supports list-
# style character indexing and slicing out of the box, this function is useful
# only where explicit list types are required: e.g.,
#
#     >>> list words
#     >>> set_list_to_string_split_on_words words 'Time held me green and dying'
#     >>> print_string ${words[1]} ${words[4]} ${words[5]}
#     Time green dying
#function set_list_to_string_split_on_words() {
    # Validate passed arguments.
#    die_unless_args_2 'expected one list name and one string'
#    string list_name="${1}" __text__="${2}"
#    die_unless_list "${list_name}"

    # Split with parameter expansion flag "(z)".
#    set_list_to_evaluation "${list_name}" '${(z)__text__}'
#}
