#!/usr/bin/env zsh
# ====================[ join                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Convert non-scalar lists to scalar strings.

# ....................{ JOINERS                            }....................
#FIXME: Rename to join_list(), the most basic form of joining.
document_function '
string join_list_undelimited(string list_name)

Join the list with the passed name into a string with each list element
undelimited (i.e., delimited by the empty string): e.g.,

    >>> list herbert; herbert=( "songs" "of a" "sentient flute" )
    >>> join_list_undelimited herbert
    songsof asentient flute
'
function join_list_undelimited() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__jl="${1}"
    die_unless_list "${list_name__jl}"

    # See print_string_undelimited() for further details.
    string IFS=
    print_string "${(P)list_name__jl}"
}

# ....................{ JOINERS ~ delimiter                }....................
#FIXME: Rename to join_list_with_delimiter(). Preposition "on" is specific to
#splitting.
document_function '
string join_list_on_delimiter(string list_name, string delimiter)

Get a string suffixing each element except the last of the passed list with
the passed delimiter. The delimiter may be of any length: e.g.,

    >>> list heinlein; heinlein=( "the moon" "is" "a" "harsh mistress" )
    >>> join_list_on_delimiter heinlein ", "
    the moon, is, a, harsh mistress
'
function join_list_on_delimiter() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one delimiter'
    string list_name__jlwd="${1}" delimiter__jlwd="${2}"
    die_unless_list "${list_name__jlwd}"

    # If the passed delimiter is a colon, delimit such delimiter by periods.
    # Delimited, this is:
    #
    # * "j.:.", joining on colons.
    # * "@P", expanding to the list with the passed name.
    if is "${delimiter__jlwd}" == ':' si
    then print_string "${(j.:.@P)list_name__jlwd}"
    # Otherwise, delimit such delimiter by colons. Since zsh appears to
    # expand no parameters embedded in parameter expansion flags (e.g.,
    # "print ${(j:${delimiter}:)@}", joining list elements with the raw string
    # "${delimiter}" rather than the expansion of such parameter), wrap the
    # desired expression in an "eval" to force such expansion.
    else eval "print_string \"\${(j:${delimiter__jlwd}:)${list_name__jlwd}}\""
    fi
}

#FIXME: Rename to join_list_with_newline().
document_function '
string join_list_on_newline(string list_name)

Get a string suffixing each element except the last of the passed list with
a newline character: e.g.,

    >>> list banks; banks=( use of weapons )
    >>> join_list_on_newline banks
    use
    of
    weapons
'
function join_list_on_newline() {
    die_unless_arg 'expected one list name'
    join_list_on_delimiter "${@}" "${ZESHY_CHARACTER_NEWLINE}"
}

# ....................{ JOINERS ~ delimiters               }....................
document_function '
string join_list_conjunctively(string text1, string text2, ...)

Join the passed strings into a string conjunctively delimiting such strings
(i.e., with the logical conjunction "and"). Specifically:

* Double quote all passed strings.
* Prefix all passed strings except the first and last with ", ".
* Prefix the last passed string with ", and ".
* Truncat the returned string to a sensible maximum (currently, 75% of the
  current terminal width).

Unlike most Zeshy functions operating on lists, this function excepts accepts
list elements as positional arguments rather than as a variable name due to
caller requirements: e.g.,

    >>> join_list_conjunctively "I mrethil" "peliar" "duiw laiss"
    "I mrethil", "peliar", and "duiw laiss"
'
function join_list_conjunctively() {
    # Validate and join the passed arguments. Dismantled, this is:
    #
    # * "\"${^@}\"", double quoting each passed string.
    die_unless_args 'expected at least one string'
    list args; args=( "\"${^@}\"" )
    string text
    text="$(join_list_on_delimiters args ', ' ', and ' ' and ' )"

    #FIXME: Close, but not quite right. Ideally, we want to preserve human-
    #readable print_string when truncating. Humans expect print_string resembling:
    #     "I mrethil", "p...", ...
    #Rather than:
    #     "I mrethil", "peliar"...
    #Not terribly easy or readibly internationalizable, so I suppose I'm content
    #with this as is. For now...

    # Truncate the joined string to 75% of the current terminal's width, rounded
    # down to the nearest integer.
    integer max_length=80
    is_standard_output_terminal and max_length=$(( 0.75 * $(get_terminal_width) ))
    truncate_string "${text}" "${max_length}" '...'
}

#FIXME: Rename to join_list_with_delimiters().
document_function '
string join_list_on_delimiters(
  string list_name, string nonlast_delimiter,
  string last_delimiter_if_three_or_more_elements,
  string last_delimiter_if_two_elements = "${last_delimiter_if_three_or_more_elements}")

Join the list with the passed name into a string with each list element
excluding the last delimited by the first passed delimiter and the last list
element delimited by the second passed delimiter. Delimiters may be of any
length: e.g.,

    >>> list pat_the_bunny
    >>> pat_the_bunny=( "the" "wingnut" "dishwashers" "union" )
    >>> join_list_on_last_delimiter pat_the_bunny "+" "?"
    the+wingnut+dishwashers?union
'
function join_list_on_delimiters() {
    # Validate passed arguments.
    die_unless_args_3_to_4\
        'expected one list name, one non-last delimiter, one last delimiter if three or more list elements, and optional last delimiter if two list elements'
    string\
        list_name__jlwd="${1}" nonlast_delimiter__jlwd="${2}"\
        last_delimiter_if_three_or_more__jlwd="${3}" last_delimiter_if_two__jlwd
    last_delimiter_if_two__jlwd="${4:-${last_delimiter_if_three_or_more__jlwd}}"
    die_unless_list "${list_name__jlwd}"
    integer list_size__jlwd; list_size__jlwd="$(get_list_size "${list_name__jlwd}")"

    # Join the passed list depending on the size of such list.
    if (( list_size__jlwd >= 3 )); then
        # Join all list elements excluding the last into a string. Note: DO NOT
        # DOUBLE-QUOTE SUCH LIST WHEN SETTING ${__list_sans_last_element__}, as
        # that aggregates such list elements into a single string. *shakes fist*
        list list_sans_last_element__jlwd
        string list_sans_last_element_string__jlwd
        list_sans_last_element__jlwd=( ${${(@P)list_name__jlwd}[1,-2]} )
#       print_message "lsle[@]: $__list_sans_last_element__[1]; $__list_sans_last_element__[2]"
        list_sans_last_element_string__="$(join_list_on_delimiter\
            list_sans_last_element__jlwd "${nonlast_delimiter__jlwd}")"

        # Join the last list element into such list.
        print_string "${list_sans_last_element_string__jlwd}${last_delimiter_if_three_or_more__jlwd}${${(@P)list_name__jlwd}[-1]}"
#       print_string "${list_sans_last_element_string__}"
    elif (( list_size__jlwd == 2 ))
    then print_string "${${(@P)list_name__jlwd}[1]}${last_delimiter_if_two__jlwd}${${(@P)list_name__jlwd}[2]}"
    else print_string "${${(@P)list_name__jlwd}[1]}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: How about join_list_on_delimiter(), instead?
#FUXME: Rename "list_elements" to "list_entries" everywhere. The latter gives
#more Google hits and is more concise. Double win! Actually, perhaps get_*()-
#style names wouldn't be more appropriate? Consider:
# string get_list_entries_joined_undelimited
#Ah, no; much too much of a mouthful. Good as is.
#FUXME: Actually, just drop the "_elements" everywhere. Excessive; unneeded. And
#reduce "with" to "on". That gives us final functions resembling:
#   join_list_on_delimiter()

#FUXME: We should probably just centralize split and join functions into a new
#component: say, "type/variable/list_and_string".
# See "string/string" for corresponding split_*() functions.

#FUXME: Rename to get_list_as_restorable_string() or
#get_restorable_string_from_list(). Perhaps 
# ....................{ JOINERS ~ lines                    }....................
#FUXME: Trivial. Delete?
# string join_list_to_lines(string list_name)
#
# Join the list with the passed name into a newline-delimited string: e.g.,
#
#     >>> list grok; grok=( "Stranger in" "a" "Strange Land" )
#     >>> join_list_to_lines grok
#     Stranger in
#     a
#     Strange Land
#function join_list_to_lines() {
#   die_unless_arg 'expected one list name'
#   join_list_on_delimiter "${1}" '\n'
#

#FUXME: The "_to_string" is redundant and renders function names cumbersome and
#unreadable. Replace with "_elements", which *isn't* redundant (e.g., renaming
#join_list_undelimited() to
#join_list_undelimited()).
#           "${(@P)__list_sans_last_element__}"\

#FUXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
#}

#FUXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_args_at_least_3; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_delimitermunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_args_2
#   then print_string "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else print_string "${1}"
#   fi

#FUXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the passed arguments.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_DOT_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FUXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps print_restorable_list()? AH! Got it: convert_list_to_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FUXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_args_2_or_more\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    behead_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_variable List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
