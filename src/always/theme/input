#!/usr/bin/env zsh
# ====================[ input                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Input, theming interactive user input.

# ....................{ NULL                               }....................
# void ask_any_key(string prompt = "press any key to continue.\n")
#
# Ask the current user to type a single character. This function blocks until
# the user does so and then returns true.
ask_any_key() {
    # Print the passed prompt.
    die_unless_at_most_one_arg 'expected optional prompt'
    utter_no_newline "${1:-press any key to continue.\n}"

    # Block on user input.
    string  answer
    read -k answer

    # Unless the user input a newline, print a trailing newline.
    is "${answer}" == '\n' si or sputter_blank_line
}

# ....................{ BOOLEANS                           }....................
# bool ask_yes_or_no(string question)
#
# Ask the current user a yes or no question suffixed by "[yn]", returning false
# unless the user responds with either "Y" or "y".
ask_yes_or_no() {
    die_unless_one_arg 'expected one question'
    utter_no_newline "${1} [yn] "
    string  answer
    read -q answer
}

# bool ask_yes_or_no_harder(string question)
#
# Ask the current user a yes or no question suffixed by "[YES/no]", returning
# false unless the user responds with exactly "YES". This stringent alternative
# to ask_yes_or_no() is intended for questions whose affirmation carries
# potentially harmful consequences (e.g., data loss).
ask_yes_or_no_harder() {
    die_unless_one_arg 'expected one question'
    utter_no_newline "${1} [YES/no] "
    string answer
    read   answer
    is "${answer}" == 'YES' si
}

# --------------------( WASTELANDS                         )--------------------
# char *ask_yes_or_no(char *question, char *choices = 'yn', char *true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#ask_yes_or_no() {
#    die_unless_at_least_one_arg 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    mutter "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one
#    read   answer
#    is "${answer}" == "${true_answer}" si
#}
