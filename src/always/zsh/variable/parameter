#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle `zsh` parameter expansion.
-/-

# ....................{ GLOBALS                            }....................
declare_global_with_stdin <<'/---'
string ZESHY_IFS_DEFAULT

Default internal field separator (IFS), splitting fields on longest contiguous
substrings of *whitespace* (i.e., space, tab, newline, and null characters). By
POSIX dictate, setting string global ${IFS} to this default is equivalent to
unsetting such global.
/---
ZESHY_IFS_DEFAULT=$' \t\n\0'

declare_global_with_stdin <<'/---'
list_set ZESHY_PARAMETER_EXPANSION_TOKENS

List of all possible parameter expansion tokens. See
get_string_parameter_expansion_token_if_found() for further details.
/---
ZESHY_PARAMETER_EXPANSION_TOKENS=(
    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '^' '&' '*'
    '-' '_' '\' '|' '/' '?'
)

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_string_parameter_expansion_token(string text1, string text2, ...)

Get an arbitrary parameter expansion token specific to the passed string or
throw an exception if no such token exists (i.e., if such string contains all
possible tokens). See get_string_parameter_expansion_token_if_found() for
further details: e.g.,

.get_string_parameter_expansion_token()
==========================================
[source]
------------------------------------------
>>> string token on_knowledge="
...     Once upon a time, in some out of the way corner of that universe which
...     is dispersed into numberless twinkling solar systems, there was a star
...     upon which clever beasts invented knowing. That was the most arrogant
...     and mendacious minute of \"world history,\" but nevertheless, it was
...     only a minute. ,:.;~\`'\"=+@#\$%^&*-_\\|/"
>>> token="$(get_string_parameter_expansion_token_if_found "${on_knowledge}")"
>>> print_string "${token}"
?
>>> list  on_truth_and_lie
>>> eval "on_truth_and_lie=( \${(s${token},${token})on_knowledge} )"
>>> print_string "${on_truth_and_lie[1]}\n${on_truth_and_lie[-2]}"
Once upon a time
it was only a minute.
------------------------------------------
==========================================
/---
function get_string_parameter_expansion_token() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string text="${*}"

    # Get such token or throw an exception if no such token exists.
    get_string_parameter_expansion_token_if_found "${@}" or
        die "\"$(truncate_string_for_message "${text}")\" contains all possible parameter expansion tokens"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_string_parameter_expansion_token_if_found(
    string text1, string text2, ...)

Get an arbitrary parameter expansion token specific to the passed string or
return failure if no such token exists (i.e., if such string contains all
possible tokens). Such tokens are punctuation characters with which `zsh`
delimits parameter expansion flag arguments (e.g., the `;` in
`${(j:canticle:)leibowitz}`). Assuming such string does _not_ contain all
possible tokens, this function efficiently finds an arbitrary such token for
subsequent interpolation in an `eval` statement: e.g.,

.get_string_parameter_expansion_token_if_found()
==========================================
[source]
------------------------------------------
>>> string token on_knowledge="
...     We believe that we know something about the things themselves when we
...     speak of trees, colors, snow, and flowers; and yet we possess nothing
...     but metaphors for things â€” metaphors which correspond in no way to the
...     original entities. ,:.;~\`'\"=+@#\$%^&*-_\\|/?"
>>> get_string_parameter_expansion_token_if_found "${on_knowledge}")" or
...     print_string "Every concept arises from the equation of unequal things."
Every concept arises from the equation of unequal things.
------------------------------------------
==========================================

See ${ZESHY_PARAMETER_EXPANSION_TOKENS} for all such tokens.
/---
function get_string_parameter_expansion_token_if_found() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string text="${*}"

    # Since the caret is arguably the least common such token, explicitly test
    # for the absence of such token in such string prior to algorithmically
    # finding another possible token. For efficiency, inline such test.
    is "${text}" != *'^'* si and return_string '^'

    # To efficiently find the first such token not already in such string:
    #
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference ${ZESHY_PARAMETER_EXPANSION_TOKENS}, a list set containing
    #   each possible such token as a list element, from the prior list set into
    #   a third list set, containing each possible token not in such string.
    # * Arbitrarily return the first element of such set.
    #
    # Such algorithm is considerably more efficient than iteratively finding
    # such token. In any case, the prior optimization *SHOULD* catch most cases.

    # List set of all unique characters in the passed string.
    list_set text_chars; set_list_to_string_characters text_chars "${text}"

    # Difference such set from ${ZESHY_PARAMETER_EXPANSION_TOKENS}.
    list tokens_free; set_list_to_list_difference\
         tokens_free ZESHY_PARAMETER_EXPANSION_TOKENS text_chars

    # If such string does *NOT* contain at least one such token, arbitrarily
    # return the first such token.
    if { is_list_nonempty tokens_free } {
        return_string "${tokens_free[1]}"
    # Else, such string contains all possible tokens, an insane feat worthy of
    # jeering applause. Fail instead.
    } else {
        return_false
    }
}

# --------------------( WASTELANDS                         )--------------------
#>>> string dea="drug:employment:agency:,.;~\`'\"=+@#\$%^&*-_\\|/" token
#>>> token="$(get_string_parameter_expansion_token_if_found "${dea}")"
#>>> print_string "parameter expansion token: ${token}"
#parameter expansion token: ?
#
## Split such string on such token.
#>>> list  volstead_act
#>>> eval "volstead_act=( \${(s${token}:${token})dea} )"
#>>> print_string ${volstead_act[1]} ${volstead_act[2]} ${volstead_act[3]}
#drug employment agency

#...     The surest way to corrupt a youth is to instruct him to hold in higher
#...     esteem those who think alike than those who think differently.
#>>> get_string_parameter_expansion_token "${on_youth_instruction}"
#?
#declare_global_with_stdin <<'/---'
#string ZESHY_IFS_PRIOR
#
#Prior value of ${IFS}, the internal field separator. store_ifs() sets such
#global and restore_ifs() sets ${IFS} to such global. See such functions for
#further details.
#/---

# ....................{ STORERS                            }....................
#FUXME: God, but the time expended on such functions! Utter ridiculousness.
#declare_function_with_stdin <<'/---'
#void store_string(string global_name, string new_value)
#
#Store the current value of the passed string global to
#${ZESHY_IFS_PRIOR} and set ${IFS} to the passed value. Call restore_ifs() to
#restore ${IFS} to ${ZESHY_IFS_PRIOR}, its prior value. See entry ``IFS'' of
#`man zshparam` for further details on the format for such values: e.g.,
#
#[[store_ifs.example]]
#.store_ifs()
#==========================================
#[source]
#------------------------------------------
## Safely split a string on colons. Note this may also be achieved by running
## "set_list_to_string_split_on_string drug_warrior_propaganda ':'".
#>>> store_ifs ':'
#>>> {
#...     list drug_warrior_propaganda
#...     read -r -d '' -A drug_warrior_propaganda <<<\
#...         "Schedule 1: no currently accepted medical use in the United States"
#... } always {
#...     restore_ifs
#... }
#>>> print_string "${drug_warrior_propaganda[1]}"
#Schedule 1
#------------------------------------------
#==========================================
#
#== Alternatives ==
#
#There exist two safe, efficient, and convenient alternatives to calling this and
#restore_ifs(). While less explicitly readable than these functions, such
#alternatives require less effort.
#
#=== Command-prefixed ${IFS} Assignment ===
#
#When confining the assignment of ${IFS} to a single command as in the
#<<store_ifs.example,prior example>>, prefixing such command with such
#assignment provides a shorthand alternative: e.g.,
#
#.store_ifs() vs. Command-prefixed ${IFS} Assignment
#==========================================
#[source]
#------------------------------------------
#>>> list doors_of_perception
#>>> IFS=';' read -r -d '' -A doors_of_perception <<<\
#...     "The martyrs go hand in hand into the arena; they are crucified alone."
#>>> print_string "${doors_of_perception[1]}"
#The martyrs go hand in hand into the arena
#------------------------------------------
#==========================================
#
#=== Block-localized ${IFS} Assignment ===
#
#Assigning ${IFS} localized to the current block extends such assignment to all
#commands subsequently run in such block, providing a similar alternative: e.g.,
#
#.store_ifs() vs. Block-localized ${IFS} Assignment
#==========================================
#[source]
#------------------------------------------
#>>> list heaven_and_hell
#>>> {
#...     string IFS='-'
#...     read -r -d '' -A heaven_and_hell <<<
#...         "Anything rather than the burning brightness of unmitigated Reality
#...          - anything!"
#... }
#>>> print_string "${heaven_and_hell[1]}"
#Anything rather than the burning brightness of unmitigated Reality
#
#------------------------------------------
#==========================================
#/---
#function store_ifs() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one ${IFS}-formatted string'
#    string ifs_new="${1}"
#
#    # Store such separator.
#    ZESHY_IFS_PRIOR="${IFS}"
#    IFS="${ifs_new}"
#}
#
#declare_function_with_stdin <<'/---'
#void restore_ifs(void)
#
#Restore ${IFS}, the internal field separator, to the value previously stored by
#store_ifs() to ${ZESHY_IFS_PRIOR}. See such function for further details.
#/---
#function restore_ifs() {
#    # Validate sanity.
#    die_if_args
#    die_unless_string_nonempty "${ZESHY_IFS_PRIOR}"\
#        'expected non-empty "${ZESHY_IFS_PRIOR}" (did you forget to call store_ifs()?)'
#
#    # Restore such separator, resetting such global to the empty string to
#    # ensure an exception on attempting to call restore_ifs() without
#    # immediately previously calling store_ifs().
#    IFS="${ZESHY_IFS_PRIOR}"
#    ZESHY_IFS_PRIOR=
#}

#...         "Shrovetides, May Days, Carnivals - these permitted a direct
#...          experience of the animal otherness underlying personal and social
#...          identity."
#declare_function_with_stdin <<'/---'
#string get_string_parameter_expansion_delimiter_if_found(
#    string text1, string text2, ...)
#
#Get an arbitrary zsh parameter expansion delimiter character _not_ in the passed
#strings or return false if no such character exists (i.e., such strings contain
#all possible delimiter characters, effectively all printable ASCII characters
#and hence unlikely for most cases). Several parameter expansion flags require
#one or more arguments delimited by some arbitrary character _not_ in such
#arguments (e.g., "${(j:Canticle:)Leibowitz}"). This function efficiently finds
#such a character, if available, for subsequent use in an "eval" statement: e.g.,
#
#.get_string_parameter_expansion_delimiter_if_found()
#==========================================
#[source]
#------------------------------------------
## Split such string on commas. Of course, this is more simply implemented as
## "fiat_homo_split=( ${(s:,:)fiat_homo} )". If, however, the delimiter to
## split such string on is unknown at implementation time, this simpler
## implementation fails if a colon delimiter is preferred. This longer
## implementation succeeds regardless of delimiter choice.
#>>> string fiat_homo="From the fall of the cesium, O Lord, deliver us."
#>>> string split_on=","
#>>> character flag_delim="$(\
#...     get_string_parameter_expansion_delimiter_if_found "${split_on}")"
#>>> list  split
#>>> eval "split=( ${(s${flag_delim}${split_on}${flag_delim})fiat_homo} )"
#>>> print_string "${split[1]}"
#From the fall of the cesium
#------------------------------------------
#==========================================
#/---
#function get_string_parameter_expansion_delimiter_if_found() {
#    # Validate passed parameters.
#    die_unless_args 'expected at least one string'
#    string text="${*}"
#
#    # List set of all unique characters in such string.
#    list_set text_characters
#    set_list_to_string_characters text_characters "${text}"
#
#    # List of all available delimiters (i.e., all possible delimiters *NOT* in
#    # such string), efficiently constructed by differencing the list of all
#    # possible delimiters from the list set of all unique string characters.
#    list text_delimiters; set_list_to_list_difference text_delimiters\
#        ZESHY_PARAMETER_EXPANSION_DELIMITERS text_characters
#
#    # If at least one delimiter is available, arbitrarily return the first.
#    if { is_list_nonempty text_delimiters } {
#        return_string "${text_delimiters[1]}"
#    # Else, no delimiter is available. Such string necessarily contains all
#    # possible delimiters, a daunting feat worthy of applause. Fail instead.
#    } else {
#        return_false
#    }
#}

