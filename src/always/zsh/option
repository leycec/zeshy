#!/usr/bin/env zsh
# ====================[ option                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle options specific to the current zsh shell.
#
# --------------------( SEE ALSO                           )--------------------
# man zshoptions
#     List all available zsh options.

#FIXME: Rename _shell to _zsh everywhere below. (Yes; I've given it quite a
#ponderous weight of consideration...and, well, it only makes sense.)
#FIXME: Note that this has knock-on effects elsewhere in the codebase: namely,
#for orthogonality, we should also rename all "if_shell_interactive" directories
#to... heck, why not just "if_interactive"? There's only one thing that can be
#interactive, so it's hard to see the point of specifying a noun here.
#Similarly, mass rename all "_OPTIONS_IF_SHELL_INTERACTIVE" to
#"_OPTIONS_IF_INTERACTIVE" and such. Much more concise. I heartily approve.

# ....................{ ALIASES                            }....................
declare_alias_with_stdin <<'________________<heredoc?>________________'
void enable_shell_option_locally(string option_name1, string option_name2, ...)

Locally enable the passed `zsh` options in the current context (e.g., block,
conditional, function, script). Options enabled in this manner revert to their
global setting on leaving such context: e.g.,

.enable_shell_option_locally()
==========================================
[source]
------------------------------------------
>>> function risky_non_business() {
...     enable_shell_option_locally no_warn_create_global
...     a_new_hopelessness="None shall pass."
... }
>>> risky_non_business                      # this does not print a warning!
>>> an_old_cheerfulness="Some shall pass."  # this does
------------------------------------------
==========================================
________________<heredoc?>________________
alias enable_shell_option_locally='setopt -- local_options'

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_shell_option(
    string option_name,
    string error_message = "\"${option_name}\" not a shell option")

Throw an exception with the passed message unless the current shell supports the
passed zsh option.
________________<heredoc?>________________
function die_unless_shell_option() {
    die_unless_args_1_to_2\
        'expected one option name and optional error message'
    string option_name="${1}"
    is_shell_option "${option_name}" or
        die "${2:-\"${option_name}\" not a shell option}"
}

# ....................{ EXCEPTIONS ~ option                }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_shell_interactive(
    string error_message = "current shell non-interactive")

Throw an exception with the passed message unless the current shell is
interactive. See is_shell_interactive() for more details.
________________<heredoc?>________________
function die_unless_shell_interactive() {
    die_unless_args_0_to_1 'expected optional error message'
    is_shell_interactive or die "${1:-current shell non-interactive}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_shell_login(
    string error_message = "current shell not a login shell")

Throw an exception with the passed message unless the current shell is a login
shell. See is_shell_login() for more details.
________________<heredoc?>________________
function die_unless_shell_login() {
    die_unless_args_0_to_1 'expected optional error message'
    is_shell_login or die "${1:-current shell not a login shell}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_shell_option(string option_name)

Return true if zsh supports the passed option: e.g.,

.is_shell_option()
==========================================
[source]
------------------------------------------
>>> is_shell_option unprivileged or print_string "Welcome, bourgeoisie."
Welcome, bourgeoisie.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_shell_option() {
    # Validate passed arguments.
    die_unless_arg 'expected one option name'
    string option_name="${1}" output

    # The previous implementation for this function resembled:
    #
    #     run_command_silent set +o local_options "${option_name}"
    #
    # While a clever solution, such implementation subtly fails when passed
    # options "privileged" or "restricted". As "man zshoptions" documents, the
    # option "local_options" localizes all options *EXCEPT* "privileged" or
    # "restricted", which remain unexpectedly globally set. Instead, employ an
    # even more insidiously smart solution by noting "[[ -o ${option_name} ]]"
    # always returns in one of three possible ways:
    #
    # * When passed a valid option name currently enabled, such command prints
    #   nothing and returns zero exit status.
    # * When passed a valid option name currently disabled, such command prints
    #   nothing and returns non-zero exit status.
    # * When passed an invalid option name, such command prints
    #   "is_shell_option:2: no such option: ${option_name}" to standard error
    #   and returns non-zero exit status.
    #
    # Consequently, a shell option exists when such command either returns zero
    # exit status or prints nothing.
    if { output="$(is -o "${option_name}" si 2>&1)" } {
        return_true
    } else {
        is_string_empty "${output}" | print_stdin_and_return_exit_status
    }
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_shell_option_enabled(string option_name)

Return true if the current shell enables the passed option. See
`man zshoptions` for a list of such options: e.g.,

.is_shell_option_enabled()
==========================================
[source]
------------------------------------------
>>> is_shell_option_enabled privileged or print_string "Goodbye, prole."
Goodbye, prole.
------------------------------------------
==========================================
________________<heredoc?>________________
function is_shell_option_enabled() {
    die_unless_arg 'expected one option name'
    string option_name="${1}"
    die_unless_shell_option "${option_name}"
    is -o "${option_name}" si
}

# ....................{ TESTERS ~ option                   }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_shell_interactive(void)

Return true if standard input to the current shell _was_ attached to a
terminal device on initial execution of such shell. When testing whether
standard input to the current shell is _currently_ attached to a terminal
device, consider calling is_stdin_terminal() instead. Standard input
to the current shell could have been initially attached to a terminal device
but since closed, in which case relying on the return value from this function
would be problematic.
________________<heredoc?>________________
function is_shell_interactive() {
    # Avoid running "is_shell_option_enabled interactive". While correct, such
    # command is somewhat slower than merely testing this option directly. While
    # Zeshy typically ignores such efficiency concerns, this function is called
    # frequently enough to warrant minor optimizations.
    die_if_args
    is -o interactive si
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_shell_login(void)

Return true if the first argument passed to the current shell was `-'. The
startup process running the `login` command typically passes such argument to
startup shells on successful login.
________________<heredoc?>________________
function is_shell_login() {
    die_if_args
    is_shell_option_enabled login
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void enable_shell_options(string option_name1, string option_name2, ...)

Enable the passed zsh options.
________________<heredoc?>________________
function enable_shell_option() {
    die_unless_args 'expected at least one option name'
    for option_name ("${@}") {
        die_unless_shell_option "${option_name}"
        set -o "${option_name}"
    }
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void disable_shell_option(string option_name1, string option_name2, ...)

Disable the passed zsh options.
________________<heredoc?>________________
function disable_shell_option() {
    die_unless_args 'expected at least one option name'
    for option_name ("${@}") {
        die_unless_shell_option "${option_name}"
        set -o "$(negate_shell_option "${option_name}")"
    }
}

#FIXME: Accept multiple option names, for orthogonality.
declare_function_with_stdin <<'________________<heredoc?>________________'
void negate_shell_option(string option_name)

Negate the passed zsh option. If such option is enabled, prefix such option
with `no_`; if such option is disabled, remove such prefix from such option.
As inexpressibly horrible edge cases, options `nomatch` and `notify` are
considered enabled despite their `no` prefixes: e.g.,

.negate_shell_option()
==========================================
[source]
------------------------------------------
>>> negate_shell_option nomatch
no_nomatch
>>> negate_shell_option no_notify
notify
------------------------------------------
==========================================
________________<heredoc?>________________
function negate_shell_option() {
    # Validate passed arguments.
    die_unless_args 'expected at least one option name'
    string option_name="${1}" is_option_disabled
    die_unless_shell_option "${option_name}"

    # For comparability, lowercase such option and strip out underscores.
    option_name="$(remove_string_substrings "${option_name}" '_')"
    option_name="$(lowercase_string "${option_name}")"

    # If such option is either "nomatch", "notify", "nonomatch", or "nonotify",
    # perform edge case handling.
    if { is_string_matches_with_capturing\
        "${option_name}" '(no|)(nomatch|notify)' } {
        # If such option is disabled, enable such option.
        if { is_string_nonempty "${match[1]}" } {
            return_string "${match[2]}"
        # Else, disable such option.
        } else {
            return_string "no_${match[2]}"
        }
    # Else, perform default handling.
    } else {
        # If such option is disabled, enable such option.
        string option_name_negated
        if {   option_name_negated="$(\
                get_string_match_group_if_matched "${option_name}" 'no(*)')" } {
            return_string "${option_name_negated}"
        # Else, disable such option.
        } else {
            return_string "no_${option_name}"
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename _shell_option to _zsh_option everywhere.
#       print "output: ${output}"
#   output="$(is -o "${option_name}" si 2>&1)" or
#       is_string_empty "${output}"
#FUXME: This is called often enough, we should probably just cache the result as
#a *NON-EXPORTED* global variable of the current shell. The *NON-EXPORTED* is key.
#   string_global ZESHY_IS_SHELL_INTERACTIVE="${ZESHY_IS_SHELL_INTERACTIVE-$(run_command_silent_and_get_exit_status_boolean is_shell_option_enabled interactive)}"
#   is_boolean_true "${ZESHY_IS_SHELL_INTERACTIVE}"
#   die_unless_arg 'expected one option name'
#   string option_name="${1}"
#   die_unless_shell_option "${option_name}"
#   set -o "${option_name}"
#       ${ZESHY_STDERR_FILE_DESCRIPTOR}>&${ZESHY_STDOUT_FILE_DESCRIPTOR})" or
#function isot() {
#    string option_name="${1}" output
#      not is_string_suffix "${output}" "no such option: ${option_name}"
#   if not output="$(is -o "${option_name}" si 2>&1)" and
#      is_string_suffix "${output}" "no such option: ${option_name}"
#   then return_false
#   elif print "output: ${output}"
#   else return_true
#   fi
#}

# See "man zshoptions" for a list
# of such options# and interactively reading commands from standard input.
# Technically, this could be
    # avoided by calling "set +o" only if the passed option is *NOT*
    # "privileged" or "restricted".
    #FUXME: Doesn't work. Best way appears to be capturing the print_string of a test
    #resembling "$(is -o "${option_name}" si)" for an error message resembling:
    #   zsh: no such option: oeuoeuo
    # Dismantled, this is:
    #
    # * "set +o", printing the passed option name if such option exists or
    #   returning false.
    # * "run_command_silent", hiding such print_string while retaining such return status.
