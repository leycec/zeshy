#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle options specific to the current `zsh` shell.

== See Also ==

* `man zshoptions`, listing all available `zsh` options.
-/-

#FIXME: Rename _shell to _zsh everywhere below. (Yes; I've given it quite a
#ponderous weight of consideration...and, well, it only makes sense.)

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_shell_option(
    string option_name,
    string error_message = "Shell option \"${option_name}\" unrecognized.")

Throw an exception with the passed message unless `zsh` supports the passed
option. See is_shell_option() for further details.
/---
function die_unless_shell_option() {
    die_unless_args_1_to_2\
        'Expected one option name and optional error message.'
    string option_name="${1}"
    is_shell_option "${option_name}" or
        die "${2:-Shell option \"${option_name}\" unrecognized.}"
}

# ....................{ EXCEPTIONS ~ option                }....................
declare_function_with_stdin <<'/---'
void die_unless_shell_interactive(
    string error_message = "Current shell non-interactive.")

Throw an exception with the passed message unless the current shell is
interactive. See is_shell_interactive() for more details.
/---
function die_unless_shell_interactive() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_shell_interactive or die "${1:-Current shell non-interactive.}"
}

declare_function_with_stdin <<'/---'
void die_unless_shell_login(
    string error_message = "Current shell not a login shell.")

Throw an exception with the passed message unless the current shell is a login
shell. See is_shell_login() for more details.
/---
function die_unless_shell_login() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_shell_login or die "${1:-Current shell not a login shell.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_shell_option(string option_name1, ...)

Return success if `zsh` supports all passed shell options: e.g.,

.is_shell_option()
==========================================
[source]
------------------------------------------
>>> string on_good_nature=\
...    "Good nature is, of all moral qualities, the one that the world needs
...     most, and good nature is the result of ease and security, not of a life
...     of arduous struggle. Modern methods of production have given us the
...     possibility of ease and security for all; we have chosen, instead, to
...     have overwork for some and starvation for the others. Hitherto we have
...     continued to be as energetic as we were before there were machines; in
...     this we have been foolish, but there is no reason to go on being foolish
...     for ever."
>>> is_shell_option privileged and get_string_line "${on_good_nature}" 1
Good nature is, of all moral qualities, the one that the world needs
------------------------------------------
==========================================
/---
function is_shell_option() {
    # Validate sanity.
    die_unless_args 'Expected one or more option names.'

    # Test such option. Technically, this is also testable with the following
    # cumbersome block:
    #
    #     string output
    #     if { output="$(is -o "${option_name}" si 2>&1)" } {
    #         report_success
    #     } else {
    #         is_string_empty "${output}" and report_status
    #     }
    #
    # The previous implementation for this function resembled:
    #
    #     run_code_silent set +o local_options "${option_name}"
    #
    # While a clever solution, such implementation subtly fails when passed
    # options "privileged" or "restricted". As "man zshoptions" documents, the
    # option "local_options" localizes all options *EXCEPT* "privileged" or
    # "restricted", which remain unexpectedly globally set. Instead, note
    # "is -o ${option_name} si" always returns in one of three possible ways:
    #
    # * When passed a valid option name currently enabled, such command prints
    #   nothing and returns zero exit status.
    # * When passed a valid option name currently disabled, such command prints
    #   nothing and returns non-zero exit status.
    # * When passed an invalid option name, such command prints
    #   "is_shell_option:2: no such option: ${option_name}" to standard error
    #   and returns non-zero exit status.
    #
    # Consequently, a shell option exists when such command either returns zero
    # exit status or prints nothing.
    is_map_key options "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_shell_option_enabled(string option_name)

Return success if the passed option is currently enabled in the current shell:
e.g.,

.is_shell_option_enabled()
==========================================
[source]
------------------------------------------
>>> string on_lunacy=\
...    "Men who allow their love of power to give them a distorted view of the
...     world are to be found in every asylum: one man will think he is Governor
...     of the Bank of England, another will think he is the King, and yet
...     another will think he is God. Highly similar delusions, if expressed by
...     educated men in obscure language, lead to professorships in philosophy;
...     and if expressed by emotional men in eloquent language, lead to
...     dictatorships. Certified lunatics are shut up because of the proneness
...     to violence when their pretensions are questioned; the uncertified
...     variety are given control of powerful armies, and can inflict death and
...     disaster upon all sane men within their reach."
>>> is_shell_option_enabled alias and get_string_line "${on_lunacy}" 1
Men who allow their love of power to give them a distorted view of the
------------------------------------------
==========================================
/---
function is_shell_option_enabled() {
    # Validate sanity.
    die_unless_arg 'Expected one option name.'
    string option_name="${1}"
    die_unless_shell_option "${option_name}"

    # Test such option. Technically, this is also implementable as:
    #
    #     is "${options[${option_name}]" == 'on' si
    #
    # The current implementation appears more clarid and efficient, however.
    is -o "${option_name}" si
}

# ....................{ TESTERS ~ option                   }....................
#FIXME: Reduce to simply aliases.
declare_function_with_stdin <<'/---'
[status: boolean] is_shell_interactive(void)

Return success if standard input to the current shell _was_ attached to a
terminal device on initial execution of such shell. When testing whether
standard input to the current shell is _currently_ attached to a terminal
device, consider calling is_stdin_terminal() instead. Standard input
to the current shell could have been initially attached to a terminal device
but since closed, in which case relying on the return value from this function
would be problematic.
/---
function is_shell_interactive() {
    # Avoid running "is_shell_option_enabled interactive". While correct, such
    # command is somewhat slower than merely testing this option directly. While
    # Zeshy typically ignores such efficiency concerns, this function is called
    # frequently enough to warrant minor optimizations.
    die_if_args
    is -o interactive si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_shell_login(void)

Return success if the first argument passed to the current shell was `-'. The
startup process running the `login` command typically passes such argument to
startup shells on successful login.
/---
function is_shell_login() {
    die_if_args
    is_shell_option_enabled login
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_shell_option_disabled(string option_name)

Convert the passed `zsh` shell option to disabled form. Specifically, if such
option is:

* Enabled (i.e., _not_ prefixed by `no_`), prefix such option by `no_`.
* Disabled (i.e., prefixed by `no_`), remove such prefix from such option.

As edge cases, note that options `nomatch` and `notify` are considered enabled
despite their `no` prefixes: e.g.,

.get_shell_option_disabled
==========================================
[source]
------------------------------------------
>>> get_shell_option_disabled privelaged
no_privelaged
>>> get_shell_option_disabled nomatch
no_nomatch
>>> get_shell_option_disabled no_notify
notify
------------------------------------------
==========================================
/---
function get_shell_option_disabled() {
    # Validate sanity.
    die_unless_arg 'Expected one option name.'
    string option_name="${1}" is_option_disabled
    die_unless_shell_option "${option_name}"

    # For comparability, lowercase such option and strip out underscores.
    option_name="$(lowercase_string\
        $(remove_string_text "${option_name}" '_'))"

    # If such option is either "nomatch", "notify", "nonomatch", or "nonotify",
    # perform edge case handling.
    if { is_string_matches_glob_capturing_groups\
        "${option_name}" '(no|)(nomatch|notify)' } {
        # If such option is disabled, enable such option.
        if { is_string_nonempty "${match[1]}" } {
            return_string "${match[2]}"
        # Else, disable such option.
        } else {
            return_string "no_${match[2]}"
        }
    # Else, perform default handling.
    } else {
        # If such option is disabled, enable such option.
        string option_name_negated
        if {   option_name_negated="$(\
                get_string_text_matching_glob_group_if_found "${option_name}" 'no(*)')" } {
            return_string "${option_name_negated}"
        # Else, disable such option.
        } else {
            return_string "no_${option_name}"
        }
    }
}

# ....................{ SETTERS                            }....................
#FIXME: Add examples.
declare_function_with_stdin <<'/---'
void enable_shell_options(string option_name1, ...)

Globally enable the passed shell options.
/---
function enable_shell_option() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize changes to disable_shell_option().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args 'Expected one or more option names.'

    # Enable such options. Technically, this is also implementable as:
    #
    #     set -o "${option_name}"
    #
    # Since there exists no corresponding command for disabling such options,
    # however, we adopt the current approach for orthogonality with
    # disable_shell_option().
    string option_name
    for    option_name ("${@}") {
        die_unless_shell_option "${option_name}"
        options[${option_name}]='on'
    }
}

declare_function_with_stdin <<'/---'
void disable_shell_option(string option_name1, ...)

Globally disable the passed shell options. See enable_shell_option() for further
details.
/---
function disable_shell_option() {
    # See enable_shell_option() for further details.
    die_unless_args 'Expected one or more option names.'
    string option_name
    for    option_name ("${@}") {
        die_unless_shell_option "${option_name}"
        options[${option_name}]='off'
    }
}

declare_function_with_stdin <<'/---'
void invert_shell_option(string option_name1, ...)

Globally invert the passed shell options. Specifically, for each such option, if
such option is:

* Currently enabled, disable such option.
* Currently disabled, enable such option.
/---
function invert_shell_option() {
    # Validate sanity.
    die_unless_args 'Expected one or more option names.'

    # Invert such arguments.
    string option_name
    for    option_name ("${@}") {
        die_unless_shell_option "${option_name}"

        if is ${options[${option_name}]} == 'on' si {
            options[${option_name}]='off'
        } else {
            options[${option_name}]='on'
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ TESTERS ~ option                   }....................
#FUXME: Reduce to simply aliases.
#declare_function_with_stdin <<'/---'
#[status: boolean] is_shell_interactive(void)
#
#Return success if standard input to the current shell _was_ attached to a
#terminal device on initial execution of such shell. When testing whether
#standard input to the current shell is _currently_ attached to a terminal
#device, consider calling is_stdin_terminal() instead. Standard input
#to the current shell could have been initially attached to a terminal device
#but since closed, in which case relying on the return value from this function
#would be problematic.
#/---
#function is_shell_interactive() {
#    # Avoid running "is_shell_option_enabled interactive". While correct, such
#    # command is somewhat slower than merely testing this option directly. While
#    # Zeshy typically ignores such efficiency concerns, this function is called
#    # frequently enough to warrant minor optimizations.
#    die_if_args
#    is -o interactive si
#}
#
#declare_function_with_stdin <<'/---'
#[status: boolean] is_shell_login(void)
#
#Return success if the first argument passed to the current shell was `-'. The
#startup process running the `login` command typically passes such argument to
#startup shells on successful login.
#/---
#function is_shell_login() {
#    die_if_args
#    is_shell_option_enabled login
#}

#FUXME: *sigh* We implemented this prior to discovering the canonical
#${options} map global, which permits negation as follows:
#
#    if is ${options[${option_name}]} == 'on' si {
#       options[${option_name}]='off'
#    } else {
#       options[${option_name}]='on'
#    }
#
#No kidding. It's *THAT* simple. Excise the current implementation, with mute
#shame. ("Remove the stone of shame... and attach the stone of triumph!")
#FUXME: Oh, wait. That implements inversion, which also seems useful.
#(Implement!) We want *NEGATION* of the actual option name here. This strikes
#me as ludicrous, given the ${options} map. Grep the codebase for wherever we
#call this and, ideally, excise completely.
#FUXME: Accept multiple option names, for orthogonality.

#       set -o "$(negate_shell_option "${option_name}")"
    # The previous implementation for this function resembled:
    #
    #     run_code_silent set +o local_options "${option_name}"
    #
    # While a clever solution, such implementation subtly fails when passed
    # options "privileged" or "restricted". As "man zshoptions" documents, the
    # option "local_options" localizes all options *EXCEPT* "privileged" or
    # "restricted", which remain unexpectedly globally set. Instead, employ an
    # even more insidiously smart solution by noting "[[ -o ${option_name} ]]"
    # always returns in one of three possible ways:
    #
    # * When passed a valid option name currently enabled, such command prints
    #   nothing and returns zero exit status.
    # * When passed a valid option name currently disabled, such command prints
    #   nothing and returns non-zero exit status.
    # * When passed an invalid option name, such command prints
    #   "is_shell_option:2: no such option: ${option_name}" to standard error
    #   and returns non-zero exit status.
    #
    # Consequently, a shell option exists when such command either returns zero
    # exit status or prints nothing.
#   if { output="$(is -o "${option_name}" si 2>&1)" } {
#       report_success
#   } else {
#       is_string_empty "${output}" and report_status
#   }

# ....................{ ALIASES                            }....................
#declare_alias_with_stdin\
#    'void enable_shell_option_local(string option_name1, string option_name2, ...)'\
#    'setopt -- local_options' <<'/---'
#Locally enable the passed `zsh` options in the current context (e.g., block,
#conditional, function, script). Options enabled in this manner revert to their
#global setting on leaving such context: e.g.,
#
#.enable_shell_option_local()
#==========================================
#[source]
#------------------------------------------
#>>> function risky_non_business() {
#...     enable_shell_option_local no_warn_create_global
#...     a_new_hopelessness="None shall pass."
#... }
#>>> risky_non_business                      # this does not print a warning!
#>>> an_old_cheerfulness="Some shall pass."  # this does
#------------------------------------------
#==========================================
#/---

#FUXME: Note that this has knock-on effects elsewhere in the codebase: namely,
#for orthogonality, we should also rename all "if_shell_interactive" directories
#to... heck, why not just "if_interactive"? There's only one thing that can be
#interactive, so it's hard to see the point of specifying a noun here.
#Similarly, mass rename all "_OPTIONS_IF_SHELL_INTERACTIVE" to
#"_OPTIONS_IF_INTERACTIVE" and such. Much more concise. I heartily approve.
#FUXME: Rename _shell_option to _zsh_option everywhere.
#       print "output: ${output}"
#   output="$(is -o "${option_name}" si 2>&1)" or
#       is_string_empty "${output}"
#FUXME: This is called often enough, we should probably just cache the result as
#a *NON-EXPORTED* global variable of the current shell. The *NON-EXPORTED* is key.
#   string_global ZESHY_IS_SHELL_INTERACTIVE="${ZESHY_IS_SHELL_INTERACTIVE-$(run_code_silent_and_get_status_boolean is_shell_option_enabled interactive)}"
#   is_boolean_true "${ZESHY_IS_SHELL_INTERACTIVE}"
#   die_unless_arg 'expected one option name'
#   string option_name="${1}"
#   die_unless_shell_option "${option_name}"
#   set -o "${option_name}"
#       ${ZESHY_STDERR_FILE_DESCRIPTOR}>&${ZESHY_STDOUT_FILE_DESCRIPTOR})" or
#function isot() {
#    string option_name="${1}" output
#      not is_string_suffix "${output}" "no such option: ${option_name}"
#   if not output="$(is -o "${option_name}" si 2>&1)" and
#      is_string_suffix "${output}" "no such option: ${option_name}"
#   then report_failure
#   elif print "output: ${output}"
#   else report_success
#   fi
#}

# See "man zshoptions" for a list
# of such options# and interactively reading commands from standard input.
# Technically, this could be
    # avoided by calling "set +o" only if the passed option is *NOT*
    # "privileged" or "restricted".
    #FUXME: Doesn't work. Best way appears to be capturing the print_string of a test
    #resembling "$(is -o "${option_name}" si)" for an error message resembling:
    #   zsh: no such option: oeuoeuo
    # Dismantled, this is:
    #
    # * "set +o", printing the passed option name if such option exists or
    #   returning false.
    # * "run_code_silent", hiding such print_string while retaining such return status.
