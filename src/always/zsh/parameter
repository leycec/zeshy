#!/usr/bin/env zsh
# ====================[ parameter                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle `zsh` parameter expansion.

# ....................{ GLOBALS                            }....................
declare_global_with_stdin <<'________________<heredoc?>________________'
list_set ZESHY_PARAMETER_EXPANSION_TOKENS

List of all possible parameter expansion tokens. See
get_string_parameter_expansion_token_if_found() for further details.
________________<heredoc?>________________
ZESHY_PARAMETER_EXPANSION_TOKENS=(
    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '^' '&' '*'
    '-' '_' '\' '|' '/' '?'
)

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[stdout: string, status: boolean] get_string_parameter_expansion_token_if_found(
    string text1, string text2, ...)

Get an arbitrary parameter expansion token specific to the passed string or
return failure if no such token exists (i.e., if such string contains all
possible tokens). Such tokens are punctuation characters with which `zsh`
delimits parameter expansion flag arguments (e.g., the `;` in
`${(j:canticle:)leibowitz}`). Assuming such string does _not_ contain all
possible tokens, this function efficiently finds an arbitrary such token for
subsequent interpolation in an `eval` statement: e.g.,

.get_string_parameter_expansion_token_if_found()
==========================================
[source]
------------------------------------------
# A string containing all but one possible such token.
>>> string dea="drug:employment:agency:,.;~\`'\"=+@#\$%^&*-_\\|/" token

# Find such token.
>>> token="$(get_string_parameter_expansion_token_if_found "${dea}")"
>>> print_string "parameter expansion token: ${token}"
parameter expansion token: ?

# Split such string on such token.
>>> list  volstead_act
>>> eval "volstead_act=( \${(s${token}:${token})dea} )"
>>> print_string ${volstead_act[1]} ${volstead_act[2]} ${volstead_act[3]}
drug employment agency
------------------------------------------
==========================================

See ${ZESHY_PARAMETER_EXPANSION_TOKENS} for all such tokens.
________________<heredoc?>________________
function get_string_parameter_expansion_token() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    string text="${*}"

    # Since the caret is arguably the least common such token, explicitly test
    # for the absence of such token in such string prior to algorithmically
    # finding another possible token. For efficiency, inline such test.
    is "${text}" != *'^'* si and return_string '^'

    # To efficiently find the first such token not already in such string:
    #
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference ${ZESHY_PARAMETER_EXPANSION_TOKENS}, a list set containing
    #   each possible such token as a list element, from the prior list set into
    #   a third list set, containing each possible token not in such string.
    # * Arbitrarily return the first element of such set.
    #
    # Such algorithm is considerably more efficient than iteratively finding
    # such token. In any case, the prior optimization *SHOULD* catch most cases.

    # List set of all unique characters in the passed string.
    list_set text_chars; set_list_to_string_characters text_chars "${text}"

    # Difference such set from ${ZESHY_PARAMETER_EXPANSION_TOKENS}.
    list tokens_free; set_list_to_list_difference\
         tokens_free ZESHY_PARAMETER_EXPANSION_TOKENS text_chars

    # If such string does *NOT* contain at least one such token, arbitrarily
    # return the first such token.
    if { is_list_nonempty tokens_free } {
        return_string "${tokens_free[1]}"
    # Else, such string contains all possible tokens, an insane feat worthy of
    # jeering applause. Fail instead.
    } else {
        return_false
    }
}

# --------------------( WASTELANDS                         )--------------------
#declare_function_with_stdin <<'________________<heredoc?>________________'
#string get_string_parameter_expansion_delimiter_if_found(
#    string text1, string text2, ...)
#
#Get an arbitrary zsh parameter expansion delimiter character _not_ in the passed
#strings or return false if no such character exists (i.e., such strings contain
#all possible delimiter characters, effectively all printable ASCII characters
#and hence unlikely for most cases). Several parameter expansion flags require
#one or more arguments delimited by some arbitrary character _not_ in such
#arguments (e.g., "${(j:Canticle:)Leibowitz}"). This function efficiently finds
#such a character, if available, for subsequent use in an "eval" statement: e.g.,
#
#.get_string_parameter_expansion_delimiter_if_found()
#==========================================
#[source]
#------------------------------------------
## Split such string on commas. Of course, this is more simply implemented as
## "fiat_homo_split=( ${(s:,:)fiat_homo} )". If, however, the delimiter to
## split such string on is unknown at implementation time, this simpler
## implementation fails if a colon delimiter is preferred. This longer
## implementation succeeds regardless of delimiter choice.
#>>> string fiat_homo="From the fall of the cesium, O Lord, deliver us."
#>>> string split_on=","
#>>> character flag_delim="$(\
#...     get_string_parameter_expansion_delimiter_if_found "${split_on}")"
#>>> list  split
#>>> eval "split=( ${(s${flag_delim}${split_on}${flag_delim})fiat_homo} )"
#>>> print_string "${split[1]}"
#From the fall of the cesium
#------------------------------------------
#==========================================
#________________<heredoc?>________________
#function get_string_parameter_expansion_delimiter_if_found() {
#    # Validate passed parameters.
#    die_unless_args 'expected at least one string'
#    string text="${*}"
#
#    # List set of all unique characters in such string.
#    list_set text_characters
#    set_list_to_string_characters text_characters "${text}"
#
#    # List of all available delimiters (i.e., all possible delimiters *NOT* in
#    # such string), efficiently constructed by differencing the list of all
#    # possible delimiters from the list set of all unique string characters.
#    list text_delimiters; set_list_to_list_difference text_delimiters\
#        ZESHY_PARAMETER_EXPANSION_DELIMITERS text_characters
#
#    # If at least one delimiter is available, arbitrarily return the first.
#    if { is_list_nonempty text_delimiters } {
#        return_string "${text_delimiters[1]}"
#    # Else, no delimiter is available. Such string necessarily contains all
#    # possible delimiters, a daunting feat worthy of applause. Fail instead.
#    } else {
#        return_false
#    }
#}

