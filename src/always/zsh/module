#!/usr/bin/env zsh
# ====================[ shell                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle precompiled zsh modules.
#
# --------------------( SEE ALSO                           )--------------------
# https://jgao.googlecode.com/svn/trunk/.shell/zsh_module
#     Comprehensive zsh module autoload definitions inspiring those below.
#
# "os/kernel"
#     Handling *nix kernel modules.

# ....................{ TESTERS                            }....................
#FIXME: Uhm; how actually does one do this? The zsh manual explicitly suggests
#the best method is:
#
#    run_silently zmodload "${1}"
#
#But that's demonstrably silly. A test method shouldn't actually have non-
#idempotent side effects. In lieu of any builtin method, the best way might
#simply be to search the appropriate path under "/usr/share/zsh" for filenames
#corresponding to passed modules.

# void is_module(string module_name)
#
# Return true if zsh provides some module with the passed name.
#is_module() {
#    die_unless_arg 'expected one module name'
#    zmodload "${1}"
#}

# ....................{ LOADERS                            }....................
document_function '
void load_zsh_module(string module_name)

Load the passed zsh module.
'
function load_zsh_module() {
    die_unless_arg 'expected one module name'
    zmodload -- "${1}"
}

document_function '
void unload_zsh_module(string module_name)

Unload the passed zsh module.
'
function unload_zsh_module() {
    # Dismantled, this is:
    #
    # * "u", unloading this module.
    # * "i", a noop if this module is not currently loaded.
    die_unless_arg 'expected one module name'
    zmodload -ui -- "${1}"
}

# ....................{ RUNNERS                            }....................
document_function '
string run_with_mapfile(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command with the zsh "mapfile" module loaded before and
unloaded after running the command. "mapfile" is inherently unsafe; in
particular, unsetting list elements permanently and silently deletes files
with the same name as such elements. On the other hand, "mapfile" is slightly
more efficient than safer alternatives (e.g., "$(< "${filename}")"). This
function renders "mapfile" somewhat safer but not necessarily safe. Please
exercise caution when calling this function *AND FOR HEAVEN''S SAKE *NEVER*
MANUALLY LOAD* "mapfile".
'
function run_with_mapfile() {
    #FIXME: When enabled, this sporadically fails with an inscrutable error like:
    #    "(anon):82: bad math expression: operand expected at `/usr/share...'"
    #File a bug report if this is still the case under recent zsh versions.
    # Forcibly prevent harmful ${mapfile} and hence filesystem changes.
#   freeze_variable mapfile

    # Run such command with global map ${mapfile}.
    load_zsh_module zsh/mapfile
    {
        run "${@}"
    } always {
        unload_zsh_module zsh/mapfile
    }
}

# ....................{ STARTUP                            }....................
# Autoload zsh module-defined functions at the beginning rather than end of
# Zeshy startup, thus avoiding errors when subsequent Zeshy startup functions
# call such functions.
prepend_startup_zeshy_command autoload_zsh_modules

document_function '
void autoload_zsh_modules(void)

Autoload functions and variables defined by stock zsh modules, thus deferring
loading such modules until calling such functions or expanding such variables.
'
function autoload_zsh_modules() {
    # Validate sanity.
    (( # == 0 )) || die 'expected no arguments'

    # Define autoloads for all autoloadable functions in the current user's
    # function path list, obsoleting manual autoloading of such functions.
    # Since the set of all basenames of all plain files in all directories in
    # such list is exactly the set of all autoloadable function names, globbing
    # such basenames suffices to find all such names. Dismantled, this is:
    #
    # * "${^fpath}", iteratively expanding to each directory containing
    #   autoloadable function files.
    # * "/*", globbing all files and subdirectories of such directory.
    # * ".", excluding non-plain files (e.g., device files, directories).
    # * ":t", expanding to the tail (i.e., basename) of each such file.
    for function_name (${^fpath}/*(.:t)) {
        # For safety, autoload this function under option "-U" to suppress alias
        # expansion. This prevents expansion of Zeshy- and user-specific aliases
        # under core zsh functions implemented with no such aliases in mind.
#       print "autoloading \"${autoload_function_name}\"..."
        autoload -U -- "${function_name}"
    }

    # Define autoloads for all autoloadable functions defined by zsh modules not
    # autoloaded above. Unlike above, this requires manually mapping modules to
    # function names -- an unctuous proposition. Dismantled, this is:
    #
    # * "-a", autoloading the following builtins ("b"), functions ("f"), or
    #   parameters ("p") from the immediately following module.
    # * "i", ignoring rather than failing when such builtins, functions, or
    #   parameters have already been loaded within such module.
    #
    # Avoid mapping modules already loaded by the main Zeshy script as well as:
    #
    # * "mapfile", whose overly permissive style poses a profound risk of
    #   permanent, silent file deletion or modification. For safety, this module
    #   must be manually loaded and unloaded.
    # * "prof", which when loaded begins aggressively profiling zsh functions.
    #   While useful, autoloading the zprof() function this module defines will
    #   begin profiling *ONLY* at the first call of such function, whereas such
    #   function is intended to be called after having already loaded this
    #   module and performed the profiled code. By intentional design, this
    #   module must be manually loaded and unloaded.
    zmodload -abi zsh/cap cap getcap setcap
    zmodload -abi zsh/clone clone
    zmodload -abi zsh/compctl compctl compcall
    zmodload -abi zsh/computil comparguments compdescribe compfiles compgroups\
        compquote comptags comptry compvalues
    zmodload -afi zsh/deltochar delete-to-char zap-to-char
    zmodload -afi zsh/mathfunc abs int float acos acosh asin asinh atan atanh\
        cbrt ceil cos cosh erf erfc exp expm1 fabs floor gamma j0 j1 lgamma log\
        log10 log1p logb sin sinh sqrt tan tanh y0 y1 ilogb signgam copysign\
        fmod hypot nextafter jn yn ldexp scalb rand48
    zmodload -abi zsh/pcre pcre_compile pcre_study pcre_match
    zmodload -abi zsh/sched sched
    zmodload -abi zsh/net/socket zsocket
    zmodload -abi zsh/net/tcp ztcp
    zmodload -abi zsh/system syserror sysread syswrite
    zmodload -api zsh/system errnos
    zmodload -abi zsh/termcap echotc
    zmodload -api zsh/termcap termcap
    zmodload -abi zsh/zftp zftp
    zmodload -api zsh/zleparameter keymaps widgets
    zmodload -abi zsh/zpty zpty
    zmodload -abi zsh/zselect zselect
}

# --------------------( WASTELANDS                         )--------------------
# void load_mapfile(void)
#
# Load zsh module "mapfile". This module is *INHERENTLY* dangerous; in
# particular, unsetting list elements permanently and silently deletes files
# with the same name as such elements. To prevent accidental calamity, either:
#
# * If possible, call run_with_mapfile() rather than this function, which safely
#   handles such lifecycle issues for you.
# * Otherwise, unload "mapfile" immediately after use via unload_mapfile().
#function load_mapfile() {
#    load_zsh_module zsh/mapfile
#}

# void unload_mapfile(void)
#
# Unload zsh module "mapfile". See load_mapfile().
#function unload_mapfile() {
#    unload_zsh_module zsh/mapfile
#}

