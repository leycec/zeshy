#!/usr/bin/env zsh
# ====================[ pager                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle paging ala "more" and "less".

# ....................{ GETTERS                            }....................
# string get_pager_command(void)
#
# Get the pager command preferred by the current user.
function get_pager_command() {
    die_if_args
    output "${PAGER:=$(get_first_command_path less more)}"
}

# ....................{ PRINTERS                           }....................
#FIXME: It'd be great to implement the following swag idea:
#
#* When not paging, to visually demarcate wrapped lines (ideally with color? or
#  perhaps simply with a simple prefix). So, rather than printing:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
#odes=497142 mode=755
#  Instead, printing:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ^-> odes=497142 mode=755
#  Or perhaps simply:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr_in
# ...odes=497142 mode=755
#  Or the slightly cleverer:
#udev                 /dev                      devtmpfs     rw nosuid relatime size=10240k nr...
# ..._inodes=497142 mode=755
#  Actually, no. That reads awkwardly. One "..." is sufficient, I should think.
#  Happily, "yppy" already has appropriate Unicode for the former arrows. In either case, I
#  prefer the prefixing space on the wrapped line.

# string output_paged(string text1, string text2, ...)
#
# If the passed string exceeds the current terminal's dimensions, print such
# string with the current user's preferred pager; otherwise, only print such
# string as is (i.e., without paging). Therefore, this function implements an
# intelligent pager.
function output_paged() {
    prepend_args_with_piped_input
    output_paged_if_exceeds_terminal_dimensions "${@}" or output "${*}"
}

# string output_paged_if_exceeds_terminal_dimensions(
#   string text1, string text2, ...)
#
# If the passed string exceeds the current terminal's dimensions, print such
# string with the current user's preferred pager; otherwise, return false.
function output_paged_if_exceeds_terminal_dimensions() {
    # Validate passed arguments.
    prepend_args_with_piped_input
    die_unless_args 'expected at least one string'
    string text="${*}"

    # If not called from a terminal, output such string without paging.
    is_shell_terminal or {
        output "${@}"
        return_true
    }

    # List of output lines.
    list lines; set_list_to_string_lines lines "${text}"

    # Determine whether such output's logical line length (i.e., accounting for
    # implicit wrapping of long lines) exceeds the terminal height or physical
    # line width the terminal width. The algorithm resembles
    # get_displayed_line_length(), but differs by immediately stopping iteration
    # on exceeding terminal height or width rather than continuing to accumulate
    # total line length. This reduces an otherwise O(N) algorithm to effectively
    # O(1), assuming non-ludicrous terminal height and width.
    integer\
        text_height line_sans_ansi_width terminal_height terminal_width_plus_one
    text_height="$(get_list_size lines)"
    terminal_height="$(get_terminal_height)"

    # Terminal width plus one to avoid treating maximally long lines as wrapped.
    terminal_width_plus_one=$(( $(get_terminal_width) + 1 ))
#   say "text_height: ${text_height}\nterminal_height: ${terminal_height}"

    # ${text_height} gives only the number of lines in such string without
    # considering line wrapping. Even if such number does not exceed the
    # terminal height, such number incremented by the number of additional
    # wrapped lines in such string *COULD* still exceed the terminal height. In
    # the latter case, such string requires paging.
    string line_sans_ansi
    (( text_height > terminal_height )) or for line ("${lines[@]}") {
        # Remove ANSI color codes prior to testing line length.
        line_sans_ansi_width="$(\
            get_string_length_multibyte_sans_ansi_color_codes "${line}")"
#       say "line width (sans ANSI): ${line_sans_ansi_width}"

        # Increment the number of lines required to display such text by the
        # number of wrapped lines by which the current line exceeds the terminal
        # width (i.e., by the number of additional wrapped lines in this line).
        (( text_height += line_sans_ansi_width / terminal_width_plus_one ))
        (( text_height > terminal_height )) and break
    }
#   say "text_height: ${text_height}\nterminal_height: ${terminal_height}"
#   say "text_width: ${text_width}\nterminal_width_plus_one: ${terminal_width_plus_one}"

    # If the terminal suffices to display output without paging, do not page.
    (( text_height > terminal_height )) or return_false
#   say "line length: ${text_height}\nterminal height: ${terminal_height}"

    # Pager command to be run.
    list pager; pager=( "${PAGER}" )

    # Pager command name capitalized for use below.
    string pager_command_name
    pager_command_name="$(capitalize_string "$(get_path_basename "${PAGER}")")"

    # List of pager options specific to such pager.
    string pager_options_list_name
    pager_options_list_name="ZESHY_${pager_command_name}_OPTIONS"
    is_list "${pager_options_list_name}" and
        pager+=( "${(@P)pager_options_list_name}" )

    # Page such text.
    output "${text}" | "${pager[@]}"
}

# ....................{ RUNNERS                            }....................
# string run_paged(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command with standard output and error piped to the current
# pager if such output exceeds either the current terminal height or width or as
# is (i.e., without paging) otherwise. Hence, this is an intelligent pager.
#
# Customary pager commands block on standard input, thus delaying output until
# after the input command completes operation. Resource-intensive commands not
# completing immediately (e.g., "ls -R *") thus block paging with no
# intermediate output until such commands eventually complete. To rectify such
# interface woes, this function immediately prints all output as received from
# the passed command to standard error prior to paging such output, as needed.
function run_paged() {
    # If not called from a terminal, run such command without paging.
    if not is_shell_terminal; then
        run "${@}"
    # If passed piped input and no arguments, output such input without paging.
    elif is_no_args and is_piped_input; then
        output_paged "$(get_piped_input)"
    # Otherwise, run the passed command with redirection. Dismantled, this is:
    #
    # * "1>&1", preserving standard output prior to its subsequent redirection.
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
    # * "or true", ignoring such function call when returning false, since the
    #   prior "1>&2" redirection already successfully printed such output.
    #
    # Avoid the following seemingly efficient and certainly simpler alternative,
    # which unfortunately discards non-zero exit status from run():
    #
    #   run "${@}" 1>&1 1>&2 | output_paged_if_exceeds_terminal_dimensions or true
    else
        die_unless_args 'expected one command'
#       output "run_paged: ${@}..."
        output_paged_if_exceeds_terminal_dimensions\
            "$(run "${@}" 1>&1 1>&2 2>&1)" or true
    fi
}

# --------------------( WASTELANDS                         )--------------------
#   get_and_set_string_global_if_unset_or_empty_to_evaluation
#   set_string_if_unset_or_empty_to_evaluation\
#       PAGER '$(get_first_command_path less more)'
#   output "${PAGER}"

#function get_string_global_and_set_if_unset_or_empty_to_evaluation() {
#    die_unless_one_arg 'expected one string variable name'
#    string __variable_name__="${1}"
#    declare_string_global "${__variable_name__}"
#    set_string_if_unset_or_empty_to_evaluation\
#        "${__variable_name__}" '$(get_first_command_path less more)'
#    output "${__variable_name__}"
#}

        #FIXME: Not quite right. Try prefixing or suffixing 2>&1.
        #FIXME: Woops. This erroneously discards non-zero exit status from
        #run(). We only want to discard non-zero exit status from
        #output_...(). Hmmmm. Frak this. Revert to the prior logic, which
        #actually worked perfectly.
#       run "${@}" 1>&1 1>&2 | output_paged_if_exceeds_terminal_dimensions or
#           true
#       string output; set_string_to_piped_input output
#       output_paged "${output}"
#       line_sans_ansi_width="$(get_string_length "$(remove_ansi_color_codes "${line}")")"
#       text_width=${#$(remove_ansi_color_codes "${line}")}
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
#       run "${@}" 1>&1 1>&2 2>&1 | output_paged_if_exceeds_terminal_dimensions

#   say 'here!' 
#   is_piped_input and {
#       say 'received piped input:'
#       say "$(< /dev/stdin)"
#       say 'yikes'
#       close_standard_input
#       say 'yikes'
#       is -p /dev/stdin si and say 'pipe"s alive!!!!'
#       say 'yikes'
#       is_piped_input and say 'pipe"s alive!!!!'
#       say 'yikes'
#   }
#   say 'no, here!' 
    # If passed piped input and...
#   string output
#   if is_piped_input; then
#       say "received piped input: $(get_piped_input)"
        # ...no arguments, capture such output without running a command.
        # Duplicate the behavior of the output capturing below by printing such
        # output to standard error.
#       if is_no_args; then
#           set_string_to_piped_input output
#           output_paged "${output}"
        # ...at least one argument, run such arguments as a command and pipe the
        # input piped to this function to such command. See below for details.
#       else
            #FIXME: Not quite right. Revise run() to implicitly check for piped
            #input and, if available, to close such input after use. That would
            #condense the following two conditional blocks into one.
#           run_with_piped_input run "${@}" 1>&1 1>&2 2>&1 |
#               output_paged_if_exceeds_terminal_dimensions
#           output="$(run_with_piped_input run "${@}" 1>&1 1>&2 2>&1)"

            # Per the "CAVEAT" described under Zeshy Pipe, manually ensure
            # is_piped_input() now returns false.
#           close_standard_input
#       fi
    #FIXME: Hmm; the documentation no longer reflects the reality. Fixmeup.
    # Otherwise, run the passed command with redirection. Dismantled, this is:
    #
    # * "2>&2", preserving standard error prior to its subsequent redirection.
    # * "2>&1", redirecting standard error to output. Since command substitution
    #   only captures the latter, only such redirection captures standard error.
    # * "1>&1", preserving standard output prior to its subsequent redirection.
    # * "1>&2", redirecting standard output to error. Since command substitution
    #   only captures the former, this immediately prints all output produced by
    #   running such command.
#   else
#       die_unless_args 'expected one command'
#       output "run_paged: ${@}..."
#       run "${@}" 1>&1 1>&2 2>&1 | output_paged_if_exceeds_terminal_dimensions
#   fi
#           die_if_args 'expected no command when passed piped input'
#           output="$(get_piped_input)"
#           outcry "${output}"
#           output_paged_if_exceeds_terminal_dimensions "${output}"

#FIXME: Woops! We've dramatically simplified this by now paging on *ANY*
#line wrapping. That means we know longer need to determine displayed page
#length. Clean up documentation.
#FIXME: Actually, while this is decent, it'd be far better to:
#
#* Revert back to the prior logic of only paging when total displayed line
#  length exceeds terminal height *AND*
#   noop "${PAGER:="$(get_first_command_path less more)"}"

#   integer terminal_width_plus_one
#   (( terminal_width_plus_one = terminal_width + 1 ))
    # * Wrapping Accounting for line wrapping 
    # * Output width (i.e., the length of the longest output line) exceeds
    #   terminal width.
    # Accumulate wrapped line height and maximum line width until either exceeds
    # terminal height or width, at which point we know we need to page.#       (( text_height > terminal_height or
#          text_width  > terminal_width )) and break
#       output "line (width: ${text_width}) ${line}"
#       (( text_width > terminal_width )) and break
#   (( text_height > terminal_height or
#      text_width  > terminal_width  )) or return_true
