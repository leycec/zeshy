#!/usr/bin/env zsh
# ====================[ locale                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handling the current user's preferred locale (i.e., environment variables
# defining language, location, country, and culture preferences).
#
# --------------------( SEE ALSO                           )--------------------
# http://pubs.opengroup.org/onlinepubs/007908799/xbd/envvar.html
#     Documents all canonical locale environment variables (e.g., ${LC_ALL}).
#
# --------------------( TODO                               )--------------------
# * It'd be great to begin providing hooks for a Zeshy message catalog of
#   internationalized messages (e.g., errors, warnings, headers). I note that,
#   while there's little to no Zsh-specific content on i18n, Bash-specific
#   content is of growing interest: e.g.,
#   http://www.linuxjournal.com/content/internationalizing-those-bash-scripts
#   The key takeaway appears to be ".po" (Portable Object)-format files
#   consisting of a fairly awkward key-value driven textual syntax:
#
#       File: en.po
#       msgid "Main Greeting"
#       msgstr "Welcome, what do you want to do today?"
#       msgid "Missing File Error"
#       msgstr "File Not Found"
#
#   Executing the "msgfmt" command converts such human-readable text files to a
#   machine-readable binary format whose filename is in a format referred to as
#   a "text domain." Each application defines its own "text domain" hopefully
#   globally unique to that application, to avoid conflicts with other installed
#   ".mo" files when installed under system-wide paths. In our case, the "text
#   domain" is simply "zeshy": e.g.,
#
#       # Generate the machine-readable ".mo" file from the human-readable
#       # ".po" file above.
#       msgfmt -o zeshy.mo en.po
#       # Install such file to a system-recognized path.
#       cp -p zeshy.zsh.mo $HOME/locale/en/LC_MESSAGES/
#
#   System-wide ".mo" files reside under "/usr/share/locale" on Gentoo systems,
#   for example. Ah; nice. Looks like we set application-specific text domains
#   like so, thus avoiding installation in such system-specific paths:
#
#       global_string TEXTDOMAIN='zeshy'
#       global_string TEXTDOMAINDIR="${ZESHY_HOME}/locale"
#
#   Ah. Actually, we probably shouldn't set that. Zeshy is an application
#   wrapper; individual Zeshy applications could be expected to set such globals,
#   thus conflicting with Zeshy use. Instead, just pass such strings as hard-
#   coded options to every call of "gettext" and "ngettext". (Nice!)
#
#   So, Zeshy'll need a new top-level "locale" directory with structure like
#   that of "/usr/share/locale". We'll also want to auto-generate such directory
#   on any change to *ANY* underlying ".po" file if in debug mode (since the
#   current locale may be changed while running Zeshy without restarting Zeshy).
#
#   Actually using such strings is equally simple. Run "gettext", which
#   implicitly opens the ".mo" file corresponding to the current locale and
#   retrieves the string corresponding to the passed key:
#
#       # If the current locale is English, print:
#       #     "Welcome, what do you want to do today?"
#       gettext -s "Main Greeting"
#
#   Mmmmm. Intriguing. Bash (and presumably Zsh) appear to offer a convient
#   language-centric wrapper around "gettext": $"..." and $'...'. If the
#   embedded string is a key contained by the ".mo" file for this text domain,
#   Bash substitutes such string with the corresponding value; otherwise, Bash
#   ignores the prefixing '$' character and expands such string as is. Uhm. Hm!
#   GNU *STRONGLY DISCOURAGES* such usage due to security and portability flaws:
#       https://www.gnu.org/software/gettext/manual/html_node/bash.html
#
#   Interesting. "gettext" distributes a "gettext.sh" script defining a few
#   helper functions, documented here:
#       https://www.gnu.org/software/gettext/manual/gettext.html
#
#   The "Preparing Shell Scripts for Internationalization" section recommends to
#   "Simplify translatable strings so that they don't contain command substitution
#    ("`...`" or "$(...)"), variable access with defaulting (like
#    ${variable-default}), access to positional arguments (like $0, $1, ...) or
#    highly volatile shell variables (like $?)." In other words, interpolated
#    variables must have purely alphabetic names. I'm fairly certain we adhere
#    to such suggests everywhere, except in a few exception error messages where
#    we interpolate in "${1}" or "${2}". *shrug*
#
#   For strings interpolating no variables, calling "gettext" suffices (as above).
#   For strings interpolating at least one variable, we'll need to call the
#   eval_gettext() defined by the gettext.sh script. Actually, let's just rip
#   that function definition into a new Zeshy-specific eval_gettext() function.
#   Interestingly, this implies the msgid key actually contains the desired
#   "$"-prefixed variable names, which will naturally be interpolated into such
#   string *AFTER* mapping to the desired msgstr value.
#
#   Interesting: strings requiring plural handling use "ngettext" and
#   eval_ngettext(), instead. Quite a bit to read up on, here!
#
#   We should be able to write a single function encapsulating the above four
#   commands: e.g.,
#
#   * If passed no plurality parameters and:
#     * If passed a msgid matching *'$'*, call eval_gettext() (or the Zeshy
#       equivalent thereof).
#     * Else, run "gettext".
#   * Else:
#     * If passed a msgid matching *'$'*, call eval_ngettext() (or the Zeshy
#       equivalent thereof).
#     * Else, run "ngettext".
# * Right. So, regardless of the low-level interface discussed above, the high-
#   level interface should be encapsulated by the following three functions:
#
#   void die_localized(string error_msgid, string text_domain = 'zeshy', string text_domain_dirname = "${ZESHY_HOME}/locale")
#   void curse_localized(string warning_msgid, string text_domain = 'zeshy', string text_domain_dirname = "${ZESHY_HOME}/locale")
#   void utter_localized(string info_msgid, string text_domain = 'zeshy', string text_domain_dirname = "${ZESHY_HOME}/locale")
#
#   Fairly self-explanatory. Zeshy scripts are welcome to pass script-specific
#   text domains and dirnames (and probably define helper functions of their
#   own); Zeshy functions, on the other hand, merely call such functions as is,
#   relying on the default values to provide sensible behavior.
#
#   Also, I note most of the above examples to equate the default English msgid
#   and msgstr. This is, of course, terrible. The msgids passed to the above
#   functions should *ALWAYS* be concise descriptors, perhaps simply the name
#   of the calling function or component for language-agnostic behavior: e.g.,
#
#   function im_gonna_die() {
#       # Print the error message with msgid "im_gonna_die".
#       die_localized 'im_gonna_die'
#   }
#
#   Sweet. I reckon that covers things, yes?

# ....................{ EXCEPTIONS                         }....................
# void die_unless_locale(
#   string locale,
#   string error_message = "\"${locale}\" not an installed locale")
#
# Throw an exception unless the passed locale is available under the current
# system.
function die_unless_locale() {
    die_unless_one_or_two_args 'expected one locale and optional error message'
    string locale="${1}"
    is_locale "${locale}" or die "${2:-\"${locale}\" not an installed locale}"
}

# ....................{ TESTS                              }....................
# boolean is_locale(string locale)
#
# Return true if the passed locale is available under the current system. Such
# locales are typically installed on installing (or upgrading) "glibc" or
# running corresponding utilities (e.g., "localegen" under Gentoo).
function is_locale() {
    #FIXME: Does "uclibc" install a comparable command?
    # "glibc" installs "locale", which when run with option "-a" lists all
    # available locales in newline-delimited format. Since alternative C
    # libraries (e.g., "uclibc") are unlikely to install such command, throw an
    # exception unless "locale" is currently installed.
    die_unless_one_arg 'expected one locale'
    die_unless_installed locale
    locale -a | is_string_contains_line "${1}"
}

# boolean is_character_locale_encoding_utf8(void)
#
# Return true if the current user's character locale enables UTF-8 encoding.
function is_character_locale_encoding_utf8() {
    # Validate sanity.
    die_if_args

    # The current character locale enables UTF-8 encoding if suffixed by either
    # ".utf8" (the canonical UTF-8 encoding name) or ".UTF-8" (a non-canonical
    # common alias of ".utf8").
    string character_locale; character_locale="$(get_character_locale)"
    is "${character_locale}" == *'.'('utf8'|'UTF-8') si
}

# ....................{ GETTERS                            }....................
# string get_character_locale(void)
#
# Get the current user's character locale (i.e., the ${LC_CTYPE} environment
# variable). Applications use such locale to ascertain:
#
# * Input and output character encodings (e.g., UTF-8, US-ASCII).
# * Regular expression character classes (e.g., [[:alpha:]], [[:space:]]).
#
# See set_locale() for further details on the format of such string.
function get_character_locale() {
    # ${LC_ALL} supersedes ${LC_CTYPE} superseding ${LANG} for purposes of
    # ascertaining the character locale, according to:
    #
    #     http://rosettacode.org/wiki/Terminal_control/Unicode_output
    #
    # Specifically:
    #
    # * If ${LC_ALL} is set, it overrides all other locale globals.
    # * Else if ${LC_CTYPE} is set, it provides the desired value.
    # * Else if ${LANG} is set, it provides a default value for unset locale
    #   globals and hence ${LC_CTYPE}.
    # * Otherwise, the default locale is always the "C" locale.
    die_if_args
    get_first_nonempty_variable_value_or "C" LC_ALL LC_CTYPE LANG
}

# ....................{ SETTERS                            }....................
# void set_locale(string locale)
#
# Set the current user's locale to the passed locale specifier of the format
# "${language_code}_${country_code}.${encoding_code}", where:
#
# * "${language_code}" is two lowercase letters signifying such language (e.g.,
#   "en" for English, "fr" for French).
# * "${country_code}" is two uppercase letters signifying such country (e.g.,
#   "AU" for Australia, "CA" for Canada).
# * "${encoding_code}" is one or more letters signifying such encoding (e.g.,
#   "UTF-8" for UTF-8).
function set_locale() {
    die_unless_one_arg 'expected one locale'
    string locale="${1}"
    die_unless_locale "${locale}"
    global_string LC_ALL="${locale}"
}

# ....................{ PRINTERS                           }....................
# string print_locale(void)
#
# Print a human-readable synopsis of the current locale.
function print_locale() {
    #FIXME: "locale" output is not terribly helpful. Annotating such output
    #with human-readable labels would be helpful. Actually... depending on
    #"locale" is a tad silly, here. Since it refuses to print human-readable
    #output, let's do so in its stead.
    die_if_args
    die_unless_installed locale
    locale
}

# --------------------( WASTELANDS                         )--------------------
#   if is_nonempty LC_ALL
#   then sputter ${LC_ALL}
#   elif is_nonempty LC_CTYPE
#   then sputter ${LC_CTYPE}
#   elif is_nonempty LANG
#   then sputter ${LANG}
#   else die 'environment variables "LC_ALL", "LC_CTYPE", and "LANG" either not defined or empty'
#   fi

    #FIXME: We *REALLY* want to verify the passed string is a valid locale
    #under the current system, since we're not actually calling a command. How?
# While the Linux community appears to prefer the
# former, enough systems use the latter to necessitate matching both.#
