#!/usr/bin/env zsh
# ====================[ theme                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle themed interactive user input.

# ....................{ NULL                               }....................
# void ask_any_key(string prompt = "press any key to continue.\n")
#
# Ask the current user to type a single character. This function blocks until
# the user does so and then returns true.
ask_any_key() {
    # Validate passed arguments and print the passed prompt .
    die_unless_args_0_to_1 'expected optional prompt'
    die_unless_shell_interactive
    say_no_newline "${1:-press any key to continue.\n}"

    # Block on single-character user input, printing a trailing newline unless
    # the user input a newline.
    string answer; answer="$(get_input_character)"
    is "${answer}" == '\n' si or print_newline
}

# ....................{ BOOLEANS                           }....................
# boolean ask_boolean(string question)
#
# Ask the current user a yes or no question suffixed by "[yn]", returning false
# unless the user responds with either "y" or "Y".
ask_boolean() {
    die_unless_args_1 'expected one question'
    die_unless_shell_interactive
    say_no_newline "${1} [yn] "
    is_input_character_y_or_Y
}

# boolean ask_boolean_strongly(string question)
#
# Ask the current user a yes or no question suffixed by "[YES/no]", returning
# false unless the user responds with exactly "YES". This stringent alternative
# to ask_boolean() is intended for questions whose affirmation carries
# potentially harmful consequences (e.g., data loss).
ask_boolean_strongly() {
    # Validate passed arguments and print the passed prompt.
    die_unless_args_1 'expected one question'
    die_unless_shell_interactive
    say_no_newline "${1} [YES/no] "

    # Block on newline-delimited user input.
    string answer; answer="$(get_input_line)"
    is "${answer}" == 'YES' si
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Prefix prompts with "$(get_call_stack_root_basename): ", much like say() functions.

# string ask_boolean(string question, string choices = 'yn', string true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#ask_boolean() {
#    die_unless_args 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    msay "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one
#    read   answer
#    is "${answer}" == "${true_answer}" si
#}
