#!/usr/bin/env zsh
# ====================[ terminal                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Terminal, handling terminal emulation attributes (e.g., VT100).
#
# --------------------( CAVEATS                            )--------------------
# All functions defined by this component operate on file descriptors. Since
# subshells do not inherit file descriptors attached to terminal devices, some
# functions do not behave as expected when called from subshells: e.g.,
#
#    >>> is_terminal and print "Firefly Class"
#    Firefly Class
#    >>> $(is_terminal or print "Universal Alliance")
#    Universal Alliance
#
# Avoid calling functions from subshells, where feasible.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_terminal(string error_message = 'not a terminal')
#
# Raise an exception unless shell output is attached to a terminal device.
die_unless_terminal() {
    die_unless_at_most_one_arg 'expected optional error message'
    is_terminal or die "${1:-not attached to a terminal device}"
}

# ....................{ TESTS                              }....................
# boolean is_terminal(void)
#
# Return true if shell output is attached to a terminal device.
is_terminal() {
    # Return true if the file descriptor for standard output is open and
    # attached to a terminal. (Avoid testing standard input, as commands passed
    # piped input may still be attached to a terminal.)
    die_if_args
    is -t ${ZESHY_STDOUT} si
}

# ....................{ GETTERS                            }....................
# integer get_terminal_height(void)
#
# Get the height in lines of the current terminal device.
get_terminal_height() {
    die_if_args
    sputter "${LINES}"  # also gettable with "tput lines", but overkill
}

# integer get_terminal_width(void)
#
# Get the width in characters of the current terminal device.
get_terminal_width() {
    die_if_args
    sputter "${COLUMNS}"  # also gettable with "tput columns", but overkill
}

# ....................{ GETTERS ~ lines                    }....................
#FIXME: Rename get_wrapped_line_height(). Unsure it's used anywhere, anyway.
# integer get_displayed_line_length(string text1, string text2, ...)
#
# Get the total number of lines in the passed strings when displayed on the
# current terminal (i.e., accounting for long lines). This is a number strictly
# greater than or equal to that returned by get_line_length().
get_displayed_line_length() {
    # Validate passed arguments.
    die_unless_args 'expected at least one string'
    integer displayed_line_length terminal_width
    terminal_width_plus_one=$(get_terminal_width)
    (( ++terminal_width_plus_one ))

    # For each line of the passed string, increment line length by the sum of:
    #
    # * "1", for the physical trailing newline.
    # * The number of logical newlines Zsh injects into such string for wrapping
    #   purposes, calculated as the physical line length divided by terminal
    #   width (i.e., maximum logical line length). Add 1 to avoid off-by-one.
    for line ("${(f)@}") {
        (( displayed_line_length += 1 + (${#line} / terminal_width) ))
    }

    # Return such length.
    sputter ${displayed_line_length}
}

#FIXME: Provide additional terminfo-based capabilities. See "man terminfo".
# ....................{ WRITERS                            }....................
# void clear_terminal_screen(void)
#
# Clear the current terminal of all prior output. This function implements a
# pure-Zsh analogue of the "clear" command.
clear_terminal_screen() {
    die_if_args
    die_unless_terminal

    # Oddly, the terminfo "clear" capability moves the cursor to the second
    # rather than first line after clearing the screen. Amend this.
    echoti clear
    move_terminal_cursor_to 1 1
}

#FIXME: Add support for negative index offsets.
# void move_terminal_cursor_to(integer column, integer row)
#
# Move the cursor on the current terminal to the passed 1-based column and row
# indices.
move_terminal_cursor_to() {
    # Validate passed arguments.
    die_unless_two_args 'expected one column and one row index'
    die_unless_terminal
    die_unless_nonnegative_decimal "${1}"
    die_unless_nonnegative_decimal "${2}"
    integer column="${1}" row="${2}"
    (( column <= $(get_terminal_width) )) or die\
        "column ${column} exceeds terminal width $(get_terminal_width)"
    (( row <= $(get_terminal_height) )) or die\
        "row ${row} exceeds terminal height $(get_terminal_height)"

    # Convert Zsh-style 1-based indices to "terminfo"-style 0-based indices.
    echoti cup $(( row - 1 )) $(( column - 1 ))
}

# ....................{ SETUP                              }....................
setup_terminal() {
    die_if_args
    die_unless_terminal
    setup_terminal_options
    setup_terminal_colors
}

setup_terminal_options() {
    # Permit use of meta characters (i.e., characters setting the high bit).
    set meta-flag    on
    set input-meta   on
    set output-meta  on
    set convert-meta off

    # Numerous applications complain under long ${TERM} strings (e.g.,
    # "rtorrent"). Truncate such strings to equivalent abbreviations.
    is "${TERM}" == 'rxvt-unicode-256color' si and {
        utter 'truncating ${TERM} to "rxvt-unicode" for safety...'
        TERM='rxvt-unicode'
    }
}

# --------------------( WASTELANDS                         )--------------------
