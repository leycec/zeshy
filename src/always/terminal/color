#!/usr/bin/env zsh
# ====================[ color                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle ANSI and Zsh color codes.
#
# --------------------( SEE ALSO                           )--------------------
# https://en.wikipedia.org/wiki/ANSI_escape_code
#   Excrutiatingly helpful dissection of ANSI escape codes.
#
# http://ciembor.github.com/4bit
#   4bit, arguably the best and probably only terminal color scheme designer.
#
# --------------------( TODO                               )--------------------
# * Add support for fish-like syntax highlighting. Happily, someone's already
#   gone to the work of Zshifying this; we'll just want to Zeshify it a bit:
#   https://github.com/zsh-users/zsh-syntax-highlighting
# * Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#   urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#   some Zsh code the other day simplifying such support... Hmmmmmmmm.
# * It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#   https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors

# ....................{ TESTS                              }....................
# boolean is_color_terminal(void)
#
# Return true if shell output is attached to a polychrome terminal device (i.e.,
# a terminal device providing more than merely monochrome black and white).
is_color_terminal() {
    die_if_args
    is_shell_terminal and (( $(get_terminal_color_count) > 2 ))
}

# ....................{ GETTERS                            }....................
# integer get_terminal_color_count(void)
#
# Get the number of colors supported by the current terminal device.
get_terminal_color_count() {
    die_if_args  # also gettable with "echotc Co", but overkill
    output "${terminfo[colors]}"
}

# ....................{ REMOVERS                           }....................
# string remove_string_ansi_color_codes(string text)
#
# Remove all ANSI color codes from the passed string. The resulting string will
# retain non-color ANSI escapes (e.g., "\033[J", clearing from the current
# cursor to the end of the screen).
remove_string_ansi_color_codes() {
    die_unless_args 'expected at least one string'
    output "${*//${ZESHY_ANSI_COLOR_CODE_GLOB_CSI}${~ZESHY_ANSI_COLOR_CODE_GLOB_SGR}/}"
}

# string remove_string_zsh_color_codes(string text)
#
# Remove all Zsh color codes from the passed string. The resulting string will
# retain non-color prompt escapes (e.g., "%D", expanding to the current date).
remove_string_zsh_color_codes() {
    die_unless_args 'expected at least one string'
    output "${*//${~ZESHY_ZSH_COLOR_CODE_GLOB}/}"
}

# ....................{ SETUP                              }....................
#FIXME: It'd be nice to avoid having to setup colors. I wonder if, rather than
#requiring setup_terminal_colors() be called on startup, we couldn't switch to
#expanding colors by calling color-named functions: e.g., "$(FG_WHITE_BOLD)", or
#perhaps "$(fg white bold)" or "$(get_foreground_bold_color white)". In any
#case, such functions initialize internal color structures if necessary and
#proceed on their way. This is inherently more robust, since of course nothing
#precludes users from setting "FG_WHITE_BOLD='nonsense!!!!uhoh%P%YYDYDYD%D'"
#externally, at the moment. Yes, I rather like the
#"$(get_foreground_bold_color white)" idea. Make it so, good sir! If efficiency
#actually mattered, such verbosity would be a poor idea. But it absolutely
#doesn't, so...

# void setup_terminal_colors()
#
# Define colors only under color-aware terminals. When under color-unaware
# terminals, the variables below are left undefined and thus expand without
# error to nothing when evaluated in the context of an actual prompt.
setup_terminal_colors() {
    # Validate sanity.
    die_if_args
    setup_terminal_color_globs

    #FIXME: Incorrect. If not a terminal, we still need to define such globals
    #to the empty string, to simplify use elsewhere. (The caller shouldn't have
    #to care, in other words.) We probably want to implement three helper
    #functions resembling:
    #
    #* setup_terminal_no_colors(), if no color support.
    #* setup_terminal_8_colors(), if typical color support.
    #* setup_terminal_256_colors(), if 256 color support.
#   is_color_terminal or return_true
#   get_terminal_color_count
    setup_terminal_8_colors
}

# void setup_terminal_color_globs()
#
# Define globs for matching color codes in various formats.
setup_terminal_color_globs() {
    # Dismantled, this is:
    #
    # * $'\E\[', matching the 2-byte ANSI Control Sequence Introducer (CSI)
    #   identical to "<Esc>[" signifying an ANSI escape code.
    # * (...)m", matching zero or more Select Graphic Rendition (SGR)
    #   parameters also referred to as color indices:
    #   * "|", matching the empty string and hence the ANSI escape code
    #     "CSI m" identical to "<Esc>[0m" resetting all SGR parameters.
    #   * "[0-9](#c1,3)", matching an 8-bit integer expressed as one to three
    #     digits as the first SGR parameter.
    #   * "(;[0-9](#c1,3))##", matching zero or more sequences of a semicolon
    #     followed by an 8-bit integer as all following SGR parameters.
    #
    # Unfortunately, Zsh fails with a "bad pattern" error when we aggregate the
    # CSI and SGR into a single glob. Separate such globs until solving this.
    global_string\
        ZESHY_ANSI_COLOR_CODE_GLOB_CSI=$'\E\['\
        ZESHY_ANSI_COLOR_CODE_GLOB_SGR='(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'

    # Dismantled, this is:
    #
    # * "%(...)", matching a "%"-prefixed prompt escape.
    # * "[BbSsUu]", matching a bold, standout, or underline parameter.
    # * "[0-9]##[FfKk]", matching a fore- or background parameter prefixed by
    #   integer argument consisting of one or more digits.
    # * "[FfKk]\{?*\}", matching a fore- or background parameter suffixed by:
    #   * String argument consisting of a well-known color name (e.g., "red").
    #   * Integer argument consisting of one or more digits.
    global_string\
        ZESHY_ZSH_COLOR_CODE_GLOB='%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'
}

setup_terminal_8_colors() {
    # Colorize "ls" by importing the ${LS_COLORS} global.
    is_installed dircolors and
        source_shell_script_command_output 'sh' 'dircolors --sh'

    # Declare color-specific dictionaries: $fg, $fg_bold, $fg_no_bold, $bg,
    # $bg_bold, and $bg_no_bold. In each such dictionary, keys are color
    # names (e.g., "red") and values terminal-specific strings activating that
    # color combination under the current output.
    colors

    # Surround each color definition in "%{...%}"; this informs ZSH that, when
    # performing prompt expansion, these strings do not contribute to the length
    # of that prompt.
    string color_name_lowercase_string
    for color_name (WHITE BLACK RED GREEN BLUE YELLOW MAGENTA CYAN) {
        color_name_lowercase_string="$(lowercase_string ${color_name})"
        eval "global_string\
            FG_${color_name}='%{${fg_no_bold[${color_name_lowercase_string}]}%}'\
            FG_${color_name}_BOLD='%{${fg_bold[${color_name_lowercase_string}]}%}'\
            BG_${color_name}='%{${bg_no_bold[${color_name_lowercase_string}]}%}'\
            BG_${color_name}_BOLD='%{${bg_bold[${color_name_lowercase_string}]}%}'"
#           eval global_string FG_${color_name}='%{$fg_no_bold[${(L)color_name}]%}'
#           eval global_string FG_${color_name}_BOLD='%{$fg_bold[${(L)color_name}]%}'
#           eval global_string BG_${color_name}='%{$bg_no_bold[${(L)color_name}]%}'
#           eval global_string BG_${color_name}_BOLD='%{$bg_bold[${(L)color_name}]%}'
    }

    # Define hard-coded ANSI color codes for use below.
    integer ansi_black=0 ansi_white=7 ansi_intense=9

    # Define reset "colors" (i.e., resetting colors to their defaults).
    global_string FG_RESET="%{${reset_color}%}" BG_RESET="%{${reset_color}%}"

    # Redefine foreground greyscale colors. The above definitions assign
    # FG_BLACK a somewhat unreadable pure-black color value and FG_WHITE a
    # grey rather than white color value.
    #
    # Note: the substring "$'\033['" cannot be interpolated into the prior
    # and subsequent strings as "\$\033[". (We can't recall why; do you?)
    global_string\
        FG_BLACK="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_black}m%}"\
        FG_WHITE="${FG_RESET}%{"$'\033['"${ansi_intense}${ansi_white}m%}"\
        FG_WHITE_BOLD="%{${fg_bold[white]}%}"\
        FG_GREY="%{${fg_no_bold[white]}%}"\
        FG_GREY_BOLD="${FG_WHITE}"
#           FG_GREY_BOLD="%{${fg_bold[black]}%}"
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ GETTERS ~ globs                    }....................
# string get_ansi_color_code_glob(void)
#
# Get an extended glob matching ANSI color codes.
#get_ansi_color_code_glob() {
#    die_if_args
#    output '\x1B\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#}

# string get_zsh_color_code_glob(void)
#
# Get an extended glob matching Zsh color codes. See "Prompt Expansion" under
# "info zsh" for further details.
#get_zsh_color_code_glob() {
#    die_if_args
#    output '%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'
#}

#   string ansi_color_code_glob
#   ansi_color_code_glob="$(get_ansi_color_code_glob)"
#   string test="$'\E\['(|[0-9](#c1,3)(;[0-9](#c1,3))##)m"
#   string test="$'\E\['"
#   output "glob: $test"
#   output "${*//${~ZESHY_ANSI_COLOR_CODE_GLOB}/}"
#   output "${*//$'\E\[((|[0-9](#c1,3)(;[0-9](#c1,3))##)m'/}"
#   output "${*//$'\E\['(|[0-9](#c1,3)(;[0-9](#c1,3))##)m/}"
#   output "${*//$'\E'/}"
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB_SGR='(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB='\x1B\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB='\033\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB="\$'\E'"'\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB=$'\E\['"(|[0-9](#c1,3)(;[0-9](#c1,3))##)m"
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB="\\033"
#   global_string ZESHY_ANSI_COLOR_CODE_GLOB="\E"
    # Cache the ANSI color glob to a global variable, if not already cached.
#   set_string_if_unset_or_empty_to_evaluation\
#       ZESHY_ANSI_COLOR_CODE_GLOB '$(get_ansi_color_code_glob)'
    # Cache the ZSH color glob to a global variable, if not already cached.
#   set_string_if_unset_or_empty_to_evaluation\
#       ZESHY_ZSH_COLOR_CODE_GLOB '$(get_ansi_color_code_glob)'
#   noop "${ZESHY_ZSH_COLOR_CODE_GLOB=$(get_zsh_color_code_glob)}"
#   output "${1//${~ZESHY_ANSI_COLOR_CODE_GLOB}}"
#   output "${1//${~ZESHY_ZSH_COLOR_CODE_GLOB}}"

#FIXME: Such globs are unlikely to change during runtime. (What would that even
#mean?) They should be cached to global variables for efficiency.
#   string glob; glob="$(get_ansi_color_code_glob)"
#   output "${1//${~glob}}"
#   string glob; glob="$(get_zsh_color_code_glob)"
#   output "${1//${~glob}}"
# ....................{ GETTERS ~ lines                    }....................
#FIXME: Shift to Zeshy String.
#get_string_line_length_excluding_zsh_color_codes() {
    #FIXME: Raise exception if the passed string contains a newline. We should
    #probably extricate the core logic into a separate remove_zsh_color_codes().
#    die_unless_one_arg 'expected one string'
#    string glob; glob="$(get_zsh_color_code_glob)"
#    output ${#${(S%%)1//${~glob}}
#}

#   output "${1//\x1B\[([0-9](#c1,2)(;[0-9](#c1,2))(#c0,1))(#c0,1)m}"
#   output "${1//\x1B\[([0-9](#c1,2)(;[0-9](#c1,2))(#c0,1))(#c0,1)[m|K]}"
# least the eight customary shell colors: black, white, red, green, blue,
# yellow, magenta, and cyan.
    # Do not call die_unless_shell_terminal(), as subshells have no terminals.
    # Do not call die_unless_shell_terminal(), as subshells have no terminals.
# Avoid calling this function from a subshell (e.g.,
# "$(is_shell_terminal and print ok)"), as subshells cannot test the file descriptors
# of their parent shells.    #* setup_terminal_colors_to_monochrome(), if no color support.

    #* setup_terminal_colors_to_8_color_polychrome(), if typical color support.
    #* setup_terminal_colors_to_256_color_polychrome(), if 256 color support.
    # Exit status of this command.
#   string output; output="$(run "${(q)@}" 1>&1 1>&2)" or exit_status=${?}
#   integer exit_status="${?}"
#   string output="$(eval "${(q)@}" 1>&1 1>&2)"
#   string output="$((eval "${@}") 1>&1 1>&2)"
#   say "running: ${*}"
#   say "output: ${output}"
#   msay 'line_length: '; printeger $(get_string_line_length "${output}")
#   say "terminal_height: $(get_terminal_height)"

    # Return the exit status of this command.
#   false
#   say "running: ${*}"
#   return "${exit_status}"

#FIXME: We currently define the "LESS" global (probably in "zshrc"), defining
#global "less" options. Shift to Zeshy "config", renamed to
#"ZESHY_PAGER_OPTIONS", and explicitly apply such global below. (We don't need
#interactive and non-interactive forms, obviously -- it's always interactive!)

        #FIXME: Ugh. This should just go into "ZESHY_PAGER_OPTIONS", clearly.
        # If "less" is the current pager, pass the following options:
        #
        # * "--no-init", avoiding clearing the screen on initialization.
#       if is "${PAGER}" == less si
#       then pager+=( '--no-init' )
#       fi

#   string output="$(run_with_unified_output "${@}")"
#   say "output: ${output}"
    # Otherwise, printeger as is.
#   else
#       printeger "${output}" 
#   fi

#   printeger "page command line: ${*}"
#   printeger "page second arg: ${2}"
#   run "${(q)@} 2>&1 | '${PAGER:-less}'"

# string ask_boolean(string question, string choices = 'yn', string true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#ask_boolean() {
#    die_unless_at_least_one_arg 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    msay "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one 
#    read   answer
#    is "${answer}" == "${true_answer}" si
#} 

#emulate -R sh -c 'eval "$(dircolors --sh)"'
# Dismantled, this is:
        # * "(L}", lowercasing the current color name. The maps colors() defines
        #   have lowercase_string rather than uppercase_string keys.

    # Coerce the response to lowercase_string for comparability and compare.
#   is_sure="$(lowercase_string "${is_sure}")"
#   is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si
#
    # Define ANSI colors for the ANSI shell prompt, below.
    #export   PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
    #export    PROMPT_GREY="%{"$'\033[${FG_BLACK}m'"%}"
    #export     PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
    #export   PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
    #export  PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
    #export    PROMPT_BLUE="%{"$'\033[${FG_BLUE_HIGH}m'"%}"
    #export PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
    #export    PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
    #export   PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

    # Define ANSI colors for "print" and "echo" uses, below.
    #export   BLACK="\e[${FG_BLACK_HIGH}m"
    #export     RED="\e[${FG_RED_HIGH}m"
    #export   GREEN="\e[${FG_GREEN_HIGH}m"
    #export  YELLOW="\e[${FG_YELLOW_HIGH}m"
    #export    BLUE="\e[${FG_BLUE}m"
    #export MAGENTA="\e[${FG_MAGENTA_HIGH}m"
    #export    CYAN="\e[${FG_CYAN}m"
    #export   WHITE="\e[${FG_WHITE}m"
    #export    BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
    #export  NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
    #export   RESET="\e[${FG_RESET}m"
# ....................{ STREAMS                            }....................
# Load the "colors" module. This defines the function "colors" that, when
# called, itself defines in excess of six associative arrays: $fg, $fg_bold,
# $fg_no_bold, $bg, $bg_bold, and $bg_no_bold. Each array, when indexed by
# color name (e.g., $bg_bold{red}), further expands to the terminal-specific
# string activating that color combination under the current output.
#autoload -U colors

#FIXME: Causes the "su" command to fail to output its data. Hm; obviously, this
#is a flawed approach. Research alternatives.
# Color all debug, warning, and error output for all processes: in particular,
# color all output sent by each process to the process-specific stderr "file".
#exec 2>>(\
#    while read LINE; do \
#        printeger -P "${FG_RED_BOLD}${(q)LINE}${FG_RESET}" > '/dev/tty'; \
#        printeger -n $'\0'; \
#    done &)

# ....................{ COLORS                             }....................
# See "http://en.wikipedia.org/wiki/ANSI_escape_code", for further details.

# Color bases.
#  BASE_BLACK="0"
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    BASE_RED="1"
#  BASE_GREEN="2"
# BASE_YELLOW="3"
#   BASE_BLUE="4"
#BASE_MAGENTA="5"
#   BASE_CYAN="6"
#  BASE_WHITE="7"
#  BASE_RESET="9"

# Color foregrounds.
#  FG_BLACK="3${BASE_BLACK}"
#    FG_RED="3${BASE_RED}"
#  FG_GREEN="3${BASE_GREEN}"
# FG_YELLOW="3${BASE_YELLOW}"
#   FG_BLUE="3${BASE_BLUE}"
#FG_MAGENTA="3${BASE_MAGENTA}"
#   FG_CYAN="3${BASE_CYAN}"
#  FG_WHITE="3${BASE_WHITE}"
#  FG_RESET="3${BASE_RESET}"

# Color backgrounds.
#  BG_BLACK="4${BASE_BLACK}"
#    BG_RED="4${BASE_RED}"
#  BG_GREEN="4${BASE_GREEN}"
# BG_YELLOW="4${BASE_YELLOW}"
#   BG_BLUE="4${BASE_BLUE}"
#BG_MAGENTA="4${BASE_MAGENTA}"
#   BG_CYAN="4${BASE_CYAN}"
#  BG_WHITE="4${BASE_WHITE}"
#  BG_RESET="4${BASE_RESET}"

# Color foregrounds (high intensity).
#  FG_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    FG_RED_HIGH="9${BASE_RED}"
#  FG_GREEN_HIGH="9${BASE_GREEN}"
# FG_YELLOW_HIGH="9${BASE_YELLOW}"
#   FG_BLUE_HIGH="9${BASE_BLUE}"
#FG_MAGENTA_HIGH="9${BASE_MAGENTA}"
#   FG_CYAN_HIGH="9${BASE_CYAN}"
#  FG_WHITE_HIGH="9${BASE_WHITE}"
#  FG_RESET_HIGH="9${BASE_RESET}"

# Color backgrounds (high intensity).
#  BG_BLACK_HIGH="10${BASE_BLACK}"
#    BG_RED_HIGH="10${BASE_RED}"
#  BG_GREEN_HIGH="10${BASE_GREEN}"
# BG_YELLOW_HIGH="10${BASE_YELLOW}"
#   BG_BLUE_HIGH="10${BASE_BLUE}"
#BG_MAGENTA_HIGH="10${BASE_MAGENTA}"
#   BG_CYAN_HIGH="10${BASE_CYAN}"
#  BG_WHITE_HIGH="10${BASE_WHITE}"
#  BG_RESET_HIGH="10${BASE_RESET}"

# Color attributes.
#           RESET="00"
#INTENSITY_NORMAL="22"
#  INTENSITY_BOLD="01"
# INTENSITY_FAINT="02"
#       ITALIC_ON="03"
#UNDERLINE_SINGLE="04"
#UNDERLINE_DOUBLE="21"
#   UNDERLINE_OFF="24"
#      BLINK_SLOW="05"
#      BLINK_FAST="06"
#       BLINK_OFF="25"
#  IMAGE_NEGATIVE="07"  # inverse (reverse), swapping foreground and background
#  IMAGE_POSITIVE="27"
#         CONCEAL="08"
#          REVEAL="28"

# Define (but do not export) ANSI colors for the ANSI shell prompt, below.
#  PROMPT_BLACK="%{"$'\033[${FG_BLACK_HIGH}m'"%}"
#    PROMPT_RED="%{"$'\033[${FG_RED_HIGH}m'"%}"
#  PROMPT_GREEN="%{"$'\033[${FG_GREEN_HIGH}m'"%}"
# PROMPT_YELLOW="%{"$'\033[${FG_YELLOW_HIGH}m'"%}"
#   PROMPT_BLUE="%{"$'\033[${FG_BLUE}m'"%}"
#PROMPT_MAGENTA="%{"$'\033[${FG_MAGENTA_HIGH}m'"%}"
#   PROMPT_CYAN="%{"$'\033[${FG_CYAN_HIGH}m'"%}"
#  PROMPT_WHITE="%{"$'\033[${FG_WHITE}m'"%}"

# Define (but do not export) ANSI colors for "print" and "echo" uses, below.
#  BLACK="\e[${FG_BLACK_HIGH}m"
#    RED="\e[${FG_RED_HIGH}m"
#  GREEN="\e[${FG_GREEN_HIGH}m"
# YELLOW="\e[${FG_YELLOW_HIGH}m"
#   BLUE="\e[${FG_BLUE}m"
#MAGENTA="\e[${FG_MAGENTA_HIGH}m"
#   CYAN="\e[${FG_CYAN_HIGH}m"
#  WHITE="\e[${FG_WHITE}m"
#   BOLD="\e[${INTENSITY_BOLD};${FG_RESET}m"
# NORMAL="\e[${INTENSITY_NORMAL};${FG_RESET}m"
#  RESET="\e[${FG_RESET}m"
