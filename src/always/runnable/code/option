#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle commands passed user-configured and/or caller-passed lists of options.
-/-

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
string run_code_with_options(
    string command_prefix,
    string options_list_names,
    string command_arg1, string command_arg2, ...)

Run a command dynamically constructed from the passed arguments as follows:

* Split the passed options list names on whitespace into a list of the names of
  all lists with options to be passed to such command (e.g., split
  `ZESHY_GREP_OPTIONS ZESHY_GREP_OPTIONS_IF_RECURSIVE` into a list containing
  `ZESHY_GREP_OPTIONS` and `ZESHY_GREP_OPTIONS_IF_RECURSIVE`).
* Set the command to be run to pipe standard input if this function was piped
  such input or to the empty string otherwise (e.g., `cat /dev/stdin |`).
* Append the passed prefix to such command (e.g., `run_code_paged grep -R`).
* For every list name in such list:
** If such list exists, append all elements of that list to such command.
** Else, throw an exception.
* Append the passed arguments to such command (e.g., `${(q)@}`).
* Run such command (e.g., assuming the caller passed a single argument `Weeds`
  and piped no input and the above options lists contain default elements,
  `run_code_paged grep --extended-regexp --no-messages --recursive 'Weeds'`).

For example:

.run_code_with_options()
==========================================
[source]
------------------------------------------
# Run grep recursively with the passed list of options and user arguments,
# paging standard output if required.
>>> run_code_with_options "run_code_paged command grep"\
...     "ZESHY_GREP_OPTIONS ZESHY_GREP_OPTIONS_IF_RECURSIVE" -- "${(q)@}"
------------------------------------------
==========================================
/---
function run_code_with_options() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'
    string command_prefix__rcwo="${1}"
    list command__rcwo options_list_names__rcwo

    # If passed piped input, propagate such input to the command to be run.
    if { is_stdin_pipe } {
        command__rcwo+=( \< "${ZESHY_STDIN_PATH}" \| )
    }

    # Append such prefix split into shell words to such line.
    command__rcwo+="${(z)command_prefix__rcwo}"

    # Split the whitespace-delimited string of option list names into a list of
    # such names, to be interpolated below.
    set_list_to_string_words options_list_names__rcwo "${2}"
    shift_args 2

    # For each options list name, append the contents of such list to such
    # command or throw a warning if no such list exists.
    string options_list_name__rcwo
    for    options_list_name__rcwo ("${options_list_names__rcwo[@]}") {
        if { is_list "${options_list_name__rcwo}" } {
            command__rcwo+=( "${(@P)options_list_name__rcwo}" )
        } else {
            die "\"${options_list_name__rcwo}\" not a list"
        }
    }

    # Append all remaining passed arguments to such command.
    command__rcwo+=( "${@}" )

    # Run such command.
#   print_string "run_code_with_options: \"${command__rcwo[*]}\"..."
    run_code "${command__rcwo[@]}"
}

#FIXME: Rename to run_code_with_options_configured().
declare_function_with_stdin <<'/---'
string run_code_with_options_configured(
    string command_prefix,
    string options_list_names,
    string command_arg1, string command_arg2, ...)

Run a command dynamically constructed from the passed arguments as under
run_code_with_options() and also appending
` ${list_name_first}_IF_INTERACTIVE` if the current shell is interactive and
` ${list_name_first}_IF_NONINTERACTIVE` otherwise to `${options_list_names}`,
where `${list_name_first}` is the first word in `${options_list_names}`.
/---
function run_code_with_options_configured() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'
    string options_list_name__rcwoc options_list_name_first__rcwoc

    # The first shell word from the list of options list names, comprising the
    # name of the options list to be suffixed below.
    options_list_name_first__rcwoc="$(get_string_word "${2}" 1)"

    # If an options list with name corresponding to whether the current shell is
    # interactive or not exists, append such name to the passed list of such
    # names if such list exists.
    if { is_shell_interactive } {
        options_list_name__rcwoc="${options_list_name_first__rcwoc}_IF_INTERACTIVE"
    } else {
        options_list_name__rcwoc="${options_list_name_first__rcwoc}_IF_NONINTERACTIVE"
    }
    if { is_list "${options_list_name__rcwoc}" } {
        2+=" ${options_list_name__rcwoc}"
    }

    # Run such command.
    run_code_with_options "${@}"
}

# ....................{ RUNNERS ~ silent                   }....................
declare_function_with_stdin <<'/---'
string run_code_silent_with_options(
    string command_prefix,
    string options_list_names,
    string command_arg1, string command_arg2, ...)

Silently run a command dynamically constructed from the passed arguments as
under run_code_with_options() and also appending
` ${list_name_first}_IF_SILENT` and ` ${list_name_first}_IF_NONINTERACTIVE` to
`${options_list_names}`, where `${list_name_first}` is the first shell word in
`${options_list_names}`.
/---
function run_code_silent_with_options() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with run_code_silent_with_options_configured().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'
    string options_list_name_first__rcswo

    # The first shell word from the list of options list names, having the name
    # of the options list to be suffixed below.
    options_list_name_first__rcswo="$(get_string_word "${2}" 1)"

    # For each options list name given below, append such name to the passed
    # list of such names if such list exists.
    string options_list_name_suffix__rcswo options_list_name__rcswo
    for    options_list_name_suffix__rcswo ('_IF_SILENT' '_IF_NONINTERACTIVE') {
        options_list_name__rcswo="${options_list_name_first__rcswo}${options_list_name_suffix__rcswo}"
        if { is_list "${options_list_name__rcswo}" } {
            2+=" ${options_list_name__rcswo}"
        }
    }

    # Run such command. Avoid prepending such command with a call to
    # run_code_silent(), which inadvertently silences error output from
    # run_code_with_options(). Specifically, don't do this:
    #     run_code_silent run_code_with_options "${@}"
    run_code_with_options "${@}" '&>/dev/null'
#   run_code_with_options "${@}"
}

declare_function_with_stdin <<'/---'
string run_code_silent_with_options_configured(
    string command_prefix,
    string options_list_names,
    string command_arg1, string command_arg2, ...)

Silently run a command dynamically constructed from the passed arguments as
under run_code_with_options_configured() and also appending
` ${list_name_first}_IF_SILENT` and ` ${list_name_first}_IF_NONINTERACTIVE` to
`${options_list_names}`, where `${list_name_first}` is the first shell word in
`${options_list_names}`.
/---
function run_code_silent_with_options_configured() {
    # See run_code_silent_with_options() for further details.
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'
    string options_list_name_first__rcswo
    options_list_name_first__rcswo="$(get_string_word "${2}" 1)"
    string options_list_name_suffix__rcswo options_list_name__rcswo
    for    options_list_name_suffix__rcswo ('_IF_SILENT' '_IF_NONINTERACTIVE') {
        options_list_name__rcswo="${options_list_name_first__rcswo}${options_list_name_suffix__rcswo}"
        if { is_list "${options_list_name__rcswo}" } {
            2+=" ${options_list_name__rcswo}"
        }
    }
    run_code_with_options_configured "${@}" '&>/dev/null'
}

# --------------------( WASTELANDS                         )--------------------
#Handle dynamically constructed command lines passed options lists.

#Construct a command from the passed arguments contextually depending on whether
#or not the current shell is interactive; then run such command. To do so, append
#` ${list_name_first}_IF_SHELL_INTERACTIVE` if this shell is interactive or
#` ${list_name_first}_IF_SHELL_NON_INTERACTIVE` otherwise to the passed string of
#list names, where ${list_name_first} is the first list name in such string; then
#call run_code_with_options() on such arguments.
#   is_list "${options_list_name_first__rcwos}_IF_SILENT" and
#       2+=" ${options_list_name_first__rcwos}_IF_SILENT"
#   is_list "${options_list_name_first__rcwos}_IF_NONINTERACTIVE" and
#       2+=" ${options_list_name_first__rcwos}_IF_NONINTERACTIVE"

#Construct a command from the passed arguments; then run such command quietly
#(i.e., with neither terminal output or interactive input). To do so, append
#; then call run_code_with_options() on such arguments
#   options_list_names__rwo+=( '1' )
#   print "list type: ${(t)options_list_names__rwo}"
#   die_unless_list options_list_names__rwo
    # Similarly, avoid prepending such command with a call to
    # run_code_to_stderr(), which... well, I can't quite remember
    # why not. Hmm.
    #
    #     >>> run_code_to_stderr run_code_with_options "${@}"
#   print "running silently: ${*}"
#   for options_list_name__rwos (
#       "${options_list_name_first__rwos}_IF_SILENT"
#       "${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE") {
#       is_list "${options_list_name__rwos}" and
#           2+=" ${options_list_name__rwos}"
#   }
    # Append a non-interactive-specific options list name, regardless of whether
    # the current shell is interactive.
#   2+=" ${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE"

#FUXME: Ah; it's not an objection, more a... curiosity. But how are pipes
#handled in relation to the call stack, exactly? We'd really like one-liners
#such as "ls -o --type=full * | grep -v yumyum | less -o" to work as
#expected. I suspect the shell already handles this correctly by running
#each pipe command as the root of its own call stack in a separate subshell...
#Hmm; but, in that case, such subshells would be marked as non-interactive.
#In any case, we'll just have to test such pipes ourselves and see what zsh
#comes up with. (We should be able to hack it up in our favor, but...)
#FUXME: *NO, NO, NO.* The above heavy-weight solution is horrible. It's
#horribly inefficient. It's horribly complex. It's a big fail. Here's what
#we're going to do instead. It's not pretty, but we have to do it anyway to
#support arbitrary option passing when interactive: for *MOST* functions with
#existing interactive aliases, we need to divert such aliases to a new
#function with name prefixed by "_interactive" accepting arbitrary options
#and *NOT* passing "--". The original non-interactive function must, on the
#other hand, explicitly pass "--". We've already excised the hard-coded "--"
#from this function, so we're good to go. Look: I know it'll be unpleasant,
#but we basically have little choice. It'll probably take two days from
#starting to finishing such revisions.
#
#Example:
#Define a new remove_file_interactively() function. Redefine interactive
#alias "rm" to call such function rather than remove_file(). Do *NOT* change
#the original remove_file(). And...we're good!

#ensure the resulting command
#does *NOT* request input from the current user
