#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle commands passed user-configured and/or caller-passed options.
/---

#FIXME: Substantially improve examples.

# ....................{ SETTERS                            }....................
#FIXME: Rename to set_list_to_lists_and_arg_options:() or perhaps to
#set_list_to_arg_options_and_lists:().
#FIXME: Actually call such function below and elsewhere (e.g., remove_file()).
#FIXME: Actually, we now need new middleware functions
#set_list_to_options_listed_contextual_and_passed() and
#set_list_to_options_listed_silent_and_passed() calling this low-level 
#set_list_to_options_listed_and_passed() function.
#FIXME: Complete documentation...

declare_function_with_stdin <<'/---'
void set_list_to_options_listed_and_passed(
    string target_list_name,
    string source_list_names,
    string arg1?, ...)

Set the passed target list to the concatenation of all items in the passed
source lists (in the passed order) followed by all *options* in the passed arguments.

Set the passed list to the  union of all currently configured and passed *options* (i.e.,
arguments prefixed by `-`, up to but not including an argument `--` denoting the
end of such options) as list keys whose values are the empty string.

== Algorithm ==

This function aggregates such options from the passed arguments as follows:

//FIXME: Not the best approach. More straightforwardly, just document that we
add all elements of such lists as keys of the passed list.

* The passed string of whitespace-delimited options list names is split on
  whitespace into a local list of the names of all lists containing such options
  (e.g., splitting string `ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_RECURSIVE`
  into a list with strings `ZESHY_OPTIONS_GREP` and
  `ZESHY_OPTIONS_GREP_IF_RECURSIVE`).
* For every list name in such list:
** If such list exists, append all elements of that list to such command.
** Else, throw an exception.

== Alternatives ==

While this function could alternatively set a passed map (e.g., for efficient
option lookup and modification), doing so would fail to preserve option order
and repetition. While many commands ignore option order and/or repetition, many
do _not_ (e.g., ImageMagick's `convert`). Hence, only a list-based
implementation provides a general-purpose solution.
/---
function set_list_to_options_listed_and_passed() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one list name, one options list names string, and optional command arguments.'
    string list_name__sltocap="${1}" options_list_names_string__sltocap="${2}"
    list options_list_names__sltocap
    integer arg_option_index_last__sltocap
    die_unless_list "${list_name__sltocap}"
    shift_args_2

    # Split the whitespace-delimited string of option list names into a list of
    # such names, to be interpolated below.
    set_list_to_string_words options_list_names__sltocap\
        "${options_list_names_string__sltocap}"

    # Append all options in such options lists to such list. Since appending to
    # an arbitrary list already requires an eval(), iterate with an eval()-based
    # iterator rather than implement such iteration manually.
    for_string_words options_list_names__sltocap options_list_name__sltocap\
        'die_unless_list "${options_list_name__sltocap}"
        '${list_name__sltocap}'+=( "${(@P)options_list_name__sltocap}" )'

    # Append all passed options to such list. To differentiate passed options
    # from non-options, find the index of the last option and if nonzero append
    # all prior arguments.
    set_integer_to_arg_option_index_last arg_option_index_last__sltocap
    if (( arg_option_index_last__sltocap )) {
        append_list "${list_name__sltocap}"\
            "${@[1,${arg_option_index_last__sltocap}]}"
    }
}

# ....................{ RUNNERS                            }....................
#FIXME: Is this function ever called directly? The existing nomenclature is
#*EXCEEDINGLY* awkward. After all, there's no requirement that such options be
#"configured" -- only that they exist in the passed list. O.K.; we have a better
#FIXME related to that, so see that below.
#FIXME: Reduce documentation. set_list_to_options_configured_and_passed() now
#documents quite a bit of this.

declare_function_with_stdin <<'/---'
string run_code_with_options(
    string command_prefix,
    string options_list_names,
    string command_arg1?, ...)

Run a command dynamically constructed from the passed arguments as follows:

* Split the passed options list names on whitespace into a list of the names of
  all lists with options to be passed to such command (e.g., split
  `ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_RECURSIVE` into a list containing
  `ZESHY_OPTIONS_GREP` and `ZESHY_OPTIONS_GREP_IF_RECURSIVE`).
* Set the command to be run to pipe standard input if this function was piped
  such input or to the empty string otherwise (e.g., `cat /dev/stdin |`).
* Append the passed prefix to such command (e.g., `run_code_paged grep -R`).
* For every list name in such list:
** If such list exists, append all elements of that list to such command.
** Else, throw an exception.
* Append the passed arguments to such command (e.g., `${(q)@}`).
* Run such command (e.g., assuming the caller passed a single argument `Weeds`
  and piped no input and the above options lists contain default elements,
  `run_code_paged grep --extended-regexp --no-messages --recursive 'Weeds'`).

For example:

.run_code_with_options()
==========================================
[source]
------------------------------------------
# Run grep recursively with the passed list of options and user arguments,
# paging standard output if required.
>>> run_code_with_options "run_code_paged command grep"\
...     "ZESHY_OPTIONS_GREP ZESHY_OPTIONS_GREP_IF_RECURSIVE" -- "${(q)@}"
------------------------------------------
==========================================
/---
function run_code_with_options() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one command prefix, one options list names string, and optional command arguments.'
    string command_prefix__rcwo="${1}"
    list command__rcwo options_list_names__rcwo

    # If passed piped input, propagate such input to the command to be run.
    if { is_stdin_pipe } {
        command__rcwo+=( get_stdin '|' )
    }

    #FIXME: Is this really necessary? I strongly suspect the eventual "eval"
    #performed by run_code() to render this vestigial. If this *ISN'T*
    #vestigial, we should be appending to such list with a new function
    #append_list_with_string_words(): e.g.,
    #
    #    append_list_with_string_words command__rcwo "${command_prefix__rcwo}"

    # Append such prefix split into shell words to such line.
    command__rcwo+=( "${(z)command_prefix__rcwo}" )

    # Split the whitespace-delimited string of option list names into a list of
    # such names, to be interpolated below.
    set_list_to_string_words options_list_names__rcwo "${2}"
    shift_args_2

    # For each options list name, append the contents of such list to such
    # command or throw a warning if no such list exists.
    string options_list_name__rcwo
    for    options_list_name__rcwo ("${options_list_names__rcwo[@]}") {
        die_unless_list      "${options_list_name__rcwo}"
        command__rcwo+=( "${(@P)options_list_name__rcwo}" )
    }

    # Append all remaining passed arguments to such command.
    command__rcwo+=( "${@}" )

    # Run such command.
#   print_string "run_code_with_options: \"${command__rcwo[*]}\"..."
    run_code "${command__rcwo[@]}"
}

#FIXME: Rename to run_code_with_options_assembled:(). Numerous applicable verbs
#here (synonyms of "composed" seem best applicable), but "assembled" reads the
#best. Really! (The use of "configured" here was always inane, as
#run_code_with_options() itself operated on configured options lists.)
#FIXME: Perhaps:
#
#* run_code_with_options_arranged().
#* run_code_with_options_contextualized().
#
#O.K.; O.K. I must admit "assembled" to be the best choice, at present.

declare_function_with_stdin <<'/---'
string run_code_with_options_configured(
    string command_prefix,
    string options_list_names,
    string command_arg1?, ...)

Run a command dynamically constructed from the passed arguments as under
run_code_with_options() and also appending
` ${list_name_first}_IF_INTERACTIVE` if the current shell is interactive and
` ${list_name_first}_IF_NONINTERACTIVE` otherwise to `${options_list_names}`,
where `${list_name_first}` is the first word in `${options_list_names}`.
/---
function run_code_with_options_configured() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one command prefix, one options list names string, and optional command arguments.'
    string options_list_name__rcwoc options_list_name_first__rcwoc

    # The first shell word from the list of options list names, comprising the
    # name of the options list to be suffixed below.
    options_list_name_first__rcwoc="$(get_string_word "${2}" 1)"

    # If an options list with name corresponding to whether the current shell is
    # interactive or not exists, append such name to the passed list of such
    # names if such list exists.
    if { is_shell_interactive } {
        options_list_name__rcwoc="${options_list_name_first__rcwoc}_IF_INTERACTIVE"
    } else {
        options_list_name__rcwoc="${options_list_name_first__rcwoc}_IF_NONINTERACTIVE"
    }
    if { is_list "${options_list_name__rcwoc}" } {
        2+=" ${options_list_name__rcwoc}"
    }

    # Run such command.
    run_code_with_options "${@}"
}

# ....................{ RUNNERS ~ silent                   }....................
#FIXME: Ideally, the entirety of this function's logic should be shifted into
#run_code_with_options_assembled(). After all, detecting whether or not
#"/dev/fd/1" is redirected to "/dev/null" or not *SHOULD* be a trivial task, at
#which point such function can implicitly decide to add silent-specific options.
#If this is the case, excise this function away!
#FIXME: O.K.; this is indeed trivially discernable with code resembling:
#
#    >>> string pae
#    >>> set_string_to_path_canonical pae /dev/stdout >/dev/null
#    >>> print "${pae}"
#    /dev/null
#FIXME: It'd be great to encapsulate this in a new function is_stdout_silent().

declare_function_with_stdin <<'/---'
string run_code_silent_with_options(
    string command_prefix,
    string options_list_names,
    string command_arg1?, ...)

Silently run a command dynamically constructed from the passed arguments as
under run_code_with_options() and also appending
` ${list_name_first}_IF_SILENT` and ` ${list_name_first}_IF_NONINTERACTIVE` to
`${options_list_names}`, where `${list_name_first}` is the first shell word in
`${options_list_names}`.
/---
function run_code_silent_with_options() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one command prefix, one options list names string, and optional command arguments.'
    string options_list_name_first__rcswo

    # The first shell word from the list of options list names, having the name
    # of the options list to be suffixed below.
    options_list_name_first__rcswo="$(get_string_word "${2}" 1)"

    # For each options list name given below, append such name to the passed
    # list of such names if such list exists.
    string options_list_name_suffix__rcswo options_list_name__rcswo
    for    options_list_name_suffix__rcswo ('_IF_SILENT' '_IF_NONINTERACTIVE') {
        options_list_name__rcswo="${options_list_name_first__rcswo}${options_list_name_suffix__rcswo}"
        if { is_list "${options_list_name__rcswo}" } {
            2+=" ${options_list_name__rcswo}"
        }
    }

    # Run such command. Avoid prepending such command with a call to
    # run_code_silent(), which inadvertently silences error output from
    # run_code_with_options(). Specifically, don't do this:
    #     run_code_silent run_code_with_options "${@}"
    run_code_with_options "${@}" '&>/dev/null'
#   run_code_with_options "${@}"
}

# --------------------( WASTELANDS                         )--------------------
# Given this,
#contemplate at least renaming run_code_with_options_configured() to
#run_code_with_options_listed().
#FUXME: Rename to run_code_silent_with_options_assembled().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with run_code_silent_with_options_configured().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#FUXME: This function is *NEVER* called anywhere and, honestly, should probably
#never be called. (It's difficult to see the use case, anyway.) Excise for now.
#declare_function_with_stdin <<'/---'
#string run_code_silent_with_options_configured(
#    string command_prefix,
#    string options_list_names,
#    string command_arg1?, ...)
#
#Silently run a command dynamically constructed from the passed arguments as
#under run_code_with_options_configured() and also appending
#` ${list_name_first}_IF_SILENT` and ` ${list_name_first}_IF_NONINTERACTIVE` to
#`${options_list_names}`, where `${list_name_first}` is the first shell word in
#`${options_list_names}`.
#/---
#function run_code_silent_with_options_configured() {
#    # See run_code_silent_with_options() for further details.
#    die_unless_args_2_or_more\
#        'Expected one command prefix, one options list names string, and optional command arguments.'
#    string options_list_name_first__rcswo
#    options_list_name_first__rcswo="$(get_string_word "${2}" 1)"
#    string options_list_name_suffix__rcswo options_list_name__rcswo
#    for    options_list_name_suffix__rcswo ('_IF_SILENT' '_IF_NONINTERACTIVE') {
#        options_list_name__rcswo="${options_list_name_first__rcswo}${options_list_name_suffix__rcswo}"
#        if { is_list "${options_list_name__rcswo}" } {
#            2+=" ${options_list_name__rcswo}"
#        }
#    }
#    run_code_with_options_configured "${@}" '&>/dev/null'
#}

#FUXME: Not necessarily the best idea, as maps discard position -- which is
#often of critical importance to option handling. Revert to a list, I should
#think. Or perhaps support both? Anyway, we at least need a basic list approach,
#as that's what the runners below will be calling (for efficiency -- no need to
#extract map keys and such when converting back into a list).

#    string options_list_name__rcwo
#    for    options_list_name__rcwo ("${options_list_names__sltocap[@]}") {
#    }'
#        if { is_list "${options_list_name__rcwo}" } {
#            command__rcwo+=( "${(@P)options_list_name__rcwo}" )
#        } else {
#            die "\"${options_list_name__rcwo}\" not a list"
#        }
#       command__rcwo+=( \< "${ZESHY_STDIN_PATH}" \| )
#Handle dynamically constructed command lines passed options lists.

#Construct a command from the sanity contextually depending on whether
#or not the current shell is interactive; then run such command. To do so, append
#` ${list_name_first}_IF_SHELL_INTERACTIVE` if this shell is interactive or
#` ${list_name_first}_IF_SHELL_NON_INTERACTIVE` otherwise to the passed string of
#list names, where ${list_name_first} is the first list name in such string; then
#call run_code_with_options() on such arguments.
#   is_list "${options_list_name_first__rcwos}_IF_SILENT" and
#       2+=" ${options_list_name_first__rcwos}_IF_SILENT"
#   is_list "${options_list_name_first__rcwos}_IF_NONINTERACTIVE" and
#       2+=" ${options_list_name_first__rcwos}_IF_NONINTERACTIVE"

#Construct a command from the sanity; then run such command quietly
#(i.e., with neither terminal output or interactive input). To do so, append
#; then call run_code_with_options() on such arguments
#   options_list_names__rwo+=( '1' )
#   print "list type: ${(t)options_list_names__rwo}"
#   die_unless_list options_list_names__rwo
    # Similarly, avoid prepending such command with a call to
    # run_code_to_stderr(), which... well, I can't quite remember
    # why not. Hmm.
    #
    #     >>> run_code_to_stderr run_code_with_options "${@}"
#   print "running silently: ${*}"
#   for options_list_name__rwos (
#       "${options_list_name_first__rwos}_IF_SILENT"
#       "${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE") {
#       is_list "${options_list_name__rwos}" and
#           2+=" ${options_list_name__rwos}"
#   }
    # Append a non-interactive-specific options list name, regardless of whether
    # the current shell is interactive.
#   2+=" ${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE"

#FUXME: Ah; it's not an objection, more a... curiosity. But how are pipes
#handled in relation to the call stack, exactly? We'd really like one-liners
#such as "ls -o --type=full * | grep -v yumyum | less -o" to work as
#expected. I suspect the shell already handles this correctly by running
#each pipe command as the root of its own call stack in a separate subshell...
#Hmm; but, in that case, such subshells would be marked as non-interactive.
#In any case, we'll just have to test such pipes ourselves and see what zsh
#comes up with. (We should be able to hack it up in our favor, but...)
#FUXME: *NO, NO, NO.* The above heavy-weight solution is horrible. It's
#horribly inefficient. It's horribly complex. It's a big fail. Here's what
#we're going to do instead. It's not pretty, but we have to do it anyway to
#support arbitrary option passing when interactive: for *MOST* functions with
#existing interactive aliases, we need to divert such aliases to a new
#function with name prefixed by "_interactive" accepting arbitrary options
#and *NOT* passing "--". The original non-interactive function must, on the
#other hand, explicitly pass "--". We've already excised the hard-coded "--"
#from this function, so we're good to go. Look: I know it'll be unpleasant,
#but we basically have little choice. It'll probably take two days from
#starting to finishing such revisions.
#
#Example:
#Define a new remove_file_interactively() function. Redefine interactive
#alias "rm" to call such function rather than remove_file(). Do *NOT* change
#the original remove_file(). And...we're good!

#ensure the resulting command
#does *NOT* request input from the current user
