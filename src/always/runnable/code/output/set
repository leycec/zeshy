#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *command output setters* (i.e., functions running commands and setting
variables to all standard output and/or error which such commands produce).
-/-

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void run_code_and_set_string_to_coprocess_output_from_redirection(
    string command_name, string command_arg1, string command_arg2, ...,
    string string_name,
    string redirection)

Run the passed command after opening an *identity coprocess* (i.e., a coprocess
outputting all output passed to such coprocess) and set the passed string
variable to all output redirected from such command to such coprocess by the
passed string of `zsh` redirections (e.g., `1>&p 2>/dev/null`, setting such
variable to all standard output from such command as well as silencing all
standard error from such command): e.g.,

.run_code_and_set_string_to_coprocess_output_from_redirection()
==========================================
[source]
------------------------------------------
>>> string on_subservience on_addiction=\
...    "We've been led into a culture that has been engineered to leave us
...     tired, hungry for indulgence, willing to pay a lot for convenience and
...     entertainment, and most importantly, vaguely dissatisfied with our lives
...     so that we continue wanting things we don't have. We buy so much because
...     it always seems like something is still missing. Western economies,
...     particularly that of the United States, have been built in a very
...     calculated manner on gratification, addiction, and unnecessary spending.
...     We spend to cheer ourselves up, to reward ourselves, to celebrate, to
...     fix problems, to elevate our status, and to alleviate boredom."
>>> run_code_and_set_string_to_coprocess_output_from_redirection\
...     'get_string_line "${on_addiction}" 1' on_subservience '1>&p 2>/dev/null'
>>> print_string "${on_dominance}"
We've been led into a culture that has been engineered to leave us
------------------------------------------
==========================================

== Identity Coprocess ==

While seemingly meaningless, such coprocess serves as a temporary repository
storing command output, permitting such command to be run in the current shell
rather than a subshell, permitting such command to modify the current shell
(e.g., `temporary_pathnames=( /tmp/* )`, setting list ${temporary_pathnames} to
the absolute path of all temporary files and directories in `/tmp`). See
get_stdin_until_eot() for further details on the function such coprocess calls.
/---
# Ideally, a simple pipeline would suffice to implement this function. For
# example, in the case of implementing
# run_code_silent_and_set_string_to_stderr(), this might reduce to:
#
#     { run_code "${@}" 1>/dev/null } |&
#         set_string_to_stdin "${string_name__rcasste}"
#
# While such pipeline succeeds for commands *NOT* modifying the current
# shell environment (e.g.,
# "output_string 'Our national flower is the concrete cloverleaf.'"), such
# pipeline fails all other commands (e.g., "list war;
# war=( War is the supreme drama of a completely mechanized society. )").
#
# The reason why is subtle, for those unfamiliar with the arcane viscera of
# zsh operation: all subcommands of a pipeline except the last are executed
# in subshells. For safety, modifying subshell environments *NEVER* modifies
# the current shell environment. Indeed, while variables are readily
# exportable *DOWN* the shell hierarchy from the current shell to subshells,
# there exist no means of exporting variables back *UP* the shell hierarchy
# from subshells to the current shell.
#
# The command to be run must thus be run from the current shell. While this
# excludes pipelines, two (substantially less convenient) alternatives
# remain:
#
# * Temporary files. Standard error from such command could be piped to a
#   temporary file, the passed variable set to the contents of such file,
#   and such file removed. While feasible, such approach is regrettably
#   heavyweight for such a core function as this.
# * Coprocesses. Standard error from such command could be piped to a
#   coprocess, the passed variable set to standard input from such coprocess
#   (which is, hopefully, the standard error piped earlier to such coprocess),
#   and such coprocess closed. Hence, such approach uses such coprocess as a
#   temporary repository for storing standard error from such command.
#
# Both approaches ensure that such command is run from *AND* such variable
# is set in the current shell. Coprocesses, however, are the usual solution
# to assembling pipelines in which some subcommand other than the last must
# be run in the current shell. Hence, we adopt the latter alternative.
function run_code_and_set_string_to_coprocess_output_from_redirection() {
    # Validate sanity.
    die_unless_args_3_or_more\
        'Expected one command, one string name, and one redirection string.'
    string string_name__rcassto="${@[-2]}" redirection__rcassto="${@[-1]}"
    pop_args 2

    # Coprocess outputting all standard input piped to such subshell until
    # receiving a line containing only an EOT character. See such function
    # for further details.
    open_coprocess get_stdin_until_eot

    {
        #FIXME: O.K.; we have a trap() problem here. Soft termination signals
        #(at least SIGINT induced by <Ctrl-c> and possibly others) do not induce
        #termination. The reason why is probably that only the current shell
        #receives and handles such SIGINT; the coprocess doesn't appear to and
        #hence continues running in an infinite loop after the current shell has
        #long since terminated. The coprocess is waiting to receive input, which
        #it never does. So, on receiving SIGINT, we just need to:
        #    output_string_to_coprocess "${ZESHY_ASCII_EOT}"; close_coprocess
        #Well, that or explicitly do the latter. Hmm; right. For a "soft
        #termination", we'd might as well try to close it cleanly. So, do output
        #EOT as well.

        # Run such command. To prevent the passed redirection from conflicting
        # with redirections already embedded in such command, explicitly
        # segregate the former from the latter with "{" and "}" delimiters.
#       output_string "variable: ${string_name__rcassto}; command: ${@}"
        run_code '{' "${@}" '} '${redirection__rcassto}

        # Write a line containing only the EOT character to such function,
        # which should now successfully return.
        output_string_to_coprocess "${ZESHY_ASCII_EOT}"

        # Set the passed string to all standard error cached via such coprocess.
        # To quote modern culture, "Shit just got real."
        set_string_to_coprocess_output "${string_name__rcassto}"
    } always close_coprocess
}

# ....................{ SETTERS ~ loud                     }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: integer]
    run_code_and_set_string_to_stdout(
        string command_name, string command_arg1, string command_arg2, ...,
        string string_name)

Run the passed command and set the passed string variable to all standard output
(but _not_ error) from such command. By preserving rather than redirecting such
output, standard output and error will still be output as usual: e.g.,

.run_code_and_set_string_to_stdout()
==========================================
[source]
------------------------------------------
>>> string on_health on_happiness=\
...    "Can you imagine what would happen if all of America stopped buying so
...     much unnecessary fluff that doesn't add a lot of lasting value to our
...     lives? The economy would collapse and never recover. All of America's
...     well-publicized problems, including obesity, depression, pollution and
...     corruption are what it costs to create and sustain a trillion-dollar
...     economy. For the economy to be \"healthy\", America has to remain
...     unhealthy. Healthy, happy people don't feel like they need much they
...     don't already have, and that means they don't buy a lot of junk, don't
...     need to be entertained as much, and they don't end up watching a lot of
...     commercials. The culture of the eight-hour workday is big business' most
...     powerful tool for keeping people in this same dissatisfied state where
...     the answer to every problem is to buy something."
>>> run_code_and_set_string_to_stdout\
...     'get_string_line "${on_happiness}" -1' on_health
the answer to every problem is to buy something.
>>> print_string "${on_health}"
the answer to every problem is to buy something.
------------------------------------------
==========================================
/---
function run_code_and_set_string_to_stdout() {
    die_unless_args_2_or_more 'Expected one command and one string name.'
    run_code_and_set_string_to_coprocess_output_from_redirection\
        "${@}" '1>&1 1>&p'
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: integer]
    run_code_and_set_string_to_stderr(
        string command_name, string command_arg1, string command_arg2, ...,
        string string_name)

Run the passed command and set the passed string variable to all standard error
(but _not_ output) from such command. By preserving rather than redirecting such
output, standard output and error will still be output as usual: e.g.,

.run_code_and_set_string_to_stderr()
==========================================
[source]
------------------------------------------
>>> string on_learning on_ideas=\
...    "Did ever grow anything
...     In the garden of your mind?
...     You can grow ideas
...     In the garden of your mind.
...
...     It's good to be curious about many things.
...     You can think about things and make believe.
...     All you have to do is think
...     And they'll grow.
...
...     There are so many things
...     To learn about in this world.
...     And so many people
...     Who can help us learn."
>>> run_code_and_set_string_to_stderr\
...     'get_string_line "${on_ideas}" 1 1>&2' on_learning
Did ever grow anything
>>> print_string "${on_health}"
Did ever grow anything
------------------------------------------
==========================================
/---
function run_code_and_set_string_to_stderr() {
    die_unless_args_2_or_more 'Expected one command and one string name.'
    run_code_and_set_string_to_coprocess_output_from_redirection\
        "${@}" '2>&2 2>&p'
}

# ....................{ SETTERS ~ silent                   }....................
declare_function_with_stdin <<'/---'
void run_code_silent_and_set_string_to_stdout(
    string command_name, string command_arg1, string command_arg2, ...,
    string string_name)

Run the passed command *silently* (i.e., squelching standard output and error)
and set the passed string variable to all standard output (but _not_ error) from
such command: e.g.,

.run_code_silent_and_set_string_to_stdout()
==========================================
[source]
------------------------------------------
>>> string on_dominance on_consumerism=\
...    "\"Morning, sir or madam or neuter,\" the thing said. \"This your planet,
...     is it?"
...     The other alien, which was stubby and green, had wandered off into the
...     woods by the side of the road. Out of the corner of his eye Newt saw it
...     kick a tree, and then run a leaf through some complicated gadget on its
...     belt. It didn't look very pleased.
...     \"Well, yes. I suppose so,\" he said.
...     The toad stared thoughtfully at the skyline.
...     \"Had it long, have we, sir?\" it said.
...     \"Er. Not personally. I mean, as a species, about half a million years.
...     I think.\"
...     The alien exchanged glances with its colleague. \"Been letting the old
...     acid rain build up, haven't we, sir?\" it said. \"Been letting ourselves
...     go a bit with the old hydrocarbons, perhaps?\"
...     \"I'm sorry?\"
...     \"Could you tell me your planet's albedo, sir?\" said the toad, still
...     staring levelly at the horizon as though it was doing something
...     interesting.
...     \"Er. No.\"
...     \"Well, I'm sorry to have to tell you, sir, that your polar ice caps are
...     below regulation size for a planet of this category, sir.\"
...     \"Oh, dear,\" said Newt. He was wondering who he could tell about this,
...     and realizing that there was absolutely no one who would believe him.
...     The toad bent closer. It seemed to be worried about something, insofar
...     as Newt was any judge of the expressions of an alien race he'd never
...     encountered before.
...     \"We'll overlook it on this occasion, sir...\"
...     Newt stuck his head out of the window.
...     \"Thank you!\"
...     The small alien walked past the car.
...     \"C02 level up 0.5 percent,\" it rasped, giving him a meaningful look.
...     \"You do know you could find yourself charged with being a dominant
...     species while under the influence of impulse-driven consumerism, don't
...     you?\""
>>> run_code_silent_and_set_string_to_stdout\
...     'get_string_line "${on_consumerism}" 1' on_dominance
>>> print_string "${on_dominance}"
"Morning, sir or madam or neuter," the thing said. "This your planet,
------------------------------------------
==========================================
/---
function run_code_silent_and_set_string_to_stdout() {
    die_unless_args_2_or_more 'Expected one command and one string name.'
    run_code_and_set_string_to_coprocess_output_from_redirection\
        "${@}" '1>&p 2>/dev/null'
}

declare_function_with_stdin <<'/---'
void run_code_silent_and_set_string_to_stderr(
    string command_name, string command_arg1, string command_arg2, ...,
    string string_name)

Run the passed command *silently* (i.e., squelching standard output and error)
and set the passed string variable to all standard error (but _not_ output) from
such command: e.g.,

.run_code_silent_and_set_string_to_stderr()
==========================================
[source]
------------------------------------------
>>> string on_responsibility on_submission=\
...    "Let's pretend for a moment that work doesn't turn people into stultified
...     submissives. Let's pretend, in defiance of any plausible psychology and
...     the ideology of its boosters, that it has no effect on the formation of
...     character. And let's pretend that work isn't as boring and tiring and
...     humiliating as we all know it really is. Even then, work would still
...     make a mockery of all humanistic and democratic aspirations, just
...     because it usurps so much of our time. Socrates said that manual
...     laborers make bad friends and bad citizens because they have no time to
...     fulfill the responsibilities of friendship and citizenship. He was
...     right. Because of work, no matter what we do we keep looking at our
...     watches. The only thing \"free\" about so-called free time is that it
...     doesn't cost the boss anything. Free time is mostly devoted to getting
...     ready for work, going to work, returning from work, and recovering from
...     work. Free time is a euphemism for the peculiar way labor as a factor of
...     production not only transports itself at its own expense to and from the
...     workplace but assumes primary responsibility for its own maintenance and
...     repair. Coal and steel don't do that. Lathes and typewriters don't do
...     that. But workers do. No wonder Edward G. Robinson in one of his
...     gangster movies exclaimed, \"Work is for saps!\""
>>> run_code_silent_and_set_string_to_stderr\
...     'get_string_line "${on_submission}" 1 1>&2' on_responsibility
>>> print_string "${on_responsibility}"
Let's pretend for a moment that work doesn't turn people into stultified
------------------------------------------
==========================================
/---
function run_code_silent_and_set_string_to_stderr() {
    die_unless_args_2_or_more 'Expected one command and one string name.'
    run_code_and_set_string_to_coprocess_output_from_redirection\
        "${@}" '1>/dev/null 2>&p'
}

#FIXME: In lieu of unit tests...
#function comm() {
#    string stdout stderr
#
#    run_code_and_set_string_to_stdout '{ print ok; print ko 1>&2; }' stdout
#    print "stdout: ${stdout}"
#    run_code_and_set_string_to_stderr '{ print ok; print ko 1>&2; }' stderr
#    print "stderr: ${stderr}"
#
#    run_code_silent_and_set_string_to_stdout 'print "ok\nhm"; print "ko\nhm" 1>&2' stdout
#    print "stdout (silent): ${stdout}"
#    run_code_silent_and_set_string_to_stderr 'print "ok\nhm"; print "ko\nhm" 1>&2' stderr
#    print "stderr (silent): ${stderr}"
#}

# --------------------( WASTELANDS                         )--------------------
    # Validate passed arguments.
#   die_unless_args_2_or_more 'Expected one command and one string name.'
#   string string_name__rcasste="${@[-1]}"
#   pop_arg

    # File descriptors opened for writing to standard output and error for the
    # current shell. Since the subshell invoked below substitutes such output
    # with its own, storing handles to such output permits their access in such
    # subshell.
#   file_descriptor stdout__rcasste stderr__rcasste
#   {
#       open_file_descriptor_to_stdout stdout__rcasste
#       open_file_descriptor_to_stderr stderr__rcasste

        # Run such command and set such string. Dismantled, this is:
        #
        # * "2>&1", redirecting standard error to output for the subshell,
        #   ensuring such output is captured into such string.
        # * "1>&${...}", redirecting standard output for the subshell to
        #   standard output for the current shell.
        # * "2>&${...}", redirecting standard error for the subshell to
        #   standard error for the current shell.
#       set_string_to_string "${string_name__rcasste}" "$(run_code "${@}"\
#           2>&1 1>&${stdout__rcasste} 2>&${stderr__rcasste})"
    # Close such descriptors safely (e.g., in the event of an exception).
#   } always {
#       close_file_descriptor_if_open stdout__rcasste
#       close_file_descriptor_if_open stderr__rcasste
#   }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with run_code_and_set_string_to_stdout(),
    # run_code_and_set_string_to_stderr(), and
    # run_code_silent_and_set_string_to_stdout().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
#   die_unless_args_2_or_more 'Expected one command and one string name.'
#   string string_name__rcasste="${@[-1]}"
#   pop_arg

    # Coprocess outputting all standard input piped to such subshell until
    # receiving a line containing only an EOT character. See such function
    # for further details.
#   open_coprocess get_stdin_until_eot

#   {
        # Run such command, silencing standard output and redirecting standard
        # error to such coprocess.
#       output_string "variable: ${string_name__rcasste}; command: ${@}"
#       run_code "${@}" 1>/dev/null 2>&p

        # Write a line containing only the EOT character to such function,
        # which should now successfully return.
#       output_string_to_coprocess "${ZESHY_ASCII_EOT}"

        # Set the passed string to all standard error cached via such coprocess.
        # To quote modern culture, "Shit just got real."
#       set_string_to_coprocess_output "${string_name__rcasste}"
#   } always close_coprocess

    # See run_code_silent_and_set_string_to_stderr() for further details.
#   die_unless_args_2_or_more 'Expected one command and one string name.'
#   string string_name__rcassto="${@[-1]}"
#   pop_arg
#   open_coprocess get_stdin_until_eot

#   {
#       run_code "${@}" 1>&1 1>&p
#       output_string_to_coprocess "${ZESHY_ASCII_EOT}"
#       set_string_to_coprocess_output "${string_name__rcassto}"
#   } always close_coprocess

#       "${@[1,-2]}" '1>&p 2>/dev/null' "${@[-1]}"

    # See run_code_silent_and_set_string_to_stderr() for further details.
#   die_unless_args_2_or_more 'Expected one command and one string name.'
#   string string_name__rcassto="${@[-1]}"
#   pop_arg
#   open_coprocess get_stdin_until_eot

#   {
#       run_code "${@}" 1>&p 2>/dev/null
#       output_string_to_coprocess "${ZESHY_ASCII_EOT}"
#       set_string_to_coprocess_output "${string_name__rcassto}"
#   } always close_coprocess

    # File descriptor opened for writing to standard output for the current
    # shell. Since the subshell invoked below substitutes such output with its
    # own, storing a handle to such output permits its access in such subshell.
#   file_descriptor stdout__rcassto
#   {
#       open_file_descriptor_to_stdout stdout__rcassto

        # Run such command and set such string. Dismantled, this is:
        #
        # * "1>&1", redirecting standard output for the subshell to itself.
        #   While redundant, this ensures such output survives subsequent
        #   redirection under shell option "MULTIOS" and is hence captured into
        #   such string.
        # * "1>&${...}", redirecting standard output for the subshell to
        #   standard output for the current shell.
        #
        # Since command substitution does *NOT* capture standard error, this has
        # the beneficial side effect of printing standard error as normal.
#       set_string_to_string "${string_name__rcassto}"\
#           "$(run_code "${@}" 1>&1 1>&${stdout__rcassto})"
    # Close such descriptor safely (e.g., in the event of an exception).
#   } always {
#       close_file_descriptor_if_open stdout__rcassto
#   }
