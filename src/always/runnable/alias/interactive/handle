#!/usr/bin/env zsh
# ====================[ handle                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle all interactive alias functionality *OTHER* than defining such aliases.
# See "define" for the latter.

# ....................{ LISTERS                            }....................
document_function '
void print_interactive_aliases(void)

List all declared interactive alias names with corresponding expansions.
'
function print_interactive_aliases() {
    # Validate sanity.
    die_if_args
    string type

    # For each currently declared interactive alias in lexicographic order...
    for name ( $(list_map_keys_sorted_lexically_ascending\
        ZESHY_INTERACTIVE_ALIAS_NAME_TO_EXPANSION) ) {
        # Get such alias' type by map lookup. Since is_map_key() imposes
        # perceptible delays, use zsh builtins. See is_map_key() for details.
        if (( ${+ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION[${name}]} ))
        then type="${ZESHY_COLOR[green]}interactive_abbreviation"
        elif (( ${+ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION[${name}]} ))
        then type="${ZESHY_COLOR_BOLD[green]}interactive_substitution"
        else type="${ZESHY_COLOR[red]}interactive_alias"
        fi

        # Print such alias.
        print_string_colored\
            "${type} ${ZESHY_COLOR_BOLD[white]}${name}${ZESHY_COLOR[grey]}=${ZESHY_COLOR_BOLD[grey]}\"${ZESHY_COLOR_ITALIC[magenta]}${ZESHY_INTERACTIVE_ALIAS_NAME_TO_EXPANSION[${name}]}${ZESHY_COLOR_BOLD[grey]}\""
    } | page_string
}

# ....................{ MAKERS                             }....................
# Define interactive aliases at digest recompilation rather than Zeshy startup
# time, for both efficiency and sanity.
append_make_zeshy_command make_interactive_aliases

document_function '
void make_interactive_aliases(void)

Define interactive aliases specified by Zeshy''s user configuration files.
'
function make_interactive_aliases() {
    # Validate sanity.
    die_if_args
    string command_name alias_name

    # Define listed abbreviations.
    for specification ("${ZESHY_INTERACTIVE_ABBREVIATIONS[@]}") {
        interactive_abbreviation "${specification}"
    }

    # Define listed substitutions. Avoid calling interactive_substitution(),
    # which throws exceptions and hence disrupts digest recompilation for
    # aliases not existing pathables.
    for specification ("${ZESHY_INTERACTIVE_SUBSTITUTIONS[@]}") {
        interactive_substitution_if_pathable_or_cry "${specification}"
    }
    for specification ("${ZESHY_INTERACTIVE_SUBSTITUTIONS_IF_PATHABLE[@]}") {
        interactive_substitution_if_pathable "${specification}"
    }
    for alias_name\
        ("${ZESHY_INTERACTIVE_SUBSTITUTIONS_IF_PATHABLE_RUN_DISOWNED[@]}") {
        # While we *COULD* simply call interactive_substitution_if_pathable(),
        # this is altogether more efficient and straightforward. (Since we
        # have to match the command name anyway, we'd might as well use it.)
        command_name="${alias_name//[\{\}]}"
        is_pathable "${command_name}" and interactive_substitution\
            ${alias_name}="run_disowned ${command_name}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Define and call a new interactive_substitution_if_pathable_or_cry() instead
    #to avoid crashing the entire compilation process when such command is not
    #installed on the current system. Robustness for the win!

# (It *SHOULDN'T* ever be, and since it
    # shouldn't ever be, print warnings instead.)
        #FUXME: Should probably centralize into a new
        #interactive_substitution_if_pathable().
#       alias_name="${specification%%\=*}"
#       command_name="${alias_name//[\{\}]}"
#       is_pathable "${command_name}" and interactive_substitution\
#           "${specification}"
#FUXME: How essential are these, actually? I'm thinking... not. The difficulty
#is coherently coordinating colors between the three. *sigh*
#I say we excise these, for now.
#document_function '
#void list_interactive_abbreviations(void)
#
#List all declared interactive abbreviation names with corresponding expansions.
#'
#function list_interactive_abbreviations() {
#    # Validate sanity.
#    die_if_args
#
#    # List such aliases.
#    for name ( $(list_map_keys_sorted_lexically_ascending\
#        ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION) ) {
#        print_string "interactive_abbreviation ${name}=\"${ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION[${name}]}\""
#    } | page_string
#}
#
#document_function '
#void list_interactive_substitutions(void)
#
#List all declared interactive substitution names with corresponding expansions.
#'
#function list_interactive_substitutions() {
#    # Validate sanity.
#    die_if_args
#
#    # List such aliases.
#    for name ( $(list_map_keys_sorted_lexically_ascending\
#        ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION) ) {
#        print_string "interactive_substitution ${name}=\"${ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION[${name}]}\""
#    } | page_string
#}
#
    # Reset colors in preparation for subsequent output.
#   reset_
#   print_string "${ZESHY_COLOR_RESET}"
    #FUXME: Excellent. We should probably define (and expand here) a new *ALIAS*
    #set_colors_locally<> testing whether or not standard output for the current
    #function is attached to a terminal and, if not, temporarily locally
    #replacing all color strings and maps previously globally defined with
    #strings expanding to the empty string. (Clearly, such maps should have the
    #same keys but empty values.) Rather than expensively redeclaring such
    #variables on each such alias expansion, predeclare such variables in
    #"io/terminal/color" as, perhaps, ${ZESHY_COLOR_EMPTY} and so on.
    #FUXME: Actually, localize_colors<> is a significantly better name. Yum-yum.

#FUXME: Colorify such output; it's a tad difficult to read without helpful
#syntax highlighting.

#       if is_map_key ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION "${name}"
#       elif is_map_key ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION "${name}"
        #FUXME: Let's try improving is_map_key() efficiency, shall we?
#       if is_map_key ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION "${name}"
#       elif is_map_key ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION "${name}"
#       if is_map_key ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION "${name}"
#       elif is_map_key ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION "${name}"
        # If such alias is an abbreviation, prefix such declaration with that.
        # If such alias is a substitution, prefix such declaration with that.
        # Otherwise, prefix such declaration with a generic alias type.
#   {
#       list_interactive_abbreviations
#       print_newline
#       list_interactive_substitutions
#   } | page_string
#   =(
#       "${ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION[@]}"
#       "${ZESHY_INTERACTIVE_SUBSTITUTION_NAME_TO_EXPANSION[@]}"
#   )
#       say_first_section 'interactive abbreviation list'
#       say_next_section 'interactive substitution list'

#       ${(k)ZESHY_INTERACTIVE_ABBREVIATION_NAME_TO_EXPANSION}) {

# This includes list element of:
#* ${ZESHY_INTERACTIVE_ABBREVIATIONS}, define:
#  * An interactive abbreviation from such element stripped of "{"- and "}"-
#    non-delimited substrings to such element stripped of "{"- and "}"-
#    delimited substrings (e.g., for list element "{v}im",
#    "interactive_abbreviation v=vim"), if the former exists.
#* ${ZESHY_INTERACTIVE_SUBSTITUTIONS_RUN_DISOWNED}, define:
#  * An interactive substitution from such element stripped of "{"- and "}"-
#    delimited substrings to the same string (e.g., for "{cali}bre",
#    "interactive_substitution calibre=''run_disowned calibre''").
#  * An interactive abbreviation from such element stripped of "{"- and "}"-
#    non-delimited substrings to the above string (e.g., for "{cali}bre",
#    "interactive_abbreviation cali=''run_disowned calibre''"), if the former
#    exists.
