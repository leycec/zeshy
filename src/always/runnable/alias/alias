#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle core alias functionality.
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_file_alias_suffixed(
    string filename,
    string error_message = "\"${filename}\" not suffix aliased")

Throw an exception with the passed message unless a suffix alias exists for the
filetype of the passed file.
/---
function die_unless_file_alias_suffixed() {
    die_unless_args_1_to_2\
        'expected one filename and optional error message'
    string filename="${1}"
    is_file_alias_suffixed "${filename}" or
        die "${2:-\"${filename}\" not suffix aliased}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_alias(string alias_name1, string alias_name2, ...)

Return success if all passed aliases exist.
/---
function is_alias() {
    # Validate passed arguments.
    die_unless_args 'expected at least one alias name'

    # Sadly, alias() explicitly requires option "-s" for testing suffix aliases
    # and no such option for testing normal and global aliases. Hence, iterate
    # such aliases and manually apply such options.
    for alias_name__ia ("${@}") {
        is_alias_normal_or_global "${alias_name__ia}" or
        is_alias_suffix "${alias_name__ia}" or
            return_false
    }

    # All such aliases exist. Return jubilation.
    return_true
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_normal(string alias_name1, string alias_name2, ...)

Return success if all passed *normal aliases* (i.e., aliases expanded only in
command position) exist.
/---
function is_alias_normal() {
    # Validate sanity.
    die_unless_args 'expected at least one alias name'
    is_map_key aliases "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_global(string alias_name1, string alias_name2, ...)

Return success if all passed *global aliases* (i.e., aliases expanded in _all_
positions, not merely command position) exist.
/---
function is_alias_global() {
    die_unless_args 'expected at least one alias name'
    is_map_key galiases "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_normal_or_global(
    string alias_name1, string alias_name2, ...)

Return success if all passed aliases are existing *normal or global aliases*
(i.e., non-suffix aliases).
/---
function is_alias_normal_or_global() {
    die_unless_args 'expected at least one alias name'
    run_command_silent alias -- "${@}"
}

declare_function_with_stdin <<'/---'
[status: boolean] is_alias_suffix(
    string alias_name1, string alias_name2, ...)

Return success if all passed suffix aliases exist.
/---
function is_alias_suffix() {
    die_unless_args 'expected at least one alias name'
    run_command_silent alias_suffix -- "${@}"
}

# ....................{ TESTERS ~ file                     }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_file_alias_suffixed(string filename)

Return success if a suffix alias exists for the filetype of the passed file.
/---
function is_file_alias_suffixed() {
    die_unless_arg 'expected one filename'
    string filetype; filetype="$(get_file_type_if_found "${1}")"
    is_string_nonempty "${filetype}" and is_alias_suffix "${filetype}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_alias_expansion(string alias_name)

Get the string to which the passed alias expands: e.g.,

.get_alias_expansion()
==========================================
[source]
------------------------------------------
>>> alias on_idleness='print_string\
...    "Suppose that, at a given moment, a certain number of people are engaged
...     in the manufacture of pins. They make as many pins as the world needs,
...     working (say) eight hours a day. Someone makes an invention by which the
...     same number of men can make twice as many pins: pins are already so
...     cheap that hardly any more will be bought at a lower price. In a
...     sensible world, everybody concerned in the manufacturing of pins would
...     take to working four hours instead of eight, and everything else would
...     go on as before. But in the actual world this would be thought
...     demoralizing. The men still work eight hours, there are too many pins,
...     some employers go bankrupt, and half the men previously concerned in
...     making pins are thrown out of work. There is, in the end, just as much
...     leisure as on the other plan, but half the men are totally idle while
...     half are still overworked. In this way, it is insured that the
...     unavoidable leisure shall cause misery all round instead of being a
...     universal source of happiness. Can anything more insane be imagined?"'
>>> get_string_line "$(get_alias_expansion on_idleness)" -1
universal source of happiness. Can anything more insane be imagined?
------------------------------------------
==========================================
/---
function get_alias_expansion() {
    # Validate passed arguments.
    die_unless_arg 'expected one alias name'
    string alias_name="${1}"
    die_unless_alias "${alias_name}"

    # Get such expansion. Happily, this is remarkably straight-forward.
    whence -- "${alias_name}"
}

# ....................{ GETTERS ~ list                     }....................
declare_function_with_stdin <<'/---'
string get_aliases(void)

List all alias names, delimited by newline.
/---
function get_aliases() {
    die_if_args
    get_aliases_normal_or_global
    get_aliases_suffix
}

declare_function_with_stdin <<'/---'
string get_aliases_normal_or_global(void)

List all *normal and global alias* names (i.e., non-suffix alias names),
delimited by newline.
/---
function get_aliases_normal_or_global() {
    die_if_args
    alias +
}

declare_function_with_stdin <<'/---'
string get_aliases_suffix(void)

List all suffix alias names, delimited by newline.
/---
function get_aliases_suffix() {
    die_if_args
    alias +s
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_list_to_aliases(string list_name)

Set the passed list to all alias names.
/---
function set_list_to_aliases() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__slta="${1}"
    die_unless_list "${list_name__slta}"

    # Set such list.
    set_list_to_string_lines "${list_name__slta}" "$(get_aliases)"
}

declare_function_with_stdin <<'/---'
void set_list_to_aliases_normal_or_global(string list_name)

Set the passed list to all normal and global alias (i.e., non-suffix alias)
names.
/---
function set_list_to_aliases_normal_or_global() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltanag="${1}"
    die_unless_list "${list_name__sltanag}"

    # Set such list.
    set_list_to_string_lines\
        "${list_name__sltanag}" "$(get_aliases_normal_or_global)"
}

declare_function_with_stdin <<'/---'
void set_list_to_aliases_suffix(string list_name)

Set the passed list to all suffix alias names.
/---
function set_list_to_aliases_suffix() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltas="${1}"
    die_unless_list "${list_name__sltas}"

    # Set such list.
    set_list_to_string_lines "${list_name__sltas}" "$(get_aliases_suffix)"
}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void undefine_alias(string alias_name1, string alias_name2, ...)

Undefine the passed aliases.
/---
function undefine_alias() {
    # Validate passed arguments.
    die_unless_args 'expected at least one alias name'

    # Sadly, unhash() and hence unalias() explicitly require option "-s" for
    # removing suffix aliases and no such option for removing normal and global
    # aliases. Hence, iterate such aliases and manually apply such options.
    # For efficiency, avoid calling Zeshy functions.
    for aluas_name__ua ("${@}") {
        # If such alias is a non-suffix alias, undefine such alias as such. See
        # is_alias_normal_or_global() for further details.
        if { alias -- "${aluas_name__ua}" &>/dev/null } {
            unalias    -- "${aluas_name__ua}"
        # Else, such alias is a non-suffix alias. Undefine such alias as such.
        } else {
            unalias -s -- "${aluas_name__ua}"
        }
    }
}

declare_function_with_stdin <<'/---'
void undefine_alias_normal_or_global(
    string alias_name1, string alias_name2, ...)

Undefine the passed normal or global aliases (i.e., non-suffix aliases).
/---
function undefine_alias_normal_or_global() {
    die_unless_args 'expected at least one alias name'
    unalias    -- "${aluas_name__ua}"
}

declare_function_with_stdin <<'/---'
void undefine_alias_suffix(string alias_name1, string alias_name2, ...)

Undefine the passed suffix aliases.
/---
function undefine_alias_suffix() {
    die_unless_args 'expected at least one alias name'
    unalias -s -- "${aluas_name__ua}"
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Replace with a call to a new is_map_keys() function, which can be
    #efficiently implemented by embedding the entire loop in an "eval".
    # Test such aliases.
#   for alias_name ("${@}") {
#       (( ${+aliases[${alias_name}]} )) or return_false
#   }
#   return_true
    #FUXME: Generalize to accept multiple alias names. To do so, we'll want to
    #implement a new function is_map_keys() returning success only if all passed
    #keys exist in the passed map. This should be considerably faster than
    #performing an explicit loop. Such function may be implemented by noting
    #that "(( ${map[(i)(${(q)1}|...|${(q)@[-1]})]} <= ${#map} ))"
    #implements such test. I'm not quite sure about the "(q)"; however, we'll
    #certainly need some form of escaping. Right. "(q)" should do it, I think.
    #For efficiency, we certainly wouldn't want to call escape_string()
    #repeatedly. Unsure how to efficiently construct the list of keys, however.
    #Shouldn't be terribly hard; just contemplate it.
