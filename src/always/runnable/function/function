#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle core function functionality.
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_function(
    string function_name,
    string error_message = "\"${function_name}\" not a function")

Throw an exception with the passed message unless the passed function exists.
/---
function die_unless_function() {
    die_unless_args_1_to_2\
        'expected one function name and optional error message'
    string function_name="${1}"
    is_function "${function_name}" or
        die "${2:-\"${function_name}\" not a function}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_function(string function_name1, string function_name1, ...)

Return true if all passed functions exist.
/---
function is_function() {
    die_unless_args 'expected at least one function name'
    run_command_silent typeset -f -- "${@}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_functions(void)

List all function names, delimited by newline.
/---
function get_functions() {
    die_if_args
    typeset +f
}

declare_function_with_stdin <<'/---'
string get_functions_math(void)

List all *user-defined math function* (i.e., functions declared by
`functions -M`) names, delimited by newline.
/---
function get_functions_math() {
    die_if_args
    functions -M
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_list_to_functions(string list_name)

Set the passed list to all function names.
/---
function set_list_to_functions() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name__sltf="${1}"
    die_unless_list "${list_name__sltf}"

    # Set such list.
    set_list_to_string_lines "${list_name__sltf}" "$(get_functions)"
}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void undefine_function(string function_name1, string function_name2, ...)

Undefine the passed functions.
/---
function undefine_function() {
    die_unless_args 'expected at least one function name'
    unfunction -- "${@}"
}

# ....................{ DEFINERS ~ enable                  }....................
declare_function_with_stdin <<'/---'
void disable_function(string function_name1, string function_name2, ...)

Disable the passed functions. Disabled functions remain defined but uncallable
until reenabled by enable_function().
/---
function disable_function() {
    die_unless_args 'expected at least one function name'
    disable -f -- "${@}"
}

declare_function_with_stdin <<'/---'
void enable_function(string function_name)

Enable the passed functions. Since all functions are enabled by default, this is
useful for only undoing prior calls to disable_function().
/---
function enable_function() {
    die_unless_args 'expected at least one function name'
    enable -f -- "${@}"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_function(string function_name)

Print the passed function's definition.
/---
function print_function() {
    # Validate passed arguments.
    die_unless_arg 'expected one function name'
    string function_name="${1}"
    die_unless_function "${function_name}"

    # Print such function.
    whence -f -- "${function_name}"
}

# ....................{ PRINTERS ~ line                    }....................
declare_function_with_stdin <<'/---'
string print_function_line_contextually(
    string function_name, integer line_number)

Print the passed line of the passed function contextually. If such function is
sufficiently small (e.g., less than six lines), print the complete function
definition; otherwise, print only the passed line and some number of lines
preceding and succeeding such line of such function definition as context.
/---
function print_function_line_contextually() {
    # Validate passed arguments.
    die_unless_args_2 'expected one function name and one line number'
    string function_name="${1}" line_number="${2}"
    die_unless_function "${function_name}"
    die_unless_integer_positive "${line_number}"

    #FIXME: Sadly, this isn't quite right. The line number appears to be
    #relative to the original function definition in the source file. Here's a
    #simple test:
    #
    #    command dirs -p | number_lines_highlighting_line 0
    #
    #zsh reports the failing command on a line number that could only be the
    #original file including comments and blank lines. Sadly, that means we
    #can't reliably highlight line numbers for any functions except those defined
    #in the Zeshy digest. It also means we have to manually map the function
    #name to the exact block of code in the exact Zeshy file defining such
    #function, taking into account things like conditional themes. (Commands
    #needn't be considered. But themes must.) It's all highly annoying, and
    #frankly somewhat out of bounds at the moment.
    #
    #How about this: for the moment, drop the line number highlighting. It's
    #erroneous and unhelpful. When time permits re-implement this conditional to:
    #
    #* If this function is a Zeshy function (i.e., is compiled into the Zeshy
    #  digest), perform the above behavior with line number highlighting using
    #  "awk" and a similar script to below.
    #* Otherwise, print a code listing with no such highlighting using "nl".
    #
    #Because this probably relies on advanced Zeshy functionality not readily
    #implementable without access to the Zeshy codebase, we should segregate
    #this into an autoload function (say, print_function_highlighting_line()).
    #Then test here for the existence of such function. If available, call it;
    #otherwise, do nothing. (No error, if it doesn't exist yet.)

    # If the most recent stack frame signifies an existing function, print that
    # function's definition to standard error as line-numbered code. Since line
    # numbers in stack frames start from the first line of such definition while
    # the default printer for such definitions starts from the prior line
    # declaring the function name, do *NOT* number the first printed line.
    print -- "\n${funcname_first}() failed on line ${fileline_first}."
    whence -f -- "${funcname_first}" | awk -vNRBAD=${fileline_first} '
# If the function name, print a hyphen in place of the current line number
# followed by the name.
NR == 1 {
    printf("%6s   %s\n", "-", $0)
}
# If any line other than the erroneous line, print the current line number
# followed by the line. (Due to the prefixing function name declaration, the
# current line number is one larger than expected. Subtract one for comparison.)
NR > 1 && NR-1 != NRBAD {
    # If this line is "}" and hence the end of this function definition, print
    # hyphens in place of the current line number followed by the "}".
    if ($0 == "}") {
        NREND=NR
        gsub(/./, "-", NREND)
        printf("%6s   }\n", NREND)
    }
    else {
        printf("%6d   %s\n", NR-1, $0)
    }
}
# If the erroneous line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (What? YOU CAN DO BETTER!?)
NR-1 == NRBAD {
    # Number of digits in the current line number.
    NRLEN = length(NR-1);
         if (NRLEN==1) {NRNOW = " <-~ " NR-1}
    else if (NRLEN==2) {NRNOW = "<-~ " NR-1}
    else if (NRLEN==3) {NRNOW = "<- " NR-1}
    else               {NRNOW = NR-1}       # if true, your function is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}' 2>&1
}

# --------------------( WASTELANDS                         )--------------------
# if previously disabled by disable_function()
    # Validate sanity.
#   die_if_args

    # While bash has a builtin means of listing such names (i.e., "typeset -F"),
    # zsh surprisingly does not. Hence, we manually implement such listing by
    # parsing the output of builtin whence(). First, list all current runnables.
#   string runnable_names; runnable_names="$(whence -wm '*')"

    # Filter non-functions from such list.
#   remove_list_nonmatches runnable_names '*: function'

    # Print such list.
#   page_string "${runnable_names}"

# Globally re-enable the function with the passed name, presumably previously
# disabled with a call to disable_function().
#   if [[ -n "${ZESHY_IS_DEBUGGING-}" && -n "${funcname_first}" &&\
#         "$(whence -w -- "${funcname_first}")" == *': function' ]]; then
#   is "$(whence -w -- "${1}")" == *': function' si

# ....................{ GETTERS                            }....................
# string list_functions(void)
#
# List all currently declared zsh function names delimited by newlines.
#list_functions() {
#    die_if_args
#    typeset -f +   # yes, this is mind-numbingly crazy
#}

# string output(int number)
#
# Return the passed integer from the current function.
#output() {
#    die_unless_arg 'expected one integer'
#    print -- "${1}"
#}

# string output(string text1, string text2, ...)
#
# Return the concatenation of the passed strings from the current function.
#output() {
#    die_unless_args 'expected at least one string'
#    print -- "${@}"
#}
