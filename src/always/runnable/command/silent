#!/usr/bin/env zsh
# ====================[ silence                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle command output silencing (i.e., squelching standard output and/or
# error).

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'-\-'
void run_command_silent(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command silently, squelching both standard output and error.
-\-
function run_command_silent() {
    run_command "${@}" &>/dev/null
}

declare_function_with_stdin <<'-\-'
void run_command_silent_stdout(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command with no standard output. This function preserves standard
error and hence prints warnings, exceptions, and similar error messages.
-\-
function run_command_silent_stdout() {
    run_command "${@}" 1>/dev/null
}

declare_function_with_stdin <<'-\-'
void run_command_silent_stderr(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command with no standard error. This function preserves standard
output and hence silences only warnings, exceptions, and similar error messages.
-\-
function run_command_silent_stderr() {
    run_command "${@}" 2>/dev/null
}

# ....................{ RUNNERS ~ exit status              }....................
declare_function_with_stdin <<'-\-'
string run_command_silent_and_get_exit_status(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command silently (i.e., squelching output) and get the exit
status of such command: e.g.,

.run_command_silent_and_get_exit_status()
==========================================
[source]
------------------------------------------
>>> run_command_silent_and_get_exit_status grep "*" /no/such/path/exists
2
------------------------------------------
==========================================
-\-
function run_command_silent_and_get_exit_status() {
    run_command_silent "${@}" | return_exit_status
}

declare_function_with_stdin <<'-\-'
string run_command_silent_and_get_exit_status_boolean(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command silently (i.e., squelching output) and, if exiting
with zero exit status, return `1`; otherwise, return the empty string: e.g.,

.run_command_silent_and_get_exit_status_boolean()
==========================================
[source]
------------------------------------------
>>> boolean IS_MUTT_PATHABLE=$(\
...     run_command_silent_and_get_exit_status_boolean is_pathable mutt)
>>> is_boolean_true "${IS_MUTT_PATHABLE}" and print_string \"mutt\" installed
"mutt" installed
------------------------------------------
==========================================
-\-
function run_command_silent_and_get_exit_status_boolean() {
    if { run_command_silent "${@}" } {
        return_string 1
    } else {
        return_true
    }
}

# --------------------( WASTELANDS                         )--------------------
    # Obscenely clever, if we may say so. (We may!) See
    # return_exit_status() for similar logic.
# Preserving standard error preventsdd warnings, errors, and exceptions.
