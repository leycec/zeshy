#!/usr/bin/env zsh
# ====================[ redirect                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle command output redirection (e.g., to standard error or file).

# ....................{ RUNNERS                            }....................
declare_function '
string run_command_into_stdout(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command, redirecting standard error to output.
'
function run_command_into_stdout() {
    run_command "${@}" 2>&1
}

declare_function '
string run_command_into_stderr(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command, redirecting standard output to error.
'
function run_command_into_stderr() {
    run_command "${@}" 1>&2
}

# ....................{ RUNNERS ~ variable                 }....................
declare_function '
string run_command_and_set_string_to_stdout(
  string command_name, string command_arg1, string command_arg2, ...,
  string string_name)

Run the passed command, printing standard output and error as normal and setting
the passed string to all printed standard output but not error.
'
function run_command_and_set_string_to_stdout() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one string name'
    string string_name__rcassts="${@[-1]}"
    pop_arg

    # File descriptor opened for writing to the current shell's stdout. Since
    # the subshell invoked below "replaces" the current shell's stdout with its
    # own, storing such stdout here permits its access in such subshell.
    file_descriptor stdout__rcassts
    open_file_descriptor_to_stdout stdout__rcassts

    # Run such command with output captured into such string *AND* redirected to
    # the subshell's stdout (to be captured into such string) and the current
    # shell's stdout.
    set_string_to_string ${string_name__rcassts}\
        "$(run_command "${@}" >&1 >&${stdout__rcassts})"

    # Close such descriptor.
    close_file_descriptor stdout__rcassts
}

# ....................{ RUNNERS ~ file                     }....................
declare_function '
void run_command_into_file(
  string command_name, string command_arg1, string command_arg2, ...,
  string filename)

Run the passed command, redirecting both standard output and error to the passed
file by overwriting such file with such output.
'
function run_command_into_file() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one filename'
    string filename="${@[-1]}"
    die_unless_file_plain_or_not_path "${filename}"
    pop_arg

    # Run such command.
    run_command "${@}" >&!"${filename}"
}

declare_function '
void run_command_stdout_into_file(
  string command_name, string command_arg1, string command_arg2, ...,
  string filename)

Run the passed command, redirecting standard output (but not error) to the
passed file by overwriting such file with such output.
'
function run_command_stdout_into_file() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one filename'
    string filename="${@[-1]}"
    die_unless_file_plain_or_not_path "${filename}"
    pop_arg

    # Run such command.
    run_command "${@}" >!"${filename}"
}

# --------------------( WASTELANDS                         )--------------------
#   exec 3>&1
#   exec {stdout__rcassts}>&1
#       "$(run_command "${@}" >&1 >&3)"

    #FUXME: Rewrite to use set_string(), which, incidentally, should be renamed
    #to set_string_to_string().
#   string output__rcassts
#   output__rcassts="$(run_command "${@}" >&1 >&${stdout__rcassts})"
#   eval ${string_name__rcassts}="${output__rcassts}"
#   eval ${string_name__rcassts}="\$(run_command "\${@}" >&1 >&${stdout__rcassts})"
#   eval "${string_name__rcassts}=\"\$(run_command "\${@}" >&1 >&${stdout__rcassts})\""

        #FUXME: While this certainly works, coercively redirecting *ALL* output
        #to standard error is really not the best idea. Turns out, there's a
        #much better way: before the process substitution, duplicate filehandle
        #1 to a new function-specific filehandle -- say, 3. (Hmm; actually, is
        #there a way to select the next available filehandle? We certainly don't
        #want to muck up 3, if the caller has already open such handle. I
        #suppose we could readily implement such a function ourselves by
        #iteratively testing each filehandle until finding one not currently
        #open. Right; pretty easy, actually. Check to make sure zsh doesn't
        #already provide such functionality, however.) In any case, assume 3 for
        #now. Then the following code inspired by
        #http://stackoverflow.com/questions/12451278/bash-capture-stdout-to-a-variable-but-still-display-it-in-the-console
        #both prints *AND* captures output in real-time:
        #
        #    exec 3>&1
        #    FF=$(ls / | tee >(cat - >&3))
        #    print $FF
        #
        #Awesome, huh? Not terribly simple, but it works. I wonder if zsh
        #provides an even simpler mechanism for effecting this, ideally not
        #calling the external "tee" or "cat" commands? Right. It looks like
        #setting MULTIOS (which of course we do), should permit something like:
        #
        #    exec 3>&1               # duplicate stdout to new filehandle 3
        #    FF=$({ ls / } >&1 >&3)  # run "ls /", both captured and printed!
        #    print $FF               # print the captured string, to be sure
        #
        #The additional "{" or "}" may or may not be necessary to ensure proper
        #behavior. They don't really hurt, in any case. See "MULTIOS" in "man
        #zshmisc" for details.
        #
        #I've confirmed it. That actually works! (Without the "{", it turns out.
        #Let's leave the braces out for now... until it breaks, anyway.) Greaat!
        #This is astonishingly easy to implement. Perhaps we could encapsulate
        #such functionality in a new setter function -- say, either
        #set_string_to_command_stdout() or
        #run_command_into_stdout_and_set_string()? The former's fairly nice,
        #called like so:
        #
        #    string output
        #    set_string_to_command_stdout output "${@}"
        #
        #And... that's it. set_string_to_command_stdout() just implements the
        #above MULTIOS-style redirection trickery. Nice, no? Oh, and we'll
        #probably want to implement a new function or alias performing filehandle
        #duplication. "exec 3>&1" is just not the most readable code.
        #FUXME: Hmmm; rather than set_string_to_command_stdout(), how about:
        #run_command_into_stdout_and_variable()? O.K.; that's great. It coincides
        #much better with existing nomenclature *AND* is a proper "run_command_"-
        #prefixed function name, as expected by run(). Go, go! It *DOES* mean
        #appending rather than prepending the variable name, which I typically
        #dislike -- but here, the fact that we're eval-ing the passed command is
        #much more important than nomenclature preferences.
        #FUXME: O.K.; how about:
        #run_command_and_set_string_to_stdout()? Perfect, no?

#FUXME: I've become increasingly less fond of such nomenclature. It's just too
#verbose, and needlessly so. Everyone knows what "stdout" and "stderr" refers
#to, so just refer to them as such. Also, avoid the preposition "to" here, which
#we use elsewhere to denote a "set" verb. This isn't setting; it's...well,
#output. So how about the preposition "into," instead? All told, this gives us
#the following renamings:
#
#* run_command_into_stdout().
#* run_command_into_stderr().
#* run_command_into_file().

#FUXME: Rename to run_command_silent_output_exit_status().
#FUXME: Rename run_command_redirecting_to_*() to run_command_redirected_to_*() everywhere below.
#Actually, how about just run_command_output_*().
