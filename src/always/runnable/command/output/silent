#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle running commands *silenced* (i.e., squelching all standard output and/or
error from such command).
-/-

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
[status: integer] run_command_silent(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command silently, squelching both standard output and error.
/---
function run_command_silent() {
    run_command "${@}" &>/dev/null
}

declare_function_with_stdin <<'/---'
[status: integer] run_command_silent_stdout(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command partially silently, squelching standard output but _not_
error. Preserving standard error preserves warnings and errors.
/---
function run_command_silent_stdout() {
    run_command "${@}" 1>/dev/null
}

declare_function_with_stdin <<'/---'
void run_command_silent_stderr(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command partially silently, squelching standard error but _not_
output. Preserving standard output silences only warnings and errors.
/---
function run_command_silent_stderr() {
    run_command "${@}" 2>/dev/null
}

# ....................{ RUNNERS ~ exit status              }....................
declare_function_with_stdin <<'/---'
string run_command_silent_and_get_exit_status(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command *silently* (i.e., squelching both standard output and
error) and output the exit status of such command: e.g.,

.run_command_silent_and_get_exit_status()
==========================================
[source]
------------------------------------------
>>> run_command_silent_and_get_exit_status grep "*" /no/such/path/exists
2
------------------------------------------
==========================================
/---
function run_command_silent_and_get_exit_status() {
    run_command_silent "${@}" and get_exit_status
}

declare_function_with_stdin <<'/---'
string run_command_silent_and_get_exit_status_boolean(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command silently *silently* (i.e., squelching both standard
output and error). If such command *fails* (i.e., returns zero exit status), return `1`; otherwise, return the empty string: e.g.,

.run_command_silent_and_get_exit_status_boolean()
==========================================
[source]
------------------------------------------
>>> boolean IS_MUTT_PATHABLE=$(\
...     run_command_silent_and_get_exit_status_boolean is_pathable mutt)
>>> is_boolean_true "${IS_MUTT_PATHABLE}" and print_string \"mutt\" installed
"mutt" installed
------------------------------------------
==========================================
/---
function run_command_silent_and_get_exit_status_boolean() {
    if { run_command_silent "${@}" } {
        return_string "${ZESHY_BOOLEAN_TRUE}"
    } else {
        return_string "${ZESHY_BOOLEAN_FALSE}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    # Obscenely clever, if we may say so. (We may!) See
    # return_exit_status() for similar logic.
# Preserving standard error preventsdd warnings, errors, and exceptions.
