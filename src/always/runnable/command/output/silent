#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *silent commands* (i.e., commands whose standard output and/or error is
redirected to the bit bucket and hence ``squelched'').
-/-

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
[status: integer] run_command_silent(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command *silently* (i.e., squelching standard output and error).
/---
function run_command_silent() {
    run_command "${@}" &>/dev/null
}

declare_function_with_stdin <<'/---'
[stderr: string, status: integer] run_command_silent_stdout(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command, silencing standard output but _not_ error. Preserving
standard error preserves warnings and errors.
/---
function run_command_silent_stdout() {
    run_command "${@}" 1>/dev/null
}

declare_function_with_stdin <<'/---'
[stdout: string, status: integer] run_command_silent_stderr(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command, silencing standard error but _not_ output. Preserving
standard output silences only warnings and errors.
/---
function run_command_silent_stderr() {
    run_command "${@}" 2>/dev/null
}

# ....................{ GETTERS                            }....................
#FIXME: Improve examples.
declare_function_with_stdin <<'/---'
integer run_command_silent_and_get_exit_status(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command *silently* (i.e., squelching standard output and error)
and return the exit status of such command: e.g.,

.run_command_silent_and_get_exit_status()
==========================================
[source]
------------------------------------------
>>> run_command_silent_and_get_exit_status 'grep "*" /no/such/path/exists'
2
------------------------------------------
==========================================
/---
function run_command_silent_and_get_exit_status() {
    run_command_silent "${@}" and get_exit_status
}

declare_function_with_stdin <<'/---'
boolean run_command_silent_and_get_exit_status_boolean(
    string command_name, string command_arg1, string command_arg2, ...)

Run the passed command *silently* (i.e., squelching standard output and error)
and return the exit status of such command converted into a boolean value.
Specifically, if such command:

* Succeeds (i.e., returns zero exit status), return ${ZESHY_BOOLEAN_TRUE}.
* fails (i.e., returns nonzero exit status), return ${ZESHY_BOOLEAN_FALSE}.

For example:

.run_command_silent_and_get_exit_status_boolean()
==========================================
[source]
------------------------------------------
>>> boolean IS_MUTT_PATHABLE=$(\
...     run_command_silent_and_get_exit_status_boolean is_pathable mutt)
>>> (( IS_MUTT_PATHABLE )) and print_string '"mutt" installed'
"mutt" installed
------------------------------------------
==========================================
/---
function run_command_silent_and_get_exit_status_boolean() {
    if { run_command_silent "${@}" } {
        return_string "${ZESHY_BOOLEAN_TRUE}"
    } else {
        return_string "${ZESHY_BOOLEAN_FALSE}"
    }
}

# ....................{ WRITERS                            }....................
declare_function_with_stdin <<'/---'
[status: integer] run_command_silent_and_write_file_with_output(
    string command_name, string command_arg1, string command_arg2, ...,
    string filename)

Run the passed command *silently* (i.e., squelching standard output and error)
and overwrite the passed file with all output (both standard output and error)
from such command.
/---
function run_command_silent_and_write_file_with_output() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'Expected one command and one filename.'
    string filename__rcsawfwo="${@[-1]}"
    die_unless_file_regular_or_not_path "${filename__rcsawfwo}"
    pop_arg

    # Run such command.
    run_command "${@}" >&!"${filename__rcsawfwo}"
}

declare_function_with_stdin <<'/---'
[stderr: string, status: integer]
    run_command_silent_stdout_and_write_file_with_stdout(
        string command_name, string command_arg1, string command_arg2, ...,
        string filename)

Run the passed command, silencing standard output (but _not_ error) and
overwriting the passed file with such output.
/---
function run_command_silent_stdout_and_write_file_with_stdout() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'Expected one command and one filename.'
    string filename__rcssawfws="${@[-1]}"
    die_unless_file_regular_or_not_path "${filename__rcssawfws}"
    pop_arg

    # Run such command.
    run_command "${@}" >!"${filename__rcssawfws}"
}

# --------------------( WASTELANDS                         )--------------------
    # Validate sanity.
#   die_unless_args_2_or_more 'Expected one command and one string name.'
#   string string_name__rcassto="${@[-1]}"
#   pop_arg

    # Run such command and set such string.
#   run_command "${@}" 2>/dev/null |
#       set_string_to_stdin "${string_name__rcassto}"

#       print -pr $'\C-D'
#       print -r "ughugh" >&p
#       print -r $'\C-D' >&p
#       print -r '-----' >&p
#       print -r "ohhohh" >&p
#       eval ${string_name__rcasste}'="$(< /dev/stdin)" <&p'

#Since coprocesses
    # typically loop on standard input until receiving EOF and since there
    # exists no sane 
#See the above discussion.
    # Absolute path of a temporary file to which standard error is to be
    # redirected below.
#   stderr_filename__rcasste="$(make_file_temporary)"

#   {
        # Run such command and set such string.
#       output_string "variable: ${string_name__rcasste}; command: ${@}"
#       run_command "${@}" 1>/dev/null 2>"${stderr_filename__rcasste}"
#   } always {
#       remove_file "${stderr_filename__rcasste}"
#   }

    #FUXME: This runs such command in a subshell and hence fails in the general
    #case. To fix this, we'll probably have to redirect stderr (and stdout in the
    #prior function) to a temporary file and then "cat" such file. Craziness, I
    #know; but it's literally the only way. *shrug*

    # Run such command and set such string. This is surprisingly difficult. In
    # particular, note the internal delimiters "{" and "}" *ARE* requisite;
    # oddly, removing them induces zsh to ignore the redirection "1>/dev/null".
#   output_string "variable: ${string_name__rcasste}; command: ${@}"
#   { run_command "${@}" 1>/dev/null } |&
#       set_string_to_stdin "${string_name__rcasste}"

    # Nonetheless, there exist 
    #
    # While typically beneficial, the inability
    # to export modifications *UP* the shell hierarchy from
    #
    # Since *NO* shell including zsh provides a builtin mechanism
    # for exporting 

#; removing them
    # effectively reduces this function to run_command_silent()
#   { eval "yim=( /*(#qZ) )" 1>/dev/null } |& set_string_to_stdin_pipe lil
#   set_string_to_string "${string_name__rcasste}" "$({
#       run_command "${@}" 1>/dev/null
#   } 2>&1)"

#, redirecting both standard output and error to the passed
#file by overwriting such file with such output.

#Run the passed command partially silently, squelching standard error but _not_
#output. Preserving standard output silences only warnings and errors.

#partially silently, squelching standard output but _not_
#error. Preserving standard error preserves warnings and errors.

    # Obscenely clever, if we may say so. (We may!) See
    # return_exit_status() for similar logic.
# Preserving standard error preventsdd warnings, errors, and exceptions.
