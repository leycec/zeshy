#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle command output redirection.
-/-

# ....................{ RUNNERS                            }....................
# For safety, apply redirections outside rather than inside the command(s) to be
# run (e.g., 'run_command "${@}" 2>&1' rather than 'run_command "${@} 2>&1"').
# The latter only applies to the last command embedded in such string, whereas
# the former applies to *ALL* commands embedded in such string. This is also
# achievable by delimiting such command by "{" and "}" (e.g.,
# 'run_command "{ ${@} } 2>&1"'), but more elegantly as below.

#FIXME: Rename to run_command_redirecting_stderr_to_stdout().
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: integer]
    run_command_into_stdout(
        string command_name, string command_arg1, string command_arg2, ...)

Run the passed command, redirecting standard error to output.
/---
function run_command_into_stdout() {
    run_command "${@}" 2>&1
}

#FIXME: Rename to run_command_redirecting_stdout_to_stderr().
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: integer]
    run_command_into_stderr(
        string command_name, string command_arg1, string command_arg2, ...)

Run the passed command, redirecting standard output to error.
/---
function run_command_into_stderr() {
    run_command "${@}" 1>&2
}

# ....................{ RUNNERS ~ variable                 }....................
declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: integer]
    run_command_and_set_string_to_stdout(
        string command_name, string command_arg1, string command_arg2, ...,
        string string_name)

Run the passed command, printing standard output and error as normal and setting
the passed string to all printed standard output but _not_ error.
/---
function run_command_and_set_string_to_stdout() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one string name'
    string string_name__rcassto="${@[-1]}"
    pop_arg

    # File descriptor opened for writing to standard output for the current
    # shell. Since the subshell invoked below substitutes such output with its
    # own, storing a handle to such output permits its access in such subshell.
    file_descriptor stdout__rcassto
    {
        open_file_descriptor_to_stdout stdout__rcassto

        # Run such command and set such string. Dismantled, this is:
        #
        # * "1>&1", redirecting standard output for the subshell to itself.
        #   While redundant, this ensures such output survives subsequent
        #   redirection under shell option "MULTIOS" and is hence captured into
        #   such string.
        # * "1>&${...}", redirecting standard output for the subshell to
        #   standard output for the current shell.
        #
        # Since command substitution does *NOT* capture standard error, this has
        # the beneficial side effect of printing standard error as normal.
        set_string_to_string "${string_name__rcassto}"\
            "$(run_command "${@}" 1>&1 1>&${stdout__rcassto})"
    # Close such descriptor safely (e.g., in the event of an exception).
    } always {
        close_file_descriptor_if_open stdout__rcassto
    }
}

declare_function_with_stdin <<'/---'
[stdout: string, stderr: string, status: integer]
    run_command_and_set_string_to_stderr(
        string command_name, string command_arg1, string command_arg2, ...,
        string string_name)

Run the passed command, printing standard output and error as normal and setting
the passed string to all printed standard error but _not_ output.
/---
function run_command_and_set_string_to_stderr() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one string name'
    string string_name__rcasste="${@[-1]}"
    pop_arg

    # File descriptors opened for writing to standard output and error for the
    # current shell. Since the subshell invoked below substitutes such output
    # with its own, storing handles to such output permits their access in such
    # subshell.
    file_descriptor stdout__rcasste stderr__rcasste
    {
        open_file_descriptor_to_stdout stdout__rcasste
        open_file_descriptor_to_stderr stderr__rcasste

        # Run such command and set such string. Dismantled, this is:
        #
        # * "2>&1", redirecting standard error to output for the subshell,
        #   ensuring such output is captured into such string.
        # * "1>&${...}", redirecting standard output for the subshell to
        #   standard output for the current shell.
        # * "2>&${...}", redirecting standard error for the subshell to
        #   standard error for the current shell.
        set_string_to_string "${string_name__rcasste}" "$(run_command "${@}"\
            2>&1 1>&${stdout__rcasste} 2>&${stderr__rcasste})"
    # Close such descriptors safely (e.g., in the event of an exception).
    } always {
        close_file_descriptor_if_open stdout__rcasste
        close_file_descriptor_if_open stderr__rcasste
    }
}

#FIXME: In lieu of unit tests...
#function simo() {
#    string stdout stderr
#    run_command_and_set_string_to_stdout '{ print ok; print ko 1>&2; }' stdout
#    print "stdout: ${stdout}"
#    run_command_and_set_string_to_stderr '{ print ok; print ko 1>&2; }' stderr
#    print "stderr: ${stderr}"
#}

# ....................{ RUNNERS ~ file                     }....................
#FIXME: Rename to run_command_and_write_file_with_output().
declare_function_with_stdin <<'/---'
[status: integer] run_command_into_file(
    string command_name, string command_arg1, string command_arg2, ...,
    string filename)

Run the passed command, redirecting both standard output and error to the passed
file by overwriting such file with such output.
/---
function run_command_into_file() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one filename'
    string filename__rcif="${@[-1]}"
    die_unless_file_plain_or_not_path "${filename__rcif}"
    pop_arg

    # Run such command.
    run_command "${@}" >&!"${filename__rcif}"
}

#FIXME: Rename to run_command_writing_stdout_to_file().
declare_function_with_stdin <<'/---'
[stderr: string, status: integer] run_command_stdout_into_file(
    string command_name, string command_arg1, string command_arg2, ...,
    string filename)

Run the passed command, redirecting standard output (but not error) to the
passed file by overwriting such file with such output.
/---
function run_command_stdout_into_file() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one filename'
    string filename__rcsif="${@[-1]}"
    die_unless_file_plain_or_not_path "${filename__rcsif}"
    pop_arg

    # Run such command.
    run_command "${@}" >!"${filename__rcsif}"
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Clearly, this isn't right. ">&1" redirects *BOTH* stdout and
        #stderr to stdout, implying that you've now effectively destroyed
        #stderr. So, how do we *PRESERVE* stderr?
#           "$(run_command "${@}" ${ZESHY_STDERR_FILE_DESCRIPTOR}>&${ZESHY_STDOUT_FILE_DESCRIPTOR} ${ZESHY_STDOUT_FILE_DESCRIPTOR}>&${stdout__rcassts} ${ZESHY_STDERR_FILE_DESCRIPTOR}>&${stderr__rcassts})"

# (e.g., to standard error or file).
#   exec 3>&1
#   exec {stdout__rcassts}>&1
#       "$(run_command "${@}" >&1 >&3)"

    #FUXME: Rewrite to use set_string(), which, incidentally, should be renamed
    #to set_string_to_string().
#   string output__rcassts
#   output__rcassts="$(run_command "${@}" >&1 >&${stdout__rcassts})"
#   eval ${string_name__rcassts}="${output__rcassts}"
#   eval ${string_name__rcassts}="\$(run_command "\${@}" >&1 >&${stdout__rcassts})"
#   eval "${string_name__rcassts}=\"\$(run_command "\${@}" >&1 >&${stdout__rcassts})\""

        #FUXME: While this certainly works, coercively redirecting *ALL* output
        #to standard error is really not the best idea. Turns out, there's a
        #much better way: before the process substitution, duplicate filehandle
        #1 to a new function-specific filehandle -- say, 3. (Hmm; actually, is
        #there a way to select the next available filehandle? We certainly don't
        #want to muck up 3, if the caller has already open such handle. I
        #suppose we could readily implement such a function ourselves by
        #iteratively testing each filehandle until finding one not currently
        #open. Right; pretty easy, actually. Check to make sure zsh doesn't
        #already provide such functionality, however.) In any case, assume 3 for
        #now. Then the following code inspired by
        #http://stackoverflow.com/questions/12451278/bash-capture-stdout-to-a-variable-but-still-display-it-in-the-console
        #both prints *AND* captures output in real-time:
        #
        #    exec 3>&1
        #    FF=$(ls / | tee >(cat - >&3))
        #    print $FF
        #
        #Awesome, huh? Not terribly simple, but it works. I wonder if zsh
        #provides an even simpler mechanism for effecting this, ideally not
        #calling the external "tee" or "cat" commands? Right. It looks like
        #setting MULTIOS (which of course we do), should permit something like:
        #
        #    exec 3>&1               # duplicate stdout to new filehandle 3
        #    FF=$({ ls / } >&1 >&3)  # run "ls /", both captured and printed!
        #    print $FF               # print the captured string, to be sure
        #
        #The additional "{" or "}" may or may not be necessary to ensure proper
        #behavior. They don't really hurt, in any case. See "MULTIOS" in "man
        #zshmisc" for details.
        #
        #I've confirmed it. That actually works! (Without the "{", it turns out.
        #Let's leave the braces out for now... until it breaks, anyway.) Greaat!
        #This is astonishingly easy to implement. Perhaps we could encapsulate
        #such functionality in a new setter function -- say, either
        #set_string_to_command_stdout() or
        #run_command_into_stdout_and_set_string()? The former's fairly nice,
        #called like so:
        #
        #    string output
        #    set_string_to_command_stdout output "${@}"
        #
        #And... that's it. set_string_to_command_stdout() just implements the
        #above MULTIOS-style redirection trickery. Nice, no? Oh, and we'll
        #probably want to implement a new function or alias performing filehandle
        #duplication. "exec 3>&1" is just not the most readable code.
        #FUXME: Hmmm; rather than set_string_to_command_stdout(), how about:
        #run_command_into_stdout_and_variable()? O.K.; that's great. It coincides
        #much better with existing nomenclature *AND* is a proper "run_command_"-
        #prefixed function name, as expected by run(). Go, go! It *DOES* mean
        #appending rather than prepending the variable name, which I typically
        #dislike -- but here, the fact that we're eval-ing the passed command is
        #much more important than nomenclature preferences.
        #FUXME: O.K.; how about:
        #run_command_and_set_string_to_stdout()? Perfect, no?

#FUXME: I've become increasingly less fond of such nomenclature. It's just too
#verbose, and needlessly so. Everyone knows what "stdout" and "stderr" refers
#to, so just refer to them as such. Also, avoid the preposition "to" here, which
#we use elsewhere to denote a "set" verb. This isn't setting; it's...well,
#output. So how about the preposition "into," instead? All told, this gives us
#the following renamings:
#
#* run_command_into_stdout().
#* run_command_into_stderr().
#* run_command_into_file().

#FUXME: Rename to run_command_silent_output_exit_status().
#FUXME: Rename run_command_redirecting_to_*() to run_command_redirected_to_*() everywhere below.
#Actually, how about just run_command_output_*().
