#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle the *call stack* (i.e., list of all runnables transitively calling the
current runnable, typically beginning with the shell command and ending with
such runnable).
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_call_stack_contains(string runnable_name)

Return success if the call stack contains the passed *runnable* (i.e., function
or script), in which case such runnable is either the current function or
transitively called such function.
/---
function is_call_stack_contains() {
    # Validate sanity.
    die_unless_arg 'expected one runnable name'
#   print "function: ${1}\nfuncstack: ${funcstack[*]}"

    # Test such stack. Avoid calling additional functions (e.g.,
    # is_list_contains(), get_list_size()) to avoid polluting the same stack
    # being tested. See is_list_contains() for further details.
    (( ${funcstack[(ie)${1}]} <= ${#funcstack} ))
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_call_stack_size(void)

Get the size of the call stack, excluding the call to this function.
/---
function get_call_stack_size() {
    # Validate sanity.
    die_if_args

    # Get such size. Avoid calling additional functions (e.g.,
    # get_list_size()) to avoid polluting the same stack being manipulated.
    return_string $(( ${#funcstack} - 1 ))
}

# ....................{ GETTERS ~ root                     }....................
declare_function_with_stdin <<'/---'
string get_call_stack_root(void)

Get the *call stack root* (i.e., the runnable at the bottom of such stack and
hence responsible for initiating all calls on such stack). The format for such
string depends on the type of such runnable. Specifically, if such runnable is
a:

* Function, this is the name of such function.
* Script, this is the absolute or relative path with which such script was
  originally executed.
/---
function get_call_stack_root() {
    # If the call stack is nonempty, return the first runnable on such stack;
    # else, return "zeshy".
    die_if_args
    return_string "${funcstack[-1]-zeshy}"
}

declare_function_with_stdin <<'/---'
string get_call_stack_root_basename(void)

Get the basename of the call stack root. If such root is a script, this is the
basename of such script. Otherwise, this is equivalent to get_call_stack_root().
See such function for further details.
/---
function get_call_stack_root_basename() {
    die_if_args
    basename -- "$(get_call_stack_root)"
}

# ....................{ PRINTERS                           }....................
#FIXME: There appears to be a very curious oddity in zsh; sourcing a zsh script
#containing the line "return 1" produces the expected call stack, resembling:
#
#./tmpy.zsh: failed with exit status 1
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 8458093679346917924 }
#      \_ TRAPZERR() { ./tmpy.zsh: 2 }
#       \_ ./tmpy.zsh { zsh: 32 }
#
#Running a zsh script containing the line "exit 1" as a command, however,
#produces call stacks resembling:
#
#TRAPZERR: failed with exit status 20
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 7955925549229362501 }
#      \_ TRAPZERR() { /bin/zsh: 31 }
#
#In the latter case, zsh reports the call stack to contain no such command. But
#it gets worse! zsh fails to include commands in *ALL* call stacks; try
#"command ls zzmmmm", for example. This tends to produce inherently senseless
#error output. I suggest one of two solutions:
#
#* If "TRAPZERR" is the top of the call stack, print no call stack. (It's
#  meaningless, so don't even bother.) This is most certainly the simplest
#  solution. (Actually, I tried this. It blatantly sucks.)
#* Forcefully add the expected command to the top of the call stack. This is
#  much better, since the prior solution still crudely reports
#  "TRAPZERR: failed with exit status 20" when in fact we expect
#  "./tmpy.zsh: failed with exit status 1". Just not sure how to *GET* the
#  expected command name or exit status.

#FIXME: Fix the example. Don't just *SAY* what happens. Actually *SHOW* it.
declare_function_with_stdin <<'/---'
string print_call_stack(void)

Print a trace of the current call stack consisting of all previously called
functions, sourced files, and `eval` statements in the current call path,
excluding only the stack frame of the caller's call to this function.

Consider redirecting such output to standard error, especially when accompanying
such stack with error or warning messages. Doing so ensures that calling this
function from process substitutions (e.g., `$(get_zsh_version)`) prints to the
terminal device attached to the current shell rather than into a string captured
by such shell -- without requiring such shell explicitly print such stack: e.g.,

.print_call_stack()
==========================================
[source]
------------------------------------------
# Assuming neither "/spider" or "/murphy" exist, the following command
# substitution throws an exception printing a call stack trace to
# standard error without effort on our behalf.
>>> string first_file; first_file="$(get_first_file /spider /murphy)"
------------------------------------------
==========================================
/---
function print_call_stack() {
    # Validate passed arguments. For safety, avoid calling other functions both
    # here and below that might conceivably throw exceptions.
    die_if_args

    # Delimit such output from prior output, if necessary.
    start_stdout_printing_delimited

    # Call stack size.
    integer funcstack_size=${#funcstack}

    # Current stack frame.
    integer index

    # First stack frame to be printed, defaulting to the call to this function.
    # If die_with_exit_status() called this function, avoid printing both this
    # call and the call to die_with_exit_status(). As zeshy-specific internal
    # implementation details, such calls convey no useful context to external
    # zeshy users. (While hardly essential, this does improve output.)
    integer index_first=1
    if is "${funcstack_size}" -ge 3 and
          "${funcstack[2]}" == 'die_with_exit_status' si {
        index_first=3
    }

    # Line, function name, and filename from which the caller of the previous
    # stack frame called the current stack frame.
    integer caller_line
    string  caller_name filename

    #FIXME: Prefer UTF-8-specific multibyte aesthetics on capable terminals.
    # String with which to prefix each call stack line.
    string frame_prefix=" ${ZESHY_STYLE_TO_COLOR[print_call_stack.prefix]-}"'\_'

    # Print the current call stack, excluding the call to the current function.
    for (( index = index_first; index <= funcstack_size; index++ )) {
        # Split the current stack frame's funcfiletrace entry on the last colon
        # in that entry into this frame's filename and line number, thus
        # accounting for possible colons in filenames (e.g., from "colon:blow:7"
        # to filename "colon:blow" and line number 7).
        caller_name="${funcstack[${index}]}"
        caller_line="${funcfiletrace[${index}]##*:}"
           filename="${funcfiletrace[${index}]%:*}"

        # If this frame signifies a function, append "()" to such name. Sadly,
        # if a script with the same name exists (which is technically feasible,
        # given zsh support for double-quoted function names), there appears to
        # be no simple way of discerning between the two. *shrug*
        #
        # Note that, when called due to an exception thrown from an interactive
        # alias, such alias will be disabled here and hence not be recognized as
        # a function. Since such alias signifies an alias and not a function,
        # this is (arguably) not a bug. (Nothin' to see here, folks.)
        if { typeset -f -- "${caller_name}" &>/dev/null } {
            caller_name="${ZESHY_STYLE_TO_COLOR[print_call_stack.function_name]-}${caller_name}${ZESHY_STYLE_TO_COLOR[print_call_stack.function_parens]-}()"
        # If this frame signifies an "eval" statement, color accordingly.
        } elif is "${caller_name}" == '(eval)' si {
            caller_name="${ZESHY_STYLE_TO_COLOR[print_call_stack.eval_parens]-}(${ZESHY_STYLE_TO_COLOR[print_call_stack.eval_name]-}eval${ZESHY_STYLE_TO_COLOR[print_call_stack.eval_parens]-})"
        # Else, this frame signifies a shell script. Color accordingly.
        } else {
            caller_name="${ZESHY_STYLE_TO_COLOR[print_call_stack.script_quotes]-}\"${ZESHY_STYLE_TO_COLOR[print_call_stack.script_name]-}${caller_name}${ZESHY_STYLE_TO_COLOR[print_call_stack.script_quotes]-}\""
        }

        # Print the current stack frame.
        output_string\
            "${frame_prefix} ${caller_name} ${ZESHY_STYLE_TO_COLOR[print_call_stack.brace]-}{ ${ZESHY_STYLE_TO_COLOR[print_call_stack.filename]-}${filename}${ZESHY_STYLE_TO_COLOR[print_call_stack.colon]-}: ${ZESHY_STYLE_TO_COLOR[print_call_stack.line]-}${caller_line} ${ZESHY_STYLE_TO_COLOR[print_call_stack.brace]-}}"

        # Indent the next stack frame to the right.
        frame_prefix=" ${frame_prefix}"
    }

    # Update globals tracking state for start_stdout_printing_delimited() calls.
    update_stdout_tracking
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Shift to "00-declare". This is all *REALLY* "early" functionality
#required for core zeshy functionality (e.g., printing exceptions). How about
#"00-startup/10-runnable/call_stack"? Sounds good to me. And we even already
#have the slot open!

#(i.e., the initial
#function or script transitively responsible for the call to this function).
#Get the name of the first (i.e., oldest) function or script on the call stack,
#serving as the root of the current call tree. For scripts, such name is the
#absolute or relative path at which such script was originally called.

#implying. Thus, return true only if the passed runnable either is the
#current runnable or transitively called the current runnable.
#   is_list_contains funcstack "${1}"
    #FUXME: I'm not convinced that printing the name of both this function and
    #caller error handlers is helpful. I mean, do we *REALLY* need the first
    #two lines of:
    #
    #\_ print_call_stack() { /home/leycec/zsh/zeshy/src/main: 499 }
    # \_ die_with_exit_status() { /home/leycec/zsh/zeshy/src/main: 3271992097900940624 }
    #  \_ TRAPZERR() { /bin/zsh: 1 }
    #
    #I'm thinking no. No sane language prints such internals, so... neither
    #shall we, we-we? Keep the "TRAPZERR" line, obviously, but cut everything
    #above that. Also keep any "die" line, but again cut everything above such
    #line. Readability is of key importance in stack traces.
    #FUXME: Then again, the truth is probably more important. O.K.; keep it.
    #FUXME: Die if called directly from the command-line. Ah! Actually, there's
    #no good reason that shouldn't work. What we should do, possibly, is detect
    #whether the call stack has at least three callers *AND* our caller is
    #die_with_exit_status(), in which case omit the first two callers, yes? This
    #is a bit more "magicky" than we like, but... is there any reasonable
    #alternative? I submit, "No."
    # Get such name. Since this function is transitively called by die(), avoid
    # zeshy functions liable to throw exceptions if implemented poorly (e.g.,
    # is_list_nonempty()).
#   if (( ${#funcstack} )) {
#       return_string "${funcstack[-1]}"
#   } else {
#       return_string ''
#   }
#on the current call path (i.e.,
#the path of functions and scripts calling the current function or script).
        # If die_with_exit_status() called this function, avoid printing such
        # call, whose internal implementation conveys no meaningful data to most
        # Zeshy users.
#       caller_name="${funcstack[${i}]}"
#       is "${caller_name}" == 'die_with_exit_status' si and continue

    # Colors to be expanded below.
#   string\
#       color_prefix="${ZESHY_COLOR[white_bold]-}"\
#       color_function_name="${ZESHY_COLOR[blue_bold]-}"\
#       color_function_parens="${ZESHY_COLOR[blue]-}"\
#       color_script_name="${ZESHY_COLOR[magenta_bold]-}"\
#       color_script_quotes="${ZESHY_COLOR[magenta]-}"\
#       color_eval_name="${ZESHY_COLOR[cyan_bold]-}"\
#       color_eval_parens="${ZESHY_COLOR[cyan]-}"\
#       color_brace="${ZESHY_COLOR[red_bold]-}"\
#       color_filename="${ZESHY_COLOR[grey_bold]-}"\
#       color_colon="${ZESHY_COLOR[grey]-}"\
#       color_line="${ZESHY_COLOR[red]-}"

        #FUXME: We could take this a step further by associating different
        #colors with different types of runnables (e.g., blue for functions,
        #magenta for scripts, and cyan for eval statements). What print_message ye? Ya!

#, as doing so sets such
    # caller name to "is_caller_equals". Implement such functions manually
#       'no such caller (this function or its caller called directly from the command line)'
# Consider calling
#get_caller_name_from_subshell if capturing output by process substitution: e.g.,
# >>> function choir() { output_string_sans_newline "caller: "; get_caller }
#declare_function '
#boolean get_caller_name_from_subshell(void)
#
#Get the name of the function or script calling the function or script calling
#this function *WHEN CALLED FROM A SUBSHELL*. Consider calling get_caller()
#unless capturing output by process substitution: e.g.,
#
#    >>> function timbered() { choir }
#    >>> function choir() { print "caller: $(get_caller_name_from_subshell)" }
#    >>> timbered
#    caller: timbered
#'
#function get_caller_name_from_subshell() {
#    # Validate sanity. See is_caller() for implementation details.
#    die_if_args
#    curse_string "funcstack: ${funcstack[*]}"
#    (( ${#funcstack} >= 4 )) or die\
#        'no such caller; this function either not called from a subshell or its caller called directly from the command line'
#
#    # Get such name.
#    print_string "${funcstack[4]}"
#}

#(This function returns the basename of the string
#returned by get_call_stack_root_name(), in other words.)
#If such name is that of a script originally called with
#Script names contain path components
#If the call stack is empty (i.e., this function was called directly from the
#command line), return "zeshy".
#This function returns an absolute path if the first object on the call stack
#is a script called by an absolute path. Where this is undesirable, consider
#calling get_call_stack_root_basename().
        # If this name is an absolute path, return that path's basename.
#       if is_path_absolute "${funcstack[-1]}"
#       then print_string "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else print_string "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FUXME: Zeshify.
#   (( # == 0 )) || die 'expected no arguments'
    #FUXME: ${ZESHY_SCRIPT_NAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
#   if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
#       print -- "${ZESHY_SCRIPT_NAME}"

#FUXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
