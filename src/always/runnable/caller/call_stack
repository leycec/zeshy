#!/usr/bin/env zsh
# ====================[ call_stack                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the call stack of functions and scripts on the current call path (i.e.,
# the path of functions and scripts calling the current function or script).

# ....................{ TESTERS                            }....................
document_function '
boolean is_call_stack_contains(string runnable_name)

Return true if the current call stack contains the passed runnable (i.e.,
function or script). Thus, return true only if the passed runnable either is the
current runnable or transitively called the current runnable.
'
function is_call_stack_contains() {
    die_unless_arg 'expected one runnable name'
#   print "function: ${1}\nfuncstack: ${funcstack[*]}"
    is_list_contains funcstack "${1}"
}

# ....................{ GETTERS                            }....................
document_function '
integer get_call_stack_size(void)

Get the size of the current call stack, excluding the call to this function.
'
function get_call_stack_size() {
    # Avoid calling get_list_size(), which increments the size of such stack.
    die_if_args
    print_string $(( ${#funcstack} - 1 ))   # Exclude the call to this function.
}

# ....................{ GETTERS ~ root                     }....................
document_function '
string get_call_stack_root_name(void)

Get the name of the first (i.e., oldest) function or script on the call stack,
serving as the root of the current call tree. For scripts, such name is the
absolute or relative path at which such script was originally called.
'
function get_call_stack_root_name() {
    # Validate sanity.
    die_if_args

    # Get such name. Since this function is transitively called by die(), avoid
    # Zeshy functions liable to throw exceptions if implemented poorly (e.g.,
    # is_list_nonempty()).
    if (( ${#funcstack} ))
    then print_string "${funcstack[-1]}"
    else print_string 'zeshy'
    fi
}

document_function '
string get_call_stack_root_basename(void)

Get the name of the first function or basename of the first script on the call
stack. See get_call_stack_root_name() for further details.
'
function get_call_stack_root_basename() {
    die_if_args
    get_path_basename "$(get_call_stack_root_name)"
}

# ....................{ PRINTERS                           }....................
#FIXME: There appears to be a very curious oddity in zsh; sourcing a zsh script
#containing the line "return 1" produces the expected call stack, resembling:
#
#./tmpy.zsh: failed with exit status 1
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 8458093679346917924 }
#      \_ TRAPZERR() { ./tmpy.zsh: 2 }
#       \_ ./tmpy.zsh { zsh: 32 }
#
#Running a zsh script containing the line "exit 1" as a command, however,
#produces call stacks resembling:
#
#TRAPZERR: failed with exit status 20
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 7955925549229362501 }
#      \_ TRAPZERR() { /bin/zsh: 31 }
#
#In the latter case, zsh reports the call stack to contain no such command. But
#it gets worse! zsh fails to include commands in *ALL* call stacks; try
#"command ls zzmmmm", for example. This tends to produce inherently senseless
#error output. I suggest one of two solutions:
#
#* If "TRAPZERR" is the top of the call stack, print no call stack. (It's
#  meaningless, so don't even bother.) This is most certainly the simplest
#  solution. (Actually, I tried this. It blatantly sucks.)
#* Forcefully add the expected command to the top of the call stack. This is
#  much better, since the prior solution still crudely reports
#  "TRAPZERR: failed with exit status 20" when in fact we expect
#  "./tmpy.zsh: failed with exit status 1". Just not sure how to *GET* the
#  expected command name or exit status.

document_function '
string print_call_stack(void)

Print a trace of the current call stack consisting of all previously called
functions, sourced files, and "eval" statements in the current call path to
standard error, excluding only the stack frame of the caller''s call to this
function. Printing to standard error rather than output ensures that calling
this function from command substitutions (e.g., "$(get_zsh_version)") prints
to the terminal device attached to the current shell, without requiring the
caller to explicitly perform such printing: e.g.,

  # Assuming neither "/spider" or "/murphy" exist, the following command
  # substitution throws an exception printing a call stack trace to
  # standard error without effort on our behalf.
  >>> string first_file; first_file="$(get_first_file /spider /murphy)"
'
function print_call_stack() {
    #FIXME: Both colorify and prefer UTF-8 on capable terminals.
    #FIXME: I'm not convinced that printing the name of both this function and
    #caller error handlers is helpful. I mean, do we *REALLY* need the first
    #two lines of:
    #
    #\_ print_call_stack() { /home/leycec/zsh/zeshy/src/main: 499 }
    # \_ die_with_exit_status() { /home/leycec/zsh/zeshy/src/main: 3271992097900940624 }
    #  \_ TRAPZERR() { /bin/zsh: 1 }
    #
    #I'm thinking no. No sane language prints such internals, so... neither
    #shall we, we-we? Keep the "TRAPZERR" line, obviously, but cut everything
    #above that. Also keep any "die" line, but again cut everything above such
    #line. Readability is of key importance in stack traces.

    #FIXME: Die if called directly from the command-line. Ah! Actually, there's
    #no good reason that shouldn't work. What we should do, possibly, is detect
    #whether the call stack has at least three callers *AND* our caller is
    #die_with_exit_status(), in which case omit the first two callers, yes? This
    #is a bit more "magicky" than we like, but... is there any reasonable
    #alternative? I submit, "No."

    # Validate passed arguments. For robustness, avoid calling other functions
    # here and below that might conceivably throw an exception.
    die_if_args

    # Call stack size.
    integer funcstack_size=${#funcstack}

    # Current stack frame.
    integer i

    # First stack frame to be printed, defaulting to the call to this function.
    # If die_with_exit_status() called this function, avoid printing both that
    # call and the call to die_with_exit_status(). As Zeshy-specific internal
    # implementation details, such calls convey no useful context to external
    # Zeshy users. (While hardly essential, this does improve output.)
    integer i_first=1
    (( funcstack_size >= 3 )) and
        is "${funcstack[2]}" == 'die_with_exit_status' si and i_first=3

    # Line, function name, and filename from which the caller of the previous
    # stack frame called the current stack frame.
    integer caller_line
    string  caller_name filename

    # String with which to prefix each call stack line.
    string frame_prefix=" ${ZESHY_COLOR_STYLE[print_call_stack.prefix]-}\\\\_"

    # Print the current call stack, excluding the call to the current function.
    for (( i = i_first; i <= funcstack_size; i++ )) {
        # Split the current stack frame's funcfiletrace entry on the last colon
        # in that entry into this frame's filename and line number, thus
        # accounting for possible colons in filenames (e.g., from "colon:blow:7"
        # to filename "colon:blow" and line number 7).
        caller_name="${funcstack[${i}]}"
        caller_line="${funcfiletrace[${i}]##*:}"
           filename="${funcfiletrace[${i}]%:*}"

        # If this frame signifies a function, append "()" to such name. Sadly,
        # if a script with the same name exists (which is technically feasible,
        # given zsh support for double-quoted function names), there appears to
        # be no simple way of discerning between the two. *shrug*
        #
        # Note that, when called due to an exception thrown from an interactive
        # alias, such alias will be disabled here and hence not be recognized as
        # a function. Since such alias signifies an alias and not a function,
        # this is (arguably) not a bug. (Nothin' to see here, folks.)
        if typeset -f -- "${caller_name}" &>/dev/null
        then caller_name="${ZESHY_COLOR_STYLE[print_call_stack.function_name]-}${caller_name}${ZESHY_COLOR_STYLE[print_call_stack.function_parens]-}()"
        # If this frame signifies an "eval" statement, color accordingly.
        elif is "${caller_name}" == '(eval)' si
        then caller_name="${ZESHY_COLOR_STYLE[print_call_stack.eval_parens]-}(${ZESHY_COLOR_STYLE[print_call_stack.eval_name]-}eval${ZESHY_COLOR_STYLE[print_call_stack.eval_parens]-})"
        # Else, this frame signifies a shell script. Color accordingly.
        else caller_name="${ZESHY_COLOR_STYLE[print_call_stack.script_quotes]-}\"${ZESHY_COLOR_STYLE[print_call_stack.script_name]-}${caller_name}${ZESHY_COLOR_STYLE[print_call_stack.script_quotes]-}\""
        fi

        # Print the current stack frame to standard error.
        print --\
            "${frame_prefix} ${caller_name} ${ZESHY_COLOR_STYLE[print_call_stack.brace]-}{ ${ZESHY_COLOR_STYLE[print_call_stack.filename]-}${filename}${ZESHY_COLOR_STYLE[print_call_stack.colon]-}: ${ZESHY_COLOR_STYLE[print_call_stack.line]-}${caller_line} ${ZESHY_COLOR_STYLE[print_call_stack.brace]-}}"

        # Indent the next stack frame to the right.
        frame_prefix=" ${frame_prefix}"
    }
}

# --------------------( WASTELANDS                         )--------------------
        # If die_with_exit_status() called this function, avoid printing such
        # call, whose internal implementation conveys no meaningful data to most
        # Zeshy users.
#       caller_name="${funcstack[${i}]}"
#       is "${caller_name}" == 'die_with_exit_status' si and continue

    # Colors to be expanded below.
#   string\
#       color_prefix="${ZESHY_COLOR[white_bold]-}"\
#       color_function_name="${ZESHY_COLOR[blue_bold]-}"\
#       color_function_parens="${ZESHY_COLOR[blue]-}"\
#       color_script_name="${ZESHY_COLOR[magenta_bold]-}"\
#       color_script_quotes="${ZESHY_COLOR[magenta]-}"\
#       color_eval_name="${ZESHY_COLOR[cyan_bold]-}"\
#       color_eval_parens="${ZESHY_COLOR[cyan]-}"\
#       color_brace="${ZESHY_COLOR[red_bold]-}"\
#       color_filename="${ZESHY_COLOR[grey_bold]-}"\
#       color_colon="${ZESHY_COLOR[grey]-}"\
#       color_line="${ZESHY_COLOR[red]-}"

        #FUXME: We could take this a step further by associating different
        #colors with different types of runnables (e.g., blue for functions,
        #magenta for scripts, and cyan for eval statements). What print_message ye? Ya!

#, as doing so sets such
    # caller name to "is_caller_equals". Implement such functions manually
#       'no such caller (this function or its caller called directly from the command line)'
# Consider calling
#get_caller_name_from_subshell if capturing output by process substitution: e.g.,
# >>> function choir() { print_string_unnewlined "caller: "; get_caller_name }
#document_function '
#boolean get_caller_name_from_subshell(void)
#
#Get the name of the function or script calling the function or script calling
#this function *WHEN CALLED FROM A SUBSHELL*. Consider calling get_caller_name()
#unless capturing output by process substitution: e.g.,
#
#    >>> function timbered() { choir }
#    >>> function choir() { print "caller: $(get_caller_name_from_subshell)" }
#    >>> timbered
#    caller: timbered
#'
#function get_caller_name_from_subshell() {
#    # Validate sanity. See is_caller() for implementation details.
#    die_if_args
#    curse_string "funcstack: ${funcstack[*]}"
#    (( ${#funcstack} >= 4 )) or die\
#        'no such caller; this function either not called from a subshell or its caller called directly from the command line'
#
#    # Get such name.
#    print_string "${funcstack[4]}"
#}

#(This function returns the basename of the string
#returned by get_call_stack_root_name(), in other words.)
#If such name is that of a script originally called with
#Script names contain path components
#If the call stack is empty (i.e., this function was called directly from the
#command line), return "zeshy".
#This function returns an absolute path if the first object on the call stack
#is a script called by an absolute path. Where this is undesirable, consider
#calling get_call_stack_root_basename().
        # If this name is an absolute path, return that path's basename.
#       if is_path_absolute "${funcstack[-1]}"
#       then print_string "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else print_string "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FIXME: Zeshify.
#   (( # == 0 )) || die 'expected no arguments'
    #FIXME: ${ZESHY_SCRIPT_NAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
#   if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
#       print -- "${ZESHY_SCRIPT_NAME}"

#FIXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
