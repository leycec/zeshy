#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *runnables*, comprising the following types:

* `zsh` aliases (e.g., `return_exit_status`).
* `zsh` functions (e.g., `get_zeshy_version`).
* `zsh` builtins (e.g., `print`).
* `zsh` operators (e.g., `[[`).
* External commands in the current user's ${PATH} (e.g., `ls`), also referred to
  as *pathables*.
-/-

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_runnable(
    string runnable_name,
    string error_message = "\"${runnable_name}\" not a runnable")

Throw an exception with the passed message unless the passed runnable exists.
/---
function die_unless_runnable() {
    die_unless_args_1_to_2\
        'Expected one runnable name and optional error message.'
    string runnable_name="${1}"
    is_runnable "${runnable_name}" or
        die "${2:-\"${runnable_name}\" not a runnable}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_runnable(string runnable_name)

Return success if the passed *runnable* (i.e., external command or `zsh` alias,
builtin, function, or operator) exists.
/---
function is_runnable() {
    die_unless_arg 'Expected one runnable name.'
    run_code_silent whence -- "${1}"
}

# ....................{ TESTERS ~ type                     }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_runnable_type_equals(
    string runnable_name, string runnable_type)

Return success if the passed runnable is of the passed type: e.g.,

.is_runnable_type_equals()
==========================================
[source]
------------------------------------------
>>> alias thomas_migley_jr='he who destroys ozone'
>>> is_runnable_type_equals thomas_migley_jr alias and print 'yet lives'
yet lives
------------------------------------------
==========================================
/---
function is_runnable_type_equals() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one runnable name and one type.'
    string runnable_name="${1}"
    die_unless_runnable "${runnable_name}"

    # If such runnable exists, match such runnable's type.
    is_string_equals "$(get_runnable_type "${runnable_name}")" "${2}"
}

#FIXME: Rename to is_runnable_type_matches().
declare_function_with_stdin <<'/---'
[status: boolean] is_runnable_type_match(
    string runnable_name, string runnable_type)

Return success if the passed runnable's type matches the passed glob: e.g.,

.is_runnable_type_equals()
==========================================
[source]
------------------------------------------
>>> function bergtatt() { output into the mountain chambers; }
>>> is_runnable_type_match bergtatt '[^a]*' and print 'Graablick watches'
Graablick watches
------------------------------------------
==========================================
/---
function is_runnable_type_match() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one runnable name and one type glob.'
    string runnable_name="${1}"
    die_unless_runnable "${runnable_name}"

    # If such runnable exists, match such runnable's type.
    is_string_matches_glob "$(get_runnable_type "${runnable_name}")" "${2}"
}

# ....................{ TESTERS ~ builtin                  }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_builtin(string builtin_name)

Return success if the passed `zsh` builtin operator exists.
/---
function is_builtin() {
    die_unless_arg 'Expected one builtin name.'
    is_runnable "${1}" and is_runnable_type_equals "${1}" 'builtin'
}

declare_function_with_stdin <<'/---'
[status: boolean] is_reserved(string reserved_name)

Return success if the passed `zsh` reserved operator exists.
/---
function is_reserved() {
    die_unless_arg 'Expected one reserved operator name.'
    is_runnable "${1}" and is_runnable_type_equals "${1}" 'reserved'
}

# --------------------( GETTERS                            )--------------------
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] string get_runnable_type(
    string runnable_name)

Get the `zsh`-specific lowercase type of the passed runnable if such runnable
exists or throw an exception otherwise. See get_runnable_type_if_found() for
further details.
/---
function get_runnable_type() {
    get_runnable_type_if_found "${@}" or die "Runnable \"${1}\" not found."
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] string get_runnable_type_if_found(
    string runnable_name)

Get the `zsh`-specific lowercase type of the passed runnable if such runnable
exists or return failure otherwise. If such runnable is:

* A `zsh` alias, this is `alias`.
* A `zsh` builtin (e.g., `print`), this is `builtin`.
* A `zsh` function, this is `function`.
* A `zsh` operator (e.g., `[[`), this is `reserved`.
* An external command in the current user's ${PATH}, this is `command`.
* An external command _not_ in the current user's ${PATH} but hashed with
  builtin hash(), this is `hashed`.

For example:

.get_runnable_type_if_found()
==========================================
[source]
------------------------------------------
>>> alias on_history='print_string\
...    "During part of 1941 and 1942, when the Luftwaffe was busy in Russia, the
...     German radio regaled its home audience with stories of devastating air
...     raids on London. Now, we are aware that those raids did not happen. But
...     what use would our knowledge be if the Germans conquered Britain? For
...     the purpose of a future historian, did those raids happen, or didn't
...     they? The answer is: If Hitler survives, they happened, and if he falls
...     they didn't happen. So with innumerable other events of the past ten or
...     twenty years. Is the Protocols of the Elders of Zion a genuine document?
...     Did Trotsky plot with the Nazis? How many German aeroplanes were shot
...     down in the Battle of Britain? Does Europe welcome the New Order? In no
...     case do you get one answer which is universally accepted because it is
...     true: in each case you get a number of totally incompatible answers, one
...     of which is finally adopted as the result of a physical struggle.
...     History is written by the winners."'
>>> get_runnable_type_if_found on_history
alias
------------------------------------------
==========================================
/---
function get_runnable_type_if_found() {
    # Validate passed arguments.
    die_unless_arg 'Expected one runnable name.'
    string runnable_type_specifier

    # If such runnable exists, get such runnable's type. To do so, get such
    # runnable's type specifier of the form "${runnable_name}: ${object_type}"
    # (e.g., "stonesoup: command"), where "${object_type}" is either such
    # runnable's type if such runnable exists or "none" otherwise. In the latter
    # case, such command also returns non-zero exit status.
    if { runnable_type_specifier="$(whence -w -- "${1}")" } {
        # Remove the runnable name from such type specifier.
        return_string "${##*: }"
    # Else, such runnable does not exist. By zeshy precedent, return failure and
    # no output (rather than returning failure and output "none").
    } else {
        return_false
    }
}

# --------------------( PRINTERS                           )--------------------
#FIXME: This function could use some work. Ideally, if such runnable is an alias
#or function, such runnable (including runnable implementation) should be
#printed with zsh-specific syntax highlighting. (Pygments-driven, perhaps? I
#believe we've given the idea of syntax highlighting some thought elsewhere.)
declare_function_with_stdin <<'/---'
string print_runnable(string runnable_name)

Print a human-readable synopsis of the passed runnable. Specifically, if such
runnable is:

* A `zsh` alias, print such alias name and expansion with syntax highlighting.
* A `zsh` function, print such function name and body with syntax highlighting.
* An external command in the current user's ${PATH}, print the absolute path of
  such command.
/---
function print_runnable() {
    # Validate passed arguments.
    die_unless_arg 'Expected one runnable name.'
    string runnable_name="${1}"
    die_unless_runnable "${runnable_name}"

    # Print such runnable paged to account for lengthy alias expansions and
    # function bodies.
    which -- "${runnable_name}" | page_stdin
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to get_runnable_type_if_found(). Naturally, consider implementing
#the corresponding get_runnable_type() function calling this function.
#FUXME: Rename to is_runnable_type_equals_equals(). The current function name suggests
#an equally valid but completely different function accepting one string
#matching "function", "alias", "command", etc.

#   {
#       string true_type; true_type="$(get_runnable_type "${runnable_name}")"
#       is "${test_type}" == "${true_type}" si
#   }
    # Validate passed arguments.
#   string object_type; object_type="$(whence -w -- "${1}")"
#   print_string "${object_type##*: }"
# Inspect runnable names, types, values, and related metadata. Runnables are run
# when in command position (i.e., when the first shell word of a command line),
# comprising the following types:
#   is $(whence -w "${1}") == *': (alias|builtin|function)' si
#   string builtin_name="${1}"
#   is_runnable "${builtin_name}" and {
#       string type; type="$(get_runnable_type "${builtin_name}")"
#       "$(whence -w -- "${1}")" == *': builtin' si
#   }
