#!/usr/bin/env zsh
# ====================[ runnable                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle runnables, comprising the following types:
#
# * zsh aliases (e.g., "return_command_exit_status").
# * zsh functions (e.g., "get_zeshy_version").
# * zsh builtins (e.g., "print").
# * zsh operators (e.g., "[[").
# * External commands in the current user's ${PATH} (e.g., "ls").

# ....................{ EXCEPTIONS                         }....................
# void die_unless_runnable(
#   string runnable_name,
#   string error_message = "\"${runnable_name}\" not a runnable")
#
# Throw an exception unless the passed runnable exists.
function die_unless_runnable() {
    die_unless_args_1_to_2\
        'expected one runnable name and optional error message'
    string runnable_name="${1}"
    is_runnable "${runnable_name}" or
        die "${2:-\"${runnable_name}\" not a runnable}"
}

# ....................{ TESTERS                            }....................
# boolean is_runnable(string runnable_name)
#
# Return true if the passed runnable (i.e., external command or zsh alias,
# builtin, function, or operator) exists.
function is_runnable() {
    die_unless_arg 'expected one runnable name'
    run_silently whence -- "${1}"
}

# ....................{ TESTERS ~ type                     }....................
#FIXME: Rename to is_runnable_type_equals_equals(). The current function name suggests
#an equally valid but completely different function accepting one string
#matching "function", "alias", "command", etc.

# boolean is_runnable_type_equals(string runnable_name, string runnable_type)
#
# Return true if the passed runnable is of the passed type: e.g.,
#
#     >>> alias thomas_migley_jr='he who destroys ozone'
#     >>> is_runnable_type_equals thomas_migley_jr alias and print 'yet lives'
#     yet lives
function is_runnable_type_equals() {
    # Validate passed arguments.
    die_unless_args_2 'expected one runnable name and one type'
    string runnable_name="${1}" type="${2}"

    # If such runnable exists, match such runnable's type.
    is_runnable "${runnable_name}" and
        get_runnable_type "${runnable_name}" | is_string_equals "${type}"
}

# boolean is_runnable_type_match(string runnable_name, string type_glob)
#
# Return true if the passed runnable's type matches the passed glob: e.g.,
#
#     >>> function bergtatt() { output into the mountain chambers; }
#     >>> is_runnable_type_match bergtatt '[^a]*' and print 'Graablick watches'
#     Graablick watches
function is_runnable_type_match() {
    # Validate passed arguments.
    die_unless_args_2 'expected one runnable name and one type glob'
    string runnable_name="${1}" type_glob="${2}"

    # If such runnable exists, match such runnable's type.
    is_runnable "${runnable_name}" and
        get_runnable_type "${runnable_name}" | is_string_match "${type_glob}"
}

# ....................{ TESTERS ~ builtin                  }....................
# boolean is_builtin(string builtin_name)
#
# Return true if the passed zsh builtin exists.
function is_builtin() {
    die_unless_arg 'expected one name'
    is_runnable_type_equals "${1}" 'builtin'
}

# boolean is_reserved(string reserved_name)
#
# Return true if the passed zsh reserved operator exists.
function is_reserved() {
    die_unless_arg 'expected one name'
    is_runnable_type_equals "${1}" 'reserved'
}

# --------------------( GETTERS                            )--------------------
# string get_runnable_type(string runnable_name)
#
# Get the type of the passed runnable: e.g.,
#
#     >>> alias thomas_migley_jr='he who destroys ozone'
#     >>> get_runnable_type thomas_migley_jr
#     alias
#
# Specifically, if such runnable is:
#
# * A zsh alias, this is "alias".
# * A zsh function, this is "function".
# * A zsh builtin (e.g., print()), this is "builtin".
# * A zsh operator (e.g., "[["), this is "reserved".
# * An external command in the current user's ${PATH}, this is "command".
function get_runnable_type() {
    # "$(whence -w -- "${1}")" prints strings of the form "${1}: ${object_type}"
    # (e.g., "stonesoup: command"), where "${object_type}" is either "alias",
    # "command", "function", or "none". In the latter case, such command returns
    # non-zero exit status implicitly throwing an exception.
    die_unless_arg 'expected one runnable name'
    print_string "${"$(whence -w -- "${1}")"##*: }"
}

# --------------------( WASTELANDS                         )--------------------
#   {
#       string true_type; true_type="$(get_runnable_type "${runnable_name}")"
#       is "${test_type}" == "${true_type}" si
#   }
    # Validate passed arguments.
#   string object_type; object_type="$(whence -w -- "${1}")"
#   print_string "${object_type##*: }"
# Inspect runnable names, types, values, and related metadata. Runnables are run
# when in command position (i.e., when the first shell word of a command line),
# comprising the following types:
#   is $(whence -w "${1}") == *': (alias|builtin|function)' si
#   string builtin_name="${1}"
#   is_runnable "${builtin_name}" and {
#       string type; type="$(get_runnable_type "${builtin_name}")"
#       "$(whence -w -- "${1}")" == *': builtin' si
#   }
