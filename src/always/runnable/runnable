#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *runnables* (i.e., executable objects), including the following:

* `zsh` aliases (e.g., `report_status`).
* `zsh` functions (e.g., `get_zeshy_version`).
* `zsh` builtins (e.g., `print`).
* `zsh` operators (e.g., `[[`).
* External commands in the current user's ${PATH} (e.g., `ls`), elsewhere
  referred to as *pathables*.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_if_runnable(
    string runnable_name,
    string error_message =
        "\"${runnable_name}\" already a defined $(get_runnable_type "${runnable_name}"):${ZESHY_ASCII_NEWLINE}$(print_runnable "${runnable_name}")")

Throw an exception with the passed message if the passed runnable already
exists. See is_runnable() for further details.
/---
function die_if_runnable() {
    # Validate sanity.
    die_unless_args_1_to_2\
        'Expected one runnable name and optional error message.'
    string runnable_name="${1}"

    # If such runnable already exists, throw an exception.
    if { is_runnable "${runnable_name}" } {
        # If the caller passed an error message, throw such message.
        if { is_args_2 } {
            die "${2}"
        # Else, throw a message describing such runnable. Since print_runnable()
        # prints headings dependent on the current terminal width and since
        # die() typically embeds such message in a visual box reducing such
        # width by the width of box borders, die() does *NOT* suffice to print
        # such runnable.
        } else {
            die_evaluated '\"${runnable_name}\" already a defined $(get_runnable_type "${runnable_name}"):${ZESHY_ASCII_NEWLINE}$(print_runnable "${runnable_name}")'
        }
    }
}

declare_function_with_stdin <<'/---'
void die_unless_runnable(
    string runnable_name,
    string error_message =
        "\"${runnable_name}\" not runnable (i.e., not an alias, builtin, command, or function).")

Throw an exception with the passed message unless the passed runnable exists.
See is_runnable() for further details.
/---
function die_unless_runnable() {
    die_unless_args_1_to_2\
        'Expected one runnable name and optional error message.'
    string runnable_name="${1}"
    is_runnable "${runnable_name}" or
        die "${2-\"${runnable_name}\" not runnable (i.e., not an alias, builtin, command, or function).}"
}

#FIXME: In lieu of unit tests...
#FIXME: O.K.; I've tracked down the issue to an error in the wrapping code.
#Basically, wrapping really isn't working at all. There appear to be an
#extraordinary number of off-by-one issues there. The issue is *NOT* with
#die_evaluated() or related terminal width code, which is working as expected.
#But at least nothing is segmentation faulting, eh? *sigh*
function difo() {
    die_if_runnable info
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_runnable(string runnable_name)

Return success if the passed *runnable* (i.e., external command or `zsh` alias,
builtin, function, or operator) exists.
/---
function is_runnable() {
    die_unless_arg 'Expected one runnable name.'
    whence -- "${1}" &>/dev/null
}

# ....................{ TESTERS ~ type                     }....................
#FIXME: Improve examples.
declare_function_with_stdin <<'/---'
[status: boolean] is_runnable_type_equals(
    string runnable_name, string runnable_type)

Return success if the passed runnable is of the passed type: e.g.,

.is_runnable_type_equals()
==========================================
[source]
------------------------------------------
>>> alias thomas_migley_jr='he who destroys ozone'
>>> is_runnable_type_equals thomas_migley_jr alias and output_string 'yet lives'
yet lives
------------------------------------------
==========================================
/---
function is_runnable_type_equals() {
    # Validate sanity.
    die_unless_args_2 'Expected one runnable name and one type.'
    string runnable_name="${1}"
    die_unless_runnable "${runnable_name}"

    # If such runnable exists, match such runnable's type.
    is_string_equals "$(get_runnable_type "${runnable_name}")" "${2}"
}

#FIXME: Rename to is_runnable_type_matches().
declare_function_with_stdin <<'/---'
[status: boolean] is_runnable_type_match(
    string runnable_name, string runnable_type)

Return success if the passed runnable's type matches the passed glob: e.g.,

.is_runnable_type_equals()
==========================================
[source]
------------------------------------------
>>> function bergtatt() { output into the mountain chambers; }
>>> is_runnable_type_match bergtatt '[^a]*' and print 'Graablick watches'
Graablick watches
------------------------------------------
==========================================
/---
function is_runnable_type_match() {
    # Validate sanity.
    die_unless_args_2 'Expected one runnable name and one type glob.'
    string runnable_name="${1}"
    die_unless_runnable "${runnable_name}"

    # If such runnable exists, match such runnable's type.
    is_string_matches_glob "$(get_runnable_type "${runnable_name}")" "${2}"
}

# ....................{ TESTERS ~ builtin                  }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_builtin(string builtin_name)

Return success if the passed `zsh` builtin operator exists.
/---
function is_builtin() {
    die_unless_arg 'Expected one builtin name.'
    is_runnable "${1}" and is_runnable_type_equals "${1}" 'builtin'
}

declare_function_with_stdin <<'/---'
[status: boolean] is_reserved(string reserved_name)

Return success if the passed `zsh` reserved operator exists.
/---
function is_reserved() {
    die_unless_arg 'Expected one reserved operator name.'
    is_runnable "${1}" and is_runnable_type_equals "${1}" 'reserved'
}

# --------------------( GETTERS                            )--------------------
declare_function_with_stdin <<'/---'
string get_runnable_type(string runnable_name)

Get the `zsh`-specific lowercase type of the passed runnable if such runnable
exists or throw an exception otherwise. See get_runnable_type_if_found() for
further details.
/---
function get_runnable_type() {
    get_runnable_type_if_found "${@}" or die_unless_runnable "${1}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_runnable_type_if_found(
    string runnable_name)

Get the `zsh`-specific lowercase type of the passed runnable if such runnable
exists or return failure otherwise. If such runnable is:

* A `zsh` alias, this is `alias`.
* A `zsh` builtin (e.g., `print`), this is `builtin`.
* A `zsh` function, this is `function`.
* A `zsh` operator (e.g., `[[`), this is `reserved`.
* An external command in the current user's ${PATH}, this is `command`.
* An external command _not_ in the current user's ${PATH} but hashed with
  builtin hash(), this is `hashed`.

For example:

.get_runnable_type_if_found()
==========================================
[source]
------------------------------------------
>>> alias on_history='print_string\
...    "During part of 1941 and 1942, when the Luftwaffe was busy in Russia, the
...     German radio regaled its home audience with stories of devastating air
...     raids on London. Now, we are aware that those raids did not happen. But
...     what use would our knowledge be if the Germans conquered Britain? For
...     the purpose of a future historian, did those raids happen, or didn't
...     they? The answer is: If Hitler survives, they happened, and if he falls
...     they didn't happen. So with innumerable other events of the past ten or
...     twenty years. Is the Protocols of the Elders of Zion a genuine document?
...     Did Trotsky plot with the Nazis? How many German aeroplanes were shot
...     down in the Battle of Britain? Does Europe welcome the New Order? In no
...     case do you get one answer which is universally accepted because it is
...     true: in each case you get a number of totally incompatible answers, one
...     of which is finally adopted as the result of a physical struggle.
...     History is written by the winners."'
>>> get_runnable_type_if_found on_history
alias
------------------------------------------
==========================================
/---
function get_runnable_type_if_found() {
    # Validate sanity.
    die_unless_arg 'Expected one runnable name.'
    string runnable_type

    # If such runnable exists, get such runnable's type. To do so, get such
    # runnable's type specifier of the form "${runnable_name}: ${object_type}"
    # (e.g., "stonesoup: command"), where "${object_type}" is either such
    # runnable's type if such runnable exists or "none" otherwise. In the latter
    # case, such command also returns non-zero exit status.
    if { runnable_type="$(whence -w -- "${1}")" } {
        # Remove the runnable name from such type specifier.
        return_string "${runnable_type##*: }"
    # Else, such runnable does not exist. By zeshy precedent, return failure and
    # no output (rather than returning failure and output "none").
    } else {
        report_failure
    }
}

# --------------------( PRINTERS                           )--------------------
#FIXME: Actually implement print_builtin().
#FIXME: This function is *MOSTLY* a sane substitution for "which". To make it a
#reliable solution, we'll want a new function frontend -- say,
#which_runnable_with_options(). Such function should *ONLY* call
#print_runnable() with its passed arguments if such arguments contain no options
#(i.e., if all such arguments are non-option arguments); if, however, such
#arguments contain at least one option, such function should call "which"
#instead with such arguments. (Nice, eh?)

declare_function_with_stdin <<'/---'
string print_runnable(string runnable_name1, ...)

Print a human-readable synopsis of all passed *runnables* (e.g., aliases,
builtins, commands, functions, operators). Specifically, if such runnable is:

* A `zsh` alias, print such alias name and expansion with syntax highlighting.
* A `zsh` function, print such function name and body with syntax highlighting.
* An external command in the current user's ${PATH}, print the absolute path of
  such command.
/---
function print_runnable() {
    # Validate sanity.
    die_unless_args 'Expected one or more runnable names.'
#   print "terminal width: $(get_terminal_width) (${COLUMNS})"

    # Print such runnables.
    string runnable_name runnable_type
    for    runnable_name ("${@}") {
        # If such runnable exists, defer such printing to a function specific to
        # such runnable's type. For efficienty, inline such implementation. See
        # get_runnable_type_if_found() for further details.
        if { runnable_type="$(whence -w -- "${runnable_name}")" } {
            # Print the dominant definition for such runnable.
            case "${runnable_type}" {
            *' function')               print_function "${runnable_name}";;
            *' alias')                  print_alias    "${runnable_name}";;
            *' '('command'|'hashed'))   print_pathable "${runnable_name}";;
            *' '('builtin'|'reserved')) print_builtin  "${runnable_name}";;
            *) die 'Runnable "'${runnable_name}'" type '${runnable_type}' unrecognized.';;
            }

            # If the dominant definition of such runnable is not a command
            # *AND* a command with the same name as such runnable exists, also
            # print such runnable as a command.
            if { is "${runnable_type}" != *' '('command'|'hashed') si and
                 is_pathable "${runnable_name}" } {
                print_pathable "${runnable_name}"
            }
        # Else, such runnable does not exist. Throw an exception.
        } else {
            die_unless_runnable "${runnable_name}"
        }
    } | page_stdin
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Correct documentation!
#FUXME: Definitely add examples!
#equal to the former rather than latter. To ensure this, this function evaluates
#the passed string under a terminal width temporarily set to the former.
#overrides such width width 
#
#however, such
#messages and hence the prior heading embedded in such message should actually
#be restricted to less than the current terminal width (namely, to the
#current terminal width minus the width of the left and right box borders)

#FUXME: This function could use some work. Ideally, if such runnable is an alias
#or function, such runnable (including runnable implementation) should be
#printed with zsh-specific syntax highlighting. (Pygments-driven, perhaps? I
#believe we've given the idea of syntax highlighting some thought elsewhere.)

#    string runnable_name="${1}"
#    die_unless_runnable "${runnable_name}"
#
#    # Print such runnable paged to account for lengthy alias expansions and
#    # function bodies.
#    which -- "${runnable_name}" | page_stdin
# die "Runnable \"${1}\" not found."
#FUXME: Rename to get_runnable_type_if_found(). Naturally, consider implementing
#the corresponding get_runnable_type() function calling this function.
#FUXME: Rename to is_runnable_type_equals_equals(). The current function name suggests
#an equally valid but completely different function accepting one string
#matching "function", "alias", "command", etc.

#   {
#       string true_type; true_type="$(get_runnable_type "${runnable_name}")"
#       is "${test_type}" == "${true_type}" si
#   }
    # Validate sanity.
#   string object_type; object_type="$(whence -w -- "${1}")"
#   print_string "${object_type##*: }"
# Inspect runnable names, types, values, and related metadata. Runnables are run
# when in command position (i.e., when the first shell word of a command line),
# comprising the following types:
#   is $(whence -w "${1}") == *': (alias|builtin|function)' si
#   string builtin_name="${1}"
#   is_runnable "${builtin_name}" and {
#       string type; type="$(get_runnable_type "${builtin_name}")"
#       "$(whence -w -- "${1}")" == *': builtin' si
#   }
