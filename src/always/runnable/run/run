#!/usr/bin/env zsh
# ====================[ run                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle dynamically constructed command lines.

# ....................{ RUNNERS                            }....................
document_function '
string run(string command_line) --OR--
string run(string command_name, string command_arg1, string command_arg2, ...)

Run the passed strings concatenated as a single command. Technically, zsh
already runs strings as commands when in command position (i.e., when the
first shell word of a command line): e.g.,

    # Print the login message. Happily, this works as expected.
    >>> list command_line; command_line=( cat /dev/issue )
    >>> "${command_line[@]}"
    Caution, feeble entity. You are entering \n.\O (\s \m \r) \t.

Sadly, such execution fails on strings containing shell-reserved characters
(e.g., "|", "<", ">"): e.g.,

    # Print the first 16 characters of the login message. Unhappily, this does
    # not work as expected. (Unless you correctly expected it to fail. Which
    # it does -- in spades.)
    >>> list command_line; command_line=( cat /etc/issue \| cut -c 1,16 )
    >>> "${command_line[@]}"
    cat: |: No such file or directory
    cat: cut: No such file or directory

This function amends such behavior by correctly running all strings as
commands regardless of shell-reserved content: e.g.,

    # Print the first 16 characters of the login message. Aaaand we have worky.
    >>> list command_line; command_line=( cat /etc/issue \| cut -c 1,16 )
    >>> run "${command_line[@]}"
    Caution, feeble

This function takes two different forms:

* If passed one argument, this function evaluates such argument as the entire
  command to be run. This requires the caller explicitly construct the entire
  command line, including quote protection of command arguments containing
  shell-reserved characters: e.g.,

    # Run the entropic random number generator until generating a string
    # containing shell-reserved characters.
    >>> string command_line
    >>> command_line="cat /dev/random \| grep -E "\{Eschaton Entombed\(\)\}""
    >>> run "${command_line}"
    {Eschaton Entombed()}                   # it could happen...

  This form preserves quote protection and hence is generally safer than the
  next form, which silently strips one level of such protection. However,
  this form is subject to a subtle caveat: when passing a single argument
  interpolating a list, expand list elements with "${*}" rather than "${@}".
  The former expands list elements in place; the latter appends all list
  elements following the first as discrete arguments to this function: e.g.,

    # Doubleplusungood. This is equivalent to:
    #     run "dd | pv -t" "if=/dev/null" "of=/dev/sda"
    >>> set_args dd if=/dev/null of=/dev/sda
    >>> run "${@} | pv -t"       # you probably don''t want to run this

    # Ohsonice. This never does the wrong thing. (But you''ll wish it did...)
    >>> set_args dd if=/dev/null of=/dev/sda
    >>> run "${*} | pv -t"       # you *REALLY* don''t want to run this

* If passed multiple arguments, this function evaluates the concatenation of
  such arguments as the command to be run. This implicitly constructs the
  command line on behalf of the caller (which is nice), but requires the
  caller explicitly quote protect command arguments containing shell-reserved
  characters (which is horrible): e.g.,

    # Run the same command. Unhappily, this crashes and burns piquantly. Why?
    # Because run() internally calls "eval" which silently strips one level
    # of quote protection from the argument to "grep".
    >>> list command_line
    >>> command_line=( cat /dev/random \| grep -E "\{Eschaton Entombed\(\)\}" )
    >>> run "${command_line[@]}"
    grep: Entombed()}: No such file or directory

    # Run the same command, explicitly quote protecting the argument to "grep".
    # Happily, it works. Unhappily, it''s user friendliness is.... questionable.
    >>> list command_line
    >>> command_line=( cat /dev/random \| grep -E ${(q):-\{Eschaton Entombed\(\)\}} )
    >>> run "${command_line[@]}"
    {Eschaton Entombed()}                   # it could happen... but will it?

In either case, avoid passing commands that when run recursively call this
function or the equivalent "eval" builtin. Each such call strips one level of
quote protection, ultimately resulting in jaberwocky-style gibberish. To
protect against such errors, this function avoids evaluating commands that
either directly run "run" (i.e., this function) or functions prefixed with
"run_" (e.g., "run_silently", a function internally calling this function).

tl;dr
-----
If passing a single argument, *NEVER INTERPOLATE "${@}" INTO SUCH ARGUMENT*.
If passing multiple arguments, *ALWAYS QUOTE-PROTECT PASSED ARGUMENTS WITH
PARAMETER EXPANSION MODIFIER "(q)"*.
'
function run() {
    # Validate passed arguments.
    die_unless_args 'expected one command'

    # If the argument in command position is either this function name or a
    # "run_"-prefixed function name, assume such argument to be a call to a
    # Zeshy-specific function recursively calling this function. In such case,
    # do *NOT* "eval" such command as the recursive call to this function will
    # do so already. Since each "eval" strips one level of quotes from such
    # command, running such command as is avoids stripping quote protection.
    string command_name; command_name="$(get_string_word "${1}" 1)"
    is "${command_name}" == run(|_?*) si and {
#       print_string "run (direct): ${@}... (last arg: ${@[-1]})"
        # If passed a composite command line as a single argument, split such
        # command line into shell words prior to execution by zsh.
        if is_args_1
        then "${(z)@}"
        # Otherwise, assume the passed arguments already correspond to valid
        # shell words whose concatenation produces the desired command line.
        else "${@}"
        fi

        # Get us out of here, Jim.
        return_true
    }

    # If passed one argument, evaluation of such argument as a composite command
    # line is generally safe. If passed multiple arguments, evaluation of the
    # concatenation of such arguments into a composite command line is generally
    # unsafe unless the caller read, understood, and adhered to the prior
    # documentation; in particular, such command line *HOPEFULLY* runs no
    # command internally calling either this function or the "eval" builtin.
    #
    # To improve safety, this function previously conditionally quote protected
    # unescaped shell-reserved characters in such arguments, thus handling
    # arguments the caller neglected to explicitly quote protect with "(q)".
    # Unfortunately, such cleverness uncleverly munged valid zsh statements:
    # e.g.,
    #
    #       # Quote protecting the " " in "ls /tmp" produces unexpected results.
    #       run "print $(ls /tmp)"
    #
    # Hence, this function now elects to do nothing whatsoever, requiring the
    # caller quote protect user-passed arguments with "(q)".
    #
    # You have now entered the Clusterfuck Zone.
#   print_string "run: ${@}..."
    if is_standard_input_piped
    then run_with_standard_input_piped eval "${@}"
    else eval "${@}"
    fi
}

#FIXME: Rename to run_if_pathable().
document_function '
string run_if_runnable(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command if runnable (e.g., in the current ${PATH}).
'
function run_if_runnable() {
    die_unless_args 'expected one command'
    string command_name; command_name="$(get_string_word "${1}" 1)"
    is_pathable "${command_name}" and run "${@}"
}

# ....................{ RUNNERS ~ background               }....................
document_function '
void run_backgrounded(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command in the background.
'
function run_backgrounded() {
    run "${@}" &
}

document_function '
void run_disowned(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command disowned from the current shell and hence:

* Not listed in the jobs table and hence "jobs" output.
* Not receiving the HUP signal and hence terminating on termination of the
  current shell.
'
function run_disowned() {
    # For safety, run disowned commands in new subshells. While negligibly
    # expensive, this avoids subtle termination issues associated with process
    # substitution of temporary files: e.g.,
    #
    #     # Hideous. This captures 64 random strings into a temporary file and
    #     # prints such file as a disowned job. What now? Let me tell you what
    #     # now. No shell owns such job and hence deletes such file after job
    #     # completion, resulting in gradual file accumulation.
    #     run cat =(head -64 /dev/urandom) &!
    #
    #     # Beautiful. This performs the same task in a new subshell as a
    #     # disowned job. While disowned, some subshell owns such job and hence
    #     # deletes such file after job completion.
    #     (run cat =(head -64 /dev/urandom)) &!
#   print_string "running disowned: ${@}"
    ( run "${@}" ) &!
}

# ....................{ RUNNERS ~ directory                }....................
#FIXME: I'm not happy with the order of arguments to either this or the
#run_as_user() function. In keeping with Zeshy nomenclature, the command to be
#run should always be the *FIRST* passed argument -- not the laste. Reverse!

document_function '
void run_under_dir(
  string dirname,
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command under the passed directory.
'
function run_under_dir() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one dirname and one command '
    string dirname="${1}"
    shift_arg

    # Temporarily change to the passed directory, run the passed command, and
    # change back to the prior directory. Call the latter function in an
    # "always" block to ensure such restoration in the event of an exception.
    set_current_dir "${dirname}"
    {
#       print_string "running under \"${dirname}\": ${@}"
        run "${@}"
    } always {
        restore_current_dir
    }
}

# ....................{ RUNNERS ~ user                     }....................
document_function '
void run_as_user(
  string username,
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command as the passed user.
'
function run_as_user() {
    # Validate passed arguments, stripping off the prefixing username.
    die_unless_args_2_or_more 'expected one username and one command'
    string username="${1}"
    shift_arg

    # If the user under which to run the passed command is the current user,
    # defer to the run() command and immediately return.
    is "${username}" == "$(get_current_user)" si and {
        run "${@}"
        return_true
    }

    # Command name to run.
    string command_name; command_name="$(get_string_word "${1}" 1)"

    #FIXME: Insufficient. zsh builtins and functions should be executable as
    #other users, though it's probably non-trivial to do so. Perhaps prefix the
    #command line with "zeshy" and augment "bin/zeshy" to handle passed commands?
    #Yes, yes... something like this be close to it:
    #
    #   is_pathable "${command_name}" or sudo -E "zeshy -c '${*}'"
    #
    #Of course, that's not *QUITE* right. If ${*} contains either '"' or "'"
    #characters, we need to quote protect such characters (and *ONLY* such
    #characters, yes?). Not terribly difficult, but contemplate.
    die_unless_pathable "${command_name}"

    #FIXME: The first conditional is too strict; if "sudo" is installed, we want
    #to be checking whether the current user is listed by "/etc/sudoers". Ah;
    #hmm; that file has a rather complex structure. We really don't want to
    #parse it manually. Instead, let's just use the following logic:
    #if is_pathable sudo and { is_current_user_superuser "${username}"

    # If the target user is the superuser, use "sudo" to take advantage of
    # password caching. Avoid "@", as that splits the command line into discrete
    # arguments. "sudo" and "su" can split their own arguments, thank you.
    if is_pathable sudo and is_user_superuser "${username}"
    then sudo -E  "${*}"
    # Otherwise, use "su".
    else su -p -c "${*}" "${username}"
    fi
}

document_function '
void run_as_superuser(
  string command_name, string command_arg1, string command_arg2, ...)

Run the passed command as the superuser.
'
function run_as_superuser() {
    run_as_user root "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Terrible names, really. I've never been satisfied. The key, I suspect,
#is that they need be much more concise. Without that, there's really no
#incentive to bother with them. How about simply:
#
#* run_to_standard_output().
#* run_to_standard_error().
#* run_to_file().
#* run_to_file_and_print_standard_error() or run_to_file_standard_output().
#  Right; the latter, I should think. Reads great, so... go!
#
#It's obvious, in either case, what's being redirected: output. Seems
#substantially better, yes?
#FUXME: Rename run_redirecting_to_*() to run_redirected_to_*() everywhere below.
#   string command_name; command_name="$(get_command_line_runnable_name "${@}")"
#FUXME: "_silently" is a poor choice of adjective, both here and everywhere else.
#What we *REALLY* mean is "_silently", a much stronger adjective properly
#conveying the intent. After all, something that is quiet still emits sound --
#merely quieter than such sound otherwise might be. Silence, however, is another
#order of quietude, and perfectly reflective of the intended effect here.

#seemingly similar but substantially 
# --------------------( TODO                               )--------------------
# * Document the fact that non-shell-reserved arguments passed to run()
#   should *ALWAYS* be quote-protected by the caller with "${(q)@}". I believe
#   we've already penned relevant documentation in the WASTELANDS, so just restore.
#   Also note that if the caller fails to quote-protect such arguments, this
#   function silently attempts to quote-protect such arguments on the caller's
#   behalf -- and usually, but not always, succeeds.
#   Actually, that's no longer how it works: we *ALWAYS* force one level of quote
#   protection if passed multiple arguments and none otherwise. Much less error
#   prone, and implies that passing only one argument is ideal (since that affords
#   the caller total control over quote protection).
#See run_with_options() for further details.
#* Splits the passed string of options list names on whitespace into a proper
#  list of the names of all lists with options to be passed on such command
#  line (e.g., splits "ZESHY_GREP_OPTIONS ZESHY_GREP_OPTIONS_IF_RECURSIVE" into
#  a 2-element list containing both "ZESHY_GREP_OPTIONS" and
#  "ZESHY_GREP_OPTIONS_IF_RECURSIVE").
#* Sets the main options list name ${main_list_options_name} to the first
#  element of such list (e.g., "ZESHY_GREP_OPTIONS").
#* If the current shell is interactive, appends
#  "${main_list_options_name}_IF_SHELL_INTERACTIVE" to such list; else appends
#  "${main_list_options_name}_IF_SHELL_NONINTERACTIVE" (e.g., assuming the
#  latter case, "ZESHY_GREP_OPTIONS_IF_SHELL_NONINTERACTIVE").

#Create a command line to be run with the passed options and arguments and
#run such command line. While most run functions run the passed command line as
#is, this run function creates such command line dynamically: e.g.,
    # Append an options list name corresponding to whether the current shell is
    # interactive to the passed list of such names.
#   if is_shell_interactive
#   then __options_list_names__+="${__options_list_names__[1]}_IF_SHELL_INTERACTIVE"
#   else __options_list_names__+="${__options_list_names__[1]}_IF_SHELL_NONINTERACTIVE"
#   fi

#FUXME: O.K.; this should be substantially improved as follows:
#
#* If non-interactive, always prefix passed args with "--" as currently done.
#* If interactive, however, *NEVER* do so. It just completely breaks user
#  expectations, I'm afraid. That isn't too print_message that we can't still take
#  precautions, however: e.g.,
#  * Copy only "-"-prefixed passed args into a new temporary list.
#  * Filter such list with a file match glob excluding all list elements
#    *NOT* matching existing paths.
#  * If any list elements remain, print a warning and recommendation on how
#    to correct such issue (e.g., by prepending such args with "--").
#FUXME: Not every POSIX-style function calls this function. Consequently,
#I'm afraid we'll have to manually hunt down all current improper uses of
#"--" in such functions and excise them.
#FUXME: Technically, if interactive, we really only want to avoid prefixing
#passed args with "--" when this function is transitively called by a
#function of the same or similar name as the command to be run (e.g., when
#the passed command is "command rm" and this function is transitively called
#by interactive alias rr()). In such case, the current user has a reasonable
#expectation that any options entered will be passed as is to the corresponding
#underlying command. In all other cases, no such expectation exists. I should
#note that under the proposed help documentation revisions, the
#interactive_abbreviation() function will be improved so as to accept an
#optional option specifying the underlying external command to be run.
#Presumably, we'll then record all such passed options in a global map from
#alias to command name. Given that, determining whether or not to prefix
#passed args with "--" when interactive reduces to the following heuristic:
#
#* If and only if:
#  * The name of function called earliest on the call stack is an existing
#    key of such map *AND*
#  * The current command line to be run matches "command ${map_value}",
#    where ${map_value} is the value for such key in such map,
#* Then and only then exclude a prefixing "--".
#* Otherwise, always include a prefixing "--".
#
#Sweet. It's (fairly) simple, very efficient, and easily debuggable. Go, no?
#No iterative searching or complex heuristics required, so... It's hard to
#see any hard objections, really.
    # 1-based index of the first "--" in the passed arguments.
#   __dash_index__="${@[(i)--]}"
#   (( __dash_index__ == 1 )) and
#       die "arguments $(join_list_conjunctively "${@}") contain no options list names"

    # If the caller passed a "--" argument, move all arguments preceding such
    # argument into the list of options list names.
#   if (( __dash_index__ <= # )); then
#       __options_list_names__=( "${@[1,$(( __dash_index__ - 1 ))]}" )
#       shift_args "${__dash_index__}"
    # Otherwise, move only the first passed argument into such list.
#   else
#       __options_list_names__=( "${@[1]}" )
#       shift_arg
#   fi

    #FUXME: No point in uppercasing. Just reuse the caller-provided case.
    # Uppercase the first passed list name.
#   __options_list_name_uppercase__="$(\
#       uppercase_string "${__options_list_names__[1]}")"

#FUXME: Documentation's somewhat out-of-date and rather vague. Should note that
#the first passed list option name signifies the "root" to which
#"_IS_SHELL_INTERACTIVE", etc. will be appended.
#FUXME: Woops. Subtle, but fatal, flaw here: a "--" passed as an actual command
#argument is indistinguishable from a "--" passed to delimit the end of list
#option names. Oh, bloody hell. This function has become one gigantic ball of
#fail. Ah; right. I have the solution. It's a tad hacky, but much cleaner than
#the current nonsense, while still admitting the same expressivity: since
#variable names cannot contain whitespace by zsh definition, simply interpret
#the passed list_options_name as, in fact, a whitespace-delimited string
#splittable into all such names, callable like so:
#
#    run_with_options 'run_paged hiya' 'ZESHY_HIYA ZESHY_HIYA_RECURSIVE' "${(q)@}"
#
#While slightly awkward, I'm satisfied with the current argument order, as it
#corresponds exactly to the resulting order of interpolation. Phew! Make it so.

# * Appends the elements of all lists the contents of all lists with the passed name.
# * Append "--", treating subsequent command arguments as non-options. This
#   precaution prevents treating option-like arguments as options (e.g., if a
#   file "-l" exists, "ls -- -l" lists that file while "ls -l" does not).
# * Append the passed command arguments. This completes the command line.
# * If this function was called with piped input, pipe such input to the command
#   line; otherwise, run the command line as is.
#
# For example:
#
# string run_with_options(
#   string command_prefix,
#   string list_options_name1, string list_options_name2, ...,
#   "--",
#   string command_arg1, string command_arg2, ...)

#FUXME: Awkward nomenclature, really. How about simply
#run_silently_and_get_exit_status()? Same number of characters but reads simpler.
#The run_redirecting_*()-style nomenclature makes inherent sense as the
#writing effectively happens while running such command; but here, getting the
#exit status can only happen after running such command, suggesting "_and_" to
#be a much better fit.

# Run the passed command with standard error redirected to standard output, thus
# "unifying" all command output to standard output.
# string run_outcrying(
# string run_outputting(
# string run_under_standard_error(
# string run_under_standard_output(
# string run_on_standard_error(
# string run_on_standard_output(
# string run_into_standard_error(
# string run_into_standard_output(
# string run_to_standard_error(
# string run_to_standard_output(
# string run_to_standard_output(
# string run_standard_print_to_error(
# string run_print_to_standard_error(
# string run_standard_print_to_error(

# string run_to_standard_error(
# string run_print_to_standard_error(
#FUXME: O.K.; revert to the original idea of accepting an initial list of list
#names prior to the command prefix and subsequent arguments. It's quite simple
#to do so; just switch to:
#
# string run_with_options(
#   string list_options_name,
#   string command_prefix,
#   string command_arg1, string command_arg2, ...) --OR--
# string run_with_options(
#   string list_options_name1, string list_options_name2, ...,
#   "--",
#   string command_prefix,
#   string command_arg1, string command_arg2, ...)
#
#This requires a fairly significant fixup elsewhere, but renders this function
#dramatically simpler to use by callers. It also makes much more intuitive sense
#to pass options list names as "options" prefixed by the traditional "--"
#options prefix than the current oddball approach.

        # Remove all passed arguments preceding and including the first passed "--",
        # having copied such arguments into the prior list.
#       die "arguments $(join_list_conjunctively "${@}") contain no \"--\""
#   integer __i__
#   for (( __i__ = 1; __i__ <= #; __i__++ )) {
#       is "${@[${__i__}]}" == '--' si and break
#   }
# string run_with_options(
#   string command_prefix,
#   string list_options_name,
#   string command_arg1, string command_arg2, ...)
#FUXME: Rename to run_silently_as_user(), if we actually still use this
#somewhere. Wait; no. Excise this completely. Don't bother chaining run_*()
#commands together into one function. The number of possible permutations is
#stupidly high. Instead, just call such functions in a simple chain: e.g.,
#
#    run_silently run_as_user 'ls' 'leycec'

# void run_silently_as(
#   string username,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command as the passed user quietly (i.e., squelching output).
#function run_silently_as() {
#    run_as_user "${@}" &>/dev/null
#}

    #FUXME: Perform an additional sanity check before running: if such file is
    #an existing non-file, throw an exception. This suggests a new function
    #die_unless_file_or_not_found(). (Nice name!)
    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into zsh-specific words.
#   print_unescaped "command line: ${@}"
#   list command_line; command_line=( "${(z)@}" )
#   list command_line; command_line=( "${(Qz)@}" )
    #FUXME: Insufficient. Consider "LC_ALL=C ls".

#   print_string "PWD: ${PWD}"
#       print_string "PWD: ${PWD}"
#       set_current_dir "$(get_current_dir)"
    # If passed one argument, evaluate such argument is. This is the ideal case.
#   is_args_1 and {
#       print_string "run (single-arg eval): ${1}..."
#       if is_standard_input_piped
#       then eval "run_with_standard_input_piped ${1}"
#       else eval "${1}"
##       else
##           print_string 'piped no input'
##           eval "${1}"
#       fi
#       return_true
#   }

    # If piped input, pipe such input to the command to be run.
#   is_standard_input_piped and set_args 'run_with_standard_input_piped' "${@}"

    # Otherwise, passed multiple arguments that *HOPEFULLY* run no command
    # internally calling either this function or the "eval" builtin.
    #
    # This branch previously conditionally quote protected all unescaped shell-
    # reserved characters in such arguments, thus handling arguments the caller
    # neglected to explicitly quote protect with "(q)". Unfortunately, such
    # cleverness was entirely too clever, munging zsh statements like:
    #
    #       run "print $(ls /tmp)"
    #
    # Hence, we have elected to do nothing whatsoever, requiring the caller
    # quote protect user-passed arguments with "(q)".
    #
    # You have now entered the Clusterfuck Zone.
#   print_string "run (multiple-arg eval): ${args[@]}... (last arg: ${@[-1]})"
#   eval "${@}"
    # Otherwise, we've entered the Clusterfuck Zone. zsh deals poorly with
    # quotes in "eval" strings. We can't simply brute-force quote-protection on
    # all passed arguments (e.g., "eval ${(q)@}"), as that overly quotes passed
    # arguments the caller expects to remain unquoted (e.g., "2>&1"). Instead,
    # we implement a crude shell parser selectively quote-protecting only non-
    # evaluatable strings *NOT* containing reserved characters. YES, THIS IS
    # AAAAAAAAAABSOLUTELY CRAZY. Fix this, kind zsh developers. (Fix this now.)

# See above examples.
#
# Run the passed command. While zsh and hence Zeshy already run strings as
# commands if in command position, strings containing shell-reserved characters
# (e.g., "|", "<", ">") do not run as expected. This function amends that.
#
# conditionally quote-protecting passed arguments as required: e.g.,
#
#   # Command to be run, split into multiple parts to make life troublesome.
#   >>> string command='cat /dev/random | grep'
#   >>> list grep_args; grep_args=( -E '\{Eschaton Entombed\(\)\}' )
#
#   # Doubleplusungood. zsh parses the former as one composite command name and
#   # the pipe in the latter as a raw command argument. In either case, failure.
#   >>> ${command} ${grep_args[@]}          # bad!
#   >>> ${(z)command} ${(q)grep_args[@]}    # equally bad!
#
#   # Ohsonice. Run the expected command.
#   >>> run "${command}" "${grep_args[@]}"
#   {Eschaton Entombed()}                   # it could happen...
#
# This function suffers numerous pitfalls, which you don't usually but
# occasionally need to worry about. Beware the following impenetrable caveats:
#
# * When passing a single argument interpolated from a caller-provided list,
#   expand list elements with ${*} rather than ${@}. The former expands list
#   elements in place as expected; the latter expands list elements into
#   multiple arguments rather than a single argument, despite appearances: e.g.,
#
#   # Doubleplusungood. If "${@}" contains at least two elements, this passes
#   # run() such elements as discrete arguments and appends " | pv -t" onto the
#   # final such element. Probably not what you indiscretely expected, eh?
#   >>> run "${@} | pv -t"
#
#   # Ohsonice. This never does the wrong thing.
#   >>> run "${*} | pv -t"

    #FUXME: Not quite right. We should probably call "$(get_command_line_runnable_name)"
    #to get the name of the command in command position. *shrug, for the moment*
#   list command_line; command_line=( "${(z)@}" )
#   is "${command_line[1]}" == run(|_?*) si and {

    #FUXME: Shouldn't we be reusing the split apart "${command_line}" from above?
#   list args; args=( "${@}" )
#   list args; args=( "${(@)@[1,-1]}" )
#   list arg_words
#   print_string "run (multiple-arg eval): ${args[@]}... (last arg: ${@[-1]}) [before]"
#   for ((i = 1; i <= ${#args}; i++)) {
        #FUXME: Still not quite right. Basically, we should be forcefully escaping
        #*ALL* unescaped shell-reserved characters -- not merely ", ', and " ". If
        #the caller would rather no such characters be escaped, then they need to
        #pass one and only one argument. Basically, this function has three
        #different modes of operation; we need succinctly document all three, above.
        #
        #*WAAAAAIT*. Wait just a minute. Is all of this extreme effort effectively
        #equivalent to just calling:
        #    "${@}"
        #I mean, we're effectively prohibiting reserved shell characters anyway.
        #So... I don't see the difference. Simply running "${@}" is obviously a
        #vast improvement over the computationally expensive and admittedly
        #error-prone logic below. In fact, reducing to "${@}" allows us to
        #completely remove the above run_*() logic. Also nice.
        #
        #Yes. This strikes me as the way to go. The eval() builtin basically
        #breaks down completely when passed multiple arguments and hence cannot
        #be called reliably in such cases. So, don't. Just run "${@}" as is
        #if passed multiple arguments to sidestep such issues entirely.
        #
        #Nice. I've just verified running "${@}" works as expected with builtins.
        #What're we waiting for...?
        #
        #Actually, I'm glad I waited. Drop this entire "for" loop. The remainder
        #of this function remains the same. This is the best we can do, I'm afraid.
        #Unfortunately, this sort of ad-hoc dynamic quote protection works in the
        #average case but generally fails: e.g., if passed "$(ls hello)", we don't
        #want to quote protect the space in such argument. Hence, stop doing this
        #altogether. *shrug*

        # Quote protection flag "(q)" escapes all shell-reserved characters
        # (e.g., "<", "&", "|"). While useful, such protection conflicts with
        # caller expectations. In this case, callers expect us to interpret
        # such characters according to their shell-reserved meaning rather than
        # as escaped characters. Hence, escape only the proper subset of shell-
        # reserved characters not conflicting with such expectations: namely,
        # single spaces, single quotes, and double quotes. Do so only when such
        # character has not already been escaped (i.e., prefixed with "\").
        #
        # Dismantled, this is:
        #
        # * "${args[${i}]//", globally replacing in the current argument.
        # * "(#b)", enabling back references (i.e., match groups).
        # * "(...|)", matching as group 1 either:
        #   * "(#s)", the beginning of the string.
        #   * "[^\\]", any character other than a "\" escape.
        # * "([ \'\"]), matching as group 2 the character to be escaped.
        #
        # *SUCH REPLACEMENT IS INDELIBLY, INCREDIBLY FRAGILE*. Since this
        # function comprises the heart of Zeshy operation, take care when
        # revising such replacement to account for all possible cases. In
        # particular, see list_path(). Attempt calling such function
        # with filenames containing both spaces and unbalanced quotes when
        # passing arguments as both "${@}" and "${(q)@}". Such replacement
        # should succeed under both protected and non-protected arguments.
#       print_string "run (multiple-arg eval): fixing up argument ${i} \"${args[${i}]}\"..."
#       args[${i}]="${args[${i}]//(#b)((#s)|[^\\])([ \'\"])/${match[1]}\\${match[2]}}"
#       arg_words=( "${(z)args[${i}]}" )
#       (( ${#arg_words} > 1 )) and {
#           print_string "run: fixing up \"${args[${i}]}\"..."
#           args[${i}]="${(q)args[${i}]}"
#       }

        #FUXME: Clearly, this fails to match all possible shell strings. It
        #should, however, suffice with immediate needs.
        #FUXME: Does this accomodate "is" and "si" in passed arguments? We
        #may need to perform an eval to expand aliases, here.
        #FUXME: Seems inherently dangerous, actually. Filenames containing
        #reserved characters as well as spaces or quotes certainly require
        #quote protection as well. Hmmm.

        # If the current argument contains at least one reserved shell
        # string (i.e., "<", ">", "||", "&&", or "$" when not preceded by an
        # escaping "\\" and not enclosed in quotes), ignore such argument.
        # Quoting such argument destroys its shell interpretation.
#       is "${args[${i}]}" == (|*[^\\])(*[\<\>\|\&\$\(\)\[\]\{\}]*) si and
#       is "${args[${i}]}" != (\'*\'|\"*\"|\`*\`) si and continue

        # If the current argument cannot be evaluated, quote such argument
        # and ensure the result can be. Avoid calling Zeshy functions here
        # (e.g., run_silently()), as such functions transitively call this
        # function. (Ugh!)
#       eval ": ${args[${i}]}" 1>/dev/null 2>&1 or {
#           print_message "fixing up ${args[${i}]}"
#           args[${i}]="${(q)args[${i}]}"
#           eval ": ${args[${i}]}" 1>/dev/null 2>&1 or
#               die "command \"${@}\" argument \"${arg}\" invalid"
#       }
#   }
#   eval ${(q)@}
#   eval ${@}
#   ${@}
#   return $?

    #FUXME: This works, but is rather clumsy. For one, it fails to account for
    #user-defined functions calling run(). For another, it's slow and abjectly
    #error-prone. How about reducing this to:
    #
    #   string run_function_glob='run(|_*)'
    #
    #This simply and effectively matches user-defined functions, assuming they
    #prefix such functions with "run_". This does not, however, match all of our
    #functions. We'll need to systematically rename them all, I'm afraid (e.g.,
    #run_with_priority_highest() to run_run_with_priority_highest()). Arguably, this is a good move *ANYWAY*.
    #Consistency assists readability, and makes it explicit exactly what's
    #happening when you call such functions.

    # If running a Zeshy function recursively calling this function, do *NOT*
    # "eval" the passed command as the second call to this function will do so
    # already. Since each "eval" strips one level of quotes from such command,
    # running such command as is avoids stripping of quote protection.
#   string run_function_glob='(run(|_as|as_superuser|_every|_paged|_with_options|_with_priorities)|run_with_priority_highest|run_silently(|_as)|run_with_priority_lowest|run_to_standard_output)'
#   list command_line; command_line=( "${(z)@}" )
#   is "${command_line[1]}" == ${~run_function_glob} si and {

#       list command_line; command_line=( "${@}" )
#       print_string "run_paged: ${command_line[@]}..."
    #FUXME: Ugh. Broken. We need to ignore VT100 commands. I've been
    #searching for a zsh-specific solution, but have yet to find anything. Ah!
    #It's not zsh, but it'll do: sed!
    #http://www.commandlinefu.com/commands/view/3584/remove-color-codes-special-characters-with-sed
    #Looks like this should get us close. Let's research it a bit:
    #sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
    #sed -r "s/\x1B\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g"
    #I suspect the second is more accurate. Again, research.
#       print_width=${#"$(remove_ansi_color_codes "${line}")"}
#       line="$(remove_ansi_color_codes "${line}")"
#       print_width=${#line}

        #FUXME: Excise this frivolous check after all's well above.
#       exec {/dev/stdin}>&-
#       exec 0<&-
#       is_standard_input_piped and die 'uh-oh; still piped input!'
    # Terminal width plus one to avoid treating maximally long lines as wrapped.
# terminal_width_plus_one
# (( terminal_width_plus_one = terminal_width + 1 ))
        # Test line height.
#       (( line_height += line_width / terminal_width ))
#       (( line_height > terminal_height )) and break
#   (( wrapped_line_height > terminal_height )) or {
#       (( line_width > maximum_line_width && maximum_line_width = line_width ))
#       (( maximum_line_width > terminal_width )) and break
    # Localize passed arguments. Do *NOT* call die_unless_args_2_or_more(),
    # as such function suffixes the argument list with piped input. While this
    # is typically what we want, this function already pipes piped input to the
    # command to be run... Suffixing the argument list passes such input to such
    # command twice, therefore. Which is blatantly bad.
#   (( # >= 2 )) or
#       die 'expected one command prefix, one list name, and zero or more command arguments'
#       args[${i}]="${args[${i}]//(#b)([ \'\"])/\\${match[1]}}"

        #FUXME: O.K.; this works, but it's all a bit shoddy. Test this by
        #editing list_path(), adding back "${(q)@}" and seeing whether
        #things survive! We may need to be a bit less zealous.
        #FUXME: This should probably avoid escaping already escaped characters
        #(e.g., "\ "). Use a method similar to below, I'd imagine.
#       args[${i}]="${args[${i}]//(#b)(^|[^\\])([ \'\"])/${match[1]}\\${match[2]}}"
#       args[${i}]="${${args[${i}]// /\\ }//'}"
#       arg_words=( "${=args[${i}]}" )
    #FUXME: Generalize to a run_with_options() approach. Also, we currently pass
    #"-x" to prevent "watch" from running the passed command under "sh -c", which
    #will rarely behave as expected from a Zeshy perspective. However, that means
    #we actually need to prefix such command with "zsh -c" if a zsh builtin or
    #die if a Zeshy-specific function. Or, would zsh shells spawned by the
    #"watch" command inherit Zeshy functions? Hmmmmm; test us up. Also,
    #"--color" doesn't really work. That's O.K., but don't expect miracles.
    #(Color support is a Gentoo patch courtesy Debian, so there you go...)

#       string output; output="$(run "${@}" 2>&2 2>&1 1>&1 1>&2)"

#   eval ${command_line[@]}
#   eval "${(q)command_line[@]}"

    # If passed at least one non-option argument, append such arguments.
#   is_args and is "${1}" != [\<\|]* si and command_line+=( -- "${@}" )
#   is_args and {
#       if is "${1}" == [\>\<\|]* si
#       then command_line+=(    "${@}" )
#       else command_line+=( -- "${@}" )
#       else command_line+=( -- "${(q)@}" )
#       fi
#   }

#. Note
# that preserving escapes and quotes (e.g., "\ ", "'''") in command arguments
# requires protecting arguments with "(q)" prior to calling this function#|\$\{*\))|(\$\(*\)
#       for arg ("${args}") {
#           noop "${args[${i}]}" or {
#           if not eval "print -- ${args[${i}]}" 1>/dev/null 2>&1 or {
#               print_message "fixing up ${args[${i}]}"
#               args[${i}]="${(q)args[${i}]}"
#               eval "print -- ${args[${i}]}" 1>/dev/null 2>&1 or
#                   die "command \"${@}\" argument \"${arg}\" invalid"
#           }
#                  eval "print -- ${(q)args[${i}]} true" 1>/dev/null 2>&1; then
#              eval "print -- ${args[${i}]} true" 1>/dev/null 2>&1 or {
#              eval "print -- ${args[${i}]}" 1>/dev/null 2>&1 or {
#           if is "${args[${i}]}" != [\'\"]* si and
#              is "${args[${i}]}" != *[\<\>\|]* si and
#              not eval "print -- ${args[${i}]}" 1>/dev/null 2>&1; then
#               print_message "fixing up ${args[${i}]}"
#               args[${i}]="${(q)args[${i}]}"
#               eval "print -- ${args[${i}]} true" 1>/dev/null 2>&1 or
#                   die "command \"${@}\" argument \"${arg}\" invalid"
#           fi

    # If one argument was passed, such argument signifies a command line to be
    # run. Otherwise, only the concatenation of such arguments signifies the
    # line. In the latter case, embedded escapes and quotes (e.g., "\ ", "'''")
    # in such arguments must be preserved in the expansion with "(q)".
#   if is_args_1
#   then eval "${1}"
#   else eval "${@}"
#   else eval "${(q)@}"
#   fi

#function run_silently_converting_exit_status_to_boolean() {
#}
#function run_silently_and_get_exit_status_boolean() {
#}
#function run_silently_and_get_boolean_exit_status() {
#}

#run_and_get_exit_status_if_false
#FUXME: Pretty silly. We don't use this. Consider excising. Actually, it could
#be helpful to generalize this to something like:
#   return_command_exit_status_if_false
# int one_if(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command run_silently (i.e., squelching output) and, if exiting
# with success, return "1"; otherwise, return the empty string: e.g.,
#
#     >>> integer IS_MUTT_INSTALLED=$(one_if is_pathable mutt)
#     >>> is_nonzero "${IS_MUTT_INSTALLED}" and print '"mutt" is installed'
#     "mutt" is installed
#one_if() {
#    run_silently "${@}" and return 1 or return_true
#}

# that preserving escapes and quotes (e.g., "\ ", "'''") in command arguments
# requires protecting arguments with "(q)" prior to calling this function: e.g.,
#
#   # Command to be run.
#   >>> list command_line
#   >>> command_line=( screen -list | grep --count ' )
#
#   # Command arguments to be passed to "grep".
#   >>> list grep_args; grep_args=( --count 'eschaton' )
#   print_unescaped "last... \"${command_line[-1]}\"..."
#   eval command ls -l "${command_line[-1]}"
#   eval run_paged command ls -l "${command_line[-1]}"
#   run_it run_paged command ls -l "${command_line[-1]}"
#   run ${command_line[@]}

#FUXME: This function should really be cleaved into two: all of the user-
#specific logic shifted into run_as() and only the eval() retained in this
#function. That shouldn't leave terribly much here... which is good. You know;
#the more I consider it, the more I wonder if run() shouldn't simply be a
#straightforward alias for 'alias'. That would single-handedly eliminate all of
#the "(q)" nonsense... and thereby break everything! The solution is simple:
#
#* Create a new "alias run='eval'" alias.
#* Transition all existing run() calls to run().
#* Rename run() to run_as(), probably with slight implementation changes.

#FUXME: This function should really be cleaved into two: all of the user-
#specific logic shifted into run_as() and only the eval() retained in this
#function. That shouldn't leave terribly much here... which is good. You know;
#the more I consider it, the more I wonder if run() shouldn't simply be a
#straightforward alias for 'alias'. That would single-handedly eliminate all of
#the "(q)" nonsense... and thereby break everything! The solution is simple:
#
#* Create a new "alias run='eval'" alias.
#* Transition all existing run() calls to run().
#* Rename run() to run_as(), probably with slight implementation changes.

# void run(string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed builtin or command, ideally quote-protected to avoid premature
# parsing of shell-specific syntax (e.g., pipes, redirections). Where passing a
# parameter expansion to this function, force such protection with "(q)": e.g.,
#
#   # Good! Manually quote-protect with single or double quotes.
#   >>> run 'screen -list | grep --count eschaton'
#   969
#
#   # Good! Automatically quote-protect with parameter expansion flag "(q)".
#   >>> string command=$(screen -list | grep --count singularity)
#   >>> run "${(q)command}"
#   696
#
#   # Doubleplusungood. zsh parses the pipe prior to calling run().
#   >>> run screen -list | grep --count eschaton
#run() {
#    die_unless_args 'expected one or more command strings'

    # Command line to run. Dismantled, this is:
    #
    # * "Q", stripping one level of quote protection from the passed parameters,
    #   undoing prior "(q)" quote protection.
    # * "z", splitting such parameters into zsh-specific words.
#   print "command line: ${@}"
#    list command_line; command_line=( "${(Qz)@}" )
#   list command; command=( "${(Qz)@}" )
#   print "second arg: ${command_line[2]}"
    
    # Command name to run as the first word of such command line.
#   string command_name="${(Q)command_line[1]}"
#    string command_name="${command_line[1]}"
    
    # A string conditionally defined to (in order):
    #
    # * If a zsh alias, function, or builtin has the command name, that name.
    # * Otherwise, if the current $PATH contains the command name, the absolute
    #   path to that command.
    # * Otherwise, raise an exception.
#    string command_path
#    command_path="$(whence "${command_name}")" or
#        die "\"${command_name}\" not found in \$PATH"

    # If the passed command has not been overridden by a shell alias or
    # function, run it as a command. Do not call the customary is_pathable()
    # function, as that does not test whether or not a command is overridden.
#    if is_path_absolute "${command_path}"; then
        # If running this command under a different user, do so.
#        if is_string_nonempty 'ZESHY_RUN_AS' and
#           is "${ZESHY_RUN_AS}" != "${USER}" si; then
            # If the target user is the superuser, use "sudo" to take
            # advantage of password caching. Do *NOT* use the "(@)" expansion in
            # either of the following two commands, as that would split the line
            # into discrete command arguments.
#            if is "${ZESHY_RUN_AS}" == root si and is_pathable sudo; then
#               echo "sudoing as ${ZESHY_RUN_AS}: ${command}"
#                sudo -E "${command_line}"
            # Otherwise, use "su".
#            else
#               echo "suing as ${ZESHY_RUN_AS}: ${command}"
#                su --preserve-environment\
#                   --command "${command_line}" "${ZESHY_RUN_AS}"
#            fi
        # Otherwise, run this command as the current user. Use the "[@]"
        # expansion here, as calling the command manually requires we split the
        # line into discrete command arguments. Evaluate this command to ensure
        # the shell correctly handles shell constructs (e.g., "|").
#        else
##           print "evaling: ${command_line[@]}"
#            eval "${command_line[@]}"
#        fi
    #FUXME: Incomplete. How does one run a builtin as another user? Implement.
    # Otherwise, the passed command must be a shell built-in. Evaluate it!
#    else
#       print "evaling: ${command_line[@]}"
#        eval "${command_line[@]}"
#    fi
#}
    # If the second-to-last passed argument is "--", treat the last passed
    # argument as a command line suffix to be appended to the command line.
#   if is_args_at_least_2 and is "${@[-2]}" == '--' si; then
#       command_line_suffix="${@[-1]}"
#       pop_args_2
#   fi

    #FUXME: This isn't quite right. The reason why, of course, is long lines.
    #Technically, such lines contain a single newline; when displayed, such
    #lines implicitly force more than a single newline. To account for this,
    #we'll need add a new function get_displayed_line_length() to
    #"shell/terminal". Its implication returns an integer as follows:
    #
    #* For each physical line in the passed string, increment line length by one.
    #* For each 80th character (or what have you) in each physical line in the
    #  passed string, increment line length by one. A simple calculation
    #  obtains this:
    # If not outputting to a terminal of height less than the height of the
    # print_string produced by this command, immediately return.

#   is_standard_output_terminal and
#     (( $(get_displayed_line_length "${output}") >  )) or
#     return_true

    # Localize passed arguments.
#   list lines; lines=( "${(f)@}" )

    #FUXME: Is this really the most efficient means of propagating pipes?
#   then run "print -- $(< /dev/stdin)' | ${(q)command_line[@]}"

#   die_unless_args_2_or_more\

# string testify(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command, converting raised exceptions to non-zero exit status.
# This function is particularly helpful for propagating exceptions thrown by
# subshells up the call stack of the current shell. (By default, zsh does *NOT*
# propagate such exceptions.)
# reliably capturing the standard
# print_string of exception-throwing functions: e.g.,
#
#     # Bad. Regardless of whether get_file_first() throws an exception, the
#     # declaration of "first_file" silently succeeds.
#     >>> string first_file="$(testify get_file_first /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#     
#     # Good. If get_file_first() throws an exception, the declaration of
#     # "first_file" explicitly fails by propagating such exception.
#     >>> string first_file="$(testify get_file_first /rache /bartmoss)" or
#     ...   die 'neither "/rache" or "/bartmoss" found'
#testify() {
#    {
#        run "${(q)@}" 2>&1
#    } always {
#        integer exit_status=${?}
#        (( ${exit_status} )) and exit ${exit_status}
#    }
#}

    #FUXME: ...we appear to no longer require the "Q". (Naturally, I have no
    #firm idea why.)

#   string command_line="$(get_command_line "${@}")"

# Note, commands should be passed as quoted strings to prevent the calling
# shell from evaluating pipes, redirections, et al. prior to passing the
# command. (See the run() function, above.)

    #FUXME: This only strips one dash. How to strip more?
    # Strip prefixing dashes from this string to prevent the "basename" command
    # from intepreting such dashes as options to that command. This is actually
    # a real-world concern. By convention, for example, Linux prefixes login
    # shell command lines with one dash.
#   string process_command_line="${$(get_process_command_line)#-}"
#   string process_command_line="$(get_process_command_line)"
#   process_command_line="${process_command_line#-}"
