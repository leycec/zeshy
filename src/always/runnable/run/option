#!/usr/bin/env zsh
# ====================[ option                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle dynamically constructed command lines passed options lists.

# ....................{ RUNNERS ~ options                  }....................
document_function '
string run_with_options(
  string command_prefix,
  string options_list_names,
  string command_arg1, string command_arg2, ...)

Construct a command from the passed arguments; then run such command: e.g.,

  # Run grep recursively with the passed list of options and user arguments,
  # paging standard output if required.
  >>> run_with_options "run_paged grep"\
  ...   "ZESHY_GREP_OPTIONS ZESHY_GREP_OPTIONS_IF_RECURSIVE" "${(q)@}"

Specifically:

* Split the passed string of options list names on whitespace into a list of
  the names of all lists with options to be passed to such command (e.g., splits
  "ZESHY_GREP_OPTIONS ZESHY_GREP_OPTIONS_IF_RECURSIVE" into a list containing
  "ZESHY_GREP_OPTIONS" and "ZESHY_GREP_OPTIONS_IF_RECURSIVE").
* Set the command to be run to pipe standard input if this function was piped
  such input or to the empty string otherwise (e.g., "cat /dev/stdin |" or "").
* Append the passed prefix to such command (e.g., "run_paged grep -R").
* For every list name in such list:
  * If that list exists, append all elements of that list to such command.
  * Else throw an exception.
* Append the passed arguments to such command (e.g., "${(q)@}").
* Run such command (e.g., assuming the caller passed a single argument ''Weeds''
  and piped no input and the above options lists contain default elements,
  "run_paged grep --extended-regexp --no-messages --recursive ''Weeds''").
'
function run_with_options() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'
    string command_prefix__rwo="${1}"
    list command__rwo options_list_names__rwo

    # If passed piped input, propagate such input to the command to be run.
    is_standard_input_piped and command__rwo+=( cat '/dev/stdin' \| )

    # Append such prefix split into shell words to such line.
    command__rwo+="${(z)command_prefix__rwo}"

    # Split the whitespace-delimited string of option list names into a list of
    # such names, to be interpolated below.
    set_list_to_string_split_on_words options_list_names__rwo "${2}"
    shift_args_2

    # For each options list name, append the contents of such list to such
    # command or throw a warning if no such list exists.
    for options_list_name__rwo ("${options_list_names__rwo[@]}") {
        if is_list "${options_list_name__rwo}"
        then command__rwo+=( "${(@P)options_list_name__rwo}" )
        else die "\"${options_list_name__rwo}\" not a list"
        fi
    }

    # Append all remaining passed arguments to such command.
    command__rwo+=( "${@}" )

    # Run such command.
#   print_string "run_with_options: \"${command__rwo[*]}\"..."
    run "${command__rwo[@]}"
}

document_function '
string run_with_options_silently(
  string command_prefix,
  string options_list_names,
  string command_arg1, string command_arg2, ...)

Construct a command from the passed arguments; then run such command quietly
(i.e., with neither terminal output or interactive input). To do so, append
" ${list_name_first}_IF_SHELL_NON_INTERACTIVE" to the passed string of list
names, where ${list_name_first} is the first list name in such string; then
call run_with_options() on such arguments.
'
function run_with_options_silently() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'

    # The first shell word from the list of options list names, having the name
    # of the options list to be suffixed below.
    string options_list_name_first__rwos
    options_list_name_first__rwos="$(get_string_word "${2}" 1)"

    # For each options list name given below, append such name to the passed
    # list of such names if such list exists.
    is_list "${options_list_name_first__rwos}_IF_SILENT" and
        2+=" ${options_list_name_first__rwos}_IF_SILENT"
    is_list "${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE" and
        2+=" ${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE"

    # Run such command. Avoid prepending such command with a call to
    # run_silently(), which inadvertently silences error output from
    # run_with_options(). Specifically, don't do this:
    #
    #     >>> run_silently run_with_options "${@}"
    run_with_options "${@}"
#   run_with_options "${@}" '1>&2'
}

document_function '
string run_with_options_configured(
  string command_prefix,
  string options_list_names,
  string command_arg1, string command_arg2, ...)

Construct a command from the passed arguments contextually depending on whether
or not the current shell is interactive; then run such command. To do so, append
" ${list_name_first}_IF_SHELL_INTERACTIVE" if this shell is interactive or
" ${list_name_first}_IF_SHELL_NON_INTERACTIVE" otherwise to the passed string of
list names, where ${list_name_first} is the first list name in such string; then
call run_with_options() on such arguments.
'
function run_with_options_configured() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one command prefix, one list name, and optional command arguments'

    # The first shell word from the list of options list names, comprising the
    # name of the options list to be suffixed below.
    string options_list_name_first__rwoc
    options_list_name_first__rwoc="$(get_string_word "${2}" 1)"

    # If an options list with name corresponding to whether the current shell is
    # interactive or not exists, append such name to the passed list of such
    # names if such list exists.
    string options_list_name__rwoc
    if is_shell_interactive
    then options_list_name__rwoc="${options_list_name_first__rwoc}_IF_SHELL_INTERACTIVE"
    else options_list_name__rwoc="${options_list_name_first__rwoc}_IF_SHELL_NONINTERACTIVE"
    fi
    is_list "${options_list_name__rwoc}" and
        2+=" ${options_list_name__rwoc}"

    # Run such command.
    run_with_options "${@}"
}

# --------------------( WASTELANDS                         )--------------------
#   options_list_names__rwo+=( '1' )
#   print "list type: ${(t)options_list_names__rwo}"
#   die_unless_list options_list_names__rwo
    # Similarly, avoid prepending such command with a call to
    # run_to_standard_error(), which... well, I can't quite remember
    # why not. Hmm.
    #
    #     >>> run_to_standard_error run_with_options "${@}"
#   print "running silently: ${*}"
#   for options_list_name__rwos (
#       "${options_list_name_first__rwos}_IF_SILENT"
#       "${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE") {
#       is_list "${options_list_name__rwos}" and
#           2+=" ${options_list_name__rwos}"
#   }
    # Append a non-interactive-specific options list name, regardless of whether
    # the current shell is interactive.
#   2+=" ${options_list_name_first__rwos}_IF_SHELL_NONINTERACTIVE"

#FUXME: Ah; it's not an objection, more a... curiosity. But how are pipes
#handled in relation to the call stack, exactly? We'd really like one-liners
#such as "ls -o --type=full * | grep -v yumyum | less -o" to work as
#expected. I suspect the shell already handles this correctly by running
#each pipe command as the root of its own call stack in a separate subshell...
#Hmm; but, in that case, such subshells would be marked as non-interactive.
#In any case, we'll just have to test such pipes ourselves and see what zsh
#comes up with. (We should be able to hack it up in our favor, but...)
#FUXME: *NO, NO, NO.* The above heavy-weight solution is horrible. It's
#horribly inefficient. It's horribly complex. It's a big fail. Here's what
#we're going to do instead. It's not pretty, but we have to do it anyway to
#support arbitrary option passing when interactive: for *MOST* functions with
#existing interactive aliases, we need to divert such aliases to a new
#function with name prefixed by "_interactive" accepting arbitrary options
#and *NOT* passing "--". The original non-interactive function must, on the
#other hand, explicitly pass "--". We've already excised the hard-coded "--"
#from this function, so we're good to go. Look: I know it'll be unpleasant,
#but we basically have little choice. It'll probably take two days from
#starting to finishing such revisions.
#
#Example:
#Define a new remove_file_interactively() function. Redefine interactive
#alias "rm" to call such function rather than remove_file(). Do *NOT* change
#the original remove_file(). And...we're good!

#ensure the resulting command
#does *NOT* request input from the current user
