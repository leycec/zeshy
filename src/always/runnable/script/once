#!/usr/bin/env zsh
# ====================[ once                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle shell scripts "once" (i.e., avoiding sourcing scripts already
# sourced under the current shell). While Zeshy itself calls no functions
# defined by this component, such functionality may be helpful to callers
# handling only a small to medium number of shell scripts. For efficiency, Zeshy
# prefers implicitly autoloading function definitions with digest files rather
# than explicitly sourcing shell scripts.

#FIXME: All functions below are effectively broken and require testing! Hurk.
#Documentation's probably a bit... off, as well.

# ....................{ SOURCERS                           }....................
document_function '
string source_shell_scripts_once(string filename1, string filename2, ...)

Source the passed shell scripts "once" (i.e., not sourcing scripts already
sourced under the current shell).
'
function source_shell_scripts_once() {
    die_unless_args 'expected at least one filename'
    for script_name ("${@}") source_shell_script_once "${script_name}"
}

#FIXME: The prefixing of variable names with "zeshy_" is, frankly, silly. Cease.
document_function '
string source_shell_script_once(
  string filename, string arg1, string arg2, ...)

Source the passed shell script if not previously sourced by this function or
externally modified since such sourcing; otherwise, return silently. When
sourcing such script, pass the passed arguments.

If the passed path is relative, we look for such path first under the current
working directory and then Zeshy''s root directory (e.g., "/usr/share/zeshy/").
We then resolve the exact Zeshy script(s) to be imported as follows:

* If the passed path is an existing file, import such file.
* If the passed path is an existing directory:
  * Containing a file named "${ZESHY_MAIN_SCRIPT_BASENAME}", import such file.
  * Otherwise, import all files such directory contains.
* Otherwise, die.

This function mimics the import() builtin of high-level languages (e.g., Python).

This function defines local variables, which imported scripts may safely
access for informative path metadata: namely,

* "zeshy_script_name", having the relative path to the imported script under
  "${ZESHY_HOME}/src".
* "zeshy_script_path", having the absolute path to the imported script.
* "zeshy_script_mtime", having the modification time of the imported script.
'
function source_shell_script_once() {
    # Validate passed arguments.
    die_unless_args\
        'expected one filename and optional script arguments'
    string zeshy_script_path="${1}"
    die_unless_file "${zeshy_script_path}"
    behead_arg

    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path.
    zeshy_script_path="$(canonicalize_path "${zeshy_script_path}")"

    # Modification time of this script.
    integer zeshy_script_mtime
    zeshy_script_mtime="$(get_path_mtime "${zeshy_script_path}")"

    map_global_export ZESHY_REQUIRED_PATH_TO_MTIME

    # If this script has not yet been imported or has been but has changed since
    # being imported, (re)import this script.
    if not is_map_key ZESHY_REQUIRED_PATH_TO_MTIME "${zeshy_script_path}" or
        (( zeshy_script_mtime !=\
            "${ZESHY_REQUIRED_PATH_TO_MTIME["${zeshy_script_path}"]}" )); then

        # Record this script as being imported prior to doing so, thus
        # preventing infinitely recursive reimportation should this or another
        # script imported by this script attempt to import this script again.
        ZESHY_REQUIRED_PATH_TO_MTIME["${zeshy_script_path}"]="${zeshy_script_mtime}"

        # Source such script.
        say "sourcing \"${zeshy_script_path}\"..."
        source_shell_script "${zeshy_script_path}" "${@}"
    fi
}

document_function '
string source_shell_script_once_under_dir(
  string dirname, string arg1, string arg2, ...)

Conditionally import the passed directory. See source_shell_script_once() for
further details.
'
function source_shell_script_once_under_dir() {
    # Validate passed arguments.
    die_unless_args\
        'expected one dirname and optional import options'
    string zeshy_script_dir="${1}"
    die_unless_dir "${zeshy_script_dir}"
    behead_arg

    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.swp", excluding files with filetype "swp".
    for zeshy_script_dir_child ( "${zeshy_script_dir}"/*(-.)~*.swp ) {
        # Delegate to helper functions depending on path type.
        if is_dir "${zeshy_script_path}"
        then source_shell_script_once_under_dir "${zeshy_script_dir_child}" "${@}"
        else source_shell_script_once "${zeshy_script_dir_child}" "${@}"
        fi
    }
}

# --------------------( WASTELANDS                         )--------------------
#       source_shell_script_once "${zeshy_script_dir_child}" "${@}"
    # Validate passed arguments.
#   die_unless_args 'expected one pathname and optional script arguments'
#   string zeshy_script_name="${1}" zeshy_script_path
#   behead_arg

# void source_shell_script_once_file(
#   string filename, string arg1, string arg2, ...)
#
# Conditionally import the passed file. See require() for details.
#function source_shell_script_once_file() {
#}

    # Delegate to helper functions depending on path type.
#   if is_dir "${zeshy_script_path}"
#   then source_shell_script_once_dir  "${zeshy_script_path}" "${@}"
#   else source_shell_script_once_file "${zeshy_script_path}" "${@}"
#   fi

    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.swp", excluding files with filetype "swp".
#   for zeshy_script_dir_child ( "${zeshy_script_dir}"/*(^D@)~*.swp ) {
#       source_shell_script_once "${zeshy_script_dir_child}" "${@}"
#   }

    # If such script is either an absolute path or extant relative path, attempt
    # to import such script as is.
#   if is_path_absolute "${zeshy_script_name}" or
#      is_path          "${zeshy_script_name}"
#   then zeshy_script_path="${zeshy_script_name}"
    # Otherwise, attempt to import a Zeshy component having that script name.
#   else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
#   fi

        # If the script corresponds to a command-specific script under
        # "zeshy/command" excluding the top-level ".main" script, ensure this
        # command is actually installed.
#       if is_string_contains "${zeshy_script_path}" '/zeshy/command/'; then
#           string command_name="${zeshy_script_path#*/zeshy/command/}"
#           is "${command_name}" == "${ZESHY_MAIN_SCRIPT_BASENAME}" si or
#               die_unless_pathable "${command_name}"
#       fi

#string_global_export ZESHY_CACHE_COMPILATION_DIR="${ZESHY_DOT_DIR}/compilation"
#FIXME: Add support for zcompile(). Pass "-M" if the passed file matches
# */zeshy/src/* and "-R" otherwise.

    # If such script is either an absolute path or extant relative path, attempt
    # to import such script as is.
#   if is_path_absolute "${zeshy_script_name}" or
#      is_path          "${zeshy_script_name}"
#   then zeshy_script_path="${zeshy_script_name}"
    # Otherwise, attempt to import a Zeshy component having that script name.
#   else zeshy_script_path="${ZESHY_HOME}/src/${zeshy_script_name}"
#   fi

#   say "requireing ${1}..."
    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    # If this directory contains a main script, import only such script;
    # otherwise, import all children of such directory.
#   if is_file "${zeshy_main_script}"
#   then source_shell_script_once_file         "${zeshy_main_script}" "${@}"
#   else source_shell_script_once_dir_children "${zeshy_script_dir}"  "${@}"
#   fi

# string require_dir_children(
#   string dirname, string arg1, string arg2, ...)
#
# Conditionally import all files and directories under the passed directory.
#function require_dir_children() {
    # Validate passed arguments.
#    die_unless_args\
#        'expected one dirname and optional import options'
#    string zeshy_script_dir="${1}"; shift
#    die_unless_dir "${zeshy_script_dir}"

    #FIXME: Hmmm; no need to include "zwc", I should think. No?
    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.(swp|zwc)", excluding files with filetype "swp" or "zwc".
#    for zeshy_script_dir_child ( "${zeshy_script_dir}"/*(^D@)~*.(swp|zwc) ) {
#        require "${zeshy_script_dir_child}" "${@}"
#    }
#}

#{
        #FIXME: Technically, this works. Sadly, zsh exposes no explicit
        #mechanism for sourcing zcompiled scripts. (Odd, we know.) Rather, one
        #can only use such scripts with the fpath-enabled autoload mechanism.
        # Absolute path to the file caching the compilation of this script.
#       string zeshy_script_compiled_path="${ZESHY_CACHE_COMPILATION_DIR}${zeshy_script_path}.zwc"
#
        # If this script has not yet been compiled or has been but has changed since
        # being compiled, (re)compile this script.
#       if is not -f "${zeshy_script_compiled_path}" or\
#           ${zeshy_script_mtime} -ne\
#           $(get_path_mtime "${zeshy_script_compiled_path}") si; then
#           # zcompile() refuses to create directory structure, so do so for it.
#           make_dir_if_not_found "$(dirname "${zeshy_script_compiled_path}")"
#
#           say "compiling \"${zeshy_script_path}\" to \"${zeshy_script_compiled_path}\"..."
#           say "compiling \"${zeshy_script_path}\"..."
#           zcompile "${zeshy_script_compiled_path}" "${zeshy_script_path}"
#
            # Set the mtime of the compiled script to that of the uncompiled
            # script to ensure the above conditional fails on future imports.
#           set_path_mtime "${zeshy_script_compiled_path}" ${zeshy_script_mtime}
#       fi
#       source "${zeshy_script_compiled_path}" "${@}"
#}
