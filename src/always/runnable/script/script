#!/usr/bin/env zsh
# ====================[ script                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle shell scripts, executable text files implemented in CLI shell scripting
# languages (e.g., Bourne, bash, zsh, Zeshy).

# ....................{ GLOBALS                            }....................
#FIXME: Rename to ${ZESHY_SHELLS_EMULATABLE_DIRECTLY_GLOB}.
declare_global '
string ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY

Glob matching all shells explicitly emulatable by builtin emulate().
'
ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY='zsh|sh|ksh|csh'

#FIXME: Rename to ${ZESHY_SHELLS_EMULATABLE_INDIRECTLY_GLOB}.
declare_global '
string ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY

Glob matching all shells implicitly emulatable by zsh and hence sourceable by
source_shell_script().
'
ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY='zeshy|(|a|ba|c|da|k|mk|pdk|re|tc|z)sh'

#FIXME: Rename to ${ZESHY_SHELL_NAME_TO_EMULATABLE_SHELL_NAME}.
declare_global '
map ZESHY_MAP_TO_EMULATABLE_SHELL_NAME

Map from shell name to the name of the zsh-emulatable shell closest in
ancestry and hence operation to the former shell if a sufficiently close shell
exists. zsh-emulatable shells are those explicitly accepted by the emulate()
builtin: at present, only "sh", "csh", "ksh", and "zsh".
'
ZESHY_MAP_TO_EMULATABLE_SHELL_NAME=(
    # Bourne shell variants.
    'ash'  'sh'
    'bash' 'sh'
    'dash' 'sh'
    'resh' 'sh'
    'sh' 'sh'

    # csh variants.
    'csh'  'csh'
    'tcsh' 'csh'

    # ksh variants.
    'ksh'   'ksh'
    'mksh'  'ksh'
    'pdksh' 'ksh'

    # zsh variants.
    'zsh'   'zsh'
    'zeshy' 'zeshy'
)

# ....................{ EXCEPTIONS                         }....................
declare_function '
string die_unless_shell_script(
    string pathname,
    string error_message = "\"${pathname}\" not a shell script")

Throw an exception with the passed message unless the passed path is an existing
shell script. See is_shell_script() for further details.
'
function die_unless_shell_script() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_shell_script "${pathname}" or
        die "${2:-\"${pathname}\" not a shell script}"
}

# ....................{ TESTERS                            }....................
declare_function '
boolean is_shell_script(string pathname)

Return true if the passed path is an existing shell script (i.e., text file with
first line prefixed by "#!").
'
function is_shell_script() {
    # Validate passed arguments.
    die_unless_arg 'expected one pathname'
    string pathname="${1}"

    #FIXME: Pretty shoddy implementation, honestly. Shell scripts lacking
    #shebang lines are still shell scripts. I suspect the external command
    #"file" will output much more useful output for such scripts; hence,
    #consider deferring to "file" if the passed path is a text file lacking a
    #shebang line. Test us up!

    # Test such path.
    is_file_text "${pathname}" and
        run_command_silent get_shell_script_shebang_command_if_found "${pathname}"
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_shell_script_defining_function_autoload(). (The current
#title simply isn't specific enough: it's not just the script defining that
#function, it's the script defining that function's *AUTOLOAD* implementation.)
declare_function '
string get_shell_script_defining_function(string function_name)

Get the absolute path of the shell script defining the passed function if some
script with basename such function name resides in some directory listed by
global list ${fpath} or throw an exception. If multiple scripts match such
function name, arbiratrily get the absolute path of the first such script
listed by ${fpath}: e.g.,

    >>> get_shell_script_defining_function zsh-mime-handler
    /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
'
function get_shell_script_defining_function() {
    # Validate passed arguments.
    die_unless_arg 'expected one function name'
    string function_name="${1}"

    # Dismantled, this is:
    #
    # * "^", iteratively expanding to each directory listed by ${fpath}.
    # * "(N)", excluding non-extant filenames.
    list shell_scripts; shell_scripts=( ${^fpath}"/${function_name}"(.N) )

    # If no shell script defines such function, throw an exception; otherwise,
    # print the absolute path of the first such script.
#   print_message "filename_matches: \"${filename_matches[@]}\""
    die_unless_list_nonempty shell_scripts\
        "shell script defining ${function_name}() not found"
    print_string "${shell_scripts[1]}"
}

# ....................{ SOURCERS                           }....................
declare_function '
string source_shell_script_defining_function(
  string function_name,
  string filename, string arg1, string arg2, ...)

Source the shell script defining the passed function with the passed
arguments, reading and executing all commands in such script under the current
shell. See:

* get_shell_script_defining_function() for discussion on finding such script.
* source_shell_script() for discussion on sourcing such script.
'
function source_shell_script_defining_function() {
    # Validate passed arguments.
    die_unless_args 'expected one function name and optional script arguments'
    string function_name="${1}" filename
    shift_arg

    # Source such script.
    filename="$(get_shell_script_defining_function "${function_name}")"
    source_shell_script "${filename}" "${@}"
}

declare_function '
string source_shell_script(string filename, string arg1, string arg2, ...)

Source the passed shell script with the passed arguments, reading and
executing all commands in such script under the current shell. If such script:

* Has a filetype matching an emulatable shell, emulate such shell.
* Contains a shebang line matching an emulatable shell, emulate such shell.
* Contains no shebang line but transitively resides under a directory with
  basename matching an emulatable shell (e.g., "zsh" in the case of
  "/usr/share/zsh/5.0.0/functions/TCP/tcp_log"), emulate such shell.
* Otherwise, throw an exception.

An "emulatable shell" is any shell with name matching a key of global map
${ZESHY_MAP_TO_EMULATABLE_SHELL_NAME} (e.g., since
${ZESHY_MAP_TO_EMULATABLE_SHELL_NAME[tcsh]} exists, tcsh is an emulatable
shell).

If such script requires a non-emulatable shell (e.g., with a shebang line
resembling "#!/usr/bin/env fish" or "#!/bin/es"), throw an exception. Such
scripts cannot be reliably emulated under zsh and hence cannot be sourced
under the current shell. Consider explicitly running such scripts under the
appropriate shell (e.g., "fish odd_fellows_rest.fish").

If such script requires an emulatable non-Zeshy shell (e.g., with a shebang
line resembling "#!/usr/bin/env zsh" or "#!/bin/bash"), source such script
"safely" by emulating the default environment consisting of builtins, options,
and traps specific to such shell. In particular, revert to customary shell
execution of commands by not throwing exceptions on non-zero exit status.

If such script requires Zeshy (e.g., with a shebang line resembling
"#!/usr/bin/env zeshy"), source such script as is without emulation.

See source_shell_script_under_shell() for further discussion on emulation.
'
function source_shell_script() {
    # Validate passed arguments. Avoid calling die_unless_shell_script(), whose
    # implementation duplicates our parsing of the script shebang line here.
    die_unless_args 'expected one script filename and optional script arguments'
    string filename="${1}" filetype shell_name shebang_command_name
    die_unless_file_text "${filename}"
#   print_message "filename: ${filename}\nfiletype: ${filetype}"

    # Identify the shell to be emulated. If such script's filetype matches an
    # emulatable shell, assume such shell.
    if filetype="$(get_file_type_if_matching\
        "${filename}" "${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY}")"
    then shell_name="${filetype}"
    # If such script contains a shebang line matching an emulatable shell,
    # assume such shell.
    elif shebang_command_name="$(get_shell_script_shebang_command_name_if_found\
        "${filename}")"
    then shell_name="$(get_string_match_group_if_found\
        "${shebang_command_name}" "*(${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY})*")" or
        die "shell \"${shebang_command_name}\" required by \"${filename}\" not emulatable"
    # If such script transitively resides in a directory with basename matching
    # an emulatable shell, assume such shell.
    elif shell_name="$(get_string_match_group_if_found\
        "${filename}" "*/(${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY})/*")"
    then noop
    # Otherwise, throw an exception.
    else die "\"${filename}\" contains no shebang line"
    fi

    # Source such script emulated under such shell.
    source_shell_script_under_shell "${@}" "${shell_name}"
}

declare_function '
string source_shell_script_under_shell(
  string filename, string arg1, string arg2, ...,
  string shell_command_name)

Source the passed shell script with the passed arguments emulated under the
passed shell command, reading and executing all commands in such script under
the current shell. Since zsh emulates only some (but not all) shell commands,
this function maps the passed shell command to a zsh-emulated shell command
according to global map ${ZESHY_MAP_TO_EMULATABLE_SHELL_NAME}.

* Unfortunately, zsh currently emulates bash as sh (i.e., Bourne shell). Since
  this is rarely desirable, Zeshy improves such emulation by enabling bash-
  specific shell options (e.g., "ksh_glob", "no_sh_glob"). While imperfect,
  this is probably the best we can currently do. Consider explicitly running
  bash scripts under bash (e.g., "bash sonic_excess_in_its_purest_form.bash").
'
function source_shell_script_under_shell() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one script filename, optional script arguments, and one shell name'
    string filename="${1}" shell_name="${@[-1]}"
    die_unless_file_text "${filename}"
    pop_arg

    # Source such script under such shell, quote-protecting such script and
    # script arguments for safety against the brute ravages of run().
    run_command_under_shell 'source --' "${(q)@}" "${shell_name}"
}

# ....................{ RUNNERS                            }....................
declare_function '
string run_command_under_zsh_defaults(
  string command_name, string command_arg1, string command_arg2, ...,
  string shell_name)

Run the passed command emulated under default zsh options and traps, as
typically required for function autoloads bundled with zsh: e.g.,

    >>> run_command_under_zsh_defaults zsh-mime-setup
'
function run_command_under_zsh_defaults() {
    die_unless_args 'expected one command'
    run_command_under_shell "${@}" zsh
}

declare_function '
string run_command_under_shell(
  string command_name, string command_arg1, string command_arg2, ...,
  string shell_name)

Run the passed command emulated under the passed shell.
'
function run_command_under_shell() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one command and one shell name'
    string shell_name="${@[-1]}"
    pop_arg

    # Map the passed shell to the closest zsh-emulatable shell.
    shell_name="$(get_map_key_value_if_found\
        ZESHY_MAP_TO_EMULATABLE_SHELL_NAME "${shell_name}")" or
        die "shell \"${shell_name}\" not emulatable"

    # Source such script under such emulation. Dismantled, this is:
    #
    # * "-L", localizing the redefinition of TRAPZERR() to this block.
    # * "-R", resetting shell options to the default expected by such shell.
    #
    # Do not redefine TRAPINT(); printing stack traces on user interrupts
    # is universally useful and not conflicting with script expectations.
    case "${shell_name}" {
    # If a bash shell script, attempt Bourne shell emulation with bash-
    # specific options. Such emulation is admittedly... imperfect.
    bash)
        #FIXME: The bash_source() function defined at a Googleable URL defines
        #additional aliases (e.g., "alias shopt=':'"). Unfortunately, Zeshy
        #currently has no means of temporarily defining aliases and then
        #restoring the prior definition if already defined. We'll need some
        #such mechanism prior to defining such aliases, clearly. (At least, I
        #don't think it does. Hmm; but function definitions are clearly
        #localized, as below. Surely alias definitions are as well, yes?)
        emulate -LR sh
        enable_shell_option_locally\
            bash_rematch\
            brace_expand\
            ksh_array\
            ksh_glob\
            no_sh_glob\
        ;;
    # If a shell explicitly emulatable by zsh, do so.
    ${~ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY})
        emulate -LR "${shell_name}";;
    # Otherwise, this function failed to properly map such script's required
    # shell to a zsh-supported shell; throw an exception.
    *) die "shell \"${shell_name}\" not mapped to an emulatable shell";;
    }

    # Temporarily cease throwing exceptions on non-zero exit status.
    TRAPZERR() { return $(( 128 + ${1} )) }

    # Run such command under such emulation. Note that the above emulation of
    # traditional TRAPZERR() behaviour persists while running such command,
    # which is helpful, *AND* processing the exit status such command returns,
    # which is unhelpful. In the latter case, non-zero exit status fails to
    # signal ZERR. Manually test such status and, if non-zero, throw the
    # expected exception.
    run_command "${@}" or die "\"${@}\" failed with exit status ${?}"
}

# --------------------( WASTELANDS                         )--------------------
# (i.e., a text file with first line is a "#!"-prefixed shebang line).
#Since this function is
    # transitively called before the remainder of the Zeshy codebase, avoid
    # calling conventional Zeshy functions (e.g., get_string_match_group_if_found()).
#FUXME: This function's just silly. Excise!
#declare_function '
#string get_shell_script_shebang_command_if_found(string filename)
#
#Get the first line excluding prefixing "#!" of the passed shell script if such
#line is prefixed with "#!" or return false otherwise: e.g.,
#
#    >>> get_shell_script_shebang_command_if_found "/etc/zsh/zshrc"
#    /usr/bin/env zsh
#'
#function get_shell_script_shebang_command_if_found() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one filename'

#   # Validate passed arguments. Avoid calling die_unless_shell_script(), which
#   # transitively calls this function.
#   string filename="${1}" shebang_command
#   die_unless_file_text "${filename}"

#   #FUXME: Defer to 
#   # Get such command or fail trying.
#   if run_command_with_mapfile "shebang_command=\"\$(get_string_match_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '(#s)\#!([^${ZESHY_ASCII_NEWLINE}]#)*')\""
#   then print_string "${shebang_command}"
#   else return_false
#   fi
#}

    #FUXME: Shift run_command_with_mapfile() and hence the whole component "module"
    #here, sadly. That said, one does really want to be able to load and unload
    #zsh modules from top-level functions, so... good change, anyway.
    #FUXME: Ugh. Wait. We don't really want to move get_string_match_group_if_found()
    #here, do we? Reconsider.
    #FUXME: Uhm. This implementation is wrong. Shebang lines *MUST* be the first
    #lines in such files.

#   if run_command_with_mapfile "shebang_line=\"\$(get_string_match_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '(#s)(\#![^${ZESHY_ASCII_NEWLINE}]#)*')\""
#       is \"\${\${(f)mapfile[\${filename}]}[1]}\" ==\
#   then print_string "${shebang_line}"
#FUXME: This has utterly nothing to do with this component, but either
#"-o EMACS" or "-o VI" should be enabled depending on ${EDITOR}. Make it so! So?

#FUXME: Undefined here. *shrug* Perhaps extract into an alias in "alias"?
#freeze_variable ZESHY_MAP_TO_EMULATABLE_SHELL_NAME

# ....................{ STARTUP                            }....................
# Initialize shell script-specific constants early to permit subsequent Zeshy
# startup commands to source shell scripts "safely."
#run_hook_on_zeshy_startup startup_zeshy_shell_script_constants

# void startup_zeshy_shell_script_constants(void)
#
# Initialize shell script-specific constants.
#function startup_zeshy_shell_script_constants() {
    #FUXME: Interestingly, there appears to be no convenient means of defining a
    #constant map or list; of course, one can simply call freeze_variable() after
    #defining such variable, but that seems inordinantly complex. Any ideas?
    #Something like this could probably work, but it's fugly as heck.
    #   alias define_variable='output'
    #   define_variable TEST | as_map_global_constant ( hello "'ello?" )
    #Ah! Right. I believe we *CAN* (somewhat) do this by adding a new
    #freeze_list_to_evaluation() to accept... ah; no. We'd have to eval the
    #passed args, which renders the original arguments unreadable. Nope; no way,
    #really. Just call freeze_variable.

    # Declare such constants.
#       ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY\
#       ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY

#FUXME: This needs to happen before MIME-specific startup. Hmm; either we need a
#new function with name resembling:
#   run_hook_on_zeshy_startup_first()
#   run_hook_on_zeshy_startup_before_other_commands()
#   run_hook_on_zeshy_startup_first()

#       source --  /usr/share/zsh/5.0.0/functions/MIME/zsh-mime-setup -f
#       "${(z)@}"
#       run "${@}"
#   string exit_status="${?}"
#   integer exit_status=${?}
#       print 'okok'
    # The above emulation of traditional TRAPZERR() behavior persists both while
    # running commands in such script, which is wise, *AND* processing the exit
    # status of such script, which is unwise. In the latter case, non-zero exit
    # status fails to signal ZERR. Manually test such status and, if non-zero,
    # throw the expected exception.
#   (( exit_status == ZESHY_EXIT_STATUS_SUCCESS )) or
#       die "\"${@}\" failed with exit status ${exit_status}"
#   if filetype="$(get_file_type_if_found "${filename}")" and
#      is_string_match "${filetype}" "${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY}"
#           print_warning "sourcing bash script \"${filename}\" as a Bourne script"
#           print_warning "emulating bash as a Bourne script"
# To avoid conflict with ImageMagick's "import" command, we prefer "require".
#FUXME: Replace with references to run_command_under_shell(); then excise.
# string source_shell_script_command_output(
#   string shell_name,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
#function source_shell_script_command_output() {
    # Validate passed arguments.
#    die_unless_args_2_or_more\
#        'expected at least one shell name and one command name'
#    string shell_name="${1}"
#    shift_arg

    #FUXME: Refer to the previously defined glob.
#    is "${shell_name}" == (zsh|sh|ksh|csh) si or
#        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_pathable "${command_name}"

    # Source safely.
#    emulate -R "${shell_name}" -c "eval \$(${@})"
#}

# Avoid calling die_unless_shell_script(), whose
    # implementation duplicates our parsing of the script shebang line here.#       PATH="${PATH}:${FPATH}" source -- "${@}"
#   * A supported non-Zeshy shell (e.g., "#!/usr/bin/env zsh", "#!/bin/bash"),
#     source such script "safely" by emulating the shell environment expected by
#     such script with default shell options and traps. In particular, revert to
#     traditional shell execution of commands by not throwing exceptions on
#     commands returning non-zero exit status.
#   * An unsupported non-Zeshy shell (e.g., "#!/usr/bin/env fish", "#!/bin/es"),
#     throw an exception. Such scripts cannot currently be reliably emulated
#     under zsh and hence cannot be sourced under the current shell. Consider
#     explicitly running such scripts under the desired shell (e.g.,
#     "fish odd_fellows_rest.fish").
#   * Zeshy (e.g., "#!/usr/bin/env zeshy"), source such script as is (i.e.,
#     under the current shell environment, with no such emulation).
    #FUXME: Actually, can't we just shift the "zsh"-specific conditional below
    #into the prior function and then just call that?
    # Identify the shell to be emulated. Such script's basename is a function
    # name and hence cannot be suffixed by a filetype, so the only available
    # identifier is a shebang line if found. Attempt to find such line.
#   if shebang_command_name="$(get_shell_script_shebang_command_if_found\
#       "${filename}")"
#   then shell_name="$(get_string_match_group_if_found\
#       "${shebang_command_name}" "${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY}")" or
#       die "script \"${filename}\" requiring unknown shell \"${shebang_command_name}\" not sourceable"
    # Technically, another crude identifier exists: if such script resides under
    # a directory named "zsh", assume such shell to be zsh.
#   elif is_string_contains "${filename}" '/zsh/'
#   then shell_name='zsh'
    # Otherwise, assume such shell to be Zeshy.
#   else
#       print_warning "script \"${filename}\" lacking shebang line assumed to be a Zeshy script"
#       shell_name='zeshy'
#   fi

        # If a shell explicitly emulatable by zsh, do so.
#       ${~ZESHY_GLOB_EMULATABLE_SHELLS})
#           emulate -LR "${shell_name}";;
        # Otherwise, this function failed to properly map such script's specific
        # shell to a zsh-supported shell; throw an exception.
#       *) die "script \"${filename}\" requiring unmapped shell \"${shell_name}\" not sourceable";;
# follows:
#
# /======================^============================\
# | passed shell command | emulated shell environment |
# <======================+============================>
# | ash                  | sh                         |
# | bash                 | bash*                      |
# | csh                  | csh                        |
# | dash                 | sh                         |
# | mksh                 | ksh                        |
# | pdksh                | ksh                        |
# | resh                 | sh                         |
# | tcsh                 | csh                        |
# | sh                   | sh                         |
# | zeshy                | NONE                       |
# | zsh                  | zsh                        |
# \======================+============================/
#FUXME: Replace with a simple map. This is overkill. Extreme overkill.
# string map_shell_to_emulatable_shell(string shell_name)
#
# Get the zsh-emulatable shell closest in ancestry and hence operation to the
# passed shell if a sufficiently close shell exists (e.g., if passed "tcsh",
# return "csh") or throw an exception (e.g., if passed "fish", throw an
# exception). The emulate() builtin supports only a subset of available shells,
# requiring all other shells be mapped to the "closest" supported shell: e.g.,
#
#     >>> map_shell_to_emulatable_shell tcsh
#     csh
#     >>> map_shell_to_emulatable_shell fish
#     map_shell_to_emulatable_shell: shell "fish" not mappable to an emulatable shell
#function map_shell_to_emulatable_shell() {
#function get_shell_emulating_shell() {
    # Validate passed arguments.
#    die_unless_arg 'expected one shell name'
#    string shell_name="${1}"

    #FUXME: New die_unless_shell_emulatable_() function, yes? Also, rename
    #${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY} to ${ZESHY_GLOB_SHELL_SOURCEABLE}?
#    is_string_match "${shell_name}" "${ZESHY_GLOB_SHELL_EMULATABLE_INDIRECTLY}" or
#        die "shell \"${shell_name}\" not mappable to an emulatable shell"

    # Map the passed shell command to the closest zsh-emulatable shell command.
#    case "${shell_name}" in
    # If such shell is supported under a generic zsh-recognized name, map
    # the former to latter.
#    (a|da|re)sh) print_string 'sh';;
#    tcsh) print_string 'csh';;
#    (m|pd)ksh) print_string 'ksh';;
#    *) print_string "${shell_name}"
#    esac
#}
#   case "${shell_name}" in
    # If such shell is supported under a generic zsh-recognized name, map
    # the former to latter.
#   (a|da|re)sh) shell_name='sh';;
#   tcsh) shell_name='csh';;
#   (m|pd)ksh) shell_name='ksh';;
#   esac


# string source_shell_script_command_output(
#   string shell_name,
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Emulate the passed command under the passed shell (e.g., "sh", "csh") and, if
# successful, source the command's standard output.
#function source_shell_script_command_output() {
    # Validate passed arguments.
#    die_unless_args_2_or_more\
#        'expected at least one shell name and one command name'
#    string shell_name="${1}"
#    shift_arg

    #FUXME: Refer to the previously defined glob.
#    is "${shell_name}" == (zsh|sh|ksh|csh) si or
#        die "\"${shell_name}\" not an emulatable shell"
#   string command_name="${1}"
#   die_unless_pathable "${command_name}"

    # Source safely.
#    emulate -R "${shell_name}" -c "eval \$(${@})"
#}

#         if shebang_command_name="$(get_string_match_group_if_found\
#           "${shebang_command}"\
#           '(/usr|)/bin/env[[:space:]]##([^[:space:]]##)')"
#       then print_string "${shebang_command_name}"
#       elif shebang_command_name="$(get_string_match_group_if_found\
#           "${shebang_command}"\
#           '(/usr|)/bin/env[[:space:]]##([^[:space:]]##)')"
#       then print_string "${shebang_command_name}"
#       else return_false

# Safely source the passed non-Zeshy script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than zsh shell environment).
#       string glob="[/ ](${emulatable_shells})((#e)| )" shebang
#       string regex="^.*[/ ](${emulatable_shells})($| )" shebang_command
        #FUXME: Insufficient. Search, say, the first eight lines for a shebang.
        #This suggests a call pipeline resembling:
        #  shebang_line="$(get_file_text_line_matching_pcre "$(get_file_text_lines "${filename}" 1 8)" "${shebang_regex}")"
#       shebang_line="$(get_file_text_first_line "${filename}")"
#           shell="${match[1]}"
#       print_string "shebang_line: ${shebang_line}"
#       print_string "shell=${shell}"
    #FUXME: Hmm; this appears to be fixed under zsh 5.0.0. Verify. Wait; no.
    #This should be expected behavior, given the prior TRAPZERR() statement.
    # Interestingly, zsh fails to signal ZERR when the sourced script fails with
    # non-zero exit status. Let's signal ZERR ourselves, shall we?

#If the passed filename is not absolute, convert
    # such filename to an absolute path by searching the current working
    # directory, ${PATH}, and ${FPATH} (in that order) for such basename.# string get_shell_script_path(string script_name)
#
# Get the absolute path of the passed script if in at least one path listed
# below or throw an exception. If in multiple such paths, get the first such
# path. If the passed name is the absolute path of a text file, return such file
# as is. Otherwise, this function generalizes get_autoload_path() by searching
# for (in order):
#
# * Any file in the current working directory with such name.
# * Any file in the current user's ${PATH} with such name (i.e., a command).
# * Any file in the current user's ${FPATH} with such name (i.e., an autoload).
#function get_shell_script_path() {
    # Validate passed arguments.
#    die_unless_arg 'expected one filename'
#    string filename="${1}"

    # If such name is the absolute path of a text file, return such name as is.
#    if is_path_absolute "${filename}"; then
#        die_unless_file_text "${filename}"
#        print_string "${filename}"
    # Otherwise, iteratively search the described paths for such file.
#    else
#        list script_paths; script_paths=( "${PWD}" "${path[@]}" "${fpath[@]}" )
#        get_shell_script_autoload_path "${filename}" script_paths
#    fi
#}

# string get_shell_script_defining_function(
#   string function_name, string autoload_dirs_list_name = 'fpath')
#
# Get the absolute path of the shell script defining the passed function if under at least one
# path in the passed list of paths or throw an exception. If under multiple such
# paths, get the first such path: e.g.,
#
#     >>> get_shell_script_autoload_path zsh-mime-handler
#     /usr/share/zsh/4.3.11/functions/MIME/zsh-mime-handler
#function get_shell_script_defining_function() {
    # Validate passed arguments, discarding all but the basename of the passed
    # filename.
#    die_unless_args_1_to_2\
#        'expected one basename and optional list name'
#    string basename autoload_dirs_list_name="${2:-fpath}"
#    basename="$(get_path_basename "${1}")"

    # Dismantled, this is:
    #
    # * "filename_matches_list_name", the name of the list listing all
    #   directories to be searched for the passed autoload.
    # * "(@P)", expanding to such list.
    # * "^", iteratively expanding to each such directory.
    # * "/${filename}", concatenating the passed autoload to each such
    #   directory, producing a possible absolute path to such autoload.
    # * "(N)", ignoring non-extant such absolute paths.
#    list filename_matches
#    filename_matches=( ${^${(@P)autoload_dirs_list_name}}"/${basename}"(N) )
#   filename_matches=( ${^fpath}/"${filename}"(N) )

    # Throw an exception if no path in the passed list of paths has such script.
#   print_message "filename_matches: \"${filename_matches[@]}\""
#   is_list filename_matches or print 'ugug!'
#    die_unless_list_nonempty filename_matches
#        "autoloadable script \"${basename}\" not found"

    # Print the first such path.
#    print_string "${filename_matches[1]}"
#}

# string source_shell_script_(string filename, string arg1, string arg2, ...)
#
# Source the passed shell script with the passed arguments, reading and
# executing all commands in such script under the current shell. If such script:

    #FUXME: Not quite right. We clearly need to allow "bash", for example. To do
    #so, just match the glob '[a-z]##sh'. The emulate() builtin is smart enough
    #to default to "zsh", if all else fails.
# Safely source the passed non-Zeshy script by emulating the shell environment
# expected by that script with default shell options and traps (e.g., a script
# "mandibles_of_joy.sh" expects a Bourne rather than zsh shell environment).
# Zeshy throws such exceptions, necessitating rendering non-Zeshy shell scripts
# expecting traditional unsafe behavior inoperable.
#     regardless of non-zero exit status. (Zeshy implicitly throws exceptions on
#     command returning such status.)
#FUXME: WAIT; WAIT; WAIT. This distinction between Zeshy and non-Zeshy is
#hideous. Why? Because *we* can programmatically determine which is required by
#simple analysis of the she-bang. (We need better she-bang functions, by the
#way.) If the she-bang ends in either "/zeshy" or " zeshy", we have a Zeshy
#script on our hands and need to just source it as is. Otherwise, we need to
#source it under emulation appropriate to that shell. Roll all of this into one
#common function named simply source_shell_script().

# string source_zeshy_script(
#   string script_filename, string script_arg1, string script_arg2, ...)
#
# Source the passed Zeshy script with the passed arguments. Avoid calling this
# function with non-Zeshy shell scripts, which often behave unexpectedly under
# the default Zeshy shell environment. Zeshy implicitly throws an exception on a
# command returning non-zero exit status, rendering non-Zeshy shell scripts
# expecting conventional unsafe behavior inoperable. Consider calling
# source_shell_script() instead, in such cases.
#function source_zeshy_script() {
#    die_unless_args 'expected one script filename and optional script arguments'
#    source -- "${@}"
#}

# string source_zeshy_scripts(
#   string script_filename1, string script_filename2, ...)
#
# Source the passed Zeshy scripts. See source_zeshy_script() for details.
#function source_zeshy_scripts() {
#    die_unless_args 'expected at least one script filename'
#    for filename ("${@}") { source -- "${filename}" }
#}

# void zeshy_initialize_imports(void)
#
# Initialize the imports dictionary, used by the require() function. This is a
# global dictionary mapping from imported script name to the mtime (i.e.,
# modification time) of the script at the time of importation. The require()
# function adds script names to this dictionary on importing those scripts so
# as to record having done so. This record keeping allows that function to
# avoid importing already imported scripts.
#
# Zeshy Shell requires we separate this initialization into a distinct function,
# for hitherto inexplicable reasons. (There be subtle dragons aboot.)
#zeshy_initialize_imports() {
#    die_if_args

#    # Explicitly empty the dictionary. This is irrelevant on the first call to
#    # this function, but definitely matters on subsequent calls!
#    map_global_export ZESHY_REQUIRED_PATH_TO_MTIME; ZESHY_REQUIRED_PATH_TO_MTIME=( )
#}

#   elif is_path_exists          "${PWD}/${zeshy_script_name}"
#   then zeshy_script_path="${PWD}/${zeshy_script_name}"

    # Initialize the imports dictionary used by the zimport() function.
#   zeshy_initialize_imports

    # Inform the user that this script is being imported. This script is usually
    # sourced via the zsh source() built-in rather than the Zeshy zimport()
    # function; thus, our failure to do this here would require callers do this
    # there, prior to their sourcing this script.
    #
    # Distinguish the former from the latter by noting whether the
    # "${zeshy_script_mtime}" variable has been set or not; if it has, this script
    # was sourced via zimport() rather than source().
#   is_undeclared 'zeshy_script_mtime' or print_message "loading \"${zeshy_core_path}\"..."

    #FUXME: Replace with single call to run_command_with_mapfile().
#   if shebang_line="$(get_string_match_group_if_found\
#       "${mapfile[${pathname}]}"\
#       "([^${ZESHY_ASCII_NEWLINE}]#)")"
#   if run_command_with_mapfile "shebang_line=\"\$(get_string_match_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '[#]!([^${ZESHY_ASCII_NEWLINE}]#)')\""
#       '\#!([^$'\n']#)')\""
#   then print_string "${shebang_line}"
#   else return_false
#   fi
#   run_command_with_mapfile "get_string_match_group_if_found\
#       \"\${mapfile[\${filename}]}\"\
#       '[#]!([^${ZESHY_ASCII_NEWLINE}]#)'"
#   load_mapfile
#   get_string_match_group_if_found\
#       "${mapfile[${filename}]}" "(#s)\#!([^${ZESHY_ASCII_NEWLINE}]#)*"
#   unload_mapfile
#   list lines; set_list_to_file_text_lines lines "${pathname}"
#   if is_string_prefix "${lines[1]}" '#!'
#   then print_string "${lines[1]}"
#   else return_false
#   fi

    # Technically, we could implement this with pure-zsh.
