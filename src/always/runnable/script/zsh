#!/usr/bin/env zsh
# ====================[ zsh                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle zsh shell scripts.

# ....................{ EXCEPTIONS                         }....................
document_function '
string die_unless_zsh_script_valid(
  string pathname,
  string error_message = "\"${pathname}\" not a valid zsh script")

Throw an exception with the passed message unless the passed path is a valid zsh
script. See is_zsh_script_valid() for further details.
'
function die_unless_zsh_script_valid() {
    die_unless_args_1_to_2\
        'expected one filename and optional error message'
    string filename="${1}"
    is_zsh_script_valid "${filename}" or
        die "${2:-\"${filename}\" not a valid zsh script}"
}

# ....................{ TESTERS                            }....................
#FIXME: This probably returns false positives for Zeshy scripts due to our use
#of global aliases: namely, both "[[ ]]" and "is si" are invalid under Zeshy
#but this function (probably!) only reports the former to be invalid, thus
#returning false positives for edge case errors. There probably isn't much we
#can do about this; though, I wonder if manually passing "-c 'alias -g is=[['"
#and such would induce zsh to define such global aliases prior to testing the
#passed script. No idea, but conceivably worth a shot.

document_function '
boolean is_zsh_script_valid(string filename)

Return true if the passed zsh script is valid (i.e., contains no syntactic
errors).
'
function is_zsh_script_valid() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file_text "${filename}"

    # Check such script.
    zsh -o no_exec -- "${filename}"
}

# ....................{ GETTERS                            }....................
document_function '
void get_zsh_shebang_line(void)

Get the canonical shebang line for zsh scripts: e.g.,

    >>> get_zsh_shebang_line
    #!/usr/bin/env zsh
'
function get_zsh_shebang_line() {
    # Validate sanity.
    die_if_args

    # Absolute path of external command "env". By precedent, most *nix
    # distributions install the command under "/usr/bin". Nonetheless, recent
    # attempts to unify "/" and "/usr" within the FLOSS community (...their
    # names shall remain nameless: *cough* Poettering *cough*) suggest this may
    # not always be the case everywhere. Just cover our bases will belong, here.
    string env_path; env_path="$(get_pathable_path env)"
    print_string "#!${env_path} zsh"
}

# ....................{ COMPACTERS                         }....................
document_function '
void compact_zsh_script(string filename)

Compact the passed zsh script to standard output without modifying such script.
Such output will be an exact duplicate of such script, excluding all extraneous
comments and whitespace.

Compacted zsh scripts typically run slightly faster than uncompacted zsh
scripts, a slight speedup which over a script''s lifetime could prove beneficial.
While better than nothing, even compacted zsh scripts typically run much slower
than compiled zsh scripts autoloaded from zsh digest files. Hence, critical zsh
scripts (e.g., the main Zeshy codebase) prefer compilation to compaction.
'
function compact_zsh_script() {
    # Validate passed arguments. Ideally, call die_unless_zsh_script_valid()
    # rather than die_unless_file_text() to do so; sadly, the former fails to
    # validate working Zeshy scripts (e.g., topmost component "main").
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file_text "${filename}"

    # Compact such script. For efficiency:
    #
    # * Get script contents with zsh module "mapfile", as in get_file_text().
    # * Avoid copying script contents with function calls (e.g., print_string(),
    #   write_file_with_string()).
    #
    # *PRAISE BE TO ZELDA*, this actually works!
    load_zsh_module_mapfile
    {
        # For safety, prefix such script with the canonical zsh shebang line.
        get_zsh_shebang_line

        # Split comments and whitespace from such script into all remaining
        # shell words. Dismantled, this is:
        #
        # * "(Z:C:)", splitting into shell words, discarding comments and non-
        #   newline whitespace, and converting newlines to semicolons.
        list source_words
        source_words=( ${(Z:C:)mapfile[${filename_source}]} )

        # Concatenate such list to a string.
        string source_text; source_text="${source_words[*]}"

        # For both readability and efficiency, replace contiguous runs of
        # two or more ' ; ' with a single newline. While replacing runs of
        # one or more ' ; ' would be preferable, such replacement destroys
        # valid integer-style for loop syntax and semicolons in documentation.
        print -- "${source_text//(( |); )(#c2,)/${~ZESHY_ASCII_NEWLINE}}"
    } always {
        unload_zsh_module_mapfile
    }
}

document_function '
void compact_zsh_script_to_file(string source_filename, string target_filename)

Compact the passed source to target zsh script without modifying such source.
Such target will be an exact duplicate of such source, excluding all extraneous
comments and whitespace. If such target already exists, throw an exception. See
compact_zsh_script() for further details.
'
function compact_zsh_script_to_file() {
    # Validate passed arguments.
    die_unless_args_2 'expected one source filename and one target filename'
    string filename_source="${1}" filename_target="${2}"
    interactively say\
        "compacting \"${filename_source}\" to \"${filename_target}\"..."

    # Compact such script.
    compact_zsh_script "${filename_source}" > "${filename_target}"
}

#FIXME: Great testbed, until we implement proper unit testing.
#function cpow() {
#    remove_file_if_found "${HOME}/tmp/meow"
#    compact_zsh_script_to_file "${HOME}/tmp/main" "${HOME}/tmp/meow"
#    print_file_text "${HOME}/tmp/meow"
#}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_file "${filename_source}"
#   die_if_path     "${filename_target}"
#       run_with_mapfile "print -- \${(Z:C:)mapfile[\${filename}]}"
    # Compact such script. For efficiency, avoid string copies of string
    # contents and hence extraneous calls (e.g., to write_file_with_string()).
#   {
        # For safety, prefix such script with the canonical zsh shebang line.
#       get_zsh_shebang_line

        # To avoid string copies, manually implement the equivalent of the
        # following:
        #
        #     compact_zsh_script "${filename_source}" |
        #         replace_string_matches_with_string '( ; )##'\
        #             "${ZESHY_ASCII_NEWLINE}"
#       run_with_mapfile "
#           # Split such source script, removing comments and whitespace.
#           list source_words; source_words=(
#               \${(Z:C:)mapfile[\${filename_source}]} )

#           # Convert such list to a string.
#           string source_text; source_text=\"\${source_words[*]}\"

#           # For both readability and efficiency, replace contiguous runs of
#           # two or more ' ; ' with a single newline. While replacing runs of
#           # one or more ' ; ' would be preferable, such replacement destroys
#           # integer-style loop syntax and hence must be avoided (as well as
#           # disrupting semi-colons in documentation, of course).
#           print -- \"\${source_text//(( |); )(#c2,)/${~ZESHY_ASCII_NEWLINE}}\""
#   } > "${filename_target}"
        # To avoid string copies, manually implement the equivalent of the
        # following:
        #
        #     compact_zsh_script "${filename_source}" |
        #         replace_string_matches_with_string '( ; )##'\
        #             "${ZESHY_ASCII_NEWLINE}"
#           print -- \"\${source_text}\""
#   die_if_file "${filename_target}"
#effectively copying such source to target file and 
#Compaction clones such source to target files and the former to 
#After compaction, the former remains unmodified while the latter is a clone of
#the former. Compaction  and does *NOT* touch the
#source. removing all extraneous comments and whitespace from such script. 
