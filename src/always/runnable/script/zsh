#!/usr/bin/env zsh
# ====================[ zsh                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle zsh shell scripts.

# ....................{ TESTERS                            }....................
#FIXME: This probably returns false positives for Zeshy scripts due to our use
#of global aliases: namely, both "[[ ]]" and "is si" are invalid under Zeshy
#but this function (probably!) only reports the former to be invalid, thus
#returning false positives for edge case errors. There probably isn't much we
#can do about this; though, I wonder if manually passing "-c 'alias -g is=[['"
#and such would induce zsh to define such global aliases prior to testing the
#passed script. No idea, but conceivably worth a shot.

document_function '
boolean is_zsh_script_valid(string filename)

Return true if the passed zsh script is valid (i.e., contains no syntactic
errors).
'
function is_zsh_script_valid() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    # Check such script.
    zsh -o no_exec -- "${filename}"
}

# ....................{ COMPACTERS                         }....................
document_function '
void compact_zsh_script(string filename)

Compact the passed zsh script to standard output without modifying such script.
Such output will be an exact duplicate of such script, excluding all extraneous
comments and whitespace.

Compacted zsh scripts typically run slightly faster than uncompacted zsh
scripts, a slight speedup which over a script''s lifetime could prove beneficial.
While better than nothing, even compacted zsh scripts typically run much slower
than compiled zsh scripts autoloaded from zsh digest files. Hence, critical zsh
scripts (e.g., the main Zeshy codebase) prefer compilation to compaction.
'
function compact_zsh_script() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"

    # Compact such script. For efficiency, borrow get_file_text()'s "mapfile"-
    # centric implementation. Dismantled, this is:
    #
    # * "(Z:C:)", splitting such file into shell words, discarding comments and
    #   extraneous non-newline whitespace, and converting newlines to ";"
    #   characters.
    run_with_mapfile "print -- \${(Z:C:)mapfile[\${filename}]}"
}

document_function '
void compact_zsh_script_to_file(string source_filename, string target_filename)

Compact the passed source to target zsh script without modifying such source.
Such target will be an exact duplicate of such source, excluding all extraneous
comments and whitespace. If such target already exists, throw an exception. See
compact_zsh_script() for further details.
'
function compact_zsh_script_to_file() {
    # Validate passed arguments. *PRAISE BE TO ZELDA*, this actually works!
    die_unless_args_2 'expected one source filename and one target filename'
    string filename_source="${1}" filename_target="${2}"
    die_unless_file "${filename_source}"
    die_if_path     "${filename_target}"
    interactively say\
        "compacting \"${filename_source}\" to \"${filename_target}\"..."

    # Compact such script. For efficiency, avoid string copies of string
    # contents and hence extraneous calls (e.g., to write_file_with_string()).
    {
        # For safety, prefix such script with the canonical zsh shebang line.
        get_zsh_shebang_line

        # To avoid string copies, manually implement the equivalent of the
        # following:
        #
        #     compact_zsh_script "${filename_source}" |
        #         replace_string_match_with_string '( ; )##'\
        #             "${ZESHY_CHARACTER_NEWLINE}"
        run_with_mapfile "
            # Split such source script, removing comments and whitespace.
            list source_words; source_words=(
                \${(Z:C:)mapfile[\${filename_source}]} )

            # Convert such list to a string.
            string source_text; source_text=\"\${source_words[*]}\"

            # For both readability and efficiency, replace contiguous runs of
            # two or more ' ; ' with a single newline. While replacing runs of
            # one or more ' ; ' would be preferable, such replacement destroys
            # integer-style loop syntax and hence must be avoided (as well as
            # disrupting semi-colons in documentation, of course).
            print -- \"\${source_text//(( |); )(#c2,)/${~ZESHY_CHARACTER_NEWLINE}}\""
    } > "${filename_target}"
}

#FIXME: Great testbed, until we implement proper unit testing.
#function cpow() {
#    remove_file_if_found "${HOME}/tmp/meow"
#    compact_zsh_script_to_file "${HOME}/tmp/main" "${HOME}/tmp/meow"
#    print_file_text "${HOME}/tmp/meow"
#}

# --------------------( WASTELANDS                         )--------------------
#           print -- \"\${source_text}\""
#   die_if_file "${filename_target}"
#effectively copying such source to target file and 
#Compaction clones such source to target files and the former to 
#After compaction, the former remains unmodified while the latter is a clone of
#the former. Compaction  and does *NOT* touch the
#source. removing all extraneous comments and whitespace from such script. 
