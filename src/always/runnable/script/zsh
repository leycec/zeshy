#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle `zsh` shell scripts.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
string die_unless_zsh_script_valid(
    string pathname,
    string error_message = "\"${pathname}\" not a valid zsh script")

Throw an exception with the passed message unless the passed path is a valid
`zsh` script. See is_zsh_script_valid() for further details.
/---
function die_unless_zsh_script_valid() {
    die_unless_args_1_to_2\
        'expected one filename and optional error message'
    string filename="${1}"
    is_zsh_script_valid "${filename}" or
        die "${2:-\"${filename}\" not a valid zsh script}"
}

# ....................{ TESTERS                            }....................
#FIXME: This probably returns false positives for Zeshy scripts due to our use
#of global aliases: namely, both "[[ ]]" and "is si" are invalid under Zeshy
#but this function (probably!) only reports the former to be invalid, thus
#returning false positives for edge case errors. There probably isn't much we
#can do about this; though, I wonder if manually passing "-c 'alias -g is=[['"
#and such would induce zsh to define such global aliases prior to testing the
#passed script. No idea, but conceivably worth a shot.

declare_function_with_stdin <<'/---'
[status: boolean] is_zsh_script_valid(string filename)

Return success if the passed `zsh` script is syntactically valid.
/---
function is_zsh_script_valid() {
    # Validate passed arguments.
    die_unless_arg 'expected one filename'
    string filename="${1}"
    die_unless_file_text "${filename}"

    # Test such script.
    zsh -o no_exec -- "${filename}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_zsh_shebang_line(void)

Get the canonical shebang line for `zsh` scripts: e.g.,

.get_zsh_shebang_line()
==========================================
[source]
------------------------------------------
>>> get_zsh_shebang_line
#!/usr/bin/env zsh
------------------------------------------
==========================================
/---
function get_zsh_shebang_line() {
    # Validate sanity.
    die_if_args

    # Absolute path of external command "env". By precedent, most *nix
    # distributions install the command under "/usr/bin". Nonetheless, recent
    # attempts to unify "/" and "/usr" within the FLOSS community (...their
    # names shall remain nameless: *cough* Poettering *cough*) suggest this may
    # not always be the case everywhere. Just cover our bases will belong, here.
    string env_path; env_path="$(get_pathable_path env)"
    return_string "#!${env_path} zsh"
}

# ....................{ COMPACTERS                         }....................
declare_function_with_stdin <<'/---'
void compact_zsh_script_to_script(string source_script, string target_script)

Compact the passed source to target `zsh` script without modifying such source.
Such target will be an exact duplicate of such source, excluding all extraneous
comments and whitespace. If such target already exists, throw an exception. See
compact_zsh_script() for further details.
/---
function compact_zsh_script_to_file() {
    # Validate passed arguments.
    die_unless_args_2 'expected one source filename and one target filename'
    string script_source="${1}" script_target="${2}"
    print_message_interactively\
        "compacting \"${script_source}\" to \"${script_target}\"..."

    # Compact such script.
    get_zsh_script_contents_compacted "${script_source}" >"${script_target}"
}

declare_function_with_stdin <<'/---'
string get_zsh_script_contents_compacted(string filename)

Get the contents of the passed `zsh` script in *compacted form* (i.e., excluding
all extraneous comments and whitespace but otherwise identical to such script),
suitable for serialization back to disk as a compacted script. Such scripts
typically run marginally faster than their uncompacted equivalents. It should be
noted, however, that even compacted scripts run significantly slower than the
equivalent functions autoloaded into a `zsh` digest file.
/---
function get_zsh_script_contents_compacted() {
    # Validate passed arguments. Ideally, call die_unless_zsh_script_valid()
    # rather than die_unless_file_text() to do so; sadly, the former fails to
    # validate working zeshy scripts (e.g., topmost component "main").
    die_unless_arg 'expected one filename'
    string script="${1}"
    die_unless_file_text "${script}"

    # Compact such script. For efficiency:
    #
    # * Get script contents with zsh module "mapfile", as in get_file_text().
    # * Avoid copying script contents with function calls (e.g., print_string(),
    #   write_file_with_string()).
    #
    # *PRAISE BE TO ZELDA*, this actually works!
    load_module_mapfile
    {
        # For safety, prefix such script with the canonical zsh shebang line.
        get_zsh_shebang_line

        # Split comments and whitespace from such script into all remaining
        # shell words. Dismantled, this is:
        #
        # * "(Z:C:)", splitting into shell words, discarding comments and non-
        #   newline whitespace, and converting newlines to semicolons.
        list script_words; script_words=( ${(Z:C:)mapfile[${script}]} )

        # Concatenate such list to a string.
        string script_text="${script_words[*]}"

        #FIXME: Actually, it's not feasible to safely perform such replacement
        #in all cases. Drop this and document *WHY* we drop this. (For example,
        #consider a string legitimately containing two or more " ; ". Since
        #matching double-quoted zsh strings requires non-regular and hence non-
        #trivial parsing, it's simply impractical.)
        #FIXME: We can -- and should -- get around this for at least the zeshy
        #codebase (but probably *NOT* in general) by creating a new function
        #calling this function: get_zsh_script_contents_compacted_prettily().
        #Or... perhaps not. It *IS* a tad unreliable, and it's difficult to see
        #how it can be simplistically improved.

        # For both readability and efficiency, replace contiguous runs of
        # two or more ' ; ' with a single newline. While replacing runs of
        # one or more ' ; ' would be preferable, such replacement destroys
        # valid integer-style for loop syntax and semicolons in documentation.
        output_string "${script_text//(( |); )(#c2,)/${~ZESHY_ASCII_NEWLINE}}"
    } always {
        unload_module_mapfile
    }
}

#FIXME: Great testbed, until we implement proper unit testing.
#function cpow() {
#    remove_file_if_found "${HOME}/tmp/meow"
#    compact_zsh_script_to_file "${HOME}/tmp/main" "${HOME}/tmp/meow"
#    print_file_text "${HOME}/tmp/meow"
#}

# --------------------( WASTELANDS                         )--------------------
# Hence, critical `zsh`
#scripts (e.g., the main `zeshy` codebase) prefer compilation to compaction.
#, a slight speedup which over a script''s lifetime could prove beneficial
#   die_unless_file "${filename_source}"
#   die_if_path     "${filename_target}"
#       run_command_with_mapfile "print -- \${(Z:C:)mapfile[\${filename}]}"
    # Compact such script. For efficiency, avoid string copies of string
    # contents and hence extraneous calls (e.g., to write_file_with_string()).
#   {
        # For safety, prefix such script with the canonical zsh shebang line.
#       get_zsh_shebang_line

        # To avoid string copies, manually implement the equivalent of the
        # following:
        #
        #     compact_zsh_script "${filename_source}" |
        #         replace_string_glob_matches_with_string '( ; )##'\
        #             "${ZESHY_ASCII_NEWLINE}"
#       run_command_with_mapfile "
#           # Split such source script, removing comments and whitespace.
#           list source_words; source_words=(
#               \${(Z:C:)mapfile[\${filename_source}]} )

#           # Convert such list to a string.
#           string source_text; source_text=\"\${source_words[*]}\"

#           # For both readability and efficiency, replace contiguous runs of
#           # two or more ' ; ' with a single newline. While replacing runs of
#           # one or more ' ; ' would be preferable, such replacement destroys
#           # integer-style loop syntax and hence must be avoided (as well as
#           # disrupting semi-colons in documentation, of course).
#           print -- \"\${source_text//(( |); )(#c2,)/${~ZESHY_ASCII_NEWLINE}}\""
#   } > "${filename_target}"
        # To avoid string copies, manually implement the equivalent of the
        # following:
        #
        #     compact_zsh_script "${filename_source}" |
        #         replace_string_glob_matches_with_string '( ; )##'\
        #             "${ZESHY_ASCII_NEWLINE}"
#           print -- \"\${source_text}\""
#   die_if_file "${filename_target}"
#effectively copying such source to target file and 
#Compaction clones such source to target files and the former to 
#After compaction, the former remains unmodified while the latter is a clone of
#the former. Compaction  and does *NOT* touch the
#source. removing all extraneous comments and whitespace from such script. 
