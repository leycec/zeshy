#!/usr/bin/env zsh
# ====================[ call_stack                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the function and script call stack.

# ....................{ GETTERS                            }....................
document_function '
string get_call_stack_root_name(void)

Get the name of the first (i.e., oldest) function or script on the call stack,
serving as the root of the current call tree. For scripts, such name is the
absolute or relative path at which such script was originally called.
'
function get_call_stack_root_name() {
    # Validate sanity.
    die_if_args

    # Get such name. Since this function is transitively called by die(), avoid
    # Zeshy functions liable to throw exceptions if implemented poorly (e.g.,
    # is_list_nonempty()).
    if (( ${#funcstack} ))
    then print_string "${funcstack[-1]}"
    else print_string 'zeshy'
    fi
}

document_function '
string get_call_stack_root_basename(void)

Get the name of the first function or basename of the first script on the call
stack. See get_call_stack_root_name() for further details.
'
function get_call_stack_root_basename() {
    die_if_args
    get_path_basename "$(get_call_stack_root_name)"
}

# --------------------( WASTELANDS                         )--------------------
#(This function returns the basename of the string
#returned by get_call_stack_root_name(), in other words.)
#If such name is that of a script originally called with
#Script names contain path components
#If the call stack is empty (i.e., this function was called directly from the
#command line), return "zeshy".
#This function returns an absolute path if the first object on the call stack
#is a script called by an absolute path. Where this is undesirable, consider
#calling get_call_stack_root_basename().
        # If this name is an absolute path, return that path's basename.
#       if is_path_absolute "${funcstack[-1]}"
#       then print_string "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else print_string "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FIXME: Zeshify.
#   (( # == 0 )) || die 'expected no arguments'
    #FIXME: ${ZESHY_SCRIPT_NAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
#   if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
#       print -- "${ZESHY_SCRIPT_NAME}"

#FIXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
