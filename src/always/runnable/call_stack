#!/usr/bin/env zsh
# ====================[ call_stack                         ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle the function and script call stack.

#FIXME: Shift this component into a new "runnable/caller" directory and split
#all *_caller_*() functions into a new "runnable/caller" component.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_caller_equals(
  string caller_name,
  string error_message = "\"${caller_name}\" not the caller")

Throw an exception with the passed message unless the name of the function or
script calling the function or script calling this function is the passed name.
See is_caller_equals() for further details.
'
function die_unless_caller_equals() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one caller name and optional error message'
    string caller_name="${1}"

    # Test such name. Avoid calling is_caller_equals().
    (( ${#funcstack} >= 3 )) and is "${funcstack[3]}" == "${caller_name}" si or
        die "${2:-\"${caller_name}\" not the caller}"
}

# ....................{ TESTERS                            }....................
document_function '
boolean is_caller(void)

Return true if the current call stack contains at least one function or script,
excluding the most recent calls to this function and this function''s caller.
This function returns true *UNLESS* called directly from the command line or by
a function or script called directly from the command line: e.g.,

    >>> is_caller or
    ...     print_string "for I saw the last known landscape destroyed for"
    for I saw the last known landscape destroyed for
'
function is_caller() {
    # ${funcstack[1]} is always "is_caller", ${funcstack[2]} the name of the
    # function or script calling this function, and ${funcstack[3]} that of the
    # function or script calling the function or script calling this function
    # (i.e., the desired caller), if such function or script exists. Test for
    # the latter. Avoid calling get_list_size(), which increments the size of
    # such stack.
    die_if_args
    (( ${#funcstack} >= 3 ))
}

document_function '
void is_caller_equals(string caller_name)

Return true if the name of the function or script calling the function or script
calling this function is the passed name.
'
function is_caller_equals() {
    # Validate passed arguments.
    die_unless_arg 'expected one caller name'
    string caller_name="${1}"

    # Test such name. Avoid calling is_caller(), get_caller_name(), or
    # is_string_equals().
    (( ${#funcstack} >= 3 )) and is "${funcstack[3]}" == "${caller_name}" si
}

document_function '
boolean is_call_stack_contains(string runnable_name)

Return true if the current call stack contains the passed runnable (i.e.,
function or script). Thus, return true only if the passed runnable either is the
current runnable or transitively called the current runnable.
'
function is_call_stack_contains() {
    die_unless_arg 'expected one runnable name'
#   print "function: ${1}\nfuncstack: ${funcstack[*]}"
    is_list_contains funcstack "${1}"
}

# ....................{ GETTERS                            }....................
document_function '
boolean get_caller_name(void)

Get the name of the function or script calling the function or script calling
this function. If no such function or script exists (i.e., this function was
called directly from the command line or by a function or script called directly
from the command line), throw an exception. This function returns the correct
name when called from a subshell capturing output by process substitution: e.g.,

    >>> function timbered() { choir }
    >>> function choir() { print_string "caller: $(get_caller_name)()" }
    >>> timbered
    caller: timbered()
'
function get_caller_name() {
    # Validate sanity. Avoid calling die_unless_caller().
    die_if_args
    (( ${#funcstack} >= 3 )) or
        die 'no caller as called directly from the command line'

    # Get such name.
    print_string "${funcstack[3]}"
}

# ....................{ GETTERS ~ root                     }....................
document_function '
string get_call_stack_root_name(void)

Get the name of the first (i.e., oldest) function or script on the call stack,
serving as the root of the current call tree. For scripts, such name is the
absolute or relative path at which such script was originally called.
'
function get_call_stack_root_name() {
    # Validate sanity.
    die_if_args

    # Get such name. Since this function is transitively called by die(), avoid
    # Zeshy functions liable to throw exceptions if implemented poorly (e.g.,
    # is_list_nonempty()).
    if (( ${#funcstack} ))
    then print_string "${funcstack[-1]}"
    else print_string 'zeshy'
    fi
}

document_function '
string get_call_stack_root_basename(void)

Get the name of the first function or basename of the first script on the call
stack. See get_call_stack_root_name() for further details.
'
function get_call_stack_root_basename() {
    die_if_args
    get_path_basename "$(get_call_stack_root_name)"
}

# --------------------( WASTELANDS                         )--------------------
#, as doing so sets such
    # caller name to "is_caller_equals". Implement such functions manually
#       'no such caller (this function or its caller called directly from the command line)'
# Consider calling
#get_caller_name_from_subshell if capturing output by process substitution: e.g.,
# >>> function choir() { print_string_nonnewlined "caller: "; get_caller_name }
#document_function '
#boolean get_caller_name_from_subshell(void)
#
#Get the name of the function or script calling the function or script calling
#this function *WHEN CALLED FROM A SUBSHELL*. Consider calling get_caller_name()
#unless capturing output by process substitution: e.g.,
#
#    >>> function timbered() { choir }
#    >>> function choir() { print "caller: $(get_caller_name_from_subshell)" }
#    >>> timbered
#    caller: timbered
#'
#function get_caller_name_from_subshell() {
#    # Validate sanity. See is_caller() for implementation details.
#    die_if_args
#    curse_string "funcstack: ${funcstack[*]}"
#    (( ${#funcstack} >= 4 )) or die\
#        'no such caller; this function either not called from a subshell or its caller called directly from the command line'
#
#    # Get such name.
#    print_string "${funcstack[4]}"
#}

#(This function returns the basename of the string
#returned by get_call_stack_root_name(), in other words.)
#If such name is that of a script originally called with
#Script names contain path components
#If the call stack is empty (i.e., this function was called directly from the
#command line), return "zeshy".
#This function returns an absolute path if the first object on the call stack
#is a script called by an absolute path. Where this is undesirable, consider
#calling get_call_stack_root_basename().
        # If this name is an absolute path, return that path's basename.
#       if is_path_absolute "${funcstack[-1]}"
#       then print_string "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else print_string "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FIXME: Zeshify.
#   (( # == 0 )) || die 'expected no arguments'
    #FIXME: ${ZESHY_SCRIPT_NAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
#   if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
#       print -- "${ZESHY_SCRIPT_NAME}"

#FIXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
