#!/usr/bin/env zsh
# ====================[ document                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Document aliases, functions, and globals.
#
# --------------------( SEE ALSO                           )--------------------
# http://powerman.name/doc/asciidoc
#     AsciiDoc cheatsheet.

#FIXME: Remove all reference to {prepend,append,set}_args_with_stdin() from the
#Zeshy codebase, excluding set_args_with_stdin() where called from herestring-
#style aliases. In all other cases, such calls are highly dangerous and should
#be eliminated.
#FIXME: Wait. I believe we *MIGHT* be able to resuscitate such function *IF* we
#can augment them as follows (...no idea if this works, but it seems worth a
#try):
#
#* If standard input is an open pipe *AND* if list global ${pipestatus} is of
#  size larger than one, then doesn't that definitively suggest the current
#  function is directly piped standard input? Naturally, we should extensively
#  test this in vanilla zsh before running around like a mad badger attempting
#  to implement this in Zeshy.

#FIXME: Naturally, AsciiDoc will be an only optional dependency for users
#attempting to build the documentation. If not installed, we'll just display
#function documentation as is when a user runs "help function". If installed,
#we'll probably want to pipe function documentation dynamically through either
#the ASCII or man page exporters. (Sweeeeeet, no?)

#FIXME: Matching function prototypes is feasible with one or possibly more PCREs
#but *NOT* globs, due to the need to match arbitrarily many function names and
#argument specifiers. This is essential, since:
#
#* If AsciiDoc is installed, function prototypes should be dynamically marked up
#  with AsciiDoc-specific notation, which I believe even supports colors.
#* Else, function prototypes should be styled with conventional color styles.
#FIXME: Source code highlighting is simple. Just write:
#
#    [source,bash]
#    ----
#    INSERT CODE HERE
#    ----
#
#Sadly, neither Pygments or other less popular alternatives support zsh yet.
#Hence, "bash" suffices. Then, we want to selectively prefer "pygments" where
#available. To do so, we'll need to output the following at the very top of each
#AsciiDoc document we send to "asciidoc":
#
#    8<---------------
#    = Title
#    :source-highlighter: pygments
#
#This is an AsciiDoc header instructing "asciidoc" to prefer the "pygments"
#backend for the [source] filter. For further details, see:
#    https://groups.google.com/forum/?fromgroups=#!topic/asciidoc/ReIM4z-zi9I
#FIXME: Avoid repetition. In particular, replace "[source,bash]" with simply
#"[source]" everywhere by setting the default "language" in the AsciiDoc
#document header, like so:
#
#    :language: bash
#
#The same style can be extended to set default table attributes as follows:
#
#    :grid:  none
#    :frame: topbot

#FIXME: Documentation functions should continue working after Zeshy startup. To
#make this work, we'll need to redefine them in a precompile_zeshy_() function
#to ensure that the digest file contains the redefinition. Honestly, I'm not
#entirely convinced we want to serialize such documentation to disk; of course,
#we *DO*. But that invokes a few not-so-subtle issues. For now, just retain
#documentation in memory until it becomes a demonstrable problem.
#FIXME: After having performed a great deal of online research, "gzip" appears
#to be the canonical go-to for small text file compression.
#FIXME: Hmmmm. No. Scratch that. We really need a filesystem-based approach.
#O.K.; so, here's the idea:
#
#* Shift the definitions of set_alias_documentation(), etc. to this component,
#  replacing all current calls to such functions with hard-coded additions to
#  such map globals. *DO IT.* Trust me. This is needed to ensure that such
#  functions are compiled into Zeshy's digest file.
#* *DON'T* redefine document_alias(), document_function(), or document_global().
#  Instead redefine set_alias_documentation(), etc. to write to disk rather to
#  such map globals in the precompile_zeshy_*() function defined below, thus
#  ensuring the redefinition of such functions is compiled into Zeshy's digest.
#
#Bam. Nice one, eh?
#FIXME: Ensure this is performed in, say, "main":
#
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation

# ....................{ DOCUMENTERS ~ alias                }....................
#FIXME: O.K., O.K. Stop the "<>" nonsense with aliases. It's useful for
#referencing aliases to distinguish them from functions but completely unuseful
#for prototyping aliases. Alias prototype syntax should be a proper subset of
#function prototype syntax. (Note this is really the only way to do the PEG, as
#well; can you imagine duplicating the bloody function PEG for aliases with only
#ignorable differences?)

function document_alias() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one documentation string'
    local documentation="${1}"

    # If such documentation is prefixed by an alias prototype, match the
    # relevant alias name from such prototype. While zsh permissively allows
    # alias name declarations to be quoted and hence contain arbitrary
    # characters as with functions, such aliases are not runnable: e.g.,
    #
    #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
    #   >>> o\ w\ s
    #   zsh: command not found: o w s
    #
    # For simplicity, use a similar glob expression as document_function().
    if [[ "${documentation}" ==\
        (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
    then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
    else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
    fi
}

# ....................{ DOCUMENTERS ~ function             }....................
#FIXME: Define a new document_function_glob() or
#document_function_sans_filename_globbing() or
#document_function_and_disable_filename_globbing(). Yes, the latter. While
#verbose, that's not necessarily a bad thing in this case, as such function
#dramatically alters function parsing. In any case, such function should
#define a new alias of the same name expanding as follows:
#
#    alias ${function_name}="noglob ${function_name}"
#
#Test if such alias already exists before doing so, in which case throw an
#exception or perhaps merely print a warning. (Nah, exception!)
#FIXME: Actually, no one'll ever call this function. Rename to
#document_function_with_stdin_and_disable_function_filename_globbing() and
#implement accordingly. Yes, this is an obscenely long function name. No, in
#this particular instance, I don't particularly care. There's no reasonable
#abbreviation permitting the function name and heredoc declaration to reside on
#the same line, so such function is called like so:
#
#    document_function_with_stdin_and_disable_function_filename_globbing\
#        <<'________________<heredoc?>________________'
#    ...
#    ________________<heredoc?>________________

function document_function_and_disable_filename_globbing() {
    #FIXME: Implement me, and consider also implementing a new
    #disable_function_filename_globbing() function.
}

function document_function() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one documentation string'
    local documentation__df="${1}"

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
    if [[ "${documentation__df}" ==\
        (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
        # Attempt to split such function name on " [or] " delimiters.
        local    function_name__df="${match[1]}"
        local -a function_names__df
        function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
        if (( ${#function_names__df} == 1 ))
        then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
        else
            for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
                ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
            }
        fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
    else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
    fi
}

function document_function_with_stdin() {
    # Validate passed arguments.
    (( # )) && die 'expected no arguments'

    # If standard input is empty, throw an exception. See is_stdin_nonempty()
    # for further details.
    read -t 0 || die 'standard input empty'

    #FIXME: Actually define set_string_with_stdin(). Simplicity incarnate.
    # Document such input. See set_string_with_stdin() for further details.
    document_function "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# ....................{ DOCUMENTERS ~ global               }....................
#FIXME: I'm unclear why this needs to be an alias. If we were declaring such
#variable locally, I could see it, but... yeah; I think I slightly erred in
#implementing this as an alias. Convert to a function and reap the rewards of
#simplicity.

alias document_global='
{
    # Localize the passed herestring.
    local documentation__dg="$(< /dev/stdin)"

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more permissive glob expression than
    # typically preferred. Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    #
    # Else throw an exception with a portion of such documentation.
    [[ "${documentation__dg}" ==\
        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
        die "help string \"${documentation__dg[1,40]}...\" not prefixed by a variable declaration"

    #FIXME: If such global has been declared, we should probably print a
    #warning to standard error if its declared type differs from the
    #documentation-declared type. The implementation is a bit tedious,
    #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
    #dynamically constructed from its converse for performing efficient
    #lookups. Clearly, not a priority for the moment.

    # If such global has not yet been declared, do so. Prefer globals
    # "${match[1]}" and "${match[2]}" to human-readable local variables to
    # avoid polluting the local shell environment any further. See
    # is_variable() for implementation details.
    [[ -n "${(P)match[2]+x}" ]] || {
        # Runnable declaring variables of such type.
        declarator__dg="${match[1]}_global_export"

        # If such runnable does not exist, throw an exception. See
        # is_runnable() for implementation details.
        whence -- "${declarator__dg}" &>/dev/null ||
            die "\"${match[1]}\" not a recognized type"

        # Declare such global.
        "${declarator__dg}" "${match[2]}"
    }

    # Document such global.
    ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${match[2]}]="${documentation__dg}"
#   print "function name: ${match[1]}"
} <<<'

# ....................{ DOCUMENTATION                      }....................
#FIXME: Document document_function_with_stdin() as well. In the documentation,
#note the reason for needing document_function_with_stdin() to be the fact that
#both single- and double-quoted strings interface poorly with AsciiDoc syntax.
#Specifically, AsciiDoc's frequent use of:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.
#
#Fortunately, zsh supplies a third alternative: here-documents. Since zsh
#writes here-documents to standard input, this function expects non-empty
#standard input. See document_function() for further details.


#FIXME: Should be up-to-date, aside from the function renaming.
document_function_with_stdin <<'________________<heredoc?>________________'
void document_function_and_disable_filename_globbing(string documentation)

Set the documentation for the function named by the function prototype prefixing
the passed string to such string and disable filename globbing on all arguments
callers pass to such function. While the latter admittedly has little to do with
function documentation, bundling the two together slightly simplifies life. See
document_function() and disable_function_filename_globbing() for further
details.
________________<heredoc?>________________

#FIXME: Terribly obsolete. Rewrite.
document_function_with_stdin '
void document_global(string documentation)

If called when recompiling Zeshy''s user digest file, globally export the global
prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
prefixing the passed string *AND* document such global with such string; else,
do nothing.
'

document_function_with_stdin <<'________________<heredoc?>________________'
void document_alias(string documentation)

Set the documentation for the alias named by the alias prototype prefixing the
passed string to such string. Documentation consists of an alias prototype in
Zeshy-specific C-like syntax and a function description in AsciiDoc.

== Alias Prototypes ==

Alias prototypes follow a C-like syntax supporting zsh features not commonly
found in conventional high-level languages: return and argument channels. Since
zsh does _not_ currently support alias prototypes, we cannot coerce zsh to
respect or enforce such prototypes at runtime. Zeshy can, however, convert such
prototypes to syntax-highlighted, contextually-linked specifications in end-
consumer documentation.

=== Alias Documentation Grammar ===

Alias documentation consists of an alias prototype and description delimited by
mandatory whitespace. An alias prototype consists of one or more return types,
one alias name, and zero or more arguments; an alias description consists of
arbitrary http://asciidoc.org[AsciiDoc] with additional support for conveniently
cross-referencing other Zeshy documentation.

For completeness, we document such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)].
See the <<document_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., ReturnTypes, Whitespace):

.Alias Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| AliasDocumentation    | <- | AliasPrototype Whitespace+ AsciiDoc
| AliasPrototype        | <- | Whitespace* ReturnTypes
                               Whitespace+ AliasName
                               Whitespace* AliasArgs
| AliasName             | <- | AlphanumericString
| AliasArgs             | <- | ArgumentList | ArgumentChannels
| AliasArgChannels      | <- | ``['' Whitespace* ( AliasArgChannel Whitespace*
                               ``,'' Whitespace*)* AliasArgChannel Whitespace*
                               ``]''
| AliasArgChannel       | <- | AliasArgChannelName Whitespace* ``:'' Whitespace*
                               (Argument | ArgumentList)
| AliasArgChannelName   | <- | ``args'' | ``argstring'' | ``stdin''
|===============================================================================

== Alias Description and Prototype ==

Aliases support the same descriptions and prototypes as functions, with one
minor and one major exception. See document_function() for all other details.

=== Minor Exception ===

Function prototypes permit multiple names. Alias prototypes permit only one.

=== Major Exception ===

Function prototypes permit only two argument channel names: `args` and `stdin`.
Alias prototypes permit a third argument channel specific to herestring-driven
aliases: `argstring`.

By design, zsh aliases are expanded inline and hence cannot accept arbitrary
arguments not accepted by the commands such aliases expand to. As example, the
alias `l` declared by `alias l=ls` accepts only the arguments accepted by
command `ls` -- no more, no less.

Herestring-driven aliases circumvent such constraints by accepting a single
herestring argument embedding one or more ``real'' arguments to be passed such
alias. Since such aliases _always_ accept a single herestring, declaring a
single-string argument list conveys no meaningful information. Rather, such
aliases should declare a herestring-specific argument channel `argstring`
accepting the argument list embedded in such herestring. For clarity, consider
optionally suffixing aliases defined in this way with `_from': e.g.,

.Herestring-driven Alias
==========================================
[source]
------------------------------------------
document_alias '
alias set_args_to_string_split_on_words_from[
    argstring: (string text1, string text2, ...)]

Set the current argument list to the passed strings split on shell words: e.g.,

    >>> set_args_to_string_split_on_words_from 'worker can "create nothing"'
    >>> print_string ${3}
    create nothing
'
alias set_args_to_string_split_on_words_from='
{
    # Validate passed arguments.
    list args__sltssowf
    set_list_to_stdin_split_on_words args__sltssowf
    (( ${#args__sltssowf} >= 1 )) or die 'expected at least one string'

    # Temporary list to split such strings into.
    list words__sltssowf

    # Split such strings.
    set_list_to_string_split_on_words words__sltssowf "${args__sltssowf[@]}"

    # Set the current argument list to such words.
    set_args "${words__sltssowf[@]}"

    # Delete such temporary list.
    undefine_variable words__sltssowf
} <<<'
------------------------------------------
________________<heredoc?>________________

document_function_with_stdin <<'________________<heredoc?>________________'
void document_function(string documentation)

Set the documentation for the function named by the function prototype prefixing
the passed string to such string. Documentation consists of a function prototype
in Zeshy-specific C-like syntax and a function description in
http://asciidoc.org[AsciiDoc].

== Function Documentation Grammar ==

Function documentation consists of a function prototype and description
delimited by mandatory whitespace. A function prototype consists of one or more
return types, one or more function names, and zero or more function arguments;
a function description consists of arbitrary http://asciidoc.org[AsciiDoc] with
additional support for conveniently cross-referencing other Zeshy documentation.

For completeness, we document such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:

[[document_function.peg]]
.Function Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| FunctDocumentation    | <- | FunctPrototype Whitespace+ AsciiDoc
| http://asciidoc.org[AsciiDoc] | <- | (XReference | AnyCharacter)*
| XReference            | <- | WordStart XReferObject WordEnd
| XReferObject          | <- | XReferAliasOrFunct |
                               XReferAlias |
                               XReferFunct |
                               XReferGlobal
| XReferAliasOrFunct    | <- | AlphanumericString ``()''
| XReferAlias           | <- | ``alias:''    XReferAliasOrFunct
| XReferFunct           | <- | ``function:'' XReferAliasOrFunct
| XReferGlobal          | <- | ``${'' AlphanumericString ``}''
| FunctPrototype        | <- | Whitespace* ReturnTypes
                               Whitespace+ FunctNames
                               Whitespace* FunctArgs
| ReturnTypes           | <- | Type | ReturnChannels
| Type                  | <- | AlphanumericString
| ReturnChannels        | <- | ``['' Whitespace* ( ReturnChannel Whitespace*
                               ``,'' Whitespace*)* ReturnChannel Whitespace*
                               ``]''
| ReturnChannel         | <- | ReturnChannelName Whitespace* ``:'' Whitespace*
                               Type
| ReturnChannelName     | <- | ``stdout'' | ``stderr'' | ``status''
| FunctNames            | <- | (FunctName Whitespace+ ``[or]'' Whitespace+)*
                                FunctName
| FunctName             | <- | AlphanumericString
| FunctArgs             | <- | FunctArgList | FunctArgChannels
| FunctArgChannels      | <- | ``['' Whitespace* ( FunctArgChannel Whitespace*
                               ``,'' Whitespace*)* FunctArgChannel Whitespace*
                               ``]''
| FunctArgChannel       | <- | FunctArgChannelName Whitespace* ``:'' Whitespace*
                               (FunctArg | FunctArgList)
| FunctArgChannelName   | <- | ``args'' | ``stdin''
| FunctArgList          | <- | ``('' Whitespace* (FunctArgsEmpty |
                               FunctArgsNonEmpty) Whitespace* ``)''
| FunctArgsEmpty        | <- | FunctArgEmpty?
| FunctArgsNonEmpty     | <- | (FunctArgNonEmpty Whitespace* ``,'' Whitespace*)*
                                FunctArgNonEmpty
| FunctArg              | <- | FunctArgEmpty | FunctArgNonEmpty
| FunctArgEmpty         | <- | ``void''
| FunctArgNonEmpty      | <- | Type  Whitespace+ FunctArgName (Whitespace*
                               ``='' Whitespace* FunctArgDefaultValue)?
| FunctArgName          | <- | AlphanumericString
| FunctArgDefaultValue  | <- | ZshValue
| ZshValue              | <- | Integer | Float |
                               SingleQuotedString | DoubleQuotedString
| Integer               | <- | ``-''? Digit+
| Float                 | <- | ``-''? Digit+ ``.'' Digit+
| SingleQuotedString    | <- | ``\''' (``\'\''' | !``\''' AnyCharacter)* ``\'''
| DoubleQuotedString    | <- | ``"''  (``\\"''  | !``"''  AnyCharacter)* ``"''
| AlphanumericString    | <- | (!(Whitespace | Punctuation) AnyCharacter)*
| Whitespace            | <- | Space | Tab | Newline
| Punctuation           | <- | ``('' | ``)'' | ``['' | ``]'' | ``{'' | ``}'' |
                               ``,'' | ``='' | ``:'' | ``"'' | ``\'''
| Digit                 | <- | ``0'' | ``1'' | ``2'' | ``3'' | ``4'' | ``5'' |
                               ``6'' | ``7'' | ``8'' | ``9''
| AnyCharacter          | <- | Whitespace | Punctuation | Digit | ``a'' | ...
|===============================================================================

== Function Description ==

Function descriptions follow http://asciidoc.org[AsciiDoc] syntax augmented to
support Zeshy-specific cross-references of aliases, functions, and globals. To
cross-reference another:

* zsh alias or function, suffix such alias or function name with `()` (e.g.,
  `document_function()`). If both an alias _and_ function share such name, the
  cross-reference refers only to the alias (in keeping with zsh behavior). For
  genericity, this is generally preferable to the next two disambiguations.
* zsh alias, prefix such name with `alias:` and suffix such name with `()`
  (e.g., `alias:catch()`).
* zsh function, prefix such name with `function:` and suffix such name with `()`
  (e.g., `function:catch()`).
* zsh global, prefix such name with `${` and suffix such name with `}` (e.g.,
  `${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}`).

== Function Prototypes ==

Function prototypes follow a C-like syntax supporting zsh features not commonly
found in conventional high-level languages: function name synonyms and return
and argument channels. Since zsh does _not_ currently support function
prototypes, we cannot coerce zsh to respect or enforce such prototypes at
runtime. Zeshy can, however, convert such prototypes to syntax-highlighted,
contextually-linked specifications in end-consumer documentation.

=== Function Prototype Context-sensitivity ===

In conventional high-level languages, a function is typified by its *signature*:
the set of function name(s), return type(s), and argument type(s) uniquely
identifying that function. Each signature is statically predefined at function
declaration time and either not subject to subsequent change or changeable only
by redeclaring its function.

In zsh, a function is typified only by the set of its names. Since this is
hardly a signature in the conventional sense, zsh functions have arguably no
function signature and certainly no statically predefined set of return type(s)
and/or argument type(s). Rather, these types are the implicit result of dynamic
implementation details possibly depending on local, global, or external state --
which is to say, effectively anything you'd like.

For example, it's possible (though a pretty bad idea) to define a function
accepting at least one string argument and conditionally changing both return
and argument types in context-dependent relation to such argument as follows:

* If such argument is "hexadecimal -> decimal", accept a second string in
  base 16 hexadecimal format and return the equivalent base 10 integer.
* If such argument is "string1, ... -> list", accept one or more additional
  strings and return the concatenation of such strings as a string convertible
  without error into a list of such strings by the caller.
* If such argument is "stdin == 'clear' ? string -> void : void -> string", test
  whether such function was piped standard input equal to string "clear". If so,
  accept a second string signifying the name of a list to be cleared; otherwise,
  accept no additional strings and return a string of random bytes.

This rabbit hole goes deep. Since supporting such conditionality is infeasible
(and arguably undesirable), [underline]#this function naively assumes all function
signatures to be statically predefined at function declaration time#. For
signatures for which this is not the case (as in the above example), consider
documenting only the most commonly called signature in the function prototype.

[[document_function.return_types]]
== Return Types ==

zsh return types are more intricate than those of normal high-level languages.
All functions return three *channels* (i.e., ``streams'' of orthogonal output):

. A string of standard output.
. A string of standard error.
. A byte of exit status.

=== Single Return Type ===

Since most functions only output to standard output and throw exceptions rather
than return non-zero exit status on failure, shorthand notation suffices for
such functions. Declaring a single return type as in conventional high-level
languages (e.g., `integer hikikomori(string otaku)`) signifies such function to
always return a string of standard output convertible without error to such
type, an empty string of standard error, and zero exit status (i.e., success).

==== Non-Scalar Return Types ====

Zeshy provides aliases for both returning and receiving returned lists and maps,
suggesting `list` and `map` are acceptable return types from either standard
output or error. Since returning such types incurs a significant performance
penalty, consider only returning such types for sufficiently small lists and
maps (noting that ``small'' has yet to be rigorously defined).

=== Mapped Return Types ===

Some functions output to standard error and/or return non-zero exit status,
necessitating a longhand notation mapping each of the three possible return
channels (standard output, standard input, and exit status) to the return type
such function returns on such channel. Specifically, declaring a `[`- and `]`-
bracketed map of one to three `,`-delimited, `:`-separated key-value pairs
mapping return channel to return type (e.g.,
`[stdout: float, stderr: string, status: integer] nhk(string kyokai)`)
signifies such function to return standard output and error strings and exit
status convertible without error to such types.

At least one such key-value pair must be declared. The value declares the
return type that channel returns (e.g., `string`). The key identifies the
channel itself via one of three case-insensitive strings:

* `stdout`, the standard output channel. Returns any conventional type or
  `void`, a pseudo-type signifying such function to return no standard output.
  Defaults to `void` if unspecified.
* `stderr`, the standard error return channel. Returns any conventional type or
  `void`, a pseudo-type signifying such function to return no standard error.
  Defaults to `void` if unspecified.
* `status`, the exit status return channel. Returns only the following
  numerical return types (defaulting to `true` if unspecified):
  ** `true`, a pseudo-type signifying such function to always succeed (ignoring
     exceptions). While `true` and `false` are values rather than genuine types,
     mere technicalities are merely that.
  ** `false`, a pseudo-type signifying such function to always fail. Since Zeshy
     implicitly throws exceptions on failure, such type is generally unhelpful.
  ** `boolean`, signifying such function to return exit status 0 on success or 1
     on failure. Most such functions are `is_`-prefixed *testers* returning only
     `[status: boolean]` and hence no standard output or error (e.g.,
     `[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).
  ** `integer`, signifying a function returning more than merely exit statuses 0
     and 1 (e.g., `grep`, returning 0 on match, 1 on no match, and 2 on error).

Return types thus default to map `[stdout: void, stderr: void, status: true]`.
For example, the following prototypes all equivalently define a function
accepting no arguments, returning a string convertible without error to a float
from standard output and no standard error, and always succeeding:

.Mapped Return Types
==========================================
* `float ukigumo(void)`.
* `[stdout: float] ukigumo(void)`.
* `[stdout: float, stderr: void] ukigumo(void)`.
* `[stdout: float, status: true] ukigumo(void)`.
* `[stdout: float, stderr: void, status: true] ukigumo(void)`.
==========================================

== Function Names ==

zsh function names are more intricate than those of normal high-level languages.
All functions have one or more names, declared at function declaration time with
whitespace delimiters. Repeat such declaration in function documentation with
case-insensitive `[or]` delimiters: e.g.,

.Function Name Synonyms
==========================================
[source]
------------------------------------------
document_function ''
void name [or] synonym [or] pseudonym [or] anonym(void)

A function callable as either name(), synonym(), pseudonym(), or anonym().
''
function name synonym pseudonym anonym() { true }
------------------------------------------
==========================================

== Function Arguments ==

As expected, zsh function arguments are more intricate than those of normal
high-level languages. All functions accept two *channels* (i.e., ``streams'' of
orthogonal input):

. A passed argument list.
. A string of standard input.

[[document_function.argument_list]]
=== Single Function Argument List ===

Since most functions only accept passed argument lists rather than standard
input, shorthand notation suffices for such functions. Declaring a single `(`-
and `)`-bracketed argument type list of one or more `,`-delimited argument
declarations consisting of a whitespace-delimited type and name followed by
optional `=` and default value in typical zsh syntax as in normal high-level
languages (e.g., `void the(string ultimate, integer question = 42)`) signifies
such function to accept only such arguments with no standard input.

==== Function Argument Names ===

Argument names should contain no whitespace or punctuation, much like real zsh
variable names. While argument names need not correspond to the actual variable
name (if any) the function implementation copies such argument into, this is
generally considered good form.

==== Function Argument Types ===

Argument types are any single scalar types (e.g., `boolean`, `integer`), thus
excluding `void`, `list`, and `map`. Since argument lists are lists, consider
passing read-only lists as arguments and lists to be modified as the names of
such lists. While maps can be packed into argument lists, consider always
passing maps as the names of such maps. When passing the name rather than value
of variables, consider mangling *ALL* variable names declared in the function
implementation in a function-specific manner to avoid accidentally overriding
externally with internally declared variables. Zeshy heuristically mangles by
appending `__` followed by the first letter of each word in the function name,
which suffices for most purposes. For readability, avoid mangling documented
argument names. For example:

.Function Argument Mangling
==========================================
[source]
------------------------------------------
document_function ''
void set_list_to_raspberry_hybrids(string list_name, string flavor)

Set the passed list to all known raspberry hybrids of the passed flavor.
''
function set_list_to_raspberry_hybrids() {
    # Validate passed arguments.
    die_unless_args_2 ''expected one list name and one raspberry flavor''
    string list_name__sltrh="${1}" flavor__sltrh="${@[-1]}"
    die_unless_list "${list_name__sltrh}"

    # Set such list.
    if is_string_equals "${flavor}" acidic
    then set_list_to_evaluation "${list_name__sltrh}" ''( loganberry )''
    else set_list_to_evaluation "${list_name__sltrh}" ''( tayberry )''
    fi
}
------------------------------------------
==========================================

==== Function Argument Default Values ===

Default argument values are any valid right-hand side of a scalar assignment,
including double-quoted strings nesting arbitrarily deep process substitutions
(e.g., `(string dirname = "$(is_superuser and "/o" or "$(get_dir)")")`). For
safety, Zeshy *never* evaluates such values, which may thus contain executable
code known to have dangerous side-effects. (Naturally, this is not a good idea.)

==== Empty Function Argument List ===

Functions accepting no arguments may declare an argument list of either:

* `()' as in shell languages.
* `(void)` as in C-like languages.

==== Variadic Function Function Argument List ===

Functions accepting arbitrarily many arguments of the same type (referred to as
``variadic functions'' elsewhere) should declare only the first such argument
including optional default value followed by `, ...`. When a default value is
declared, any number of such arguments may be passed; then if a caller passes no
such arguments, the function defaults to a single argument of the default value.
When no default value is declared, at least one such argument must be passed.
Such arguments may be preceded and followed by other arguments. For example:

.Variadic Function
==========================================
[source]
------------------------------------------
document_function ''
void uhoh(integer mtime, string dirname1 = "/", ..., boolean is_recursive)

A function accepting an integer, zero or more dirnames defaulting to "/" if
no such strings are passed, and a boolean -- usually doing something rather
dangerous.
''
function uhoh() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        ''expected one integer, optional dirnames, and one boolean''
    string mtime="${1}" is_recursive="${@[-1]}"
    die_unless_integer "${mtime}"
    die_unless_boolean "${is_recursive}"

    # Remove such integer and boolean from the argument list. All remaining
    # arguments, if any, are dirnames.
    shift_arg
    pop_arg

    # If no arguments remain, default to "/".
    is_args or set_args "/"

    # Do something rather dangerous.
    print "Mu-haha! [${mtime}]"
    if is_boolean_true "${is_recursive}"
    then ls -R -- "${@}"
    else ls    -- "${@}"
    fi
}

=== Mapped Function Argument List ===

Some functions also accept standard input, necessitating a longhand notation
mapping each of the two possible argument channels (passed argument list and
standard input) to the argument type list such function accepts on such channel.
Specifically, declaring a `[`- and `]`-bracketed map of one to two `,`-
delimited, `:`-separated key-value pairs mapping argument channel to argument
type list (e.g., `void taake[args: (string hordaland1, ...), stdin: string vi]`)
signifies such function to accept passed arguments and standard input
convertible without error to such types.

At least one such key-value pair must be declared. The key identifies the
argument channel such pair describes via one of two case-insensitive strings:

* `args`, the passed list of arguments channel.
* `stdin`, the standard input argument channel.

The value identifies the argument(s) such channel accepts via either:

* Shorthand notation, a
  <<document_function.argument_list,single argument declaration>> consisting of:
  * A whitespace-delimited type and name followed by optional `=` and default
    value in typical zsh syntax, signifying such function to accept only that
    argument on such channel (e.g.,
    `void chomsky[args: boolean the_purpose, stdin: integer of_education]`).
  * `void`, a pseudo-type signifying such function to accept _no_ arguments on
    such channel.
* Longhand notation, a list of
  <<document_function.argument_list,one or more argument declarations>>
  bracketed by `(` and `)` and delimited by `,`, signifying such function to
  accept all such arguments on that channel (e.g.,
  `void kropotkin[args: (integer mutual1, ...), stdin: (integer aid1, ...)]`).

Argument list types thus default to map `[args: void, stdin: void]`. For
example, the following prototypes all equivalently define a function
accepting a string convertible without error to a character on the passed
argument list and no standard input, and always succeeding:

.Mapped Return Types
==========================================
* `void kurosawa(character red_beard)`.
* `void kurosawa[args: character red_beard]`.
* `void kurosawa[args: (character red_beard)]`.
* `void kurosawa[args: (character red_beard), stdin: void]`.
==========================================
________________<heredoc?>________________

# --------------------( WASTELANDS                         )--------------------
#Since zsh expands aliases inline, aliases cannot accept arbitrary arguments not
#accepted by the command such alias expands to.

#FUXME: Obscenely out-of-date. Significantly expand, noting that the alias
#documentation PEG is effectively the proper subset of the function
#documentation PEG excluding function name synonyms and replacing "(" and ")"
#with "<" and ">".
#While all function implementations remain free to
#dynamically redefine their signatures and hence deviate from such static
#documentation, developers should question the cognitive cost of such functions!

#FUXME: There is one other matter, of course: standard input. And
#come to think, this is also a concern for function documentation as well.
#How do we document whether a function accepts standard input and, when it does
#so, where it places such input in relation to other accepted arguments if any?
#*UGH*. Super annoying that I neglected to account for stdin. *sigh*
#FUXME: O.K.; I think I have a working syntax. The idea is simple: zsh
#extensions to C-like function prototype syntax are "["- and "]"-delimited.
#Since herestring-driven aliases unpack stdin into customary arguments, we have
#an stdin argument syntax resembling:
#
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#
#What's nice is that, as a function, it would simply be written as:
#
#[stdout: float] ukigumo(string dirname, integer mtime)
#
#Simple, concise, and consistent. Excellent. The above syntax naturally extends
#to support standard input being assigned to only one argument, like so:
#
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Ugh. So, that works, but doesn't really coincide with above. How about:
#
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Right. That works. It's obviously tempting to reduce every "[" and "]" to a
#"(" and ")" at this point, but that reduces the resulting prototype to a
#slightly less readable mish-a-mash ala LISP (*shudder*):
#
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#Hmm. Is that *REALLY* less readable? Frankly, it seems *MORE* readable. Right.
#O.K.; so, in this instance only, contemplate LISP-ish syntax. I can't believe
#I'm muttering that, but... well, it is much easier to remember and hence to
#write, and reads quite well as well. So, there you are!
#
#Right. There's just one final thing: input pipes. Quite a few functions only
#expect piped standard input, not just any ol' standard input. So, we'll need to
#also support something resembling:
#
#(stdout: float) ukigumo(piped stdin: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin-pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(piped: string dirname, integer mtime)
#
#The latter, I should think. "piped" implies "stdin" and more, so prefixing with
#or otherwise explicitly stating "stdin" is unnecessary. Well! That should do it,
#no? We'll need to slightly revise both the PEG and examples below, but better
#now that after we've begun using this syntax everywhere, eh? :}
#
#Ah, right: one final thing. The ":" implies mandatory and, in most cases, piped
#standard input is optional. How about a new "?" suffix for optional input, ala:
#
#(stdout: float) ukigumo(piped? string dirname, integer mtime)
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#BRILLIANT. Bravo, senior Cecil. Bravo.
#
#Note, however, that optional piped input is probably unhelpful and should
#arguably be eliminated from the Zeshy codebase. Hence, for now, just document
#the "stdin:"-style syntax.
#FUXME: O.K.; so, the above syntax isn't *QUITE* right. Since we're *NEVER*
#passing in standard input as an optional argument, any standard input passed is
#always as a second "channel" completely outside the scope of passed arguments.
#Also note that *_from()-style aliases *APPEAR* to the caller to accept a single
#string rather than standard input, suggesting an additional "string:" channel.
#Revert to "["-style syntax, for clarity. This suggests the following syntax:
#
#    # A function accepting a string *AND* standard input.
#    [stdout: void] set_string_to_stdin[
#       args: string string_name, stdin: string input]
#
#    # A function accepting one or more integers on standard input.
#    [stdout: string] get_stdin_integers[
#       args: void, stdin: (integer int1, ...)]
#
#    # Equivalent to the prior prototype.
#    [stdout: string] get_stdin_integers[stdin: (integer int1, ...)]
#
#    # A herestring-style alias.
#    [stdout: float] ukigumo[string: (string dirname, integer mtime)]
#
#So, the fundamental idea is that "args:" and "stdin:" both default to "void",
#as for return types. Either or neither may be specified, with predictable
#consequences in any case. Beautiful, no? (Well, certainly *LOGICAL*!)

#Tester functions returning only boolean exit status and no standard output or
#error may thus map return types `[status: boolean]` (e.g.,
#`[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).

#Being unprototyped, zsh function argument order and type is not
#statically predefined at function declaration time but may conditionally
#dynamically depend on local, global, and/or external state. For example,
#While perfectly documenting all possible function argument dynamics is both unfeasible and undesirable,
#conditionally depend and hence arguably more involved
#(though not necessarily beneficially) than those of conventional high-level languages.

#Documenting all possible function prototype dynamics is both unfeasible and
#undesirable. For sanity, function documentation assumes function signatures to
#be statically predefined at function declaration time as in normal high-level languages. Function implementations remain
#free to dynamically redefine and hence stray from such documentation as
#necessary, although this is generally discouraged.

#For brevity, functions may specify a single return type as in conventional
#high-level languages (e.g., `integer`).
# Zeshy documents such values in one of two ways:
#With a single type as in conventional high-level languages (e.g., `integer`),
#signifying such function to return a string of standard output convertible
#without error to such type, an empty string of standard error, and zero exit
#status (i.e., success). Since most functions only write to standard output and
#throw exceptions rather than return non-zero exit status on error, this
#shorthand notation simplifies most functions'' documentation.

#| Digit                 | <- | ``0'' | DigitNonZero
#| DigitNonZero          | <- | ``1'' | ``2'' | ``3'' | ``4'' | ``5'' | ``6'' |
#                               ``7'' | ``8'' | ``9''
#| Integer               | <- | ``-''? (``0'' | DigitNonZero Digit*)

#FUXME: I've performed an obscene amount of research on lightweight
#documentation formats and the winner *HANDS DOWN* is AsciiDoc. The syntax
#absolutely rocks, is near infinitely extendable with "pluginname:string"-style
#syntax and third-party plugins, exports beautiful HTML, LaTeX, PDF, man pages,
#DocBook, and so on. All Git documentation is written in AsciiDoc (which should
#absolutely tell you something: this is Linus' Git, after all). Markdown and
#Textile are rather outdated at this point. The only genuine competitor is the
#official Python documentation language, RestructuredText (reST). I'll admit:
#reST is powerful. Probably nearly as or even slightly more powerful than
#AsciiDoc. But in the end, that doesn't really matter... because the syntax is
#absolute shite. I mean, *LOOK AT THAT SYNTAX*. What the bloody hell were they
#thinking? They could have simply adopted the de facto e-mail-style markup
#syntax from which AsciiDoc (and Markdown and Textile and pretty much every
#other lightweight documentation language) is descended. But *NO*, they had to
#reinvent the friggin' wheel. And they failed. They thoroughly failed. Thank the
#Nordic Gods, then, for AsciiDoc.

#[stdout: float] ukigumo(stdin -> [string dirname, integer mtime])
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(string dirname, integer mtime) <- stdin
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#[stdout: float] ukigumo(stdin -> string dirname, integer mtime)

#FUXME: set_function_documentation() will need to detect whether passed standard
#input and, if so, ... Hmm. Actually, we should probably just do so in the high-
#level functions themselves (e.g., document_function()). That necessitates
#pushing such documentation to the end of this file, but... *shrug*. That's
#fine, and arguably even preferred here (since it centralizes all documentation
#in one place). Arguably, we should then provide distinct high-level functions
#entitled document_function_from_stdin() and so forth. The issue with
#trying to make a single "smart" document_function() implicitly detecting open
#standard input is that such functions will be called from the top-level during
#Zeshy startup and hence cannot distinguish external from internal standard
#input. Subvert such confusion with distinct functions only accepting standard
#input.

#set_alias_documentation document_global '
#void document_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
#alias document_global='
#{
#    # Localize the passed herestring.
#    local documentation__dg="$(< /dev/stdin)"
#...
#} <<<'

#Document the function named in the function prototype prefixing the passed
#documentation, which consists of a function prototype in C-like syntax
#followed by function description in AsciiDoc.
#
#whose syntax supports zsh features not commonly found in
#conventional high-level languages (e.g., function name synonyms, tristate return
#values). For completeness, we specify such syntax with a Parser Expression
#Grammar (PEG):
#
#Such types should correspond to the actual variable type (if
#any) the function implementation copies such argument into.
#
#values are *NEVER* evaluated by Zeshy and hence may contain executable code that
#could, whenever evaluated, have dangerous side-effects. 
#
#assigning each argument a
#mandatory name and type and optional default value.
#
#While argument names need
#not correspond to the variable name (if any) the function implementation copies
#such argument into, argument types and optional default value should, of course.
#
#(e.g., "function name synonym pseudonym nom_de_guerre nom_de_plume() { true }",
#a function callable as either name(), synonym(), pseudonym(), nom_de_guerre(),
#or nom_de_plume()).
#
#by listing all such names in whitespace-
#delimited fashion (e.g., .
#at least one name  also arbi:
#a
#Most function names as in conventional high-level languages (e.g., "integer"),
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#
#For functions with only one name, call this function as follows:
#
#    document_function ''
#    RETURN_TYPE FUNCTION_NAME(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#For functions with multiple names, call this function as follows:
#
#    document_function ''
#    RETURN_TYPE FUNCTION_NAME_1 [or] FUNCTION_NAME_2 [or] ... FUNCTION_NAME_N(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME_1 FUNCTION_NAME_2 ... FUNCTION_NAME_N() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#Capitalized strings above denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  FUXME: Rewrite this section after implementing the above additions. It gets a
#  bit complicated, but... heck, it''ll definitely be worth it.
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.
#* "FUNCTION_NAME_2", the second name for such function. While most functions have
#
#  As in C-like languages, type "void" signifies such function to return no
#  standard output and/or error.
#
#Function prototypes follow the familiar "RETURN_TYPE FUNCTION_NAME 
#
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#While zsh does not support function prototypes, this function
#adopts conventional high-level language function prototype syntax for documentation-specific purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#named by the C-style function prototype of the passed
#documentation string. Since zsh permits no function prototyping, this function
#adopts conventional high-level language function prototype syntax for documentation purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#syntax does *NOT* constitute 
#While such syntax does *NOT* constitute an enforcable
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#, which must thus be prefixed  with such documentation. 
#
#This function is deleted by Zeshy immediately before compiling its user digest
#file and hence only callable from the global context of Zeshy components.

#FUXME: It'd be great to support a distinction between standard output and
#error return values in function prototypes. How about something resembling:
#
#    # Function returning a string of standard output and no standard error.
#    [string, void] do_something(void)
#
#    # Or perhaps the more verbose:
#    [stdout: string, stderr: void] do_something(void)
#
#    # Actually, we could support both (obviously), which we should do. Ah;
#    # actually, we should probably just add such "stdout:" and "stderr:"
#    # labels on printing human-readable documentation to users, yes? Ah;
#    # perhaps not. It'd certainly be more intelligible to developers browsing
#    # the code to see "[stdout: string, stderr: void]" versus the former.
#    # The more verbose version also lends itself well to specifying exit
#    # status, as below.
#
#Since most functions return no standard error, retain support for shorthand:
#
#    # Same as above, shorthand.
#    string do_something(void)
#
#While most functions return 0 exit status, some do not. How about this:
#
#    # Function returning a string of standard output and no standard error
#    # and non-zero exit status on failure.
#    [string, void, boolean] do_something(void)
#
#    # Or, again:
#    [stdout: string, stderr: void, status: boolean] do_something(void)
#
#Status may either be "void" (i.e., always returns 0), "boolean" (i.e.,
#either returns 0 or 1), or "integer" (i.e., returns a variety of statuses.
#
#Ah! Another way in which the labels are demonstrably superior: in may cases,
#we'll want to specify "stdout" and "status" but not "stderr". So, that's just:
#
#    [stdout: string, status: boolean] do_something(void)
#
#Naturally, order no longer matters. Sweet! I'm thinking we *ABSOLUTELY*
#shouldn't support the abbreviated "[stdout, void, boolean]" style, yes? Far too
#much ambiguity and head-scratching.
#FUXME: The specification below has become sufficiently complex to warrant a BNF.
#I know, I know. But we'll make it simple and concise, with adequate commenting.
#There's really no better way.

# ....................{ GLOBALS                            }....................
#FUXME: This is terrible. Eliminate such global entirely; instead, simply
#attempt to run a dynamically constructed command
#${variable_type}_global_export().

#set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#map ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#
#Map variable type to the declarator (i.e., command prefix) declaring and
#exporting globals of such type.
#'
#typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#    # String types.
#    string    'export'
#    boolean   'export'
#    character 'export'

    # Integer types.
#    integer         'export -i'
#    file_descriptor 'export -i'
#
    # Float types.
#    float 'export -F'
#
#    # List types.
#    list     'export -a'
#    list_set 'export -Ua'
#
#    # While "export -a" succeeds (as above), "export -A" fails with error.
#    # Hence, revert to builtin typeset().
#    map 'typeset -Agx'
#)

        # If such global''s type is not a Zeshy-specific type, throw an
        # exception. See is_map_key() for implementation details.
#       (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#           die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
#       ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

# ....................{ MAIN                               }....................
#FUXME: Not quite right. We also want to undefine all of the above aliases and
#functions before Zeshy digest compilation, suggesting we create a new
#precompilation hook performing all such undefinitions. I can't imagine that
#order matters, there; so, just add a customary precompilation hook here.

#run_hook_on_zeshy_precompile precompile_zeshy_documentation_undefine

#document_function '
#void precompile_zeshy_documentation_undefine(void)
#
#Undefine all documentation-defining runnables (e.g., set_alias_documentation(),
#document_global()) *AFTER* sourcing all Zeshy components calling such runnables
#and hence having defined all available documentation. To  Zeshy caches 
#The documentation such runnables
#'
#function precompile_zeshy_documentation_undefine() {
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
#}

#FUXME: Rename "[or]" to "[or]" everywhere. Avoid simply "or", as that isn't
#subject to global replacement.
# For simplicity, this function ignores 
# such low-level distinctions, accepts
# (e.g., "boolean", "list", "string"). If 
#
#While most functions have only one name, zsh does permit additional names to be
#declared in function declarations with the above whitespace-delimited syntax.
#
#Capitalized strings denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific type of variable returned by such function
#  (e.g., "boolean", "list", "string").
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.

# *BEFORE* compiling Zeshy''s user digest file
# (i.e., at the top level of Zeshy components and in precompilation hooks).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Define document_function() before document_alias(), which documents itself
# with the former function.
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias document_alias=':' document_function=':' document_global=':'

# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_DOT_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)
