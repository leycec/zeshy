#!/usr/bin/env zsh
# ====================[ document                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Document aliases, functions, and globals.

#FIXME: Documentation functions should continue working after Zeshy startup. To
#make this work, we'll need to redefine them in a precompile_zeshy_() function
#to ensure that the digest file contains the redefinition. Honestly, I'm not
#entirely convinced we want to serialize such documentation to disk; of course,
#we *DO*. But that invokes a few not-so-subtle issues. For now, just retain
#documentation in memory until it becomes a demonstrable problem.
#FIXME: After having performed a great deal of online research, "gzip" appears
#to be the canonical go-to for small text file compression.
#FIXME: Hmmmm. No. Scratch that. We really need a filesystem-based approach.
#O.K.; so, here's the idea:
#
#* Shift the definitions of set_alias_documentation(), etc. to this component,
#  replacing all current calls to such functions with hard-coded additions to
#  such map globals. *DO IT.* Trust me. This is needed to ensure that such
#  functions are compiled into Zeshy's digest file.
#* *DON'T* redefine document_alias(), document_function(), or document_global().
#  Instead redefine set_alias_documentation(), etc. to write to disk rather to
#  such map globals in the precompile_zeshy_*() function defined below, thus
#  ensuring the redefinition of such functions is compiled into Zeshy's digest.
#
#Bam. Nice one, eh?
#FIXME: Ensure this is performed in, say, "main":
#
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation

# ....................{ DOCUMENTERS ~ alias                }....................
set_function_documentation document_alias '
void document_alias(string documentation)

If called when recompiling Zeshy''s user digest file, document the alias
prefixing the passed string with such string; else, do nothing.
'
function document_alias() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one documentation string'
    local documentation="${1}"

    # If such documentation is prefixed by an alias prototype, match the
    # relevant alias name from such prototype. While zsh permissively allows
    # alias name declarations to be quoted and hence contain arbitrary
    # characters as with functions, such aliases are not runnable: e.g.,
    #
    #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
    #   >>> o\ w\ s
    #   zsh: command not found: o w s
    #
    # For simplicity, use a similar glob expression as document_function().
    if [[ "${documentation}" ==\
        (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
    then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
    else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
    fi
}

# ....................{ DOCUMENTERS ~ function             }....................
#FIXME: Define a new document_function_glob() or
#document_function_sans_filename_globbing() or
#document_function_and_disable_filename_globbing(). Yes, the latter. While
#verbose, that's not necessarily a bad thing in this case, as such function
#dramatically alters function parsing. In any case, such function should
#define a new alias of the same name expanding as follows:
#
#    alias ${function_name}="noglob ${function_name}"
#
#Test if such alias already exists before doing so, in which case throw an
#exception or perhaps merely print a warning. (Nah, exception!)
#FIXME: It'd be great to support a distinction between standard output and
#error return values in function prototypes. How about something resembling:
#
#    # Function returning a string of standard output and no standard error.
#    [string, void] do_something(void)
#
#    # Or perhaps the more verbose:
#    [stdout: string, stderr: void] do_something(void)
#
#    # Actually, we could support both (obviously), which we should do. Ah;
#    # actually, we should probably just add such "stdout:" and "stderr:"
#    # labels on printing human-readable documentation to users, yes? Ah;
#    # perhaps not. It'd certainly be more intelligible to developers browsing
#    # the code to see "[stdout: string, stderr: void]" versus the former.
#    # The more verbose version also lends itself well to specifying exit
#    # status, as below.
#
#Since most functions return no standard error, retain support for shorthand:
#
#    # Same as above, shorthand.
#    string do_something(void)
#
#While most functions return 0 exit status, some do not. How about this:
#
#    # Function returning a string of standard output and no standard error
#    # and non-zero exit status on failure.
#    [string, void, boolean] do_something(void)
#
#    # Or, again:
#    [stdout: string, stderr: void, status: boolean] do_something(void)
#
#Status may either be "void" (i.e., always returns 0), "boolean" (i.e.,
#either returns 0 or 1), or "integer" (i.e., returns a variety of statuses.
#
#Ah! Another way in which the labels are demonstrably superior: in may cases,
#we'll want to specify "stdout" and "status" but not "stderr". So, that's just:
#
#    [stdout: string, status: boolean] do_something(void)
#
#Naturally, order no longer matters. Sweet! I'm thinking we *ABSOLUTELY*
#shouldn't support the abbreviated "[stdout, void, boolean]" style, yes? Far too
#much ambiguity and head-scratching.
#FIXME: The specification below has become sufficiently complex to warrant a BNF.
#I know, I know. But we'll make it simple and concise, with adequate commenting.
#There's really no better way.

#FIXME: Document prototype syntax, including "[or]" delimiters.
set_function_documentation document_function '
void document_function(string documentation)

Document the function named in the function prototype prefixing the passed
documentation, whose syntax supports zsh features not commonly found in
conventional high-level languages (e.g., function name synonyms, tristate return
values). For completeness, we specify such syntax with a Parser Expression
Grammar (PEG):

    FunctionDocumentation <-- FunctionPrototype Whitespace+ FunctionDescription
    FunctionPrototype     <-- Whitespace* ReturnType Whitespace+ FunctionNames
                              Whitespace* Arguments
    FunctionDescription   <-- AnyCharacter*
    ReturnType            <-- Type | ReturnTypes
    Type                  <-- AlphanumericString
    ReturnTypes           <-- "[" Whitespace* (  ReturnCategoryType Whitespace*
                              "," Whitespace* )* ReturnCategoryType Whitespace*
                              "]"
    ReturnCategoryType    <-- ReturnCategory Whitespace* ":" Whitespace* Type
    ReturnCategory        <-- "stdout" | "stderr" | "status"
    FunctionNames         <-- (FunctionName Whitespace+ "[or]" Whitespace+)*
                               FunctionName
    FunctionName          <-- AlphanumericString
    Arguments             <-- "(" Whitespace* (  Argument Whitespace*
                              "," Whitespace* )* Argument Whitespace* ")"
    Argument              <-- Type Whitespace+ ArgumentName (Whitespace*
                              "="  Whitespace* ArgumentDefaultValue)?
    ArgumentName          <-- AlphanumericString
    ArgumentDefaultValue  <-- SingleQuotedString | DoubleQuotedString
    SingleQuotedString    <-- "''" (!"''" AnyCharacter)* "''"
    DoubleQuotedString    <-- ''"'' (''\"'' | (!''"'' AnyCharacter))* ''"''
    AlphanumericString    <-- (!(Whitespace | Punctuation) AnyCharacter)*
    Whitespace            <-- Space | Tab | Newline
    Punctuation           <-- "(" | ")" | "[" | "]" | "{" | "}" | "," | "=" |
                              ":" | "''" | ''"''

Such documentation thus consists of a function prototype and description
delimited by whitespace. The function prototype itself consists of one or more
return types, one or more function names, and zero or more function arguments
delimited by whitespace.

## Return Types

Return types in zsh are more involved than in conventional high-level languages.
All functions "return" exactly three values (in the abstract sense of "return"):
a string of standard output, a string of standard error, and a byte of exit
status. Zeshy documents such values in one of two ways:

* With a single type as in conventional high-level languages (e.g., "integer"),
  signifying such function to return a string of standard output convertible
  without error to such type, an empty string of standard error, and zero exit
  status (i.e., success). Since most functions only write to standard output and
  throw exceptions rather than return non-zero exit status on error, this
  shorthand notation simplifies most functions'' documentation.
* With a "["- and "]"-bracketed list of one to three ","-delimited key-value
  pairs (e.g., "[stdout: float, stderr: string, status: integer]". Keys are one
  of three case-insensitive strings:
  * "stdout", denoting a standard output return type.
  * "stderr", denoting a standard error return type.
  * "status", denoting an exit status return type.
  Values are the types such strings are convertible to without error (e.g.,
  "integer"). At least one such key-value pair must be specified. When
  unspecified, "stdout" and "stderr" both default to return type "void" (i.e.,
  the empty string) and "status" to "true" (i.e., zero exit status). Therefore,
  the return types default to "[stdout: void, stderr: void, status: true]".
  "stdout" and "stderr" return values may assume any type in addition to "void",
  signifying such function to return no standard output and/or error, as in C-
  like languages. "status" return values may assume only the following types:
  * "true", denoting a function that always succeeds, ignoring exceptions.
    Technically, "true" and "false" are values rather than types. Luckily, mere
    technicalities never stopped Zeshy.
  * "false", denoting a function that always fails. Since Zeshy implicitly
    throws exceptions on failure, this is generally unhelpful.
  * "boolean", denoting a function either returning exit status 0 on success or
    1 on failure. This typically implies such function to be a "tester."
  * "integer", denoting a function returning more than merely exit statuses 0
    and 1. GNU-specific "grep" is the canonical example, returning 0 on match,
    1 on no match, and 2 on error.

Hence, the following function prototypes are equivalent:

    float ukigumo(void)
    [stdout: float] ukigumo(void)
    [stdout: float, stderr: void] ukigumo(void)
    [stdout: float, status: true] ukigumo(void)
    [stdout: float, stderr: void, status: true] ukigumo(void)

ukigumo() accepts no arguments, returns a string convertible without error to a
float on standard output and no standard error, and always succeeds.

Tester functions returning only a boolean exit status and no standard output or
error should have a return type of "[status: boolean]". For example:

    [status: boolean] is_dir_too_terrible_to_behold(string dirname)

Since Zeshy provides aliases for returning and receiving returned lists and
maps, types "list" and "map" are technically acceptable as return types. Since
returning such types incurs a significant performance penalty, consider only
returning such types when such lists and maps are sufficiently small in size.
Note that "small" has yet to be rigorously defined!

## Function Names

Function names in zsh are also more involved than in conventional high-level
languages. All functions have at least (but possibly more than) one name,
declared at function declaration time with a typical whitespace-delimited list.
Zeshy documents such values with a case-insensitive "[or]"-delimited list.
Hence, the following zsh commands document a function with multiple names:

    document_function ''
    void name [or] synonym [or] pseudonym [or] anonym(void)

    A function callable as either name(), synonym(), pseudonym(), or anonym().
    ''
    function name synonym pseudonym anonym() { true }

## Function Arguments

Function arguments in zsh are unprototyped and hence arguably more involved
(though not necessarily beneficially) than in conventional high-level languages.
Zeshy documents such arguments with C-like syntax, with a "("- and ")"-bracketed
list of one or more ","-delimited argument declarations consisting of a
whitespace-delimited type and name followed by optional "=" and default value in
conventional zsh syntax (e.g., "(string the_ultimate, integer question = 42)").

Argument names should contain no whitespace or punctuation, much like real zsh
variable names. While argument names need not correspond to the actual variable
name (if any) the function implementation copies such argument into, this is
generally considered good form.

Argument types are any single scalar types (e.g., "boolean", "integer"), thus
excluding "void", "list", and "map". Since argument lists are lists, consider
passing read-only lists as arguments and lists to be modified as the names of
such lists. While maps can be packed into argument lists, consider always
passing maps as the names of such maps. When passing the name rather than value
of variables, consider mangling *ALL* variable names declared in the function
implementation in a function-specific manner to avoid accidentally overriding
externally with internally declared variables. Zeshy heuristically mangles by
appending "__" followed by the first letter of each word in the function name,
which suffices for most purposes. For readability, avoid mangling documented
argument names. For example:

    document_function ''
    void set_list_to_raspberry_hybrids(string list_name, string flavor)

    Set the passed list to all known raspberry hybrids of the passed flavor.
    ''
    function set_list_to_raspberry_hybrids() {
        # Validate passed arguments.
        die_unless_args_2 ''expected one list name and one raspberry flavor''
        string list_name__sltrh="${1}" flavor__sltrh="${@[-1]}"
        die_unless_list "${list_name__sltrh}"

        # Set such list.
        if is_string_equals "${flavor}" acidic
        then set_list_to_evaluation "${list_name__sltrh}" ''( loganberry )''
        else set_list_to_evaluation "${list_name__sltrh}" ''( tayberry )''
        fi
    }

Default argument values are any valid right-hand side of a scalar assignment,
including double-quoted strings nesting arbitrarily deep process substitutions
(e.g., "(string dirname = "$(is_superuser and "/o" or "$(get_dir)")")"). For
safety, Zeshy *NEVER* evaluates such values, which may thus contain executable
code known to have dangerous side-effects. (Naturally, this is not a good idea.)

Functions accepting no arguments should state "(void)", as in C-like languages.

Functions accepting arbitrarily many arguments of the same type should fully
specify the first such argument including default value followed by an ellipse.
If a default value is given, zero or more such arguments may be passed, which if
zero default to a single argument of such value; else, one or more such
arguments must be passed. Such arguments may be preceded and followed by
arbitrary other arguments. For example:

    document_function ''
    void uhoh(integer mtime, string dirname1 = "/", ..., boolean is_recursive)

    A function accepting an integer, zero or more dirnames defaulting to "/" if
    no such strings are passed, and a boolean -- usually doing something rather
    dangerous.
    ''
    function uhoh() {
        # Validate passed arguments.
        die_unless_args_2_or_more\
            ''expected one integer, optional dirnames, and one boolean''
        string mtime="${1}" is_recursive="${@[-1]}"
        die_unless_integer "${mtime}"
        die_unless_boolean "${is_recursive}"

        # Remove such integer and boolean from the argument list. All remaining
        # arguments, if any, are dirnames.
        shift_arg
        pop_arg

        # If no arguments remain, default to "/".
        is_args or set_args "/"

        # Do something rather dangerous.
        print "Mu-haha! [${mtime}]"
        if is_boolean_true "${is_recursive}"
        then ls -R -- "${@}"
        else ls    -- "${@}"
        fi
    }

Such types should correspond to the actual variable type (if
any) the function implementation copies such argument into.

values are *NEVER* evaluated by Zeshy and hence may contain executable code that
could, whenever evaluated, have dangerous side-effects. 

assigning each argument a
mandatory name and type and optional default value.

While argument names need
not correspond to the variable name (if any) the function implementation copies
such argument into, argument types and optional default value should, of course.



(e.g., "function name synonym pseudonym nom_de_guerre nom_de_plume() { true }",
a function callable as either name(), synonym(), pseudonym(), nom_de_guerre(),
or nom_de_plume()).


by listing all such names in whitespace-
delimited fashion (e.g., .
at least one name  also arbi:
a
Most function names as in conventional high-level languages (e.g., "integer"),

* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
  Technically, all zsh functions "return" three values (in the low-level sense):
  a string of standard output, a string of standard error, and an exit status.
  Practically, most zsh functions avoid writing to standard error and only .

For functions with only one name, call this function as follows:

    document_function ''
    RETURN_TYPE FUNCTION_NAME(
        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)

    HUMAN_READABLE_DOCUMENTATION
    ''
    function FUNCTION_NAME() {
        FUNCTION_IMPLEMENTATION
    }

For functions with multiple names, call this function as follows:

    document_function ''
    RETURN_TYPE FUNCTION_NAME_1 [or] FUNCTION_NAME_2 [or] ... FUNCTION_NAME_N(
        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)

    HUMAN_READABLE_DOCUMENTATION
    ''
    function FUNCTION_NAME_1 FUNCTION_NAME_2 ... FUNCTION_NAME_N() {
        FUNCTION_IMPLEMENTATION
    }

Capitalized strings above denote the following semantics:

* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
  Technically, all zsh functions "return" three values (in the low-level sense):
  a string of standard output, a string of standard error, and an exit status.
  Practically, most zsh functions avoid writing to standard error and only .
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  FIXME: Rewrite this section after implementing the above additions. It gets a
  bit complicated, but... heck, it''ll definitely be worth it.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* "FUNCTION_NAME_1", the first name for such function. While most functions have
  only one name, zsh permits additional names to be declared in a function
  declaration with the above whitespace-delimited syntax.
* "FUNCTION_NAME_2", the second name for such function. While most functions have

  As in C-like languages, type "void" signifies such function to return no
  standard output and/or error.

Function prototypes follow the familiar "RETURN_TYPE FUNCTION_NAME 

familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:

* 
  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)

While zsh does not support function prototypes, this function
adopts conventional high-level language function prototype syntax for documentation-specific purposes.
While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
appropriately .
the return type, argument types, or argument order of 
at runtime, it can convert such prototype into 

named by the C-style function prototype of the passed
documentation string. Since zsh permits no function prototyping, this function
adopts conventional high-level language function prototype syntax for documentation purposes.
While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
appropriately .
the return type, argument types, or argument order of 
at runtime, it can convert such prototype into 

syntax does *NOT* constitute 
While such syntax does *NOT* constitute an enforcable
familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:

* 
  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)

, which must thus be prefixed  with such documentation. 

This function is deleted by Zeshy immediately before compiling its user digest
file and hence only callable from the global context of Zeshy components.
'
function document_function() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one documentation string'
    local documentation="${1}" function_name
    local -a function_names

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
    if [[ "${documentation}" ==\
        (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
        # Attempt to split such function name on " [or] " delimiters.
        function_name="${match[1]}"
        function_names=( "${(s: [or] :)function_name}" )

        # If such function name contains no such delimiters, document as is.
        if (( ${#function_names} == 1 ))
        then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name}]="${documentation}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
        else
            for function_name_split ("${function_names[@]}") {
#                   print "function name split: ${function_name_split}"
                ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split}]="${documentation}"
            }
        fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
    else die "help string \"${documentation[1,40]}...\" not prefixed by a function prototype"
    fi
}

# ....................{ DOCUMENTERS ~ global               }....................
set_alias_documentation document_global '
void document_global<string documentation>

If called when recompiling Zeshy''s user digest file, globally export the global
prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
prefixing the passed string *AND* document such global with such string; else,
do nothing.
'
alias document_global='
{
    # Localize the passed herestring.
    local documentation__dg="$(< /dev/stdin)"

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    #
    # Else throw an exception with a portion of such documentation.
    [[ "${documentation__dg}" ==\
        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
        die "help string \"${documentation__dg[1,40]}...\" not prefixed by a variable declaration"

    #FIXME: If such global has been declared, we should probably print a
    #warning to standard error if its declared type differs from the
    #documentation-declared type. The implementation is a bit tedious,
    #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
    #dynamically constructed from its converse for performing efficient
    #lookups. Clearly, not a priority for the moment.

    # If such global has not yet been declared, do so. Prefer globals
    # "${match[1]}" and "${match[2]}" to human-readable local variables to
    # avoid polluting the local shell environment any further. See
    # is_variable() for implementation details.
    [[ -n "${(P)match[2]+x}" ]] || {
        # Runnable declaring variables of such type.
        declarator__dg="${match[1]}_global_export"

        # If such runnable does not exist, throw an exception. See
        # is_runnable() for implementation details.
        whence -- "${declarator__dg}" &>/dev/null ||
            die "\"${match[1]}\" not a recognized type"

        # Declare such global.
        "${declarator__dg}" "${match[2]}"
    }

    # Document such global.
    ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${match[2]}]="${documentation__dg}"
#   print "function name: ${match[1]}"
} <<<'

# --------------------( WASTELANDS                         )--------------------
# ....................{ GLOBALS                            }....................
#FUXME: This is terrible. Eliminate such global entirely; instead, simply
#attempt to run a dynamically constructed command
#${variable_type}_global_export().

#set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#map ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#
#Map variable type to the declarator (i.e., command prefix) declaring and
#exporting globals of such type.
#'
#typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#    # String types.
#    string    'export'
#    boolean   'export'
#    character 'export'

    # Integer types.
#    integer         'export -i'
#    file_descriptor 'export -i'
#
    # Float types.
#    float 'export -F'
#
#    # List types.
#    list     'export -a'
#    list_set 'export -Ua'
#
#    # While "export -a" succeeds (as above), "export -A" fails with error.
#    # Hence, revert to builtin typeset().
#    map 'typeset -Agx'
#)

        # If such global''s type is not a Zeshy-specific type, throw an
        # exception. See is_map_key() for implementation details.
#       (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#           die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
#       ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

# ....................{ MAIN                               }....................
#FUXME: Not quite right. We also want to undefine all of the above aliases and
#functions before Zeshy digest compilation, suggesting we create a new
#precompilation hook performing all such undefinitions. I can't imagine that
#order matters, there; so, just add a customary precompilation hook here.

#run_hook_on_zeshy_precompile precompile_zeshy_documentation_undefine

#document_function '
#void precompile_zeshy_documentation_undefine(void)
#
#Undefine all documentation-defining runnables (e.g., set_alias_documentation(),
#document_global()) *AFTER* sourcing all Zeshy components calling such runnables
#and hence having defined all available documentation. To  Zeshy caches 
#The documentation such runnables
#'
#function precompile_zeshy_documentation_undefine() {
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
#}

#FUXME: Rename "[or]" to "[or]" everywhere. Avoid simply "or", as that isn't
#subject to global replacement.
# For simplicity, this function ignores 
# such low-level distinctions, accepts
# (e.g., "boolean", "list", "string"). If 
#
#While most functions have only one name, zsh does permit additional names to be
#declared in function declarations with the above whitespace-delimited syntax.
#
#Capitalized strings denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific type of variable returned by such function
#  (e.g., "boolean", "list", "string").
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.

# *BEFORE* compiling Zeshy''s user digest file
# (i.e., at the top level of Zeshy components and in precompilation hooks).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Define document_function() before document_alias(), which documents itself
# with the former function.
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias document_alias=':' document_function=':' document_global=':'

# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_DOT_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)
