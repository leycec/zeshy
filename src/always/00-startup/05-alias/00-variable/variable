#!/usr/bin/env zsh
# ====================[ variable                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle variable declarator aliases.

# ....................{ DECLARATORS                        }....................
document_alias '
void undefine_variable_from<string variable_name1, string variable_name2, ...>

Undefine the passed variables in the caller''s context. If such context is a
global shell or script, undefine such variables globally; otherwise, undefine
such variables locally. Undefining globals thus requires calling this alias
from a global context (i.e., *NOT* from within a function).

Due to zsh constraints, variable names must be passed whitespace-delimited in a
single shell word (e.g., single- or double-quoted string).
'
alias undefine_variable_from='{
    # Validate passed arguments.
    list args__uv; set_list_to_stdin_split_on_words args__uv
    (( ${#args__uv} >= 1 )) or die "expected at least one variable name"

    # For safety, destructively coerce such variables to writable local strings.
    # When passed read-only variables, this prevents zsh from failing on the
    # subsequent call to unset() with "zsh: ${variable_name} read-only".
    typeset +r -- "${args__uv[@]}"

    # Unset such variables.
    unset -- "${args__uv[@]}"
} <<<'

# ....................{ DECLARATORS ~ float                }....................
# zsh already provides builtin float() for declaring local floats.

#FIXME: Rename to float_with_fractional_digit_count().
document_alias '
void float_with_fractional_digit_length<integer length, string variable_name>

Declare the passed float (i.e., fractional number) locally, constrained to the
passed number of fractional digits.
'
alias float_with_fractional_digit_length='local -F'  # "float" does *NOT* suffice

document_alias '
void float_global<string variable_name1, string variable_name2, ...>

Declare the passed float globally but *NOT* exported to the calling shell.
'
alias float_global='float -g --'

document_alias '
void float_global_export<string variable_name1, string variable_name2, ...>

Declare the passed float globally exported to the calling shell.
'
alias float_global_export='export -F --'

document_alias '
void float_constant_global_export<string variable_name1, string variable_name2, ...>

Declare the passed float constant globally exported to the calling shell.
'
alias float_constant_global_export='export -Fr --'

# ....................{ DECLARATORS ~ list                 }....................
# Due to current inadequacies in zsh, lists and maps cannot be initialized or
# declared to be read-only at declaration time. To perform the latter, consider
# calling freeze_variable() after initializing such list or map after declaring
# such list or map. While cumbersome, zsh currently affords no alternatives:
#
#     >>> list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )
#     >>> freeze_variable sequence

document_alias '
void list<string variable_name1, string variable_name2, ...>

Declare the passed list (i.e., sequential array) locally.
'
alias list='typeset -a --'

document_alias '
void list_global<string variable_name1, string variable_name2, ...>

Declare the passed list (i.e., sequential array) globally but *NOT* exported to
the calling shell.
'
alias list_global='typeset -ag --'

document_alias '
void list_global_export<string variable_name1, string variable_name2, ...>

Declare the passed list (i.e., sequential array) globally exported to the
calling shell.
'
alias list_global_export='export -a --'

# ....................{ DECLARATORS ~ list set             }....................
document_alias '
void list_set<string variable_name1, string variable_name2, ...>

Declare the passed list set (i.e., sequential array ignoring duplicate values)
locally.
'
alias list_set='typeset -Ua --'

document_alias '
void list_set_global<string variable_name1, string variable_name2, ...>

Declare the passed list set (i.e., sequential array ignoring duplicate values)
globally but *NOT* exported to the calling shell.
'
alias list_set_global='typeset -Uag --'

document_alias '
void list_set_global_export<string variable_name1, string variable_name2, ...>

Declare the passed list set (i.e., sequential array ignoring duplicate values)
globally exported to the calling shell.
'
alias list_set_global_export='export -Ua --'

# ....................{ DECLARATORS ~ list tie             }....................
document_alias '
void list_tied_string<
  string text_name, string list_name, string separator = ":">

Declare a string with the passed name "tied" to the list with the passed name.
This resembles a Perl tie by joining the list''s elements with the passed
separator, defaulting to ":", into a string and updating that string on each
update (i.e., change) to that list: e.g.,

    >>> list_tied_string arroyo array " "
    >>> list array; array=( cuidad juarez )
    >>> print "${arroyo}"
    cuidad juarez
    >>> array=( el paso )
    >>> print "${arroyo}"
    el paso

Importantly, note zsh leaves the list-tied string initially unset -- even if
the list to which it is tied is set! Hence, list-tied strings should usually
be declared prior to the list to which they tie. Yes, this is unintuitive.
'
alias list_tied_string='typeset -T'

# ....................{ DECLARATORS ~ map                  }....................
# Due to current inadequacies in zsh, maps must be externally initialized: e.g.,
#
#     >>> map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

document_alias '
void map<string variable_name1, string variable_name2, ...>

Declare the passed map (i.e., associative array) locally.
'
alias map='typeset -A --'

document_alias '
void map_global<string variable_name1, string variable_name2, ...>

Declare the passed map (i.e., associative array) globally but *NOT* exported to
the calling shell.
'
alias map_global='typeset -Ag --'

document_alias '
void map_global_export<string variable_name1, string variable_name2, ...>

Declare the passed map (i.e., associative array) globally exported to the
calling shell.
'
# While "export -a" succeeds, "export -A" oddly fails with error. *shrug*
alias map_global_export='typeset -Agx'

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename "list_set" to "listset" everywhere, for clarity.
#FUXME: Rename to string_tied_list<> to better corresponding to argument order.
#FUXME: This is terrible. Entirely replace 
#document_alias '
#void unfreeze_variable(string variable_name1, string variable_name2, ...)
#
#Unfreeze the passed variables in the current context. This destructively
#destroys such variables'' type and value and is intended to be called only
#prior to calling undefine_variable_from(). Don''t ask; don''t tell.
#'
#alias unfreeze_variable='typeset +r --'

    # If not doing so, calling this
#function on read-only variables causes zsh to fail with ungainly errors
#resembling: "zsh: VARIABLE_NAME read-only".
# for formatting the string
# representation of such integer in that base when output: e.g.,
