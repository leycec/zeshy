#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core variable aliases.
/---

# ....................{ DECLARATORS                        }....................
declare_function_with_stdin <<'/---'
void undefine_variable(string variable_name)

Undefine the passed variables in the caller's context. See
undefine_variable_from() for further details: e.g.,

.undefine_variable()
==========================================
[source]
------------------------------------------
>>> string_constant on_allegiance=\
...    "If a thousand men were not to pay their tax-bills this year, that would
...     not be a violent and bloody measure, as it would be to pay them, and
...     enable the State to commit violence and shed innocent blood. This is, in
...     fact, the definition of a peaceable revolution, if any such is possible.
...     If the tax-gatherer, or any other public officer, asks me, as one has
...     done, \"But what shall I do?\" my answer is, \"If you really wish to do
...     anything, resign your office.\" When the subject has refused allegiance,
...     and the officer has resigned his office, then the revolution is
...     accomplished."
>>> undefine_variable on_allegiance
>>> print_string   "${on_allegiance}"
zsh: on_rules: parameter not set
------------------------------------------
==========================================
/---
# See undefine_variable_from() for further details.
alias undefine_variable='{
    string variable_name__uv; set_string_to_stdin variable_name__uv
    die_unless_variable_name "${variable_name__uv}"
    typeset +r -- "${variable_name__uv}"
    unset --      "${variable_name__uv}"
} <<<'

#FIXME: Rename to undefine_variables_from().
declare_function_with_stdin <<'/---'
void undefine_variable_from(string variable_name1, string variable_name2, ...)

Undefine the passed variables in the caller's context. If this is either the
command line or the top level of a shell script, undefine such variables
globally; else, undefine such variables locally. Undefining globals thus
requires expanding this alias from a global context (i.e., _not_ from within a
function body).

By `zsh` constraint, variable names must be passed as whitespace-delimited
substrings of a single- or double-quoted string: e.g.,

.undefine_variable_from()
==========================================
[source]
------------------------------------------
>>> string_constant on_rules="Any fool can make a rule"
>>> string_constant on_fools="And any fool will mind it."
>>> undefine_variable_from 'on_rules on_fools'
>>> print_string "${on_rules}"
zsh: on_rules: parameter not set
------------------------------------------
==========================================
/---
alias undefine_variable_from='{
    # Validate passed arguments.
    list args__uvf; set_list_to_stdin_words args__uvf
    (( ${#args__uvf} >= 1 )) or die "expected at least one variable name"

    # For safety, destructively coerce such variables to writable local strings.
    # When passed read-only variables, this prevents zsh from failing on the
    # subsequent call to unset() with "zsh: ${variable_name} read-only".
    typeset +r -- "${args__uvf[@]}"

    # Unset such variables.
    unset -- "${args__uvf[@]}"
} <<<'

# --------------------( WASTELANDS                         )--------------------
#If such string or list were previously 
#
#Since such declaration  Such string and list should _not_ be declared prior to
#expanding this alias.
#
#The closest analogues are (arguably) tied hashes in Perl. : e.g.,
#
#Changing such string sets such list to the result of
#splitting such string on such separator; likewise, changing such list sets such
#string to the result of joining such list on such separator.
#
#On changing such string, such list is set to the result of
#This resembles a Perl tie by joining such list's elements with the passed
#separator (defaulting to `:`) into a string and updating that string on each
#update (i.e., change) to that list: e.g.,
#FUXME: This is terrible. Can we hack around this?
#Such string is initially unset -- even if
#the list to which it is tied is set! Hence, list-tied strings should usually
#be declared prior to the list to which they tie. Yes, this is unintuitive.

#FUXME: "typeset -T" expects a string name and then a list name. Fix the
#implementation below.
#FUXME: Define a new undefine_variable() alias for undefining only a single
#variable. Simpler name and calling method; hence, separate alias.
#   string args__uv; set_list_to_stdin_words args__uv
#   (( ${#args__uv} == 1 )) or die "expected one variable name"
#   typeset +r -- "${args__uv[1]}"
#   unset --      "${args__uv[1]}"

#FUXME: Rename "list_set" to "listset" everywhere, for clarity.
#FUXME: Rename to string_tied_list<> to better corresponding to argument order.
#FUXME: This is terrible. Entirely replace 
#declare_alias '
#void unfreeze_variable(string variable_name1, string variable_name2, ...)
#
#Unfreeze the passed variables in the current context. This destructively
#destroys such variables'' type and value and is intended to be called only
#prior to calling undefine_variable_from(). Don''t ask; don''t tell.
#'
#alias unfreeze_variable='typeset +r --'

    # If not doing so, calling this
#function on read-only variables causes zsh to fail with ungainly errors
#resembling: "zsh: VARIABLE_NAME read-only".
# for formatting the string
# representation of such integer in that base when output: e.g.,
