#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define list-specific aliases.

# ....................{ CONVERTERS                         }....................
# While *NOT* an alias and hence otherwise inapplicable to this component, this
# function's implementation is inseparable from that of alias
# set_list_to_string_piped<>. For the love of Elder Gods, define both together.

declare_function '
string convert_list_to_string(string list_name)

Get a string losslessly encapsulating the contents of the passed list. Call
set_list_to_string_piped() to restore such string back into such list. See
set_list_to_string_piped() and return_list<> for further details.
'
function convert_list_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Convert such list. Dismantled, this is:
    #
    # * '1:-list' expands to the passed list name or 'list' if no such name
    #   was passed.
    # * 'P' transitively expands this name to the actual name of the desired
    #   associative list in the caller's scope.
    # * '@' interprets this expansion as a list rather than scalar.
    # * 'qq' protectively embeds all reserved shell characters in such names
    #   and values in single quotes.
    print_string "${(qq@P)list_name}"
}

# ....................{ RETURNERS                          }....................
declare_alias '
string return_list<string list_name>

Return the passed list from the current function or script. Specifically:

* Losslessly convert such list into a string.
* Print such string to standard output.
* Return from such function or script with zero exit status (i.e., success).

Callers of such function or script may consider calling
set_list_to_string_piped<> to convert such string back into the original list.

*CAVEAT EMPTOR*: while stable, this alias performs at least three complete list
copies assuming subsequent expansion of set_list_to_string_piped<> and two list
copies otherwise. In other words, this alias is inefficient with large lists.
Where efficiency is a concern, refactor list functions to accept list names as
passed arguments and expand such lists with parameter expansion flags "(@P)".
'
alias return_list='
{
    # Validate passed arguments.
    list  args__rl; set_list_to_stdin_words args__rl
    (( ${#args__rl} == 1 )) || die "expected one list name"

    # Return such list.
    convert_list_to_string "${args__rl[1]}"
    return_true
} <<<'

# ....................{ SETTERS                            }....................
#FIXME: Extend to restore_map().
#FIXME: Fix now-broken examples in "README.dev". Actually, consider removing
#such examples and associated caveats altogether.

declare_alias '
void set_list_to_string_piped<string list_name>

Convert the string piped on standard input into the passed list. Such string
must be of the same format output by convert_list_to_string() and return_list<>
(e.g., parameter expansion flags "(qq)"). While such string must be piped into
this alias, such list name must be passed after this alias: e.g.,

    # Return a stringified list.
    >>> function get_minerals() {
    ...     list asbestos; asbestos=( nephrite porphyry glauconite mafic )
    ...     return_list asbestos
    ... }

    # Restore such string back into such list.
    >>> get_minerals | set_list_to_string_piped asbestos_copy
    >>> print_string "${asbestos_copy[1]}"
    nephrite
'
alias set_list_to_string_piped='{
    # If standard input contains no newline, throw an exception. Avoid
    # calling is_string_contains() which performs two implicit string
    # copies.
    string list_string__sltsp; list_string__sltsp="$(< /dev/stdin)"
    is  "${list_string__sltsp}" == *${ZESHY_ASCII_NEWLINE}* si or
        die "expected a piped string"

    # For efficiency, remove the suffixing herestring zsh appended to
    # standard input "in-place". Hereafter, "/dev/stdin" contains the piped
    # stringified list and ${match[1]} the target list name. Dismantled,
    # this is:
    #
    # * "%", non-greedily removing such suffix.
    # * "(#b)", enabling group capturing.
    # * "(*)", matching the passed list name into ${match[1]}.
    list_string__sltsp="${list_string__sltsp%(#b)${ZESHY_ASCII_NEWLINE}(*)}"
    string list_name__sltsp="${match[1]}"

    # Declare such list if not already. Unfortunately, such declaration is
    # complicated by an unreported and absurdly subtle zsh issue: variables
    # declared in blocks resembling "... | { ... #HERE! ... } <<< ..." are not
    # declared properly without printing the type of such variables. Apparently,
    # printing to the bit bucket "/dev/null" suffices! (Submit a bug report.)
    is_list "${list_name__sltsp}" or {
        list ${list_name__sltsp}
        print_string "${(tP)list_name__sltsp}" >&/dev/null
    }

    # Convert such string to such list.
#   print_string "list: ${list_string__sltsp}"
    set_list_to_evaluation "${list_name__sltsp}" "\${(z)list_string__sltsp}"
} <<<'

#FIXME: Absurdly helpful "unit tests". Preserve until implementing proper tests.
#function get_minerals() {
#    list asbestos; asbestos=( nephrite 'porph yry' "\"glauc\" 'o' ni\"te" mafic )
#    return_list asbestos
#}
#function test_minerals() {
#    get_minerals | set_list_to_string_piped asbestos_copy
#    print_string "asbestos (1): ${asbestos_copy[1]}"
#    print_string "asbestos (2): ${asbestos_copy[2]}"
#    print_string "asbestos (3): ${asbestos_copy[3]}"
#}

# ....................{ APPENDERS                          }....................
declare_alias '
void append_list_with_list_locally_from<
  string list_name,
  string append_list_name1, append_list_name2, ...>

Declare a new local list with the first passed list name containing all passed
lists in the same order. When the first passed list has not already been locally
declared in the current function or script, this effectively shadows the first
passed list with a list containing the same elements as such list *AND* also all
elements of the other passed lists. This is especially useful for temporarily
appending a global list with function-specific elements. Due to zsh constraints,
list names must be passed whitespace-delimited in a single shell word (e.g.,
single- or double-quoted string): e.g.,

    # Define a GNU/Hurd-specific path listing function deferring to list_path().
    >>> function list_path_on_gnu_hurd() {
    ...     append_list_with_list_locally_from\
    ...         "ZESHY_LS_OPTIONS ZESHY_LS_OPTIONS_IF_OS_GNU_HURD"
    ...     list_path "${@}"
    ... }
'
alias append_list_with_list_locally_from='
{
    # Validate passed arguments.
    list  args__aplwll; set_list_to_stdin_words args__aplwll
    (( ${#args__aplwll} >= 2 )) or die "expected at least two list names"

    # Make a temporary local list containing all passed lists'' elements.
    list list__aplwll
    for list_name__aplwll ("${args__aplwll[@]}") {
        die_unless_list "${list_name__aplwll}"
        list__aplwll+=( "${(@P)list_name__aplwll}" )
    }

    # Shadow the first passed list with such temporary list.
    list "${args__aplwll[1]}"
    set_list_to_list "${args__aplwll[1]}" list__aplwll
#   print "list__aplwll: ${list__aplwll[@]}"
#   print "target list: ${(@P)args__aplwll[1]}"
#   print "target list name: ${args__aplwll[1]}"

    # Delete such temporary list to avoid polluting the caller''s namespace.
    undefine_variable_from list__aplwll
} <<<'

# --------------------( WASTELANDS                         )--------------------
#FUXME: Shift to "map".
#declare_alias '
#string get_map_keys_sorted_lexically_ascending<string map_name>
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#alias get_map_keys_sorted_lexically_ascending='
#{
#    # Validate passed arguments.
#    list  args__lmksla; set_list_to_stdin_words args__lmksla
#    (( ${#args__lmksla} == 1 )) or die "expected one map name"
#    string map_name__lmksla="${1}"
#    die_unless_map "${map_name__lmksla}"
#
#    # List such keys.
#} <<<'

#   string list_name__aplwll="${args__aplwll[1]}"
#   shift_list "${list_name__aplwll}"
#   die_unless_list "${list_name__aplwll}"

#Shadow the first passed list with a local list of the same name containing the
#contents of all passed lists in the passed order.

    # Validate passed arguments.
#   die_unless_args_2_or_more "expected at least two list names"
#   string list_name="${1}"
#   shift_arg
#   die_unless_list "${list_name}"

    # Create a temporary list containing the first passed list appended by all
    # remaining passed lists.
#   list __appended_list__; __appended_list__=( "${(@P)list_name}" )
#   for append_list_name ("${@}") {
#       die_unless_list "${append_list_name}"
#       __appended_list__+=( "${(@P)append_list_name}" )
#   }

    # Shadow the first passed list with the temporary list.
#   eval "list ${list_name}; ${list_name}=( \"\${__appended_list__[@]}\" )"

    # Delete the temporary list to avoid polluting the caller namespace.
#   unset __appended_list__

#* The first such list appended by all remaining passed lists.
#FUXME: Great, I think. Test. If working, shift to a new "00-alias/list"
#component.
#FUXME: Rename to set_list_to_string() and change the "*" below to "1". (Unless
#you can think of a definable reason to accept multiple strings? I can't. The
#list contents should *ALWAYS* be a single string, right?)
#FUXME: Oh, boy; this is great, but requires a bit of documentation revisions
#above and implementation revisions below. Basically.........................
#it turns out that when you both pipe input *AND* herestring input into a block,
#zsh appends the latter to the former. Makes sense, as the former does lexically
#appear prior to the latter. So, we treat the last line of block input as the
#passed list name and all other lines as list content. Hence, the function
#prototype is effectively:
# void set_list_to_string_piped<string list_name>
#...with the caveat that the string must be piped into such alias. Phew! Sweet.
    #FUXME: ACTUALLY IMPLEMENT THIS. See above. Note that we *REALLY* want to
    #avoid list copies here; hence, we should probably defer copying from
    #/dev/stdin by editing the final line below to... oh. Right. We can''t
    #defer, since we have to split it on newline here. Incidentally, do that
    #using a (hopefully) efficient %%-style parameter glob enabling "(#b)",
    #which should both remove the passed list name (leaving only the piped
    #string) *AND* capture such name into ${match[1]}.
    #FUXME: I suspect module "mapfile" might yield the most efficient
    #implementation here, even considering the overhead of loading and unloading
    #such module for each call to this function. We''ll have to verify that
    #mapfile actually works for special device files, but... it''s worth a try,
    #if only for the efficiency gains. (This also helps avoid a copy into a
    #local variable, which is very nice.)

#   eval "${list_name__sltsp}=( \${(z)list_string__sltsp} )"
#   set_list_to_evaluation\
#       "${list_name__sltsp}" "\${(Qz):-\${list_string__sltsp}}"
#   string list_name__sltsp=asbestos_copy
    # If such list was not previously declared, throw an exception. While most
    # such aliases declare such variable if not previously declared, doing so
    # here is sadly unfeasible due to an unreported zsh issue: 
#   integer hmm
#   is_variable_integer hmm or print okokok
#   die_unless_list "${list_name__sltsp}"

#       run_command_silent print_string "${(tP)list_name__sltsp}"
#       print "hello"
#       eval "${list_name__sltsp}=( )"
#   is_list "${list_name__sltsp}" or eval "list ${list_name__sltsp}"
#   list ${list_name__sltsp}
#   list asbestos_copy
#   print_string "asbestos_copy type: ${(tP)list_name__sltsp}"
#   print_string "asbestos_copy type: ${(tP)list_name__sltsp}"
#   print_string "asbestos_copy type: $(get_variable_type ${list_name__sltsp})"
#   list asbestos_copy; asbestos_copy=( )
#   is -n ${asbestos_copy+x} si
#   get_variable_type asbestos_copy
#   print "${(tP)list_name__sltsp}"
#   is_list asbestos_copy or print "uhoh."
#   is_list "${list_name__sltsp}" or print "hmmm"
#   asbestos_copy+="ok"
#   print "asbestos_copy: ${asbestos_copy[1]}"
#   print_string "list name: ${list_name__sltsp}"
#   die_unless_list "asbestos_copy"
#   die_unless_list "${list_name__sltsp}"

    # Temporarily load module "mapfile" and ensure such module is unloaded prior
    # to returning, even if an exception is thrown. See run_command_with_mapfile() for
    # further details.
#   } always {
#       unload_zsh_module zsh/mapfile
#   }
#   load_zsh_module zsh/mapfile
#       is "${mapfile[/dev/stdin]}" == *${ZESHY_ASCII_NEWLINE}* si or
# For efficiency, avoid a list copy.
# To avoid
        # polluting the local shell environment, reference such values as is
        # rather than copying such values into human-readable local variables.
#   convert_list_to_string asbestos
# >>> list asbestos_copy
    # Validate passed arguments.
#   list args__sltsc; set_list_to_stdin_words args__sltsc
#   (( ${#args__sltsc} == 1 )) ||
#       die "expected one list name and at least one string"
#   string list_name__sltsc="${args__sltsc[1]}"
#   shift_list args__sltsc

    # Declare such list if not already.
#   is_list "${list_name__sltsc}" or eval "list ${list_name__sltsc}"

    # Convert such string to such list. For efficiency, this avoids a list copy.
#   set_list_to_evaluation "${list_name__sltsc}" "\${(Qz):-\${args__sltsc[*]}}"

#FUXME: Great! Now fixup documentation both here and in
#convert_list_to_string().
#FUXME: Shift convert_list_to_string() here and convert into an alias. It's not
#necessary, but vastly improves understandability and code maintenance to keep
#the two definitions together.
# void set_list_to_string_piped(string list_name, string list_contents)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
# See convert_list_to_string() for further details.

#Such constraints are
#(e.g., parameter expansion flags "(qq)"). Due to zsh constraints, such string
#must be piped into this alias
#See convert_list_to_string() and return_list<> for further
#details, caveats, and examples.

#Avoid calling set_list_to_evaluation(),
    # which incurs yet another expensive list copy.
#   eval "${list_name_sltsc}=( \${(Qz):-\${args_sltsc[*]}} )"
#   set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
#Typically, such
#string should have been previously created by return_list<>.
# See convert_list_to_string() for further details.

#FUXME: Every alias in this component should be suffixed with "_from",
#indicating an unavoidable single quoted passed argument style.

#alias set_list_to_string_converted='{
#    # Validate passed arguments.
#    list args_sltsc; set_list_to_stdin_words args_sltsc
#    (( ${#args_sltsc} >= 2 )) ||
#        die "expected one list name and at least one string"
#    string list_name_sltsc="${args_sltsc[1]}"
#    shift_list args_sltsc
#
#    # Declare such list if not already.
#    is_list "${list_name_sltsc}" or eval "list ${list_name_sltsc}"
#
#    # Convert such string to such list.
#    set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
#} <<<'

#   >>> function make_list() {
#   >>>   list original; original=( oeu ooo 'zzz 3' 967 )
#   >>>   convert_list_to_string original
#   >>> }
#
#   # Make a new list named "copy" converted from such function's return value.
#   >>> set_list_to_string_from "copy $(make_list)"
#FUXME: Honestly, this is silly. Why not just:
#
#    function make_list() {
#       list original; original=( oeu ooo 'zzz 3' 967 )
#       return_list original
#    }
#
#    list copy
#    run_command_and_set_list_to_output make_list copy
#
#O.K.; a function resembling run_command_and_set_list_to_output() is clearly the
#way to go. This function name is probably as concise as we can go without
#becoming unintentionally obfuscatory. I say, "Run with it."
#FUXME: Rename to set_list_to_string() and shift to "00-alias/list".
#FUXME: Wait. The new-style herestring-driven aliases permit a superior approach.
#See below
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
#alias restore_list='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    is -n "${list+x}" si or list list;
#    list=( ${(z)"$(< /dev/stdin)"} )
#}'
