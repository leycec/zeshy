#!/usr/bin/env zsh
# ====================[ test                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle tests intended to be called from a top-level shell script context.

# ....................{ TESTERS ~ math                     }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_math_function_rand48(void)

Return success if `zsh` was compiled with support for erand48(), an optional C
function defined by the current system's mathematical library (e.g., `libm`).
________________<heredoc?>________________
function is_math_function_rand48() {
    # Sadly, zsh provides no direct means of testing for such math support.
    # Happily, a venerate hack exists. Since rand48() if defined *ALWAYS*
    # returns a float in [0.0, 1.0), the expression "(( rand48() >= 0.0 ))" only
    # fails under shells not defining such function.
    die_if_args

    # Since this function is often called prior to calling startup_zeshy(),
    # which autoloads zsh modules, load the module defining rand48() here.
    zmodload zsh/mathfunc

    # Test such function, squelching errors should such function not exist.
    eval '(( rand48() >= 0.0 ))' &>/dev/null
}

# ....................{ TESTERS ~ pathable                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_pathable_gnu(string command_name)

Return success if the passed command is in the current ${PATH} _and_ the GNU
implementation of such command. Such implementations often implement helpful, if
non-standard, long-form options either unavailable in non-GNU implementations
(e.g., `grep --perl-regexp`) or available only via short-form options (e.g.,
`ls -v` rather than `ls --version`).
________________<heredoc?>________________
function is_pathable_gnu() {
    # Validate sanity.
    die_unless_arg 'expected one command name'
    string command_name="${1}"

    # Return success if the following conditions are all true:
    #
    # * Such command is in the current ${PATH}. See get_pathable_path_if_found()
    #   for further details.
    # * Such command successfully returns its version given a GNU-style option.
    # * Such version contains "GNU".
    is "${command_name:t:c}" == '/'* si and {
        string output
        output="$(command "${command_name}" --version 2>&/dev/null)" and
            is "${output}" == *'GNU'* si
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Shift somewhere more appropriate. Perhaps we want a new component
#"runnable/pathable/gnu", for example. Ah; right. Such functions must be
#available early. Hence, shift to component "00-startup/15-pathable/gnu".
#FUXME: Replace with a more general function -- say, is_pathable_gnu().
#FUXME: Replace the call to is_pathable() with its underlying implementation.
