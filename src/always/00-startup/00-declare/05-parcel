#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: We'll need some mechanism for cross-referencing other components in
#AsciiDoc descriptions. How about a "@{...}"-style syntax (e.g.,
#"Please see component @{string} or @{variable/map/map}")? Finding *WHICH*
#component such reference references is slightly more difficult than for
#aliases, functions, and globals, however, as component names are non-unique.
#Since components often change paths, we probably want to employ a relative
#path-searching algorithm as follows:
#
#* If such component is prefixed with an absolute or relative path prefix
#  (e.g., @{/always/variable/list/list} or @{../../type}), test whether such
#  file exist. Relative paths are simply relative to the directory containing
#  the current component. Absolute paths should be prefixed with the directory
#  of the overlay root containing containing the current component. (Err,
#  perhaps *ANY* overlay root, testing each? No sense being overly restrictive.)
#* If that fails, prefix such component name with "./" (e.g., from @{string} to
#  @{./string}). If such file exists in the same directory as the directory of
#  the current component, such file is the desired target of such cross-reference.
#* If that fails, prefix such component name with "../" (e.g., from @{string} to
#  @{../string}). Again test whether such file exists.
#* Continue prefixing such component name with an additional "../" until either
#  traversing above the overlay root containing the current component or
#  discovering such component.
#FIXME: Actually, the above searching mechanism isn't quite enough, as parcels
#residing under discontiguous overlay roots would never be able to find each
#other. Frankly, it's a fairly annoying issue. It's also extremely inefficient
#under the default premise of explicitly searching the filesystem on each
#@{...} reference. The latter can be significantly improved, at least, by
#performing an upfront "print -lr -- **/*": that is, caching the set of all
#absolute paths of all zeshy scripts compiled into the current user digest file.
#Indeed, caching such set into a map should provide reasonably efficient lookup.
#FIXME: Ah! We've divorced parcels from scripts. Before, there was a one-to-one
#relationship between parcels and scripts; now, there's basically a many-to-many
#relationship, where each script can declare arbitrarily many parcels and
#parcels can be distributed across multiple files. Hence, the set of all parcel
#names (which should, of course, be formatted as "/"-delimited pathnames, which
#need not necessarily exist but typically will under the conventional one-to-one
#scenario) is easily iterated as the *KEYS* of map ${ZESHY_PARCEL_NAME_TO_HELP}.
#FIXME: Ah! We could even do one better, by caching into a map whose keys are
#script basenames and whose values are a null-delimited string list of all
#absolute dirnames containing such basename, *SORTED* alphabetically. The
#sorting is essential... err, perhaps it isn't. In any case, this should provide
#*EXTREMELY* efficient lookup. If such value contains only one string, we have
#our candidate; otherwise, search such value split on null. We're then looking
#for a dirname with the minimum distance to the current script's dirname. Sure,
#we could manually implement a Levenshtein or Hamming distance function,
#calculate each such distance, and take the dirname with the minimum distance.
#But that strikes me as overkill. Given the nature of POSIX paths, I see a
#simpler solution. If we can efficiently find the longest common prefix of both
#dirnames, then counting the total number of "/" characters in the remainder
#following such prefix in *BOTH* dirnames gives the total directory distance
#between such dirnames. Sweet, no? The question is: can we efficiently find
#longest common prefixes? I'm not completely sure, but a PCRE-based approach
#appears to work at least decently:
#
#* Append "/" to each dirname, if not already present. (This ensures the
#  correctness of the distance calculation.)
#* SCRATCH THIS (i.e., ignore): Determine which of the two dirnames is longer.
#* Ah-ha! Convert the current script's dirname to a PCRE as follows:
#  * Using a glob, replace every substring matching "([^/]##/)" to
#    "(${match[1]})?". Actually, that's not quite right; to ensure proper
#    nesting (and efficiency!), we need to nest such expressions. For example,
#    convert "/usr/share/zeshy/with/all/" to
#    "/(usr/(share/(zeshy/(with/(all/)?)?)?)?)?". Ah! Simple. Replace
#    each such substring with "(${match[1]}", then append ${X} number of ")?"
#    to the end of such string, where ${X} is 1 minus the number of "/"
#    characters in such string. This is probably easiest implemented with a glob-
#    based iterator, frankly. In any case, we have our PCRE!
#  * Then, just match each dirname split from such null-delimited list with such
#    PCRE. *EVERY* dirname is guaranteed to match. The longest common prefix is
#    given by iterating match groups, starting at -1 and ending at -${X}. The
#    last *NONEMPTY* match group giv... Actually, just concatenate match groups!
#    Why not, right? Then "${match[*]}" with IFS="/" should give the longest
#    common prefix. Sweet. This is rather eclectically cool, and probably
#    deserves its own function -- say, get_path_distance()? Can't imagine we'll
#    often need it, but... heck, it's there, anyway.
#  * Then, remove such longest common prefix from both dirnames and count the
#    total number of remaining "/" characters in such strings.
#  * It's all quite doable, really.
#* If such count is 1, stop prematurely. There can't be anything closer... Well,
#  there could be something equally as close but in the opposite direction. Hmm;
#  I suppose we should give precedence to subdirectories rather than parent
#  directories, yes? *sigh*

# See @{global} and @{function} for help strings for all globals and functions
# defined below, respectively.

# ....................{ GLOBALS                            }....................
# Map from parcel names to help strings documenting such parcels. Avoid formally
# documenting such map, which zeshy precompilation subsequently undefines (to
# conserve space). See also the following lists specific to top-level
# components, which precompilation converts into elements of related maps:
# ${ZESHY_CORE_HELP_ALIASES}, ${ZESHY_CORE_HELP_FUNCTIONS}, and
# ${ZESHY_CORE_HELP_GLOBALS}.
typeset -Ag ZESHY_PARCEL_NAME_TO_HELP

# Map from parcel names to null-delimited string lists of all aliases,
# functions, and globals declared by such parcel, respectively.
typeset -Agx\
    ZESHY_PARCEL_NAME_TO_ALIAS_NAMES\
    ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES\
    ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES

#FIXME: Reset to the empty string before its compilation into the digest file.
#This can be achieved with a late precompile hook, yes? This is important, as it
#ensures that all subsequent calls involving a parcel will throw an exception as
#desired (since the empty string is not an existing parcel -- hopefully, anyway!).

# Current parcel name. Since the value of such global is typically specific to
# the most recent zeshy script to have called declare_parcel_to_script(), avoid exporting
# such global to caller scripts.
typeset -g ZESHY_PARCEL_NAME

# ....................{ EXCEPTIONS                         }....................
function die_if_parcel_name() {
    (( # == 1 || # == 2 )) ||
        die 'expected one parcel name and optional error message'
    string parcel_name="${1}"
    is_parcel "${parcel_name}" and
        die "${2:-parcel \"${parcel_name}\" already declared}"
}

function die_unless_parcel() {
    (( # == 1 || # == 2 )) ||
        die 'expected one parcel name and optional error message'
    string parcel_name="${1}"
    is_parcel "${parcel_name}" or
        die "${2:-parcel \"${parcel_name}\" undeclared}"
}

# ....................{ TESTERS                            }....................
function is_parcel() {
    # See is_map_key() for further details.
    (( # == 1 )) || die 'expected one parcel name'
    (( ${+ZESHY_PARCEL_NAME_TO_HELP[${1}]} ))
}

# ....................{ GETTERS                            }....................
#FIXME: Shift these into a new component; they're simply not required here.
#FIXME: Document!
function get_parcel() {
    # Validate passed arguments.
    (( # == 0 )) || die 'expected no arguments'
    print -r -- "${ZESHY_PARCEL_NAME}"
}

# ....................{ SETTERS                            }....................
#FIXME: Shift these into a new component; they're simply not required here.
#FIXME: Document!
function set_parcel() {
    # Validate passed arguments. If such name is not an absolute path (i.e., is
    # either not prefixed by "/" or contains null characters), such name is
    # invalid as a parcel name, so throw an exception. See @{parcel} for further
    # details.
    (( # == 1 )) || die 'expected one parcel name'
    local parcel_name="${1}"
    die_unless_parcel "${parcel_name}"

    # Set the current parcel to such script, canonicalized to avoid ambiguity
    # when cross-referencing parcels. See canonicalize_path() for further
    # details. For efficiency, avoid calling set_parcel().
    ZESHY_PARCEL_NAME="${parcel_name}"
}

#FIXME: Document!
function set_parcel_to_script() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one script name'
    local script_name="${1}"
    [[ -f "${script_name}" ]] || die "\"${script_name}\" not a zeshy script"

    # Set the current parcel to such script, canonicalized to avoid ambiguity
    # when cross-referencing parcels. See canonicalize_path() for further
    # details. For efficiency, avoid calling set_parcel().
    ZESHY_PARCEL_NAME="$(print -- "${script_name}"(:A))"
}

# ....................{ ADDERS                             }....................
#FIXME: Technically, suffix aliases reside in a separate namespace and hence
#require separate handling. I can't really be bothered at the moment. Shouldn't
#be a terribly difficult change; just keep it in mind. For simplicity and
#orthogonality with nomenclature elsewhere, retain this function and simply add
#a new function add_parcel_alias_suffix(). Note we'll probably want to add a new
#subdirectory "15-alias/" containing the existing file "15-alias" and a new file
#"suffix" containing new declare_alias_suffix() functions.
function add_parcel_alias() {
    # Since alias names can contain any character including null, escape nulls
    # in such name. See define_alias() for further details.
    (( # == 2 )) || die 'expected one parcel name and one alias name'
    local parcel_name="${1:-${ZESHY_PARCEL_NAME}}"
    die_unless_parcel "${parcel_name}"
    ZESHY_PARCEL_NAME_TO_ALIAS_NAMES[${parcel_name}]+=$'\0'"${2//$'\0'/\\$'\0'}"
}

function add_parcel_function() {
    # Since function names can contain any character including null, escape
    # nulls in such name.
    (( # == 2 )) || die 'expected one parcel name and one function name'
    local parcel_name="${1:-${ZESHY_PARCEL_NAME}}"
    die_unless_parcel "${parcel_name}"
    ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${parcel_name}]+=$'\0'"${2//$'\0'/\\$'\0'}"
}

function add_parcel_global() {
    # Since global names can only contain identifier characters and hence *NOT*
    # null, nulls need not be escaped.
    (( # == 2 )) || die 'expected one parcel name and one global name'
    local parcel_name="${1:-${ZESHY_PARCEL_NAME}}"
    die_unless_parcel "${parcel_name}"
    ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES[${parcel_name}]+=$'\0'"${2}"
}

# ....................{ DECLARERS                          }....................
#FIXME: Rename this to declare_parcel_script() and likewise below. Then, have
#such functions call a new declare_script() function, which should call a new
#set_parcel() function. declare_parcel_script() should thus perform the expected
#die_unless_file() routine. (See below.)
#FIXME: Rename set_parcel() to set_parcel_script(). Then, define a new
#set_parcel() function. For efficiency, set_parcel_script() should *NOT* call
#set_parcel().

#FIXME: Document!
function declare_parcel() {
    # Validate passed arguments. If such parcel has already been declared, throw
    # an exception. Since parcels are typically associated with absolute paths,
    # this shouldn't ever occur. Make sure it doesn't!
    (( # == 2 )) || die 'expected one parcel name and one help string'
    local  parcel_name="${1}" help="${2}"
    die_if_parcel_name "${parcel_name}"

    # If such name is not an absolute path (i.e., is either not prefixed by "/"
    # or contains null characters), such name is not a valid parcel name; throw
    # an exception! See @{parcel} for further details.
    [[ "${parcel_name}" != '/'* || "${parcel_name}" == *$'\0'* ]] &&
        die "parcel \"${parcel_name}\" invalid (i.e., not an absolute path)"

    # Set the current parcel.
    ZESHY_PARCEL_NAME="${parcel_name}"

    # Map such parcel name to such help string.
    ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"
}

# ....................{ DECLARERS ~ script                 }....................
#FIXME: Document!
function declare_parcel_to_script() {
    # Validate passed arguments.
    (( # == 1 || # == 2 )) ||
        die 'expected optional script name and one help string'
    local script_name="${ZESHY_SCRIPT_NAME}" help="${argv[-1]}"
    is_args_2 and script_name="${1}"

    # Declare such parcel as such script path, canonicalized to avoid ambiguity
    # between parcels. See set_parcel_to_script() for further details.
    declare_parcel "$(print -- "${script_name}"(:A))" "${help}"
}

function declare_parcel_to_script_with_stdin() {
    run_runnable_with_stdin declare_parcel_to_script "${@}"
}

# ....................{ RUNNERS                            }....................
function run_runnable_with_stdin() {
    # Validate passed arguments. If standard input is empty, throw an exception.
    # See is_stdin_nonempty() for further details.
    (( # == 1 )) || die 'expected one function name'
    read -t 0 || die 'standard input empty'
    local function_name__rrws="${1}"
    shift_arg

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${function_name__rrws}" &>/dev/null ||
        die "runnable \"${function_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${function_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: For sanity, these should probably default the first argument to
#${ZESHY_PARCEL_NAME} if only passed one argument. Simplifies use elsewhere.
#FUXME: Fixup documentation.
    # Due to implementation details, avoid calling declare_parcel().
    # Nonetheless, ensure this function implements similar logic.

    # If such parcel has already been declared, throw an exception.
#   die_if_parcel_name "${parcel_name}"

    # Map such parcel name to such help string.
#   ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"

    # Set the current parcel to such script. This internally converts such
    # script to a parcel name, necessitating we subsequently use
    # ${ZESHY_PARCEL_NAME} rather than ${script_name}.
#   set_parcel_to_script "${script_name}"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
#   (( ${+ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]} )) and
#       die "parcel \"${parcel_name}\" already declared"

#FUXME: Shift all such adders as well as die_unless_parcel(), is_parcel(), and
#whatever else we don't explicitly require here into new parcel "zsh/parcel".
    # Validate passed arguments.
#   (( # == 2 )) || die 'expected one script name and one help string'
#   local script_name="${ZESHY_SCRIPT_NAME}" help="${argv[-1]}"
#   is_args_2 and script_name="${1}"
#   die_unless_file "${script_name}"

    # Canonicalize such path to avoid ambiguity when cross-referencing parcels.
    # See canonicalize_path() for further details.
#   script_name="$(print -- "${script_name}"(:A))"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
#   (( ${+ZESHY_PARCEL_NAME_TO_HELP[${script_name}]} )) and
#       die "parcel \"${script_name}\" already declared"

    # Map such parcel name to such help string.
#   ZESHY_PARCEL_NAME_TO_HELP[${script_name}]="${help}"

    # Set the current parcel to such name.
#   ZESHY_PARCEL_NAME="${script_name}"

    #FUXME: O.K.; convert the script to a parcel name by stripping the prefix
    #corresponding to the current overlay root from such name. Again, we'll need
    #a similar global to "${ZESHY_SCRIPT_NAME}" expanding to the
    #absolute path of the current overlay root. Simple!
    #FUXME: Set the current parcel, as well.

    # Name of such parcel.
#   local parcel_name

#alias, global, and function help strings into
#logically related units.
# ....................{ DECLARERS                          }....................
#declare_function_with_stdin <<'-\-'
#void declare_parcel_to_script(string documentation)
#
#Declare the current shell script to be a new parcel documented with the passed
#help string. See declare_parcel_to_script() for further details.
#-\-
#function declare_parcel_to_script() {
#    (( # == 1 )) || die 'expected one help string'
#    declare_parcel_to_script "${ZESHY_SCRIPT_NAME}" "${1}"
#}

#FUXME: Are we not overthinking this? Why not simply rename "parcels" to
#"scripts", below?
#FUXME: "${0}" doesn't appear to expand to the current script name within
#functions. While we could hack about this, a simpler solution is to utilize a
#string global set by "src/compile". Yummm!
#FUXME: Shift to "03-global". Ah, wait. We can't declare globals without the
#corresponding aliases being defined. O.K.; we need to shift the
#"../01-type/variable" subdirectory here, then shift "03-global" there. Hmmm;
#perhaps not. "03-global" is really only valid *AFTER* sourcing all parcels in
#such subdirectory, so... perhaps we want:
#
#00-declare/
#   03-variable/
#   04-global
#
#Simpler, in terms of dependency management.
