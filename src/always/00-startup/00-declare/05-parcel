#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *parcel* (i.e., `zeshy`-specific abstractions containing aliases,
# parcels, and functions) declarers.

#FIXME: We'll need some mechanism for cross-referencing other components in
#AsciiDoc descriptions. How about a "@{...}"-style syntax (e.g.,
#"Please see component @{string} or @{variable/map/map}")? Finding *WHICH*
#component such reference references is slightly more difficult than for
#aliases, functions, and globals, however, as component names are non-unique.
#Since components often change paths, we probably want to employ a relative
#path-searching algorithm as follows:
#
#* If such component is prefixed with an absolute or relative path prefix
#  (e.g., @{/always/variable/list/list} or @{../../type}), test whether such
#  file exist. Relative paths are simply relative to the directory containing
#  the current component. Absolute paths should be prefixed with the directory
#  of the overlay root containing containing the current component. (Err,
#  perhaps *ANY* overlay root, testing each? No sense being overly restrictive.)
#* If that fails, prefix such component name with "./" (e.g., from @{string} to
#  @{./string}). If such file exists in the same directory as the directory of
#  the current component, such file is the desired target of such cross-reference.
#* If that fails, prefix such component name with "../" (e.g., from @{string} to
#  @{../string}). Again test whether such file exists.
#* Continue prefixing such component name with an additional "../" until either
#  traversing above the overlay root containing the current component or
#  discovering such component.

# ....................{ GLOBALS                            }....................
# Global map from parcel names to the help strings documenting such parcels. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_PARCEL_NAME_TO_HELP

# Current parcel name. See "global" for such global's documentation.
typeset -gx ZESHY_PARCEL_NAME_CURRENT

# ....................{ DECLARERS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_parcel(
    string script_name = "${ZESHY_SCRIPT_NAME_CURRENT}",
    string documentation)

Declare the passed `zeshy` script (defaulting to the currently sourced script)
to be a new parcel, documented with the passed help string.

== Parcels ==

*Parcels* are `zeshy`-specific abstractions associating all aliases, globals,
and functions subsequently declared in such script with such script. While most
high-level languages provide native support for such abstractions (e.g., `perl`
packages, `python` modules, `ruby` gems), `zsh` does not. Even if `zsh` did,
however, `zeshy`\'s compilation of its codebase into a ``flat'' digest file
would likely render such abstractions moot.

Parcels provide a useful, if limited, pure-`zsh` facsimile of the conventional
package motif. By aggregating logically related `zsh` objects into abstract
units, parcels form the building blocks of `zeshy`\'s online documentation and
offline help system.
________________<heredoc?>________________
function declare_parcel() {
    # Validate passed arguments.
    (( # == 2 )) || die 'expected one script name and one help string'
    local script_name="${ZESHY_SCRIPT_NAME_CURRENT}" help="${argv[-1]}"
    is_args_2 and script_name="${1}"
    die_unless_file "${script_name}"

    #FIXME: O.K.; convert the script to a parcel name by stripping the prefix
    #corresponding to the current overlay root from such name. Again, we'll need
    #a similar global to "${ZESHY_SCRIPT_NAME_CURRENT}" expanding to the
    #absolute path of the current overlay root. Simple!

    # Name of such parcel.
    local parcel_name

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
    (( ${+ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]} )) and
        die "parcel \"${parcel_name}\" already declared"

    # Map such parcel name to such help string.
    ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"

    #FIXME: Set the current parcel, as well.
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_parcel_with_stdin[
    args: string script_name = "${0}", stdin: string documentation]

Declare a new *parcel* (i.e., `zeshy`-specific abstractions containing aliases,
parcels, and functions) corresponding to the passed shell script (defaulting to
the current shell script) documented with standard input. This function is the
standard input-specific analogue to declare_parcel(), which accepts a string
argument rather than standard input. See declare_function_with_stdin() for
further details on why this function is preferable to declare_parcel().
________________<heredoc?>________________
function declare_parcel_with_stdin() {
    run_runnable_with_stdin declare_parcel
}

# --------------------( WASTELANDS                         )--------------------
#alias, global, and function help strings into
#logically related units.
# ....................{ DECLARERS                          }....................
#declare_function_with_stdin <<'________________<heredoc?>________________'
#void declare_parcel(string documentation)
#
#Declare the current shell script to be a new parcel documented with the passed
#help string. See declare_parcel_for_script() for further details.
#________________<heredoc?>________________
#function declare_parcel() {
#    (( # == 1 )) || die 'expected one help string'
#    declare_parcel_for_script "${ZESHY_SCRIPT_NAME_CURRENT}" "${1}"
#}

#FUXME: Are we not overthinking this? Why not simply rename "parcels" to
#"scripts", below?
#FUXME: "${0}" doesn't appear to expand to the current script name within
#functions. While we could hack about this, a simpler solution is to utilize a
#string global set by "src/compile". Yummm!
#FUXME: Shift to "03-global". Ah, wait. We can't declare globals without the
#corresponding aliases being defined. O.K.; we need to shift the
#"../01-type/variable" subdirectory here, then shift "03-global" there. Hmmm;
#perhaps not. "03-global" is really only valid *AFTER* sourcing all parcels in
#such subdirectory, so... perhaps we want:
#
#00-declare/
#   03-variable/
#   04-global
#
#Simpler, in terms of dependency management.
