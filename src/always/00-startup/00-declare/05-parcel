#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: We'll need some mechanism for cross-referencing other components in
#AsciiDoc descriptions. How about a "@{...}"-style syntax (e.g.,
#"Please see component @{string} or @{variable/map/map}")? Finding *WHICH*
#component such reference references is slightly more difficult than for
#aliases, functions, and globals, however, as component names are non-unique.
#Since components often change paths, we probably want to employ a relative
#path-searching algorithm as follows:
#
#* If such component is prefixed with an absolute or relative path prefix
#  (e.g., @{/always/variable/list/list} or @{../../type}), test whether such
#  file exist. Relative paths are simply relative to the directory containing
#  the current component. Absolute paths should be prefixed with the directory
#  of the overlay root containing containing the current component. (Err,
#  perhaps *ANY* overlay root, testing each? No sense being overly restrictive.)
#* If that fails, prefix such component name with "./" (e.g., from @{string} to
#  @{./string}). If such file exists in the same directory as the directory of
#  the current component, such file is the desired target of such cross-reference.
#* If that fails, prefix such component name with "../" (e.g., from @{string} to
#  @{../string}). Again test whether such file exists.
#* Continue prefixing such component name with an additional "../" until either
#  traversing above the overlay root containing the current component or
#  discovering such component.
#FIXME: Actually, the above searching mechanism isn't quite enough, as parcels
#residing under discontiguous overlay roots would never be able to find each
#other. Frankly, it's a fairly annoying issue. It's also extremely inefficient
#under the default premise of explicitly searching the filesystem on each
#@{...} reference. The latter can be significantly improved, at least, by
#performing an upfront "print -lr -- **/*": that is, caching the set of all
#absolute paths of all zeshy scripts compiled into the current user digest file.
#Indeed, caching such set into a map should provide reasonably efficient lookup.
#FIXME: Ah! We could even do one better, by caching into a map whose keys are
#script basenames and whose values are a null-delimited string list of all
#absolute dirnames containing such basename, *SORTED* alphabetically. The
#sorting is essential... err, perhaps it isn't. In any case, this should provide
#*EXTREMELY* efficient lookup. If such value contains only one string, we have
#our candidate; otherwise, search such value split on null. We're then looking
#for a dirname with the minimum distance to the current script's dirname. Sure,
#we could manually implement a Levenshtein or Hamming distance function,
#calculate each such distance, and take the dirname with the minimum distance.
#But that strikes me as overkill. Given the nature of POSIX paths, I see a
#simpler solution. If we can efficiently find the longest common prefix of both
#dirnames, then counting the total number of "/" characters in the remainder
#following such prefix in *BOTH* dirnames gives the total directory distance
#between such dirnames. Sweet, no? The question is: can we efficiently find
#longest common prefixes? I'm not completely sure, but a PCRE-based approach
#appears to work at least decently:
#
#* Append "/" to each dirname, if not already present. (This ensures the
#  correctness of the distance calculation.)
#* SCRATCH THIS (i.e., ignore): Determine which of the two dirnames is longer.
#* Ah-ha! Convert the current script's dirname to a PCRE as follows:
#  * Using a glob, replace every substring matching "([^/]##/)" to
#    "(${match[1]})?". Actually, that's not quite right; to ensure proper
#    nesting (and efficiency!), we need to nest such expressions. For example,
#    convert "/usr/share/zeshy/with/all/" to
#    "/(usr/(share/(zeshy/(with/(all/)?)?)?)?)?". Ah! Simple. Replace
#    each such substring with "(${match[1]}", then append ${X} number of ")?"
#    to the end of such string, where ${X} is 1 minus the number of "/"
#    characters in such string. This is probably easiest implemented with a glob-
#    based iterator, frankly. In any case, we have our PCRE!
#  * Then, just match each dirname split from such null-delimited list with such
#    PCRE. *EVERY* dirname is guaranteed to match. The longest common prefix is
#    given by iterating match groups, starting at -1 and ending at -${X}. The
#    last *NONEMPTY* match group giv... Actually, just concatenate match groups!
#    Why not, right? Then "${match[*]}" with IFS="/" should give the longest
#    common prefix. Sweet. This is rather eclectically cool, and probably
#    deserves its own function -- say, get_path_distance()? Can't imagine we'll
#    often need it, but... heck, it's there, anyway.
#  * Then, remove such longest common prefix from both dirnames and count the
#    total number of remaining "/" characters in such strings.
#  * It's all quite doable, really.
#* If such count is 1, stop prematurely. There can't be anything closer... Well,
#  there could be something equally as close but in the opposite direction. Hmm;
#  I suppose we should give precedence to subdirectories rather than parent
#  directories, yes? *sigh*

# ....................{ GLOBALS                            }....................
# Global map from parcel names to the help strings documenting such parcels.
# Avoid formally documenting such map, which zeshy precompilation subsequently
# undefines to conserve space. See also the following lists specific to top-
# level components, which precompilation converts into elements of related maps:
# ${ZESHY_CORE_HELP_ALIASES}, ${ZESHY_CORE_HELP_FUNCTIONS}, and
# ${ZESHY_CORE_HELP_GLOBALS}.
typeset -Ag ZESHY_PARCEL_NAME_TO_HELP

# Current parcel name. Since the value of such global is typically specific to
# the most recent zeshy script to have called declare_parcel(), avoid exporting
# such global to caller scripts. See @{global} for such global's documentation.
typeset -g ZESHY_PARCEL_NAME_CURRENT

# ....................{ DECLARERS                          }....................
# See @{function} for help strings for all functions below.

function declare_parcel() {
    # Validate passed arguments.
    (( # == 2 )) || die 'expected one script name and one help string'
    local script_name="${ZESHY_SCRIPT_NAME_CURRENT}" help="${argv[-1]}"
    is_args_2 and script_name="${1}"
    die_unless_file "${script_name}"

    # If such path is relative, throw an exception. Permitting relative parcels
    # invites ambiguity issues.
    die_unless_path_absolute "${script_name}"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
    (( ${+ZESHY_PARCEL_NAME_TO_HELP[${script_name}]} )) and
        die "parcel \"${script_name}\" already declared"

    # Map such parcel name to such help string.
    ZESHY_PARCEL_NAME_TO_HELP[${script_name}]="${help}"

    # Set the current parcel to such name.
    ZESHY_PARCEL_NAME_CURRENT="${script_name}"
}

function declare_parcel_with_stdin() {
    run_runnable_with_stdin declare_parcel "${@}"
}

# ....................{ RUNNERS                            }....................
function run_runnable_with_stdin() {
    # Validate passed arguments. If standard input is empty, throw an exception.
    # See is_stdin_nonempty() for further details.
    (( # == 1 )) || die 'expected one function name'
    read -t 0 || die 'standard input empty'
    local function_name__rrws="${1}"
    shift_arg

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${function_name__rrws}" &>/dev/null ||
        die "runnable \"${function_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${function_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: O.K.; convert the script to a parcel name by stripping the prefix
    #corresponding to the current overlay root from such name. Again, we'll need
    #a similar global to "${ZESHY_SCRIPT_NAME_CURRENT}" expanding to the
    #absolute path of the current overlay root. Simple!
    #FUXME: Set the current parcel, as well.

    # Name of such parcel.
#   local parcel_name

#alias, global, and function help strings into
#logically related units.
# ....................{ DECLARERS                          }....................
#declare_function_with_stdin <<'________________<heredoc?>________________'
#void declare_parcel(string documentation)
#
#Declare the current shell script to be a new parcel documented with the passed
#help string. See declare_parcel() for further details.
#________________<heredoc?>________________
#function declare_parcel() {
#    (( # == 1 )) || die 'expected one help string'
#    declare_parcel "${ZESHY_SCRIPT_NAME_CURRENT}" "${1}"
#}

#FUXME: Are we not overthinking this? Why not simply rename "parcels" to
#"scripts", below?
#FUXME: "${0}" doesn't appear to expand to the current script name within
#functions. While we could hack about this, a simpler solution is to utilize a
#string global set by "src/compile". Yummm!
#FUXME: Shift to "03-global". Ah, wait. We can't declare globals without the
#corresponding aliases being defined. O.K.; we need to shift the
#"../01-type/variable" subdirectory here, then shift "03-global" there. Hmmm;
#perhaps not. "03-global" is really only valid *AFTER* sourcing all parcels in
#such subdirectory, so... perhaps we want:
#
#00-declare/
#   03-variable/
#   04-global
#
#Simpler, in terms of dependency management.
