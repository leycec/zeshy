#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: We'll need some mechanism for cross-referencing other components in
#AsciiDoc descriptions. How about a "@{...}"-style syntax (e.g.,
#"Please see component @{string} or @{variable/map/map}")? Finding *WHICH*
#component such reference references is slightly more difficult than for
#aliases, functions, and globals, however, as component names are non-unique.
#Since components often change paths, we probably want to employ a relative
#path-searching algorithm as follows:
#
#* If such component is prefixed with an absolute or relative path prefix
#  (e.g., @{/always/variable/list/list} or @{../../type}), test whether such
#  file exist. Relative paths are simply relative to the directory containing
#  the current component. Absolute paths should be prefixed with the directory
#  of the overlay root containing containing the current component. (Err,
#  perhaps *ANY* overlay root, testing each? No sense being overly restrictive.)
#* If that fails, prefix such component name with "./" (e.g., from @{string} to
#  @{./string}). If such file exists in the same directory as the directory of
#  the current component, such file is the desired target of such cross-reference.
#* If that fails, prefix such component name with "../" (e.g., from @{string} to
#  @{../string}). Again test whether such file exists.
#* Continue prefixing such component name with an additional "../" until either
#  traversing above the overlay root containing the current component or
#  discovering such component.
#FIXME: Actually, the above searching mechanism isn't quite enough, as parcels
#residing under discontiguous overlay roots would never be able to find each
#other. Frankly, it's a fairly annoying issue. It's also extremely inefficient
#under the default premise of explicitly searching the filesystem on each
#@{...} reference. The latter can be significantly improved, at least, by
#performing an upfront "print -lr -- **/*": that is, caching the set of all
#absolute paths of all zeshy scripts compiled into the current user digest file.
#Indeed, caching such set into a map should provide reasonably efficient lookup.
#FIXME: Ah! We've divorced parcels from scripts. Before, there was a one-to-one
#relationship between parcels and scripts; now, there's basically a many-to-many
#relationship, where each script can declare arbitrarily many parcels and
#parcels can be distributed across multiple files. Hence, the set of all parcel
#names (which should, of course, be formatted as "/"-delimited pathnames, which
#need not necessarily exist but typically will under the conventional one-to-one
#scenario) is easily iterated as the *KEYS* of map ${ZESHY_PARCEL_NAME_TO_HELP}.
#FIXME: Ah! We could even do one better, by caching into a map whose keys are
#script basenames and whose values are a null-delimited string list of all
#absolute dirnames containing such basename, *SORTED* alphabetically. The
#sorting is essential... err, perhaps it isn't. In any case, this should provide
#*EXTREMELY* efficient lookup. If such value contains only one string, we have
#our candidate; otherwise, search such value split on null. We're then looking
#for a dirname with the minimum distance to the current script's dirname. Sure,
#we could manually implement a Levenshtein or Hamming distance function,
#calculate each such distance, and take the dirname with the minimum distance.
#But that strikes me as overkill. Given the nature of POSIX paths, I see a
#simpler solution. If we can efficiently find the longest common prefix of both
#dirnames, then counting the total number of "/" characters in the remainder
#following such prefix in *BOTH* dirnames gives the total directory distance
#between such dirnames. Sweet, no? The question is: can we efficiently find
#longest common prefixes? I'm not completely sure, but a PCRE-based approach
#appears to work at least decently:
#
#* Append "/" to each dirname, if not already present. (This ensures the
#  correctness of the distance calculation.)
#* SCRATCH THIS (i.e., ignore): Determine which of the two dirnames is longer.
#* Ah-ha! Convert the current script's dirname to a PCRE as follows:
#  * Using a glob, replace every substring matching "([^/]##/)" to
#    "(${match[1]})?". Actually, that's not quite right; to ensure proper
#    nesting (and efficiency!), we need to nest such expressions. For example,
#    convert "/usr/share/zeshy/with/all/" to
#    "/(usr/(share/(zeshy/(with/(all/)?)?)?)?)?". Ah! Simple. Replace
#    each such substring with "(${match[1]}", then append ${X} number of ")?"
#    to the end of such string, where ${X} is 1 minus the number of "/"
#    characters in such string. This is probably easiest implemented with a glob-
#    based iterator, frankly. In any case, we have our PCRE!
#  * Then, just match each dirname split from such null-delimited list with such
#    PCRE. *EVERY* dirname is guaranteed to match. The longest common prefix is
#    given by iterating match groups, starting at -1 and ending at -${X}. The
#    last *NONEMPTY* match group giv... Actually, just concatenate match groups!
#    Why not, right? Then "${match[*]}" with IFS="/" should give the longest
#    common prefix. Sweet. This is rather eclectically cool, and probably
#    deserves its own function -- say, get_path_distance()? Can't imagine we'll
#    often need it, but... heck, it's there, anyway.
#  * Then, remove such longest common prefix from both dirnames and count the
#    total number of remaining "/" characters in such strings.
#  * It's all quite doable, really.
#* If such count is 1, stop prematurely. There can't be anything closer... Well,
#  there could be something equally as close but in the opposite direction. Hmm;
#  I suppose we should give precedence to subdirectories rather than parent
#  directories, yes? *sigh*

# See @{global} and @{function} for help strings for all globals and functions
# defined below, respectively.

# ....................{ GLOBALS                            }....................
# Map from parcel names to help strings documenting such parcels. Avoid formally
# documenting such map, which zeshy precompilation subsequently undefines (to
# conserve space). See also the following lists specific to top-level
# components, which precompilation converts into elements of related maps:
# ${ZESHY_CORE_HELP_ALIASES}, ${ZESHY_CORE_HELP_FUNCTIONS}, and
# ${ZESHY_CORE_HELP_GLOBALS}.
typeset -Ag ZESHY_PARCEL_NAME_TO_HELP

# Map from parcel names to null-delimited string lists of all aliases,
# functions, and globals declared by such parcel, respectively.
typeset -Agx\
    ZESHY_PARCEL_NAME_TO_ALIAS_NAMES\
    ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES\
    ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES

#FIXME: Reset to the empty string before its compilation into the digest file.
#This can be achieved with a late precompile hook, yes? This is important, as it
#ensures that all subsequent calls involving a parcel will throw an exception as
#desired (since the empty string is not an existing parcel -- hopefully, anyway!).

# Current parcel name. Since the value of such global is typically specific to
# the most recent zeshy script to have called declare_parcel_to_script(), avoid exporting
# such global to caller scripts.
typeset -g ZESHY_PARCEL_NAME

# ....................{ EXCEPTIONS                         }....................
function die_if_parcel() {
    (( # == 1 || # == 2 )) ||
        die 'expected one parcel name and optional error message'
    string parcel_name="${1}"
    is_parcel "${parcel_name}" and
        die "${2:-parcel \"${parcel_name}\" already declared}"
}

function die_unless_parcel() {
    (( # == 1 || # == 2 )) ||
        die 'expected one parcel name and optional error message'
    string parcel_name="${1}"
    is_parcel "${parcel_name}" or
        die "${2:-parcel \"${parcel_name}\" undeclared}"
}

# ....................{ TESTERS                            }....................
function is_parcel() {
    # See is_map_key() for further details.
    (( # == 1 )) || die 'expected one parcel name'
    (( ${+ZESHY_PARCEL_NAME_TO_HELP[${1}]} ))
}

# ....................{ ADDERS                             }....................
#FIXME: Technically, suffix aliases reside in a separate namespace and hence
#require separate handling. I can't really be bothered at the moment. Shouldn't
#be a terribly difficult change; just keep it in mind. For simplicity and
#orthogonality with nomenclature elsewhere, retain this function and simply add
#a new function add_parcel_alias_suffix(). Note we'll probably want to add a new
#subdirectory "15-alias/" containing the existing file "15-alias" and a new file
#"suffix" containing new declare_alias_suffix() functions.
function add_parcel_alias() {
    # Since alias names can contain any character including null, escape nulls
    # in such name. See define_alias() for further details.
    (( # == 2 )) || die 'expected one parcel name and one alias name'
    local parcel_name="${1:-${ZESHY_PARCEL_NAME}}"
    die_unless_parcel "${parcel_name}"
    ZESHY_PARCEL_NAME_TO_ALIAS_NAMES[${parcel_name}]+=$'\0'"${2//$'\0'/\\$'\0'}"
}

function add_parcel_function() {
    # Since function names can contain any character including null, escape
    # nulls in such name.
    (( # == 2 )) || die 'expected one parcel name and one function name'
    local parcel_name="${1:-${ZESHY_PARCEL_NAME}}"
    die_unless_parcel "${parcel_name}"
    ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${parcel_name}]+=$'\0'"${2//$'\0'/\\$'\0'}"
}

function add_parcel_global() {
    # Since global names can only contain identifier characters and hence *NOT*
    # null, nulls need not be escaped.
    (( # == 2 )) || die 'expected one parcel name and one global name'
    local parcel_name="${1:-${ZESHY_PARCEL_NAME}}"
    die_unless_parcel "${parcel_name}"
    ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES[${parcel_name}]+=$'\0'"${2}"
}

# ....................{ DECLARERS                          }....................
#FIXME: Document!
function declare_parcel() {
    # Validate passed arguments. If such parcel has already been declared, throw
    # an exception. Since parcels are typically associated with absolute paths,
    # this shouldn't ever occur. Make sure it doesn't!
    (( # == 2 )) || die 'expected one parcel name and one help string'
    local  parcel_name="${1}" help="${2}"
    die_if_parcel "${parcel_name}"

    # If such name is not an absolute path (i.e., is either not prefixed by "/"
    # or contains null characters), such name is not a valid parcel name; throw
    # an exception! See @{parcel} for further details.
    [[ "${parcel_name}" != '/'* || "${parcel_name}" == *$'\0'* ]] &&
        die "parcel \"${parcel_name}\" invalid (i.e., not an absolute path)"

    # Set the current parcel. See set_parcel() for further details.
    ZESHY_PARCEL_NAME="${parcel_name}"

    # Map such parcel name to such help string.
    ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"
}

# ....................{ DECLARERS ~ script                 }....................
#FIXME: Rename "parcel_to_script" to "parcel_as_script" everywhere.
#FIXME: Document!
function declare_parcel_to_script() {
    # Validate passed arguments.
    (( # == 1 || # == 2 )) ||
        die 'expected optional script name and one help string'
    local script_name="${ZESHY_SCRIPT_NAME}" help="${argv[-1]}"
    is_args_2 and script_name="${1}"

    # Declare such parcel as such script path, canonicalized to avoid ambiguity
    # between parcels. See set_parcel_to_script() for further details.
    declare_parcel "$(print -- "${script_name}"(:A))" "${help}"
}

function declare_parcel_to_script_with_stdin() {
    run_runnable_with_stdin declare_parcel_to_script "${@}"
}

# ....................{ RUNNERS                            }....................
function run_runnable_with_stdin() {
    # Validate passed arguments. If standard input is empty, throw an exception.
    # See is_stdin_nonempty() for further details.
    (( # == 1 )) || die 'expected one function name'
    read -t 0 || die 'standard input empty'
    local function_name__rrws="${1}"
    shift_arg

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${function_name__rrws}" &>/dev/null ||
        die "runnable \"${function_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${function_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# ....................{ DOCUMENTERS                        }....................
declare_parcel_to_script_with_stdin <<'-\-'
Handle *parcel* (i.e., a `zeshy`-specific abstraction encapsulating all aliases,
globals, and functions declared by a `zeshy` script) declarers. See
declare_parcel() for further details.

While most high-
level languages provide native support for declaring such abstractions (e.g.,
`perl` packages, `python` modules, `ruby` gems), `zsh` does not. Even if `zsh`
did, however, `zeshy`\'s compilation into unstructured digest files would likely
render such abstractions moot. Hence, the necessity of a `zeshy`-specific
abstraction allowing for such compilation.

Parcels implement a useful (if limited) pure-`zsh` facsimile of the typical
package motif, aggregating logically related `zsh` objects into abstract units.
Under most high-level languages, such units form a language-specific topology
of both reusable components (for programming purposes) and exportable
documentation (for specification purposes). Under `zsh`, however, only the
latter applies. Since `zsh` digest files dispense with structure (and hence
reusable components), parcels principally form a `zsh`-specific topology of
documentation -- both offline and on.

== Parcel Names ==

All parcel names are *absolute paths* (i.e., prefixed and internally delimited
by the directory separator '/' and containing no null characters). Since parcels
are abstractions, such paths need _not_ actually exist. Assuming the customary
one-to-one relationship between parcels and scripts
<<parcel.relations.1to1,documented below>>, however, each parcel name is the
absolute path of the existing shell script declaring such parcel.

== Parcel-script Relationships ==

Parcels are abstractions related to but _not_ necessarily synonymous with the
physical `zeshy` scripts declaring such parcels.

[[parcel.relations.1to1]]
=== One-to-one Parcel-script Relationships ===

There typically exists a one-to-one relationship between parcels and scripts.
For each such script, there exists a corresponding parcel whose name is the
absolute path of such script -- both guaranteeing uniqueness between parcel
names and establishing a convenient means of associating parcels with scripts.
With such relationships, a script's absolute path identifies its parcel and a
parcel's name its script's absolute path.

To implement such relationship, such scripts should call a *parcel declarer*
(e.g., declare_parcel_to_script(), declare_parcel_script_with_stdin()) before calling any
other declarers (e.g., declare_alias(), declare_function_with_stdin()).

=== One-to-many Parcel-script Relationships ===

A one-to-many relationship between parcels and scripts, in which one parcel is
distributed across multiple scripts (hereafter referred to as the *swarm* of
scripts declaring and defining such parcel), is also feasible. As with aliases,
functions, and variables, parcels are typically only declared once. Hence, for
one script in each such swarm, there exists a corresponding parcel whose name
is the absolute path of such script. All other scripts in such swarm non-
ambiguously refer to such parcel by such path.

To implement such relationship, the declaring script in such swarm should call
a parcel declarer before calling any parcel-specific declarers. All other
scripts in such swarm should call a *parcel setter* (e.g., set_parcel(),
set_parcel_script()) before calling any parcel-specific declarers.

=== Many-to-one Parcel-script Relationships ===

A many-to-one relationship between parcels and scripts, in which multiple
parcels (hereafter referred to as the *passel* of parcels being declared and
defined) are centralized into one script, is also feasible. For each such
script, there exist multiple corresponding parcels. To guarantee uniqueness
between parcel names, only one such parcel name may be the absolute path of
such script. All other parcel names in such passel must be arbitrary (probably
nonextant) absolute paths (e.g., by appending arbitrary integers to the path of
such script).

To implement such relationship, such script should be internally subdivided into
such parcels, calling a parcel declarer for each such parcel before calling all
declarers specific to such parcel.

=== Many-to-many Parcel-script Relationships ===

Lastly, a many-to-many relationship between parcels and scripts, in which
multiple parcels are distributed across multiple scripts, is also feasible.
Since such relationships blend one-to-many and many-to-one relationships, see
prior sections for further details. (Given the subtle complexities of such
relationships, many-to-many parcel-script relationships are rather uncommon.)

=== Parcel-script Relationships in zeshy ===

Since one-to-one relationships tend to conform more closely to user expectations
than one-to-many, many-to-one, or many-to-many relationships, all scripts in the
`zeshy` codebase declare and define exactly one parcel.
-\-

# --------------------( WASTELANDS                         )--------------------
#documentation.
#While parcels have no bearing 
#Since digest files `zeshy`\'s user digest files 
#While such units 
#units, parcels form the building blocks for `zeshy`\'s online documentation and
#offline help systems.

#FUXME: Rename this to declare_parcel_script() and likewise below. Then, have
#such functions call a new declare_script() function, which should call a new
#set_parcel() function. declare_parcel_script() should thus perform the expected
#die_unless_file() routine. (See below.)
#FUXME: Rename set_parcel() to set_parcel_script(). Then, define a new
#set_parcel() function. For efficiency, set_parcel_script() should *NOT* call
#set_parcel().

#FUXME: For sanity, these should probably default the first argument to
#${ZESHY_PARCEL_NAME} if only passed one argument. Simplifies use elsewhere.
#FUXME: Fixup documentation.
    # Due to implementation details, avoid calling declare_parcel().
    # Nonetheless, ensure this function implements similar logic.

    # If such parcel has already been declared, throw an exception.
#   die_if_parcel_name "${parcel_name}"

    # Map such parcel name to such help string.
#   ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"

    # Set the current parcel to such script. This internally converts such
    # script to a parcel name, necessitating we subsequently use
    # ${ZESHY_PARCEL_NAME} rather than ${script_name}.
#   set_parcel_to_script "${script_name}"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
#   (( ${+ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]} )) and
#       die "parcel \"${parcel_name}\" already declared"

#FUXME: Shift all such adders as well as die_unless_parcel(), is_parcel(), and
#whatever else we don't explicitly require here into new parcel "zsh/parcel".
    # Validate passed arguments.
#   (( # == 2 )) || die 'expected one script name and one help string'
#   local script_name="${ZESHY_SCRIPT_NAME}" help="${argv[-1]}"
#   is_args_2 and script_name="${1}"
#   die_unless_file "${script_name}"

    # Canonicalize such path to avoid ambiguity when cross-referencing parcels.
    # See canonicalize_path() for further details.
#   script_name="$(print -- "${script_name}"(:A))"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
#   (( ${+ZESHY_PARCEL_NAME_TO_HELP[${script_name}]} )) and
#       die "parcel \"${script_name}\" already declared"

    # Map such parcel name to such help string.
#   ZESHY_PARCEL_NAME_TO_HELP[${script_name}]="${help}"

    # Set the current parcel to such name.
#   ZESHY_PARCEL_NAME="${script_name}"

    #FUXME: O.K.; convert the script to a parcel name by stripping the prefix
    #corresponding to the current overlay root from such name. Again, we'll need
    #a similar global to "${ZESHY_SCRIPT_NAME}" expanding to the
    #absolute path of the current overlay root. Simple!
    #FUXME: Set the current parcel, as well.

    # Name of such parcel.
#   local parcel_name

#alias, global, and function help strings into
#logically related units.
# ....................{ DECLARERS                          }....................
#declare_function_with_stdin <<'-\-'
#void declare_parcel_to_script(string documentation)
#
#Declare the current shell script to be a new parcel documented with the passed
#help string. See declare_parcel_to_script() for further details.
#-\-
#function declare_parcel_to_script() {
#    (( # == 1 )) || die 'expected one help string'
#    declare_parcel_to_script "${ZESHY_SCRIPT_NAME}" "${1}"
#}

#FUXME: Are we not overthinking this? Why not simply rename "parcels" to
#"scripts", below?
#FUXME: "${0}" doesn't appear to expand to the current script name within
#functions. While we could hack about this, a simpler solution is to utilize a
#string global set by "src/compile". Yummm!
#FUXME: Shift to "03-global". Ah, wait. We can't declare globals without the
#corresponding aliases being defined. O.K.; we need to shift the
#"../01-type/variable" subdirectory here, then shift "03-global" there. Hmmm;
#perhaps not. "03-global" is really only valid *AFTER* sourcing all parcels in
#such subdirectory, so... perhaps we want:
#
#00-declare/
#   03-variable/
#   04-global
#
#Simpler, in terms of dependency management.
