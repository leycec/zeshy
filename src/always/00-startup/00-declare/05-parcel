#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: We'll need some mechanism for cross-referencing other components in
#AsciiDoc descriptions. How about a "@{...}"-style syntax (e.g.,
#"Please see component @{string} or @{variable/map/map}")? Finding *WHICH*
#component such reference references is slightly more difficult than for
#aliases, functions, and globals, however, as component names are non-unique.
#Since components often change paths, we probably want to employ a relative
#path-searching algorithm as follows:
#
#* If such component is prefixed with an absolute or relative path prefix
#  (e.g., @{/always/variable/list/list} or @{../../type}), test whether such
#  file exist. Relative paths are simply relative to the directory containing
#  the current component. Absolute paths should be prefixed with the directory
#  of the overlay root containing containing the current component. (Err,
#  perhaps *ANY* overlay root, testing each? No sense being overly restrictive.)
#* If that fails, prefix such component name with "./" (e.g., from @{string} to
#  @{./string}). If such file exists in the same directory as the directory of
#  the current component, such file is the desired target of such cross-reference.
#* If that fails, prefix such component name with "../" (e.g., from @{string} to
#  @{../string}). Again test whether such file exists.
#* Continue prefixing such component name with an additional "../" until either
#  traversing above the overlay root containing the current component or
#  discovering such component.
#FIXME: Actually, the above searching mechanism isn't quite enough, as parcels
#residing under discontiguous overlay roots would never be able to find each
#other. Frankly, it's a fairly annoying issue. It's also extremely inefficient
#under the default premise of explicitly searching the filesystem on each
#@{...} reference. The latter can be significantly improved, at least, by
#performing an upfront "print -lr -- **/*": that is, caching the set of all
#absolute paths of all zeshy scripts compiled into the current user digest file.
#Indeed, caching such set into a map should provide reasonably efficient lookup.
#FIXME: Ah! We've divorced parcels from scripts. Before, there was a one-to-one
#relationship between parcels and scripts; now, there's basically a many-to-many
#relationship, where each script can declare arbitrarily many parcels and
#parcels can be distributed across multiple files. Hence, the set of all parcel
#names (which should, of course, be formatted as "/"-delimited pathnames, which
#need not necessarily exist but typically will under the conventional one-to-one
#scenario) is easily iterated as the *KEYS* of map ${ZESHY_PARCEL_NAME_TO_HELP}.
#FIXME: Ah! We could even do one better, by caching into a map whose keys are
#script basenames and whose values are a null-delimited string list of all
#absolute dirnames containing such basename, *SORTED* alphabetically. The
#sorting is essential... err, perhaps it isn't. In any case, this should provide
#*EXTREMELY* efficient lookup. If such value contains only one string, we have
#our candidate; otherwise, search such value split on null. We're then looking
#for a dirname with the minimum distance to the current script's dirname. Sure,
#we could manually implement a Levenshtein or Hamming distance function,
#calculate each such distance, and take the dirname with the minimum distance.
#But that strikes me as overkill. Given the nature of POSIX paths, I see a
#simpler solution. If we can efficiently find the longest common prefix of both
#dirnames, then counting the total number of "/" characters in the remainder
#following such prefix in *BOTH* dirnames gives the total directory distance
#between such dirnames. Sweet, no? The question is: can we efficiently find
#longest common prefixes? I'm not completely sure, but a PCRE-based approach
#appears to work at least decently:
#
#* Append "/" to each dirname, if not already present. (This ensures the
#  correctness of the distance calculation.)
#* SCRATCH THIS (i.e., ignore): Determine which of the two dirnames is longer.
#* Ah-ha! Convert the current script's dirname to a PCRE as follows:
#  * Using a glob, replace every substring matching "([^/]##/)" to
#    "(${match[1]})?". Actually, that's not quite right; to ensure proper
#    nesting (and efficiency!), we need to nest such expressions. For example,
#    convert "/usr/share/zeshy/with/all/" to
#    "/(usr/(share/(zeshy/(with/(all/)?)?)?)?)?". Ah! Simple. Replace
#    each such substring with "(${match[1]}", then append ${X} number of ")?"
#    to the end of such string, where ${X} is 1 minus the number of "/"
#    characters in such string. This is probably easiest implemented with a glob-
#    based iterator, frankly. In any case, we have our PCRE!
#  * Then, just match each dirname split from such null-delimited list with such
#    PCRE. *EVERY* dirname is guaranteed to match. The longest common prefix is
#    given by iterating match groups, starting at -1 and ending at -${X}. The
#    last *NONEMPTY* match group giv... Actually, just concatenate match groups!
#    Why not, right? Then "${match[*]}" with IFS="/" should give the longest
#    common prefix. Sweet. This is rather eclectically cool, and probably
#    deserves its own function -- say, get_path_distance()? Can't imagine we'll
#    often need it, but... heck, it's there, anyway.
#  * Then, remove such longest common prefix from both dirnames and count the
#    total number of remaining "/" characters in such strings.
#  * It's all quite doable, really.
#* If such count is 1, stop prematurely. There can't be anything closer... Well,
#  there could be something equally as close but in the opposite direction. Hmm;
#  I suppose we should give precedence to subdirectories rather than parent
#  directories, yes? *sigh*

# See @{global} and @{function} for help strings for all globals and functions
# defined below, respectively.

# ....................{ GLOBALS                            }....................
# Map from parcel names to help strings documenting such parcels. Avoid formally
# documenting such map, which zeshy precompilation subsequently undefines (to
# conserve space). See also the following lists specific to top-level
# components, which precompilation converts into elements of related maps:
# ${ZESHY_CORE_HELP_ALIASES}, ${ZESHY_CORE_HELP_FUNCTIONS}, and
# ${ZESHY_CORE_HELP_GLOBALS}.
typeset -Ag ZESHY_PARCEL_NAME_TO_HELP

# Map from parcel names to null-delimited string lists of all aliases,
# functions, and globals declared by such parcel, respectively.
typeset -Agx\
    ZESHY_PARCEL_NAME_TO_ALIAS_NAMES\
    ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES\
    ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES

#FIXME: Reset to the empty string before its compilation into the digest file.
#This can be achieved with a late precompile hook, yes? This is important, as it
#ensures that all subsequent calls involving a parcel will throw an exception as
#desired (since the empty string is not an existing parcel -- hopefully, anyway!).

# Current parcel name. Since the value of such global is typically specific to
# the most recent zeshy script to have called declare_parcel_as_script(), avoid exporting
# such global to caller scripts.
typeset -g ZESHY_PARCEL_NAME

# ....................{ EXCEPTIONS                         }....................
function die_if_parcel() {
    (( # == 1 || # == 2 )) ||
        die 'expected one parcel name and optional error message'
    local parcel_name="${1}"
    is_parcel "${parcel_name}" &&
        die "${2:-parcel \"${parcel_name}\" already declared}"
}

function die_unless_parcel() {
    (( # == 1 || # == 2 )) ||
        die 'expected one parcel name and optional error message'
    local parcel_name="${1}"
    is_parcel "${parcel_name}" ||
        die "${2:-parcel \"${parcel_name}\" undeclared}"
}

# ....................{ TESTERS                            }....................
function is_parcel() {
    # See is_map_key() for further details.
    (( # == 1 )) || die 'expected one parcel name'
    (( ${+ZESHY_PARCEL_NAME_TO_HELP[${1}]} ))
}

# ....................{ SETTERS                            }....................
# To avoid tiresome timing issues, such functions are not called by this parcel
# Since such functions are called by top-level parcel "global", they cannot be
# relegated to "always/zeshy/parcel".

function set_parcel() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one parcel name'
    local parcel_name="${1}"
    die_unless_parcel "${parcel_name}"

    # Set such parcel.
    ZESHY_PARCEL_NAME="${parcel_name}"
}

function set_parcel_as_script() {
    # Validate passed arguments.
#   print -r -- "args: ${*}"
    (( # == 1 )) || die 'expected one parcel name'
    local script_name="${1}" parcel_name
    [[ -f "${script_name}" ]] || die "\"${script_name}\" not a script"

    # Set the current parcel to the absolute path of such script converted into
    # a parcel name.
    set_parcel "$(convert_path_to_parcel "${script_name}")"
}

# ....................{ CONVERTERS                         }....................
function convert_path_to_parcel() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one pathname'
    local parcel_name="${1}"
    [[ -e "${parcel_name}" ]] || die "\"${parcel_name}\" not found"

    # Canonicalize such path. See canonicalize_path() for further details.
    parcel_name="$(print -r -- "${parcel_name}"(:A))"

    #FIXME: I'd rather not another ad-hoc overlay to handle "~/.zeshy/config/"
    #script parcels. To avoid this, we'll want to have the *REAL* directory
    #containing such scripts be a new "~/.zeshy/overlay/if_config/" directory,
    #which "~/.zeshy/config" simply symbolically links to for user convenience.
    #This is quite a nice refactoring, actually, as it brings all zeshy scripts
    #to be compiled into the digest strictly under an overlay root. It also
    #simplifies our previously stated (and still quite sensible) intention of
    #sourcing *BOTH* "/usr/share/zeshy/if_config/"* and
    #"~/.zeshy/overlay/if_config/"* *WHENEVER* recompiling such digest.

    # Replace system-specific overlay prefixes with system-agnostic labels.
    # Note the lack of an "else" branch in the logic below. If such parcel is a
    # symbolic link to a script physically residing outside of a zeshy overlay,
    # both of the branches below fail. This is hardly ideal (due to portability
    # issues) but currently ignorable. Since most parcels reside in the system-
    # wide overlay, attempt to match such overlay first. Dismantled, this is:
    #
    # * "(#b)(*)", matching the fragment of such path following the unmatched
    #   directory of the overlay containing such path into ${match[1]}.
    # * "${match[1]#/}", removing a prefixing "/" from such path if present to
    #   avoid parcel names prefixed by "zeshy:///" or "zeshy.user:///".
        if [[ "${parcel_name}" == "${ZESHY_OVERLAY_DIR}"(#b)(*) ]] {
        parcel_name="zeshy://${match[1]#/}"
    } elif [[ "${parcel_name}" == "${ZESHY_USER_OVERLAY_DIR}"(#b)(*) ]] {
        parcel_name="zeshy.user://${match[1]#/}"
    }

    # Return such parcel.
    print -r -- "${parcel_name}"
}

# ....................{ ADDERS                             }....................
#FIXME: Technically, suffix aliases reside in a separate namespace and hence
#require separate handling. I can't really be bothered at the moment. Shouldn't
#be a terribly difficult change; just keep it in mind. For simplicity and
#orthogonality with nomenclature elsewhere, retain this function and simply add
#a new function add_parcel_alias_suffix(). Note we'll probably want to add a new
#subdirectory "15-alias/" containing the existing file "15-alias" and a new file
#"suffix" containing new declare_alias_suffix() functions.
function add_parcel_alias() {
    # Validate passed arguments. Since alias names can contain any character and
    # hence null used below to delimit alias names, escape nulls in such name.
    # See define_alias() for further details.
    (( # == 2 )) || die 'expected one parcel name and one alias name'
    local parcel_name__apa="${1}" alias_name__apa="${2//$'\0'/\\$'\0'}"
    die_unless_parcel "${parcel_name__apa}"

    # If this is the first alias to be added to such parcel, initialize such
    # list to simply this alias.
    if (( ${+ZESHY_PARCEL_NAME_TO_ALIAS_NAMES[${parcel_name__apa}]} )) {
        ZESHY_PARCEL_NAME_TO_ALIAS_NAMES[${parcel_name__apa}]="${alias_name__apa}"
    # Else, at least one alias has already been added to such parcel. Delimit
    # this alias from prior aliases with a null.
    } else {
        ZESHY_PARCEL_NAME_TO_ALIAS_NAMES[${parcel_name__apa}]+=$'\0'"${alias_name__apa}"
    }
}

function add_parcel_function() {
    # See add_parcel_alias() for further details.
    (( # == 2 )) || die 'expected one parcel name and one function name'
    local parcel_name__apf="${1}" function_name__apf="${2//$'\0'/\\$'\0'}"
    die_unless_parcel "${parcel_name__apf}"
    if (( ${+ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${parcel_name__apf}]} )) {
        ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${parcel_name__apf}]="${function_name__apf}"
    } else {
        ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${parcel_name__apf}]+=$'\0'"${function_name__apf}"
    }
}

function add_parcel_global() {
    # Since global names can only contain identifier characters and hence *NOT*
    # null, nulls need not be escaped. See add_parcel_alias() for further
    # details.
    (( # == 2 )) || die 'expected one parcel name and one global name'
    local parcel_name__apg="${1}" global_name__apg="${2}"
    die_unless_parcel "${parcel_name__apg}"
    if (( ${+ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES[${parcel_name__apg}]} )) {
        ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES[${parcel_name__apg}]="${global_name__apg}"
    } else {
        ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES[${parcel_name__apg}]+=$'\0'"${global_name__apg}"
    }
}

# ....................{ DECLARERS                          }....................
function declare_parcel() {
    # Validate passed arguments. If such parcel has already been declared, throw
    # an exception. Since parcels are typically associated with absolute paths,
    # this shouldn't ever occur. Make sure it doesn't!
    (( # == 2 )) || die 'expected one parcel name and one help string'
    local  parcel_name="${1}" help="${2}"
    print -r -- "declaring parcel \"${parcel_name}\""
    die_if_parcel "${parcel_name}"

    # If such name is not a path (i.e., contains null characters), throw an
    # exception. See documentation for further details.
    [[ "${parcel_name}" == *$'\0'* ]] &&
        die "parcel name \"${parcel_name}\" not a path (due to embedded null characters)"

    # Set the current parcel. See set_parcel() for further details.
    ZESHY_PARCEL_NAME="${parcel_name}"

    # Map such parcel name to such help string.
    ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"
}

# ....................{ DECLARERS ~ script                 }....................
function declare_parcel_as_script() {
    # Validate passed arguments.
    (( # == 1 || # == 2 )) ||
        die 'expected optional script name and one help string'
    local script_name="${ZESHY_SCRIPT_NAME}" help="${argv[-1]}"
    (( # == 2 )) && script_name="${1}"
    [[ -f "${script_name}" ]] || die "\"${script_name}\" not a script"

    # Convert from the absolute path of such script to a parcel name and declare
    # such parcel with such documentation.
    declare_parcel "$(convert_path_to_parcel "${script_name}")" "${help}"
}

function declare_parcel_as_script_with_stdin() {
    run_runnable_with_stdin declare_parcel_as_script "${@}"
}

# ....................{ RUNNERS                            }....................
function run_runnable_with_stdin() {
    # Validate passed arguments. If standard input is empty, throw an exception.
    # See is_stdin_nonempty() for further details.
    (( # )) || die 'expected one runnable name and optional arguments'
    read -t 0 || die 'standard input empty'
    local runnable_name__rrws="${1}"
    shift

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${runnable_name__rrws}" &>/dev/null ||
        die "runnable \"${runnable_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${runnable_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# ....................{ DOCUMENTERS                        }....................
declare_parcel_as_script_with_stdin <<'/---'
Handle parcel declarers. See declare_parcel() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
# If such name is not an absolute path (i.e., is
    # either not prefixed by "/" or contains null characters), such name is
    # invalid as a parcel name, so throw an exception. See @{parcel} for further
    # details.
    # If such parcel does not exist, throw an exception.
#   die_unless_parcel "${parcel_name}"

    # Else, set the current parcel to such parcel.
#   ZESHY_PARCEL_NAME="${parcel_name}"
#FUXME: declare_parcel_as_script() should call this function. WAIT. No. Full
#stop. We need a new convert_script_to_parcel() function. (I know, I know.) Just
#go gonzo, yo!
#is either not prefixed by "/" or 
#   [[ "${parcel_name}" != '/'* || "${parcel_name}" == *$'\0'* ]] &&
#       die "parcel \"${parcel_name}\" invalid (i.e., not an absolute path)"
#FUXME: O.K.; we don't actually require this here. Shift to "zeshy/parcel" and
#shift its documentation (currently in "10-function") with it. Huzzah!
    # Convert
#   parcel_name=

    # Since the implementation below fails to cleanly integrate with that of
    # declare_parcel(), reimplement rather than call such function.
    #
    # Map such parcel name to such help string *BEFORE* calling
    # set_parcel_as_script(), which throws an exception if this is not the case.
#   ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"

    # Set the current parcel to such parcel.
#   set_parcel_as_script "${parcel_name}"

    # Declare such parcel as such script path, canonicalized to avoid ambiguity
    # between parcels. See set_parcel_as_script() for further details.
#is absolute (e.g., `/usr/src/zeshy/always/os/os`), such path need _not_
#exist. Otherwise
    # Declare such parcel as such script path, canonicalized to avoid ambiguity
    # between parcels. See set_parcel_as_script() for further details.
#   declare_parcel "$(print -- "${script_name}"(:A))" "${help}"

#FUXME: Rename "parcel_as_script" to "parcel_as_script" everywhere.
#FUXME: Fairly important: shift set_parcel() back here and augment such function
#to replace ${ZESHY_OVERLAY_DIR} and ${ZESHY_USER_OVERLAY_DIR} when prefixing
#parcel names with "/zeshy/" and "/user/" prefixes, respectively.
#the directory of the overlay containing the passed script
#with a system-agnostic label indicating the overlay:
#FUXME: Yes, in hindsight, we probably want a separate string global
#${ZESHY_OVERLAY_DIR}, currently initialized to just ${ZESHY_HOME}. It's easy to
#conceive of scenarios in which such directory is a ${ZESHY_HOME} subdirectory,
#justifying such choice.
#documentation.
#While parcels have no bearing 
#Since digest files `zeshy`\'s user digest files 
#While such units 
#units, parcels form the building blocks for `zeshy`\'s online documentation and
#offline help systems.

#FUXME: Rename this to declare_parcel_script() and likewise below. Then, have
#such functions call a new declare_script() function, which should call a new
#set_parcel() function. declare_parcel_script() should thus perform the expected
#die_unless_file() routine. (See below.)
#FUXME: Rename set_parcel() to set_parcel_script(). Then, define a new
#set_parcel() function. For efficiency, set_parcel_script() should *NOT* call
#set_parcel().

#FUXME: For sanity, these should probably default the first argument to
#${ZESHY_PARCEL_NAME} if only passed one argument. Simplifies use elsewhere.
#FUXME: Fixup documentation.
    # Due to implementation details, avoid calling declare_parcel().
    # Nonetheless, ensure this function implements similar logic.

    # If such parcel has already been declared, throw an exception.
#   die_if_parcel_name "${parcel_name}"

    # Map such parcel name to such help string.
#   ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]="${help}"

    # Set the current parcel to such script. This internally converts such
    # script to a parcel name, necessitating we subsequently use
    # ${ZESHY_PARCEL_NAME} rather than ${script_name}.
#   set_parcel_as_script "${script_name}"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
#   (( ${+ZESHY_PARCEL_NAME_TO_HELP[${parcel_name}]} )) and
#       die "parcel \"${parcel_name}\" already declared"

#FUXME: Shift all such adders as well as die_unless_parcel(), is_parcel(), and
#whatever else we don't explicitly require here into new parcel "zsh/parcel".
    # Validate passed arguments.
#   (( # == 2 )) || die 'expected one script name and one help string'
#   local script_name="${ZESHY_SCRIPT_NAME}" help="${argv[-1]}"
#   is_args_2 and script_name="${1}"
#   die_unless_file "${script_name}"

    # Canonicalize such path to avoid ambiguity when cross-referencing parcels.
    # See canonicalize_path() for further details.
#   script_name="$(print -- "${script_name}"(:A))"

    # If such parcel has already been declared, throw an exception. Since
    # parcels are typically associated with unique paths, this should never
    # happen. Make sure it doesn't! See is_map_key() for further details.
#   (( ${+ZESHY_PARCEL_NAME_TO_HELP[${script_name}]} )) and
#       die "parcel \"${script_name}\" already declared"

    # Map such parcel name to such help string.
#   ZESHY_PARCEL_NAME_TO_HELP[${script_name}]="${help}"

    # Set the current parcel to such name.
#   ZESHY_PARCEL_NAME="${script_name}"

    #FUXME: O.K.; convert the script to a parcel name by stripping the prefix
    #corresponding to the current overlay root from such name. Again, we'll need
    #a similar global to "${ZESHY_SCRIPT_NAME}" expanding to the
    #absolute path of the current overlay root. Simple!
    #FUXME: Set the current parcel, as well.

    # Name of such parcel.
#   local parcel_name

#alias, global, and function help strings into
#logically related units.
# ....................{ DECLARERS                          }....................
#declare_function_with_stdin <<'/---'
#void declare_parcel_as_script(string documentation)
#
#Declare the current shell script to be a new parcel documented with the passed
#help string. See declare_parcel_as_script() for further details.
#/---
#function declare_parcel_as_script() {
#    (( # == 1 )) || die 'expected one help string'
#    declare_parcel_as_script "${ZESHY_SCRIPT_NAME}" "${1}"
#}

#FUXME: Are we not overthinking this? Why not simply rename "parcels" to
#"scripts", below?
#FUXME: "${0}" doesn't appear to expand to the current script name within
#functions. While we could hack about this, a simpler solution is to utilize a
#string global set by "src/compile". Yummm!
#FUXME: Shift to "03-global". Ah, wait. We can't declare globals without the
#corresponding aliases being defined. O.K.; we need to shift the
#"../01-type/variable" subdirectory here, then shift "03-global" there. Hmmm;
#perhaps not. "03-global" is really only valid *AFTER* sourcing all parcels in
#such subdirectory, so... perhaps we want:
#
#00-declare/
#   03-variable/
#   04-global
#
#Simpler, in terms of dependency management.
