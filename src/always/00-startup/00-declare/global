#!/usr/bin/env zsh
# ====================[ global                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle global declarers.

# ....................{ GLOBALS                            }....................
# Global map from global names to the help strings documenting such globals. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_GLOBAL_NAME_TO_HELP

# ....................{ DECLARERS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_global(string documentation)

Set the documentation for the global exported variable named by the variable
declaration prefixing the passed string to such string and, if such variable has
not already been declared, declare such variable to be global, exported, and of
the documented type. Variable documentation consists of:

. A *variable declaration* in Zeshy-specific C-like syntax, consisting of one
  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`).
. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
  with Zeshy-specific markup for cross-referencing other Zeshy documentation.

== Variable Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):

.Variable Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
| GlobalName            | <- | AlphanumericString
|===============================================================================

== Variable Type ==

A variable's type may be any alphanumeric string for which an alias of the same
name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
variable type but `order_of_the_blackened_denarius` is not, since
file_descriptor_global_export() is an existing alias but
order_of_the_blackened_denarius_global_export() is (hopefully) not.

Zeshy provides numerous such aliases and hence variable types, including:
`boolean`, `character`, `file_descriptor`, `float`, `integer`, `list`,
`list_set`, `map`, and `string`.
________________<heredoc?>________________
function declare_global() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help__dg="${1}"

    # If such documentation is prefixed by a variable declaration, match the
    # variable name and type from such declaration. Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    #
    # Else throw an exception with a portion of such documentation.
    [[ "${help__dg}" ==\
        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
        die_for_declarator_type_with_help 'global' "${help}"

    # Before attempting to declare such global, we should test whether such a
    # global already exists and if so either throw an exception or print a
    # warning. There exists no efficient means of performing such test, however.
    # While there do exist efficient means of testing whether a variable either
    # local or global exists and whether such variable in the current scope is
    # local or global, the only means of testing whether a global exists is to
    # parse the output of "typeset -gx +" for a line matching such global's
    # name. While such parsing could conceivably be efficient for infrequent
    # purposes, this function does not follow an infrequent purpose.

    # Such global's declared type and name.
    local global_type__dg="${match[1]}" global_name__dg="${match[2]}"

    # Alias declaring globals of such type.
    local declarator__dg="${global_type__dg}_global_export"

    # If such alias does not exist, throw an exception. Since such alias
    # could technically also be a function, match both. See is_runnable()
    # for further details.
#       print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
    whence -- "${declarator__dg}" &>/dev/null ||
        die "type \"${global_type__dg}\" unrecognized (${declarator__dg}() undefined)"

    # Declare such global. Since the declarator is typically an alias rather
    # than function or pathable, zsh requires evaluating rather than running
    # such declarator. While acceptable, this is somewhat... annoying.
    eval "${declarator__dg} \"\${global_name__dg}\""

    # Map such global name to such help string *AFTER* successfully declaring
    # such global.
    ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_global_with_stdin[stdin: string documentation]

Set the documentation for the global exported variable named by the variable
declaration prefixing standard input to such input. This function is the
standard input-specific analogue to declare_global(), which accepts a string
argument rather than standard input. See declare_function_with_stdin() for
further details on why this function is preferable to declare_global().
________________<heredoc?>________________

function declare_global_with_stdin() {
    run_runnable_with_stdin declare_global
}

# --------------------( WASTELANDS                         )--------------------
#       {
        # Global prototype prefixing such help string.
#       string help_prototype

        # If such string contains a newline (i.e., "\n"), crudely match the
        # substring preceding such newline as the global prototype.
#       if [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
        # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       die 'global help string invalid (see "print_help declare_global" for details):
#'"${help_prototype}"
#   }
