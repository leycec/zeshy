#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_with_stdin <<'______________<heredoc?>______________'
Handle function declarers.
______________<heredoc?>______________

#FIXME: Rename the ${ZESHY_HELP_GLOBALS}, etc. globals to
#${ZESHY_CORE_HELP_GLOBALS}, etc. Such globals, *DISTINCT* from the above, now
#apply *ONLY* to top-level components (e.g., src/{main,compile,...}). For
#efficiency (and simplicity), retain the current approach of simply appending to
#such lists. Then during zeshy precompilation (as implemented by
#"always/zsh/help/precompile"), simply iterate over each such list and for each
#help string simply call declare_global(), etc. Ultra-simple and efficient.
#After doing so, all documentation resides in the
#${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals as desired.

#FIXME: Not terribly fond of the noun "component", to be honest. It's rather
#lengthy. Conceivable alternatives:
#
#* "bundle". Decent, but I rather prefer "parcel".
#* "container". Non-ideal. Containers are lists and maps.
#* "capsule". Nice!
#* "parcel". Nice!
#* "package". Non-ideal. Packages are a larger-scale abstraction.
#* "unit". Possibly nice? A bit too terse and ambiguous, perhaps.
#
#Right. "parcel" really strikes me as the ideal candidate, at the moment. Shall
#we run with it?
#FIXME: Add declare_component() and declare_component_with_stdin() functions.
#It bears considering how we'll actually associate components with aliases,
#functions, and globals, considering that zsh does not support nested data
#structures. I suppose we'll need to pack everything into a map. How about
#${ZESHY_COMPONENT_NAME_TO_ALIAS_NAME} (and so forth for globals and functions),
#with structure resembling:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'declare' 'declare_alias:declare_function:declare_global'
#  )
#
#Hence, values are ":"-delimited function names. For globals, this clearly
#suffices, as global names are sufficiently constrained. For aliases and
#functions, however, we'll need to support double-quoted strings. Just double-
#quoted, to make things *MOSTLY* simple. The only complexity there is
#remembering to quote-protect embedded '"' characters in alias and function
#names.
#FIXME: Wait. Component names *MUST* also include internal structure --
#subdirectories (i.e., parent components), in this case. The above should be:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'always/00-startup/00-declare/declare'
#          'declare_alias:declare_function:declare_global'
#  )
#
#The reason why, of course, is that component names are only unique within such
#subdirectories.
#FIXME: Actually, avoid double-quoting strings containing colons. The far
#simpler solution is to prefix colons in alias and function names with "\". Such
#list is then splittable with a slightly more efficient PCRE matching colon
#separators with negative lookahead: e.g., "(?!\\):". Since there's no character
#alias and function names *CANNOT* contain, it's doubtful there's a more
#efficient approach. (Actually, I suppose we could try to find a UTF-8 character
#in the range 127 to 255 guaranteed... ah; forget it. Way too much bit hackery.)
#In any case, "(?!\\):" should certainly be efficient enough for *MOST* cases.
#FIXME: To minimize the number of characters that need to be escaped, why don't
#we just use null instead of colon? That then raises the obvious question: why
#don't we just stipulate that zeshy-specific alias and function names *CANNOT*
#contain nulls? To be fair, though, this single use probably doesn't warrant
#prohibiting nulls entirely. Just use a PCRE resembling "(?!\\)\0". (Yes, I've
#checked the PCRE documentation: a lone "\0" does indeed refer to binary zero.)
#Bam!

#FIXME: On calling declare_component(), we'll need to set a global caching the
#current component name (complete with subdirectories) -- say,
#${ZESHY_COMPONENT_NAME_CURRENT}. There's no need to persist such global after
#sourcing all zeshy components, so we should probably undefine it after that.

#FIXME: The above globals raise the obvious question: should we keep them in
#memory or serialize them to disk? For the most, I strongly suspect they're
#sufficiently small to impose no burden in memory. If this ever changes, we
#simply offload them to disk with a KVS-based implementation. Simple, no?

#FIXME: Remove all reference to {prepend,append,set}_args_with_stdin() from the
#Zeshy codebase, excluding set_args_with_stdin() where called from herestring-
#style aliases. In all other cases, such calls are highly dangerous and should
#be eliminated.
#FIXME: Wait. I believe we *MIGHT* be able to resuscitate such function *IF* we
#can augment them as follows (...no idea if this works, but it seems worth a
#try):
#
#* If standard input is an open pipe *AND* if list global ${pipestatus} is of
#  size larger than one, then doesn't that definitively suggest the current
#  function is directly piped standard input? Naturally, we should extensively
#  test this in vanilla zsh before running around like a mad badger attempting
#  to implement this in Zeshy.

#FIXME: Naturally, AsciiDoc will be an only optional dependency for users
#attempting to build the documentation. If not installed, we'll just display
#function documentation as is when a user runs "help function". If installed,
#we'll probably want to pipe function documentation dynamically through either
#the ASCII or man page exporters. (Sweeeeeet, no?)

#FIXME: Matching function prototypes is feasible with one or possibly more PCREs
#but *NOT* globs, due to the need to match arbitrarily many function names and
#argument specifiers. This is essential, since:
#
#* If AsciiDoc is installed, function prototypes should be dynamically marked up
#  with AsciiDoc-specific notation, which I believe even supports colors.
#* Else, function prototypes should be styled with conventional color styles.
#FIXME: Source code highlighting is simple. Just write:
#
#    [source,bash]
#    ----
#    INSERT CODE HERE
#    ----
#
#Sadly, neither Pygments or other less popular alternatives support zsh yet.
#Hence, "bash" suffices. Then, we want to selectively prefer "pygments" where
#available. To do so, we'll need to output the following at the very top of each
#AsciiDoc document we send to "asciidoc":
#
#    8<---------------
#    = Title
#    :source-highlighter: pygments
#
#This is an AsciiDoc header instructing "asciidoc" to prefer the "pygments"
#backend for the [source] filter. For further details, see:
#    https://groups.google.com/forum/?fromgroups=#!topic/asciidoc/ReIM4z-zi9I
#FIXME: Avoid repetition. In particular, replace "[source,bash]" with simply
#"[source]" everywhere by setting the default "language" in the AsciiDoc
#document header, like so:
#
#    :language: bash
#
#The same style can be extended to set default table attributes as follows:
#
#    :grid:  none
#    :frame: topbot

#FIXME: Documentation functions should continue working after Zeshy startup. To
#make this work, we'll need to redefine them in a precompile_zeshy_() function
#to ensure that the digest file contains the redefinition. Honestly, I'm not
#entirely convinced we want to serialize such documentation to disk; of course,
#we *DO*. But that invokes a few not-so-subtle issues. For now, just retain
#documentation in memory until it becomes a demonstrable problem.
#FIXME: After having performed a great deal of online research, "gzip" appears
#to be the canonical go-to for small text file compression.
#FIXME: Hmmmm. No. Scratch that. We really need a filesystem-based approach.
#O.K.; so, here's the idea:
#
#* Shift the definitions of set_alias_documentation(), etc. to this component,
#  replacing all current calls to such functions with hard-coded additions to
#  such map globals. *DO IT.* Trust me. This is needed to ensure that such
#  functions are compiled into Zeshy's digest file.
#* *DON'T* redefine declare_alias(), declare_function(), or declare_global().
#  Instead redefine set_alias_documentation(), etc. to write to disk rather to
#  such map globals in the precompile_zeshy_*() function defined below, thus
#  ensuring the redefinition of such functions is compiled into Zeshy's digest.
#
#Bam. Nice one, eh?

# ....................{ GLOBALS                            }....................
#FIXME: Don't neglect to delete such maps immediately after use in
#precompilation!

# Global map from function names to the help strings documenting such functions.
# See ${ZESHY_PARCEL_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_FUNCTION_NAME_TO_HELP

# Map from synonymized function names to the first function names declared for
# such functions. See @{global} for such global's documentation.
typeset -Agx ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME

# ....................{ DECLARERS                          }....................
# See below for function documentation.
function declare_function() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help__df="${1}"

    # Unless such string matches the function help PCRE, throw an exception.
    [[ "${help__df}" =~\
        ${ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES} ]] ||
        die_for_declarator_type_with_help 'function' "${help__df}"
#   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
#       print "match ${match_index}: ${match[${match_index}]}"
#   }

    # List of substrings captured by the prior match. The PCRE-based iteration
    # below overwrites ${match}, necessitating we copy it here.
    local -a help_match__df; help_match__df=( "${match[@]}" )

    # List of function names matched from such string.
    local -a function_names__df

    # If such function has only a single name, match such name.
    if [[ -n "${help_match__df[2]}" ]] {
        function_names=( "${help_match__df[2]}" )
    # Else, such function has multiple names. Since single- and double-quoted
    # function names may contain commas, such names cannot be split on commas as
    # with function attributes above. Rather, match such names with iteration.
    } else {
        # Prepare to match such names.
        pcre_compile -- "${ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_NAME}"
        pcre_study

        # Match such names, recording each to be a synonym of the first such
        # name matched above. See for_string_pcre_matches() for further details.
        local ZPCRE_OP='0 0'
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match__df[3]}" } {
            function_names__df+="${match[1]}"
            ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[${match[1]}]="${function_names__df[1]}"
        }
    }
#   for ((match_index=1; match_index <= ${#names}; ++match_index)) {
#       print "name ${match_index}: ${names[${match_index}]}"
#   }

    # If such function has attributes, match such attributes.
    if [[ -n "${help_match__df[1]}" ]] {
        # List of function attributes split from such string. Split on commas
        # after truncating:
        #
        # * Optional whitespace surrounding commas (e.g., from " , " to ",").
        # * Optional trailing commas and/or whitespace.
        local -a attributes__df; attributes__df=(
            "${(s:,:)${help_match__df[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]#,#[[:space:]]#}"
        )
#       for ((match_index=1; match_index <= ${#attrs}; ++match_index)) {
#           print "attr ${match_index}: ${attrs[${match_index}]}"
#       }

        # If such attributes include "globbable," disable filename globbing for
        # all arguments passed to such function names. See is_list_contains()
        # for further details.
        if (( ${attributes__df[(i)globbable]} <= ${#attributes__df} )) {
            for function_name ("${function_names__df[@]}") {
                # For safety (in the event of function names containing alias-
                # reserved characters), call define_alias() rather than manually
                # defining such alias.
                define_alias\
                    "${function_name__df}" "noglob \"${function_name__df}\""
            }
        }
    }

    # Add all such functions to the current parcel.
    for function_name__df ("${function_names__df[@]}") {
        add_parcel_function\
            "${ZESHY_PARCEL_NAME}" "${function_name__df}"
    }

    # Map the first function name to such help string. Note the choice of
    # mapping function name synonyms to the first function name above, as well;
    # this is *NOT* a coincidence, as could be inferred.
    ZESHY_FUNCTION_NAME_TO_HELP[${function_names__df[1]}]="${help__df}"
}

# See below for function documentation.
function declare_function_with_stdin() {
    run_runnable_with_stdin declare_function
}

# See below for function documentation.
function die_for_declarator_type_with_help()
    # Validate passed arguments.
    (( # == 2 )) || die 'expected one type string and one help string'
    local type="${1}" help="${2}"

    # Function prototype prefixing such help string.
    local help_prototype

    # If such string contains a blank line (i.e., "\n\n"), crudely match the
    # substring preceding such line as the function prototype.
    if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
        help_prototype="${match[1]}"
    # Else if such string contains a newline (i.e., "\n"), crudely match the
    # substring preceding such newline as the function prototype.
    } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
        help_prototype="${match[1]}"
    # Else, abandon all hope.
    } else {
        help_prototype="${help}"
    }

    # Throw an exception suffixed by such prototype.
    die "${type} help string invalid (see \"print_help declare_${type}\"):
${help_prototype}"
}

# ....................{ DOCUMENTERS                        }....................
# Document functions previously defined by this parcel.

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_function(string documentation)

Set the documentation for the function named by the function prototype prefixing
the passed string to such string. Function documentation consists of:

. A *function prototype* in Zeshy-specific C-like syntax, consisting of zero or
  more function attributes, one or more function return types, one or more
  function names, and zero or more function arguments (e.g.,
  `<globbable> boolean <ruth, benedict>(integer siphon, character funnel)`, a
  function with one attribute `globbable`, one return type `boolean`, two names
  `ruth` and `benedict`, and two arguments `siphon` and `funnel`).
. A *function description* in http://asciidoc.org[AsciiDoc] syntax augmented
  with Zeshy-specific markup for cross-referencing other Zeshy documentation
  (e.g., `Everyone _believes_ that the *man* +atop+ the box _owns_ the fish()`).

== Function Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:

[[declare_function.peg]]
.Function Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| FunctDocumentation    | <- | FunctPrototype Whitespace+ AsciiDoc
| http://asciidoc.org[AsciiDoc] | <- | (XReference \| AnyCharacter)*
| XReference            | <- | WordStart XReferObject WordEnd
| XReferObject          | <- | XReferAliasOrFunct \|
                               XReferAlias \|
                               XReferFunct \|
                               XReferGlobal
| XReferAliasOrFunct    | <- | AlphanumericString ``()''
| XReferAlias           | <- | ``alias:''    XReferAliasOrFunct
| XReferFunct           | <- | ``function:'' XReferAliasOrFunct
| XReferGlobal          | <- | ``${'' AlphanumericString ``}''
| FunctPrototype        | <- | Whitespace* FunctAttrs
                               Whitespace* ReturnTypes
                               Whitespace+ FunctNames
                               Whitespace* FunctArgs
| FunctAttrs            | <- | ``{'' Whitespace*
                               (FunctAttr ListComma)*
                                FunctAttr ListCommaOptional
                               Whitespace* ``}''
| FunctAttr             | <- | ``globbable''
| ReturnTypes           | <- | Type \| ReturnChannels
| Type                  | <- | AlphanumericString
| ReturnChannels        | <- | ``['' Whitespace*
                               (ReturnChannel ListComma)*
                                ReturnChannel ListCommaOptional
                               Whitespace* ``]''
| ReturnChannel         | <- | ReturnChannelName Whitespace* ``:'' Whitespace*
                               Type
| ReturnChannelName     | <- | ``stdout'' \| ``stderr'' \| ``status''
| FunctNames            | <- | FunctName | FunctNameList
| FunctName             | <- | AlphanumericString |
                               SingleQuotedString |
                               DoubleQuotedString
| FunctNameList         | <- | ``<'' Whitespace*
                               (FunctName ListComma)*
                                FunctName ListCommaOptional
                               Whitespace* ``>''
| FunctArgs             | <- | FunctArgList \| FunctArgChannels
| FunctArgChannels      | <- | ``['' Whitespace*
                               (FunctArgChannel ListComma)*
                                FunctArgChannel ListCommaOptional
                               Whitespace ``]''
| FunctArgChannel       | <- | FunctArgChannelName Whitespace* ``:'' Whitespace*
                               (FunctArg \| FunctArgList)
| FunctArgChannelName   | <- | ``args'' \| ``stdin''
| FunctArgList          | <- | ``('' Whitespace*
                               (FunctArgsEmpty \| FunctArgsNonEmpty)
                               Whitespace* ``)''
| FunctArgsEmpty        | <- | FunctArgEmpty?
| FunctArgsNonEmpty     | <- | (FunctArgNonEmpty ListComma)*
                                FunctArgNonEmpty ListCommaOptional
| FunctArg              | <- | FunctArgEmpty \| FunctArgNonEmpty
| FunctArgEmpty         | <- | ``void''
| FunctArgNonEmpty      | <- | Type  Whitespace+ FunctArgName (Whitespace*
                               ``='' Whitespace* FunctArgDefaultValue)?
| FunctArgName          | <- | AlphanumericString
| FunctArgDefaultValue  | <- | ZshValue
| ListComma             | <- |  Whitespace* ``,'' Whitespace*
| ListCommaOptional     | <- | (Whitespace* ``,'')?
| ZshValue              | <- | Integer \| Float \|
                               SingleQuotedString \| DoubleQuotedString
| Integer               | <- | ``-''? Digit+
| Float                 | <- | ``-''? Digit+ ``.'' Digit+
| SingleQuotedString    | <- | ``\''' (``\'\''' \| !``\''' AnyCharacter)* ``\'''
| DoubleQuotedString    | <- | ``"''  (``\\"''  \| !``"''  AnyCharacter)* ``"''
| AlphanumericString    | <- | (!(Whitespace \| Punctuation) AnyCharacter)*
| Whitespace            | <- | `` '' \| ``\\t'' \| ``\\n''
| Punctuation           | <- | ``('' \| ``)'' \| ``['' \| ``]'' \| ``{'' \| ``}'' \|
                               ``,'' \| ``='' \| ``:'' \| ``"'' \| ``\'''
| Digit                 | <- | ``0'' \| ``1'' \| ``2'' \| ``3'' \| ``4'' \| ``5'' \|
                               ``6'' \| ``7'' \| ``8'' \| ``9''
| AnyCharacter          | <- | Whitespace \| Punctuation \| Digit \| ``a'' \| ...
|===============================================================================

== Function Description ==

Function descriptions follow http://asciidoc.org[AsciiDoc] syntax augmented to
support Zeshy-specific cross-references of aliases, functions, and globals. To
cross-reference another:

* zsh alias or function, suffix such alias or function name with `()` (e.g.,
  `declare_function()`). If both an alias _and_ function share such name, the
  cross-reference refers only to the alias (in keeping with zsh behavior). For
  genericity, this is generally preferable to the next two disambiguations.
* zsh alias, prefix such name with `alias:` and suffix such name with `()`
  (e.g., `alias:catch()`).
* zsh function, prefix such name with `function:` and suffix such name with `()`
  (e.g., `function:catch()`).
* zsh global, prefix such name with `${` and suffix such name with `}` (e.g.,
  `${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}`).

== Function Prototypes ==

Function prototypes follow a C-like syntax supporting zsh features not commonly
found in conventional high-level languages: function name synonyms and return
and argument channels. Since zsh does _not_ currently support function
prototypes, we cannot coerce zsh to respect or enforce such prototypes at
runtime. Zeshy can, however, convert such prototypes to syntax-highlighted,
contextually-linked specifications in end-consumer documentation.

=== Context-sensitivity ===

In conventional high-level languages, a function is typified by its *signature*:
the set of function name(s), return type(s), and argument type(s) uniquely
identifying that function. Each signature is statically predefined at function
declaration time and either not subject to subsequent change or changeable only
by redeclaring its function.

In zsh, a function is typified only by the set of its names. Since this is
hardly a signature in the conventional sense, zsh functions have arguably no
function signature and certainly no statically predefined set of return type(s)
and/or argument type(s). Rather, these types are the implicit result of dynamic
implementation details possibly depending on local, global, or external state --
which is to say, effectively anything you'd like.

For example, it's possible (though a pretty bad idea) to define a function
accepting at least one string argument and conditionally changing both return
and argument types in context-dependent relation to such argument as follows:

* If such argument is "hexadecimal -> decimal", accept a second string in
  base 16 hexadecimal format and return the equivalent base 10 integer.
* If such argument is "string1, ... -> list", accept one or more additional
  strings and return the concatenation of such strings as a string convertible
  without error into a list of such strings by the caller.
* If such argument is "stdin == 'clear' ? string -> void : void -> string", test
  whether such function was piped standard input equal to string "clear". If so,
  accept a second string signifying the name of a list to be cleared; otherwise,
  accept no additional strings and return a string of random bytes.

This rabbit hole goes deep. Since supporting such conditionality is infeasible
(and arguably undesirable), [underline]#this function naively assumes all function
signatures to be statically predefined at function declaration time#. For
signatures for which this is not the case (as in the above example), consider
documenting only the most commonly called signature in the function prototype.

=== Function Attributes ===

Functions may be annotated with a list of Zeshy-specific function attributes.
Declaring a `{`- and `}`-bracketed list of one or more `,`-delimited attribute
names annotates such function with such attributes, which this function parses
and dynamically enables. The following attributes are currently supported:

==== globbable =====

`globbable`, signifying this function's arguments to _not_ be subject to
conventional filename globbing and hence to be passed to such function as is. By
default, all function arguments _are_ subject to such globbing, preventing glob
expressions from being passed as function arguments unless explicitly quoted or
escaped. Enabling this attribute on a function disables such behavior for all
arguments callers pass such function: e.g.,

.Globbable Function
==========================================
[source]
------------------------------------------
>>> declare_function '
... <globbable> [status: boolean] is_string_matcheses(string text, string glob)
...
... A function that may be passed unquoted glob expressions.
... '
>>> function is_string_matcheses() { is ${1} == ${~2} si }
>>> is_string_matcheses satoshi_nakamoto *n[aeou]k[aeou]* and print metzdowd
metzdowd
------------------------------------------
==========================================

Internally, this attribute is implemented by defining a new alias of the same
name expanding to such function prefixed by `noglob` (e.g.,
`alias ${function_name}="noglob ${function_name}"`).

=== Return Types ===

zsh return types are more intricate than those of normal high-level languages.
All functions return three *channels* (i.e., ``streams'' of orthogonal output):

. A string of standard output.
. A string of standard error.
. A byte of exit status.

==== Single Return Type ====

Since most functions only output to standard output and throw exceptions rather
than return non-zero exit status on failure, shorthand notation suffices for
such functions. Declaring a single return type as in conventional high-level
languages (e.g., `integer hikikomori(string otaku)`) signifies such function to
always return a string of standard output convertible without error to such
type, an empty string of standard error, and zero exit status (i.e., success).

===== Non-Scalar Return Types =====

Zeshy provides aliases for both returning and receiving returned lists and maps,
suggesting `list` and `map` are acceptable return types from either standard
output or error. Since returning such types incurs a significant performance
penalty, consider only returning such types for sufficiently small lists and
maps (noting that ``small'' has yet to be rigorously defined).

==== Mapped Return Types ====

Some functions output to standard error and/or return non-zero exit status,
necessitating a longhand notation mapping each of the three possible return
channels (standard output, standard input, and exit status) to the return type
such function returns on such channel. Specifically, declaring a `[`- and `]`-
bracketed map of one to three `,`-delimited, `:`-separated key-value pairs
mapping return channel to return type (e.g.,
`[stdout: float, stderr: string, status: integer] nhk(string kyokai)`)
signifies such function to return standard output and error strings and exit
status convertible without error to such types.

At least one such key-value pair must be declared. The value declares the
return type that channel returns (e.g., `string`). The key identifies the
channel itself via one of three case-insensitive strings:

* `stdout`, the standard output channel. Returns any conventional type or
  `void`, a pseudo-type signifying such function to return no standard output.
  Defaults to `void` if unspecified.
* `stderr`, the standard error return channel. Returns any conventional type or
  `void`, a pseudo-type signifying such function to return no standard error.
  Defaults to `void` if unspecified.
* `status`, the exit status return channel. Returns only the following
  numerical return types (defaulting to `true` if unspecified):
  ** `true`, a pseudo-type signifying such function to always succeed (ignoring
     exceptions). While `true` and `false` are values rather than genuine types,
     mere technicalities are merely that.
  ** `false`, a pseudo-type signifying such function to always fail. Since Zeshy
     implicitly throws exceptions on failure, such type is generally unhelpful.
  ** `boolean`, signifying such function to return exit status 0 on success or 1
     on failure. Most such functions are `is_`-prefixed *testers* returning only
     `[status: boolean]` and hence no standard output or error (e.g.,
     `[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).
  ** `integer`, signifying a function returning more than merely exit statuses 0
     and 1 (e.g., `grep`, returning 0 on match, 1 on no match, and 2 on error).

Return types thus default to map `[stdout: void, stderr: void, status: true]`.
For example, the following prototypes all equivalently define a function
accepting no arguments, returning a string convertible without error to a float
from standard output and no standard error, and always succeeding:

.Mapped Return Types
==========================================
* `float ukigumo(void)`.
* `[stdout: float] ukigumo(void)`.
* `[stdout: float, stderr: void] ukigumo(void)`.
* `[stdout: float, status: true] ukigumo(void)`.
* `[stdout: float, stderr: void, status: true] ukigumo(void)`.
==========================================

=== Function Names ===

zsh function names are more intricate than those of normal high-level languages.
All functions have one or more names, declared at function declaration time by
listing such names delimited by whitespace. Sadly, documentation requires re-
listing such names delimited by commas and bracketed by `<` and `>`. While such
repetition is regrettable, zsh's lack of prototyping support affords us no
alternatives: e.g.,

.Function Name Synonyms
==========================================
[source]
------------------------------------------
>>> declare_function '
... void name, synonym, pseudonym, anonym(void)
...
... A function callable as either name(), synonym(), pseudonym(), or anonym().
... '
>>> function name synonym pseudonym anonym() { print 'nom de plume' }
>>> name
nom de plume
>>> pseudonym
nom de plume
------------------------------------------
==========================================

=== Function Arguments ===

As expected, zsh function arguments are more intricate than those of normal
high-level languages. All functions accept two *channels* (i.e., ``streams'' of
orthogonal input):

. A passed argument list.
. A string of standard input.

[[declare_function.argument_list]]
==== Single Function Argument List ====

Since most functions only accept passed argument lists rather than standard
input, shorthand notation suffices for such functions. Declaring a single `(`-
and `)`-bracketed argument type list of one or more `,`-delimited argument
declarations consisting of a whitespace-delimited type and name followed by
optional `=` and default value in typical zsh syntax as in normal high-level
languages (e.g., `void the(string ultimate, integer question = 42)`) signifies
such function to accept only such arguments with no standard input.

===== Function Argument Names =====

Argument names should contain no whitespace or punctuation, much like real zsh
variable names. While argument names need not correspond to the actual variable
name (if any) the function implementation copies such argument into, this is
generally considered good form.

===== Function Argument Types =====

Argument types are any single scalar types (e.g., `boolean`, `integer`), thus
excluding `void`, `list`, and `map`. Since argument lists are lists, consider
passing read-only lists as arguments and lists to be modified as the names of
such lists. While maps can be packed into argument lists, consider always
passing maps as the names of such maps. When passing the name rather than value
of variables, consider mangling *ALL* variable names declared in the function
implementation in a function-specific manner to avoid accidentally overriding
externally with internally declared variables. Zeshy heuristically mangles by
appending `__` followed by the first letter of each word in the function name,
which suffices for most purposes. For readability, avoid mangling documented
argument names. For example:

.Function Argument Mangling
==========================================
[source]
------------------------------------------
declare_function '
void set_list_to_raspberry_hybrids(string list_name, string flavor)

Set the passed list to all known raspberry hybrids of the passed flavor.
'
function set_list_to_raspberry_hybrids() {
    # Validate passed arguments.
    die_unless_args_2 'expected one list name and one raspberry flavor'
    string list_name__sltrh="${1}" flavor__sltrh="${@[-1]}"
    die_unless_list "${list_name__sltrh}"

    # Set such list.
    if { is_string_equals "${flavor}" acidic }
        eval "${list_name__sltrh}=( loganberry )"
    } else {
        eval "${list_name__sltrh}=( tayberry )"
    }
}
------------------------------------------
==========================================

===== Function Argument Default Values =====

Default argument values are any valid right-hand side of a scalar assignment,
including double-quoted strings nesting arbitrarily deep process substitutions
(e.g., `(string dirname = "$(is_superuser and "/o" or "$(get_dir)")")`). For
safety, Zeshy *never* evaluates such values, which may thus contain executable
code known to have dangerous side-effects. (Naturally, this is not a good idea.)

===== Empty Function Argument List =====

Functions accepting no arguments may declare an argument list of either:

* `()' as in shell languages.
* `(void)` as in C-like languages.

===== Variadic Function Function Argument List =====

Functions accepting arbitrarily many arguments of the same type (referred to as
``variadic functions'' elsewhere) should declare only the first such argument
including optional default value followed by `, ...`. When a default value is
declared, any number of such arguments may be passed; then if a caller passes no
such arguments, the function defaults to a single argument of the default value.
When no default value is declared, at least one such argument must be passed.
Such arguments may be preceded and followed by other arguments. For example:

.Variadic Function
==========================================
[source]
------------------------------------------
declare_function '
void uhoh(integer mtime, string dirname1 = "/", ..., boolean is_recursive)

A function accepting an integer, zero or more dirnames defaulting to "/" if
no such strings are passed, and a boolean -- usually doing something rather
dangerous.
'
function uhoh() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one integer, optional dirnames, and one boolean'
    string mtime="${1}" is_recursive="${@[-1]}"
    die_unless_integer "${mtime}"
    die_unless_boolean "${is_recursive}"

    # Remove such integer and boolean from the argument list. All remaining
    # arguments, if any, are dirnames.
    shift_arg
    pop_arg

    # If no arguments remain, default to "/".
    is_args or set_args "/"

    # Do something rather dangerous.
    print "Mu-haha! [${mtime}]"
    if is_boolean_true "${is_recursive}"
    then ls -R -- "${@}"
    else ls    -- "${@}"
    fi
}
------------------------------------------
==========================================

==== Mapped Function Argument List ====

Some functions also accept standard input, necessitating a longhand notation
mapping each of the two possible argument channels (passed argument list and
standard input) to the argument type list such function accepts on such channel.
Specifically, declaring a `[`- and `]`-bracketed map of one to two `,`-
delimited key-value `:`-separated pairs mapping argument channel to argument
type list signifies such function to accept passed argument strings and a string
of standard input convertible without error to such types (e.g.,
`void taake[args: (string hordaland1, ...), stdin: string vi]`).

At least one such key-value pair must be declared. Each key is any of the
following case-insensitive strings:

* `args`, the *passed arguments* argument channel.
* `stdin`, the *standard input* argument channel.

Each value identifies the arguments such channel accepts in either:

* _Shorthand notation_, a
  <<declare_function.argument_list,single argument declaration>> consisting of
  either:
** A whitespace-delimited type and name followed by optional `=` and default
   value in typical zsh syntax, signifying such function to accept only that
   argument on such channel (e.g.,
   `void chomsky[args: boolean the_purpose, stdin: integer of_education]`).
** `void`, a pseudo-type signifying such function to accept _no_ arguments on
   such channel.
* _Longhand notation_, a `(`- and `)`-bracketed list of one or more `,`-
  delimited <<declare_function.argument_list,argument declarations>>,
  signifying such function to accept all such arguments on that channel (e.g.,
  `void kropotkin[args: (integer mutual1, ...), stdin: (integer aid1, ...)]`).

Argument list types thus default to map `[args: void, stdin: void]`. For
example, the following prototypes all equivalently define a function
accepting a string convertible without error to a character on the passed
argument list and no standard input, and always succeeding:

.Mapped Return Types
==========================================
* `void kurosawa(character red_beard)`.
* `void kurosawa[args: character red_beard]`.
* `void kurosawa[args: (character red_beard)]`.
* `void kurosawa[args: (character red_beard), stdin: void]`.
==========================================

________________<heredoc?>________________

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_function_with_stdin[stdin: string documentation]

Set the documentation for the function named by the function prototype prefixing
standard input to such input. This function is the standard input-specific
analogue to declare_function(), which accepts a string argument rather than
standard input. Function documentation adheres to http://asciidoc.org[AsciiDoc]
syntax conflicting with both single- and double-quoted zsh string syntax and
hence cannot reliably be passed as a string argument. Such conflicts include:

* AsciiDoc-specific paired single quote, conflicting with zsh-specific single-
  quoted string escapes (e.g., '``The Bastion''', a double-quoted string in
  AsciiDoc that zsh reduces to "``The Bastion'").
* AsciiDoc-specific paired backticks, conflicting with zsh-specific double-
  quoted string process substitution (e.g., "`the' `stranger'", a pair of
  single-quoted strings in AsciiDoc that zsh attempts to substitute with the
  output of running the external command "the' ").

By accepting standard input in lieu of string arguments, this function allows
documentation containing such conflicts to be defined by here-documents: e.g.,

.Here-documented Function
==========================================
[source]
------------------------------------------
declare_function_with_stdin <<'________________<heredoc!>________________'
void armok(string god, character of, boolean blood)

``Losing'' is `fun`.
________________<heredoc!>________________
''
------------------------------------------
==========================================

See declare_function() for further details.
________________<heredoc?>________________

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_for_declarator_type_with_help(string namespace, string documentation)

Throw an exception describing a failure to declare a `zsh` object of the passed
namespace (i.e., `alias`, `global`, `function`) documented by the passed help
string. This utility function is intended to be called by only declare_alias(),
declare_global(), and declare_function().
________________<heredoc?>________________

# ....................{ DOCUMENTERS                        }....................
# Document functions previously defined by @{parcel} under such parcel, rather
# than the current parcel.

declare_parcel_with_stdin\
    "$(dirname -- "${ZESHY_SCRIPT_NAME}")/"*'-parcel'\
    <<'______________<heredoc?>______________'
Handle parcel declarers. See declare_parcel() for further details.
______________<heredoc?>______________

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_parcel(
    string script_name = "${ZESHY_SCRIPT_NAME}",
    string documentation)

Declare the passed `zeshy` script (defaulting to the currently sourced script)
to be a new parcel, documented with the passed help string.

== Parcels ==

*Parcels* are `zeshy`-specific abstractions associating all aliases, globals,
and functions subsequently declared in such script with such script. While most
high-level languages provide native support for such abstractions (e.g., `perl`
packages, `python` modules, `ruby` gems), `zsh` does not. Even if `zsh` did,
however, `zeshy`\'s compilation of its codebase into a ``flat'' digest file
would likely render such abstractions moot.

Parcels provide a useful, if limited, pure-`zsh` facsimile of the conventional
package motif. By aggregating logically related `zsh` objects into abstract
units, parcels form the building blocks of `zeshy`\'s online documentation and
offline help system.
________________<heredoc?>________________

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_parcel_with_stdin[
    args: string script_name = "${0}", stdin: string documentation]

Declare a new *parcel* (i.e., `zeshy`-specific abstractions containing aliases,
parcels, and functions) corresponding to the passed shell script (defaulting to
the current shell script) documented with standard input. This function is the
standard input-specific analogue to declare_parcel(), which accepts a string
argument rather than standard input. See declare_function_with_stdin() for
further details on why this function is preferable to declare_parcel().
________________<heredoc?>________________

declare_function_with_stdin <<'________________<heredoc?>________________'
void run_runnable_with_stdin[
    args: (string runnable_name, string argument1, string argument2, ...),
    stdin: string input]

Run the passed *runnable* (i.e., alias, function, command), passing such
function first all passed arguments in the passed order and finally all standard
input to this function as a single argument. For safety, this function closes
such input immediately after running such runnable: e.g.,

.run_runnable_with_stdin()
==========================================
[source]
------------------------------------------
>>> string on_commodities=\
...     "In proportion as the bourgeoisie, i.e., capital, is developed, in the
...      same proportion is the proletariat, the modern working class, developed
...      â€” a class of labourers, who live only so long as they find work, and
...      who find work only so long as their labour increases capital. These
...      labourers, who must sell themselves piecemeal, are a commodity, like
...      every other article of commerce, and are consequently exposed to all
...      the vicissitudes of competition, to all the fluctuations of the market."
>>> output_string "${on_commodities}" | run_runnable_with_stdin head -2 -
In proportion as the bourgeoisie, i.e., capital, is developed, in the
same proportion is the proletariat, the modern working class, developed
------------------------------------------
==========================================
________________<heredoc?>________________

# --------------------( WASTELANDS                         )--------------------
    # Add each such function to the current parcel. For efficiency, inline such
    # iteration. See add_parcel_alias() for further details.
#   for function_name__df ("${function_names__df[@]}") {
#       ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${ZESHY_PARCEL_NAME}]+=$'\0'"${2//$'\0'/\\$'\0'}"
#   }

#Handle *parcel* (i.e., `zeshy`-specific abstractions containing aliases,
#parcels, and functions) declarers.
#FUXME: Actually call this in such functions.
#FUXME: So what should component documentation contain? It's fairly simple, I
#think: *ALL* component documentation should be AsciiDoc. We could support a
#prefixing prototype, but I fail to see how that's helpful. The current
#component name is perfectly inferrable from the current path -- no need to
#duplicate it unnecessarily. Great!
#FUXME: Rename to run_function_passed_stdin() or run_runnable_with_stdin().
#FUXME: A bit discontent with the current structure. Shift this and
#declare_function_with_stdin() to a new component "00-function". Rename this
#component to "declare", retaining all existing functions. Shift "define" and
#"document" here. Last, shift declare_function*() documentation to
#"00-function". I know, I know. But it's worth it.
#FUXME: O.K.; the above is essentially correct. What we specifically want,
#however, are the following three subcomponents with the expected content:
#"00-function", "alias", and "global". Simple. Elegant. Go-go!

# Component "document" declares and documents all other pertinent globals (e.g.,
# ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME}).
#FUXME: I submit we should define a syntax for embedding function attributes in
#function documentation and having declare_function() itself parse and handle
#such attributes. For the moment, I can only think of one such attribute:
#"globbable". Define such attribute like so:
#
#   <globbable> void happy_go_lucky(void)
#
#Dead simple, yes? What's great about this is that it formally associates the
#attribute with the function's documentation, which we can later highlight
#accordingly.
#       # Function prototype prefixing such help string.
#       string help_prototype

#       # If such string contains a blank line (i.e., "\n\n"), crudely match the
#       # substring preceding such line as the function prototype.
#       if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
#           help_prototype="${match[1]}"
#       # Else if such string contains a newline (i.e., "\n"), crudely match the
#       # substring preceding such newline as the function prototype.
#       } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
#       # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       die 'function help string invalid (see "print_help declare_function" for details):
#'"${help_prototype}"

                #FUXME: If such function name contains spaces or other awkward
                #characters, this is likely to fail -- probably silently!
                #Command-line experimentation suggests that creating such an
                #alias requires *EXTREME* quoting and quote-protection of such
                #quotes. Since this is fairly odd, it's conceivable it's a bug.
                #Here's what the horrid syntax looks like:
                #
                #  >>> alias \"hm\ mm\"="print ik"
                #  >>> "hm mm"
                #  ik
                #
                #So, both the prefixing and suffixing '"' as well as internal
                #whitespace have to be explicitly escaped. Certainly doable;
                #it's just... annoying! I suspect the "=" character also needs
                #be escaped. Anything else? *sigh*
                #FUXME: Given the complexity, we might want to define a function
                #accepting a desired alias name and expansion as two separate
                #parameters and defining such alias -- say, define_alias()?

    #FUXME: Leveraging the above regular expressions, parse function name
    #synonyms and attributes. See above for the algorithm.

    # Store such documentation for subsequent parsing.
#   ZESHY_HELP_GLOBAL+="${1}"

    #FUXME: This is incorrect, as it fails to declare globals if a local of the
    #same name exists. See is_variable_global() for a solution.
    #FUXME: If such global has been declared, we should probably print a
    #warning to standard error if its declared type differs from the
    #documentation-declared type. The implementation is a bit tedious,
    #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
    #dynamically constructed from its converse for performing efficient
    #lookups. Clearly, not a priority for the moment.
    # If such global has not yet been declared, do so. See is_variable() for
    # further details.
#   [[ -n "${(P)global_name__dg+x}" ]] || {

#FUXME: Restore the ${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals back to this
#component. Use such globals rather than ${ZESHY_HELP_GLOBALS}, etc. in
#function implementations below.
#FUXME: Consequently, declare_function() should immediately parse the passed
#help string's function prototype for only the following bits of metadata:
#
#* The list of all function attributes.
#* The list of all function names.
#
#Given the latter, set ${ZESHY_FUNCTION_NAME_TO_HELP} with the *FIRST* such
#function name and set ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME} as
#discussed below from all such function names to the first such function name.
#
#Then, given the former, if such attributes contain "globbable", define one
#"noglob" alias for each function name. Awesomeness!
#FUXME: Honestly, I don't see why we shouldn't support the same syntax for
#aliases. Hence, both functions should call an underlying function passed the
#names of the maps to... Ah, wait. No, no. Aliases don't genuinely support
#synonyms. We could fake it, I suppose. But I'm unsure whether there's any
#value in that. For now, confine such parsing to functions.

#FUXME: How should function synonyms be handled? For proper HTML construction,
#the fact that one function is a synonym of another *REALLY* needs to be
#embedded in either this data structure or another. How about a map
#${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME}? Given the following
#function declaration:
#
#  function func1 func2 func3() { ... }
#
#...we would populate such map as follows:
#
#  ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME=(
#      'func1' 'func1'
#      'func2' 'func1'
#      'func3' 'func1'
#  )
#
#Hence, given a function name, it's (largely) trivial and reasonably efficient
#to find all synonyms of such function. We arbitrarily choose the first function
#name to be the "source" to which all synonyms refer, including such function
#name itself. Note that functions with no synonyms should *NOT* be defined by
#such map. We could certainly admit that, but it serves no purpose and
#(potentially) squanders quite a bit of safe.
#   print "attrs: ${attrs[@]}"
#   print "names: ${names[@]}"
    #FUXME: Right. We don't actually need the list of names, due to our helpful
    #choice of global data structure. Instead, we only need to record the
    #*FIRST* function name in a string local.

        # Match the first such name, which by the definition of such PCRE is
        # guaranteed to exist. See for_string_pcre_matches() for further details.
#       pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names_string}"
#       function_names+="${match[1]}"

        #FUXME: Rather than append to such list, do the following:
        #
        #* Set the above string local to the first match.
        #* For all subsequent matches, map from such match to such string local
        #  in global ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME}.
        #
        #To do so simply (and efficiently!), do something resembling:
        #
        # This should be guaranteed to match and hence always return success.
#       while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match[3]}" } {
#           names+="${match[1]}"
#       }

        # Such names as a raw string. Since iteration overwrites list global
        # ${match}, copy such string before overwriting it below.
#       local names_string="${help_match[3]}"

    #FUXME: We'll clearly need to convert a few of the locals below into globals
    #above. Let's cross that tepid bridge when we trip into it.

        #FUXME: Actually, only print the first line of such documentation. Also, use
        #a different color for such line; say, regular red or cyan?
        #FUXME: Actually, print as follows:
        #
        #* If such prototype contains a blank line (i.e., "\n\n\n"), print from the
        #  first line of such prototype up to the next line that comes first of
        #  either such blank line or 5. (This avoids inevitable problems with
        #  pathological documentation.)
        #* Else, print only the first line of such documentation. This is only an
        #  unlikely edge case, so it needn't be too fancy; pretty much everyone will
        #  follow zeshy precedent of a blank line, I reckon.

    #string pcre_return_type=${pcre_ident}
        #string pcre_function_name_list='\{\s*+([^}]*?)(?:'${pcre_comma}')?\}'
#FUXME: Actually, defer such definition to the same precompilation function
#iterating and serializing all documentation to disk. The reason? Simplicity,
#centralizing all function prototype parsing into a single function. Such
#parsing is rapidly becoming too complex to duplicate between multiple
#functions.
#FUXME: Function name synonyms should be implemented as symbolic links in the
#documentation directory. Consequently, no parsing of function name synonyms is
#desirable in declare_function() itself. In fact, we can reduce the current
#temporary maps ZESHY_ALIAS_NAME_TO_DOCUMENTATION and so on to corresponding
#lists ZESHY_USER_HELP_ALIASES and so on. Just append each passed
#documentation string as is to the desired list.
#FUXME: Define a new declare_function_glob() or
#declare_function_sans_filename_globbing() or
#declare_function_and_disable_filename_globbing(). Yes, the latter. While
#verbose, that's not necessarily a bad thing in this case, as such function
#dramatically alters function parsing. In any case, such function should
#define a new alias of the same name expanding as follows:
#
#    alias ${function_name}="noglob ${function_name}"
#
#Test if such alias already exists before doing so, in which case throw an
#exception or perhaps merely print a warning. (Nah, exception!)

    #FUXME: Actually define set_string_with_stdin(). Simplicity incarnate.
    # Document such input. See set_string_with_stdin() for further details.
#Prefer globals
    # "${match[1]}" and "${match[2]}" to human-readable local variables to
    # avoid polluting the local shell environment any further. 
#FUXME: I'm unclear why this needs to be an alias. If we were declaring such
#variable locally, I could see it, but... yeah; I think I slightly erred in
#implementing this as an alias. Convert to a function and reap the rewards of
#simplicity.

# ....................{ SETTERS                            }....................
#function set_alias_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_CORE_HELP_ALIASES+="${1}"
#}

#function set_function_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_HELP_FUNCTION+="${1}"
#}

#function set_global_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_HELP_GLOBAL+="${1}"
#}

    # If such documentation is prefixed by an alias prototype, match the
    # relevant alias name from such prototype. While zsh permissively allows
    # alias name declarations to be quoted and hence contain arbitrary
    # characters as with functions, such aliases are not runnable: e.g.,
    #
    #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
    #   >>> o\ w\ s
    #   zsh: command not found: o w s
    #
    # For simplicity, use a similar glob expression as declare_function().
#   if [[ "${documentation}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
#   then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
#   fi

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
        # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi
#FUXME: declare_function() is arguably a bit more than mere documentation, now.
#Ditto for declare_global(). Perhaps we should contemplate a nomenclature
#change -- say, to prototype_function() or declare_function(). Yes, "declare"
#strikes me as the proper verb here. It applies to globals as well!
#FUXME: O.K., O.K. Stop the "<>" nonsense with aliases. It's useful for
#referencing aliases to distinguish them from functions but completely unuseful
#for prototyping aliases. Alias prototype syntax should be a proper subset of
#function prototype syntax. (Note this is really the only way to do the PEG, as
#well; can you imagine duplicating the bloody function PEG for aliases with only
#ignorable differences?)

#FUXME: Ensure this is performed in, say, "main":
#
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
# ....................{ DOCUMENTATION                      }....................
# Map from Zeshy-specific alias name to documentation for such alias.
#local -A ZESHY_ALIAS_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific function name to documentation for such function.
#local -A ZESHY_FUNCTION_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific global name to documentation for such global.
#local -A ZESHY_GLOBAL_NAME_TO_DOCUMENTATION

# Avoid documenting the following three functions, subsequently undefined during
# Zeshy startup and hence inaccessible to callers.

# void set_alias_documentation(string alias_name, string documentation)
#
# Document the passed alias with the passed string.
#function set_alias_documentation() {
#    (( # == 2 )) || die 'expected one alias name and one help string'
#    ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_function_documentation(string function_name, string documentation)
#
# Document the passed function with the passed string.
#function set_function_documentation() {
#    (( # == 2 )) || die 'expected one function name and one help string'
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_global_documentation(string global_name, string documentation)
#
# Document the passed global with the passed string.
#function set_global_documentation() {
#    (( # == 2 )) || die 'expected one global name and one help string'
#    ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#       # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi

#names following the `(`- and `)`-bracketed argument list or `[`- and `]`-
#bracketed argument channel list signifies such function to be annotated by such

#declare_function_with_stdin <<'________________<heredoc?>________________'
#void declare_function_with_stdin_and_disable_filename_globbing[
#    stdin: string documentation]
#
#Set the documentation for the function named by the function prototype prefixing
#standard input to such input and disable filename globbing on all arguments
#callers subsequently pass to such function. While the latter admittedly has
#little to do with function documentation, bundling the two together simplifies
#life. See declare_function_with_stdin() and
#disable_function_filename_globbing() for further details.
#________________<heredoc?>________________

#FUXME: Actually, no one'll ever call this function. Rename to
#declare_function_with_stdin_and_disable_function_filename_globbing() and
#implement accordingly. Yes, this is an obscenely long function name. No, in
#this particular instance, I don't particularly care. There's no reasonable
#abbreviation permitting the function name and heredoc declaration to reside on
#the same line, so such function is called like so:
#
#    declare_function_with_stdin_and_disable_function_filename_globbing\
#        <<'________________<heredoc?>________________'
#    ...
#    ________________<heredoc?>________________
#FUXME: Document declare_function_with_stdin() as well. In the documentation,
#note the reason for needing declare_function_with_stdin() to be the fact that
#both single- and double-quoted strings interface poorly with AsciiDoc syntax.
#Specifically, AsciiDoc's frequent use of:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.
#
#Fortunately, zsh supplies a third alternative: here-documents. Since zsh
#writes here-documents to standard input, this function expects non-empty
#standard input. See declare_function() for further details.

#While function documentation can be passed as a
#conventional string argument to declare_function() rather than as standard
#input to this function, such documentation adheres to 
#http://asciidoc.org[AsciiDoc] syntax containing syntactic constructs
#containing characters conflicting with
#conventional single- or double-quoted zsh strings:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.

#Set the documentation for the globally exported variable named by the variable
#declaration prefixing the passed string to such string. Documentation consists
#of a variable declaration in Zeshy-specific C-like syntax and a variable
#description in http://asciidoc.org[AsciiDoc].
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.

#Set the documentation for the function named by the function prototype prefixing
#the passed string to such string. Documentation consists of a function prototype
#in Zeshy-specific C-like syntax and a function description in
#http://asciidoc.org[AsciiDoc].
#Function documentation consists of a function prototype and description
#delimited by mandatory whitespace. A function prototype consists of one or more
#return types, one or more function names, and zero or more function arguments;
#a function description consists of arbitrary http://asciidoc.org[AsciiDoc] with
#additional support for conveniently cross-referencing other Zeshy documentation.

#Alias documentation consists of an alias prototype and description delimited by
#mandatory whitespace. An alias prototype consists of one or more return types,
#one alias name, and zero or more arguments; an alias description consists of
#arbitrary http://asciidoc.org[AsciiDoc] with additional support for conveniently
#cross-referencing other Zeshy documentation.

#== Alias Prototypes ==
#
#Alias prototypes follow a C-like syntax supporting zsh features not commonly
#found in conventional high-level languages: return and argument channels. Since
#zsh does _not_ currently support alias prototypes, we cannot coerce zsh to
#respect or enforce such prototypes at runtime. Zeshy can, however, convert such
#prototypes to syntax-highlighted, contextually-linked specifications in end-
#consumer documentation.

#Since zsh expands aliases inline, aliases cannot accept arbitrary arguments not
#accepted by the command such alias expands to.

#FUXME: Obscenely out-of-date. Significantly expand, noting that the alias
#documentation PEG is effectively the proper subset of the function
#documentation PEG excluding function name synonyms and replacing "(" and ")"
#with "<" and ">".
#While all function implementations remain free to
#dynamically redefine their signatures and hence deviate from such static
#documentation, developers should question the cognitive cost of such functions!

#FUXME: There is one other matter, of course: standard input. And
#come to think, this is also a concern for function documentation as well.
#How do we document whether a function accepts standard input and, when it does
#so, where it places such input in relation to other accepted arguments if any?
#*UGH*. Super annoying that I neglected to account for stdin. *sigh*
#FUXME: O.K.; I think I have a working syntax. The idea is simple: zsh
#extensions to C-like function prototype syntax are "["- and "]"-delimited.
#Since herestring-driven aliases unpack stdin into customary arguments, we have
#an stdin argument syntax resembling:
#
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#
#What's nice is that, as a function, it would simply be written as:
#
#[stdout: float] ukigumo(string dirname, integer mtime)
#
#Simple, concise, and consistent. Excellent. The above syntax naturally extends
#to support standard input being assigned to only one argument, like so:
#
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Ugh. So, that works, but doesn't really coincide with above. How about:
#
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Right. That works. It's obviously tempting to reduce every "[" and "]" to a
#"(" and ")" at this point, but that reduces the resulting prototype to a
#slightly less readable mish-a-mash ala LISP (*shudder*):
#
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#Hmm. Is that *REALLY* less readable? Frankly, it seems *MORE* readable. Right.
#O.K.; so, in this instance only, contemplate LISP-ish syntax. I can't believe
#I'm muttering that, but... well, it is much easier to remember and hence to
#write, and reads quite well as well. So, there you are!
#
#Right. There's just one final thing: input pipes. Quite a few functions only
#expect piped standard input, not just any ol' standard input. So, we'll need to
#also support something resembling:
#
#(stdout: float) ukigumo(piped stdin: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin-pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(piped: string dirname, integer mtime)
#
#The latter, I should think. "piped" implies "stdin" and more, so prefixing with
#or otherwise explicitly stating "stdin" is unnecessary. Well! That should do it,
#no? We'll need to slightly revise both the PEG and examples below, but better
#now that after we've begun using this syntax everywhere, eh? :}
#
#Ah, right: one final thing. The ":" implies mandatory and, in most cases, piped
#standard input is optional. How about a new "?" suffix for optional input, ala:
#
#(stdout: float) ukigumo(piped? string dirname, integer mtime)
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#BRILLIANT. Bravo, senior Cecil. Bravo.
#
#Note, however, that optional piped input is probably unhelpful and should
#arguably be eliminated from the Zeshy codebase. Hence, for now, just document
#the "stdin:"-style syntax.
#FUXME: O.K.; so, the above syntax isn't *QUITE* right. Since we're *NEVER*
#passing in standard input as an optional argument, any standard input passed is
#always as a second "channel" completely outside the scope of passed arguments.
#Also note that *_from()-style aliases *APPEAR* to the caller to accept a single
#string rather than standard input, suggesting an additional "string:" channel.
#Revert to "["-style syntax, for clarity. This suggests the following syntax:
#
#    # A function accepting a string *AND* standard input.
#    [stdout: void] set_string_to_stdin[
#       args: string string_name, stdin: string input]
#
#    # A function accepting one or more integers on standard input.
#    [stdout: string] get_stdin_integers[
#       args: void, stdin: (integer int1, ...)]
#
#    # Equivalent to the prior prototype.
#    [stdout: string] get_stdin_integers[stdin: (integer int1, ...)]
#
#    # A herestring-style alias.
#    [stdout: float] ukigumo[string: (string dirname, integer mtime)]
#
#So, the fundamental idea is that "args:" and "stdin:" both default to "void",
#as for return types. Either or neither may be specified, with predictable
#consequences in any case. Beautiful, no? (Well, certainly *LOGICAL*!)

#Tester functions returning only boolean exit status and no standard output or
#error may thus map return types `[status: boolean]` (e.g.,
#`[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).

#Being unprototyped, zsh function argument order and type is not
#statically predefined at function declaration time but may conditionally
#dynamically depend on local, global, and/or external state. For example,
#While perfectly documenting all possible function argument dynamics is both unfeasible and undesirable,
#conditionally depend and hence arguably more involved
#(though not necessarily beneficially) than those of conventional high-level languages.

#Documenting all possible function prototype dynamics is both unfeasible and
#undesirable. For sanity, function documentation assumes function signatures to
#be statically predefined at function declaration time as in normal high-level languages. Function implementations remain
#free to dynamically redefine and hence stray from such documentation as
#necessary, although this is generally discouraged.

#For brevity, functions may specify a single return type as in conventional
#high-level languages (e.g., `integer`).
# Zeshy documents such values in one of two ways:
#With a single type as in conventional high-level languages (e.g., `integer`),
#signifying such function to return a string of standard output convertible
#without error to such type, an empty string of standard error, and zero exit
#status (i.e., success). Since most functions only write to standard output and
#throw exceptions rather than return non-zero exit status on error, this
#shorthand notation simplifies most functions'' documentation.

#| Digit                 | <- | ``0'' | DigitNonZero
#| DigitNonZero          | <- | ``1'' | ``2'' | ``3'' | ``4'' | ``5'' | ``6'' |
#                               ``7'' | ``8'' | ``9''
#| Integer               | <- | ``-''? (``0'' | DigitNonZero Digit*)

#FUXME: I've performed an obscene amount of research on lightweight
#documentation formats and the winner *HANDS DOWN* is AsciiDoc. The syntax
#absolutely rocks, is near infinitely extendable with "pluginname:string"-style
#syntax and third-party plugins, exports beautiful HTML, LaTeX, PDF, man pages,
#DocBook, and so on. All Git documentation is written in AsciiDoc (which should
#absolutely tell you something: this is Linus' Git, after all). Markdown and
#Textile are rather outdated at this point. The only genuine competitor is the
#official Python documentation language, RestructuredText (reST). I'll admit:
#reST is powerful. Probably nearly as or even slightly more powerful than
#AsciiDoc. But in the end, that doesn't really matter... because the syntax is
#absolute shite. I mean, *LOOK AT THAT SYNTAX*. What the bloody hell were they
#thinking? They could have simply adopted the de facto e-mail-style markup
#syntax from which AsciiDoc (and Markdown and Textile and pretty much every
#other lightweight documentation language) is descended. But *NO*, they had to
#reinvent the friggin' wheel. And they failed. They thoroughly failed. Thank the
#Nordic Gods, then, for AsciiDoc.

#[stdout: float] ukigumo(stdin -> [string dirname, integer mtime])
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(string dirname, integer mtime) <- stdin
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#[stdout: float] ukigumo(stdin -> string dirname, integer mtime)

#FUXME: set_function_documentation() will need to detect whether passed standard
#input and, if so, ... Hmm. Actually, we should probably just do so in the high-
#level functions themselves (e.g., declare_function()). That necessitates
#pushing such documentation to the end of this file, but... *shrug*. That's
#fine, and arguably even preferred here (since it centralizes all documentation
#in one place). Arguably, we should then provide distinct high-level functions
#entitled declare_function_from_stdin() and so forth. The issue with
#trying to make a single "smart" declare_function() implicitly detecting open
#standard input is that such functions will be called from the top-level during
#Zeshy startup and hence cannot distinguish external from internal standard
#input. Subvert such confusion with distinct functions only accepting standard
#input.

#set_alias_documentation declare_global '
#void declare_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
#alias declare_global='
#{
#    # Localize the passed herestring.
#    local documentation__dg="$(< /dev/stdin)"
#...
#} <<<'

#Document the function named in the function prototype prefixing the passed
#documentation, which consists of a function prototype in C-like syntax
#followed by function description in AsciiDoc.
#
#whose syntax supports zsh features not commonly found in
#conventional high-level languages (e.g., function name synonyms, tristate return
#values). For completeness, we specify such syntax with a Parser Expression
#Grammar (PEG):
#
#Such types should correspond to the actual variable type (if
#any) the function implementation copies such argument into.
#
#values are *NEVER* evaluated by Zeshy and hence may contain executable code that
#could, whenever evaluated, have dangerous side-effects. 
#
#assigning each argument a
#mandatory name and type and optional default value.
#
#While argument names need
#not correspond to the variable name (if any) the function implementation copies
#such argument into, argument types and optional default value should, of course.
#
#(e.g., "function name synonym pseudonym nom_de_guerre nom_de_plume() { true }",
#a function callable as either name(), synonym(), pseudonym(), nom_de_guerre(),
#or nom_de_plume()).
#
#by listing all such names in whitespace-
#delimited fashion (e.g., .
#at least one name  also arbi:
#a
#Most function names as in conventional high-level languages (e.g., "integer"),
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#
#For functions with only one name, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#For functions with multiple names, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME_1 [or] FUNCTION_NAME_2 [or] ... FUNCTION_NAME_N(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME_1 FUNCTION_NAME_2 ... FUNCTION_NAME_N() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#Capitalized strings above denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  FUXME: Rewrite this section after implementing the above additions. It gets a
#  bit complicated, but... heck, it''ll definitely be worth it.
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.
#* "FUNCTION_NAME_2", the second name for such function. While most functions have
#
#  As in C-like languages, type "void" signifies such function to return no
#  standard output and/or error.
#
#Function prototypes follow the familiar "RETURN_TYPE FUNCTION_NAME 
#
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#While zsh does not support function prototypes, this function
#adopts conventional high-level language function prototype syntax for documentation-specific purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#named by the C-style function prototype of the passed
#documentation string. Since zsh permits no function prototyping, this function
#adopts conventional high-level language function prototype syntax for documentation purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#syntax does *NOT* constitute 
#While such syntax does *NOT* constitute an enforcable
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#, which must thus be prefixed  with such documentation. 
#
#This function is deleted by Zeshy immediately before compiling its user digest
#file and hence only callable from the global context of Zeshy components.

#FUXME: It'd be great to support a distinction between standard output and
#error return values in function prototypes. How about something resembling:
#
#    # Function returning a string of standard output and no standard error.
#    [string, void] do_something(void)
#
#    # Or perhaps the more verbose:
#    [stdout: string, stderr: void] do_something(void)
#
#    # Actually, we could support both (obviously), which we should do. Ah;
#    # actually, we should probably just add such "stdout:" and "stderr:"
#    # labels on printing human-readable documentation to users, yes? Ah;
#    # perhaps not. It'd certainly be more intelligible to developers browsing
#    # the code to see "[stdout: string, stderr: void]" versus the former.
#    # The more verbose version also lends itself well to specifying exit
#    # status, as below.
#
#Since most functions return no standard error, retain support for shorthand:
#
#    # Same as above, shorthand.
#    string do_something(void)
#
#While most functions return 0 exit status, some do not. How about this:
#
#    # Function returning a string of standard output and no standard error
#    # and non-zero exit status on failure.
#    [string, void, boolean] do_something(void)
#
#    # Or, again:
#    [stdout: string, stderr: void, status: boolean] do_something(void)
#
#Status may either be "void" (i.e., always returns 0), "boolean" (i.e.,
#either returns 0 or 1), or "integer" (i.e., returns a variety of statuses.
#
#Ah! Another way in which the labels are demonstrably superior: in may cases,
#we'll want to specify "stdout" and "status" but not "stderr". So, that's just:
#
#    [stdout: string, status: boolean] do_something(void)
#
#Naturally, order no longer matters. Sweet! I'm thinking we *ABSOLUTELY*
#shouldn't support the abbreviated "[stdout, void, boolean]" style, yes? Far too
#much ambiguity and head-scratching.
#FUXME: The specification below has become sufficiently complex to warrant a BNF.
#I know, I know. But we'll make it simple and concise, with adequate commenting.
#There's really no better way.

# ....................{ GLOBALS                            }....................
#FUXME: This is terrible. Eliminate such global entirely; instead, simply
#attempt to run a dynamically constructed command
#${variable_type}_global_export().

#set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#map ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#
#Map variable type to the declarator (i.e., command prefix) declaring and
#exporting globals of such type.
#'
#typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#    # String types.
#    string    'export'
#    boolean   'export'
#    character 'export'

    # Integer types.
#    integer         'export -i'
#    file_descriptor 'export -i'
#
    # Float types.
#    float 'export -F'
#
#    # List types.
#    list     'export -a'
#    list_set 'export -Ua'
#
#    # While "export -a" succeeds (as above), "export -A" fails with error.
#    # Hence, revert to builtin typeset().
#    map 'typeset -Agx'
#)

        # If such global''s type is not a Zeshy-specific type, throw an
        # exception. See is_map_key() for implementation details.
#       (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#           die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
#       ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

# ....................{ MAIN                               }....................
#FUXME: Not quite right. We also want to undefine all of the above aliases and
#functions before Zeshy digest compilation, suggesting we create a new
#precompilation hook performing all such undefinitions. I can't imagine that
#order matters, there; so, just add a customary precompilation hook here.

#run_hook_on_zeshy_precompile precompile_zeshy_documentation_undefine

#declare_function '
#void precompile_zeshy_documentation_undefine(void)
#
#Undefine all documentation-defining runnables (e.g., set_alias_documentation(),
#declare_global()) *AFTER* sourcing all Zeshy components calling such runnables
#and hence having defined all available documentation. To  Zeshy caches 
#The documentation such runnables
#'
#function precompile_zeshy_documentation_undefine() {
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
#}

#FUXME: Rename "[or]" to "[or]" everywhere. Avoid simply "or", as that isn't
#subject to global replacement.
# For simplicity, this function ignores 
# such low-level distinctions, accepts
# (e.g., "boolean", "list", "string"). If 
#
#While most functions have only one name, zsh does permit additional names to be
#declared in function declarations with the above whitespace-delimited syntax.
#
#Capitalized strings denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific type of variable returned by such function
#  (e.g., "boolean", "list", "string").
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.

# *BEFORE* compiling Zeshy''s user digest file
# (i.e., at the top level of Zeshy components and in precompilation hooks).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Define declare_function() before declare_alias(), which documents itself
# with the former function.
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias declare_alias=':' declare_function=':' declare_global=':'

# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)
