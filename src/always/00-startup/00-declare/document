#!/usr/bin/env zsh
# ====================[ document                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Document aliases, functions, and global prototypes defined by @{declare}.

# ....................{ DECLARERS ~ global                 }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_global(string documentation)

Set the documentation for the global exported variable named by the variable
declaration prefixing the passed string to such string and, if such variable has
not already been declared, declare such variable to be global, exported, and of
the documented type. Variable documentation consists of:

. A *variable declaration* in Zeshy-specific C-like syntax, consisting of one
  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`).
. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
  with Zeshy-specific markup for cross-referencing other Zeshy documentation.

== Variable Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):

.Variable Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
| GlobalName            | <- | AlphanumericString
|===============================================================================

== Variable Type ==

A variable's type may be any alphanumeric string for which an alias of the same
name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
variable type but `order_of_the_blackened_denarius` is not, since
file_descriptor_global_export() is an existing alias but
order_of_the_blackened_denarius_global_export() is (hopefully) not.

Zeshy provides numerous such aliases and hence variable types, including:
`boolean`, `character`, `file_descriptor`, `float`, `integer`, `list`,
`list_set`, `map`, and `string`.
________________<heredoc?>________________

# ....................{ DECLARERS ~ alias                  }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_alias(string documentation)

Set the documentation for the alias named by the alias prototype prefixing the
passed string to such string. Alias documentation consists of:

. An *alias prototype* in Zeshy-specific C-like syntax, consisting of one or
  more alias return types, one alias name, and zero or more alias arguments
  (e.g., `string the_parable_of_the_box(integer derrick, character jensen)`).
. An *alias description* in http://asciidoc.org[AsciiDoc] syntax, augmented with
  Zeshy-specific markup for cross-referencing other Zeshy documentation.
  (e.g., `The *box* is +full+ of salmon, and a *man* sits +atop+ the box.`)

== Alias Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)].
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., ReturnTypes, Whitespace):

.Alias Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| AliasDocumentation    | <- | AliasPrototype Whitespace+ AsciiDoc
| AliasPrototype        | <- | Whitespace* ReturnTypes
                               Whitespace+ AliasName
                               Whitespace* AliasArgs
| AliasName             | <- | AlphanumericString
| AliasArgs             | <- | ArgumentList | ArgumentChannels
| AliasArgChannels      | <- | ``['' Whitespace* ( AliasArgChannel Whitespace*
                               ``,'' Whitespace*)* AliasArgChannel Whitespace*
                               ``]''
| AliasArgChannel       | <- | AliasArgChannelName Whitespace* ``:'' Whitespace*
                               (Argument | ArgumentList)
| AliasArgChannelName   | <- | ``args'' | ``argstring'' | ``stdin''
|===============================================================================

== Alias Description and Prototype ==

Aliases support the same descriptions and prototypes as functions, with one
minor and one major exception. See declare_function() for all other details.

=== Minor Exception ===

Function prototypes permit multiple names. Alias prototypes permit only one.

=== Major Exception ===

Function prototypes permit only two argument channel names: `args` and `stdin`.
Alias prototypes permit a third argument channel specific to herestring-driven
aliases: `argstring`.

By design, zsh aliases are expanded inline and hence cannot accept arbitrary
arguments not accepted by the commands such aliases expand to. As example, the
alias `l` declared by `alias l=ls` accepts only the arguments accepted by
command `ls` -- no more, no less.

Herestring-driven aliases circumvent such constraints by accepting a single
herestring argument embedding one or more ``real'' arguments to be passed such
alias. Since such aliases _always_ accept a single herestring, declaring a
single-string argument list conveys no meaningful information. Rather, such
aliases should declare a herestring-specific argument channel `argstring`
accepting the argument list embedded in such herestring. For clarity, consider
optionally suffixing aliases defined in this way with `_from': e.g.,

.Herestring-driven Alias
==========================================
[source]
------------------------------------------
declare_alias '
alias set_args_to_string_split_on_words_from[
    argstring: (string text1, string text2, ...)]

Set the current argument list to the passed strings split on shell words: e.g.,

    >>> set_args_to_string_split_on_words_from 'worker can "create nothing"'
    >>> print_string ${3}
    create nothing
'
alias set_args_to_string_split_on_words_from='
{
    # Validate passed arguments.
    list args__sltssowf
    set_list_to_stdin_words args__sltssowf
    (( ${#args__sltssowf} >= 1 )) or die 'expected at least one string'

    # Temporary list to split such strings into.
    list words__sltssowf

    # Split such strings.
    set_list_to_string_words words__sltssowf "${args__sltssowf[@]}"

    # Set the current argument list to such words.
    set_args "${words__sltssowf[@]}"

    # Delete such temporary list.
    undefine_variable words__sltssowf
} <<<'
------------------------------------------
==========================================
________________<heredoc?>________________

# ....................{ DECLARERS ~ function               }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_function(string documentation)

Set the documentation for the function named by the function prototype prefixing
the passed string to such string. Function documentation consists of:

. A *function prototype* in Zeshy-specific C-like syntax, consisting of zero or
  more function attributes, one or more function return types, one or more
  function names, and zero or more function arguments (e.g.,
  `<globbable> boolean <ruth, benedict>(integer siphon, character funnel)`, a
  function with one attribute `globbable`, one return type `boolean`, two names
  `ruth` and `benedict`, and two arguments `siphon` and `funnel`).
. A *function description* in http://asciidoc.org[AsciiDoc] syntax augmented
  with Zeshy-specific markup for cross-referencing other Zeshy documentation
  (e.g., `Everyone _believes_ that the *man* +atop+ the box _owns_ the fish()`).

== Function Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:

[[declare_function.peg]]
.Function Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| FunctDocumentation    | <- | FunctPrototype Whitespace+ AsciiDoc
| http://asciidoc.org[AsciiDoc] | <- | (XReference \| AnyCharacter)*
| XReference            | <- | WordStart XReferObject WordEnd
| XReferObject          | <- | XReferAliasOrFunct \|
                               XReferAlias \|
                               XReferFunct \|
                               XReferGlobal
| XReferAliasOrFunct    | <- | AlphanumericString ``()''
| XReferAlias           | <- | ``alias:''    XReferAliasOrFunct
| XReferFunct           | <- | ``function:'' XReferAliasOrFunct
| XReferGlobal          | <- | ``${'' AlphanumericString ``}''
| FunctPrototype        | <- | Whitespace* FunctAttrs
                               Whitespace* ReturnTypes
                               Whitespace+ FunctNames
                               Whitespace* FunctArgs
| FunctAttrs            | <- | ``{'' Whitespace*
                               (FunctAttr ListComma)*
                                FunctAttr ListCommaOptional
                               Whitespace* ``}''
| FunctAttr             | <- | ``globbable''
| ReturnTypes           | <- | Type \| ReturnChannels
| Type                  | <- | AlphanumericString
| ReturnChannels        | <- | ``['' Whitespace*
                               (ReturnChannel ListComma)*
                                ReturnChannel ListCommaOptional
                               Whitespace* ``]''
| ReturnChannel         | <- | ReturnChannelName Whitespace* ``:'' Whitespace*
                               Type
| ReturnChannelName     | <- | ``stdout'' \| ``stderr'' \| ``status''
| FunctNames            | <- | FunctName | FunctNameList
| FunctName             | <- | AlphanumericString |
                               SingleQuotedString |
                               DoubleQuotedString
| FunctNameList         | <- | ``<'' Whitespace*
                               (FunctName ListComma)*
                                FunctName ListCommaOptional
                               Whitespace* ``>''
| FunctArgs             | <- | FunctArgList \| FunctArgChannels
| FunctArgChannels      | <- | ``['' Whitespace*
                               (FunctArgChannel ListComma)*
                                FunctArgChannel ListCommaOptional
                               Whitespace ``]''
| FunctArgChannel       | <- | FunctArgChannelName Whitespace* ``:'' Whitespace*
                               (FunctArg \| FunctArgList)
| FunctArgChannelName   | <- | ``args'' \| ``stdin''
| FunctArgList          | <- | ``('' Whitespace*
                               (FunctArgsEmpty \| FunctArgsNonEmpty)
                               Whitespace* ``)''
| FunctArgsEmpty        | <- | FunctArgEmpty?
| FunctArgsNonEmpty     | <- | (FunctArgNonEmpty ListComma)*
                                FunctArgNonEmpty ListCommaOptional
| FunctArg              | <- | FunctArgEmpty \| FunctArgNonEmpty
| FunctArgEmpty         | <- | ``void''
| FunctArgNonEmpty      | <- | Type  Whitespace+ FunctArgName (Whitespace*
                               ``='' Whitespace* FunctArgDefaultValue)?
| FunctArgName          | <- | AlphanumericString
| FunctArgDefaultValue  | <- | ZshValue
| ListComma             | <- |  Whitespace* ``,'' Whitespace*
| ListCommaOptional     | <- | (Whitespace* ``,'')?
| ZshValue              | <- | Integer \| Float \|
                               SingleQuotedString \| DoubleQuotedString
| Integer               | <- | ``-''? Digit+
| Float                 | <- | ``-''? Digit+ ``.'' Digit+
| SingleQuotedString    | <- | ``\''' (``\'\''' \| !``\''' AnyCharacter)* ``\'''
| DoubleQuotedString    | <- | ``"''  (``\\"''  \| !``"''  AnyCharacter)* ``"''
| AlphanumericString    | <- | (!(Whitespace \| Punctuation) AnyCharacter)*
| Whitespace            | <- | `` '' \| ``\\t'' \| ``\\n''
| Punctuation           | <- | ``('' \| ``)'' \| ``['' \| ``]'' \| ``{'' \| ``}'' \|
                               ``,'' \| ``='' \| ``:'' \| ``"'' \| ``\'''
| Digit                 | <- | ``0'' \| ``1'' \| ``2'' \| ``3'' \| ``4'' \| ``5'' \|
                               ``6'' \| ``7'' \| ``8'' \| ``9''
| AnyCharacter          | <- | Whitespace \| Punctuation \| Digit \| ``a'' \| ...
|===============================================================================

== Function Description ==

Function descriptions follow http://asciidoc.org[AsciiDoc] syntax augmented to
support Zeshy-specific cross-references of aliases, functions, and globals. To
cross-reference another:

* zsh alias or function, suffix such alias or function name with `()` (e.g.,
  `declare_function()`). If both an alias _and_ function share such name, the
  cross-reference refers only to the alias (in keeping with zsh behavior). For
  genericity, this is generally preferable to the next two disambiguations.
* zsh alias, prefix such name with `alias:` and suffix such name with `()`
  (e.g., `alias:catch()`).
* zsh function, prefix such name with `function:` and suffix such name with `()`
  (e.g., `function:catch()`).
* zsh global, prefix such name with `${` and suffix such name with `}` (e.g.,
  `${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}`).

== Function Prototypes ==

Function prototypes follow a C-like syntax supporting zsh features not commonly
found in conventional high-level languages: function name synonyms and return
and argument channels. Since zsh does _not_ currently support function
prototypes, we cannot coerce zsh to respect or enforce such prototypes at
runtime. Zeshy can, however, convert such prototypes to syntax-highlighted,
contextually-linked specifications in end-consumer documentation.

=== Context-sensitivity ===

In conventional high-level languages, a function is typified by its *signature*:
the set of function name(s), return type(s), and argument type(s) uniquely
identifying that function. Each signature is statically predefined at function
declaration time and either not subject to subsequent change or changeable only
by redeclaring its function.

In zsh, a function is typified only by the set of its names. Since this is
hardly a signature in the conventional sense, zsh functions have arguably no
function signature and certainly no statically predefined set of return type(s)
and/or argument type(s). Rather, these types are the implicit result of dynamic
implementation details possibly depending on local, global, or external state --
which is to say, effectively anything you'd like.

For example, it's possible (though a pretty bad idea) to define a function
accepting at least one string argument and conditionally changing both return
and argument types in context-dependent relation to such argument as follows:

* If such argument is "hexadecimal -> decimal", accept a second string in
  base 16 hexadecimal format and return the equivalent base 10 integer.
* If such argument is "string1, ... -> list", accept one or more additional
  strings and return the concatenation of such strings as a string convertible
  without error into a list of such strings by the caller.
* If such argument is "stdin == 'clear' ? string -> void : void -> string", test
  whether such function was piped standard input equal to string "clear". If so,
  accept a second string signifying the name of a list to be cleared; otherwise,
  accept no additional strings and return a string of random bytes.

This rabbit hole goes deep. Since supporting such conditionality is infeasible
(and arguably undesirable), [underline]#this function naively assumes all function
signatures to be statically predefined at function declaration time#. For
signatures for which this is not the case (as in the above example), consider
documenting only the most commonly called signature in the function prototype.

=== Function Attributes ===

Functions may be annotated with a list of Zeshy-specific function attributes.
Declaring a `{`- and `}`-bracketed list of one or more `,`-delimited attribute
names annotates such function with such attributes, which this function parses
and dynamically enables. The following attributes are currently supported:

==== globbable =====

`globbable`, signifying this function's arguments to _not_ be subject to
conventional filename globbing and hence to be passed to such function as is. By
default, all function arguments _are_ subject to such globbing, preventing glob
expressions from being passed as function arguments unless explicitly quoted or
escaped. Enabling this attribute on a function disables such behavior for all
arguments callers pass such function: e.g.,

.Globbable Function
==========================================
[source]
------------------------------------------
>>> declare_function ''
... <globbable> [status: boolean] is_string_matcheses(string text, string glob)
...
... A function that may be passed unquoted glob expressions.
... ''
>>> function is_string_matcheses() { is ${1} == ${~2} si }
>>> is_string_matcheses satoshi_nakamoto *n[aeou]k[aeou]* and print metzdowd
metzdowd
------------------------------------------
==========================================

Internally, this attribute is implemented by defining a new alias of the same
name expanding to such function prefixed by `noglob` (e.g.,
`alias ${function_name}="noglob ${function_name}"`).

=== Return Types ===

zsh return types are more intricate than those of normal high-level languages.
All functions return three *channels* (i.e., ``streams'' of orthogonal output):

. A string of standard output.
. A string of standard error.
. A byte of exit status.

==== Single Return Type ====

Since most functions only output to standard output and throw exceptions rather
than return non-zero exit status on failure, shorthand notation suffices for
such functions. Declaring a single return type as in conventional high-level
languages (e.g., `integer hikikomori(string otaku)`) signifies such function to
always return a string of standard output convertible without error to such
type, an empty string of standard error, and zero exit status (i.e., success).

===== Non-Scalar Return Types =====

Zeshy provides aliases for both returning and receiving returned lists and maps,
suggesting `list` and `map` are acceptable return types from either standard
output or error. Since returning such types incurs a significant performance
penalty, consider only returning such types for sufficiently small lists and
maps (noting that ``small'' has yet to be rigorously defined).

==== Mapped Return Types ====

Some functions output to standard error and/or return non-zero exit status,
necessitating a longhand notation mapping each of the three possible return
channels (standard output, standard input, and exit status) to the return type
such function returns on such channel. Specifically, declaring a `[`- and `]`-
bracketed map of one to three `,`-delimited, `:`-separated key-value pairs
mapping return channel to return type (e.g.,
`[stdout: float, stderr: string, status: integer] nhk(string kyokai)`)
signifies such function to return standard output and error strings and exit
status convertible without error to such types.

At least one such key-value pair must be declared. The value declares the
return type that channel returns (e.g., `string`). The key identifies the
channel itself via one of three case-insensitive strings:

* `stdout`, the standard output channel. Returns any conventional type or
  `void`, a pseudo-type signifying such function to return no standard output.
  Defaults to `void` if unspecified.
* `stderr`, the standard error return channel. Returns any conventional type or
  `void`, a pseudo-type signifying such function to return no standard error.
  Defaults to `void` if unspecified.
* `status`, the exit status return channel. Returns only the following
  numerical return types (defaulting to `true` if unspecified):
  ** `true`, a pseudo-type signifying such function to always succeed (ignoring
     exceptions). While `true` and `false` are values rather than genuine types,
     mere technicalities are merely that.
  ** `false`, a pseudo-type signifying such function to always fail. Since Zeshy
     implicitly throws exceptions on failure, such type is generally unhelpful.
  ** `boolean`, signifying such function to return exit status 0 on success or 1
     on failure. Most such functions are `is_`-prefixed *testers* returning only
     `[status: boolean]` and hence no standard output or error (e.g.,
     `[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).
  ** `integer`, signifying a function returning more than merely exit statuses 0
     and 1 (e.g., `grep`, returning 0 on match, 1 on no match, and 2 on error).

Return types thus default to map `[stdout: void, stderr: void, status: true]`.
For example, the following prototypes all equivalently define a function
accepting no arguments, returning a string convertible without error to a float
from standard output and no standard error, and always succeeding:

.Mapped Return Types
==========================================
* `float ukigumo(void)`.
* `[stdout: float] ukigumo(void)`.
* `[stdout: float, stderr: void] ukigumo(void)`.
* `[stdout: float, status: true] ukigumo(void)`.
* `[stdout: float, stderr: void, status: true] ukigumo(void)`.
==========================================

=== Function Names ===

zsh function names are more intricate than those of normal high-level languages.
All functions have one or more names, declared at function declaration time by
listing such names delimited by whitespace. Sadly, documentation requires re-
listing such names delimited by commas and bracketed by `<` and `>`. While such
repetition is regrettable, zsh's lack of prototyping support affords us no
alternatives: e.g.,

.Function Name Synonyms
==========================================
[source]
------------------------------------------
>>> declare_function ''
... void name, synonym, pseudonym, anonym(void)
...
... A function callable as either name(), synonym(), pseudonym(), or anonym().
... ''
>>> function name synonym pseudonym anonym() { print 'nom de plume' }
>>> name
nom de plume
>>> pseudonym
nom de plume
------------------------------------------
==========================================

=== Function Arguments ===

As expected, zsh function arguments are more intricate than those of normal
high-level languages. All functions accept two *channels* (i.e., ``streams'' of
orthogonal input):

. A passed argument list.
. A string of standard input.

[[declare_function.argument_list]]
==== Single Function Argument List ====

Since most functions only accept passed argument lists rather than standard
input, shorthand notation suffices for such functions. Declaring a single `(`-
and `)`-bracketed argument type list of one or more `,`-delimited argument
declarations consisting of a whitespace-delimited type and name followed by
optional `=` and default value in typical zsh syntax as in normal high-level
languages (e.g., `void the(string ultimate, integer question = 42)`) signifies
such function to accept only such arguments with no standard input.

===== Function Argument Names =====

Argument names should contain no whitespace or punctuation, much like real zsh
variable names. While argument names need not correspond to the actual variable
name (if any) the function implementation copies such argument into, this is
generally considered good form.

===== Function Argument Types =====

Argument types are any single scalar types (e.g., `boolean`, `integer`), thus
excluding `void`, `list`, and `map`. Since argument lists are lists, consider
passing read-only lists as arguments and lists to be modified as the names of
such lists. While maps can be packed into argument lists, consider always
passing maps as the names of such maps. When passing the name rather than value
of variables, consider mangling *ALL* variable names declared in the function
implementation in a function-specific manner to avoid accidentally overriding
externally with internally declared variables. Zeshy heuristically mangles by
appending `__` followed by the first letter of each word in the function name,
which suffices for most purposes. For readability, avoid mangling documented
argument names. For example:

.Function Argument Mangling
==========================================
[source]
------------------------------------------
declare_function ''
void set_list_to_raspberry_hybrids(string list_name, string flavor)

Set the passed list to all known raspberry hybrids of the passed flavor.
''
function set_list_to_raspberry_hybrids() {
    # Validate passed arguments.
    die_unless_args_2 ''expected one list name and one raspberry flavor''
    string list_name__sltrh="${1}" flavor__sltrh="${@[-1]}"
    die_unless_list "${list_name__sltrh}"

    # Set such list.
    if { is_string_equals "${flavor}" acidic }
        eval "${list_name__sltrh}=( loganberry )"
    } else {
        eval "${list_name__sltrh}=( tayberry )"
    }
}
------------------------------------------
==========================================

===== Function Argument Default Values =====

Default argument values are any valid right-hand side of a scalar assignment,
including double-quoted strings nesting arbitrarily deep process substitutions
(e.g., `(string dirname = "$(is_superuser and "/o" or "$(get_dir)")")`). For
safety, Zeshy *never* evaluates such values, which may thus contain executable
code known to have dangerous side-effects. (Naturally, this is not a good idea.)

===== Empty Function Argument List =====

Functions accepting no arguments may declare an argument list of either:

* `()' as in shell languages.
* `(void)` as in C-like languages.

===== Variadic Function Function Argument List =====

Functions accepting arbitrarily many arguments of the same type (referred to as
``variadic functions'' elsewhere) should declare only the first such argument
including optional default value followed by `, ...`. When a default value is
declared, any number of such arguments may be passed; then if a caller passes no
such arguments, the function defaults to a single argument of the default value.
When no default value is declared, at least one such argument must be passed.
Such arguments may be preceded and followed by other arguments. For example:

.Variadic Function
==========================================
[source]
------------------------------------------
declare_function ''
void uhoh(integer mtime, string dirname1 = "/", ..., boolean is_recursive)

A function accepting an integer, zero or more dirnames defaulting to "/" if
no such strings are passed, and a boolean -- usually doing something rather
dangerous.
''
function uhoh() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        ''expected one integer, optional dirnames, and one boolean''
    string mtime="${1}" is_recursive="${@[-1]}"
    die_unless_integer "${mtime}"
    die_unless_boolean "${is_recursive}"

    # Remove such integer and boolean from the argument list. All remaining
    # arguments, if any, are dirnames.
    shift_arg
    pop_arg

    # If no arguments remain, default to "/".
    is_args or set_args "/"

    # Do something rather dangerous.
    print "Mu-haha! [${mtime}]"
    if is_boolean_true "${is_recursive}"
    then ls -R -- "${@}"
    else ls    -- "${@}"
    fi
}
------------------------------------------
==========================================

==== Mapped Function Argument List ====

Some functions also accept standard input, necessitating a longhand notation
mapping each of the two possible argument channels (passed argument list and
standard input) to the argument type list such function accepts on such channel.
Specifically, declaring a `[`- and `]`-bracketed map of one to two `,`-
delimited key-value `:`-separated pairs mapping argument channel to argument
type list signifies such function to accept passed argument strings and a string
of standard input convertible without error to such types (e.g.,
`void taake[args: (string hordaland1, ...), stdin: string vi]`).

At least one such key-value pair must be declared. Each key is any of the
following case-insensitive strings:

* `args`, the *passed arguments* argument channel.
* `stdin`, the *standard input* argument channel.

Each value identifies the arguments such channel accepts in either:

* _Shorthand notation_, a
  <<declare_function.argument_list,single argument declaration>> consisting of
  either:
** A whitespace-delimited type and name followed by optional `=` and default
   value in typical zsh syntax, signifying such function to accept only that
   argument on such channel (e.g.,
   `void chomsky[args: boolean the_purpose, stdin: integer of_education]`).
** `void`, a pseudo-type signifying such function to accept _no_ arguments on
   such channel.
* _Longhand notation_, a `(`- and `)`-bracketed list of one or more `,`-
  delimited <<declare_function.argument_list,argument declarations>>,
  signifying such function to accept all such arguments on that channel (e.g.,
  `void kropotkin[args: (integer mutual1, ...), stdin: (integer aid1, ...)]`).

Argument list types thus default to map `[args: void, stdin: void]`. For
example, the following prototypes all equivalently define a function
accepting a string convertible without error to a character on the passed
argument list and no standard input, and always succeeding:

.Mapped Return Types
==========================================
* `void kurosawa(character red_beard)`.
* `void kurosawa[args: character red_beard]`.
* `void kurosawa[args: (character red_beard)]`.
* `void kurosawa[args: (character red_beard), stdin: void]`.
==========================================

________________<heredoc?>________________

# ....................{ DECLARERS ~ stdin                  }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_alias_with_stdin[stdin: string documentation]

Set the documentation for the alias named by the variable declaration prefixing
standard input to such input. This function is the standard input-specific
analogue to declare_alias(), which accepts a string argument rather than
standard input. See declare_function_with_stdin() for further details on why
this function is preferable to declare_alias().
________________<heredoc?>________________

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_global_with_stdin[stdin: string documentation]

Set the documentation for the global exported variable named by the variable
declaration prefixing standard input to such input. This function is the
standard input-specific analogue to declare_global(), which accepts a string
argument rather than standard input. See declare_function_with_stdin() for
further details on why this function is preferable to declare_global().
________________<heredoc?>________________

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_function_with_stdin[stdin: string documentation]

Set the documentation for the function named by the function prototype prefixing
standard input to such input. This function is the standard input-specific
analogue to declare_function(), which accepts a string argument rather than
standard input. Function documentation adheres to http://asciidoc.org[AsciiDoc]
syntax conflicting with both single- and double-quoted zsh string syntax and
hence cannot reliably be passed as a string argument. Such conflicts include:

* AsciiDoc-specific paired single quote, conflicting with zsh-specific single-
  quoted string escapes (e.g., '``The Bastion''', a double-quoted string in
  AsciiDoc that zsh reduces to "``The Bastion'").
* AsciiDoc-specific paired backticks, conflicting with zsh-specific double-
  quoted string process substitution (e.g., "`the' `stranger'", a pair of
  single-quoted strings in AsciiDoc that zsh attempts to substitute with the
  output of running the external command "the' ").

By accepting standard input in lieu of string arguments, this function allows
documentation containing such conflicts to be defined by here-documents: e.g.,

.Here-documented Function
==========================================
[source]
------------------------------------------
declare_function_with_stdin <<'________________<heredoc!>________________'
void armok(string god, character of, boolean blood)

``Losing'' is `fun`.
________________<heredoc!>________________
''
------------------------------------------
==========================================

See declare_function() for further details.
________________<heredoc?>________________

# --------------------( WASTELANDS                         )--------------------
