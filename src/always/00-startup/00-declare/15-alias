#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle alias declarers.
______________<heredoc?>______________

#FIXME: It'd be great to support an optional suffixing argument to
#declare_alias(): the alias expansion to expand such alias to. This eliminates
#the unctuous duplication inherent in the current approach, while still
#admitting such approach. The resulting prototype would resemble:
#
#   void declare_alias(string documentation, string expansion = "")
#
#Note this cannot be scaled to functions without stupid and extreme hardship
#(i.e., single- or double-quoting the entire function body *OR* escaping all
#shell-reserved characters in such body, which is equally absurd).

# ....................{ GLOBALS                            }....................
# Global map from alias names to the help strings documenting such aliases. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_ALIAS_NAME_TO_HELP

# ....................{ DECLARERS                          }....................
declare_function_with_stdin <<'-\-'
void declare_alias(string documentation)

Declare the alias named by the alias prototype prefixing the passed help string
to be contained by the current parcel and documented by such string. Alias help
strings consist of:

. An *alias prototype* in `zeshy`-specific C-like syntax consisting of one or
  more alias return types, one alias name, and zero or more alias arguments
  (e.g., `string the_parable_of_the_box(integer derrick, character jensen)`).
. An *alias description* in http://asciidoc.org[AsciiDoc] syntax, augmented with
  `zeshy`-specific markup for cross-referencing other `zeshy` documentation.
  (e.g., `The *box* is +full+ of salmon, and a *man* sits +atop+ the box.`)

== Alias Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)].
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., ReturnTypes, Whitespace):

.Alias Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| AliasDocumentation    | <- | AliasPrototype Whitespace+ AsciiDoc
| AliasPrototype        | <- | Whitespace* ReturnTypes
                               Whitespace+ AliasName
                               Whitespace* AliasArgs
| AliasName             | <- | AlphanumericString
| AliasArgs             | <- | ArgumentList | ArgumentChannels
| AliasArgChannels      | <- | ``['' Whitespace* ( AliasArgChannel Whitespace*
                               ``,'' Whitespace*)* AliasArgChannel Whitespace*
                               ``]''
| AliasArgChannel       | <- | AliasArgChannelName Whitespace* ``:'' Whitespace*
                               (Argument | ArgumentList)
| AliasArgChannelName   | <- | ``args'' | ``argstring'' | ``stdin''
|===============================================================================

== Alias Description and Prototype ==

Aliases support the same descriptions and prototypes as functions, with one
minor and one major exception. See declare_function() for all other details.

=== Minor Exception ===

Function prototypes permit multiple names. Alias prototypes permit only one.

=== Major Exception ===

Function prototypes permit only two argument channel names: `args` and `stdin`.
Alias prototypes permit a third argument channel specific to herestring-driven
aliases: `argstring`.

By design, zsh aliases are expanded inline and hence cannot accept arbitrary
arguments not accepted by the commands such aliases expand to. As example, the
alias `l` declared by `alias l=ls` accepts only the arguments accepted by
command `ls` -- no more, no less.

Herestring-driven aliases circumvent such constraints by accepting a single
herestring argument embedding one or more ``real'' arguments to be passed such
alias. Since such aliases _always_ accept a single herestring, declaring a
single-string argument list conveys no meaningful information. Rather, such
aliases should declare a herestring-specific argument channel `argstring`
accepting the argument list embedded in such herestring. For clarity, consider
optionally suffixing aliases defined in this way with `_from': e.g.,

.Herestring-driven Alias
==========================================
[source]
------------------------------------------
declare_alias '
void set_args_to_string_split_on_words_from[
    argstring: (string text1, string text2, ...)]

Set the current argument list to the passed strings split on shell words: e.g.,

    >>> string on_relations=\
    ...    "All fixed, fast-frozen relations, with their train of ancient and
    ...     venerable prejudices and opinions, are swept away, all new-formed
    ...     ones become antiquated before they can ossify. All that is solid
    ...     melts into air, all that is holy is profaned, and man is at last
    ...     compelled to face with sober senses his real conditions of life, and
    ...     his relations with his kind."
    >>> set_args_to_string_split_on_words_from "${on_relations}"
    >>> print_string ${3}
    fast-frozen
'
alias set_args_to_string_split_on_words_from='
{
    # Validate passed arguments.
    list args__sltssowf
    set_list_to_stdin_words args__sltssowf
    (( ${#args__sltssowf} >= 1 )) or die 'expected at least one string'

    # Temporary list to split such strings into.
    list words__sltssowf

    # Split such strings.
    set_list_to_string_words words__sltssowf "${args__sltssowf[@]}"

    # Set the current argument list to such words.
    set_args "${words__sltssowf[@]}"

    # Delete such temporary list.
    undefine_variable words__sltssowf
} <<<'
------------------------------------------
==========================================
-\-
function declare_alias() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help__da="${1}"

    # Unless such string matches the function help PCRE, throw an exception.
    [[ "${help__da}" =~\
       "${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}" ]] ||
        die_for_declarator_type_with_help 'alias' "${help__da}"
#   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
#       print "match ${match_index}: ${match[${match_index}]}"
#   }

    # Alias name matched from such string.
    local alias_name__da="${match[1]}"

    # Map such alias to such help string.
    ZESHY_ALIAS_NAME_TO_HELP[${alias_name__da}]="${help__da}"

    # Add such alias to the current parcel.
    add_parcel_alias "${ZESHY_PARCEL_NAME}" "${alias_name__da}"
}

declare_function_with_stdin <<'-\-'
void declare_alias_with_stdin[stdin: string documentation]

Set the documentation for the alias named by the variable declaration prefixing
standard input to such input. Consider calling this rather than declare_alias(),
which requires passing a string argument rather than standard input. See
declare_function_with_stdin() for further details.
-\-
function declare_alias_with_stdin() {
    run_runnable_with_stdin declare_alias
}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'-\-'
void define_alias(string alias_name, string alias_expansion)

Define the passed alias to expand to the passed expansion. While `zsh` already
offers intuitive syntax for defining aliases with names _not_ containing alias-
reserved characters (e.g., `"`, `=`, whitespace), defining aliases with names
containing such characters requires such characters be explicitly escaped and
hence is neither intuitive or safe. This function amends this: e.g.,

.define_alias()
==========================================
[source]
------------------------------------------
>>> define_alias "propaganda = explanation" 'print_string "
...     Israel is an embattled country. They rely very heavily on U.S. support.
...     So they have developed a very sophisticated system of propaganda. They
...     don't call it propaganda. They call it hasbarah. It is the only country
...     I know of in the world that refers to propaganda as explanation. The
...     Ministry of Propaganda is the Ministry of Explanation. The idea being
...     that our position on everything is so obviously correct that if we only
...     explain it to people, they will see that it is right."'
>>> get_line $("propaganda = explanation") -1
explain it to people, they will see that it is right.
------------------------------------------
==========================================
-\-
function define_alias() {
    # Validate passed arguments.
    (( # == 2 )) || die 'expected one alias name and one alias expansion'
    local alias_name__da alias_expansion__da="${2}"

    # Sanitize such name, escaping all alias-reserved characters. Unlike
    # functions, merely double quoting alias names does *NOT* suffice.
    alias_name__da="${1//(#m)([\"=[:space:]])/\\${MATCH}}"

    # If such alias already exists, throw an exception. See
    # is_alias_normal_or_global() for further details.
    alias -- "${alias_name__da}" &>/dev/null and
        die "alias \"${alias_name__da}\" already exists"

    # Declare such alias.
    alias -- "${alias_name__da}"="${alias_expansion__da}"
}

# ....................{ DEFINERS ~ type                    }....................
declare_alias_with_stdin <<'-\-'
void alias_global(string alias_name, string alias_expansion)

Define a *global alias* (i.e., alias expanded in any shell word position rather
than only in command position).
-\-
alias alias_global="alias -g"

declare_alias_with_stdin <<'-\-'
void alias_suffix(string alias_name, string alias_expansion)

Define a *suffix alias* (i.e., alias expanded when a file of such suffixed
filetype is in command position).
-\-
alias alias_suffix="alias -s"

# --------------------( WASTELANDS                         )--------------------
#Set the documentation for the alias named by the alias prototype prefixing the
#passed string to such string. 
#by association with 
#only at the end of
#expressions, typically for filetypes).

    #FUXME: Fixup! We don't have to do much parsing here. Aliases can't be
    #globbable (as that's how we make things globbable in the first place) and
    #can't have synonyms, so we just need to parse the straightup alias name.
    #That still requires a bit of work, but by leveraging the above regular
    #expressions shouldn't be *TOO* terribly convoluted.
    #FUXME: O.K.; match similarly to declare_function() below, but using the
    #following PCRE instead: ${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}.
