#!/usr/bin/env zsh
# ====================[ pcre                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by alias, function, and global declarers.

# ....................{ GLOBALS                            }....................
# Exported string PCRE globals, defined and documented below.
typeset -gx\
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME\
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES\
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_NAME\
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES\

# Define such PCREs in an anonymous block to permit definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
    # PCRE matching the start of a zeshy help string. Dismantled, this is:
    #
    # * "(?s)", inducing '.' to match all characters including newline.
    local pcre_start='(?s)^\s*+'

    # Comma preceded and followed by optional whitespace.
    local pcre_comma='\s*+,\s*+'

    # zsh identifier (i.e., variable name).
    local pcre_ident='[-_[:alnum:]]++'

    # Function attributes. zeshy currently prohibits single- and double-quoted
    # attribute names, thus simplifying matching.
    local pcre_function_attributes='(?:<\s*+([^>]*+)>\s++)?'

    # Function return types. zeshy currently prohibits single- and double-quoted
    # return types, thus simplifying matching.
    local pcre_return_channel_grouped='('${pcre_ident}')\s*+:\s*+('${pcre_ident}')'
    local pcre_return_type_grouped='(?:void|('${pcre_ident}'))'
    local                    pcre_return_type=${pcre_ident}
    local pcre_return_channels_grouped='\[\s*+([^]]*+)\]'
    local         pcre_return_channels='\[\s*+[^]]*+\]'
    local pcre_return_type_or_channels='(?:'${pcre_return_type}'|'${pcre_return_channels}')\s++'
    local pcre_return_type_or_channels_grouped='(?:'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')\s++'

    # Function names. Since zsh permits single- and double-quoted function names,
    # matching requires more than class negation.
    local pcre_runnable_name_unquoted=${pcre_ident}
    local pcre_runnable_name_double_quoted='"(?:\\"|[^"])*"'
    local pcre_runnable_name_single_quoted="'(?:''|[^'])*'"
    local pcre_runnable_name_content=${pcre_runnable_name_unquoted}'|'${pcre_runnable_name_double_quoted}'|'${pcre_runnable_name_single_quoted}
    local pcre_function_name_grouped='('${pcre_runnable_name_content}')'
    local       pcre_function_name='(?:'${pcre_runnable_name_content}')'
    local pcre_function_names='\{\s*+((?:'${pcre_function_name}${pcre_comma}')*'${pcre_function_name}')(?:'${pcre_comma}')?\s*+\}'
    local pcre_function_name_or_names='(?:('${pcre_function_name}')|'${pcre_function_names}')\s*+'

    # Alias names. Since zsh permits single- and double-quoted alias names,
    # matching requires more than class negation. While quoting alias names is
    # is non-trivial (unlike functions), it *IS* feasible. See define_alias()
    # for further details.
    local pcre_alias_name_grouped='('${pcre_runnable_name_content}')'

    # Function arguments.
    local pcre_arg_value_double_quoted='"(?:\\"|$\([^)]*+\)|[^"])*"'
    local pcre_arg_value_single_quoted=${pcre_function_name_single_quoted}
    local pcre_arg_value_number='-?\d++\.\d++|-?\d++'
    local pcre_arg_value_content=${pcre_arg_value_double_quoted}'|'${pcre_arg_value_single_quoted}'|'${pcre_arg_value_number}
    local pcre_arg_value_equals='\s*+=\s*+'
    local pcre_arg_value_grouped=${pcre_arg_value_equals}'('${pcre_arg_value_content}')'
    local         pcre_arg_value=${pcre_arg_value_equals}'(?:'${pcre_arg_value_content}')'
    local pcre_arg_grouped='('${pcre_ident}')\s++('${pcre_ident}')(?:'${pcre_arg_value_grouped}')?'
    local            pcre_arg=${pcre_ident}'\s++'${pcre_ident}'(?:'${pcre_arg_value}')?'
    local pcre_args_list_grouped='((?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}')(?:'${pcre_comma}')?'
    local          pcre_args_list='(?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}'(?:'${pcre_comma}')?'
    local pcre_args_grouped='\(\s*+(?:void|'${pcre_args_list_grouped}')?\s*+\)'
    local         pcre_args='\(\s*+(?:void|'${pcre_args_list}')?\s*+\)'
    local pcre_arg_channel_grouped='('${pcre_ident}')\s*+:\s*+(?:(void|'${pcre_arg}')|('${pcre_args}'))'
    local            pcre_arg_channel=${pcre_ident}'\s*+:\s*+(?:void|'${pcre_arg}'|'${pcre_args}')'
    local pcre_arg_channels='\[\s*+((?:'${pcre_arg_channel}${pcre_comma}')*'${pcre_arg_channel}')(?:'${pcre_comma}')?\s*+\]'
    local pcre_args_or_channels_grouped='(?:'${pcre_args_grouped}'|'${pcre_arg_channels}')'

    # Function description. Ignore cross-references embedded in the following
    # AsciiDoc-specific passthrough syntactic constructs, which AsciiDoc and hence
    # zeshy ignores for parsing purposes:
    #
    # * "`"-delimited passthrough quotes.
    # * "pass:["- and "]"-delimited passthrough macros.
    # * "+++"-delimited passthrough macros.
    # * "$$"-delimited passthrough macros.
    # * "\n----"-delimited listing blocks.
    # * "\n...."-delimited literal blocks.
    # * "\n////"-delimited comment blocks.
    # * "\n++++"-delimited passthrough blocks.
    # * "\n[literal]"-prefixed literal paragraphs.
    # * "\n "- and "\n\t"-prefixed literal lines.
    #
    # Ignore cross-references embedded in the following AsciiDoc-specific anchored
    # syntactic constructs, which AsciiDoc anchors for subsequent cross-referencing
    # and hence should not themselves contain cross-references:
    #
    # * "\n."-prefixed block titles.
    local pcre_asciidoc_quote_backtick='\b`\N*?`\b'
    local pcre_asciidoc_macro_pass='pass:\[(?:\\\]|\N)*?\]'
    local pcre_asciidoc_macro_plus='\+\+\+\N*?\+\+\+'
    local pcre_asciidoc_macro_dollar='\$\$\N*?\$\$'
    local pcre_asciidoc_block_listing='-{4,}+\n.*?\n-{4,}+'
    local pcre_asciidoc_block_literal='\.{4,}+\n.*?\n\.{4,}+'
    local pcre_asciidoc_block_comment='/{4,}+\n.*?\n/{4,}+'
    local pcre_asciidoc_block_pass='\+{4,}+\n.*?\n\+{4,}+'
    local pcre_asciidoc_block_title_or_line_literal='(?:\.|[ \t]++)\N+'
    local pcre_asciidoc_paragraph_literal='^\[literal\]\n.*?(?:\n\n|\Z)'
    local pcre_asciidoc_cross_reference='((?:'${pcre_asciidoc_quote_backtick}'|\b(?:'${pcre_asciidoc_macro_pass}'|'${pcre_asciidoc_macro_plus}'|'${pcre_asciidoc_macro_dollar}')\b|^(?:'${pcre_asciidoc_block_listing}'|'${pcre_asciidoc_block_literal}'|'${pcre_asciidoc_block_comment}'|'${pcre_asciidoc_block_pass}'|'${pcre_asciidoc_block_title_or_line_literal}')$|'${pcre_asciidoc_paragraph_literal}'|.)*?)([$@]\{'${pcre_ident}'\}|(?:(alias|function):)?'${pcre_ident}'\(\))'
    local pcre_asciidoc_suffix='(.*)'
    local pcre_asciidoc='\s*+(.*)'

    # PCRE matching the alias name in an alias prototype.
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME=${pcre_start}${pcre_return_type_or_channels}${pcre_alias_name_grouped}

    # PCRE matching all function attributes and names in function prototypes.
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES=${pcre_start}${pcre_function_attributes}${pcre_return_type_or_channels}${pcre_function_name_or_names}

    # PCRE matching one function name in a list of such names.
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_NAME=${pcre_function_name_grouped}'(?:'${pcre_comma}')?'

    #FIXME: Exclude attributes and names.
    # PCRE matching all semantic substrings in function prototypes, excluding
    # attributes and names. This includes return types, arguments, and AsciiDoc.
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES=${pcre_start}${pcre_function_attributes}${pcre_return_type_or_channels_grouped}${pcre_function_name_or_names}${pcre_args_or_channels_grouped}${pcre_asciidoc}'()$'
}

# --------------------( WASTELANDS                         )--------------------
