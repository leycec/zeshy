#!/usr/bin/env zsh
# ====================[ declare                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle alias, function, and global declarers.

#FIXME: Rename the ${ZESHY_HELP_GLOBALS}, etc. globals to
#${ZESHY_CORE_HELP_GLOBALS}, etc. Such globals, *DISTINCT* from the above, now
#apply *ONLY* to top-level components (e.g., src/{main,compile,...}). For
#efficiency (and simplicity), retain the current approach of simply appending to
#such lists. Then during zeshy precompilation (as implemented by
#"always/zsh/help/precompile"), simply iterate over each such list and for each
#help string simply call declare_global(), etc. Ultra-simple and efficient.
#After doing so, all documentation resides in the
#${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals as desired.

#FIXME: Add declare_component() and declare_component_with_stdin() functions.
#It bears considering how we'll actually associate components with aliases,
#functions, and globals, considering that zsh does not support nested data
#structures. I suppose we'll need to pack everything into a map. How about
#${ZESHY_COMPONENT_NAME_TO_ALIAS_NAME} (and so forth for globals and functions),
#with structure resembling:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'declare' 'declare_alias:declare_function:declare_global'
#  )
#
#Hence, values are ":"-delimited function names. For globals, this clearly
#suffices, as global names are sufficiently constrained. For aliases and
#functions, however, we'll need to support double-quoted strings. Just double-
#quoted, to make things *MOSTLY* simple. The only complexity there is
#remembering to quote-protect embedded '"' characters in alias and function
#names.
#FIXME: Wait. Component names *MUST* also include internal structure --
#subdirectories (i.e., parent components), in this case. The above should be:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'always/00-startup/00-declare/declare'
#          'declare_alias:declare_function:declare_global'
#  )
#
#The reason why, of course, is that component names are only unique within such
#subdirectories.
#FIXME: On calling declare_component(), we'll need to set a global caching the
#current component name (complete with subdirectories) -- say,
#${ZESHY_COMPONENT_NAME_CURRENT}. There's no need to persist such global after
#sourcing all zeshy components, so we should probably undefine it after that.
#FIXME: So what should component documentation contain? It's fairly simple, I
#think: *ALL* component documentation should be AsciiDoc. We could support a
#prefixing prototype, but I fail to see how that's helpful. The current
#component name is perfectly inferrable from the current path -- no need to
#duplicate it unnecessarily. Great!
#FIXME: We'll need some mechanism for cross-referencing other components in
#AsciiDoc descriptions. How about a "@{...}"-style syntax (e.g.,
#"Please see component @{string} or @{variable/map/map}")? Finding *WHICH*
#component such reference references is slightly more difficult than for
#aliases, functions, and globals, however, as component names are non-unique.
#Since components often change paths, we probably want to employ a relative
#path-searching algorithm as follows:
#
#* If such component is prefixed with an absolute or relative path prefix
#  (e.g., @{/always/variable/list/list} or @{../../type}), test whether such
#  file exist. Relative paths are simply relative to the directory containing
#  the current component. Absolute paths should be prefixed with the directory
#  of the overlay root containing containing the current component. (Err,
#  perhaps *ANY* overlay root, testing each? No sense being overly restrictive.)
#* If that fails, prefix such component name with "./" (e.g., from @{string} to
#  @{./string}). If such file exists in the same directory as the directory of
#  the current component, such file is the desired target of such cross-reference.
#* If that fails, prefix such component name with "../" (e.g., from @{string} to
#  @{../string}). Again test whether such file exists.
#* Continue prefixing such component name with an additional "../" until either
#  traversing above the overlay root containing the current component or
#  discovering such component.

#FIXME: The above globals raise the obvious question: should we keep them in
#memory or serialize them to disk? For the most, I strongly suspect they're
#sufficiently small to impose no burden in memory. If this ever changes, we
#simply offload them to disk with a KVS-based implementation. Simple, no?

#FIXME: Remove all reference to {prepend,append,set}_args_with_stdin() from the
#Zeshy codebase, excluding set_args_with_stdin() where called from herestring-
#style aliases. In all other cases, such calls are highly dangerous and should
#be eliminated.
#FIXME: Wait. I believe we *MIGHT* be able to resuscitate such function *IF* we
#can augment them as follows (...no idea if this works, but it seems worth a
#try):
#
#* If standard input is an open pipe *AND* if list global ${pipestatus} is of
#  size larger than one, then doesn't that definitively suggest the current
#  function is directly piped standard input? Naturally, we should extensively
#  test this in vanilla zsh before running around like a mad badger attempting
#  to implement this in Zeshy.

#FIXME: Naturally, AsciiDoc will be an only optional dependency for users
#attempting to build the documentation. If not installed, we'll just display
#function documentation as is when a user runs "help function". If installed,
#we'll probably want to pipe function documentation dynamically through either
#the ASCII or man page exporters. (Sweeeeeet, no?)

#FIXME: Matching function prototypes is feasible with one or possibly more PCREs
#but *NOT* globs, due to the need to match arbitrarily many function names and
#argument specifiers. This is essential, since:
#
#* If AsciiDoc is installed, function prototypes should be dynamically marked up
#  with AsciiDoc-specific notation, which I believe even supports colors.
#* Else, function prototypes should be styled with conventional color styles.
#FIXME: Source code highlighting is simple. Just write:
#
#    [source,bash]
#    ----
#    INSERT CODE HERE
#    ----
#
#Sadly, neither Pygments or other less popular alternatives support zsh yet.
#Hence, "bash" suffices. Then, we want to selectively prefer "pygments" where
#available. To do so, we'll need to output the following at the very top of each
#AsciiDoc document we send to "asciidoc":
#
#    8<---------------
#    = Title
#    :source-highlighter: pygments
#
#This is an AsciiDoc header instructing "asciidoc" to prefer the "pygments"
#backend for the [source] filter. For further details, see:
#    https://groups.google.com/forum/?fromgroups=#!topic/asciidoc/ReIM4z-zi9I
#FIXME: Avoid repetition. In particular, replace "[source,bash]" with simply
#"[source]" everywhere by setting the default "language" in the AsciiDoc
#document header, like so:
#
#    :language: bash
#
#The same style can be extended to set default table attributes as follows:
#
#    :grid:  none
#    :frame: topbot

#FIXME: Documentation functions should continue working after Zeshy startup. To
#make this work, we'll need to redefine them in a precompile_zeshy_() function
#to ensure that the digest file contains the redefinition. Honestly, I'm not
#entirely convinced we want to serialize such documentation to disk; of course,
#we *DO*. But that invokes a few not-so-subtle issues. For now, just retain
#documentation in memory until it becomes a demonstrable problem.
#FIXME: After having performed a great deal of online research, "gzip" appears
#to be the canonical go-to for small text file compression.
#FIXME: Hmmmm. No. Scratch that. We really need a filesystem-based approach.
#O.K.; so, here's the idea:
#
#* Shift the definitions of set_alias_documentation(), etc. to this component,
#  replacing all current calls to such functions with hard-coded additions to
#  such map globals. *DO IT.* Trust me. This is needed to ensure that such
#  functions are compiled into Zeshy's digest file.
#* *DON'T* redefine declare_alias(), declare_function(), or declare_global().
#  Instead redefine set_alias_documentation(), etc. to write to disk rather to
#  such map globals in the precompile_zeshy_*() function defined below, thus
#  ensuring the redefinition of such functions is compiled into Zeshy's digest.
#
#Bam. Nice one, eh?

# ....................{ GLOBALS                            }....................
#FIXME: Don't neglect to delete such maps immediately after use in
#precompilation!

# Global maps from alias, function, and global names to help strings for such.
# Avoid documenting such maps formally, which we delete during precompilation to
# conserve space. See also the following lists specific to top-level components,
# which precompilation converts into elements of such maps:
# ${ZESHY_CORE_HELP_ALIASES}, ${ZESHY_CORE_HELP_FUNCTIONS}, and
# ${ZESHY_CORE_HELP_GLOBALS}.
#
# Component "document" declares and documents all other pertinent globals (e.g.,
# ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME}).
typeset -Ag\
    ZESHY_ALIAS_NAME_TO_HELP\
    ZESHY_FUNCTION_NAME_TO_HELP\
    ZESHY_GLOBAL_NAME_TO_HELP\

# ....................{ GLOBALS ~ pcre                     }....................
# Exported string PCRE globals, defined and documented below.
typeset -gx\
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME\
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES\
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_NAME\
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES\

# Define such PCREs in an anonymous block to permit definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
    # PCRE matching the start of a zeshy help string. Dismantled, this is:
    #
    # * "(?s)", inducing '.' to match all characters including newline.
    local pcre_start='(?s)^\s*+'

    # Comma preceded and followed by optional whitespace.
    local pcre_comma='\s*+,\s*+'

    # zsh identifier (i.e., variable name).
    local pcre_ident='[-_[:alnum:]]++'

    # Function attributes. zeshy currently prohibits single- and double-quoted
    # attribute names, thus simplifying matching.
    local pcre_function_attributes='(?:<\s*+([^>]*+)>\s++)?'

    # Function return types. zeshy currently prohibits single- and double-quoted
    # return types, thus simplifying matching.
    local pcre_return_channel_grouped='('${pcre_ident}')\s*+:\s*+('${pcre_ident}')'
    local pcre_return_type_grouped='(?:void|('${pcre_ident}'))'
    local                    pcre_return_type=${pcre_ident}
    local pcre_return_channels_grouped='\[\s*+([^]]*+)\]'
    local         pcre_return_channels='\[\s*+[^]]*+\]'
    local pcre_return_type_or_channels='(?:'${pcre_return_type}'|'${pcre_return_channels}')\s++'
    local pcre_return_type_or_channels_grouped='(?:'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')\s++'

    # Function names. Since zsh permits single- and double-quoted function names,
    # matching requires more than class negation.
    local pcre_runnable_name_unquoted=${pcre_ident}
    local pcre_runnable_name_double_quoted='"(?:\\"|[^"])*"'
    local pcre_runnable_name_single_quoted="'(?:''|[^'])*'"
    local pcre_runnable_name_content=${pcre_runnable_name_unquoted}'|'${pcre_runnable_name_double_quoted}'|'${pcre_runnable_name_single_quoted}
    local pcre_function_name_grouped='('${pcre_runnable_name_content}')'
    local       pcre_function_name='(?:'${pcre_runnable_name_content}')'
    local pcre_function_names='\{\s*+((?:'${pcre_function_name}${pcre_comma}')*'${pcre_function_name}')(?:'${pcre_comma}')?\s*+\}'
    local pcre_function_name_or_names='(?:('${pcre_function_name}')|'${pcre_function_names}')\s*+'

    # Alias names. Since zsh permits single- and double-quoted alias names,
    # matching requires more than class negation. While quoting alias names is
    # is non-trivial (unlike functions), it *IS* feasible. See define_alias()
    # for further details.
    local pcre_alias_name_grouped='('${pcre_runnable_name_content}')'

    # Function arguments.
    local pcre_arg_value_double_quoted='"(?:\\"|$\([^)]*+\)|[^"])*"'
    local pcre_arg_value_single_quoted=${pcre_function_name_single_quoted}
    local pcre_arg_value_number='-?\d++\.\d++|-?\d++'
    local pcre_arg_value_content=${pcre_arg_value_double_quoted}'|'${pcre_arg_value_single_quoted}'|'${pcre_arg_value_number}
    local pcre_arg_value_equals='\s*+=\s*+'
    local pcre_arg_value_grouped=${pcre_arg_value_equals}'('${pcre_arg_value_content}')'
    local         pcre_arg_value=${pcre_arg_value_equals}'(?:'${pcre_arg_value_content}')'
    local pcre_arg_grouped='('${pcre_ident}')\s++('${pcre_ident}')(?:'${pcre_arg_value_grouped}')?'
    local            pcre_arg=${pcre_ident}'\s++'${pcre_ident}'(?:'${pcre_arg_value}')?'
    local pcre_args_list_grouped='((?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}')(?:'${pcre_comma}')?'
    local          pcre_args_list='(?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}'(?:'${pcre_comma}')?'
    local pcre_args_grouped='\(\s*+(?:void|'${pcre_args_list_grouped}')?\s*+\)'
    local         pcre_args='\(\s*+(?:void|'${pcre_args_list}')?\s*+\)'
    local pcre_arg_channel_grouped='('${pcre_ident}')\s*+:\s*+(?:(void|'${pcre_arg}')|('${pcre_args}'))'
    local            pcre_arg_channel=${pcre_ident}'\s*+:\s*+(?:void|'${pcre_arg}'|'${pcre_args}')'
    local pcre_arg_channels='\[\s*+((?:'${pcre_arg_channel}${pcre_comma}')*'${pcre_arg_channel}')(?:'${pcre_comma}')?\s*+\]'
    local pcre_args_or_channels_grouped='(?:'${pcre_args_grouped}'|'${pcre_arg_channels}')'

    # Function description. Ignore cross-references embedded in the following
    # AsciiDoc-specific passthrough syntactic constructs, which AsciiDoc and hence
    # zeshy ignores for parsing purposes:
    #
    # * "`"-delimited passthrough quotes.
    # * "pass:["- and "]"-delimited passthrough macros.
    # * "+++"-delimited passthrough macros.
    # * "$$"-delimited passthrough macros.
    # * "\n----"-delimited listing blocks.
    # * "\n...."-delimited literal blocks.
    # * "\n////"-delimited comment blocks.
    # * "\n++++"-delimited passthrough blocks.
    # * "\n[literal]"-prefixed literal paragraphs.
    # * "\n "- and "\n\t"-prefixed literal lines.
    #
    # Ignore cross-references embedded in the following AsciiDoc-specific anchored
    # syntactic constructs, which AsciiDoc anchors for subsequent cross-referencing
    # and hence should not themselves contain cross-references:
    #
    # * "\n."-prefixed block titles.
    local pcre_asciidoc_quote_backtick='\b`\N*?`\b'
    local pcre_asciidoc_macro_pass='pass:\[(?:\\\]|\N)*?\]'
    local pcre_asciidoc_macro_plus='\+\+\+\N*?\+\+\+'
    local pcre_asciidoc_macro_dollar='\$\$\N*?\$\$'
    local pcre_asciidoc_block_listing='-{4,}+\n.*?\n-{4,}+'
    local pcre_asciidoc_block_literal='\.{4,}+\n.*?\n\.{4,}+'
    local pcre_asciidoc_block_comment='/{4,}+\n.*?\n/{4,}+'
    local pcre_asciidoc_block_pass='\+{4,}+\n.*?\n\+{4,}+'
    local pcre_asciidoc_block_title_or_line_literal='(?:\.|[ \t]++)\N+'
    local pcre_asciidoc_paragraph_literal='^\[literal\]\n.*?(?:\n\n|\Z)'
    local pcre_asciidoc_cross_reference='((?:'${pcre_asciidoc_quote_backtick}'|\b(?:'${pcre_asciidoc_macro_pass}'|'${pcre_asciidoc_macro_plus}'|'${pcre_asciidoc_macro_dollar}')\b|^(?:'${pcre_asciidoc_block_listing}'|'${pcre_asciidoc_block_literal}'|'${pcre_asciidoc_block_comment}'|'${pcre_asciidoc_block_pass}'|'${pcre_asciidoc_block_title_or_line_literal}')$|'${pcre_asciidoc_paragraph_literal}'|.)*?)([$@]\{'${pcre_ident}'\}|(?:(alias|function):)?'${pcre_ident}'\(\))'
    local pcre_asciidoc_suffix='(.*)'
    local pcre_asciidoc='\s*+(.*)'

    # PCRE matching the alias name in an alias prototype.
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME=${pcre_start}${pcre_return_type_or_channels}${pcre_alias_name_grouped}

    # PCRE matching all function attributes and names in function prototypes.
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES=${pcre_start}${pcre_function_attributes}${pcre_return_type_or_channels}${pcre_function_name_or_names}

    # PCRE matching one function name in a list of such names.
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_NAME=${pcre_function_name_grouped}'(?:'${pcre_comma}')?'

    #FIXME: Exclude attributes and names.
    # PCRE matching all semantic substrings in function prototypes, excluding
    # attributes and names. This includes return types, arguments, and AsciiDoc.
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES=${pcre_start}${pcre_function_attributes}${pcre_return_type_or_channels_grouped}${pcre_function_name_or_names}${pcre_args_or_channels_grouped}${pcre_asciidoc}'()$'
}

# ....................{ DECLARERS                          }....................
#FIXME: I submit we should define a syntax for embedding function attributes in
#function documentation and having declare_function() itself parse and handle
#such attributes. For the moment, I can only think of one such attribute:
#"globbable". Define such attribute like so:
#
#   <globbable> void happy_go_lucky(void)
#
#Dead simple, yes? What's great about this is that it formally associates the
#attribute with the function's documentation, which we can later highlight
#accordingly.

function declare_alias() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help="${1}"

    #FIXME: Fixup! We don't have to do much parsing here. Aliases can't be
    #globbable (as that's how we make things globbable in the first place) and
    #can't have synonyms, so we just need to parse the straightup alias name.
    #That still requires a bit of work, but by leveraging the above regular
    #expressions shouldn't be *TOO* terribly convoluted.
    #FIXME: O.K.; match similarly to declare_function() below, but using the
    #following PCRE instead: ${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}.
}

function declare_function() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help="${1}"

    # Unless such string matches the function help PCRE, throw an exception.
    [[ "${help}" =~\
        ${ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES} ]] || {
        # Function prototype prefixing such help string.
        string help_prototype

        # If such string contains a blank line (i.e., "\n\n"), crudely match the
        # substring preceding such line as the function prototype.
        if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
            help_prototype="${match[1]}"
        # Else if such string contains a newline (i.e., "\n"), crudely match the
        # substring preceding such newline as the function prototype.
        } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
            help_prototype="${match[1]}"
        # Else, abandon all hope.
        } else {
            help_prototype="${help}"
        }

        die 'function help string invalid (see "print_help declare_function" for details):
'"${help_prototype}"
    }
#   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
#       print "match ${match_index}: ${match[${match_index}]}"
#   }

    # List of substrings captured by the prior match. The PCRE-based iteration
    # below overwrites ${match}, necessitating we copy it here.
    local -a help_match; help_match=( "${match[@]}" )

    # List of function names matched from such string.
    local -a function_names

    # If such function has only a single name, match such name.
    if [[ -n "${help_match[2]}" ]] {
        function_names=( "${help_match[2]}" )
    # Else, such function has multiple names. Since single- and double-quoted
    # function names may contain commas, such names cannot be split on commas as
    # with function attributes above. Rather, match such names with iteration.
    } else {
        # Prepare to match such names.
        pcre_compile -- "${ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_NAME}"
        pcre_study

        # Match such names, recording each to be a synonym of the first such
        # name matched above. See for_string_pcre_matches() for further details.
        local ZPCRE_OP='0 0'
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match[3]}" } {
            function_names+="${match[1]}"
            ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[${match[1]}]="${function_names[1]}"
        }
    }
#   for ((match_index=1; match_index <= ${#names}; ++match_index)) {
#       print "name ${match_index}: ${names[${match_index}]}"
#   }

    # If such function has attributes, match such attributes.
    if [[ -n "${help_match[1]}" ]] {
        # List of function attributes split from such string. Split on commas
        # after truncating:
        #
        # * Optional whitespace surrounding commas (e.g., from " , " to ",").
        # * Optional trailing commas and/or whitespace.
        local -a attributes; attributes=(
            "${(s:,:)${help_match[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]#,#[[:space:]]#}"
        )
#       for ((match_index=1; match_index <= ${#attrs}; ++match_index)) {
#           print "attr ${match_index}: ${attrs[${match_index}]}"
#       }

        # If such attributes include "globbable," disable filename globbing for
        # all arguments passed to such function names. See is_list_contains()
        # for further details.
        if (( ${attributes[(i)globbable]} <= ${#attributes} )) {
            for function_name ("${function_names[@]}") {
                # For safety (in the event of function names containing alias-
                # reserved characters), call define_alias() rather than manually
                # defining such alias.
                define_alias "${function_name}" "noglob \"${function_name}\""
            }
        }
    }

    # Map the first function name to such help string. Note the choice of
    # mapping function name synonyms to the first function name above, as well;
    # this is *NOT* a coincidence, as could be inferred.
    ZESHY_FUNCTION_NAME_TO_HELP[${function_names[1]}]="${help}"
}

function declare_global() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help__dg="${1}"

    # If such documentation is prefixed by a variable declaration, match the
    # variable name and type from such declaration. Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    #
    # Else throw an exception with a portion of such documentation.
    [[ "${help__dg}" ==\
        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] || {
        # Global prototype prefixing such help string.
        string help_prototype

        # If such string contains a newline (i.e., "\n"), crudely match the
        # substring preceding such newline as the global prototype.
        if [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
            help_prototype="${match[1]}"
        # Else, abandon all hope.
        } else {
            help_prototype="${help}"
        }

        die 'global help string invalid (see "print_help declare_global" for details):
'"${help_prototype}"
    }

    # Before attempting to declare such global, we should test whether such a
    # global already exists and if so either throw an exception or print a
    # warning. There exists no efficient means of performing such test, however.
    # While there do exist efficient means of testing whether a variable either
    # local or global exists and whether such variable in the current scope is
    # local or global, the only means of testing whether a global exists is to
    # parse the output of "typeset -gx +" for a line matching such global's
    # name. While such parsing could conceivably be efficient for infrequent
    # purposes, this function does not follow an infrequent purpose.

    # Such global's declared type and name.
    local global_type__dg="${match[1]}" global_name__dg="${match[2]}"

    # Alias declaring globals of such type.
    local declarator__dg="${global_type__dg}_global_export"

    # If such alias does not exist, throw an exception. Since such alias
    # could technically also be a function, match both. See is_runnable()
    # for further details.
#       print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
    whence -- "${declarator__dg}" &>/dev/null ||
        die "type \"${global_type__dg}\" unrecognized (${declarator__dg}() undefined)"

    # Declare such global. Since the declarator is typically an alias rather
    # than function or pathable, zsh requires evaluating rather than running
    # such declarator. While acceptable, this is somewhat... annoying.
    eval "${declarator__dg} \"\${global_name__dg}\""

    # Map such global name to such help string *AFTER* successfully declaring
    # such global.
    ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"
}

# ....................{ DECLARERS ~ stdin                  }....................
function declare_alias_with_stdin() {
    run_declarator_with_stdin declare_alias
}

function declare_function_with_stdin() {
    run_declarator_with_stdin declare_function
}

function declare_global_with_stdin() {
    run_declarator_with_stdin declare_global
}

function run_declarator_with_stdin() {
    # Validate passed arguments. If standard input is empty, throw an exception.
    # See is_stdin_nonempty() for further details.
    (( # == 1 )) || die 'expected one function name'
    read -t 0 || die 'standard input empty'
    local declarator_name__rdws="${1}"

    # If such declarator is not runnable, throw an exception.
    whence -- "${declarator_name__rdws}" &>/dev/null ||
        die "declarator ${global_type__dg}() undefined"

    # Declare such input. See get_stdin() for further details.
    "${declarator_name__rdws}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
                #FUXME: If such function name contains spaces or other awkward
                #characters, this is likely to fail -- probably silently!
                #Command-line experimentation suggests that creating such an
                #alias requires *EXTREME* quoting and quote-protection of such
                #quotes. Since this is fairly odd, it's conceivable it's a bug.
                #Here's what the horrid syntax looks like:
                #
                #  >>> alias \"hm\ mm\"="print ik"
                #  >>> "hm mm"
                #  ik
                #
                #So, both the prefixing and suffixing '"' as well as internal
                #whitespace have to be explicitly escaped. Certainly doable;
                #it's just... annoying! I suspect the "=" character also needs
                #be escaped. Anything else? *sigh*
                #FUXME: Given the complexity, we might want to define a function
                #accepting a desired alias name and expansion as two separate
                #parameters and defining such alias -- say, define_alias()?

    #FUXME: Leveraging the above regular expressions, parse function name
    #synonyms and attributes. See above for the algorithm.

    # Store such documentation for subsequent parsing.
#   ZESHY_HELP_GLOBAL+="${1}"

    #FUXME: This is incorrect, as it fails to declare globals if a local of the
    #same name exists. See is_variable_global() for a solution.
    #FUXME: If such global has been declared, we should probably print a
    #warning to standard error if its declared type differs from the
    #documentation-declared type. The implementation is a bit tedious,
    #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
    #dynamically constructed from its converse for performing efficient
    #lookups. Clearly, not a priority for the moment.
    # If such global has not yet been declared, do so. See is_variable() for
    # further details.
#   [[ -n "${(P)global_name__dg+x}" ]] || {

#FUXME: Restore the ${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals back to this
#component. Use such globals rather than ${ZESHY_HELP_GLOBALS}, etc. in
#function implementations below.
#FUXME: Consequently, declare_function() should immediately parse the passed
#help string's function prototype for only the following bits of metadata:
#
#* The list of all function attributes.
#* The list of all function names.
#
#Given the latter, set ${ZESHY_FUNCTION_NAME_TO_HELP} with the *FIRST* such
#function name and set ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME} as
#discussed below from all such function names to the first such function name.
#
#Then, given the former, if such attributes contain "globbable", define one
#"noglob" alias for each function name. Awesomeness!
#FUXME: Honestly, I don't see why we shouldn't support the same syntax for
#aliases. Hence, both functions should call an underlying function passed the
#names of the maps to... Ah, wait. No, no. Aliases don't genuinely support
#synonyms. We could fake it, I suppose. But I'm unsure whether there's any
#value in that. For now, confine such parsing to functions.

#FUXME: How should function synonyms be handled? For proper HTML construction,
#the fact that one function is a synonym of another *REALLY* needs to be
#embedded in either this data structure or another. How about a map
#${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME}? Given the following
#function declaration:
#
#  function func1 func2 func3() { ... }
#
#...we would populate such map as follows:
#
#  ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME=(
#      'func1' 'func1'
#      'func2' 'func1'
#      'func3' 'func1'
#  )
#
#Hence, given a function name, it's (largely) trivial and reasonably efficient
#to find all synonyms of such function. We arbitrarily choose the first function
#name to be the "source" to which all synonyms refer, including such function
#name itself. Note that functions with no synonyms should *NOT* be defined by
#such map. We could certainly admit that, but it serves no purpose and
#(potentially) squanders quite a bit of safe.
#   print "attrs: ${attrs[@]}"
#   print "names: ${names[@]}"
    #FUXME: Right. We don't actually need the list of names, due to our helpful
    #choice of global data structure. Instead, we only need to record the
    #*FIRST* function name in a string local.

        # Match the first such name, which by the definition of such PCRE is
        # guaranteed to exist. See for_string_pcre_matches() for further details.
#       pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names_string}"
#       function_names+="${match[1]}"

        #FUXME: Rather than append to such list, do the following:
        #
        #* Set the above string local to the first match.
        #* For all subsequent matches, map from such match to such string local
        #  in global ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME}.
        #
        #To do so simply (and efficiently!), do something resembling:
        #
        # This should be guaranteed to match and hence always return success.
#       while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match[3]}" } {
#           names+="${match[1]}"
#       }

        # Such names as a raw string. Since iteration overwrites list global
        # ${match}, copy such string before overwriting it below.
#       local names_string="${help_match[3]}"

    #FUXME: We'll clearly need to convert a few of the locals below into globals
    #above. Let's cross that tepid bridge when we trip into it.

        #FUXME: Actually, only print the first line of such documentation. Also, use
        #a different color for such line; say, regular red or cyan?
        #FUXME: Actually, print as follows:
        #
        #* If such prototype contains a blank line (i.e., "\n\n\n"), print from the
        #  first line of such prototype up to the next line that comes first of
        #  either such blank line or 5. (This avoids inevitable problems with
        #  pathological documentation.)
        #* Else, print only the first line of such documentation. This is only an
        #  unlikely edge case, so it needn't be too fancy; pretty much everyone will
        #  follow zeshy precedent of a blank line, I reckon.

    #string pcre_return_type=${pcre_ident}
        #string pcre_function_name_list='\{\s*+([^}]*?)(?:'${pcre_comma}')?\}'
#FUXME: Actually, defer such definition to the same precompilation function
#iterating and serializing all documentation to disk. The reason? Simplicity,
#centralizing all function prototype parsing into a single function. Such
#parsing is rapidly becoming too complex to duplicate between multiple
#functions.
#FUXME: Function name synonyms should be implemented as symbolic links in the
#documentation directory. Consequently, no parsing of function name synonyms is
#desirable in declare_function() itself. In fact, we can reduce the current
#temporary maps ZESHY_ALIAS_NAME_TO_DOCUMENTATION and so on to corresponding
#lists ZESHY_USER_HELP_ALIASES and so on. Just append each passed
#documentation string as is to the desired list.
#FUXME: Define a new declare_function_glob() or
#declare_function_sans_filename_globbing() or
#declare_function_and_disable_filename_globbing(). Yes, the latter. While
#verbose, that's not necessarily a bad thing in this case, as such function
#dramatically alters function parsing. In any case, such function should
#define a new alias of the same name expanding as follows:
#
#    alias ${function_name}="noglob ${function_name}"
#
#Test if such alias already exists before doing so, in which case throw an
#exception or perhaps merely print a warning. (Nah, exception!)

    #FUXME: Actually define set_string_with_stdin(). Simplicity incarnate.
    # Document such input. See set_string_with_stdin() for further details.
#Prefer globals
    # "${match[1]}" and "${match[2]}" to human-readable local variables to
    # avoid polluting the local shell environment any further. 
#FUXME: I'm unclear why this needs to be an alias. If we were declaring such
#variable locally, I could see it, but... yeah; I think I slightly erred in
#implementing this as an alias. Convert to a function and reap the rewards of
#simplicity.

# ....................{ SETTERS                            }....................
#function set_alias_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_CORE_HELP_ALIASES+="${1}"
#}

#function set_function_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_HELP_FUNCTION+="${1}"
#}

#function set_global_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_HELP_GLOBAL+="${1}"
#}

    # If such documentation is prefixed by an alias prototype, match the
    # relevant alias name from such prototype. While zsh permissively allows
    # alias name declarations to be quoted and hence contain arbitrary
    # characters as with functions, such aliases are not runnable: e.g.,
    #
    #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
    #   >>> o\ w\ s
    #   zsh: command not found: o w s
    #
    # For simplicity, use a similar glob expression as declare_function().
#   if [[ "${documentation}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
#   then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
#   fi

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
        # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi
#FUXME: declare_function() is arguably a bit more than mere documentation, now.
#Ditto for declare_global(). Perhaps we should contemplate a nomenclature
#change -- say, to prototype_function() or declare_function(). Yes, "declare"
#strikes me as the proper verb here. It applies to globals as well!
#FUXME: O.K., O.K. Stop the "<>" nonsense with aliases. It's useful for
#referencing aliases to distinguish them from functions but completely unuseful
#for prototyping aliases. Alias prototype syntax should be a proper subset of
#function prototype syntax. (Note this is really the only way to do the PEG, as
#well; can you imagine duplicating the bloody function PEG for aliases with only
#ignorable differences?)

#FUXME: Ensure this is performed in, say, "main":
#
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
# ....................{ DOCUMENTATION                      }....................
# Map from Zeshy-specific alias name to documentation for such alias.
#local -A ZESHY_ALIAS_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific function name to documentation for such function.
#local -A ZESHY_FUNCTION_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific global name to documentation for such global.
#local -A ZESHY_GLOBAL_NAME_TO_DOCUMENTATION

# Avoid documenting the following three functions, subsequently undefined during
# Zeshy startup and hence inaccessible to callers.

# void set_alias_documentation(string alias_name, string documentation)
#
# Document the passed alias with the passed string.
#function set_alias_documentation() {
#    (( # == 2 )) || die 'expected one alias name and one help string'
#    ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_function_documentation(string function_name, string documentation)
#
# Document the passed function with the passed string.
#function set_function_documentation() {
#    (( # == 2 )) || die 'expected one function name and one help string'
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_global_documentation(string global_name, string documentation)
#
# Document the passed global with the passed string.
#function set_global_documentation() {
#    (( # == 2 )) || die 'expected one global name and one help string'
#    ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#       # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi

#names following the `(`- and `)`-bracketed argument list or `[`- and `]`-
#bracketed argument channel list signifies such function to be annotated by such

#declare_function_with_stdin <<'________________<heredoc?>________________'
#void declare_function_with_stdin_and_disable_filename_globbing[
#    stdin: string documentation]
#
#Set the documentation for the function named by the function prototype prefixing
#standard input to such input and disable filename globbing on all arguments
#callers subsequently pass to such function. While the latter admittedly has
#little to do with function documentation, bundling the two together simplifies
#life. See declare_function_with_stdin() and
#disable_function_filename_globbing() for further details.
#________________<heredoc?>________________

#FUXME: Actually, no one'll ever call this function. Rename to
#declare_function_with_stdin_and_disable_function_filename_globbing() and
#implement accordingly. Yes, this is an obscenely long function name. No, in
#this particular instance, I don't particularly care. There's no reasonable
#abbreviation permitting the function name and heredoc declaration to reside on
#the same line, so such function is called like so:
#
#    declare_function_with_stdin_and_disable_function_filename_globbing\
#        <<'________________<heredoc?>________________'
#    ...
#    ________________<heredoc?>________________
#FUXME: Document declare_function_with_stdin() as well. In the documentation,
#note the reason for needing declare_function_with_stdin() to be the fact that
#both single- and double-quoted strings interface poorly with AsciiDoc syntax.
#Specifically, AsciiDoc's frequent use of:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.
#
#Fortunately, zsh supplies a third alternative: here-documents. Since zsh
#writes here-documents to standard input, this function expects non-empty
#standard input. See declare_function() for further details.

#While function documentation can be passed as a
#conventional string argument to declare_function() rather than as standard
#input to this function, such documentation adheres to 
#http://asciidoc.org[AsciiDoc] syntax containing syntactic constructs
#containing characters conflicting with
#conventional single- or double-quoted zsh strings:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.

#Set the documentation for the globally exported variable named by the variable
#declaration prefixing the passed string to such string. Documentation consists
#of a variable declaration in Zeshy-specific C-like syntax and a variable
#description in http://asciidoc.org[AsciiDoc].
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.

#Set the documentation for the function named by the function prototype prefixing
#the passed string to such string. Documentation consists of a function prototype
#in Zeshy-specific C-like syntax and a function description in
#http://asciidoc.org[AsciiDoc].
#Function documentation consists of a function prototype and description
#delimited by mandatory whitespace. A function prototype consists of one or more
#return types, one or more function names, and zero or more function arguments;
#a function description consists of arbitrary http://asciidoc.org[AsciiDoc] with
#additional support for conveniently cross-referencing other Zeshy documentation.

#Alias documentation consists of an alias prototype and description delimited by
#mandatory whitespace. An alias prototype consists of one or more return types,
#one alias name, and zero or more arguments; an alias description consists of
#arbitrary http://asciidoc.org[AsciiDoc] with additional support for conveniently
#cross-referencing other Zeshy documentation.

#== Alias Prototypes ==
#
#Alias prototypes follow a C-like syntax supporting zsh features not commonly
#found in conventional high-level languages: return and argument channels. Since
#zsh does _not_ currently support alias prototypes, we cannot coerce zsh to
#respect or enforce such prototypes at runtime. Zeshy can, however, convert such
#prototypes to syntax-highlighted, contextually-linked specifications in end-
#consumer documentation.

#Since zsh expands aliases inline, aliases cannot accept arbitrary arguments not
#accepted by the command such alias expands to.

#FUXME: Obscenely out-of-date. Significantly expand, noting that the alias
#documentation PEG is effectively the proper subset of the function
#documentation PEG excluding function name synonyms and replacing "(" and ")"
#with "<" and ">".
#While all function implementations remain free to
#dynamically redefine their signatures and hence deviate from such static
#documentation, developers should question the cognitive cost of such functions!

#FUXME: There is one other matter, of course: standard input. And
#come to think, this is also a concern for function documentation as well.
#How do we document whether a function accepts standard input and, when it does
#so, where it places such input in relation to other accepted arguments if any?
#*UGH*. Super annoying that I neglected to account for stdin. *sigh*
#FUXME: O.K.; I think I have a working syntax. The idea is simple: zsh
#extensions to C-like function prototype syntax are "["- and "]"-delimited.
#Since herestring-driven aliases unpack stdin into customary arguments, we have
#an stdin argument syntax resembling:
#
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#
#What's nice is that, as a function, it would simply be written as:
#
#[stdout: float] ukigumo(string dirname, integer mtime)
#
#Simple, concise, and consistent. Excellent. The above syntax naturally extends
#to support standard input being assigned to only one argument, like so:
#
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Ugh. So, that works, but doesn't really coincide with above. How about:
#
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Right. That works. It's obviously tempting to reduce every "[" and "]" to a
#"(" and ")" at this point, but that reduces the resulting prototype to a
#slightly less readable mish-a-mash ala LISP (*shudder*):
#
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#Hmm. Is that *REALLY* less readable? Frankly, it seems *MORE* readable. Right.
#O.K.; so, in this instance only, contemplate LISP-ish syntax. I can't believe
#I'm muttering that, but... well, it is much easier to remember and hence to
#write, and reads quite well as well. So, there you are!
#
#Right. There's just one final thing: input pipes. Quite a few functions only
#expect piped standard input, not just any ol' standard input. So, we'll need to
#also support something resembling:
#
#(stdout: float) ukigumo(piped stdin: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin-pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(piped: string dirname, integer mtime)
#
#The latter, I should think. "piped" implies "stdin" and more, so prefixing with
#or otherwise explicitly stating "stdin" is unnecessary. Well! That should do it,
#no? We'll need to slightly revise both the PEG and examples below, but better
#now that after we've begun using this syntax everywhere, eh? :}
#
#Ah, right: one final thing. The ":" implies mandatory and, in most cases, piped
#standard input is optional. How about a new "?" suffix for optional input, ala:
#
#(stdout: float) ukigumo(piped? string dirname, integer mtime)
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#BRILLIANT. Bravo, senior Cecil. Bravo.
#
#Note, however, that optional piped input is probably unhelpful and should
#arguably be eliminated from the Zeshy codebase. Hence, for now, just document
#the "stdin:"-style syntax.
#FUXME: O.K.; so, the above syntax isn't *QUITE* right. Since we're *NEVER*
#passing in standard input as an optional argument, any standard input passed is
#always as a second "channel" completely outside the scope of passed arguments.
#Also note that *_from()-style aliases *APPEAR* to the caller to accept a single
#string rather than standard input, suggesting an additional "string:" channel.
#Revert to "["-style syntax, for clarity. This suggests the following syntax:
#
#    # A function accepting a string *AND* standard input.
#    [stdout: void] set_string_to_stdin[
#       args: string string_name, stdin: string input]
#
#    # A function accepting one or more integers on standard input.
#    [stdout: string] get_stdin_integers[
#       args: void, stdin: (integer int1, ...)]
#
#    # Equivalent to the prior prototype.
#    [stdout: string] get_stdin_integers[stdin: (integer int1, ...)]
#
#    # A herestring-style alias.
#    [stdout: float] ukigumo[string: (string dirname, integer mtime)]
#
#So, the fundamental idea is that "args:" and "stdin:" both default to "void",
#as for return types. Either or neither may be specified, with predictable
#consequences in any case. Beautiful, no? (Well, certainly *LOGICAL*!)

#Tester functions returning only boolean exit status and no standard output or
#error may thus map return types `[status: boolean]` (e.g.,
#`[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).

#Being unprototyped, zsh function argument order and type is not
#statically predefined at function declaration time but may conditionally
#dynamically depend on local, global, and/or external state. For example,
#While perfectly documenting all possible function argument dynamics is both unfeasible and undesirable,
#conditionally depend and hence arguably more involved
#(though not necessarily beneficially) than those of conventional high-level languages.

#Documenting all possible function prototype dynamics is both unfeasible and
#undesirable. For sanity, function documentation assumes function signatures to
#be statically predefined at function declaration time as in normal high-level languages. Function implementations remain
#free to dynamically redefine and hence stray from such documentation as
#necessary, although this is generally discouraged.

#For brevity, functions may specify a single return type as in conventional
#high-level languages (e.g., `integer`).
# Zeshy documents such values in one of two ways:
#With a single type as in conventional high-level languages (e.g., `integer`),
#signifying such function to return a string of standard output convertible
#without error to such type, an empty string of standard error, and zero exit
#status (i.e., success). Since most functions only write to standard output and
#throw exceptions rather than return non-zero exit status on error, this
#shorthand notation simplifies most functions'' documentation.

#| Digit                 | <- | ``0'' | DigitNonZero
#| DigitNonZero          | <- | ``1'' | ``2'' | ``3'' | ``4'' | ``5'' | ``6'' |
#                               ``7'' | ``8'' | ``9''
#| Integer               | <- | ``-''? (``0'' | DigitNonZero Digit*)

#FUXME: I've performed an obscene amount of research on lightweight
#documentation formats and the winner *HANDS DOWN* is AsciiDoc. The syntax
#absolutely rocks, is near infinitely extendable with "pluginname:string"-style
#syntax and third-party plugins, exports beautiful HTML, LaTeX, PDF, man pages,
#DocBook, and so on. All Git documentation is written in AsciiDoc (which should
#absolutely tell you something: this is Linus' Git, after all). Markdown and
#Textile are rather outdated at this point. The only genuine competitor is the
#official Python documentation language, RestructuredText (reST). I'll admit:
#reST is powerful. Probably nearly as or even slightly more powerful than
#AsciiDoc. But in the end, that doesn't really matter... because the syntax is
#absolute shite. I mean, *LOOK AT THAT SYNTAX*. What the bloody hell were they
#thinking? They could have simply adopted the de facto e-mail-style markup
#syntax from which AsciiDoc (and Markdown and Textile and pretty much every
#other lightweight documentation language) is descended. But *NO*, they had to
#reinvent the friggin' wheel. And they failed. They thoroughly failed. Thank the
#Nordic Gods, then, for AsciiDoc.

#[stdout: float] ukigumo(stdin -> [string dirname, integer mtime])
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(string dirname, integer mtime) <- stdin
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#[stdout: float] ukigumo(stdin -> string dirname, integer mtime)

#FUXME: set_function_documentation() will need to detect whether passed standard
#input and, if so, ... Hmm. Actually, we should probably just do so in the high-
#level functions themselves (e.g., declare_function()). That necessitates
#pushing such documentation to the end of this file, but... *shrug*. That's
#fine, and arguably even preferred here (since it centralizes all documentation
#in one place). Arguably, we should then provide distinct high-level functions
#entitled declare_function_from_stdin() and so forth. The issue with
#trying to make a single "smart" declare_function() implicitly detecting open
#standard input is that such functions will be called from the top-level during
#Zeshy startup and hence cannot distinguish external from internal standard
#input. Subvert such confusion with distinct functions only accepting standard
#input.

#set_alias_documentation declare_global '
#void declare_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
#alias declare_global='
#{
#    # Localize the passed herestring.
#    local documentation__dg="$(< /dev/stdin)"
#...
#} <<<'

#Document the function named in the function prototype prefixing the passed
#documentation, which consists of a function prototype in C-like syntax
#followed by function description in AsciiDoc.
#
#whose syntax supports zsh features not commonly found in
#conventional high-level languages (e.g., function name synonyms, tristate return
#values). For completeness, we specify such syntax with a Parser Expression
#Grammar (PEG):
#
#Such types should correspond to the actual variable type (if
#any) the function implementation copies such argument into.
#
#values are *NEVER* evaluated by Zeshy and hence may contain executable code that
#could, whenever evaluated, have dangerous side-effects. 
#
#assigning each argument a
#mandatory name and type and optional default value.
#
#While argument names need
#not correspond to the variable name (if any) the function implementation copies
#such argument into, argument types and optional default value should, of course.
#
#(e.g., "function name synonym pseudonym nom_de_guerre nom_de_plume() { true }",
#a function callable as either name(), synonym(), pseudonym(), nom_de_guerre(),
#or nom_de_plume()).
#
#by listing all such names in whitespace-
#delimited fashion (e.g., .
#at least one name  also arbi:
#a
#Most function names as in conventional high-level languages (e.g., "integer"),
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#
#For functions with only one name, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#For functions with multiple names, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME_1 [or] FUNCTION_NAME_2 [or] ... FUNCTION_NAME_N(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME_1 FUNCTION_NAME_2 ... FUNCTION_NAME_N() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#Capitalized strings above denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  FUXME: Rewrite this section after implementing the above additions. It gets a
#  bit complicated, but... heck, it''ll definitely be worth it.
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.
#* "FUNCTION_NAME_2", the second name for such function. While most functions have
#
#  As in C-like languages, type "void" signifies such function to return no
#  standard output and/or error.
#
#Function prototypes follow the familiar "RETURN_TYPE FUNCTION_NAME 
#
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#While zsh does not support function prototypes, this function
#adopts conventional high-level language function prototype syntax for documentation-specific purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#named by the C-style function prototype of the passed
#documentation string. Since zsh permits no function prototyping, this function
#adopts conventional high-level language function prototype syntax for documentation purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#syntax does *NOT* constitute 
#While such syntax does *NOT* constitute an enforcable
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#, which must thus be prefixed  with such documentation. 
#
#This function is deleted by Zeshy immediately before compiling its user digest
#file and hence only callable from the global context of Zeshy components.

#FUXME: It'd be great to support a distinction between standard output and
#error return values in function prototypes. How about something resembling:
#
#    # Function returning a string of standard output and no standard error.
#    [string, void] do_something(void)
#
#    # Or perhaps the more verbose:
#    [stdout: string, stderr: void] do_something(void)
#
#    # Actually, we could support both (obviously), which we should do. Ah;
#    # actually, we should probably just add such "stdout:" and "stderr:"
#    # labels on printing human-readable documentation to users, yes? Ah;
#    # perhaps not. It'd certainly be more intelligible to developers browsing
#    # the code to see "[stdout: string, stderr: void]" versus the former.
#    # The more verbose version also lends itself well to specifying exit
#    # status, as below.
#
#Since most functions return no standard error, retain support for shorthand:
#
#    # Same as above, shorthand.
#    string do_something(void)
#
#While most functions return 0 exit status, some do not. How about this:
#
#    # Function returning a string of standard output and no standard error
#    # and non-zero exit status on failure.
#    [string, void, boolean] do_something(void)
#
#    # Or, again:
#    [stdout: string, stderr: void, status: boolean] do_something(void)
#
#Status may either be "void" (i.e., always returns 0), "boolean" (i.e.,
#either returns 0 or 1), or "integer" (i.e., returns a variety of statuses.
#
#Ah! Another way in which the labels are demonstrably superior: in may cases,
#we'll want to specify "stdout" and "status" but not "stderr". So, that's just:
#
#    [stdout: string, status: boolean] do_something(void)
#
#Naturally, order no longer matters. Sweet! I'm thinking we *ABSOLUTELY*
#shouldn't support the abbreviated "[stdout, void, boolean]" style, yes? Far too
#much ambiguity and head-scratching.
#FUXME: The specification below has become sufficiently complex to warrant a BNF.
#I know, I know. But we'll make it simple and concise, with adequate commenting.
#There's really no better way.

# ....................{ GLOBALS                            }....................
#FUXME: This is terrible. Eliminate such global entirely; instead, simply
#attempt to run a dynamically constructed command
#${variable_type}_global_export().

#set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#map ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#
#Map variable type to the declarator (i.e., command prefix) declaring and
#exporting globals of such type.
#'
#typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#    # String types.
#    string    'export'
#    boolean   'export'
#    character 'export'

    # Integer types.
#    integer         'export -i'
#    file_descriptor 'export -i'
#
    # Float types.
#    float 'export -F'
#
#    # List types.
#    list     'export -a'
#    list_set 'export -Ua'
#
#    # While "export -a" succeeds (as above), "export -A" fails with error.
#    # Hence, revert to builtin typeset().
#    map 'typeset -Agx'
#)

        # If such global''s type is not a Zeshy-specific type, throw an
        # exception. See is_map_key() for implementation details.
#       (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#           die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
#       ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

# ....................{ MAIN                               }....................
#FUXME: Not quite right. We also want to undefine all of the above aliases and
#functions before Zeshy digest compilation, suggesting we create a new
#precompilation hook performing all such undefinitions. I can't imagine that
#order matters, there; so, just add a customary precompilation hook here.

#run_hook_on_zeshy_precompile precompile_zeshy_documentation_undefine

#declare_function '
#void precompile_zeshy_documentation_undefine(void)
#
#Undefine all documentation-defining runnables (e.g., set_alias_documentation(),
#declare_global()) *AFTER* sourcing all Zeshy components calling such runnables
#and hence having defined all available documentation. To  Zeshy caches 
#The documentation such runnables
#'
#function precompile_zeshy_documentation_undefine() {
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
#}

#FUXME: Rename "[or]" to "[or]" everywhere. Avoid simply "or", as that isn't
#subject to global replacement.
# For simplicity, this function ignores 
# such low-level distinctions, accepts
# (e.g., "boolean", "list", "string"). If 
#
#While most functions have only one name, zsh does permit additional names to be
#declared in function declarations with the above whitespace-delimited syntax.
#
#Capitalized strings denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific type of variable returned by such function
#  (e.g., "boolean", "list", "string").
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.

# *BEFORE* compiling Zeshy''s user digest file
# (i.e., at the top level of Zeshy components and in precompilation hooks).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Define declare_function() before declare_alias(), which documents itself
# with the former function.
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias declare_alias=':' declare_function=':' declare_global=':'

# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)
