#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle *float* (i.e., fractional number) variable declarers.
______________<heredoc?>______________

# ....................{ FLOATS                             }....................
# zsh already provides builtin float() for declaring local floats.

declare_alias_with_stdin <<'-\-'
void float_global(string variable_name1, string variable_name2, ...)

Declare the passed floats globally, but _not_ exported to the calling shell.
-\-
alias float_global='float -g --'

declare_alias_with_stdin <<'-\-'
void float_global_export(string variable_name1, string variable_name2, ...)

Declare the passed floats globally exported to the calling shell.
-\-
alias float_global_export='export -F --'

declare_alias_with_stdin <<'-\-'
void float_constant_global_export(
    string variable_name1, string variable_name2, ...)

Declare the passed float constants globally exported to the calling shell.
-\-
alias float_constant_global_export='export -Fr --'

# ....................{ FLOATS ~ fixed                     }....................
declare_alias_with_stdin <<'-\-'
void float_with_fractional_digits(
    integer length = 10,
    string variable_name1, string variable_name2, ...)

Declare the passed floats locally. On parameter (but _not_ arithmetic)
expansion, such floats will be implicitly truncated to the passed number of
fractional digits (defaulting to 10). Since this does _not_ apply to arithmetic
expansion, such floats internally retain all data for calculation purposes:
e.g.,

.float_with_fractional_digits()
==========================================
[source]
------------------------------------------
>>> float_with_fractional_digits 3 prouhet_thue_morse=0.412154033640
>>> print_string "${prouhet_thue_morse}" $(( prouhet_thue_morse ** 2 ))
0.412 0.16987094744572223
------------------------------------------
==========================================
-\-
alias float_with_fractional_digits='local -F'  # "float" does *NOT* suffice

# ....................{ FLOATS ~ scientific                }....................
declare_alias_with_stdin <<'-\-'
void float_with_significant_figures(
    integer length = 10,
    string variable_name1, string variable_name2, ...)

Declare the passed floats locally. On parameter (but _not_ arithmetic)
expansion, such floats will be implicitly converted to *scientific notation*
with the significand truncated to the passed number of significant figures.

Let `${f}` be such a float. If:

* `(( f == 0 ))`, such notation formats `${f}` as `0.0000000000e+00` (assuming
  10 significant figures).
* `(( f > 0 ))`, such notation formats `${f}` as `${a}e+${b}`, where `${a}` is
  the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
  exponent such that `(( f == A * 10 ** b ))`.
* `(( f < 0 ))`, such notation formats `${f}` as `${a}e-${b}`, where `${a}` is
  the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
  exponent such that `(( f == A * 10 ** -b ))`.

Since this does _not_ apply to arithmetic expansion, such floats internally
retain all data for subsequent calculation: e.g.,

.float_with_significant_figures()
==========================================
[source]
------------------------------------------
>>> float_with_significant_figures 3 gelfonds_constant=22.140692632779269
>>> print_string "${gelfonds_constant}" $(( sqrt(gelfonds_constant) ))
2.214e+01 4.7053897426249405
------------------------------------------
==========================================
-\-
alias float_with_significant_figures='local -E'  # "float" does *NOT* suffice

# --------------------( WASTELANDS                         )--------------------
