#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'______________<heredoc?>______________'
Handle *integer* (i.e., non-fractional number) variable declarators.
______________<heredoc?>______________

# ....................{ INTEGERS                           }....................
# zsh already provides builtin integer() for declaring local integers.

declare_alias_with_stdin\
    'void integer_global(string variable_name1, string variable_name2, ...)'\
    'integer -g --' <<'/---'
Declare the passed integers globally, but _not_ exported to the calling shell.
/---

declare_alias_with_stdin\
    'void integer_global_export(
        string variable_name1, string variable_name2, ...)'\
    'export -i --' <<'/---'
Declare the passed integers globally exported to the calling shell.
/---

# ....................{ INTEGERS ~ constant                }....................
declare_alias_with_stdin\
    'void integer_constant_global_export(
        string variable_name1, string variable_name2, ...)'\
    'export -ir --' <<'/---'
Declare the passed integer constants globally exported to the calling shell.
/---

# ....................{ INTEGERS ~ base                    }....................
# Note that "integer" does *NOT* suffice here.
declare_alias_with_stdin\
    'void integer_in_base(
        integer base,
        string variable_name1, string variable_name2, ...)'\
    'local -i'  <<'/---'
Declare the passed integers locally in the passed base. On expansion, such
integers will be implicitly converted to the equivalent values in such base.
Additionally, if such base is:

* `8`, such integers will be pretty printed in *octal format* and hence:
** Prefixed with a C-style `0`.
* `16`, such integers will be pretty printed in *hexadecimal format* and hence:
** Prefixed with a C-style `0x`.
** Digits in the range [10, 15] will be printed as capitalized letters in the
   range [A, F], per tradition.

For example: e.g.,

.integer_in_base()
==========================================
[source]
------------------------------------------
>>> integer_in_base 16 factory_farming=4277009102
>>> print_string    "${factory_farming}"
0xFEEDFACE
------------------------------------------
==========================================
/---

# ....................{ INTEGERS ~ file descriptor         }....................
declare_alias_with_stdin\
    'void file_descriptor(string variable_name1, string variable_name2, ...)'\
    'integer' <<'/---'
Declare the passed file descriptors locally.
/---

declare_alias_with_stdin\
    'void file_descriptor_global(
        string variable_name1, string variable_name2, ...)'\
    'integer_global' <<'/---'
Declare the passed file descriptors globally, but _not_ exported to the calling
shell.
/---

declare_alias_with_stdin\
    'void file_descriptor_global_export(
        string variable_name1, string variable_name2, ...)'\
    'integer_global_export' <<'/---'
Declare the passed file descriptors globally exported to the calling shell.
/---

# ....................{ DECLARATORS ~ boolean              }....................
declare_alias_with_stdin\
    'void boolean(string variable_name1, string variable_name2, ...)'\
    'integer' <<'/---'
Declare the passed booleans locally. By `zsh` constraint, booleans are currently
indistinguishable from strings, such that the empty string signifies a false
value and any nonempty string a true value. However, explicitly declaring
booleans as such improves clarity, (possible) forwards compatibility, and
symmetry with existing builtins integer() and float().

== Implementation ==

While `zsh` currently lacks builtin support for boolean types, such types are
readily implementable with either:

* Integer types. Mapping boolean false to integer 0 and boolean true to
  integer 1 yields both an efficient representation and means of testing
  boolean truth: e.g.,
+
.Integer-based Booleans
==========================================
[source]
------------------------------------------
>>> integer is_television_truth
>>> (( is_television_truth )) or get_string_line\
...    "Television is not the truth. Television's a god-damned amusement park.
...     Television is a circus, a carnival, a traveling troupe of acrobats,
...     storytellers, dancers, singers, jugglers, sideshow freaks, lion tamers,
...     and football players. We're in the boredom-killing business. So if you
...     want the Truth, go to God! Go to your gurus. Go to yourselves! Because
...     that's the only place you're ever gonna find any real truth. But, man,
...     you're never gonna get any truth from us. We'll tell you anything you
...     wanna hear. We lie like hell. We'll tell you that Kojak always gets the
...     killer and that nobody ever gets cancer at Archie Bunker's house. And no
...     matter how much trouble the hero is in, don't worry. Just look at your
...     watch. At the end of the hour, he's gonna win. We'll tell you any shit
...     you want to hear." 1
------------------------------------------
==========================================
* String types. Mapping boolean false to the empty string and boolean true to
  any nonempty string yields a slightly less efficient representation and means
  of testing boolean truth: e.g.,
+
.String-based Booleans
==========================================
[source]
------------------------------------------
>>> string is_television_reality
>>> is -n "${is_television_reality}" or get_string_line\
...    "We deal in illusions, man. None of it is true! But you people sit there
...     day after day, night after night, all ages, colors, creeds. We're all
...     you know. You're beginning to believe the illusions we're spinning here.
...     You're beginning to think that the tube is reality and that your own
...     lives are unreal. You do whatever the tube tells you. You dress like the
...     tube, you eat like the tube, you raise your children like the tube. You
...     even think like the tube. This is mass madness. You maniacs. In God's
...     name, you people are the real thing. We are the illusion. So turn off
...     your television sets. Turn them off now. Turn them off right now. Turn
...     them off and leave them off. Turn them off right in the middle of this
...     sentence I am speaking to you now. Turn them off!" 1
We deal in illusions, man. None of it is true! But you people sit there
------------------------------------------
==========================================

Since testing for integer zeroness is more efficient than testing for string
emptiness _and_ since integers are already constrained to integral values
containing customary boolean values 0 and 1,  `zeshy` adopts integers rather
than strings for its boolean implementation.
/---

declare_alias_with_stdin\
    'void boolean_global(string variable_name1, string variable_name2, ...)'\
    'integer_global'  <<'/---'
Declare the passed booleans globally, but _not_ exported to the calling shell.
See boolean() for further details.
/---

declare_alias_with_stdin\
    'void boolean_global_export(
        string variable_name1, string variable_name2, ...)'\
    'integer_global_export' <<'/---'
Declare the passed booleans globally exported to the calling shell. See
boolean() for further details.
/---

declare_alias_with_stdin\
    'void boolean_constant_global_export(
        string variable_name1, string variable_name2, ...)'\
    'integer_constant_global_export' <<'/---'
Declare the passed boolean constants globally exported to the calling shell. See
boolean() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Theoretically, integers should provide a much more efficient type for
#housing booleans than strings. After all, there's no need for string handling,
#which, to support arbitrarily long strings containing null characters, do not
#cleanly map to C strings and hence require more under-the-scenes handling than
#simple integers (which probably map fairly reasonably to underlying C types).
#In short, testing "(( boolean_variable ))" for the truth of a boolean should be
#significantly faster (aggregated over all such tests) than testing
#"[[ -n ${boolean_variable} ))".
#FUXME: Integers actually make a *VASTLY* preferable core type for implementing
#booleans than strings. Testing integer zeroness or non-zeroness is more
#efficient *AND* readable than the equivalent string emptiness or nonemptiness
#tests. Moreover, it just makes intuitive sense to represent booleans as
#integers constrained to 0 and 1. To effect this change, we'll need to:
#
#* Revise "00-startup/02-constants/boolean".
#* Revise "variable/boolean".
#
#That *SHOULD* be it. But I'm sure everything will break anyway. *sigh*

#boolean duality translates better onto integers
#than strings,
#* `10`, such integers will be converted to *decimal format*, the default format.
#(i.e., non-fractional number) 
