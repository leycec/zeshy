#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_to_script_with_stdin <<'-\-'
Handle global declarers.
-\-

# ....................{ GLOBALS                            }....................
# Global map from global names to the help strings documenting such globals. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_GLOBAL_NAME_TO_HELP

# Glob matching zsh variable names. Dismantled, this is:
#
# * "[a-zA-Z_]", matching the first character of a valid zsh variable name.
# * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
ZESHY_VARIABLE_NAME_GLOB='[a-zA-Z_][a-zA-Z0-9_]#'

# ....................{ DECLARERS                          }....................
#FIXME: Documentation significantly desynchronized. For example, defining list
#and map globals is now exceedingly simple. Any delimiters (not merely "\(" and
#"\)") may be used, as zeshy simply ignores the first and last shell words of
#such globals' initial value. Sweet!
#FIXME: The documentation introduction is also completely wrong, both here and
#below. *sigh*
declare_function_with_stdin <<'-\-'
void declare_global(
    string global_type = "",
    string global_name = "",
    string global_value1 = "", string global_value2, ...,
    string documentation)

Set the documentation for the global exported variable named by the variable
declaration prefixing the passed string to such string and, if such variable has
not already been declared, declare such variable to be global, exported, and of
the documented type. Variable documentation consists of:

. A *variable declaration* in Zeshy-specific C-like syntax, consisting of one
  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`).
. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
  with Zeshy-specific markup for cross-referencing other Zeshy documentation.

== Variable Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):

.Variable Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
| GlobalName            | <- | AlphanumericString
|===============================================================================

== Variable Type ==

A variable's type may be any alphanumeric string for which an alias of the same
name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
variable type but `order_of_the_blackened_denarius` is not, since
file_descriptor_global_export() is an existing alias but
order_of_the_blackened_denarius_global_export() is (hopefully) not.

`zeshy` provides numerous such aliases and hence variable types, including:
boolean(), character(), file_descriptor(), float(), integer(), list(),
list_set(), map(), and string().
-\-
function declare_global() {
    # Validate passed arguments.
    (( # )) || die\
        'expected one help string, optional type, optional global name, and optional values'
    local help__dg="${@[-1]}" type__dg name__dg value__dg declarator__dg

    # Remove such help string from the argument list. See pop_arg() for further
    # details.
    argv[-1]=()

    # If passed a help string and global type and name, localize such arguments.
    # As this is the common case, handle this condition before those below.
    if (( # >= 2 )) {
        type__dg="${1}"
        name__dg="${2}"

        # Remove such type and name from the argument list. All remaining
        # arguments comprise such global's initial value, if any.
        shift 2
    # If passed only a help string and global name, default such type to string.
    } elif (( # == 1 )) {
        # Avoid shifting such argument, as no subsequent value was passed.
        type__dg="string"
        name__dg="${1}"
    # Else, only a help string was passed. Dynamically parse such type and name
    # from the variable declaration prefixing such string.
    } else {
        #FIXME: This could probably be generalized to support "="-delimited
        #assignment, but I have doubts as to whether that'd be widely useful.
        # Match the variable type and name from such declaration or throw an
        # exception if the help string contains no declaration. Dismantled, this
        # is:
        #
        # * "(#b)", capturing match groups into list global ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
        # * "[[:space:]]##", matching mandatory whitespace.
        # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
        [[ "${help__dg}" ==\
            (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
            die_for_declarator_type_with_help 'global' "${help__dg}"

        # Localize such type and name.
        type__dg="${match[1]}"
        name__dg="${match[2]}"
    }

    # If such type is empty, throw an exception.
    (( -n "${type__dg}" )) || die 'expected nonempty global type'

    # If such name contains a "=", split such name on the first "=" into the
    # genuine name and initial value (respectively). Since zsh prohibits
    # variable names from containing "=", such logic is inherently safe.
    if (( "${name__dg}" == (#b)([[:IDENT:]]##)'='(*) )) {
        name__dg="${match[1]}"
        value__dg="${match[2]}"
    }

    # If such name is syntactically invalid, throw an exception.
    [[ "${name__dg}" == ${~ZESHY_VARIABLE_NAME_GLOB} ]] ||
        die "global name \"${name__dg}\" syntactically invalid"

    # Alias declaring globals of such type.
    declarator__dg="${type__dg}_export"

    # If such alias does not exist, throw an exception. Since such alias
    # could technically also be a function, match both. See is_runnable()
    # for further details.
#   print "global type: ${type__dg}; global name: ${name__dg}; declarator: ${declarator__dg}"
    whence -- "${declarator__dg}" &>/dev/null ||
        die "global \"${name__dg}\" type \"${type__dg}\" unrecognized (${declarator__dg}() undefined)"

    # Declare such global. Since the declarator is typically an alias rather
    # than function or pathable, zsh requires evaluating rather than running
    # such declarator. While acceptable, this is somewhat... annoying.
    #
    # Before doing so, we should ideally test whether such global already exists
    # and if so either throw an exception or print a warning. Unfortunately,
    # there exists no efficient means of implementing such test. While there do
    # exist efficient means of testing whether a variable either local or global
    # exists and whether such variable in the *CURRENT* scope is local or global,
    # the only means of testing whether a global exists is to parse the output of
    # "typeset -gx +" for a line matching such global's name. While such parsing
    # could conceivably be efficient for infrequent purposes, declaring globals
    # is not an infrequent purpose.
    #
    # If passed an initial value, declare such global set to such value.
    if (( -n "${value__dg}" )) {
        # If passed at least two initial values, such global must be nonscalar
        # (e.g., list, map). Sadly, defining the initial value for a nonscalar is
        # somewhat more subtle than defining the initial value for a scalar.
        if (( # )) {
            # If such type is actually scalar, throw an exception.
            [[ "${type__dg}" == (list|map|list_*|map_*) ]] ||
                die "scalar global \"${name__dg}\" initialized to nonscalar value: ${value__dg} ${*}"

            # Ignore the first (i.e., ${value__dg}) and last (i.e., ${argv[-1]})
            # elements of such value. Such elements signify ignorable zeshy-
            # specific delimiters (e.g., "\(", "\)", "[", "]"). See pop_arg()
            # for further details.
            ${argv[-1]}=()

            # Quote-protect each remaining element of such value, manually re-
            # delimiting such value with zsh-specific delimiters "(" and ")".
            eval "${declarator__dg} ${name__dg}; ${name__dg}=(" "${(q)@}" ')'
        # Else, such global is scalar. For safety, quote-protect such value.
        } else {
            eval ${declarator__dg} ${name__dg}=${(q)value__dg}
        }
    # Else, declare such global with no such value (i.e., set to the default
    # value for its type).
    } else {
        eval ${declarator__dg} ${name__dg}
    }

    # Add such global to the current parcel.
    add_parcel_global "${name__dg}"

    # Map such global to such help string.
    ZESHY_GLOBAL_NAME_TO_HELP[${name__dg}]="${help__dg}"
}

#FIXME: Correct documentation.
declare_function_with_stdin <<'-\-'
void declare_global_with_stdin[
    args: (string global_type = "",
           string global_name = "",
           string global_value1 = "", string global_value2, ...),
    stdin: string documentation]

Set the documentation for the global exported variable named by the variable
declaration prefixing standard input to such input. Consider calling this rather
than declare_global(), which requires passing a string argument rather than
standard input. See declare_function_with_stdin() for further details.
-\-
function declare_global_with_stdin() {
    run_runnable_with_stdin declare_global "${@}"
}

# ....................{ GLOBALS                            }....................
declare_global_with_stdin <<'-\-'
string ZESHY_VARIABLE_NAME_GLOB

Glob matching syntactically valid `zsh` variable names.
-\-

() {
    # Parent directory of the current script.
    local script_dirname; script_dirname="$(dirname -- "${ZESHY_SCRIPT_NAME}")/"

    # ................{ GLOBALS ~ parcel                   }....................
    # Document globals previously defined by @{parcel} under such parcel.
    set_parcel_to_script "${script_dirname}"*'-parcel'

    declare_global_with_stdin <<'-\-'
string ZESHY_PARCEL_NAME

Current parcel name, identifying the most recently declared parcel (e.g., by a
call to declare_parcel_to_script() or declare_parcel_to_script_with_stdin()).
See such functions for further details.
-\-

    declare_global_with_stdin <<'-\-'
map ZESHY_PARCEL_NAME_TO_ALIAS_NAMES

Map each parcel name to an internally null-delimited string of the names of all
aliases contained in such parcel. Since such names can technically contain null
characters (although rare in practice), all actual nulls in such names are
escaped (i.e., prefixed with `\`) and must be ignored as delimiters.

Ideally, this would be structured as a *map of lists* (i.e., mapping each parcel
name to the list of the names of all aliases contained in such parcel). Since
`zsh` currently fails to support nested structures (along with all other popular
shells, to be fair), the desired map value instead joins each such list on the
null character into a string. The original list is losslessly retrievable from
such string value by:

* Splitting such string on nulls, ignoring *escaped nulls* (i.e., `\`-prefixed
  null characters).
* Removing the `\` character prefixing each escaped null in the resulting list.
-\-

    declare_global_with_stdin <<'-\-'
map ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES

Map each parcel name to an internally null-delimited string of the names of all
functions contained in such parcel. See ${ZESHY_PARCEL_NAME_TO_ALIAS_NAMES} for
further details.
-\-

    declare_global_with_stdin <<'-\-'
map ZESHY_PARCEL_NAME_TO_GLOBAL_NAMES

Map each parcel name to an internally null-delimited string of the names of all
globals contained in such parcel. See ${ZESHY_PARCEL_NAME_TO_ALIAS_NAMES} for
further details.
-\-

    # ................{ GLOBALS ~ function                 }....................
    # Document globals previously defined by @{function} under such parcel.
    set_parcel_to_script "${script_dirname}/"*'-function'

    declare_global_with_stdin <<'-\-'
map ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME

Map *synonymized function names* (i.e., function names for functions with
multiple names) to the first function names declared for such functions. Since
all first function names thus map to themselves, this map contains the identity
map. To conserve memory, this map does _not_ map *non-synonymized function
names* (i.e., function names for functions with only one name): e.g.,

.ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME()
==========================================
[source]
------------------------------------------
>>> string on_duty=\
...    "It is the fundamental duty of the citizen to resist and to restrain the
...     violence of the state. Those who choose to disregard this responsibility
...     can justly be accused of complicity in war crimes, which is itself
...     designated as 'a crime under international law' in the principles of the
...     Charter of Nuremberg."
>>> function war_crimes tribunal on_vietnam() { print_string "${on_duty}" }
>>> print_string\
...    "war_crimes: ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[war_crimes]}
...     tribunal:   ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[tribunal]}
...     on_vietnam: ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[on_vietnam]}"
war_crimes: war_crimes
tribunal:   war_crimes
on_vietnam: war_crimes
------------------------------------------
==========================================
-\-
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Woops. O.K.; we basically have to transition *EVERY* global declaration
#from the current form:
#
#  declare_global_with_stdin <<'-\-'
#  string ZESHY_PARCEL_NAME
#
#  Current parcel name.
#  -\-
#
#...to:
#
#  declare_global_with_stdin <<'-\-'
#  Current parcel name.
#  -\- \
#  string ZESHY_PARCEL_NAME
#
#Yes, this actually works (so long as whitespace exists between the global type
#and the prior help string -- hence the space preceding the "\"). It's also
#*DRAMATICALLY* better for the following reasons:
#
#* It actually permits constant globals to be declared. Yes, we'll need a new
#  declare_global_constant_with_stdin(), but that's Aeon's play. Such function
#  must require such global name contain a "=" followed by a value: e.g.,
#
#  declare_global_with_stdin <<'-\-'
#  Current parcel name constant.
#  -\-\
#      string_constant ZESHY_PARCEL_NAME_CONSTANT='/proc/self/root/striker'
#* Which brings us to the *REAL* reason (though even the above is compelling):
#  permitting lists and maps to be declared without extreme repetition. With the
#  current approach, declaring lists and maps requires repeating such objects'
#  names at least *THREE* times, which is obscene. The above approach eliminates
#  all such repetition.
#
#Naturally, to support this, declare_global() must be revised to accept at least
#three mandatory arguments: the global type, name, and help string (in that order,
#for orthogonality). Wait, scratch that: the help string, global type, and name.
#If such name contains a "=", such global must be defined in an "eval" statement,
#appending all additional arguments; else, throw an exception if any additional
#arguments were passed. And that's it, you know? Instantaneous awesomeness. We
#shouldn't really require any bizarre parsing; just split the global name on the
#first "=" in such name: everything to the left is the "true" name and everything
#to the right the first shell word of such global's initial value to be "eval"-ed.
#FUXME: See parcel "interactive_alias" for efficient splitting logic.
#FUXME: O.K.; so, to avoid "zsh: unknown file attribute" errors on defining maps
#and lists, we'll need to define an alias as follows:
#
#    alias declare_global_constant_with_stdin="noglob declare_global_constant_with_stdin"
#
#Oh, bloody hell. That only *SUPERFICIALLY* works. For some reason, zsh still
#aggregates everything between bare "(" and ")" characters into a single function
#argument. This can be hacked around in one of two equally ugly ways:
#
#* Just allow the caller to omit the "(" and ")" characters. Since the type is
#  also passed, we *KNOW* whether it's a list or map and hence that we need to
#  add such characters back into the "eval" we perform.
#* Force the caller to pass explicitly escaped "(" and ")" characters. There are
#  three ways of doing that: single- or double-quoting each such character or
#  preceding each such character with "\". The latter's probably the least ugly.
#
#Actually, there's another way still -- and it's reasonably slick. Just require
#"[" and "]" in place of "(" and ")", then internally convert such characters to
#"(" and ")".
#
#Again, all of these work. We probably shouldn't allow the characters to be
#omitted -- that just looks crass. I'd like to support *BOTH* of the remaining
#methods (i.e., escaped "(" and "[" instead of "("). Great! Go-go-go.
#FUXME: Oh, hell. "[" and "]" are cool, but just a *TAD* excessive. No need to
#make this full-on python, right? Just settle for escaped parens, for now.
#FUXME: Don't bother with the noglob alias above. Callers still rightly expect
#filename globbing to be in effect. (After all, defining lists often *REQUIRES*
#such globbing.)
#FUXME: Naturally, zsh strips the quoting around passed arguments. If required,
#add such quoting back for "eval" purposes with '"'${^@}'"'.
#FUXME: Sweet! If the passed type is scalar, we do *NOT* need to "eval" such
#declaration. Yes, this actually works:
#
#   >>> string   defi="zimo=ok"
#   >>> string ${defi}
#   >>> print ${zimo}
#ok
#FUXME: Oh, wait. No, we still need the "eval", as the type is also dynamic.

    #FUXME: *sigh* This function *APPENDS* stdin, not *PREPENDS* stdin, as
    #expected by the function above. But due to the variadic definition of the
    #function above, we'd rather not change such function's signature. Yes? No?
    #FUXME: Throw an exception if such name is syntactically invalid. We'll
    #probably want to shift a bit of "zsh/variable" functionality here to do so.
    #Perhaps just the requisite PCRE, yes?

#FUXME: Rename to declare_global_with_stdin_help(). Consider also renaming alias
#and function declarers.
#           eval "${declarator__dg} ${name__dg}; ${name__dg}=(" "'"${^@}"'" ')'
    # Such global's help string, type, and name.
    # Validate passed arguments.
#   (( # == 1 || # == 3 )) ||
#       die 'expected either one help string or one help string, one type name, and one global name'

#declare_function_with_stdin <<'-\-'
#void declare_global(string documentation)
#
#Set the documentation for the global exported variable named by the variable
#declaration prefixing the passed string to such string and, if such variable has
#not already been declared, declare such variable to be global, exported, and of
#the documented type. Variable documentation consists of:
#
#. A *variable declaration* in Zeshy-specific C-like syntax, consisting of one
#  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`).
#. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
#  with Zeshy-specific markup for cross-referencing other Zeshy documentation.
#
#== Variable Documentation Grammar ==
#
#For completeness, we specify such syntax as a
#http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
#See the <<declare_function.peg,function documentation PEG>> from which this PEG
#derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):
#
#.Variable Documentation Grammar
#[cols=">strong,^,<"]
#|===============================================================================
#| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
#| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
#| GlobalName            | <- | AlphanumericString
#|===============================================================================
#
#== Variable Type ==
#
#A variable's type may be any alphanumeric string for which an alias of the same
#name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
#variable type but `order_of_the_blackened_denarius` is not, since
#file_descriptor_global_export() is an existing alias but
#order_of_the_blackened_denarius_global_export() is (hopefully) not.
#
#Zeshy provides numerous such aliases and hence variable types, including:
#`boolean`, `character`, `file_descriptor`, `float`, `integer`, `list`,
#`list_set`, `map`, and `string`.
#-\-
#function declare_global() {
#    # Validate passed arguments.
#    (( # == 1 )) || die 'expected one help string'
#    local help__dg="${1}"
#
#    # If such documentation is prefixed by a variable declaration, match the
#    # variable name and type from such declaration. Dismantled, this is:
#    #
#    # * "(#b)", capturing match groups into global list ${match}.
#    # * "[[:space:]]#", matching optional whitespace.
#    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
#    # * "[[:space:]]##", matching mandatory whitespace.
#    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
#    #
#    # Else throw an exception with a portion of such documentation.
#    [[ "${help__dg}" ==\
#        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
#        die_for_declarator_type_with_help 'global' "${help}"
#
#    # Before attempting to declare such global, we should test whether such a
#    # global already exists and if so either throw an exception or print a
#    # warning. There exists no efficient means of performing such test, however.
#    # While there do exist efficient means of testing whether a variable either
#    # local or global exists and whether such variable in the current scope is
#    # local or global, the only means of testing whether a global exists is to
#    # parse the output of "typeset -gx +" for a line matching such global's
#    # name. While such parsing could conceivably be efficient for infrequent
#    # purposes, this function does not follow an infrequent purpose.
#
#    # Such global's declared type and name.
#    local global_type__dg="${match[1]}" global_name__dg="${match[2]}"
#
#    # Alias declaring globals of such type.
#    local declarator__dg="${global_type__dg}_global_export"
#
#    # If such alias does not exist, throw an exception. Since such alias
#    # could technically also be a function, match both. See is_runnable()
#    # for further details.
##       print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
#    whence -- "${declarator__dg}" &>/dev/null ||
#        die "type \"${global_type__dg}\" unrecognized (${declarator__dg}() undefined)"
#
#    # Declare such global. Since the declarator is typically an alias rather
#    # than function or pathable, zsh requires evaluating rather than running
#    # such declarator. While acceptable, this is somewhat... annoying.
#    eval "${declarator__dg} \"\${global_name__dg}\""
#
#    # Add such global to the current parcel.
#    add_parcel_global "${ZESHY_PARCEL_NAME}" "${global_name__dg}"
#
#    # Map such global to such help string.
#    ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"
#}

#FUXME: It'd be *GREAT* to revise the basic "list" and "map" aliases 
# See @{parcel} for such global's declaration.
# See @{function} for such global's declaration.
#FUXME: The global below efficiently obsoletes *ALL* other bizarre schemes we'd
#considered for recording synonyms (particularly, the use of symbolic links
#within the KVS directory for function documentation). Whenever the caller
#requests documentation for some function ${function_name}, perform the
#following mapping:
#
#  function_name="${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[${function_name}]-${function_name}}"
# Prefix this parcel name with an integer to ensure zeshy sources this parcel
# before parcels depending on this parcel (e.g., "parcel" itself).

#       {
        # Global prototype prefixing such help string.
#       string help_prototype

        # If such string contains a newline (i.e., "\n"), crudely match the
        # substring preceding such newline as the global prototype.
#       if [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
        # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       die 'global help string invalid (see "print_help declare_global" for details):
#'"${help_prototype}"
#   }
