#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_to_script_with_stdin <<'______________<heredoc?>______________'
Handle global declarers.
______________<heredoc?>______________

#FIXME: Woops. O.K.; we basically have to transition *EVERY* global declaration
#from the current form:
#
#  declare_global_with_stdin <<'________________<heredoc?>________________'
#  string ZESHY_PARCEL_NAME
#
#  Current parcel name.
#  ________________<heredoc?>________________
#
#...to:
#
#  declare_global_with_stdin <<'________________<heredoc?>________________'
#  Current parcel name.
#  ________________<heredoc?>________________ \
#  string ZESHY_PARCEL_NAME
#
#Yes, this actually works (so long as whitespace exists between the global type
#and the prior help string -- hence the space preceding the "\"). It's also
#*DRAMATICALLY* better for the following reasons:
#
#* It actually permits constant globals to be declared. Yes, we'll need a new
#  declare_global_constant_with_stdin(), but that's Aeon's play. Such function
#  must require such global name contain a "=" followed by a value: e.g.,
#
#  declare_global_constant_with_stdin <<'________________<heredoc?>________________'
#  Current parcel name constant.
#  ________________<heredoc?>________________\
#      string ZESHY_PARCEL_NAME_CONSTANT='/proc/self/root/striker'
#* Which brings us to the *REAL* reason (though even the above is compelling):
#  permitting lists and maps to be declared without extreme repetition. With the
#  current approach, declaring lists and maps requires repeating such objects'
#  names at least *THREE* times, which is obscene. The above approach eliminates
#  all such repetition.
#
#Naturally, to support this, declare_global() must be revised to accept at least
#three mandatory arguments: the global type, name, and help string (in that order,
#for orthogonality). Wait, scratch that: the help string, global type, and name.
#If such name contains a "=", such global must be defined in an "eval" statement,
#appending all additional arguments; else, throw an exception if any additional
#arguments were passed. And that's it, you know? Instantaneous awesomeness. We
#shouldn't really require any bizarre parsing; just split the global name on the
#first "=" in such name: everything to the left is the "true" name and everything
#to the right the first shell word of such global's initial value to be "eval"-ed.
#FIXME: See parcel "interactive_alias" for efficient splitting logic.
#FIXME: O.K.; so, to avoid "zsh: unknown file attribute" errors on defining maps
#and lists, we'll need to define an alias as follows:
#
#    alias declare_global_constant_with_stdin="noglob declare_global_constant_with_stdin"
#
#Oh, bloody hell. That only *SUPERFICIALLY* works. For some reason, zsh still
#aggregates everything between bare "(" and ")" characters into a single function
#argument. This can be hacked around in one of two equally ugly ways:
#
#* Just allow the caller to omit the "(" and ")" characters. Since the type is
#  also passed, we *KNOW* whether it's a list or map and hence that we need to
#  add such characters back into the "eval" we perform.
#* Force the caller to pass explicitly escaped "(" and ")" characters. There are
#  three ways of doing that: single- or double-quoting each such character or
#  preceding each such character with "\". The latter's probably the least ugly.
#
#Actually, there's another way still -- and it's reasonably slick. Just require
#"[" and "]" in place of "(" and ")", then internally convert such characters to
#"(" and ")".
#
#Again, all of these work. We probably shouldn't allow the characters to be
#omitted -- that just looks crass. I'd like to support *BOTH* of the remaining
#methods (i.e., escaped "(" and "[" instead of "("). Great! Go-go-go.
#FIXME: Oh, hell. "[" and "]" are cool, but just a *TAD* excessive. No need to
#make this full-on python, right? Just settle for escaped parens, for now.
#FIXME: Don't bother with the noglob alias above. Callers still rightly expect
#filename globbing to be in effect. (In effect, defining lists often requires
#such globbing.)
#FIXME: Naturally, zsh strips the quoting around passed arguments. If required,
#add such quoting back for "eval" purposes with '"'${^@}'"'.

# ....................{ GLOBALS                            }....................
# Global map from global names to the help strings documenting such globals. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_GLOBAL_NAME_TO_HELP

# ....................{ DECLARERS                          }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_global(string documentation)

Set the documentation for the global exported variable named by the variable
declaration prefixing the passed string to such string and, if such variable has
not already been declared, declare such variable to be global, exported, and of
the documented type. Variable documentation consists of:

. A *variable declaration* in Zeshy-specific C-like syntax, consisting of one
  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`).
. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
  with Zeshy-specific markup for cross-referencing other Zeshy documentation.

== Variable Documentation Grammar ==

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):

.Variable Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
| GlobalName            | <- | AlphanumericString
|===============================================================================

== Variable Type ==

A variable's type may be any alphanumeric string for which an alias of the same
name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
variable type but `order_of_the_blackened_denarius` is not, since
file_descriptor_global_export() is an existing alias but
order_of_the_blackened_denarius_global_export() is (hopefully) not.

Zeshy provides numerous such aliases and hence variable types, including:
`boolean`, `character`, `file_descriptor`, `float`, `integer`, `list`,
`list_set`, `map`, and `string`.
________________<heredoc?>________________
function declare_global() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one help string'
    local help__dg="${1}"

    # If such documentation is prefixed by a variable declaration, match the
    # variable name and type from such declaration. Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    #
    # Else throw an exception with a portion of such documentation.
    [[ "${help__dg}" ==\
        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
        die_for_declarator_type_with_help 'global' "${help}"

    # Before attempting to declare such global, we should test whether such a
    # global already exists and if so either throw an exception or print a
    # warning. There exists no efficient means of performing such test, however.
    # While there do exist efficient means of testing whether a variable either
    # local or global exists and whether such variable in the current scope is
    # local or global, the only means of testing whether a global exists is to
    # parse the output of "typeset -gx +" for a line matching such global's
    # name. While such parsing could conceivably be efficient for infrequent
    # purposes, this function does not follow an infrequent purpose.

    # Such global's declared type and name.
    local global_type__dg="${match[1]}" global_name__dg="${match[2]}"

    # Alias declaring globals of such type.
    local declarator__dg="${global_type__dg}_global_export"

    # If such alias does not exist, throw an exception. Since such alias
    # could technically also be a function, match both. See is_runnable()
    # for further details.
#       print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
    whence -- "${declarator__dg}" &>/dev/null ||
        die "type \"${global_type__dg}\" unrecognized (${declarator__dg}() undefined)"

    # Declare such global. Since the declarator is typically an alias rather
    # than function or pathable, zsh requires evaluating rather than running
    # such declarator. While acceptable, this is somewhat... annoying.
    eval "${declarator__dg} \"\${global_name__dg}\""

    # Add such global to the current parcel.
    add_parcel_global "${ZESHY_PARCEL_NAME}" "${global_name__dg}"

    # Map such global to such help string.
    ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void declare_global_with_stdin[stdin: string documentation]

Set the documentation for the global exported variable named by the variable
declaration prefixing standard input to such input. Consider calling this rather
than declare_global(), which requires passing a string argument rather than
standard input. See declare_function_with_stdin() for further details.
________________<heredoc?>________________
function declare_global_with_stdin() {
    run_runnable_with_stdin declare_global
}

# ....................{ GLOBALS ~ parcel                   }....................
# Document globals previously defined by @{parcel} under such parcel.
set_parcel_to_script "$(dirname -- "${ZESHY_SCRIPT_NAME}")/"*'-parcel'

declare_global_with_stdin <<'________________<heredoc?>________________'
string ZESHY_PARCEL_NAME

Current parcel name, identifying the most recently declared parcel (e.g., by a
call to declare_parcel_to_script() or declare_parcel_to_script_with_stdin()).
See such functions for further details.
________________<heredoc?>________________

# ....................{ GLOBALS ~ function                 }....................
# Document globals previously defined by @{function} under such parcel.
set_parcel_to_script "$(dirname -- "${ZESHY_SCRIPT_NAME}")/"*'-function'

declare_global_with_stdin <<'________________<heredoc?>________________'
map ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME

Map *synonymized function names* (i.e., function names for functions with
multiple names) to the first function names declared for such functions. Since
all first function names thus map to themselves, this map contains the identity
map. To conserve memory, this map does _not_ map *non-synonymized function
names* (i.e., function names for functions with only one name): e.g.,

.ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME()
==========================================
[source]
------------------------------------------
>>> string on_duty=\
...    "It is the fundamental duty of the citizen to resist and to restrain the
...     violence of the state. Those who choose to disregard this responsibility
...     can justly be accused of complicity in war crimes, which is itself
...     designated as 'a crime under international law' in the principles of the
...     Charter of Nuremberg."
>>> function war_crimes tribunal on_vietnam() { print_string "${on_duty}" }
>>> print_string\
...    "war_crimes: ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[war_crimes]}
...     tribunal:   ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[tribunal]}
...     on_vietnam: ${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[on_vietnam]}"
war_crimes: war_crimes
tribunal:   war_crimes
on_vietnam: war_crimes
------------------------------------------
==========================================
________________<heredoc?>________________

# --------------------( WASTELANDS                         )--------------------
# See @{parcel} for such global's declaration.
# See @{function} for such global's declaration.
#FUXME: The global below efficiently obsoletes *ALL* other bizarre schemes we'd
#considered for recording synonyms (particularly, the use of symbolic links
#within the KVS directory for function documentation). Whenever the caller
#requests documentation for some function ${function_name}, perform the
#following mapping:
#
#  function_name="${ZESHY_FUNCTION_NAME_SYNONYM_TO_FUNCTION_NAME[${function_name}]-${function_name}}"
# Prefix this parcel name with an integer to ensure zeshy sources this parcel
# before parcels depending on this parcel (e.g., "parcel" itself).

#       {
        # Global prototype prefixing such help string.
#       string help_prototype

        # If such string contains a newline (i.e., "\n"), crudely match the
        # substring preceding such newline as the global prototype.
#       if [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
        # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       die 'global help string invalid (see "print_help declare_global" for details):
#'"${help_prototype}"
#   }
