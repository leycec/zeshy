#!/usr/bin/env zsh
# ====================[ zsh                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle zsh hooks (i.e., event-driven functions called by zsh).
#
# --------------------( SEE ALSO                           )--------------------
# man zshmisc
#   Reference details on canonical hook lists.

#FIXME: O.K.; I've definitively determined what went wrong when invoking the
#"Cataclysm: DDA" error (i.e., running "cataclysm-dda" with an existing "save"
#subdirectory corresponding to a prior version). For some reason,
#"cataclysm-dda" corrupts (err... "changes") the terminal line settings of the
#current shell on failing with an error. Restoring such settings turns out to be
#both remarkably fast and simple: just run "stty sane". "sane" is an "aggregate
#setting" combining multiple sane terminal line settings. I'm unclear as to
#whether or not it's GNU-specific, but suspect it is. Under BSD, the simplest
#(but less functional) equivalent may be "stty echo -nl -cbreak". We probably
#want a new function reset_terminal() in "io/terminal/terminal" running such
#command. Since it is fast *AND* since terminal corruption when it occurs is
#horrible enough to make frequent resets worthwhile, I'm having trouble coming
#up with a compelling argument *AGAINST* resetting the terminal prior to
#printing every shell prompt. Hence, consider adding:
#
#   run_hook_before_prompt_printed reset_terminal
#
#For further details, see http://docstore.mik.ua/orelly/unix/upt/ch42_04.htm and
#http://www.unixguide.net/linux/faq/06.14.shtml.
#FIXME: Actually, having reset_terminal() run "stty sane" really isn't the most
#generally applicable solution, since that overwrites custom terminal line
#settings that the user actually intended. Instead, do the following:
#
#* On zeshy startup, run "stty -g >'${ZESHY_USER_CACHE_DIR}/stty'". Again, check
#  whether or not this is GNU-specific. If it is, just do *NOTHING* on BSD
#  systems, which is obviously better than doing something horrible. In any case,
#  this caches current terminal line settings to a zeshy-specific file.
#* Implement the following functions:
#
#   function reset_terminal_to_sane_defaults() {
#       stty sane
#   }
#   function reset_terminal_to_startup_defaults() {
#       stty "$(get_file_text "${ZESHY_USER_CACHE_DIR}/stty")"
#   }
#
#Ideally, we'd just save such settings to a global string, avoiding a file read
#for each shell prompt. Sadly, "stty" only supports printing machine-readable
#settings to a file. (I know.) We can circumvent this by:
#
#* Caching to such file as above, or perhaps simply a temporary file. Wait...
#  doesn't zsh support writing to and from variables as files? Check. If not:
#* Read such file into a string global.
#* Delete such file.
#
#Annoying, but certainly faster.

# ....................{ RUNNERS                            }....................
declare_function_with_stdin <<'/---'
void run_hook_after_dir_set_interactively(string function_name)

Call the passed function after the current working directory changes. Unlike
option `auto_pushd`, which `zsh` performs only after cd() is called, `zsh` calls
the passed function after _any_ builtin setting the current working directory is
called, excluding popd() (e.g., cd(), pushd()).
/---
function run_hook_after_dir_set_interactively() {
    die_unless_arg 'expected one function name'
    list_global chpwd_functions; chpwd_functions+="${1}"
}

declare_function_with_stdin <<'/---'
void run_hook_before_zsh_exit(string function_name)

Call the passed function before the current shell exits. Note that such
function ``...is not called by exiting subshells, nor when the exec precommand
modifier is used before an external command. Also, unlike TRAPEXIT, it is not
called when functions exit.'' In other words, `zsh` does not guarantee such
function to be called on every shell exit -- just most of them.
/---
function run_hook_before_zsh_exit() {
    die_unless_arg 'expected one function name'
    list_global zshexit_functions; zshexit_functions+="${1}"
}

# ....................{ RUNNERS ~ command                  }....................
declare_function_with_stdin <<'/---'
void run_hook_before_prompt_printed(string function_name)

Call the passed function before printing a shell prompt for the current user.
/---
function run_hook_before_prompt_printed() {
    die_unless_arg 'expected one function name'
    list_global precmd_functions; precmd_functions+="${1}"
}

declare_function_with_stdin <<'/---'
void run_hook_before_input_historied(string function_name)

Call the passed function before appending a command input by the current user to
the current history and before running such command. Pass such function such
command as a single argument. Such function is subject to special history-
specific handling. See `zshaddhistory` in `man zshmisc` for further details.
/---
function run_hook_before_input_historied() {
    die_unless_arg 'expected one function name'
    list_global zshaddhistory_functions; zshaddhistory_functions+="${1}"
}

declare_function_with_stdin <<'/---'
void run_hook_before_input_run(string function_name)

Call the passed function before running a command input by the current user but
after appending such command to the current history (i.e., after running all
run_hook_before_input_historied() hooks). Such function is passed an argument
list resembling
`[args: (string history_line, string readable_line, string command)]` given:

* `history_line`, the pre-processed history line. If the current shell is
  recording history and the history buffer recorded such input, this is such
  input; else, this is the empty string.
* `readable_line`, a human-readable line. This is such input truncated to one
  terminal line in a manner preserving readability (e.g., eliding block bodies).
* `command`, the post-processed command to be run. This is such input with all
  embedded aliases expanded.
/---
function run_hook_before_input_run() {
    die_unless_arg 'expected one function name'
    list_global preexec_functions; preexec_functions+="${1}"
}

# --------------------( WASTELANDS                         )--------------------
#Pass such function the following three
#arguments (in order):
#
#* Pre-processed history line. If shell history is currently active and the
#  history buffer retained the input, this is such input as recorded in the
#  history buffer; otherwise, this is the empty string.
#* Human-readable line. This is the input truncated to a single terminal line in
#  a manner preserving human readability (e.g., eliding function bodies).
#* Post-processed line. This is the input to be run and hence has all aliases
#  implicitly expanded.
#FUXME: Rename to run_hook_before_command_run().
#void run_hook_on_zsh_directory_change(string hook_name)
