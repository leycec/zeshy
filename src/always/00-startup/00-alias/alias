#!/usr/bin/env zsh
# ====================[ alias                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define alias-specific aliases.

# ....................{ ALIASES                            }....................
# void global_alias(string alias_name, string alias_expansion)
#
# Declare a global alias (i.e., an alias expandable anywhere in an expression
# rather than only in command position).
alias global_alias="alias -g"

# void suffix_alias(string alias_name, string alias_expansion)
#
# Declare a suffix alias (i.e., an alias expandable only at the end of
# expressions, typically for filetypes).
alias suffix_alias="alias -s"

# ....................{ ALIASES ~ global                   }....................
# boolean is(...)
#
# Syntactic sugar signifying the delimiting prefix for a boolean test: e.g.,
#
#   is "PatGoD" == *GoD si and print "Piper methysticum"  # or...
#   [[ "PatGoD" == *GoD ]]  && print "Piper methysticum"  # equivalent!
global_alias is='[['

# void si(void)
#
# Syntactic sugar signifying the delimiting suffix for a boolean test.
global_alias si=']]'

global_alias or='||'
global_alias and='&&'
global_alias not='!'

# --------------------( WASTELANDS                         )--------------------
#Since Zeshy is function autoload-based and aliases
# cannot be autoloaded, Zeshy confines alias definitions to only this file.

#FIXME: Shift entire file as is to "always/00-startup/00-alias". This isn't
#simply "because we can, now"; it's actually subtly essential:
#
#1. It guarantees such aliases to be registered in the global list
#   ${ZESHY_ALIAS_NAMES} and hence unaliases on restarting Zeshy.
#2. It's also more efficient. Compiling aliases into a function eliminates
#   excess whitespace and documentation.
#
#On the other hand, doing so necessitates a slight rewrite of "compile".
#Nothing too big, but the occasional bug may crop up...

#FIXME: Rename global_*() to *_global() everywhere: e.g., from
#string_global() to string_global() and from
#string_global_constant() to string_global_constant(). Helpful to be consistent.

# ....................{ VARIABLES                          }....................
# void freeze_variable(string variable_name)
#
# Render the passed variable read-only (e.g., "const", "final").
#alias freeze_variable='typeset -r'

# void list_global_constant(list variable_name)
#
# Globally declare a list constant.
#alias list_global_constant='typeset -axr'

# void list_set_global_constant(list variable_name)
#
# Globally declare a list set constant (i.e., a list ignoring duplicate values).
#alias list_set_global_constant='typeset -Uaxr'

# void map_global_constant(map variable_name)
#
# Globally declare a map constant.
#alias map_global_constant='typeset -Axr'

# Success code, as returned by successful processes on process completion.
# value  tends to be the conventional choice.
# Failure code, as returned by failed processes on process completion. Note
# that, technically, any return code greater than or equal to this value
# constitutes a process failure.
# void remove_first_arg(void)
#alias get_one_arg_shifted='output "${1}"; shift_arg'
#alias get_one_arg_popped='output "${@[-1]}"; pop_arg'

# Delete the temporary function used to construct the above aliases.
#unfunction make_die_unless_alias

# For convenience, "-h" and
# "--help" are always parsed as valid argument options# void set_first_arg_to_piped_input(void)
#alias parse_args='zparseopts -D -E -A ARGS -- h -help'

# void prepend_piped_input_to_args(void)
# void append_piped_input_to_args(void)
# void append_arg_with_standard_input_if_piped(void)

# For clarity, Zeshy uses the verbs "shift" and "pop" in the Perl sense.

#FIXME: What does "ignoring duplicate values" even mean in the context of a map?
# void map_set(string variable_name)
#
# Locally declare a map set (i.e., a map ignoring duplicate values).
#alias map_set='typeset -UA'

# void map_global_set(string variable_name)
#
# Globally declare a map set (i.e., a map ignoring duplicate values).
#alias map_global_set='typeset -UAx'

#FIXME: Not quite right. Should technically read "#funcstack == 1". We
#temporarily permit one additional layer of function calls to permit calls by
#interactive aliases to be considered as "directly." While we should certainly
#revert this back to "#funcstack == 1", doing so requires we leverage function
#aliases rather than interactive aliases: e.g., rather than this
#
#    interactive_alias cd='change_path'
#    change_path() { ... }
#
#we do this:
#
#    change_path cd() { ... }
#
#It's more or less fine for now, but should be looked at.
#FIXME: Actually, this is pretty terrible, and should be excised everywhere
#currently called (which shouldn't be terribly many, by now).

# string is_interactive_directly(string command_name, string option1, string option2, ...)
#
# Return true if:
#
# * The current function was not called by another function (i.e., was called
#   directly by the current user from the command-line interface).
# * The current shell is attached to a terminal device and interactively reading
#   commands from standard input.
#alias is_interactive_directly='(( ${#funcstack} <= 2 )) and is_interactive'

#alias set_args_to_standard_input_if_piped='is_standard_input_piped and set_args "$(get_standard_input_piped)"'
#FIXME: !!!!!DEPRECATED!!!!! This alias has **SEVERE** fatal errors.
#Necessarily use set_to_piped_input() instead.
# string get_standard_input_piped(void)
#
# Get the standard input piped to the current function or script as a string.
# This is typically used with is_standard_input_piped(): e.g.,
#
#     >>> ska_maria() {
#     ...     if is_standard_input_piped
#     ...     then print -- "$(get_standard_input_piped)"
#     ...     else print -- "${@}"
#     ...     fi
#     ... }
#     >>> print pastora | ska_maria
#     pastora
#     >>> ska_maria pastora
#     pastora
#alias get_standard_input_piped='die "this function should be calling set_to_piped_input(), instead!"'

#FIXME: Sweet; these can *ALL* be made functions. Switch! Awesome.
# boolean die_unless_standard_input_piped(void)
#
# Return true if standard input to the current function or script is a pipe.
#alias is_standard_input_piped='is -p /dev/stdin si'

# boolean is_standard_input_piped(void)
#
# Return true if standard input to the current function or script is a pipe.
#alias is_standard_input_piped='is -p /dev/stdin si'

#alias get_standard_input_piped='< /dev/stdin'
#alias get_standard_input_piped='< /dev/stdin && exec 0<&-'

#string output
#output print_string | set_to_piped_input
#set_to_piped_input output
#alias 'piped_input_string
#alias set_to_piped_input='
#    is -n "${__print__+x}" si or string __print__;
#    __print__="$(< /dev/stdin)";
#    exec 0<&-'

#alias set_print_to_piped_input='
#    is -n "${output+x}" si or string output;
#    output="$(< /dev/stdin)";
#    exec 0<&-'

# ....................{ TYPES ~ interactive aliases        }....................
# Defer defining the following functions until having defined all prior aliases.

#FIXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

#FIXME: Clean up documentation everywhere below.
#FIXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FIXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> interactive_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing callable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> interactive_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> interactive_substitution {m}k{d}ir='mkdir -v --'
#    >>> interactive_substitution {mkd}ir='mkdir -v --'
#    >>> interactive_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing interactive_abbreviation() or interactive_alias() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#function interactive_substitution() {
#    (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or return_true
#    string ALIAS_TYPE='substitution'
#    interactive_alias "${@}"
#}

# void interactive_abbreviation(string alias_specification)
#
# If the current user has enabled the configuration global
# ${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}, define an interactive
# abbreviation according to the passed "="-delimited alias specification: e.g.,
#
#     >>> interactive_abbreviation p="print Thunnus maccoyii"
#     >>> p
#     Thunnus maccoyii
#     >>> () { p }
#     p: interactive abbreviation "p" cannot be called non-interactively
#     print_stack_trace: "p" failed with exit status 1.
#
# Interactive abbreviations are interactive aliases (and hence intended to be
# called only directly from the command line), such that:
#
# * If the passed alias name has the same name as some existing callable (e.g.,
#   builtin, command), print a warning and return without defining such alias.
#
# Interactive abbreviations *NEVER* replace existing callables, but are
# otherwise identical to interactive aliases.
#function interactive_abbreviation() {
#    (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or return_true
#    string ALIAS_TYPE='abbreviation'
#    interactive_alias "${@}"
#}

#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

# void interactive_alias(string alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
#function interactive_alias() {
    # Validate passed arguments, splitting the "="-delimited alias name and
    # expansion split from all passed strings. Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
#    die_unless_args
#    string\
#        alias_name="${*%%[[:space:]]#\=*}"\
#        alias_expansion="${*#*\=[[:space:]]#}"\
#        alias_name_type command_name\
#        alias_expansion_if_interactive alias_expansion_if_non_interactive\
#        alias_logic_if_interactive alias_logic_if_non_interactive
#   print "args: ${*%%=*}"

    # Type of interactive alias to be defined, defaulting to "alias" if not
    # already set by the caller. Recognized types include:
    #
    # * "substitution", only set by interactive_substitution().
    # * "abbreviation", only set by interactive_abbreviation().
    # * "alias", only set by this function.
#    string ALIAS_TYPE="${ALIAS_TYPE:-alias}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "alias type: ${ALIAS_TYPE}\nalias name: ${alias_name}\nalias expansion: ${alias_expansion}" 1>&2

    # Validate passed arguments.
#    is "${ALIAS_TYPE}" == (substitution|abbreviation|alias) si or
#        die "interactive alias type \"${ALIAS_TYPE}\" unrecognized"
#    is "${alias_name}" == "${alias_expansion}" si and
#        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '=' delimiter"
#    (( ${#alias_name} )) or
#        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
#    (( ${#alias_expansion} )) or
#        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

    # If such alias name contains at least one "{"- and "}"-delimited substring,
    # concatenating all such substrings provides the abbreviation name embedded
    # in such alias name (e.g., abbreviation "ichy" in alias "l{ich}mumm{y}").
    # Parse and possibly define such abbreviation.
#    is "${alias_name}" == *'{'*'}'* si and
#        _parse_embedded_interactive_abbreviation

    # If such alias name is already a declared...
#    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # ...Zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
#        if is "${alias_name_type}" == 'function' si and
#        then die "interactive ${ALIAS_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"
        # ...any other callable (e.g., alias, builtin, command) and this is an
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
#        elif is "${ALIAS_TYPE}" == 'abbreviation' si; then
#            cry "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#            return_true
#        # Otherwise, silently wrap such callable in the passed alias.
#        fi
    # If such alias name is *NOT* already a declared callable and this is an
    # interactive substitution alias, there exists nothing to be substituted.
    # Throw an exception.
#    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#        die "interactive substitution \"${alias_name}\" not a defined command or builtin"
    # Otherwise, declare such callable as the the passed alias.
#    fi
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # If the command (i.e., the first word) the alias expands to is the same as
    # the alias name but is not an existing callable, assume the caller is
    # attempting to interactively alias a function of the same name: e.g.,
    #
    #  interactive_alias recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While Zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "interactive_alias recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
#    command_name="${alias_expansion[(w)1]}"
#    is "${alias_name}" == "${command_name}" si and
#        not whence -- "${command_name}" 1>/dev/null 2>&1 and
#        die "interactive alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # Interactive logic to be performed by the function definition below.
#    alias_expansion_if_interactive="${alias_expansion} \"\${@}\""
#    alias_logic_if_interactive="
#    if is_standard_input_piped
#    then run_with_piped_input ${alias_expansion_if_interactive}
#    else ${alias_expansion_if_interactive}
#    fi"

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing callable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
#    if is "${alias_name_type}" == 'none' si
#    then alias_logic_if_non_interactive="die 'interactive ${ALIAS_TYPE} \"${alias_name}\" cannot be called non-interactively'"
#    else
#        alias_expansion_if_non_interactive="${alias_name} \"\${@}\""
#        alias_logic_if_non_interactive="
#    if is_standard_input_piped
#    then run_with_piped_input ${alias_expansion_if_non_interactive}
#    else ${alias_expansion_if_non_interactive}
#    fi"
#    fi

    # Define the desired alias as a function of the same name to:
    #
    # * Temporarily disable this function to prevent infinite recursion on
    #   subsequently calling an alias, builtin, or command of the same name.
    # * If:
    #   * This shell is interactive, thus excluding non-interactive scripts.
    #   * Standard print_string is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
    #   * This "alias" was called directly from the command line, thus
    #     excluding non-interactive calls from functions.
    #   * Then run the passed alias expansion.
    # * Else, run the desired non-interactive expansion.
    # * Regardless of whether such run throws an exception, always re-enable
    #   this function for subsequent calling.
#    eval "function ${alias_name}() {
#    {
#        disable -f ${alias_name}
#        if [[ -o interactive && -t ${ZESHY_FILE_DESCRIPTOR_STANDARD_OUTPUT} && \${#funcstack} -eq 1 ]]
#        then ${alias_logic_if_interactive}
#        else ${alias_logic_if_non_interactive}
#        fi
#    } always {
#        enable -f ${alias_name}
#    }
#}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2
#}

# void _parse_embedded_interactive_abbreviation(void)
#
# Parse "{"- and "}"-delimited substrings from the current interactive alias
# name of the current type ("substitution" or "abbreviation") expanding to the
# current alias expansion. Concatenating such substrings gives the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing callables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
#
# This function is a helper intended to be called only by interactive_alias(),
# thus accepting no arguments and returning no values.
#_parse_embedded_interactive_abbreviation() {
    # Validate sanity.
#    die_if_args

    # If such abbreviation is invalid, throw an exception.
#    is "${ALIAS_TYPE-}" == 'alias' si and
#        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a \"{...}\" but is neither an abbreviation or substitution"
#    is "${alias_name}" == \{[^\{\}]#\} si and
#        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a full \"{...}\""
#    is "${alias_name}" == *\{\}* si and
#        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an empty \"{}\""
#    is "${alias_name}" == *\{[^\}]# si and
###        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an unclosed '{'"

    # Copy of the passed alias name.
#    string alias_name_copy="${alias_name}"

    # Abbreviation name parsed from ${alias_name_copy}.
#    string abbre_name

    # Character succeeding the leftmost "}" in ${alias_name_copy}.
#    string abbre_next_char

    # 1-based indices of the characters immediately preceding and succeeding
    # the leftmost "}" in ${alias_name_copy}.
#    integer\
#        abbre_last_char_index\
#        abbre_next_char_index abbre_next_next_char_index

    # Iteratively shift the leftmost "}" in ${alias_name_copy} right one
    # character until either finding an abbreviation name claimed by no
    # existing callable or reaching the end of ${alias_name_copy}.
#    while true; do
#        abbre_name="${alias_name_copy//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       print_string_escaped "abbreviation: ${abbre_name}"
        #FIXME: Reenable!
#        whence -- "${abbre_name}" 1>/dev/null 2>&1 or break

        # Find the index of the leftmost "}" in ${alias_name_copy} by
        # matching the first "{..}" in such copy. Dismantled, this is:
        #
        # * "#", matching from the beginning of ${alias_name_copy}.
        # * "(#m)", setting global integer ${MEND}, the 1-based index of
        #   the last character matched -- in this case, the leftmost "{".
#        noop "${alias_name_copy#(#m)[^\{\}]#\{[^\{\}]##\}}"

        # If the index of the leftmost "}" is the last character in
        # ${alias_name_copy}, the prior iteration shifted such "}" to the
        # end of such copy and hence exhausted all characters. Return!
#        (( abbre_next_char_index = MEND + 1 ))
#        (( abbre_next_char_index < ${#alias_name_copy} )) or break

        # Otherwise, get the character succeeding the leftmost "}".
#        (( abbre_last_char_index = MEND - 1 ))
#       print_string "abbre_next_char_index: ${abbre_next_char_index}"
#        abbre_next_char="${alias_name_copy[${abbre_next_char_index}]}"

        # Shift the leftmost "}" in ${alias_name_copy} right one character.
        #
        # If the character succeeding the leftmost "}" is a "{", there exist
        # two adjacent "{..}" expressions (e.g., "{mk}{d}ir"). Do not shift
        # the "}" to the right of the "{" (e.g., "{mk{}d}ir"); rather, merge
        # the two expressions (e.g., "{mkd}ir").
#        if is "${abbre_next_char}" == '{' si; then
#            (( ++abbre_next_char_index ))
#            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${alias_name_copy[${abbre_next_char_index},-1]}"
        # Otherwise, simply shift the leftmost "}" right one character.
#        else
#            (( abbre_next_next_char_index = abbre_next_char_index + 1 ))
#            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${abbre_next_char}}${alias_name_copy[${abbre_next_next_char_index},-1]}"
#        fi
#       print_string "new alias name: ${alias_name_copy}"
#    done

    # If all possible abbreviation names have already been claimed by
    # existing callables and:
    #
    # * This is an interactive substitution, print a warning and define no
    #   such abbreviation.
    # * This is an interactive abbreviation, do nothing (i.e., attempt to
    #   use the entire alias name stripped of "{" and "}" characters as the
    #   abbreviation name).
#    if (( abbre_next_char_index == ${#alias_name_copy} )); then
#        if is "${ALIAS_TYPE}" == 'substitution' si; then
#            string abbre_name_type
#            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#            abbre_name_type="${$(whence -w -- "${abbre_name}")##*: }"
#            cry "abbreviation \"${abbre_name}\" in interactive substitution \"${alias_name}\" already a defined ${abbre_name_type}:\n$(which "${abbre_name}")"
#        fi
    # If this is an interactive substitution, define an interactive
    # abbreviation of the above abbreviation name and same expansion as this
    # substitution. While this does recursively call interactive_alias(), such
    # call *NEVER* performs another recursive call. (Why? Listen closely: such
    # abbreviation name contains no "{" or "}" characters and hence no embedded
    # abbreviation. Since such recursive call never calls this function, the
    # recursion is guaranteed to "bottom out" after the first recursion.)
#    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#       print "abbreviating embedded ${abbre_name}=\"${alias_expansion}\"" 1>&2
#        interactive_abbreviation ${abbre_name}="${alias_expansion}"
    # If this is an interactive abbreviation, set the alias name to be returned
    # to the above abbreviation name.
#    else alias_name="${abbre_name}"
#    fi

    # Strip "{" and "}" characters from the alias name to be returned.
#    alias_name="${alias_name//[\{\}]}"
#}
