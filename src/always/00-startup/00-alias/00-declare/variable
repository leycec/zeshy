#!/usr/bin/env zsh
# ====================[ variable                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define variable-specific aliases.

# ....................{ VARIABLES                          }....................
document_alias '
void undefine_variable_from<string variable_name1, string variable_name2, ...>

Undefine the passed variables in the caller''s context. If such context is a
global shell or script, undefine such variables globally; otherwise, undefine
such variables locally. Undefining globals thus requires calling this alias
from a global context (i.e., *NOT* from within a function).

Due to zsh constraints, variable names must be passed whitespace-delimited in a
single shell word (e.g., single- or double-quoted string).
'
alias undefine_variable_from='{
    # Validate passed arguments.
    list args__uv; set_list_to_standard_input_split_on_words args__uv
    (( ${#args__uv} >= 1 )) or die "expected at least one variable name"

    # For safety, destructively coerce such variables to writable local strings.
    # When passed read-only variables, this prevents zsh from failing on the
    # subsequent call to unset() with "zsh: ${variable_name} read-only".
    typeset +r -- "${args__uv[@]}"

    # Unset such variables.
    unset -- "${args__uv[@]}"
} <<<'

# ....................{ VARIABLES ~ string                 }....................
document_alias '
void string<string variable_name1, string variable_name2, ...>

Declare the passed string locally.
'
alias string='local --'

document_alias '
void string_global<string variable_name1, string variable_name2, ...>

Declare the passed string globally but *NOT* exported to the calling shell.
'
alias string_global='typeset -g --'

document_alias '
void string_global_export<string variable_name1, string variable_name2, ...>

Declare the passed string globally exported to the calling shell.
'
alias string_global_export='export --'

document_alias '
void string_constant_global_export<
    string variable_name1, string variable_name2, ...>

Declare the passed string constant globally exported to the calling shell.
'
alias string_constant_global_export='export -r --'

# ....................{ VARIABLES ~ boolean                }....................
document_alias '
void boolean<string variable_name1, string variable_name2, ...>

Declare the passed boolean (i.e., string assuming true value "1" or false value
"") locally. Due to zsh inadequacies, such booleans are currently
indistinguishable from strings. Nevertheless, we recommend users explicitly
declare booleans as such for clarity, (possible) forwards compatibility, and
symmetry with existing builtins integer() and float().
'
alias boolean=string

document_alias '
void boolean_global<string variable_name1, string variable_name2, ...>

Declare the passed boolean globally but *NOT* exported to the calling shell.
See boolean<> for further details.
'
alias boolean_global=string_global

document_alias '
void boolean_global_export<string variable_name1, string variable_name2, ...>

Declare the passed boolean globally exported to the calling shell. See
boolean<> for further details.
'
alias boolean_global_export=string_global_export

document_alias '
void boolean_constant_global_export<
    string variable_name1, string variable_name2, ...>

Declare the passed boolean constant globally exported to the calling shell. See
boolean<> for further details.
'
alias boolean_constant_global_export=string_constant_global_export

# ....................{ VARIABLES ~ character                }....................
document_alias '
void character<string variable_name1, string variable_name2, ...>

Declare the passed character (i.e., string of length 1) locally. Due to zsh
inadequacies, such characters are currently indistinguishable from strings.
Nevertheless, we recommend users explicitly declare characters as such for
clarity, (possible) forwards compatibility, and symmetry with existing builtins
integer() and float().
'
alias character=string

document_alias '
void character_global<string variable_name1, string variable_name2, ...>

Declare the passed character globally but *NOT* exported to the calling shell.
See character<> for further details.
'
alias character_global=string_global

document_alias '
void character_global_export<string variable_name1, string variable_name2, ...>

Declare the passed character globally exported to the calling shell. See
character<> for further details.
'
alias character_global_export=string_global_export

document_alias '
void character_constant_global_export<
    string variable_name1, string variable_name2, ...>

Declare the passed character constant globally exported to the calling shell. See
character<> for further details.
'
alias character_constant_global_export=string_constant_global_export

# ....................{ VARIABLES ~ integer                }....................
# zsh already provides builtin integer() for declaring local integers.

document_alias '
void integer_in_base<integer base, string variable_name>

Declare the passed integer (i.e., non-fractional number) in the passed base
locally. zsh internally retains such base for subsequent pretty printing: e.g.,

    >>> integer_in_base 16 cow_mutilation=4277009102
    >>> print_string "${cow_mutilation}"
    0xFEEDFACE
'
alias integer_in_base='local -i '  # "integer" does *NOT* suffice here

document_alias '
void integer_global<string variable_name1, string variable_name2, ...>

Declare the passed integer globally but *NOT* exported to the calling shell.
'
alias integer_global='integer -g --'

document_alias '
void integer_global_export<string variable_name1, string variable_name2, ...>

Declare the passed integer globally exported to the calling shell.
'
alias integer_global_export='export -i --'

document_alias '
void integer_constant_global_export<string variable_name1, string variable_name2, ...>

Declare the passed integer constant globally exported to the calling shell.
'
alias integer_constant_global_export='export -ir --'

# ....................{ VARIABLES ~ float                  }....................
# zsh already provides builtin float() for declaring local floats.

#FIXME: Rename to float_with_fractional_digit_count().
document_alias '
void float_with_fractional_digit_length<integer length, string variable_name>

Declare the passed float (i.e., fractional number) locally, constrained to the
passed number of fractional digits.
'
alias float_with_fractional_digit_length='local -F'  # "float" does *NOT* suffice

document_alias '
void float_global<string variable_name1, string variable_name2, ...>

Declare the passed float globally but *NOT* exported to the calling shell.
'
alias float_global='float -g --'

document_alias '
void float_global_export<string variable_name1, string variable_name2, ...>

Declare the passed float globally exported to the calling shell.
'
alias float_global_export='export -F --'

document_alias '
void float_constant_global_export<string variable_name1, string variable_name2, ...>

Declare the passed float constant globally exported to the calling shell.
'
alias float_constant_global_export='export -Fr --'

# ....................{ VARIABLES ~ list                   }....................
# Due to current inadequacies in zsh, lists and maps cannot be initialized or
# declared to be read-only at declaration time. To perform the latter, consider
# calling freeze_variable() after initializing such list or map after declaring
# such list or map. While cumbersome, zsh currently affords no alternatives:
#
#     >>> list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )
#     >>> freeze_variable sequence

document_alias '
void list<string variable_name1, string variable_name2, ...>

Declare the passed list (i.e., sequential array) locally.
'
alias list='typeset -a --'

document_alias '
void list_global<string variable_name1, string variable_name2, ...>

Declare the passed list (i.e., sequential array) globally but *NOT* exported to
the calling shell.
'
alias list_global='typeset -ag --'

document_alias '
void list_global_export<string variable_name1, string variable_name2, ...>

Declare the passed list (i.e., sequential array) globally exported to the
calling shell.
'
alias list_global_export='export -a --'

# ....................{ VARIABLES ~ list set               }....................
document_alias '
void list_set<string variable_name1, string variable_name2, ...>

Declare the passed list set (i.e., sequential array ignoring duplicate values)
locally.
'
alias list_set='typeset -Ua --'

document_alias '
void list_set_global<string variable_name1, string variable_name2, ...>

Declare the passed list set (i.e., sequential array ignoring duplicate values)
globally but *NOT* exported to the calling shell.
'
alias list_set_global='typeset -Uag --'

document_alias '
void list_set_global_export<string variable_name1, string variable_name2, ...>

Declare the passed list set (i.e., sequential array ignoring duplicate values)
globally exported to the calling shell.
'
alias list_set_global_export='export -Ua --'

# ....................{ VARIABLES ~ list tie               }....................
document_alias '
void list_tied_string<
  string text_name, string list_name, string separator = ":">

Declare a string with the passed name "tied" to the list with the passed name.
This resembles a Perl tie by joining the list''s elements with the passed
separator, defaulting to ":", into a string and updating that string on each
update (i.e., change) to that list: e.g.,

    >>> list_tied_string arroyo array " "
    >>> list array; array=( cuidad juarez )
    >>> print "${arroyo}"
    cuidad juarez
    >>> array=( el paso )
    >>> print "${arroyo}"
    el paso

Importantly, note zsh leaves the list-tied string initially unset -- even if
the list to which it is tied is set! Hence, list-tied strings should usually
be declared prior to the list to which they tie. Yes, this is unintuitive.
'
alias list_tied_string='typeset -T'

# ....................{ VARIABLES ~ map                    }....................
# Due to current inadequacies in zsh, maps must be externally initialized: e.g.,
#
#     >>> map hash_map; hash_map=( 'key 1' 'value 1' 'key 2' 'value 2' )

document_alias '
void map<string variable_name1, string variable_name2, ...>

Declare the passed map (i.e., associative array) locally.
'
alias map='typeset -A --'

document_alias '
void map_global<string variable_name1, string variable_name2, ...>

Declare the passed map (i.e., associative array) globally but *NOT* exported to
the calling shell.
'
alias map_global='typeset -Ag --'

document_alias '
void map_global_export<string variable_name1, string variable_name2, ...>

Declare the passed map (i.e., associative array) globally exported to the
calling shell.
'
# While "export -a" succeeds, "export -A" oddly fails with error. *shrug*
alias map_global_export='typeset -Agx'

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename "list_set" to "listset" everywhere, for clarity.
#FUXME: Rename to string_tied_list<> to better corresponding to argument order.
#FUXME: This is terrible. Entirely replace 
#document_alias '
#void unfreeze_variable(string variable_name1, string variable_name2, ...)
#
#Unfreeze the passed variables in the current context. This destructively
#destroys such variables'' type and value and is intended to be called only
#prior to calling undefine_variable_from(). Don''t ask; don''t tell.
#'
#alias unfreeze_variable='typeset +r --'

    # If not doing so, calling this
#function on read-only variables causes zsh to fail with ungainly errors
#resembling: "zsh: VARIABLE_NAME read-only".
# for formatting the string
# representation of such integer in that base when output: e.g.,
