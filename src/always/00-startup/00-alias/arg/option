#!/usr/bin/env zsh
# ====================[ option                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define aliases handling argument options (i.e., "-"-prefixed arguments).

# ....................{ TESTERS                            }....................
document_alias '
boolean is_arg_nonoptions_1<void>

Return true if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count<> for further details.
'
alias is_arg_nonoptions_1='
{
    set_integer_to_arg_nonoption_count count__ian
    (( count__ian == 1 ))
}'

document_alias '
boolean is_arg_nonoptions_1_to_3<void>

Return true if the caller passed between one to three non-option arguments. See
set_integer_to_arg_nonoption_count<> for further details.
'
alias is_arg_nonoptions_1_to_3='
{
    set_integer_to_arg_nonoption_count count__ian1t3
    (( 1 <= count__ian1t3 && count__ian1t3 <= 3 ))
}'

# ....................{ SETTERS                            }....................
document_alias '
void set_integers_to_arg_nonoption_count_and_first_index_from<
    string count_integer_name, string first_index_integer_name>

Set the first passed integer to the number of non-options arguments the caller
passed (i.e., arguments not prefixed by "-") and the second passed integer to
the 1-based index of the first such argument.  Due to zsh
constraints, integer names must be passed whitespace-delimited in a single shell
word (e.g., single- or double-quoted string). See
set_integer_to_arg_nonoption_count<> and
set_integer_to_arg_nonoption_first_index<> for further details.
'
alias set_integers_to_arg_nonoption_count_and_first_index_from='
{
    # Validate passed arguments.
    list args__seitancafif
    set_list_to_standard_input_split_on_words args__seitancafif
    (( ${#args__seitancafif} == 2 )) or die "expected two integer names"
    string\
        count_integer_name__seitancafif="${args__seitancafif[1]}"\
        index_integer_name__seitancafif="${args__seitancafif[2]}"

    # Get the index of the first non-option argument.
    set_integer_to_arg_nonoption_first_index\
        "${index_integer_name__seitancafif}"
#   print "arg count: ${#}"
#   print "arg nonoption first index \"${index_integer_name__seitancafif}\": ${(P)index_integer_name__seitancafif}"
#   print "arg nonoption count: $(( # - ${(P)index_integer_name__seitancafif} + 1 ))"

    # Set such integer.
#   print "count integer name: ${count_integer_name__seitancafif}"
     is_variable_integer "${count_integer_name__seitancafif}" or
        integer "${count_integer_name__seitancafif}"
    set_integer "${count_integer_name__seitancafif}"\
        $(( # - ${(P)index_integer_name__seitancafif} + 1 ))
} <<<'

document_alias '
void set_integer_to_arg_nonoption_count<string integer_name>

Set the passed integer to the number of non-options arguments the caller
passed (i.e., arguments not prefixed by "-"). Parse arguments "-" and "--" as
ending option arguments.
'
alias set_integer_to_arg_nonoption_count='
{
    # Validate passed arguments.
    list args__seitanc; set_list_to_standard_input_split_on_words args__seitanc
    (( ${#args__seitanc} == 1 )) or die "expected one integer name"

    # Defer to the above alias with a placeholder first index integer name.
    set_integers_to_arg_nonoption_count_and_first_index_from\
        "${args__seitanc[1]} index_integer_name__seitanc"
#   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
} <<<'

document_alias '
void set_integer_to_arg_nonoption_first_index<string integer_name>

Set the passed integer to:

* If the caller passed at least one non-option argument (i.e., argument not
  prefixed by "-"), the 1-based index of the first such argument.
* Else the number of arguments the caller passed plus one. This corresponds to
  default zsh behavior for builtin list index modifiers "(i)" and "(I)".

Parse arguments "-" and "--" as ending option arguments.
'
alias set_integer_to_arg_nonoption_first_index='
{
    #FIXME: Replace implementation with a single expansion of
    #set_integers_to_arg_nonoption_count_and_first_index_from<>.

    # Validate passed arguments.
    list args__seitanfi
    set_list_to_standard_input_split_on_words args__seitanfi
    (( ${#args__seitanfi} == 1 )) or die "expected one integer name"
    string integer_name__seitanfi="${args__seitanfi[1]}"
    integer arg_nonoption_first_index__seitanfi

    # If passed arguments contain "-" or "--", the index of the first non-option
    # in such arguments is one after the index of such "-" or "--".
    arg_nonoption_first_index__seitanfi=${@[(i)-|--]}
    if (( arg_nonoption_first_index__seitanfi <= # ))
    then noop $(( ++arg_nonoption_first_index__seitanfi ))
    # Otherwise, the index of the first non-option in such arguments is the
    # index of the argument *NOT* prefixed by "-" or the number of such
    # arguments if all arguments are prefixed by "-" or no arguments are passed.
    else arg_nonoption_first_index__seitanfi=${@[(i)[^-]*]}
    fi

    # Set such integer.
     is_variable_integer "${integer_name__seitanfi}" or
        integer "${integer_name__seitanfi}"
    set_integer "${integer_name__seitanfi}"\
        "${arg_nonoption_first_index__seitanfi}"
} <<<'

#Ad-hoc test functions. Quite helpful until we jerry rig together a proper unit
#test framework.

#function tyam() {
#    set_integers_to_arg_nonoption_count_and_first_index_from 'y z'
#    print "arg nonoption count: $y\narg nonoption first index: $z\n"
##   is_arg_nonoptions_1_to_3 and print "...between 1 to 3"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}

# ....................{ SETTERS ~ map                      }....................
document_alias '
void set_map_to_arg_options_with_help_from<
  string map_name,
  string option_spec1, option_spec2, ...,
  string help_message>

Parse and remove "-"-prefixed options from the current argument list via the
passed zparseopts()-formatted options specifications into the passed map.
Preserve all other arguments in the current argument list for subsequent parsing
by the caller. See "info zsh[i][zparseopts]" for further details. Due to zsh
constraints, arguments must be passed whitespace-delimited in a single shell
word (e.g., single- or double-quoted string).

Parse options "-h" and "--help" by printing the passed help message and
returning from the caller function or script with zero exit status. If parsing
fails, also print such message but return with non-zero exit status: e.g.,

  # Set command-line arguments.
  >>> set_args -d --ad --alive 42 "glass_arm.shattering"

  # Parse such arguments.
  >>> map arg_options
  >>> set_map_to_arg_options_with_help_from ''arg_options d e -ad -or: -alive:: "
Usage: doa [OPTION]... [FILE]...

Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.

Options:
  -h, --help          print this help text and exit
  -d                  return non-zero exit status if such files fail to run
  -e                  evaluate rather than run the passed files
  --ad                switch from a Julian to Gregorian calendar
  --or DEATHS         set the maximum number of DEATHS
  --alive [LIVES]     set the starting number of LIVES (default: 3)
"''

  # Check parsed options.
  >>> print_string "option \"--alive\": ${arg_options[--alive]}"
  option "--alive": 42
  >>> is_map_key arg_options "-d" and print "option \"-d\": enabled"
  option "-d": enabled
'
alias set_map_to_arg_options_with_help_from='
{
    # Validate passed arguments.
    list args__paowhf; set_list_to_standard_input_split_on_words args__paowhf
    (( ${#args__paowhf} >= 3 )) ||
        die "expected one map name, at least one option specifier, and one help string"
    string map_name__paowhf="${args__paowhf[1]}"
    string help_message__paowhf="${args__paowhf[-1]}"

    # Remove the first and last passed arguments, having parsed such arguments.
    behead_list args__paowhf
    curtail_list   args__paowhf

    # Locally declare such map if not already declared.
    is_map "${map_name__paowhf}" or map "${map_name__paowhf}"

    # Parse options under the passed (and canonical help) option specifications,
    # preserving unparsed options for subsequent parsing by the caller. If such
    # parsing fails, print the passed help text and return from the caller or
    # script with non-zero exit status. Dismantled, this is:
    #
    # * "-D", removing *ONLY* parsed options from the current argument list.
    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
    #   option specification, thus preserving all unspecified options.
    # * "-M", parsing "="-prefixed substrings in option specifications as the
    #   map key to parse such option into (e.g., "-help=h" parses long option
    #   "--help" into map key ${arg_options[-h]} rather than
    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
    #   target list or map name to parse such option into.
    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
    #   either the option values if passed or the empty string if not passed.
    zparseopts -M -D -E -A "${map_name__paowhf}" --\
        "${args__paowhf[@]}" h -help=h or {
        curse_string "${help_message__paowhf}"
        return_false
    }

    # If passed a help option, ignore all other options, print the passed help
    # text, and return from the caller function or script.
    is_map_key "${map_name__paowhf}" "-h" and return_string "${args__paowhf}"
} <<<'

# --------------------( WASTELANDS                         )--------------------
    # Validate passed arguments.
#   list args__seitanc; set_list_to_standard_input_split_on_words args__seitanc
#   (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#   string integer_name__seitanc="${args__seitanc[1]}"

    # Get the index of the first non-option argument.
#   set_integer_to_arg_nonoption_first_index arg_nonoption_first_index__seitanc
#   print "arg count: ${#}"
#   print "arg nonoption first index: ${arg_nonoption_first_index__seitanc}"
#   print "arg nonoption count: $(( # - arg_nonoption_first_index__seitanc + 1 ))"

    # Set such integer.
#    is_variable_integer "${integer_name__seitanc}" or integer "${integer_name__seitanc}"
#   set_integer "${integer_name__seitanc}"\
#       $(( # - arg_nonoption_first_index__seitanc + 1 ))

#FUXME: Rename to set_list_to_arg_options_with_help_from<> and accept the first
#passed argument as a list name. In other words, stop assuming a list name of
#${arg_options} as we currently do.

#boolean is_arg_nonoptions_1_to_3{void}
#boolean is_arg_nonoptions_1_to_3<void>
#Return true if the number of non-options in the current argument list (i.e.,
#arguments not prefixed by "-") is . This alias parses arguments "-" and "--"
#as the last options in such list.

#set_integer_to_arg_nonoption_count __nonoptions__ and
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#'
#alias is_arg_nonoptions_1_to_3='
#{
#    integer __nonoptions__; set_integer_to_arg_nonoption_count __nonoptions__
#    print "non-option count: ${__nonoptions__}"
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#}
#'
#function tyam() {
#   set_integer_to_arg_nonoption_count y
#   print "arg nonoption count: $y"
#    is_arg_nonoptions_1_to_3 and print "...between 1 to 3"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}
    #FUXME: Such functionality, duplicated above, should arguably be
    #encapsulated into a single function -- perhaps, say set_integer_locally()
    #or set_integer_declaratively(). Hmm; how about
    #set_integer_declared_locally_unless_found() or
    #set_integer_and_localize_unless_declared() or
    #set_integer_localized_if_unset()? Yes; the latter, I should think. Ah; wait.
    #The syntax is rather ugly, requiring a composite herestring. *shrug*

#   set_integer "${integer_name_seitanfi}" $(( arg_nonoption_first_index_seitanfi ))
#   list __args__; __args__=( ${(z)"$(< /dev/stdin)"} )
# Get the number of non-options passed (i.e., non-"-"-prefixed arguments).
    #FUXME: Be nice to extract this into a new set_integer_to_evaluation().
    #Actually, how about a more general set_scalar_to_evaluation()? Right. That
    #seems perfect.

#   noop ${(P)__integer_name__::=$(( __arg_nonoption_first_index__ ))}
#   noop ${(P)__integer_name__::=$(( # - __arg_nonoption_first_index__ + 1 ))}
        # Else, if at least one passed arguments is not prefixed by "-", such
        # argument is the first non-option in such arguments.
        # Otherwise, set such index to the size of such list plus one.
#       (( __arg_option_last_index__ <= # )) or 
#           (( __arg_option_last_index__ <= # )) or 
#       then noop ${(P)__integer_name__::=$(( __arg_option_last_index__ ))}
#       else 
#       fi

#   noop  ${(P)__integer_name__::=${@[(i)-|--]}}
#   if (( ${(P)__integer_name__} <= # ))

#FUXME: Completely unrelated to this component, but we can now actually create
#sensible return_string()-style aliases! Oh, man; pretty sweet. Finally found
#it.

    #FUXME: Validate the passed argument is a single argument. Just revert to
    #the traditional argument parsing to do so.
    # Validate passed arguments.
#   string __integer_name__; __integer_name__="$(get_standard_input_piped)"
