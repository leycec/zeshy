#!/usr/bin/env zsh
# ====================[ option                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define aliases handling argument options (i.e., "-"-prefixed arguments).

# ....................{ TESTERS                            }....................
# boolean is_arg_nonoptions_1_to_3(void)
#
# Return true if the caller passed between one to three non-option arguments.
# Return true if the number of non-options in the current argument list (i.e.,
# arguments not prefixed by "-") is . This alias parses arguments "-"
# and "--" as the last options in such list.
alias is_arg_nonoptions_1_to_3='
{
    set_integer_to_arg_nonoption_count __nonoptions__
    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
}
'
#set_integer_to_arg_nonoption_count __nonoptions__ and
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#'
#alias is_arg_nonoptions_1_to_3='
#{
#    integer __nonoptions__; set_integer_to_arg_nonoption_count __nonoptions__
#    print "non-option count: ${__nonoptions__}"
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#}
#'

# ....................{ SETTERS                            }....................
# void set_integer_to_arg_nonoption_first_index(string integer_name)
#
# Set the passed integer to:
#
# * If the caller passed at least one non-option argument (i.e., argument not
#   prefixed by "-"), the 1-based index of the first such argument.
# * Else the number of arguments the caller passed plus one. This corresponds to
#   default Zsh behavior for builtin list index modifiers "(i)" and "(I)".
#
# As is standard, this alias parses option arguments "-" and "--" as the final
# option arguments.
alias set_integer_to_arg_nonoption_first_index='
{
    # Validate passed arguments.
    list  args_seitanfi; set_list_to_standard_input_split_on_words args_seitanfi
    (( ${#args_seitanfi} == 1 )) || die "expected one integer name"
    string integer_name_seitanfi="${args_seitanfi[1]}"
    integer arg_nonoption_first_index_seitanfi

    # If passed arguments contain "-" or "--", the index of the first non-option
    # in such arguments is one after the index of such "-" or "--".
    arg_nonoption_first_index_seitanfi=${@[(i)-|--]}
    if (( arg_nonoption_first_index_seitanfi <= # ))
    then noop $(( ++arg_nonoption_first_index_seitanfi ))
    # Otherwise, the index of the first non-option in such arguments is the
    # index of the argument *NOT* prefixed by "-" or the number of such
    # arguments if all arguments are prefixed by "-" or no arguments are passed.
    else arg_nonoption_first_index_seitanfi=${@[(i)[^-]*]}
    fi

    # Set such integer.
     is_integer "${integer_name_seitanfi}" or integer "${integer_name_seitanfi}"
    set_integer "${integer_name_seitanfi}"\
        "${arg_nonoption_first_index_seitanfi}"
} <<<'

# void set_integer_to_arg_nonoption_count(string integer_name)
#
# Set the passed integer to the number of non-options arguments the caller
# passed (i.e., arguments not prefixed by "-"). As is standard, this alias
# parses option arguments "-" and "--" as the final option arguments.
alias set_integer_to_arg_nonoption_count='
{
    # Validate passed arguments.
    list args_seitanc; set_list_to_standard_input_split_on_words args_seitanc
    (( ${#args_seitanc} == 1 )) || die "expected one integer name"
    string integer_name_seitanc="${args_seitanc[1]}"

    # Get the index of the first non-option argument.
    set_integer_to_arg_nonoption_first_index arg_nonoption_first_index_seitanc
    print "arg count: ${#}"
    print "arg nonoption first index: ${arg_nonoption_first_index_seitanc}"
    print "arg nonoption count: $(( # - arg_nonoption_first_index_seitanc + 1 ))"

    #FIXME: Such functionality, duplicated above, should arguably be
    #encapsulated into a single function -- perhaps, say set_integer_locally()
    #or set_integer_declaratively().

    # Set such integer.
     is_integer "${integer_name_seitanc}" or integer "${integer_name_seitanc}"
    set_integer "${integer_name_seitanc}"\
        $(( # - arg_nonoption_first_index_seitanc + 1 ))
} <<<'
function tyam() {
    set_integer_to_arg_nonoption_count y
    print "arg nonoption count: $y"
}
function tyim() {
    tyam
    tyam -a
    tyam -a a
}

# --------------------( WASTELANDS                         )--------------------
#   set_integer "${integer_name_seitanfi}" $(( arg_nonoption_first_index_seitanfi ))
#   list __args__; __args__=( ${(z)"$(< /dev/stdin)"} )
# Get the number of non-options passed (i.e., non-"-"-prefixed arguments).
    #FUXME: Be nice to extract this into a new set_integer_to_evaluation().
    #Actually, how about a more general set_scalar_to_evaluation()? Right. That
    #seems perfect.

#   noop ${(P)__integer_name__::=$(( __arg_nonoption_first_index__ ))}
#   noop ${(P)__integer_name__::=$(( # - __arg_nonoption_first_index__ + 1 ))}
        # Else, if at least one passed arguments is not prefixed by "-", such
        # argument is the first non-option in such arguments.
        # Otherwise, set such index to the size of such list plus one.
#       (( __arg_option_last_index__ <= # )) or 
#           (( __arg_option_last_index__ <= # )) or 
#       then noop ${(P)__integer_name__::=$(( __arg_option_last_index__ ))}
#       else 
#       fi

#   noop  ${(P)__integer_name__::=${@[(i)-|--]}}
#   if (( ${(P)__integer_name__} <= # ))

#FUXME: Completely unrelated to this component, but we can now actually create
#sensible return_string()-style aliases! Oh, man; pretty sweet. Finally found
#it.

    #FUXME: Validate the passed argument is a single argument. Just revert to
    #the traditional argument parsing to do so.
    # Validate passed arguments.
#   string __integer_name__; __integer_name__="$(get_standard_input_piped)"
