#!/usr/bin/env zsh
# ====================[ option                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define aliases handling argument options (i.e., "-"-prefixed arguments).

# ....................{ TESTERS                            }....................
# boolean is_arg_nonoptions_1_to_3(void)
#
# Return true if the caller passed between one to three non-option arguments.
# Return true if the number of non-options in the current argument list (i.e.,
# arguments not prefixed by "-") is . This alias parses arguments "-" and "--"
# as the last options in such list.
alias is_arg_nonoptions_1_to_3='
{
    set_integer_to_arg_nonoption_count    arg_nonoption_count_ian1t3;
    (( 1 <= arg_nonoption_count_ian1t3 && arg_nonoption_count_ian1t3 <= 3 ))
}'

# ....................{ SETTERS                            }....................
# void set_integer_to_arg_nonoption_first_index<string integer_name>
#
# Set the passed integer to:
#
# * If the caller passed at least one non-option argument (i.e., argument not
#   prefixed by "-"), the 1-based index of the first such argument.
# * Else the number of arguments the caller passed plus one. This corresponds to
#   default Zsh behavior for builtin list index modifiers "(i)" and "(I)".
#
# Parse option arguments "-" and "--" as the last option arguments.
alias set_integer_to_arg_nonoption_first_index='
{
    # Validate passed arguments.
    list  args__seitanfi
    set_list_to_standard_input_split_on_words args__seitanfi
    (( ${#args__seitanfi} == 1 )) or die "expected one integer name"
    string integer_name__seitanfi="${args__seitanfi[1]}"
    integer arg_nonoption_first_index__seitanfi

    # If passed arguments contain "-" or "--", the index of the first non-option
    # in such arguments is one after the index of such "-" or "--".
    arg_nonoption_first_index__seitanfi=${@[(i)-|--]}
    if (( arg_nonoption_first_index__seitanfi <= # ))
    then noop $(( ++arg_nonoption_first_index__seitanfi ))
    # Otherwise, the index of the first non-option in such arguments is the
    # index of the argument *NOT* prefixed by "-" or the number of such
    # arguments if all arguments are prefixed by "-" or no arguments are passed.
    else arg_nonoption_first_index__seitanfi=${@[(i)[^-]*]}
    fi

    # Set such integer.
     is_integer "${integer_name__seitanfi}" or integer "${integer_name__seitanfi}"
    set_integer "${integer_name__seitanfi}"\
        "${arg_nonoption_first_index__seitanfi}"
} <<<'

# void set_integer_to_arg_nonoption_count<string integer_name>
#
# Set the passed integer to the number of non-options arguments the caller
# passed (i.e., arguments not prefixed by "-"). Parse option arguments "-" and
# "--" as the last option arguments.
alias set_integer_to_arg_nonoption_count='
{
    # Validate passed arguments.
    list args__seitanc
    set_list_to_standard_input_split_on_words args__seitanc
    (( ${#args__seitanc} == 1 )) || die "expected one integer name"
    string integer_name__seitanc="${args__seitanc[1]}"

    # Get the index of the first non-option argument.
    set_integer_to_arg_nonoption_first_index arg_nonoption_first_index__seitanc
#   print "arg count: ${#}"
#   print "arg nonoption first index: ${arg_nonoption_first_index__seitanc}"
#   print "arg nonoption count: $(( # - arg_nonoption_first_index__seitanc + 1 ))"

    # Set such integer.
     is_integer "${integer_name__seitanc}" or integer "${integer_name__seitanc}"
    set_integer "${integer_name__seitanc}"\
        $(( # - arg_nonoption_first_index__seitanc + 1 ))
} <<<'

# --------------------( WASTELANDS                         )--------------------
#set_integer_to_arg_nonoption_count __nonoptions__ and
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#'
#alias is_arg_nonoptions_1_to_3='
#{
#    integer __nonoptions__; set_integer_to_arg_nonoption_count __nonoptions__
#    print "non-option count: ${__nonoptions__}"
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#}
#'
#function tyam() {
#   set_integer_to_arg_nonoption_count y
#   print "arg nonoption count: $y"
#    is_arg_nonoptions_1_to_3 and print "...between 1 to 3"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}
    #FUXME: Such functionality, duplicated above, should arguably be
    #encapsulated into a single function -- perhaps, say set_integer_locally()
    #or set_integer_declaratively(). Hmm; how about
    #set_integer_declared_locally_unless_found() or
    #set_integer_and_localize_unless_declared() or
    #set_integer_localized_if_unset()? Yes; the latter, I should think. Ah; wait.
    #The syntax is rather ugly, requiring a composite herestring. *shrug*

#   set_integer "${integer_name_seitanfi}" $(( arg_nonoption_first_index_seitanfi ))
#   list __args__; __args__=( ${(z)"$(< /dev/stdin)"} )
# Get the number of non-options passed (i.e., non-"-"-prefixed arguments).
    #FUXME: Be nice to extract this into a new set_integer_to_evaluation().
    #Actually, how about a more general set_scalar_to_evaluation()? Right. That
    #seems perfect.

#   noop ${(P)__integer_name__::=$(( __arg_nonoption_first_index__ ))}
#   noop ${(P)__integer_name__::=$(( # - __arg_nonoption_first_index__ + 1 ))}
        # Else, if at least one passed arguments is not prefixed by "-", such
        # argument is the first non-option in such arguments.
        # Otherwise, set such index to the size of such list plus one.
#       (( __arg_option_last_index__ <= # )) or 
#           (( __arg_option_last_index__ <= # )) or 
#       then noop ${(P)__integer_name__::=$(( __arg_option_last_index__ ))}
#       else 
#       fi

#   noop  ${(P)__integer_name__::=${@[(i)-|--]}}
#   if (( ${(P)__integer_name__} <= # ))

#FUXME: Completely unrelated to this component, but we can now actually create
#sensible return_string()-style aliases! Oh, man; pretty sweet. Finally found
#it.

    #FUXME: Validate the passed argument is a single argument. Just revert to
    #the traditional argument parsing to do so.
    # Validate passed arguments.
#   string __integer_name__; __integer_name__="$(get_standard_input_piped)"
