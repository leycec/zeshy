#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define list-specific aliases.

# ....................{ CONVERTERS                         }....................
# While *NOT* an alias and hence otherwise inapplicable to this component, this
# function's implementation is inseparable from that of alias
# set_list_to_string_piped<>. For the love of Elder Gods, define both together.

document_function '
string convert_list_to_string(string list_name)

Get a string losslessly encapsulating the contents of the passed list. Call
set_list_to_string_piped() to restore such string back into such list. See
set_list_to_string_piped() and return_list<> for further details.
'
function convert_list_to_string() {
    # Validate passed arguments.
    die_unless_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Convert such list. Dismantled, this is:
    #
    # * '1:-list' expands to the passed list name or 'list' if no such name
    #   was passed.
    # * 'P' transitively expands this name to the actual name of the desired
    #   associative list in the caller's scope.
    # * '@' interprets this expansion as a list rather than scalar.
    # * 'qq' protectively embeds all reserved shell characters in such names
    #   and values in single quotes.
    print_string "${(qq@P)list_name}"
}

# ....................{ RETURNERS                          }....................
document_alias '
string return_list<string list_name>

Return the passed list from the current function or script. Specifically:

* Losslessly convert such list into a string.
* Print such string to standard output.
* Return from such function or script with zero exit status (i.e., success).

Callers of such function or script may consider calling
set_list_to_string_piped<> to convert such string back into the original list.

*CAVEAT EMPTOR*: while stable, this alias performs at least three complete list
copies assuming subsequent expansion of set_list_to_string_piped<> and two list
copies otherwise. In other words, this alias is inefficient with large lists.
Where efficiency is a concern, refactor list functions to accept list names as
passed arguments and expand such lists with parameter expansion flags "(@P)".
'
alias return_list='
{
    # Validate passed arguments.
    list args_rl; set_list_to_standard_input_split_on_words args_rl
    (( #args_rl == 1 )) || die "expected one list name"

    # Return such list.
    convert_list_to_string "${args_rl[1]}"
    return_true
} <<<'

# ....................{ SETTERS                            }....................
#FIXME: Fix now-broken examples in "README.dev". Also, extend to restore_map().
#FIXME: Rename to set_list_to_string() and change the "*" below to "1". (Unless
#you can think of a definable reason to accept multiple strings? I can't. The
#list contents should *ALWAYS* be a single string, right?)
#FIXME: Oh, boy; this is great, but requires a bit of documentation revisions
#above and implementation revisions below. Basically.........................
#it turns out that when you both pipe input *AND* herestring input into a block,
#zsh appends the latter to the former. Makes sense, as the former does lexically
#appear prior to the latter. So, we treat the last line of block input as the
#passed list name and all other lines as list content. Hence, the function
#prototype is effectively:
# void set_list_to_string_piped<string list_name>
#...with the caveat that the string must be piped into such alias. Phew! Sweet.

#FIXME: *ACTUALLY TEST*, using the example below.

document_alias '
void set_list_to_string_piped<string list_name>

Convert the string piped on standard input into the passed list. Such string
must be of the same format output by convert_list_to_string() and return_list<>
(e.g., parameter expansion flags "(qq)"). While such string must be piped into
this alias, such list name must be passed after this alias: e.g.,

  # Return a stringified list.
  >>> get_minerals() {
  ...     list asbestos
  ...     asbestos=( nephrite porphyry glauconite mafic )
  ...     convert_list_to_string asbestos
  ... }

  # Restore such string back into such list.
  >>> list asbestos_copy
  >>> get_minerals | set_list_to_string_piped asbestos_copy
  >>> print_string "${asbestos_copy[1]}"
  nephrite
'
alias set_list_to_string_piped='{
    #FIXME: ACTUALLY IMPLEMENT THIS. See above. Note that we *REALLY* want to
    #avoid list copies here; hence, we should probably defer copying from
    #/dev/stdin by editing the final line below to... oh. Right. We can''t
    #defer, since we have to split it on newline here. Incidentally, do that
    #using a (hopefully) efficient %%-style parameter glob enabling "(#b)",
    #which should both remove the passed list name (leaving only the piped
    #string) *AND* capture such name into ${match[1]}.

    # Validate passed arguments.
    list args_sltsc; set_list_to_standard_input_split_on_words args_sltsc
    (( ${#args_sltsc} == 1 )) ||
        die "expected one list name and at least one string"
    string list_name_sltsc="${args_sltsc[1]}"
    shift_list_element args_sltsc

    # Declare such list if not already.
    is_list "${list_name_sltsc}" or eval "list ${list_name_sltsc}"

    # Convert such string to such list. For efficiency, this avoids a list copy.
    set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
} <<<'

# --------------------( WASTELANDS                         )--------------------
#FUXME: Great! Now fixup documentation both here and in
#convert_list_to_string().
#FUXME: Shift convert_list_to_string() here and convert into an alias. It's not
#necessary, but vastly improves understandability and code maintenance to keep
#the two definitions together.
# void set_list_to_string_piped(string list_name, string list_contents)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
# See convert_list_to_string() for further details.

#Such constraints are
#(e.g., parameter expansion flags "(qq)"). Due to zsh constraints, such string
#must be piped into this alias
#See convert_list_to_string() and return_list<> for further
#details, caveats, and examples.

#Avoid calling set_list_to_evaluation(),
    # which incurs yet another expensive list copy.
#   eval "${list_name_sltsc}=( \${(Qz):-\${args_sltsc[*]}} )"
#   set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
#Typically, such
#string should have been previously created by return_list<>.
# See convert_list_to_string() for further details.

#FUXME: Every alias in this component should be suffixed with "_from",
#indicating an unavoidable single quoted passed argument style.

#alias set_list_to_string_converted='{
#    # Validate passed arguments.
#    list args_sltsc; set_list_to_standard_input_split_on_words args_sltsc
#    (( ${#args_sltsc} >= 2 )) ||
#        die "expected one list name and at least one string"
#    string list_name_sltsc="${args_sltsc[1]}"
#    shift_list_element args_sltsc
#
#    # Declare such list if not already.
#    is_list "${list_name_sltsc}" or eval "list ${list_name_sltsc}"
#
#    # Convert such string to such list.
#    set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
#} <<<'

#   >>> function make_list() {
#   >>>   list original; original=( oeu ooo 'zzz 3' 967 )
#   >>>   convert_list_to_string original
#   >>> }
#
#   # Make a new list named "copy" converted from such function's return value.
#   >>> set_list_to_string_from "copy $(make_list)"
#FUXME: Honestly, this is silly. Why not just:
#
#    function make_list() {
#       list original; original=( oeu ooo 'zzz 3' 967 )
#       return_list original
#    }
#
#    list copy
#    run_and_set_list_to_output make_list copy
#
#O.K.; a function resembling run_and_set_list_to_output() is clearly the
#way to go. This function name is probably as concise as we can go without
#becoming unintentionally obfuscatory. I say, "Run with it."
#FUXME: Rename to set_list_to_string() and shift to "00-alias/list".
#FUXME: Wait. The new-style herestring-driven aliases permit a superior approach.
#See below
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
#alias restore_list='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    is -n "${list+x}" si or list list;
#    list=( ${(z)"$(< /dev/stdin)"} )
#}'
