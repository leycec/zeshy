#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define list-specific aliases.

#FIXME: Every alias in this component should be suffixed with "_from",
#indicating an unavoidable single quoted passed argument style.

# ....................{ SETTERS                            }....................
#FIXME: Fix now-broken examples in "README.dev". Also, extend to restore_map().
#FIXME: Great! Now fixup documentation both here and in
#convert_list_to_string().
#FIXME: Shift convert_list_to_string() here and convert into an alias. It's not
#necessary, but vastly improves understandability and code maintenance to keep
#the two definitions together.
#FIXME: Rename to set_list_to_string() and change the "*" below to "1". (Unless
#you can think of a definable reason to accept multiple strings? I can't. The
#list contents should *ALWAYS* be a single string, right?)

# void set_list_to_string_piped(string list_name, string list_contents)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
# See convert_list_to_string() for further details.

#FIXME: Oh, boy; this is great, but requires a bit of documentation revisions
#above and implementation revisions below. Basically.........................
#it turns out that when you both pipe input *AND* herestring input into a block,
#zsh appends the latter to the former. Makes sense, as the former does lexically
#appear prior to the latter. So, we treat the last line of block input as the
#passed list name and all other lines as list content. Hence, the function
#prototype is effectively:
# void set_list_to_string_piped(string list_name)
#...with the caveat that the string must be piped into such alias. Phew! Sweet.

alias set_list_to_string_piped='{
    # Validate passed arguments.
    list args_sltsc; set_list_to_standard_input_split_on_words args_sltsc
    (( ${#args_sltsc} == 1 )) ||
        die "expected one list name and at least one string"
    string list_name_sltsc="${args_sltsc[1]}"
    shift_list_element args_sltsc

    # Declare such list if not already.
    is_list "${list_name_sltsc}" or eval "list ${list_name_sltsc}"

    # Convert such string to such list.
    set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
} <<<'

# --------------------( WASTELANDS                         )--------------------
#alias set_list_to_string_converted='{
#    # Validate passed arguments.
#    list args_sltsc; set_list_to_standard_input_split_on_words args_sltsc
#    (( ${#args_sltsc} >= 2 )) ||
#        die "expected one list name and at least one string"
#    string list_name_sltsc="${args_sltsc[1]}"
#    shift_list_element args_sltsc
#
#    # Declare such list if not already.
#    is_list "${list_name_sltsc}" or eval "list ${list_name_sltsc}"
#
#    # Convert such string to such list.
#    set_list_to_evaluation "${list_name_sltsc}" "\${(Qz):-\${args_sltsc[*]}}"
#} <<<'

#   >>> function make_list() {
#   >>>   list original; original=( oeu ooo 'zzz 3' 967 )
#   >>>   convert_list_to_string original
#   >>> }
#
#   # Make a new list named "copy" converted from such function's return value.
#   >>> set_list_to_string_from "copy $(make_list)"
#FIXME: Honestly, this is silly. Why not just:
#
#    function make_list() {
#       list original; original=( oeu ooo 'zzz 3' 967 )
#       return_list original
#    }
#
#    list copy
#    run_and_set_list_to_output make_list copy
#
#O.K.; a function resembling run_and_set_list_to_output() is clearly the
#way to go. This function name is probably as concise as we can go without
#becoming unintentionally obfuscatory. I say, "Run with it."
#FIXME: Rename to set_list_to_string() and shift to "00-alias/list".
#FIXME: Wait. The new-style herestring-driven aliases permit a superior approach.
#See below
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
#alias restore_list='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    is -n "${list+x}" si or list list;
#    list=( ${(z)"$(< /dev/stdin)"} )
#}'
