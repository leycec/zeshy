#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define list-specific aliases.

#FIXME: Every alias in this component should be suffixed with "_from",
#indicating an unavoidable single quoted passed argument style.

# ....................{ SETTERS                            }....................
#FIXME: Fix now-broken examples in "README.dev". Also, extend to restore_map().
#FIXME: Sweet! Should work, no? Call like so:
#    function make_list() {
#       list original; original=( oeu ooo 'zzz 3' 967 )
#       convert_list_to_string original
#    }
#
#    # Make a new list named "copy" converted from such function's return value.
#    set_list_to_string_from "copy $(make_list)"
#
#Use this as the example below.
#FIXME: Great! Now fixup documentation both here and in
#convert_list_to_string().
#FIXME: Shift convert_list_to_string() here and convert into an alias. It's not
#necessary, but vastly improves understandability and code maintenance to keep
#the two definitions together.
#FIXME: Rename to set_list_to_string() and change the "*" below to "1". (Unless
#you can think of a definable reason to accept multiple strings? I can't. The
#list contents should *ALWAYS* be a single string, right?)

# void set_list_to_string_from(string list_name, string list_contents)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
alias set_list_to_string_from='{
    # Validate passed arguments.
    list __args__; set_list_to_standard_input_split_on_words __args__
    (( ${#__args__} >= 2 )) ||
        die "expected one list name and at least one string"
    string __list_name__="${__args__[1]}"
    shift_list_element __args__

    # Declare such list if not already.
    is_list "${__list_name__}" or eval "list ${__list_name__}"

    # Convert such string to such list.
    set_list_to_evaluation "${__list_name__}" "\${(Qz):-\${__args__[*]}}"
} <<<'

# --------------------( WASTELANDS                         )--------------------
#FIXME: Honestly, this is silly. Why not just:
#
#    function make_list() {
#       list original; original=( oeu ooo 'zzz 3' 967 )
#       return_list original
#    }
#
#    list copy
#    run_and_set_list_to_output make_list copy
#
#O.K.; a function resembling run_and_set_list_to_output() is clearly the
#way to go. This function name is probably as concise as we can go without
#becoming unintentionally obfuscatory. I say, "Run with it."
#FIXME: Rename to set_list_to_string() and shift to "00-alias/list".
#FIXME: Wait. The new-style herestring-driven aliases permit a superior approach.
#See below
# void restore_list(void)
#
# Convert the string piped on standard input to a local list named "list",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_list().
#alias restore_list='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    is -n "${list+x}" si or list list;
#    list=( ${(z)"$(< /dev/stdin)"} )
#}'
