#!/usr/bin/env zsh
# ====================[ argument                           ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define argument-specific aliases.

# ....................{ EXCEPTIONS                         }....................
# string get_statement_dying_unless(string math_condition)
#
# Get an evaluatable string throwing an exception unless the caller of the
# function or script evaluating such string satisfies the passed math condition
# (typically on the number of passed arguments): e.g.,
#
#     # Make
#     >>> alias die_unless_args_at_least_42="$(get_statement_dying_unless '# == 42')"
function get_statement_dying_unless() {
    (( # == 1 )) || die 'expected one condition'
    print "(( ${1} )) || die"
}

# string get_statement_dying_unless_standard_input_piped(
#   string test_condition)
#
# Get an evaluatable string throwing an exception unless the caller of the
# function or script evaluating such string satisfies:
#
# * The passed math condition, if standard input to such function or script is
#   not an open pipe. This is the common case.
# * The passed math condition with all integers implicitly decremented by one,
#   if standard input to such function or script is an open pipe. In such case,
#   assume the callee will prepend or append all piped input to the current
#   argument list as an additional argument.
function get_statement_dying_unless_standard_input_piped() {
    # Validate passed arguments.
    (( # == 1 )) || die 'expected one condition'
    local test_unless_piped="${1}" test_if_piped

    # Construct a condition in the case of piped input from the passed condition,
    # decrementing integers in such condition by one. Dismantled, this is:
    #
    # * "(#m)", capturing each match into string global ${MATCH}.
    # * "//", matching each...
    # * "<->", positive integer (i.e., a substring of one or more digits).
    # * "$(( ${MATCH} - 1 ))", replacing such integer by an integer one less.
    test_if_piped="${test_unless_piped//(#m)<->/$(( ${MATCH} - 1 ))}"

    # Return such command.
    print "if [[ -p /dev/stdin ]]; then (( ${test_if_piped} )); else (( ${test_unless_piped} )); fi || die"
}

# ....................{ EXCEPTIONS ~ exact                 }....................
# void die_if_args(void)
#
# Die with a canonical message if the caller passed any arguments.
alias die_if_args='(( # )) and die "expected no arguments"'

# void die_unless_args(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
alias die_unless_args="$(get_statement_dying_unless '#')"

# void die_unless_args_1(string error_message)
#
# Die with the passed message unless the caller passed exactly one argument.
alias die_unless_args_1="$(get_statement_dying_unless '# == 1')"

# void die_unless_args_2(string error_message)
#
# Die with the passed message unless the caller passed exactly two arguments.
alias die_unless_args_2="$(get_statement_dying_unless '# == 2')"

# void die_unless_args_3(string error_message)
#
# Die with the passed message unless the caller passed exactly three arguments.
alias die_unless_args_3="$(get_statement_dying_unless '# == 3')"

# void die_unless_args_4(string error_message)
#
# Die with the passed message unless the caller passed exactly four arguments.
alias die_unless_args_4="$(get_statement_dying_unless '# == 4')"

# ....................{ EXCEPTIONS ~ range                 }....................
# void die_unless_args_0_to_1(string error_message)
#
# Die with the passed message unless the caller passed at most one argument.
alias die_unless_args_0_to_1="$(get_statement_dying_unless '# <= 1')"

# void die_unless_args_0_to_2(string error_message)
#
# Die with the passed message unless the caller passed at most two arguments.
alias die_unless_args_0_to_2="$(get_statement_dying_unless '# <= 2')"

# void die_unless_args_0_to_3(string error_message)
#
# Die with the passed message unless the caller passed at most three arguments.
alias die_unless_args_0_to_3="$(get_statement_dying_unless '# <= 3')"

# void die_unless_args_0_to_4(string error_message)
#
# Die with the passed message unless the caller passed at most four arguments.
alias die_unless_args_0_to_4="$(get_statement_dying_unless '# <= 4')"

# void die_unless_args_1_to_2(string error_message)
#
# Die with the passed message unless the caller passed one or two arguments.
alias die_unless_args_1_to_2="$(get_statement_dying_unless '# == 1 || # == 2')"

# void die_unless_args_1_to_3(string error_message)
#
# Die with the passed message unless the caller passed one to three arguments.
alias die_unless_args_1_to_3="$(get_statement_dying_unless '# >= 1 && # <= 3')"

# void die_unless_args_1_to_4(string error_message)
#
# Die with the passed message unless the caller passed one to four arguments.
alias die_unless_args_1_to_4="$(get_statement_dying_unless '# >= 1 && # <= 4')"

# void die_unless_args_2_to_3(string error_message)
#
# Die with the passed message unless the caller passed two or three arguments.
alias die_unless_args_2_to_3="$(get_statement_dying_unless '# == 2 || # == 3')"

# void die_unless_args_3_to_4(string error_message)
#
# Die with the passed message unless the caller passed three or four arguments.
alias die_unless_args_3_to_4="$(get_statement_dying_unless '# == 3 || # == 4')"

# ....................{ EXCEPTIONS ~ lower                 }....................
# While we would prefer to embedd math operators in alias names (e.g.,
# "die_unless_args_>=_4"), current Zsh operators already reserve such operators.
# Instead, settle for descriptions of such operators.

#FIXME: Rename to die_unless_args_2_at_least() and similarly below.
# void die_unless_args_at_least_2(string error_message)
#
# Die with the passed message unless the caller passed at least two arguments.
alias die_unless_args_at_least_2="$(get_statement_dying_unless '# >= 2')"

# void die_unless_args_at_least_3(string error_message)
#
# Die with the passed message unless the caller passed at least three arguments.
alias die_unless_args_at_least_3="$(get_statement_dying_unless '# >= 3')"

# void die_unless_args_at_least_4(string error_message)
#
# Die with the passed message unless the caller passed at least four arguments.
alias die_unless_args_at_least_4="$(get_statement_dying_unless '# >= 4')"

# ....................{ EXCEPTIONS ~ pipe                  }....................
#FIXME: Rename to die_unless_args_2_or_1_if_standard_input_piped().
# void die_unless_args_2_unless_standard_input_piped(
#   string error_message)
#
# Die with the passed message unless the caller passed either:
#
# * Two arguments, if standard input is not an open pipe.
# * One argument, if standard input is an open pipe. In such a case, assume the
#   callee will prepend or append such input to the current argument list as an
#   additional argument.
alias die_unless_args_2_unless_standard_input_piped="$(\
    get_statement_dying_unless_standard_input_piped '# == 2')"

#FIXME: Rename to die_unless_args_2_to_3_or_1_to_2_if_standard_input_piped().
# void die_unless_args_2_to_3_unless_standard_input_piped(
#   string error_message)
#
# Die with the passed message unless the caller passed either:
#
# * Two or three arguments, if standard input is not an open pipe.
# * One or two arguments, if standard input is an open pipe. In such a case,
#   assume the callee will prepend or append such input to the current argument
#   list as an additional argument.
alias die_unless_args_2_to_3_unless_standard_input_piped="$(\
    get_statement_dying_unless_standard_input_piped '# == 2 || # == 3')"

# ....................{ TESTERS                            }....................
# boolean is_args(void)
#
# Return true if the caller passed at least one argument.
alias is_args='(( # ))'

# boolean is_args_0(void)
#
# Return true if the caller passed no arguments.
alias is_args_0='(( # == 0 ))'

# boolean is_args_0(void)
#
# Return true if the caller passed no or one arguments.
alias is_args_0_to_1='(( # <= 1 ))'

# boolean is_args_0_to_2(void)
#
# Return true if the caller passed at most two arguments.
alias is_args_0_to_2='(( # <= 2 ))'

# boolean is_args_0_to_3(void)
#
# Return true if the caller passed at most three arguments.
alias is_args_0_to_3='(( # <= 3 ))'

# boolean is_args_1(void)
#
# Return true if the caller passed exactly one argument.
alias is_args_1='(( # == 1 ))'

# boolean is_args_1_to_3(void)
#
# Return true if the caller passed between one to three arguments.
alias is_args_1_to_3='(( # >= 1 && # <= 3 ))'

# boolean is_args_2(void)
#
# Return true if the caller passed exactly two arguments.
alias is_args_2='(( # == 2 ))'

# boolean is_args_at_least_2(void)
#
# Return true if the caller passed at least two arguments.
alias is_args_at_least_2='(( # >= 2 ))'

# boolean is_args_at_least_3(void)
#
# Return true if the caller passed at least three arguments.
alias is_args_at_least_3='(( # >= 3 ))'

# ....................{ GETTERS                            }....................
# string get_args(void)
#
# Get the current argument list as a concatenated string.
alias get_args='print -r -- ${*}'

# ....................{ SETTERS                            }....................
# void set_args(string arg1, string arg2, ...)
#
# Replace the current argument list with the passed arguments.
alias set_args='set --'

#FIXME: Rename to append_arg().
# void append_args(string arg1, string arg2, ...)
#
# Append the passed arguments to the end of the current argument list.
alias append_args='set_args "${@}"'

# ....................{ SETTERS ~ pipe                     }....................
# void set_args_to_standard_input_if_piped(void)
#
# If standard input to the current function or script is an open pipe, replace
# the current argument list with such input.
alias set_args_to_standard_input_if_piped='
is_standard_input_piped and {
    set_args "$(< /dev/stdin)"
    close_standard_input
}'

# void prepend_args_with_standard_input_if_piped(void)
#
# If standard input to the current function or script is an open pipe, replace
# If the current function or script is piped input, prepend such input to the
# beginning of the current argument list.
alias prepend_args_with_standard_input_if_piped='
is_standard_input_piped and {
    set_args "$(< /dev/stdin)" "${@}"
    close_standard_input
}'

# void append_args_with_standard_input_if_piped(void)
#
# If the current function or script is piped input, append such input to the end
# of the current argument list.
alias append_args_with_standard_input_if_piped='
is_standard_input_piped and {
    set_args "${@}" "$(< /dev/stdin)"
    close_standard_input
}'

# ....................{ SHIFTERS                           }....................
# void shift_args(integer argument_count = 1)
#
# Remove the passed number of arguments (defaulting to 1) from the start of the
# current argument list.
alias shift_args='shift'

#FIXME: Rename to shift_arg(), shift_args_2(), and shift_args_3() respectively.
#Actually, the latter two are blatantly obsolete: just call "shift_args 2" and
#"shift_args 3" instead. Ah, wait -- for orthoganlity with pop_args_*() aliases,
#keep them.

# void shift_one_arg(void)
#
# Remove the first argument from the current argument list.
alias shift_one_arg='shift 1'

# void shift_two_args(void)
#
# Remove the first two arguments from the current argument list.
alias shift_two_args='shift 2'

# void shift_three_args(void)
#
# Remove the first three arguments from the current argument list.
alias shift_three_args='shift 3'

# ....................{ POPPERS                            }....................
#FIXME: Rename to pop_arg(), pop_args_2(), and pop_args_3(), respectively.

# void pop_one_arg(void)
#
# Remove the last argument from the current argument list.
alias pop_one_arg='set -- ${@[1,-2]}'
#alias pop_one_arg='@[-1]=()'

# void pop_two_args(void)
#
# Remove the last two arguments from the current argument list.
alias pop_two_args='set -- ${@[1,-3]}'

# void pop_three_args(void)
#
# Remove the last three arguments from the current argument list.
alias pop_three_args='set -- ${@[1,-4]}'

# ....................{ PARSERS                            }....................
# void parse_arg_options_helpfully(
#   string option_spec1, option_spec2, ...,
#   string help_message)
#
# Parse "-"-prefixed options from the current argument list according to the
# passed "zparseopts"-formatted options specifications into local map
# ${arg_options}. Remove parsed options from the current argument list but
# preserve all other arguments for subsequent parsing by the caller. Parse
# options "-h" and "--help" by printing the passed help message and returning
# from the caller function or script with zero exit status. If option parsing
# fails, print the passed help message but return non-zero exit status.
#
# Due to implementation constraints, option specifications and the help message
# *MUST* be passed in a shell word (e.g., single- or double-quoted string). See
# "info zsh[i][zparseopts]" for further details on option specifications: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --alive 42 "glass_arm.shattering"
#
#   # Parse such arguments.
#   >>> parse_arg_options_helpfully 'd e -ad -or: -alive:: "
#Usage: doa [OPTION]... [FILE]...
#
#Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.
#
#Options:
#  -h, --help          print this help text and exit
#  -d                  return non-zero exit status if such files fail to run
#  -e                  evaluate rather than run the passed files
#  --ad                switch from a Julian to Gregorian calendar
#  --or DEATHS         set the maximum number of DEATHS
#  --alive [LIVES]     set the starting number of LIVES (default: 3)
#"'
#
#   # Validate such parsing.
#   >>> output_string "option \"--alive\": ${arg_options[--alive]}"
#   option "--alive": 42
#   >>> is_map_key arg_options '-d' and print 'option "-d": enabled'
#   option "-d": enabled
alias parse_arg_options_helpfully='
map arg_options
{
    list __args__; set_list_to_standard_input_split_on_words __args__
    string __help_message__="${__args__[-1]}"
    pop_list_element __args__

    # Parse options under the passed (and canonical help) option specifications,
    # preserving unparsed options for subsequent parsing by the caller. If such
    # parsing fails, print the passed help text and return from the caller or
    # script with non-zero exit status. Dismantled, this is:
    #
    # * "-D", removing *ONLY* parsed options from the current argument list.
    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
    #   option specification, thus preserving all unspecified options.
    # * "-M", parsing "="-prefixed substrings in option specifications as the
    #   map key to parse such option into (e.g., "-help=h" parses long option
    #   "--help" into map key ${arg_options[-h]} rather than
    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
    #   target list or map name to parse such option into.
    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
    #   either the option values if passed or the empty string if not passed.
    zparseopts -M -D -E -A arg_options -- "${__args__[@]}" h -help=h or {
        outcry_string "${__help_message__}"
        return_false
    }

    # If passed a help option, ignore all other options, print the passed help
    # text, and return from the caller function or script.
    (( ${+arg_options[-h]} )) && {
        output_string "${__help_message__}"
        return_true
    }
} <<<'

# --------------------( WASTELANDS                         )--------------------
# void parse_arg_options(string arg_spec1, string arg_spec2, ...)
#
# Parse the current argument list according to the passed "zparseopts"-formatted
# argument specifications (e.g., "h", short option "-h" accepting no argument;
# "-count:", long option "--count" requiring a trailing argument) into local map
# ${arg_options}: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_arg_options d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key arg_options '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> output_string_escaped\
#   ...   "-d: ${arg_options[-d]}\n--ad: ${arg_options[--crest]}\n--wing: ${arg_options[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
#
# See "zparseopts" under "man zshmodules" for argument specification details.

# Dismantled, this is:
#
# * "-D", removing *ONLY* parsed options from the current argument list.
# * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
#   option specification (i.e., preserving options with no such specification).
# * "-A arg_options", parsing passed options into map ${options}. Map keys are
#   option names (e.g., "-c", "--iapropaganda") and map values are either the
#   option values if passed or the empty string if not passed.
#alias parse_arg_options='map arg_options; zparseopts -D -E -A arg_options --'

#FUXME: Rename to set_args_to_standard_input_if_piped(). Current nomenclature is
#unnecessarily absurdly heavy-weight. Fix-up below as well, please.
#alias is_at_least_one_arg=is_args
#FUXME: Not necessarily convinced spoken numbers rather than simple numbers are
#the right way to go, here. The former read rather clumsily (particularly in the
#case of "die_unless_args_0_to_1") and are certainly less concise. Consider:
#
# die_unless_0_arg()
# die_unless_1_arg()
# die_unless_2_args()
# die_unless_0_or_1_arg()
# die_unless_1_to_3_args()
#
#We could even take this a step further by prefixing with "_arg":
#
# die_unless_args_0()
# die_unless_args_1()
# die_unless_args_2()
# die_unless_args_0_to_1()
# die_unless_args_1_to_3()
#
#Yay; much better. Why? Because worrying about plurals is really unintelligent.
#Non-native speakers will have a hell of a time recalling whether its "1_arg" or
#"2_args", so just cut that word-hell off the pass by dispensing with such
#nonsense.

# ....................{ EXCEPTIONS ~ upper                 }....................
# void die_unless_args_at_least_1(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
#alias die_unless_args_at_least_1="$(get_statement_dying_unless '# >= 1')"
