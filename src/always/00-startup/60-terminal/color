#!/usr/bin/env zsh
# ====================[ color                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle ANSI- and zsh-specific color codes.
#
# --------------------( SEE ALSO                           )--------------------
# https://en.wikipedia.org/wiki/ANSI_escape_code
#   Excrutiatingly helpful dissection of ANSI escape codes.
#
# http://ciembor.github.com/4bit
#   4bit, arguably the best and probably only terminal color scheme designer.
#
# --------------------( TODO                               )--------------------
# * Add support for fish-like syntax highlighting. Happily, someone's already
#   gone to the work of Zshifying this; we'll just want to Zeshify it a bit:
#   https://github.com/zsh-users/zsh-syntax-highlighting
# * Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#   urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#   some Zsh code the other day simplifying such support... Hmmmmmmmm.
# * It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#   https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors

# ....................{ GLOBALS                            }....................
# Defer initialization of such colors to startup_zeshy_terminal_colors(), below.

#FIXME: Map ${ZESHY_ANSI_SGR} suggests we could profitably implement _FAINT and
#_STANDOUT versions, as well. Test us up! *YES*. Great: the "italic" attribute
#is implemented as italics under many terminals. We absolutely want that. :)

# Document reset colors.
document_global '
string ZESHY_COLOR_RESET

ANSI escape sequence resetting foreground and background colors to defaults.
'
document_global '
string ZESHY_PROMPT_COLOR_RESET

Prompt escape sequence resetting foreground and background colors to defaults.
'

# Document general purpose colors.
document_global '
map ZESHY_COLOR

Map from lowercase color name to ANSI escape sequence foregrounding such color.
'
document_global '
map ZESHY_COLOR_BOLD

Map from lowercase color name to ANSI escape sequence foregrounding such color
in "bold" (i.e., with bright emphasis).
'
document_global '
map ZESHY_COLOR_ITALIC

Map from lowercase color name to ANSI escape sequence foregrounding such color
in "italics" (i.e., slanted obliquely).
'
document_global '
map ZESHY_COLOR_BACKGROUND

Map from lowercase color name to ANSI escape sequence backgrounding such color.
'
document_global '
map ZESHY_COLOR_BOLD_BACKGROUND

Map from lowercase color name to ANSI escape sequence backgrounding such color
in "bold" (i.e., with bright emphasis).
'

# Document prompt-specific colors.
document_global '
map ZESHY_PROMPT_COLOR

Map from lowercase color name to prompt escape sequence foregrounding such color.
'
document_global '
map ZESHY_PROMPT_COLOR_BOLD

Map from lowercase color name to prompt escape sequence foregrounding such color
in "bold" (i.e., with bright emphasis).
'
document_global '
map ZESHY_PROMPT_COLOR_ITALIC

Map from lowercase color name to prompt escape sequence foregrounding such color
in "italics" (i.e., slanted obliquely).
'
document_global '
map ZESHY_PROMPT_COLOR_BACKGROUND

Map from lowercase color name to prompt escape sequence backgrounding such color.
'
document_global '
map ZESHY_PROMPT_COLOR_BOLD_BACKGROUND

Map from lowercase color name to prompt escape sequence backgrounding such color
in "bold" (i.e., with bright emphasis).
'

# ....................{ GLOBALS ~ ansi                     }....................
document_global '
map ZESHY_ANSI_SGR

Map from lowercase Select Graphics Rendition (SGR) ANSI name to value.
'
ZESHY_ANSI_SGR=(
    reset 00

    # Attribute enablers.
    bold      01
    faint     02
    italic    03
    underline 04
    blink     05
    reverse   07
    conceal   08
    normal    22

    # Attribute disablers.
    italic_off  23
    underline_off 24
    blink_off     25
    reverse_off   27
    conceal_off   28

    # Foreground colors.
    black   30
    red     31
    green   32
    yellow  33
    blue    34
    magenta 35
    cyan    36
    white   37
    default 39

    # Background colors.
    black_background   40
    red_background     41
    green_background   42
    yellow_background  43
    blue_background    44
    magenta_background 45
    cyan_background    46
    white_background   47
    default_background 49

    # Foreground high-intensity colors.
    black_intense   90
    red_intense     91
    green_intense   92
    yellow_intense  93
    blue_intense    94
    magenta_intense 95
    cyan_intense    96
    white_intense   97
    default_intense 99

    # Background high-intensity colors.
    black_intense_background   100
    red_intense_background     101
    green_intense_background   102
    yellow_intense_background  103
    blue_intense_background    104
    magenta_intense_background 105
    cyan_intense_background    106
    white_intense_background   107
    default_intense_background 109
)

document_global '
string ZESHY_ANSI_CSI

2-byte ANSI Control Sequence Introducer (CSI) prefixing all ANSI escape
sequences, equivalent to "<Esc>[".
'
ZESHY_ANSI_CSI=$'\E\['

document_global '
string ZESHY_ANSI_SGR_NEXT

1-byte ANSI Select Graphics Rendition (SGR) delimiter separating subsequences
in all graphics-specific ANSI escape sequences.
'
ZESHY_ANSI_SGR_NEXT=';'

document_global '
string ZESHY_ANSI_SGR_SUFFIX

1-byte ANSI Select Graphics Rendition (SGR) suffix for all graphics-specific
ANSI escape sequences.
'
ZESHY_ANSI_SGR_SUFFIX='m'

# ....................{ GLOBALS ~ glob                     }....................
# Unfortunately, zsh fails with a "bad pattern" error when aggregating the
# following CSI and SGR globs into a single glob. Separate such globs, for now.

document_global '
string ZESHY_ZSH_COLOR_GLOB

Glob matching color-specific Zsh prompt escapes. Dismantled, this is:

* "%(...)", matching a "%"-prefixed prompt escape.
* "[BbSsUu]", matching a bold, italic, or underline parameter.
* "[0-9]##[FfKk]", matching a fore- or background parameter prefixed by
  integer argument consisting of one or more digits.
* "[FfKk]\{?*\}", matching a fore- or background parameter suffixed by:
  * String argument consisting of a well-known color name (e.g., "red").
  * Integer argument consisting of one or more digits.
'
ZESHY_ZSH_COLOR_GLOB='%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'

document_global '
string ZESHY_ANSI_SGR_GLOB

Glob matching the 2-byte ANSI Select Graphic Rendition (SGR) prefixing all
color-specific ANSI escape codes. Dismantled, this is:

* (...)m", matching zero or more Select Graphic Rendition (SGR)
  parameters also referred to as color indices:
  * "|", matching the empty string and hence the ANSI escape code
    "CSI m" identical to "<Esc>[0m" resetting all SGR parameters.
  * "[0-9](#c1,3)", matching an 8-bit integer expressed as one to three
    digits as the first SGR parameter.
  * "(;[0-9](#c1,3))##", matching zero or more sequences of a semicolon
    followed by an 8-bit integer as all following SGR parameters.
'
ZESHY_ANSI_SGR_GLOB="(|[0-9](#c1,3)(${ZESHY_ANSI_SGR_NEXT}[0-9](#c1,3))##)${ZESHY_ANSI_SGR_SUFFIX}"

# ....................{ TESTERS                            }....................
document_function '
boolean is_terminal_color(void)

Return true if shell output is attached to a polychrome terminal device (i.e.,
a terminal device providing more than merely monochrome black and white).
'
function is_terminal_color() {
    die_if_args
    is_shell_interactive and (( $(get_terminal_color_count) > 2 ))
}

# ....................{ GETTERS                            }....................
document_function '
integer get_terminal_color_count(void)

Get the number of colors supported by the current terminal device.
'
function get_terminal_color_count() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Get such colors. Note "echotc Co" also works, but is somewhat overkill.
    print_string "${terminfo[colors]}"
}

# ....................{ REMOVERS                           }....................
document_function '
string remove_string_ansi_color_codes(string text)

Remove all ANSI color codes from the passed string. The resulting string will
retain non-color ANSI escapes (e.g., "\033[J", clearing from the current
cursor to the end of the screen).
'
function remove_string_ansi_color_codes() {
    die_unless_args 'expected at least one string'
    print_string\
        "${*//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}/}"
}

document_function '
string remove_string_zsh_color_codes(string text)

Remove all Zsh color codes from the passed string. The resulting string will
retain non-color prompt escapes (e.g., "%D", expanding to the current date).
'
function remove_string_zsh_color_codes() {
    die_unless_args 'expected at least one string'
    print_string "${*//${~ZESHY_ZSH_COLOR_GLOB}/}"
}

# ....................{ STARTUP                            }....................
append_command_to_zeshy_startup_if_shell_interactive\
    startup_zeshy_terminal_color

document_function '
void startup_zeshy_terminal_color(void)

Define color globals specific to the current terminal. If such terminal is
monochrome (i.e., colorless), such colors default to the empty string.
'
function startup_zeshy_terminal_color() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    #FIXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_no_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FIXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    startup_zeshy_terminal_color_8
}

document_function '
void startup_zeshy_terminal_color_8(void)

Define color globals for terminals supporting between 8 to 255 colors.
'
function startup_zeshy_terminal_color_8() {
    # Validate sanity.
    die_if_args
    die_unless_shell_interactive

    # Define reset globals.
    ZESHY_COLOR_RESET="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_PROMPT_COLOR_RESET="%{${ZESHY_COLOR_RESET}%}"

    # Normal and bold color attributes as ANSI escape sequences.
    string\
        ansi_normal="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_bold="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}"\
        ansi_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[reset]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[italic]}${ZESHY_ANSI_SGR_NEXT}"

    # Define foreground greyscale colors. The default definitions assign
    # ${ZESHY_COLOR_BLACK} a somewhat unreadable quasi-black color value and
    # ${ZESHY_COLOR_WHITE} a somewhat grey rather than white color value.
#   ZESHY_COLOR[black]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[normal]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[black_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
#   ZESHY_COLOR[grey]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"

    # List of all such color names, excluding pseudo-color "grey".
    list color_names
    color_names=( white black red green blue yellow magenta cyan )

    # Set general purpose colors.
    string color_background_name
    for color_name (${color_names[@]}) {
        color_background_name="${color_name}_background"
#       print "color (fg): ${color_name}\ncolor (bg): ${color_background_name}"
        ZESHY_COLOR[${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_BACKGROUND[${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR[${color_background_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_BOLD[${color_name}]="${ansi_bold}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]="${ansi_bold}${ZESHY_ANSI_SGR[${color_background_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
        ZESHY_COLOR_ITALIC[${color_name}]="${ansi_italic}${ZESHY_ANSI_SGR[${color_name}]}${ZESHY_ANSI_SGR_SUFFIX}"
    }

    # Default foreground greyscale colors are notoriously "off," assigning
    # ${ZESHY_COLOR[white]} a grey rather than white color and defining no
    # corresponding suite of grey colors. To correct this:
    #
    # * Assign ${ZESHY_COLOR[white]} to new color ${ZESHY_COLOR_BOLD[grey]}.
    # * Assign bold black to all other foreground grey colors.
    # * Assign white and bold black to corresponding background grey colors.
    ZESHY_COLOR[white]="${ansi_normal}${ZESHY_ANSI_SGR[white_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR[grey]="${ansi_bold}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_BOLD[grey]="${ansi_normal}${ZESHY_ANSI_SGR[white]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_ITALIC[grey]="${ansi_bold_italic}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_BACKGROUND[grey]="${ansi_normal}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"
    ZESHY_COLOR_BOLD_BACKGROUND[grey]="${ansi_bold}${ZESHY_ANSI_SGR[white_background]}${ZESHY_ANSI_SGR_SUFFIX}"

    # Set prompt-specific colors, "%{"- and "%}"-delimited in to indicate
    # such colors do not contribute to prompt length.
    for color_name (${color_names[@]} grey) {
        ZESHY_PROMPT_COLOR[${color_name}]="%{${ZESHY_COLOR[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BACKGROUND[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_BOLD[${color_name}]="%{${ZESHY_COLOR_BOLD[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_BOLD_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]}%}"
        ZESHY_PROMPT_COLOR_ITALIC[${color_name}]="%{${ZESHY_COLOR_ITALIC[${color_name}]}%}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Actually, the default black value should be fine. We certainly
    #shouldn't discard it as we do here! Everything else is probably O.K., but
    #"black" really needs to be looked at.
    #FUXME: We use a high-intensity color here, which
    #https://en.wikipedia.org/wiki/ANSI_escape_code suggests to be non-standard.
    #Attempt to substitute with the standard bold attribute, instead.

#   ZESHY_COLOR_BOLD[grey]="${ansi_bold}${ZESHY_ANSI_SGR[black_intense]}${ZESHY_ANSI_SGR_SUFFIX}"
#   ZESHY_COLOR_BOLD[grey]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR[bold]}${ZESHY_ANSI_SGR_NEXT}${ZESHY_ANSI_SGR[black]}${ZESHY_ANSI_SGR_SUFFIX}"
#       (( ${+ZESHY_COLOR[${color_name}]} )) or
#       (( ${+ZESHY_COLOR_BACKGROUND[${color_name}]} )) or
#       (( ${+ZESHY_COLOR_BOLD[${color_name}]} )) or
#       (( ${+ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]} )) or
#   typeset -p ZESHY_COLOR
#   print_string "declared foreground non-bold colors: ${ZESHY_COLOR[*]}"
#   typeset -gAx ZESHY_COLOR
    #FUXME: Heavyweight zsh script. When time affords, shift such functionality
    #into Zeshy. The less we depend on exogenous zsh scripts, the better to all!
    #Right. I've manually verified "colors" to be a verify short script
    #effectively consisting of only a long series of global variable
    #definitions. Let's a-go!

    # Declare color-specific dictionaries: $fg, $fg_bold, $fg_no_bold, $bg,
    # $bg_bold, and $bg_no_bold. In each such dictionary, keys are color
    # names (e.g., "red") and values terminal-specific strings activating that
    # color combination under the current output.
#   colors

#           ZESHY_COLOR[${color_name}]="${fg_no_bold[${color_name}]}"
#       (( ${+ZESHY_COLOR_BACKGROUND[${color_name}]} )) or
#           ZESHY_COLOR_BACKGROUND[${color_name}]="${bg_no_bold[${color_name}]}"
#       (( ${+ZESHY_COLOR_BOLD[${color_name}]} )) or
#           ZESHY_COLOR_BOLD[${color_name}]="${fg_bold[${color_name}]}"
#       (( ${+ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]} )) or
#           ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]="${bg_bold[${color_name}]}"

    #FUXME: Declare and document (but do not define) such globals at the top-
    #level. Incidentally, "${reset_color}" is defined by colors() above.

    # Define hard-coded ANSI color codes for use below.
#   integer_global_export ansi_black=0 ansi_white=7 ansi_intense=9

    # Define reset "colors" (i.e., resetting colors to their defaults).
#   string_global_export\
#       ZESHY_COLOR_RESET="%{${reset_color}%}"\
#       ZESHY_COLOR_RESET_BACKGROUND="%{${reset_color}%}"

#FUXME: What is this? It isn't "bold" and doesn't correspond to anything in
#zsh's "colors" script.
#integer_global_export ZESHY_ANSI_COLOR_INTENSE=9

# Define hard-coded ANSI color codes for use below.
#${ZESHY_COLOR_RESET}
#FUXME: Declare globally at the topmost level.
#   ZESHY_COLOR_WHITE_BOLD="%{${fg_bold[white]}%}"
#   ZESHY_COLOR_GREY_BOLD="%{${fg_bold[black]}%}"
    # Surround each color definition in "%{...%}"; this informs ZSH that, when
    # performing prompt expansion, these strings do not contribute to the length
    # of that prompt.
#   string color_name_lowercase
#       color_name_lowercase="$(lowercase_string "${color_name}")"

# For each of the eight customary terminal colors, declare and document four
# global variables for such color.
#() {
    # Declare and document foreground colors, including pseudo-color "GREY".
#    string color_name_capitalized
#    for color_name (${ZESHY_COLOR_NAMES[@]} GREY) {
#        color_name_capitalized="${(C)color_name}"
#        document_global "
#string ZESHY_COLOR_${color_name}
#
#${color_name_capitalized} foreground color as a ANSI escape sequence.
#"
#        document_global "
#string ZESHY_COLOR_${color_name}_BOLD
#
#${color_name_capitalized} foreground bold color as a ANSI escape sequence.
#"
#        document_global "
#string ZESHY_PROMPT_COLOR_${color_name}
#
#${color_name_capitalized} foreground color as a ANSI prompt escape sequence.
#"
#        document_global "
#string ZESHY_PROMPT_COLOR_${color_name}_BOLD
#
#${color_name_capitalized} foreground bold color as a ANSI prompt escape sequence.
#"
#    }
#
#    # Declare and document background colors, omitting pseudo-color "GREY" (for
#    # which there exist no background colors suitable).
#    for color_name (${ZESHY_COLOR_NAMES[@]}) {
#        document_global "
#string ZESHY_COLOR_${color_name}_BACKGROUND
#
#${color_name_capitalized} background color as a ANSI escape sequence.
#"
#        document_global "
#string ZESHY_COLOR_${color_name}_BOLD_BACKGROUND
#
#${color_name_capitalized} background bold color as a ANSI escape sequence.
#"
#        document_global "
#string ZESHY_PROMPT_COLOR_${color_name}_BACKGROUND
#
#${color_name_capitalized} background color as a ANSI prompt escape sequence.
#"
#        document_global "
#string ZESHY_PROMPT_COLOR_${color_name}_BOLD_BACKGROUND
#
#${color_name_capitalized} background bold color as a ANSI prompt escape sequence.
#"
#    }
#   for color_name (${ZESHY_COLOR_NAMES[@]}) {

#document_function '
#void startup_zeshy_terminal_color_prompt(void)
#
#Define prompt-specific color globals for the current terminal.
#'
#function startup_zeshy_terminal_color_prompt() {
#    # Validate sanity.
#    die_if_args
#    die_unless_shell_interactive
#
#    # Embed each color definition in "%{...%}", notifying ZSH that such strings
#    # do not contribute to prompt length when interpolated in prompts.
#    string global_name
#    for color_name (${ZESHY_COLOR_NAMES[@]} GREY) {
#        global_name="ZESHY_COLOR_${color_name}"
#        set_string ZESHY_PROMPT_COLOR_${color_name} "${(P)global_name}"
#    }
#}

#   ZESHY_COLOR_BLACK="${ZESHY_COLOR_RESET}%{"$'\033['"${ansi_intense}${ansi_black}m%}"
#   ZESHY_COLOR_WHITE="${ZESHY_COLOR_RESET}%{"$'\033['"${ansi_intense}${ansi_white}m%}"
    # Note: the substring "$'\033['" cannot be interpolated into the prior
    # and subsequent strings as "\$\033[". (We can't recall why; do you?)
    # List of all such color names.
#   string color_names='WHITE BLACK RED GREEN BLUE YELLOW MAGENTA CYAN'
#   for color_name (${color_names} GREY) {
#   list color_names

#       WHITE BLACK RED GREEN BLUE YELLOW MAGENTA CYAN) {
#FUXME: Fairly certain we never define ${ZESHY_GREY_*BACKGROUND}, yes? Avoid
#defining or documenting such globals, if so.

#are left undefined and hence expand without error to the  when evaluated in the context of an actual prompt
#   is_terminal_color or return_true
#   get_terminal_color_count
        #FUXME: For simplicity (and revisabality), declare such globals at the
        #outermost in a similar for loop.
#Incorrect. If not a terminal, we still need to define such globals
    #to the empty string, to simplify use elsewhere. (The caller shouldn't have
    #to care, in other words.) 
#string_global_export\
    #ZESHY_COLOR_WHITE ZESHY_COLOR_WHITE_BOLD\
    #ZESHY_COLOR_WHITE_BACKGROUND ZESHY_COLOR_WHITE_BOLD_BACKGROUND\

#Terminal-specific ANSI sequence for white foreground color.
#FUXME: It'd be nice to avoid having to startup colors. I wonder if, rather than
#requiring startup_terminal_colors() be called on startup, we couldn't switch to
#expanding colors by calling color-named functions: e.g., "$(ZESHY_COLOR_WHITE_BOLD)", or
#perhaps "$(fg white bold)" or "$(get_foreground_bold_color white)". In any
#case, such functions initialize internal color structures if necessary and
#proceed on their way. This is inherently more robust, since of course nothing
#precludes users from setting "ZESHY_COLOR_WHITE_BOLD='nonsense!!!!uhoh%P%YYDYDYD%D'"
#externally, at the moment. Yes, I rather like the
#"$(get_foreground_bold_color white)" idea. Make it so, good sir! If efficiency
#actually mattered, such verbosity would be a poor idea. But it absolutely
#doesn't, so...
#FUXME: Or rather "$(get_color_bold_foreground white)".
#string_global_export ZESHY_COLOR_WHITE_FOREGROUND
#   is_standard_output_terminal and (( $(get_terminal_color_count) > 2 ))
        #FUXME: All such globals should be previously declared at the outermost
        #level. Cease defining such globals under an "eval"; use a newly defined
        #set_string() function resembling the current set_integer().
#       eval "string_global\
#           ZESHY_COLOR_${color_name}='%{${fg_no_bold[${color_name_lowercase_string}]}%}'\
#           ZESHY_COLOR_${color_name}_BOLD='%{${fg_bold[${color_name_lowercase_string}]}%}'\
#           BG_${color_name}='%{${bg_no_bold[${color_name_lowercase_string}]}%}'\
#           BG_${color_name}_BOLD='%{${bg_bold[${color_name_lowercase_string}]}%}'"

#           eval string_global_export ZESHY_COLOR_${color_name}='%{$fg_no_bold[${(L)color_name}]%}'
#           eval string_global_export ZESHY_COLOR_${color_name}_BOLD='%{$fg_bold[${(L)color_name}]%}'
#           eval string_global_export BG_${color_name}='%{$bg_no_bold[${(L)color_name}]%}'
#           eval string_global_export BG_${color_name}_BOLD='%{$bg_bold[${(L)color_name}]%}'
#   string_global_export  LS_COLORS
#   is_string_nonempty "${LS_COLORS}" or {

# Globs matching the 2-byte ANSI Control Sequence Introducer (CSI) and Select
# Graphic Rendition (SGR), respectively. Dismantled, this is:
#
# * $'\E\[', matching the 2-byte ANSI Control Sequence Introducer (CSI)
#   identical to "<Esc>[" signifying an ANSI escape code.
# * (...)m", matching zero or more Select Graphic Rendition (SGR)
#   parameters also referred to as color indices:
#   * "|", matching the empty string and hence the ANSI escape code
#     "CSI m" identical to "<Esc>[0m" resetting all SGR parameters.
#   * "[0-9](#c1,3)", matching an 8-bit integer expressed as one to three
#     digits as the first SGR parameter.
#   * "(;[0-9](#c1,3))##", matching zero or more sequences of a semicolon
#     followed by an 8-bit integer as all following SGR parameters.
#
# Unfortunately, Zsh fails with a "bad pattern" error when we aggregate the
# CSI and SGR into a single glob. Separate such globs until solving this.
    # Colorize "ls" by importing the ${LS_COLORS} global.
#   is_pathable dircolors and run_under_shell "$(dircolors --sh)" 'sh'
#       source_shell_script_command_output 'sh' 'dircolors --sh'
# void startup_terminal_color_globs()
#
# Define globs for matching color codes in various formats.
#function startup_terminal_color_globs() {
# ....................{ GETTERS ~ globs                    }....................
# string get_ansi_color_code_glob(void)
#
# Get an extended glob matching ANSI color codes.
#get_ansi_color_code_glob() {
#    die_if_args
#    print_string '\x1B\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#}

# string get_zsh_color_code_glob(void)
#
# Get an extended glob matching Zsh color codes. See "Prompt Expansion" under
# "info zsh" for further details.
#get_zsh_color_code_glob() {
#    die_if_args
#    print_string '%([BbSsUu]|[0-9]##[FfKk]|[FfKk]\{?*\})'
#}

#   string ansi_color_code_glob
#   ansi_color_code_glob="$(get_ansi_color_code_glob)"
#   string test="$'\E\['(|[0-9](#c1,3)(;[0-9](#c1,3))##)m"
#   string test="$'\E\['"
#   print_string "glob: $test"
#   print_string "${*//${~ZESHY_ANSI_COLOR_CODE_GLOB}/}"
#   print_string "${*//$'\E\[((|[0-9](#c1,3)(;[0-9](#c1,3))##)m'/}"
#   print_string "${*//$'\E\['(|[0-9](#c1,3)(;[0-9](#c1,3))##)m/}"
#   print_string "${*//$'\E'/}"
#   string_global_export ZESHY_ANSI_SGR_GLOB='(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB='\x1B\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB='\033\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB="\$'\E'"'\[(|[0-9](#c1,3)(;[0-9](#c1,3))##)m'
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB=$'\E\['"(|[0-9](#c1,3)(;[0-9](#c1,3))##)m"
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB="\\033"
#   string_global_export ZESHY_ANSI_COLOR_CODE_GLOB="\E"
    # Cache the ANSI color glob to a global variable, if not already cached.
#   set_string_if_unset_or_empty_to_evaluation\
#       ZESHY_ANSI_COLOR_CODE_GLOB '$(get_ansi_color_code_glob)'
    # Cache the ZSH color glob to a global variable, if not already cached.
#   set_string_if_unset_or_empty_to_evaluation\
#       ZESHY_ZSH_COLOR_GLOB '$(get_ansi_color_code_glob)'
#   noop "${ZESHY_ZSH_COLOR_GLOB=$(get_zsh_color_code_glob)}"
#   print_string "${1//${~ZESHY_ANSI_COLOR_CODE_GLOB}}"
#   print_string "${1//${~ZESHY_ZSH_COLOR_GLOB}}"

#FIXME: Such globs are unlikely to change during runtime. (What would that even
#mean?) They should be cached to global variables for efficiency.
#   string glob; glob="$(get_ansi_color_code_glob)"
#   print_string "${1//${~glob}}"
#   string glob; glob="$(get_zsh_color_code_glob)"
#   print_string "${1//${~glob}}"
# ....................{ GETTERS ~ lines                    }....................
#FIXME: Shift to Zeshy String.
#get_string_line_length_excluding_zsh_color_codes() {
    #FIXME: Raise exception if the passed string contains a newline. We should
    #probably extricate the core logic into a separate remove_zsh_color_codes().
#    die_unless_arg 'expected one string'
#    string glob; glob="$(get_zsh_color_code_glob)"
#    print_string ${#${(S%%)1//${~glob}}
#}

#   print_string "${1//\x1B\[([0-9](#c1,2)(;[0-9](#c1,2))(#c0,1))(#c0,1)m}"
#   print_string "${1//\x1B\[([0-9](#c1,2)(;[0-9](#c1,2))(#c0,1))(#c0,1)[m|K]}"
# least the eight customary shell colors: black, white, red, green, blue,
# yellow, magenta, and cyan.
    # Do not call die_unless_standard_output_terminal(), as subshells have no terminals.
    # Do not call die_unless_standard_output_terminal(), as subshells have no terminals.
# Avoid calling this function from a subshell (e.g.,
# "$(is_standard_output_terminal and print ok)"), as subshells cannot test the file descriptors
# of their parent shells.    #* startup_terminal_colors_to_monochrome(), if no color support.

    #* startup_terminal_colors_to_8_color_polychrome(), if typical color support.
    #* startup_terminal_colors_to_256_color_polychrome(), if 256 color support.
    # Exit status of this command.
#   string output; output="$(run "${(q)@}" 1>&1 1>&2)" or exit_status=${?}
#   integer exit_status="${?}"
#   string output="$(eval "${(q)@}" 1>&1 1>&2)"
#   string output="$((eval "${@}") 1>&1 1>&2)"
#   say "running: ${*}"
#   say "output: ${output}"
#   msay 'line_length: '; printeger $(get_string_line_length "${output}")
#   say "terminal_height: $(get_terminal_height)"

    # Return the exit status of this command.
#   false
#   say "running: ${*}"
#   return "${exit_status}"

#FIXME: We currently define the "LESS" global (probably in "zshrc"), defining
#global "less" options. Shift to Zeshy "config", renamed to
#"ZESHY_PAGER_OPTIONS", and explicitly apply such global below. (We don't need
#interactive and non-interactive forms, obviously -- it's always interactive!)

        #FIXME: Ugh. This should just go into "ZESHY_PAGER_OPTIONS", clearly.
        # If "less" is the current pager, pass the following options:
        #
        # * "--no-init", avoiding clearing the screen on initialization.
#       if is "${PAGER}" == less si
#       then pager+=( '--no-init' )
#       fi

#   string output="$(run_redirecting_to_standard_output "${@}")"
#   say "output: ${output}"
    # Otherwise, printeger as is.
#   else
#       printeger "${output}" 
#   fi

#   printeger "page command line: ${*}"
#   printeger "page second arg: ${2}"
#   run "${(q)@} 2>&1 | '${PAGER:-less}'"

# string is_input_character_y_or_Y_asked(string question, string choices = 'yn', string true_answer = 'y')
#
# Ask the user an interactive yes or no question suffixed by the passed choices,
# returning false unless the user responds with exactly the passed true answer.
#is_input_character_y_or_Y_asked() {
#    die_unless_args 'expected exactly one question'
#
#    string question="${1}"
#    string choices="${2:-yn}"
#    string true_answer="${3:-y}"
#
#    # Sow the question and harvest the response.
#    msay "${question} [${choices}] "
#    string answer
#
#    # If the caller requests the default choices, read exactly one 
#    read   answer
#    is "${answer}" == "${true_answer}" si
#} 

#emulate -R sh -c 'eval "$(dircolors --sh)"'
# Dismantled, this is:
        # * "(L}", lowercasing the current color name. The maps colors() defines
        #   have lowercase_string rather than uppercase_string keys.

    # Coerce the response to lowercase_string for comparability and compare.
#   is_sure="$(lowercase_string "${is_sure}")"
#   is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si
#
    # Define ANSI colors for the ANSI shell prompt, below.
    #export   PROMPT_BLACK="%{"$'\033[${ZESHY_COLOR_BLACK_HIGH}m'"%}"
    #export    PROMPT_GREY="%{"$'\033[${ZESHY_COLOR_BLACK}m'"%}"
    #export     PROMPT_RED="%{"$'\033[${ZESHY_COLOR_RED_HIGH}m'"%}"
    #export   PROMPT_GREEN="%{"$'\033[${ZESHY_COLOR_GREEN_HIGH}m'"%}"
    #export  PROMPT_YELLOW="%{"$'\033[${ZESHY_COLOR_YELLOW_HIGH}m'"%}"
    #export    PROMPT_BLUE="%{"$'\033[${ZESHY_COLOR_BLUE_HIGH}m'"%}"
    #export PROMPT_MAGENTA="%{"$'\033[${ZESHY_COLOR_MAGENTA_HIGH}m'"%}"
    #export    PROMPT_CYAN="%{"$'\033[${ZESHY_COLOR_CYAN_HIGH}m'"%}"
    #export   PROMPT_WHITE="%{"$'\033[${ZESHY_COLOR_WHITE}m'"%}"

    # Define ANSI colors for "print" and "echo" uses, below.
    #export   BLACK="\e[${ZESHY_COLOR_BLACK_HIGH}m"
    #export     RED="\e[${ZESHY_COLOR_RED_HIGH}m"
    #export   GREEN="\e[${ZESHY_COLOR_GREEN_HIGH}m"
    #export  YELLOW="\e[${ZESHY_COLOR_YELLOW_HIGH}m"
    #export    BLUE="\e[${ZESHY_COLOR_BLUE}m"
    #export MAGENTA="\e[${ZESHY_COLOR_MAGENTA_HIGH}m"
    #export    CYAN="\e[${ZESHY_COLOR_CYAN}m"
    #export   WHITE="\e[${ZESHY_COLOR_WHITE}m"
    #export    BOLD="\e[${INTENSITY_BOLD};${ZESHY_COLOR_RESET}m"
    #export  NORMAL="\e[${INTENSITY_NORMAL};${ZESHY_COLOR_RESET}m"
    #export   RESET="\e[${ZESHY_COLOR_RESET}m"
# ....................{ STREAMS                            }....................
# Load the "colors" module. This defines the function "colors" that, when
# called, itself defines in excess of six associative arrays: $fg, $fg_bold,
# $fg_no_bold, $bg, $bg_bold, and $bg_no_bold. Each array, when indexed by
# color name (e.g., $bg_bold{red}), further expands to the terminal-specific
# string activating that color combination under the current output.
#autoload -U colors

#FIXME: Causes the "su" command to fail to print_string its data. Hm; obviously, this
#is a flawed approach. Research alternatives.
# Color all debug, warning, and error print_string for all processes: in particular,
# color all print_string sent by each process to the process-specific stderr "file".
#exec 2>>(\
#    while read LINE; do \
#        printeger -P "${ZESHY_COLOR_RED_BOLD}${(q)LINE}${ZESHY_COLOR_RESET}" > '/dev/tty'; \
#        printeger -n $'\0'; \
#    done &)

# ....................{ COLORS                             }....................
# See "http://en.wikipedia.org/wiki/ANSI_escape_code", for further details.

# Color bases.
#  BASE_BLACK="0"
#  ZESHY_COLOR_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${ZESHY_COLOR_BLACK_HIGH}m'"%}"
#    BASE_RED="1"
#  BASE_GREEN="2"
# BASE_YELLOW="3"
#   BASE_BLUE="4"
#BASE_MAGENTA="5"
#   BASE_CYAN="6"
#  BASE_WHITE="7"
#  BASE_RESET="9"

# Color foregrounds.
#  ZESHY_COLOR_BLACK="3${BASE_BLACK}"
#    ZESHY_COLOR_RED="3${BASE_RED}"
#  ZESHY_COLOR_GREEN="3${BASE_GREEN}"
# ZESHY_COLOR_YELLOW="3${BASE_YELLOW}"
#   ZESHY_COLOR_BLUE="3${BASE_BLUE}"
#ZESHY_COLOR_MAGENTA="3${BASE_MAGENTA}"
#   ZESHY_COLOR_CYAN="3${BASE_CYAN}"
#  ZESHY_COLOR_WHITE="3${BASE_WHITE}"
#  ZESHY_COLOR_RESET="3${BASE_RESET}"

# Color backgrounds.
#  BG_BLACK="4${BASE_BLACK}"
#    BG_RED="4${BASE_RED}"
#  BG_GREEN="4${BASE_GREEN}"
# BG_YELLOW="4${BASE_YELLOW}"
#   BG_BLUE="4${BASE_BLUE}"
#BG_MAGENTA="4${BASE_MAGENTA}"
#   BG_CYAN="4${BASE_CYAN}"
#  BG_WHITE="4${BASE_WHITE}"
#  BG_RESET="4${BASE_RESET}"

# Color foregrounds (high intensity).
#  ZESHY_COLOR_BLACK_HIGH="9${BASE_BLACK}"
#  PROMPT_BLACK="%{"$'\033[${ZESHY_COLOR_BLACK_HIGH}m'"%}"
#    ZESHY_COLOR_RED_HIGH="9${BASE_RED}"
#  ZESHY_COLOR_GREEN_HIGH="9${BASE_GREEN}"
# ZESHY_COLOR_YELLOW_HIGH="9${BASE_YELLOW}"
#   ZESHY_COLOR_BLUE_HIGH="9${BASE_BLUE}"
#ZESHY_COLOR_MAGENTA_HIGH="9${BASE_MAGENTA}"
#   ZESHY_COLOR_CYAN_HIGH="9${BASE_CYAN}"
#  ZESHY_COLOR_WHITE_HIGH="9${BASE_WHITE}"
#  ZESHY_COLOR_RESET_HIGH="9${BASE_RESET}"

# Color backgrounds (high intensity).
#  BG_BLACK_HIGH="10${BASE_BLACK}"
#    BG_RED_HIGH="10${BASE_RED}"
#  BG_GREEN_HIGH="10${BASE_GREEN}"
# BG_YELLOW_HIGH="10${BASE_YELLOW}"
#   BG_BLUE_HIGH="10${BASE_BLUE}"
#BG_MAGENTA_HIGH="10${BASE_MAGENTA}"
#   BG_CYAN_HIGH="10${BASE_CYAN}"
#  BG_WHITE_HIGH="10${BASE_WHITE}"
#  BG_RESET_HIGH="10${BASE_RESET}"

# Color attributes.
#           RESET="00"
#INTENSITY_NORMAL="22"
#  INTENSITY_BOLD="01"
# INTENSITY_FAINT="02"
#       ITALIC_ON="03"
#UNDERLINE_SINGLE="04"
#UNDERLINE_DOUBLE="21"
#   UNDERLINE_OFF="24"
#      BLINK_SLOW="05"
#      BLINK_FAST="06"
#       BLINK_OFF="25"
#  IMAGE_NEGATIVE="07"  # inverse (reverse), swapping foreground and background
#  IMAGE_POSITIVE="27"
#         CONCEAL="08"
#          REVEAL="28"

# Define (but do not export) ANSI colors for the ANSI shell prompt, below.
#  PROMPT_BLACK="%{"$'\033[${ZESHY_COLOR_BLACK_HIGH}m'"%}"
#    PROMPT_RED="%{"$'\033[${ZESHY_COLOR_RED_HIGH}m'"%}"
#  PROMPT_GREEN="%{"$'\033[${ZESHY_COLOR_GREEN_HIGH}m'"%}"
# PROMPT_YELLOW="%{"$'\033[${ZESHY_COLOR_YELLOW_HIGH}m'"%}"
#   PROMPT_BLUE="%{"$'\033[${ZESHY_COLOR_BLUE}m'"%}"
#PROMPT_MAGENTA="%{"$'\033[${ZESHY_COLOR_MAGENTA_HIGH}m'"%}"
#   PROMPT_CYAN="%{"$'\033[${ZESHY_COLOR_CYAN_HIGH}m'"%}"
#  PROMPT_WHITE="%{"$'\033[${ZESHY_COLOR_WHITE}m'"%}"

# Define (but do not export) ANSI colors for "print" and "echo" uses, below.
#  BLACK="\e[${ZESHY_COLOR_BLACK_HIGH}m"
#    RED="\e[${ZESHY_COLOR_RED_HIGH}m"
#  GREEN="\e[${ZESHY_COLOR_GREEN_HIGH}m"
# YELLOW="\e[${ZESHY_COLOR_YELLOW_HIGH}m"
#   BLUE="\e[${ZESHY_COLOR_BLUE}m"
#MAGENTA="\e[${ZESHY_COLOR_MAGENTA_HIGH}m"
#   CYAN="\e[${ZESHY_COLOR_CYAN_HIGH}m"
#  WHITE="\e[${ZESHY_COLOR_WHITE}m"
#   BOLD="\e[${INTENSITY_BOLD};${ZESHY_COLOR_RESET}m"
# NORMAL="\e[${INTENSITY_NORMAL};${ZESHY_COLOR_RESET}m"
#  RESET="\e[${ZESHY_COLOR_RESET}m"
