#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle path access, change, and modification times.
-/-

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
float get_path_time_for_format(string pathname, character format)

Get the time (in high-resolution fractional seconds since the Unix epoch) for
the passed path corresponding to the passed format character, which must be one
of the following:

* `x`, obtaining such path's access time.
* `y`, obtaining such path's modification time.
* `z`, obtaining such path's change time.

Such characters are `stat`-specific format specifiers. See `man stat` for
further details.

Such time is typically accurate to the nanosecond (!). See get_time() for
further details: e.g.,

.get_path_time_for_format()
==========================================
[source]
------------------------------------------
>>> set_path_mtime           /the/sound/of/perseverance 134664317.620900507
>>> get_path_time_for_format /the/sound/of/perseverance 'y'
134664317.620900507
------------------------------------------
==========================================
/---
#FIXME: Such implementation is Linux-specific. The BSD version actually
#implicitly supports floating point times, which is quite a bit better than the
#situation on Linux. See:
#    https://developer.apple.com/library/mac/#documentation/Darwin/Reference/Manpages/man1/stat.1.html
#I really can't be bothered to implement support at the moment, but there it
#is. Hopefully, by the time this becomes a concern, zsh implements builtin
#zstat() support for high resolution times. :)

# Sadly, zsh's zstat() fails to support retrieval of high-resolution file times,
# even under systems recording such times (e.g., post-2.6 Linux kernels). Until
# such support is added, retrieve such times by cobbling together the expected
# fractional Unix time from the output of the GNU-specific "stat"
# implementation: e.g.,
#
#     # Print the current modification time for standard output in both human-
#     # and machine-readable format, delimited by "~~~". Note that the former
#     # provides the desired fractional portion and the latter the desired
#     # integer portion. Grafting the two together yields the expected time:
#     # 1369265941.436503138.
#     >>> stat --dereference --printf '%y~~~%Y' /dev/fd/1
#     2013-05-22 19:39:01.436503138 -0400~~~1369265941
#
# If the current "stat" implementation is non-GNU, retrieve the typical low-
# resolution file times. (Technically, we could add support for the BSD-specific
# "stat" implementation, but it hardly seems worth it. zsh's zstat() *SHOULD*
# add support for higher resolution by the time this becomes a larger concern.)
if { is_pathable_gnu stat } {
    function get_path_time_for_format() {
        # Validate sanity.
        die_unless_args_2 'expected one pathname and one format'
        string pathname="${1}" format="${2}"
        is "${format}" == [xyz] si or
            die "format \"${format}\" neither \"x\", \"y\", or \"z\""

        # If "stat" formats such time in the customary English format
        # "AA:BB:CC.DD", capture the "."-prefixed substring of digits as the
        # desired number of nanoseconds. Dismantled, this is:
        #
        # * "%${format}", printing such time in locale-dependent format.
        # * "%${(U)format}", printing such time in seconds since the Unix epoch.
        # * "(#b)", capturing all subsequent match groups.
        # * "('.'[[:digit:]]##)", capturing nanoseconds to ${match[1]}.
        # * "([[:digit:]]##)", capturing seconds to ${match[2]}.
        if is "$(command stat --dereference --printf "%${format}~~~%${(U)format}" -- "${pathname}")" ==\
            *([[:digit:]][[:digit:]]':')([[:digit:]][[:digit:]]':')([[:digit:]][[:digit:]])(#b)('.'[[:digit:]]##)*'~~~'([[:digit:]]##) si {
            return_string "${match[2]}${match[1]}"
        # Else, "stat" formats such time in another locale-dependent format.
        # Devolve to returning only the desired number of seconds.
        } else {
            command stat --dereference --printf "%${(U)format}" -- "${pathname}"
        }
    }
} else {
    function get_path_time_for_format() {
        # Validate sanity.
        die_unless_args_2 'expected one pathname and one format'
        string pathname="${1}" format="${2}"

        case "${format}" {
        x) zstat +atime -- "${pathname}";;
        y) zstat +mtime -- "${pathname}";;
        z) zstat +ctime -- "${pathname}";;
        *) die "format \"${format}\" neither \"x\", \"y\", or \"z\"";;
        }
    }
}

# ....................{ GETTERS ~ mtime                    }....................
declare_function_with_stdin <<'/---'
float get_path_mtime(string pathname)

Get the *mtime* (i.e., modification time) of the passed path in high-resolution
fractional seconds since the Unix epoch. By POSIX mandate, this is the
most recent time from the following list:

* Such path's creation.
* The most recent change to such path's permissions.
* The most recent change to such path's content. If such path is a:
** File, this is the most recent change to such file's content.
** Directory, this is the most recent creation, deletion, or renaming (but
   not change to permissions or content) of a file or subdirectory in such
   directory.

Such time is typically accurate to the nanosecond. See get_time() for further
details: e.g.,

.get_path_mtime()
==========================================
[source]
------------------------------------------
>>> set_path_mtime /scavenger/of/human/sorrow 1355695676.627450733
>>> get_path_mtime /scavenger/of/human/sorrow
1355695676.627450733
------------------------------------------
==========================================
/---
function get_path_mtime() {
    die_unless_arg 'expected one pathname'
    get_path_time_for_format "${1}" 'y'
}

# --------------------( WASTELANDS                         )--------------------
#   mtime="${2:-$(get_time)}"
# with optional fractional digits on
#systems recording high-resolution file times)
#, where
#the meaning of ``high-resolution'' depends on system-specific properties
#       zam=( "${(s:~~~:)"$(stat --dereference --printf '%y~~~%Y' "${pathname}")"}" )
        # For efficiency, inline such implementation. See set_list_to_string_split_on_string for further details.
#   if is_file "${pathname}"
#   else die "\"${pathname}\" not found or not a file or directory"
#     directory's file or subdirectory creation,
#     deletion, 
# * to file content or
# permissions. If such path is a directory, this time reflects file and
# subdirectory creation but not changes to file or subdirectory content or
# permissions.
