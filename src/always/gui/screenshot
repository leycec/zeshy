#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *screenshotters* (i.e., functions capturing screenshots of some or all of
the screen currently displayed by the window manager).
/---

#FIXME: Also support "KScreenshot" under KDE and "gnome-screenshot" under GNOME.
#FIXME: Interestingly, it's possible to take a pseudo-screenshot of terminal
#output via the "script" command. Running "script" enters a subshell under which
#all output is redirected to file "typescript", which is then convertable into
#an HTML file by installing and running command "ansi2html" on such file. zeshy
#should support such functionality *WITHOUT* use of "script" (but still using
#"ansi2html") -- probably through the customary
#:redirect_stdout_to_file_start() and
#:redirect_stdout_to_file_stop() approach.

# ....................{ SCREENSHOTTERS                     }....................
declare_function_with_stdin <<'/---'
void :screenshot_screen_to_file(string filename)

Capture a screenshot of the screen currently displayed by the window manager to
the passed image file. Such file *must* be suffixed by an image-specific
filetype supported by the underlying screenshot command -- commonly either
`.jpg` or `.png` (e.g., `screen.jpg`, `screenshot.png`).
/---
# If ImageMagick is pathable, prefer "import".
if { is_pathable import } {
    function :screenshot_screen_to_file() {
        die_unless_arg 'Expected one filename.'
        command import -window root "${1}"
    }
# Else if "scrot" is pathable, fallback to such command.
} elif { is_pathable scrot } {
    function :screenshot_screen_to_file() {
        die_unless_arg 'Expected one filename.'
        command scrot "${1}"
    }
# Else if "imlib2_grab" is pathable, fallback to such command.
} elif { is_pathable imlib2_grab } {
    function :screenshot_screen_to_file() {
        die_unless_arg 'Expected one filename.'
        command imlib2_grab "${1}"
    }
# Else if "xwd" *AND* "xwdtopnm" (and hence all other Netpbm commands,
# hopefully) are both pathable, defer to such commands. Such commands tend to be
# bundled with most Linux distributions providing X.org. The former outputs only
# in the X11-specific XY and Z formats; the latter converts such output to the
# intermediate PNM format, which may then be converted to standard image formats
# with other Netpbm commands (e.g., "pnmtopng"). Somewhat insane, of course, but
# reasonably well-supported.
} elif { is_pathables xwd xwdtopnm } {
    function :screenshot_screen_to_file() {
        die_unless_arg 'Expected one filename.'
        ::run_xwd_with_options_to_file -root "${1}"
    }

    # Run "xwd", passing all arguments except the last as options, in a Netpbm-
    # based pipeline capturing such screenshot to the passed file.
    function ::run_xwd_with_options_to_file() {
        # Validate sanity.
        die_unless_args 'Expected optional options and one filename.'
        :string filename="${@[-1]}" filetype pnmto_command
        pop_arg

        # Get such filename's type.
        :set_string_to_file_type filetype "${filename}"

        # Set the "pnmto*" command to call specific to such type if such command
        # exists or throw an exception otherwise. Since there exists no "pnmtojpg"
        # command, handle such case specifically.
        if is "${filetype}" == 'jpg' si {
            pnmto_command='pnmtojpeg'
        } else {
            pnmto_command="pnmto${filetype}"
            die_unless_pathable "File \"${filename}\" type ${filetype} unsupported (i.e., command \"${pnmto_command}\" not found.)"
        }

        # Run "xwd", passing all remaining arguments as presumed options to
        # such command.
        command xwd "${@}" | command xwdtopnm | command "${pnmto_command}" >\
            "${filename}"
    }
}

declare_function_with_stdin <<'/---'
void :screenshot_window_to_file(int window_id, string filename)

Capture a screenshot of the window with the passed ID under the current window
manager to the passed image file. See :screenshot_screen_to_file() for further
details.
/---
# If ImageMagick is pathable, prefer "import".
if { is_pathable import } {
    function :screenshot_window_to_file() {
        die_unless_args_2 'Expected one window ID and one filename.'
        :string window_id="${1}" filename="${2}"
        die_unless_integer_nonnegative "${window_id}"
        command import -window "${window_id}" "${filename}"
    }
# Else if "imlib2_grab" is pathable, fallback to such command. (Interestingly,
# "scrot" simply defers to "imlib2_grab" but fails to provide a corresponding
# option.)
} elif { is_pathable imlib2_grab } {
    function :screenshot_window_to_file() {
        die_unless_args_2 'Expected one window ID and one filename.'
        :string window_id="${1}" filename="${2}"
        die_unless_integer_nonnegative "${window_id}"
        command imlib2_grab -id "${window_id}" "${filename}"
    }
# Else if "xwd" *AND* "xwdtopnm" are both pathable, defer to such commands.
} elif { is_pathables xwd xwdtopnm } {
    function :screenshot_window_to_file() {
        die_unless_args_2 'Expected one window ID and one filename.'
        :string window_id="${1}" filename="${2}"
        die_unless_integer_nonnegative "${window_id}"
        ::run_xwd_with_options_to_file -id "${window_id}" "${filename}"
    }
}

declare_function_with_stdin <<'/---'
void :screenshot_region_to_file(string filename)

Capture a screenshot of the *region* (i.e., rectangular area within the screen
currently displayed by the window manager interactively selected by the current
user) to the passed image file.  See :screenshot_screen_to_file() for further
details.
/---
# If ImageMagick is pathable, prefer "import".
if { is_pathable import } {
    function :screenshot_region_to_file() {
        die_unless_arg 'Expected one filename.'
        command import "${filename}"
    }
# Else if "scrot" is pathable, fallback to such command. (Interestingly,
# "imlib2_grab" fails to provide a corresponding option.)
} elif { is_pathable scrot } {
    function :screenshot_region_to_file() {
        die_unless_arg 'Expected one filename.'
        command scrot -s "${filename}"
    }
# Else if "xwd" *AND* "xwdtopnm" are both pathable, defer to such commands.
} elif { is_pathables xwd xwdtopnm } {
    function :screenshot_region_to_file() {
        die_unless_arg 'Expected one filename.'
        ::run_xwd_with_options_to_file "${filename}"
    }
}

# --------------------( WASTELANDS                         )--------------------
# This parcel does *NOT* support "xwd", bundled with X.org but outputting files
# only in the X11-specific XY and Z formats. While such files are convertable
# to standard image formats with ImageMagick's "convert" command, ImageMagick
# already provides the "import" command for capturing images directly to such
# formats. Since a hypothetical "xwd"-based screenshotter would need to call
# "convert" and hence depend on ImageMagick, there appears to be little
# incentive not to simply call "import" instead.
#
# For posterity, a hypothetical "xwd"-based screenshotter of the passed window
# ID would perform the following:
#
#     >>> command xwd -id "${window_id}" | command convert xwd:- "${filename}"

        # :string filename="${1}" filetype pnmto_command

        # # Get such filename's type.
        # :set_string_to_file_type filetype "${filename}"

        # # Set the "pnmto*" command to call specific to such type if such command
        # # exists or throw an exception otherwise. Since there exists no "pnmtojpg"
        # # command, handle such case specifically.
        # if is "${filetype}" == 'jpg' si {
        #     pnmto_command='pnmtojpeg'
        # } else {
        #     pnmto_command="pnmto${filetype}"
        #     die_unless_pathable "File \"${filename}\" type ${filetype} unsupported (i.e., command \"${pnmto_command}\" not pathable.)"
        # }

        # command xwd -root | command xwdtopnm | command "${pnmto_command}" >\
        #     "${filename}"

        # command scrot -c -d 3 -m "${1}"
#FUXME: Also support "xwd", seemingly bundled with X.org. Since "xwd" only
#outputs in the X11-specific XY and Z formats, however, doing so sanely will
#require following up calls to "xwd" with calls to another command converting
#such output to sane PNG or JPG image formats. (No idea which command converts!)
