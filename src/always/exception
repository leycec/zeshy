#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core exception functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_exception(void)

Throw an exception with the passed message unless an uncaught exception has been
thrown. See is_exception() for further details.
/---
function die_unless_exception() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_exception or die "${1-No exception thrown.}"
}

declare_function_with_stdin <<'/---'
void die_unless_in_always(
    string error_message =
        "Not in an \"always :{...}:\" block (or in an \"always :{...}:\" block missetting ${TRY_BLOCK_ERROR}).}")

Throw an exception with the passed message if either this function was not
called from within an `always :{...}:` block _or_ `zsh` integer global
${TRY_BLOCK_ERROR} is undefined (which it should never be).
/---
function die_unless_in_always() {
    # Validate sanity.
    die_unless_args_0_to_1 'Expected optional error message.'

    # If such integer is undefined or less than zero, this function cannot have
    # been called from within a sane "always :{...}:" block. zsh always sets
    # such integer to the exit status of the last command in the prior block --
    # which, by POSIX mandate, is an integer in [0, 255].
    (( ${TRY_BLOCK_ERROR--1} < 0 )) or die\
        "${1-Not in an \"always :{...}:\" block (or in an \"always :{...}:\" block missetting ${TRY_BLOCK_ERROR}).}"
}

declare_function_with_stdin <<'/---'
void die_evaluated(string evaluation)

Throw an exception whose error message is the result of dynamically evaluating
the passed string in a *double-quoted context* (i.e., as
`eval 'die "'${evaluation}'"'`). Since the result of dynamically evaluating a
string containing no *process substitutions* (i.e., `$(...)` expressions) is the
same string, this function is typically only passed single-quoted strings
containing such substitutions -- namely, substitutions of functions dependent on
the current terminal width.

== Terminal Width ==

The width available to each line of exception messages (typically) differs from
the width available to each line of normal output (i.e., the current terminal
width). Assuming default user-configurable styles, die() prints exception
messages in frames fabricated with box-drawing glyphs, implying no line of such
message may be longer than the current terminal width minus the lengths of the
left and right borders of such frames.

For readability, this function evaluates the passed string with a terminal width
temporarily set to such length. Consider the following erroneous call to die():

.Incorrect Terminal Width under die()
==========================================
[source]
------------------------------------------
>>> die "$(print_runnable info)"
┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• die() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
┋ ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• Command          ┋
┋ info •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃                          ┋
┋ /usr/bin/info                                                                                 ┋
┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
------------------------------------------
==========================================

The resulting message is plainly malformed. Consider calling this function with
the same string, single-quoted rather than double-quoted to delay execution of
such substitution until this function has temporarily overriden the current
terminal width with the restricted length:

.Correct Terminal Width under die_evaluated()
==========================================
[source]
------------------------------------------
>>> die_evaluated '$(print_runnable info)'
┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• die_evaluated() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
┋ ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• Command info •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃ ┋
┋ /usr/bin/info                                                                                  ┋
┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
------------------------------------------
==========================================
/---
function die_evaluated() {
    # Validate sanity.
    die_unless_arg 'Expected one evaluatable string.'
    string evaluation="${1}" message

    # If function get_terminal_width_for_errors() has been defined by this
    # point, evaluated such string under a restricted terminal width.
    if { is_function get_terminal_width_for_errors } {
        COLUMNS="$(get_terminal_width_for_errors)"\
            eval 'message="'${evaluation}'"'
    # Else, evaluate such string as is.
    } else {
        eval 'message="'${evaluation}'"'
    }

    # Throw such exception with such evaluated message.
    die "${message}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_exception(void)

Return success if an uncaught exception has been thrown (i.e., ${EXCEPTION} is
currently defined).
/---
function is_exception() {
    die_if_args
    is_variable_string EXCEPTION
}

# ....................{ THROWERS                           }....................
declare_function_with_stdin <<'/---'
void throw_exception_caught(void)

Rethrow the exception previously caught by the current `always :{...}:` block.
If this function was not called within such a block _or_ no exception was
previously caught or thrown, a new exception indicating that is thrown.
/---
function throw_exception_caught() {
    # Validate sanity.
    die_if_args
    die_unless_in_always

    # If no exception was caught, throw an exception indicating that.
    (( ${+CAUGHT} )) or {
        # If an exception was thrown, throw an exception with such exception.
        (( ${+EXCEPTION} )) or
            die "Exception \"${EXCEPTION}\" uncaught."

        # Else, no exception was even thrown. Now you're really in for it!
        die 'No exception thrown.'
    }

    # Rethrow the currently caught exception.
    throw_exception "${CAUGHT}"
}

# --------------------( WASTELANDS                         )--------------------
    # If such integer is undefined, throw an exception.
#   if (( ${+TRY_BLOCK_ERROR} == 0 )) {
#       die 'Global ${TRY_BLOCK_ERROR} undefined.'
# For robustness (e.g., in case , inline such test. See is_function() for further details.
#   if { typeset -f get_terminal_width_for_errors &>/dev/null } {

#FUXME: Nice nomenclature. Rename the rather clunky
#die_unless_context_current_function() to die_unless_in_function(). (Much
#better!)

#   (( # == 0 )) || throw_exception\
#       "zeshy: catch_exception_matching_glob_if_found() expected one glob but received:\n${*}" 1>&2

        # If not in an "always {...}" 
        # Else if this function was not called from within an "always {...}"
        # block *OR* ${TRY_BLOCK_ERROR} is undefined, throw an exception
        # indicating that. See throw_exception() for further details.
#    if (( ${TRY_BLOCK_ERROR--1} <= -1 )) {
#        if (( ${+TRY_BLOCK_ERROR} == 0 )) {
#            print 'zeshy: zsh global ${TRY_BLOCK_ERROR} undefined' 1>&2
#        } else {
#            print 'zeshy: catch_exception_matching_glob_if_found() not called in an "always {...}" block' 1>&2
#        }
#
#        # Since this function was not called from within an "always {...}"
#        # block, there's little point in setting ${TRY_BLOCK_ERROR} to nonzero
#        # exit status to indicate failure. Instead, simply return such status.
#        return 1

    # If function get_terminal_width_for_errors() has been defined by this
    # point, throw such exception with such string evaluated under a restricted
    # terminal width. For stability, inline such test. See is_function() for
    # further details.
#    if { typeset -f get_terminal_width_for_errors &>/dev/null } {
#        COLUMNS="$(get_terminal_width_for_errors)" eval 'die "'${evaluation}'"'
#    }
    # Else, throw such exception with such string evaluated as is.
#    } else {
#        eval 'die "'${evaluation}'"'
#    }
