#!/usr/bin/env zsh
# ====================[ 00interactive_alias                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Interactive Alias, Zeshy-specific aliases active only when called
# directly from the command line of an interactive Zsh shell. When called from
# any other context (e.g., from a Zsh function or script), interactive aliases
# either reduce to their alias name if that of an existing callable (e.g., a
# command in the current user's ${PATH}) or throw an exception otherwise.
#
# This component resides at the overlay root to guarantee its importation during
# compilation of the Zeshy digest file prior to typical Zeshy components. The
# latter call functions defined by this component (e.g.,
# interactive_substitution()) in a global context.
#
# --------------------( MOTIVATION                         )--------------------
# Startup shell scripts and scripting frameworks often install the canonical
# alias "ll", listing paths in long format by expanding to "ls -l": e.g.,
#
#     # Alias producing greppable and hence shell script-friendly output.
#     alias ll="ls -l"
#
# While convenient, such alias suffers more than a few drawbacks:
#
# * Shell scripts calling "ll" behave as expected only if such alias retains a
#   shell script-friendly expansion. But such alias is readily editable into a
#   shell script-unfriendly expansion, suggesting no such guarantees: e.g.,
#
#     # Alias producing non-greppable and hence shell script-unfriendly output.
#     alias ll="ls -l --color=always --human-readable"
#
# * Shell scripts calling "ll" rather than "ls" behave as expected only under
#   the current shell environment and hence are inherently non-portable.
#   Different users and systems install different startup shell scripts and
#   scripting frameworks, suggesting no such guarantees: e.g.,
#
#     # Alias expanding to a non-"ls" command, producing unexpected output.
#     alias ll="long_long_integer"
#
# * Shell scripts defining a function ll() behave as expected only *NOT* under
#   the current shell environment. Since Zsh assigns aliases higher precedence
#   than functions, an externally defined alias "ll" supercedes any internally
#   defined function ll(): e.g.,
#
#     # Function overriden by the defined alias "ll".
#     ll() {
#         print 'If the caller defined an alias "ll", you'll never see this.'
#     }
#
# --------------------( SOLUTION                           )--------------------
# Interactive aliases solve such portability issues, to varying degrees. Like
# traditional aliases, interactive aliases are declared via "="-delimited
# syntax with which the alias name precedes the alias expansion delimited by an
# "=" character: e.g.,
#
#     # Identical to the prior definition but prefixed with "interactive_".
#     interactive_alias l="ls -l"
#
# Like traditional aliases, the various types of interactive aliases are defined
# by various Zeshy functions:
#
# * interactive_substitution(), substituting an existing Zsh builtin or external
#   command in ${PATH} with an interactive alias of the same name: e.g.,
#
#     # Substitute the external "ls" command with an interactive alias "ls"
#     # internally calling such command with helpful arguments.
#     interactive_substitution ls="ls --all --sort=version"
#
# * interactive_abbreviation(), abbreviating an existing Zsh builtin or external
#   command in ${PATH} with an interactive alias of a different name: e.g.,
#
#     # Abbreviate the external "ls" command with an interactive alias "l".
#     interactive_abbreviation l="ls"
#
# * interactive_alias(), a low-level helper function declaring an interactive
#   alias *NOT* substituting or abbreviating an existing Zsh builtin or external
#   command in ${PATH}. However, most interactive aliases substitute or
#   abbreviate such builtins or commands! For improved portability and safety,
#   consider calling the high-level functions interactive_substitution() or
#   interactive_abbreviation() instead.
#
# --------------------( CONSTRAINTS                        )--------------------
# Interactive substitutions and abbreviations are interactive aliases imposing
# additional runtime constraints, for safety. All interactive aliases should be
# declared as either substitutions or abbreviations, ideally.
#
# Interactive substitutions
#
# --------------------( SYNTAX                             )--------------------
# Interactive aliases are declared with the customary "="-delimited syntax for
# plain, global, and suffix aliases, as the above examples demonstrate.
#
# Interactive substitutions and abbreviations (but not low-level aliases
# declared by directly calling interactive_alias()) additionally support
# embedded "{..}" expressions in alias names. Such expressions combine multiple
# interactive_substitution() and interactive_abbreviation() calls into a single
# call whose outcome depends on the current shell environment and system.
#
# Interactive substitutions interpret embedded "{..}" expressions as
# interactive abbreviations to be expanded to the same alias. If the implied
# interactive abbreviation name is already an existing command in the current
# user's ${PATH}, the function interactive_substitution() iteratively searches
# for the nearest abbreviation name *NOT* already an external command: e.g.,
#
#     # An interactive substitution containing embedded "{..}" expressions.
#     interactive_substitution {m}k{d}ir="mkdir --parents --verbose --"
#
#     # If no external command in the current user's ${PATH} is named "md", the
#     # above statement is equivalent to the following two statements.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#     interactive_abbreviation md="mkdir"
#
#     # Else if no external command is named "mkd", the above statement is
#     # equivalent to the following two statements.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#     interactive_abbreviation mkd="mkdir"  # "mkd" rather than "md", here
#
#     # Else if no external command is named "mkdi", the above statement is
#     # equivalent to the following two statements.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#     interactive_abbreviation mkdi="mkdir"  # "mkdi" rather than "md", here
#
#     # So, interactive_substitution() iteratively searches for the first name
#     # in the following list *NOT* already an external command in the current
#     # user's ${PATH}: "md", "mkd", and "mkdi". If all such names are already
#     # existing commands, interactive_substitution() prints a warning and
#     # simply reduces to the following one statement.
#     interactive_substitution mkdir="mkdir --parents --verbose --"
#
# Interactive abbreviations interpret embedded "{..}" expressions as the
# interactive abbreviation name to be expanded to. This is principally useful
# for generic safety, to accommodate heterogenous end user systems under which
# one has no control and hence could have conceivably installed commands with
# the same names as desired abbreviations: e.g.,
#
#     # Risky! This fails with warning if "rcs" is already an existing command.
#     interactive_abbreviation rcs="rc-status start"
#
#     # Safer. This fails with warning only if all of "rcs", "rcst", "rcsta",
#     # and "rcstar" are already existing commands.
#     interactive_abbreviation {rcs}tart="rc-status start"
#
# Ideally, all interactive substitutions and abbreviations (and hence all
# interactive aliases) should contain at least one "{..}" expression.
#
# --------------------( SYNTAX ~ algorithm                 )--------------------
# Interactive substitutions and abbreviations parse "{..}" expressions according
# to a simple exhaustive algorithm, which for each iteration:
#
# * Concatenates all "{"- and "}"-delimited substrings in the original alias
#   name into an implied abbreviation name: e.g.,
#
#   # In this iteration, the implied abbreviation name is "md".
#   interactive_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
# * If the implied abbreviation name is not already an existing command name,
#   creates such abbreviation; otherwise, shifts the leftmost "}" right by one
#   character in the original alias name unless prior to the last character of
#   such name in which case prints a warning: e.g.,
#
#   # First test whether "md" is already an existing command. If not, run:
#   interactive_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
#   # Else, test whether "mkd" is already an existing command. If not, run:
#   interactive_abbreviation {mk}{d}ir="mkdir --parents --verbose --"
#
#   # Else, test whether "mkdi" is already an existing command. If not, run:
#   interactive_abbreviation {mkdi}ir="mkdir --parents --verbose --"
#
#   # Else, all such names already exist. Emit a vile warning.
#   curse 'interactive abbreviations "md", "mkd", and "mkdi" already existing commands'
#
# --------------------( CAVEATS                            )--------------------
# Zeshy requires such functionality before compiling its digest, sadly. Since
# Zeshy confines most functionality to its digest, no function below may call
# Zeshy functions. All functions below must manually implement Zeshy functions
# defined elsewhere!
#
# Zeshy implements interactive aliases as functions rather than genuine aliases.
# This solves the prior problem of Zsh assigning aliases higher precedence
# than functions, but could potentially trip up the unawares. (In practice, the
# difference between aliases and functions tends to be negligible. Usually,
# anyway!)
#
# --------------------( TODO                               )--------------------
# * Genius! (Or, at the least, modestly clever. Oh, very well: it's merely
#   obvious.) We can dramatically improve efficiency and reliability by
#   partitioning the digest file into two such files:
#   * One compiling the gamut of all Zeshy functions and active interactively.
#   * The other compiling all Zeshy functions *EXCEPT* interactive aliases and
#     active non-interactively. (This is easy; just prepend a second call to a
#     Zeshy compilation function with temporary disabling of such globals via
#     ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS= and
#     ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS=).
#   Override the Zsh hook called immediately:
#   * Before evaluation of a new user-input interactive command to prepend the
#     ${FPATH} with the prior digest file, excising the latter digest file if
#     already prepended.
#   * After evaluation of a new user-input interactive command to prepend the
#     ${FPATH} with the latter digest file, excising the former digest file if
#     already prepended.
#   All of this assumes Zsh exposes sufficient hooks, of course. It may not. It
#   probably doesn't, in fact. But if it does... coolness is ours, baby.
# * Technically, we can support interactive aliases on functions -- but only
#   in somewhat roundabout fashion. We would need detect this to be an alias on a
#   function (easy), then define a new function with the same implementation as the
#   function to be replaced by such alias but with a new name, say,
#   "${alias_name}____tmp" (perhaps easy; doesn't "which ${function_name}" provide
#   us a function implementation which we could then eval into a new function with
#   such placeholder name?), then replace the old with the new function name in the
#   alias expansion (easy). It's a bit involved, but nothing too intractable.

# ....................{ DECLARATORS                        }....................
#FIXME: Clean up documentation everywhere below.
function interactive_substitution() {
    (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or return_true
    string ALIAS_TYPE='substitution'
    interactive_alias "${@}"
}

# void interactive_abbreviation(string alias_specification)
#
# If the current user has enabled the configuration global
# ${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}, define an interactive
# abbreviation according to the passed "="-delimited alias specification: e.g.,
#
#     >>> interactive_abbreviation p="print Thunnus maccoyii"
#     >>> p
#     Thunnus maccoyii
#     >>> () { p }
#     p: interactive abbreviation "p" cannot be called non-interactively
#     print_stack_trace: "p" failed with exit status 1.
#
# Interactive abbreviations are interactive aliases (and hence intended to be
# called only directly from the command line), such that:
#
# * If the passed alias name has the same name as some existing callable (e.g.,
#   builtin, command), print a warning and return without defining such alias.
#
# Interactive abbreviations *NEVER* replace existing callables, but are
# otherwise identical to interactive aliases.
function interactive_abbreviation() {
    (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or return_true
    string ALIAS_TYPE='abbreviation'
    interactive_alias "${@}"
}

# ....................{ HELPERS                            }....................
# void interactive_alias(string alias_specification)
#
# Declare the passed specification as an interactive alias, active only when the
# builtin or command to be aliased is run directly from an interactive shell.
# Due to implementation details, functions cannot currently be interactively
# aliased. Interactive aliases are inactive in non-interactive scripts and
# functions, and hence helpful for applying human-readable options on that
# builtin or command when run directly by a human. This function fails if the
# builtin or command to be aliased does not exist. See
# interactive_alias_if_installed() for an alternative not failing in such cases.
#
# The alias specification format is identical to that of normal aliases: e.g.,
#
#   # Alias print() to sort arguments only when called interactively.
#   >>> print T M D
#   T M D
#   >>> interactive_alias print="print -o"
#   >>> print T M D
#   D M T
#   >>> print_indirectly() { print "${@}" }
#   >>> print_indirectly T M D
#   T M D
function interactive_alias() {
    # Validate passed arguments, splitting the "="-delimited alias name and
    # expansion split from all passed strings. Dismantled, this is:
    #
    # * "${*...}", expanding to all passed strings concatenated together.
    # * "[[:space:]]#", excluding zero or more whitespace characters (e.g.,
    #   tab, space) and hence ignoring whitespace surrounding such delimiter.
    die_unless_args
    string\
        alias_name="${*%%[[:space:]]#\=*}"\
        alias_expansion="${*#*\=[[:space:]]#}"\
        alias_name_type command_name\
        alias_expansion_if_interactive alias_expansion_if_non_interactive\
        alias_logic_if_interactive alias_logic_if_non_interactive
#   print "args: ${*%%=*}"

    # Type of interactive alias to be defined, defaulting to "alias" if not
    # already set by the caller. Recognized types include:
    #
    # * "substitution", only set by interactive_substitution().
    # * "abbreviation", only set by interactive_abbreviation().
    # * "alias", only set by this function.
    string ALIAS_TYPE="${ALIAS_TYPE:-alias}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "alias type: ${ALIAS_TYPE}\nalias name: ${alias_name}\nalias expansion: ${alias_expansion}" 1>&2

    # Validate passed arguments.
    is "${ALIAS_TYPE}" == (substitution|abbreviation|alias) si or
        die "interactive alias type \"${ALIAS_TYPE}\" unrecognized"
    is "${alias_name}" == "${alias_expansion}" si and
        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '=' delimiter"
    (( ${#alias_name} )) or
        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
    (( ${#alias_expansion} )) or
        die "interactive ${ALIAS_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

    # If such alias name contains at least one "{"- and "}"-delimited substring,
    # concatenating all such substrings provides the abbreviation name embedded
    # in such alias name (e.g., abbreviation "ichy" in alias "l{ich}mumm{y}").
    # Parse and possibly define such abbreviation.
    is "${alias_name}" == *'{'*'}'* si and
        _parse_embedded_interactive_abbreviation

    # If such alias name is already a declared...
    if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
        # ...Zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
        if is "${alias_name_type}" == 'function' si and
        then die "interactive ${ALIAS_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"
        # ...any other callable (e.g., alias, builtin, command) and this is an
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
        elif is "${ALIAS_TYPE}" == 'abbreviation' si; then
            curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
            return_true
        # Otherwise, silently wrap such callable in the passed alias.
        fi
    # If such alias name is *NOT* already a declared callable and this is an
    # interactive substitution alias, there exists nothing to be substituted.
    # Throw an exception.
    elif is "${ALIAS_TYPE}" == 'substitution' si; then
        die "interactive substitution \"${alias_name}\" not a defined command or builtin"
    # Otherwise, declare such callable as the the passed alias.
    fi
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # If the command (i.e., the first word) the alias expands to is the same as
    # the alias name but is not an existing callable, assume the caller is
    # attempting to interactively alias a function of the same name: e.g.,
    #
    #  interactive_alias recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While Zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "interactive_alias recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
    command_name="${alias_expansion[(w)1]}"
    is "${alias_name}" == "${command_name}" si and
        not whence -- "${command_name}" 1>/dev/null 2>&1 and
        die "interactive alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ALIAS_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    # Interactive logic to be performed by the function definition below.
    alias_expansion_if_interactive="${alias_expansion} \"\${@}\""
    alias_logic_if_interactive="
    if is_piped_input
    then run_with_piped_input ${alias_expansion_if_interactive}
    else ${alias_expansion_if_interactive}
    fi"

    # Non-interactive logic to be performed by the function definition below. If
    # this alias name is not already an existing callable (e.g., as in the case
    # of interactive abbreviations), throw an exception. Otherwise, call this alias
    # name as is without expanding the passed expansion.
    if is "${alias_name_type}" == 'none' si
    then alias_logic_if_non_interactive="die 'interactive ${ALIAS_TYPE} \"${alias_name}\" cannot be called non-interactively'"
    else
        alias_expansion_if_non_interactive="${alias_name} \"\${@}\""
        alias_logic_if_non_interactive="
    if is_piped_input
    then run_with_piped_input ${alias_expansion_if_non_interactive}
    else ${alias_expansion_if_non_interactive}
    fi"
    fi

    # Define the desired alias as a function of the same name to:
    #
    # * Temporarily disable this function to prevent infinite recursion on
    #   subsequently calling an alias, builtin, or command of the same name.
    # * If:
    #   * This shell is interactive, thus excluding non-interactive scripts.
    #   * Standard output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
    #   * This "alias" was called directly from the command line, thus
    #     excluding non-interactive calls from functions.
    #   * Then run the passed alias expansion.
    # * Else, run the desired non-interactive expansion.
    # * Regardless of whether such run throws an exception, always re-enable
    #   this function for subsequent calling.
    eval "function ${alias_name}() {
    {
        disable -f ${alias_name}
        if [[ -o interactive && -t ${ZESHY_STDOUT} && \${#funcstack} -eq 1 ]]
        then ${alias_logic_if_interactive}
        else ${alias_logic_if_non_interactive}
        fi
    } always {
        enable -f ${alias_name}
    }
}"
#   is "${ALIAS_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2
}

# void _parse_embedded_interactive_abbreviation(void)
#
# Parse "{"- and "}"-delimited substrings from the current interactive alias
# name of the current type ("substitution" or "abbreviation") expanding to the
# current alias expansion. Concatenating such substrings gives the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing callables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
#
# This function is a helper intended to be called only by interactive_alias(),
# thus accepting no arguments and returning no values.
_parse_embedded_interactive_abbreviation() {
    # Validate sanity.
    die_if_args

    # If such abbreviation is invalid, throw an exception.
    is "${ALIAS_TYPE-}" == 'alias' si and
        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a \"{...}\" but is neither an abbreviation or substitution"
    is "${alias_name}" == \{[^\{\}]#\} si and
        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains a full \"{...}\""
    is "${alias_name}" == *\{\}* si and
        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an empty \"{}\""
    is "${alias_name}" == *\{[^\}]# si and
        die "interactive ${ALIAS_TYPE} \"${alias_name}\" contains an unclosed '{'"

    # Copy of the passed alias name.
    string alias_name_copy="${alias_name}"

    # Abbreviation name parsed from ${alias_name_copy}.
    string abbre_name

    # Character succeeding the leftmost "}" in ${alias_name_copy}.
    string abbre_next_char

    # 1-based indices of the characters immediately preceding and succeeding
    # the leftmost "}" in ${alias_name_copy}.
    integer\
        abbre_last_char_index\
        abbre_next_char_index abbre_next_next_char_index

    # Iteratively shift the leftmost "}" in ${alias_name_copy} right one
    # character until either finding an abbreviation name claimed by no
    # existing callable or reaching the end of ${alias_name_copy}.
    while true; do
        abbre_name="${alias_name_copy//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       sputter_escaped "abbreviation: ${abbre_name}"
        whence -- "${abbre_name}" 1>/dev/null 2>&1 or break

        # Find the index of the leftmost "}" in ${alias_name_copy} by
        # matching the first "{..}" in such copy. Dismantled, this is:
        #
        # * "#", matching from the beginning of ${alias_name_copy}.
        # * "(#m)", setting global integer ${MEND}, the 1-based index of
        #   the last character matched -- in this case, the leftmost "{".
        noop "${alias_name_copy#(#m)[^\{\}]#\{[^\{\}]##\}}"

        # If the index of the leftmost "}" is the last character in
        # ${alias_name_copy}, the prior iteration shifted such "}" to the
        # end of such copy and hence exhausted all characters. Return!
        (( abbre_next_char_index = MEND + 1 ))
        (( abbre_next_char_index < ${#alias_name_copy} )) or break

        # Otherwise, get the character succeeding the leftmost "}".
        (( abbre_last_char_index = MEND - 1 ))
#       sputter "abbre_next_char_index: ${abbre_next_char_index}"
        abbre_next_char="${alias_name_copy[${abbre_next_char_index}]}"

        # Shift the leftmost "}" in ${alias_name_copy} right one character.
        #
        # If the character succeeding the leftmost "}" is a "{", there exist
        # two adjacent "{..}" expressions (e.g., "{mk}{d}ir"). Do not shift
        # the "}" to the right of the "{" (e.g., "{mk{}d}ir"); rather, merge
        # the two expressions (e.g., "{mkd}ir").
        if is "${abbre_next_char}" == '{' si; then
            (( ++abbre_next_char_index ))
            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${alias_name_copy[${abbre_next_char_index},-1]}"
        # Otherwise, simply shift the leftmost "}" right one character.
        else
            (( abbre_next_next_char_index = abbre_next_char_index + 1 ))
            alias_name_copy="${alias_name_copy[1,${abbre_last_char_index}]}${abbre_next_char}}${alias_name_copy[${abbre_next_next_char_index},-1]}"
        fi
#       sputter "new alias name: ${alias_name_copy}"
    done

    # If all possible abbreviation names have already been claimed by
    # existing callables and:
    #
    # * This is an interactive substitution, print a warning and define no
    #   such abbreviation.
    # * This is an interactive abbreviation, do nothing (i.e., attempt to
    #   use the entire alias name stripped of "{" and "}" characters as the
    #   abbreviation name).
    if (( abbre_next_char_index == ${#alias_name_copy} )); then
        if is "${ALIAS_TYPE}" == 'substitution' si; then
            string abbre_name_type
            abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
            abbre_name_type="${$(whence -w -- "${abbre_name}")##*: }"
            curse "abbreviation \"${abbre_name}\" in interactive substitution \"${alias_name}\" already a defined ${abbre_name_type}:\n$(which "${abbre_name}")"
        fi
    # If this is an interactive substitution, define an interactive
    # abbreviation of the above abbreviation name and same expansion as this
    # substitution. While this does recursively call interactive_alias(), such
    # call *NEVER* performs another recursive call. (Why? Listen closely: such
    # abbreviation name contains no "{" or "}" characters and hence no embedded
    # abbreviation. Since such recursive call never calls this function, the
    # recursion is guaranteed to "bottom out" after the first recursion.)
    elif is "${ALIAS_TYPE}" == 'substitution' si; then
#       print "abbreviating embedded ${abbre_name}=\"${alias_expansion}\"" 1>&2
        interactive_abbreviation ${abbre_name}="${alias_expansion}"
    # If this is an interactive abbreviation, set the alias name to be returned
    # to the above abbreviation name.
    else alias_name="${abbre_name}"
    fi

    # Strip "{" and "}" characters from the alias name to be returned.
    alias_name="${alias_name//[\{\}]}"
}

# --------------------( WASTELANDS                         )--------------------
# Thus, this component is a
# hard dependency of typical Zeshy components.
#FIXME: This still isn't quite right. The reason is subtle:
#    interactive_alias ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

#FIXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FIXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> interactive_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing callable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> interactive_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> interactive_substitution {m}k{d}ir='mkdir -v --'
#    >>> interactive_substitution {mkd}ir='mkdir -v --'
#    >>> interactive_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing interactive_abbreviation() or interactive_alias() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#FIXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

# Unlike traditional aliases, :
# substitution and abbreviation interactive aliases. 
#
# Interactive aliases are declarable with one of the following functions:
#
# the "interactive_alias"
# helper (as above), Zeshy recommends using the following  "interactive 
#
# While interactive aliases are declarable directly with the "interactive_alias"
# helper (as above), Zeshy recommends using the following  "interactive 
# There are two prominent types of interactive aliases.
#
# Like traditional aliases, there are two prominent types of interactive
# aliases: substitution and abbreviation interactive aliases. 
#
# Defer defining the following functions until having defined all prior aliases.
    # While the following block would ideally be encapsulated in a separate
    # function, its calling of interactive_abbreviation() and hence dynamic
    # evaluation of a new function definition would erroneously confine such
    # definition to the subshell
#       alias_name="$(parse_embedded_interactive_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"


#       print -r -- "${alias_name//[\{\}]}"
#       alias_name="$(parse_embedded_interactive_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"
# string parse_embedded_interactive_abbreviation(
#   string alias_type, string alias_name, string alias_expansion)
#
# Parse "{"- and "}"-delimited substrings from the passed interactive alias name
# of the passed type (either "substitution" or "abbreviation") expanding to the
# passed expansion. Concatenating such substrings provides the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing callables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
    # Validate passed arguments.
#   die_unless_three_args\
#       'expected one alias type, one alias name, and one alias expansion'
#   string alias_type="${1}" alias_name="${2}" alias_expansion="${3}"
#   sputter_escaped "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}"

#           match=()
#           (( abbre_first_char_index = ${mend[1]} - 1 ))
#           (( abbre_right_brace_index = MEND ))
    # Return unless the current user configuration enables substitutions.
    # Return unless the current user configuration enables abbreviations.
#   string alias_name="${*%%[[:space:]]#\=*}"
#   noop "${(S)alias_name//*\{(#b)(*?)\}*}"
#   if ; then
#   if is "${alias_name}" == *'{'(#b)(*?)'}'* si; then
#   if is -n "${(MS)alias_name//*\{(#b)(*?)\}*}" si; then
#   sputter "match attempt: ${(SI:1:)alias_name//*\{(#b)(*?)\}*}"
#   sputter "match attempt: ${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   match=()
#   noop "${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   if is -n "${match}" si; then
#       match=()
#       is "${alias_name}" == (#b)[^{}]#'{'([^{}]##)'}'[^{}]# si
#       is "${alias_name}" == ([^{}]#'{'(#b)([^{}]##)'}')## si
#       is "${alias_name}" == (#b)([^{}]#'{'([^{}]##)'}')## si
#       sputter "alias_name: ${alias_name}"
#       print "${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       sputter "embedding: ${match[*]}"
#       sputter "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       sputter "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       integer embedded_first_char_index=$(( ${mend[1]} - 1 ))
#       sputter "match: ${match[1]}; mend: ${mend[1]}"

#   string abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#   if is "${abbre_name}" != "${alias_name}" si; then
#       integer alias_name_length="${#alias_name}" abbre_next_char_index
#       sputter_escaped "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}\nalias name length: ${alias_name_length}"
#   else
#By design, the passed alias must be either an interactive abbreviation or
# substitution. #       while whence -- "${abbre_name}" 1>/dev/null 2>&1; do
#           (( abbre_next_char_index < 10 )) or break
                #FIXME: Should be handled by the above exception handling, no?
#               (( abbre_next_char_index < alias_name_length )) or
#                   die "interactive substitution \"${alias_name}\" contains an unclosed '{'"
    # If *NOT* a raw interactive alias (e.g., if either an interactive
    # substitution or abbreviation) and 
#           string abbre_name_definition
#           abbre_name_definition=""
#           curse "embedded abbreviation interactive substitution \"${alias_name}\" contains"

#           case "${interactive_alias_type}" in
            # ...this is an interactive substitution alias and the current user
            # prohibits substituting callables with such aliases, return!
#           substitution) return_true;;
#               is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#                   return_true
            # ...this an interactive abbreviation alias, return! Also, if the
            # current user prohibits abbreviating callables with such aliases,
            # print a warning indicating such abbreviation could not be defined.
#           elif is "${interactive_alias_type}" == 'abbreviation' si; then
#               is -n "${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}" si or
#                   curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#               return_true

    #FIXME: Document. I get it. We were trying to make the above
    #'interactive_alias print="print -o"' example work as expected. But, if you
    #think about it, that's pretty much impossible in the general case. For example,
    #'interactive_alias print="run_paged print -o"' pretty much fails under non-
    #interactivity with the naive assumption of the first word being the command to be
    #run. I'd say this needs dramatic generalization. Basically, the function should
    #strictly accept only one or two arguments; if passed, the second argument tells
    #what to run when non-interactive and otherwise defaults to the following:
    #
    #* If the alias name and first word of the alias expansion are the same and:
    #  * Such name is an existing function, throw an exception (as below) when run
    #    non-interactive.
    #  * Default to such name without arguments (as below) when non-interactive.
    #* Otherwise, default to such name without arguments (as below) when non-interactive.
    #
    #Oh, wait. The above FIXME handles such edge cases, so... simply default to:
    #
    #* If the first word of the alias expansion is a non-empty, non-alias, non-function
    #  (i.e., is a command, builtin, or reserved), such word.
    #* Else if the first word of the alias expansion matches the "run_"* glob and the
    #  second word of such expansion is a non-empty, non-alias, non-function, such word.
    #* Else if the alias name is a non-empty, non-alias, non-function, such name.
    #* Otherwise, throw an exception from within such function definition.
    #
    #Note that *': function' erroneously fails to match aliases. So, just glob
    #*': '(builtin|command|reserved) explicitly. *shrug*
    #
    #This default cleanly handles the prior examples. It won't work in all cases, of
    #course, which is why we permit parameters resembling:
    #
    #    interactive_alias print_up="do_something_curious print -o"' 'print'
    #
    #*ACTUALLY*, the more I think about, the more I realize the above heuristics only
    #apply to the case that the alias name is a non-function (e.g., external command);
    #in such case, the above heuristic can be seemlessly reduced to simply calling such
    #name. If, on the other hand, the alias name is an *ABBREVIATION*, then it should
    #*NEVER* be callable non-interactively; an exception should always be thrown. Since
    #this logic biffurcates cleanly between interactive_alias() and
    #interactive_abbreviation()... You know, why do we even have those two functions?
    #Any interactive alias for which the alias name is *NOT* already an existing non-
    #function is implicitly an abbreviation or something similar. I believe we can
    #dispense with interactive_abbreviation(), therefore.

    #FIXUP: We should probably throw an exception under cases such as:
    #
    #  interactive_alias recursive='recursive -not -ok'
    #  function recursive() { print 'uh oh'; }
    #
    #While recursion *USUALLY* works (due to our use of function disabling and
    #enabling below), it fails if the first word of the alias expansion expands
    #to a Zsh function of the same name as the alias. In the case above, such
    #function has yet to be defined. Hence, *UNLESS* such word has a non-empty,
    #non-function type, we assume its type to be function and throw an exception.

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.

#   then alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#interactive_alias ff="firefox"
    # The string to expand this alias to when called non-interactively.
#   if is "${alias_name}" == "${command_name}" and\
#      "$(whence -w "${command_name}")" == *': function' si
#   then alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
        #FIXME: Have my doubts about this logic; it feels... dubious. Too
        #clever, and arguably bug-prone. Let's ride bareback for a bit.
#       if is "${alias_name_type}" != 'function' si
#       then alias_expansion_if_non_interactive="${alias_name}"
#       else alias_expansion_if_non_interactive=
#       fi
#   else
#       alias_expansion_if_non_interactive="${command_name} \"\${@}\""
#       alias_logic_if_non_interactive="
#   if is_piped_input
#   then run_with_piped_input ${alias_expansion_if_non_interactive}
#   else ${alias_expansion_if_non_interactive}
#   fi"
#   fi

#FIXME: Implement me. Basically, disembowel interactive_alias(). ;]
#define_interactive_alias() {
#}

    #SUBSTITUTION
#   if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
#       if is "${alias_name_type}" == 'function' si; then
#           die "interactive substitution \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       else
#           is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#               return_true
#       fi
#   else
#       die "interactive substitution \"${alias_name}\" not found in \$PATH"
#   fi

    #ABBREVIATION
    # If a function, throw an exception. While Zsh does behave sensibly when
    # aliasing functions (e.g., "alias rm='rm -i'" behaves non-recursively),
    # interactive aliases are functions rather than aliases. Defining an
    # interactive alias of the same name as an existing function thus
    # silently overwrites such function, which is never helpful. Prohibit!
    # If anything other than a function (e.g., builtin, command),
    # emit a warning and return without redefining such builtin or command.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and
#       is "${alias_name_type}" != 'function' si and {
#       curse "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       return_true
#   }

    # If such alias name is an existing callable, either emit a warning or throw
    # an exception (depending on the type of such callable).
        # Definition of such callable and appropriate error message.
#       string alias_definition error_message
#       alias_definition=""

#FIXME: ${ZESHY_IS_WRAPPING_BUILTINS} is a rather poor name. Globally rename to
#${ZESHY_IS_WRAPPING_BUILTINS_WITH_INTERACTIVE_ALIASES}, please.

    # Alias name type, if the passed alias name is already declared to be an
    # alias, builtin, command, or function.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and {
        #FIXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
        #I suppose not! We don't call eval() in the function definition, and doing so
        #would introduce yet more bizarre edge-casing. Explicitly document why we
        #currently prohibit this. The current logic here suffices, in any case.

        # Die if already declared unless the current user requests wrapping such
        # types with interactive aliases. In particular, replacing a declared
        # Zsh alias or function with an interactive alias is largely senseless;
        # Zsh aliases and functions may always be implemented to account for
        # interactivity (e.g., by calling is_interactive() or interactively()),
        # thus obviating the need for interactive aliases in such cases. Since
        # silently replacing declared Zsh aliases and functions seems an
        # inherently risky (and certainly useless) proposition, disallow it.
#       if   is "${alias_name_type}" == (builtin|reserved) si
#       then is -n "${ZESHY_IS_WRAPPING_BUILTINS-}" si or return_true
#       elif is "${alias_name_type}" == command si
#       then is -n "${ZESHY_IS_WRAPPING_COMMANDS-}" si or return_true
#       else die\
#           "interactive alias \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       fi
#   }

    #FIXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
    #I suppose not! We don't call eval() in the function definition, and doing so
    #would introduce yet more bizarre edge-casing. Explicitly document why we
    #currently prohibit this. The current logic here suffices, in any case.

    #   and functions with interactive aliases is senseless, as the
    #   former may always be implemented to account for
    #   interactivity (e.g., by calling is_interactive() or interactively()),
    #   thus obviating the need for interactive aliases in such cases. Since
    #   silently replacing declared Zsh aliases and functions seems an
    #   inherently risky (and certainly useless) proposition, disallow it.

        #FIXME: Hmm; we can't say whether or not an alias is invalid without
        #expanding it to its expansion and then taking the name of 
    # Non-interactive logic to be performed by the function definition below.
#   if is -n "${alias_expansion_if_non_interactive}" si; then
#       alias_expansion_if_non_interactive+=' "${@}"'
#       alias_logic_if_non_interactive="
#   if is_piped_input
#   then run_with_piped_input ${alias_expansion_if_non_interactive}
#   else ${alias_expansion_if_non_interactive}
#   fi"
#   else alias_logic_if_non_interactive="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#   fi

    # Otherwise, such alias name is either an existing Zsh function or has yet
    # to be declared. In the former case, we (optimistically) assume 
#FIXME: In the event of conflict with existing commands or builtins, it'd be
#great to
#FIXME: Excise this everywhere used. Since interactive_alias() now integrates
#such functionality directly, we no longer require this at all.
# bool is_zeshy_wrapping_core_commands(void)
#
# Return true if the current user requests Zeshy wrap interactively run core
# commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#is_zeshy_wrapping_core_commands() {
#    (( # == 0 )) or die 'no arguments expected'
#    [[ -n "${ZESHY_IS_WRAPPING_COMMANDS-}" ]]
#}

    # Die if the passed alias name is already a defined callable.
#   is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
#       die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"
    # Return true if the current user requests Zeshy wrap interactively run core
    # commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#   [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]

    #FIXME: Hmm; disabling the function makes piped calls such as:
    #cat /proc/cpuinfo|cat
    #...fail, which is clearly undesirable.
# void interactive_alias_of_core_command(string alias_specification)
#
# Declare the passed specification as an interactive alias if .
# See interactive_alias() for further details.
#interactive_alias_of_core_command() {
#    is_zeshy_wrapping_core_commands and
#    interactive_alias ls='list_path_concisely'
#}

# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.

#   print --\
#       '[[ -p /dev/stdin && ${#} -eq 0 ]] && '\
#       'set -- "${@}" "$(< /dev/stdin)"'"; (( ${1} )) || die"
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
#       "is -p /dev/stdin si and not (( ${1} )) and set -- "\

#       typeset command
#       if [[ -o interactive && \${#funcstack} -eq 1 ]]
#       then command=\"${(q)alias_expansion}\"
#       else command=\"${(q)alias_expansion_if_non_interactive}\"
#       fi
#       if is_piped_input
#       then run_with_piped_input \${command}
#       else                     \${command}
#       fi

#           if is_piped_input
#           then run_with_piped_input ${alias_expansion}
#           else ${alias_expansion}
#           fi
#       then ${alias_expansion}
#       else ${alias_expansion_if_not_interactive}
# bool is_terminal(void)
#
# Return true if shell output is attached to a terminal device. Specifically,
# return true if the file descriptor for standard output is open and attached to
# a terminal. (Avoid testing standard input, as commands passed piped input may
# still be "attached" to a terminal.) Do not implement this as a function, as a
# functions tests theirs rather than their callers' file descriptors.
#alias is_terminal='is -t ${ZESHY_STDOUT} si'

# bool is_color_terminal(void)
#
# Return true if the current shell is attached to a color-aware terminal device
# supporting at least the customary 8 colors (i.e., black, white, red, green,
# blue, yellow, magenta, and cyan).
#alias is_color_terminal='is_terminal and (( terminfo[colors] >= 8 ))'

#alias die_unless_no_args=die_if_args

# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FIXME: Reads a bit awkwardly, and superfulous. Supplant everywhere with
#"not is_args".

# void prepend_args(string arg1, string arg2, ...)
#
# Prepend the passed arguments to the beginning of the current argument list.
#alias prepend_args='set_args "${@}"'

# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the "global_alias" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a Zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "global_map const set" expands to
#   "proclaim global_map const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., global_map, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FIXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       curse "\"${command_name}\" not a Zsh builtin or command in \$PATH"
#       return_failure
#   fi

# void interactive_alias_if_installed(string alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#interactive_alias_if_installed() {
#    FIXME: Rewrite. Only call interactive_alias if the passed command is installed.
#    interactive_alias "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FIXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#global_alias equals='-eq'
#global_alias deceeds='-lt'
#global_alias deceeds_or_equals='-le'
#global_alias exceeds='-gt'
#global_alias exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   global_list two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#global_alias global='-x'

# Mark the declared variable as constant (i.e., read-only). By Zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#global_alias const='-r'
