#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string repeaters* (i.e., functions repeating strings, typically for
ensuring padded, aligned, and/or otherwise structured output).
/---

# ....................{ SETTERS                            }....................
# Such functions are transitively called by print_exception() via
# output_call_stack_lists_with_style_prefix() and hence subject to the same
# constraints: namely, to avoid calling other functions from such functions
# unless explicitly preceding such calls with tests of whether such functions
# are still defined or not.

declare_function_with_stdin <<'/---'
void set_integer_to_string_length_printable(
    string integer_name,
    string text1, ...)

Set the passed integer to the total length in printable multibyte characters of
the passed strings excluding ANSI escape sequences in such strings. See
get_string_length_printable() for a getter analogue and
get_string_ansiless_length_printable() for further details. e.g.,

.set_integer_to_string_length_printable()
==========================================
[source]
------------------------------------------
>>> integer length
>>> string on_theology=\
...    "Nobushige, a respected samurai, came to Hakuin and asked, \"Is there
...     really a heaven and hell?\"
...     \"Who are you?\" inquired Hakuin.
...     \"A samurai,\" Nobushige replied.
...     \"You, a samurai!\" exclaimed Hakuin. \"What kind of ruler would have
...     you as his guard? Your face looks like that of a beggar.\"
...     In anger, Nobushige drew his sword. Hakuin continued, \"Oh, you have a
...     sword? Your weapon is probably too dull to even cut off my head.\"
...     As Nobushige raised his sword, Hakuin remarked, \"Here open the gates of
...     hell.\"
...     As Nobushige lowered his sword, Hakuin intoned, \"Here open the gates of
...     heaven.\""
>>> set_integer_to_string_length_printable length "${on_theology}"
>>> output_string "${length}"
568
>>> set_integer_to_string_length_printable length\
...     "${ZESHY_STYLE_TO_COLOR[color.black]}${on_theology}"
>>> output_string "${length}"
568
------------------------------------------
==========================================
/---
function set_integer_to_string_length_printable() {
    # Validate sanity. Yes, capturing such string to a local variable is
    # necessary due to a probable zsh bug. See get_string_length() for further
    # details.
    die_unless_args_2_or_more\
        'Expected one integer name and one or more strings.'
    string integer_name__sitslp="${1}" text__sitslp="${*[2,-1]}"

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_string() and is_list for further details.
    is "${(tP)integer_name__sitslp-}" == 'integer'* si or die\
        "\${${integer_name__sitslp}} undefined or not an integer variable."
    is "${(t)ZESHY_ANSI_GLOB}" == 'scalar'* si or die\
         "\${ZESHY_ANSI_GLOB} undefined or not a string variable."

    # Set such length. For efficiency, inline such implementation. See
    # set_string_to_string() and get_string_length_printable() for further details.
    noop "${(P)integer_name__sitslp::=${(m)#${text__sitslp//${~ZESHY_ANSI_GLOB}}}}"
}

#FIXME: If any function begged for examples, this would be it.
#FIXME: It's possible to create a generalized version of this function named
#set_string_to_string_repeated_to_length() accepting any padding regardless of
#whether such padding contains ANSI escape sequences. Doing so requires code
#similar to that shifted to the wastelands (grep for
#"repetition_count__sstsartl"): namely, manually calculating whether the length
#of such padding excluding ANSI escape sequences evenly divides the passed
#length and, if not, appending the leftmost subset of such padding (again
#excluding ANSI escape sequences, which may be easier said than done). In such
#case, repetition must use the generalized printf() technique rather than the
#parameter expansion flag "(r...)" technique below. In other words, such
#function will have a completely different and considerably more complex and
#less efficient implementation. It'll probably be important at some point -- but
#it certainly isn't now!
declare_function_with_stdin <<'/---'
void set_string_to_string_ansiless_repeated_to_length(
    string string_name,
    string padding,
    integer length)

Set the passed string variable to the passed padding *NOT* containing ANSI
escape sequences repeated until producing a string of exactly the passed length.
If such length is _not_ evenly divided by the length of such padding, the last
repetition of such padding will be truncated on the right by as many characters
as needed to guarantee producing a string of exactly the passed length.

== Caveats ==

*Avoid embedding ANSI escape sequences in such padding.* Doing so over-reports
such padding's length, producing a string of insufficient length.
/---
function set_string_to_string_ansiless_repeated_to_length() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one string name, one padding string, and one length.'
    string\
        string_name__sstsartl="${1}"\
        padding__sstsartl="${2}"\
        length__sstsartl="${3}"\
        remainder__sstsartl
    character token__sstsartl

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_string() and is_list for further details.
    is "${(tP)string_name__sstsartl-}" == 'scalar'* si or die\
        "\${${string_name__sstsartl}} undefined or not a string variable."

    # Validate remaining arguments. See die_unless_string_nonempty() and
    # die_unless_integer_nonnegative() for further details.
    is -n "${padding__sstsartl}" si or die 'Expected nonempty padding.'
    is "${length__sstsartl}" == <-> si or die\
        "Length \"${length__sstsartl}\" less than zero or not an integer."

    # Parameter expansion token suitable for repeating such padding. If no such
    # token exists, an exception will be thrown. While this would typically be
    # problematic, padding strings are typically succinct and hence unlikely to
    # contain all possible parameter expansion tokens. Moreover, the general-
    # purpose solution (avoiding such tokens) is substantially more complex,
    # more error prone, and less efficient than the token-based solution
    # implemented below.
    set_character_to_string_parameter_expansion_token\
        token__sstsartl "${padding__sstsartl}"

    # Repeat such string. While the length of such padding is not guaranteed to
    # divide the passed length, parameter expansion flag "(r...)" guarantees
    # that in such case the last repetition of such padding only expands to the
    # leftmost substring of such padding producing a string of exactly the
    # passed length: e.g.,
    #
    #     >>> print ${(r:6::=~-:):-}
    #     =~-=~-
    #     >>> print ${(r:8::=~-:):-}
    #     =~-=~-=~
    #
    # Parameter expansion flag "(l...)" behaves similarly except that in such
    # case the first repetition of such padding only expands to the rightmost
    # substring of such padding producing a string of exactly the passed length.
    # Since this does *NOT* produce the expected result, the implementation
    # below leverages flag "(r...)" instead: e.g.,
    #
    #     >>> print ${(l:6::=~-:):-}
    #     =~-=~-
    #     >>> print ${(l:8::=~-:):-}
    #     ~-=~-=~-
    eval ${string_name__sstsartl}'="${(r'${token__sstsartl}${length__sstsartl}${token__sstsartl}${token__sstsartl}${padding__sstsartl}${token__sstsartl}'):-}"'
}

#FIXME: In lieu of unit tests...
#function biso() {
#    string text padding="=>/{"
#    set_string_to_string_ansiless_repeated_to_length text "${padding}" 9
#    output_string "padding: ${padding}; result length: 9; result: ${text}"
#}

# --------------------( WASTELANDS                         )--------------------
    # For efficiency, inline the equivalent of:
    # 
    #     >>> get_string_ansiless_length_printable "$(remove_string_ansi "${@}")"
#FUXME: Remove entirely. Existing calls to this function should be changed to
#call get_string_length_printable() instead. The whole "_sans_ansi"
#concept is fundamentally flawed, as discussed below.
#FUXME: Bad nomenclature, I'm afraid. set_integer_to_string_length_printable()
#should be a general-purpose function and hence exclude the length of non-
#printable ANSI escape sequences. Hence, this function should be renamed to
#set_integer_to_string_length_printable() and shifted to a more appropriate
#parcel (e.g., @{variable/string/set}). Naturally, the existing
#get_string_ansiless_length_printable() function should internally defer to
#set_integer_to_string_length_printable().

#    integer\
#        padding_length__sstsartl\
#        repetition_count__sstsartl\
#        remainder_length__sstsartl
    # Padding length. See get_string_ansiless_length_printable() for further details.
#    padding_length__sstsartl=${(m)#padding__sstsartl}
#
#    # Number of times to completely repeat the passed padding. If such padding's
#    # length evenly divides the passed length, such repetition suffices to
#    # produce the requested string; else, a leftmost substring of such padding
#    # must be appended to such repetition to produce the requested string.
#    repetition_count__sstsartl=$((\
#        string_length__sstsartl / padding_length__sstsartl ))
#
#    # Length of the longest leftmost substring of such padding needed to produce
#    # a string of exactly the passed length. If such padding's length evenly
#    # divides the passed length, this is 0; else, this is a positive integer.
#    remainder_length__sstsartl=$((\
#        string_length__sstsartl % padding_length__sstsartl ))
#
#    # If such length is a positive integer, then by the prior discussion such
#    # padding's length does *NOT* evenly divide the passed length. In such case,
#    # get the leftmost substring of such padding of such length.
#    if (( remainder_length__sstsartl != 0 )) {
#        remainder__sstsartl="${padding__sstsartl[1,${remainder_length__sstsartl}]}"
#    }

    # Set such string to the required repetition of such padding followed by the
    # leftmost substring of such padding. See set_string_to_string() and
    # repeat_string() for further details.

    #FUXME: Implement me. Copy from repeat_string(), yes?
