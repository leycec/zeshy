#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string repeaters* (i.e., functions repeating strings, typically for
ensuring padded, aligned, and/or otherwise structured output).
/---

# ....................{ SETTERS                            }....................
# Since print_exception() transitively calls this function via
# output_call_stack_lists_with_style_prefix(), this function is subject to the
# same constraints: namely, avoid calling other functions from this function
# unless explicitly preceding such calls with tests of whether such functions
# are still defined or not.

#FIXME: If any function begged for examples, this would be it.
declare_function_with_stdin <<'/---'
void set_string_to_string_padded_to_length(
    string string_name,
    string padding,
    integer length)

Set the passed string variable to the passed padding repeated until producing a
string of exactly the passed length. If such length is _not_ evenly divided by
the length of such padding, the last repetition of such padding will be
truncated on the right by as many characters as needed to guarantee producing a
string of exactly the passed length.
/---
function set_string_to_string_padded_to_length() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one string name, one padding string, and one length.'
    string\
        string_name__sstsptl="${1}"\
        padding__sstsptl="${2}"\
        string_length__sstsptl="${3}"\
        remainder__sstsptl
    character token__sstsptl
    integer\
        padding_length__sstsptl\
        repetition_count__sstsptl\
        remainder_length__sstsptl

    # See die_unless_string_nonempty() and die_unless_integer_nonnegative() for
    # further details.
    is -n "${padding__sstsptl}" si or die 'Expected nonempty padding.'
    is "${string_length__sstsptl}" == <-> si or die\
        "Length \"${string_length__sstsptl}\" not >= 0."

    # Padding length. See get_string_length_printable() for further details.
    padding_length__sstsptl=${(m)#padding__sstsptl}

    # Number of times to completely repeat the passed padding. If such padding's
    # length evenly divides the passed length, such repetition suffices to
    # produce the requested string; else, a leftmost substring of such padding
    # must be appended to such repetition to produce the requested string.
    repetition_count__sstsptl=$((\
        string_length__sstsptl / padding_length__sstsptl ))

    # Length of the longest leftmost substring of such padding needed to produce
    # a string of exactly the passed length. If such padding's length evenly
    # divides the passed length, this is 0; else, this is a positive integer.
    remainder_length__sstsptl=$((\
        string_length__sstsptl % padding_length__sstsptl ))

    # If such length is a positive integer, then by the prior discussion such
    # padding's length does *NOT* evenly divide the passed length. In such case,
    # get the leftmost substring of such padding of such length.
    if (( remainder_length__sstsptl != 0 )) {
        remainder__sstsptl="${padding__sstsptl[1,${remainder_length__sstsptl}]}"
    }

    #FIXME: Implement me. Copy from repeat_string(), yes?

    # Parameter expansion token suitable for repeating such padding with.
    if { set_character_to_string_parameter_expansion_token_if_found\
            token__sstsptl "${padding__sstsptl}" } {
        noop
    }

    # Set such string to the required repetition of such padding followed by the
    # leftmost substring of such padding. See set_string_to_string() and
    # repeat_string() for further details.
#   token__sstsptl
}

# --------------------( WASTELANDS                         )--------------------
