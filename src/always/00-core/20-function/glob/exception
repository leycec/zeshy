#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle exception globbing.
/---

# ....................{ CATCHERS                           }....................
#FIXME: Add example.
declare_function_with_stdin <<'/---'
<globbable> [status: boolean] catch_exception_matching_glob_if_found(
    string exception_glob)

Catch an exception matching the passed glob thrown by the `{...}` block
preceding the `always {...}` block presumably calling this function if an
exception was thrown matching such glob or return failure otherwise. In the
former case, this function ``catches'' such exception by setting string global
${CAUGHT} to ${EXCEPTION} (i.e., the string that was thrown), unsetting
${EXCEPTION}, and returning success. If no exception was thrown, was but does
_not_ match such glob, _or_ this function was _not_ called in an `always {...}`
block, failure is returned. See throw_exception() for further details.
/---
function catch_exception_matching_glob_if_found() {
    # Validate sanity.
    die_unless_arg 'Expected one glob.'
    die_unless_in_always

    # If an exception was thrown *AND* such exception matches such glob, return
    # success from both the current function and "always {...}" block *AND*
    # "catch" such exception as documented above.
    if (( ${+EXCEPTION} )) and is "${EXCEPTION}" == ${~1} si {
        TRY_BLOCK_ERROR=0
        string_global CAUGHT="${EXCEPTION}"
        clear_exception
        report_success
    }

    # Else, return failure.
    report_failure
}

# --------------------( WASTELANDS                         )--------------------
# undefine_variable EXCEPTION
#Since this function is typically called from within
    # exception handlers (i.e., "always {...}" blocks), return failure from such
    # handler rather than throwing yet another exception.
#    (( # == 1 )) || {
#        print "zeshy: catch_exception_matching_glob_if_found() expected one glob but received:\n${*}" 1>&2
#        (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#        return 1
#    }

# Permit globs to be passed unquoted to catch_exception_matching_glob_if_found()
# by disabling filename globbing for such function.
#alias    catch_exception_matching_glob_if_found='noglob catch_exception_matching_glob_if_found'

#FUXME: Shift to @{always/exception}. There's really no rational reason to have
#this here. Refactor print_exception_with_status() to manually implement such globbing and
#resultant handling. Yum!
