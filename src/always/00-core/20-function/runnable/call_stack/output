#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *call stack outputters* (i.e., functions printing the current call stack,
typically employed for printing exception stack traces).
/---

# For fault tolerance in exception handlers, avoid calling other functions in
# such functions unless explicitly preceding such calls with tests of whether
# such functions are still defined or not.

# ....................{ OUTPUTTERS                         }....................
declare_function_with_stdin <<'/---'
string output_call_stack_root_runnable(void)

Output the name of the runnable at the root of the current call stack (i.e., the
last runnable on such stack and hence originating such stack -- typically called
directly from the command line by the current user), using user-configurable
styles prefixed by the caller's name suffixed by `.runnable.` (i.e.,
`$(get_caller).runnable.`). See
output_call_stack_index_runnable_with_style_prefix() for further details.
/---
function output_call_stack_root_runnable() {
    die_if_args
    output_call_stack_index_runnable_with_lists_and_style_prefix\
        -1 funcstack funcsourcetrace "$(get_caller).runnable."
}

declare_function_with_stdin <<'/---'
string output_call_stack_index_runnable_with_lists_and_style_prefix(
    integer frame_index,
    string funcstack_list_name,
    string funcsourcetrace_list_name,
    string style_prefix)

Output the name of the runnable at the passed 1-based (positive or negative)
index of the call stack encapsulated by the passed instances of canonical list
globals ${funcstack} and ${funcsourcetrace}, using user-configurable styles
prefixed by the passed string.
/---
function output_call_stack_index_runnable_with_lists_and_style_prefix() {
    # Validate sanity.
    die_unless_args_4 'Expected one index, one ${funcstack} list name, one ${funcsourcetrace} list name, and one style prefix.'
    string\
        index__ocsirwlasp="${1}"
        funcstack_name__ocsirwlasp="${2}"\
        funcsourcetrace_name__ocsirwlasp="${3}"\
        style_prefix__ocsirwlasp="${4}"\
        runnable__ocsirwlasp
    integer count__ocsirwlasp

    # If any such list is undefined or not a list, fail.
    { (( ${+funcstack_name__ocsirwlasp} +\
         ${+funcsourcetrace_name__ocsirwlasp} == 2 )) and
      is "${(tP)funcstack_name__ocsirwlasp}" == 'array-'* si and
      is "${(tP)funcsourcetrace_name__ocsirwlasp}" == 'array-'* si } or die\
        "Lists \${${funcstack_name__ocsirwlasp}\} and/or \${${funcsourcetrace_name__ocsirwlasp}\} undefined."

    # If such index is not an integer, throw an exception. See is_integer() for
    # further details.
    is "${index__ocsirwlasp}" == ('-'|)<-> si or die\
        "\"${index__ocsirwlasp}\" not an integer."

    # Before performing further validation, resolve a subtlety resulting from
    # this being a function rather than alias and hence modifying the current
    # call stack. Specifically, if the desired call stack is the current call
    # stack, ignore the current function and all directly preceding functions
    # matching glob "output_call_stack_*_runnable*" calling such function.
    #
    # Since other functions matching such glob should *NOT* be ignored, zsh
    # array indexing flags (e.g., "(I)") do *NOT* suffice. Rather:
    #
    # * Manually find the call stack index of the first stack frame *NOT*
    #   matching such glob.
    # * Copy the sublist of the current call stack following such index into
    #   temporary local lists.
    # * Set the desired call stack list names to such list names.
    #
    # Such logic allows all subsequent code to remain the same, regardless of
    # whether the desired call stack is the current call stack. This is simpler
    # (though slightly less efficient) than implementing optimized logic for
    # when the desired call stack is the current call stack. *shrug*
    if is "${funcstack_name__ocsirwlasp}" == 'funcstack' si {
        # For obvious reasons, skip the first such index. Since this guarantees
        # such index to exceed 1, a list copy is *ALWAYS* required.
        integer index_first__ocsirwlasp
        for ((  index_first__ocsirwlasp=2;
                index_first__ocsirwlasp <= count__ocsirwlasp;
                index_first__ocsirwlasp++ )) {
            is "${${(@P)funcstack_name__ocsirwlasp}[${index_first__ocsirwlasp}]}" ==\
               'output_call_stack_'*'_runnable'* si or break
        }

        list funcstack__ocsirwlasp funcsourcetrace__ocsirwlasp
        funcstack__ocsirwlasp=(       "${funcstack[${index_first__ocsirwlasp},-1]}" )
        funcsourcetrace__ocsirwlasp=( "${funcsourcetrace[${index_first__ocsirwlasp},-1]}" )
        funcstack_name__ocsirwlasp='funcstack__ocsirwlasp'
        funcsourcetrace_name__ocsirwlasp='funcsourcetrace__ocsirwlasp'
    }

    # Size of the first such list. See get_list_size() for further details.
    count__ocsirwlasp="${#${(@P)funcstack_name__ocsirwlasp}}"

    # If such lists are of unequal size, throw an exception.
    (( count__ocsirwlasp == ${#${(@P)funcsourcetrace_name__ocsirwlasp}} )) or
        die "List \${${funcstack_name__ocsirwlasp}\} size ${count__ocsirwlasp} unequal to list \${${funcsourcetrace_name__ocsirwlasp}\} size ${#${(@P)funcsourcetrace_name__ocsirwlasp}}."

    # If such index is not a valid index of such call stack, throw an exception.
    # See is_call_stack_index() for further details.
    (( (1 <= index__ocsirwlasp && index__ocsirwlasp <= count__ocsirwlasp) ||
       (-count__ocsirwlasp <= index__ocsirwlasp && index__ocsirwlasp <= -1) )) or {
        die "\"${index__ocsirwlasp}\" not an index of list \${${funcstack_name__ocsirwlasp}\} (i.e., not in [-${count__ocsirwlasp}, ${count__ocsirwlasp}])."

    # Indexed runnable name.
    runnable__ocsirwlasp="${${(@P)funcstack_name__ocsirwlasp}[${index__ocsirwlasp}]}"

    # If such root is a script, get such script's basename. To reduce dependency
    # on external functions, inline such implementation. See get_path_basename()
    # for further details.
    if { is_call_stack_index_script "${call_stack_root}" }
        return_string "${call_stack_root:t}"
    # Else, such root is a function or eval(). Return such root as is.
    } else {
        return_string "${call_stack_root}"
    }
}

# ....................{ OUTPUTTERS ~ stack                 }....................
declare_function_with_stdin <<'/---'
string output_call_stack(void)

Output a trace of the current call stack to standard output. See
output_call_stack_with_lists() for further details.
/---
function output_call_stack() {
    output_call_stack_with_lists funcstack funcfiletrace funcsourcetrace
}

#FIXME: There appears to be a very curious oddity in zsh; sourcing a zsh script
#containing the line "return 1" produces the expected call stack, resembling:
#
#./tmpy.zsh: failed with exit status 1
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 8458093679346917924 }
#      \_ TRAPZERR() { ./tmpy.zsh: 2 }
#       \_ ./tmpy.zsh { zsh: 32 }
#
#Running a zsh script containing the line "exit 1" as a command, however,
#produces call stacks resembling:
#
#TRAPZERR: failed with exit status 20
#    \_ curse_call_stack() { /home/leycec/zsh/zeshy/src/main: 418 }
#     \_ handle_exception() { /home/leycec/zsh/zeshy/src/main: 7955925549229362501 }
#      \_ TRAPZERR() { /bin/zsh: 31 }
#
#In the latter case, zsh reports the call stack to contain no such command. But
#it gets worse! zsh fails to include commands in *ALL* call stacks; try
#"command ls zzmmmm", for example. This tends to produce inherently senseless
#error output. I suggest one of two solutions:
#
#* If "TRAPZERR" is the top of the call stack, print no call stack. (It's
#  meaningless, so don't even bother.) This is most certainly the simplest
#  solution. (Actually, I tried this. It blatantly sucks.)
#* Forcefully add the expected command to the top of the call stack. This is
#  much better, since the prior solution still crudely reports
#  "TRAPZERR: failed with exit status 20" when in fact we expect
#  "./tmpy.zsh: failed with exit status 1". Just not sure how to *GET* the
#  expected command name or exit status.

declare_function_with_stdin <<'/---'
string output_call_stack_with_lists(
    string funcstack_list_name,
    string funcfiletrace_list_name,
    string funcsourcetrace_list_name)

Output a trace of the call stack encapsulated by the passed instances of
canonical list globals ${funcstack}, ${funcfiletrace}, and ${funcsourcetrace} to
standard output.

If print_exception_with_status() called this function (the typical case), both
the call to this function by print_exception_with_status() _and_ the call to
print_exception_with_status() will be omitted from the output. As implementation
details of `zeshy`-specific exception handling, such calls convey no meaningful
context to end consumers of exception stack traces.

consisting of all previously called
functions, sourced files, and `eval` statements in the current call path,
excluding only the stack frame of the caller's call to this function.

== Call Stack Globals ==

Module `zsh/parameter` exports four call stack-centric list globals:
${funcfiletrace}, ${funcsourcetrace}, ${funcstack}, and ${functrace}.

=== ${funcfiletrace} and ${funcsourcetrace} ===

Each element of ${funcfiletrace} and ${funcsourcetrace} provides the `:`-
delimited line number and filename of the corresponding runnable in the call
stack. In the case of ${funcfiletrace}, such line numbers and filenames specify
the *point of call* of such runnables (i.e., the line at which such runnable was
called in such file); in the case of ${funcsourcetrace}, such line numbers and
filenames specify the *point of definition* of such runnables (i.e., the line at
which such runnable was defined in such file).

For most purposes (including outputting call stacks), points of call are more
helpful than points of definition. However, the latter do provide unique
metadata _not_ provided by any other such list: namely, the capacity to
distinguish whether a runnable was a called function or sourced file. Since
function names may contain arbitrary characters and filenames arbitrary
characters excluding `/` and `\0`, there exists no general-purpose means of
distinguishing between the two merely on the basis of name alone.

Happily, ${funcsourcetrace} circuitously corrects this issue. If a runnable was
a sourced file, the corresponding element of ${funcsourcetrace} is suffixed by
`:0`; else, such element is suffixed by `:${line_number}`, where
`${line_number}` is a strictly positive integer.

Hence, this function requires both lists.

=== ${funcstack} ===

Each element of ${funcstack} provides the name of the corresponding runnable in
the call stack. Since neither ${funcfiletrace} or ${funcsourcetrace} provide
such metadata, this function also requires the ${funcstack} for such call stack.

=== ${functrace} ===

Each element of ${functrace} provides the `:`-delimited line number and filename
of the point of call for the corresponding runnable in the call stack. Since
such line number is relative to the start of the runnable rather than file
containing such call _and_ since ${funcfiletrace} already provides such line
number and filename in *absolute form* (i.e., relative to the file rather than
runnable containing such call), this function does _not_ require such list.

== Caveats ==

*Consider redirecting such output to standard error*, especially when
accompanying such stack with error or warning messages. Doing so ensures that
calling this function from process substitutions (e.g., `$(get_zsh_version)`)
implicitly outputs to the terminal device attached to the current shell rather
than into a string captured by such shell.
/---
function output_call_stack_with_lists() {
    # Validate sanity. For safety, avoid calling other functions both here and
    # below that might conceivably throw exceptions or no longer exist. On the
    # other hand, since zsh expands aliases at function definition time,
    # expanding aliases is quite safe.
    die_unless_args_3\
        'Expected one funcstack list name, one funcfiletrace list name, and one funcsourcetrace list name.'
    string\
        funcstack_name__pcswfaf="${1}"\
        funcfiletrace_name__pcswfaf="${2}"\
        funcsourcetrace_name__pcswfaf="${3}"\
        indentation__pcswfaf\
        corner_left_first__pcswfaf\
        border_left_first__pcswfaf\
        joiner_left_first__pcswfaf\
        corner_left_tween__pcswfaf\
        border_left_tween__pcswfaf\
        joiner_left_tween__pcswfaf\
        corner_left_last__pcswfaf\
        border_left_last__pcswfaf\
        joiner_left_last__pcswfaf\
        callee_name__pcswfaf\
        callee_eval_prefix__pcswfaf\
        callee_eval_suffix__pcswfaf\
        callee_function_prefix__pcswfaf\
        callee_function_suffix__pcswfaf\
        callee_filename_prefix__pcswfaf\
        callee_filename_suffix__pcswfaf\
        caller_filename_prefix__pcswfaf\
        caller_parens_left__pcswfaf\
        caller_parens_right__pcswfaf\
        caller_filename_suffix__pcswfaf\
        caller_filename__pcswfaf\
        caller_line_prefix__pcswfaf\
        caller_line_suffix__pcswfaf
    integer\
        frame_count__pcswfaf\
        frame_index__pcswfaf\
        frame_index_first__pcswfaf\
        caller_line__pcswfaf

    # If any such list is undefined or not a list, fail.
    { (( ${+funcstack_name__pcswfaf} +\
         ${+funcfiletrace_name__pcswfaf} +\
         ${+funcsourcetrace_name__pcswfaf} == 3 )) &&
      [[ "${(tP)funcstack_name__pcswfaf}" == 'array-'* ]] &&
      [[ "${(tP)funcfiletrace_name__pcswfaf}" == 'array-'* ]] &&
      [[ "${(tP)funcsourcetrace_name__pcswfaf}" == 'array-'* ]] } || die\
        "Lists \${${funcstack_name__pcswfaf}\}, \${${funcfiletrace_name__pcswfaf}\}, and/or \${${funcsourcetrace_name__pcswfaf}\} undefined."

    #FIXME: If such lists are not of the same size, throw an exception.

    # Substrings prefixing each line printed below.
    corner_left_first__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.corner_left_first__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.corner_left_first__pcswfaf]-\\}"
    border_left_first__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.border_left_first__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.border_left_first__pcswfaf]-_}"
    joiner_left_first__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.joiner_left_first__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.joiner_left_first__pcswfaf]- }"
    corner_left_tween__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.corner_left_tween__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.corner_left_tween__pcswfaf]-\\}"
    border_left_tween__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.border_left_tween__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.border_left_tween__pcswfaf]-_}"
    joiner_left_tween__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.joiner_left_tween__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.joiner_left_tween__pcswfaf]- }"
    corner_left_last__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.corner_left_last__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.corner_left_last__pcswfaf]-\\}"
    border_left_last__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.border_left_last__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.border_left_last__pcswfaf]-_}"
    joiner_left_last__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.joiner_left_last__pcswfaf]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.joiner_left_last__pcswfaf]- }"

    # All other substrings printed below.
    callee_eval_prefix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_eval_prefix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.callee_eval_prefix]-}${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_eval]-}"
    callee_eval_suffix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_eval_suffix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.callee_eval_suffix]-()}"
    callee_function_prefix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_function_prefix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.callee_function_prefix]-}${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_function]-}"
    callee_function_suffix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_function_suffix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.callee_function_suffix]-()}"
    callee_filename_prefix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_filename_prefix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.callee_filename_prefix]-\"}${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_filename]-}"
    callee_filename_suffix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.callee_filename_suffix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.callee_filename_suffix]-\"}"
    caller_parens_left__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_parens_left]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.caller_parens_left]-\{ }"
    caller_parens_right__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_parens_right]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.caller_parens_right]-\{ }"
    caller_filename_prefix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_filename_prefix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.caller_filename_prefix]-\"}${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_filename]-}"
    caller_filename_suffix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_filename_suffix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.caller_filename_suffix]-\"}"
    caller_line_prefix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_line_prefix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.caller_line_prefix]-: }${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_line]-}"
    caller_line_suffix__pcswfaf="${ZESHY_STYLE_TO_COLOR[output_call_stack.caller_line_suffix]-}${ZESHY_STYLE_TO_TEXT[output_call_stack.caller_line_suffix]-}"

    #FIXME: Reduce to a manual check. No calling of external functions allowed!
    # Get the number of stack frames on such call stack.
    frame_count__pcswfaf="$(get_list_size "${funcstack_name__pcswfaf}")"

    # If the call stack contains at least three stack frames *AND*
    # print_exception_with_status() called this function (which is the customary
    # case), set the first stack frame to be printed to the caller of
    # print_exception_with_status() rather than this function call. As
    # zeshy-specific implementation details, such calls convey no context to
    # zeshy users and hence must be ignored. While hardly essential, this does
    # improve the utility of output.
    if (( frame_count__pcswfaf >= 3 )) and
        is "${${(@P)funcstack_name__pcswfaf}[2]}" == 'print_exception_with_status' si {
        frame_index_first__pcswfaf=3
    # Else, set the first stack frame to be printed to this function call.
    } else {
        frame_index_first__pcswfaf=1
    }

    #FIXME: Reduce to a manual check. No calling of external functions allowed!
    #Hmmmm; actually, repeating an arbitrary string is quite non-trivial. We'll
    #need to check for the existence of such function and shift it's definition
    #under @{00-core/20-function}.
    #FIXME: Actually, no! I recall it's quite feasible generally using only
    #slightly slower {..} globbing.

    #FIXME: Such calculation assumes each border substring to be a single
    #character. Fine for now, of course, but contemplate generalization.

    # Repeat each border substring sufficiently many times to ensure vertical
    # alignment of the callee name following such border: e.g.,
    #
    #    ┠┈┈┈•
    #    ┖┰┈┈•
    #     ┖┰┈•
    #      ┖┈•
    #
    # As the prior example demonstrates, the first line requires one character
    # less than the frame count of such substring, the last line exactly one
    # such character, and every other line one less such character than the
    # prior character.
    border_left_first__pcswfaf="$(repeat_string "${border_left_first__pcswfaf}" "$(( frame_count__pcswfaf - frame_index__pcswfaf ))")"
    border_left_tween__pcswfaf="$(repeat_string "${border_left_tween__pcswfaf}" "$(( border_left_first__pcswfaf - 1 ))")"

    # Print such stack, excluding the call to this function.
    for (( frame_index__pcswfaf  = frame_index_first__pcswfaf;
           frame_index__pcswfaf <= frame_count__pcswfaf;
           frame_index__pcswfaf++ )) {
        # If this is the first stack frame to be printed, prefix such frame with
        # adornment specific to such frame.
        if (( frame_index__pcswfaf == frame_index_first__pcswfaf )) {
            output_string_sans_newline\
                "${corner_left_first__pcswfaf}${border_left_first__pcswfaf}${joiner_left_first__pcswfaf}"
        # If this is the last stack frame to be printed, prefix such frame with
        # adornment specific to such frame.
        } elif (( frame_index__pcswfaf == frame_count__pcswfaf )) {
            output_string_sans_newline\
                "${indentation__pcswfaf}${corner_left_last__pcswfaf}${border_left_last__pcswfaf}${joiner_left_last__pcswfaf}"
        # Else, prefix such frame with customary adornment.
        } else {
            # If this is at or after the third stack frame to be printed, indent
            # such frame to the right. See the prior output examples.
            if (( frame_index__pcswfaf > frame_index_first__pcswfaf + 1 )) {
                indentation__pcswfaf+=' '
            }

            # Truncate such border by one arbitrary character. For simplicity,
            # snip off the rightmost character.
            border_left_tween__pcswfaf="${border_left_tween__pcswfaf[1,-2]}"

            # Print such prefix.
            output_string_sans_newline\
                "${indentation__pcswfaf}${corner_left_tween__pcswfaf}${border_left_tween__pcswfaf}${joiner_left_tween__pcswfaf}"
        }

        # Get the function name, file line, and filename at which the caller of
        # the prior stack frame called the current stack frame.
        #
        # Split the current stack frame's ${funcfiletrace} entry on the last
        # colon in such entry into such file line and filename, thus accounting
        # for possible colons in filenames (e.g., from "colon:blow:7" to
        # filename "colon:blow" and line number 7).
        callee_name__pcswfaf="${${(@P)funcstack_name__pcswfaf}[${frame_index__pcswfaf}]}"
        caller_line__pcswfaf="${${(@P)funcfiletrace_name__pcswfaf}[${frame_index__pcswfaf}]##*:}"
        caller_filename__pcswfaf="${${(@P)funcfiletrace_name__pcswfaf}[${frame_index__pcswfaf}]%:*}"

        #FIXME: Actually, this should just call 
        #output_call_stack_root_with_lists_and_style_prefix() now.

        # If the callee for this frame was a sourced script, print such callee
        # accordingly. See is_call_stack_index_script() for further details.
        if is "${${(@P)funcsourcetrace_name__pcswfaf}[${frame_index__pcswfaf}]}" == *':0' si {
            output_string_sans_newline\
                "${callee_filename_prefix__pcswfaf}${callee_name__pcswfaf}${callee_filename_suffix__pcswfaf}"
        # Else if such callee was an eval() statement, print such callee
        # accordingly.
        } elif is "${callee_name__pcswfaf}" == '(eval)' si {
            output_string_sans_newline\
                "${callee_eval_prefix__pcswfaf}eval${callee_eval_suffix__pcswfaf}"
        # Else, such callee was a called function. Print such callee
        # accordingly.
        } else {
            output_string_sans_newline\
                "${callee_eval_function__pcswfaf}${callee_name__pcswfaf}${callee_eval_suffix__pcswfaf}"
        }

        # Print all remaining metadata for such frame.
        output_string\
            "${caller_parens_left__pcswfaf}${caller_filename_prefix__pcswfaf}${caller_filename__pcswfaf}${caller_filename_suffix__pcswfaf}${caller_line_prefix__pcswfaf}${caller_line__pcswfaf}${caller_line_suffix__pcswfaf}${caller_parens_right__pcswfaf}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#declare_function_with_stdin <<'/---'
#string output_call_stack_index_runnable_with_style_prefix(
#    integer frame_index, string style_prefix)
#
#Output the name of the runnable at the passed 1-based positive or negative index
#of the current call stack, using user-configurable styles prefixed by the passed
#string. See output_call_stack_index_runnable_with_lists_and_style_prefix() for
#further details.
#/---
#function output_call_stack_index_runnable_with_style_prefix() {
#    die_unless_args_2 'Expected one index and one style prefix.'
#    output_call_stack_index_runnable_with_lists_and_style_prefix\
#        "${1}" funcstack funcsourcetrace "${2}"
#}

#declare_function_with_stdin <<'/---'
#string output_call_stack_index_runnable(integer index)
#
#Output the name of the runnable at the passed 1-based positive or negative index
#of the current call stack, using user-configurable styles prefixed by the
#caller's name suffixed by `.runnable.` (i.e., `$(get_caller).runnable.`). See
#output_call_stack_index_runnable_with_style_prefix() for further details.
#/---
#function output_call_stack_index_runnable() {
#    die_unless_arg 'Expected one index.'
#    output_call_stack_index_runnable_with_style_prefix\
#        "${1}" "$(get_caller).runnable."
#}

    #FUXME: Reduce to a manual check. No calling of external functions allowed!
#    die_unless_lists\
#        "${funcstack_name__pcswfaf}"\
#        "${funcfiletrace_name__pcswfaf}"\
#        "${funcsourcetrace_name__pcswfaf}"

#FUXME: Rename to output_call_stack_root(). There! I said it. Senseless
#nomenclature before, I'm afraid. Naturally, we'll want a corresponding
#output_call_stack_root_with_style_prefix().
#print 'in @{call_stack/output}'

#FUXME: Excise. It's a single point of failure, and I don't particularly want to
#bothering with checking for its existence. Merge directly into
#print_exception().
#declare_function_with_stdin <<'/---'
#string output_exception_call_stack(void)
#
#Output a trace of the call stack for the currently thrown exception to standard
#output. See output_call_stack_with_lists() for further details.
#/---
#function output_exception_call_stack() {
#    die_unless_exception
#    output_call_stack_with_funcstack_and_funcfiletrace\
#        ZESHY_EXCEPTION_FUNCSTACK\
#        ZESHY_EXCEPTION_FUNCFILETRACE\
#        ZESHY_EXCEPTION_FUNCSOURCETRACE
#}

#Handle *call stack outputters* (i.e., the stack of all called `zsh`
#functions, sourced `zsh` scripts, and evaluated eval() statements on the current
#call path) functionality.

        #FUXME: Actually, ${filesourcetrace} might provide us a way of
        #distinguishing between whether the current runnable is a called
        #function or sourced file. Such list defines the line and filename at
        #which such runnable is defined -- which should only apply to functions:
        #
        #"funcsourcetrace
        #      ...for files that have been executed by the source or `.'
        #      builtins, the trace information is shown as filename:0, since the
        #      entire file is the definition."
        #
        #So that's how we distinguish between the two, assuming functions called
        #on the first line of a file have trace information "filename:1". (Which
        #seems reasonable but must be tested, of course.)
        #FUXME: O.K.; I've confirmed the above assumption to be the case. We'll
        #need to be passed ${filesourcetrace} as well then, I'm afraid.

        # If this frame signifies a called function, append "()" to such name. Sadly,
        # if a script with the same name exists (which is technically feasible,
        # given zsh support for arbitrary function names), there appears to be
        # no simple way of discerning between the two. *shrug*
#        if { typeset -f -- "${callee_name__pcswfaf}" &>/dev/null } {
#            output_string_sans_newline\
#                "${ZESHY_STYLE_TO_COLOR[output_call_stack.function_name]-}${callee_name__pcswfaf}${ZESHY_STYLE_TO_COLOR[output_call_stack.function_parens]-}()"
#        # If this frame signifies an "eval" statement, color accordingly.
#        } elif is "${callee_name__pcswfaf}" == '(eval)' si {
#            output_string_sans_newline\
#                "${ZESHY_STYLE_TO_COLOR[output_call_stack.eval_parens]-}(${ZESHY_STYLE_TO_COLOR[output_call_stack.eval_name]-}eval${ZESHY_STYLE_TO_COLOR[output_call_stack.eval_parens]-})"
#        # Else, this frame signifies a shell script. Color accordingly.
#        } else {
#            output_string_sans_newline\
#                "${ZESHY_STYLE_TO_COLOR[output_call_stack.script_quotes]-}\"${ZESHY_STYLE_TO_COLOR[output_call_stack.script_name]-}${callee_name__pcswfaf}${ZESHY_STYLE_TO_COLOR[output_call_stack.script_quotes]-}\""
#        }

        #FUXME: Increment the padding by one instead.
        # Indent the next stack frame to the right.
#       frame_prefix__pcswfaf=" ${frame_prefix__pcswfaf}"
#             is_frame_first__pcswfaf="${ZESHY_BOOLEAN_FALSE}"
#           output_string_sans_newline "${frame_prefix_first__pcswfaf}"
#           output_string_sans_newline "${frame_prefix_tween__pcswfaf}"

    # True if the current stack frame is the first such frame to be printed.
#    boolean is_frame_first__pcswfaf
#    is_frame_first__pcswfaf="${ZESHY_BOOLEAN_TRUE}"

#       if (( is_frame_first__pcswfaf )) {
#             is_frame_first__pcswfaf="${ZESHY_BOOLEAN_FALSE}"
#       frame_prefix_first__pcswfaf\
#       frame_prefix_tween__pcswfaf\
#   frame_prefix_first__pcswfaf="${corner_left_first__pcswfaf}${border_left_first__pcswfaf}${joiner_left_first__pcswfaf}"
#   frame_prefix_tween__pcswfaf="${corner_left_tween__pcswfaf}${border_left_tween__pcswfaf}${joiner_left_tween__pcswfaf}"
    #FUXME: If we ever need to calculate string lengths, do *NOT* embed colors
    #in such substrings until *AFTER* calculating their string lengths, below.
    #FUXME: Shift this to a ${ZESHY_STYLE_TO_TEXT}-based approach.
    #FUXME: Prefer UTF-8-specific multibyte aesthetics on capable terminals.

#FUXME: Fix the example. Don't just *SAY* what happens. Actually *SHOW* it.
#Print a trace of the current call stack consisting of all previously called
#functions, sourced files, and `eval` statements in the current call path,
#excluding only the stack frame of the caller's call to this function.
#
#Consider redirecting such output to standard error, especially when accompanying
#such stack with error or warning messages. Doing so ensures that calling this
#function from process substitutions (e.g., `$(get_zsh_version)`) prints to the
#terminal device attached to the current shell rather than into a string captured
#by such shell -- without requiring such shell explicitly print such stack: e.g.,
#
#.output_call_stack()
#==========================================
#[source]
#------------------------------------------
## Assuming neither "/spider" or "/murphy" exist, the following command
## substitution throws an exception printing a call stack trace to
## standard error without effort on our behalf.
#>>> string first_file; first_file="$(get_first_file /spider /murphy)"
#------------------------------------------
#==========================================

#FUXME: Oh, yeah? Like what? Any such functions should be shifted under
#@{00-core}, if they can't be outright implemented inline.

# Such functions call functions unavailable at @{00-core} time and hence not
# shiftable to the prior parcel of the same name.

# for the _not_ handled by the prior parcel of the same name
#``Away with ye, matey!'' and hence benefit from exclusion.
    # First stack frame to be printed. , defaulting to the call to this function.
    # If print_exception_with_status() called this function, avoid printing both this
    # call and the call to print_exception_with_status(). As zeshy-specific internal
    # implementation details, such calls convey no useful context to external
    # zeshy users. (While hardly essential, this does improve output.)
    # Line, function name, and filename from which the caller of the previous
    # stack frame called the current stack frame.
#   integer caller_line__pcswfaf
#   string  callee_name__pcswfaf filename__pcswfaf

    # If either such list does not exist, throw an exception. See is_list() for
    # further details.
#    is -n "${(P)funcstack_name__pcswfaf+x}" and
#       -n "${(P)funcfiletrace_name__pcswfaf+x}" and
#        "${(tP)variable_name__il}" == (array|list)* and
#        "${(tP)variable_name__il}" == (array|list)* si or die\
#        ''

#    Referencing such
    # styles where  is strongly encouraged, unlike that of color pseudo-styles (e.g.,
    # "${ZESHY_STYLE_TO_COLOR[color.red:bold]}").
#   ╓•
#   ╙╥•
#    ╙╥•
#     ╙─•
#
#   ╘╤
#    ╘╤
#     ╘╤
#      ╘╤
#
#   ▙▖
#    ▙▖
#     ▙▖

# ....................{ PRINTERS                           }....................
#declare_function_with_stdin <<'/---'
#string output_call_stack(void)
#
#Print a trace of the current call stack. See output_call_stack() for further
#details.
#/---
#FUXME: Actually, implementing such function is non-trivial, since the mere act
#of calling output_call_stack() modifies the call stack. Two approaches:
#
#* In this function, attempt to shift the current call off the call stack. This
#  is the simplest and hence ideal fix, if zsh permits it. (Pleeease?)
#* Else, we'll need to convert output_call_stack() to an alias. It's
#  certainly... Oh, no. That doesn't work, as we'd then have to redefine the
#  die() function defined by @{main}. *sigh*
#function output_call_stack() {
#}

    # Delimit such output from prior output, if necessary.
#   start_stdout
    # Reset terminal attributes in preparation for subsequent output.
#   stop_stdout

        # Note that, when called due to an exception thrown from an interactive
        # alias, such alias will be disabled here and hence not be recognized as
        # a function. Since such alias signifies an alias and not a function,
        # this is (arguably) not a bug. (Nothin' to see here, folks.)

    # Update globals tracking state for start_stdout() calls.
#FUXME: Shift to "00-declare". This is all *REALLY* "early" functionality
#required for core zeshy functionality (e.g., printing exceptions). How about
#"00-startup/10-runnable/call_stack"? Sounds good to me. And we even already
#have the slot open!

#(i.e., the initial
#function or script transitively responsible for the call to this function).
#Get the name of the first (i.e., oldest) function or script on the call stack,
#serving as the root of the current call tree. For scripts, such name is the
#absolute or relative path at which such script was originally called.

#implying. Thus, return true only if the passed runnable either is the
#current runnable or transitively called the current runnable.
#   is_list_contains funcstack "${1}"
    #FUXME: I'm not convinced that printing the name of both this function and
    #caller error handlers is helpful. I mean, do we *REALLY* need the first
    #two lines of:
    #
    #\_ output_call_stack() { /home/leycec/zsh/zeshy/src/main: 499 }
    # \_ print_exception_with_status() { /home/leycec/zsh/zeshy/src/main: 3271992097900940624 }
    #  \_ TRAPZERR() { /bin/zsh: 1 }
    #
    #I'm thinking no. No sane language prints such internals, so... neither
    #shall we, we-we? Keep the "TRAPZERR" line, obviously, but cut everything
    #above that. Also keep any "die" line, but again cut everything above such
    #line. Readability is of key importance in stack traces.
    #FUXME: Then again, the truth is probably more important. O.K.; keep it.
    #FUXME: Die if called directly from the command-line. Ah! Actually, there's
    #no good reason that shouldn't work. What we should do, possibly, is detect
    #whether the call stack has at least three callers *AND* our caller is
    #print_exception_with_status(), in which case omit the first two callers, yes? This
    #is a bit more "magicky" than we like, but... is there any reasonable
    #alternative? I submit, "No."
    # Get such name. Since this function is transitively called by die(), avoid
    # zeshy functions liable to throw exceptions if implemented poorly (e.g.,
    # is_list_nonempty()).
#   if (( ${#funcstack} )) {
#       return_string "${funcstack[-1]}"
#   } else {
#       return_string ''
#   }
#on the current call path (i.e.,
#the path of functions and scripts calling the current function or script).
        # If print_exception_with_status() called this function, avoid printing such
        # call, whose internal implementation conveys no meaningful data to most
        # Zeshy users.
#       callee_name="${funcstack[${i}]}"
#       is "${callee_name}" == 'print_exception_with_status' si and continue

    # Colors to be expanded below.
#   string\
#       color_prefix="${ZESHY_COLOR[white_bold]-}"\
#       color_function_name="${ZESHY_COLOR[blue_bold]-}"\
#       color_function_parens="${ZESHY_COLOR[blue]-}"\
#       color_script_name="${ZESHY_COLOR[magenta_bold]-}"\
#       color_script_quotes="${ZESHY_COLOR[magenta]-}"\
#       color_eval_name="${ZESHY_COLOR[cyan_bold]-}"\
#       color_eval_parens="${ZESHY_COLOR[cyan]-}"\
#       color_brace="${ZESHY_COLOR[red_bold]-}"\
#       color_filename="${ZESHY_COLOR[grey_bold]-}"\
#       color_colon="${ZESHY_COLOR[grey]-}"\
#       color_line="${ZESHY_COLOR[red]-}"

        #FUXME: We could take this a step further by associating different
        #colors with different types of runnables (e.g., blue for functions,
        #magenta for scripts, and cyan for eval statements). What print_message ye? Ya!

#, as doing so sets such
    # caller name to "is_caller_equals". Implement such functions manually
#       'no such caller (this function or its caller called directly from the command line)'
# Consider calling
#get_callee_name_from_subshell if capturing output by process substitution: e.g.,
# >>> function choir() { output_string_sans_newline "caller: "; get_caller }
#declare_function '
#boolean get_callee_name_from_subshell(void)
#
#Get the name of the function or script calling the function or script calling
#this function *WHEN CALLED FROM A SUBSHELL*. Consider calling get_caller()
#unless capturing output by process substitution: e.g.,
#
#    >>> function timbered() { choir }
#    >>> function choir() { print "caller: $(get_callee_name_from_subshell)" }
#    >>> timbered
#    caller: timbered
#'
#function get_callee_name_from_subshell() {
#    # Validate sanity. See is_caller() for implementation details.
#    die_if_args
#    curse_string "funcstack: ${funcstack[*]}"
#    (( ${#funcstack} >= 4 )) or die\
#        'no such caller; this function either not called from a subshell or its caller called directly from the command line'
#
#    # Get such name.
#    print_string "${funcstack[4]}"
#}

#(This function returns the basename of the string
#returned by get_call_stack_root_name(), in other words.)
#If such name is that of a script originally called with
#Script names contain path components
#If the call stack is empty (i.e., this function was called directly from the
#command line), return "zeshy".
#This function returns an absolute path if the first object on the call stack
#is a script called by an absolute path. Where this is undesirable, consider
#calling output_call_stack_root_with_style_prefix().
        # If this name is an absolute path, return that path's basename.
#       if is_path_absolute "${funcstack[-1]}"
#       then print_string "${funcstack[-1]:t}"
        # Otherwise, return this name as is.
#       else print_string "${funcstack[-1]}"
#       fi

#       if is "${funcstack[-1]}" == /* is
# Get the script name for the current script. This is a string succinctly
# describing the script under execution, typically of one to two words.
#
# Scripts may safely redefine this function to return another name; in this
# case, scripts called by the script redefining this function will still call
# this original definition (since functions are not inherited via script
# calls).
    # If the current process is an interactive shell, then return the name of
    # the function that called this function excluding all intermediary I/O-
    # and error handling-specific function calls. Typically, that function is
    # the function that called the function that called this function (i.e.,
    # the function two calls earlier in the function callstack). Insert magical
    # handwaving here.

    #FUXME: Zeshify.
#   (( # == 0 )) || die 'expected no arguments'
    #FUXME: ${ZESHY_SCRIPT_NAME} is horrible. After extensive grepping about,
    #it's clear we no longer use this hideous hack. Excise!
    # If the caller set a non-empty ${ZESHY_SCRIPT_NAME}, return that name.
#   if [[ -n  "${ZESHY_SCRIPT_NAME-}" ]]; then
#       print -- "${ZESHY_SCRIPT_NAME}"

#FUXME: Rename to get_current_command_name(). Hmm; perhaps not. How about
#get_call_stack_name_first()? Yes. That seems much more representative and
#suggests a new "shell/call_stack" component.
