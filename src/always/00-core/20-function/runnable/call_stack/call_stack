#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core call stack functionality. The call stack is the list of all
*runnables* (i.e., called `zeshy` functions, sourced `zeshy` scripts, and
evaluated eval() statements) on the call path to the current runnable from the
initial runnable originating such runnable -- typically, the runnable called
directly by the current user from the CLI.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_call_stack_contains(string runnable_name)

Return success if the current call stack contains the passed *runnable* (i.e.,
`zeshy` function or script). Success implies such runnable to either be the
current function or to have transitively called such function.
/---
function is_call_stack_contains() {
    # Validate sanity.
    die_unless_arg 'Expected one runnable name.'
    die_unless_list funcstack
#   print "function: ${1}\nfuncstack: ${funcstack[*]}"

    # Test such stack. Avoid calling additional functions (e.g.,
    # is_list_contains(), get_list_size()) to avoid polluting the call stack
    # being tested. See is_list_contains() for further details.
    (( ${funcstack[(ie)${1}]} <= ${#funcstack} ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_call_stack_index_script(integer index)

Return success if the runnable corresponding to the passed 1-based index of the
current call stack was a sourced `zeshy` script (rather than, say, a called
`zeshy` function or evaluated eval() statement).
/---
function is_call_stack_index_script() {
    # Validate sanity.
    die_unless_arg 'Expected one index.'
    string index="${1}"
    die_unless_list_index funcsourcetrace "${index}"
#   print "function: ${1}\nfuncstack: ${funcstack[*]}"

    # Test such stack. If such runnable was a sourced file, the corresponding
    # element of ${funcsourcetrace} is suffixed by `:0`; else, such element is
    # suffixed by `:${line_number}`, where `${line_number}` is a strictly
    # positive integer. (Witchery -- and not the gentle sort, either!)
    is "${funcsourcetrace[${index}]}" == *':0' si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_call_stack_size(void)

Get the size of the current call stack, excluding the call to this function.
/---
function get_call_stack_size() {
    # Validate sanity.
    die_if_args
    die_unless_list funcstack

    # Get such size. Avoid calling additional functions (e.g.,
    # get_list_size()) to avoid polluting the call stack being examined.
    output_string $(( ${#funcstack} - 1 ))
}

# ....................{ GETTERS ~ root                     }....................
declare_function_with_stdin <<'/---'
string get_call_stack_root(void)

Get the current *call stack root* (i.e., last runnable on such stack and hence
originating all calls on such stack). The format for such string depends on the
type of such runnable. Specifically, if such runnable was a:

* Function, this is the name of such function.
* Script, this is the path (either absolute or relative and hence _not_
  necessarily canonical) that such script was originally run as.
/---
function get_call_stack_root() {
    # Validate sanity.
    die_if_args
    die_unless_list funcstack

    # Get such root. Although the call stack should *ALWAYS* be nonempty,
    # provide a sane fallback default.
    output_string "${funcstack[-1]-zeshy}"
}

declare_function_with_stdin <<'/---'
string get_call_stack_root_basename(void)

Get the basename of the call stack root. If such root is a script, this is such
script's basename; else, this is the return value of get_call_stack_root(). See
such function for further details.
/---
function get_call_stack_root_basename() {
    # Validate sanity.
    die_if_args
    string call_stack_root

    # Get such root.
    call_stack_root="$(get_call_stack_root)"

    # If such root is a script, get such script's basename. To reduce dependency
    # on external functions, inline such implementation. See get_path_basename()
    # for further details.
    if { is_call_stack_index_script "${call_stack_root}" }
        return_string "${call_stack_root:t}"
    # Else, such root is a function or eval(). Return such root as is.
    } else {
        return_string "${call_stack_root}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    # Get such basename. To reduce dependency on external functions, inline such
    # implementation. See get_path_basename() for further details.
#   output_string 

    #FUXME: Insufficient. Function names can contain path separators, but this
    #function should only reduce a runnable name to its basename if such
    #runnable signifies a script rather than function. To discriminate between
    #the two, see output_call_stack_with_lists() -- necessarily implementing
    #similar logic.

#FUXME: Rename to is_call_stack_runnable().
    # If the call stack is nonempty, return the first runnable on such stack;
    # else, return "zeshy". (The latter should *NEVER* trigger, but is provided
    # as a failsafe backup.)

    #FUXME: Poor implementation. 
#   command basename -- "$(get_call_stack_root)"
#FUXME: Rename to is_call_stack_runnable().
