#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core exception functionality.
/---

#FIXME: Add examples.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_in_always(
    string error_message =
        "Not in an \"always :\{...\}:\" block (or \$\{TRY_BLOCK_ERROR\} ${TRY_BLOCK_ERROR} not in [0, 255] and hence an invalid exit status).}")

Throw an exception with the passed message unless this function was transitively
called in an `always {...}` block. See is_in_always() for further details.
/---
function die_unless_in_always() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_in_always or die\
        "${1-Not in an \"always :\{...\}:\" block (or \$\{TRY_BLOCK_ERROR\} ${TRY_BLOCK_ERROR--1} not in [0, 255] and hence an invalid exit status).}"
}

declare_function_with_stdin <<'/---'
void die_evaluated(string evaluation)

Throw an exception whose error message is the result of dynamically evaluating
the passed string in a *double-quoted context* (i.e., as
`eval 'die "'${evaluation}'"'`). Since the result of dynamically evaluating a
string containing no *process substitutions* (i.e., `$(...)` expressions) is the
same string, this function is typically only passed single-quoted strings
containing such substitutions -- namely, substitutions of functions dependent on
the current terminal width.

== Terminal Width ==

The width available to each line of exception messages (typically) differs from
the width available to each line of normal output (i.e., the current terminal
width). Assuming default user-configurable styles, die() prints exception
messages in frames fabricated with box-drawing glyphs, implying no line of such
message may be longer than the current terminal width minus the lengths of the
left and right borders of such frames.

For readability, this function evaluates the passed string with a terminal width
temporarily set to such length. Consider the following erroneous call to die():

.Incorrect Terminal Width under die()
==========================================
[source]
------------------------------------------
>>> die "$(print_runnable info)"
┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• die() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
┋ ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• Command          ┋
┋ info •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃                          ┋
┋ /usr/bin/info                                                                                 ┋
┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
------------------------------------------
==========================================

The resulting message is plainly malformed. Consider calling this function with
the same string, single-quoted rather than double-quoted to delay execution of
such substitution until this function has temporarily overriden the current
terminal width with the restricted length:

.Correct Terminal Width under die_evaluated()
==========================================
[source]
------------------------------------------
>>> die_evaluated '$(print_runnable info)'
┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• die_evaluated() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
┋ ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• Command info •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃ ┋
┋ /usr/bin/info                                                                                  ┋
┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
------------------------------------------
==========================================
/---
function die_evaluated() {
    # Validate sanity.
    die_unless_arg 'Expected one evaluatable string.'
    string evaluation="${1}" message

    # If get_exception_message_width() has been defined by this point,
    # evaluate such string under a terminal width restricted accordingly.
    if { is_function get_exception_message_width } {
        COLUMNS="$(get_exception_message_width)"\
            eval 'message="'${evaluation}'"'
    # Else, evaluate such string as is.
    } else {
        eval 'message="'${evaluation}'"'
    }

    # Throw such exception with such evaluated message.
    die "${message}"
}

# ....................{ EXCEPTIONS ~ exception             }....................
declare_function_with_stdin <<'/---'
void die_unless_exception(string error_message = "No exception thrown.")

Throw an exception with the passed message unless an uncaught exception was
thrown by the `{...}` block preceding the `always {...}` block calling this
function. See is_exception() for further details.
/---
function die_unless_exception() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_exception or die "${1-No exception thrown.}"
}

declare_function_with_stdin <<'/---'
void die_unless_exception_caught(string error_message = "No exception caught.")

Throw an exception with the passed message unless an exception was caught by the
`always {...}` block calling this function. See is_exception_caught() for
further details.
/---
function die_unless_exception_caught() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_exception_caught or die "${1-No exception caught.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_in_always(void)

Report success if this function was transitively called in an `always {...}`
block.

== Caveats ==

*While reliable, this function is _not_ infallible.* Since list and string
globals ${zsh_eval_context} and ${ZSH_EVAL_CONTEXT} fail to contextualize the
execution of code in `always {...}` blocks, this function defers to integer
global ${TRY_BLOCK_ERROR} as a proxy for such context.

If ${TRY_BLOCK_ERROR} is undefined or less than zero, this function _cannot_
have been called in a sane `always {...}` block. On entering such a block, `zsh`
_always_ sets such integer to the exit status of the last command in the prior
block and hence an integer in [0, 255]. Likewise, on exiting such block, `zsh`
returns such integer as such block's exit status and reverts such integer to its
default value of -1.

Under ideal conditions, ${TRY_BLOCK_ERROR} is defined to be greater than or
equal to zero _only_ when expanded from an `always {...}` block. However, such
global is user-alterable; a defective `always {...}` block could reset such
global to a negative integer, in which case this function would erroneously
report failure despite being called in an `always {...}` block. Fortunately,
such edge case remains unlikely, rendering this concern (mostly) moot.
/---
function is_in_always() {
    die_if_args
    (( ${TRY_BLOCK_ERROR--1} >= 0 ))
}

# ....................{ TESTERS ~ exception                }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_exception(void)

Report success if an uncaught exception was thrown by the `{...}` block
preceding the `always {...}` block calling this function. Since
throw_exception() sets string global ${EXCEPTION} to such exception's error
message and catch_exception() unsets such global, the existence of such global
implies such condition.
/---
function is_exception() {
    # For efficiency, inline such test. See is_variable() for further details.
    die_if_args
    (( ${+EXCEPTION} ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_exception_caught(void)

Report success if an exception was caught by the `always {...}` block calling
this function. Since catch_exception() sets string global ${CAUGHT} to such
exception's error message and print_exception_if_unhandled() unsets such global,
the existence of such global implies such condition.
/---
function is_exception_caught() {
    # For efficiency, inline such test. See is_variable() for further details.
    die_if_args
    (( ${+CAUGHT} ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_exception_stored(void)

Report success if an uncaught exception was thrown by the `{...}` block
preceding the `always {...}` block calling this function _and_ all metadata
previously associated with such exception by store_exception_with_status() still
exists. Specifically, report success if the following variables are still
defined: ${EXCEPTION}, ${ZESHY_EXCEPTION_STATUS}, ${ZESHY_EXCEPTION_FUNCSTACK},
${ZESHY_EXCEPTION_FUNCFILETRACE}, and ${ZESHY_EXCEPTION_FUNCSOURCETRACE}.
/---
function is_exception_stored() {
    # While we could also verify the correct types for such globals, such
    # zealousness smacks of overkill. (And not the good, heavy metal kind.)
    die_if_args

    #FIXME: Odd. Very well, stupidly silly. Just define a single is_variable()
    #function accepting multiple arguments. Excise is_variables()!
    is_variables\
        EXCEPTION\
        ZESHY_EXCEPTION_STATUS\
        ZESHY_EXCEPTION_FUNCSTACK\
        ZESHY_EXCEPTION_FUNCFILETRACE\
        ZESHY_EXCEPTION_FUNCSOURCETRACE
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_exception(void)

Get the error message associated with the uncaught exception thrown by the
`{...}` block preceding the `always {...}` block calling this function.
Specifically, get the value of string global ${EXCEPTION}.
/---
function get_exception() {
    die_if_args
    die_unless_exception
    output_string "${EXCEPTION}"
}

declare_function_with_stdin <<'/---'
string get_exception_caught(void)

Get the error message associated with the exception caught by the `always {...}`
block calling this function.  Specifically, get the value of string global
${CAUGHT}.
/---
function get_exception_caught() {
    die_if_args
    die_unless_exception_caught
    output_string "${CAUGHT}"
}

# ....................{ THROWERS                           }....................
declare_function_with_stdin <<'/---'
void throw_exception_caught(void)

Rethrow the exception caught by the `always {...}` block calling this function.
Such exception will be rethrown with the same error message but _not_ exit
status or call stack associated with the original exception.
/---
function throw_exception_caught() {
    # Validate sanity.
    die_if_args
    die_unless_in_always
    die_unless_exception_caught

    #FIXME: While this works, it also discards the call stack associated with
    #the original exception. This is fixable -- but are we motivated?

    # Rethrow the currently caught exception.
    throw_exception "${CAUGHT}"
}

# ....................{ CATCHERS                           }....................
declare_function_with_stdin <<'/---'
void catch_exception(void)

Catch any uncaught exception thrown by the `{...}` block preceding the
`always {...}` block calling this function if such an exception exists or throw
an exception otherwise. See catch_exception_if_found() for further details.
/---
function catch_exception() {
    die_if_args
    catch_exception_if_found or die_unless_exception
}

declare_function_with_stdin <<'/---'
[status: boolean] catch_exception_if_found(void)

Catch any uncaught exception thrown by the `{...}` block preceding the
`always {...}` block calling this function if such an exception exists or report
failure otherwise. ``Catching'' an exception implies the following:

* Setting string global ${CAUGHT} to ${EXCEPTION}, the error message thrown with
  such exception.
* Undefining all globals previously associated with such exception by
  store_exception_with_status() (e.g., ${EXCEPTION}, ${ZESHY_EXCEPTION_STATUS}).
  See such function for further details.
* Setting ${TRY_BLOCK_ERROR} to 0 prevent such `always {...}` block from
  propagating such exception back up the call stack.

After calling this function, no exception will appear to have been thrown (e.g.,
is_exception() and is_exception_stored() will report failure). See
throw_exception() for further details.
/---
function catch_exception_if_found() {
    # Validate sanity.
    die_if_args
    die_unless_in_always

    # If any exception was thrown, report success from both the current function
    # and "always {...}" block *AND* catch such exception.
    is_exception and {
        # Catch such exception.
        string_global CAUGHT="${EXCEPTION}"

        #FIXME: Ideally, we would expand alias undefine_variable() here.
        #Unfortunately, such alias is currently defined somewhat too
        #zealously. Rename such alias to undefine_variable_constant() and define
        #a *NEW* alias undefine_variable() expanding only to call unset() as
        #below (and hence accepting multiple arguments!).

        # Clear such exception by unsetting all globals previously set by
        # store_exception_with_status() *AFTER* catching such exception.
        unset\
            EXCEPTION\
            ZESHY_EXCEPTION_STATUS\
            ZESHY_EXCEPTION_FUNCSTACK\
            ZESHY_EXCEPTION_FUNCFILETRACE\
            ZESHY_EXCEPTION_FUNCSOURCETRACE

        # Report success from this "always {...}" block *AFTER* successfully
        # completing all prior logic.
        TRY_BLOCK_ERROR=0
    }
}

declare_function_with_stdin <<'/---'
<globbable> [status: boolean] catch_exception_matching_glob_if_found(
    string error_message_glob)

Catch any uncaught exception thrown by the `{...}` block preceding the
`always {...}` block calling this function if such an exception was thrown with
an error message matching the passed glob or report failure otherwise. This
function is (effectively) equivalent to catch() in conventional `zsh`. See
catch_exception_if_found() for further details.
/---
function catch_exception_matching_glob_if_found() {
    # Validate sanity.
    die_unless_arg 'Expected one glob.'
    die_unless_in_always

    # If an uncaught exception matches such glob, catch such exception.
    (( ${+EXCEPTION} )) and is "${EXCEPTION}" == ${~1} si and
        catch_exception_if_found
}

# --------------------( WASTELANDS                         )--------------------
#Catch any exception whose error message matches the passed glob thrown by the
#`{...}` block preceding the `always {...}` block presumably calling this
#function if such an exception was thrown or report failure
#otherwise. In the former case, string global ${CAUGHT} is set to such
#exception's error message. See throw_exception() for further details.

#report success from both
    # the current function and "always {...}" block *AND* 
    #FUXME: Reduce to simply die_unless_exception_caught(). In fact, perhaps
    #such function should have the following implementation?

    # If no exception was caught, throw an exception indicating that.
#    (( ${+CAUGHT} )) or {
#        # If an exception was thrown, throw an exception with such exception.
#        if { is_exception } {
#            die "Exception \"${EXCEPTION}\" uncaught."
#        # Else, no exception was even thrown. Now you're really in for it!
#        } else {
#            die 'No exception thrown.'
#        }
#    }

# If
#this function was not called within such a block _or_ no exception was
#previously caught or thrown, a new exception indicating that is thrown.

    # Validate sanity.
#    die_if_args
#    die_unless_in_always
#
#    # Validate sanity.
#    (( # == 0 )) || die 'Expected no arguments.'
#
#    # Unset all globals previously set by store_exception_with_status(). See
#    # clear_exception() for further details.
#    unset\
#        EXCEPTION\
#        ZESHY_EXCEPTION_STATUS\
#        ZESHY_EXCEPTION_FUNCSTACK\
#        ZESHY_EXCEPTION_FUNCFILETRACE\
#        ZESHY_EXCEPTION_FUNCSOURCETRACE

#== Caveats ==
#
#*Callers calling either this function or die_unless_exception() and requiring
#one or more `zeshy`-specific exception globals (e.g., ${ZESHY_EXCEPTION_STATUS})
#should explicitly test for and handle the non-existence of such globals.* For
#improved resilience in the event such globals have been undefined since an
#exception was first thrown, the exit status of this function depends only on the
#existence of string global ${EXCEPTION}. 

#. In the former case, string global ${CAUGHT} is set to such
#exception's error message and all other globals associated . 
#
#Clear the currently thrown exception. After calling this function, no exception
#will appear to have been thrown (e.g., is_exception() will report failure).
#Specifically, this function undefines all exception-specific globals previously
#defined by store_exception_with_status() at the time of such exception. See
#such function for further details.

#    {
#        TRY_BLOCK_ERROR=0
#        string_global CAUGHT="${EXCEPTION}"
#        clear_exception
#    }

#setting string global ${CAUGHT} to ${EXCEPTION} (i.e., the string that was
#thrown), undefining ${EXCEPTION}, and reporting success. If no exception was
#thrown, was but does _not_ match such glob, _or_ this function was _not_ called
#in an `always {...}` block, failure is returned. See throw_exception() for
#further details.

    # Else, return failure.
#   report_failure
# undefine_variable EXCEPTION
#Since this function is typically called from within
    # exception handlers (i.e., "always {...}" blocks), return failure from such
    # handler rather than throwing yet another exception.
#    (( # == 1 )) || {
#        print "zeshy: catch_exception_matching_glob_if_found() expected one glob but received:\n${*}" 1>&2
#        (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#        return 1
#    }

# Permit globs to be passed unquoted to catch_exception_matching_glob_if_found()
# by disabling filename globbing for such function.
#alias    catch_exception_matching_glob_if_found='noglob catch_exception_matching_glob_if_found'

#FUXME: Shift to @{always/exception}. There's really no rational reason to have
#this here. Refactor print_exception_with_status() to manually implement such globbing and
#resultant handling. Yum!

#_or_ `zsh` integer global ${TRY_BLOCK_ERROR} is undefined (which it
#should never be).

#   (or in an \"always :{...}:\" block missetting ${TRY_BLOCK_ERROR}).}"
#FUXME: Functions below expand aliases possibly not available at this point. Is
#this parcel sourced before or after sourcing @{00-core}? If the former, we
#should finally contemplate implementing support for a genuine
#"src/always_before" overlay -- which would neatly fix such issue.
#print 'in @{exception}'

    # If such integer is undefined, throw an exception.
#   if (( ${+TRY_BLOCK_ERROR} == 0 )) {
#       die 'Global ${TRY_BLOCK_ERROR} undefined.'
# For robustness (e.g., in case , inline such test. See is_function() for further details.
#   if { typeset -f get_terminal_width_for_errors &>/dev/null } {

#FUXME: Nice nomenclature. Rename the rather clunky
#die_unless_context_current_function() to die_unless_in_function(). (Much
#better!)

#   (( # == 0 )) || throw_exception\
#       "zeshy: catch_exception_matching_glob_if_found() expected one glob but received:\n${*}" 1>&2

        # If not in an "always {...}" 
        # Else if this function was not called from within an "always {...}"
        # block *OR* ${TRY_BLOCK_ERROR} is undefined, throw an exception
        # indicating that. See throw_exception() for further details.
#    if (( ${TRY_BLOCK_ERROR--1} <= -1 )) {
#        if (( ${+TRY_BLOCK_ERROR} == 0 )) {
#            print 'zeshy: zsh global ${TRY_BLOCK_ERROR} undefined' 1>&2
#        } else {
#            print 'zeshy: catch_exception_matching_glob_if_found() not called in an "always {...}" block' 1>&2
#        }
#
#        # Since this function was not called from within an "always {...}"
#        # block, there's little point in setting ${TRY_BLOCK_ERROR} to nonzero
#        # exit status to indicate failure. Instead, simply return such status.
#        return 1

    # If function get_terminal_width_for_errors() has been defined by this
    # point, throw such exception with such string evaluated under a restricted
    # terminal width. For stability, inline such test. See is_function() for
    # further details.
#    if { typeset -f get_terminal_width_for_errors &>/dev/null } {
#        COLUMNS="$(get_terminal_width_for_errors)" eval 'die "'${evaluation}'"'
#    }
    # Else, throw such exception with such string evaluated as is.
#    } else {
#        eval 'die "'${evaluation}'"'
#    }
