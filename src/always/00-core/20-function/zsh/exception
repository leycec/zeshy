#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core exception functionality.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_exception(void)

Throw an exception with the passed message unless an uncaught exception has been
thrown. See is_exception() for further details.
/---
function die_unless_exception() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_exception or die "${1-No exception thrown.}"
}

declare_function_with_stdin <<'/---'
void die_unless_in_always(
    string error_message =
        "Not in an \"always :\{...\}:\" block (or \$\{TRY_BLOCK_ERROR\} ${TRY_BLOCK_ERROR} not in [0, 255] and hence an invalid exit status).}")

Throw an exception with the passed message unless this function was transitively
called in an `always :{...}:` block. See is_in_always() for further details.
/---
function die_unless_in_always() {
    die_unless_args_0_to_1 'Expected optional error message.'
    is_in_always or die\
        "${1-Not in an \"always :\{...\}:\" block (or \$\{TRY_BLOCK_ERROR\} ${TRY_BLOCK_ERROR--1} not in [0, 255] and hence an invalid exit status).}"
}

declare_function_with_stdin <<'/---'
void die_evaluated(string evaluation)

Throw an exception whose error message is the result of dynamically evaluating
the passed string in a *double-quoted context* (i.e., as
`eval 'die "'${evaluation}'"'`). Since the result of dynamically evaluating a
string containing no *process substitutions* (i.e., `$(...)` expressions) is the
same string, this function is typically only passed single-quoted strings
containing such substitutions -- namely, substitutions of functions dependent on
the current terminal width.

== Terminal Width ==

The width available to each line of exception messages (typically) differs from
the width available to each line of normal output (i.e., the current terminal
width). Assuming default user-configurable styles, die() prints exception
messages in frames fabricated with box-drawing glyphs, implying no line of such
message may be longer than the current terminal width minus the lengths of the
left and right borders of such frames.

For readability, this function evaluates the passed string with a terminal width
temporarily set to such length. Consider the following erroneous call to die():

.Incorrect Terminal Width under die()
==========================================
[source]
------------------------------------------
>>> die "$(print_runnable info)"
┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• die() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
┋ ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• Command          ┋
┋ info •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃                          ┋
┋ /usr/bin/info                                                                                 ┋
┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
------------------------------------------
==========================================

The resulting message is plainly malformed. Consider calling this function with
the same string, single-quoted rather than double-quoted to delay execution of
such substitution until this function has temporarily overriden the current
terminal width with the restricted length:

.Correct Terminal Width under die_evaluated()
==========================================
[source]
------------------------------------------
>>> die_evaluated '$(print_runnable info)'
┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• die_evaluated() •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
┋ ┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• Command info •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃ ┋
┋ /usr/bin/info                                                                                  ┋
┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
------------------------------------------
==========================================
/---
function die_evaluated() {
    # Validate sanity.
    die_unless_arg 'Expected one evaluatable string.'
    string evaluation="${1}" message

    # If get_exception_message_width() has been defined by this point,
    # evaluate such string under a terminal width restricted accordingly.
    if { is_function get_exception_message_width } {
        COLUMNS="$(get_exception_message_width)"\
            eval 'message="'${evaluation}'"'
    # Else, evaluate such string as is.
    } else {
        eval 'message="'${evaluation}'"'
    }

    # Throw such exception with such evaluated message.
    die "${message}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_exception(void)

Report success if an uncaught exception has been thrown (i.e., ${EXCEPTION} is
currently defined).

== Caveats ==

*Callers calling either this function or die_unless_exception() and requiring
one or more `zeshy`-specific exception globals (e.g., ${ZESHY_EXCEPTION_STATUS})
should explicitly test for and handle the non-existence of such globals.* For
improved resilience in the event such globals have been undefined since an
exception was first thrown, the exit status of this function depends only on the
existence of string global ${EXCEPTION}. 
/---
function is_exception() {
    # While we could also verify the correct types for such globals, such
    # zealousness smacks of overkill. (And not the good, heavy metal kind.)
    die_if_args
    is_variables\
        EXCEPTION\
        ZESHY_EXCEPTION_STATUS\
        ZESHY_EXCEPTION_FUNCSTACK\
        ZESHY_EXCEPTION_FUNCFILETRACE\
        ZESHY_EXCEPTION_FUNCSOURCETRACE
}

declare_function_with_stdin <<'/---'
[status: boolean] is_in_always(void)

Report success if this function was transitively called in an `always :{...}:`
block.

== Caveats ==

*While reliable, this function is _not_ infallible.* Since list and string
globals ${zsh_eval_context} and ${ZSH_EVAL_CONTEXT} fail to contextualize the
execution of code in `always :{...}:` blocks, this function defers to integer
global ${TRY_BLOCK_ERROR} as a proxy for such context.

If ${TRY_BLOCK_ERROR} is undefined or less than zero, this function _cannot_
have been called in a sane `always :{...}:` block. On entering such a block,
`zsh` _always_ sets such integer to the exit status of the last command in the
prior block and hence an integer in [0, 255]. Likewise, on exiting such block,
`zsh` returns such integer as such block's exit status and reverts such integer
to its default value of -1.

Under ideal conditions, ${TRY_BLOCK_ERROR} is defined to be greater than or
equal to zero _only_ when expanded from an `always :{...}:` block. However,
such global is user-alterable; a defective `always :{...}:` block could reset
such global to a negative integer, in which case this function would erroneously
report failure despite being called in an `always :{...}:` block. Fortunately,
such edge case remains unlikely, rendering this concern (mostly) moot.
/---
function is_in_always() {
    die_if_args
    (( ${TRY_BLOCK_ERROR--1} >= 0 ))
}

# ....................{ THROWERS                           }....................
declare_function_with_stdin <<'/---'
void throw_exception_caught(void)

Rethrow the exception previously caught by the current `always :{...}:` block.
If this function was not called within such a block _or_ no exception was
previously caught or thrown, a new exception indicating that is thrown.
/---
function throw_exception_caught() {
    # Validate sanity.
    die_if_args
    die_unless_in_always

    # If no exception was caught, throw an exception indicating that.
    (( ${+CAUGHT} )) or {
        # If an exception was thrown, throw an exception with such exception.
        (( ${+EXCEPTION} )) or
            die "Exception \"${EXCEPTION}\" uncaught."

        # Else, no exception was even thrown. Now you're really in for it!
        die 'No exception thrown.'
    }

    #FIXME: While this works, it also discards the call stack associated with
    #the original exception. This is certainly fixable. Are we motivated?

    # Rethrow the currently caught exception.
    throw_exception "${CAUGHT}"
}

# --------------------( WASTELANDS                         )--------------------
#_or_ `zsh` integer global ${TRY_BLOCK_ERROR} is undefined (which it
#should never be).

#   (or in an \"always :{...}:\" block missetting ${TRY_BLOCK_ERROR}).}"
#FUXME: Functions below expand aliases possibly not available at this point. Is
#this parcel sourced before or after sourcing @{00-core}? If the former, we
#should finally contemplate implementing support for a genuine
#"src/always_before" overlay -- which would neatly fix such issue.
#print 'in @{exception}'

    # If such integer is undefined, throw an exception.
#   if (( ${+TRY_BLOCK_ERROR} == 0 )) {
#       die 'Global ${TRY_BLOCK_ERROR} undefined.'
# For robustness (e.g., in case , inline such test. See is_function() for further details.
#   if { typeset -f get_terminal_width_for_errors &>/dev/null } {

#FUXME: Nice nomenclature. Rename the rather clunky
#die_unless_context_current_function() to die_unless_in_function(). (Much
#better!)

#   (( # == 0 )) || throw_exception\
#       "zeshy: catch_exception_matching_glob_if_found() expected one glob but received:\n${*}" 1>&2

        # If not in an "always {...}" 
        # Else if this function was not called from within an "always {...}"
        # block *OR* ${TRY_BLOCK_ERROR} is undefined, throw an exception
        # indicating that. See throw_exception() for further details.
#    if (( ${TRY_BLOCK_ERROR--1} <= -1 )) {
#        if (( ${+TRY_BLOCK_ERROR} == 0 )) {
#            print 'zeshy: zsh global ${TRY_BLOCK_ERROR} undefined' 1>&2
#        } else {
#            print 'zeshy: catch_exception_matching_glob_if_found() not called in an "always {...}" block' 1>&2
#        }
#
#        # Since this function was not called from within an "always {...}"
#        # block, there's little point in setting ${TRY_BLOCK_ERROR} to nonzero
#        # exit status to indicate failure. Instead, simply return such status.
#        return 1

    # If function get_terminal_width_for_errors() has been defined by this
    # point, throw such exception with such string evaluated under a restricted
    # terminal width. For stability, inline such test. See is_function() for
    # further details.
#    if { typeset -f get_terminal_width_for_errors &>/dev/null } {
#        COLUMNS="$(get_terminal_width_for_errors)" eval 'die "'${evaluation}'"'
#    }
    # Else, throw such exception with such string evaluated as is.
#    } else {
#        eval 'die "'${evaluation}'"'
#    }
