#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *argument options* (i.e., arguments prefixed by `-`).
/---

#FIXME: As the nomenclature below demonstrates, suffixing alias names by "_for"
#rather than "_from" for aliases accepting multiple arguments in a single string
#produces a more legible calling convention. Change "_from" to "_for"
#everywhere, please.
#FIXME: If *NOT* compiling a debug build, such aliases should *NOT* be reduced
#to noops -- unlike the comparable is_arg_*() aliases, which should be. In other
#words, no significant changes here.

# ....................{ ALIASES                            }....................
# Declare aliases for corresponding functions declared below prior to defining
# such functions, ensuring all such aliases exist at function definition time.
alias set_integer_to_arg_option_index_last='set_integer_to_arg_option_index_last "${@}"'
alias set_integer_to_arg_nonoption_count='set_integer_to_arg_nonoption_count "${@}"'
alias set_integer_to_arg_nonoption_index_first='set_integer_to_arg_nonoption_index_first "${@}"'
alias set_integers_to_arg_nonoption_count_and_index_first='set_integers_to_arg_nonoption_count_and_index_first "${@}"'

# ....................{ TESTERS                            }....................
#FIXME: Aliases below should be dynamically constructed rather than manually
#defined -- for both sanity and efficiency.
#FIXME: O.K.; all of the below are fairly horrible. Reimplement as proper
#functions by passing the argument list from an alias to function of the same
#name. This should also allow us to eliminate the absurd "_from" syntax below,
#which is *ABSOLUTELY ESSENTIAL* (because it's horrible). Look: any function
#incurring the cost of expanding such aliases can certainly afford the
#negligible cost of passing their argument list to another function for testing.
#Make it so, please.

declare_alias_with_stdin <<'/---'
[status: boolean] is_arg_nonoption(void)

Return success if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---
alias is_arg_nonoption=is_arg_nonoptions_1

declare_alias_with_stdin <<'/---'
[status: boolean] is_arg_nonoptions(void)

Return success if the caller passed at least one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---
alias is_arg_nonoptions=is_arg_nonoptions_1_or_more

declare_alias_with_stdin <<'/---'
[status: boolean] is_arg_nonoptions_0(void)

Return success if the caller passed no non-option arguments. See
set_integer_to_arg_nonoption_count() for further details.
/---
alias is_arg_nonoptions_0='{
    set_integer_to_arg_nonoption_count count__ian0
    (( count__ian0 == 0 ))
}'

declare_alias_with_stdin <<'/---'
[status: boolean] is_arg_nonoptions_1(void)

Return success if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---
alias is_arg_nonoptions_1='{
    set_integer_to_arg_nonoption_count count__ian1
    (( count__ian1 == 1 ))
}'

declare_alias_with_stdin <<'/---'
[status: boolean] is_arg_nonoptions_1_or_more(void)

Return success if the caller passed at least one non-option arguments. See
set_integer_to_arg_nonoption_count() for further details.
/---
alias is_arg_nonoptions_1_or_more='{
    set_integer_to_arg_nonoption_count count__ian1om
    (( count__ian1om >= 1 ))
}'

declare_alias_with_stdin <<'/---'
[status: boolean] is_arg_nonoptions_1_to_3(void)

Return success if the caller passed between one to three non-option arguments.
See set_integer_to_arg_nonoption_count() for further details.
/---
alias is_arg_nonoptions_1_to_3='{
    set_integer_to_arg_nonoption_count count__ian1t3
    (( 1 <= count__ian1t3 && count__ian1t3 <= 3 ))
}'

# ....................{ SETTERS ~ option                   }....................
# The corresponding aliases are declared above.

declare_alias_with_stdin <<'/---'
void set_integer_to_arg_option_index_last(string integer_name)

Set the passed integer to the 1-based index of the last *option argument* (i.e.,
argument prefixed by `-`) the caller passed or 0 if no such argument was passed.
See set_integer_to_arg_nonoption_index_first() for further details.
/---
function set_integer_to_arg_option_index_last() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    string integer_name_option_index_last___sitaoil="${@[-1]}"
    integer nonoption_index_first__sitaoil placeholder__sitaoil
    pop_arg

    # Get the index of the first non-option argument. See
    # set_integer_to_arg_nonoption_index_first() for further details.
    set_integers_to_arg_nonoption_count_and_index_first\
        placeholder__sitaoil nonoption_index_first__sitaoil

    # Set the index of the last option argument given the prior index.
    set_integer_to_integer "${integer_name_option_index_last___sitaoil}"\
        $(( nonoption_index_first__sitaoil - 1 ))
}

# ....................{ SETTERS ~ nonoption                }....................
declare_alias_with_stdin <<'/---'
void set_integer_to_arg_nonoption_count(string integer_name)

Set the passed integer to the number of *non-options arguments* (i.e., arguments
_not_ prefixed by `-`) the caller passed. See
set_integer_to_arg_nonoption_index_first() for further details.
/---
function set_integer_to_arg_nonoption_count() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_integer_to_arg_nonoption_index_first() and
    # set_integer_to_arg_option_index_last().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    string integer_name__sitanc="${@[-1]}"
    integer placeholder__sitanc
    pop_arg

    # Defer to the function below, discarding the value of the second integer
    # variable passed to such function. Since the implementation of such
    # function is somewhat nontrivial, this provides a somewhat "cleaner"
    # solution than reimplementing such function.
    set_integers_to_arg_nonoption_count_and_index_first\
        "${integer_name__sitanc}" placeholder__sitanc
}

declare_alias_with_stdin <<'/---'
void set_integer_to_arg_nonoption_index_first(string integer_name)

Set the passed integer to the 1-based index of the first *non-option argument*
(i.e., argument _not_ prefixed by `-`) the caller passed. Specifically:

* If the caller passed an argument equal to `-` or `--`, one greater than the
  index of such argument. By POSIX design, such arguments prematurely terminate
  option arguments.
* Else if the caller passed at least one argument _not_ prefixed by `-`, the
  index of the first such argument.
* Else, one greater than the number of arguments the caller passed. This
  corresponds to default `zsh` behavior for builtin list index modifiers `(i)`
  and `(I)`.
/---
function set_integer_to_arg_nonoption_index_first() {
    # See set_integer_to_arg_nonoption_count() for further details.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    string integer_name__sitanc="${@[-1]}"
    integer placeholder__sitanc
    pop_arg
    set_integers_to_arg_nonoption_count_and_index_first\
        placeholder__sitanc "${integer_name__sitanc}"
}

declare_alias_with_stdin <<'/---'
void set_integers_to_arg_nonoption_count_and_index_first(
    string integer_name_count, string integer_name_index_first)

Set the first passed integer to the number of *non-option arguments* (i.e.,
arguments _not_ prefixed by `-`) the caller passed and the second passed integer
to the 1-based index of the first such argument. See
set_integer_to_arg_nonoption_count() and
set_integer_to_arg_nonoption_index_first() for further details.
/---
function set_integers_to_arg_nonoption_count_and_index_first() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one count integer name, and one index integer name.'
    string\
        integer_name_count__sitancaif="${@[-2]}"\
        integer_name_index_first__sitancaif="${@[-1]}"
    integer index_first__sitancaif
#   print "count: ${integer_name_count__sitancaif}\nindex_first: ${integer_name_index_first__sitancaif}"
    die_unless_variables_integer\
        "${integer_name_count__sitancaif}"\
        "${integer_name_index_first__sitancaif}"
    pop_args_2

    # If such arguments contain "-" or "--", such index is one after the index
    # of such argument.
    index_first__sitancaif="${@[(i)-|--]}"
    if (( index_first__sitancaif <= # )) {
          index_first__sitancaif+=1
    # Else, such index is the index of the first argument *NOT* prefixed by "-"
    # if such argument exists or the number of such arguments otherwise.
    } else {
        index_first__sitancaif="${@[(i)[^-]*]}"
    }

    # Set such integers. For efficiency, inline such implementations. See
    # set_integer_to_integer() for further details.
    noop ${(P)integer_name_count__sitancaif::=$(( # - index_first__sitancaif + 1 ))}
    noop ${(P)integer_name_index_first__sitancaif::=${index_first__sitancaif}}
#   print "arg count: ${#}"
#   print "arg nonoption first index \"${integer_name_index__sitancaif}\": ${(P)integer_name_index__sitancaif}"
#   print "arg nonoption count: $(( # - ${(P)integer_name_index__sitancaif} + 1 ))"
#   print "count integer name: ${integer_name_count__sitancaif}"
}

#FIXME: Ad-hoc test functions. Quite helpful until we jerry rig together a
#proper unit test framework.
#function tyam() {
#    integer count index_first index_last
#    set_integers_to_arg_nonoption_count_and_index_first count index_first
#    set_integer_to_arg_option_index_last index_last
#    print "args: ${*}\narg nonoption count: ${count}\narg nonoption first index: ${index_first}\narg option last index: ${index_last}\n"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}

# ....................{ SETTERS ~ map                      }....................
declare_alias_with_stdin <<'/---'
void set_map_to_arg_options_with_help_from(
    string map_name,
    string option_spec1, ...,
    string help_message)

Parse and remove `-`-prefixed options from the current argument list via the
passed zparseopts()-formatted options specifications into the passed map.
Preserve all other arguments in the current argument list for subsequent parsing
by the caller. See `info zsh[i][zparseopts]` for further details. Due to `zsh`
constraints, arguments must be passed whitespace-delimited in a single shell
word (e.g., single- or double-quoted string).

Parse options `-h` and `--help` by printing the passed help message and
returning from the caller function or script with zero exit status. If parsing
fails, also print such message but return with non-zero exit status: e.g.,

.set_map_to_arg_options_with_help_from()
==========================================
[source]
------------------------------------------
# Set command-line arguments.
>>> set_args -d --ad --alive 42 "glass_arm.shattering"

# Parse such arguments.
>>> map arg_options
>>> set_map_to_arg_options_with_help_from 'arg_options d e -ad -or: -alive:: "
Usage: doa [OPTION]... [FILE]...

Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.

Options:
  -h, --help          print this help text and exit
  -d                  return non-zero exit status if such files fail to run
  -e                  evaluate rather than run the passed files
  --ad                switch from a Julian to Gregorian calendar
  --or DEATHS         set the maximum number of DEATHS
  --alive [LIVES]     set the starting number of LIVES (default: 3)
"'

# Check parsed options.
>>> print_string "option \"--alive\": ${arg_options[--alive]}"
option "--alive": 42
>>> is_map_key arg_options "-d" and print "option \"-d\": enabled"
option "-d": enabled
------------------------------------------
==========================================
/---
alias set_map_to_arg_options_with_help_from='
{
    # Validate sanity.
    list  args__smtaowhf; set_list_to_stdin_words args__smtaowhf
    (( ${#args__smtaowhf} >= 3 )) ||
        die "expected one map name, at least one option specifier, and one help string"
    string map_name__smtaowhf="${args__smtaowhf[1]}"
    string help_message__smtaowhf="${args__smtaowhf[-1]}"

    # Remove the first and last passed argument having parsed such arguments.
    shift_list args__smtaowhf
    pop_list   args__smtaowhf

    # Locally declare such map if not already declared.
    is_map "${map_name__smtaowhf}" or map "${map_name__smtaowhf}"

    # Parse options under the passed (and canonical help) option specifications,
    # preserving unparsed options for subsequent parsing by the caller. If such
    # parsing fails, print the passed help text and return from the caller or
    # script with non-zero exit status. Dismantled, this is:
    #
    # * "-D", removing *ONLY* parsed options from the current argument list.
    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
    #   option specification, thus preserving all unspecified options.
    # * "-M", parsing "="-prefixed substrings in option specifications as the
    #   map key to parse such option into (e.g., "-help=h" parses long option
    #   "--help" into map key ${arg_options[-h]} rather than
    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
    #   target list or map name to parse such option into.
    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
    #   either the option values if passed or the empty string if not passed.
    if { not zparseopts -M -D -E -A "${map_name__smtaowhf}" --\
        "${args__smtaowhf[@]}" h -help=h } {
        print_warning "invalid command-line argument(s)"
        output_string "${help_message__smtaowhf}"
        report_failure
    }

    # If passed a help option, ignore all other options, print the passed help
    # text, and return from the caller function or script.
    if { is_map_key "${map_name__smtaowhf}" "-h" } {
        return_string "${args__smtaowhf}"
    }
} <<<'

# --------------------( WASTELANDS                         )--------------------
#function set_integer_to_arg_nonoption_index_first() {
#    # Validate sanity.
#    die_unless_args 'Expected zero or more arguments and one integer name.'
#    string integer_name__sitanif="${@[-1]}"
#    integer arg_nonoption_index_first__sitanif
#    pop_arg
#
#    # If such arguments contain "-" or "--", such index is one after the index
#    # of such argument.
#    arg_nonoption_index_first__sitanif="${@[(i)-|--]}"
#    if (( arg_nonoption_index_first__sitanif <= # )) {
#          arg_nonoption_index_first__sitanif+=1
#    # Else, such index is the index of the first argument *NOT* prefixed by "-"
#    # if such argument exists or the number of such arguments otherwise.
#    } else {
#        arg_nonoption_index_first__sitanif="${@[(i)[^-]*]}"
#    }
#
#    # Set such integer.
#    set_integer_to_integer "${integer_name__sitanif}"\
#        "${arg_nonoption_index_first__sitanif}"
#}

    # Set the index of the first non-option argument.
#    set_integer_to_integer "${integer_name_index__sitancaif}"\
#        "${arg_nonoption_index_first__sitancaif}"
#
#    # Set the number of such arguments.
#    set_integer_to_integer "${integer_name_count__sitancaif}"\
#        $(( # - ${(P)integer_name_index__sitancaif} + 1 ))

#, parsing arguments `-` and `--` as ending option arguments.

#FUXME: Also, our creation of local variables on the caller's behalf if not
#already declared is amusing, but highly incongruous. Consider it: when can a
#caller reasonably expect a setter to declare a variable for itself? Solipsistic
#answer: when such setter is an alias. But this is turn requires the caller to
#somehow know whether a setter is an alias or function, an implementation detail
#the caller should *NEVER* be knowledgable of. In other words, declaring local
#variables on the caller's behalf is breaking bad and should be desisted.
#Instead, just throw an exception if such variable does not exist (as usual).

#    # Validate sanity.
#    list args__seitancafif; set_list_to_stdin_words args__seitancafif
#    (( ${#args__seitancafif} == 2 )) or die "expected two integer names"
#    string\
#        count_integer_name__seitancafif="${args__seitancafif[1]}"\
#        index_integer_name__seitancafif="${args__seitancafif[2]}"
#
#    # Get the index of the first non-option argument.
#    set_integer_to_arg_nonoption_index_first\
#        "${index_integer_name__seitancafif}"
##   print "arg count: ${#}"
##   print "arg nonoption first index \"${index_integer_name__seitancafif}\": ${(P)index_integer_name__seitancafif}"
##   print "arg nonoption count: $(( # - ${(P)index_integer_name__seitancafif} + 1 ))"
#
#    # Set such integer.
##   print "count integer name: ${count_integer_name__seitancafif}"
#    is_variable "${count_integer_name__seitancafif}" or
#        integer "${count_integer_name__seitancafif}"
#    set_integer_to_integer "${count_integer_name__seitancafif}"\
#        $(( # - ${(P)index_integer_name__seitancafif} + 1 ))
#} <<<'

# Due to `zsh` constraints,
#integer names must be passed whitespace-delimited in a single shell word (e.g.,
#single- or double-quoted string).

#   die_unless_integer "${integer_name__sitanc}"
#== Premature Denotation ==
#
#By precedent, the first passed argument equal to `-` or `--` prematurely
#terminates option arguments. If such an argument was passed, the passed integer
#will be set to one greater than the index of such argument rather than the index
#of the first passed non-option argument.

    #FUXME: Replace implementation with a single expansion of
    #set_integers_to_arg_nonoption_count_and_index_first().

#alias set_integer_to_arg_nonoption_index_first='{
#    #FIXME: Replace implementation with a single expansion of
#    #set_integers_to_arg_nonoption_count_and_index_first().
#
#    # Validate sanity.
#    list args__seitanfi
#    set_list_to_stdin_words args__seitanfi
#    (( ${#args__seitanfi} == 1 )) or die "expected one integer name"
#    string integer_name__seitanfi="${args__seitanfi[1]}"
#    integer arg_nonoption_index_first__seitanfi
#
#    # If sanity.contain "-" or "--", the index of the first non-option
#    # in such arguments is one after the index of such "-" or "--".
#    arg_nonoption_index_first__seitanfi=${@[(i)-|--]}
#    if (( arg_nonoption_index_first__seitanfi <= # )) {
#        noop $(( ++arg_nonoption_index_first__seitanfi ))
#    # Otherwise, the index of the first non-option in such arguments is the
#    # index of the argument *NOT* prefixed by "-" or the number of such
#    # arguments if all arguments are prefixed by "-" or no arguments are passed.
#    } else {
#        arg_nonoption_index_first__seitanfi=${@[(i)[^-]*]}
#    }
#
#    # Set such integer.
#    is_variable "${integer_name__seitanfi}" or
#        integer "${integer_name__seitanfi}"
#    set_integer_to_integer "${integer_name__seitanfi}"\
#        "${arg_nonoption_index_first__seitanfi}"
#} <<<'

#alias set_integer_to_arg_nonoption_count='
#{
#    # Validate sanity.
#    list args__seitanc; set_list_to_stdin_words args__seitanc
#    (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#
#    # Defer to the above alias with a placeholder first index integer name.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        "${args__seitanc[1]} index_integer_name__seitanc"
##   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
#} <<<'

#FUXME: Globally rename "_arg_nonoption_index_first" to
#"_arg_nonoption_index_first".

#declare_alias_with_stdin <<'/---'
#void set_integer_to_arg_nonoption_count(string integer_name)
#
#Set the passed integer to the number of *non-options arguments* the caller
#passed (i.e., arguments not prefixed by `-`). Parse arguments `-` and `--` as
#ending option arguments.
#/---
#alias set_integer_to_arg_nonoption_count='
#{
#    # Validate sanity.
#    list args__seitanc; set_list_to_stdin_words args__seitanc
#    (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#
#    # Defer to the above alias with a placeholder first index integer name.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        "${args__seitanc[1]} index_integer_name__seitanc"
##   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
#} <<<'

    # Validate sanity.
#   list args__seitanc; set_list_to_stdin_words args__seitanc
#   (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#   string integer_name__seitanc="${args__seitanc[1]}"

    # Get the index of the first non-option argument.
#   set_integer_to_arg_nonoption_index_first arg_nonoption_index_first__seitanc
#   print "arg count: ${#}"
#   print "arg nonoption first index: ${arg_nonoption_index_first__seitanc}"
#   print "arg nonoption count: $(( # - arg_nonoption_index_first__seitanc + 1 ))"

    # Set such integer.
#    is_variable_integer "${integer_name__seitanc}" or integer "${integer_name__seitanc}"
#   set_integer_to_integer "${integer_name__seitanc}"\
#       $(( # - arg_nonoption_index_first__seitanc + 1 ))

#FUXME: Rename to set_list_to_arg_options_with_help_from() and accept the first
#passed argument as a list name. In other words, stop assuming a list name of
#${arg_options} as we currently do.

#boolean is_arg_nonoptions_1_to_3{void}
#boolean is_arg_nonoptions_1_to_3<void>
#Return true if the number of non-options in the current argument list (i.e.,
#arguments not prefixed by "-") is . This alias parses arguments "-" and "--"
#as the last options in such list.

#set_integer_to_arg_nonoption_count __nonoptions__ and
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#'
#alias is_arg_nonoptions_1_to_3='
#{
#    integer __nonoptions__; set_integer_to_arg_nonoption_count __nonoptions__
#    print "non-option count: ${__nonoptions__}"
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#}
#'
#function tyam() {
#   set_integer_to_arg_nonoption_count y
#   print "arg nonoption count: $y"
#    is_arg_nonoptions_1_to_3 and print "...between 1 to 3"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}
    #FUXME: Such functionality, duplicated above, should arguably be
    #encapsulated into a single function -- perhaps, print_message set_integer_locally()
    #or set_integer_declaratively(). Hmm; how about
    #set_integer_declared_locally_unless_found() or
    #set_integer_and_localize_unless_declared() or
    #set_integer_localized_if_unset()? Yes; the latter, I should think. Ah; wait.
    #The syntax is rather ugly, requiring a composite herestring. *shrug*

#   set_integer_to_integer "${integer_name_seitanfi}" $(( arg_nonoption_index_first_seitanfi ))
#   list __args__; __args__=( ${(z)"$(< /dev/stdin)"} )
# Get the number of non-options passed (i.e., non-"-"-prefixed arguments).
    #FUXME: Be nice to extract this into a new set_integer_to_evaluation().
    #Actually, how about a more general set_scalar_to_evaluation()? Right. That
    #seems perfect.

#   noop ${(P)__integer_name__::=$(( __arg_nonoption_index_first__ ))}
#   noop ${(P)__integer_name__::=$(( # - __arg_nonoption_index_first__ + 1 ))}
        # Else, if at least one sanity.is not prefixed by "-", such
        # argument is the first non-option in such arguments.
        # Otherwise, set such index to the size of such list plus one.
#       (( __arg_option_last_index__ <= # )) or 
#           (( __arg_option_last_index__ <= # )) or 
#       then noop ${(P)__integer_name__::=$(( __arg_option_last_index__ ))}
#       else 
#       fi

#   noop  ${(P)__integer_name__::=${@[(i)-|--]}}
#   if (( ${(P)__integer_name__} <= # ))

#FUXME: Completely unrelated to this component, but we can now actually create
#sensible return_string()-style aliases! Oh, man; pretty sweet. Finally found
#it.

    #FUXME: Validate the passed argument is a single argument. Just revert to
    #the traditional argument parsing to do so.
    # Validate sanity.
#   string __integer_name__; __integer_name__="$(get_stdin_piped)"
