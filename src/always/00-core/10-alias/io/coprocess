#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *coprocesses*. See coprocess() for further details.

== See Also ==

* [http://www.zsh.org/mla/users/2011/msg00095.html](Coprocess tutorial, redux),
  the authoritative introduction to coprocesses. Since `zsh`\'s `man` and `info`
  pages remain remarkably silent on the issue, such introduction also serves as
  canonical documentation for coprocesses and comes recommended.
/---

# ....................{ DECLARERS                          }....................
#FIXME: Add examples. Desperately needed, in this case. Coprocesses are rather
#obtuse, it must be admitted.
declare_alias_with_stdin\
    'void open_coprocess(
        string command1_name, string command1_arg1, string command1_arg2, ...,
        string command2_name, string command2_arg1, string command2_arg2, ...,
        ...)'\
   'set_shell_option_locally no_monitor
    coproc' <<'/---'
Run the passed sequence of commands as a *coprocess* (i.e., subshell of the
current shell whose standard input and output are attached to a temporary
anonymous FIFO readable and writable only from the current shell). To reduce
verbosity, this alias also disables job monitoring for the current context.
To safely close such coprocess (and associate subshell and file descriptor) and
_and_ reenable such monitoring, consider calling close_coprocess() from a
subsequent `always` block: e.g.,

== Motivation ==

Coprocesses are generalizations of pipelines. In a pipeline, all commands
except the last are run in subshells and hence cannot modify the current shell.
Using a coprocess, however, arbitrary commands can be executed in either
subshells _or_ the current shell and hence modify the current shell.
/---

# ....................{ OUTPUTTERS                         }....................
declare_alias_with_stdin\
    'void output_string_to_coprocess(string text = "")'\
    'print -rp --' <<'/---'
Output the passed string (defaulting to the empty string) suffixed by a newline
to standard input of the coprocess for the current shell. If no such coprocess
exists, throw an exception.
/---

# ....................{ SETTERS                            }....................
# This should probably be shifted elsewhere, but I can't be bothered.
declare_function_with_stdin <<'/---'
void set_string_to_coprocess_output(string string_name)

Set the passed string variable to all standard output of the coprocess for the
current shell. If no such coprocess exists, throw an exception.
/---
function set_string_to_coprocess_output() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'

    # Set such string. Ideally, the following (slightly more efficient)
    # assignment should also work:
    #
    #     IFS= read -rp -d "" string_name__sstco
    #
    # Instead, such assignment silently blocks. Note that the "{" and "}"
    # delimiters are essential, ensuring the expansion of get_stdin() receives
    # standard input from such coprocess rather than from the current context.
#   eval ${string_name__sstco}'="$(< /dev/stdin)" <&p'
    { set_string_to_string "${1}" "$(get_stdin)" } <&p
}

# ....................{ CLOSERS                            }....................
#FIXME: This should probably throw an exception if no coprocess is currently
#open. No idea if testing such condition is even feasible at the moment,
#however. (Hmm, perhaps attempting a "print -np &>/dev/null" and seeing if an
#exception is thrown?)
#FIXME: It'd be nice to extricate "wait $!" and "wait" into corresponding
#aliases of a new jobs parcel -- say @{05-alias/io/job}?

# Honestly, this is insanity. In theory, waiting for the exit() coprocess to
# complete should suffice to ensure that all coprocesses are complete. In
# practice, the "always" block enclosing such expansion complicates matters.
# Without such block, a single wait suffices; with such block, an additional
# wait on *ALL* running jobs in the current context is also required. It's
# patently unclear why, but at least this belatedly suffices.
#
# The "coproc { coproc : }" command comes courtesy Bart Schaefer at the
# "zshworkers" mailing list -- apparently resolving a long-standing issue with
# coprocess handling of subshells. See any of the following threads:
#
# * http://www.zsh.org/mla/users/2011/msg00093.html
# * http://www.zsh.org/mla/users/2011/msg00095.html
# * http://www.zsh.org/mla/workers/2013/msg00188.html
#
# We really do wish they'd simply resolve the underlying issue. (This is
# becoming somewhat embarrassing, fellows.)
declare_alias_with_stdin 'void close_coprocess(void)'\
   '{
        coproc { coproc : }
        wait ${!}
        wait
        set_shell_option_locally monitor
    }' <<'/---'
Close the coprocess for the current shell, thus closing the corresponding
file descriptor and subshell.
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: I don't quite get it. We should be able to prefix such alias expansion
#with "always ", as alias always_convert_exception_to_warning() does. I recall
#attempting that and it not working. Nonetheless, it *SHOULD* work... Try again!

# Ideally, this alias should also reenable job monitoring by calling
# "set_shell_option_locally monitor". Sadly, doing so typically displays job
# monitoring for the call to coproc() below -- even when waiting for all jobs
# to complete in the current context *AND* reenabling job monitoring only after
# such jobs complete. We managed to track this down to the "always" block
# construct; for some glibly unfathomable reason, zsh fails to wait properly in
# such blocks. Instead, the caller must explicitly 
#   set_shell_option_locally monitor' <<'/---'

# Short of sleeping for a sufficiently long
# duration, there's no reliable means of getting this to work; hence, we don't.
#   string string_name__sstco="${1}"
#   die_unless_variable_string "${string_name__sstco}"

#   print 'ok..'
#   print "coproc: $(get_stdin)" <&p
#   print 'ko..'
#declare_alias_with_stdin\
#    'void set_string_to_coprocess_output(string string_name)'\
#    '{
#        # Validate sanity.
#        string string_name__sstco; string_name__sstco="$(get_stdin)"
#        die_unless_variable_string "${string_name__sstco}"
#
#        # Set such string. Ideally, the following (slightly more efficient)
#        # assignment should also work:
#        #
#        #     IFS= read -rp -d "" string_name__sstco
#        #
#        # Instead, such assignment silently blocks. *shrug*
#        print "coproc: $(get_stdin)" <&p
#        set_string_to_string "${string_name__sstco}" "$(get_stdin)" <&p
#    } <<<' <<'/---'
#Set the passed string variable to all standard output of the coprocess for the
#current shell. If no such coprocess exists, throw an exception.
#/---

#set_shell_option_locally monitor
# This alias also reenables the job monitoring
#temporary disabled by open_coprocess().

#always 
#Such
#coprocess should always be closed by calling close_coprocess() from an `always` block to 

#   'void open_coprocess_to_stdin_until_eot(void)'\
        # Set such string. Dismantled, this is:
        #
        # * "IFS=", preventing read() from splitting input on field separators.
        # * "-r", preserving input characters (e.g., backslashes do not escape).
        # * "-p", reading from the current coprocess.
        # * "-d ''", reading all input rather than merely to the first newline.
#       IFS= read -rp -d "" string_name__sstco

# (and hence cannot modify the current shell)
#current shell and subshells. should be executed in
#subshells and which 
#execute arbitrarily many pipeline subcommands
#in an arbitrary sequence of 

#subshells of the current shell whose standard input
#and output  connected that of the current shell with a temporary FIFO),
#(i.e., a 
