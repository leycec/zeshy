#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by alias, function, and global declarers.

# ....................{ GLOBALS                            }....................
# Exported string PCRE globals, defined and documented below.
typeset -gx\
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAMES\
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES\
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES\
    ZESHY_HELP_PCRE_RUNNABLE_PROTOTYPE_NAME

# Define such PCREs in an anonymous block to permit definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
    # PCRE matching the start of a zeshy help string. Dismantled, this is:
    #
    # * "(?s)", inducing '.' to match all characters including newline.
    local pcre_start='(?s)^\s*+'

    # Comma preceded and followed by optional whitespace.
    local pcre_comma='\s*+,\s*+'

    # zsh identifier (i.e., variable name).
    local pcre_ident='[-_[:alnum:]]++'

    # Function attributes. zeshy currently prohibits single- and double-quoted
    # attribute names, thus simplifying matching.
    local pcre_function_attributes='(?:<\s*+([^>]*+)>\s++)?'

    # Function return types. zeshy currently prohibits single- and double-quoted
    # return types, thus simplifying matching.
    local pcre_return_channel_grouped='('${pcre_ident}')\s*+:\s*+('${pcre_ident}')'
    local pcre_return_type_grouped='(?:void|('${pcre_ident}'))'
    local                    pcre_return_type=${pcre_ident}
    local pcre_return_channels_grouped='\[\s*+([^]]*+)\]'
    local         pcre_return_channels='\[\s*+[^]]*+\]'
    local pcre_return_type_or_channels='(?:'${pcre_return_type}'|'${pcre_return_channels}')\s++'
    local pcre_return_type_or_channels_grouped='(?:'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')\s++'

    # Runnable names. Since zsh permits single- and double-quoted alias and
    # function names, matching requires more than merely class negation. While
    # reliably quoting alias names is non-trivial (unlike functions), it *IS*
    # feasible. See define_alias() for further details.
    #
    # Strictly speaking, only function syntax supports synonyms under plain zsh.
    # Since such support is a superficial convenience, however, there exists no
    # reason *NOT* to extend such support to alias syntax as well. Hence, we do.
    local pcre_runnable_name_unquoted_grouped='('${pcre_ident}')'
    local            pcre_runnable_name_unquoted=${pcre_ident}
    local pcre_runnable_name_quoted_single_grouped="'((?:[^']|'')*)'"
    local          pcre_runnable_name_quoted_single="'(?:[^']|'')*'"
    local pcre_runnable_name_quoted_double_grouped='"((?:[^"]|\\")*)"'
    local          pcre_runnable_name_quoted_double='"(?:[^"]|\\")*"'
    local pcre_runnable_name_grouped='(?|'${pcre_runnable_name_unquoted_grouped}'|'${pcre_runnable_name_quoted_single_grouped}'|'${pcre_runnable_name_quoted_double_grouped}')'
    local         pcre_runnable_name='(?:'${pcre_runnable_name_unquoted}'|'${pcre_runnable_name_quoted_single}'|'${pcre_runnable_name_quoted_double}')'
    local pcre_runnable_names_grouped='\{\s*+((?:'${pcre_runnable_name}'(?:'${pcre_comma}'|\s++))*'${pcre_runnable_name}')(?:'${pcre_comma}')?\s*+\}'
    local pcre_runnable_name_or_names_grouped='(?:'${pcre_runnable_name_grouped}'|'${pcre_runnable_names_grouped}')\s*+'

    # Function arguments.
    local pcre_arg_value_quoted_double='"(?:\\"|$\([^)]*+\)|[^"])*"'
    local pcre_arg_value_quoted_single=${pcre_runnable_name_quoted_single}
    local pcre_arg_value_number='-?\d++\.\d++|-?\d++'
    local pcre_arg_value_content=${pcre_arg_value_quoted_double}'|'${pcre_arg_value_quoted_single}'|'${pcre_arg_value_number}
    local pcre_arg_value_equals='\s*+=\s*+'
    local pcre_arg_value_grouped=${pcre_arg_value_equals}'('${pcre_arg_value_content}')'
    local         pcre_arg_value=${pcre_arg_value_equals}'(?:'${pcre_arg_value_content}')'
    local pcre_arg_grouped='('${pcre_ident}')\s++('${pcre_ident}')(?:'${pcre_arg_value_grouped}')?'
    local            pcre_arg=${pcre_ident}'\s++'${pcre_ident}'(?:'${pcre_arg_value}')?'
    local pcre_args_list_grouped='((?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}')(?:'${pcre_comma}')?'
    local          pcre_args_list='(?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}'(?:'${pcre_comma}')?'
    local pcre_args_grouped='\(\s*+(?:void|'${pcre_args_list_grouped}')?\s*+\)'
    local         pcre_args='\(\s*+(?:void|'${pcre_args_list}')?\s*+\)'
    local pcre_arg_channel_grouped='('${pcre_ident}')\s*+:\s*+(?:(void|'${pcre_arg}')|('${pcre_args}'))'
    local            pcre_arg_channel=${pcre_ident}'\s*+:\s*+(?:void|'${pcre_arg}'|'${pcre_args}')'
    local pcre_arg_channels='\[\s*+((?:'${pcre_arg_channel}${pcre_comma}')*'${pcre_arg_channel}')(?:'${pcre_comma}')?\s*+\]'
    local pcre_args_or_channels_grouped='(?:'${pcre_args_grouped}'|'${pcre_arg_channels}')'

    # Function description. Ignore cross-references embedded in the following
    # AsciiDoc-specific passthrough syntactic constructs, which AsciiDoc and hence
    # zeshy ignores for parsing purposes:
    #
    # * "`"-delimited passthrough quotes.
    # * "pass:["- and "]"-delimited passthrough macros.
    # * "+++"-delimited passthrough macros.
    # * "$$"-delimited passthrough macros.
    # * "\n----"-delimited listing blocks.
    # * "\n...."-delimited literal blocks.
    # * "\n////"-delimited comment blocks.
    # * "\n++++"-delimited passthrough blocks.
    # * "\n[literal]"-prefixed literal paragraphs.
    # * "\n "- and "\n\t"-prefixed literal lines.
    #
    # Ignore cross-references embedded in the following AsciiDoc-specific anchored
    # syntactic constructs, which AsciiDoc anchors for subsequent cross-referencing
    # and hence should not themselves contain cross-references:
    #
    # * "\n."-prefixed block titles.
    local pcre_asciidoc_quote_backtick='\b`\N*?`\b'
    local pcre_asciidoc_macro_pass='pass:\[(?:\\\]|\N)*?\]'
    local pcre_asciidoc_macro_plus='\+\+\+\N*?\+\+\+'
    local pcre_asciidoc_macro_dollar='\$\$\N*?\$\$'
    local pcre_asciidoc_block_listing='-{4,}+\n.*?\n-{4,}+'
    local pcre_asciidoc_block_literal='\.{4,}+\n.*?\n\.{4,}+'
    local pcre_asciidoc_block_comment='/{4,}+\n.*?\n/{4,}+'
    local pcre_asciidoc_block_pass='\+{4,}+\n.*?\n\+{4,}+'
    local pcre_asciidoc_block_title_or_line_literal='(?:\.|[ \t]++)\N+'
    local pcre_asciidoc_paragraph_literal='^\[literal\]\n.*?(?:\n\n|\Z)'
    local pcre_asciidoc_cross_reference='((?:'${pcre_asciidoc_quote_backtick}'|\b(?:'${pcre_asciidoc_macro_pass}'|'${pcre_asciidoc_macro_plus}'|'${pcre_asciidoc_macro_dollar}')\b|^(?:'${pcre_asciidoc_block_listing}'|'${pcre_asciidoc_block_literal}'|'${pcre_asciidoc_block_comment}'|'${pcre_asciidoc_block_pass}'|'${pcre_asciidoc_block_title_or_line_literal}')$|'${pcre_asciidoc_paragraph_literal}'|.)*?)([$@]\{'${pcre_ident}'\}|(?:(alias|function):)?'${pcre_ident}'\(\))'
    local pcre_asciidoc_suffix='(.*)'
    local pcre_asciidoc='\s*+(.*)'

    # PCRE matching all alias names in alias prototypes.
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAMES="${pcre_start}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}"

    # PCRE matching all function attributes and names in function prototypes.
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES="${pcre_start}${pcre_function_attributes}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}"

    #FIXME: Exclude attributes and names.
    # PCRE matching all semantic substrings in function prototypes, excluding
    # attributes and names. This includes return types, arguments, and AsciiDoc.
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES="${pcre_start}${pcre_function_attributes}${pcre_return_type_or_channels_grouped}${pcre_runnable_name_or_names_grouped}${pcre_args_or_channels_grouped}${pcre_asciidoc}"'()$'

    # PCRE matching one alias or function name in a list of such names.
    ZESHY_HELP_PCRE_RUNNABLE_PROTOTYPE_NAME=${pcre_runnable_name_grouped}'(?:'${pcre_comma}')?'
}

# --------------------( WASTELANDS                         )--------------------
    # Function names. Since functions but *NOT* aliases support synonyms,
    # function and alias name syntax must be handled distinctly.
#   local pcre_function_name_grouped='('${pcre_runnable_name_content}')'
#   local       pcre_function_name='(?:'${pcre_runnable_name_content}')'
#   local pcre_function_names='\{\s*+((?:'${pcre_runnable_name}'(?:'${pcre_comma}'|\s++))*'${pcre_runnable_name}')(?:'${pcre_comma}')?\s*+\}'
#   local pcre_function_name_or_names='(?:'${pcre_runnable_name_grouped}'|'${pcre_function_names}')\s*+'

    # Alias names. Since zsh permits single- and double-quoted alias names,
    # matching requires more than class negation. While quoting alias names is
    # is non-trivial (unlike functions), it *IS* feasible. See define_alias()
    # for further details.
#   local pcre_alias_name_grouped='('${pcre_runnable_name_content}')'
