#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *integer* (i.e., non-fractional number) variable declarators.
/---

# ....................{ INTEGERS                           }....................
# zsh already provides builtin integer() for declaring local integers.

declare_alias_with_stdin 'void integer_global(string variable_name1, ...)'\
    'integer -g --' <<'/---'
Declare the passed integers globally, but _not_ exported to the calling shell.
/---

declare_alias_with_stdin\
    'void integer_global_export(string variable_name1, ...)'\
    'export -i --' <<'/---'
Declare the passed integers globally exported to the calling shell.
/---

# ....................{ INTEGERS ~ constant                }....................
declare_alias_with_stdin\
    'void integer_constant_global_export(string variable_name1, ...)'\
    'export -ir --' <<'/---'
Declare the passed integer constants globally exported to the calling shell.
/---

# ....................{ INTEGERS ~ base                    }....................
# Note that "integer" does *NOT* suffice here.
declare_alias_with_stdin\
    'void integer_in_base(integer base, string variable_name1, ...)'\
    'local -i'  <<'/---'
Declare the passed integers locally in the passed base. On expansion, such
integers will be implicitly converted to the equivalent values in such base.
Additionally, if such base is:

* `8`, such integers will be pretty printed in *octal format* and hence:
** Prefixed with a C-style `0`.
* `16`, such integers will be pretty printed in *hexadecimal format* and hence:
** Prefixed with a C-style `0x`.
** Digits in the range [10, 15] will be printed as capitalized letters in the
   range [A, F], per tradition.

For example: e.g.,

.integer_in_base()
==========================================
[source]
------------------------------------------
>>> integer_in_base 16 factory_farming=4277009102
>>> print_string    "${factory_farming}"
0xFEEDFACE
------------------------------------------
==========================================
/---

# ....................{ INTEGERS ~ file descriptor         }....................
declare_alias_with_stdin\
    'void file_descriptor(string variable_name1, ...)'\
    'integer' <<'/---'
Declare the passed file descriptors locally.
/---

declare_alias_with_stdin\
    'void file_descriptor_global(string variable_name1, ...)'\
    'integer_global' <<'/---'
Declare the passed file descriptors globally, but _not_ exported to the calling
shell.
/---

declare_alias_with_stdin\
    'void file_descriptor_global_export(string variable_name1, ...)'\
    'integer_global_export' <<'/---'
Declare the passed file descriptors globally exported to the calling shell.
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Theoretically, integers should provide a much more efficient type for
#housing booleans than strings. After all, there's no need for string handling,
#which, to support arbitrarily long strings containing null characters, do not
#cleanly map to C strings and hence require more under-the-scenes handling than
#simple integers (which probably map fairly reasonably to underlying C types).
#In short, testing "(( boolean_variable ))" for the truth of a boolean should be
#significantly faster (aggregated over all such tests) than testing
#"[[ -n ${boolean_variable} ))".
#FUXME: Integers actually make a *VASTLY* preferable core type for implementing
#booleans than strings. Testing integer zeroness or non-zeroness is more
#efficient *AND* readable than the equivalent string emptiness or nonemptiness
#tests. Moreover, it just makes intuitive sense to represent booleans as
#integers constrained to 0 and 1. To effect this change, we'll need to:
#
#* Revise "00-startup/02-constants/boolean".
#* Revise "variable/boolean".
#
#That *SHOULD* be it. But I'm sure everything will break anyway. *sigh*

#boolean duality translates better onto integers
#than strings,
#* `10`, such integers will be converted to *decimal format*, the default format.
#(i.e., non-fractional number) 
