#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'---'
Handle path access, change, and modification times.
---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_path_time_format(
    character format,
    string error_message =
        "\"stat\" time format \"${format}\" invalid (i.e., neither \"x\", \"y\", or \"z\").")

Throw an exception with the passed message unless the passed character is a
valid path time format. See is_path_time_format() for further details.
/---
function die_unless_path_time_format() {
    die_unless_args_1_to_2 'Expected one format and optional error message.'
    string format="${1}"
    is_path_time_format "${format}" or
        die "${2:-\"stat\" time format \"${format}\" invalid (i.e., neither \"x\", \"y\", or \"z\").}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_path_time_format(character format)

Return success if the passed character is either `x`, `y`, or `z`, corresponding
to the three `stat`-specific character formats accepted by
get_path_time_for_format().
/---
function is_path_time_format() {
    die_unless_arg 'Expected one path time format.'
    is "${1}" == [xyz] si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
float get_path_time_for_format(string pathname, character format)

Get the time of the passed path corresponding to the passed format character.

Such time is in high-resolution fractional seconds since the Unix epoch,
typically accurate to the nanosecond. See get_time() for further details.

Such character is a `stat`-specific format specifier for retrieving path times.
See `man stat` for further details. Specifically, if such character is:

* `x`, such path's access time is returned.
* `y`, such path's modification time is returned.
* `z`, such path's change time is returned.

For example:

.get_path_time_for_format()
==========================================
[source]
------------------------------------------
>>> set_path_mtime           /the/sound/of/perseverance 134664317.620900507
>>> get_path_time_for_format /the/sound/of/perseverance 'y'
134664317.620900507
------------------------------------------
==========================================
/---
#FIXME: Such implementation is Linux-specific. The BSD version actually
#implicitly supports floating point times, which is quite a bit better than the
#situation on Linux. (Nice reversal, BSD!) See:
#    https://developer.apple.com/library/mac/#documentation/Darwin/Reference/Manpages/man1/stat.1.html
#I really can't be bothered to implement support at the moment, but there it
#is. Hopefully, by the time this becomes a concern, zsh revises zstat() to
#support high resolution times. :)

# Sadly, zsh's zstat() fails to support retrieval of high-resolution file times,
# even under systems recording such times (e.g., post-2.6 Linux kernels). Until
# such support is added, retrieve such times by cobbling together the expected
# fractional Unix time from the output of the GNU-specific "stat"
# implementation: e.g.,
#
#     # Print the current modification time for standard output in both human-
#     # and machine-readable format, delimited by "~~~". Note that the former
#     # provides the desired fractional portion and the latter the desired
#     # integer portion. Grafting the two together yields the expected time:
#     # 1369265941.436503138.
#     >>> stat --dereference --printf '%y~~~%Y' /dev/fd/1
#     2013-05-22 19:39:01.436503138 -0400~~~1369265941
#
# If the current "stat" implementation is non-GNU, retrieve the typical low-
# resolution file times. (Technically, we could add support for the BSD-specific
# "stat" implementation, but it hardly seems worth it. zsh's zstat() *SHOULD*
# add support for higher resolution by the time this becomes a larger concern.)
if { is_pathable_gnu stat } {
    function get_path_time_for_format() {
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize changes with versions below.
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # Validate sanity.
        die_unless_args_2 'Expected one pathname and one format.'
        string pathname="${1}" format="${2}"
        die_unless_path "${pathname}"
        die_unless_path_time_format "${format}"

        # If "stat" formats such time in the customary English format
        # "AA:BB:CC.DD", capture the "."-prefixed substring of digits as the
        # desired number of nanoseconds. Dismantled, this is:
        #
        # * "%${format}", printing such time in locale-dependent format.
        # * "%${(U)format}", printing such time in seconds since the Unix epoch.
        # * "(#b)", capturing all subsequent match groups.
        # * "('.'[[:digit:]]##)", capturing nanoseconds to ${match[1]}.
        # * "([[:digit:]]##)", capturing seconds to ${match[2]}.
        if is "$(command stat --dereference\
            --printf "%${format}~~~%${(U)format}" -- "${pathname}")" ==\
            *([[:digit:]][[:digit:]]':')([[:digit:]][[:digit:]]':')([[:digit:]][[:digit:]])(#b)('.'[[:digit:]]##)*'~~~'([[:digit:]]##) si {
            return_string "${match[2]}${match[1]}"
        # Else, "stat" formats such time in another locale-dependent format.
        # Devolve to returning only the desired number of seconds.
        } else {
            command stat --dereference --printf "%${(U)format}" -- "${pathname}"
        }
    }
} else {
    function get_path_time_for_format() {
        # Validate sanity.
        die_unless_args_2 'Expected one pathname and one format.'
        string pathname="${1}" format="${2}"
        die_unless_path "${pathname}"
        die_unless_path_time_format "${format}"

        case "${format}" {
        x) zstat +atime -- "${pathname}";;
        y) zstat +mtime -- "${pathname}";;
        z) zstat +ctime -- "${pathname}";;
        # The prior call to die_unless_path_time_format() should handle this.
        *) die
        }
    }
}

# ....................{ GETTERS ~ mtime                    }....................
declare_function_with_stdin <<'/---'
float get_path_mtime(string pathname)

Get the modification time of the passed path in high-resolution fractional
seconds since the Unix epoch. See get_time() for further details. By POSIX
design, this is the most recent time of those in the following list:

* Such path's creation.
* The most recent change to such path's permissions.
* The most recent change to such path's content. If such path is a:
** File, this is the most recent change to such file's content.
** Directory, this is the most recent creation, deletion, or renaming (but
   not change to permissions or content) of a file or subdirectory in such
   directory.

For example:

.get_path_mtime()
==========================================
[source]
------------------------------------------
>>> set_path_mtime /scavenger/of/human/sorrow 1355695676.627450733
>>> get_path_mtime /scavenger/of/human/sorrow
1355695676.627450733
------------------------------------------
==========================================
/---
function get_path_mtime() {
    die_unless_arg 'Expected one pathname.'
    get_path_time_for_format "${1}" 'y'
}

# --------------------( WASTELANDS                         )--------------------
#   mtime="${2:-$(get_time)}"
# with optional fractional digits on
#systems recording high-resolution file times)
#, where
#the meaning of ``high-resolution'' depends on system-specific properties
#       zam=( "${(s:~~~:)"$(stat --dereference --printf '%y~~~%Y' "${pathname}")"}" )
        # For efficiency, inline such implementation. See set_list_to_string_split_on_string for further details.
#   if is_file "${pathname}"
#   else die "\"${pathname}\" not found or not a file or directory"
#     directory's file or subdirectory creation,
#     deletion, 
# * to file content or
# permissions. If such path is a directory, this time reflects file and
# subdirectory creation but not changes to file or subdirectory content or
# permissions.
