#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *list globs* (i.e., extended glob expressions matching list items).
/---

# ....................{ TESTERS                            }....................
# Yes, the distinctions in nomenclature between this and subsequent functions is
# intended. See @{glob/string/string} for additional justifications.

declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_list_matches_glob(
    string list_name, string glob)

Return success if the passed list contains an item matching the passed glob:
e.g.,

.is_list_matches_glob()
==========================================
[source]
------------------------------------------
>>> list on_fundamentalism; on_fundamentalism=(
...    "As for the second notion, the idea that we could lose our freedom by"
...    "succumbing to a wave of religious hysteria, I am sorry to say that I"
...    "consider it possible. I hope that it is not probable. But there is a"
...    "latent deep strain of religious fanaticism in this, our culture; it is"
...    "rooted in our history and it has broken out many times in the past. It"
...    "is with us now; there has been a sharp rise in strongly evangelical"
...    "sects in this country in recent years, some of which hold beliefs"
...    "theocratic in the extreme, anti-intellectual, anti-scientific, and"
...    "anti-libertarian. It is a truism that almost any sect, cult, or"
...    "religion will legislate its creed into law if it acquires the political"
...    "power to do so, and will follow it by suppressing opposition,"
...    "subverting all education to seize early the minds of the young, and by"
...    "killing, locking up, or driving underground all heretics. This is"
...    "equally true whether the faith is Communism or HolyRollerism; indeed it"
...    "is the bounden duty of the faithful to do so. The custodians of the"
...    "True Faith cannot logically admit tolerance of heresy to be a virtue." )
>>> is_list_matches_glob on_fundamentalism *'anti-'[[:WORD:]]* and\
...     output_string "Man is not a rational animal, he is a rationalizing animal."
Man is not a rational animal, he is a rationalizing animal.
------------------------------------------
==========================================
/---
function is_list_matches_glob() {
    die_unless_args_2 'Expected one list name and one glob.'
    run_code_silent get_list_index_matching_glob_first_if_found "${(q)@}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> string get_list_item_matching_glob_first(
    string list_name, string glob)

Get the first item of the passed list matching the passed glob or throw an
exception if no such item matches: e.g.,

.get_list_item_matching_glob_first()
==========================================
[source]
------------------------------------------
>>> list on_sectarianism; on_sectarianism=(
...    "Nevertheless this business of legislating religious beliefs into law"
...    "has never been more than sporadically successful in this country –"
...    "Sunday closing laws here and there, birth control legislation in spots,"
...    "the Prohibition experiment, temporary enclaves of theocracy such as"
...    "Voliva's Zion, Smith's Nauvoo, a few others. The country is split up"
...    "into such a variety of faiths and sects that a degree of uneasy"
...    "tolerance now exists from expedient compromise; the minorities"
...    "constitute a majority of opposition against each other. Could it be"
...    "otherwise here? Could any one sect obtain a working majority at the"
...    "polls and take over the country? Perhaps not – but a combination of a"
...    "dynamic evangelist, television, enough money, and modern techniques of"
...    "advertising and propaganda might make Billy Sunday's efforts look like"
...    "a corner store compared to Sears Roebuck. Throw in a depression for"
...    "good measure, promise a material heaven here on earth, add a dash of"
...    "anti-Semitism, anti-Catholicism, anti-Negroism, and a good large dose"
...    "of anti-\"furriners\" in general and anti-intellectuals here at home"
...    "and the result might be something quite frightening – particularly when"
...    "one recalls that our voting system is such that a minority distributed"
...    "as pluralities in enough states can constitute a working majority in"
...    "Washington... The capacity of the human mind for swallowing nonsense"
...    "and spewing it forth in violent and repressive action has never yet"
...    "been plumbed." )
>>> get_list_item_matching_glob_first on_sectarianism *'anti-'[[:WORD:]]*
anti-Semitism, anti-Catholicism, anti-Negroism, and a good large dose
------------------------------------------
==========================================
/---
function get_list_item_matching_glob_first() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one list name and one glob.'
    string match__glimgf

    # Get such match if found or throw an exception.
    if { match__glimgf="$(get_list_item_matching_glob_first_if_found "${@}")" } {
        return_string "${match__glimgf}"
    } else {
        string list_name__glimgf="${1}" glob__glimgf="${2}"
        die 'List ${'${list_name__glimgf}'} contains no item matching "'${glob__glimgf}'".'
    }
}

declare_function_with_stdin <<'/---'
<globbable> [stdout: string, status: boolean]
    get_list_item_matching_glob_first_if_found(string list_name, string glob)

Get the first item of the passed list matching the passed glob or return
failure if no item matches: e.g.,

.get_list_item_matching_glob_first_if_found()
==========================================
[source]
------------------------------------------
>>> list on_testimony; on_testimony=(
...    "In the Twentieth Century of my trespass on earth,"
...    "having exterminated one billion heathens,"
...    "heretics, Jews, Moslems, witches, mystical seekers,"
...    "black men, Asians, and Christian brothers,"
...    "every one of them for his own good,"
...    ""
...    "a whole continent of red men for living in unnatural community"
...    "and at the same time having relations with the land,"
...    "one billion species of animals for being sub-human,"
...    "and ready to take on the bloodthirsty creatures from the other planets,"
...    "I, Christian man, groan out this testament of my last will." )
>>> get_list_item_matching_glob_first_if_found on_testimony ?p?c?l?ps? or
...     output_string "We shall not all sleep, but we shall be changed . . ."
We shall not all sleep, but we shall be changed . . .
------------------------------------------
==========================================
/---
function get_list_item_matching_glob_first_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one list name and one glob.'
    string list_name__glimgfif="${1}"
    integer index__glimgfif

    # Get such item if found or fail. Since subscript flag "(r)" expands to
    # the empty string if no such item matches and hence is indistinguishable
    # from a successful match of the empty string (e.g., "*"), avoid such flag.
    index__glimgfif="$(get_list_index_matching_glob_first_if_found "${@}")" and
        output_string "${${(@P)list_name__glimgfif}[${index__glimgfif}]}"
}

# ....................{ GETTERS ~ index                    }....................
#FIXME: Rename to get_list_index_first_matching_glob() in light of nomenclature
#elsewhere (e.g., get_list_index_first_equaling()). Quite a bit more readable,
#in any case. Perform such renamings above and below, naturally.
declare_function_with_stdin <<'/---'
<globbable> integer get_list_index_matching_glob_first(
    string list_name, string glob)

Get the 1-based index of the first item in the passed list matching the passed
glob expression or throw an exception if no such item matches: e.g.,

.get_list_index_matching_glob_first()
==========================================
[source]
------------------------------------------
>>> list on_tumescence; on_tumescence=(
...     "I give my blood fifty parts polystyrene,"
...     "twenty-five parts benzene, twenty-five parts good old gasoline,"
...     "to the last bomber pilot aloft, that there shall be one acre"
...     "in the dull world where the kissing flower may bloom,"
...     "which kisses you so long your bones explode under its lips."
...     ""
...     "My tongue goes to the Secretary of the Dead"
...     "to tell the corpses, \"I'm sorry, fellows,"
...     "the killing was just one of those things"
...     "difficult to pre-visualize — like a cow,"
...     "say, getting blown up by lightning.\""
...     ""
...     "My stomach, which has digested"
...     "four hundred treaties giving the Indians"
...     "eternal right to their land, I give to the Indians,"
...     "I throw in my lungs full of tumors, from faithfully"
...     "smoking the peace pipe before every massacre."
...     ""
...     "My soul I leave to the bee"
...     "that he may sting it and die, my brain"
...     "to the fly, his back the hysterical green color of slime,"
...     "that he may suck on it and die, my flesh to the advertising man,"
...     "the anti-prostitute, who loathes human flesh for money." )
>>> get_list_index_matching_glob_first on_tumescence *'to the'[[:blank:]]*
3
------------------------------------------
==========================================
/---
function get_list_index_matching_glob_first() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one glob.'
    string index__glimgf

    # Get such match if found or throw an exception.
    if { index__glimgf="$(get_list_index_matching_glob_first_if_found "${@}")" } {
        return_string "${index__glimgf}"
    } else {
        string list_name__glimgf="${1}" glob__glimgf="${2}"
        die 'List ${'${list_name__glimgf}'} contains no item matching "'${glob__glimgf}'".'
    }
}

declare_function_with_stdin <<'/---'
<globbable> [stdout: integer, status: boolean]
    get_list_index_matching_glob_first_if_found(string list_name, string glob)

Get the 1-based index of the first item in the passed list matching the passed
glob expression or return failure if no such item matches: e.g.,

.get_list_index_matching_glob_first_if_found()
==========================================
[source]
------------------------------------------
>>> list on_madness; on_madness=(
...     "I assign my crooked backbone"
...     "to the dice maker, to chop up into dice,"
...     "for casting lots as to who shall see his own blood"
...     "on his shirt front and who his brother's,"
...     "for the race isn't to the swift but to the crooked."
...     ""
...     "To the last man surviving on earth"
...     "I give my eyelids worn out by fear, to wear"
...     "in his long nights of radiation and silence,"
...     "so that his eyes can't close, for regret"
...     "is like tears seeping through closed eyelids."
...     "
...     "I give the emptiness my hand: the pinkie picks no more noses,"
...     "slag clings to the black stick of the ring finger,"
...     "a bit of flame jets from the tip of the fuck-you finger,"
...     "the first finger accuses the heart, which has vanished,"
...     "on the thumb stump wisps of smoke ask a ride into the emptiness."
...     ""
...     "In the Twentieth Century of my nightmare"
...     "on earth, I swear on my chromium testicles"
...     "to this testament"
...     "and last will"
...     "of my iron will, my fear of love, my itch for money, and my madness." )
>>> get_list_index_matching_glob_first_if_found on_madness *'on_sanity'* or
...     output_string "Lieutanant! This corpse will not stop burning!"
Lieutanant! This corpse will not stop burning!
------------------------------------------
==========================================
/---
function get_list_index_matching_glob_first_if_found() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one glob.'
    string list_name__glimgfif="${1}" glob__glimgfif="${2}"
    integer list_index__glimgfif
    die_unless_list "${list_name__glimgfif}"

    # 1-based index of the first matching item. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'i', expanding to the index of the first item matching...
    # * "${~glob__glimgfif}", the passed glob as a glob rather than literal.
    list_index__glimgfif="${${(@P)list_name__glimgfif}[(i)${~glob__glimgfif}]}"

    # Get such index if found or return failure.
    (( list_index__glimgfif <= $(get_list_size "${list_name__glimgfif}") )) and
        output_string "${list_index__glimgfif}"
}

#FIXME: Add examples.
declare_function_with_stdin <<'/---'
<globbable> [stdout: integer, status: boolean]
    get_list_index_matching_glob_first_after_index_if_found(
        string list_name, string glob, integer start_index)

Get the 1-based index of the first item in the passed list matching the
passed glob _after_ the passed index or return failure if no such item matches.
/---
function get_list_index_matching_glob_first_after_index_if_found() {
    # Validate sanity.
    die_unless_args_3 'Expected one list name, one glob, and one start index.'
    string\
        list_name__glmifafif="${1}"\
        glob__glmifafif="${2}"\
        index_start__glmifafif="${3}"\
        list_size__glmifafif
    integer index__glmifafif
    list list_copy__glmifafify
    die_unless_list_index "${list_name__glmifafif}" "${index_start__glmifafif}"

    # Begin searching at the next such index. Since zsh supplies no builtin
    # means of finding from some index (subscript flag "(i)" always matches from
    # index 1), consider the following clever alternative:
    #
    # * Copy the *ENTIRE* subset of such list after such index into a new list.
    # * Search such list with subscript flag "(i)".
    # * Offset the matching index if found by the passed index.
    #
    # In the worst case, such copy duplicates such list. While unfortunate, this
    # is considerably faster (if memory intensive) than manual iteration.
    list_copy__glmifafif=(
        "${${(@P)list_name__glmifafif}[$(( index_start__glmifafif + 1 )),]}" )

    # Get such index if found or return failure.
    index__glmifafif="$(get_list_index_matching_glob_first_if_found\
        list_copy__glmifafif "${glob__glmifafif}")"  and
        return_string $(( index__glmifafif + index_start__glmifafif ))
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_matching_glob(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all items in the passed source list matching the
passed glob: e.g.,

.set_list_to_list_items_matching_glob()
==========================================
[source]
------------------------------------------
>>> list on_linearity on_cyclicity; on_cyclicity=(
...    "Catch! calls the Once-ler."
...    "He lets something fall."
...    "It's a Truffula Seed."
...    "It's the last one of all!"
...    "You're in charge of the last of the Truffula Seeds."
...    "And Truffula Trees are what everyone needs."
...    "Plant a new Truffula. Treat it with care."
...    "Give it clean water. And feed it fresh air."
...    "Grow a forest. Protect it from axes that hack."
...    "Then the Lorax"
...    "and all of his friends"
...    "may come back." )
>>> set_list_to_list_items_matching_glob on_linearity on_cyclicity *'last*'
>>> print_list on_linearity
1: It's the last one of all!
2: You're in charge of the last of the Truffula Seeds.
------------------------------------------
==========================================
/---
function set_list_to_list_items_matching_glob() {
    # Validate passed arguments.
    die_unless_args_3\
        'Expected one target list name, one source list name, and one glob.'
    string\
        list_name_target__sltlimg="${1}"\
        list_name_source__sltlimg="${2}"\
        glob__sltlimg="${3}"
    die_unless_lists "${list_name_target__sltlimg}" "${list_name_source__sltlimg}"

    # Remove non-matching items. Dismantled, this is:
    #
    # * "(M)" and ":#", removing all such source list items not matching...
    # * "${~glob__sltlimg}", such glob as a glob rather than literal.
    eval ${list_name_target__sltlimg}'=(
        "${(M)'${list_name_source__sltlimg}'[@]:#${~glob__sltlimg}}" )'
}

declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_not_matching_glob(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all items in the passed source list _not_ matching
the passed glob: e.g.,

.set_list_to_list_items_not_matching_glob()
==========================================
[source]
------------------------------------------
>>> list on_profit on_medicine; on_medicine=(
...    "When at last we are sure"
...    "You've been properly pilled,"
...    "Then a few paper forms"
...    "Must be properly filled"
...    "So that you and your heirs"
...    "May be properly billed." )
>>> set_list_to_list_items_not_matching_glob on_profit on_medicine *'o'*
>>> print_list on_profit
1: When at last we are sure
------------------------------------------
==========================================
/---
function set_list_to_list_items_not_matching_glob() {
    # Validate passed arguments.
    die_unless_args_3\
        'Expected one target list name, one source list name, and one glob.'
    string\
        list_name_target__sltling="${1}"\
        list_name_source__sltling="${2}"\
        glob__sltling="${3}"
    die_unless_lists "${list_name_target__sltling}" "${list_name_source__sltling}"

    # Remove non-matching items. Dismantled, this is:
    #
    # * ":#", removing all such source list items matching...
    # * "${~glob__sltling}", such glob as a glob rather than literal.
    eval ${list_name_target__sltling}'=(
        "${'${list_name_source__sltling}'[@]:#${~glob__sltling}}" )'
}

# ....................{ SETTERS ~ range                    }....................
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_after_item_matching_glob(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all items of the passed source list after and
including the first item matching the passed glob or throw an exception if no
such item matches.
/---
function set_list_to_list_items_after_item_matching_glob() {
    # Validate passed arguments.
    die_unless_args_3\
        'Expected one target list name, one source list name, and one glob.'
    string\
        list_name_target__sltleami="${1}"\
        list_name_source__sltleami="${2}"\
        glob__sltleami="${3}"
    integer index__sltleami
    die_unless_lists\
        "${list_name_target__sltleami}"\
        "${list_name_source__sltleami}"

    # Get the first matching index.
    index__sltleami="$(get_list_index_matching_glob_first\
        "${list_name_source__sltleami}" "${glob__sltleami}")"

    # Set such list.
    eval ${list_name_target}'=(
        "${'${list_name_source__sltleami}'[${index__sltleami},]}" )'
}

declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_between_items_matching_globs(
    string target_list_name,
    string source_list_name,
    string start_glob,
    string end_glob)

Set the passed target list to all items of the passed source list that:

* Follow the first item matching the first passed glob, including such item. If
  no such item matches, throw an exception.
* Precede the next item matching the second passed glob, including such item. If
  no such item matches, include all remaining items, thus mimicking
  set_list_to_list_items_after_item_matching_glob().
/---
function set_list_to_list_items_between_items_matching_globs() {
    # Validate passed arguments.
    die_unless_args_4\
        'Expected one target list name, one source list name, one start glob, and one end glob.'
    string\
        list_name_target__sltlebmi="${1}"\
        list_name_source__sltlebmi="${2}"\
        glob_start__sltlebmi="${3}"\
        glob_end__sltlebmi="${4}"
    integer index_start__sltlebmi index_next__sltlebmi
    die_unless_lists\
        "${list_name_target__sltlebmi}"\
        "${list_name_source__sltlebmi}"

    # Get the first matching index.
    index_start__sltlebmi="$(get_list_index_matching_glob_first\
        "${list_name_source__sltlebmi}" "${glob_start__sltlebmi}")"

    # Get the next matching index if found.
    if { index_end__sltlebmi="$(get_list_index_matching_glob_first_after_index_if_found\
        "${list_name_source__sltlebmi}"\
        "${glob_start__sltlebmi}"\
        "${index_start__sltlebmi}")" } {
    # Else, default to the last index.
    } else {
        index_end__sltlebmi="$(get_list_size "${list_name_source__sltlebmi}")"
    }

    # Set such list.
    eval ${list_name_target__sltlebmi}'=(
        "${'${list_name_source__sltlebmi}'[${index_start__sltlebmi},${index_end__sltlebmi}]}" )'
}

# ....................{ REMOVERS                           }....................
#FIXME: Add examples.
declare_function_with_stdin <<'/---'
<globbable> void remove_list_items_matching_glob(string list_name, string glob)

Remove all items matching the passed glob from the passed list: e.g.,

.remove_list_items_matching_glob()
==========================================
[source]
------------------------------------------
>>> list on_secrecy; on_secrecy=(
...    "I began to sense faintly that secrecy is the keystone of all tyranny."
...    "Not force, but secrecy... censorship. When any government, or any"
...    "church for that matter, undertakes to say to its subjects, \"This you"
...    "may not read, this you must not see, this you are forbidden to know,\""
...    "the end result is tyranny and oppression, no matter how holy the"
...    "motives. Mighty little force is needed to control a man whose mind has"
...    "been hoodwinked; contrariwise, no amount of force can control a free"
...    "man, a man whose mind is free. No, not the rack, not fission bombs, not"
...    "anything — you can't conquer a free man; the most you can do is kill"
...    "him." )
>>> remove_list_items_matching_glob on_secrecy *[aoeu]*
>>> print_list on_secrecy
1: him.
------------------------------------------
==========================================
/---
function remove_list_items_matching_glob() {
    die_unless_args_2 'Expected one list name and one glob.'
    set_list_to_list_items_not_matching_glob "${1}" "${1}" "${2}"
}

declare_function_with_stdin <<'/---'
<globbable> void remove_list_items_not_matching_glob(string list_name, string glob)

Remove all items _not_ matching the passed glob from the passed list (i.e.,
reduce such list to exactly the subset of items matching such glob).

.remove_list_items_not_matching_glob()
==========================================
[source]
------------------------------------------
>>> list on_morality; on_morality=(
...    "Stood in firelight, sweltering. Bloodstain on chest like map of violent"
...    "new continent. Felt cleansed. Felt dark planet turn under my feet and"
...    "knew what cats know that makes them scream like babies in night."
...    ""
...    "Looked at sky through smoke heavy with human fat and God was not there."
...    "The cold, suffocating dark goes on forever and we are alone. Live our"
...    "lives, lacking anything better to do. Devise reason later. Born from"
...    "oblivion; bear children, hell-bound as ourselves, go into oblivion."
...    "There is nothing else."
...    ""
...    "Existence is random. Has no pattern save what we imagine after staring"
...    "at it for too long. No meaning save what we choose to impose. This"
...    "rudderless world is not shaped by vague metaphysical forces. It is not"
...    "God who kills the children. Not fate that butchers them or destiny that"
...    "feeds them to the dogs. It’s us. Only us. Streets stank of fire. The"
...    "void breathed hard on my heart, turning its illusions to ice,"
...    "shattering them. Was reborn then, free to scrawl own design on this"
...    "morally blank world."
...    ""
...    "Was Rorschach." )
>>> remove_list_items_not_matching_glob on_morality *[Ww]'as'*
>>> print_list on_morality
01: Looked at sky through smoke heavy with human fat and God was not there.
02: shattering them. Was reborn then, free to scrawl own design on this
03: Was Rorschach.
------------------------------------------
==========================================
/---
function remove_list_items_not_matching_glob() {
    die_unless_args_2 'Expected one list name and one glob.'
    set_list_to_list_items_matching_glob "${1}" "${1}" "${2}"
}

# ....................{ REMOVERS ~ range                   }....................
#FIXME: Documentation should be restated in form resembling "Remove all items
#around the..."
declare_function_with_stdin <<'/---'
<globbable> void remove_list_items_around_items_matching_globs(
    string list_name, string start_glob, string end_glob)

Reduce the passed list to only the subset of items both:

* Following the first item matching the first passed glob, including such
  item. If no such item matches, throw an exception.
* Preceding the next item matching the second passed glob, including such
  item. If no such item matches, include all remaining items, thus
  mimicking set_list_to_list_items_after_item_matching_glob().
/---
function remove_list_nonmatches_before_and_after_inclusive() {
    die_unless_args_3\
        'Expected one list name, one start glob, and one end glob.'
    set_list_to_list_items_between_items_matching_globs\
        "${1}" "${1}" "${2}" "${3}"
}

# --------------------( WASTELANDS                         )--------------------
#>>> Political tags -- such as royalist, communist, democrat, populist, fascist, liberal, conservative, and so forth -- are never basic criteria. The human race divides politically into those who want people to be controlled and those who have no such desire. The former are idealists acting from highest motives for the greatest good of the greatest number. The latter are surly curmudgeons, suspicious and lacking in altruism. But they are more comfortable neighbors than the other sort. 

#   if { index__glimgfif="$(get_list_index_matching_glob_first_if_found "${@}")" } {
#       return_string "${${(@P)list_name__glimgfif}[${index__glimgfif}]}"
#   } else {
#       report_failure
#   }

#FUXME: Rename to
#set_list_to_list_items_between_items_matching_glob(). For simplicity, such
#function should behave inclusively in all cases. This will require a minor
#change here (...for the better, simplifying the implementation below) and
#wherever this function is called. If the caller requires exclusivity on either
#end, they'll simply have to call shift_list() and/or pop_list() -- quite
#doable, really. There's *NO* way to meaningfully embed such operations in this
#function's nomenclature; so, this is absolutely the way to go.

        # Since such match is exclusive, offset such index to the prior item.
#       (( --index_end__sltlebmi ))

#FUXME: Terrible name, really. Consider renaming to
#remove_list_items_before_match_and_after_match() or
#remove_list_items_around_items_matching_globs(). Yes,
#the latter I should think.
#Equivalently, remove all items from the passed list either:
#
#* Preceding the first item matching the first passed glob, excluding such
#  item. If no such item matches, throw an exception.
#* Following the next item matching the second passed glob, including such
#  item. If no such item matches, remove no such items, thus
#  mimicking remove_list_nonmatches_before().
#   string list_name__rlebmaafm="${1}"
#   shift_arg

    # Remove such non-matches.
#   set_list_to_list_items_between_items_matching_globs\
#       "${list_name__rlebmaafm}" "${list_name__rlebmaafm}" "${@}"

#FUXME: Rename to remove_list_items_not_matching_glob(). Trying to grok the current function
#name severely hurts my head. (A bad thing.)
# or die "list \"${list_name_source__sltleami}\" contains no item matching \"${glob__sltleami}\""
#FUXME: Rename to set_list_to_list_items_matching_glob_first_until_next(). Scratch that. How
#about set_list_to_list_items_after_match_until_match_inclusive() or simply
#set_list_to_list_items_between_items_matching_globs()? Right. The latter reads
#particularly well.
#FUXME: Drop the optional default value here and elsewhere. Unhelpful and
#obfuscatory.

    #FUXME: Call die_unless_list_index() instead.
    # Validate such index, permitting index 0 as well as normal 1-based indices.
#   __list_size__="$(get_list_size "${list_name}")"
#   (( __offset__ >= 0 && __offset__ < __list_size__ )) or
#       die "list \"${list_name}\" index ${__offset__} not in [0, ${__list_size__})"

    #FUXME: Shouldn't this defer to get_list_index_matching_glob_first_if_found()?
    # Return such index if found or throw an exception.
#   integer __index__
#   if { __index__="$(get_list_index_matching_glob_first_if_found "${@}")" } {
#       return_string "${__index__}"
#   } else {
#       string list_name="${1}" __glob__="${2}"
#       die "no item of list \"${list_name}\" matching \"${__glob__}\""
#   }

#FUXME: Once we validate this works as expected, implement the converse
#get_last_list_item_matching() function by using flag "(R)" where we
#currently use flag "(r)".

    #FUXME: Shouldn't this defer to get_list_item_matching_glob_first_if_found()?
    # Return such item if found or throw an exception. Avoid subscript flag
    # "(r)", which expands to the empty string if no such item matches. Such
    # expansion is indistinguishable from a successful match, if the first such
    # match is the empty string (e.g., with glob "*").
#   integer __index__
#   if { __index__="$(get_list_index_matching_glob_first_if_found "${@}")" }
#       return_string "${${(@P)list_name}[${__index__}]}"
#   } else {
#       string list_name="${1}" __glob__="${2}"
#       die "no item of list \"${list_name}\" matching \"${__glob__}\""
#   }

#   string text="${1}" glob_first="${2}" glob_next
#   glob_next="${4-${glob_first}}"
# void remove_list_nonmatches_before_match_first_or_match_next_and_after(
# after and
# including the first item matching the first passed glob until but
# excluding the next item matching the second passed glob. If no item
# matches the first passed glob, throw an exception. However, if no item
# matches the second passed glob, simply include all remaining items, thus
# mimicking set_list_to_list_items_after_item_matching_glob().
    #FUXME: It might actually be more efficient to copy the entire subset of the
    #passed list following such index into a new temporary list for searching,
    #as "(i)" *WOULD* work on such temporary. Actually, yes... this is most
    #certainly more efficient.
#   for (( ++__index__; __index__ <= __list_size__; ++__index__ )) {
#       is_string_matches_glob\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    #FUXME: Not right. An empty item could in fact match a non-empty glob
    #(e.g., "*"), in which case testing emptiness does not suffice. Instead,
    #call get_list_index_matching_glob_first() and note this subtlety.
    # Get the first match. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'r', expanding to the first item matching...
    # * "${~glob}", the passed glob as a glob rather than raw string.
#   __item__="${${(@P)list_name}[(r)${~__glob__}]}"

    # Throw an exception if no item matches.
#   die_if_string_empty "${__item__}"\
#       "no item of list \"${list_name}\" matches \"${__glob__}\""

    # Otherwise, return such item.
#   print_string "${__item__}"
    # Find the first match.
#   integer __index__ __list_size__
#   __list_size__="$(get_list_size "${list_name}")"
#   for (( __index__ = 0; __index__ < __list_size__; ++__index__ )) {
#       is_string_matches_glob\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    # Throw an exception if no item matches.
#   (( __index__ < __list_size__ )) or
#       die "no item of list \"${list_name}\" matches \"${__glob__}\""

# void set_list_to_list_excluding_items_preceding_match(
# void set_list_to_list_excluding_matches(
# void set_list_to_list_including_only_matches(
#FUXME: Order of function arguments is, arguably, somewhat ad hoc. Switch the
#source_list_name and glob arguments, perhaps?
# void remove_list_items_matching(
#   string source_list_name, string glob,
#   string target_list_name = "${source_list_name}")
#
# Copy all items of the passed source list *NOT* matching the passed glob
# into the passed target list (defaulting to the passed source list). If passed
# only two arguments, remove all matching source list items "in-place." This
# function implements the inverse of retain_list_items_matching().
#function set_list_to_list_without_items_matching() {
#function remove_list_items_matching() {
#   if is_args_2; then
#       list_name_source="${list_name_target}"
#       __glob__="${2}"
#   else
#       list_name_source="${2}"
#       __glob__="${3}"
#   fi
