#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle the first path matching glob qualifiers.
-/-

#FIXME: Nonsense. Shift the core getters to @{qualifier} and all remaining
#getters to the corresponding parcels.

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_path_matching_qualifier_first().
#FIXME: Alter function signature to:
#
#string get_path_matching_qualifier_first(
#    string pathname1, string pathname2, ...,
#    string glob_qualifier)
#
#Clearly, I didn't quite grok filename generation when I first concocted this
#function. The above approach is quite a bit more sensible. Just drop the
#trailing exception message-specific labels altogether. *WAY* overkill. (If you
#really want super-hyper-turbo human-readable exceptions, call
#get_path_matching_qualifier_first_if_found() instead and perform an
#explicit die() -- which incidentally produces much cleaner code.) Call it like
#so:
#
#>>> get_path_matching_glob_qualifier_first "imprimi_potest/"* 'w/'
#
#The resulting exception message (if no path matches) should simply resemble:
#
#    no path matches glob "'imprimi_potest/'*(#q'w/')"
#FIXME: Actually, just eliminate this. No one benefits from unreadable exceptions.

declare_function_with_stdin <<'/---'
string get_path_matching_glob_qualifier_first(
    string pathname1, string pathname2, ...,
    string glob_qualifiers,
    string label_if_singular, string label_if_plural)

Get the first passed path matching the passed glob qualifier or throw an
exception if no such path matches such qualifier, in which case embed the passed
human-readable singular or plural label into the resulting exception message
(depending on whether one or more than one paths were passed): e.g.,

.get_path_matching_glob_qualifier_first()
==========================================
[source]
------------------------------------------
# Get the first owner-writable subdirectory of a newly created directory.
>>> make_dir "imprimi_potest/{imprimatur,censorship}"
>>> get_path_matching_glob_qualifier_first "imprimi_potest/"* "w/"\
...     "an owner-writable directory" "owner-writable directories"
imprimatur
------------------------------------------
==========================================
/---
function get_path_matching_glob_qualifier_first() {
    # Validate passed arguments.
    die_unless_args_4_or_more\
        'expected at least one pathname, one glob, one singular label, and one plural label'
    string\
        label_if_singular="${@[-2]}" label_if_plural="${@[-1]}" pathname
    pop_args 2

    # If at least one argument matches such glob qualifiers, return the first.
    if { pathname="$(get_path_matching_qualifier_first_if_found "${@}")" } {
        return_string "${pathname}"
    # Else, throw an exception.
    } else {
        # For list indexing convenience, pop off the passed glob.
        pop_arg

        #FIXME: Whatever gettext() interface we support will certainly include
        #support for plurality. See @{io/locale} for further discussion.

        # Throw a differing error message depending on argument plurality.
        if { is_arg } {
            die "\"${1}\" not found or not ${label_if_singular}"
        } else {
            die "$(join_strings_for_message "${@}") not found or not ${label_if_plural}"
        }
    }
}

#FIXME: Fix examples.
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_path_matching_qualifier_first_if_found(
    string pathname1, string pathname2, ...,
    string glob_qualifier)

Get the first passed path that exists matching the passed glob qualifier or
return failure if no such path exists.

== Exception Handling ==

There exists no corresponding get_path_matching_glob_qualifier_first(). While
implementing such function is certainly feasible, any exceptions thrown by such
implementation would be unlikely to be human-readable (e.g.,
`no path matches glob "'imprimi_potest/'*(#q'w/')"`). Instead, simply call this
function and throw an exception if such call fails: e.g.,

.get_path_matching_qualifier_first_if_found() Exception Handling
==========================================
[source]
------------------------------------------
# Get the first owner-writable subdirectory of a newly created directory.
>>> make_dir "imprimi_potest/{imprimatur,censorship}"
>>> get_path_matching_qualifier_first_if_found "imprimi_potest/"* "w/" or die\
...     "an owner-writable directory" "owner-writable directories"
imprimatur
------------------------------------------
==========================================
/---
function get_path_matching_qualifier_first_if_found() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one or more pathnames and one glob qualifier'
    list pathnames

    # If at least one pathname exists matching such qualifier, get the first.
    set_list_to_paths_matching_qualifier pathnames "${@}"
    if { is_list_nonempty pathnames } {
        return_string  "${pathnames[1]}"
    # Else, fail.
    } else {
        return_false
    }
}

# ....................{ GETTERS ~ file                     }....................
declare_function_with_stdin <<'/---'
string get_file_first(string filename1, string filename2, ...)

Get the first passed extant file after deeply resolving symbolic links or throw
an exception if no such file exists.
/---
function get_file_first() {
    die_unless_args 'expected one or more filenames'
    get_path_matching_glob_qualifier_first "${@}" '-.' 'a file' 'files'
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_file_first_if_found(
    string filename1, string filename2, ...)

Get the first passed file that exists after resolving symbolic links or return
failure if no such file exists.
/---
function get_file_first_if_found() {
    die_unless_args 'expected one or more filenames'
    get_path_matching_qualifier_first_if_found "${@}" '-.'
}

# ....................{ GETTERS ~ dir                      }....................
declare_function_with_stdin <<'/---'
string get_dir_first(string dirname1, string dirname2, ...)

Get the first passed directory that exists after resolving symbolic links or
throw an exception if no such directory exists.
/---
function get_dir_first() {
    die_unless_args 'expected one or more dirnames'
    get_path_matching_glob_qualifier_first "${@}" '-/' 'a directory' 'directories'
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_dir_first_if_found(
    string dirname1, string dirname2, ...)

Get the first passed directory that exists after resolving symbolic links or
return failure if no such directory exists.
/---
function get_dir_first_if_found() {
    die_unless_args 'expected one or more dirnames'
    get_path_matching_qualifier_first_if_found "${@}" '-/'
}

# ....................{ GETTERS ~ dir : writable           }....................
declare_function_with_stdin <<'/---'
string get_dir_writable_first(string dirname1, string dirname2, ...)

Get the first passed directory writable by the current user after resolving
symbolic links or throw an exception if no such directory exists.
/---
function get_dir_writable_first() {
    die_unless_args 'expected one or more dirnames'
    get_dir_writable_first "${@}" or die\
        "$(join_strings_for_message "${@}") not found or not writable directories"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_dir_writable_first_if_found(
    string dirname1, string dirname2, ...)

Get the first passed directory writable by the current user after resolving
symbolic links or return failure if no such directory exists.
/---
function get_dir_writable_first_if_found() {
    die_unless_args 'expected one or more dirnames'
    get_path_matching_qualifier_first_if_found\
        "${@}" '-e{[[ -d $REPLY && -w $REPLY ]]}'
}

# --------------------( WASTELANDS                         )--------------------
#   get_path_matching_glob_qualifier_first\
#       "${@}" '-e{[[ -d $REPLY && -w $REPLY ]]}'\
#       'a writable directory' 'writable directories'

    # Get the first such pathname.

    # Convert such qualifier to a proper qualifier, if not already.
#   glob_qualifier="$(convert_strings_to_glob_qualifiers "${glob_qualifier}")"

    # If at least one path matches, return the first; else, fail.
#   pathname_match=( "${^@}"${~glob_qualifier} ) or ignore_exit_status
#   if { is_list_nonempty pathname_match } {
#       return_string "${pathname_match[1]}"
#   } else {
#       return_false
#   }

#FUXME: Generalize to accept any glob as under is_path_globbed_matches_qualifier(). This
#requires wrapping current arguments in "()". Just call
#convert_string_to_glob_qualifier(), in other words.

#    string glob,
#    string glob_qualifier1, string glob_qualifier2, ...)

#FUXME: Rename to get_path_matching_glob_qualifier_first(). Honestly, this is a
#bit heavyweight. Contemplate usage elsewhere.
#FUXME: We arguably want a new "glob" directory and a new "first" component in
#such directory containing such functionality. It's a bit much for just a core
#"glob" component.
