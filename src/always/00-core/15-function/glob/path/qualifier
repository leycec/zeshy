#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *glob qualifiers* (i.e., `(#q`- and `)`-delimited expressions suffixing
path-specific globs).

== See Also ==

* Section ``Glob Qualifiers'' of `man zshexpn`, documenting such qualifiers.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_path_globbed_matches_qualifier(
    string glob,
    string glob_qualifier1, string glob_qualifier2, ...)

Return success if at least one existing path matches the passed glob _and_ all
passed glob qualifiers. See set_list_to_paths_globbed_matching_qualifier() for
further details: e.g.,

.is_path_globbed_matches_qualifier()
==========================================
[source]
------------------------------------------
>>> string on_mondays=\
...    "Both Plato and Xenophon attribute to Socrates and obviously share with
...     him an awareness of the destructive effects of work on the worker as a
...     citizen and a human being. Herodotus identified contempt for work as an
...     attribute of the classical Greeks at the zenith of their culture. To
...     take only one Roman example, Cicero said that \"whoever gives his labor
...     for money sells himself and puts himself in the rank of slaves.\" His
...     candor is now rare, but contemporary primitive societies which we are
...     wont to look down upon have provided spokesmen who have enlightened
...     Western anthropologists. The Kapauku of West Irian, according to
...     Posposil, have a conception of balance in life and accordingly work only
...     every other day, the day of rest designed \"to regain the lost power and
...     health.\" Our ancestors, even as late as the eighteenth century when
...     they were far along the path to our present predicament, at least were
...     aware of what we have forgotten, the underside of industrialization.
...     Their religious devotion to \"St. Monday\" – thus establishing a de
...     facto five-day week 150-200 years before its legal consecration – was
...     the despair of the earliest factory owners. They took a long time in
...     submitting to the tyranny of the bell, predecessor of the time clock. In
...     fact it was necessary for a generation or two to replace adult males
...     with women accustomed to obedience and children who could be molded to
...     fit industrial needs. Even the exploited peasants of the ancient regime
...     wrested substantial time back from their landlord's work. According to
...     Lafargue, a fourth of the French peasants' calendar was devoted to
...     Sundays and holidays, and Chayanov's figures from villages in Czarist
...     Russia – hardly a progressive society – likewise show a fourth or fifth
...     of peasants' days devoted to repose. Controlling for productivity, we
...     are obviously far behind these backward societies. The exploited muzhiks
...     would wonder why any of us are working at all. So should we."
>>> make_dir on_diversity
>>> is_path_globbed_matches_qualifier ?n_d?v?rs?t? '/^F' 'u'"$(get_user)" and
...     get_string_line "${on_mondays}" -1
would wonder why any of us are working at all. So should we.
------------------------------------------
==========================================
/---
function is_path_globbed_matches_qualifier() {
    # Validate passed arguments.
    die_unless_args_2_or_more 'expected one glob and one glob qualifier'
    string glob="${1}"
    list pathnames
    shift_arg

    # Delimit such qualifiers, if not already.
    glob+="$(convert_strings_to_glob_qualifiers "${@}")"

    # Perform such match.
    set_list_to_paths_globbed pathnames "${glob}"

    # If at least one existing path matched, return success.
    is_list_nonempty pathnames
}

# ....................{ SETTERS                            }....................
#FIXME: Document!
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_paths_matching_qualifier(
    string list_name,
    string pathname1, string pathname2, ...,
    string glob_qualifier)

Set the passed list to the subset of passed paths that exist matching the passed
glob qualifier. As under set_list_to_paths_globbed_matching_qualifier(), such
glob qualifier may be either parenthesized (e.g., `(.-)`) or not (e.g., `.-`):
e.g.,

.set_list_to_paths_matching_qualifier()
==========================================
[source]
------------------------------------------
>>> list terminal_devices
>>> set_list_to_paths_matching_qualifier terminal_devices /dev/tty<->## %
>>> print_string "${terminal_devices[1,3]}"
/dev/tty0 /dev/tty1 /dev/tty2
------------------------------------------
==========================================
/---
function set_list_to_paths_matching_qualifier() {
    # Validate passed arguments.
    die_unless_args_3_or_more\
        'expected one list name, one or more pathnames, and one glob qualifier'
    string list_name__sltpmq="${1}" qualifier__sltpmq="${@[-1]}"
    list pathnames__sltpmq
    die_unless_list "${list_name__sltpmq}"
    shift_args
    pop_args

    # List of pathnames to be matched.
    pathnames__sltpmq=( "${@}" )

    # Delimit such qualifier, if not already.
    qualifier__sltpmq="$(convert_strings_to_glob_qualifiers\
        "${qualifier__sltpmq}")"

    # Perform such match.
    set_list_to_evaluation ${list_name__sltpgmq}\
        '"${^pathnames__sltpmq}"${~qualifier__sltpmq}'
}

declare_function_with_stdin <<'/---'
<globbable> void set_list_to_paths_globbed_matching_qualifier(
    string list_name,
    string glob,
    string glob_qualifier, string glob_qualifier2, ...)

Set the passed list to all existing paths matching the passed glob _and_ all
passed glob qualifiers: e.g.,

.set_list_to_paths_globbed_matching_qualifier()
==========================================
[source]
------------------------------------------
>>> list pseudo_files
>>> set_list_to_paths_globbed_matching_qualifier pseudo_files /proc/[a-z]## -.L0
>>> print_string "${pseudo_files[1,3]}"
/proc/buddyinfo /proc/cgroups /proc/cmdline
------------------------------------------
==========================================

== Qualifier Syntax ==

For convenience, glob qualifiers may be formatted as any of the following:

* Undelimited strings (e.g., `^-U`, matching files _not_ owned by the current
  effective user after resolving symbolic links).
* `(`- and `)`-delimited strings (e.g., `(^-U)`).
* `(#q`- and `)`-delimited strings (e.g., `(#q^-U)`).
/---
function set_list_to_paths_globbed_matching_qualifier() {
    # Validate passed arguments.
    die_unless_args_3_or_more\
        'expected one list name, one glob, and one or more glob qualifiers'
    string list_name__sltpgmq="${1}" glob__sltpgmq="${2}"
    die_unless_list "${list_name__sltpgmq}"
    shift_args 2

    # Delimit such qualifiers, if not already.
    glob__sltpgmq+="$(convert_strings_to_glob_qualifiers "${@}")"

    # Perform such match.
    set_list_to_evaluation ${list_name__sltpgmq} '${~glob__sltpgmq}'
}

# ....................{ CONVERTERS                         }....................
#FIXME: Rename to convert_string_to_glob_qualifier().
declare_function_with_stdin <<'/---'
string convert_strings_to_glob_qualifiers(string text1, string text2, ...)

Convert each passed string to a *glob qualifier* delimited by `(#q` and `)`, if
not already, and return the concatenated results: e.g.,

.convert_strings_to_glob_qualifiers()
==========================================
[source]
------------------------------------------
>>> convert_strings_to_glob_qualifiers '-.' 'a+40000'
(#q-.)(#qa+40000)
------------------------------------------
==========================================
/---
function convert_strings_to_glob_qualifiers() {
    # Validate passed arguments.
    die_unless_args 'expected one or more string'

    # If only passed one such qualifier and such qualifier is not already
    # delimited by either `(` and `)` *OR* `(#q` and `)`, delimit such qualifier
    # by the latter. This logic differs slightly from that when passed more than
    # one such qualifier, since in the latter case `(` and `)` qualifiers
    # constitute invalid syntax and hence must be replaced.
    #
    # For efficiency, inline such test both here and below.
    if { is_arg and is "${glob_qualifier}" != '('(|'#q')*')' si } {
        return_string "(#q${glob_qualifier})"
    } else {
    # Else, more than one such qualifier was passed. For each such qualifier not
    # already delimited by `(#q` and `)`, do so. If such qualifier is unsafely
    # already delimited by `(` and `)`, convert the `(` to `(#q`. The reason is
    # subtle: qualifier syntax permits `(` prefixes only if there exists one such
    # qualifier; in all other cases, `(#q` prefixes are required instead.
        string glob_qualifier glob_qualifiers
        for    glob_qualifier ("${@}") {
            if is "${glob_qualifier}" != '(#q'*')' si {
                glob_qualifiers+="(#q${${glob_qualifier#(}%)})"
            } else {
                glob_qualifiers+="${glob_qualifier}"
            }
        }
        return_string "${glob_qualifiers}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#   pathname_match=( "${^@}"${~qualifier__sltpmq} ) or ignore_exit_status
#   set_list_to_paths_globbed ${list_name__sltpgmq} "${glob__sltpgmq}"

#, matching the same
    # Set such list. Since such setting tends to return spurious non-zero exit
    # status (e.g., if any globbed path is not readable by the current user),
    # ignore the resulting status.
#   eval ${list_name__sltpmq}'=( ${~glob__sltpmq} )' or ignore_exit_status

#, ignoring non-fatal errors induced by such match. See
    # set_list_to_paths_globbed_matching_qualifier() for further details
#There are many kinds of gods. Therefore there are many kinds of men.

#   die_unless_path "${pathname}"

#Return success if at least one path matches all passed glob qualifiers, each of
#which may be either parens-delimited (e.g., `(^-U)`) or not (e.g., `^-U`): e.g.,

#FUXME: Create a new is_path_globbed_matches_qualifier() accepting a glob as well.

    # Return such qualifier.
#   output_string "${glob_qualifier}"
#FUXME: Rename to convert_strings_to_glob_qualifiers().

    # If such path exists, match such qualifier. Since no glob qualifier ever
    # matches a nonextant path, ignore nonextant paths.
#   is_path "${pathname}" and {

#. See section "Glob Qualifiers" in "man zshexpn" for further details
#       "${list_name__sltpmq}" '${~glob__sltpmq}${~glob_qualifier__sltpmq}'
#   die_unless_path "${pathname}"
        # If such qualifiers are not already parens-delimited, do so.
#       is_string_matches_glob "${glob_qualifier}" '\((|\#q)*\)' or
#           glob_qualifier="(#q${glob_qualifier})"

        #FUXME: Hmm; does non-zero exit status actually indicate a match failure in
        #all possible cases? Negligibly minor optimization, but somewhat
        #intellectually intriguing.

#, expanded immediately after expanding such path and hence equivalent to "${pathname}"${~glob}
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
#FUXME: We should probably rename all functions matching is_*_match() to
#is_*_matching_*() (e.g., from is_string_matches_glob() to is_string_matchesing(), from
#is_string_matches_pcre_multiline() to is_string_matchesing_pcre_line()). Extending this
#to get_*_match() functions seems somewhat absurd, however: e.g., from
#get_string_pcre_multiline_match_index_all() to get_string_matches_pcre_line() is terrible
#and doesn't even make sense.
# boolean is_path_globbed_matches_qualifiering_glob_qualifier(
#function is_path_globbed_matches_qualifiering_glob_qualifier() {

#
        #Interestingly, this also allows us to obsolete the need to explicitly
        #pass in human-readable labels. Indeed, I now believe we should entirely
        #excise the passed ${match_type_singular} and ${match_type_plural}
        #arguments in favor of an internal lookup table from 
