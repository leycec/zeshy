#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle variable types.
/---

# ....................{ GLOBALS                            }....................
declare_global_with_stdin\
    string ZESHY_VARIABLE_TYPE_GLOB_FLOAT='float*' <<'/---'
Glob matching type strings for float variables.
/---

declare_global_with_stdin\
    string ZESHY_VARIABLE_TYPE_GLOB_INTEGER='integer*' <<'/---'
Glob matching type strings of integer variables.
/---

declare_global_with_stdin\
    string ZESHY_VARIABLE_TYPE_GLOB_LIST='(array|list)*' <<'/---'
Glob matching type strings of list variables.
/---

declare_global_with_stdin\
    string ZESHY_VARIABLE_TYPE_GLOB_MAP='association*' <<'/---'
Glob matching type strings of map variables.
/---

declare_global_with_stdin\
    string ZESHY_VARIABLE_TYPE_GLOB_STRING='scalar*' <<'/---'
Glob matching type strings of string variables.
/---

# ....................{ GLOBALS ~ zeshy                    }....................
# Globs matching zeshy-specific types depending on the prior canonical types.

declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_BOOLEAN="${ZESHY_VARIABLE_TYPE_GLOB_INTEGER}" <<'/---'
Glob matching type strings of boolean variables.
/---

declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_CHARACTER="${ZESHY_VARIABLE_TYPE_GLOB_STRING}" <<'/---'
Glob matching type strings of character variables.
/---

# ....................{ GLOBALS ~ plural                   }....................
# Globs matching two or more of the prior canonical types.

declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_NUMBER='(float|integer)*' <<'/---'
Glob matching type strings of *numeric variables* (i.e., floats and integers).
/---

declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_SCALAR='(float|integer|scalar)*' <<'/---'
Glob matching type strings of *scalar variables* (i.e., floats, integers, and
strings).
/---

declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_NONSCALAR='(array|association|list)*' <<'/---'
Glob matching type strings of *nonscalar variables* (i.e., lists and maps).
/---

# ....................{ GLOBALS ~ scope                    }....................
declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_LOCAL='*-local' <<'/---'
Glob matching type strings of local variables.
/---

# Sadly, type strings of local but *NOT* global variables are explicitly
# suffixed by a suffix specific to such variables. Thus, type strings of the
# latter are matchable only by matching type strings either:
#
# * *NOT* containing delimiter "-" (and hence implicitly global).
# * Containing delimiter "-" suffixed by an suffix other than "local" (and
#   hence implicitly global).
#
# While extended globs lack support for the generalized negative lookahead and
# lookbehind assertions now supported by most PCRE implementations, they *DO*
# support negative character classes. Since no type suffix other than "-local"
# starts with "l", negating such letter suffices to match the desired strings.
declare_global_with_stdin string\
    ZESHY_VARIABLE_TYPE_GLOB_GLOBAL='([^-]##|*-[^l]*)' <<'/---'
Glob matching type strings of global variables.
/---

# ....................{ EXCEPTIONS                         }....................
() {
    # Human-readable singular and plural variants of such variable type,
    # prefixed with appropriate articles (e.g., "an integer", "a string").
    string variable_type_singular variable_type_plural

    # String list of function names to be declared.
    string\
        function_names_die_unless_singular\
        function_names_die_unless_plural\
        function_names_test_singular

    # Name of the string global matching such variable's type.
    string string_name_type_glob

    # Code snippet used to programmatically construct function definitions.
    string is_variable_type_matches

    # For each zeshy-specific variable type, declare exception handler and
    # tester functions specific to such type.
    string variable_type
    for    variable_type (
        # zsh types.
        float integer list map string

        # zsh type aggregators.
        number scalar nonscalar

        # zeshy types.
        boolean character
    ) {
        # If the first letter of such type is a vowel, prefix such type by "an".
        # with "an".
        if is "${variable_type[1]}" == [aeiou] si {
            variable_type_singular="an ${variable_type}"
        # Else, the first letter of such type is a consonant. Prefix such type
        # by "a".
        } else {
            variable_type_singular="a ${variable_type}"
        }

        # Pluralize such type, suffixing such type by "s".
        variable_type_plural="${variable_type}s"

        # If such type is nonscalar, declare two such functions. The former
        # complies with scalar nomenclature; the latter complies with
        # nomenclature specific to such type (e.g., set_list_to_list()).
        if is "${variable_type}" == (list|map) si {
            function_names_die_unless_singular="die_unless_variable_${variable_type} die_unless_${variable_type}"
            function_names_die_unless_plural="die_unless_variables_${variable_type} die_unless_${variable_type_plural}"
        # Else, such type is scalar. Declare a single function.
        } else {
            function_names_die_unless_singular="die_unless_variable_${variable_type}"
            function_names_die_unless_plural="die_unless_variables_${variable_type}"
        }

        # Since is_variable_list() and is_variable_map() imply different
        # function semantics from is_list() and is_map() (simply by virtue of
        # function name), define only the former here. See below for the latter.
        function_names_test_singular="is_variable_${variable_type}"

        # Declare documentation for such function(s). For simplicity, avoid
        # passing documentation as standard input.
        declare_function 'void {'${function_names_die_unless_singular}'}(
    string variable_name,
    string error_message = "\$\{${variable_name}\} not '${variable_type_singular}'.")

Throw an exception with the passed message unless the passed variable exists and
is '${variable_type_singular}'."'
        declare_function 'void {'${function_names_die_unless_plural}'}(
    string variable_name1, string variable_name2, ...)

Throw an exception with a stock message unless all passed variables exist and
are '${variable_type_plural}'."'
        declare_function '
[status: boolean] {'${function_names_test_singular}'}(string variable_name)

Return success if the passed variable is '${variable_type_singular}'. If such
variable does not exist, throw an exception."'

        # Get the name of the string global matching such variable's type.
        string_name_type_glob="ZESHY_VARIABLE_TYPE_GLOB_${(U)variable_type}"

        # If such global does *NOT* exist, throw an exception. See is_variable()
        # for further details.
        is -n "${(P)string_name_type_glob+x}" si or
            die '${'${string_name_type_glob}'} undefined.'

        # Code snippet returning success if the variable with name
        # ${variable_name__vt} exists and is of the desired type. If such variable
        # does not exist, throw an exception. For efficiency, inline such
        # implementation. See is_variable() for further details.
        is_variable_type_matches='
    is -n "${(P)variable_name__vt+x}" si or
        die "'${(C)variable_type}' \${${variable_name__vt}} undefined."
    is "${(tP)variable_name__vt}" == '${(P)string_name_type_glob}' si'

        # Declare such function(s). For efficiency, such functions inline their
        # implementations rather than call is_variable_type_matches_glob() -- an
        # overly heavyweight tester for functions called as commonly as these.
        eval 'function '${function_names_die_unless_singular}'() {
    die_unless_args_1_to_2\
        "Expected one variable name and optional error message."
    string variable_name__vt="${1}"

    '${is_variable_type_matches}' or
        die "${2:-\${${variable_name__vt}} not '${variable_type_singular}':${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__vt}")}"
}'
        eval 'function '${function_names_die_unless_plural}'() {
    die_unless_args "Expected at least one variable name."

    string variable_name__vt
    for    variable_name__vt ("${@}") {
        '${is_variable_type_matches}' or
            die "\${${variable_name__vt}} not '${variable_type_plural}':${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__vt}")"
    }
}'
        eval 'function '${function_names_test_singular}'() {
    die_unless_arg "Expected one variable name."
    string variable_name__vt="${1}"
    '${is_variable_type_matches}'
}'
    }
}

# ....................{ TESTERS                            }....................
# See above for is_variable_list() and is_variable_map(), which share semantics
# closer to those of the exception handlers defined above.

declare_function_with_stdin <<'/---'
[status: boolean] is_list(string variable_name)

Return success if the passed variable both exists and is a list. Unlike
is_variable_list(), do _not_ throw an exception if such variable does not exist.
/---
function is_list() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    string variable_name__il="${1}"

    # Test such variable. For efficiency, inline such implementation. See
    # is_variable() for further details.
    is -n "${(P)variable_name__il+x}" and
         "${(tP)variable_name__il}" == ${~ZESHY_VARIABLE_TYPE_GLOB_LIST} si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_map(string variable_name)

Return success if the passed variable both exists and is a map. Unlike
is_variable_map(), do _not_ throw an exception if such variable does not exist.
/---
function is_map() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    string variable_name__im="${1}"

    # Test such variable. For efficiency, inline such implementation. See
    # is_variable() for further details.
    is -n "${(P)variable_name__im+x}" and
         "${(tP)variable_name__im}" == ${~ZESHY_VARIABLE_TYPE_GLOB_MAP} si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_variable_type(string variable_name)

Get the `zsh`-specific lowercase type of the passed variable. If such variable
is:

* A float, `float` prefixes such type.
* An integer, `integer` prefixes such type.
* A map, `association` prefixes such type.
* A string, `scalar` prefixes such type.
* A user- or `zeshy`-defined list, `list` prefixes such type.
* A canonical `zsh` list variables (e.g., ${match}, ${path}), `array` prefixes
  such type.

If such variable was declared with scope:

* Local, `-local` suffixes such type.
* Exported, `-exported` suffixes such type.

For example:

.get_variable_type()
==========================================
[source]
------------------------------------------
>>> list on_employment; on_employment=(
...     "Most men would feel insulted if it were proposed to employ them in"
...     "throwing stones over a wall, and then in throwing them back, merely"
...     "that they might earn their wages. But many are no more worthily"
...     "employed now." )
>>> get_variable_type on_employment
array-local
------------------------------------------
==========================================
/---
function get_variable_type() {
    # Validate passed arguments.
    die_unless_arg 'expected one variable name'
    string variable_name__gvt="${1}"
    die_unless_variable "${variable_name__gvt}"

    # Get such type. Dismantled, this is:
    #
    # * "P", expanding to the variable with the passed name.
    # * "t", expanding such variable's type.
    return_string "${(tP)variable_name__gvt}"
}

# --------------------( WASTELANDS                         )--------------------
# The following aggregate types match two or more of the above.
        # If debugging zeshy, guarantee the existence of the string global
        # matching such variable's type by throwing an exception if such global
        # does not exist. Since such global *ALWAYS* exists under normal
        # conditions, this is purely a debug sanity check.
#       if (( ZESHY_IS_DEBUG )) {
#           is_variable_type_matches='
#   (( ${+'${string_name_type_glob}'} )) or
#       die "global \${'${string_name_type_glob}'} undefined"'
        # Else, initialize such logic to the empty string.
#       } else {
#           is_variable_type_matches=''
#       }

#   is -n "${(P)variable_name__vt+x}" si or
#* `association` for map variables.
#* `array` and `array-special` for `zsh`-specific canonical list variables (e.g.,
#  ${match}, ${path}).
#* `float` for float variables.
#* `integer` for integer variables.
#* `list` for list variables.
#* `scalar` for string variables.

#           function_names_test_singular="is_variable_${variable_type} is_${variable_type}"
    #FUXME: Might as well declare "is_variable_${variable_type}" functions as
    #well, yes? When we do so, we'd might as well inline the calls to
    #is_variable_type_matches_glob(). Indeed, at that point, we'd might as well
    #eliminate such function altogether. It's rather heavyweight, pointlessly.

#FUXME: Extract the globs repeated below (e.g., ('list'|'array')* into globals,
#reducing repetition and explanation elsewhere.

    # Documentation-specific string list of function names to be declared.
#   string\
#       function_names_die_singular_help\
#       function_names_die_plural_help\
#       function_names_test_singular_help

# ....................{ TESTERS                            }....................
#declare_function_with_stdin <<'/---'
#<globbable> [status: boolean] is_variable_type_matches_glob(
#    string variable_name, string glob)
#
#Return success if the type of the passed variable matches the passed glob: e.g.,
#
#.is_variable_type_matches_glob()
#==========================================
#[source]
#------------------------------------------
#>>> map on_industry=(
#...     "If"    "a man walk in the woods for love of them half of each day,"
#...     "he"    "is in danger of being regarded as a loafer; but if he spends"
#...     "his"   "whole day as a speculator, shearing off those woods and making"
#...     "Earth" "bald before her time, he is esteemed an industrious"
#...     "and"   "enterprising citizen. As if a town had no interest in
#...     "its"   "forests but to cut them down!" )
#>>> is_variable_type_matches_glob on_industry "map*" and
#...     print_string "You must get your living by loving."
#You must get your living by loving.
#------------------------------------------
#==========================================
#/---
#function is_variable_type_matches_glob() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one variable name and one glob'
#    string variable_name__ivtm="${1}" glob__ivtm="${2}"
#    die_unless_variable "${variable_name__ivtm}"
#
#    # If such variable exists, match its type against the passed glob.
#    is_string_matches_glob\
#        "$(get_variable_type "${variable_name__ivtm}")"\
#        "${glob__ivtm}"
#}
#
## ....................{ TESTERS ~ type                     }....................
#declare_function_with_stdin <<'/---'
#[status: boolean] is_variable_float(string variable_name)
#
#Return success if the passed variable was declared to be a float.
#/---
#function is_variable_float() {
#    die_unless_arg 'expected one variable name'
#    is_variable_type_matches_glob "${1}" 'float*'
#}
#
#declare_function_with_stdin <<'/---'
#[status: boolean] is_variable_integer(string variable_name)
#
#Return success if the passed variable was declared to be an integer.
#/---
#function is_variable_integer() {
#    die_unless_arg 'expected one variable name'
#    is_variable_type_matches_glob "${1}" 'integer*'
#}
#
#declare_function_with_stdin <<'/---'
#[status: boolean] is_variable_string(string variable_name)
#
#Return success if the passed variable was declared to be a string.
#/---
#function is_variable_string() {
#    die_unless_arg 'expected one variable name'
#    is_variable_type_matches_glob "${1}" 'scalar*'
#}
#
#declare_function_with_stdin <<'/---'
#[status: boolean] {is_variable_list, is_list}(string variable_name)
#
#Return success if the passed variable was declared to be a *list* (i.e.,
#sequential array).
#/---
#function is_variable_list is_list() {
#    die_unless_arg 'expected one variable name'
#    is_variable_type_matches_glob "${1}" '(list|array)*'
#}
#
#declare_function_with_stdin <<'/---'
#[status: boolean] {is_variable_map, is_map}(string variable_name)
#
#Return success if the passed variable was declared to be a *map* (i.e.,
#associative array).
#/---
#function is_variable_map is_map() {
#    die_unless_arg 'expected one variable name'
#    is_variable_type_matches_glob "${1}" 'association*'
#}
#
#           function_names_die_plural_help="{die_unless_variables_${variable_type}, die_unless_${variable_type_plural}}"
#           function_names_test_singular_help="{is_variable_${variable_type}, is_${variable_type}}"
#           function_names_die_singular_help="{die_unless_variable_${variable_type}, die_unless_${variable_type}}"

    # If such variable does not exist, throw an exception. See is_variable() for
    # further details.
#   is -n "${(P)variable_name__vt+x}" si or
#       die "variable \"${variable_name__vt}\" undefined"

    # If such variable is of improper type, throw an exception.
#   is "${(tP)variable_name__vt}" == ${~ZESHY_VARIABLE_TYPE_GLOB_'${(U)variable_type}'} si or

#FUXME: While the efficiency is appreciated, the extreme reduplication here
#absolutely isn't. Minimize this by dynamically declaring all such functions and
#function documentation. This is surprisingly simpler than you'd think. We'll
#need to iterate on lowercase type, which we uppercase as needed with builtin
#parameter flags. Nothing could be simpler! We can (and should) incorporate list
#and map types into such iteration, which require special handling. Each
#iteration, simply test whether the current type matches "(list|map)" and, if
#so, provide multiple names for such function. Shouldn't be tremendously hard.

# For efficiency, such functions inline their implementations rather than call
# is_variable_type_matches_glob() -- an overly heavyweight if useful tester for
# functions called as commonly as these.

#declare_function_with_stdin <<'/---'
#void die_unless_variable_float(
#    string variable_name,
#    string error_message = "variable \"${variable_name}\" not a float")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a float.
#/---
#function die_unless_variable_float() {
#    # Validate passed arguments.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duvf="${1}"
##
#    # If such variable does not exist, throw an exception. See is_variable() for
#    # further details.
#    is -n "${(P)variable_name__duvf+x}" si or
#        die "variable \"${variable_name__duvf}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # is_variable_float() for further details.
#    is "${(tP)variable_name__duvf}" == ${~ZESHY_VARIABLE_TYPE_GLOB_INTEGER}* si or
#        die "${2:-variable \"${variable_name__duvf}\" not a float but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvf}")}"
#}
#
#declare_function_with_stdin <<'/---'
#void die_unless_variable_integer(
#    string variable_name,
#    string error_message = "variable \"${variable_name}\" not an integer")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be an integer.
#/---
#function die_unless_variable_integer() {
#    # Validate passed arguments.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duvi="${1}"
#
#    # If such variable does not exist, throw an exception. See is_variable() for
#    # further details.
#    is -n "${(P)variable_name__duvi+x}" si or
#        die "variable \"${variable_name__duvi}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # is_variable_integer() for further details.
#    is "${(tP)variable_name__duvi}" == 'integer'* si or
#        die "${2:-variable \"${variable_name__duvi}\" not an integer but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvi}")}"
#}
#
#declare_function_with_stdin <<'/---'
#void die_unless_variable_string(
#    string variable_name,
#    string error_message = "variable \"${variable_name}\" not a string")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a string.
#/---
#function die_unless_variable_string() {
#    # Validate passed arguments.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duvs="${1}"
#
#    # If such variable does not exist, throw an exception. See is_variable() for
#    # further details.
#    is -n "${(P)variable_name__duvs+x}" si or
#        die "variable \"${variable_name__duvs}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # is_variable_string() for further details.
#    is "${(tP)variable_name__duvs}" == 'scalar'* si or
#        die "${2:-variable \"${variable_name__duvs}\" not a string but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvs}")}"
#}
#
#declare_function_with_stdin <<'/---'
#void {die_unless_variable_list, die_unless_list}(
#    string variable_name,
#    string error_message = "variable \"${variable_name}\" not a list")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a list.
#/---
#function die_unless_variable_list die_unless_list() {
#    # Validate passed arguments.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duvl="${1}"
#
#    # If such variable does not exist, throw an exception. See is_variable() for
#    # further details.
#    is -n "${(P)variable_name__duvl+x}" si or
#        die "variable \"${variable_name__duvl}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # is_variable_list() for further details.
#    is "${(tP)variable_name__duvl}" == ('list'|'array')* si or
#        die "${2:-variable \"${variable_name__duvl}\" not a list but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvl}")}"
#}
#
#declare_function_with_stdin <<'/---'
#void {die_unless_variable_map, die_unless_map}(
#    string variable_name,
#    string error_message = "\"${variable_name}\" not a map")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a map.
#/---
#function die_unless_variable_map die_unless_map() {
#    # Validate passed arguments.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duvm="${1}"
#
#    # If such variable does not exist, throw an exception. See is_variable() for
#    # further details.
#    is -n "${(P)variable_name__duvm+x}" si or
#        die "variable \"${variable_name__duvm}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # is_variable_map() for further details.
#    is "${(tP)variable_name__duvm}" == 'association'* si or
#        die "${2:-variable \"${variable_name__duvm}\" not a map but defined as:${ZESHY_ASCII_NEWLINE}$(print_variable "${variable_name__duvm}")}"
#}
#
#
#FUXME: These functions are called commonly enough that their implementations
#should be inlined. is_variable_type_matches_glob() is *FAR* too heavyweight a
#function to call so frequently.

#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvm="${1}"
#   is_map "${variable_name__duvm}" or
#       die "${2:-\"${variable_name__duvm}\" not a map}"

    # Validate passed arguments.
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvl="${1}"

    #FUXME: Quite helpful; replicate above and elsewhere. Actually, since such
    #code would more-or-less be exact duplicates, extricate into a helper function.

    # If such variable is not a list...
#   is_list "${variable_name__duvl}" or
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvs="${1}"
#   is_variable_string "${variable_name__duvs}" or
#       die "${2:-variable \"${variable_name__duvs}\" not a string}"
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string variable_name__duvi="${1}"
#   is_variable_integer "${variable_name__duvi}" or
#       die "${2:-variable \"${variable_name__duvi}\" not an integer}"

        # If such variable exists, append such variable's current definition to
        # the exception's message.
#       string message=
#       is_variable "${variable_name__duvl}" and {
#           message+=" "
#           message+="${ZESHY_ASCII_NEWLINE}original type: $(get_variable_type "${variable_name__duvl}")"
#       }

        # Throw such exception.
#   is_variable_float "${variable_name__duvf}" or
#       die "${2:-\"${variable_name__duvf}\" not an float}"
    # Global lists have type "list", local lists "list-local", and zsh-specific
    # global lists (e.g., "${path}") "array" or "array-special".
    # Global maps have type "association" and local maps "association-local".
#By `zsh` precedent, such type is
#of the form `${typename}-${locality}`, where `${typename}` is such type (e.g.,
#`array`, `string`) and `${locality}` is either:
#
#* `global`, if such variable is global.
#* `local`, if such variable is local.
#
#For example:

# is_variable_type_matches_glob "${variable_name__duvl}" 'array-local' and message+='hmm!!!!!!!'
#   print -r -- "${(tP)variable_name__gvt}"
#       "${glob__ivtm}" or {
#       print_string "variable type not matching \"${glob__ivtm}\": $(get_variable_type "${variable_name__ivtm}")"
#   }
#FUXME: Add support for function name synonyms to declare_function().
#void die_unless_variable_list [or] die_unless_list(
#void die_unless_variable_list [or] die_unless_list(
#void die_unless_variable_list <or> die_unless_list(
#void die_unless_variable_list OR die_unless_list(
#void die_unless_variable_list --or-- die_unless_list(
#void die_unless_variable_list --OR-- die_unless_list(
#void die_unless_variable_list|die_unless_list(

#string die_unless_list_documentation='  string variable_name,
#  string error_message = "\"${variable_name}\" not a list")
#
#Throw an exception unless the passed variable is a list.
#'
#
#declare_function "
#void die_unless_list(
#"
