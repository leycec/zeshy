#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Core zeshy functions attributed with "<globbable>" should be declared *BEFORE*
# defining other zeshy functions calling such functions. Since zeshy implements
# such attribute as aliases of the same names and since zsh expands aliases at
# function definition rather than call time, such aliases should be declared
# *BEFORE* definitions expanding such aliases. While nonfatal, failure to do
# fails to disable filename globbing when calling such functions from other
# zeshy functions.

declare_parcel_as_script_with_stdin <<'-/-'
Handle core extended glob functionality.

== See Also ==

* Section "FILENAME GENERATION" of `man zshexpn`, documenting glob syntax.
-/-

# ....................{ GLOBALS                            }....................
#FIXME: Replace current magic strings with these everywhere.
declare_global_with_stdin string ZESHY_GLOB_CAPTURE_MATCH='(#m)' <<'/---'
Globbing flag capturing the current match into string global ${MATCH}.
/---

declare_global_with_stdin string ZESHY_GLOB_CAPTURE_GROUPS='(#b)' <<'/---'
Globbing flag capturing each subsequent parenthesised group into the
corresponding element of list global ${match}.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
<globbable> void die_unless_string_matches_glob(
    string text,
    string glob,
    string error_message =
        "string \"${text}\" not matched by glob \"${glob}\"")

Throw an exception with the passed message unless the passed string matches the
passed glob. See is_string_matches_glob() for further details.
/---
function die_unless_string_matches_glob() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional error message'
    string text="${1}" glob="${2}"
#   output_string $'\n'"glob: ${glob}"

    # Test such match.
    is_string_matches_glob "${text}" "${glob}" or
        die "${3:-string \"${text}\" not matched by glob \"${glob}\"}"
}

declare_function_with_stdin <<'/---'
<globbable> void die_unless_string_matches_glob_capturing_groups(
    string text,
    string glob,
    string error_message =
        "string \"${text}\" not matched by glob \"${glob}\"")

Throw an exception with the passed message unless the passed string matches the
passed glob. If such string matches such glob, set match globals ${MATCH},
${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and ${mend}. See
is_string_matches_glob_capturing_groups() for further details.
/---
function die_unless_string_matches_glob_capturing_groups() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional error message'
    string text="${1}" glob="${2}"
#   output_string "glob: ${glob}"

    # Test such match.
    is_string_matches_glob_capturing_groups "${text}" "${glob}" or
        die "${3:-string \"${text}\" not matched by glob \"${glob}\"}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_string_matches_glob(string text, string glob)

Return success if the passed string matches the passed glob and, in such case,
set match globals ${MATCH}, ${MBEGIN}, and ${MEND} but _not_ necessarily
${match}, ${mbegin}, or ${mend}; the latter (slightly) reduce match efficiency.
Consider calling is_string_matches_glob_capturing_groups() or prefix such glob
with `(#b)` to set all such globals: e.g.,

.is_string_matches_glob()
==========================================
[source]
------------------------------------------
>>> string on_law; on_law=\
...    "If you reason instead of repeating what is taught you; if you analyze
...     the law and strip off those cloudy fictions with which it has been
...     draped in order to conceal its real origin, which is the right of the
...     stronger, and its substance, which has ever been the consecration of
...     all the tyrannies handed down to mankind through its long and bloody
...     history; when you have comprehended this, your contempt for the law will
...     be profound indeed. You will understand that to remain the servant of
...     the written law is to place yourself every day in opposition to the law
...     of conscience, and to make a bargain on the wrong side; and, since this
...     struggle cannot go on forever, you will either silence your conscience
...     and become a scoundrel, or you will break with tradition, and you will
...     work with us for the utter destruction of all this injustice, economic,
...     social and political."
>>> is_string_matches_glob "${on_law}" ut(#c2,)?r*d?str?ct??n and print_string\
...    "Men lived thousands of years before the first States were constituted."
Men lived thousands of years before the first States were constituted.
------------------------------------------
==========================================
/---
function is_string_matches_glob() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(convert_string_to_glob_capturing_substrings "${2}")"
#   output_string "glob: ${glob}"

    # Test such match. Avoid quoting such glob.
    is "${text}" == ${~glob} si
}

declare_function_with_stdin <<'/---'
<globbable> [status: boolean] is_string_matches_glob_capturing_groups(
    string text, string glob)

Return success if the passed string matches the passed glob and, in such case,
set match globals ${MATCH}, ${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and
${mend}. If capturing only one match group, consider calling
get_string_match_group_first() or
get_string_match_group_first_if_matched() instead. See
convert_string_to_glob_capturing_groups_and_substrings() for further details:
e.g.,

.is_string_matches_glob_capturing_groups() vs. get_string_match_group_*if_matched()
==========================================
[source]
------------------------------------------
>>> is_string_matches_glob_capturing_groups "hiroshima" (???)oshima
>>> print_string "${match[1]}"
hir
>>> get_string_match_group_first_if_matched "hiroshima" (???)oshima
hir
>>> get_string_matches_glob_index_if_matched  "hiroshima" (???)oshima 1
hir
------------------------------------------
==========================================
/---
function is_string_matches_glob_capturing_groups() {
    # Validate passed arguments.
    die_unless_args_2 'expected one string and one glob'
    string text="${1}" glob
    glob="$(convert_string_to_glob_capturing_groups_and_substrings "${2}")"

    # Test such match. Avoid quoting such glob.
    is "${text}" == ${~glob} si
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> integer get_string_matches_glob_count(string text, string glob)

Get the number of substrings in the passed string matching the passed glob: e.g.,

.get_string_matches_glob_count()
==========================================
[source]
------------------------------------------
>>> string on_sufficiency=\
...    "No man can serve two masters: for either he will hate the one, and love
...     the other; or else he will hold to the one, and despise the other. Ye
...     cannot serve God and Mammon.
...     Therefore I say unto you, Take no thought for your life, what ye shall
...     eat, or what ye shall drink; nor yet for your body, what ye shall put
...     on. Is not the life more than meat, and the body than raiment?
...     Behold the fowls of the air: for they sow not, neither do they reap, nor
...     gather into barns; yet your heavenly Father feedeth them. Are ye not
...     much better than they?
...     Which of you by taking thought can add one cubit unto his stature?
...     And why take ye thought for raiment? Consider the lilies of the field,
...     how they grow; they toil not, neither do they spin:
...     and yet I say unto you, That even Solomon in all his glory
...     was not arrayed like one of these.
...     Wherefore, if God so clothe the grass of the field, which today is, and
...     tomorrow is cast into the oven, shall he not much more clothe you, O ye
...     of little faith?
...     Therefore take no thought, saying, What shall we eat? or, What shall we
...     drink? or, Wherewithal shall we be clothed?
...     Take therefore no thought for the morrow: for the morrow shall take
...     thought for the things of itself. Sufficient unto the day is the evil
...     thereof."
>>> get_string_matches_glob_count "${on_sufficiency}" ('field'|'raiament')
4
------------------------------------------
==========================================
/---
function get_string_matches_glob_count() {
    integer match_count=0
    for_string_matches_glob "${@}" 'match_count+=1'
    return_string ${match_count}
}

# ....................{ GETTERS ~ group                    }....................
declare_function_with_stdin <<'/---'
<globbable> string get_string_matches_glob_index(
    string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or throw an exception if such string fails to match: e.g.,

.get_string_matches_glob_index()
==========================================
[source]
------------------------------------------
>>> string on_fellowship=\
...    "I came to the conclusion long ago, after prayerful search and study and
...     discussion with as many people as I could meet, that all religions were
...     true and also that all had some error in them, and that whilst I hold by
...     my own, I should hold others as dear as Hinduism, from which it
...     logically follows that we should hold all as dear as our nearest kith
...     and kin and that we should make no distinction between them. So we can
...     only pray, if we are Hindus, not that a Christian should become a Hindu,
...     or if we are Mussalmans, not that a Hindu or a Christian should become a
...     Mussalman, nor should we even secretely pray that anyone should be
...     converted, but our inmost prayer should be that a Hindu should be a
...     better Hindu, a Muslim a better Muslim, a Christian a better Christian.
...     That is the fundamental truth of fellowship."
>>> get_string_matches_glob_index "${on_fellowship}" *('Mus'[^ ]##)* 1
Mussalmans
------------------------------------------
==========================================
/---
function get_string_matches_glob_index() {
    get_string_matches_glob_index_if_matched "${@}" or {
        string text="${1}" glob="${2}"
        die "\"${text}\" not matched by glob \"${glob}\""
    }
}

#FIXME: Rename to get_string_matches_glob_index_if_found().
declare_function_with_stdin <<'/---'
<globbable> [stdout: string, status: boolean]
    get_string_matches_glob_index_if_matched(
        string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first
such group) resulting from matching the passed string against the passed glob
or return false if such string fails to match: e.g.,

.get_string_matches_glob_index_if_matched()
==========================================
[source]
------------------------------------------
>>> get_string_matches_glob_index_if_matched "Hologram" *(o?)(o?)(o?)* 2 or
...     print_string "Meat space versus the parallel universe"
Meat space versus the parallel universe
------------------------------------------
==========================================
/---
function get_string_matches_glob_index_if_matched() {
    # Validate passed arguments.
    die_unless_args_2_to_3\
        'expected one string, one glob, and optional group index'
    string text="${1}" glob group_index="${3:-1}"
    die_unless_integer_positive "${group_index}"
    glob="$(convert_string_to_glob_capturing_groups_and_substrings "${2}")"

    # If such string matches, return such group. Avoid double-quoting such glob.
    if is "${text}" == ${~glob} si {
        return_string "${match[${group_index}]}"
    # Else, return failure.
    } else {
        return_false
    }
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_substrings(string glob)

Convert the passed glob to capture matched substrings, if not already doing so.
On each successful match, such glob sets the following canonical globals:

* ${MATCH}, a string global expanding to the currently matched substring.
* ${MBEGIN}, an integer global expanding to the 1-based index of the matched
  string at which such substring starts.
* ${MEND}, an integer global expanding to the 1-based index of the matched
  string at which such substring ends.

Specifically, this function prefixes the passed glob with globbing flag `(#m)`
if such glob does not already contain such flag.
/---
function convert_string_to_glob_capturing_substrings() {
    # If such glob already contains "(#m)", prefixing yet another does no harm.
    die_unless_arg 'expected one glob'
    return_string "${ZESHY_GLOB_CAPTURE_MATCH}${1}"
}

declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_groups(string glob)

Convert the passed glob to capture match groups, if not already doing so. On
each successful match, such glob sets the following canonical globals:

* ${match}, a list global containing each match group captured within such
  substring (e.g., `${match[1]}`, the first match group).
* ${mbegin}, a list global containing each 1-based index of the matched string
  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
  at which the first match group starts).
* ${mend}, a list global containing each 1-based index of the matched string
  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
  at which the first match group ends).

Specifically, this function prefixes the passed glob with globbing flag `(#b)`
if such glob does not already contain such flag.
/---
function convert_string_to_glob_capturing_groups() {
    # Validate passed arguments.
    die_unless_arg 'expected one glob'
    string glob="${1}"

    # If such glob does *NOT* already enable globbing flag "(#b)", prefix such
    # glob with such flag. Such logic contrasts with that of
    # convert_string_to_glob_capturing_substrings(), which always prefixes its
    # glob with flag "(#m)". While the position of "(#m)" within a glob is
    # irrelevant, the position of "(#b)" within a glob is relevant and hence
    # must not be changed if already present.
    if is "${glob}" != *"${ZESHY_GLOB_CAPTURE_GROUPS}"* si {
        return_string   "${ZESHY_GLOB_CAPTURE_GROUPS}${glob}"
    # Else, do not.
    } else {
        return_string "${glob}"
    }
}

declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_groups_and_substrings(
    string glob)

Convert the passed glob to capture match groups _and_ matched substrings, if not
already doing so. On each successful match, such glob sets the following
canonical globals:

* All list globals set by convert_string_to_glob_capturing_groups() (i.e.,
  ${match}, ${mbegin}, and ${mend}). See such function for further details.
* All string globals set by convert_string_to_glob_capturing_substrings() (i.e.,
  ${MATCH}, ${MBEGIN}, and ${MEND}). See such function for further details.

Specifically, this function prefixes the passed glob with globbing flags
`(#b)(#m)` if such glob does not already contain such flags. According to `zsh`
documentation:

[quote, `man zshexpn`]
____________________________________________________________________
Unlike backreferences _(i.e., match groups)_, there is no speed penalty for
using match references _(i.e., matched substrings)_.
____________________________________________________________________

Hence, if capturing match groups, it costs us nothing and conceivably gains us
something to also capture matched substrings.
/---
function convert_string_to_glob_capturing_groups_and_substrings() {
    # Validate passed arguments. For efficiency, inline the call to
    # convert_string_to_glob_capturing_substring().
    die_unless_arg 'expected one glob'
    convert_string_to_glob_capturing_groups "${ZESHY_GLOB_CAPTURE_MATCH}${1}"
}

# ....................{ REMOVERS                           }....................
declare_function_with_stdin <<'/---'
<globbable> string remove_string_matches_glob(string text, string glob)

Remove all substrings from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_matches_glob()
==========================================
[source]
------------------------------------------
>>> remove_string_matches_glob "rear_window" r??
indow
------------------------------------------
==========================================
/---
function remove_string_matches_glob() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1//${~2}}"
}

declare_function_with_stdin <<'/---'
<globbable> string remove_string_prefix_glob_match(string text, string glob)

Remove the longest prefix from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_prefix_glob_match()
==========================================
[source]
------------------------------------------
>>> remove_string_prefix_glob_match "north by northwest" *n{o,d}?th
west
------------------------------------------
==========================================
/---
function remove_string_prefix_glob_match() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1##${~2}}"
}

declare_function_with_stdin <<'/---'
<globbable> string remove_string_suffix_glob_match(string text, string glob)

Remove the longest suffix from the passed string matching the passed glob and
return the resulting string: e.g.,

.remove_string_suffix_glob_match()
==========================================
[source]
------------------------------------------
>>> remove_string_suffix_glob_match "dial.m.for.murder" .m?????*
dial.
------------------------------------------
==========================================
/---
function remove_string_suffix_glob_match() {
    die_unless_args_2 'expected one string and one glob'
    return_string "${1%%${~2}}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: The current "matches_glob" and "matches_pcre" nomenclature is fairly
#off-kilter, frankly. Contemplate globally renaming such substrings to
#"matches_glob" and "matches_pcre" everywhere.

#FUXME: Also, note that glob expressions *CAN* match at the beginning and end of
#strings: flags "s" and "e" in the same section as above. Between this and
#backreferencing, I believe we've largely obsoleted our need for regular
#expression matching in the Zeshy codebase and should probably substitute all
#such matching with more efficient and certainly elegant glob matching.
#FUXME: O.K.; the current nomenclature of prefixing only PCRE matching functions
#is no longer tenable. Why? For one, it's unclear which actually *IS* more
#efficient. In some cases, the PCRE version is clearly more efficient (e.g.,
#for_string_matches_pcre(), which unlike for_string_matches_glob() does *NOT* fork a
#subshell for each match). We need to manually suffix all of the below with
#"_glob". I know; I know. But it just needs to be done.
#FUXME: Ah-ha! While the current approach of single-quoting passed globs
#certainly works, wouldn't it be preferable if we could just pass globs as is
#(i.e., unquoted)? Turns out, we can! At least, I *THINK* we can. It requires
#testing, but "man zshmisc" suggests that prefixing each call to a function
#accepting such globs with "noglob " disables implicit filename globbing of
#shell words and hence permits passing unquoted globs. (This must be how the
#canonical catch() function works...) Naturally, writing "noglob " everywhere
#would be silly -- so we implement the same clever hack catch() implements.
#Namely, we alias the same name to expand to itself prefixed by "noglob ": e.g.,
#
#    alias is_string_matches_glob='noglob is_string_matches_glob'
#
#And we should be good to go. Thanks to digest magic, just add each such alias
#*IMMEDIATELY BEFORE THE FUNCTION IT EXPANDS*, below. This will help us to
#maintain all of this abominable machinery, which I must say... ROCKS!

#slightly reduces match efficiency
#This function does _not_ necessarily provide such command access to
#${match}, ${mbegin}, or ${mend}, as doing so slightly reduces match efficiency.

    #FUXME: In fact, do this *EVERYWHERE* in this component. If there's no
    #performance impact (and there isn't), there's no compelling reason *NOT* to
    #do so.

    # Induce the passed glob to capture matched substrings.
#FUXME: Hmm. Niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiice. It turns out it *IS*
#possible to match globs iteratively in a manner similar to that of regular
#expressions. Should be fairly efficient, as well. First, note that parameter
#expansion "${string//(#m)${~glob}/${MATCH}}" is a noop iteratively replacing
#all substrings matching glob ${glob} with themselves. That isn't terribly
#useful, but note that this is generalizable into a similar parameter
#expansion "${string//(#m)${~glob}/$(run_command_on_match "${command}" "${MATCH}"; print_string "${MATCH}")}". Now *THIS* is clever. Unsure why I didn't think of it earlier,
#honestly. For each match, pass such match to helper function
#run_command_on_match() evaluating the passed "${command}", presumably passed
#the current match with standard output and error redirected to the bit bucket
#(to avoid mucking up the current match). Then, assuming such evaluation does
#not throw an exception, print such match, thus avoiding changing such string.
#Ah! Note that if we run the simpler parameter expansion
#"noop ${string//(#m)${~glob}/$(run_command_on_match "${command}" "${MATCH}")}",
#we achieve the same effect! No need to worry about whether or not we replace
#matched substrings, since we don't bother assigning the resulting string. Nice.
#In fact, it might even (slightly) improve efficiency to just replace all
#matches with the empty string (e.g., ";print;"), resulting in a smaller
#temporary string to be retained in-memory.

#declare_function_with_stdin <<'/---'
#[status: boolean] is_string_contains_glob_characters(string text)
#
#Return success if the passed string contains at least one glob-reserved
#character. This includes most ASCII punctuation (e.g., `[`, `<`, `(`, `|`, `+`).
#/---
#function is_string_contains_glob_characters() {
#    die_unless_arg 'expected one string'
#    is_string_matches_glob "${1}" *[\[\]\<\>\(\)\|+*?#~^]*
#}

    # Validate passed arguments
#   die_unless_args_2\
#       'expected one string and one glob expression'
#   string text="${1}" glob="${2}"

    #FUXME: Fairly silly, premature optimization. I mean, how often will an
    #empty string or glob or glob with no glob-reserved characters be passed?
    #This can all pretty much be reduced to a single command calling
    #for_string_match(). The implementation should resemble the corresponding
    #PCRE implementation. See such function!

    # If either such string or glob is empty, there can be no possible matches.
#   if is -z "${text}" or -z "${glob}" si {
#       return_string 0
    # If such glob contains no glob-reserved characters, such glob is a string
    # literal. Get the number of instances of such literal in such string.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_substrings_count "${text}" "${glob}")"
    # Else, count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
#   } else {
#       integer match_count=-1
#       string text_old

#       # For efficiency, avoid calling is_string_equals().
#       until { is "${text_old}" == "${text}" si } {
#           (( ++match_count ))
#           text_old="${text}"
#           text="${text/${~glob}/}"
#       }

#       return_string ${match_count}
#   }

#capture groups into canonical list globals (i.e., ${match}, ${mbegin}, ${mend})
#and substrings into canonical string globals (i.e., ${MATCH}, ${MBEGIN},
#${MEND}). .

#This function does _not_ implicitly capture match groups into canonical `zsh`
#globals (e.g., `${match}`). To perform such capturing, consider calling
#is_string_matches_glob_capturing_groups() instead.

#   die_unless_args_2 'expected one string and one glob'
#   is "${1}" == ${~2} si
#...     Personal success is not wrong. But it is limited in importance, and once
#...     you have enough of it it is a shame to keep striving for that, instead
#...     of for truth, beauty, or justice."
    # If not containing globbing flags "(#b)" or "(#m)", prefix such glob with
    # such strings. For efficiency, inline such tests.
#   is "${glob}" == *'(#b)'* si or glob="(#b)${glob}"
#   is "${glob}" == *'(#m)'* si or glob="(#m)${glob}"

    # Return such glob.
#   return_string "${glob}"

#   die_unless_arg 'expected one glob'
#   string glob="${1}"

    # If not containing globbing flag "(#m)", prefix such glob with such flag.
#   if is "${glob}" == *'(#m)'* si {
#       return_string "(#m)${glob}"
    # Else, do not.
#   } else {
#       return_string "${glob}"
#   }

#FUXME: Note that for_string_matches_pcre() documents similar globals. We should
#aggregate such documentation into a single function and cross-reference such
#function everywhere else.
#FUXME: Rename to is_string_matches_captivated() or
#is_string_matches_capturing(). The latter reads poorly, so... the former? Both
#read poorly, actually. How about is_string_matches_glob_capturing_groups()? Nice one!
#Actually, is_string_matches_captivatingly()... nah. Scratch that. Insanity. Go
#is_string_matches_glob_capturing_groups().
#FUXME: Call convert_string_to_glob_capturing_groups_and_substrings() internally
#for improved generality.

#* `${MATCH}`, a string global expanding to the entire matched substring.
#* `${match}`, a list global containing each match group captured within such
#  substring (e.g., `${match[1]}`, the first match group).
#* `${mbegin}`, a list global containing each 1-based index of the passed string
#  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
#  at which the first match group starts).
#* `${mend}`, a list global containing each 1-based index of the passed string
#  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
#  at which the first match group ends).

#When successfully matching, such glob sets list globals `${match}`, `${mbegin}`,
#and `${mend}` containing matched groups. See is_string_matches_glob_capturing_groups()
#for further details.

#In such case, access such groups after calling this function with the following
#list globals:
#
#* `${match}`, each element the substring captured by the match group with the
#  same list index or the empty string if no such substring was captured (e.g.,
#  `${match[1]}`, the substring captured by the first match group).
#* `${mbegin}`, each element the index of the passed string at which the
#  substring captured by the match group with the same list index begins (e.g.,
#  `${mbegin[1]}`, the string index at which the first match group begins).
#* `${mend}`, each element the index of the passed string at which the substring
#  captured by the match group with the same list index ends (e.g., `${mend[1]}`,
#  the string index at which the first match group ends).

#FUXME: Rename to convert_string_to_glob_matching_lines(), in keeping with
#convert_string_to_pcre_matching_lines() nomenclature.
#FUXME: Rename to convert_string_to_glob_capturing_groups() or
#convert_string_to_glob_matching_groups(). Hmmm; the former's a bit more verbose
#but much more explanatory and hence preferable. I mean, every glob "matches
#groups" already, so the latter conveys no meaningful information.
    #FUXME: Extract into a new get_string_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_substrings_count "${text}" "${glob}")"
#       string text_matches_deleted="${text//${glob}/}"
#       return_string $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))

# (i.e., saving `(` and
#`)`-delimited match groups in global list ${match})
#   if is "${text}" == ${~glob} si
#FUXME: Rename to get_string_matches_glob_index(). The current function name is
#exceptionally ambiguous; after all, there could be multiple means of specifying
#which match to retrieve, of which group indices are merely the most obvious.
    #FUXME: Verify whether this suffices for instances of "${match[1]}" and so
    #forth in the replacement. I strongly suspect not (...in fact, let us say,
    #obviously not), in which case we require a separate
    #replace_string_match_with_evaluation() function.
#FUXME: I've never enjoyed pretending such functions to be getters. Rename to
#convert_string_to_glob_capturing_groups().
#FUXME: Rename to convert_string_to_glob_matching_lines()... or perhaps simply
#convert_string_to_glob_matching_lines(). Yes! The latter. Perfect.
# Such strings must be quote protected to be matched as specified when globbing.
#FUXME: No longer convinced this function is a good idea. The principle issue is
#quoting, which plays poorly with and in any case obstructs construction of
#string globs. Excise this function.

#FUXME: This needs a rename. It can currently be read in two very different
#ways, and the expected reading is *NOT* the actual reading. How about
#is_string_matches_capturing_groups_groups() or
#is_string_matches_glob_capturing_groups()? I prefer the former, I reckon. The added
#"_with" makes all the difference for readability here.
#FUXME: Rename to enable_glob_group_capturing()?
#FUXME: Rename to enable_glob_line_matching()?
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.

    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FUXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
