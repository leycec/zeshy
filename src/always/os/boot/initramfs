#!/usr/bin/env zsh
# ====================[ initramfs                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle initramfs images (i.e., initial RAM filesystems).

# ....................{ GETTERS                            }....................
document_function '
string get_initramfs_file(string kernel_home = "$(get_kernel_home)")

Get the absolute path of the initramfs image installed under the "/boot"
partition for the passed kernel (defaulting to the current kernel).
'
function get_initramfs_file() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"

    # Print such path.
    print_string "/boot/initramfs-$(get_kernel_version "${kernel_home}").img"
}

# ....................{ LISTERS                            }....................
document_function '
string list_initramfs(string filename = "$(get_initramfs_file)")

List the contents of the passed initramfs image (defaulting to the image
installed under the "/boot" partition for the current kernel).
'
function list_initramfs() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional filename'
    string filename; filename="${1:-$(get_initramfs_file)}"
    die_unless_file "${filename}"

    # List such initramfs.
    gunzip -c "${filename}" | cpio -tv
}

# ....................{ EXTRACTERS                         }....................
document_function '
void extract_initramfs(string filename = "$(get_initramfs_file)")

Extract the passed initramfs image (defaulting to that installed under the
"/boot" partition for the current kernel) into the current working directory.
'
function extract_initramfs() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional filename'
    string filename; filename="${1:-$(get_initramfs_file)}"
    die_unless_file "${filename}"

    # Extract such initramfs.
    interactively say "extracting \"${filename}\"..."
    gunzip -c "${filename}" | cpio -id --no-absolute-filenames
}

# ....................{ MAKERS                             }....................
document_function '
void make_initramfs(
  string initramfs_home = "${ZESHY_INITRAMFS_HOME}",
  string kernel_home = "$(get_kernel_home)")

Reinstall the passed initramfs (defaulting to ${ZESHY_INITRAMFS_HOME}) to the
/boot partition as "/boot/initramfs-${kernel_version}.img", a filename format
implicitly expected by GRUB2, where ${kernel_version} is the version of the
passed kernel (defaulting to "/usr/src/linux").
'
function make_initramfs() {
    # Validate passed arguments.
    die_unless_args_0_to_2\
        'expected optional initramfs dirname and kernel dirname'
    string source_dirname target_filename kernel_home
    source_dirname="${1:-${ZESHY_INITRAMFS_HOME}}"
    kernel_home="${2:-$(get_kernel_home)}"
    die_unless_dir "${source_dirname}"
    target_filename="$(get_initramfs_file "${kernel_home}")"

    # Curse for all dynamically linked binaries in the passed source directory.
    # Since initramfses are notoriously intolerant of dynamic linking, use of a
    # single such binary is likely to raise boot-time issues.
    is_dir "${source_dirname}/bin" and
        for binary_filename ("${source_dirname}/bin/"*(x)) {
            is_dynamically_linked_executable_binary "${binary_filename}" and
                cry "\"${binary_filename}\" dynamically linked (likely to cause boot failure)"
        }

    # Mount the "/boot" partition writably.
    mount_writable_boot_dir

    # Ensure the passed source directory is the root of the installed target
    # image by temporarily changing to such directory.
    set_current_dir "${source_dirname}"

    # Install. Note that "cpio" expects input in the form of one input file or
    # directory per line. Since "cpio" does *NOT* recry into subdirectories,
    # do so for it with "**/*". Since "gzip" fails to return non-zero exit
    # status when "cpio" returns non-zero exit status, do so for "gzip" by
    # throwing an exception in such case. While "cpio" and "gzip" are blatantly
    # brain-dead, we are not.
    {
        say_first_section\
            "installing \"${source_dirname}/\" to \"${target_filename}\""
        remove_file_if_found "${target_filename}"

        # Pipe the null-delimited print_string of "find" to "cpio". Technically,
        # running a pure-Zsh alternative to "find" should be feasible (e.g.,
        # "print_string_nulled ./**/* |"). Unfortunately, "cpio" is an
        # unusually testy command, basically tolerating only "find" output.
        find . -print0 |
            cpio --null -o -H newc |
            gzip -9 > "${target_filename}"
    # Regardless of whether such installation succeeds, always revert the
    # current directory to its prior path (as the user expects).
    } always {
        restore_current_dir
    }

    # List the contents of the newly installed target image, if interactive.
    say_next_section "listing \"${target_filename}\""
    list_initramfs "${target_filename}"
}

# --------------------( WASTELANDS                         )--------------------
#       die_if_piped_command_failed

#           cpio -o -H newc --quiet |
#       print_string_nulled ./**/* |
#   print_path_verbosely "${filename}"
# Remove the target image if already installed to avoid errors below.

# ....................{ GETTERS ~ current                  }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
# string get_kernel_home(void)
#
# Get the absolute path of the root directory for the current kernel: e.g.,
#
#     >>> get_kernel_home
#     /usr/src/linux
#get_initramfs_home() {
#    die_if_args
#    print_string      "${ZESHY_INITRAMFS_HOME}"
#}
