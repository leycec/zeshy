#!/usr/bin/env zsh
# ====================[ initramfs                          ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle initramfs images (i.e., initial RAM filesystems).

# ....................{ GETTERS                            }....................
# string get_initramfs_file(string kernel_home = "$(get_kernel_home)")
#
# Get the absolute path of the initramfs image installed under the "/boot"
# partition for the passed kernel (defaulting to the current kernel).
get_initramfs_file() {
    die_unless_no_or_one_arg 'expected optional kernel dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    output_string "/boot/initramfs-$(get_kernel_version "${kernel_home}").img"
}

# ....................{ LISTERS                            }....................
# string list_initramfs(string filename = "$(get_initramfs_file)")
#
# List the contents of the passed initramfs image (defaulting to the image
# installed under the "/boot" partition for the current kernel).
list_initramfs() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional filename'
    string filename; filename="${1:-$(get_initramfs_file)}"
    die_unless_file "${filename}"

    # List such initramfs.
    gunzip -c "${filename}" | cpio -tv
}

# ....................{ EXTRACTERS                         }....................
# void extract_initramfs(string filename = "$(get_initramfs_file)")
#
# Extract the passed initramfs image (defaulting to that installed under the
# "/boot" partition for the current kernel) into the current working directory.
extract_initramfs() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional filename'
    string filename; filename="${1:-$(get_initramfs_file)}"
    die_unless_file "${filename}"

    # Extract such initramfs.
    interactively say "extracting \"${filename}\"..."
    gunzip -c "${filename}" | cpio -id --no-absolute-filenames
}

# ....................{ MAKERS                             }....................
# void make_initramfs(
#   string initramfs_home = "${ZESHY_INITRAMFS_HOME}",
#   string kernel_home = "$(get_kernel_home)")
#
# Reinstall the passed initramfs (defaulting to ${ZESHY_INITRAMFS_HOME}) to the
# /boot partition as "/boot/initramfs-${kernel_version}.img", a filename format
# implicitly expected by GRUB2, where ${kernel_version} is the version of the
# passed kernel (defaulting to "/usr/src/linux").
make_initramfs() {
    # Validate passed arguments.
    die_unless_at_most_two_args\
        'expected optional initramfs dirname and kernel dirname'
    string source_dirname target_filename kernel_home
    source_dirname="${1:-${ZESHY_INITRAMFS_HOME}}"
    kernel_home="${2:-$(get_kernel_home)}"
    die_unless_dir "${source_dirname}"
    target_filename="$(get_initramfs_file "${kernel_home}")"

    # Curse for all dynamically linked binaries in the passed source directory.
    # Since initramfses are notoriously intolerant of dynamic linking, use of a
    # single such binary is likely to raise boot-time issues.
    is_dir "${source_dirname}/bin" and
        for binary_filename ("${source_dirname}/bin/"*(x)) {
            is_dynamically_linked_executable_binary "${binary_filename}" and
                cry "\"${binary_filename}\" dynamically linked (likely to cause boot failure)"
        }

    # Mount the "/boot" partition writably.
    mount_writable_boot_dir

    # Ensure the passed source directory is the root of the installed target
    # image by temporarily changing to such directory.
    set_current_dir "${source_dirname}"

    # Install. Note that "cpio" expects input in the form of one input file or
    # directory per line. Since "cpio" does *NOT* recry into subdirectories,
    # do so for it with "**/*". Since "gzip" fails to return non-zero exit
    # status when "cpio" returns non-zero exit status, do so for "gzip" by
    # throwing an exception in such case. While "cpio" and "gzip" are blatantly
    # brain-dead, we are not.
    {
        say_first_section\
            "installing \"${source_dirname}/\" to \"${target_filename}\"..."
        remove_file_if_found "${target_filename}"

        # Pipe the null-delimited output_string of "find" to "cpio". Technically,
        # running a pure-Zsh alternative to "find" should be feasible (e.g.,
        # "output_string_delimited_by_null ./**/* |"). Unfortunately, "cpio" is an
        # unusually testy command, basically tolerating only "find" output.
        find . -print0 |
            cpio --null -o -H newc |
            gzip -9 > "${target_filename}"
        die_if_piped_command_failed
    # Regardless of whether such installation succeeds, always revert the
    # current directory to its prior path (as the user expects).
    } always {
        restore_current_dir
    }

    # List the contents of the newly installed target image, if interactive.
    say_next_section "listing \"${target_filename}\"..."
    list_initramfs "${target_filename}"
}

# --------------------( WASTELANDS                         )--------------------
#           cpio -o -H newc --quiet |
#       output_string_delimited_by_null ./**/* |
#   print_path_verbosely "${filename}"
# Remove the target image if already installed to avoid errors below.

# ....................{ GETTERS ~ current                  }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
# string get_kernel_home(void)
#
# Get the absolute path of the root directory for the current kernel: e.g.,
#
#     >>> get_kernel_home
#     /usr/src/linux
#get_initramfs_home() {
#    die_if_args
#    output_string      "${ZESHY_INITRAMFS_HOME}"
#}
