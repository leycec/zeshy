#!/usr/bin/env zsh
# ====================[ cron                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle cron jobs and related process scheduling.

# ....................{ RUNNERS                            }....................
#FIXME: Rename to run_on_scheduled_interval(), run_on_schedule(),
#run_on_interval(), or run_every_interval(). I rather prefer the latter, but...

# void run_every(
#   string command_name, string command_arg1, string command_arg2, ...,
#   integer seconds)
#
# Run the passed command every passed number of seconds.
function run_every() {
    # Validate passed arguments.
    die_unless_args_at_least_2\
        'expected one duration in seconds and one command'
    string every_seconds="${@[-1]}"
    die_unless_string_integer_positive "${every_seconds}"
    shift_one_arg

    #FIXME: Not quite right; this conditional succeeds on command lines
    #resembling "ls 2>&1", but shouldn't. It's exceedingly difficult to
    #reliably determine whether or not such command requires shell
    #interpretation; so, just excise this conditional altogether. What follows
    #is generally reliable and, in fact, more precise, as we can pass intervals
    #in units other than seconds to the sleep() builtin.

    # If the passed command is an external command, run under "watch", a POSIX-
    # standard command with an efficiently aesthetic CLI supporting only
    # external commands.
    if is_installed "$(get_command_line_runnable_name "${@}")"
    then watch -n ${every_seconds} -x -- "${@}"
    # Otherwise, run under a mimic of the "watch" CLI.
    else
        # Until the user explicitly hits <Ctrl-C>, ...
        while true; do
            #FIXME: Append with a right-aligned timestamp, as under "watch".
            #Also, shouldn't we actually be calling "echoti" directly here?
            # Mimic the "watch" UI. For efficiency, call "echoti" directly.
            clear_terminal_screen
            print_string "Every ${every_seconds}s: ${@}\n"

            #FIXME: We could actually make this reasonably precise; ideally, we
            #want to run the passed command precisely on the passed interval.
            #But the current implementation just sleeps for the passed interval.
            #Not at all the same thing, particularly for commands that take
            #somewhat long to complete. Instead, get the current time before and
            #after executing such command. Subtract the positive difference
            #between the two from the desired interval; the resulting float is
            #the exact number of time units to sleep this iteration. Simple.
            #Ah! Wait. There's an even simpler means. The prior iteration should
            #calculate the time at which the next iteration should run such
            #command; then, in the next iteration, just get the current time...
            #Hmm. Perhaps that's not simpler at all, actually. O.K.; constrain
            #everything to the current iteration. For simplicity, go with the
            #first idea above.
            # Run and sleep. (Just like in real life.)
            run "${@}"
            sleep ${every_seconds}s
        done
    fi
}

# --------------------( WASTELANDS                         )--------------------
