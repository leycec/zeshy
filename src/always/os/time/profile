#!/usr/bin/env zsh
# ====================[ run                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle profiling of runnables (e.g., aliases, commands, functions).

# ....................{ RUNNERS                            }....................
# string run_profiled(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command, profiled. After running such command, print a human-
# readable profile of all Zsh functions called by such command to standard
# error to guarantee expected behavior under process substitution.
function run_profiled() {
    # Validate passed arguments.
    die_unless_args 'expected one command'

    # Temporarily load module "prof", thus initiating profiling.
    load_zsh_module zsh/prof

    {
        # Run such command.
        run "${@}"

        # Print such profile to standard error. Avoid calling
        # run_redirected_to_standard_error() to avoid slowing down profiling.
        zprof 1>&2
    # Always unload module "prof", thus terminating profiling.
    } always {
        unload_zsh_module zsh/prof
    }
}

#FIXME: Shouldn't this be run_with_progress_bar()? Much more intelligible, and
#straight forward.
# string run_with_progress_timer(
#   string command_name, string command_arg1, string command_arg2, ...)
#
# Run the passed command, printing a progress timer on standard error displaying
# how many seconds have elapsed since running such command. Consider calling
# this function on silent and/or slow commands (e.g., "ntpd -q -s",
# synchronizing the local system time against remote time servers but displaying
# no progress while doing so).
function run_with_progress_timer() {
    # Validate passed arguments.
    die_unless_args 'expected one command'

    #FIXME: If "pv" is *NOT* installed, are there any respectable alternatives?
    #Surely we could cobble together a weak pure-Zsh solution, no? I wonder if
    #anything similar's been done in bash, actually...

    # Prefer "pv", the pipe viewer.
    if is_installed pv
    then run "${*} | pv -t"
#   then print "progress_time: ${@}"; run "${@} | pv -t"
    # Otherwise, simply run the passed command.
    else run "${@}"
    fi
}

#FIXME: Rename to run_on_scheduled_interval(), run_on_schedule(),
#run_on_interval(), or run_every_interval(). I rather prefer the latter, but...

# void run_every(
#   string command_name, string command_arg1, string command_arg2, ...,
#   integer seconds)
#
# Run the passed command every passed number of seconds.
function run_every() {
    # Validate passed arguments.
    die_unless_args_2_or_more\
        'expected one duration in seconds and one command'
    string every_seconds="${@[-1]}"
    die_unless_string_integer_positive "${every_seconds}"
    shift_one_arg

    #FIXME: Not quite right; this conditional succeeds on command lines
    #resembling "ls 2>&1", but shouldn't. It's exceedingly difficult to
    #reliably determine whether or not such command requires shell
    #interpretation; so, just excise this conditional altogether. What follows
    #is generally reliable and, in fact, more precise, as we can pass intervals
    #in units other than seconds to the sleep() builtin.

    # If the passed command is an external command, run under "watch", a POSIX-
    # standard command with an efficiently aesthetic CLI supporting only
    # external commands.
    if is_installed "$(get_command_line_runnable_name "${@}")"
    then watch -n ${every_seconds} -x -- "${@}"
    # Otherwise, run under a mimic of the "watch" CLI.
    else
        # Until the user explicitly hits <Ctrl-C>, ...
        while true; do
            #FIXME: Append with a right-aligned timestamp, as under "watch".
            #Also, shouldn't we actually be calling "echoti" directly here?
            # Mimic the "watch" UI. For efficiency, call "echoti" directly.
            clear_terminal_screen
            print_string "Every ${every_seconds}s: ${@}\n"

            #FIXME: We could actually make this reasonably precise; ideally, we
            #want to run the passed command precisely on the passed interval.
            #But the current implementation just sleeps for the passed interval.
            #Not at all the same thing, particularly for commands that take
            #somewhat long to complete. Instead, get the current time before and
            #after executing such command. Subtract the positive difference
            #between the two from the desired interval; the resulting float is
            #the exact number of time units to sleep this iteration. Simple.
            #Ah! Wait. There's an even simpler means. The prior iteration should
            #calculate the time at which the next iteration should run such
            #command; then, in the next iteration, just get the current time...
            #Hmm. Perhaps that's not simpler at all, actually. O.K.; constrain
            #everything to the current iteration. For simplicity, go with the
            #first idea above.
            # Run and sleep. (Just like in real life.)
            run "${@}"
            sleep ${every_seconds}s
        done
    fi
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: This component's getting a bit long in the tooth. Contemplate shifting
#such functions to "os/time/run".

