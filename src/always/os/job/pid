#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'---'
Handle *PIDs* (i.e., process identifiers).
---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_pid(integer pid)

Return success if a process with the passed PID is currently running: e.g.,

.is_pid()
==========================================
[source]
------------------------------------------
>>> sleep 10s &
>>> is_pid $! and print_string "Awaken, young master."
Awaken, young master.
------------------------------------------
==========================================
/---
function is_pid() {
    die_unless_arg 'Expected one process ID.'
    run_code_silent kill -0 "${1}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
integer get_pid(void)

Return the *PID* (i.e., process ID) of the current process.
/---
function get_pid() {
    die_if_args
    output_string ${$}
}

# ....................{ GETTERS ~ pid                      }....................
#FIXME: Generalize to not require "pgrep".
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_pids_running_command_if_found(
    string command_name)

Get the PIDs of all processes running the passed command as a newline-delimited
string if such processes exist (i.e., if such command is currently running) or
return failure.
/---
function get_pids_running_command_if_found() {
    # Validate passed arguments.
    die_unless_arg 'Expected one command name.'
    die_unless_pathable pgrep
    string command_name="${1}"

    # Get such PIDs.
    if { is_path_absolute "${command_name}" } {
        run_code_silent pgrep -fx "${command_name}"
    } else {
        run_code_silent pgrep  -x "${command_name}"
    }
}

#FIXME: Generalize to not require "pgrep".
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_pids_running_command_under_user_if_found(
    string command_name, string username)

Get the PIDs of all processes running the passed command under the passed user
as a newline-delimited string if such processes exist (i.e., if such command is
currently running under such user) or return failure.
/---
function get_pids_running_command_under_user_if_found() {
    # Validate passed arguments.
    die_unless_args_2 'Expected one command name and one username.'
    die_unless_pathable pgrep
    string command_name="${1}" username="${2}"

    # Get such PIDs.
    if { is_path_absolute "${command_name}" } {
        run_code_silent pgrep -u "${username}" -fx "${command_name}"
    } else {
        run_code_silent pgrep -u "${username}"  -x "${command_name}"
    }
}

# ....................{ GETTERS ~ name                     }....................
#FIXME: This probably doesn't work as expected for scripts preceeded by set
#variables (e.g., "TMP=~/.tmp script.zeshy"). Test; hack; fix! Actually,
#stackoverflow can probably help us here.

declare_function_with_stdin <<'/---'
string get_pid_command_name(integer pid)

Get the name of the command running under the process with the passed PID.
/---
function get_pid_command_name() {
    # List splitting the command-line the current process is running on words.
    # Dismantled, this is:
    #
    # * "(0)", split the command-line on null bytes. By Linux convention (and
    #   hence probably not applicable to other *nix), a null byte delimits each
    #   shell word of such line.
    list command_line_words
         command_line_words=( "${(0)$(get_pid_command_line "${@}")}" )
#   print_warning "pclp: ${command_line_words[@]}"

    # The name and absolute path of the command the current process is running.
    string command_name="${command_line_words[1]}" command_path

    # If this process is a zsh script (which it usually is), the absolute path
    # to this command is given by the third string in this array: e.g.,
    #
    #   # For a zeshy script "h3110", this array resembles...
    #   command_line_words=( zsh /usr/bin/zeshy h3110 )
    if is "${command_name}" == *sh si and (( ${#command_line_words} >= 3 )) {
        command_path="${command_line_words[3]}"
    } else {
        command_path="${command_name}"
    }

    # If the command path is "-su" (as occurs under "su"), strip the hyphen.
    is "${command_path}" == '-'* si and command_path="${command_path[2,-1]}"

    # Return the basename of this command path.
#   print "\ncommand_line_words: ${command_line_words[@]}"
#   print "command_path: ${command_path}"
    get_path_basename "${command_path}"
}

declare_function_with_stdin <<'/---'
string get_pid_command_line(integer pid)

Get the command line of the currently running process with the passed PID. Such
line is a string consisting of (in order):

* Either the absolute or relative path to the command. In the latter case,
  there is no reliable means of resolving this path into an absolute path.
* Each command line argument passed to such command prefixed by a null
  delimiter (i.e., `\x00`).

Due to such inconsistencies, use such strings _only_ for non-critical
display purposes rather than critical functionality.
/---
function get_pid_command_line() {
    #FIXME: We should instate a stronger check than this -- namely, that such
    #PID is actually valid.

    # Validate sanity.
    die_unless_arg 'Expected one process ID.'
    string pid="${1}"
    die_unless_integer "${pid}"

    #FIXME: New getter command getting such path?
    # Absolute path to the file with the command line for the passed process.
    get_file_text "/proc/${pid}/cmdline"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Double-check what occurs if no such command is running. We should throw
#an exception rather than 
#FUXME: Make the argument mandatory; optional arguments are largely harmful.
#FUXME: Rename to convert_pid_to_command_name() or get_pid_command_name().
#Yes, clearly the latter!
#FUXME: Rename to get_pid_command().
#FUXME: Make the argument mandatory; optional arguments are largely harmful.
