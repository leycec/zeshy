#!/usr/bin/env zsh
# ====================[ pid                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle process ID (PID) integers.

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'-\-'
[status: boolean] is_pid(integer pid)

Return true if a process with the passed PID is currently running: e.g.,

.is_pid()
==========================================
[source]
------------------------------------------
>>> sleep 10s &
>>> is_pid $! and print_string "Awaken, young master."
Awaken, young master.
------------------------------------------
==========================================
-\-
function is_pid() {
    die_unless_arg 'expected one process ID'
    run_command_silent kill -0 "${1}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'-\-'
integer get_pid(void)

Return the PID (i.e., process ID) of the current process.
-\-
function get_pid() {
    die_if_args
    return_string ${$}
}

#FIXME: Generalize to not require "pgrep".
declare_function_with_stdin <<'-\-'
string get_pids_running_executable(string command_name)

Return a newline-delimited string of process IDs for all processes running the
passed command. If no such process exists, return the empty string and fail.
-\-
function get_pids_running_executable() {
    # Validate passed arguments.
    die_unless_arg 'expected one command name'
    die_unless_pathable pgrep
    string command_name="${1}"

    # Get such PIDs.
    if { is_path_absolute "${command_name}" } {
        run_command_silent pgrep -fx "${command_name}"
    } else {
        run_command_silent pgrep  -x "${command_name}"
    }
}

#FIXME: Generalize to not require "pgrep".
declare_function_with_stdin <<'-\-'
string get_pids_running_executable_under_user(
    string command_name, string username)

Return a newline-delimited string of process IDs for all processes having the
passed command name running under the passed user. If no such process exists,
return the empty string and a failure return code.
-\-
function get_pids_running_executable_under_user() {
    # Validate passed arguments.
    die_unless_args_2 'expected one username and command name'
    die_unless_pathable pgrep
    string command_name="${1}" username="${2}"

    # Get such PIDs.
    if { is_path_absolute "${command_name}" } {
        run_command_silent pgrep -u "${username}" -fx "${command_name}"
    } else {
        run_command_silent pgrep -u "${username}"  -x "${command_name}"
    }
}

# ....................{ GETTERS ~ name                     }....................
#FIXME: This probably doesn't work as expected for scripts preceeded by set
#variables (e.g., "TMP=~/.tmp script.zeshy"). Test; hack; fix! Actually,
#stackoverflow can probably help us here. Google us up the fix, yo!
#FIXME: Make the argument mandatory; optional arguments are largely harmful.
#FIXME: Rename to convert_pid_to_command_name() or get_pid_command_name().
#Yes, clearly the latter!

declare_function_with_stdin <<'-\-'
string get_process_command_name(integer pid = ${PID})

Get the name of the command the process with the passed PID (defaulting to
that of the current process) is running.
-\-
function get_process_command_name() {
    # List splitting the command-line the current process is running on words.
    # Dismantled, this is:
    #
    # * "(0)", split the command-line on null bytes. By Linux convention (and
    #   hence probably not applicable to other *nix), a null byte delimits each
    #   shell word of such line.
    list command_line_words
         command_line_words=( "${(0)$(get_process_command_line "${@}")}" )
#   print_warning "pclp: ${command_line_words[@]}"

    # The name and absolute path of the command the current process is running.
    string command_name="${command_line_words[1]}" command_path

    # If this process is a zsh script (which it usually is), the absolute path
    # to this command is given by the third string in this array: e.g.,
    #
    #   # For a Zeshy script "h3110", this array resembles...
    #   command_line_words=( zsh /usr/bin/zeshy h3110 )
    if is "${command_name}" == *sh si and (( ${#command_line_words} >= 3 ))
    then command_path="${command_line_words[3]}"
    else command_path="${command_name}"
    fi

    # If the command path is "-su" (as occurs under "su"), strip the hyphen.
    is "${command_path}" == '-'* si and command_path="${command_path[2,-1]}"

    # Return the basename of this command path.
#   print "\ncommand_line_words: ${command_line_words[@]}"
#   print "command_path: ${command_path}"
    get_path_basename "${command_path}"
}

#FIXME: Rename to get_pid_command().
#FIXME: Make the argument mandatory; optional arguments are largely harmful.
declare_function_with_stdin <<'-\-'
string get_process_command_line(integer pid = ${PID})

Get the command line the process with the passed PID (defaulting to that of
the current process) is running. This is a string consisting of (in order):

* Either the absolute or relative path to the command. In the latter case,
  there is no reliable means of resolving this path into an absolute path.
* Each command line argument passed to such command prefixed by a null
  delimiter (i.e., `\x00`).

Due to such inconsistencies, use such strings _only_ for non-critical
display purposes rather than critical functionality.
-\-
function get_process_command_line() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected one optional process ID'
    integer pid; pid="${1:-$(get_pid)}"

    #FIXME: New getter command getting such path?
    # Absolute path to the file with the command line for the passed process.
    print_file_text "/proc/${pid}/cmdline"
}

# --------------------( WASTELANDS                         )--------------------
