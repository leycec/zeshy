#!/usr/bin/env zsh
# ====================[ job                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle jobs (i.e., currently running processes).

#FIXME: Contemplate renaming nomenclature from is_command_running() to
#is_job_running_command(), which better coincides with the current
#get_pid_running_command() nomenclature. Or perhaps not; a bit hard to say.
#While slightly longer, 

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'-\-'
void die_unless_command_running(
    string command_name,
    string error_message = "\"${command_name}\" not running")

Throw an exception unless some user is currently running the passed command.
-\-
function die_unless_command_running() {
    die_unless_args_1_to_2\
        'expected one command name and optional error message'
    string command_name="${1}"
    is_command_running "${command_name}" or die "${2:-\"${command_name}\" not running}"
}

declare_function_with_stdin <<'-\-'
void die_unless_command_running_under_user(
    string command_name,
    string username,
    string error_message = "${username} not running \"${command_name}\"")

Throw an exception unless the passed user is currently running the passed
command.
-\-
function die_unless_command_running_under_user() {
    die_unless_args_2_to_3\
        'expected one command name, one username, and optional error message'
    string command_name="${1}" username="${2}"
    is_command_running_under_user "${username}" "${command_name}" or
        die "${username} not running \"${command_name}\""
}

# ....................{ TESTERS                            }....................
#FIXME: Reimplement me! Dredge up the implementation from the WASTELANDS. Also,
#this *REALLY* wants to be in a new "os/job/cron" component. Shift the existing
#"os/process" component to "os/job/job". Nice, ne?
declare_function_with_stdin <<'-\-'
[status: boolean] is_cronjob(void)

Return true if the current process is the grandchild of a "cron" process.
-\-
function is_cronjob() {
    die_if_args
    die "this function currently unimplemented!"

    #FIXME: This no longer works, of course. That said, let's pursue the
    #familiar strategy of testing such global boolean if set and otherwise
    #caching such global boolean for subsequent lookup.
    is_variable_nonempty ZESHY_IS_CRONJOB
}

declare_function_with_stdin <<'-\-'
[status: boolean] is_command_running(string command_name)

Return true if at least one user is currently running the passed command.
-\-
function is_command_running() {
    die_unless_arg 'expected one command name'
    run_command_silent get_pids_running "${@}"
}

declare_function_with_stdin <<'-\-'
[status: boolean] is_command_running_under_user(
    string command_name, string username)

Return true if the passed user is currently running the passed command.
-\-
function is_command_running_under_user() {
    die_unless_args_2 'expected one command name and one username'
    run_command_silent get_pids_running_command_under_user "${@}"
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Extract the first conditional into a new function 
    #get_pids_running_command().

#FUXME: Since Zeshy uses "command" to mean "command line," we should probably
#rename "_command" everywhere here to "_pathable": e.g., is_pathable_running().
#Of course, that also isn't quite right, since command names need not be
#pathable to be executable. Hmm... O.K., how about to "_executable", thus
#giving us: is_binary_executable_running(). Seems sensible, yes? Hmm; or perhaps this
#is fine after all. We could, after all, define an is_command_line_running() if
#we required such functionality.
#FUXME: It's unfortunate I spent a bit of time on this...as it appears to be
#completely superfluous. zsh *DOES* throw exceptions on any subprocess of a
#pipeline failing, as each such subprocess executes in its own subshell. *sigh*
#declare_function '
#void die_if_piped_command_failed(
#  integer pipe_position = -2, string error_message = "prior command failed")
#
#Throw an exception if the command with the passed position (defaulting to -2
#and hence the second-to-last command) in the prior pipe failed with non-zero
#exit status. Zeshy already implicitly throws an exception if the command in
#the last position fails, thus requiring this function be called *ONLY* when
#the last command erroneously succeeds despite the prior command in its pipe
#failing. This is, thankfully, rare.
#'
#function die_if_piped_command_failed() {
#    die_unless_args_0_to_2\
#        'expected optional pipe position and error message'
#
#    #FUXME: How often do we check success? Perhaps an is_successful() function
#    #is soon in order.
#    (( pipestatus[${1:--2}] == ZESHY_EXIT_STATUS_SUCCESS )) or
#        die "${2:-prior command failed}"
#}

# ....................{ ERRORS                             }....................
# integer exit_success(void)
#
# Exit the current process with a successful return code.
#exit_success() {
#    die_if_args
#    exit ${ZESHY_EXIT_STATUS_SUCCESS}
#}

# integer exit_failure(void)
#
# Exit the current process with a failure return code.
#exit_failure() {
#    die_if_args
#    exit ${ZESHY_EXIT_STATUS_FAILURE}
#}
