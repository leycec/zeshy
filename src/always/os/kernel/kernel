#!/usr/bin/env zsh
# ====================[ kernel                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *nix kernels.

# ....................{ GETTERS                            }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
# string get_kernel_home(void)
#
# Get the absolute path of the root directory for the current kernel: e.g.,
#
#     >>> get_kernel_home
#     /usr/src/linux
get_kernel_home() {
    # Dismantled, this is:
    #
    # * '/usr/src/'*(/...), matching all subdirectories of "/usr/src" and hence
    #   installed kernel trees.
    # * "om", sorting such subdirectories by descending modification time.
    die_if_args
    get_dir_first '/usr/src/linux' '/usr/src/'*(/om)
}

# string get_kernel_version(string kernel_home = "$(get_kernel_home)")
#
# Get the version number of the passed kernel (defaulting to the current
# kernel): e.g.,
#
#     >>> get_kernel_version /usr/src/linux-3.3.8
#     3.3.8
get_kernel_version() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home kernel_makefile
    kernel_home="${1:-$(get_kernel_home)}"
    kernel_makefile="${kernel_home}/Makefile"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_makefile}"

    # Parse the passed kernel's makefile for version specifiers.
    awk '
BEG { VERSION = PATCHLEVEL = SUBLEVEL = EXTRAVERSION = "" }
$1 == "VERSION"      { VERSION = $3 }
$1 == "PATCHLEVEL"   { PATCHLEVEL = $3 }
$1 == "SUBLEVEL"     { SUBLEVEL = $3 }
$1 == "EXTRAVERSION" { EXTRAVERSION = $3 }
END { print VERSION "." PATCHLEVEL "." SUBLEVEL EXTRAVERSION }' "${kernel_makefile}"
}

# string get_kernel_image_filename(string kernel_home = "$(get_kernel_home)")
#
# Get the absolute path of the image compiled for the passed kernel (defaulting
# to the current kernel): e.g.,
#
#     >>> get_kernel_image_filename /usr/src/linux-3.3.8
#     /usr/src/linux-3.3.8/arch/x86_64/boot/bzImage
get_kernel_image_filename() {
    # Localize and validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir "${kernel_home}"

    #FIXME: Need a "testify" here.
    # Find the passed kernel's compiled image in descending order of preference
    # (e.g., the "bzImage" big zip format is preferable to all other image
    # formats and hence listed first).
    get_file_first\
        "${kernel_home}/arch/$(get_architecture_name)/boot/"{bzImage,zImage,vmlinuz,vmlinux}
}

# ....................{ GETTERS ~ running                  }....................
# string get_running_kernel_version(void)
#
# Get the version number of the currently running kernel. If the current system
# has yet to be rebooted after installing a new kernel, this is not necessarily
# the same string that get_kernel_version() returns.
get_running_kernel_version() {
    die_if_args
    uname -r
}

# ....................{ WRITERS                            }....................
#FIXME: Implement! Should, in order:
#* Accept either an absolute or relative pathname. If absolute, is assumed to be
#  a "tar.bz2" archive having the kernel to be upgraded to; otherwise, to be the
#  basename of a directory under "/usr/src/". In the former case, transparently
#  unpack that archive into "/usr/src/", without overwriting any existing data.
#* Copy the "/usr/src/linux/.config" file, if present, into the new kernel dir.
#* Cd to the new kernel dir.
#* Run "make oldconfig".
#* If successful, forcefully overwrite the "/usr/src/linux" symlink. Defer to
#  using "eselect kernel", if available.
#* Cd back.
# void upgrade_kernel(string kernel_name)
#upgrade_kernel() {
#}

# void configure_kernel(string kernel_home = "$(get_kernel_home)")
#
# Interactively configure the passed kernel (defaulting to "/usr/src/linux").
configure_kernel() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"

    # Change the current directory to the passed kernel.
    set_current_dir "${kernel_home}"

    # Attempt to reconfigure the passed kernel.
    {
        # Rebuild the passed kernel.
        interactively say "configuring \"${kernel_home}\"..."
        make menuconfig
    # Revert the current directory to its prior path.
    } always {
        restore_current_dir
    }
}

# void make_kernel(string kernel_home = "$(get_kernel_home)")
#
# Rebuild and reinstall the passed kernel (defaulting to "/usr/src/linux") to
# the /boot partition as "/boot/kernel-${kernel_version}", a filename format
# implicitly expected by GRUB2.
make_kernel() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_home}/.config"\
        "\"${kernel_home}\" not yet configured; please run \"configure_kernel ${kernel_home}\""

    # Mount the "/boot" partition writably.
    mount_writable_boot_dir

    # Change the current directory to the passed kernel.
    set_current_dir "${kernel_home}"

    # Attempt to rebuild and reinstall the passed kernel.
    {
        # Rebuild the passed kernel.
        interactively say "making \"${kernel_home}\"..."
        make

        # Rebuild in-tree kernel modules.
        interactively say_next_section\
            "making \"${kernel_home}\" in-tree modules..."
        make modules_install

        # If Gentoo Linux, rebuild out-of-tree kernel modules.
        is_distro_gentoo and {
            interactively say_next_section\
                "making \"${kernel_home}\" out-of-tree modules..."
            if is_pathable module-rebuild
            then module-rebuild rebuild
            else cry '"module-rebuild" not installed.'
            fi
        }

        # Reinstall the passed kernel. Obtain the absolute path of its image only
        # after rebuilding the kernel, above.
        string kernel_version kernel_image_src kernel_image_trg
        kernel_version="$(get_kernel_version "${kernel_home}")"
        kernel_image_src="$(get_kernel_image_filename "${kernel_home}")"
        kernel_image_trg="/boot/kernel-${kernel_version}"
        interactively say_next_section\
            "installing \"${kernel_image_src}\" to \"${kernel_image_trg}\"..."
        copy_path_deeply "${kernel_image_src}" "${kernel_image_trg}"

        # If interactive, display the installed kernel image for verification.
        interactively list_path_verbosely "${kernel_image_trg}"
    # Revert the current directory to its prior path.
    } always {
        restore_current_dir
    }
}

# --------------------( WASTELANDS                         )--------------------
        #FIXME: It's a very minor point, but we can detect whether or not this
        #is the first build of this kernel to decide whether to print "building"
        #or "rebuilding". (Yes. *VERY* minor point. But why not get it right?)

    #FIXME: Rename set_current_dir() to set_current_dir(). Also,
    #set_current_dir() should *ALWAYS* "pushd", even if called non-interactively.
    #The reason is obvious, of course: no script should ever change the user's
    #current directory out from under him. Also, we need a new
    #revert_current_dir() function simply calling "popd" (and dying if the
    #directory stack is currently empty, of course).

#   print "${"$(get_kernel_home)"#*-}"

    #FIXME: Need a "testify" here.
    # Relative filename of the (typically compressed) kernel image, searching in
    # order of ordinary preference.
#   string kernel_filename="$(get_file_first "arch/${architecture_name}/boot/"{bzImage,zImage,vmlinuz,vmlinux})"

#FIXME: A more reliable implementation requires grepping the header (i.e., the
#first four lines) of "$(get_kernel_home)/Makefile" and then cobbling together a
#version specifier as follows:
#    print "${version}.${patchlevel}.${sublevel}${extraversion}"
#Actually, it'd be best to write an "awk" script.
    # Absolute path of the file responsible for compiling the passed kernel.
