#!/usr/bin/env zsh
# ====================[ kernel                             ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Kernel, handling *nix kernels.

# ....................{ GETTERS                            }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
# string get_kernel_home(void)
#
# Get the absolute path of the root directory for the current kernel: e.g.,
#
#     >>> get_kernel_home
#     /usr/src/linux
get_kernel_home() {
    die_if_args

    # Dismantled, this is:
    #
    # * '/usr/src/'*(/...), matching all subdirectories of "/usr/src" and hence
    #   installed kernel trees.
    # * "om", sorting such subdirectories by descending modification time.
    get_first_dir '/usr/src/linux' '/usr/src/'*(/om)
}

# string get_kernel_version(string kernel_home = get_kernel_home())
#
# Get the version number of the passed kernel (defaulting to the current
# kernel): e.g.,
#
#     >>> get_kernel_version /usr/src/linux-3.3.8
#     3.3.8
get_kernel_version() {
    # Localize and validate passed arguments.
    die_unless_no_or_one_arg 'expected optional kernel dirname'
    string kernel_home kernel_makefile
    kernel_home="${1:-$(get_kernel_home)}"
    kernel_makefile="${kernel_home}/Makefile"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_makefile}"

    # Parse the passed kernel's makefile for version specifiers.
    awk '
BEG { VERSION = PATCHLEVEL = SUBLEVEL = EXTRAVERSION = "" }
$1 == "VERSION"      { VERSION = $3 }
$1 == "PATCHLEVEL"   { PATCHLEVEL = $3 }
$1 == "SUBLEVEL"     { SUBLEVEL = $3 }
$1 == "EXTRAVERSION" { EXTRAVERSION = $3 }
END { print VERSION "." PATCHLEVEL "." SUBLEVEL EXTRAVERSION }' "${kernel_makefile}"
}

# string get_kernel_image_filename(string kernel_home = get_kernel_home())
#
# Get the absolute path of the image compiled for the passed kernel (defaulting
# to the current kernel): e.g.,
#
#     >>> get_kernel_image_filename /usr/src/linux-3.3.8
#     /usr/src/linux-3.3.8/arch/x86_64/boot/bzImage
get_kernel_image_filename() {
    # Localize and validate passed arguments.
    die_unless_no_or_one_arg 'expected optional kernel dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir "${kernel_home}"

    #FIXME: Need a "testify" here.
    # Find the passed kernel's compiled image in descending order of preference
    # (e.g., the "bzImage" big zip format is preferable to all other image
    # formats and hence listed first).
    get_first_file\
        "${kernel_home}/arch/$(get_architecture_name)/boot/"{bzImage,zImage,vmlinuz,vmlinux}
}

# ....................{ GETTERS ~ running                  }....................
# string get_running_kernel_version(void)
#
# Get the version number of the currently running kernel. If the current system
# has yet to be rebooted after installing a new kernel, this is not necessarily
# the same string that get_kernel_version() returns.
get_running_kernel_version() {
    die_if_args
    uname -r
}

# ....................{ WRITERS                            }....................
#FIXME: Implement! Should, in order:
#* Accept either an absolute or relative pathname. If absolute, is assumed to be
#  a "tar.bz2" archive having the kernel to be upgraded to; otherwise, to be the
#  basename of a directory under "/usr/src/". In the former case, transparently
#  unpack that archive into "/usr/src/", without overwriting any existing data.
#* Copy the "/usr/src/linux/.config" file, if present, into the new kernel dir.
#* Cd to the new kernel dir.
#* Run "make oldconfig".
#* If successful, forcefully overwrite the "/usr/src/linux" symlink. Defer to
#  using "eselect kernel", if available.
#* Cd back.
# void upgrade_kernel(string kernel_name)
#upgrade_kernel() {
#}

# void configure_kernel(string kernel_home = get_kernel_home())
#
# Interactively configure the passed kernel (defaulting to "/usr/src/linux").
configure_kernel() {
    # Localize passed arguments.
    die_unless_no_or_one_arg 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"

    # Change the current directory to the passed kernel.
    set_current_dir "${kernel_home}"

    # Attempt to reconfigure the passed kernel.
    {
        # Rebuild the passed kernel.
        interactively utter "configuring \"${kernel_home}\"..."
        make menuconfig
    # Revert the current directory to its prior path.
    } always {
        restore_current_dir
    }
}

# void make_kernel(string kernel_home = get_kernel_home())
#
# Rebuild and reinstall the passed kernel (defaulting to "/usr/src/linux") to
# the /boot partition as "/boot/kernel-${kernel_version}", a filename format
# implicitly expected by GRUB2.
make_kernel() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_home}/.config"\
        "\"${kernel_home}\" not yet configured; please run \"configure_kernel ${kernel_home}\""

    # Mount the "/boot" partition writably.
    mount_writable_boot_dir

    # Change the current directory to the passed kernel.
    set_current_dir "${kernel_home}"

    # Attempt to rebuild and reinstall the passed kernel.
    {
        # Rebuild the passed kernel.
        interactively utter "making \"${kernel_home}\"..."
        make

        # Rebuild in-tree kernel modules.
        interactively utter_next_section\
            "making \"${kernel_home}\" in-tree modules..."
        make modules_install

        # If Gentoo Linux, rebuild out-of-tree kernel modules.
        is_distro_gentoo and {
            interactively utter_next_section\
                "making \"${kernel_home}\" out-of-tree modules..."
            if is_installed module-rebuild
            then module-rebuild rebuild
            else curse '"module-rebuild" not installed.'
            fi
        }

        # Reinstall the passed kernel. Obtain the absolute path of its image only
        # after rebuilding the kernel, above.
        string kernel_version kernel_image_src kernel_image_trg
        kernel_version="$(get_kernel_version "${kernel_home}")"
        kernel_image_src="$(get_kernel_image_filename "${kernel_home}")"
        kernel_image_trg="/boot/kernel-${kernel_version}"
        interactively utter_next_section\
            "installing \"${kernel_image_src}\" to \"${kernel_image_trg}\"..."
        copy_path_physically "${kernel_image_src}" "${kernel_image_trg}"

        # If interactive, display the installed kernel image for verification.
        interactively list_path_verbosely "${kernel_image_trg}"
    # Revert the current directory to its prior path.
    } always {
        restore_current_dir
    }
}

# --------------------( WASTELANDS                         )--------------------
        #FIXME: It's a very minor point, but we can detect whether or not this
        #is the first build of this kernel to decide whether to print "building"
        #or "rebuilding". (Yes. *VERY* minor point. But why not get it right?)

    #FIXME: Rename set_current_dir() to set_current_dir(). Also,
    #set_current_dir() should *ALWAYS* "pushd", even if called non-interactively.
    #The reason is obvious, of course: no script should ever change the user's
    #current directory out from under him. Also, we need a new
    #revert_current_dir() function simply calling "popd" (and dying if the
    #directory stack is currently empty, of course).

#   print "${"$(get_kernel_home)"#*-}"

    #FIXME: Need a "testify" here.
    # Relative filename of the (typically compressed) kernel image, searching in
    # order of ordinary preference.
#   string kernel_filename="$(get_first_file "arch/${architecture_name}/boot/"{bzImage,zImage,vmlinuz,vmlinux})"

#FIXME: A more reliable implementation requires grepping the header (i.e., the
#first four lines) of "$(get_kernel_home)/Makefile" and then cobbling together a
#version specifier as follows:
#    print "${version}.${patchlevel}.${sublevel}${extraversion}"
#Actually, it'd be best to write an "awk" script.
    # Absolute path of the file responsible for compiling the passed kernel.

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#
# Copyright 2007-2012 by Cecil Curry.
#
#   http://www.raiazome.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
