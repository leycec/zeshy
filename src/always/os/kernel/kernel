#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *nix kernels.
-/-

# ....................{ GETTERS                            }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
declare_function_with_stdin <<'/---'
string get_kernel_home(void)

Get the absolute path of the root directory for the currently installed kernel:
e.g.,

.get_kernel_home()
==========================================
[source]
------------------------------------------
>>> get_kernel_home
/usr/src/linux
------------------------------------------
==========================================
/---
function get_kernel_home() {
    # Dismantled, this is:
    #
    # * '/usr/src/'*(/...), matching all subdirectories of "/usr/src" and hence
    #   installed kernel trees.
    # * "om", sorting such subdirectories by descending modification time.
    die_if_args
    get_dir_first '/usr/src/linux' '/usr/src/'*(/om)
}

declare_function_with_stdin <<'/---'
string get_kernel_version(string kernel_home = "$(get_kernel_home)")

Get the version number of the passed kernel (defaulting to the currently
installed kernel): e.g.,

.get_kernel_version()
==========================================
[source]
------------------------------------------
>>> get_kernel_version /usr/src/linux-3.3.8
3.3.8
------------------------------------------
==========================================
/---
function get_kernel_version() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home kernel_makefile
    kernel_home="${1:-$(get_kernel_home)}"
    kernel_makefile="${kernel_home}/Makefile"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_makefile}"

    #FIXME: zeshify. Not terribly hard, using
    #for_string_line_fields_split_on_whitespace().

    # Parse the passed kernel's makefile for version specifiers.
    awk '
BEG { VERSION = PATCHLEVEL = SUBLEVEL = EXTRAVERSION = "" }
$1 == "VERSION"      { VERSION = $3 }
$1 == "PATCHLEVEL"   { PATCHLEVEL = $3 }
$1 == "SUBLEVEL"     { SUBLEVEL = $3 }
$1 == "EXTRAVERSION" { EXTRAVERSION = $3 }
END { print VERSION "." PATCHLEVEL "." SUBLEVEL EXTRAVERSION }' "${kernel_makefile}"
}

#FIXME: Rename to get_kernel_image().
declare_function_with_stdin <<'/---'
string get_kernel_image_filename(string kernel_home = "$(get_kernel_home)")

Get the absolute path of the image compiled for the passed kernel (defaulting
to the currently installed kernel). If no such : e.g.,

.get_kernel_image_filename()
==========================================
[source]
------------------------------------------
>>> get_kernel_image_filename /usr/src/linux-3.3.8
/usr/src/linux-3.3.8/arch/x86_64/boot/bzImage
------------------------------------------
==========================================
/---
function get_kernel_image_filename() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir "${kernel_home}"

    # Find the passed kernel's compiled image in descending order of preference
    # (e.g., the "bzImage" big zip format is preferable to all other image
    # formats and hence listed first).
    get_file_first\
        "${kernel_home}/arch/$(get_architecture)/boot/"{bzImage,zImage,vmlinuz,vmlinux}
}

# ....................{ GETTERS ~ running                  }....................
#FIXME: Shift to new parcel "os/kernel/running".
#FIXME: Rename to get_kernel_version_running().
declare_function_with_stdin <<'/---'
string get_running_kernel_version(void)

Get the version number of the currently running kernel. If the current system
has yet to be rebooted after installing a new kernel, this is not necessarily
the same string that get_kernel_version() returns.
/---
function get_running_kernel_version() {
    die_if_args
    uname -r
}

# ....................{ CONFIGURERS                        }....................
#FIXME: Implement! Should, in order:
#* Accept either an absolute or relative pathname. If absolute, is assumed to be
#  a "tar.bz2" archive having the kernel to be upgraded to; otherwise, to be the
#  basename of a directory under "/usr/src/". In the former case, transparently
#  unpack that archive into "/usr/src/", without overwriting any existing data.
#* Copy the "/usr/src/linux/.config" file, if present, into the new kernel dir.
#* Cd to the new kernel dir.
#* Run "make oldconfig".
#* If successful, forcefully overwrite the "/usr/src/linux" symlink. Defer to
#  using "eselect kernel", if available.
#* Cd back.
# void upgrade_kernel(string kernel_name)
#upgrade_kernel() {
#}

declare_function_with_stdin <<'/---'
void configure_kernel(string kernel_home = "$(get_kernel_home)")

Interactively configure the passed kernel (defaulting to the current kernel).
/---
function configure_kernel() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"

    # Change the current directory to the passed kernel.
    store_dir "${kernel_home}"

    # Attempt to reconfigure the passed kernel.
    {
        # Rebuild the passed kernel.
        print_message_item "configuring \"${kernel_home}\"..."
        command make menuconfig
    # Revert the current directory to its prior path.
    } always {
        restore_dir
    }
}

# ....................{ MAKERS                             }....................
#FIXME: Add synonym for update_kernel().
declare_function_with_stdin <<'/---'
void make_kernel(string kernel_home = "$(get_kernel_home)")

Rebuild and reinstall the passed kernel (defaulting to the current kernel) to
the boot partition as `/boot/kernel-${kernel_version}`, a filename format
implicitly expected by GRUB2.
/---
function make_kernel() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'
    string\
        kernel_home\
        kernel_version\
        kernel_image_source\
        kernel_image_target
    kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir "${kernel_home}"

    #FIXME: Let's be less fatalistic. If such file does not exist, simply call
    #config_kernel() instead.
    die_unless_file "${kernel_home}/.config"\
        "\"${kernel_home}\" not yet configured; please run \"configure_kernel ${kernel_home}\""

    # Mount the "/boot" partition writably.
    mount_boot_dir_writable

    # Change the current directory to the passed kernel.
    store_dir "${kernel_home}"

    # Attempt to rebuild and reinstall the passed kernel.
    {
        # Rebuild the passed kernel.
        print_message_item "making \"${kernel_home}\"..."
        command make

        # Rebuild in-tree kernel modules.
        print_message_item "making \"${kernel_home}\" in-tree modules..."
        command make modules_install

        #FIXME: This suggests the need for externally addable kernel
        #compilation-specific hooks (e.g., for installing firmware, modules,
        #and so on). Add such function to this parcel, named
        #run_hook_after_kernel_make().
        #FIXME: Interesting. This step fails if enabling "make.conf" FEATURE
        #"userpriv" *AND* if the currently installed kernel has no user-readable
        #execute/read permissions on directory
        #"/usr/src/linux/included/generated". Clearly, if "module-rebuild" is
        #pathable, check whether or not such directory is user-readable and, if
        #not, enable such permissions after interactively asking the current user
        #whether or not to do so. (Could be unsafe, but shouldn't be, so... ask!)
        #FIXME: If "module-rebuild" isn't installed, ask the current user whether
        #they'd like us to install such package for them.

        # If Gentoo Linux, rebuild out-of-tree kernel modules.
        if { is_distro_gentoo } {
            print_message_item\
                "making \"${kernel_home}\" out-of-tree modules..."

            if { is_pathable module-rebuild } {
                command module-rebuild rebuild
            } else {
                print_warning '"module-rebuild" uninstalled'
            }
        }

        # Kernel version to be installed.
        kernel_version="$(get_kernel_version "${kernel_home}")"

        # Kernel image built above.
        kernel_image_source="$(get_kernel_image_filename "${kernel_home}")"

        # Kernel image target under the boot partition.
        kernel_image_target="/boot/kernel-${kernel_version}"

        # Copy the former to latter. For verification, list such target as well.
        print_message_item\
            "copying \"${kernel_image_source}\" to \"${kernel_image_target}\"..."
        copy_path_deeply    "${kernel_image_source}" "${kernel_image_target}"
        list_path_verbosely "${kernel_image_target}"
    # Revert the current directory to its prior path.
    } always {
        restore_dir
    }
}

# --------------------( WASTELANDS                         )--------------------
        # Reinstall the (usually compressed) image for such kernel built above. Obtain the absolute path of its image only
        # after rebuilding the kernel, above.
        # Display the installed kernel image for verification.

#       print_message_item "listing \"${kernel_image_target}\"..."
# Actually, this is one of the few
#times where we should just use a default argument. Centralize this with the
#existing get_kernel_version() above, if passed no arguments.
        #FUXME: Doesn't this need to happen only on kernel *UPGRADES*, not every
        #kernel compilation? I definitely reckon so.
        #FUXME: It's a very minor point, but we can detect whether or not this
        #is the first build of this kernel to decide whether to print "building"
        #or "rebuilding". (Yes. *VERY* minor point. But why not get it right?)

    #FUXME: Rename set_dir() to set_dir(). Also,
    #set_dir() should *ALWAYS* "pushd", even if called non-interactively.
    #The reason is obvious, of course: no script should ever change the user's
    #current directory out from under him. Also, we need a new
    #revert_current_dir() function simply calling "popd" (and dying if the
    #directory stack is currently empty, of course).

#   print "${"$(get_kernel_home)"#*-}"

    #FUXME: Need a "testify" here.
    # Relative filename of the (typically compressed) kernel image, searching in
    # order of ordinary preference.
#   string kernel_filename="$(get_file_first "arch/${architecture_name}/boot/"{bzImage,zImage,vmlinuz,vmlinux})"

#FUXME: A more reliable implementation requires grepping the header (i.e., the
#first four lines) of "$(get_kernel_home)/Makefile" and then cobbling together a
#version specifier as follows:
#    print "${version}.${patchlevel}.${sublevel}${extraversion}"
#Actually, it'd be best to write an "awk" script.
    # Absolute path of the file responsible for compiling the passed kernel.
