#!/usr/bin/env zsh
# ====================[ kernel                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *nix kernels.

# ....................{ GETTERS                            }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
declare_function '
string get_kernel_home(void)

Get the absolute path of the root directory for the current kernel: e.g.,

    >>> get_kernel_home
    /usr/src/linux
'
function get_kernel_home() {
    # Dismantled, this is:
    #
    # * '/usr/src/'*(/...), matching all subdirectories of "/usr/src" and hence
    #   installed kernel trees.
    # * "om", sorting such subdirectories by descending modification time.
    die_if_args
    get_dir_first '/usr/src/linux' '/usr/src/'*(/om)
}

declare_function '
string get_kernel_version(string kernel_home = "$(get_kernel_home)")

Get the version number of the passed kernel (defaulting to the current
kernel): e.g.,

    >>> get_kernel_version /usr/src/linux-3.3.8
    3.3.8
'
function get_kernel_version() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home kernel_makefile
    kernel_home="${1:-$(get_kernel_home)}"
    kernel_makefile="${kernel_home}/Makefile"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_makefile}"

    #FIXME: This worth Zeshying?
    # Parse the passed kernel's makefile for version specifiers.
    awk '
BEG { VERSION = PATCHLEVEL = SUBLEVEL = EXTRAVERSION = "" }
$1 == "VERSION"      { VERSION = $3 }
$1 == "PATCHLEVEL"   { PATCHLEVEL = $3 }
$1 == "SUBLEVEL"     { SUBLEVEL = $3 }
$1 == "EXTRAVERSION" { EXTRAVERSION = $3 }
END { print VERSION "." PATCHLEVEL "." SUBLEVEL EXTRAVERSION }' "${kernel_makefile}"
}

declare_function '
string get_kernel_image_filename(string kernel_home = "$(get_kernel_home)")

Get the absolute path of the image compiled for the passed kernel (defaulting
to the current kernel): e.g.,

    >>> get_kernel_image_filename /usr/src/linux-3.3.8
    /usr/src/linux-3.3.8/arch/x86_64/boot/bzImage
'
function get_kernel_image_filename() {
    # Localize and validate passed arguments.
    die_unless_args_0_to_1 'expected optional kernel dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir "${kernel_home}"

    #FIXME: Need a "testify" here.
    # Find the passed kernel's compiled image in descending order of preference
    # (e.g., the "bzImage" big zip format is preferable to all other image
    # formats and hence listed first).
    get_file_first\
        "${kernel_home}/arch/$(get_architecture_name)/boot/"{bzImage,zImage,vmlinuz,vmlinux}
}

# ....................{ GETTERS ~ running                  }....................
#FIXME: Rename to get_kernel_version_running().
declare_function '
string get_running_kernel_version(void)

Get the version number of the currently running kernel. If the current system
has yet to be rebooted after installing a new kernel, this is not necessarily
the same string that get_kernel_version() returns.
'
function get_running_kernel_version() {
    die_if_args
    uname -r
}

# ....................{ WRITERS                            }....................
#FIXME: Implement! Should, in order:
#* Accept either an absolute or relative pathname. If absolute, is assumed to be
#  a "tar.bz2" archive having the kernel to be upgraded to; otherwise, to be the
#  basename of a directory under "/usr/src/". In the former case, transparently
#  unpack that archive into "/usr/src/", without overwriting any existing data.
#* Copy the "/usr/src/linux/.config" file, if present, into the new kernel dir.
#* Cd to the new kernel dir.
#* Run "make oldconfig".
#* If successful, forcefully overwrite the "/usr/src/linux" symlink. Defer to
#  using "eselect kernel", if available.
#* Cd back.
# void upgrade_kernel(string kernel_name)
#upgrade_kernel() {
#}

declare_function '
void configure_kernel(string kernel_home = "$(get_kernel_home)")

Interactively configure the passed kernel (defaulting to "/usr/src/linux").
'
function configure_kernel() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"

    # Change the current directory to the passed kernel.
    set_current_dir "${kernel_home}"

    # Attempt to reconfigure the passed kernel.
    {
        # Rebuild the passed kernel.
        print_message "configuring \"${kernel_home}\"..."
        make menuconfig
    # Revert the current directory to its prior path.
    } always {
        restore_current_dir
    }
}

#FIXME: Add synonym for update_kernel().
declare_function '
void make_kernel(string kernel_home = "$(get_kernel_home)")

Rebuild and reinstall the passed kernel (defaulting to "/usr/src/linux") to
the /boot partition as "/boot/kernel-${kernel_version}", a filename format
implicitly expected by GRUB2.
'
function make_kernel() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'
    string kernel_home; kernel_home="${1:-$(get_kernel_home)}"
    die_unless_dir  "${kernel_home}"
    die_unless_file "${kernel_home}/.config"\
        "\"${kernel_home}\" not yet configured; please run \"configure_kernel ${kernel_home}\""

    # Mount the "/boot" partition writably.
    mount_boot_partition_writable

    # Change the current directory to the passed kernel.
    set_current_dir "${kernel_home}"

    # Attempt to rebuild and reinstall the passed kernel.
    {
        # Rebuild the passed kernel.
        print_message "making \"${kernel_home}\"..."
        make

        # Rebuild in-tree kernel modules.
        print_newline
        print_message "making \"${kernel_home}\" in-tree modules..."
        make modules_install

        #FIXME: This suggests the need for externally addable kernel
        #compilation-specific hooks (e.g., for installing firmware, modules,
        #and so on).
        #FIXME: Interesting. This step fails if enabling "make.conf" FEATURE
        #"userpriv" *AND* if the currently installed kernel has no user-readable
        #execute/read permissions on directory
        #"/usr/src/linux/included/generated". Clearly, if "module-rebuild" is
        #pathable, check whether or not such directory is user-readable and, if
        #not, enable such permissions after interactively asking the current user
        #whether or not to do so. (Could be unsafe, but shouldn't be, so... ask!)

        # If Gentoo Linux, rebuild out-of-tree kernel modules.
        is_distro_gentoo and {
            print_newline
            print_message "making \"${kernel_home}\" out-of-tree modules..."
            if is_pathable module-rebuild
            then module-rebuild rebuild
            else print_warning '"module-rebuild" not installed.'
            fi
        }

        # Reinstall the passed kernel. Obtain the absolute path of its image only
        # after rebuilding the kernel, above.
        string kernel_version kernel_image_src kernel_image_trg
        kernel_version="$(get_kernel_version "${kernel_home}")"
        kernel_image_src="$(get_kernel_image_filename "${kernel_home}")"
        kernel_image_trg="/boot/kernel-${kernel_version}"
        print_newline
        print_message "installing \"${kernel_image_src}\" to \"${kernel_image_trg}\"..."
        copy_path_deeply "${kernel_image_src}" "${kernel_image_trg}"

        # Display the installed kernel image for verification.
        print_message "listing \"${kernel_image_trg}\"..."
        list_path_verbosely "${kernel_image_trg}"
    # Revert the current directory to its prior path.
    } always {
        restore_current_dir
    }
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Doesn't this need to happen only on kernel *UPGRADES*, not every
        #kernel compilation? I definitely reckon so.
        #FUXME: It's a very minor point, but we can detect whether or not this
        #is the first build of this kernel to decide whether to print "building"
        #or "rebuilding". (Yes. *VERY* minor point. But why not get it right?)

    #FUXME: Rename set_current_dir() to set_current_dir(). Also,
    #set_current_dir() should *ALWAYS* "pushd", even if called non-interactively.
    #The reason is obvious, of course: no script should ever change the user's
    #current directory out from under him. Also, we need a new
    #revert_current_dir() function simply calling "popd" (and dying if the
    #directory stack is currently empty, of course).

#   print "${"$(get_kernel_home)"#*-}"

    #FUXME: Need a "testify" here.
    # Relative filename of the (typically compressed) kernel image, searching in
    # order of ordinary preference.
#   string kernel_filename="$(get_file_first "arch/${architecture_name}/boot/"{bzImage,zImage,vmlinuz,vmlinux})"

#FUXME: A more reliable implementation requires grepping the header (i.e., the
#first four lines) of "$(get_kernel_home)/Makefile" and then cobbling together a
#version specifier as follows:
#    print "${version}.${patchlevel}.${sublevel}${extraversion}"
#Actually, it'd be best to write an "awk" script.
    # Absolute path of the file responsible for compiling the passed kernel.
