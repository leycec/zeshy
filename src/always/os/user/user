#!/usr/bin/env zsh
# ====================[ user                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle local users and groups.

#FIXME: Hmm. We don't care about being the exact superuser (UID 0) as being a
#user with sufficient superuser privelages. Should users in group "wheel" also
#be considered superuser for such purposes? In such case, the name "_superuser"
#still applies but should simply be extended to include logical superusers. In
#this case, however, we'll want to distinguish logical from physical superusers
#(e.g., since UID 0 receives a different $PATH). Anyway.... contemplate. Hmmmmm.
#
#No, I suppose not. Wheel users are required to sudo to access such permissions,
#implying we'd need augment any function calling die_unless_current_user_superuser() with
#support for run_as_superuser(). We certainly should do so, eventually. But it
#can wait, somewhat.

# ....................{ TESTERS                            }....................
#FIXME: This is pretty banal, frankly. Do we actually ever call this anywhere? I
#suspect not. What we *REALLY* want to know is whether the passed user has
#theoretical access to superuser privelages -- either because such user is the
#superuser or in a group with escalatable privelages (e.g., "wheel").
# boolean is_user_superuser(string username)
#
# Return true if the passed user (defaulting to the current user) is the
# superuser (i.e., root).
function is_user_superuser() {
    #FIXME: Shoddy. Ideally, we should be testing on UIDs even if the caller passed a
    #username. This implies we require a method for mapping between the two.
    #Should be trivially feasible. Grep us up. At the very least, we can test
    #whether the passed argument is the current username and perform such test
    #if true.
    die_unless_arg 'expected one username'
    is "${1}" == root si
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_user_pid_dir().
# string get_pid_dir(string username = "$(get_current_user)")
#
# Get the absolute path of the directory writable by the passed user (defaulting
# to the current user) containing process ID files (i.e., files whose filenames
# are commands and containing the process IDs of such commands, when run): e.g.,
#
#     >>> get_pid_dir root
#     /run
#     >>> get_pid_dir sentient_6
#     /home/sentient_6/.zeshy/run
function get_pid_dir() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional username'
    string username; username="${1:-$(get_current_user)}"
    die_unless_user "${username}"

    # If the passed user is the superuser, return the POSIX path for such files.
    if is_current_user_superuser "${username}"
    then get_dir_first '/run' '/var/run'
    # Otherwise, return the user-specific Zeshy path for such files.
    else print_string "$(get_user_zeshy_dot_dir "${username}")/run"
    fi
}

#FIXME: Rename to get_user_pid_file_for_command() and switch parameter order.
# string get_pid_file(
#   string command_name, string username = "$(get_current_user)")
#
# Get the absolute path of the file writable by the passed user containing the
# process ID of the passed command, when running: e.g.,
#
#     >>> get_pid_file enslaved sentient_7
#     /home/sentient_7/.zeshy/run/enslaved
function get_pid_file() {
    # Validate passed arguments.
    die_unless_args_1_to_2 'expected command name and optional username'
    string command_name="${1}" username
    username="${2:-$(get_current_user)}"
    die_unless_pathable "${command_name}"

    # Get Zeshy's PID directory.
    print_string "$(get_pid_dir "${username}")/${command_name}"
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_file "${filename}"
#   die_unless_file "${filename}"

    # Validate passed arguments.
#   string username="${1}" users
#   users="$(get_users_file_contents)"
#   is_string_line_match_pcre "${users}" "^${username}:"
    # Get the contents of "/etc/passwd".
    # Match the passed group against such contents.
#   users="$(split_columns_from_lines "${users_file_contents}" ':' 1)"
#   say "users: ${users}"
