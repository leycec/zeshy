#!/usr/bin/env zsh
# ====================[ user                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy User, handling operating system-level users and groups.

#FIXME: Hmm. We don't care about being the exact superuser (UID 0) as being a
#user with sufficient superuser privelages. Should users in group "wheel" also
#be considered superuser for such purposes? In such case, the name "_superuser"
#still applies but should simply be extended to include logical superusers. In
#this case, however, we'll want to distinguish logical from physical superusers
#(e.g., since UID 0 receives a different $PATH). Anyway.... contemplate. Hmmmmm.
#
#No, I suppose not. Wheel users are required to sudo to access such permissions,
#implying we'd need augment any function calling die_unless_superuser() with
#support for run_as_superuser(). We certainly should do so, eventually. But it
#can wait, somewhat.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_superuser(string error_message = 'not the superuser')
#
# Throw an exception unless the current user is the superuser (i.e., root).
die_unless_superuser() {
    die_unless_no_or_one_arg 'expected optional error message'
    is_superuser or die "${1:-\"$(get_current_username)\" not the superuser}"
}

# ....................{ EXCEPTIONS ~ local                 }....................
# void die_unless_local_group(
#   string group_name, string error_message = 'not a group')
#
# Throw an exception unless the passed group exists on the current machine.
die_unless_local_group() {
    die_unless_one_or_two_args\
        'expected one group name and optional error message'
    string group_name="${1}"
    is_local_group "${group_name}" or die "${2:-\"${group_name}\" not a group}"
}

# void die_unless_local_user(
#   string username, string error_message = 'not a user')
#
# Throw an exception unless the passed user exists on the current machine.
die_unless_local_user() {
    die_unless_one_or_two_args\
        'expected one username and optional error message'
    string username="${1}"
    is_local_user "${username}" or die "${2:-\"${username}\" not a user}"
}

# ....................{ TESTS                              }....................
# bool is_superuser(string username = get_current_username())
#
# Return true if the passed user (defaulting to the current) is the superuser.
is_superuser() {
    die_unless_no_or_one_arg 'expected optional username'

    #FIXME: Ideally, we should be testing on UIDs even if the caller passed a
    #username. This implies we require a method for mapping between the two.
    #Should be trivially feasible. Grep us up. At the very least, we can test
    #whether the passed argument is the current username and perform such test
    #if true.
    # If no arguments were passed, default to the current user. If such user's
    # effective user ID (e.g., due perhaps to privelage escalation under
    # "setuid") is that of the superuser, return true.
    is_no_args and is "${EUID}" -eq 0 si and return_true

    # Test.
    is  "${1:-$(get_current_username)}" == 'root' si
}

# ....................{ TESTS ~ local                      }....................
# void is_local_group(string group_name)
#
# Return true if the passed group exists on the current machine.
is_local_group() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one group name'
    string group_name="${1}" groups
    groups="$(get_local_groups_file_contents)"
    is_string_pcre_line_match "${groups}" "^${group_name}:"
}

# void is_local_user(string username)
#
# Return true if the passed user exists on the current machine.
is_local_user() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one username'
    string username="${1}" users
    users="$(get_local_users_file_contents)"
    is_string_pcre_line_match "${users}" "^${username}:"
}

# ....................{ GETTERS                            }....................
# string get_current_username(void)
#
# Get the username of the current user.
get_current_username() {
    die_if_args
    sputter "${USER}"
}

# ....................{ GETTERS ~ paths                    }....................
# string get_user_home(string username = get_current_username())
#
# Get the absolute path of the home directory of the passed user (defaulting to
# the current user).
get_user_home() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional username'

    # If passed no arguments, return the current user's home.
    if is_no_args
    then sputter "${HOME}"
    else
        # Get the contents of "/etc/passwd".
        string username="${1}" users
        die_unless_local_user "${username}"

        # Match the passed user against such contents.
        users="$(get_local_users_file_contents)"
        get_string_pcre_first_line_match\
            "${users}" "^${username}:([^:]*:){4}([^:]*):" 2
    fi
}

# string get_zeshy_dot_dir(string username = get_current_username())
#
# Get the absolute path of the Zeshy dot directory for the passed user
# (defaulting to the current user): e.g.,
#
#     >>> get_local_user_zeshy_dot_dir
#     /home/lydia/.zeshy/run
get_zeshy_dot_dir() {
    die_unless_no_or_one_arg 'expected optional username'
    string home; home="$(get_user_home "${@}")"
    sputter "${home}/${ZESHY_DOT_DIR_BASENAME}"
}

# string get_pid_dir(string username = get_current_username())
#
# Get the absolute path of the directory writable by the passed user (defaulting
# to the current user) containing process ID files (i.e., files whose filenames
# are commands and containing the process IDs of such commands, when run): e.g.,
#
#     >>> get_pid_dir root
#     /run
#     >>> get_pid_dir sentient_6
#     /home/sentient_6/.zeshy/run
get_pid_dir() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional username'
    string username="${1:-$(get_current_username)}"
    die_unless_local_user "${username}"

    # If the passed user is the superuser, return the POSIX path for such files.
    if is_superuser "${username}"
    then get_first_dir '/run' '/var/run'
    # Otherwise, return the user-specific Zeshy path for such files.
    else
        string zeshy_dot_dir; zeshy_dot_dir="$(get_zeshy_dot_dir "${username}")"
        sputter "${zeshy_dot_dir}/run"
    fi
}

# string get_pid_file(
#   string command_name, string username = get_current_username())
#
# Get the absolute path of the file writable by the passed user containing the
# process ID of the passed command, when running: e.g.,
#
#     >>> get_pid_file enslaved sentient_7
#     /home/sentient_7/.zeshy/run/enslaved
get_pid_file() {
    # Validate passed arguments.
    die_unless_one_or_two_args 'expected command name and optional username'
    string command_name="${1}" username="${2:-$(get_current_username)}"
    die_unless_installed "${command_name}"
    die_unless_local_user "${username}"

    # Get Zeshy's PID directory.
    string pid_dir; pid_dir="$(get_pid_dir "${username}")"
    sputter "${pid_dir}/${command_name}"
}

# ....................{ GETTERS ~ paths ~ local            }....................
# string get_local_groups_file(void)
#
# Get the absolute path of the system-wide groups file.
get_local_groups_file() {
    die_if_args
    string filename='/etc/group'
    die_unless_file "${filename}"
    sputter "${filename}"
}

# string get_local_users_file(void)
#
# Get the absolute path of the system-wide users file.
get_local_users_file() {
    die_if_args
    string filename='/etc/passwd'
    die_unless_file "${filename}"
    sputter "${filename}"
}

# string get_local_groups_file_contents(void)
#
# Get the contents of the system-wide groups file.
get_local_groups_file_contents() {
    die_if_args
    string filename; filename="$(get_local_groups_file)"
    print_text_file "${filename}"
}

# string get_local_users_file_contents(void)
#
# Get the contents of the system-wide users file.
get_local_users_file_contents() {
    die_if_args
    string filename; filename="$(get_local_users_file)"
    print_text_file "${filename}"
}

# --------------------( WASTELANDS                         )--------------------
    # Get the contents of "/etc/passwd".
    # Match the passed group against such contents.
#   users="$(split_columns_from_lines "${users_file_contents}" ':' 1)"
#   utter "users: ${users}"
