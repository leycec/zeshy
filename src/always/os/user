#!/usr/bin/env zsh
# ====================[ user                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle operating system-level users and groups.

#FIXME: Hmm. We don't care about being the exact superuser (UID 0) as being a
#user with sufficient superuser privelages. Should users in group "wheel" also
#be considered superuser for such purposes? In such case, the name "_superuser"
#still applies but should simply be extended to include logical superusers. In
#this case, however, we'll want to distinguish logical from physical superusers
#(e.g., since UID 0 receives a different $PATH). Anyway.... contemplate. Hmmmmm.
#
#No, I suppose not. Wheel users are required to sudo to access such permissions,
#implying we'd need augment any function calling die_unless_superuser() with
#support for run_as_superuser(). We certainly should do so, eventually. But it
#can wait, somewhat.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_superuser(
#   string username = "$(get_current_user)",
#   string error_message = "\"${username}\" not a superuser")
#
# Throw an exception unless the passed user (defaulting to the current user) is
# the superuser (i.e., root).
die_unless_superuser() {
    die_unless_no_or_one_arg 'expected optional username and error message'
    string username="${1:-$(get_current_user)}"
    is_superuser "${username}" or
        die "${2:-\"${username}\" not a superuser}"
}

# void die_unless_group(
#   string group_name,
#   string error_message = "\"${group_name}\" not a group")
#
# Throw an exception unless the passed group exists.
die_unless_group() {
    die_unless_one_or_two_args\
        'expected one group name and optional error message'
    string group_name="${1}"
    is_group "${group_name}" or die "${2:-\"${group_name}\" not a group}"
}

# void die_unless_user(
#   string username,
#   string error_message = "\"${username}\" not a user")
#
# Throw an exception unless the passed user exists.
die_unless_user() {
    die_unless_one_or_two_args\
        'expected one username and optional error message'
    string username="${1}"
    is_user "${username}" or die "${2:-\"${username}\" not a user}"
}

# ....................{ TESTERS                            }....................
# boolean is_superuser(string username = "$(get_current_user)")
#
# Return true if the passed user (defaulting to the current user) is the
# superuser (i.e., root).
is_superuser() {
    die_unless_no_or_one_arg 'expected optional username'

    #FIXME: Ideally, we should be testing on UIDs even if the caller passed a
    #username. This implies we require a method for mapping between the two.
    #Should be trivially feasible. Grep us up. At the very least, we can test
    #whether the passed argument is the current username and perform such test
    #if true.
    # If no arguments were passed, default to the current user. If such user's
    # effective user ID (e.g., due perhaps to privelage escalation under
    # "setuid") is that of the superuser, return true.
    is_no_args and is "${EUID}" -eq 0 si and return_true

    # Test.
    is  "${1:-$(get_current_user)}" == 'root' si
}

# boolean is_group(string group_name)
#
# Return true if the passed group exists.
is_group() {
    die_unless_one_arg 'expected one group name'
    get_groups_file_contents | is_string_pcre_line_match "^${1}:"
}

# boolean is_user(string username)
#
# Return true if the passed user exists.
is_user() {
    die_unless_one_arg 'expected one username'
    get_users_file_contents | is_string_pcre_line_match "^${1}:"
}

# ....................{ GETTERS                            }....................
# string get_current_user(void)
#
# Get the username of the current user.
get_current_user() {
    die_if_args
    output_string "${USER}"
}

# ....................{ GETTERS ~ system                   }....................
# string get_groups_file(void)
#
# Get the absolute path of the system-wide groups file.
get_groups_file() {
    die_if_args
    output_string '/etc/group'
}

# string get_users_file(void)
#
# Get the absolute path of the system-wide users file.
get_users_file() {
    die_if_args
    output_string '/etc/passwd'
}

# string get_groups_file_contents(void)
#
# Get the contents of the system-wide groups file.
get_groups_file_contents() {
    die_if_args
    print_text_file "$(get_group_file)"
}

# string get_users_file_contents(void)
#
# Get the contents of the system-wide users file.
get_users_file_contents() {
    die_if_args
    print_text_file "$(get_users_file)"
}

# ....................{ GETTERS ~ paths                    }....................
# string get_user_home(string username = "$(get_current_user)")
#
# Get the absolute path of the home directory of the passed user (defaulting to
# the current user).
get_user_home() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional username'

    # If passed no arguments, return the current user's home.
    if is_no_args
    then output_string "${HOME}"
    else
        # Get the contents of "/etc/passwd".
        string username="${1}" users
        die_unless_user "${username}"

        # Match the passed user against such contents.
        users="$(get_users_file_contents)"
        get_string_pcre_first_line_match\
            "${users}" "^${username}:([^:]*:){4}([^:]*):" 2
    fi
}

#FIXME: Rename get_user_pid_dir().
# string get_pid_dir(string username = "$(get_current_user)")
#
# Get the absolute path of the directory writable by the passed user (defaulting
# to the current user) containing process ID files (i.e., files whose filenames
# are commands and containing the process IDs of such commands, when run): e.g.,
#
#     >>> get_pid_dir root
#     /run
#     >>> get_pid_dir sentient_6
#     /home/sentient_6/.zeshy/run
get_pid_dir() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional username'
    string username; username="${1:-$(get_current_user)}"
    die_unless_user "${username}"

    # If the passed user is the superuser, return the POSIX path for such files.
    if is_superuser "${username}"
    then get_first_dir '/run' '/var/run'
    # Otherwise, return the user-specific Zeshy path for such files.
    else output_string "$(get_user_zeshy_dot_dir "${username}")/run"
    fi
}

# string get_pid_file(
#   string command_name, string username = "$(get_current_user)")
#
# Get the absolute path of the file writable by the passed user containing the
# process ID of the passed command, when running: e.g.,
#
#     >>> get_pid_file enslaved sentient_7
#     /home/sentient_7/.zeshy/run/enslaved
get_pid_file() {
    # Validate passed arguments.
    die_unless_one_or_two_args 'expected command name and optional username'
    string command_name="${1}" username
    username="${2:-$(get_current_user)}"
    die_unless_installed "${command_name}"

    # Get Zeshy's PID directory.
    output_string "$(get_pid_dir "${username}")/${command_name}"
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_file "${filename}"
#   die_unless_file "${filename}"

    # Validate passed arguments.
#   string username="${1}" users
#   users="$(get_users_file_contents)"
#   is_string_pcre_line_match "${users}" "^${username}:"
    # Get the contents of "/etc/passwd".
    # Match the passed group against such contents.
#   users="$(split_columns_from_lines "${users_file_contents}" ':' 1)"
#   say "users: ${users}"
