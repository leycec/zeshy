#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *processes* (i.e., currently running commands).
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void :die_unless_process(
    string command_name,
    string error_message = "No process running command \"${command_name}\".")

Throw an exception with the passed message unless the passed command is
currently running under some user.
/---
function :die_unless_process() {
    die_unless_args_1_to_2\
        'Expected one command name and optional error message.'
    :string command_name="${1}"
    :is_process "${command_name}" or
        die "${2-No process running command \"${command_name}\".}"
}

declare_function_with_stdin <<'/---'
void :die_unless_process_under_user(
    string command_name,
    string username,
    string error_message =
        "No process running command \"${command_name}\" under user ${username}.")

Throw an exception with the passed message unless the passed command is running
under the passed user.
/---
function :die_unless_process_under_user() {
    die_unless_args_2_to_3\
        'Expected one command name, one username, and optional error message.'
    :string command_name="${1}" username="${2}"
    :is_process_under_user "${username}" "${command_name}" or
        die "${3-No process running command \"${command_name}\" under user ${username}.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_process(string command_name)

Report success if there exists at least one process running the passed command
under _any_ user.
/---
function :is_process() {
    die_unless_arg 'Expected one command name.'
    :string process_pids
    :set_list_to_process_pids_if_found process_pids "${1}"
}

#FIXME: Ugh. Reimplement this in terms of a new setter, as above.
declare_function_with_stdin <<'/---'
[status: bool] :is_process_under_user(string command_name, string username)

Report success if there exists at least one process running the passed command
under the passed user.
/---
function :is_process_under_user() {
    die_unless_args_2 'Expected one command name and one username.'
    { get_pids_running_command_under_user_if_found "${@}" } silent:
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void :set_list_to_process_pids(string list_name, string command_name)

Set the passed list (ideally, list set) to the PIDs of all processes currently
running the passed command (in arbitrary order) if at least one such process
exists or throw an exception otherwise. See
:set_list_to_process_pids_if_found() for further details.
/---
function :set_list_to_process_pids() {
    # Ideally, we would simply defer to calling :die_unless_process() here.
    # However, doing so would introduce subtle race conditions: e.g., if such
    # process were created immediately after the call to
    # :set_list_to_process_pids_if_found() but before the call to
    # :die_unless_process(), this function would both fail to set such list
    # *AND* fail to throw an exception.
    die_unless_args_2 'Expected one list name and one command name.'
    :set_list_to_process_pids_if_found "${@}" or {
        :string command_name="${2}"
        die "No process running command \"${command_name}\"."
    }
}

declare_function_with_stdin <<'/---'
[status: bool] :set_list_to_process_pids_if_found(
    string list_name, string command_name)

Set the passed list (ideally, list set) to the PIDs of all processes currently
running the passed command (in arbitrary order) if at least one such process
exists or report failure otherwise.
/---
# If "pidof" is pathable, prefer such command for terseness and efficacy.
if { is_pathable pidof } {
    function :set_list_to_process_pids_if_found() {
        # Validate sanity.
        die_unless_args_2 'Expected one list name and one command name.'
        :string\
            list_name__sltppif="${1}"\
            command_name__sltppif="${2}"\
            process_pids__sltppif

        # Get a space-delimited string of such PIDs if at least one such process
        # exists or report failure otherwise.
        process_pids__sltppif="$(command pidof -- "${command_name__sltppif}")"\
            or report_failure

        # Set such list to such PIDs.
        set_list_to_string_words\
            "${list_name__sltppif}" "${process_pids__sltppif}"
    }
# Else if "pgrep" is pathable, prefer such command.
} elif { is_pathable pgrep } {
    function :set_list_to_process_pids_if_found() {
        # Validate sanity.
        die_unless_args_2 'Expected one list name and one command name.'
        :string\
            list_name__sltppif="${1}"\
            command_name__sltppif="${2}"\
            process_pids__sltppif

        # Get a newline-delimited string of such PIDs if at least one such
        # process exists or report failure otherwise. Call "pgrep" according to
        # whether the absolute path or only basename of such command was passed.
        if { is_path_absolute "${command_name__sltppif}" } {
            process_pids__sltppif="$(command pgrep --exact --full --\
                "${command_name__sltppif}")" or report_failure
        } else {
            process_pids__sltppif="$(command pgrep --exact --\
                "${command_name__sltppif}")" or report_failure
        }

        # Set such list to such PIDs.
        set_list_to_string_lines\
            "${list_name__sltppif}" "${process_pids__sltppif}"
    }
# Else, fallback to parsing "ps" output. As such parsing is inevitably fragile,
# this implementation is hardly ideal. Nonetheless, "ps" is effectively
# guaranteed to exist by virtue of its use on all modern Unix derivatives.
} else {
    function :set_list_to_process_pids_if_found() {
        #FIXME: If such command name is prefixed by a hyphen, this probably
        #fails silently unexpectedly horribly. *shrug*

        # Validate sanity.
        die_unless_args_2 'Expected one list name and one command name.'
        :string\
            list_name__sltppif="${1}"\
            command_name__sltppif="${2}"\
            process_pids__sltppif

        # Reduce such command to its basename if passed as a path. Option "-C"
        # passed to "ps" below fails silently if passed a path.
        :remove_path_dirname command_name__sltppif

        # Get a newline-delimited string of such PIDs if at least one such
        # process exists or report failure otherwise. Dismantled, this is:
        #
        # * "-o 'pid='", outputting a newline-delimited string list of all such
        #   PIDs sans prefixing header.
        # * "-C", matching only processes running such command basename.
        process_pids__sltppif="$(command\
            ps -o 'pid=' -C "${command_name__sltppif}")" or report_failure

        # Set such list to such PIDs.
        set_list_to_string_lines\
            "${list_name__sltppif}" "${process_pids__sltppif}"
    }
}

# --------------------( WASTELANDS                         )--------------------
# function :is_process() {
#     die_unless_arg 'Expected one command name.'
#     { get_pids_running_command_if_found "${@}" } silent:
# }

#FUXME: Convert to a function. No viable reason to define this as an alias.
#FUXME: Contemplate renaming nomenclature from :is_process() to
#is_job_running_command(), which better coincides with the current
#get_pid_running_command() nomenclature. Or perhaps not; a bit hard to say.
#While slightly longer, 

# Shift the existing
#"os/process" component to "os/job/job". Nice, ne?
    #FUXME: Extract the first conditional into a new function 
    #get_pids_running_command().

#FUXME: Since Zeshy uses "command" to mean "command line," we should probably
#rename "_command" everywhere here to "_pathable": e.g., is_pathable_running().
#Of course, that also isn't quite right, since command names need not be
#pathable to be executable. Hmm... O.K., how about to "_executable", thus
#giving us: is_binary_executable_running(). Seems sensible, yes? Hmm; or perhaps this
#is fine after all. We could, after all, define an is_command_line_running() if
#we required such functionality.
#FUXME: It's unfortunate I spent a bit of time on this...as it appears to be
#completely superfluous. zsh *DOES* throw exceptions on any subprocess of a
#pipeline failing, as each such subprocess executes in its own subshell. *sigh*
#declare_function '
#void die_if_piped_command_failed(
#  integer pipe_position = -2, string error_message = "prior command failed")
#
#Throw an exception if the command with the passed position (defaulting to -2
#and hence the second-to-last command) in the prior pipe failed with non-zero
#exit status. Zeshy already implicitly throws an exception if the command in
#the last position fails, thus requiring this function be called *ONLY* when
#the last command erroneously succeeds despite the prior command in its pipe
#failing. This is, thankfully, rare.
#'
#function die_if_piped_command_failed() {
#    die_unless_args_0_to_2\
#        'expected optional pipe position and error message'
#
#    #FUXME: How often do we check success? Perhaps an is_successful() function
#    #is soon in order.
#    (( pipestatus[${1:--2}] == ZESHY_STATUS_SUCCESS )) or
#        die "${2:-prior command failed}"
#}

# ....................{ ERRORS                             }....................
# integer exit_success(void)
#
# Exit the current process with a successful return code.
#exit_success() {
#    die_if_args
#    exit ${ZESHY_STATUS_SUCCESS}
#}

# integer exit_failure(void)
#
# Exit the current process with a failure return code.
#exit_failure() {
#    die_if_args
#    exit ${ZESHY_STATUS_FAILURE}
#}
