#!/usr/bin/env zsh
# ====================[ process                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle currently running processes.

# ....................{ EXCEPTIONS                         }....................
document_function '
void die_unless_running(
  string command_name,
  string error_message = "\"${command_name}\" not running")

Throw an exception unless some user is currently running the passed command.
'
function die_unless_running() {
    die_unless_args_1_to_2\
        'expected one command name and optional error message'
    string command_name="${1}"
    is_running "${command_name}" or die "${2:-\"${command_name}\" not running}"
}

#FIXME: Rename to die_unless_running_as_user().
document_function '
void die_unless_running_as(
  string username,
  string command_name,
  string error_message = "${username} not running \"${command_name}\"")

Throw an exception unless the passed user is currently running the passed
command.
'
function die_unless_running_as() {
    die_unless_args_2_to_3\
        'expected one username, one command name, and optional error message'
    string username="${1}" command_name="${2}"
    is_running_as "${username}" "${command_name}" or
        die "${username} not running \"${command_name}\""
}

# ....................{ TESTERS                            }....................
#FIXME: Reimplement me! Dredge up the implementation from the WASTELANDS. Also,
#this *REALLY* wants to be in a new "os/job/cron" component. Shift the existing
#"os/process" component to "os/job/job". Nice, ne?
document_function '
boolean is_cronjob(void)

Return true if the current process is the grandchild of a "cron" process.
'
function is_cronjob() {
    die_if_args
    die "this function currently unimplemented!"

    #FIXME: This no longer works, of course. That said, let's pursue the
    #familiar strategy of testing such global boolean if set and otherwise
    #caching such global boolean for subsequent lookup.
    is_variable_nonempty ZESHY_IS_CRONJOB
}

#FIXME: Rename to is_command_running().
document_function '
boolean is_running(string command_name)

Return true if at least one user is currently running the passed command.
'
function is_running() {
    die_unless_arg 'expected one command name'
    run_command_silent get_pids_running "${@}"
}

#FIXME: Rename to is_command_running_as_user().
document_function '
boolean is_running_as(string username, string command_name)

Return true if the passed user is currently running the passed command.
'
function is_running_as() {
    die_unless_args_2 'expected one username and command name'
    run_command_silent get_pids_running_as "${@}"
}

#FIXME: Might be helpful to shift all PID functions to a new "process/pid"
#component.
document_function '
boolean is_pid_running(integer pid)

Return true if some process is running under the passed process ID: e.g.,

    >>> sleep 10s &; is_running_pid $! and print "Awaken, Young Master."
    Awaken, Young Master.
'
function is_pid_running() {
    die_unless_arg 'expected one process ID'
    run_command_silent kill -0 "${1}"
}

# ....................{ GETTERS ~ pids                     }....................
document_function '
integer get_pid(void)

Return the PID (i.e., process ID) of the current process.
'
function get_pid() {
    die_if_args
    print_string ${$}
}

#FIXME: Generalize to not require "pgrep".
document_function '
string get_pids_running(string command_name)

Return a newline-delimited string of process IDs for all processes running the
passed command. If no such process exists, return the empty string and fail.
'
function get_pids_running() {
    # Validate passed arguments.
    die_unless_arg 'expected one command name'
    die_unless_pathable pgrep

    string command="${1}"
    if is_path_absolute "${command}"
    then pgrep -fx "${command}" 2>/dev/null
    else pgrep  -x "${command}" 2>/dev/null
    fi
}

#FIXME: Rename to get_pids_running_as_user().
#FIXME: Generalize to not require "pgrep".
document_function '
string get_pids_running_as(string username, string command_name)

Return a newline-delimited string of process IDs for all processes having the
passed command name running under the passed user. If no such process exists,
return the empty string and a failure return code.
'
function get_pids_running_as() {
    # Validate passed arguments.
    die_unless_args_2 'expected one username and command name'
    die_unless_pathable pgrep

    # Get such PIDs.
    string username="${1}" command="${2}"
    if is_path_absolute "${command}"
    then pgrep -u "${username}" -fx "${command}" 2>/dev/null
    else pgrep -u "${username}"  -x "${command}" 2>/dev/null
    fi
}

# ....................{ GETTERS ~ commands                 }....................
#FIXME: This probably doesn't work as expected for scripts preceeded by set
#variables (e.g., "TMP=~/.tmp script.zeshy"). Test; hack; fix! Actually,
#stackoverflow can probably help us here. Google us up the fix, yo!

document_function '
string get_process_command_name(integer pid = PID)

Get the name of the command the process with the passed PID (defaulting to
that of the current process) is running.
'
function get_process_command_name() {
    # List splitting the command-line the current process is running on words.
    # Dismantled, this is:
    #
    # * "(0)", split the command-line on null bytes. By Linux convention (and
    #   hence probably not applicable to other *nix), a null byte delimits each
    #   shell word of such line.
    list command_line_words
         command_line_words=( "${(0)$(get_process_command_line "${@}")}" )
#   print_warning "pclp: ${command_line_words[@]}"

    # The name and absolute path of the command the current process is running.
    string command_name="${command_line_words[1]}" command_path

    # If this process is a zsh script (which it usually is), the absolute path
    # to this command is given by the third string in this array: e.g.,
    #
    #   # For a Zeshy script "h3110", this array resembles...
    #   command_line_words=( zsh /usr/bin/zeshy h3110 )
    if is "${command_name}" == *sh si and (( ${#command_line_words} >= 3 ))
    then command_path="${command_line_words[3]}"
    else command_path="${command_name}"
    fi

    # If the command path is "-su" (as occurs under "su"), strip the hyphen.
    is "${command_path}" == '-'* si and command_path="${command_path[2,-1]}"

    # Return the basename of this command path.
#   print "\ncommand_line_words: ${command_line_words[@]}"
#   print "command_path: ${command_path}"
    get_path_basename "${command_path}"
}

document_function '
string get_process_command_line(integer pid = PID)

Get the command line the process with the passed PID (defaulting to that of
the current process) is running. This is a string consisting of (in order):

* Either the absolute or relative path to the command. In the latter case,
  there is no reliable means of resolving this path into an absolute path.
* Each command line argument passed to such command prefixed by a null
  delimiter (i.e., "\x00").

Due to such inconsistencies, use such strings *ONLY* for non-critical
display purposes rather than critical functionality.
'
function get_process_command_line() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected one optional process ID'
    integer pid=${1:-$(get_pid)}

    #FIXME: New getter command getting such path?
    # Absolute path to the file with the command line for the passed process.
    print_file_text "/proc/${pid}/cmdline"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: It's unfortunate I spent a bit of time on this...as it appears to be
#completely superfluous. zsh *DOES* throw exceptions on any subprocess of a
#pipeline failing, as each such subprocess executes in its own subshell. *sigh*
#document_function '
#void die_if_piped_command_failed(
#  integer pipe_position = -2, string error_message = "prior command failed")
#
#Throw an exception if the command with the passed position (defaulting to -2
#and hence the second-to-last command) in the prior pipe failed with non-zero
#exit status. Zeshy already implicitly throws an exception if the command in
#the last position fails, thus requiring this function be called *ONLY* when
#the last command erroneously succeeds despite the prior command in its pipe
#failing. This is, thankfully, rare.
#'
#function die_if_piped_command_failed() {
#    die_unless_args_0_to_2\
#        'expected optional pipe position and error message'
#
#    #FUXME: How often do we check success? Perhaps an is_successful() function
#    #is soon in order.
#    (( pipestatus[${1:--2}] == ZESHY_EXIT_STATUS_SUCCESS )) or
#        die "${2:-prior command failed}"
#}

# ....................{ ERRORS                             }....................
# integer exit_success(void)
#
# Exit the current process with a successful return code.
#exit_success() {
#    die_if_args
#    exit ${ZESHY_EXIT_STATUS_SUCCESS}
#}

# integer exit_failure(void)
#
# Exit the current process with a failure return code.
#exit_failure() {
#    die_if_args
#    exit ${ZESHY_EXIT_STATUS_FAILURE}
#}
