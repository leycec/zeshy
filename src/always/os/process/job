#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'---'
Handle *jobs* (i.e., processes owned by the current shell).
---

#FIXME: Getting the PIDs of all current jobs is an interesting question. After
#cursory examination, the most efficient means of doing so appears to be simply
#converting the third column of each line of "jobs -l" output to a list. Such
#output resembles:
#
#    [1]  + 18417 suspended
#    [2]  + 37404 suspended
#
#It'd be nice to implement a helper function
#set_list_to_string_lines_column_split_on_whitespace()!

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_integer_to_pid_job_prior(string integer_name)

Set the passed integer to the process identifier (PID) of the most recently
backgrounded command. This includes commands appended by `&`, commands prefixed
by `bg`, and the coprocess of the current shell.
/---
function set_integer_to_pid_job_prior() {
    die_unless_arg 'Expected one integer name.'
    set_integer_to_integer "${1}" "${!}"
}

# ....................{ WAITERS                            }....................
declare_function_with_stdin <<'/---'
[status: integer] wait_on_jobs_all_exit(void)

Wait indefinitely for all *jobs* (i.e., processes owned by the current shell)
to terminate, returning the exit status of the last such job.
/---
function wait_on_jobs_all_exit() {
    #FIXME: I'm fairly certain there's a minor issue here: doesn't wait()
    #*ALWAYS* return success when called with no arguments? If this is the case,
    #we can efficiently hack around this by simply passing the PIDs of all
    #current jobs to wait(). See above!
    die_if_args
    wait
}

declare_function_with_stdin <<'/---'
[status: integer] wait_on_job_prior_exit(void)

Wait indefinitely for the most recently backgrounded command to terminate,
returning the exit status of such command.
/---
function wait_on_job_prior_exit() {
    die_if_args
    wait -- "${!}"
}

# ....................{ WAITERS ~ job                      }....................
declare_function_with_stdin <<'/---'
[status: integer] wait_on_job_exit(integer job_or_pid1, ...)

Wait indefinitely for all *jobs* (i.e., processes owned by the current shell)
with the passed job or process IDs (PIDs) to terminate, returning the exit
status of the job with the last passed job or PID. If any such job does not
exist, an exception is thrown.
/---
function wait_on_job_exit() {
    die_unless_args 'Expected one or more jobs or PIDs.'
    wait -- "${@}"
}

declare_function_with_stdin <<'/---'
[status: integer] wait_on_job_exit_if_found(integer pid1, ...)

Wait indefinitely for all *jobs* (i.e., processes owned by the current shell)
with the passed job or process IDs (PIDs) that still exist to terminate,
returning the exit status of the job with the last passed job or PID.
/---
function wait_on_job_exit_if_found() {
    # Validate sanity.
    die_unless_args 'Expected one or more jobs or PIDs.'

    # wait() iteratively waits on each passed job, failing immediately on the
    # first nonextant job and hence *NOT* waiting on all subsequent jobs. Since
    # this function waits on all passed extant jobs regardless of their order in
    # the passed argument list, calling wait() once does *NOT* suffice. Instead,
    # manually wait on each such job until exhausting all passed jobs.
    string job
    for    job ("${@}") {
        wait -- "${job}" &>/dev/null or ignore_failure
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Jobs aren't merely running processes. They're running processes managed
#by the current shell (i.e., run *AND* not disowned by such shell). This is a
#considerably more granular aspect of process control than we're managing here.
#Rename this parcel to @{process}.

    #FUXME: Works great... except that it throws a TRAPZERR-induced exception on
    #*EVERY* suspension back to the command-line. Dig into this a bit further.
    #(Clearly, this should probably be simply ignored.)
