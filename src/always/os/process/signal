#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'---'
Handle *POSIX signals* (i.e., standardized asynchronous notifications used for
simple inter-process communication (IPC) and inter-thread communication).
---

# ....................{ GLOBALS                            }....................

# ....................{ PRINTERS                           }....................
#FIXME: Colorize. UTF8ize. You know the stylish drill.
declare_function_with_stdin <<'/---'
string print_signals(void)

Print a human-readable synopsis of all signals available on the current system.
For each such signal, print the signal number and name identifying such signal.
/---
function print_signals() {
    # Validate sanity.
    die_if_args
    list signal_mappings

    #FIXME: The list global ${signals} is rather unhelpful. For example, it
    #fails to specify SIGRTMIN. (To be fair, neither do kill() or "/bin/kill"
    #-- which is actually fairly concerning. How does one reliably determine
    #their values, if at all?) For another thing, the indices of the list are
    #clearly "off by one", as demonstrated below. Create new map globals
    #${ZESHY_SIGNAL_NUMBER_TO_NAME} and ${ZESHY_SIGNAL_NAME_TO_NUMBER}, probably
    #initialized from ${signals} in a precompilation function.
    #FIXME: Use such maps here rather than ${signals} to avoid such off by one
    #issues.
    #FIXME: Strip SIGZERR and SIGDEBUG from such maps. Such signals *CANNOT* be
    #sent with either the builtin kill() or external "/bin/kill" and hence are
    #not signals in the commonly understand sense. Document this, naturally.
    #FIXME: Prefix single-digit signal numbers with "0" for uniform output.

    # Construct a list of human-readable signal number to name mappings.
    integer signal_number
    for     signal_number ({1..${#signals}}) {
        signal_mappings+="$(( signal_number - 1 ))] SIG${signals[$signal_number]}"
    }

    # Columnate such list. Since there typically exist 32 canonical signals,
    # columnating into five columns tends to produce a quasi-rectangle of
    # approximately equally long columns.
    join_list_into_column_count_vertical signal_mappings 5
}

# ....................{ SENDERS                            }....................
declare_function_with_stdin <<'/---'
string send_pid_signal_user1(integer pid)

Send the process with the passed process ID (PID) the *first user-defined
signal* (i.e., SIGUSR1). See run_hook_on_signal_user1() for further details.
/---
function send_pid_signal_user1() {
    die_unless_arg 'Expected one PID.'
    kill -s USR1 "${1}"
}

declare_function_with_stdin <<'/---'
string send_pid_signal_user2(integer pid)

Send the process with the passed process ID (PID) the *second user-defined
signal* (i.e., SIGUSR2). See run_hook_on_signal_user1() for further details.
/---
function send_pid_signal_user2() {
    die_unless_arg 'Expected one PID.'
    kill -s USR2 "${2}"
}

# --------------------( WASTELANDS                         )--------------------
# string convert_list_to_string_columns_vertical(
# | command pr -5 -t
    #FUXME: zeshify "pr". Nice command; no reason we can't implement it
    #ourselves, yes? This is particularly important, as we'll be embedding ANSI
    #escape sequences in such strings and thus mucking with their perceived
    #length. Does "pr" portably handle such sequences? Somehow, I doubt it.
