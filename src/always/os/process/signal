#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *POSIX signals* (i.e., scalar identifiers supporting simple, asynchronous
inter-process and -thread communication).
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void :die_unless_signal(
    string signal,
    string error_message = "Signal \"${signal}\" invalid.")

Throw an exception with the passed message unless the passed string is a valid
POSIX signal. See is_signal() for further details.
/---
function :die_unless_signal() {
    die_unless_args_1_to_2 'Expected one signal and optional error message.'
    string signal="${1}"
    :is_signal "${signal}" or die ${2-Signal \"${signal}\" invalid.}
}

# ....................{ TESTERS                            }....................
#FIXME: Complete documentation by documenting signal formats. *sigh*
declare_function_with_stdin <<'/---'
[status: bool] :is_signal(string signal)

Report success if the passed string is a valid *POSIX signal* (i.e., a scalar
identifier supporting simple, asynchronous inter-process and -thread
communication). Specifically, report success if such string matches one of the
following formats:
/---
function :is_signal() {
    # Validate sanity.
    die_if_args
    :string signal="${1}"

    # If such signal is an integer, report success only if such integer is one
    # less than an index of canonical list global ${signals}. Since POSIX
    # assigns signals 0-based indices and zsh lists 1-based indices, subtracting
    # by one converts the former to latter.
    if { is_integer "${signal}" } {
        (( 0 <= signal && signal <= ${#signals} - 1 )) and report_status
    # Else, such signal is a string. Report success only if such string is the
    # value of any item of canonical list global ${signals}.
    } else {
        # Such such values exclude prefix "SIG", strip such prefix from such
        # string if found.
        signal="$(remove_string_prefix "${signal}" 'SIG')"

        # Find such value.
        is_list_item signals "${signal}" and report_status
    }
}

# ....................{ PRINTERS                           }....................
#FIXME: Colorize. UTF8ize. You know the stylish drill.
declare_function_with_stdin <<'/---'
string :print_signals(void)

Print a human-readable synopsis of all signals available on the current system.
For each such signal, print the signal number and name identifying such signal.
/---
function :print_signals() {
    # Validate sanity.
    die_if_args
    list signal_mappings

    #FIXME: The list global ${signals} is rather unhelpful. For example, it
    #fails to specify SIGRTMIN. (To be fair, neither do kill() or "/bin/kill"
    #-- which is actually fairly concerning. How does one reliably determine
    #their values, if at all?) For another thing, the indices of the list are
    #clearly "off by one", as demonstrated below. Create new map globals
    #${ZESHY_SIGNAL_NUMBER_TO_NAME} and ${ZESHY_SIGNAL_NAME_TO_NUMBER}, probably
    #initialized from ${signals} in a precompilation function.
    #FIXME: Use such maps here rather than ${signals} to avoid such off by one
    #issues.
    #FIXME: Strip SIGZERR and SIGDEBUG from such maps. Such signals *CANNOT* be
    #sent with either the builtin kill() or external "/bin/kill" and hence are
    #not signals in the commonly understand sense. Document this, naturally.
    #FIXME: Prefix single-digit signal numbers with "0" for uniform output.

    # Construct a list of human-readable signal number to name mappings.
    integer signal_number
    for     signal_number ({1..${#signals}}) {
        signal_mappings+="$(( signal_number - 1 ))] SIG${signals[signal_number]}"
    }

    # Columnate such list. Since there typically exist 32 canonical signals,
    # columnating into five columns tends to produce a quasi-rectangle of
    # approximately equally long columns.
    join_list_into_column_count_vertical signal_mappings 5
}

# ....................{ SENDERS ~ pid                      }....................
declare_function_with_stdin <<'/---'
void :signal_pid(int pid, string signal)

Signal the process with the passed ID with the passed POSIX signal. See
:is_signal() for further details.
/---
function :signal_pid() {
    # Validate sanity.
    :string pid="${1}" signal="${2}"
    die_unless_pid "${pid}"
    :die_unless_signal "${signal}"

    # If such signal is in integer format, pass the appropriate option.
    if { is_integer "${signal}" } {
        kill -s "${signal}" "${pid}"
    # Else, such signal is in string format. Pass the appropriate option.
    } else {
        kill -n "${signal}" "${pid}"
    }
}

#FIXME: Rename to :signal_pid_interrupt() and likewise below.
declare_function_with_stdin <<'/---'
void send_pid_signal_interrupt(int pid)

Send the process with the passed ID the *interrupt signal* (i.e., SIGINT). See
run_hook_on_signal_interrupt() for further details.
/---
function send_pid_signal_interrupt() {
    die_unless_arg 'Expected one PID.'
    :signal_pid "${1}" INT
}

declare_function_with_stdin <<'/---'
void send_pid_signal_user1(int pid)

Send the process with the passed ID the *first user-defined signal* (i.e.,
SIGUSR1). See run_hook_on_signal_user1() for further details.
/---
function send_pid_signal_user1() {
    die_unless_arg 'Expected one PID.'
    :signal_pid "${1}" USR1
}

declare_function_with_stdin <<'/---'
void send_pid_signal_user2(int pid)

Send the process with the passed ID the *second user-defined signal* (i.e.,
SIGUSR2). See run_hook_on_signal_user1() for further details.
/---
function send_pid_signal_user2() {
    die_unless_arg 'Expected one PID.'
    :signal_pid "${1}" USR1
}

# ....................{ SENDERS ~ pid                      }....................
#FIXME: Implement me!
declare_function_with_stdin <<'/---'
void :signal_process(string process, string signal)

Signal all processes running the passed command with the passed POSIX signal.
See :is_signal() for further details.
/---
function :signal_process() {
    # Validate sanity.
    :string process="${1}" signal="${2}"
    die_unless_command_running "${process}"
    :die_unless_signal "${signal}"

    #FIXME: Obviously insufficient. We need to map such process name to the set
    #of all PIDs matching such name and call :signal_pid() for each.
    #FIXME: Looks like there's a few ways. Hmm... wait! If "pkill" is installed,
    #such command provides a single, succinct means of implementing this
    #function. As fallback, call :set_list_to_process_pids_if_found() and then
    #iterate such list, calling builtin kill() on each such PID.

    # If such signal is in integer format, pass the appropriate option.
    if { is_integer "${signal}" } {
        die "Hurp!"
    # Else, such signal is in string format. Pass the appropriate option.
    } else {
        die "Burp!"
    }
}

#FIXME: Implement me!
function :signal_process_user1() {
    die_unless_arg 'Expected one PID.'
    :signal_process "${2}" USR1
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Ideally, we want to call is_list_index(). Unfortunately, that
        #functions accept negative indices as well. Perhaps we want a new
        #:is_list_index_nonnegative() tester? Right. Sounds good!

# string convert_list_to_string_columns_vertical(
# | command pr -5 -t
    #FUXME: zeshify "pr". Nice command; no reason we can't implement it
    #ourselves, yes? This is particularly important, as we'll be embedding ANSI
    #escape sequences in such strings and thus mucking with their perceived
    #length. Does "pr" portably handle such sequences? Somehow, I doubt it.
