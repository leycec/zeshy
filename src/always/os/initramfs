#!/usr/bin/env zsh
# ====================[ initramfs                          ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Initramfs, handling initramfses (i.e., initial RAM filesystems).

# ....................{ GETTERS                            }....................
# string get_initramfs_file(string kernel_home = get_kernel_home())
#
# Get the absolute path of the initramfs image installed under the "/boot"
# partition for the passed kernel.
get_initramfs_file() {
    string kernel_home kernel_version
    kernel_home="${1:-$(get_kernel_home)}"
    kernel_version="$(get_kernel_version "${kernel_home}")"
    sputter "/boot/initramfs-${kernel_version}.img"
}

# ....................{ LISTERS                            }....................
# void list_initramfs(string filename = get_initramfs_file())
#
# Verbosely list the contents of the passed initramfs image (defaulting to that
# installed under the "/boot" partition for the current kernel).
list_initramfs() {
    # Localize.
    die_unless_at_most_one_arg 'expected optional filename'
    string filename="${1:-$(get_initramfs_file)}"
    die_unless_file "${filename}"

    # List.
    gunzip -c "${filename}" | cpio -tv
}

# ....................{ WRITERS                            }....................
# void extract_initramfs(string filename = get_initramfs_file())
#
# Extract the passed initramfs image (defaulting to that installed under the
# "/boot" partition for the current kernel) into the current working directory.
extract_initramfs() {
    # Localize.
    die_unless_at_most_one_arg 'expected optional filename'
    string filename="${1:-$(get_initramfs_file)}"
    die_unless_file "${filename}"

    # Extract.
    interactively utter "extracting \"${filename}\"..."
    gunzip -c "${filename}" | cpio -id --no-absolute-filenames
}

# void make_initramfs(
#   string initramfs_home = ${ZESHY_INITRAMFS_HOME},
#   string kernel_home = get_kernel_home())
#
# Reinstall the passed initramfs (defaulting to ${ZESHY_INITRAMFS_HOME}) to the
# /boot partition as "/boot/initramfs-${kernel_version}.img", a filename format
# implicitly expected by GRUB2, where ${kernel_version} is the version of the
# passed kernel (defaulting to "/usr/src/linux").
make_initramfs() {
    # Localize and validate passed arguments.
    die_unless_at_most_two_args\
        'expected optional initramfs dirname and kernel dirname'
    string source_dirname target_filename kernel_home
    source_dirname="${1:-${ZESHY_INITRAMFS_HOME}}"
    kernel_home="${2:-$(get_kernel_home)}"
    die_unless_dir "${source_dirname}"
    target_filename="$(get_initramfs_file "${kernel_home}")"

    # Curse for all dynamically linked binaries in the passed source directory.
    # Since initramfses are notoriously intolerant of dynamic linking, use of a
    # single such binary is likely to raise boot-time issues.
    is_dir "${source_dirname}/bin" and
        for binary_filename ("${source_dirname}/bin/"*(x)) {
            is_dynamically_linked_executable_binary "${binary_filename}" and
                curse "\"${binary_filename}\" dynamically linked (likely to cause boot failure)"
        }

    # Mount the "/boot" partition writably.
    mount_writable_boot_dir

    # Ensure the passed source directory is the root of the installed target
    # image by temporarily changing to such directory.
    set_current_dir "${source_dirname}"

    # Install. Note that "cpio" expects input in the form of one input file or
    # directory per line. Since "cpio" does *NOT* recurse into subdirectories,
    # do so for it with "**/*". Since "gzip" fails to return non-zero exit
    # status when "cpio" returns non-zero exit status, do so for "gzip" by
    # throwing an exception in such case. While "cpio" and "gzip" are blatantly
    # brain-dead, we are not.
    {
        interactively utter\
            "installing \"${source_dirname}/\" to \"${target_filename}\"..."
        remove_file_if_found "${target_filename}"

        # Pipe the null-delimited output of "find" to "cpio". Technically,
        # running a pure-Zsh alternative to "find" should be feasible (e.g.,
        # "sputter_null_delimited ./**/* |"). Unfortunately, "cpio" is an
        # unusually testy command, basically tolerating only "find" output.
        find . -print0 |
            cpio --null -o -H newc |
            gzip -9 > "${target_filename}"
        die_if_piped_command_failed
    # Regardless of whether such installation succeeds, always revert the
    # current directory to its prior path (as the user expects).
    } always {
        restore_current_dir
    }

    # List the contents of the newly installed target image, if interactive.
    if is_interactive; then
        sputter_blank_line
        interactively utter "listing \"${target_filename}\"..."
        list_initramfs "${target_filename}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
#           cpio -o -H newc --quiet |
#       sputter_null_delimited ./**/* |
#   print_path_verbosely "${filename}"
# Remove the target image if already installed to avoid errors below.

# ....................{ GETTERS ~ current                  }....................
#FIXME: Blatantly Linux-specific. Generalize us up.
# string get_kernel_home(void)
#
# Get the absolute path of the root directory for the current kernel: e.g.,
#
#     >>> get_kernel_home
#     /usr/src/linux
#get_initramfs_home() {
#    die_if_args
#    sputter      "${ZESHY_INITRAMFS_HOME}"
#}

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#
# Copyright 2007-2012 by Cecil Curry.
#
#   http://www.raiazome.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
