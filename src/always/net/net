#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core networking functionality.
/---

#FIXME: Interesting prettified UI for ping called "prettyping", seemingly
#written in Bourne shell (!). Strongly upvoted, suggesting quality:
#    http://my.opera.com/CrazyTerabyte/blog/2013/10/18/prettyping-sh-a-better-ui-for-watching-ping-responses
#FIXME: Add implicit support for the "usewithtor" command supplied by "torsocks",
#probably in a new "if_installed/torsocks" component. Since "torsocks" only
#supports a finite (and currently fairly small) subset of networking
#applications, this is reasonably implementable with interactive aliases. For
#a list of supported applications, see: https://code.google.com/p/torsocks/
#FIXME: A larger list of applications not explicitly supported by "usewithtor" is
#implicitly supportable by setting ${http_proxy} and ${HTTP_PROXY} (some
#applications use the former; some the latter) prior to executing such
#applications. Naturally, such globals should only be set if Tor is currently
#running and hence cannot be globally exported. The code simply resembles:
#
#    string_global_export http_proxy='http://127.0.0.1:8118/'
#    string_global_export HTTP_PROXY="${http_proxy}"
#
#Of course, such technique does not require "torsocks". All of this suggests
#implementing a new "os/net/anonymity" component.

# ....................{ GETTERS ~ hostname                 }....................
declare_function_with_stdin <<'/---'
string get_hostname(void)

Get the current system's *hostname* (i.e., subdomain name assigned such system).
Since such hostname is _not_ necessarily fully qualified (e.g., `ryleh` rather
than `ryleh.cthulhu.com`), consider calling get_hostname_fully_qualified()
instead.
/---
function get_hostname() {
    die_if_args
    output_string "${HOST}"
}

declare_function_with_stdin <<'/---'
string get_hostname_fully_qualified(void)

Get the current system's *Fully Qualified Domain Name* (FQDN), a dot-delimited
string typically equal to `$(get_hostname).$(get_domain_name)`.
/---
function get_hostname_fully_qualified() {
    die_if_args
    command hostname --fqdn
}

# ....................{ GETTERS ~ domain name              }....................
declare_function_with_stdin <<'/---'
string get_domain_name(void)

Get the current system's domain name.
/---
function get_domain_name() {
    # Call "dnsdomainname" rather than "domainname". Curiously, the latter
    # gets the current NIS rather than DNS domain name. Since DNS (largely)
    # obsoletes NIS on modern systems, this is an unfortunate decision.
    die_if_args
    command dnsdomainname
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
string set_hostname(string hostname)

Set the hostname of the current system to the passed string.
/---
function set_hostname() {
    die_unless_arg 'Expected one string.'
    command hostname -- "${1}"
}

# ....................{ CONVERTERS                         }....................
#FIXME: Rename to convert_ip_to_domain_name:() and likewise below.
#FIXME: Again, extract is_pathable() tests *OUTSIDE* such functions.
declare_function_with_stdin <<'/---'
string convert_ip_address_to_domain_name(string ip_address)

Get the domain name responsible for hosting the passed IP address via reverse
lookup against PTR records on name servers selected by the current system.
/---
function convert_ip_address_to_domain_name() {
    # Validate sanity.
    die_unless_args 'Expected one IP address.'
    string ip_address="${1}"

    #FIXME: Implement "nslookup" support.

    # Reverse lookup, preferring "dig" to "host" to "nslookup".
    if { is_pathable dig } {
        # "dig" outputs the empty string if no PTR record maps the passed IP
        # address. Testing such condition requires capturing "dig" output.
        string domain_name
        domain_name="$(command dig +short -x -- "${ip_address}")"
        die_unless_string_nonempty "${domain_name}"\
            "IP ${ip_address} not found or maps to no authoritative PTR record."
        output_string "${domain_name}"
    } elif { is_pathable host } {
        # "host" outputs strings describing the PTR record as follows:
        #
        #     >>> host 182.28.18.27
        #     27.18.28.182.in-addr.arpa domain name pointer e.transcendental.com.
        #
        # Hence, use the fifth field excluding the trailing period.
        output_string "$(remove_string_suffix\
            "$(get_string_word "$(command host -- "${ip_address}")" 5)" '.')"
    } else {
        die 'Neither "host" or "dig" installed.'
    }
}

declare_function_with_stdin <<'/---'
string convert_domain_name_to_ip_address(string domain_name)

Get the IP address serving the passed domain name via forward lookup against A
records on name servers handling such domain name.
/---
function convert_domain_name_to_ip_address() {
    # Validate sanity.
    die_unless_args 'Expected one domain name.'
    string domain_name="${1}"

    #FIXME: Implement "nslookup" support.

    # Reverse lookup, preferring "dig" to "host" to "nslookup".
    if { is_pathable dig } {
        # "dig" outputs the empty string if no A record maps the passed domain
        # name. Testing such condition requires capturing "dig" output.
        string ip_address
        ip_address="$(command dig +short -- "${domain_name}")"
        die_unless_string_nonempty "${ip_address}"\
            "Domain \"${domain_name}\" not found or maps to no authoritative A record."
        output_string "${ip_address}"
    } elif { is_pathable host } {
        # "host" outputs strings describing the PTR record as follows:
        #
        #     >>> host -t a e.transcendental.com
        #     e.transcendental.com has address 182.28.18.27
        #
        # Hence, use the fourth field.
        output_string\
            "$(get_string_word "$(command host -- "${domain_name}")" 4)"
    # Else, throw an exception.
    } else {
        die 'Neither "host" or "dig" installed.'
    }
}

# --------------------( WASTELANDS                         )--------------------
    # If "ip" is pathable, query such command.
#    if { is_pathable ip } {
#        return_string ${"$(LC_ALL=C command ip addr show dev --\
#            "${device_name}")"[(f)3][(w)2]%/*}
#    # Else if "ifconfig" is pathable, query such command.
#    } elif { is_pathable ifconfig } {
#        return_string ${"$(LC_ALL=C command ifconfig --\
#            "${device_name}")"[(f)2][(w)2]#addr:}
#    # Else, throw an exception.
#    } else {
#        die 'Neither "ip" or "ifconfig" installed.'
#    }

# = "$(get_network_device_name_default)"
# ....................{ GETTERS                            }....................
#declare_function_with_stdin <<'/---'
#string get_net_command(void)
#
#Get the absolute path of the first command in the following list found in the
#current user's ${PATH} (in order):
#
#* `ip`, the preferred CLI for managing network interfaces.
#* `ifconfig`, an obsolete but popular CLI for managing network interfaces.
#/---
#function get_net_command() {
#    # While "/sbin" is rarely on the ${PATH} for non-wheel users, numerous
#    # commands in this path remain executable by non-wheel users: namely, "ip"
#    # and "ifconfig". "ip" typically supercedes "ifconfig", where installed.
#    die_if_args
#    get_first_command 'ip' 'ifconfig'
#}

    # While "/sbin" is rarely on the ${PATH} for non-wheel users, numerous
    # commands in this path remain executable by non-wheel users: namely, "ip"
    # and "ifconfig". Such commands are accessible only as absolute filenames.
    # "ip" supercedes "ifconfig", where installed.

#FUXME: Nomenclature backwards. This emulates a map lookup. Consequently, we
#want to instate new map-based nomenclature. Rename to
#map_domain_name_to_ip_address().
# ip_address="$(host "${domain_name}")"
#       ip_address="${ip_address[(w)4]}"
# "/sbin" supercedes
    # "/usr/sbin", by the Filesystem Hierarchy Standard (FHS).
#   die_unless_file "${pastebin_file}"
#consisting of the current hostname followed by current domain name uniquely identifying this host
#   die_unless_device "/dev/${device_name}"
