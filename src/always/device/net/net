#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle networking.
-/-

#FIXME: Add implicit support for the "usewithtor" command supplied by "torsocks",
#probably in a new "if_installed/torsocks" component. Since "torsocks" only
#supports a finite (and currently fairly small) subset of networking
#applications, this is reasonably implementable with interactive aliases. For
#a list of supported applications, see: https://code.google.com/p/torsocks/
#FIXME: A larger list of applications not explicitly supported by "usewithtor" is
#implicitly supportable by setting ${http_proxy} and ${HTTP_PROXY} (some
#applications use the former; some the latter) prior to executing such
#applications. Naturally, such globals should only be set if Tor is currently
#running and hence cannot be globally exported. The code simply resembles:
#
#    string_global_export http_proxy='http://127.0.0.1:8118/'
#    string_global_export HTTP_PROXY="${http_proxy}"
#
#Of course, such technique does not require "torsocks". All of this suggests
#implementing a new "os/net/anonymity" component.

# ....................{ GETTERS ~ hostname                 }....................
declare_function_with_stdin <<'/---'
string get_hostname(void)

Get the current system's *hostname* (i.e., subdomain name assigned such system). Since such hostname is _not_ necessarily
fully qualified (e.g., `ryleh` rather than `ryleh.cthulhu.com`), consider
calling 
/---
function get_hostname() {
    die_if_args
    output_string "${HOST}"
}

declare_function_with_stdin <<'/---'
string get_hostname_fully_qualified(void)

Get the current system's *Fully Qualified Domain Name* (FQDN), a dot-delimited
string typically equal to `$(get_hostname).$(get_domain_name)`.
/---
function get_hostname_fully_qualified() {
    die_if_args
    command hostname --fqdn
}

# ....................{ GETTERS ~ domain name              }....................
declare_function_with_stdin <<'/---'
string get_domain_name(void)

Get the current system's domain name.
/---
function get_domain_name() {
    # Call "dnsdomainname" rather than "domainname". Curiously, the latter
    # gets the current NIS rather than DNS domain name. Since DNS (largely)
    # obsoletes NIS on modern systems, this is an unfortunate decision.
    die_if_args
    command dnsdomainname
}

# ....................{ GETTERS ~ ip addresses             }....................
#FIXME: Throw an exception if no IP address is bound to this device.
#FIXME: "eth0" is no longer a sensible default device name. Simply drop the
#default, please.
#FIXME: Actually, isn't there an efficient means of listing all available device
#names? If so, use that to determine the default net device name.
#FIXME: Rather than test command availability from within this function, we
#should just test such availabity externally. Invert the conditionality.

declare_function_with_stdin <<'/---'
string get_ip_address(string device_name = "$(get_network_device_name_default)")

Get the IP address bound to the passed network device (defaulting to the first
available network device, if called directly from the command line).
/---
function get_ip_address() {
    # Validate sanity.
    die_unless_args_0_to_1 'Expected optional device name.'
    string device_name="${1:-eth0}" net_command="$(get_net_command)"

    # If "ip" is pathable, query such command.
    if { is_pathable ip } {
        return_string ${"$(LC_ALL=C command ip addr show dev --\
            "${device_name}")"[(f)3][(w)2]%/*}
    # Else if "ifconfig" is pathable, query such command.
    } elif { is_pathable ifconfig } {
        return_string ${"$(LC_ALL=C command ifconfig --\
            "${device_name}")"[(f)2][(w)2]#addr:}
    # Else, throw an exception.
    } else {
        die 'Neither "ip" or "ifconfig" installed.'
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
string set_hostname(string hostname)

Set the hostname of the current system to the passed string.
/---
function set_hostname() {
    die_unless_arg 'Expected one string.'
    command hostname -- "${1}"
}

# ....................{ CONVERTERS                         }....................
declare_function_with_stdin <<'/---'
string convert_ip_address_to_domain_name(string ip_address)

Get the domain name responsible for hosting the passed IP address via reverse
lookup against PTR records on name servers selected by the current system.
/---
function convert_ip_address_to_domain_name() {
    # Validate sanity.
    die_unless_args 'Expected one IP address.'
    string ip_address="${1}"

    #FIXME: Implement "nslookup" support.

    # Reverse lookup, preferring "dig" to "host" to "nslookup".
    if { is_pathable dig } {
        # "dig" outputs the empty string if no PTR record maps the passed IP
        # address. Testing such condition requires capturing "dig" output.
        string domain_name
        domain_name="$(command dig +short -x -- "${ip_address}")"
        die_unless_string_nonempty "${domain_name}"\
            "IP ${ip_address} not found or maps to no authoritative PTR record."
        return_string "${domain_name}"
    } elif { is_pathable host } {
        # "host" outputs strings describing the PTR record as follows:
        #
        #     >>> host 182.28.18.27
        #     27.18.28.182.in-addr.arpa domain name pointer e.transcendental.com.
        #
        # Hence, use the fifth field excluding the trailing period.
        return_string "$(remove_string_suffix\
            "$(get_string_word "$(command host -- "${ip_address}")" 5)" '.')"
    } else {
        die 'Neither "host" or "dig" installed.'
    }
}

declare_function_with_stdin <<'/---'
string convert_domain_name_to_ip_address(string domain_name)

Get the IP address serving the passed domain name via forward lookup against A
records on name servers handling such domain name.
/---
function convert_domain_name_to_ip_address() {
    # Validate sanity.
    die_unless_args 'Expected one domain name.'
    string domain_name="${1}"

    #FIXME: Implement "nslookup" support.

    # Reverse lookup, preferring "dig" to "host" to "nslookup".
    if { is_pathable dig } {
        # "dig" outputs the empty string if no A record maps the passed domain
        # name. Testing such condition requires capturing "dig" output.
        string ip_address
        ip_address="$(command dig +short -- "${domain_name}")"
        die_unless_string_nonempty "${ip_address}"\
            "Domain \"${domain_name}\" not found or maps to no authoritative A record."
        return_string "${ip_address}"
    } elif { is_pathable host } {
        # "host" outputs strings describing the PTR record as follows:
        #
        #     >>> host -t a e.transcendental.com
        #     e.transcendental.com has address 182.28.18.27
        #
        # Hence, use the fourth field.
        return_string\
            "$(get_string_word "$(command host -- "${domain_name}")" 4)"
    # Else, throw an exception.
    } else {
        die 'Neither "host" or "dig" installed.'
    }
}

# ....................{ WRITERS ~ local                    }....................
declare_function_with_stdin <<'/---'
void unbind_ip_address(string ip_address, string device_name = "eth0")

Unbind the passed IP address from the passed network device (defaulting to
"eth0"): e.g.,

.unbind_ip_address()
==========================================
[source]
------------------------------------------
>>> unbind_ip_address 10.0.0.2 eth0
------------------------------------------
==========================================
/---
function unbind_ip_address() {
    # Validate sanity.
    die_unless_args_1_to_2\
        'Expected one IP address and optional device name.'
    string ip_address="${1}" device_name="${2:-eth0}"
    die_unless_pathable ip

    #FIXME: Add support for "ifconfig", if "ip" not runnable. Also, ensure that
    #"${2}" refers to a real network device.
    print_message_item\
        "Unbinding IP address ${ip_address} from ${device_name}..."
    command ip addr del "${ip_address}" dev "${device_name}"
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ GETTERS                            }....................
#declare_function_with_stdin <<'/---'
#string get_net_command(void)
#
#Get the absolute path of the first command in the following list found in the
#current user's ${PATH} (in order):
#
#* `ip`, the preferred CLI for managing network interfaces.
#* `ifconfig`, an obsolete but popular CLI for managing network interfaces.
#/---
#function get_net_command() {
#    # While "/sbin" is rarely on the ${PATH} for non-wheel users, numerous
#    # commands in this path remain executable by non-wheel users: namely, "ip"
#    # and "ifconfig". "ip" typically supercedes "ifconfig", where installed.
#    die_if_args
#    get_first_command 'ip' 'ifconfig'
#}

    # While "/sbin" is rarely on the ${PATH} for non-wheel users, numerous
    # commands in this path remain executable by non-wheel users: namely, "ip"
    # and "ifconfig". Such commands are accessible only as absolute filenames.
    # "ip" supercedes "ifconfig", where installed.

#FUXME: Nomenclature backwards. This emulates a map lookup. Consequently, we
#want to instate new map-based nomenclature. Rename to
#map_domain_name_to_ip_address().
# ip_address="$(host "${domain_name}")"
#       ip_address="${ip_address[(w)4]}"
# "/sbin" supercedes
    # "/usr/sbin", by the Filesystem Hierarchy Standard (FHS).
#   die_unless_file "${pastebin_file}"
#consisting of the current hostname followed by current domain name uniquely identifying this host
#   die_unless_device "/dev/${device_name}"
