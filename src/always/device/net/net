#!/usr/bin/env zsh
# ====================[ net                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Net, implementing network-handling functionality.
#
# --------------------( TODO                               )--------------------
# * Add implicit support for the "usewithtor" command supplied by "torsocks",
#   probably in a new "if_installed/torsocks" component. Since "torsocks" only
#   supports a finite (and currently fairly small) subset of networking
#   applications, this is reasonably implementable with interactive aliases. For
#   a list of supported applications, see: https://code.google.com/p/torsocks/
# * A larger list of applications not explicitly supported by "usewithtor" is
#   implicitly supportable by setting ${http_proxy} and ${HTTP_PROXY} (some
#   applications use the former; some the latter) prior to executing such
#   applications. Naturally, such globals should only be set if Tor is currently
#   running and hence cannot be globally exported. The code simply resembles:
#       global_string http_proxy='http://127.0.0.1:8118/'
#       global_string HTTP_PROXY="${http_proxy}"
#   Of course, such technique does not require "torsocks". All of this suggests
#   implementing a new "os/net/anonymity" component.

# ....................{ GETTERS                            }....................
# string get_net_command(void)
#
# Get the absolute path of the command managing network interfaces.
get_net_command() {
    # While "/sbin" is rarely on the ${PATH} for non-wheel users, numerous
    # commands in this path remain executable by non-wheel users: namely, "ip"
    # and "ifconfig". Such commands are accessible only as absolute filenames.
    # "ip" supercedes "ifconfig", where installed. "/sbin" supercedes
    # "/usr/sbin", by the Filesystem Hierarchy Standard (FHS).
    die_if_args
    get_first_command\
        '/sbin/ip'       '/usr/sbin/ip'\
        '/sbin/ifconfig' '/usr/sbin/ifconfig'
}

# string get_hostname(void)
#
# Get the hostname of the current machine.
get_hostname() {
    die_if_args
    hostname
}

# string get_fully_qualified_domain_name(void)
#
# Get the Fully Qualified Domain Name (FQDN) of the current machine, a dot-
# delimited string resembling "$(get_hostname).$(get_domain_name)".
get_fully_qualified_domain_name() {
    die_if_args
    hostname --fqdn
}

# ....................{ GETTERS ~ domain names             }....................
# string get_domain_name(void)
#
# Get the domain name of the current machine.
get_domain_name() {
    die_if_args

    # Call "dnsdomainname" rather than "domainname". Curiously, the latter
    # gets the current NIS rather than DNS domain name. Since DNS (largely)
    # obsoletes NIS on modern systems, this is an unfortunate decision.
    dnsdomainname
}

# string get_domain_name_for_ip_address(string ip_address)
#
# Get the domain name responsible for hosting the passed IP address via reverse
# lookup against PTR records on name servers selected by the current machine.
get_domain_name_for_ip_address() {
    # Localize passed arguments.
    die_unless_args 'expected one IP address'
    string domain_name ip_address="${1}"

    # Reverse lookup, preferring "dig" to "host" to "nslookup".
    if is_installed dig; then
        # "dig" outputs the empty string if no PTR record maps the passed IP
        # address. Testing such condition requires capturing "dig" output.
        domain_name="$(dig +short -x "${ip_address}")"
        die_unless_nonempty "${domain_name}"\
            "\"${ip_address}\" not found or maps to no authoritative PTR record"
    elif is_installed host; then
        # "host" outputs strings describing the PTR record as follows:
        #
        #     >>> host 182.28.18.27
        #     27.18.28.182.in-addr.arpa domain name pointer e.transcendental.com.
        #
        # Hence, use the fifth field excluding the trailing period.
        domain_name="$(host "${ip_address}")"
        domain_name="${domain_name[(w)5]%.}"
    else die 'neither "host" or "dig" installed'
    fi

    output "${domain_name}"
}

# ....................{ GETTERS ~ ip addresses             }....................
#FIXME: Raise an exception if no IP address is bound to this device.
# string get_ip_address(string device_name = 'eth0')
#
# Get the IP address bound to the passed network device (defaulting to "eth0").
get_ip_address() {
    die_unless_no_or_one_arg 'expected optional device name'
    string device_name="${1:-eth0}" net_command="$(get_net_command)"

    # If "ip" is the current net command, defer to "ip".
    if is "$(get_basename "${net_command}")" == ip si
    then print ${"$(LC_ALL=C "${net_command}" addr show dev "${device_name}")"[(f)3][(w)2]%/*}
    # Otherwise, defer to "ifconfig".
    else print ${"$(LC_ALL=C "${net_command}" "${device_name}")"[(f)2][(w)2]#addr:}
    fi
}

# string get_ip_address_for_domain_name(string domain_name)
#
# Get the IP address serving the passed domain name via forward lookup against A
# records on name servers handling such domain name.
get_ip_address_for_domain_name() {
    # Localize passed arguments.
    die_unless_args 'expected one domain name'
    string ip_address domain_name="${1}"

    # Reverse lookup, preferring "dig" to "host" to "nslookup".
    if is_installed dig; then
        # "dig" outputs the empty string if no A record maps the passed domain
        # name. Testing such condition requires capturing "dig" output.
        ip_address="$(dig +short "${domain_name}")"
        die_unless_nonempty "${ip_address}"\
            "\"${domain_name}\" not found or maps to no authoritative A record"
    elif is_installed host; then
        # "host" outputs strings describing the PTR record as follows:
        #
        #     >>> host -t a e.transcendental.com
        #     e.transcendental.com has address 182.28.18.27
        #
        # Hence, use the fourth field.
        ip_address="$(host "${domain_name}")"
        ip_address="${ip_address[(w)4]}"
    else die 'neither "host" or "dig" installed'
    fi

    output "${ip_address}"
}

# ....................{ SETTERS                            }....................
# string set_hostname(string hostname)
#
# Set the hostname of the current machine to the passed string.
set_hostname() {
    die_unless_one_arg
    hostname "${1}"
}

# ....................{ WRITERS ~ local                    }....................
# void unbind_ip_address(string ip_address, string device_name = 'eth0')
#
# Unbind the passed IP address from the passed network device (defaulting to
# "eth0"): e.g.,
#
#     >>> unbind_ip_address 10.0.0.2 eth0
unbind_ip_address() {
    die_unless_one_or_two_args\
        'expected one IP address and optional device name'
    string ip_address="${1}" device_name="${2:-eth0}"

    #FIXME: Add support for "ifconfig", if "ip" not runnable. Also, ensure that
    #"${2}" refers to a real network device.
    say "unbinding IP address ${ip_address} from ${device_name}..."
    die_unless_installed ip
    ip addr del "${ip_address}" dev "${device_name}"
}

# ....................{ WRITERS ~ remote                   }....................
#FIXME: Add support for alternative pasters.
# void pastebin(string filename)
#
# Upload the contents of some file as a pastebin post. This file will be posted
# as a plain textfile, and is thus best used for logs.
pastebin() {
    die_unless_one_arg 'expected exactly one filename'
    string pastebin_file="${1}"
    die_unless_file "${pastebin_file}"
    die_unless_installed wgetpaste

    say "pasting ${pastebin_file}..."
    cat "${pastebin_file}" | wgetpaste --raw --verbose
}

# --------------------( WASTELANDS                         )--------------------
#consisting of the current hostname followed by current domain name uniquely identifying this host
#   die_unless_device "/dev/${device_name}"
