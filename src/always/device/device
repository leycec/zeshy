#!/usr/bin/env zsh
# ====================[ device                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle devices and device files.
#
# --------------------( TODO                               )--------------------
# * Check out "inxi". Looks to be a rather swag, single large bash script for
#   printing human-readable profiles of system hardware, complete with a rather
#   professional manpage. See: http://smxi.org/site/about.htm#inxi

# ....................{ EXCEPTIONS                         }....................
# void die_unless_device(
#   string pathname,
#   string error_message = "\"${pathname}\" not a device")
#
# Throw an exception unless the passed device file exists.
function die_unless_device() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_device "${pathname}" or die "${2:-\"${pathname}\" not a device}"
}

# ....................{ TESTS                              }....................
# boolean is_device(string pathname)
#
# Return true if the passed device file exists (i.e., is a device mapping to
# either a block- or character-special device).
function is_device() {
    die_unless_arg 'expected one pathname'
    string pathname="${1}"
    is -b "${pathname}" or -c "${pathname}" si
}

# ....................{ GETTERS                            }....................
# string get_device_first(string filename1, string filename2, ...)
#
# Get the absolute path of the first device file in the passed list of filenames
# to exist or raise an exception if no such file exists.
function get_device_first() {
    # Dismantled, this is:
    #
    # * "-", resolving symbolic links prior to matching.
    # * "%", including only device files.
    get_path_qualified_first "${@}" '(-%)' 'a device file' 'device files'
}

# ....................{ GETTERS ~ random                   }....................
# string get_device_printing_bytes_pseudo_randomly(void)
#
# Get the absolute path of the first canonical system-wide device file
# generating pseudo-random bytes to exist in the following list:
#
# * "/dev/frandom", a non-blocking generator commonly cited as faster than
#   "/dev/urandom", but available only after installing third-party software.
# * "/dev/erandom", a non-blocking generator by the same author as
#   "/dev/frandom", but consuming no entropy.
# * "/dev/urandom", the canonical non-blocking generator.
function get_device_printing_bytes_pseudo_randomly() {
    die_if_args
    get_device_first '/dev/'{f,e,u,}'random'
}


# string get_device_printing_bytes_randomly(void)
#
# Get the absolute path of the canonical system-wide device file generating
# genuinely random  (i.e., non-pseudo-random) bytes, typically "/etc/random".
# Typically, such device file blocks after consuming available input entropy.
# If undesirable, consider calling get_device_printing_pseudo_randomly()
# instead, which generates only pseudo-random bytes and hence never blocks.
function get_device_printing_bytes_randomly() {
    die_if_args
    get_device_first '/dev/'{f,e,u,}'random'
}

# ....................{ PRINTERS                           }....................
# string print_device(string device_filename)
#
# Print a human-readable profile of the passed device.
function print_device() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"
    die_unless_device "${device_filename}"

    #FIXME: Technically, this only tests whether or not "udev" is installed. Add
    #an additional test ensuring "udev" is also currently running, probably
    #implemented in "if_installed/udevadm" to test whether or not "udevd" is
    #currently running: say, is_udevd_running(). Actually, that seems fairly
    #straight-forward. Just implement as is here?
    # If the current system is running a "udev" daemon, beg such daemon for data
    # on the passed device.
    run_if_runnable print_udev_device
}

# --------------------( WASTELANDS                         )--------------------
# * "/dev/random", the canonical blocking generator.
#   print_message "really format "${device_file}" as ${filesystem_type}? [yes/no] "
#   string is_sure
#   read   is_sure
#   if is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si; then
#       print_message      "formatting \"${device_file}\" as ${filesystem_type}..."
