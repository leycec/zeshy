#!/usr/bin/env zsh
# ====================[ device                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle devices and device files.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_device(
#   string pathname,
#   string error_message = "\"${pathname}\" not a device")
#
# Throw an exception unless the passed device file exists.
die_unless_device() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_device "${pathname}" or die "${2:-\"${pathname}\" not a device}"
}

# ....................{ TESTS                              }....................
# boolean is_device(string pathname)
#
# Return true if the passed device file exists (i.e., is a device mapping to
# either a block- or character-special device).
is_device() {
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}"
    is -b "${pathname}" or -c "${pathname}" si
}

# ....................{ GETTERS                            }....................
# string get_first_device(string filename1, string filename2, ...)
#
# Get the absolute path of the first device file in the passed list of filenames
# to exist or raise an exception if no such file exists.
get_first_device() {
    # Dismantled, this is:
    #
    # * "-", resolving symbolic links prior to matching.
    # * "%", including only device files.
    get_first_path_match "${@}" '(-%)' 'a device file' 'device files'
}

# string get_device_generating_random_bytes(void)
#
# Get the absolute path of the first random byte-generating device file in the
# following list that exists:
#
# * "/dev/frandom", a non-blocking generator commonly cited as faster than
#   "/dev/urandom", but available only after installing third-party software.
# * "/dev/erandom", a non-blocking generator by the same author as
#   "/dev/frandom", but consuming no entropy.
# * "/dev/urandom", the canonical non-blocking generator.
# * "/dev/random", the canonical blocking generator.
get_device_generating_random_bytes() {
    die_if_args
    get_first_device '/dev/'{f,e,u,}'random'
}

# ....................{ PRINTERS                           }....................
# string print_device(string device_filename)
#
# Print a human-readable profile of the passed device.
print_device() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one device filename'
    string device_filename="${1}"
    die_unless_device "${device_filename}"

    #FIXME: Technically, this only tests whether or not "udev" is installed. Add
    #an additional test ensuring "udev" is also currently running, probably
    #implemented in "if_installed/udevadm" to test whether or not "udevd" is
    #currently running: say, is_udevd_running(). Actually, that seems fairly
    #straight-forward. Just implement as is here?
    # If the current system is running a "udev" daemon, beg such daemon for data
    # on the passed device.
    run_if_runnable print_udev_device
}

# --------------------( WASTELANDS                         )--------------------
#   say "really format "${device_file}" as ${filesystem_type}? [yes/no] "
#   string is_sure
#   read   is_sure
#   if is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si; then
#       say      "formatting \"${device_file}\" as ${filesystem_type}..."
