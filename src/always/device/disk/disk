#!/usr/bin/env zsh
# ====================[ disk                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Disk, handling disk storage.
#
# --------------------( TODO                               )--------------------
# * Add support for disk cloning. To be blunt, it's highly non-trivial and
#   rather dangerous (an understatement); but, current Linux command-line
#   support for such cloning only excacerbates this issue by unsafely admitting
#   inherently damaging operations (e.g., "dd"-ing onto a mounted partition).
#   Disk cloning requires two separate actions:
#   1. First, cloning the partition(s) header(s) and ensuring the output disk or
#      partition is at least as large as the input disk or partition. Assuming
#      an output disk of /dev/sdb and input disk of /dev/sda, this is achievable
#      by running:
#      sfdisk -d /dev/sda | sfdisk /dev/sdb
#   2. Second, cloning the actual disk or partition ("dd" operates on either
#      transparently, since both are device files). This is somewhat complicated
#      by the lack of a progress bar for "dd" and the need to prevent "dd" from
#      committing blatantly damaging data deletion. Specifically:
#      1. If the output is a disk, validate that no partition of that disk is
#         currently mounted. If the output is a partition, validate that that
#         partition is currently unmounted. Note that this implicitly guards
#         against overwriting of the main hard drive in use.
#      2. Validate that the output disk or partition is at least as large as the
#         input disk or partition. Note that the output may be an ".img" file,
#         thus somewhat complicating such checks.
#      2. Interactively confirm the user wishes to do so with ask_yes_or_no().
#      3. Perform the actual clone with "pv" (pipe view) if installed, providing
#         a visual progress bar: e.g.,
#         dd if=/dev/sda bs=32M | pv -s 512M | dd bs=32M of=/dev/sdb
#         The "bs" (block size) argument is essential to provide decent
#         throughput. Being an archaic application, "dd" defaults to an absurd
#         512KB block size; anything from 4MB to 128MB appears to be the current
#         preferred default. Since "pv" can't reasonably know the full size of
#         data being transferred, we provide it the explicit size with "-s".

# ....................{ ALIASES                            }....................
interactive_alias df='df --human-readable --sync'
interactive_alias fdisk='check_disk'

#FIXME: Rename "disk" to "disk" everywhere.
# ....................{ EXCEPTIONS                         }....................
# void die_unless_disk(
#   string pathname, string error_message = 'not a disk device')
#
# Raise an exception unless the passed device file corresponds to a currently
# attached disk.
die_unless_disk() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_disk "${pathname}" or
        die "${2:-\"${pathname}\" not found or not a disk device}"
}

# ....................{ TESTS                              }....................
# bool is_disk(string pathname)
#
# Return true if the passed path is a device file corresponding to a currently
# attached disk.
is_disk() {
    die_unless_one_arg 'expected one pathname'
    run_quietly /sbin/blkid -- "${1}"
}

# ....................{ GETTERS                            }....................
# void get_disk_filesystem_type(string device_file)
#
# Get the filesystem type of the passed disk as a lowercase_string descriptor.
get_disk_filesystem_type() {
    get_disk_property TYPE "${@}"
}

# void get_disk_label(string device_file)
#
# Get the label of the passed disk or empty string if such disk has no label.
get_disk_label() {
    get_disk_property LABEL "${@}"
}

# void get_disk_property(string device_file, string property_name)
#
# Get the value of the property with the passed name of the passed disk.
get_disk_property() {
    die_unless_two_args\
        'expected one device file and one property name'
    string device_filename="${1}" property_name="${2}"
    die_unless_disk "${device_filename}"
    /sbin/blkid -o value -s -- "${property_name}" "${device_filename}"
}

# ....................{ SETTERS                            }....................
# void set_disk_label(string device_file, string label)
#
# Set the filesystem label of the passed disk to the passed string. For safety,
# such labels should typically be no longer than 16 characters.
set_disk_label() {
    # Localize and validate passed arguments.
    die_unless_two_args 'expected one device file and label'
    string device_filename="${1}" label="${2}"
    die_unless_disk "${device_filename}"

    # Filesystem type of the passed disk.
    string filesystem_type="$(get_disk_filesystem_type "${device_filename}")"
    interactively utter\
        "labeling ${filesystem_type}-formatted \"${device_filename}\" as \"${label}\"..."

    #FIXME: Explicitly handle unformatted disks. What type does "blkid" print?
    # Relabel such disk according to such type.
    case "${filesystem_type}" in
        ext<2-4>)
            die_unless_installed e2label
            e2label -- "${device_filename}" "${label}";;
        *) die "\"${filesystem_type}\" not a currently supported filesystem type";;
    esac
}

# ....................{ PRINTERS                           }....................
#FIXME: While decent, this could certainly use augmentation. For each such disk
#that is also mounted, suffix its device path with:
#
# * A subset of print_mount_points() output, omitting "FLAGS" for brevity.
# * A subset of "df" output.
#
# We can use the "paste" command to cleverly append columns cut from "df" onto
# each print_mount_points() row of output, I believe. (Ah; well, nearly. The
# print_mount_points() output is not suitable for munging. Due to its
# substitution of FLAGS commas with spaces, space delimiters cannot be matched
# properly. Instead, we'll have to manually hack it from the "mount" command.
# Note, however, that "df" nearly provides all we need: it lacks only the
# filesystem type. Hmm...) Also:
#
# * It'd be very nice to lexicographically sort "df" lines by their first column,
#   ignoring the initial header.
# * For devices with labels, it'd be nice to print both the symbolic link label
#   and the target absolute path. This may require we cut some of the "df"
#   content, but is absolutely vital and hence takes precedence over that. To
#   conserve space, print only the label basename.
#
# Ah. The "blkid" command prints more of what we need: the absolute device file,
# the label, and the filesystem type. Moreover, it does so for *ALL* currently
# attached device files, mounted or not. Much better! That said, its output is
# not the cleanest. We'll need to munge it up quite a bit to get output suitable
# for piping to "column -t".
#
# Oh. Actually, under "blkid -o list", the output is fairly ideal. No heavy
# munging required -- save possibly for replacing the rather useless "UUID"
# column with disk size statistics.

# string print_disks(string device_filename1, string device_filename2, ...)
#
# Print a human-readable list describing each passed device or all available
# disk devices if no such devices are passed.
print_disks() {
    /sbin/blkid -o list "${@}"
    #FIXME: Does this handle whitespace in device filenames or labels? Hmm.
    #Probably need some form of quote protection, here.
    # See print_mount_points() for details.
#   (
#       print 'DEVICE LABEL'
#       print -C2 -- /dev/disk/by-label/*(:A) /dev/disk/by-label/*(:t)
#   ) | column -t
}

# ....................{ WRITERS                            }....................
# string check_disk(
#     string device_filename, string fsck_option1, string fsck_option2, ...)
#
# Check the passed disk device for errors with the passed custom "fsck" options,
# automatically repairing all such errors.
check_disk() {
    # Validate passed arguments.
    die_unless_at_least_one_arg\
        'expected one device file and optional "fsck" arguments'
    string device_file="${1}"
    die_if_mounted_disk "${device_filename}"
    shift_one_arg

    # Check and repair. Always enable option "-M" regardless of whether called
    # interactively or not, thus prohibiting disk repair on mounted devices.
    #
    # Do not, however, always enable options "-a" or "-p". While seemingly
    # sensible defaults, both induce "fsck" to conditionally ignore otherwise
    # repairable errors (e.g., superblock mount time in the future). Dismantled,
    # this is:
    #
    # * "-M", prohibiting disk repair on mounted devices, which current research
    #   shows to be inherently risky (on even read-only mounted devices!):
    #     http://serverfault.com/questions/405248/linux-force-fsck-of-a-read-only-mounted-filesystem
    # * "-C", displaying progress bars if interactive.
    # * "-T", not displaying the title if non-interactive.
    if is_interactive
    then /sbin/fsck -M -C "${device_filename}" -- "${@}"
    else /sbin/fsck -M -T "${device_filename}" -- "${@}"
    fi
}

# ....................{ WRITERS ~ format                   }....................
# string erase_disk_securely(string device_filename)
#
# Securely erase all content on the passed disk, including partition headers.
# While resource-consumptive, such erasure guarantees such content to be
# unrecoverable with even enhanced data retrieval (e.g., forensics).
erase_disk_securely() {
    # Validate passed arguments.
    die_unless_arg 'expected one device file'
    string device_filename="${1}"
    die_if_mounted_disk "${device_filename}"

    # No reasonable use case calls this function non-interactively.
    die_unless_interactive

    #FIXME: ask_yes_or_no_hard() is a fairly lame name for this function. How about,
    #say.., beg_boolean_strongly() or request_boolean_strictly()? (I *LOVE* the
    #latter. I mean, com' on! The "strongly" fits with encryption terminology,
    #and the "beg" is memorably rememberable.)
    # Confirm erasure.
    ask_yes_or_no_harder "really erase \"${device_filename}\"?" or return_false
    print
    utter "securely erasing \"${device_filename}\"... (This may take several hours to days.)"

    # Disk erasure command to be run.
    list dd; dd=( dd bs=16M of="${device_filename}" )

    # If "pv" is installed, print an incremental progress bar during erasure.
    if is_installed pv; then
        pv "$(get_device_generating_random_bytes)" | "${dd[@]}"
    # Otherwise, print incremental status updates during erasure.
    else
        # Erase in the background.
        "${dd[@]}" &

        #FIXME: Hmm; we probably want a function get_backgrounded_pid() (or some such).
        # Process ID of such erasure.
        integer dd_pid=$!

        # Print incremental status updates every second until erasure completes.
        watch -e -n1 "kill -USR1 ${dd_pid}"
    fi
}

# string format_disk(
#     string device_filename, string filesystem_type = 'ext4', string label = '',
#     string mkfs_option1, string mkfs_option2, ...)
#
# Format the passed disk as the passed filesystem type (defaulting to "ext4")
# with the passed label (defaulting to the empty string) and "mkfs" options.
format_disk() {
    # Localize passed arguments.
    die_unless_at_least_one_arg\
        'expected one device file and optional filesystem type, label, and "mkfs" arguments'
    string device_filename="${1}" filesystem_type="${2:-ext4}" label="${3}"
    shift_three_args

    # Validate passed arguments.
    die_if_mounted_disk "${device_filename}"
    string formatter="/sbin/mkfs.${filesystem_type}"
    die_unless_installed "${formatter}"\
        "\"${filesystem_type}\" not a recognized filesystem type"

    # There is no reasonable use case calling this function non-interactively.
    die_unless_interactive

    # Astonishingly, "mkfs.*" commands do *NOT* ask interactive shell users to
    # confirm extremely destructive formats prior to doing so. (Really? Come on,
    # Linux! This isn't obtuse rocket science. It's common decency.)
    ask_yes_or_no_harder\
        "really format \"${device_filename}\" as ${filesystem_type}?" or
        return_false
    sputter_blank_line

    # Format under "-v" for forced verbosity.
    if is_nonempty "${label}"
    then "${formatter}" -v -L "${label}" "${@}" -- "${device_filename}"
    else "${formatter}" -v               "${@}" -- "${device_filename}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
# * It'd be *very* nice to add implicit support for conditional paging on
#   output; basically, only page output when such output exceeds the current
#   terminal height; otherwise, print output as is. This has broad applicability
#   throughout Zeshy (e.g., grep, ls, du, cat).

# Filesystem checking (fsck). Note we do not implicitly pass the "-a" or "-p"
# options to fsck, as fsck ignores some filesystem errors (e.g., superblock
# mount time in the future) when those options are passed.
#() {
#    string ZESHY_FSCK_OPTIONS="-C -M -T"
#    interactive_alias fsck="fsck ${ZESHY_FSCK_OPTIONS}"
#    interactive_alias fsck.ext2="fsck.ext2 ${ZESHY_FSCK_OPTIONS}"
#    interactive_alias fsck.ext3="fsck.ext3 ${ZESHY_FSCK_OPTIONS}"
#    interactive_alias fsck.vfat="fsck.vfat ${ZESHY_FSCK_OPTIONS}"
#}

#FIXME: O.K.; the current implementation is obviously a sham. We need a new
    #getter "get_disk_filesystem" to acquire the filesystem of this disk,
    #ideally without mounting. This is trivially easy if the disk is already
    #mounted; just grep apart the output of "mount -l". If the disk is not
    #mounted, however, this becomes much trickier. Google whether or not there
    #are safe mechanisms for doing so.
    #
    #Ah-ha! Yes. The "blkid" commands appears to cleanly handle such things.

#interactive_alias dup="print_disk_usage_paged"
#interactive_alias dus="print_disk_usage_paged_sorted"
#FIXME: The following two functions fugly as heck. We really need to rename
#page() to run_paged() and implement dynamic paging only when the total
#length of output exceeds the current terminal height.
#  [ -z "$1" ] && 1="."
#  \du --all --no-dereference $1 | sort --numeric-sort --reverse | less

#FIXME: We could probably implement a more specific
#die_unless_disk_file() function accepting only block-special devices
#that are symlinked to at least once in the '/dev/disk/by-id' directory, the
#most complete listing of such disk devices.

#   utter "really format "${device_file}" as ${filesystem_type}? [yes/no] "
#   string is_sure
#   read   is_sure
#   if is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si; then
#       utter      "formatting \"${device_file}\" as ${filesystem_type}..."
