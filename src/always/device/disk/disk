#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle disk storage.
-/-

#FIXME: Add support for disk cloning. To be blunt, it's highly non-trivial and
#rather dangerous (an understatement); but, current Linux command-line
#support for such cloning only excacerbates this issue by unsafely admitting
#inherently damaging operations (e.g., "dd"-ing onto a mounted partition).
#Disk cloning requires two separate actions:
#1. First, cloning the partition(s) header(s) and ensuring the print_string disk or
#   partition is at least as large as the input disk or partition. Assuming
#   an print_string disk of /dev/sdb and input disk of /dev/sda, this is achievable
#   by running:
#      sfdisk -d /dev/sda | sfdisk /dev/sdb
#2. Second, cloning the actual disk or partition ("dd" operates on either
#   transparently, since both are device files). This is somewhat complicated
#   by the lack of a progress bar for "dd" and the need to prevent "dd" from
#   committing blatantly damaging data deletion. Specifically:
#   1. If the print_string is a disk, validate that no partition of that disk is
#      currently mounted. If the print_string is a partition, validate that that
#      partition is currently unmounted. Note that this implicitly guards
#      against overwriting of the main hard drive in use.
#   2. Validate that the print_string disk or partition is at least as large as the
#      input disk or partition. Note that the print_string may be an ".img" file,
#      thus somewhat complicating such checks.
#   3. Interactively confirm the user wishes to do so with is_query_character_yes().
#   4. Perform the actual clone with "pv" (pipe view) if installed, providing
#      a visual progress bar: e.g.,
#         dd if=/dev/sda bs=32M | pv -s 512M | dd bs=32M of=/dev/sdb
#      The "bs" (block size) argument is essential to provide decent
#      throughput. Being an archaic application, "dd" defaults to an absurd
#      512KB block size; anything from 4MB to 128MB appears to be the current
#      preferred default. Since "pv" can't reasonably know the full size of
#      data being transferred, we provide it the explicit size with "-s".
#FIXME: "blkid" is Linux-specific. Hence, so are most of this component's
#current implementations. Fix this.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_disk(
    string device_filename,
    string error_message = "\"${device_filename}\" not a disk device")

Throw an exception with the passed message unless the passed disk device file
exists. See is_disk() for further details.
/---
function die_unless_disk() {
    die_unless_args_1_to_2\
        'expected one device filename and optional error message'
    string filename="${1}"
    is_disk "${filename}" or
        die "${2:-\"${filename}\" not a disk device}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_disk(string device_filename)

Return success if the passed device file exists and corresponds to a currently
physically attached block-storage device (e.g., hard disk, USB flash drive) or
partition of such device. See is_disk_mounted() to test whether such disk is
currently mounted or not.
/---
function is_disk() {
    die_unless_arg 'expected one device filename'
    die_unless_pathable blkid
    run_code_silent  blkid -- "${1}"
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_disk_filesystem_type_if_found(
    string device_filename)

Get the lowercase filesystem type of the passed disk if such disk is formatted
with a filesystem or return failure otherwise: e.g.,

.get_disk_filesystem_type_if_found()
==========================================
[source]
------------------------------------------
>>> get_disk_filesystem_type_if_found "/dev/sda1"
ext4
------------------------------------------
==========================================
/---
function get_disk_filesystem_type_if_found() {
    die_unless_arg 'expected one device filename'
    get_disk_property TYPE "${1}"
}

declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_disk_property(
    string device_filename, string property)

Get the current value of the passed property for the passed disk if such disk
has such property or return failure otherwise. Common properties include:

* `LABEL`, the case-sensitive human-readable label for such disk if such disk is
  labeled.
* `TYPE`, the lowercase filesystem type for such disk if such disk is formatted
  with a filesystem.
* `UUID`, the 128-bit universally unique identifier (UUID) assigned such disk.
/---
function get_disk_property() {
    # Validate passed arguments.
    die_unless_args_2\
        'expected one device filename and one property name'
    string device_filename="${1}" property="${2}"
    die_unless_disk "${device_filename}"
    die_unless_pathable blkid

    # Print such property, if found.
    command blkid -o value -s -- "${property}" "${device_filename}"
}

# ....................{ GETTERS ~ label                    }....................
declare_function_with_stdin <<'/---'
[stdout: string, status: boolean] get_disk_label_if_found(
    string device_filename)

Get the label of the passed disk if such disk is labeled or return failure
otherwise.
/---
function get_disk_label_if_found() {
    die_unless_arg 'expected one device filename'
    get_disk_property LABEL "${1}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_disk_label(string device_filename, string label)

Set the filesystem label of the passed disk to the passed string. For safety,
disk labels should typically be no longer than 16 characters. If such disk is
_not_ formatted with a filesystem, throw an exception.
/---
function set_disk_label() {
    #FIXME: Implement die_unless_disk_unmounted()!

    # Validate passed arguments.
    die_unless_args_2 'expected one device filename and label'
    string device_filename="${1}" label="${2}" filesystem_type
    die_unless_disk_unmounted "${device_filename}"

    # Get the filesystem type of such disk if formatted with a filesystem or
    # throw an exception.
    filesystem_type="$(get_disk_filesystem_type_if_found "${device_filename}")"
    print_message_interactively\
        "labeling ${filesystem_type}-formatted \"${device_filename}\" as \"${label}\"..."

    # Label such disk according to such type.
    case "${filesystem_type}" {
    btrfs)
        die_unless_pathable btrfs
        command btrfs filesystem label -- "${device_filename}" "${label}";;
    ext<2-4>)
        die_unless_pathable e2label
        command e2label -- "${device_filename}" "${label}";;
    xfs)
        die_unless_pathable xfs_admin
        command xfs_admin -L "${label}" -- "${device_filename}";;
    *) die "filesystem \"${filesystem_type}\" currently unsupported";;
    }
}

# ....................{ PRINTERS                           }....................
#FIXME: While decent, this could certainly use augmentation. For each such disk
#that is also mounted, suffix its device path with:
#
# * A subset of print_mount_points() output, omitting "FLAGS" for brevity.
# * A subset of "df" output.
#
# We can use the "paste" command to cleverly append columns cut from "df" onto
# each print_mount_points() row of output, I believe. (Ah; well, nearly. The
# print_mount_points() print_string is not suitable for munging. Due to its
# substitution of FLAGS commas with spaces, space delimiters cannot be matched
# properly. Instead, we'll have to manually hack it from the "mount" command.
# Note, however, that "df" nearly provides all we need: it lacks only the
# filesystem type. Hmm...) Also:
#
# * It'd be very nice to lexicographically sort "df" lines by their first column,
#   ignoring the initial header.
# * For devices with labels, it'd be nice to print both the symbolic link label
#   and the target absolute path. This may require we cut some of the "df"
#   content, but is absolutely vital and hence takes precedence over that. To
#   conserve space, print only the label basename.
#
# Ah. The "blkid" command prints more of what we need: the absolute device file,
# the label, and the filesystem type. Moreover, it does so for *ALL* currently
# attached device files, mounted or not. Much better! That said, its print_string is
# not the cleanest. We'll need to munge it up quite a bit to get print_string suitable
# for piping to "column -t".
#
# Oh. Actually, under "blkid -o list", the print_string is fairly ideal. No heavy
# munging required -- save possibly for replacing the rather useless "UUID"
# column with disk size statistics.

declare_function_with_stdin <<'/---'
string print_disks(string device_filename1, string device_filename2, ...)

Print a human-readable list describing each passed device or all available
disk devices if no such devices are passed.
/---
function print_disks() {
    die_unless_pathable blkid
    command blkid -o list "${@}"
    #FIXME: Does this handle whitespace in device filenames or labels? Hmm.
    #Probably need some form of quote protection, here.
    # See print_mount_points() for details.
#   (
#       print 'DEVICE LABEL'
#       print -C2 -- /dev/disk/by-label/*(:A) /dev/disk/by-label/*(:t)
#   ) | column -t
}

# ....................{ WRITERS                            }....................
#FIXME: Rename to check_disk_with_options().
#FIXME: Right. Accept "fsck" options *FIRST*, as is the standard. Not
#particularly difficult, thankfully.

declare_function_with_stdin <<'/---'
string check_disk(
    string device_filename, string fsck_option1, string fsck_option2, ...)

Check the passed disk device for errors with the passed custom "fsck" options,
automatically repairing all such errors.
/---
function check_disk() {
    # Validate passed arguments.
    die_unless_args\
        'expected one device file and optional "fsck" arguments'
    string device_file="${1}"
    die_unless_disk_unmounted "${device_filename}"
    die_unless_pathable fsck
    shift_arg

    # Check and repair. Always enable option "-M" regardless of whether called
    # interactively or not, thus prohibiting disk repair on mounted devices.
    #
    # Do not, however, always enable options "-a" or "-p". While seemingly
    # sensible defaults, both induce "fsck" to conditionally ignore otherwise
    # repairable errors (e.g., superblock mount time in the future). Dismantled,
    # this is:
    #
    # * "-M", prohibiting disk repair on mounted devices, which current research
    #   shows to be inherently risky (on even read-only mounted devices!):
    #     http://serverfault.com/questions/405248/linux-force-fsck-of-a-read-only-mounted-filesystem
    # * "-C", displaying progress bars if interactive.
    # * "-T", not displaying the title if non-interactive.
    if { is_shell_interactive } {
        command fsck -M -C "${device_filename}" -- "${@}"
    } else {
        command fsck -M -T "${device_filename}" -- "${@}"
    }
}

# ....................{ FORMATTERS                         }....................
#FIXME: Right. Accept "mkfs" options *FIRST*, as is the standard. Not
#particularly difficult; so, let's a-go!
declare_function_with_stdin <<'/---'
string format_disk_with_options(
    string mkfs_option1, string mkfs_option2, ...,
    string device_filename,
    string filesystem_type,

Format the passed disk with the passed filesystem type under the passed `mkfs`
options.
/---
function format_disk_with_options() {
    # Validate passed arguments.
    die_unless_args\
        'expected optional "mkfs" arguments, one device filename, and one filesystem type'
    die_unless_shell_interactive
    string device_filename="${@[-2]}" filesystem_type="${@[-1]}"
    string formatter="mkfs.${filesystem_type}"
    die_unless_disk_unmounted "${device_filename}"
    die_unless_pathable "${formatter}"\
        "filesystem type \"${filesystem_type}\" unrecognized"
    pop_args 2

    # Astonishingly, "mkfs.*" commands do *NOT* ask interactive shell users to
    # confirm extremely destructive formats prior to doing so. (Really? Come on,
    # Linux! This isn't obtuse rocket science. It's common decency.)
    is_query_line_yes\
        "really format \"${device_filename}\" as ${filesystem_type}?" or
        return_false
    output_newline

    #FIXME: Naturally, we *REALLY* want to ${ZESHY_MKFS_EXT4_OPTIONS}-style list
    #globals to perform formatting with run_code_with_options_configured().
    #Here's the plan:
    #
    #* Make a new "if_config/mkfs" file containing...
    #* Empty list global ${ZESHY_MKFS_OPTIONS}.
    #* List global ${ZESHY_MKFS_OPTIONS_IF_INTERACTIVE} containing option "-v".
    #* One list global for each common filesystem type: e.g.,
    #  ${ZESHY_MKFS_EXT4_OPTIONS} and so forth. (Don't bother with
    #  "_IF_INTERACTIVE" versions of these.)

    # Format under "-v" for forced verbosity.
    if { is_string_nonempty "${label}" } {
        command "${formatter}" -v -L "${label}" "${@}" -- "${device_filename}"
    } else {
        command "${formatter}" -v               "${@}" -- "${device_filename}"
    }
}

# ....................{ FORMATTERS                         }....................
declare_function_with_stdin <<'/---'
string erase_disk_securely(string device_filename)

Securely erase all content on the passed disk, including partition headers.
While resource-consumptive, such erasure guarantees such content to be
unrecoverable with even enhanced data retrieval (e.g., forensics).
/---
function erase_disk_securely() {
    # Validate passed arguments.
    die_unless_arg 'expected one device file'
    die_unless_shell_interactive
    string device_filename="${1}"
    die_unless_disk_unmounted "${device_filename}"

    # Confirm erasure.
    is_query_line_yes\
        "really erase \"${device_filename}\"?" or return_false
    print_message "securely erasing \"${device_filename}\"... (This may take several hours to days.)"

    # Disk erasure command to be run.
    list dd; dd=( command dd bs=16M of="${device_filename}" )

    # If "pv" is installed, print an incremental progress bar during erasure.
    if { is_pathable pv } {
        command pv -- "$(get_device_random_nonblocking)" | "${dd[@]}"
    # Otherwise, print incremental status updates during erasure.
    } else {
        #FIXME: Hmm; we probably want a function get_backgrounded_pid() (or some such).
        #FIXME: Actually, how about this:
        #
        #    integer dd_pid
        #    run_code_in_background_and_set_integer_to_pid\
        #        "${dd[@]}" dd_pid

        # Erase in the background.
        "${dd[@]}" &

        # Process ID of such erasure.
        integer dd_pid=$!

        # Print incremental status updates every second until erasure completes.
        command watch -e -n1 "kill -USR1 ${dd_pid}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#(defaulting to "ext4")
#with the passed label (defaulting to the empty string) and
    #FUXME: Explicitly handle unformatted disks. What type does "blkid" print?
    # There is no reasonable use case calling this function non-interactively.
    #FUXME: is_query_character_yes_hard() is a fairly lame name for this function. How about,
    #say.., beg_boolean_strongly() or request_boolean_strictly()? (I *LOVE* the
    #latter. I mean, com' on! The "strongly" fits with encryption terminology,
    #and the "beg" is memorably rememberable.)
# * It'd be *very* nice to add implicit support for conditional paging on
#   output; basically, only page print_string when such print_string exceeds the current
#   terminal height; otherwise, print print_string as is. This has broad applicability
#   throughout Zeshy (e.g., grep, ls, du, cat).

# Filesystem checking (fsck). Note we do not implicitly pass the "-a" or "-p"
# options to fsck, as fsck ignores some filesystem errors (e.g., superblock
# mount time in the future) when those options are passed.
#() {
#    string ZESHY_FSCK_OPTIONS="-C -M -T"
#    alias_cli fsck="fsck ${ZESHY_FSCK_OPTIONS}"
#    alias_cli fsck.ext2="fsck.ext2 ${ZESHY_FSCK_OPTIONS}"
#    alias_cli fsck.ext3="fsck.ext3 ${ZESHY_FSCK_OPTIONS}"
#    alias_cli fsck.vfat="fsck.vfat ${ZESHY_FSCK_OPTIONS}"
#}

#FUXME: O.K.; the current implementation is obviously a sham. We need a new
    #getter "get_disk_filesystem" to acquire the filesystem of this disk,
    #ideally without mounting. This is trivially easy if the disk is already
    #mounted; just grep apart the print_string of "mount -l". If the disk is not
    #mounted, however, this becomes much trickier. Google whether or not there
    #are safe mechanisms for doing so.
    #
    #Ah-ha! Yes. The "blkid" commands appears to cleanly handle such things.

#alias_cli dup="print_disk_usage_paged"
#alias_cli dus="print_disk_usage_paged_sorted"
#FUXME: The following two functions fugly as heck. We really need to rename
#page() to run_code_paged() and implement dynamic paging only when the total
#length of print_string exceeds the current terminal height.
#  [ -z "$1" ] && 1="."
#  \du --all --no-dereference $1 | sort --numeric-sort --reverse | less

#FUXME: We could probably implement a more specific
#die_unless_disk_file() function accepting only block-special devices
#that are symlinked to at least once in the '/dev/disk/by-id' directory, the
#most complete listing of such disk devices.

#   print_message "really format "${device_file}" as ${filesystem_type}? [yes/no] "
#   string is_sure
#   read   is_sure
#   if is "${is_sure}" == y || "${is_sure}" == ye || "${is_sure}" == yes si; then
#       print_message      "formatting \"${device_file}\" as ${filesystem_type}..."
