#!/usr/bin/env zsh
# ====================[ mount                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle device mounting and unmounting.
#
# --------------------( TODO                               )--------------------
# * It'd be great to implement a pure-Zeshy alternative to the pure-bash
#   "devmon" script bundled with "udevil" for automounting. This script, while
#   lengthy, is well-written and readily translatable into Zeshy. (In fact, it
#   spends most of its length setting up simple functionality already provided
#   by Zeshy.) The core of "devmon" monitoring is a simple coprocess between it
#   and "udevil", which it regularly polls for new events. Simple parsing. I
#   reckon it'd be quite fun!

# ....................{ EXCEPTIONS                         }....................
#FIXME: Rename to die_unless_unmounted_disk() perhaps? This implies slightly
#different semantics, so examine usage.

declare_function '
void die_if_mounted_disk(
  string pathname,
  string error_message = "\"${pathname}\" not found or not an unmounted disk")

Throw an exception unless the passed device file corresponds to an unmounted
disk (i.e., neither the disk itself or any partition of such disk is mounted).
'
function die_if_mounted_disk() {
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_disk "${pathname}" and not is_disk_mounted "${pathname}" or
        die "${2:-\"${pathname}\" not found or not an unmounted disk}"
}

declare_function '
void die_if_mount_point(
  string pathname,
  string error_message = "\"${pathname}\" mounted")

Throw an exception if the passed path is a mount point.
'
function die_if_mount_point() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"

    #FIXME: Print what it's actually mounted to, for clarity.
    # Test and possibly throw such exception.
    is_mount_point "${pathname}" and die "${2:-\"${pathname}\" mounted}"
}

declare_function '
void die_unless_static_mount_point(
  string pathname,
  string error_message = "\"${pathname}\" not listed by \"$(get_static_mount_point_file)\"")

Throw an exception unless the passed path is listed by "/etc/fstab" and hence
statically mountable without explicitly specifying a source device file.
'
function die_unless_static_mount_point() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"

    is_static_mount_point "${pathname}" or {
        string static_filename; static_filename="$(get_static_mount_point_file)"
        die "${2:-\"${pathname}\" not listed by \"${static_filename}\"}"
    }
}

# ....................{ TESTERS                            }....................
declare_function '
boolean is_disk_mounted(string pathname)

Return true if the passed device file corresponds to a mounted disk (i.e.,
either the disk itself or some partition of such disk is currently mounted).
'
function is_disk_mounted() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"

    # Genius. Unless "blkid -o list" reports the passed disk under column "mount
    # point" as "(not mounted)", either the disk itself or some partition of
    # such disk is currently mounted. There appears to be other reasonable means
    # of testing such transitive dependencies, so this is quite essential.
    is '(not mounted)' !=\
      "$(blkid -o list | awk -v DEV="${device_filename}" '$1 == DEV { print $4, $5 }')" si
}

declare_function '
boolean is_disk_mounted_to(string device_filename, string mount_dirname)

Return true if the device with the passed filename is mounted to the directory
with the passed dirname.
'
function is_disk_mounted_to() {
    # Validate passed arguments.
    die_unless_args_2\
        'expected one device filename and mount dirname'
    string device_filename="${1}" mount_dirname="${2}"

    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    is_disk "${device_filename}" and is_dir "${mount_dirname}" or
        return_false

    #FIXME: Also implement without "mountpoint", if feasible.
    die_unless_pathable mountpoint
    is "$(mountpoint -x "${device_filename}" 2>&1)" ==\
       "$(mountpoint -d "${mount_dirname}"   2>&1)" si
}

# ....................{ TESTERS ~ mount points             }....................
#FIXME: Use of "| print_stdin_and_return_exit_status" below, while amusing, *SHOULD* be
#completely unnecessary. (I suspect we needed such expressions previously due
#to internal bugs in Zeshy's TRAPZERR() implementation, hopefully now fixed.
#Excise "| print_stdin_and_return_exit_status" below and test again.)
declare_function '
boolean is_mount_point(string dirname)

Return true if some disk is mounted to the passed directory.
'
function is_mount_point() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory readable by the current user, fail.
    if not is_dir "${mount_dirname}"
    then return_false
    # If the cross-platform portable "mountpoint" is installed, defer to such
    # command. This is more reliable than grepping file content.
    elif is_pathable mountpoint; then
        mountpoint -q "${mount_dirname}" | print_stdin_and_return_exit_status
    # If the Linux-specific "/proc/mounts" exists, grep its content. This is
    # more reliable than matching "mount" output. (See "man mount".)
    elif is_file '/proc/mounts'; then
        awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $2 == DIR {CODE=0} END {exit CODE}' '/proc/mounts' |
            print_stdin_and_return_exit_status
    # Otherwise, manually match "mount" output.
    else
        command mount | awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $3 == DIR {CODE=0} END {exit CODE}' |
            print_stdin_and_return_exit_status
    fi
}

declare_function '
boolean is_path_writable_mount_point(string dirname)

Return true if some disk is writably mounted to the passed directory.
'
function is_path_writable_mount_point() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory writable by the current user, fail.
    if not is_dir_writable "${mount_dirname}"
    then return_false
    # Since "mountpoint" has no writability option, we manually match strings.
    # This is hardly ideal, but there you are. If the Linux-specific
    # "/proc/mounts" exists, grep its content.
    elif is_file '/proc/mounts'; then
#       print_message 'testing...'
        awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$2 == DIR && $4 ~ /(^|,)rw($|,)/ { CODE = 0 }
END { exit CODE }' '/proc/mounts' | print_stdin_and_return_exit_status
#       print_message 'failed...'
    # Otherwise, manually match "mount" output.
    else
        command mount | awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$3 == DIR && $NF ~ /(,|\()rw(,|\))/ { CODE = 0 }
END { exit CODE }' | print_stdin_and_return_exit_status
    fi
}

declare_function '
boolean is_static_mount_point(string dirname)

Return true if the passed directory is listed by "/etc/fstab" and hence
mountable without explicitly specifying a source device file.
'
function is_static_mount_point() {
    die_unless_arg 'expected one dirname'
    string static_filename; static_filename="$(get_static_mount_point_file)"
    awk -v DIR="${1}" '
BEGIN { CODE = 1}
!/^[[:blank:]]*#/ && $2 == DIR { CODE = 0 }
END { exit CODE }' "${static_filename}"
}

# ....................{ GETTERS                            }....................
declare_function '
string get_mount_home(void)

Get the absolute path of the canonical directory to which the current user has
write permissions sufficient for mounting devices. Rather than returning a
static path, this function iteratively tests the following directories for
writability (in order):

* "/media".
* "/mnt".
* "${HOME}/media".
* "${HOME}/mnt".

If no such directory exists or is writable, throw an exception.
'
function get_mount_home() {
    die_if_args
    get_dir_writable_first '/media' '/mnt' "${HOME}/media" "${HOME}/mnt"
}

declare_function '
string get_static_mount_point_file(void)

Get the file statically mapping disk devices to mount points (e.g.,
"/etc/fstab").
'
function get_static_mount_point_file() {
    die_if_args
    string filename='/etc/fstab'
    die_unless_file "${filename}"
    print_string "${filename}"
}

# ....................{ GETTERS ~ mount points             }....................
declare_function '
string get_mount_points(void)

Get a newline-delimited list of the absolute paths of all mount points.
'
function get_mount_points() {
    # The third column of "mount" print_string gives the desired list. Surprisingly,
    # such list can contain duplicate mount points: e.g.,
    #
    #     # "mount" lists mount point "/" twice.
    #     >>> mount
    #     rootfs on / type rootfs (rw)
    #     /dev/mapper/vg-root on / type ext4 (rw,noatime,data=ordered)
    #
    # Hence, filter duplicate lines from the returned string.
    die_if_args
    string mount_output; mount_output="$(command mount)"
    get_string_column "${mount_output}" 3 | remove_string_line_duplicates
}

#FIXME: What's this? *sigh* I frankly can't recall. Excise, I should think.
# string get_mount_point(string mount_point_name)
#
# Get the absolute path of the passed mount point. If such point is already an
# absolute path, return such path as is; otherwise, return the first d
#get_static_mount_point_for_disk() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one device filename'
#    string device_filename="${1}"
#    die_unless_disk "${device_filename}"
#        is_path_absolute "${device_filename}" and
#            die "\"${device_filename}\" not found"
#        device_filename="$(get_device_first "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/${device_filename}")"
#}

declare_function '
string get_static_mount_point_for_disk(string device_filename)

Get the mount point to which "/etc/fstab" maps the passed disk.
'
function get_static_mount_point_for_disk() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"
    die_unless_disk "${device_filename}"

    #FIXME: Should be a pretty trivial implementation via
    #get_string_pcre_line_first_match_group(), which we'll want to augment to throw an
    #exception if no such group matches, possibly accepting an optional error
    #message (per usual). We'll probably also want a new
    #get_mount_point_setup_file() returning '/etc/fstab'. Yum.
    die "Implement me."
    string static_filename; static_filename="$(get_static_mount_point_file)"
}

# ....................{ PRINTERS                           }....................
declare_function '
string print_mount_points(void)

Print a detailed human-readable list of current mount points.
'
function print_mount_points() {
    # Validate sanity.
    die_if_args

    #FIXME: Insufficient. If "mount" encounters a non-fatal error (as occurs
    #when the kernel coerces a mounted read-write filesystem to be read-only),
    #it appends a newline-prefixed warning to such output. I'm afraid I don't
    #recall the exact output, but it's something like:
    #
    #    ...
    #    /dev/sda1 on /media/boot type ext2 rw
    #
    #    warning: "/dev/sda2" currently read-only but mounted writable; this
    #      may indicate hardware failure
    #
    #Handle this by applying the tabulation to *ONLY* that substring of "mount"
    #output preceding the first blank line, signifying warning or error output
    #(which should ideally be colorized to highlight such warning or error).

    # Dismantled, this is:
    #
    # * "print '...'", prefixing print_string with a header line.
    # * "print '-'", prefixing print_string with a banner line. (This is a temporary
    #   placeholder to be entirely replaced with a true banner line, below).
    # * "LC_ALL=C ", guaranteeing print_string from "mount" in the default format.
    # * "mount | awk", formatting print_string from "mount" through an "awk" script
    #   cutting the extraneous second and fourth columns.
    # * "(...)", aggregating such print_string into a single print_string stream.
    # * "column -t", reformatting print_string into a whitespace-delimited table.
    # * "awk", substituting commas with spaces in the flags column. Since
    #   "column -t" tabulates with such spaces, we must defer such substitution
    #   until after tabulating. Dismantled, this is:
    #   * "-v banner="$(print_hard_rule)"", passing the desired banner line to awk
    #     as an option variable.
    #   * "-F'[ ]'", preserving whitespace by treating individual spaces rather
    #     than contiguous "runs" of spaces as column delimiters.
    #   * "NR == 1", matching the first and hence header line.
    #   * "NR == 2", matching the second and hence banner line.
    #   * "NR >= 3", matching all subsequent lines print_string from "mount".
    #   * "$NF", the last and hence flags column. We can't simply write "$4", as
    #     treating individual spaces as delimiters creates "dummy" columns.
    #
    # This one-liner inspired by Peteris Krumin's magical bash one-liner at:
    # http://www.catonmat.net/blog/another-ten-one-liners-from-commandlinefu-explained
    {
        print 'device directory type flags'
        print '???'
        LC_ALL=C command mount | awk '{$2=$4=""; print}'
    } | tabulate_string | awk -v BANNER="$(print_hard_rule)" -F'[ ]' '
NR == 1 { print }
NR == 2 { print BANNER }
NR >= 3 {
    gsub(/\(|\)/, "", $NF)
    gsub(/,/, " ", $NF)
    print
}' | page_stdin
}

# ....................{ MOUNTERS                           }....................
#FIXME: Terrible name. Rename to mount_path().

declare_function '
void mount_nicely(void) --OR--
void mount_nicely(string mount_dirname) --OR--
void mount_nicely(
  string mount_option1, string mount_option2, ...,
  string device_filename) --OR--
void mount_nicely(
  string mount_option1, string mount_option2, ...,
  string device_filename, string mount_dirname)

Mount the passed disk to the passed mount point directory with the passed
mount options as follows:

* If this is an interactive shell and no arguments were passed, print a human-
  readable list of current mount points.
* If the passed device does not exist, attempt to find a device with such
  basename under these directories (in order):
  * "/dev/disk/by-label".
  * "/dev".
  * ...otherwise, raise an exception.
* If no mount point was passed, assume a mount point with the passed device
  basename under the current user''s mount home.
* If the passed mount point does not exist, recursively make it.
* If the passed mount point is already mounted to:
  * ...the passed device, do nothing.
  * ...otherwise, raise an exception.
* If the passed device is:
  * ...a device file, perform the expected mount.
  * ...a file with filetype ".iso", mount this file as an ISO image.

In other words, this function quasi-intelligently accepts darn near anything.
'
function mount_nicely() {
    # If no arguments were passed, list all current mount points.
    if is_args_0
    then print_mount_points
    # If one argument was passed listed by "/etc/fstab" as a static_mount point,
    # mount such point as such.
    elif is_args_1 and is_static_mount_point "${1}"
    then mount_point "${1}"
    # Otherwise, mount the passed device file to the passed mount point.
    else mount_disk  "${@}"
    fi
}

#FIXME: Document the fact that, if no such absolute path exists, we iteratively
#search the list of all mount points for points with such path as a basename.
declare_function '
void unmount_point(string mount_dirname1, string mount_dirname2, ...)

Unmount the passed mount point directories.
'
function unmount_point() {
    # Validate passed sanity.
    die_unless_args 'expected at least one dirname'

    # List of all mount points to be unmounted, after matching the passed globs.
    list unmount_points

    foreach mount_point ("${@}") {
        # If this path is a mount point, append it to the list of mount points
        # to be unmounted.
        if is_mount_point "${mount_point}"
        then unmount_points+="${mount_point}"
        # If this path is absolute but *NOT* a mount point, attempting to match
        # a mount point suffixed by such path is senseless. Throw an exception.
        elif is_path_absolute "${mount_point}"
        then die "\"${mount_point}\" not mounted"
        # Otherwise, append all match points suffixed by such path to the list
        # of mount points to be unmounted.
        else
            # String of newline-delimited absolute paths of all mount points.
            list mount_points mount_points_matching
            get_mount_points | set_list_to_string_lines mount_points

            # Retain only mount points matching this basename.
            set_list_to_list_matches mount_points "*/${mount_point}"

            # Append such mount points to the list.
            unmount_points+=( "${mount_points[@]}" )
        fi
    }

    #FIXME: This message isn't quite right for multiple mount points.
    # Unmount.
    interactively print_message "unmounting \"${unmount_points[@]}\"..."
    command umount -- "${unmount_points[@]}"
}

# ....................{ MOUNTERS ~ mount points            }....................
declare_function '
void mount_boot_partition_writable(void)

Mount the "/boot" partition if such partition exists and is not already mounted
writably.
'
function mount_boot_partition_writable() {
    # Validate sanity.
    die_if_args

    # If "/etc/fstab" maps some device to "/boot", mount such device.
    if is_static_mount_point '/boot'
    then mount_writable_point '/boot'
    # Otherwise, raise an exception unless "/boot" is already writable.
    elif not is_dir_writable "${mount_dirname}"
    then die\
        "\"${mount_dirname}\" neither writable or listed by \"/etc/fstab\""
    fi
}

declare_function '
void mount_point(
  string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the disk that "/etc/fstab" maps to the passed dirname to that
directory with the passed options.
'
function mount_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"
    pop_arg

    #FIXME: O.K.; for orthogonality with mount_disk(), we should really avoid
    #remounting to an already mounted directory only if such mount point
    #corresponds to the current mapping defined by /etc/fstab. (Annoying, but
    #certainly feasible.)

    # If this directory is already a mount point, return immediately.
    # Otherwise, create such directory if needed and ensure its writability.
    is_mount_point "${mount_dirname}" and return_true
    make_dir_if_not_found "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"
    die_unless_static_mount_point "${mount_dirname}"

    # Mount.
    interactively say\
        "mounting \"${mount_dirname}\" via \"/etc/fstab\"..."
    command mount "${@}" -- "${mount_dirname}"
}

declare_function '
void mount_writable_point(
 string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the device that "/etc/fstab" maps to the passed dirname to that
directory writably with the passed options.
'
function mount_writable_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"

    # If this directory is already a writable point, return immediately.
    is_path_writable_mount_point "${mount_dirname}" and return_true

    # If this directory is already mounted (and hence read-only, since the prior
    # test fell through), remount "/boot" read-write; otherwise, mount "/boot"
    # read-write.
    if is_mount_point "${mount_dirname}"
    then mount_point -o remount,rw "${@}"
    else mount_point -o         rw "${@}"
    fi
}

# ....................{ MOUNTERS ~ disks                   }....................
#FIXME: Document.
declare_function '
void mount_disk(
  string mount_option1, string mount_option2, ..., string device_filename) --OR--
void mount_disk(
  string mount_option1, string mount_option2, ...,
  string device_filename, string mount_dirname)
'
function mount_disk() {
    # Validate passed arguments.
    die_unless_args\
        'expected optional mount options, one device filename, and optional mount dirname'
    string device_filename mount_dirname

    # If the last passed argument is a writable directory, treat it as the
    # target mount point.
    if is_dir_writable "${@[-1]}"; then
        die_unless_args_2_or_more\
            'expected optional mount options, one device filename, and one mount dirname'
        device_filename="${@[-2]}"
        mount_dirname="${@[-1]}"
        pop_args_2
    # Otherwise, treat such argument as the source device file.
    else
        device_filename="${@[-1]}"
        mount_dirname="$(get_mount_home)/$(get_path_basename "${device_filename}")"
        pop_arg
    fi

    # Make the mount point, if needed.
    die_if_mount_point      "${mount_dirname}"
    make_dir_if_not_found   "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"

    # If the passed device file is instead an ISO image, mount it as such.
    if is "${device_filename}" == *.iso si; then
        interactively say\
            "mounting \"${device_filename}\" to \"${mount_dirname}\"..."
        command mount "${@}" -t iso9660 -o 'exec,loop' --\
            "${device_filename}" "${mount_dirname}"
        return_true
    fi

    # If no passed device file exists, search these directories for such file:
    #
    # * "/dev/disk/by-label".
    # * "/dev/mapper".
    # * "/dev".
    if not is_path_exists "${device_filename}"; then
        is_path_absolute "${device_filename}" and
            die "\"${device_filename}\" not found"
        device_filename="$(get_device_first "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/${device_filename}")"
    fi
    die_unless_device "${device_filename}"

    # If the passed device is already mounted to the passed directory, noop.
    # By default, "mount" unhelpfully fails with error.
    if is_disk_mounted_to "${device_filename}" "${mount_dirname}"; then
        interactively print_message "\"${device_filename}\" already mounted to \"${mount_dirname}\"."
        return_true
    fi

    # Mount.
    command mount "${@}" -- "${device_filename}" "${mount_dirname}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Alias "mount" to "mount_nicely", or perhaps simply rename the latter the
#former and improve such function so as to defer to "command mount" when non-
#interactive (much like grep()).
            #FUXME: New split_string_lines_to_list(), then:
            # get_mount_points | split_string_lines_to_list mount_points
#           mount_points=( ${(f)"$(get_mount_points)"} )
            #FUXME: O.K.; now, we need a function filtering elements from one
            #list into another. Sounds like fun. Something like
            #remove_list_elements_matching(), yes? Note: this should probably
            #act in-place on the same list. Callers may always copy it before-
            #hand, if desiring non-in-place filtering.
# string get_mount_homes(void)
#
# Get the absolute paths of all typical mount point parent directories (e.g.,
# "/mnt", "/media").
#get_mount_homes() {
#    die_if_args
#    list mount_homes
#    mount_homes=( '/media' '/mnt' "${HOME}/media" "${HOME}/mnt" )
#    convert_list_to_string mount_homes
#}

        #FUXME (new): O.K.; we need a new function testify(). (Clever, no?
        #Also consider falsify(), though that name doesn't accurately describe
        #its purpose.) Call it like this:
        #device_filename="$(testify get_device_first "/dev/disk/by-label/${device_filename}" "/dev/${device_filename}")" or die "device \"${device_filename}\" not found"
        #Simple. testify() calls the passed command via the typical run()
        #construct *BUT WRAPPED IN AN EXCEPTION HANDLER* implicitly squelching
        #any caught exception and simply converting it into a false return value.
        #That then causes the entire equality to evaluate to "false" and hence
        #implicitly throw an exception. Phew! Solved.
        #
        #FUXME: Hmm; this doesn't appear to behave as expected. If
        #get_device_first() raises an exception, I'd expect that to unwind
        #this function's stack frame as well. It doesn't. Instead, "device_filename"
        #just gets the print_string of get_device_first(), which in the case of a
        #raised exception is a stack trace. Of course, that isn't a file, so
        #the subsequent call to die_unless_disk() fails as well. This
        #strikes me as a bug, perhaps corrected by a subsequent zsh update?
#
#       mountpoint -q "${mount_dirname}" | true; print_stdin_and_return_exit_status
#       print 'here'
#       mountpoint -q "${mount_dirname}"
#       print "returned: $?"
#       mountpoint -q "${mount_dirname}" and return_true or return_false
#       mountpoint -q "${mount_dirname}" | true and return ${pipestatus[-2]}
#       mountpoint -q "${mount_dirname}" | return 1
#       mountpoint -q "${mount_dirname}" | print_stdin_and_return_exit_status
#       print 'there'
#   else is_string_nonempty "$(mount | awk '$3 == "/boot" {print $3}')"

#NR == 1 {
#    sub(/-/, " ")
#    print
#}

#   if is_string_nonempty\
#       "$(awk '!/^[[:blank:]]*#/ && $2 == "/boot" {print $2}' /etc/fstab)"; then
#   if is '/boot' == "$(awk '!/^[[:blank:]]*#/ {print $2}' /etc/fstab)" si; then

#is_disk "${device_filename}" and 

# void mount_iso(string filename)
#
# Mount the ISO image with the passed filename to a temporary directory under
# the current user's mount home.
#mount_iso() {
    # Localize and validate passed arguments.
#   die_unless_arg 'expected one ISO filename'
#   string iso_filename="${1}"
#   is "${iso_filename}" == *.iso si or
#       die "\"${iso_filename}\" not an ISO"
#   die_unless_file "${iso_filename}"
#   string ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
#   integer iso_mount_path_suffix=0
#   string  iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"\
#           iso_mount_path="${iso_mount_path_prefix}"
#   print_message 'searching for available mount point...'
#   while (is_mount_point "${iso_mount_path}") {
#       (( iso_mount_path_suffix++ ))
#       iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
#   }
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
#   print_message "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
#   make_dir_if_not_found "${iso_mount_path}" 
#   mount -t iso9660 -o 'exec,loop'\
#       "${iso_filename}" "${iso_mount_path}" or
#       die "\"${iso_filename}\" not static_mount to \"${iso_mount_path}\""
#}
#       if is_args_1 and is "${1}" == *.iso si; then
#           mount_iso "${1}"

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FUXME: This is *TERRIBLE*. Just use "mount -l" to list current mount points.
#Grepping this Linux-specific file is horrible.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# * If only one argument was passed and:
#   * ...this is an existing file with filetype "ISO", mount this file as an ISO
#     image to the current user's mount home.
#   * ...otherwise, raise an exception.

# string get_mount_points_filename(void)
#
# Get the name of the system file listing current mount points.
#get_mount_points_filename() {
#    die_if_args
#    print '/proc/mounts'
#}
