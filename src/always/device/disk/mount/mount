#!/usr/bin/env zsh
# ====================[ mount                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle device mounting and unmounting.
#
# --------------------( TODO                               )--------------------
# * It'd be great to implement a pure-Zeshy alternative to the pure-bash
#   "devmon" script bundled with "udevil" for automounting. This script, while
#   lengthy, is well-written and readily translatable into Zeshy. (In fact, it
#   spends most of its length setting up simple functionality already provided
#   by Zeshy.) The core of "devmon" monitoring is a simple coprocess between it
#   and "udevil", which it regularly polls for new events. Simple parsing. I
#   reckon it'd be quite fun!

#FIXME: Split functions dealing with mount points into a new component
#"device/disk/mount/point".
#FIXME: When mounting by label, avoid accessing "/dev/disk/by-label/" symbolic
#links, which are notoriously unreliable. Rather, use option "-L" of external
#command "blkid", designed explicitly for such situations. In fact, mapping from
#disk labels to paths is a sufficiently important function to be a new function,
#don't you think? How about get_disk_labeled()? Simple; to the point!
#FIXME: The use of "awk" *EVERYWHERE* below is fairly hideous. Strip it out;
#replace it with pure-zeshy. A shame we didn't do so initially, eh? *sigh*

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_disk_unmounted(
    string device_filename,
    string error_message = "\"${device_filename}\" not an unmounted disk")

Throw an exception with the passed message unless the passed disk is unmounted.
See is_disk_unmounted() for further details.
________________<heredoc?>________________
function die_unless_disk_unmounted() {
    die_unless_args_1_to_2\
        'expected one device filename and optional error message'
    string filename="${1}"
    is_disk_unmounted "${filename}" or
        die "${2:-\"${filename}\" not an unmounted disk}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_if_dir_mount_point(
    string dirname,
    string error_message = "\"${pathname}\" currently mounted")

Throw an exception if the passed directory is a mount point. See
is_dir_mount_point() for further details.
________________<heredoc?>________________
function die_if_dir_mount_point() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"

    #FIXME: Print what it's actually mounted to, for clarity.
    # Test and possibly throw such exception.
    is_dir_mount_point "${pathname}" and die "${2:-\"${pathname}\" currently mounted}"
}

#FIXME: Rename to die_unless_mount_point_static().
#FIXME: Actually, the nomenclature's not quite right -- either here or for
#is_dir_mountable_statically(). This should be die_unless_dir_statically_mountable(),
#since such directory is *NOT* a mount point until it's actually mounted to.
#We're only testing here whether "/etc/fstab" lists such directory -- not
#whether it's also currently mounted to.
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_dir_mountable_statically(
    string dirname,
    string error_message = "\"${dirname}\" not listed by \"$(get_static_mount_point_file)\"")

Throw an exception with the passed message unless the passed path is a static
mount point. See is_dir_mountable_statically() for further details.
________________<heredoc?>________________
function die_unless_dir_mountable_statically() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one pathname and optional error message'
    string pathname="${1}"

    # Test such mount point.
    is_dir_mountable_statically "${pathname}" or {
        string static_filename; static_filename="$(get_static_mount_point_file)"
        die "${2:-\"${pathname}\" not listed by \"${static_filename}\"}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_disk_mounted(string device_filename)

Return success if either the passed disk or some partition of such disk is
currently mounted.
________________<heredoc?>________________
function is_disk_mounted() {
    not is_disk_unmounted "${@}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_disk_unmounted(string device_filename)

Return success if neither the passed disk or some partition of such disk is
currently mounted.
________________<heredoc?>________________
function is_disk_unmounted() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"

    #FIXME: Clearly, it'd be great to implement this *WITHOUT* "awk". Examine.

    # If "blkid -o list" reports such disk under column "mount point" to be
    # "(not mounted)", neither the disk itself or some partition of such disk is
    # currently mounted. Since there appears to be no reasonable means of
    # testing partition dependencies from the command line, this is great.
    is_string_equals\
        "$(blkid -o list | awk -v DEV="${device_filename}" '$1 == DEV { print $4, $5 }')"\
        '(not mounted)'
}

#FIXME: Rename to is_disk_mounted_to_dir().
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_disk_mounted_to(
    string device_filename, string mount_dirname)

Return success if the device with the passed filename is mounted to the directory
with the passed dirname.
________________<heredoc?>________________
function is_disk_mounted_to() {
    # Validate passed arguments.
    die_unless_args_2\
        'expected one device filename and mount dirname'
    string device_filename="${1}" mount_dirname="${2}"

    # If the passed pathname does not correspond to an existing directory, it
    # cannot correspond to a valid mount point.
    is_disk "${device_filename}" and is_dir "${mount_dirname}" or
        return_false

    #FIXME: Also implement without "mountpoint", if feasible.
    die_unless_pathable mountpoint
    is "$(mountpoint -x "${device_filename}" 2>&1)" ==\
       "$(mountpoint -d "${mount_dirname}"   2>&1)" si
}

# ....................{ TESTERS ~ mount points             }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_dir_mount_point(string dirname)

Return true if some disk is mounted to the passed directory.
________________<heredoc?>________________
function is_dir_mount_point() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory readable by the current user, fail.
    if not is_dir "${mount_dirname}"
    then return_false
    # If the cross-platform portable "mountpoint" is installed, defer to such
    # command. This is more reliable than grepping file content.
    elif is_pathable mountpoint; then
        mountpoint -q "${mount_dirname}" | print_stdin_and_return_exit_status
    # If the Linux-specific "/proc/mounts" exists, grep its content. This is
    # more reliable than matching "mount" output. (See "man mount".)
    elif is_file '/proc/mounts'; then
        awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $2 == DIR {CODE=0} END {exit CODE}' '/proc/mounts' |
            print_stdin_and_return_exit_status
    # Otherwise, manually match "mount" output.
    else
        command mount | awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $3 == DIR {CODE=0} END {exit CODE}' |
            print_stdin_and_return_exit_status
    fi
}

declare_function '
boolean is_dir_mount_point_writable(string dirname)

Return true if some disk is writably mounted to the passed directory.
'
function is_dir_mount_point_writable() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory writable by the current user, fail.
    if not is_dir_writable "${mount_dirname}"
    then return_false
    # Since "mountpoint" has no writability option, we manually match strings.
    # This is hardly ideal, but there you are. If the Linux-specific
    # "/proc/mounts" exists, grep its content.
    elif is_file '/proc/mounts'; then
#       print_message 'testing...'
        awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$2 == DIR && $4 ~ /(^|,)rw($|,)/ { CODE = 0 }
END { exit CODE }' '/proc/mounts' | return_exit_status
#       print_message 'failed...'
    # Otherwise, manually match "mount" output.
    else
        command mount | awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$3 == DIR && $NF ~ /(,|\()rw(,|\))/ { CODE = 0 }
END { exit CODE }' | return_exit_status
    fi
}

#FIXME: Rename to is_dir_mount_point_static().
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_dir_mountable_statically(string dirname)

Return success if the passed directory is a *static mount point* (i.e., listed
by `/etc/fstab` and hence mountable without specifying a device file).
________________<heredoc?>________________
function is_dir_mountable_statically() {
    die_unless_arg 'expected one dirname'
    string static_filename; static_filename="$(get_static_mount_point_file)"
    awk -v DIR="${1}" '
BEGIN { CODE = 1}
!/^[[:blank:]]*#/ && $2 == DIR { CODE = 0 }
END { exit CODE }' "${static_filename}"
}

# ....................{ GETTERS                            }....................
declare_function '
string get_mount_home(void)

Get the absolute path of the canonical directory to which the current user has
write permissions sufficient for mounting devices. Rather than returning a
static path, this function iteratively tests the following directories for
writability (in order):

* "/media".
* "/mnt".
* "${HOME}/media".
* "${HOME}/mnt".

If no such directory exists or is writable, throw an exception.
'
function get_mount_home() {
    die_if_args
    get_dir_writable_first '/media' '/mnt' "${HOME}/media" "${HOME}/mnt"
}

declare_function '
string get_static_mount_point_file(void)

Get the file statically mapping disk devices to mount points (e.g.,
"/etc/fstab").
'
function get_static_mount_point_file() {
    die_if_args
    string filename='/etc/fstab'
    die_unless_file "${filename}"
    print_string "${filename}"
}

# ....................{ GETTERS ~ mount points             }....................
declare_function '
string get_mount_points(void)

Get a newline-delimited list of the absolute paths of all mount points.
'
function get_mount_points() {
    # The third column of "mount" print_string gives the desired list. Surprisingly,
    # such list can contain duplicate mount points: e.g.,
    #
    #     # "mount" lists mount point "/" twice.
    #     >>> mount
    #     rootfs on / type rootfs (rw)
    #     /dev/mapper/vg-root on / type ext4 (rw,noatime,data=ordered)
    #
    # Hence, filter duplicate lines from the returned string.
    die_if_args
    string mount_output; mount_output="$(command mount)"
    get_string_lines_word "${mount_output}" 3 | remove_string_line_duplicates
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string get_static_mount_point_for_disk(string device_filename)

Get the mount point to which `/etc/fstab` maps the passed disk.
________________<heredoc?>________________
function get_static_mount_point_for_disk() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"
    die_unless_disk "${device_filename}"

    #FIXME: Should be a pretty trivial implementation via
    #get_string_pcre_line_first_match_group(), which we'll want to augment to throw an
    #exception if no such group matches, possibly accepting an optional error
    #message (per usual). We'll probably also want a new
    #get_mount_point_setup_file() returning '/etc/fstab'. Yum.
    die "Implement me."
    string static_filename; static_filename="$(get_static_mount_point_file)"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_mount_points(void)

Print a human-readable list of current mount points.
________________<heredoc?>________________
function print_mount_points() {
    # Validate sanity.
    die_if_args

    #FIXME: Insufficient. If "mount" encounters a non-fatal error (as occurs
    #when the kernel coerces a mounted read-write filesystem to be read-only),
    #it appends a newline-prefixed warning to such output. I'm afraid I don't
    #recall the exact output, but it's something like:
    #
    #    ...
    #    /dev/sda1 on /media/boot type ext2 rw
    #
    #    warning: "/dev/sda2" currently read-only but mounted writable; this
    #      may indicate hardware failure
    #
    #Handle this by applying the tabulation to *ONLY* that substring of "mount"
    #output preceding the first blank line, signifying warning or error output
    #(which should ideally be colorized to highlight such warning or error).

    # Dismantled, this is:
    #
    # * "print '...'", prefixing print_string with a header line.
    # * "print '-'", prefixing print_string with a banner line. (This is a temporary
    #   placeholder to be entirely replaced with a true banner line, below).
    # * "LC_ALL=C ", guaranteeing print_string from "mount" in the default format.
    # * "mount | awk", formatting print_string from "mount" through an "awk" script
    #   cutting the extraneous second and fourth columns.
    # * "(...)", aggregating such print_string into a single print_string stream.
    # * "column -t", reformatting print_string into a whitespace-delimited table.
    # * "awk", substituting commas with spaces in the flags column. Since
    #   "column -t" tabulates with such spaces, we must defer such substitution
    #   until after tabulating. Dismantled, this is:
    #   * "-v banner="$(print_hard_rule)"", passing the desired banner line to awk
    #     as an option variable.
    #   * "-F'[ ]'", preserving whitespace by treating individual spaces rather
    #     than contiguous "runs" of spaces as column delimiters.
    #   * "NR == 1", matching the first and hence header line.
    #   * "NR == 2", matching the second and hence banner line.
    #   * "NR >= 3", matching all subsequent lines print_string from "mount".
    #   * "$NF", the last and hence flags column. We can't simply write "$4", as
    #     treating individual spaces as delimiters creates "dummy" columns.
    #
    # This one-liner inspired by Peteris Krumin's magical bash one-liner at:
    # http://www.catonmat.net/blog/another-ten-one-liners-from-commandlinefu-explained
    {
        print 'device directory type flags'
        print '???'
        LC_ALL=C command mount | awk '{$2=$4=""; print}'
    } | tabulate_stdin_on_whitespace |
        awk -v BANNER="$(print_hard_rule)" -F'[ ]' '
NR == 1 { print }
NR == 2 { print BANNER }
NR >= 3 {
    gsub(/\(|\)/, "", $NF)
    gsub(/,/, " ", $NF)
    print
}' | page_stdin
}

# ....................{ MOUNTERS                           }....................
#FIXME: Terrible name. Rename to mount_path_with_options().
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_nicely(void) --OR--
void mount_nicely(string mount_dirname) --OR--
void mount_nicely(
    string mount_option1, string mount_option2, ...,
    string device_filename) --OR--
void mount_nicely(
    string mount_option1, string mount_option2, ...,
    string device_filename, string mount_dirname)

Mount the passed disk to the passed mount point directory with the passed
mount options as follows:

* If this is an interactive shell and no arguments were passed, print a human-
  readable list of current mount points.
* If the passed device does not exist, attempt to find a device with such
  basename under these directories (in order):
  * `/dev/disk/by-label`.
  * `/dev`.
  * ...otherwise, raise an exception.
* If no mount point was passed, assume a mount point with the passed device
  basename under the current user's mount home.
* If the passed mount point does not exist, recursively make it.
* If the passed mount point is already mounted to:
  * ...the passed device, do nothing.
  * ...otherwise, raise an exception.
* If the passed device is:
  * ...a device file, perform the expected mount.
  * ...a file with filetype `.iso`, mount this file as an ISO image.

In other words, this function quasi-intelligently accepts darn near anything.
________________<heredoc?>________________
function mount_nicely() {
    # If no arguments were passed, list all current mount points.
    if { is_args_0 } {
        print_mount_points
    # If one argument was passed listed by "/etc/fstab" as a static_mount point,
    # mount such point as such.
    } elif { is_args_1 and is_dir_mountable_statically "${1}" }
        mount_point "${1}"
    # Otherwise, mount the passed device file to the passed mount point.
    } else {
        mount_disk  "${@}"
    }
}

#FIXME: Rename to unmount_dir().
#FIXME: Document the fact that, if no such absolute path exists, we iteratively
#search the list of all mount points for points with such path as a basename.
declare_function_with_stdin <<'________________<heredoc?>________________'
void unmount_point(string mount_dirname1, string mount_dirname2, ...)

Unmount the passed mounted directories.
________________<heredoc?>________________
function unmount_point() {
    # Validate passed sanity.
    die_unless_args 'expected at least one dirname'

    # List of all mount points to be unmounted, after matching the passed globs.
    list unmount_points

    foreach mount_point ("${@}") {
        # If this path is a mount point, append it to the list of mount points
        # to be unmounted.
        if { is_dir_mount_point "${mount_point}" }
            unmount_points+="${mount_point}"
        # If this path is absolute but *NOT* a mount point, attempting to match
        # a mount point suffixed by such path is senseless. Throw an exception.
        } elif { is_path_absolute "${mount_point}" } {
            die "\"${mount_point}\" not mounted"
        # Otherwise, append all match points suffixed by such path to the list
        # of mount points to be unmounted.
        } else {
            # String of newline-delimited absolute paths of all mount points.
            list mount_points mount_points_matching
            get_mount_points | set_list_to_string_lines mount_points

            # Retain only mount points matching this basename.
            set_list_to_list_matches mount_points "*/${mount_point}"

            # Append such mount points to the list.
            unmount_points+=( "${mount_points[@]}" )
        }
    }

    #FIXME: This message isn't quite right for multiple mount points.
    # Unmount.
    interactively print_message "unmounting \"${unmount_points[@]}\"..."
    command umount -- "${unmount_points[@]}"
}

# ....................{ MOUNTERS ~ mount points            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_boot_partition_writable(void)

Mount the `/boot` partition if such partition exists and not already mounted
writably.
________________<heredoc?>________________
function mount_boot_partition_writable() {
    # Validate sanity.
    die_if_args

    # If "/etc/fstab" maps some device to "/boot", mount such device.
    if { is_dir_mountable_statically '/boot' }
        mount_writable_point '/boot'
    # Else, raise an exception unless "/boot" is already writable.
    } elif { not is_dir_writable "${mount_dirname}" }
        die "\"${mount_dirname}\" unwritable and not listed by \"/etc/fstab\""
    }
}

#FIXME: Rename to mount_dir_statically(). Do we actually require the options?
#Contemplate simplifying this.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_point(
    string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the disk that `/etc/fstab` maps to the passed directory to that
directory with the passed options.
________________<heredoc?>________________
function mount_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"
    pop_arg

    #FIXME: O.K.; for orthogonality with mount_disk(), we should really avoid
    #remounting to an already mounted directory only if such mount point
    #corresponds to the current mapping defined by /etc/fstab. (Annoying, but
    #certainly feasible.)

    # If this directory is already a mount point, return immediately.
    # Otherwise, create such directory if needed and ensure its writability.
    is_dir_mount_point "${mount_dirname}" and return_true
    make_dir_if_not_found "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"
    die_unless_dir_mountable_statically "${mount_dirname}"

    # Mount.
    interactively say\
        "mounting \"${mount_dirname}\" via \"/etc/fstab\"..."
    command mount "${@}" -- "${mount_dirname}"
}

#FIXME: Rename to mount_dir_statically_writable_with_options(). Do we actually
#require the options, though? Contemplate simplifying this.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_writable_point(
   string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the device that `/etc/fstab` maps to the passed dirname to that
directory writably with the passed options.
________________<heredoc?>________________
function mount_writable_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"

    # If this directory is already a writable point, return immediately.
    is_dir_mount_point_writable "${mount_dirname}" and return_true

    # If this directory is already mounted (and hence read-only, since the prior
    # test fell through), remount "/boot" read-write; otherwise, mount "/boot"
    # read-write.
    if { is_dir_mount_point "${mount_dirname}" } {
        mount_point -o remount,rw "${@}"
    } else {
        mount_point -o         rw "${@}"
    }
}

# ....................{ MOUNTERS ~ disks                   }....................
#FIXME: Document.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_disk(
    string mount_option1, string mount_option2, ..., string device_filename) --OR--
void mount_disk(
    string mount_option1, string mount_option2, ...,
    string device_filename, string mount_dirname)
________________<heredoc?>________________
function mount_disk() {
    # Validate passed arguments.
    die_unless_args\
        'expected optional mount options, one device filename, and optional mount dirname'
    string device_filename mount_dirname

    # If the last passed argument is a writable directory, treat it as the
    # target mount point.
    if { is_dir_writable "${@[-1]}" } {
        die_unless_args_2_or_more\
            'expected optional mount options, one device filename, and one mount dirname'
        device_filename="${@[-2]}"
        mount_dirname="${@[-1]}"
        pop_args 2
    # Otherwise, treat such argument as the source device file.
    } else {
        device_filename="${@[-1]}"
        mount_dirname="$(get_mount_home)/$(get_path_basename "${device_filename}")"
        pop_arg
    }

    # Make the mount point, if needed.
    die_if_dir_mount_point      "${mount_dirname}"
    make_dir_if_not_found   "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"

    # If the passed device file is instead an ISO image, mount it as such.
    is_file_type "${device_filename}" 'iso' and {
        interactively say\
            "mounting \"${device_filename}\" to \"${mount_dirname}\"..."
        command mount "${@}" -t iso9660 -o 'exec,loop' --\
            "${device_filename}" "${mount_dirname}"
        return_true
    }

    # If no passed device file exists, search these directories for such file:
    #
    # * "/dev/disk/by-label".
    # * "/dev/mapper".
    # * "/dev".
    is_path_exists "${device_filename}" or {
        is_path_absolute "${device_filename}" and
            die "\"${device_filename}\" not found"
        device_filename="$(get_device_first "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/${device_filename}")"
    }
    die_unless_device "${device_filename}"

    # If the passed device is already mounted to the passed directory, noop.
    # By default, "mount" unhelpfully fails with error.
    is_disk_mounted_to "${device_filename}" "${mount_dirname}" and {
        interactively print_message "\"${device_filename}\" already mounted to \"${mount_dirname}\"."
        return_true
    }

    # Mount.
    command mount "${@}" -- "${device_filename}" "${mount_dirname}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Use of "| print_stdin_and_return_exit_status" below, while amusing, *SHOULD* be
#completely unnecessary. (I suspect we needed such expressions previously due
#to internal bugs in Zeshy's TRAPZERR() implementation, hopefully now fixed.
#Excise "| print_stdin_and_return_exit_status" below and test again.)
#FUXME: Rename to die_unless_disk_unmounted() perhaps? This implies slightly
#different semantics, so examine usage.
#FUXME: O.K.; examined. Just do it; it's fine. :}

#FUXME: What's this? *sigh* I frankly can't recall. Excise, I should think.
# string get_mount_point(string mount_point_name)
#
# Get the absolute path of the passed mount point. If such point is already an
# absolute path, return such path as is; otherwise, return the first d
#get_static_mount_point_for_disk() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one device filename'
#    string device_filename="${1}"
#    die_unless_disk "${device_filename}"
#        is_path_absolute "${device_filename}" and
#            die "\"${device_filename}\" not found"
#        device_filename="$(get_device_first "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/${device_filename}")"
#}

#FUXME: Alias "mount" to "mount_nicely", or perhaps simply rename the latter the
#former and improve such function so as to defer to "command mount" when non-
#interactive (much like grep()).
            #FUXME: New split_string_lines_to_list(), then:
            # get_mount_points | split_string_lines_to_list mount_points
#           mount_points=( ${(f)"$(get_mount_points)"} )
            #FUXME: O.K.; now, we need a function filtering elements from one
            #list into another. Sounds like fun. Something like
            #remove_list_elements_matching(), yes? Note: this should probably
            #act in-place on the same list. Callers may always copy it before-
            #hand, if desiring non-in-place filtering.
# string get_mount_homes(void)
#
# Get the absolute paths of all typical mount point parent directories (e.g.,
# "/mnt", "/media").
#get_mount_homes() {
#    die_if_args
#    list mount_homes
#    mount_homes=( '/media' '/mnt' "${HOME}/media" "${HOME}/mnt" )
#    convert_list_to_string mount_homes
#}

        #FUXME (new): O.K.; we need a new function testify(). (Clever, no?
        #Also consider falsify(), though that name doesn't accurately describe
        #its purpose.) Call it like this:
        #device_filename="$(testify get_device_first "/dev/disk/by-label/${device_filename}" "/dev/${device_filename}")" or die "device \"${device_filename}\" not found"
        #Simple. testify() calls the passed command via the typical run()
        #construct *BUT WRAPPED IN AN EXCEPTION HANDLER* implicitly squelching
        #any caught exception and simply converting it into a false return value.
        #That then causes the entire equality to evaluate to "false" and hence
        #implicitly throw an exception. Phew! Solved.
        #
        #FUXME: Hmm; this doesn't appear to behave as expected. If
        #get_device_first() raises an exception, I'd expect that to unwind
        #this function's stack frame as well. It doesn't. Instead, "device_filename"
        #just gets the print_string of get_device_first(), which in the case of a
        #raised exception is a stack trace. Of course, that isn't a file, so
        #the subsequent call to die_unless_disk() fails as well. This
        #strikes me as a bug, perhaps corrected by a subsequent zsh update?
#
#       mountpoint -q "${mount_dirname}" | true; print_stdin_and_return_exit_status
#       print 'here'
#       mountpoint -q "${mount_dirname}"
#       print "returned: $?"
#       mountpoint -q "${mount_dirname}" and return_true or return_false
#       mountpoint -q "${mount_dirname}" | true and return ${pipestatus[-2]}
#       mountpoint -q "${mount_dirname}" | return 1
#       mountpoint -q "${mount_dirname}" | print_stdin_and_return_exit_status
#       print 'there'
#   else is_string_nonempty "$(mount | awk '$3 == "/boot" {print $3}')"

#NR == 1 {
#    sub(/-/, " ")
#    print
#}

#   if is_string_nonempty\
#       "$(awk '!/^[[:blank:]]*#/ && $2 == "/boot" {print $2}' /etc/fstab)"; then
#   if is '/boot' == "$(awk '!/^[[:blank:]]*#/ {print $2}' /etc/fstab)" si; then

#is_disk "${device_filename}" and 

# void mount_iso(string filename)
#
# Mount the ISO image with the passed filename to a temporary directory under
# the current user's mount home.
#mount_iso() {
    # Localize and validate passed arguments.
#   die_unless_arg 'expected one ISO filename'
#   string iso_filename="${1}"
#   is "${iso_filename}" == *.iso si or
#       die "\"${iso_filename}\" not an ISO"
#   die_unless_file "${iso_filename}"
#   string ZESHY_SCRIPT_NAME='mount_iso'

    # Find a suitable mount path.
#   integer iso_mount_path_suffix=0
#   string  iso_mount_path_prefix="${ZESHY_MOUNT_ISO_PATH}"\
#           iso_mount_path="${iso_mount_path_prefix}"
#   print_message 'searching for available mount point...'
#   while (is_dir_mount_point "${iso_mount_path}") {
#       (( iso_mount_path_suffix++ ))
#       iso_mount_path="${iso_mount_path_prefix}${iso_mount_path_suffix}"
#   }
    
    # Mount the passed ISO filename to the desired mount path.
    #
    # Note that this does not pass the ",user" option when mounting, as doing so
    # would implicitly enables unhelpful mount options (e.g., "noexec").
#   print_message "mounting \"${iso_filename}\" to \"${iso_mount_path}\"..."
#   make_dir_if_not_found "${iso_mount_path}" 
#   mount -t iso9660 -o 'exec,loop'\
#       "${iso_filename}" "${iso_mount_path}" or
#       die "\"${iso_filename}\" not static_mount to \"${iso_mount_path}\""
#}
#       if is_args_1 and is "${1}" == *.iso si; then
#           mount_iso "${1}"

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FUXME: This is *TERRIBLE*. Just use "mount -l" to list current mount points.
#Grepping this Linux-specific file is horrible.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# * If only one argument was passed and:
#   * ...this is an existing file with filetype "ISO", mount this file as an ISO
#     image to the current user's mount home.
#   * ...otherwise, raise an exception.

# string get_mount_points_filename(void)
#
# Get the name of the system file listing current mount points.
#get_mount_points_filename() {
#    die_if_args
#    print '/proc/mounts'
#}
