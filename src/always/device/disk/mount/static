#!/usr/bin/env zsh
# ====================[ static                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle *statically mountable directories* (i.e., directories mountable without
# explicitly specifying the source disk or disk partition to be mounted).

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_dir_mountable_statically(
    string dirname,
    string error_message =\
        "\"${dirname}\" not listed by \"$(get_static_mount_point_file)\"")

Throw an exception with the passed message unless the passed directory is an
existing static mount point. See is_dir_mountable_statically() for further
details.
________________<heredoc?>________________
function die_unless_dir_mountable_statically() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one dirname and optional error message'
    string dirname="${1}"

    # Test such mount point.
    is_dir_mountable_statically "${dirname}" or {
        string static_filename; static_filename="$(get_static_mount_point_file)"
        die "${2:-\"${dirname}\" not listed by \"${static_filename}\"}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_dir_mountable_statically(string dirname)

Return success if the passed directory is a *static mount point* (i.e., listed
by `/etc/fstab` and hence implicitly mountable without explicitly specifying a
source disk or disk partition from which to mount).
________________<heredoc?>________________
function is_dir_mountable_statically() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string dirname="${1}"

    # For each line of "/etc/fstab", if the second field of such line
    # signifying a mount point matches such directory, return success. Ignore
    # comments (i.e., lines prefixed by optional whitespace followed by a "#").
    # Since the simplest (though not necessarily readable) means of immediately
    # returning from such iteration is to return failure on success and success
    # on failure, invert the exit status of such iteration to return the
    # expected exit status to our caller.
    not for_string_line_fields_split_on_whitespace\
        "$(get_static_mount_point_file)" '
        is "${match[1]}" != [[:blank:]]#"#"* and
           "${match[2]-}" == "${dirname}" si and return_false'
}

# ....................{ GETTERS                            }....................
#FIXME: Rename to get_mount_points_static_file(). Hmm; that's rather poor. How
#about get_dir_mountable_statically_file()? Yup! The latter fits our
#nomenclature here.
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_static_mount_point_file(void)

Get the file statically mapping disk devices to mount points (e.g.,
`/etc/fstab`).
________________<heredoc?>________________
function get_static_mount_point_file() {
    die_if_args
    string filename='/etc/fstab'
    die_unless_file "${filename}"
    output_string "${filename}"
}

#FIXME: Rename to get_dir_mountable_statically_for_disk() or perhaps
#get_disk_dir_mountable_statically(). While the former strikes me as both more
#legible and in better keeping with nomenclature, this could even reasonably be
#a converter: e.g., convert_disk_to_dir_mountable_statically(). Uhm; no. That
#implies *FAR* more than is done here. (Perhaps
#map_disk_to_dir_mountable_statically()? Nah. Getters are more readable.) O.K.;
#so, get_dir_mountable_statically_for_disk() it is.
declare_function_with_stdin <<'________________<heredoc?>________________'
string get_static_mount_point_for_disk(string device_filename)

Get the mount point to which `/etc/fstab` maps the passed disk.
________________<heredoc?>________________
function get_static_mount_point_for_disk() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"
    die_unless_disk "${device_filename}"

    #FIXME: Should be a pretty trivial implementation via
    #get_string_pcre_line_first_match_group(), which we'll want to augment to throw an
    #exception if no such group matches, possibly accepting an optional error
    #message (per usual). We'll probably also want a new
    #get_mount_point_setup_file() returning '/etc/fstab'. Yum.
    die "Implement me."
    string static_filename; static_filename="$(get_static_mount_point_file)"
}

# ....................{ MOUNTERS                           }....................
#FIXME: Rename to mount_dir_statically(). Do we actually require the options?
#Contemplate simplifying this.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_point(
    string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the disk that `/etc/fstab` maps to the passed directory to that
directory with the passed options.
________________<heredoc?>________________
function mount_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"
    pop_arg

    #FIXME: O.K.; for orthogonality with mount_disk(), we should really avoid
    #remounting to an already mounted directory only if such mount point
    #corresponds to the current mapping defined by /etc/fstab. (Annoying, but
    #certainly feasible.)

    # If this directory is already a mount point, return immediately.
    # Otherwise, create such directory if needed and ensure its writability.
    is_dir_mount_point "${mount_dirname}" and return_true
    make_dir_if_not_found "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"
    die_unless_dir_mountable_statically "${mount_dirname}"

    # Mount.
    print_message_interactively\
        "mounting \"${mount_dirname}\" via \"/etc/fstab\"..."
    command mount "${@}" -- "${mount_dirname}"
}

#FIXME: Rename to mount_dir_statically_writable_with_options(). Do we actually
#require the options, though? Contemplate simplifying this.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_writable_point(
   string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the device that `/etc/fstab` maps to the passed dirname to that
directory writably with the passed options.
________________<heredoc?>________________
function mount_writable_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"

    # If this directory is already a writable point, return immediately.
    is_dir_mount_point_writable "${mount_dirname}" and return_true

    # If this directory is already mounted (and hence read-only, since the prior
    # test fell through), remount "/boot" read-write; otherwise, mount "/boot"
    # read-write.
    if { is_dir_mount_point "${mount_dirname}" } {
        mount_point -o remount,rw "${@}"
    } else {
        mount_point -o         rw "${@}"
    }
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Encapsulate this with a new return_exit_status_inverted_silent() alias,
    #returning true if the piped command returns false and false otherwise.
#   if { for_string_line_fields_split_on_whitespace\
#       "$(get_static_mount_point_file)" '
#       is "${match[1]}" != [[:blank:]]#"#"* and
#          "${match[2]-}" == "${dirname}" si and return_false' } {
#       return_true
#   } else {
#       return_false
#   }

    #FUXME: Terrible. We want to call a new function is
#    awk -v DIR="${1}" '
#BEGIN { CODE = 1}
#!/^[[:blank:]]*#/ && $2 == DIR { CODE = 0 }
#END { exit CODE }' "$(get_static_mount_point_file)"
