#!/usr/bin/env zsh
# ====================[ point                              ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle mount points (i.e., directories currently mounting a disk or disk
# partition).

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void die_if_dir_mount_point(
    string dirname,
    string error_message = "\"${dirname}\" already a mount point")

Throw an exception with the passed message if the passed directory is an
existing mount point. See is_dir_mount_point() for further details.
________________<heredoc?>________________
function die_if_dir_mount_point() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one dirname and optional error message'
    string dirname="${1}"

    #FIXME: Print what it's actually mounted to, for clarity.
    # Test and possibly throw such exception.
    is_dir_mount_point "${dirname}" and
        die "${2:-\"${dirname}\" already a mount point}"
}

declare_function_with_stdin <<'________________<heredoc?>________________'
void die_unless_dir_mountable_statically(
    string dirname,
    string error_message = "\"${dirname}\" not listed by \"$(get_static_mount_point_file)\"")

Throw an exception with the passed message unless the passed directory is an
existing static mount point. See is_dir_mountable_statically() for further
details.
________________<heredoc?>________________
function die_unless_dir_mountable_statically() {
    # Validate passed arguments.
    die_unless_args_1_to_2\
        'expected one dirname and optional error message'
    string dirname="${1}"

    # Test such mount point.
    is_dir_mountable_statically "${dirname}" or {
        string static_filename; static_filename="$(get_static_mount_point_file)"
        die "${2:-\"${dirname}\" not listed by \"${static_filename}\"}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_dir_mount_point(string dirname)

Return success if the passed directory is a *mount point* (i.e., an existing
directory to which some disk or disk partition is at least readably mounted).
________________<heredoc?>________________
function is_dir_mount_point() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory readable by the current user, fail.
    if { not is_dir "${mount_dirname}" } {
        return_false
    # If the cross-platform portable "mountpoint" is installed, defer to such
    # command. This is more reliable than grepping file content.
    } elif { is_pathable mountpoint } {
        mountpoint -q "${mount_dirname}" | return_exit_status
    #FIXME: Unclear as to why this edge case exists. Why not simply always match
    #"mount" output?

    # If the Linux-specific "/proc/mounts" exists, grep its content. This is
    # more reliable than matching "mount" output. (See "man mount".)
    } elif { is_file '/proc/mounts' } {
        #FIXME: See below.
        awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $2 == DIR {CODE=0} END {exit CODE}' '/proc/mounts' |
            return_exit_status
    # Otherwise, manually match "mount" output.
    } else {
        #FIXME: O.K.; this shouldn't be terribly difficult to implement in pure-
        #zsh. We'll want a new is_string_line_with_column_index_equals() function in
        #component "variable/string/pcre/column". This should be *VERY* efficiently
        #implementable with a multiline PCRE iterated over by calling
        #for_string_matches_pcre_multiline(). The nomenclature for such function
        #resembles the similar function discussed below.

        command mount | awk -v DIR="${mount_dirname}"\
            'BEGIN {CODE=1} $3 == DIR {CODE=0} END {exit CODE}' |
            return_exit_status
    }
}

declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_dir_mount_point_writable(string dirname)

Return success if the passed directory is a *writable mount point* (i.e., an
existing directory to which some disk or disk partition is writably mounted).
________________<heredoc?>________________
function is_dir_mount_point_writable() {
    # Validate passed arguments.
    die_unless_arg 'expected one dirname'
    string mount_dirname="${1}"

    # If the passed path is not a directory writable by the current user, fail.
    if { not is_dir_writable "${mount_dirname}" } {
        return_false
    #FIXME: Unclear as to why this edge case exists. Why not simply always match
    #"mount" output?
    # Since "mountpoint" has no writability option, we manually match strings.
    # This is hardly ideal, but there you are. If the Linux-specific
    # "/proc/mounts" exists, grep its content.
    } elif { is_file '/proc/mounts' } {
#       print_message 'testing...'
        awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$2 == DIR && $4 ~ /(^|,)rw($|,)/ { CODE = 0 }
END { exit CODE }' '/proc/mounts' | return_exit_status
#       print_message 'failed...'
    # Else, manually match "mount" output.
    } else {
        #FIXME: This can presumably be implemented in pure-zsh with a new
        #function get_string_line_first_with_column_index_equals() in component
        #"variable/string/pcre/column". After getting the first such line, this
        #is necessarily the *ONLY* such line (since directories are unique).
        #Then simply call the is_string_line_with_column_index_equals() function
        #documented above, testing for... Ah. Right. So, we'll need a similar
        #is_string_line_with_column_index_matches_pcre() function. Simple and
        #synergistic, happily.
        #FIXME: Well. While the above does work perfectly well, the "awk"-based
        #solution below has a certain elegance to it, doesn't it? In short, such
        #solution suggests an iteration-based approach. And I have just the idea
        #for it. Or at least, the inkling of an idea. If the caller to such PCRE-
        #based column functions also passes the maximum number of such columns
        #(which should certainly be known, if matching a column by index!), then
        #there's no reason we couldn't dynamically construct a multiline PCRE
        #explicitly, indiscriminantly, and iteratively capturing *ALL* columns
        #into global ${match}. Then, ${match[1]} would always give the first
        #matched column value for the current line, ${match[2]} the second, and
        #so forth. Such function might have prototype resembling:
        #
        #string for_string_line_column_matches(
        #    string text, integer column_count, string command)
        #
        #Great name, simple to call. Sweet. In fact, we could readily implement
        #the aforementioned is_string_line_with_column_index_equals() with such
        #function. What's great is that it permits list comprehension-style
        #code resembling the intuitive "awk" implementation below. Ah... great!

        command mount | awk -v DIR="${mount_dirname}" '
BEGIN { CODE = 1 }
$3 == DIR && $NF ~ /(,|\()rw(,|\))/ { CODE = 0 }
END { exit CODE }' | return_exit_status
    }
}

#FIXME: Rename to is_dir_mount_point_static().
declare_function_with_stdin <<'________________<heredoc?>________________'
[status: boolean] is_dir_mountable_statically(string dirname)

Return success if the passed directory is a *static mount point* (i.e., listed
by `/etc/fstab` and hence mountable without specifying a device file).
________________<heredoc?>________________
function is_dir_mountable_statically() {
    die_unless_arg 'expected one dirname'
    string static_filename; static_filename="$(get_static_mount_point_file)"
    awk -v DIR="${1}" '
BEGIN { CODE = 1}
!/^[[:blank:]]*#/ && $2 == DIR { CODE = 0 }
END { exit CODE }' "${static_filename}"
}

# ....................{ GETTERS                            }....................
declare_function '
string get_mount_home(void)

Get the absolute path of the canonical directory to which the current user has
write permissions sufficient for mounting devices. Rather than returning a
static path, this function iteratively tests the following directories for
writability (in order):

* "/media".
* "/mnt".
* "${HOME}/media".
* "${HOME}/mnt".

If no such directory exists or is writable, throw an exception.
'
function get_mount_home() {
    die_if_args
    get_dir_writable_first '/media' '/mnt' "${HOME}/media" "${HOME}/mnt"
}

declare_function '
string get_static_mount_point_file(void)

Get the file statically mapping disk devices to mount points (e.g.,
"/etc/fstab").
'
function get_static_mount_point_file() {
    die_if_args
    string filename='/etc/fstab'
    die_unless_file "${filename}"
    print_string "${filename}"
}

# ....................{ GETTERS ~ mount points             }....................
declare_function '
string get_mount_points(void)

Get a newline-delimited list of the absolute paths of all mount points.
'
function get_mount_points() {
    # The third column of "mount" print_string gives the desired list. Surprisingly,
    # such list can contain duplicate mount points: e.g.,
    #
    #     # "mount" lists mount point "/" twice.
    #     >>> mount
    #     rootfs on / type rootfs (rw)
    #     /dev/mapper/vg-root on / type ext4 (rw,noatime,data=ordered)
    #
    # Hence, filter duplicate lines from the returned string.
    die_if_args
    string mount_output; mount_output="$(command mount)"
    get_string_column "${mount_output}" 3 | remove_string_line_duplicates
}

declare_function_with_stdin <<'________________<heredoc?>________________'
string get_static_mount_point_for_disk(string device_filename)

Get the mount point to which `/etc/fstab` maps the passed disk.
________________<heredoc?>________________
function get_static_mount_point_for_disk() {
    # Validate passed arguments.
    die_unless_arg 'expected one device filename'
    string device_filename="${1}"
    die_unless_disk "${device_filename}"

    #FIXME: Should be a pretty trivial implementation via
    #get_string_pcre_line_first_match_group(), which we'll want to augment to throw an
    #exception if no such group matches, possibly accepting an optional error
    #message (per usual). We'll probably also want a new
    #get_mount_point_setup_file() returning '/etc/fstab'. Yum.
    die "Implement me."
    string static_filename; static_filename="$(get_static_mount_point_file)"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
string print_mount_points(void)

Print a human-readable list of current mount points.
________________<heredoc?>________________
function print_mount_points() {
    # Validate sanity.
    die_if_args

    #FIXME: Insufficient. If "mount" encounters a non-fatal error (as occurs
    #when the kernel coerces a mounted read-write filesystem to be read-only),
    #it appends a newline-prefixed warning to such output. I'm afraid I don't
    #recall the exact output, but it's something like:
    #
    #    ...
    #    /dev/sda1 on /media/boot type ext2 rw
    #
    #    warning: "/dev/sda2" currently read-only but mounted writable; this
    #      may indicate hardware failure
    #
    #Handle this by applying the tabulation to *ONLY* that substring of "mount"
    #output preceding the first blank line, signifying warning or error output
    #(which should ideally be colorized to highlight such warning or error).

    # Dismantled, this is:
    #
    # * "print '...'", prefixing print_string with a header line.
    # * "print '-'", prefixing print_string with a banner line. (This is a temporary
    #   placeholder to be entirely replaced with a true banner line, below).
    # * "LC_ALL=C ", guaranteeing print_string from "mount" in the default format.
    # * "mount | awk", formatting print_string from "mount" through an "awk" script
    #   cutting the extraneous second and fourth columns.
    # * "(...)", aggregating such print_string into a single print_string stream.
    # * "column -t", reformatting print_string into a whitespace-delimited table.
    # * "awk", substituting commas with spaces in the flags column. Since
    #   "column -t" tabulates with such spaces, we must defer such substitution
    #   until after tabulating. Dismantled, this is:
    #   * "-v banner="$(print_hard_rule)"", passing the desired banner line to awk
    #     as an option variable.
    #   * "-F'[ ]'", preserving whitespace by treating individual spaces rather
    #     than contiguous "runs" of spaces as column delimiters.
    #   * "NR == 1", matching the first and hence header line.
    #   * "NR == 2", matching the second and hence banner line.
    #   * "NR >= 3", matching all subsequent lines print_string from "mount".
    #   * "$NF", the last and hence flags column. We can't simply write "$4", as
    #     treating individual spaces as delimiters creates "dummy" columns.
    #
    # This one-liner inspired by Peteris Krumin's magical bash one-liner at:
    # http://www.catonmat.net/blog/another-ten-one-liners-from-commandlinefu-explained
    {
        print 'device directory type flags'
        print '???'
        LC_ALL=C command mount | awk '{$2=$4=""; print}'
    } | tabulate_stdin_on_whitespace |
        awk -v BANNER="$(print_hard_rule)" -F'[ ]' '
NR == 1 { print }
NR == 2 { print BANNER }
NR >= 3 {
    gsub(/\(|\)/, "", $NF)
    gsub(/,/, " ", $NF)
    print
}' | page_stdin
}

# ....................{ MOUNTERS                           }....................
#FIXME: Terrible name. Rename to mount_path_with_options().
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_nicely(void) --OR--
void mount_nicely(string mount_dirname) --OR--
void mount_nicely(
    string mount_option1, string mount_option2, ...,
    string device_filename) --OR--
void mount_nicely(
    string mount_option1, string mount_option2, ...,
    string device_filename, string mount_dirname)

Mount the passed disk to the passed mount point directory with the passed
mount options as follows:

* If this is an interactive shell and no arguments were passed, print a human-
  readable list of current mount points.
* If the passed device does not exist, attempt to find a device with such
  basename under these directories (in order):
  * `/dev/disk/by-label`.
  * `/dev`.
  * ...otherwise, raise an exception.
* If no mount point was passed, assume a mount point with the passed device
  basename under the current user's mount home.
* If the passed mount point does not exist, recursively make it.
* If the passed mount point is already mounted to:
  * ...the passed device, do nothing.
  * ...otherwise, raise an exception.
* If the passed device is:
  * ...a device file, perform the expected mount.
  * ...a file with filetype `.iso`, mount this file as an ISO image.

In other words, this function quasi-intelligently accepts darn near anything.
________________<heredoc?>________________
function mount_nicely() {
    # If no arguments were passed, list all current mount points.
    if { is_args_0 } {
        print_mount_points
    # If one argument was passed listed by "/etc/fstab" as a static_mount point,
    # mount such point as such.
    } elif { is_args_1 and is_dir_mountable_statically "${1}" }
        mount_point "${1}"
    # Otherwise, mount the passed device file to the passed mount point.
    } else {
        mount_disk  "${@}"
    }
}

#FIXME: Rename to unmount_dir().
#FIXME: Document the fact that, if no such absolute path exists, we iteratively
#search the list of all mount points for points with such path as a basename.
declare_function_with_stdin <<'________________<heredoc?>________________'
void unmount_point(string mount_dirname1, string mount_dirname2, ...)

Unmount the passed mounted directories.
________________<heredoc?>________________
function unmount_point() {
    # Validate passed sanity.
    die_unless_args 'expected at least one dirname'

    # List of all mount points to be unmounted, after matching the passed globs.
    list unmount_points

    foreach mount_point ("${@}") {
        # If this path is a mount point, append it to the list of mount points
        # to be unmounted.
        if { is_dir_mount_point "${mount_point}" }
            unmount_points+="${mount_point}"
        # If this path is absolute but *NOT* a mount point, attempting to match
        # a mount point suffixed by such path is senseless. Throw an exception.
        } elif { is_path_absolute "${mount_point}" } {
            die "\"${mount_point}\" not mounted"
        # Otherwise, append all match points suffixed by such path to the list
        # of mount points to be unmounted.
        } else {
            # String of newline-delimited absolute paths of all mount points.
            list mount_points mount_points_matching
            get_mount_points | set_list_to_string_lines mount_points

            # Retain only mount points matching this basename.
            set_list_to_list_matches mount_points "*/${mount_point}"

            # Append such mount points to the list.
            unmount_points+=( "${mount_points[@]}" )
        }
    }

    #FIXME: This message isn't quite right for multiple mount points.
    # Unmount.
    interactively print_message "unmounting \"${unmount_points[@]}\"..."
    command umount -- "${unmount_points[@]}"
}

# ....................{ MOUNTERS ~ mount points            }....................
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_boot_partition_writable(void)

Mount the `/boot` partition if such partition exists and not already mounted
writably.
________________<heredoc?>________________
function mount_boot_partition_writable() {
    # Validate sanity.
    die_if_args

    # If "/etc/fstab" maps some device to "/boot", mount such device.
    if { is_dir_mountable_statically '/boot' }
        mount_writable_point '/boot'
    # Else, raise an exception unless "/boot" is already writable.
    } elif { not is_dir_writable "${mount_dirname}" }
        die "\"${mount_dirname}\" unwritable and not listed by \"/etc/fstab\""
    }
}

#FIXME: Rename to mount_dir_statically(). Do we actually require the options?
#Contemplate simplifying this.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_point(
    string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the disk that `/etc/fstab` maps to the passed directory to that
directory with the passed options.
________________<heredoc?>________________
function mount_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"
    pop_arg

    #FIXME: O.K.; for orthogonality with mount_disk(), we should really avoid
    #remounting to an already mounted directory only if such mount point
    #corresponds to the current mapping defined by /etc/fstab. (Annoying, but
    #certainly feasible.)

    # If this directory is already a mount point, return immediately.
    # Otherwise, create such directory if needed and ensure its writability.
    is_dir_mount_point "${mount_dirname}" and return_true
    make_dir_if_not_found "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"
    die_unless_dir_mountable_statically "${mount_dirname}"

    # Mount.
    interactively say\
        "mounting \"${mount_dirname}\" via \"/etc/fstab\"..."
    command mount "${@}" -- "${mount_dirname}"
}

#FIXME: Rename to mount_dir_statically_writable_with_options(). Do we actually
#require the options, though? Contemplate simplifying this.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_writable_point(
   string mount_option1, string mount_option2, ..., string mount_dirname)

Mount the device that `/etc/fstab` maps to the passed dirname to that
directory writably with the passed options.
________________<heredoc?>________________
function mount_writable_point() {
    # Validate passed arguments.
    die_unless_args 'expected optional mount options and one mount dirname'
    string mount_dirname="${@[-1]}"

    # If this directory is already a writable point, return immediately.
    is_dir_mount_point_writable "${mount_dirname}" and return_true

    # If this directory is already mounted (and hence read-only, since the prior
    # test fell through), remount "/boot" read-write; otherwise, mount "/boot"
    # read-write.
    if { is_dir_mount_point "${mount_dirname}" } {
        mount_point -o remount,rw "${@}"
    } else {
        mount_point -o         rw "${@}"
    }
}

# ....................{ MOUNTERS ~ disks                   }....................
#FIXME: Document.
declare_function_with_stdin <<'________________<heredoc?>________________'
void mount_disk(
    string mount_option1, string mount_option2, ..., string device_filename) --OR--
void mount_disk(
    string mount_option1, string mount_option2, ...,
    string device_filename, string mount_dirname)
________________<heredoc?>________________
function mount_disk() {
    # Validate passed arguments.
    die_unless_args\
        'expected optional mount options, one device filename, and optional mount dirname'
    string device_filename mount_dirname

    # If the last passed argument is a writable directory, treat it as the
    # target mount point.
    if { is_dir_writable "${@[-1]}" } {
        die_unless_args_2_or_more\
            'expected optional mount options, one device filename, and one mount dirname'
        device_filename="${@[-2]}"
        mount_dirname="${@[-1]}"
        pop_args 2
    # Otherwise, treat such argument as the source device file.
    } else {
        device_filename="${@[-1]}"
        mount_dirname="$(get_mount_home)/$(get_path_basename "${device_filename}")"
        pop_arg
    }

    # Make the mount point, if needed.
    die_if_dir_mount_point      "${mount_dirname}"
    make_dir_if_not_found   "${mount_dirname}"
    die_unless_dir_writable "${mount_dirname}"

    # If the passed device file is instead an ISO image, mount it as such.
    is_file_type "${device_filename}" 'iso' and {
        interactively say\
            "mounting \"${device_filename}\" to \"${mount_dirname}\"..."
        command mount "${@}" -t iso9660 -o 'exec,loop' --\
            "${device_filename}" "${mount_dirname}"
        return_true
    }

    # If no passed device file exists, search these directories for such file:
    #
    # * "/dev/disk/by-label".
    # * "/dev/mapper".
    # * "/dev".
    is_path_exists "${device_filename}" or {
        is_path_absolute "${device_filename}" and
            die "\"${device_filename}\" not found"
        device_filename="$(get_device_first "/dev/disk/by-label/${device_filename}" "/dev/mapper/${device_filename}" "/dev/${device_filename}")"
    }
    die_unless_device "${device_filename}"

    # If the passed device is already mounted to the passed directory, noop.
    # By default, "mount" unhelpfully fails with error.
    is_disk_mounted_to "${device_filename}" "${mount_dirname}" and {
        interactively print_message "\"${device_filename}\" already mounted to \"${mount_dirname}\"."
        return_true
    }

    # Mount.
    command mount "${@}" -- "${device_filename}" "${mount_dirname}"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to die_unless_mount_point_static().
#FUXME: Actually, the nomenclature's not quite right -- either here or for
#is_dir_mountable_statically(). This should be die_unless_dir_statically_mountable(),
#since such directory is *NOT* a mount point until it's actually mounted to.
#We're only testing here whether "/etc/fstab" lists such directory -- not
#whether it's also currently mounted to.
