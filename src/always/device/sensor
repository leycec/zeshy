#!/usr/bin/env zsh
# ====================[ sensor                             ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Sensor, handling CPU, GPU, and motherboard heat and fan speed sensors.

# ....................{ CONFIGURERS                        }....................
# void configure_sensors(void)
#
# Configure "lm_sensors" and hence the set of sensor-specific kernel modules
# exposed to the "sensors" command run by print_sensors().
configure_sensors() {
    # Validate environment sanity.
    die_if_args
    die_unless_pathable sensors-detect '"lm_sensors" not installed'
    die_unless_pathable pwmconfig      '"lm_sensors" not installed'
    die_unless_current_user_superuser
    die_unless_shell_interactive

    # If the system is under moderate load, require the user confirm his or her
    # desire to continue. "pwmconfig" temporarily turns off *ALL* fans, which
    # could result in hardware damage should the CPU attempt to soldier on.
    float processor_load
    processor_load="$(get_processor_load_as_one_minute_normalized_average)"
    if (( processor_load >= 0.5 )); then
        say 'configuring sensors temporarily turns off fans.'
        say 'system currently under load and hence may be damaged if turning off fans.'
        ask_boolean_strongly 'really turn off fans?' or return_false
    fi

    # Configure.
    say_first_section 'configuring sensors...'
    sensors-detect
    say_next_section  'configuring fans...'
    pwmconfig
}

# ....................{ PRINTERS                           }....................
# void monitor_sensors(int seconds = 1)
#
# Monitor all sensors on the current machine every passed number of seconds.
# This function is the command-line analogue of GUI-driven thermal, voltage, and
# fan monitoring (e.g., Conky, GKrellM).
monitor_sensors() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional interval'
    string seconds="${1:-1}"
    die_unless_string_integer_positive "${seconds}"

    # Lightly sleep after each run to avoid obliterating print_disk_sensors()
    # output, which tends to take longer to harvest than print_sensors() output.
    run_every ${seconds} 'print_sensors and sleep 0.5s'
}

# void print_sensors(void)
#
# Print a human-readable profile of all sensors on the current machine.
print_sensors() {
    die_if_args

    # Prefer "sensors" to "acpi". The former is considerably more general.
    if is_pathable sensors
    then run_paged  sensors
    # Since "acpi" fails to print_string a helpful profile under many machines, inform
    # the user of the fact.
    elif is_pathable acpi
    then
        is_shell_interactive and {
            cry '"lm_sensors" required for sensor monitoring but not installed.'
            cry 'defaulting to "acpi" (not recommended)...'
        }
        acpi --thermal
    # Otherwise, throw an exception.
    else die 'neither "lm_sensors" or "acpi" installed'
    fi

    # "lm_sensors" handles sensors for all devices *EXCEPT* hard drives.
    if is_pathable hddtemp
    then print_disk_sensors
    else
        interactively cry\
            '"hddtemp" required for hard drive sensor monitoring but not installed.'
    fi
}

# void print_disk_sensors(void)
#
# Print a human-readable profile of hard drive sensors on the current machine.
print_disk_sensors() {
    die_if_args
    die_unless_pathable hddtemp

    # Capture "hddtemp" output, implicitly attempting all possible hard drives.
    string hddtemp_output
    list hddtemp_lines
    hddtemp_output="$(hddtemp /dev/sd[a-z])"

    # Unlike "sensors", "hddtemp" fails to highlight unsafe temperatures.
    # Manually iterate each line of print_string for such temperatures and highlight
    # them in the same format as "sensors".
    print_string 'Adapter: SATA adapter'
    integer maximum_safe_temperature=55  # in Celcius
    for hddtemp_line ("${(f)hddtemp_output}") {
        is_string_match_pcre "${hddtemp_line}" '(\d+)°C$' and
            (( ${match[1]} >= maximum_safe_temperature )) and
            hddtemp_line+="  (high = +${maximum_safe_temperature}°C) ALARM"
        print_string "${hddtemp_line}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_pathable sensors

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#
# Copyright 2007-2012 by Cecil Curry.
#
#   http://www.raiazome.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
