#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'-/-'
Handle *device sensors* (e.g., typically measuring CPU, GPU, and motherboard
heat and fan speeds.
-/-

# ....................{ CONFIGURERS                        }....................
declare_function_with_stdin <<'/---'
void configure_sensors(void)

Configure `lm_sensors` and hence the set of sensor-specific kernel modules
exposed to the `sensors` command run by print_sensors().
/---
function configure_sensors() {
    # Validate sanity.
    die_if_args
    die_unless_pathable sensors-detect '"lm_sensors" not installed'
    die_unless_pathable pwmconfig      '"lm_sensors" not installed'
    die_unless_superuser
    die_unless_shell_interactive

    # If the system is under moderate load, require the user confirm his or her
    # desire to continue. "pwmconfig" temporarily turns off *ALL* fans, which
    # could result in hardware damage should the CPU attempt to soldier on.
    float processor_load
    processor_load="$(get_processor_load_as_one_minute_normalized_average)"
    if (( processor_load >= 0.5 )) {
        print_message_unboxed
            "Configuring sensors temporarily turns off fans. Since the system is currently under ${processor_load}% load, turning off fans may induce hardware failure or loss. Consider reducing system load before continuing."
        is_query_line_yes 'really turn off fans?' or
            return_false
    }

    # Configure.
    print_message_heading 'configuring sensors'
    sensors-detect
    print_message_heading 'configuring fans'
    pwmconfig
}

# ....................{ MONITORS                           }....................
declare_function_with_stdin <<'/---'
void monitor_sensors(integer seconds = 1)

Monitor all sensors on the current machine every passed number of seconds.
This function is the command-line analogue of GUI-driven thermal, voltage, and
fan monitoring (e.g., Conky, GKrellM).
/---
function monitor_sensors() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional interval'
    string seconds="${1:-1}"
    die_unless_integer_positive "${seconds}"

    # Lightly sleep after each run to avoid obliterating print_disk_sensors()
    # output, which tends to take longer to harvest than print_sensors() output.
    run_code_every_interval 'print_sensors and sleep 0.5s' "${seconds}s"
}

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
void print_sensors(void)

Print a human-readable profile of all sensors on the current machine.
/---
function print_sensors() {
    # Validate sanity.
    die_if_args

    # Prefer "sensors" to "acpi". The former is considerably more general.
    if { is_pathable sensors } {
        run_code_paged sensors
    # Since "acpi" fails to print_string a helpful profile under many machines, inform
    # the user of the fact.
    } elif { is_pathable acpi } {
        print_warning_wrapped\
            'Consider installing "lm_sensors" to enable optimal sensor monitoring. Defaulting to "acpi" instead.'
        acpi --thermal
    # Otherwise, throw an exception.
    } else {
        die 'neither "lm_sensors" or "acpi" installed'
    }

    # "lm_sensors" handles sensors for all devices *EXCEPT* hard drives.
    if { is_pathable hddtemp } {
        print_disk_sensors
    } else {
        print_warning\
            'Consider installing "hddtemp" to enable hard drive sensor monitoring.'
    }
}

declare_function_with_stdin <<'/---'
void print_disk_sensors(void)

Print a human-readable synopsis of hard drive sensors on the current machine.
/---
function print_disk_sensors() {
    # Validate sanity.
    die_if_args
    string hddtemp_output
    die_unless_pathable hddtemp

    # Maximum temperature in Celcius past which a visual alarm is printed.
    integer maximum_safe_temperature=55

    # Capture "hddtemp" output, implicitly attempting all possible hard drives.
    hddtemp_output="$(command hddtemp -- /dev/sd[a-z])"

    # Unlike "sensors", "hddtemp" fails to highlight unsafe temperatures.
    # Manually iterate each line of print_string for such temperatures and highlight
    # them in the same format as "sensors".
    output_string 'Adapter: SATA adapter'
    string hddtemp_line
    for    hddtemp_line ("${(f)hddtemp_output}") {
        if { is_string_matches_pcre "${hddtemp_line}" '(\d+)°C$' and
            (( ${match[1]} >= maximum_safe_temperature )) } {
            hddtemp_line+="  (high = +${maximum_safe_temperature}°C) ALARM"
        }
        output_string "${hddtemp_line}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#   die_unless_pathable sensors
