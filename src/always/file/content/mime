#!/usr/bin/env zsh
# ====================[ mime                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Mime, handling file content-derived mimetypes: e.g.,
#
# * Installing one "suffix alias" for each mimetype registered in the system-
#   wide "/etc/mailcap" or user-local "~/.mail.cap" files. This associates
#   filename suffixes with the application responsible for opening such files,
#   enabling BSD-style file opening (i.e., typing only filenames at the prompt).
#
# --------------------( INSTALLATION                       )--------------------
# Zeshy Mimetype assumes one mimetype for each desired filetype to be opened:
#
#   # Edit "/etc/mailcap", adding one line for the application opening each such
#   # filetype (e.g., a line "application/pdf;/usr/bin/okular %s" for opening
#   # PDF files in Okular).
#   vi /etc/mailcap
#
#   # Edit "/etc/mime.type", adding one line for the mimetype for each such
#   # filetype (e.g., a line "application/pdf pdf" for associating PDF files
#   # with the "application/pdf" mimetype and hence Okular, above).
#   vi /etc/mime.type
#
#   # Reload mimetype aliases.
#   mimetype_aliases_reinit
#
# --------------------( SEE ALSO                           )--------------------
# http://www.bash2zsh.com/essays/essay1_file_manager.html
#   Brilliant introduction to suffix aliases, mime types, and file magic.

# ....................{ ALIASES                            }....................
interactive_alias ze='zedit'
interactive_alias zv='zview'

# ....................{ TESTS                              }....................
#FIXME: Function names could certainly use work.
# bool is_mimetype_aliased(string filename)
#
# Return success if there exists a mimetype alias for the passed filename (i.e.,
# if the "/etc/mailcap" file maps that filename's filetype).
is_mimetype_aliased() {
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    is_suffix_alias "$(get_filetype "${filename}")"
}

# ....................{ GETTERS                            }....................
# string get_mimetype(string filename)
#
# Get the mimetype of the passed file by dynamic inspection of its content.
get_mimetype() {
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_file "${filename}"
    file --brief --mime-type -- "${filename}"
}

# string get_mimetype_aliases(void)
#
# Get a string listing currently installed "/etc/mailcap"-driven suffix aliases.
get_mimetype_aliases() {
    die_if_args
    zsh-mime-setup -l
}

# ....................{ MIMETYPES                          }....................
# void *zedit(string filename)
#
# Edit the passed filename under the application associated with the mimetype
# associated with that filename's filetype.
zedit() {
    die_unless_one_arg 'expected one filename'
    _zeshy_mimetype_open edit "${1}"
}

# void *zview(string filename)
#
# View the passed filename under the application associated with the mimetype
# associated with that filename's filetype.
zview() {
    die_unless_one_arg 'expected one filename'
    _zeshy_mimetype_open see "${1}"
}

# void *_zeshy_mimetype_open(string mimetype_command_name, string filename)
#
# Open the passed filename under the application associated with the mimetype
# associated with that filename's filetype using the passed mime-specific
# command name (e.g., "see", "edit", "compose"). This is helpful only from non-
# interactive scripts, since from interactive shells one opens a filename by
# simply typing the filename.
_zeshy_mimetype_open() {
    die_unless_two_args\
        'expected one mime command name and one filename'
    string mimetype_command_name="${1}"
    string filename="${2}"
    is_mimetype_alias "${filename}" or
        die "no mailcap entry for \"${filename}\" found"

    # If this system provides the passed command, prefer that.
    if is_installed "${mimetype_command_name}"
    then "${mimetype_command_name}" "${filename}"
    # Otherwise, default to the zsh "zsh-mime-handler" command.
    else zsh-mime-handler "${filename}"
    fi
}

# ....................{ SETUP                              }....................
# void setup_mimetype_aliases(void)
#
# Set "/etc/mailcap"-driven suffix aliases.
setup_mimetypes() {
    die_if_args

    # Install us up the bling.
    source_safely zsh-mime-setup -f
#   utter "sourced!"

    # If no such aliases were installed, emit an error.
    if not run_quietly get_mimetype_aliases; then
        if is_file "${HOME}/.mailcap" or is_file '/etc/mailcap'
        then curse   'both "~/.mailcap" and "/etc/mailcap" empty; no mimetype aliases installed'
        else curse 'neither "~/.mailcap" or "/etc/mailcap" found; no mimetype aliases installed'
        fi
    fi
#   utter "returning!"
}

#FIXME: Obsolete.
    #FIXME: Unhelpful, I suspect.
    # Set default mailcap and mimetype paths prior to installing suffix aliases
    # dependent on these paths.
#   zstyle :mime: mailcap    ~/.mailcap    /etc/mailcap
#   zstyle :mime: mime-types ~/.mime.types /etc/mime.types

    # Emit a message corresponding to whether or not we've already installed
    # aliases with a prior call to this function.
#   if is "$(mimetype_aliases_list)"
#   then utter 'reinstalling mimetype aliases...'
#   else utter   'installing mimetype aliases...'
#   fi

# ....................{ MAIN                               }....................
# Automatically install mimetype aliases, as this is *ALWAYS* generally helpful.
#mimetype_aliases_init

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
