#!/usr/bin/env zsh
# ====================[ link                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File, handling symbolic and hard links.

# ....................{ ALIASES                            }....................
interactive_alias lns='make_symbolic_link'

# ....................{ EXCEPTIONS                         }....................
# void die_unless_symbolic_link(
#   char *pathname, char *error_message = 'not a symbolic link')
#
# Throw an exception unless the passed symbolic link exists.
die_unless_symbolic_link() {
    die_unless_one_or_two_args\
        'expected one pathname and optional error message'
    string pathname="${1}"
    is_symbolic_link "${pathname}" or
        die "${2:-\"${pathname}\" not a symbolic link}"
}

# ....................{ TESTS                              }....................
# bool is_symbolic_link(char *pathname)
# 
# Return true if the passed path is an existing symbolic link.
is_symbolic_link() {
    die_unless_one_arg 'expected one pathname'
    is -L "${1}" si
}

# bool is_broken_symbolic_link(char *pathname)
# 
# Return true if the passed path is an existing broken symbolic link (i.e., is
# an existing symbolic link whose link target no longer exists).
is_broken_symbolic_link() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}"
    is_symbolic_link "${pathname}" or return_false

    # Dismantled, this is:
    #
    # * "broken_symbolic_link", an empty list if the passed symbolic link is
    #   unbroken; else, a single-element list. This is defined by:
    #   * "${pathname}"(...), filtering the passed path with glob qualifiers:
    #     * "-", transitively resolving the passed symbolic link to its final
    #       destination. If this is merely another symbolic link, the passed
    #       symbolic link is broken; else, this is a non-symbolic link (i.e.,
    #       physical file) and the passed symbolic link is unbroken.
    #     * "@", excluding non-symbolic links. When combined with the prior
    #       "-", this filters unbroken symbolic links into the empty string.
    #       (Zsh first resolves the passed symbolic link to its destination and
    #       then tests whether that destination is itself a symbolic link.)
    # 
    # See http://www.zsh.org/mla/users/2005/msg00394.html for Peter Stephenson's
    # clever inspiration.
    list broken_symbolic_link; broken_symbolic_link=( "${pathname}"(-@) )
    is_list_nonempty broken_symbolic_link
}

# ....................{ GETTERS                            }....................
# char *get_symbolic_link_target(char *filename)
#
# Get the immediate target of the passed symbolic link. This function does *NOT*
# resolve intermediate symbolic links or guarantee such target to be absolute or
# extant. See canonicalize_path() for an alternative guaranteeing such
# constraints.
get_symbolic_link_target() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one filename'
    string filename="${1}"
    die_unless_symbolic_link "${filename}"

    # Alas, but Zsh itself appears to supply no means of printing the immediate
    # target of a symbolic link. Resort to core utilities, instead.
    readlink "${filename}"
}

# ....................{ WRITERS                            }....................
#FIXME: Description no longer quite right.
# void make_symbolic_link(char *source_pathname, *target_filename)
#
# Symbolically link the former passed path to the latter passed file. If such
# file already exists and is a symbolic link, replace such file without error;
# otherwise, raise an error if such file already exists.
make_symbolic_link() {
    die_unless_two_args\
        'expected one source pathname and one target filename'

    list ln; ln=( ln "${ZESHY_LN_SYMBOLIC_OPTIONS[@]}" )
    if is_interactive
    then "${ln[@]}" "${ZESHY_LN_SYMBOLIC_OPTIONS_IF_INTERACTIVE[@]}"     -- "${@}"
    else "${ln[@]}" "${ZESHY_LN_SYMBOLIC_OPTIONS_IF_NON_INTERACTIVE[@]}" -- "${@}"
    fi
}

#FIXME: Obsolete.
# Get the physical path to which the passed symbolic link directly links.
# (i.e., resolving all intermediate symbolic links). The resulting path is
# guaranteed to be neither absolute or extant. See canonicalize_path() for an
# alternative guaranteeing absolute and extant return values.
    # Dismantled, this is:
    #
    # * "(:A)", expanding to the absolute path of such directory if relative and
    #   resolving symbolic links in such path to their non-symbolic targets.
#   sputter "${filename}"(:A)

    # See is_broken_symbolic_link() for related discussion.
#   list symbolic_link_target; symbolic_link_target=( "${filename}"(-) )
#   sputter "${symbolic_link_target[1]}"

#   string source_pathname="${1}" target_filename="${2}"
#   die_unless_file "${source_pathname}"
#
#   if is_symbolic_link "${target_filename}"; then
#       ln -sf "${source_pathname}" "${target_filename}"
#   else
#       die_if_file "${target_filename}"
#       ln -s  "${source_pathname}" "${target_filename}"
#   fi

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
