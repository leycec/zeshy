#!/usr/bin/env zsh
# ====================[ mask                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy File Mask, handling file ownership and permissions.

# ....................{ ALIASES                            }....................
#FIXME: Enable. This requires we augment set_path_creation_mask() to call
#print_path_creation_mask() when called interactively directly with no args.
#interactive_alias umask='umask -S'

# ....................{ SETTERS                            }....................
# string set_path_creation_mask(string permissions)
#
# Set the global "umask" (i.e., user mask) for the current shell to the passed
# human-readable comma-delimited string of all permissions to be allowed. All
# other permissions default to denied: e.g.,
#
#     # Allow all users and groups except the current user and group from
#     # reading subsequent paths created by such user and group. You really
#     # don't want to do this.
#     >>> set_path_creation_mask o=rwX
set_path_creation_mask() {
    die_unless_one_arg 'expected one permission string'
    string permissions="${1}"
    umask -- "${permissions}"
}

# ....................{ PRINTERS                           }....................
# string print_path_creation_mask(void)
#
# Print the global "umask" (i.e., user mask) for the current shell.
print_path_creation_mask() {
    # Validate passed arguments. "umask -S" prints a symbolic representation of
    # such mask resembling "u=rwx,g=rx,o=". Unlike human-readable "chmod" input
    # (e.g., "u+rwx,g+rx-w,o-rwx"), "umask -S" output fails to specify whether
    # such permissions are enabled or disabled. In fact, it is the former.
    # Since this is not necessarily intuitive, convert the symbolic
    # representation output by "umask -S" to that input by "chmod".
    # Unsurprisingly, this is a convolute munging.
    die_if_args
    string\
        symbol_umask symbols\
        symbol_name symbol_accepts symbol_forbids
    list symbol_types symbol_flags symbol_accepts_flags symbol_forbids_flags

    # Split "umask -S" output on commas.
    symbol_umask="$(umask -S)"
    split_string_to_list "${symbol_umask}" ',' symbol_types

    # For each of the three permission types (i.e., user, group, and other),
    # split such type on "=", convert the right-hand side of such split to a
    # list of at most three permissions (e.g., from a string "rw" to a list
    # "( r w )"), and difference the list "( r w x )" with such list. The
    # result is the list of all disabled permissions.
    symbol_flags=( 'r' 'w' 'x' )
    for symbol_type ("${symbol_types[@]}") {
        # Get the list of all disabled permissions.
        split_string_to_string_pair "${symbol_type}" '=' symbol_name symbol_accepts
        split_characters_to_list "${symbol_accepts}" symbol_accepts_flags
#       sputter "symbol_accepts_flags: ${symbol_accepts_flags[@]}"
        difference_lists symbol_flags symbol_accepts_flags symbol_forbids_flags
#       sputter "symbol_forbids_flags: ${symbol_forbids_flags[@]}"

        # By default, list expansion delimits elements with spaces. Avoid this.
        symbol_forbids="$(join_list_to_string symbol_forbids_flags)"

        # Avoid prefixing empty permissions with "+" and "-" symbols.
        if is_nonempty "${symbol_accepts}" and is_nonempty "${symbol_forbids}"
        then symbols+="${symbol_name}+${symbol_accepts}-${symbol_forbids},"
        elif is_nonempty "${symbol_accepts}"
        then symbols+="${symbol_name}+${symbol_accepts},"
        else symbols+="${symbol_name}-${symbol_forbids},"
        fi
    }

    # Remove the trailing comma accidentally appended by the final iteration.
    symbols="$(remove_suffix "${symbols}" ',')"

    # Print.
    sputter "path creation mask (umask):
  in octal:   $(umask)
  in symbols: ${symbols}"
}

# --------------------( WASTELANDS                         )--------------------
    #FIXME: Create a new 'type/string/pcre' method for global substitution.
#   sputter "path creation mask (umask): $(umask) (octal); $(umask -S) (symbolic)"
#   sputter "path creation mask (umask): $(umask) (octal) {$(umask -S) (symbolic)}"
#   sputter "path creation mask (umask): octal $(umask) {symbolic $(umask -S)}"
#   sputter "path creation mask (umask): $(umask) {$(umask -S)}"
#   sputter "path creation mask (umask): $(umask) [symbolic $(umask -S)]"
#   sputter "umask: $(umask) ($(umask -S))"
#   sputter "global path creation mask (umask): $(umask) (symbolically, $(umask -S))"
