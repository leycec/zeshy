#!/usr/bin/env zsh
# ====================[ list                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy List, handling lists (i.e., non-associative arrays).
#
# --------------------( TODO                               )--------------------
# * Incorporate difference and intersect list operations from "src/load".
# * Incorporate set operations from:
#   http://www.catonmat.net/blog/set-operations-in-unix-shell

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
die_unless_map_or_list() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_map_or_list "${1}" or die "${2:-\"${1}\" not a declared map or list}"
}

# void die_unless_list(string variable_name, string error_message = 'not a list')
#
# Die unless the variable with the passed name is a list.
die_unless_list() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_list "${1}" or die "${2:-\"${1}\" not a declared list}"
}

# ....................{ EXCEPTIONS ~ emptiness             }....................
# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# Die unless the variable with the passed name is a non-empty list.
die_unless_list_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_list_nonempty "${1}" or die "${2:-\"${1}\" not a non-empty list}"
}

# void die_if_list_empty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
die_if_list_empty() {
    die_unless_list_nonempty "${@}"
}

# ....................{ TESTS                              }....................
# bool is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
is_map_or_list() {
    die_unless_one_arg 'expected one variable name'
    is $(get_type "${1}") == (list|array|association)* si
}

# bool is_list(string variable_name)
#
# Return true if the variable with the passed name is a list (i.e., array).
is_list() {
    die_unless_one_arg 'expected one variable name'

    # Global lists have type "list", local lists "list-local", and internal
    # structures (e.g., "${path}") "array" or "array-special". Match all.
    is $(get_type "${1}") == (list|array)* si
}

# bool is_list_empty(string variable_name)
#
# Return true if the variable with the passed name is an empty list.
is_list_empty() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    is_list "${list_name}" and (( ${#${(@P)list_name}} == 0 ))
}

# bool is_list_nonempty(string variable_name)
#
# Return true if the variable with the passed name is a non-empty list.
is_list_nonempty() {
    die_unless_one_arg 'expected one variable name'
    string list_name="${1}"
    is_list "${list_name}" and (( ${#${(@P)list_name}} ))
}

# bool is_list_element(string list_name, string element)
#
# Return true if the list with the passed name contains an element with the
# passed value.
is_list_element() {
    # Localize and validate arguments.
    die_unless_two_args 'expected one list name and one element'
    string list_name="${1}" element="${2}"
    die_unless_list "${list_name}"

    #FIXME: This is extendable into an is_list_element_matching() function
    #by simple expanding ${element} as ${~element} here.
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * "${(M)", ":#", and "}", excluding all but the passed element.
    is_nonempty "${(M)${(@P)list_name}:#${element}}"
}

# ....................{ GETTERS                            }....................
# int get_list_size(string variable_name)
#
# Get the number of elements in the list with the passed name.
get_list_size() {
    die_unless_one_arg 'expected one variable name'
    die_unless_list "${1}"

    # Dismantled, this is:
    #
    # * '1', the passed list name.
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * '#', the size of this list.
    sputter ${#${(@P)1}}
}

# ....................{ GETTERS ~ elements                 }....................
#FIXME: Once we validate this works as expected, implement the converse
#get_first_list_element_matching() function by using flag "(R)" where we
#currently use flag "(r)".
# string get_first_list_element_matching(string list_name, string glob_pattern)
#
# Get the first element matching the passed glob pattern of the list with the
# passed name.
get_first_list_element_matching() {
    # Localize and validate arguments.
    die_unless_two_args 'expected one list name and one glob pattern'
    string list_name="${1}" glob_pattern="${2}" element
    die_unless_list "${list_name}"

    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired list in the caller's scope.
    # * '@', as a list rather than a scalar.
    # * 'r', expanding to the first element matching the passed pattern.
    element="${${(@P)list_name}[(r)"$glob_pattern"]}"

    # Throw an exception if no such element matches.
    die_unless_nonempty "${element}"\
        "pattern \"${glob_pattern}\" not matched in list \"${list_name}\""

    # Otherwise, return such element.
    sputter ${element}
}

# ....................{ CHECKERS                           }....................
#FIXME: Rename test_list_args().
# void check_list_args(
#   string list_name, string start_index_name, string end_index_name)
#
# Check the passed list-centric variables for sanity and, if sane, set such
# variables to sensible defaults. Specifically:
#
# * Throw an exception if no list with the passed name exists.
# * Throw an exception if the variable with the passed start index is empty but
#   the variable with the passed end index is not.
# * If both the variables with the passed start and end indices are empty,
#   default the former to "1" (i.e., the first list index) and the latter to
#   "-1" (i.e., the last list index). Such indices thus span the entire list.
# * If only the variable with the passed end index is empty, default such
#   variable to the same value as that of the passed start index. Such indices
#   thus span the single list element for the passed start index.
# * Throw an exception if the variables with such start and end indices are not
#   non-zero integers bounded by [-list_size, list_size].
# * Throw an exception if the start index is greater than the end index.
#
# In short, this function guarantees bounded list indices.
check_list_args() {
    # Validate sanity, intentionally obfuscating local variable names to avoid
    # unintentionally masking caller variables.
    die_unless_one_to_three_args\
        'expected one list name, one start index name, and one end index name'
    #FIXME: Variable name obfuscation is silly. If the unobfuscated names fail,
    #we cleary have larger issues on our hands. Investigate why we did this in
    #the first place. (Conflict with get_lines() locals, as I recall.)
    string\
        _list_name_="${1}" _beg_index_name_="${2}" _end_index_name_="${3}"\
        _list_size_ _beg_index_ _end_index_
    _list_size_="$(get_list_size "${_list_name_}")"

    # Default indices.
    if is_set_empty "${_beg_index_name_}"; then
        die_unless_set_empty "${_end_index_name_}"\
            "start index \"${_beg_index_name_}\" empty but end index \"${_end_index_name_}\" non-empty"
        _beg_index_=1
        _end_index_=${_list_size_}
    elif is_set_empty "${_end_index_name_}"; then
        _beg_index_=${(P)_beg_index_name_}
        _end_index_=${_beg_index_}
    else
        _beg_index_=${(P)_beg_index_name_}
        _end_index_=${(P)_end_index_name_}
    fi
    die_unless_decimal "${_beg_index_}"
    die_unless_decimal "${_end_index_}"

    # Validate indices, converting negative to positive indices to simplify
    # comparison. Preserve original indices for pretty printing.
    integer _new_beg_index_=${_beg_index_} _new_end_index_=${_end_index_}
    (( _new_beg_index_ > 0 )) or (( _new_beg_index_ += _list_size_ + 1 ))
    (( _new_end_index_ > 0 )) or (( _new_end_index_ += _list_size_ + 1 ))
    (( 1 <= _new_beg_index_ && _new_beg_index_ <= _list_size_ )) or
        die "list index ${_beg_index_} not in [-${_list_size_}, ${_list_size_}] or is 0"
    (( 1 <= _new_end_index_ && _new_end_index_ <= _list_size_ )) or
        die "list index ${_end_index_} not in [-${_list_size_}, ${_list_size_}] or is 0"
    (( _new_beg_index_ <= _new_end_index_ )) or
        die "start index ${_beg_index_} > end index ${_end_index_}"

    # Since indices validate, set index variables to the prior defaults.
    eval ${_beg_index_name_}=${_new_beg_index_}
    eval ${_end_index_name_}=${_new_end_index_}
#   print "${_beg_index_name_}=${(P)_beg_index_name_}"
#   print "${_end_index_name_}=${(P)_end_index_name_}"
}

# ....................{ SET OPERATORS                      }....................
# void difference_lists(
#   string left_list_name, string right_list_name, string result_list_name)
#
# Difference the first and second passed lists into the third. Considering each
# such list a list set (i.e., ignoring duplicate elements) and abbreviating
# B="${left_list_name}", C="${right_list_name}", and A="${result_list_name}",
# this function implements the asymmetric set difference A = B - C of B and C:
# e.g.,
#
#     >>> list y; y=( 'slimy' 'things' 'did' 'crawl' 'with' 'legs' )
#     >>> list e; e=( 'upon' 'the' 'slimy' 'sea' )
#     >>> list a
#     >>> difference_lists y e a
#     >>> sputter "${a[@]}"
#     things did crawl with legs
difference_lists() {
    # Validate passed arguments.
    die_unless_three_args 'expected left, right, and result list names'
    string left_list_name="${1}" right_list_name="${2}" result_list_name="${3}"
    die_unless_list "${left_list_name}"
    die_unless_list "${right_list_name}"
    die_unless_list "${result_list_name}"

    # Difference. Bless your pithy soul, Zsh 5.0.0. Dismantled, this is:
    #
    # * "(@P)", expanding all elements of the first passed list.
    # * ":|", excluding all elements of the second passed list.
    eval "${result_list_name}=( \"\${(@P)left_list_name:|${right_list_name}}\" )"
}

# void intersect_lists(
#   string left_list_name, string right_list_name, string result_list_name)
#
# Intersect the first and second passed lists into the third. Considering each
# such list a list set (i.e., ignoring duplicate elements) and abbreviating
# B="${left_list_name}", C="${right_list_name}", and A="${result_list_name}",
# this function implements the symmetric set intersection A = B & C of B and C:
# e.g.,
#
#     >>> list y; y=( 'slimy' 'things' 'did' 'crawl' 'with' 'legs' )
#     >>> list e; e=( 'upon' 'the' 'slimy' 'sea' )
#     >>> list a
#     >>> intersect_lists y e a
#     >>> sputter "${a[@]}"
#     slimy
intersect_lists() {
    # Validate passed arguments.
    die_unless_three_args 'expected left, right, and result list names'
    string left_list_name="${1}" right_list_name="${2}" result_list_name="${3}"
    die_unless_list "${left_list_name}"
    die_unless_list "${right_list_name}"
    die_unless_list "${result_list_name}"

    # Intersect. Bless your bawdy eyes, Zsh 5.0.0.
    eval "${result_list_name}=( \"\${(@P)left_list_name:*${right_list_name}}\" )"
}

# ....................{ JOINERS                            }....................
# void join_list_to_lines(string list_name)
#
# Join the list with the passed name into a newline-delimited string: e.g.,
#
#     >>> list robert; robert=( "Stranger in" "a" "Strange Land"
#     >>> join_list_to_lines robert
#     Stranger in
#     a
#     Strange Land
join_list_to_lines() {
    die_unless_one_arg 'expected one list name'
    join_list_to_string "${1}" '\n'
}

# void join_list_to_string(string list_name, string delimiter = "")
#
# Join the list with the passed name into a string with each list element
# delimited by the passed delimiter (defaulting to the empty string). The
# delimiter may be of any length: e.g.,
#
#     >>> list heinlein; heinlein=( "The Moon" "Is" "a" "Harsh Mistress" )
#     >>> join_list_to_string heinlein ", "
#     The Moon, Is, a, Harsh Mistress
join_list_to_string() {
    # Validate passed arguments.
    die_unless_one_or_two_args 'expected one list name and one delimiter'
    string list_name="${1}" delimiter="${2:-}"
    die_unless_list "${list_name}"

    # If the passed delimiter is a colon, delimit such delimiter by periods.
    # Delimited, this is:
    #
    # * "j.:.", joining on colons.
    # * "@P", expanding to the list with the passed name.
    if is "${delimiter}" == ':' si
    then sputter ${(j.:.@P)list_name}
    # Otherwise, delimit such delimiter by colons. Since Zsh appears to
    # expand no parameters embedded in parameter expansion flags (e.g.,
    # "print ${(j:${delimiter}:)@}", joining list elements with the raw string
    # "${delimiter}" rather than the expansion of such parameter), wrap the
    # desired expression in an "eval" to force such expansion.
    else eval "print -- \${(j:${delimiter}:)${list_name}}"
    fi
}

# string join_list_to_restorable_string(string variable_name)
#
# Convert the list with the passed name to a string. Call restore_list() to
# perfectly expand this string back to the original list: e.g.,
#
#   # Declare a function returning a restorable string.
#   >>> get_minerals() {
#   ...     list asbestos
#   ...     asbestos=( 'nephrite' 'porphyry' 'glauconite' 'mafic' )
#   ...     join_list_to_restorable_string asbestos
#   ... }
#
#   # Restore such string back into a local list entitled "list".
#   >>> get_minerals | restore_list
#   >>> sputter "${list[1]}"   # as in the original list
#   nephrite
join_list_to_restorable_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one list name'
    string list_name="${1}"
    die_unless_list "${list_name}"

    # Dismantled, this is:
    #
    # * '1:-list' expands to the passed list name or 'list' if no such name
    #   was passed.
    # * 'P' transitively expands this name to the actual name of the desired
    #   associative list in the caller's scope.
    # * '@' interprets this expansion as a list rather than scalar.
    # * 'qq' protectively embeds all reserved shell characters in such names
    #   and values in single quotes.
    sputter "${(qq@P)list_name}"
}

# ....................{ JOINERS ~ legible                  }....................
# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully brief number of characters: e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   "I laiss i-ferin thuiar" "I 'wilith lim echui aur."
#     I laiss i-ferin thuiarI 'wil...
#
# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
join_list_to_legible_truncated_string() {
    # Join, then truncate.
    string text; text="$(join_list_to_legible_string "${@}")"
    truncate_string "${text}" 32 '...'
}

# void join_list_to_legible_string(
#   string last_element_prefix,
#   string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string: e.g.,
#
#     >>> join_list_to_legible_string 'or' 'Wingnut' 'Dishwashers' 'Union'
#     Wingnut, Dishwashers, or Union
join_list_to_legible_string() {
    # Validate passed arguments.
    die_unless_at_least_two_args\
        'expected one delimiter, one last element prefix, and at least one list element'
    string last_element_prefix="${1}"
    shift_one_arg

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
    if is_at_least_three_args; then
        list munged; munged=( "${@[1,-2]}" "${last_element_prefix} ${@[-1]}" )
        join_list_to_string munged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
    elif is_two_args
    then sputter "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
    else sputter "${1}"
    fi
}

# ....................{ SPLITTERS                          }....................
# void split_string_to_string_pair(
#   string text, string delimiter, string variable_name1, string variable_name2)
#
# Split the passed string on the first substring of the passed delimiter into:
#
# * The string with the former name to the substring preceding such delimiter.
# * The string with the latter name to the substring following such delimiter.
#
# The delimiter may be of any non-zero length: e.g.,
#
#     >>> string prefix suffix
#     >>> split_string_to_string_pair\
#       'wolfs==head==society' '==' 'prefix' 'suffix'
#     >>> sputter "prefix: ${prefix}\nsuffix: ${suffix}"
#     prefix: wolfs
#     suffix: head==society
split_string_to_string_pair() {
    # Validate passed arguments.
    die_unless_four_args\
        'expected one delimiter, source string, and target prefix and suffix variable names'
    string text="${1}" delimiter="${2}" prefix_name="${3}" suffix_name="${4}"
    die_unless_string "${prefix_name}"
    die_unless_string "${suffix_name}"

    # If the passed string contains no such delimiter, throw an exception.
    is "${text}" == *"${delimiter}"* si or
        die "delimiter \"${delimiter}\" not found in \"${text}\""

    # Split.
    eval\
        "${prefix_name}=\"${text%%${delimiter}*}\"; "\
        "${suffix_name}=\"${text#*${delimiter}}\""
}

# ....................{ SPLITTERS ~ lists                  }....................
# string split_string_to_list(
#   string text, character delimiter, string list_name)
#
# Split the passed string on all substrings of the passed delimiting character
# into the passed list: e.g.,
#
#     >>> list array
#     >>> split_string_to_list 'Obseqious/Deep/Journeys' '/' array
#     >>> sputter "${array[1]}"
#     Obseqious
split_string_to_list() {
    # Validate passed arguments.
    die_unless_three_args\
        'expected one string, one delimiter, and one list name'
    string text="${1}" delimiter="${2}" list_name="${3}"
    die_unless_character delimiter
    die_unless_list "${list_name}"

    # If the passed delimiter is a colon, delimit such delimiter by periods.
    if is "${delimiter}" == ':' si
    then eval "${list_name}=( \${(s.:.)text} )"
    # Otherwise, delimit such delimiter by colons.
    else eval "${list_name}=( \${(s:${delimiter}:)text} )"
    fi
}

# string split_characters_to_list(string characters, string list_name)
#
# Split the passed characters into the passed list: e.g.,
#
#     >>> list array
#     >>> split_characters_to_list 'the storm-blast came' array
#     >>> sputter "${array[1]} ${array[3]} ${array[13]} ${array[15]}"
#     t e a t
#
# Since Zsh supports list-style character indexing and slicing out of the box,
# this function is useful only where explicit list types are required.
split_characters_to_list() {
    # Validate passed arguments.
    die_unless_two_args 'expected one string and one list name'
    string text="${1}" list_name="${2}"
    die_unless_list "${list_name}"

    # Split with a 0-width delimiter.
    eval "${list_name}=( \${(s::)text} )"
}

# ....................{ SPLITTERS ~ lines                  }....................
# string split_columns_from_lines(
#   string text,
#   character column_delimiter,
#   integer column_index1, integer column_index2, ...)
#
# Split the columns with the passed 1-based column indices from the passed
# string on the passed delimiting character. If passed:
#
# * Only one column index, each output line has only the corresponding column.
# * More than one such index, each output line has the corresponding columns
#   delimited by the passed delimiting character. Consider splitting each such
#   line with split_string_to_list() to obtain the resulting columns.
#
# This function is roughly analogous to the "cut -f" command.
split_columns_from_lines() {
    # Validate passed arguments.
    die_unless_at_least_three_args\
        'expected one string, one column delimiter, and at least one column index'
    string text="${1}" column_delimiter="${2}"
    die_unless_character column_delimiter
    shift_two_args

    # If passed only one column index, such column is efficiently splittable
    # with pure Zsh. Do so, Sir Robin! Arguably, we needn't do so in Zsh; the
    # non-Zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
    if is_one_arg; then
        # Index of the column preceding the passed column.
        die_unless_positive_decimal "${1}"
        integer prior_column_index=$(( ${1} - 1 ))

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column delimiter via:
        #   * "[^${column_delimiter}]#", zero or more characters excluding the
        #     column delimiter.
        #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_delimiter}]#)", a match group matching the passed
        #   column excluding the suffixing column delimiter.
        string prior_columns_glob this_column_glob
        prior_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${prior_column_index})"
        this_column_glob="(#b)([^${column_delimiter}]#)(${column_delimiter}|(#e))"

        # Split the passed column.
        sputter_newline_delimited\
            ${lines/${~prior_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure Zsh, the inefficiency (and complexity) of such literally hack
    # jobs is patently unseemly.
    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
        list   column_indices; column_indices=( "${@}" )
        string column_indices_with_commas
        column_indices_with_commas="$(join_list_to_string column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column delimiter.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such delimiter.
        sputter "${text}" | cut -s\
            -d "${column_delimiter}"\
            -f "${column_indices_with_commas}"
    fi
}

# --------------------( WASTELANDS                         )--------------------
    # If no list elements were passed, print the empty string and return.
#   is_list_nonempty "${list_name}" or return_true

    #FIXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging die_unless_list() and return_list(). (Yep!)
    #Hmm; wait. We're probably better off with difference_lists_into() and
    #intersect_lists_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZESHY_USER_DIGEST_FILE}"\
#       "${new_function_names[@]:|ZESHY_OLD_FUNCTION_NAMES}"

#FIXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps sputter_restorable_list()? AH! Got it: join_list_to_restorable_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See split_string_to_list() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which Zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FIXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by return_list() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_at_least_two_args\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_one_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}=( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See return_list() for examples.
#alias expand_List='
#is_set List or die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_unset "${list_name}" or print "list ${list_name}; "

#   die_unless_list "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
