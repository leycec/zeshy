#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Match and substitute Zsh-specific extended glob expressions.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.
#
# --------------------( TODO                               )--------------------
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

# ....................{ TESTS                              }....................
#FIXME: Rename is_string_match().
# boolean is_string_match(string text, string glob)
#
# Return true if the passed string matches the passed glob: e.g.,
#
#     >>> is_string_match 'youshima' '[fuk]ushima' or print 'dai-ichi'
#     dai-ichi
function is_string_match() {
    die_unless_one_arg 'expected one string'
    is "${1}" == "${~2}" si
}

# boolean is_string_contains_glob_characters(string text)
#
# Return true if the passed string contains at least one glob-reserved
# character and hence would *NOT* be matched as is under glob matching.
function is_string_contains_glob_characters() {
    die_unless_one_arg 'expected one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

# ....................{ GETTERS                            }....................
# integer get_string_match_count(string text, string glob)
#
# Get the number of substrings matching the passed glob expression in the passed
# string: e.g.,
#
#     >>> get_string_match_count 'bosozoku' '[bsz]o'
#     3
function get_string_match_count() {
    # Validate passed arguments
    die_unless_two_args\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}"

    # If either the passed string or glob expression is empty, return 0.
    if is_empty "${text}" or is_empty "${glob}"; then
        sputter 0
    #FIXME: Extract into a new get_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
    elif not is_glob "${glob}"; then
        string text_matches_deleted="${text//${~glob}/}"
        sputter $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, count with brute-force iteration. While Zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
    else
        integer match_count=-1
        string text_old
        until is "${text_old}" == "${text}" si; do
            (( ++match_count ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        sputter ${match_count}
    fi
}

# ....................{ WRITERS                            }....................
# string remove_string_prefix_matching(string text, string glob)
#
# Remove the longest prefix from the passed string matching the passed glob
# expression and return the resulting string: e.g.,
#
#     >>> remove_string_prefix_matching 'north by northwest' '*n{o,d}?th'
#     west
function remove_string_prefix_matching() {
    die_unless_two_args\
        'expected one string and one glob expression'
    sputter "${1##${~2}}"
}

# string remove_string_suffix_matching(string text, string glob)
#
# Remove the longest suffix from the passed string matching the passed glob
# expression and return the resulting string: e.g.,
#
#     >>> remove_string_suffix_matching 'dial.m.for.murder' '.m?????*'
#     dial.
function remove_string_suffix_matching() {
    die_unless_two_args\
        'expected one string and one glob expression'
    sputter "${1%%${~2}}"
}

# --------------------( WASTELANDS                         )--------------------
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FIXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
