#!/usr/bin/env zsh
# ====================[ glob                               ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Glob, handling glob expression matching and substitution.
#
# --------------------( SEE ALSO                           )--------------------
# "man zshexpn/FILENAME GENERATION"
#     Glob syntax details.
#
# --------------------( TODO                               )--------------------
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.
# * Also, note that glob expressions *CAN* match at the beginning and end of
#   strings: flags "s" and "e" in the same section as above. Between this and
#   backreferencing, I believe we've largely obsoleted our need for regular
#   expression matching in the Zeshy codebase and should probably substitute all
#   such matching with more efficient and certainly elegant glob matching.

# ....................{ TESTS                              }....................
# bool is_glob_expression(string text)
#
# Return true if the passed string contains at least one glob-reserved
# character and hence would *NOT* be matched as is under glob matching. 
is_glob_expression() {
    die_unless_one_arg 'expected one string'
    is "${1}" == *[\[\]\<\>\(\)\|+*?#~^]* si
}

# ....................{ GETTERS                            }....................
# int get_match_count(string text, string glob_expression)
#
# Get the number of substrings matching the passed glob expression in the passed
# string: e.g.,
#
#     >>> get_match_count '[bsz]o' 'bosozoku'
#     3
get_match_count() {
    die_unless_two_args\
        'expected one string and one glob expression'
    string text="${1}" glob="${2}" 

    # If either the passed string or glob expression is empty, return 0.
    if is_empty "${text}" or is_empty "${glob}"; then
        sputter 0
    #FIXME: Extract into a new get_substring_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
    elif not is_glob "${glob}"; then
        string text_matches_deleted="${text//${~glob}/}"
        sputter $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))
    # Otherwise, count with brute-force iteration. While Zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
    else
        integer match_count=-1
        string text_old
        until is "${text_old}" == "${text}" si; do
            (( ++match_count ))
            text_old="${text}"
            text="${text/${~glob}/}"
        done
        sputter ${match_count}
    fi
}

# ....................{ WRITERS                            }....................
# string remove_prefix_matching(string text, string glob_expression)
#
# Remove the longest prefix from the passed string matching the passed glob
# expression and return the resulting string: e.g.,
#
#     >>> remove_prefix_matching 'north by northwest' '*n{o,d}?th'
#     west
remove_prefix_matching() {
    die_unless_two_args\
        'expected one string and one glob expression'
    sputter "${1##${~2}}"
}

# string remove_suffix_matching(string text, string glob_expression)
#
# Remove the longest suffix from the passed string matching the passed glob
# expression and return the resulting string: e.g.,
#
#     >>> remove_suffix_matching 'dial.m.for.murder' '.m?????*'
#     dial.
remove_suffix_matching() {
    die_unless_two_args\
        'expected one string and one glob expression'
    sputter "${1%%${~2}}"
}

#FIXME: Obsolete.
    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FIXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
