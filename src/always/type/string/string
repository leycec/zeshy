#!/usr/bin/env zsh
# ====================[ string                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy String, handling core string functionality.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_string(
#   string variable_name, string error_message = 'not a string')
#
# Throw an exception unless the variable with the passed name is a string.
function die_unless_string() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_string "${1}" or die "${2:-\"${1}\" not of type string}"
}

#FIXME: Rename die_unless_characteracter().
# void die_unless_character(
#   string variable_name, string error_message = 'not a string')
#
# Throw an exception unless the variable with the passed name is a single-
# character string.
function die_unless_character() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_character "${1}" or
        die "${2:-\"${1}\" not of type string or more than one character in length}"
}

# ....................{ TESTS                              }....................
# boolean is_string(string variable_name)
#
# Return true if the variable with the passed name is a string.
function is_string() {
    die_unless_one_arg 'expected one variable name'
    is $(get_type "${1}") == 'scalar'* si
}

# boolean is_character(string variable_name)
#
# Return true if the variable with the passed name is a single character.
function is_character() {
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}"
    is_string "${variable_name}" and {
        integer variable_length
        variable_length=$(get_length "${(P)variable_name}")
        (( variable_length == 1 ))
    }
}

# ....................{ GETTERS ~ length                   }....................
# integer get_length(string text1, string text2, ...)
#
# Get the total length of the passed strings in single-byte characters. If any
# such string contains multibyte characters (e.g., UTF-8-encoded Unicode), this
# may not be what you expect.
function get_length() {
    die_unless_args 'expected at least one string'
    sputter ${#*}
}

# integer get_multibyte_length(string text)
#
# Get the length of the passed string in multibyte characters.
function get_multibyte_length() {
    die_unless_args 'expected at least one string'
    sputter ${(m)#*}
}

# integer get_line_length(string text1, string text2, ...)
#
# Get the total number of lines in the passed strings.
function get_line_length() {
    die_unless_args 'expected at least one string'
    list lines; lines=( "${(f)*}" )
    get_list_size lines
}

# integer get_word_length(string text, string text2, ...)
#
# Get the number of words in the passed string, aggregating each quoted
# substring into one word. Hence, this is the Zsh-specific word length.
function get_word_length() {
    die_unless_args 'expected at least one string'
    list words; words=( "${(z)*}" )
    get_list_size words
}

# integer get_unquoted_word_length(string text1, string text2, ...)
#
# Get the number of words in the passed string, *NOT* aggregating quoted
# substrings. Hence, this is the conventional document word length.
function get_unquoted_word_length() {
    die_unless_args 'expected at least one string'
    list words; words=( "${=*}" )
    get_list_size words
}

# ....................{ GETTERS ~ lines                    }....................
# string get_line(string text, int line_index = 1)
#
# Get the line corresponding to the passed line number from the passed string.
# If positive, this is the nth line from the beginning starting at 1. Conversely
# if negative, this is the nth line from the end starting at -1.
function get_line() {
    # Localize passed arguments.
    die_unless_one_or_two_args\
        'expected one string and optional line number'
    string line_index=${2:-1}
    get_lines "${1}" ${line_index} ${line_index}
}

# string get_first_lines(string text, int last_line_index = 1)
#
# Get the first n lines (defaulting to the first line) from the passed string.
function get_first_lines() {
    die_unless_one_or_two_args\
        'expected one string and optional last line number'
    get_lines "${1}" 1 ${2:-1}
}

# string get_last_lines(
#   string text, int last_line_index = $(get_line_length string))
#
# Get the last n lines (defaulting to the last line) from the passed string.
function get_last_lines() {
    die_unless_one_or_two_args\
        'expected one string and optional last line number'
    string text="${1}" line_length
    line_length="$(get_line_length "${text}")"
    get_lines "${text}" ${2:-${line_length}} ${line_length}
}

# string get_lines(
#   string text,
#   int start_line_index = 1,
#   int end_line_index = $(get_line_length string))
#
# Get the list of lines starting at the passed first line number (defaulting to
# the first line) and concluding at the passed last line number (defaulting to
# the last line) from the passed string.
function get_lines() {
    # Validate passed arguments.
    die_unless_one_to_three_args\
        'expected one string and optional start and end line numbers'
    list lines; lines=( "${(f)1}" )
    string beg_line_index="${2:-}" end_line_index="${3:-}"
    check_list_args lines beg_line_index end_line_index

    # Return the desired lines. Do *NOT* quote such expansion.
    sputter_newline_delimited ${lines[${beg_line_index},${end_line_index}]}
}

# ....................{ GETTERS ~ columns                  }....................
#FIXME: It'd be nice to generalize this to accept arbitrary regular expressions
#against which to match (e.g., "\s+", matching column delimiters as any run of
#whitespace). Actually, that suggests a new complementary
#get_columns_matching_pcre() function.

# string get_columns(
#   string text,
#   character column_delimiter,
#   integer column_index1, integer column_index2, ...)
#
# Get the columns with the passed 1-based column indices from the passed string
# on the passed delimiting character. If passed:
#
# * Only one column index, each output line has only the corresponding column.
# * More than one such index, each output line has the corresponding columns
#   delimited by the passed delimiting character. Consider splitting each such
#   line with split_string_to_list() to obtain the resulting columns.
#
# This function is roughly analogous to the "cut -f" command.
function get_columns() {
    # Validate passed arguments.
    die_unless_at_least_three_args\
        'expected one string, one column delimiter, and at least one column index'
    string text="${1}"   column_delimiter="${2}"
    die_unless_character column_delimiter
    shift_two_args

    # If passed only one column index, such column is efficiently splittable
    # with pure Zsh. Do so, Sir Robin! Arguably, we needn't do so in Zsh; the
    # non-Zsh, POSIX-compatible generalization below suffices for this case.
    #
    # But it's fun. And we can. So we do.
    if is_one_arg; then
        # Index of the column preceding the passed column.
        die_unless_positive_decimal "${1}"
        integer last_column_index=$(( ${1} - 1 ))
        list lines; lines=( ${(f)text} )

        # Glob expressions matching all columns preceding the passed column and
        # the passed column. Dismantled, this is:
        #
        # * "(...)", a non-match group matching a column including the suffixing
        #   column delimiter via:
        #   * "[^${column_delimiter}]#", zero or more characters excluding the
        #     column delimiter.
        #   * "(${column_delimiter}|(#e))", a column delimiter or newline.
        # * "(#c${prior_column_index})", matching such columns up to but not
        #   including the passed column.
        # * "(#b)", enabling back references (i.e., match groups) for all
        #   subsequent groups. Do this as late as possible, for minor and
        #   probably immeasurable efficiency.
        # * "([^${column_delimiter}]#)", a match group matching the passed
        #   column excluding the suffixing column delimiter.
        string last_columns_glob this_column_glob
        last_columns_glob="([^${column_delimiter}]#(${column_delimiter}|(#e)))(#c${last_column_index})"
        this_column_glob="(#b)([^${column_delimiter}]#)(${column_delimiter}|(#e))"

        # Split the passed column.
        sputter_newline_delimited\
            ${lines/${~last_columns_glob}${~this_column_glob}*/$match[1]}
    # Else, defer to "cut". While multiple columns are technically splittable
    # with pure Zsh, the inefficiency (and complexity) of such hacks is fugly.
    else
        # "cut" requires comma-delimited indices, so convert the passed list of
        # column indices to a comma-delimited string.
        list   column_indices; column_indices=( "${@}" )
        string column_indices_with_commas
        column_indices_with_commas="$(join_list_to_string column_indices ',')"

        # Dismantled, this is:
        #
        # * "-d", the passed column delimiter.
        # * "-f", the munged string of comma-delimited column indices.
        # * "-s", excluding lines lacking such delimiter.
        sputter "${text}" | cut -s\
            -d "${column_delimiter}"\
            -f "${column_indices_with_commas}"
    fi
}

# ....................{ GETTERS ~ words                    }....................
# string get_word(string text, integer word_index = 1)
#
# Get the word corresponding to the passed 1-based index from the passed string.
function get_word() {
    die_unless_one_or_two_args\
        'expected one string and optional index'
    sputter "${1[(w)${2:-1}]}"
}

# ....................{ SETTERS                            }....................
# void set_to_string(string variable_name, string text)
#
# Set the variable with the passed name to the passed string: e.g.,
#
#     >>> string machine_elf="tyke" tyke
#     >>> set_to_string "${machine_elf}" "jeweled self-transforming basketball"
#     >>> print "${tyke}"
#     jeweled self-transforming basketball
function set_to_string() {
    # Validate passed arguments.
    die_unless_two_args 'expected one variable name and one string'
    string string_name="${1}"
    die_unless_string "${string_name}"

    # Set.
    noop ${(P)string_name::=${2}}
}

# ....................{ REMOVERS                           }....................
# string remove_prefix(string text, string prefix)
#
# Remove the passed prefix from the passed string: e.g.,
#
#     >>> remove_prefix 'zealia brown' 'zeal'
#     ia brown
function remove_prefix() {
    die_unless_two_args 'expected one string and one prefix'
    sputter "${1##${2}}"
}

# string remove_suffix(string text, string suffix)
#
# Remove the passed suffix from the passed string: e.g.,
#
#     >>> remove_suffix 'august derleth' 'leth'
#     august der
function remove_suffix() {
    die_unless_two_args 'expected one string and one suffix'
    sputter "${1%%${2}}"
}

# string remove_duplicate_lines(string text1, string text2, ...)
#
# Remove all duplicate lines from the concatenation of the passed strings.
# Unlike conventional solutions (e.g., "sort -u", "sort | uniq -u"), this
# function preserves the line order of returned lines: e.g.,
#
#     >>> remove_duplicate_lines 'the Perfect
#     ...   and
#     ...   the Perfect
#     ...   are one Perfect and not two;
#     ...   nay, are none!'
#     the Perfect
#     and
#     are one Perfect and not two;
#     nay, are none!
function remove_duplicate_lines() {
    set_args_to_piped_input
    die_unless_args 'expected at least one string'
    sputter_newline_delimited "${(uf)*}"   # this... this is ridiculous!
}

# string truncate_string(
#   string text, int maximum_length,
#   string suffix_if_exceeding_maximum_length = '')
#
# Truncate the passed string to the passed length, replacing the end of such
# string with the passed suffix (defaulting to the empty string) if the passed
# string exceeds such length: e.g.,
#
#     >>> truncate_string 'Fallujah' 7
#     Falluja
#     >>> truncate_string 'Fallujah' 7 '...'
#     Fall...
function truncate_string() {
    # Validate passed arguments.
    die_unless_two_or_three_args\
        'expected one string, one length, and optional suffix'
    die_unless_positive_decimal "${2}"
    string text="${1}" suffix_if_exceeding_maximum_length="${3:-}"
    integer maximum_length="${2}" text_length
    text_length=$(get_length "${text}")

    # If the passed string requires no truncation, return the same string.
    (( text_length > maximum_length )) or {
        sputter "${text}"
        return
    }

    # If a suffix was passed and the passed string is at least as long as such
    # suffix, truncate by replacing the end of the string with such suffix.
    if is_nonempty "${suffix_if_exceeding_maximum_length}"; then
        integer suffix_length
        suffix_length=$(get_length "${suffix_if_exceeding_maximum_length}")
        if  (( maximum_length >  suffix_length )); then
            (( maximum_length -= suffix_length ))
#           print "maximum_length: ${maximum_length}"
            sputter\
                "${text[1,${maximum_length}]}${suffix_if_exceeding_maximum_length}"
            return_true
        fi
    fi

    # Otherwise, truncate without suffix replacement.
    sputter "${text[1,${maximum_length}]}"
}

# ....................{ SPLITTERS                          }....................
# void split_string_to_string_pair(
#   string text, string delimiter, string variable_name1, string variable_name2)
#
# Split the passed string on the first substring of the passed delimiter into:
#
# * The string with the former name to the substring preceding such delimiter.
# * The string with the latter name to the substring following such delimiter.
#
# The delimiter may be of any non-zero length: e.g.,
#
#     >>> string prefix suffix
#     >>> split_string_to_string_pair\
#       'wolfs==head==society' '==' 'prefix' 'suffix'
#     >>> sputter "prefix: ${prefix}\nsuffix: ${suffix}"
#     prefix: wolfs
#     suffix: head==society
function split_string_to_string_pair() {
    # Validate passed arguments.
    die_unless_four_args\
        'expected one delimiter, source string, and target prefix and suffix variable names'
    string text="${1}" delimiter="${2}" prefix_name="${3}" suffix_name="${4}"
    die_unless_string "${prefix_name}"
    die_unless_string "${suffix_name}"

    # If the passed string contains no such delimiter, throw an exception.
    is "${text}" == *"${delimiter}"* si or
        die "delimiter \"${delimiter}\" not found in \"${text}\""

    # Split.
    set_to_string ${prefix_name} "${text%%${delimiter}*}"
    set_to_string ${suffix_name} "${text#*${delimiter}}"
}

# ....................{ SPLITTERS ~ lists                  }....................
# string split_string_to_list(
#   string text, character delimiter, string list_name)
#
# Split the passed string on all substrings of the passed delimiting character
# into the passed list: e.g.,
#
#     >>> list array
#     >>> split_string_to_list 'Obseqious/Deep/Journeys' '/' array
#     >>> sputter "${array[1]}"
#     Obseqious
function split_string_to_list() {
    # Validate passed arguments.
    die_unless_three_args\
        'expected one string, one delimiter, and one list name'
    string text="${1}" delimiter="${2}" list_name="${3}"
    die_unless_character delimiter
    die_unless_list "${list_name}"

    # If the passed delimiter is a colon, delimit such delimiter by periods.
    if is "${delimiter}" == ':' si
    then eval "${list_name}=( \${(s.:.)text} )"
    # Otherwise, delimit such delimiter by colons.
    else eval "${list_name}=( \${(s:${delimiter}:)text} )"
    fi
}

# string split_lines_to_list(string lines, string list_name)
#
# Split the passed newline-delimited string on newlines into the passed list.
function split_lines_to_list() {
    # Validate passed arguments, treating piped input as the passed string.
    # Avoid naming the local string "lines" to avoid dynamic scope conflicts
    # with caller lists also named "lines". (O, how this hath biteth me hard.)
    string text list_name
    if is_piped_input; then
        die_unless_one_arg 'expected one list name'
        set_to_piped_input text
        list_name="${1}"
    else
        die_unless_two_args 'expected one string and one list name'
        text="${1}"
        list_name="${2}"
    fi
    die_unless_list "${list_name}"

    #FIXME: Can we use a "noop ${(P)list_name::=( ${(f)text} )}"-style
    #technique here? I suspect not, but it does beg the question...
    # Split.
#   sputter "text: ${text}"
    eval "${list_name}=( \${(f)text} )"
}

# string split_characters_to_list(string characters, string list_name)
#
# Split the passed characters into the passed list: e.g.,
#
#     >>> list array
#     >>> split_characters_to_list 'the storm-blast came' array
#     >>> sputter "${array[1]} ${array[3]} ${array[13]} ${array[15]}"
#     t e a t
#
# Since Zsh supports list-style character indexing and slicing out of the box,
# this function is useful only where explicit list types are required.
function split_characters_to_list() {
    # Validate passed arguments.
    die_unless_two_args 'expected one string and one list name'
    string text="${1}" list_name="${2}"
    die_unless_list "${list_name}"

    # Split with a 0-width delimiter.
    eval "${list_name}=( \${(s::)text} )"
}

# ....................{ WRITERS                            }....................
# string suffix_if_not_already(string text, string suffix)
#
# Suffix the passed string with the passed suffix, if not already: e.g.,
#
#     >>> suffix_if_not_already '/habitat/failing/flailing/habits' '/'
#     /habitat/failing/flailing/habits/
function suffix_if_not_already() {
    die_unless_two_args 'expected one string and one suffix'
    sputter "${1%${2}}${2}"
}

# string tabulate(string text, string delimiter = ' ')
#
# Horizontally align the passed strings on the passed delimiter (defaulting to a
# single space) into table columns.
function tabulate() {
    # Validate passed arguments, treating piped input as the passed string.
    set_args_to_piped_input
    die_unless_one_or_two_args 'expected one string and optional delimiter'

    # Tabulate.
    if is_one_arg
    then sputter "${1}" | column -t
    else sputter "${1}" | column -t -s "${2}"
    fi
}

# ....................{ WRITERS ~ case                     }....................
# string capitalize_string(string text1, string text2, ...)
#
# Capitalize the first letter of each word of the passed strings: e.g.,
#
#     >>> capitalize_string "phase two: ???" "phase three: profit"
#     Phase Two: ??? Phase Three: Profit
function capitalize_string() {
    die_unless_args 'expected at least one string'
    sputter "${(C)*}"
}

# string lowercase_string(string text1, string text2, ...)
#
# Convert the passed string to all lowercase_string: e.g.,
#
#     >>> lowercase_string "The Wind in" "the Pillows"
#     the wind in the pillows
function lowercase_string() {
    die_unless_args 'expected at least one string'
    sputter "${(L)*}"
}

# string uppercase_string(string text1, string text2, ...)
#
# Convert the passed string to all uppercase_string: e.g.,
#
#     >>> uppercase_string "The Pyre of" "My Loins"
#     THE PYRE OF MY LOINS
function uppercase_string() {
    die_unless_args 'expected at least one string'
    sputter "${(U)*}"
}

# ....................{ WRITERS ~ lines                    }....................
# string number_lines(string text)
#
# Prefix each line of the passed string with that line's number.
function number_lines() {
    sputter "${@}" |
        run_with_options 'run_paged command nl' 'ZESHY_NL_OPTIONS'
}

#FIXME: Should probably be theme-specific.
# string number_lines_highlighting(string text, int highlight_line_index)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
function number_lines_highlighting() {
    # Localize passed arguments.
    die_unless_two_args 'expected one string and one line number'
    die_unless_positive_decimal "${2}"
    string text="${1}"
    integer line_index="${2}" line_length

    #FIXME: Actually, it's trivial to convert negative to positive line numbers.
    # Validate passed arguments. Negative line numbers are impermissible.
    line_length="$(get_line_length "${text}")"
#   utter "line length: ${line_length}"
    (( 1 <= line_index && line_index <= line_length )) or
        die "line number ${line_index} not in [1, ${line_length}]"

    # Number lines.
    sputter "${text}" | awk -vNRHI=${line_index} '
# If any line other than the highlight line, print the current line number
# followed by the line.
NR != NRHI { printf("%6d%7s%s\n", NR, "", $0) }
# If the highlight line, print the current line number prefixed and suffixed by
# pleasing ASCII arrows. (See print_stack_trace() for similar logic.)
NR == NRHI {
    # Number of digits in the current line number.
    NRLEN = length(NR);
         if (NRLEN==1) {NRNOW = " <-~ " NR}
    else if (NRLEN==2) {NRNOW = "<-~ " NR}
    else if (NRLEN==3) {NRNOW = "<- " NR}
    else               {NRNOW = NR}       # if true, your string is horrid.
    printf("%s ~->   %s\n", NRNOW, $0)
}'
}

# --------------------( WASTELANDS                         )--------------------
#   eval\
#       "${prefix_name}=\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}=\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    sputter "${*[(w)1]}"
#}

#       utter "piped_input: $(get_piped_input)"
#       text="$(get_piped_input)"
    # Validate passed arguments.
#   print -lr -- "${(uf)@}"
#   sputter_newline_delimited ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       is_map_key unique_lines "${line}" or {
#           sputter ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FIXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_lines_highlighting_line() {
#    # Localize passed arguments.
#    die_unless_at_least_two_args\
#        'expected one line number and one or more strings'
#    die_unless_decimal "${1}"
#    integer highlight_line_index="${1}" line_length
#    shift_one_arg
#    string text="${@}"

#FIXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list_to_string() to join_list_with() and
#join_join_list_to_string_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FIXME: Right. join_list_to_string() is simply too brief. join_join_list_to_string() reads
#better.

    # Localize passed arguments.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_one_arg

    # Prefix.
#   list nl; nl=( nl "${ZESHY_NL_OPTIONS[@]}" )
#   sputter "${text}" | {
#       if is_interactive
#       then "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZESHY_NL_OPTIONS_IF_NON_INTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FIXME: Implementable with pure-Zsh.
#   sputter "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_one_arg 'expected one string'
#   sputter "${1[(f)1]}"
#}

#   # Localize passed arguments.
#   (( # >= 1 && # <= 2 )) ||
#       die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> split_string_to_list '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   is_set "${target_name_prefix}" or string ${target_name_prefix}
#   is_set "${target_name_suffix}" or string ${target_name_suffix}
#   is_set "${list_name}" or list "${list_name}"

#   die_unless_string "${target_name_prefix}"
#   die_unless_string "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
