#!/usr/bin/env zsh
# ====================[ type                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Type, handling core type reflection.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_set(char *variable_name, char *error_message = 'not set')
#
# Throw an exception unless the variable with the passed name is set.
die_unless_set() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_set "${variable_name}" or die "${2:-\"${variable_name}\" not set}"
}

# void die_unless_set_empty(
#   char *variable_name, char *error_message = 'not set or set but non-empty')
#
# Throw an exception unless the variable with the passed name is set and empty.
die_unless_set_empty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_set_empty "${variable_name}" or
        die "${2:-\"${variable_name}\" not set or set but non-empty}"
}

# void die_unless_unset(char *variable_name, char *error_message = 'already set')
#
# Throw an exception unless the variable with the passed name is unset.
die_unless_unset() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_unset "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
}

# ....................{ EXCEPTIONS ~ emptiness             }....................
# void die_unless_nonempty(char *string, char *error_message)  --OR--
# void die_if_empty(char *string, char *error_message)
#
# Throw an exception unless the passed string is non-empty. Since no default
# error message reasonably describes such error, an error message must be
# passed. While trivial, this function is implemented for consistency.
die_unless_nonempty die_if_empty() {
    die_unless_two_args 'expected one string and one error message'
    is_nonempty "${1}" or die "${2}"
}

# ....................{ TESTS                              }....................
# bool is_set_empty(char *variable_name)
#
# Return true if the variable with the passed name is set and empty.
is_set_empty() {
    die_unless_one_arg 'expected one variable name'

    # If the passed variable is unset, expand to "x"; otherwise, expand as is.
    # Return true if such expansion is empty. Treat "0" as empty by cutting a
    # prefixing "0", if present. See is_set().
    is -z "${${(P)1-x}#0}" si
}

# bool is_set_nonempty(char *variable_name)
#
# Return true if the variable with the passed name is set and non-empty.
is_set_nonempty() {
    die_unless_one_arg 'expected one variable name'

    # If the passed variable is unset, expand to the empty string; otherwise,
    # expand as is. Return true if such expansion is non-empty. Treat "0" as
    # empty by cutting a prefixing "0", if present. See is_set().
    is -n "${${(P)1-}#0}" si
}

# bool is_set(char *variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
is_set() {
    die_unless_one_arg 'expected one variable name'

    # Dismantled, this is:
    #
    # * "-n", true only if the following expansion is "x" and hence the passed
    #   variable is set.
    # * "(P)1", expanding to the value of the variable with passed name.
    # * "+x", coercing such value to "x" if such variable is set. Since any
    #   arbitrary non-empty value will do, use "x". (Zsh precedent, and all.)
    is -n "${${(P)1+x}#0}" si
}

# bool is_unset(char *string)
#
# Return true if the  variable with the passed name is unset (i.e., undeclared).
is_unset() {
    die_unless_one_arg 'expected one variable name'
    is -z "${(P)1+x}" si  # negate the condition is_set() tests for
}

# ....................{ TESTS ~ emptiness                  }....................
# bool is_nonempty(char *string)
#
# Return true if the passed string is non-empty (i.e., neither "0" or "").
is_nonempty() {
    die_unless_one_arg 'expected one string'
    is -n "${1#0}" si
}

# bool is_empty(char *string)
#
# Return true if the passed string is empty (i.e., either "0" or "").
is_empty() {
    die_unless_one_arg 'expected one string'
    is -z "${1#0}" si
}

# ....................{ TESTS ~ scope                      }....................
# bool is_global(char *variable_name)
#
# Return true if a global variable with the passed name exists.
is_global() {
    die_unless_one_arg 'expected one variable name'
    string variable_type="${(tP)1}"  # See get_type().
    is_nonempty "${variable_type}" and is "${variable_type}" == *'-global' si
}

# bool is_local(char *variable_name)
#
# Return true if a local variable with the passed name exists.
is_local() {
    die_unless_one_arg 'expected one variable name'
    string variable_type="${(tP)1}"  # See get_type().
    is_nonempty "${variable_type}" and is "${variable_type}" == *'-local' si
}

# ....................{ GETTERS                            }....................
# char *get_type(void *name)
#
# Get the type of the object (e.g., function, string) with the passed name or
# throw an exception if no such object exists.
get_type() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one name'
    string object_name="${1}"

    # If the object with the passed name is a variable, return its type.
    if is_set "${object_name}"; then
        # Dismantled, this is:
        #
        # * "P", expanding to the variable with the passed name.
        # * "t", expanding to the variable's type.
        sputter "${(tP)object_name}"
    # Otherwise, this object is a callable or does not exist. Determine which by
    # calling whence() and stripping the resulting string of the prefix
    # consisting only of that name (e.g., assuming object with passed name "dmt"
    # a Zsh function, stripping "dmt: function" to merely "function"). If no
    # such callable exists, whence() outputs a type of "none" under an error exit
    # code ignored with "or true".
    else
        string object_type; object_type="$(whence -w -- "${object_name}")"
        sputter "${object_type##*: }"
    fi
}

# ....................{ WRITERS                            }....................
# void freeze_variable(char *variable_name)
#
# Freeze the variable with the passed name, rendering such variable read-only
# (i.e., "const", "final").
freeze_variable() {
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}"
    die_unless_set "${variable_name}"
    typeset -r     "${variable_name}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Uhm... what? I'm fairly certain we never call this. Doesn't is_set()
#suffice? We probably want to replace this with a new is_global() function.
# bool is_variable(char *variable_name)
#
# Return true if there exists a variable with the passed name.
#is_variable() {
#    die_unless_one_arg 'expected one name'
#    is_nonempty "${(tP)1}"  # see get_type() for details
#}

#FIXME: Rename is_local().
#       string object_type
#       object_type="$(whence -w -- "${object_name}")" or true  # ignore errors

# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.
#FIXME: Uhm; shouldn't "_runnable" be "_callable" everywhere below? Do we really
#need a distinction between the two? Arguably, functions aren't runnable and
#commands and builtins aren't callable. Perhaps

# ....................{ DEPENDENCIES                       }....................
#FIXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os
