#!/usr/bin/env zsh
# ====================[ type                               ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Inspect variable types, values, and status (e.g., declared, frozen).

# ....................{ EXCEPTIONS                         }....................
# void die_unless_variable(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not set")
#
# Throw an exception unless the variable with the passed name is set.
function die_unless_variable() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_variable "${variable_name}" or die "${2:-\"${variable_name}\" not set}"
}

# void die_unless_empty_variable(
#   string variable_name,
#   string error_message = "\"${variable_name}\" not set or set but non-empty")
#
# Throw an exception unless the variable with the passed name is set and empty.
function die_unless_empty_variable() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    string variable_name="${1}"
    is_variable_empty "${variable_name}" or
        die "${2:-\"${variable_name}\" not set or set but non-empty}"
}

# void die_if_empty(string text, string error_message) --OR--
# void die_unless_nonempty(string text, string error_message)
#
# Throw an exception unless the passed string is non-empty. Since no default
# error message reasonably describes such error, an error message must be
# passed. While trivial, this function is implemented for consistency.
function die_if_empty die_unless_nonempty() {
    die_unless_two_args 'expected one string and one error message'
    is_nonempty "${1}" or die "${2}"
}

# ....................{ TESTS                              }....................
# boolean is_variable(string variable_name)
#
# Return true if the variable with the passed name is set (i.e., declared).
function is_variable() {
    # Dismantled, this is:
    #
    # * "(P)1", referencing the variable with passed name.
    # * "+x", expanding to "x" if such variable is set or to the empty string
    #   otherwise. Since any arbitrary non-empty value will do, use "x". (Zsh
    #   precedent, and all.)
    # * "is -n ... si", true if such expansion is non-empty and thus the passed
    #   valiable is set.
    die_unless_one_arg 'expected one variable name'
    is -n "${(P)1+x}" si
}

# boolean is_variable_empty(string variable_name)
#
# Return true if the variable with the passed name is set and empty.
function is_variable_empty() {
    die_unless_one_arg 'expected one variable name'

    # If the passed variable is unset, expand to "x"; otherwise, expand as is.
    # Return true if such expansion is empty. Dismantled, this is:
    #
    # * "#0", removing a prefixing "0" if present and hence treating "0" as
    #   empty. By default, Zsh only treats the empty string as empty. Since
    #   integers are scalars that are *ALWAYS* some integer and hence never the
    #   empty string, integers would never be treated as empty without such fix.
    is -z "${${(P)1-x}#0}" si
}

# boolean is_variable_nonempty(string variable_name)
#
# Return true if the variable with the passed name is set and non-empty.
function is_variable_nonempty() {
    die_unless_one_arg 'expected one variable name'

    # If the passed variable is unset, expand to the empty string; otherwise,
    # expand as is. Return true if such expansion is non-empty.
    is -n "${${(P)1-}#0}" si
}

# ....................{ TESTS ~ values                     }....................
# boolean is_nonempty(string text)
#
# Return true if the passed string is non-empty (i.e., neither "0" or "").
function is_nonempty() {
    die_unless_one_arg 'expected one string'
    is -n "${1#0}" si
}

# boolean is_empty(string text)
#
# Return true if the passed string is empty (i.e., either "0" or "").
function is_empty() {
    die_unless_one_arg 'expected one string'
    is -z "${1#0}" si
}

# ....................{ TESTS ~ scope                      }....................
# boolean is_global(string variable_name)
#
# Return true if a global variable with the passed name exists.
function is_global() {
    die_unless_one_arg 'expected one variable name'
    string variable_type="${(tP)1}"  # see get_type()
    is_nonempty "${variable_type}" and
        is_string_suffix "${variable_type}" '-global'
}

# boolean is_local(string variable_name)
#
# Return true if a local variable with the passed name exists.
function is_local() {
    die_unless_one_arg 'expected one variable name'
    string variable_type="${(tP)1}"  # see get_type()
    is_nonempty "${variable_type}" and
        is_string_suffix "${variable_type}" '-local'
}

# ....................{ GETTERS                            }....................
# string get_type(void *name)
#
# Get the type of the object (e.g., function, string) with the passed name or
# throw an exception if no such object exists.
function get_type() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one name'
    string object_name="${1}"

    # If the object with the passed name is a variable, return its type.
    if is_variable "${object_name}"; then
        # Dismantled, this is:
        #
        # * "P", expanding to the variable with the passed name.
        # * "t", expanding to the variable's type.
        sputter "${(tP)object_name}"
    # Otherwise, this object is a callable or does not exist. Determine which by
    # calling whence() and stripping the resulting string of the prefix
    # consisting only of that name (e.g., assuming object with passed name "dmt"
    # a Zsh function, stripping "dmt: function" to merely "function"). If no
    # such callable exists, whence() outputs a type of "none" under an error exit
    # code ignored with "or true".
    else
        string object_type; object_type="$(whence -w -- "${object_name}")"
        sputter "${object_type##*: }"
    fi
}

# ....................{ GETTERS ~ first                    }....................
# string get_first_nonempty_variable(
#   string variable_name1, variable_name2, ...,
#   string error_message = "\"${^@}\" not defined or empty")
#
# Get the name of the first passed variable with non-empty value or throw an
# exception if no such variables have a non-empty value: e.g.,
#
#     >>> unset_variable INDICA SATIVA
#     >>> string SALVIA DIVINORUM='is no nostrum'
#     >>> get_first_nonempty_variable(INDICA SATIVA SALVIA DIVINORUM)
#     DIVINORUM
function get_first_nonempty_variable() {
    get_first_nonempty_variable_or_false "${@}" or
        die "$(join_list_to_conjunction "${@}") not defined or empty"
}

# string get_first_nonempty_variable_value(
#   string variable_name1, variable_name2, ...,
#   string error_message = "\"${^@}\" not defined or empty")
#
# Get the value of the first passed variable with non-empty value or throw an
# exception if no such variables have a non-empty value: e.g.,
#
#     >>> unset_variable INDICA SATIVA
#     >>> string SALVIA DIVINORUM='is no nostrum'
#     >>> get_first_nonempty_variable_value(INDICA SATIVA SALVIA DIVINORUM)
#     is no nostrum
function get_first_nonempty_variable() {
    get_first_nonempty_variable_value_or_false "${@}" or
        die "$(join_list_to_conjunction "${@}") not defined or empty"
}

# string get_first_nonempty_variable_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the name of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM HARMALA
#     >>> get_first_nonempty_variable_or('Thank you, Iran.' PEGANUM HARMALA)
#     Thank you, Iran.
function get_first_nonempty_variable_or() {
    die_unless_at_least_two_args\
        'expected one default value and at least one variable name'
    get_first_nonempty_variable_or_false "${@[2,-1]}" or sputter "${@[1]}"
}

# string get_first_nonempty_variable_value_or(
#   string default_value,
#   string variable_name1, variable_name2, ...)
#
# Get the value of the first passed variable with non-empty value or the passed
# default value if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable PEGANUM
#     >>> string HARMALA='Esfand svanta'
#     >>> get_first_nonempty_variable_value_or('Thank you.' PEGANUM HARMALA)
#     Esfand svanta
function get_first_nonempty_variable_value_or() {
    die_unless_at_least_two_args\
        'expected one default value and at least one variable name'
    get_first_nonempty_variable_value_or_false "${@[2,-1]}" or sputter "${@[1]}"
}

# string get_first_nonempty_variable_or_false(
#   string variable_name1, variable_name2, ...)
#
# Get the name of the first passed variable with non-empty value or return false
# if no such variable has a non-empty value: e.g.,
#
#     >>> unset_variable FIVE MeO
#     >>> string DMT
#     >>> get_first_nonempty_variable_or_false(FIVE MeO DMT) or print "Tyke?"
#     Tyke?
function get_first_nonempty_variable_or_false() {
    die_unless_args 'expected at least one variable name'
    for variable_name ("${@}") {
        is_nonempty "${variable_name}" and {
            sputter "${variable_name}"
            return_true
        }
    }
    return_false
}

# string get_first_nonempty_variable_value_or_false(
#   string variable_name1, variable_name2, ...)
#
# Get the value of the first passed variable with non-empty value or return
# false if no such variables has a non-empty value: e.g.,
#
#     >>> unset_variable FIVE MeO
#     >>> string DMT="Crysanthemum."
#     >>> get_first_nonempty_variable_value_or_false(FIVE MeO DMT) or print "O"
#     Crysanthemum.
function get_first_nonempty_variable_value_or_false() {
    die_unless_args 'expected at least one variable name'
    for variable_name ("${@}") {
        is_nonempty "${variable_name}" and {
            sputter "${(P)variable_name}"
            return_true
        }
    }
    return_false
}

# ....................{ FREEZERS                           }....................
# void freeze_variable(string variable_name)
#
# Freeze the variable with the passed name, rendering such variable read-only
# (i.e., "const", "final").
function freeze_variable() {
    die_unless_one_arg 'expected one variable name'
    string variable_name="${1}"
    die_unless_declared "${variable_name}"
    typeset -r "${variable_name}"
}

# --------------------( WASTELANDS                         )--------------------
# void die_unless_unset(string variable_name, string error_message = 'already set')
#
# Throw an exception unless the variable with the passed name is unset.
#function die_unless_unset() {
#    die_unless_one_or_two_args\
#        'expected one variable name and optional error message'
#    string variable_name="${1}"
#    is_undeclared "${variable_name}" or die "${2:-\"${variable_name}\" already set}"
#}

    # Validate passed arguments.
    # Iterate passed arguments for the first non-empty variable or return false.
# boolean is_variable(string text)
#
# Return true if the variable with the passed name is unset (i.e., undeclared).
#function is_variable() {
    # Negate the condition is_variable_declared() tests for.
#    die_unless_one_arg 'expected one variable name'
#    is -z "${(P)1+x}" si
#}

#FIXME: I'm no longer enamoured with our use of "set" in this context, which
#conflicts with our use of "set" when referring to list and map sets. Rather,
#let's rename the former uses of "set" with "defined": e.g.,
# string get_first_defined_nonempty_variable(...)

#FIXME: Uhm... what? I'm fairly certain we never call this. Doesn't is_declared()
#suffice? We probably want to replace this with a new is_global() function.
# boolean is_variable(string variable_name)
#
# Return true if there exists a variable with the passed name.
#is_variable() {
#    die_unless_one_arg 'expected one name'
#    is_nonempty "${(tP)1}"  # see get_type() for details
#}

#FIXME: Rename is_local().
#       string object_type
#       object_type="$(whence -w -- "${object_name}")" or true  # ignore errors

# * Reflection functionality for dynamically inspecting functions and aliases
#   like first-class constructs.
#FIXME: Uhm; shouldn't "_runnable" be "_callable" everywhere below? Do we really
#need a distinction between the two? Arguably, functions aren't runnable and
#commands and builtins aren't callable. Perhaps

# ....................{ DEPENDENCIES                       }....................
#FIXME: This is generic functionality which should probably be provided by
#"core". Shift us up the genericity!
# void _zeshy_type(void)
#
# Import Zeshy components specific to the current OS.
#_zeshy_type() {
#    string current_dir="$(dirname "${zeshy_script_path}")"
#    is_dir "${current_dir}" and zimport "${current_dir}"
#}

# ....................{ MAIN                               }....................
# Call and then immediately unset (i.e., delete) _zeshy_os().
#_zeshy_os
#unset _zeshy_os
