#!/usr/bin/env zsh
# ====================[ decimal                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Decimal, handling decimals (i.e., base 10 integers). For orthogonality,
# Zeshy uses "decimal" in the same sense as "hexadecimal" -- which is to say, to
# denote integers in some base. Such use contradicts the formal sense of the
# term "decimal," a base 10 real number containing a decimal point and hence
# *NOT* an integer. While lamentable, there exists no other sane synonym of the
# term "integer". Since Zsh already uses "integer" to denote variables of that
# type, Zeshy mournfully defers to using "decimal".

# ....................{ EXCEPTIONS                         }....................
# void die_unless_decimal(
#   char *string, char *error_message = 'not an integer')
#
# Throw an exception unless the passed string is an integer. See is_decimal()
# for further details.
die_unless_decimal() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_decimal "${1}" or die "${2:-\"${1}\" not an integer}"
}

# void die_unless_positive_decimal(
#   char *string, char *error_message = 'not a positive integer')
#
# Throw an exception unless the passed string is an integer > 0.
die_unless_positive_decimal() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_positive_decimal "${1}" or die "${2:-\"${1}\" not a positive integer}"
}

# void die_unless_negative_decimal( #   char *string, char *error_message = 'not a negative integer')
#
# Throw an exception unless the passed string is an integer < 0.
die_unless_negative_decimal() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_negative_decimal "${1}" or die "${2:-\"${1}\" not a negative integer}"
}

# void die_unless_nonnegative_decimal(
#   char *string, char *error_message = 'not a nonnegative integer')
#
# Throw an exception unless the passed string is an integer >= 0.
die_unless_nonnegative_decimal() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_nonnegative_decimal "${1}" or
        die "${2:-\"${1}\" not a nonnegative integer}"
}

# void die_unless_nonpositive_decimal(
#   char *string, char *error_message = 'not a nonpositive integer')
#
# Throw an exception unless the passed string is an integer <= 0.
die_unless_nonpositive_decimal() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_nonpositive_decimal "${1}" or
        die "${2:-\"${1}\" not a nonpositive integer}"
}

# void die_unless_decimal_ranging(
#   char *string, int lower_bound, int upper_bound,
#   char *error_message = 'not an integer in')
#
# Throw an exception unless the passed string is an integer bounded by the
# passed inclusive lower and upper bounds.
die_unless_decimal_ranging() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    string integer="${1}" lower_bound="${2}" upper_bound="${3}"
    is_decimal_ranging "${integer}" "${lower_bound}" "${upper_bound}" or
        die "${4:-\"${integer}\" not an integer in [${lower_bound}, ${upper_bound}]}"
}

# ....................{ TESTS                              }....................
# bool is_decimal(char *string)
#
# Return true if the passed string is an integer consisting of a string of
# digits optionally prefixed with the negation sign "-".
is_decimal() {
    die_unless_one_arg 'expected one string'

    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, Zsh-ism.
    is "${1}" == (-|)<-> si
}

# bool is_positive_decimal(char *string)
#
# Return true if the passed string is an integer > 0.
is_positive_decimal() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer > 0 ))
}

# bool is_negative_decimal(char *string)
#
# Return true if the passed string is an integer < 0.
is_negative_decimal() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer < 0 ))
}

# bool is_nonnegative_decimal(char *string)
#
# Return true if the passed string is an integer >= 0.
is_nonnegative_decimal() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer >= 0 ))
}

# bool is_nonpositive_decimal(char *string)
#
# Return true if the passed string is an integer <= 0.
is_nonpositive_decimal() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer <= 0 ))
}

# bool is_decimal_ranging(char *string, int lower_bound, int upper_bound)
#
# Return true if the passed string is an integer bounded by the passed inclusive
# lower and upper bounds.
is_decimal_ranging() {
    die_unless_three_args\
        'expected one string, one lower bound, and one upper bound'
    die_unless_decimal "${2}"
    die_unless_decimal "${3}"
    string integer="${1}"
    integer lower_bound="${2}" upper_bound="${3}"
    is_decimal "${integer}" and
        (( lower_bound <= integer && integer <= upper_bound ))
}

# ....................{ TESTS ~ parity                     }....................
# bool is_even_decimal(char *string)
#
# Return true if the passed string is an even integer.
is_even_decimal() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and not (( integer & 1 ))
}

# bool is_odd_decimal(char *string)
#
# Return true if the passed string is an odd integer.
is_odd_decimal() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer & 1 ))
}

# ....................{ GETTERS                            }....................
# int *get_decimals_ranging(int start_integer, int end_integer)
#
# Get a list inclusively ranging over the passed start and end integers: e.g.,
#
#     >>> get_decimals_ranging 6 9
#     6 7 8 9
get_decimals_ranging() {
    die_unless_decimal "${1}"
    die_unless_decimal "${2}"
    integer beg_integer="${1}" end_integer="${2}"
    print {${beg_integer}..${end_integer}}
}

#FIXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html
# int get_random_decimal(int min = 0, int max = 32767)
#
# Get a random integer in the range [${min}, ${max}].
get_random_decimal() {
    die_unless_at_most_two_args\
        'expected optional minimum and maximum integers'
    string min="${1:-0}" max="${2:-32767}"
    die_unless_decimal "${min}"
    die_unless_decimal "${max}"

    #FIXME: Raise an exception if the passed "max" is larger than 32767? We can
    #fake larger ranges by simply multiplying with float arithmetic and capping
    #the output to the desired max, which seems preferable.

    # The current time in seconds since the first expansion of ${SECONDS} to six
    # fractional decimal places of accuracy: the maximum under Linux.
    float_with_fractional_digit_length 6 seconds="${SECONDS}"

    # Prior to returning a random number, force Zsh's internal random number
    # generator to iterate to the next such number by reseeding with such time
    # discarding the separating decimal place ".". Failure to do so returns the
    # same initial number of such sequence on each call to this function.
    RANDOM=${seconds/./}

    # Randomize.
    sputter $[(${RANDOM} % (${max} - ${min} + 1)) + ${min}]
}

# ....................{ GETTERS ~ units                    }....................
# 1KB, 1MB, 1GB, and 1TB as base 2 rather than metric (i.e., base 10) integers.
KB() {
    die_if_args
    sputter $(( 1 << 10 ))
}

MB() {
    die_if_args
    sputter $(( 1 << 20 ))
}

GB() {
    die_if_args
    sputter $(( 1 << 30 ))
}

TB() {
    die_if_args
    sputter $(( 1 << 40 ))
}

# ....................{ CONVERTERS                         }....................
# string convert_decimal_to_comma_separated_string(integer integer)
#
# Convert the passed integer to a comma-separated string: e.g.,
#
#     >>> convert_decimal_to_comma_separated_string 1776
#     1,776
convert_decimal_to_comma_separated_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one integer'
    string integer="${1}"
    die_unless_decimal "${integer}"

    # Unlike Zsh, awk's printf() happily supports comma delimitation.
    sputter "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Hmm. A tad excessive. Do we actually use these anywhere? Consider
#replacing with "type/integer" functions of the same name. Then, these are
#accessed via, say, $(KB) rather than ${KB}.

# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#     echo 1776 | comma_separate_decimal #     1,776
