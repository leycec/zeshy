#!/usr/bin/env zsh
# ====================[ decimal                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle decimals (i.e., base 10 integers). For orthogonality, Zeshy uses
# "decimal" in the sense of "hexadecimal" to denote integers of a certain base.
# Such use contradicts the formal definition of the term "decimal," a base 10
# real number containing a decimal point and hence not an integer. While
# lamentable, there exists no other sane synonym of the term "integer". Since
# Zsh already uses "integer" to denote variables of that type, "decimal" it is.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_decimal(
#   string text,
#   string error_message = "\"${1}\" not an integer")
#
# Throw an exception unless the passed string is an integer. See is_decimal()
# for further details.
die_unless_decimal() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_decimal "${1}" or die "${2:-\"${1}\" not an integer}"
}

# void die_unless_decimal_positive(
#   string text,
#   string error_message = "\"${1}\" not a positive integer")
#
# Throw an exception unless the passed string is a positive integer.
die_unless_decimal_positive() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_decimal_positive "${1}" or die "${2:-\"${1}\" not a positive integer}"
}

# void die_unless_decimal_negative(
#   string text,
#   string error_message = "\"${1}\" not a negative integer")
#
# Throw an exception unless the passed string is a negative integer.
die_unless_decimal_negative() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_decimal_negative "${1}" or die "${2:-\"${1}\" not a negative integer}"
}

# void die_unless_decimal_nonnegative(
#   string text,
#   string error_message = "\"${1}\" not a nonnegative integer")
#
# Throw an exception unless the passed string is an integer >= 0.
die_unless_decimal_nonnegative() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_decimal_nonnegative "${1}" or
        die "${2:-\"${1}\" not a nonnegative integer}"
}

# void die_unless_decimal_nonpositive(
#   string text,
#   string error_message = "\"${1}\" not a nonpositive integer")
#
# Throw an exception unless the passed string is an integer <= 0.
die_unless_decimal_nonpositive() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_decimal_nonpositive "${1}" or
        die "${2:-\"${1}\" not a nonpositive integer}"
}

# void die_unless_decimal_ranging(
#   string text, int lower_bound, int upper_bound,
#   string error_message = "\"${text}\" not an integer in [${lower_bound}, ${upper_bound}]}")
#
# Throw an exception unless the passed string is an integer bounded by the
# passed inclusive lower and upper bounds.
die_unless_decimal_ranging() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    string integer="${1}" lower_bound="${2}" upper_bound="${3}"
    is_decimal_ranging "${integer}" "${lower_bound}" "${upper_bound}" or
        die "${4:-\"${integer}\" not an integer in [${lower_bound}, ${upper_bound}]}"
}

# ....................{ TESTS                              }....................
# boolean is_decimal(string text)
#
# Return true if the passed string is an integer consisting of a string of
# digits optionally prefixed with the negation sign "-".
is_decimal() {
    die_unless_one_arg 'expected one string'

    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, Zsh-ism.
    is "${1}" == (-|)<-> si
}

# boolean is_decimal_positive(string text)
#
# Return true if the passed string is an integer > 0.
is_decimal_positive() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer > 0 ))
}

# boolean is_decimal_negative(string text)
#
# Return true if the passed string is an integer < 0.
is_decimal_negative() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer < 0 ))
}

# boolean is_decimal_nonnegative(string text)
#
# Return true if the passed string is an integer >= 0.
is_decimal_nonnegative() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer >= 0 ))
}

# boolean is_decimal_nonpositive(string text)
#
# Return true if the passed string is an integer <= 0.
is_decimal_nonpositive() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer <= 0 ))
}

# boolean is_decimal_ranging(string text, int lower_bound, int upper_bound)
#
# Return true if the passed string is an integer bounded by the passed inclusive
# lower and upper bounds.
is_decimal_ranging() {
    die_unless_three_args\
        'expected one string, one lower bound, and one upper bound'
    die_unless_decimal "${2}"
    die_unless_decimal "${3}"
    string integer="${1}"
    integer lower_bound="${2}" upper_bound="${3}"
    is_decimal "${integer}" and
        (( lower_bound <= integer && integer <= upper_bound ))
}

# ....................{ TESTS ~ parity                     }....................
# boolean is_decimal_even(string text)
#
# Return true if the passed string is an even integer.
is_decimal_even() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and not (( integer & 1 ))
}

# boolean is_decimal_odd(string text)
#
# Return true if the passed string is an odd integer.
is_decimal_odd() {
    die_unless_one_arg 'expected one string'
    string integer="${1}"
    is_decimal "${integer}" and (( integer & 1 ))
}

# ....................{ GETTERS                            }....................
# integer get_decimals_ranging(integer start_integer, integer end_integer)
#
# Get a list inclusively ranging over the passed start and end integers: e.g.,
#
#     >>> get_decimals_ranging 6 9
#     6 7 8 9
get_decimals_ranging() {
    die_unless_two_args 'expected one start integer and one end integer'
    string beg_integer="${1}" end_integer="${2}"
    die_unless_decimal "${beg_integer}"
    die_unless_decimal "${end_integer}"
    sputter {${beg_integer}..${end_integer}}
}

#FIXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html
# integer get_random_decimal(integer minimum = 0, integer maximum = 32767)
#
# Get a random integer in the range [${minimum}, ${maximum}].
get_random_decimal() {
    # Validate passed arguments.
    die_unless_at_most_two_args\
        'expected optional minimum and maximum integers'
    string min="${1:-0}" max="${2:-32767}"
    die_unless_decimal "${min}"
    die_unless_decimal "${max}"

    #FIXME: Raise an exception if the passed "max" is larger than 32767? We can
    #fake larger ranges by simply multiplying with float arithmetic and capping
    #the output to the desired max, which seems preferable.

    # The current time in seconds since the first expansion of ${SECONDS} to six
    # fractional decimal places of accuracy: the maximum under Linux.
    float_with_fractional_digit_length 6 seconds="${SECONDS}"

    # Prior to returning a random number, force Zsh's internal random number
    # generator to iterate to the next such number by reseeding with such time
    # discarding the separating decimal place ".". Failure to do so returns the
    # same initial number of such sequence on each call to this function.
    RANDOM=${seconds/./}

    # Randomize.
    sputter $[(${RANDOM} % (${max} - ${min} + 1)) + ${min}]
}

# ....................{ GETTERS ~ units                    }....................
# 1KB, 1MB, 1GB, and 1TB as base 2 rather than metric (i.e., base 10) integers.
KB() {
    die_if_args
    sputter $(( 1 << 10 ))
}

MB() {
    die_if_args
    sputter $(( 1 << 20 ))
}

GB() {
    die_if_args
    sputter $(( 1 << 30 ))
}

TB() {
    die_if_args
    sputter $(( 1 << 40 ))
}

# ....................{ CONVERTERS                         }....................
# string convert_decimal_to_comma_separated_string(integer integer)
#
# Convert the passed integer to a comma-separated string: e.g.,
#
#     >>> convert_decimal_to_comma_separated_string 1776
#     1,776
convert_decimal_to_comma_separated_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one integer'
    string integer="${1}"
    die_unless_decimal "${integer}"

    # Unlike Zsh, awk's printf() happily supports comma delimitation.
    sputter "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Let's be honest: this is all *INCREDIBLY* confusing. It confuses even
#me. Drop the "decimal" nonsense. Shift the contents of this file into
#"type/integer/integer" and delete this file. Rename functions as follows:
#
#* is_decimal() to is_string_integer().
#* is_decimal_positive() to is_string_positive().
#* is_decimal_negative() to is_string_positive().
#
#Rename die_unless_*() functions as above, as well.

#FIXME: Hmm. A tad excessive. Do we actually use these anywhere? Consider
#replacing with "type/integer" functions of the same name. Then, these are
#accessed via, say, $(KB) rather than ${KB}.

# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#     echo 1776 | comma_separate_decimal #     1,776
