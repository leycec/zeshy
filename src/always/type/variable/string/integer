#!/usr/bin/env zsh
# ====================[ integer                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle string variables with integer values. As discussed in "doc/README.dev",
# integer variables suffer numerous deficiencies (e.g., forced casting of non-
# integer types to integer value 0, forced rounding down of float types).
# Since string variables suffer no such deficiencies and implicitly support
# integer values, Zeshy prefers string to integer variables. This component
# handles such strings.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_string_integer(
#   string value,
#   string error_message = "\"${value}\" not an integer")
#
# Throw an exception unless the passed string is an integer. See
# is_string_integer() for further details.
die_unless_string_integer() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_string_integer "${1}" or die "${2:-\"${1}\" not an integer}"
}

# void die_unless_string_positive_integer(
#   string value,
#   string error_message = "\"${value}\" not a positive integer")
#
# Throw an exception unless the passed string is a positive integer.
die_unless_string_positive_integer() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_string_positive_integer "${1}" or die "${2:-\"${1}\" not a positive integer}"
}

# void die_unless_string_negative_integer(
#   string value,
#   string error_message = "\"${value}\" not a negative integer")
#
# Throw an exception unless the passed string is a negative integer.
die_unless_string_negative_integer() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_string_negative_integer "${1}" or die "${2:-\"${1}\" not a negative integer}"
}

# void die_unless_string_nonnegative_integer(
#   string value,
#   string error_message = "\"${value}\" not a nonnegative integer")
#
# Throw an exception unless the passed string is an integer >= 0.
die_unless_string_nonnegative_integer() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_string_nonnegative_integer "${1}" or
        die "${2:-\"${1}\" not a nonnegative integer}"
}

# void die_unless_string_nonpositive_integer(
#   string value,
#   string error_message = "\"${value}\" not a nonpositive integer")
#
# Throw an exception unless the passed string is an integer <= 0.
die_unless_string_nonpositive_integer() {
    die_unless_one_or_two_args\
        'expected one string and optional error message'
    is_string_nonpositive_integer "${1}" or
        die "${2:-\"${1}\" not a nonpositive integer}"
}

# void die_unless_string_integer_ranging(
#   string value, int lower_bound, int upper_bound,
#   string error_message = "\"${value}\" not an integer in [${lower_bound}, ${upper_bound}]}")
#
# Throw an exception unless the passed string is an integer between the passed
# inclusive lower and upper integer bounds.
die_unless_string_integer_ranging() {
    die_unless_three_or_four_args\
        'expected one string and optional error message'
    string value="${1}" lower_bound="${2}" upper_bound="${3}"
    is_string_integer_ranging "${value}" "${lower_bound}" "${upper_bound}" or
        die "${4:-\"${value}\" not an integer in [${lower_bound}, ${upper_bound}]}"
}

# ....................{ TESTS                              }....................
# boolean is_string_integer(string value)
#
# Return true if the passed string is an integer (i.e., digits possibly prefixed
# by a negation sign).
is_string_integer() {
    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, Zsh-ism.
    die_unless_one_arg 'expected one string'
    is "${1}" == (-|)<-> si
}

# boolean is_string_positive_integer(string value)
#
# Return true if the passed string is a positive integer.
is_string_positive_integer() {
    die_unless_one_arg 'expected one string'
    string value="${1}"
    is_string_integer "${value}" and (( value > 0 ))
}

# boolean is_string_negative_integer(string value)
#
# Return true if the passed string is a negative integer.
is_string_negative_integer() {
    die_unless_one_arg 'expected one string'
    string value="${1}"
    is_string_integer "${value}" and (( value < 0 ))
}

# boolean is_string_nonnegative_integer(string value)
#
# Return true if the passed string is an integer >= 0.
is_string_nonnegative_integer() {
    die_unless_one_arg 'expected one string'
    string value="${1}"
    is_string_integer "${value}" and (( value >= 0 ))
}

# boolean is_string_nonpositive_integer(string value)
#
# Return true if the passed string is an integer <= 0.
is_string_nonpositive_integer() {
    die_unless_one_arg 'expected one string'
    string value="${1}"
    is_string_integer "${value}" and (( value <= 0 ))
}

# boolean is_string_integer_ranging(
#   string value, int lower_bound, int upper_bound)
#
# Return true if the passed string is an value bounded by the passed inclusive
# lower and upper bounds.
is_string_integer_ranging() {
    die_unless_three_args\
        'expected one string, one lower bound, and one upper bound'
    string value="${1}" lower_bound="${2}" upper_bound="${3}"
    die_unless_string_integer "${lower_bound}"
    die_unless_string_integer "${upper_bound}"
    is_string_integer "${value}" and
        (( lower_bound <= value && value <= upper_bound ))
}

# ....................{ TESTS ~ parity                     }....................
# boolean is_string_integer_even(string value)
#
# Return true if the passed string is an even integer.
is_string_integer_even() {
    die_unless_one_arg 'expected one string'
    string value="${1}"
    is_string_integer "${value}" and not (( value & 1 ))
}

# boolean is_string_integer_odd(string value)
#
# Return true if the passed string is an odd integer.
is_string_integer_odd() {
    die_unless_one_arg 'expected one string'
    string value="${1}"
    is_string_integer "${value}" and (( value & 1 ))
}

# ....................{ GETTERS                            }....................
# integer get_string_integers_ranging(
#   integer start_integer, integer end_integer)
#
# Get a list inclusively ranging over the passed start and end integers: e.g.,
#
#     >>> get_string_integers_ranging 6 9
#     6 7 8 9
get_string_integers_ranging() {
    die_unless_two_args 'expected one start integer and one end integer'
    string beg_integer="${1}" end_integer="${2}"
    die_unless_string_integer "${beg_integer}"
    die_unless_string_integer "${end_integer}"
    output {${beg_integer}..${end_integer}}
}

#FIXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html
# integer get_string_integer_random(
#   integer minimum = 0, integer maximum = 32767)
#
# Get a random integer in the range [${minimum}, ${maximum}].
get_string_integer_random() {
    # Validate passed arguments.
    die_unless_at_most_two_args\
        'expected optional minimum and maximum integers'
    string min_integer="${1:-0}" max_integer="${2:-32767}"
    die_unless_string_integer "${min_integer}"
    die_unless_string_integer "${max_integer}"

    #FIXME: Raise an exception if the passed "max" is larger than 32767? We can
    #fake larger ranges by simply multiplying with float arithmetic and capping
    #the output to the desired max, which seems preferable.

    # The current time in seconds since the first expansion of ${SECONDS} to six
    # fractional string places of accuracy: the maximum under Linux.
    float_with_fractional_digit_length 6 seconds="${SECONDS}"

    # Prior to returning a random number, force Zsh's internal random number
    # generator to iterate to the next such number by reseeding with such time
    # discarding the separating string place ".". Failure to do so returns the
    # same initial number of such sequence on each call to this function.
    RANDOM=${seconds/./}

    # Randomize.
    output\
        $[(${RANDOM} % (${max_integer} - ${min_integer} + 1)) + ${min_integer}]
}

# ....................{ GETTERS ~ units                    }....................
# 1KB, 1MB, 1GB, and 1TB as base 2 rather than metric (i.e., base 10) integers.
KB() {
    die_if_args
    output $(( 1 << 10 ))
}

MB() {
    die_if_args
    output $(( 1 << 20 ))
}

GB() {
    die_if_args
    output $(( 1 << 30 ))
}

TB() {
    die_if_args
    output $(( 1 << 40 ))
}

# ....................{ CONVERTERS                         }....................
# string convert_string_integer_to_comma_separated_string(integer number)
#
# Convert the passed integer to a comma-separated string: e.g.,
#
#     >>> convert_string_integer_to_comma_separated_string 1776
#     1,776
convert_string_integer_to_comma_separated_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one integer'
    string integer="${1}"
    die_unless_string_integer "${integer}"

    # Unlike Zsh's printf(), awk's printf() happily supports comma delimitation.
    output "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: Let's be honest: this is all *INCREDIBLY* confusing. It confuses even
#me. Drop the "decimal" nonsense. Shift the contents of this file into
#"type/integer/integer" and delete this file. Rename functions as follows:
#
#* is_string() to is_string_integer().
#* is_string_positive_integer() to is_string_positive_integer().
#* is_string_negative_integer() to is_string_positive_integer().
#
#Rename die_unless_*() functions as above, as well.

#FIXME: Hmm. A tad excessive. Do we actually use these anywhere? Consider
#replacing with "type/integer" functions of the same name. Then, these are
#accessed via, say, $(KB) rather than ${KB}.

# For convenience, this function also accepts "stdin"-style piped input: e.g.,
#     echo 1776 | comma_separate_string #     1,776
