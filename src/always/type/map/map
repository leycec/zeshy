#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle map (i.e., associative array) variables and values.

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map(string variable_name, string error_message = 'not a map')
#
# Die unless the variable with the passed name is a map.
die_unless_map() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_map "${1}" or die "${2:-\"${1}\" not a declared map}"
}

# void die_unless_map_nonempty(
#   string variable_name, string error_message = 'not a map')
#
# Die unless the variable with the passed name is a non-empty map.
die_unless_map_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_map_nonempty "${1}" or die "${2:-\"${1}\" not a non-empty map}"
}

# ....................{ TESTS                              }....................
# boolean is_map(string variable_name)
#
# Return true if the variable with the passed name is a map (i.e.,
# associative array).
is_map() {
    die_unless_one_arg 'expected one variable name'

    # Match both global maps of type "association" and local maps of type
    # "association-local" via a glob expression.
    is $(get_type "${1}") == association* si
}

# boolean is_map_key(string map_name, string key)
#
# Return true if the map with the passed name contains the passed key.
is_map_key() {
    # Localize and validate arguments.
    die_unless_two_args 'expected one variable name and one key'
    string map_name="${1}" key="${2}"
    die_unless_map "${map_name}"

    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force Zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
    is_nonempty "${${(k@P)map_name}[(I)"$key"]}"
}

# ....................{ GETTERS                            }....................
# integer get_map_size(string map_name)
#
# Get the number of elements in the map with the passed name.
get_map_size() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one map name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Get map size.
    sputter ${#${(@P)map_name}}
}

# ....................{ CONVERTERS                         }....................
# string convert_map_to_restorable_string(string map_name)
#
# Get a string corresponding to the contents of the map with the passed name.
# See convert_list_to_restorable_string() for further details.
convert_map_to_restorable_string() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one map name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    sputter "${(qqkv@P)map_name}"
}

# --------------------( WASTELANDS                         )--------------------
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
