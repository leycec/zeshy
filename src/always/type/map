#!/usr/bin/env zsh
# ====================[ map                                ]====================
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Map, handling maps (i.e., associative arrays).

# ....................{ EXCEPTIONS                         }....................
# void die_unless_map(string variable_name, string error_message = 'not a map')
#
# Die unless the variable with the passed name is a map.
die_unless_map() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_map "${1}" or die "${2:-\"${1}\" not a declared map}"
}

# void die_unless_map_nonempty(
#   string variable_name, string error_message = 'not a map')
#
# Die unless the variable with the passed name is a non-empty map.
die_unless_map_nonempty() {
    die_unless_one_or_two_args\
        'expected one variable name and optional error message'
    is_map_nonempty "${1}" or die "${2:-\"${1}\" not a non-empty map}"
}

# ....................{ TESTS                              }....................
# bool is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
is_map_or_list() {
    die_unless_one_arg 'expected one variable name'
    
    is $(get_type "${1}") == (list|array|association)* si
}

# bool is_map(string variable_name)
#
# Return true if the variable with the passed name is a map (i.e.,
# associative array).
is_map() {
    die_unless_one_arg 'expected one variable name'
    
    # Global maps have type "association" and local maps "association-local".
    # Match both.
    is $(get_type "${1}") == association* si
}

# ....................{ TESTS ~ searches                   }....................
# bool is_map_key(string map_name, string key)
#
# Return true if the map with the passed name contains the passed key.
is_map_key() {
    # Localize and validate arguments.
    die_unless_two_args 'expected one variable name and one key'
    string map_name="${1}" key="${2}"
    die_unless_map "${map_name}"
    
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force Zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
    is_nonempty "${${(k@P)map_name}[(I)"$key"]}"
}

# ....................{ GETTERS                            }....................
# int get_map_size(string variable_name)
#
# Get the number of elements in the map with the passed name.
get_map_size() {
    die_unless_one_arg 'expected one variable name'
    die_unless_map "${1}"
    print "${#${(@P)1}}"
}

# ....................{ PASS-BY-VALUE                      }....................
# string return_map(string variable_name)
#
# Convert the map with the passed name to a string. Call restore_map() to
# perfectly expand this string back to the original map. See return_list() for
# related examples.
return_map() {
    die_unless_one_arg 'expected one variable name'
    string map_name="${1}"
    die_unless_map "${map_name}"

    # Dismantled, this is as in return_list(), except:
    #
    # * 'kv', a string concatenating all map keys and values delimited by
    #   whitespace.
    print "${(qqkv@P)map_name}"
}

#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map(void)
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
alias restore_map='{
    is -p /dev/stdin si or die "\"/dev/stdin\" not a pipe";
    map map; map=( ${(z)"$(< /dev/stdin)"} )
}'

# --------------------( COPYRIGHT AND LICENSE              )--------------------
# The information below applies to everything in this distribution,
# except where noted.
#              
# Copyright 2007-2012 by Cecil Curry.
#   
#   http://www.raiazome.com
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
