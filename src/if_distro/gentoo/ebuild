#!/usr/bin/env zsh
# ====================[ ebuild                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle Gentoo ebuilds.

# ....................{ PRINTERS                           }....................
declare_function '
string print_ebuild(string ebuild_name)

Print a human-readable synopsis of the passed ebuild.
'
function print_ebuild() {
    #FIXME: Should call a newly defined die_unless_ebuild() to verify such
    #ebuild actually exists. Shouldn't be terribly difficult, but I wonder what
    #the most efficient way to do so is? Naturally, call such function
    #everywhere an ebuild name is passed below.

    # Validate passed arguments.
    die_unless_arg 'expected one ebuild name'
    string ebuild_name="${1}"

    # Print such ebuild.
    {
        print_heading 'USE flags'
        print_ebuild_use_flags "${ebuild_name}"

        print_heading 'direct dependencies'
        print_ebuild_dependencies "${ebuild_name}"
    } | page_stdin
}

declare_function '
string print_ebuild_dependencies(string ebuild_name)

List all ebuilds on which the passed ebuild directly depends.
'
function print_ebuild_dependencies() {
    # Validate passed arguments.
    die_unless_arg 'expected one ebuild name'
    string ebuild_name="${1}"

    #FIXME: Any other utilities capable of displaying such data? Google us up.
    # Prefer "equery" for querying ebuilds. Sadly, "equery" offers insufficient
    # options for running under run_command_paged(). Attempting to do so, even after
    # passing "--no-pipe", causes "equery" to squelch all colors. Hence, run
    # "equery" as is and require the user to manually page if needed.
    if is_pathable equery
    then equery depgraph "${ebuild_name}"
    else die '"equery" not installed'
    fi
}

declare_function '
string print_ebuild_use_flags(string ebuild_name)

List all USE flags used by the passed ebuild.
'
function print_ebuild_use_flags() {
    # Validate passed arguments.
    die_unless_arg 'expected one ebuild name'
    string ebuild_name="${1}"

    #FIXME: Any other utilities capable of displaying such data? Google us up.
    #Ah, yes. We could, of course, simply grep
    #"/usr/portage/profiles/use.local.desc" for the program name. That gets us
    #USE flag descriptions only for main tree ebuilds, however. But... *shrug*
    if is_pathable equery
    then equery uses "${ebuild_name}"
    else die '"equery" not installed'
    fi
}

# ....................{ PRINTERS ~ path                    }....................
declare_function '
string print_ebuilds_installing_path(string pathname)

Print all ebuilds installing into the passed path. If this path is a file,
print only the one ebuild installing such file; otherwise, print all ebuilds
installing at least one file to such directory.
'
function print_ebuilds_installing_path() {
    # Validate passed arguments.
    die_unless_arg 'expected one pathname'
    string pathname="${1}"

    # If no such path exists, attempt to find a command with such name.
    is_path "${pathname}" or
        pathname="$(get_pathable_path "${pathname}")"

    # Prefer "equery" to "qfile" for finding ebuilds. Since the former waits to
    # print a helpful message until after finding and since finding is slow,
    # print a helpful message prior to finding.
    print_message "searching ebuild database for \"${pathname}\"..."
    if is_pathable equery
    then equery belongs "${pathname}"
    elif is_pathable qfile
    then qfile "${pathname}"
    else die 'neither "equery" or "qfile" installed'
    fi
}

# ....................{ PRINTERS ~ regex                   }....................
declare_function '
string print_ebuild_match_pcre(string regex)

Print all ebuilds with names and/or descriptions matching the passed PCRE.
'
function print_ebuild_match_pcre() {
    # Validate passed arguments.
    die_unless_arg 'expected one regex'
    string regex="${1}"

    # Prefer "eix" to "emerge". In fact, if "eix" is not installed, print_warning a
    # warning strongly suggesting doing so.
    if is_pathable eix
    then print_eix_ebuild_match_pcre "${regex}"
    else
        print_warning '"eix" not installed; defaulting to slower "emerge"-driven searching'

        # Force interpretation of the passed regex as a regular expression by
        # prefixing such regex with "%". Avoid passing option "--searchdesc",
        # as regular expressions tend to play poorly with ebuild descriptions.
        run_command_paged emerge --search -- "%${regex}"
    fi
}

# ....................{ MAKERS                             }....................
declare_function '
void make_ebuild_manifest(string ebuild_filename = '')

Updates or creates if not currently found the "Manifest" file for the passed
ebuild (defaulting to the newest ebuild in the current directory). See the
"man ebuild" for details. This function resolves errors resembling:

    !!! Fetched file: howl-6.3.1926.tar.bz2 VERIFY FAILED!
    !!! Reason: Insufficient data for checksum verification
'
function make_ebuild_manifest() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional filename'
    string ebuild_filename; ebuild_filename="${1:-$(get_current_dir)}"

    # If the passed argument is a directory, default to the last ebuild in such
    # directory. The "ebuild" command behaves the same regardless of which
    # ebuild we pass it, so this selection is entirely arbitrary.
    if is_dir "${ebuild_filename}"; then
        # List all ebuild files in the passed directory.
        string ebuild_dirname="${ebuild_filename}"
        list ebuild_filenames
        ebuild_filenames=( "${ebuild_dirname}/"*.ebuild )

        # Arbitrarily select the last in lexicographic order.
        die_unless_list_nonempty ebuild_filenames\
            "\"${ebuild_dirname}\" contains no ebuilds"
        ebuild_filename="${ebuild_filenames[-1]}"
    fi

    # Make manifest.
    die_unless_file  "${ebuild_filename}"
    ebuild "${ebuild_filename}" manifest
}

# ....................{ WASTELANDS                         }....................
#   if not is_path "${pathname}"; then
#       noop
#       pathname="$(get_pathable_path "${pathname}")"
#   fi

    #FUXME: Well, we tripped across our first zsh error. It was bound to happen.
    #I'm inclined to let it lie for a bit. (Laziness.) If this ever bites us
    #again (...and it will), post a bug report. Here's how it triggers: the
    #*FIRST* statement in an "if" block has no ZERR testing done for it. This is
    #easy to verify. All subsequent statements and statements *NOT* in "if"
    #blocks do have ZERR testing done. I assume zsh internally optimizes single-
    #statement "if" blocks to "||" commands, in which case ZERR would indeed not
    #apply. Well, it's merely a supposition. Correcting this is as simple as
    #prefixing the previously first statement with noop().
    #if not is_path "${pathname}"; then
    #    noop
    #    pathname="$(get_pathable_path "${pathname}")"
    #fi


#   print_message "making manifest \"${ebuild_filename}\" manifest..."
    # Since the ebuild name and version are split by hyphen and such
    # versions never contain hyphens, splitting on the last hyphen suffices to
    # split ebuild names from versions. Luckily, the "sort" command implements
    # such sorting for us via option "-V".
        # If the "sort" command supports option "-V", run "sort".
#       if run_command_silent 'print 1 | sort -V -'
#       then ebuild_filename="$(join_list_to_lines ebuild_filenames | sort -V -)"
        # Otherwise, default to lexicographic order.
#       else ebuild_filename="${ebuild_filenames[-1]}"
#       fi
