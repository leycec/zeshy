#!/usr/bin/env zsh
# ====================[ ebuild                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy ebuild, handling Gentoo ebuild management.

# ....................{ ALIASES                            }....................
interactive_alias eq='print_ebuilds_matching'
interactive_alias eqi='print_ebuilds_installing_path'
interactive_alias eque='print_ebuild_use_flags'

# ....................{ PRINTERS                           }....................
# string print_ebuilds_matching(string regex)
#
# Print all ebuilds with names and/or descriptions matching the passed regular
# expression.
print_ebuilds_matching() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one regex'
    string regex="${1}"

    # Prefer "eix" to "emerge". In fact, if "eix" is not installed, curse a
    # warning strongly suggesting doing so.
    if is_installed eix
    then print_eix_ebuilds_matching "${regex}"
    else
        curse '"eix" not installed; defaulting to slower "emerge"-driven searching'

        # Force interpretation of the passed regex as a regular expression by
        # prefixing such regex with "%". Avoid passing option "--searchdesc",
        # as regular expressions tend to play poorly with ebuild descriptions.
        run_paged emerge --search -- "%${regex}"
    fi
}

# string print_ebuilds_installing_path(string pathname)
#
# Print all ebuilds installing into the passed path. If this path is a file,
# print only the one ebuild installing such file; otherwise, print all ebuilds
# installing at least one file to such directory.
print_ebuilds_installing_path() {
    # Validate passed arguments.
    die_unless_one_arg 'expected one pathname'
    string pathname="${1}"

    #FIXME: Well, we tripped across our first Zsh error. It was bound to happen.
    #I'm inclined to let it lie for a bit. (Laziness.) If this ever bites us
    #again (...and it will), post a bug report. Here's how it triggers: the
    #*FIRST* statement in an "if" block has no ZERR testing done for it. This is
    #easy to verify. All subsequent statements and statements *NOT* in "if"
    #blocks do have ZERR testing done. I assume Zsh internally optimizes single-
    #statement "if" blocks to "||" commands, in which case ZERR would indeed not
    #apply. Well, it's merely a supposition. Correcting this is as simple as
    #prefixing the previously first statement with noop().
    # If no such path exists, attempt to find a command with such name.
    if not is_found "${pathname}"; then
        noop
        pathname="$(get_command_path "${pathname}")"
    fi

    # Prefer "equery" to "qfile" for finding ebuilds. Since the former waits to
    # print a helpful message until after finding and since finding is slow,
    # print a helpful message prior to finding.
    interactively utter "searching ebuild database for \"${pathname}\"..."
    if is_installed equery
    then equery belongs "${pathname}"
    elif is_installed qfile
    then qfile "${pathname}"
    else die 'neither "equery" or "qfile" installed'
    fi
}

# string print_ebuild_dependencies(string ebuild_name)
#
# Print all ebuilds on which the passed ebuild directly depends.
print_ebuild_dependencies() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one ebuild name'
    string ebuild_name="${1}"

    #FIXME: Any other utilities capable of displaying such data? Google us up.
    # Prefer "equery" for querying ebuilds. Sadly, "equery" offers insufficient
    # options for running under run_paged(). Attempting to do so, even after
    # passing "--no-pipe", causes "equery" to squelch all colors. Hence, run
    # "equery" as is and require the user to manually page if needed.
    if is_installed equery
    then equery depgraph "${ebuild_name}"
    else die '"equery" not installed'
    fi
}

# string print_ebuild_use_flags(string ebuild_name)
#
# Print all USE flags used by the passed ebuild.
print_ebuild_use_flags() {
    # Localize passed arguments.
    die_unless_one_arg 'expected one ebuild name'
    string ebuild_name="${1}"

    #FIXME: Any other utilities capable of displaying such data? Google us up.
    #Ah, yes. We could, of course, simply grep
    #"/usr/portage/profiles/use.local.desc" for the program name. That gets us
    #USE flag descriptions only for main tree ebuilds, however. But... *shrug*
    if is_installed equery
    then equery uses "${ebuild_name}"
    else die '"equery" not installed'
    fi
}

# ....................{ WRITERS                            }....................
# void make_ebuild_manifest(string ebuild_filename = '')
#
# Updates or creates if not currently found the "Manifest" file for the passed
# ebuild (defaulting to the newest ebuild in the current directory). See the
# "man ebuild" for details. This function resolves errors resembling:
#
#     !!! Fetched file: howl-6.3.1926.tar.bz2 VERIFY FAILED!
#     !!! Reason: Insufficient data for checksum verification
make_ebuild_manifest() {
    # Validate passed arguments.
    die_unless_no_or_one_arg 'expected optional filename'
    string ebuild_filename="${1:-$(get_current_dir)}"

    # If the passed argument is a directory, default to the last ebuild in such
    # directory. The "ebuild" command behaves the same regardless of which
    # ebuild we pass it, so this selection is entirely arbitrary.
    if is_dir "${ebuild_filename}"; then
        # List all ebuild files in the passed directory.
        string ebuild_dirname="${ebuild_filename}"
        list ebuild_filenames
        ebuild_filenames=( "${ebuild_dirname}/"*.ebuild )

        # Arbitrarily select the last in lexicographic order.
        die_if_list_empty ebuild_filenames\
            "\"${ebuild_dirname}\" contains no ebuilds"
        ebuild_filename="${ebuild_filenames[-1]}"
    fi

    # Make manifest.
    die_unless_file  "${ebuild_filename}"
    ebuild "${ebuild_filename}" manifest
}

# ....................{ WASTELANDS                         }....................
#   utter "making manifest \"${ebuild_filename}\" manifest..."
    # Since the ebuild name and version are split by hyphen and such
    # versions never contain hyphens, splitting on the last hyphen suffices to
    # split ebuild names from versions. Luckily, the "sort" command implements
    # such sorting for us via option "-V".
        # If the "sort" command supports option "-V", run "sort".
#       if run_quietly 'print 1 | sort -V -'
#       then ebuild_filename="$(join_list_to_lines ebuild_filenames | sort -V -)"
        # Otherwise, default to lexicographic order.
#       else ebuild_filename="${ebuild_filenames[-1]}"
#       fi
