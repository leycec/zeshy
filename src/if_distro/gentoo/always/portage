#!/usr/bin/env zsh
# ====================[ portage                            ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Handle Portage, the Gentoo package repository.

# ....................{ ALIASES                            }....................
interactive_abbreviation {em}erge='emerge'
interactive_abbreviation {em}erge{n}ews='eselect news read new'
interactive_abbreviation {em}erge{w}orld='emerge_world'
interactive_abbreviation {em}erge{p}ortage='update_portage'
interactive_abbreviation {e}merge{q}uery{u}se='print_use_flag_matches'
interactive_abbreviation {em}erge{u}ninstall='emerge --depclean'

# ....................{ TESTERS                            }....................
document_function '
boolean is_portage_outdated(void)

Return true if the Portage tree is outdated and hence requires an update. This
function treats Portage trees older than half a day to be outdated, which may
not necessarily coincide with caller expectations of "outdated."
'
function is_portage_outdated() {
    die_if_args
    (( $(get_path_modification_time "$(get_portage_home)") <\
       $(get_time_unix_offset_by_hours -12) ))
}

# ....................{ GETTERS                            }....................
document_function '
string get_portage_home(void)

Get the absolute path of the top-level Portage directory (e.g.,
"/usr/portage").
'
function get_portage_home() {
    die_if_args
    portageq portdir
}

#FIXME: Rename to get_portage_dir_archives_binary().
document_function '
string get_portage_binary_packages_dir(void)

Get the absolute path of the Portage directory storing binary packages (e.g.,
"/usr/portage/packages").
'
function get_portage_binary_packages_dir() {
    die_if_args
    portageq pkgdir
}

#FIXME: Rename to get_portage_dir_archives_source().
document_function '
string get_portage_source_archives_dir(void)

Get the absolute path of the Portage directory storing source archives (e.g.,
"/usr/portage/distfiles").
'
function get_portage_source_archives_dir() {
    die_if_args
    portageq distdir
}

# ....................{ PRINTERS                           }....................
document_function '
void print_use_flag(string use_flag_name)

Print all descriptions for the passed USE flag.
'
function print_use_flag() {
    # Validate passed arguments.
    die_unless_arg 'expected one USE flag'
    string use_flag="${1}"

    # Prefer "euse" to manually grepping files.
    if is_pathable euse
    then euse --info "${use_flag}"
    else grep_path_caselessly "${use_flag} - "\
        "$(get_portage_home)/profiles/use."{,local.}desc
    fi
}

document_function '
void print_use_flag_matches(string grep_pattern)

Print all descriptions for USE flags matching the passed "grep" pattern.
'
function print_use_flag_matches() {
    die_unless_arg 'expected one grep pattern'
    grep_path_caselessly "$(get_portage_home)/profiles/use."{,local.}desc\
        "${1}"
}

# ....................{ CHECKERS                           }....................
document_function '
void check_portage(string repository_dir = "$(get_current_dir)")

Check the passed Portage repository (defaulting to the repository containing
the current directory), for quality assurance.
'
function check_portage() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'expected optional dirname'

    if is_args_0
    then repoman
    else
        #FIXME: If this becomes a common idiom, it'd be nice to add a new
        #run_under_dir() function: e.g., "run_under_dir "${1}" repoman".
        #FIXME: We've added such function; use here!
        store_current_dir "${1}"
        {
            repoman
        } always {
            restore_current_dir
        }
    fi
}

# ....................{ EMERGERS                           }....................
document_function '
void emerge_world(void)

Update:

* The main Portage tree and all added overlays with new ebuilds, if such tree
  is sufficiently outdated. See is_portage_outdated().
* All currently installed packages in the package set "world" (i.e., set of
  all packages explicitly installed by a human at the command line).
* All transitive dependencies of currently installed packages (i.e., set of
  all packages on which currently installed packages directly or indirectly
  depend).
'
function emerge_world() {
    # Validate sanity.
    die_if_args

    # Update the Portage tree, if needed.
    is_portage_outdated and update_portage

    # Update packages with updated ebuilds, ignoring non-zero exit status.
    # Ideally, of course, non-zero exit status should never be ignored; in this
    # case and below, however, "emerge" fails if at least one package fails to
    # install. Since this occurs surprisingly often, continue onward!
    interactively say_first_section 'updating world'
    emerge --update --deep --newuse world or true

    # Update packages with reverse dependencies broken by the prior update
    # (i.e., packages dynamically linked to versioned shared libraries updated
    # and hence since removed by prior updates), ignoring non-zero exit status.
    interactively say_next_section 'updating broken reverse dependencies'
    revdep-rebuild or true

    # Update shell variables.
    interactively say_next_section 'updating shell environment'
    env-update
    source /etc/profile

    # Update configuration files.
    interactively say_next_section 'updating configuration files'
    dispatch-conf
}

document_function '
void update_portage(void)

Update the main Portage tree and all added overlays with new ebuilds. Unlike
update_gentoo, this only updates rather than installing such ebuilds.
'
function update_portage() {
    # Validate passed arguments.
    die_if_args

    # Prefer "eix-sync" to "emerge". If installed, the former subsumes the
    # latter and updates the more efficient (and hence preferable) "eix" cache.
    if is_pathable eix
    then update_portage_with_eix
    # Otherwise, update only the main Portage tree and possibly added overlays.
    else
        #FIXME: What's the point in prefixing say commands with "interactively"?
        interactively say_first_section 'updating portage'
        emerge --sync

        is_gentoo_overlay_command_installed and {
            interactively say_next_section 'updating overlays'
            update_gentoo_overlays
        }
    fi

    #FIXME: This appears to take an effectively infinite amount of time with no
    #appreciable output. I can't be bothered to debug it, at the moment. So...
    # Update the metadata cache with the contents of updated overlays.
#   interactively say_next_section 'updating portage metadata...'
#   egencache --update
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename print_use_flag_match().
    #FUXME: It'd be nice to check the mtime of "$(get_portage_home)" and if
    #older than, say, 6 hours (seems reasonable, a quarter of a day), then
    #implicitly force a Portage update. That's pretty much what one always wants
    #to happen, anyway, so... **YES** ~ make this happen, please!
#   interactively say\
#       'consider first synchronizing Portage with "update_portage"'
# boolean is_portage_outdated(void)
#
# Return true if the Portage tree is outdated and hence requires an update. This
# function treats Portage trees older than six hours to be outdated, which may
# not necessarily coincide with caller expectations of "outdated."
#unction is_portage_outdated() {
#   die_if_args
#   (( $(get_path_modification_time "$(get_portage_home)") <\
#      $(get_time_unix_offset_by_hours -6) ))
#
#   interactively say_first_section 'updating portage...'
    # Update ebuilds.
#   update_portage
