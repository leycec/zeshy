#!/usr/bin/env zsh
# ====================[ source                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Zeshy Source, handling Zsh module loading and Zeshy function autoloading.
#
# --------------------( SEE ALSO                           )--------------------
# https://jgao.googlecode.com/svn/trunk/.shell/zsh_module
#   Comprehensive module autoload definitions inspiring those below.

#FIXME: This could be a nice opportunity to truncate "main" a bit. I'd
#specifically like to see get_script_name() shifted into "shell/shell" and
#utter() and curse() shifted into "shell/output".

# ....................{ TESTS                              }....................
# bool is_zeshy_digest_outdated(void)
#
# Return true if Zeshy's digest is outdated and hence requires recompilation, as
# when such file does not exist or does but is older than the newest of:
#
# * The main user-specific Zeshy configuration file. This file contains theme
#   settings, which when edited require recompiling theme autoloads.
# * The main system-wide command directories (e.g., "/bin", "/usr/bin").
#   Installing or uninstalling commands requires recompiling command autoloads.
function is_zeshy_digest_outdated() {
    die_if_args

    # If Zeshy's digest does *NOT* exist, the digest is clearly "outdated."
    is -f "${ZESHY_USER_DIGEST_FILE}" si or return_true

    # List of modification times with which to decide whether to recompile.
    list digest_dependent_mtimes
    is -d '/bin'     si and digest_dependent_mtimes+=$(zstat +mtime '/bin')
    is -d '/usr/bin' si and digest_dependent_mtimes+=$(zstat +mtime '/usr/bin')
    is -f "${ZESHY_USER_CONFIG_FILE}" si and
        digest_dependent_mtimes+=$(zstat +mtime "${ZESHY_USER_CONFIG_FILE}")

    # If the current user is a Zeshy developer, obtain the last modification
    # time of the Zeshy codebase by sorting the set of all last modification
    # times of all files and directories in this codebase and selecting the
    # largest such time. This is at best an O(n*lg(n)) operation, and hence
    # confined to developers. Dismantled, this is:
    #
    # * "${...}"/**/*, all files and directories of this codebase.
    # * "om", sorting such files and directories by descending mtime.
    # * "[1]", the first and hence newest such file or directory.
    is -n ${ZESHY_IS_DEBUG} si and
        digest_dependent_mtimes+=$(zstat +mtime "${ZESHY_OVERLAY_ROOT}"/**/*(om[1]))

    # Set the newest modification time in such list. Technically, this is also
    # O(n*lg(n)). But the list is guaranteed to be small, so this approximates
    # O(1)... Dismantled, this is:
    #
    # * "(nO@)", numerically sorting such list in descending order.
    # * "[1]", the first and hence newest such time.
    integer zeshy_digest_mtime
    ZESHY_NEWEST_DIGEST_DEPENDENT_MTIME="${${(nO@)digest_dependent_mtimes}[1]}"
    zeshy_digest_mtime=$(zstat +mtime "${ZESHY_USER_DIGEST_FILE}")

    # Unless Zeshy's digest is as old as its newest dependency, it's outdated.
#   utter "mtimes: ${digest_dependent_mtimes[@]}"
#   utter "newest: ${ZESHY_NEWEST_DIGEST_DEPENDENT_MTIME}"
#   utter "digest: ${zeshy_digest_mtime}"
    (( ZESHY_NEWEST_DIGEST_DEPENDENT_MTIME != zeshy_digest_mtime ))
}

# ....................{ MAIN                               }....................
() {
    # ~~~~~~~~~~~~~~~~< ZSH                                >~~~~~~~~~~~~~~~~~~~~
    # Define autoloads for all autoloadable functions in ${fpath}, obsoleting
    # manual autoloading of such functions (e.g., "zsh-mime-setup" versus
    # "autoload -U zsh-mime-setup; zsh-mime-setup"). Dismantled, this is:
    #
    # * "fpath", the list of all directories with autoloadable files.
    # * "^", iteratively expanding to each such directory.
    # * "/*", each immediate file and subdirectory of such directory.
    # * "N", ignoring non-extant files and subdirectories.
    # * ".", including only plain files (e.g., excluding directories).
    # * ":t", the tail (i.e., basename) of such file.
    #
    # This matches all basenames of immediate files of directories in the function
    # path. (Since this is also the set of all autoloadable function names,
    # autoloading such basenames autoloads all autoloadable functions.) Oh!
#   for autoloadable_function_name in ${^fpath}/*(N.:t); do
    for function_name in ${^fpath}/*(.:t); do
        #   print "autoloading \"${autoload_function_name}\"..."
        # For safety, autoload this function under option "-U" to suppress alias
        # expansion. This prevents expansion of Zeshy- and user-specific aliases
        # under core Zsh functions implemented with no such aliases in mind.
        autoload -U "${function_name}"
    done

    # Define autoloads for all autoloadable functions defined by Zsh modules not
    # autoloaded above. Unlike above, this requires manually mapping such
    # functions to such modules -- an unctuous proposition. Avoid mapping:
    #
    # * Modules previously explicitly loaded by ZeshyInit Main.
    # * "mapfile", due to the risk it poses of permanent, silent file deletion.
    #
    # Dismantled, this is:
    #
    # * "-a", autoloading the following builtins ("b"), functions ("f"), or
    #   parameters ("p") from the immediately following module.
    # * "i", ignoring rather than failing when such builtins, functions, or
    #   parameters have already been loaded within such module.
    zmodload -abi zsh/cap cap getcap setcap
    zmodload -abi zsh/clone clone
    zmodload -abi zsh/compctl compctl compcall
    zmodload -abi zsh/computil comparguments compdescribe compfiles compgroups\
        compquote comptags comptry compvalues
    zmodload -abi zsh/datetime strftime
    zmodload -afi zsh/deltochar delete-to-char zap-to-char
    zmodload -afi zsh/mathfunc abs int float acos acosh asin asinh atan atanh\
        cbrt ceil cos cosh erf erfc exp expm1 fabs floor gamma j0 j1 lgamma log\
        log10 log1p logb sin sinh sqrt tan tanh y0 y1 ilogb signgam copysign\
        fmod hypot nextafter jn yn ldexp scalb rand48
    zmodload -abi zsh/pcre pcre_compile pcre_study pcre_match
    zmodload -abi zsh/sched sched
    zmodload -abi zsh/net/socket zsocket
    zmodload -abi zsh/net/tcp ztcp
    zmodload -abi zsh/system syserror sysread syswrite
    zmodload -api zsh/system errnos
    zmodload -abi zsh/termcap echotc
    zmodload -api zsh/termcap termcap
    zmodload -abi zsh/zftp zftp
    zmodload -api zsh/zleparameter keymaps widgets
    zmodload -abi zsh/zprof zprof
    zmodload -abi zsh/zpty zpty
    zmodload -abi zsh/zselect zselect

    # ~~~~~~~~~~~~~~~~< ZESHY                              >~~~~~~~~~~~~~~~~~~~~
    # Make Zeshy dot directories for the current user, if not found.
    mkdir -p "${ZESHY_USER_CONFIG_DIR}" "${ZESHY_USER_PID_DIR}"

    # The modification time of the newest path on which Zeshy's digest depends.
    # is_zeshy_digest_outdated() subsequently sets this if returning true. Yes:
    # this is somewhat hackier than we prefer, but the alternatives are uglier.
    integer ZESHY_NEWEST_DIGEST_DEPENDENT_MTIME

    # If Zeshy's digest is outdated, recompile it.
#   utter "detecting \"${ZESHY_USER_DIGEST_FILE}\"..."
    if is_zeshy_digest_outdated; then
        source_zeshy_component compile

        # Set the modification time of Zeshy's digest to that of the newest
        # modification time to prevent recompiling on the next Zeshy invocation.
        touch -m --date=@${ZESHY_NEWEST_DIGEST_DEPENDENT_MTIME}\
            "${ZESHY_USER_DIGEST_FILE}"
    # Otherwise, source all user configuration files. Since the above condition
    # implicitly sources such files already, do so when not recompiling here.
    else source "${ZESHY_USER_CONFIG_DIR}/"*
    fi

    # Declare all functions compiled into the digest file to be autoloadable.
    autoload -w "${ZESHY_USER_DIGEST_FILE}" or
        die "\"${ZESHY_USER_DIGEST_FILE}\" cannot be compiled"

    # Prefix the function path with the absolute path to the digest file to
    # ensure Zsh searches such file for the definition of such functions first.
    # Oddly, Zsh has no means of directly associating the two.
    fpath=( "${ZESHY_USER_DIGEST_FILE}" "${fpath[@]}" )
}

# --------------------( WASTELANDS                         )--------------------
#        is -f "${ZESHY_USER_DIGEST_FILE}" si and
#        (( newest_mtime == $(zstat +mtime "${ZESHY_USER_DIGEST_FILE}") )); then
#to synchronize function definitions
    # with current system and user state
        # Find the maximum of this and the prior modification time.
#       (( zeshy_dev_mtime > zeshy_mtime )) and zeshy_mtime="${zeshy_dev_mtime}"

    #FIXME: Hmmmm; O.K.; I have a dramatic improvement here, but I'm simply too
    #lazy to implement it. Not hard; just lazy. Under the current approach, we
    #technically should also be considering the mtimes of "/etc/zsh/zshrc" and
    #"~/.zshrc", as both files may define a $PATH different from the last time
    #Zeshy was invoked. But, if you think about it, this run_quickly regresses into
    #insanity, because *ANY* profile script (e.g., "/etc/profile.env") could
    #conceivably set or augment $PATH (and probably does). So, we instead need
    #to simply test the following two things:
    #
    #* If no cache file exists or such a file exists but with insufficient or
    #  erroneous content, forego the tests below and *JUST* recompile.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $ZESHY_THEME.
    #* The current (if undefined, default to empty string) against the cached
    #  value of $PATH. This requires a cache file containing sourceable values,
    #  which we declare to be local prior to sourcing: say,
    #
    #       last_ZESHY_THEME="..."
    #       last_PATH="..."
    #
    #Simple. The catch is: when do we create this file? I'm beginning to
    #suspect that our definition of $PATH for interactive shells in
    #"always/shell/profile" may obstruct things a bit, here. Oh; no. That
    #doesn't work. It must be late. Clearly, that fails to account for... well,
    #pretty much everything. Back to le drawing board.

    # If the digest file does not exist or does but is older than Zeshy's last
    # modification time, recompile this file to synchronize compiled function
    # definitions with newer Zeshy changes.
#   integer\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_USER_CONFIG_DIR}")\
#         zeshy_mtime=$(zstat +mtime "${ZESHY_USER_CONFIG_FILE}")\
#           bin_mtime=$(zstat +mtime '/bin')\
#       usr_bin_mtime=$(zstat +mtime '/usr/bin')
#   ((     bin_mtime > zeshy_mtime )) and zeshy_mtime="${bin_mtime}"
#   (( usr_bin_mtime > zeshy_mtime )) and zeshy_mtime="${usr_bin_mtime}"
