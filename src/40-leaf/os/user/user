#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle local users and groups.
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void die_unless_user(
   string username,
   string error_message = "User \"${username}\" not found.")

Throw an exception with the passed message unless the passed user exists.
/---
function die_unless_user() {
    die_unless_args_1_to_2\
        'Expected one username and optional error message.'
    is_user "${1}" or {
        :string username="${1}"
        :die "${2-User \"${username}\" not found.}"
    }
}

declare_function_with_stdin <<'/---'
void die_unless_group(
   string group_name,
   string error_message = "Group \"${group_name}\" not found.")

Throw an exception with the passed message unless the passed group exists.
/---
function die_unless_group() {
    die_unless_args_1_to_2\
        'Expected one group name and optional error message.'
    is_group "${1}" or {
        :string group_name="${1}"
        :die "${2-Group \"${group_name}\" not found.}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] is_user(string username)

Report success if the passed user exists.
/---
function is_user() {
    die_unless_arg 'Expected one username.'
    is_string_line_match "$(get_users_file_text)" "${1}:"*
}

declare_function_with_stdin <<'/---'
[status: bool] is_group(string group_name)

Report success if the passed group exists.
/---
function is_group() {
    die_unless_arg 'Expected one group name.'
    is_string_line_match "$(get_groups_file_text)" "${1}:"*
}

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_users_file()

Get the absolute path of the system-wide users file (e.g., `/etc/passwd`).
/---
function get_users_file() {
    die_if_args
    :string.output '/etc/passwd'
}

declare_function_with_stdin <<'/---'
string get_groups_file()

Get the absolute path of the system-wide groups file (e.g., `/etc/group`).
/---
function get_groups_file() {
    die_if_args
    :string.output '/etc/group'
}

# ....................{ GETTERS ~ content                  }....................
declare_function_with_stdin <<'/---'
string get_users_file_text()

Get the contents of the system-wide users file (e.g., `/etc/passwd`).
/---
function get_users_file_text() {
    die_if_args
    get_file_text "$(get_users_file)"
}

declare_function_with_stdin <<'/---'
string get_groups_file_text()

Get the contents of the system-wide groups file (e.g., `/etc/group`).
/---
function get_groups_file_text() {
    die_if_args
    get_file_text "$(get_group_file)"
}

# ....................{ GETTERS ~ path                     }....................
declare_function_with_stdin <<'/---'
string get_user_home(string username)

Get the absolute path of the home directory of the passed user.
/---
function get_user_home() {
    # Validate sanity.
    die_unless_arg 'Expected one username.'
    string username="${1}"
    die_unless_user "${username}"

    # Get such directory. Happily, zsh supplies a builtin map for such purpose.
    :string.output "${userdirs[${username}]}"
}

# ....................{ [UN]MAKERS                         }....................
#FIXME: Supporting ${ZESHY_OPTIONS_USERADD} strikes us as an increasingly poor
#idea, given that "useradd" already has a builtin mechanism for supplying option
#defaults. Excise such functionality and the corresponding functionality for
#:remove_user() below. (This includes the corresponding config files, as well!)

# If:
#
# * "adduser" is pathable, prefer such command. On Debian-based Linux distros,
#   such command is a user-friendly frontend to "useradd" setting sane defaults.
# * "useradd" is pathable, fallback to such command.
:declare_func_if_pathable_or_noop\
    ':void :make_user(:string username1, ...)' ''\
    adduser 'command adduser -- "${@}"'\
    useradd '
        run_code_with_options_configured "command useradd"\
            ZESHY_OPTIONS_USERADD -- "${@}"' <<'/---'
Create all passed local users (i.e., add such users to the local system).
/---

# If:
#
# * "deluser" is pathable, prefer such command. On Debian-based Linux distros,
#   such command is a user-friendly frontend to "userdel" with sane defaults.
# * "userdel" is pathable, fallback to such command.
:declare_func_if_pathable_or_noop\
    ':void :remove_user(:string username1, ...)' ''\
    deluser 'command deluser -- "${@}"'\
    userdel 'run_code_with_options_configured "command userdel"\
        ZESHY_OPTIONS_USERDEL -- "${@}"' <<'/---'
Remove all passed local users (i.e., delete such users from the local system).
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Arguably, user functions specific to the current user should be shifted
#to a new @{os/user/current}

# if { is_pathable deluser } {
#     function :remove_user() {
#         die_unless_args 'Expected one or more usernames.'
#         command deluser -- "${@}"
#     }
# } else {
#     function :remove_user() {
#         die_unless_args 'Expected one or more usernames.'
#         run_code_with_options_configured 'command userdel'\
#             'ZESHY_OPTIONS_USERDEL' -- "${@}"
#     }
# }

# :parcel <<'/---'
# Configure canonical `zsh` builtins (e.g., `cd`, `rm`), typically seamlessly
# replacing external commands of the same name.
# /---

#declare_function_with_stdin <<'/---'
#string get_user_pid_dir(string username)
#
#Get the absolute path of the directory writable by the passed user containing
#PID files (i.e., files with filenames the basenames of executables containing
#the PIDs of such executables for such user): e.g.,
#
#.get_user_pid_dir()
#==========================================
#[source]
#------------------------------------------
#>>> get_user_pid_dir root
#/run
#>>> get_user_pid_dir sentient_6
#/home/sentient_6/.zeshy/cache/pid
#------------------------------------------
#==========================================
#/---
#function get_user_pid_dir() {
    # Validate sanity.
#    die_unless_arg 'expected one username'
#    string username="${1}"
#    die_unless_user "${username}"

    # If the passed user is the superuser, return the POSIX path for such files.
#    if { is_string_equals "${username}" 'root' } {
#        get_dir_first '/run' '/var/run'
    # Else, return the user-specific Zeshy path for such files.
#    } else {
        #FUXME: Magic string "/cache/pid" bad. Generalize.
        #FUXME: Throw an exception if such user has no home directory and hence,
        #for all intents, does not physically exist.
#        return_string "$(get_user_zeshy_dot_dir "${username}")/cache/pid"
#    }
#}

    # Match the passed user against such contents.
#   get_string_pcre_multiline_match_index_first "$(get_users_file_text)"\
#       "^${username}:(?:[^:]*+:){4}([^:]*+):"
#FUXME: Rename to get_user_dir_home().
#FUXME: Honestly, this is pure overkill. Just use
#"$(get_user_pid_dir "${username}")/${command_name}" wherever this is required.
#"$(get_user_pid_file_for_executable "${username}" "${command_name}")" is much
#longer to type and no more convenient.
#declare_function_with_stdin <<'/---'
#string get_user_pid_file_for_executable(
#    string username, string command_name)
#
#Get the absolute path of the file writable by the passed user containing the
#process ID of the passed command, when running: e.g.,
#
#.get_user_pid_file_for_executable()
#==========================================
#[source]
#------------------------------------------
#>>> get_user_pid_file_for_executable sentient_7 enslaved
#/home/sentient_7/.zeshy/cache/pid/enslaved
#------------------------------------------
#==========================================
#/---
#function get_user_pid_file_for_executable() {
#    die_unless_args_2 'expected one username and one command name'
#    string username="${1}" command_name="${2}"
#    return_string "$(get_user_pid_dir "${username}")/${command_name}"
#}
#   die_unless_pathable "${command_name}"
#FUXME: Hmm. We don't care about being the exact superuser (UID 0) as being a
#user with sufficient superuser privelages. Should users in group "wheel" also
#be considered superuser for such purposes? In such case, the name "_superuser"
#still applies but should simply be extended to include logical superusers. In
#this case, however, we'll want to distinguish logical from physical superusers
#(e.g., since UID 0 receives a different $PATH). Anyway.... contemplate. Hmmmmm.
#
#No, I suppose not. Wheel users are required to sudo to access such permissions,
#implying we'd need augment any function calling die_unless_superuser() with
#support for run_code_as_superuser(). We certainly should do so, eventually. But it
#can wait, somewhat.

# ....................{ TESTERS                            }....................
#FUXME: This is pretty banal, frankly. Do we actually ever call this anywhere? I
#suspect not. What we *REALLY* want to know is whether the passed user has
#theoretical access to superuser privelages -- either because such user is the
#superuser or in a group with escalatable privelages (e.g., "wheel").
# boolean is_user_superuser(string username)
#
# Return true if the passed user (defaulting to the current user) is the
# superuser (i.e., root).
#function is_user_superuser() {
    #FUXME: Shoddy. Ideally, we should be testing on UIDs even if the caller passed a
    #username. This implies we require a method for mapping between the two.
    #Should be trivially feasible. Grep us up. At the very least, we can test
    #whether the passed argument is the current username and perform such test
    #if true.
#    die_unless_arg 'expected one username'
#    is "${1}" == root si
#}

#   die_unless_file "${filename}"
#   die_unless_file "${filename}"

    # Validate sanity.
#   string username="${1}" users
#   users="$(get_users_file_text)"
#   is_string_matches_pcre_multiline "${users}" "^${username}:"
    # Get the contents of "/etc/passwd".
    # Match the passed group against such contents.
#   users="$(split_columns_from_lines "${users_file_text}" ':' 1)"
#   print_message "users: ${users}"
