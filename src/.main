#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2018 by Cecil Curry.
# See "LICENSE" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Main entry point into zeshy. This zsh script bootstraps zeshy into the
# current shell environment by conditionally compiling the subset of the zeshy
# codebase specific to the current system and user into a zsh digest file and
# autoloading such file.

#FIXME; Consider globally renaming "zeshy" to "zysh". Yes, we're quite serious.

#FIXME: Given short form while, case, etc. statements, there's no longer a need
#for long form-specific reserved words. I believe the full set of such words
#is, according to section "RESERVED WORDS" of "man zshmisc": "esac", "do",
#"done", "fi", and "end". To minimize the number of reserved words, disable
#such reservation as follows:
#
#   disable -r 'do' 'done' 'end' 'esac' 'fi'
#
#Note that we'll probably need to temporarily re-enable such words when
#sourcing exogenous zsh shell scripts. Replacing "disable" with "enable" above
#should suffice for that.

#FIXME: It'd be nice, though hardly necessary, to define a new
#command_not_found_handler() function throwing a well-formatted exception. Per
#zsh documentation:
#
#    "If  no external command is found but a function command_not_found_handler
#     exists the shell executes this function with all command line arguments.
#     The function should return status zero if it successfully handled the
#     command, or non-zero status if it failed. In the latter case the
#     standard handling is applied: `command not found' is printed  to
#     standard error and the shell exits with status 127."

#FIXME: When "zsh" is upgraded while zeshy is running, things go downhill
#pretty quickly until such zeshy sessions are restarted. For example, if no
#exception has yet been thrown and hence functions throw() and catch() not
#autoloaded, then the next fatal error will trigger unhelpful zsh errors
#resembling "zsh: throw: command not found". It'd be quite nice to detect such
#upgrade and:
#
#* For each running interactive zeshy shell, implicitly restart such shell on
#  the next prompt display (i.e., after completing the current command).
#* For each running non-interactive zeshy shell, well... there's probably not
#  much we can efficiently do. Hopefully, such shell completes quickly!
#FIXME: It'd be nice to profile zeshy a bit to see what's consuming the most
#time. (I suspect the single "autoload -w" statement loading the digest, but
#one never knows, really.) Perhaps add a new "--profile-zeshy-startup" option.
#FIXME: It'd be *GREAT* to optimize release builds by stripping all comments
#from components -- particularly for top-level components sourced over and over.
#Unfortunately, we basically need a zsh parser to do so reliably; also, note
#that the license-specific comments must *NOT* be deleted. (Though, presumably
#one could delete all comments indiscriminantly and then manually prepend back
#the canonical license comments.) Hmm; a bit odd, but zsh introduces the
#following parameter expansion flag: "${(Z:C:)string_name}". Basically, "Z" is
#the bigger brother of "z" splitting strings on shell words. To quote the
#release notes, "(Z:C:) parses comments and strips them". At also strips
#extraneous unquoted whitespace, which also seems desirable. So... this seems
#like a hell of a long shot, but couldn't we just:
#
#* Load the file to be stripped into a local string variable.
#* Strip comments from such variable with "${(Z:C)...}", implicitly also
#  converting such string into a list.
#* Convert such list back into a string with a simple
#  "join_list_on_newline script_lines", or some such.
#* Serialize out the resulting string. Would it actually work? I have no idea.
#  But the following command-line test run looks *REALLY* promising:
#
#    >>> string m; m="$(< main)"
#    >>> print "${(Z:C:)m}" | less
#
#  Wow! The output looks perfectly safe for sourcing. It does include redundant
#  substrings of semicolons (e.g., "; ; ; ; ; ; ; ;"), but that at least is
#  easily globally substituted out. To truly test this, we'll want to take
#  something that's genuinely zsh with no extraneous zeshy -- say
#  "/usr/share/zsh/5.0.0/functions/v Completion/Unix/_git", the largest such
#  autoloadable function. If this works on *THAT* file, it probably works
#  anywhere. Worth a shot, anyway, due to the simplicity of the implementation.
#  zsh does all the heavy lifting here, as is sensible and gentlemanly.

# ....................{ WELCOME                            }....................
#FIXME: This is a horrible hack. Make this go away as soon as we stop exporting.
#FIXME: Hmm; while we no longer export, it's unclear whether this *IS* a hack.
#Increasingly, this operation appears requisite and hence must *NOT* be
#excised. (Probably, anyway.) Document why this is the case.

# Undefine all zeshy-specific globals (i.e., prefixed by "ZY_").
unset -m 'ZY_*'

# ....................{ DOCUMENTATION                      }....................
#FIXME: To conserve space, delete these lists immediately *AFTER* either
#compiling or loading the digest file for the current Zeshy process.

# Lists of alias, function, and global documentation specific to top-level
# zeshy components (e.g., "main", "compile"). Each list element is a help
# string documenting some alias, function, or global defined by such a
# component. Since we subsequently delete these lists to conserve space, we
# avoid formally documenting these lists... for the moment, anyway.
#
# Note that this approach incurs a minor startup cost unconditionally applied to
# all Zeshy invocations. Ideally, this documentation would *ONLY* be declared in
# the main codebase and hence by Zeshy invocations (re)compiling a digest file.
# However, doing so invites desynchronization between the actual implementation
# and documentation of early-time functionality -- rendering this documentation
# effectively useless. Since useful documentation is worth a minor startup cost,
# the current approach prevails.
local -a\
    ZY__HELP_ALIASES\
    ZY__HELP_FUNCS\
    ZY__HELP_GLOBALS

# ....................{ PROFILING                          }....................
# Set the current time since the Unix epoch *BEFORE* all subsequent operations
# to ensure reasonable profiling results.

# Load module "datetime", providing timing-related globals expanded below. Defer
# loading all other modules *AFTER* initiating such timing to improve fidelity.
zmodload zsh/datetime

# Time in partial seconds since the Unix epoch at which zeshy was first loaded
# (i.e., at which the current script was first sourced).
float ZY_TIME_START="${EPOCHREALTIME}"

# ....................{ OUTPUTTERS                         }....................
# For safety, define such runnable as an alias rather than function. While both
# are undefinable (either accidentally or maliciously), the former is expanded
# at function definition rather than call time and hence guaranteed to exist
# for all functions defined below.

ZY__HELP_ALIASES+='
[stderr=:str] :warning.output(:str warning_message)

Print the passed string as a non-fatal warning to standard error.
'
alias :warning.output='{
    print -r -- "zeshy: $(< /dev/stdin)" 1>&2
} <<<'

# ....................{ GLOBALS                           }....................
# Current version of zeshy.
typeset -g ZY_VERSION='0.0.1'

# If the major version of the current zsh interpreter is less than 5, such
# interpreter is older than zeshy requires. In such case, print an error
# message to standard error and fail. If the current shell is interactive,
# avoid exiting such shell (and hence hiding such message) by returning
# instead.
#
# Note that there exist various methods of comparing version specifiers, with
# the customary tradeoffs in complexity versus efficiency. In particular, zsh
# defines the autoloadable script "is-at-least" and zeshy the function
# :is_version_at_least(). While either does reliably compare arbitrary version
# specifiers, the former requires sourcing an external script iterating with
# doubly nested "while" loops and the latter embedding a nearly 200-line
# function in the root script sourced on every zeshy startup.
#
# Fortunately, the following simpler method presents itself.
if [[ ${ZSH_VERSION} == <0-4>.* ]] {
    :warning.output\
        "zsh ${ZSH_VERSION} detected but zsh 5.0.0 or newer required."
    return 1
}

#FIXME: Ugh. Untrue, actually.
#FIXME: What does the comment below mean? Do these globals actually prohibit
#duplicates already? We don't *BELIEVE* they do. But if they don't, then what
#does the above comment refer to as being "untrue"?

# Prohibit duplicate paths in canonical path list globals (e.g., ${path}).
# Since ${path} in particular is central to sane operation, do so prior to
# subsequent logic.
#
# If the current script was *NOT* transitively sourced from a function (i.e.,
# if such script was sourced only from the top level of other zsh scripts or
# directly from the command line), prohibiting such paths reduces to a single
# call to typeset(). Unfortunately, if the current script was transitively
# sourced from a function, the same call also silently erases such lists.
# (Which is bad.)
#
# In the latter case, avoid such erasure by explicitly copying the
# corresponding string globals to temporary string locals *BEFORE* calling
# typeset(). (While list rather than string globals could also be preserved,
# string copies are moderately more efficient than list copies.)
if (( ${zsh_eval_context[(ie)shfunc]} <= ${#zsh_eval_context} )) {
    # String locals preserving such string and hence list globals.
    local -a PATH_OLD CDPATH_OLD FPATH_OLD MANPATH_OLD
    PATH_OLD=${PATH}
    CDPATH_OLD=${CDPATH}
    FPATH_OLD=${FPATH}
    MANPATH_OLD=${MANPATH}

    # Prohibit duplicate paths in such list globals. Since such declaration
    # occurs in a function context, explicitly globalize such variables to
    # avoid their implicit localization.
    typeset -gU path cdpath fpath manpath

    # Restore such string and hence list globals.
    PATH=${PATH_OLD}
    CDPATH=${CDPATH_OLD}
    FPATH=${FPATH_OLD}
    MANPATH=${MANPATH_OLD}

    # Undefine such string locals.
    unset PATH_OLD CDPATH_OLD FPATH_OLD MANPATH_OLD
# Else, a single call to typeset() suffices.
} else {
    typeset -U path cdpath fpath manpath
}
# print "path: ${PATH}"

# ....................{ OPTIONS                           }....................
# Set the following shell options under *ALL* zeshy sessions.
#
# * File globbing:
#   * "brace_ccl", parsing brace expansions *NOT* of the form "{x,y,z}",
#     "{n1..n2}", or "{n1..n2..n3}" as ASCII character classes (e.g., "{0-9}",
#     expanding to whitespace-delimited digits 0 through 9).
#   * "extended_glob", parsing "#", "~", and "^" as extended globbing
#     modifiers.
#   * "glob_dots", permitting "."-prefixed pathnames to be globbed by globs
#     *NOT* explicitly prefixed by "." (e.g., "*").
#   * "no_case_glob", globbing case-insensitively.
#   * "no_equals", preventing "="-prefixed unquoted shell words from being
#     expanded to the absolute path of the command following such prefix.  Such
#     syntax obstructs unquoted shell word usage for little to no benefit.
#     Specifically:
#     * Such syntax fails to report failure if such command does *NOT* exist.
#     * Builtin which() and history modifier ":c" already provide the same
#       functionality, the former correctly reporting failure if such command
#       does *NOT* exist.
#   * "numeric_glob_sort", sorting globbed numeric filenames (i.e., globbed
#     filenames containing at least one run of two or more digits) numerically
#     rather than lexicographically.
setopt\
    brace_ccl\
    extended_glob\
    glob_dots\
    no_case_glob\
    no_equals\
    numeric_glob_sort\

#FIXME: For efficiency, compress *ALL* of the following discrete calls to
#setopt() into the prior single massive call to such builtin.
#FIXME: We almost certainly set several options already enabled by default. This
#isn't simply inefficient: it's fairly harmful, as it obstructs a clear
#understanding of how "far" zeshy differs from default zsh. Indeed, the number
#of options set in such single call to setopt() is a useful proxy for the number
#of differences between zeshy and stock zsh.
#
#Is there a way to determine the minimum set of options differing between the
#two? Yes! When called without arguments, setopt() has been implemented in a
#fairly clever fashion to *ONLY* output those options differing from zsh
#defaults, providing a simple means of determining what should be set below.
#FIXME: Note that, between "bin/zeshy" and "src/.zshrc", the following options
#are guaranteed to always be set here:
#
#* "no_unset", reporting failure on attempts to expand undefined variables.
#* "warn_create_global", warning on attempts to set undeclared variables.
#
#Hence, don't bother reenabling such options.

# Enforce strictness, as under conventional high-level languages.
setopt no_unset           # exception on attempting to expand unset parameters
setopt warn_create_global # warning on attempting to set undeclared parameters
setopt no_err_exit        # zeshy implements more robust error handling
setopt no_err_return      # zeshy implements more robust error handling

# Variable assignment.
setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"
setopt no_ksh_typeset     # perform word splitting on variable assignment

# Avoid printing previously assigned variables when calling typeset() with
# variables with no new assignments (e.g., "typeset specular_reflection").
setopt typeset_silent

# Variable expansion.
setopt c_bases           # print non-base 10 integers in C format (e.g., "0x33")

# Shell parsing.
setopt no_ksh_arrays      # enable 1-based lists subscriptable without braces
setopt no_ksh_autoload    # treat autoloaded files as function definitions
setopt magic_equal_subst  # enable filename expansion on "="-prefixed strings
setopt short_loops        # enable "for ... (...) { ... }"-style shell constructs

# Shell quoting.
setopt no_csh_junkie_quotes  # allow unescaped newlines in quotes
setopt no_sh_word_split  # do not field split unquoted parameters
setopt rc_quotes         # parse '' as ' in single quotes (e.g., '''' == "'")

# Command execution.
setopt no_print_exit_value  # do not print "zsh: exit $?" on command failure

# Report failure on *ANY* pipeline element failing. By default, zsh only
# reports failure on the rightmost pipeline element failing, obscuring failure
# reported by all preceding elements.
setopt pipe_fail

# Track and hence print line numbers for eval() expressions relative to the
# environment enclosing such eval() rather than such expressions themselves. The
# latter, which remains the zsh default, produces largely unreadable errors.
setopt no_eval_lineno

# Command history.
setopt hist_fcntl_lock   # prefer fcntl()- to ad hoc-based history file locking
setopt hist_lex_words    # ensure accurate parsing of commands saved to disk
setopt hist_no_store     # do not add history-specific command lines
setopt hist_reduce_blanks # reduce extraneous whitespace in history items
setopt hist_subst_pattern # permit extended globbing with ":s" and ":&"

# When adding history items, also remove all older duplicates of such items.
setopt hist_ignore_all_dups

# Do not add whitespace-prefixed command lines to the history.
setopt hist_ignore_space

# Reload command lines performing history expansion into the editing buffer
# rather than executing such lines immediately.
setopt hist_verify

# Append history items to the history file as such items are entered rather than
# when the shell exits, for safety. This also has a pleasant side effect of
# sharing the history file between multiple shell sessions.
setopt inc_append_history

# Path changing.
setopt auto_cd           # automatically "cd" to directories in command position
setopt auto_pushd        # automatically "pushd" directories onto the dirstack
setopt pushd_ignore_dups # do not push duplicate directories onto the dirstack
setopt pushd_silent      # run "pushd" and "popd" silently

# Avoid interactively confirming star-style path removal (e.g., "rm *"). While
# nice, zeshy already interactively confirms *ALL* attempted path removals.
# Since zeshy's default behavior is arguably safer than zsh's, avoid redundant
# confirmations of such removal.
setopt rm_star_silent

# Silently reduce non-matching globs to the empty string rather than printing an
# error message. While the latter appears preferable, zsh fails to also:
#
# * Signal ZERR and hence call TRAPZERR() on non-matching globs, thus failing to
#   throw exceptions or print stack traces on glob failure.
# * Permit the printed error message to be customized. The error messages zsh
#   prints are largely unhelpful for non-interactive scripts (e.g.,
#   "zsh: no matches found: Tomoe(:A)"), offering no human-readable context for
#   script debugging or development.
#
# Hence, we reluctantly disable errors on non-matching globs. zeshy scripts and
# functions must test for glob failure by testing list emptiness. With practice,
# this should (!) become second nature: e.g.,
#
#     >>> list glob_match; glob_match=( "PiKHAL/TiKHAL"(:A) )
#     >>> is_nonempty "${glob_match}" or die "\"PiKHAL/TiKHAL\" not found"
setopt null_glob

# File writing.
setopt no_clobber        # forbid ">" from truncating existing files

# PCRE matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Process control.
setopt long_list_jobs    # list jobs in long format

# Shell I/O.
setopt no_flow_control   # disable interactive flow control (e.g., ^S, ^Q)
setopt ignore_eof        # do not treat ^D as "exit", interactively
setopt interactive_comments  # enable "#" comments in interactive commands
setopt print_eight_bit   # enable 8-bit output for completion lists

# Shell prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# Tab completion.
setopt auto_menu         # use menu completion after two tabs
setopt complete_in_word  # complete inside words
setopt no_list_ambiguous # only list matches if ambiguous

# ....................{ BUILTINS                           }....................
# Disable the following builtins:
#
# * "r", expanding to "fc -e -", repeating the prior interactive command. Since
#   all reasonably modern shells provide a generalized form of such
#   functionality through <Up>, there exists no reason to reserve an eminently
#   useful single letter for an unused command.
disable r

# ....................{ MODULES                            }....................
# Load all zsh modules required by this parcel or parcel "digest". Note zsh
# module "zsh/datetime" to have already been loaded above.

# Wrap system call stat() with zsh function zstat(). Do not load this module
# with "zmodload zsh/stat", as that wraps such call with zsh function stat()
# conflicting with external POSIX command "stat". Do not bother autoloading such
# module on the first call to zstat(), as zeshy startup *ALWAYS* calls such
# function. See parcel "digest" for further details.
zmodload -F zsh/stat b:zstat

# Expose zsh's internal C-based hash tables as zsh-based dictonaries. Do not
# bother autoloading such module on the first expansion of such a dictionary,
# due to the overwhelming number and basic essentiality of such dictionaries.
# These include:
#
# * ${funcstack}, the stack of functions, scripts, and "eval" statements on the
#   current call path.
# * ${functions}, the set of all currently defined functions, permitting
#   redefinition and subsequent restoration of new function implementations.
zmodload zsh/parameter

# ....................{ EXCEPTIONS ~ throw                 }....................
# void :call_stack.unwind(void)
#
# Unwind the current call stack by intentionally triggering a fatal internal
# error. Specifically, silently attempt to redefine a local string constant --
# logic inspired directly by the canonical zsh function throw(). For reasons
# not entirely clear, such logic is *NOT* replaceable by customary commands
# signalling errors (e.g., "return 1").
#
# For robustness, implement such logic as an alias rather than function. While
# functions may be (either maliciously or accidentally) undefined at runtime
# and hence are *NOT* reliably callable by low-level exception handlers,
# aliases are expanded at function and script definition time and hence
# guaranteed to be expanded in such handlers below.
alias :call_stack.unwind='{
    readonly THROW=
    THROW= 2>/dev/null
}'


function TRAPZERR() {
    #FIXME: Such logic differs from that of :die(), which sets such status to
    #"${pipestatus[-1]}". While such differences may well be justified (e.g.,
    #due to the nature of trap handlers versus customary functions), we should
    #at least research and document the necessity of these differences.

    # Exit status of the prior command inducing the current error signal.
    integer exit_status=${status}
#   print -r -- "TRAPZERR() triggered with ${exit_status}"

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :die().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If this handler recursively triggered itself, halt such recursion by
    # printing such exception without calling additional functionality and
    # immediately returning. Specifically, unless the last instance of this
    # function in the current call stack is the first element of such stack
    # (signifying the current call), this function signalled an error. Avoid
    # another such error and thus infinite recursion by returning.
    #
    # If ${funcstack} is undefined, default such index to 1, ensuring such
    # conditional fails. An appropriate error will be returned below.
    #
    # Technically, this trap handler *COULD* have simply been called by a valid
    # script with filename "TRAPZERR". While unlikely, such edge case remains
    # marginally likelier than Schroedinger's Cat. Guard against this inanity by
    # only falling into this conditional if the runnable at such index is *NOT*
    # a script. See :call_stack.is_index_script() for further details.
    if (( ${funcstack[(I)TRAPZERR]-1} != 1 )) &&
       [[ ${funcsourcetrace[${funcstack[(I)TRAPZERR]}]-} != *':0' ]] {
        # Print an exception message to standard error.
        {
            print
            :warning.output 'TRAPZERR() threw exception: '${*}
            :warning.output 'TRAPZERR() failed with exit status '${exit_status}
            print 'current call stack:'

            # Print an exception stack trace.
            local runnable_name
            for   runnable_name ("${funcstack[@]}") {
                print '  \_ '${runnable_name}'()'
            }
        } 1>&2

        # Unwind the current call stack and shell. (See below.)
        return ${exit_status}
    }

    # If any list variable expanded below is undefined or not a list, fail.
    [[ ${(t)funcstack-} == 'array-'* ]] || {
        :warning.output '${funcstack} undefined in TRAPZERR().'
        return ${exit_status}
    }

    #FIXME: Insufficient, as backgrounding "vim" demonstrates. The crux of the
    #issue is the second condition (${#funcstack} == 1), which excludes
    #backgrounding commands called from within zeshy functions. What we
    #*REALLY* need is some means of determining whether or not we're
    #backgrounding something. That shouldn't be terribly difficult, right?
    #Surely there's a trap handler for that. Investigate.
    #FIXME: This is almost certainly Linux-specific. Or is it? It's merely a
    #nicety, so it doesn't particularly matter *TOO* much, but still.
    #FIXME: Abstract this into a new TRAPZERR() hook and shift elsewhere --
    #ideally, a new parcel (e.g., @{*-main/zsh/trap}).

    # If such status is 20 *AND* the call stack contains only the call to this
    # trap handler, such handler was triggered by the non-erroneous interactive
    # backgrounding of a foregrounded process (e.g., via <Ctrl-z>). In such
    # case, report success rather than unwinding such stack.
    if (( exit_status == 20 && ${#funcstack} == 1 )) {
        # print '20! current call stack:'
        # local runnable_name
        # for   runnable_name ("${funcstack[@]}") {
        #     print '  \_ '${runnable_name}'()'
        # }
        return 0
    }

    # If the ::exception.store() function is undefined, fail. Since this
    # is a trap handler, avoid the following customary approach to testing
    # function existence (which assumes both module "zsh/parameter" *AND*
    # feature "parameters" from such module to have been loaded):
    #
    #    if (( ${+functions[::exception.store]} )) { ... }
    typeset -f ::exception.store &>/dev/null || {
        :warning.output '::exception.store() undefined in TRAPZERR().'
        return ${exit_status}
    }

    # Convert this error into an exception. Since zsh only passes this handler
    # an exit status, do *NOT* bother fabricating an error message. Subsequent
    # exception handling should already do so.
    ::exception.store '' "${exit_status}"

    # Run all external hooks registered for such signal.
    typeset -ag ZY_HOOK_CODE_RUN_ON_SIGNAL_ZERR
    local hook_code
    for   hook_code ("${ZY_HOOK_CODE_RUN_ON_SIGNAL_ZERR[@]}") {
        eval "${hook_code}"
    }

    # Return such command's status as this trap's status. This pantomimes the
    # result of enabling shell option "ERR_RETURN". (See "man zshoptions" for
    # further details.)
    return ${exit_status}
}


# :void :die(*:str exception_messages)
function :die() {
    # Get the exit status to be associated with such exception from the current
    # runtime environment rather than expecting such status to be explicitly
    # passed. Specifically, get the exit status of the prior command --
    # regardless of whether such command resided in a pipeline or not.
    #
    # ${pipestatus} is a canonical list global whose elements are the exit
    # statuses of each subcommand of the prior pipe command or of the prior
    # command if not a pipe command. Conversely, ${?} and ${status} are
    # canonical integer globals containing the exit status of the prior command
    # *ONLY* when not such a subcommand. Since the former plainly subsumes the
    # latter, defer to the former. Consider:
    #
    #     # Define helper functions.
    #     >>> pipe_status() { print ${pipestatus[-1]} }
    #     >>> exit_status() { print $? }
    #
    #     # ${pipestatus} provides the required values.
    #     >>> true; pipe_status  # this works...
    #     0
    #     >>> true; true | false || pipe_status  # ...and so does this.
    #     1
    #
    #     # Neither ${?} or ${status} provide the required values.
    #     >>> true; exit_status  # this works...
    #     0
    #     >>> true; true | false || exit_status  # ...but this doesn't.
    #     0
    integer exit_status=${pipestatus[-1]}

    # If this function is recursively calling itself, halt such recursion by
    # printing such exception without calling additional functionality and
    # immediately unwinding the call stack. See TRAPZERR().
    if (( ${funcstack[(I):die]-1} != 1 )) &&
       [[ ${funcsourcetrace[${funcstack[(I):die]}]-} != *':0' ]] {
        # Print an exception message to standard error.
        {
            print
            :warning.output ':die() threw exception: '${*}
            :warning.output ':die() failed with exit status '${exit_status}
            print 'current call stack:'

            # Print an exception stack trace.
            local runnable_name
            for   runnable_name ("${funcstack[@]}") {
                print '  \_ '${runnable_name}'()'
            }
        } 1>&2

        # Unwind the call stack.
        :call_stack.unwind
    }

    # If this function is defined, globalize this exception.
    if { typeset -f ::exception.store &>/dev/null } {
        ::exception.store "${*}" "${exit_status}"
    # Else, print a nonfatal warning. Since the end of this function already
    # throws an exception, refrain from doing so here.
    } else {
        print '::exception.store() undefined in throw_exception().' 1>&2
    }

    # By default, zsh coerces integer global ${TRY_BLOCK_ERROR} to -1. On
    # entry, "}:always{...}:always" blocks set such integer to the exit status
    # of the last command in the corresponding ":try{...}" block. If such
    # integer is 0, this function was called from within the
    # "}:always{...}:always" block of such a ":try{...}" block whose last
    # command succeeded. While rare, handle such case by coercing the current
    # "}:always{...}:always" block to report failure rather than success.
    if (( ${TRY_BLOCK_ERROR--1} == 0 )) {
        TRY_BLOCK_ERROR=1
    }

    # Unwind the call stack.
    :call_stack.unwind
}


# :str ::exception.store(:str exception_message :int exit_status)
#
# To comply with existing zsh code, this function stores the passed exception
# message in the standard ${EXCEPTION} global rather than in a zeshy-specific
# alternative (e.g., ${ZY__EXCEPTION_MESSAGE}).
function ::exception.store() {
    # Validate sanity. Since :die() calls this function, avoid calling such
    # function; in the event of an error, simply print a message to standard
    # error and report success. Do *NOT* report failure. Since this function is
    # called by both :die() and TRAPZERR(), reporting failure here could induce
    # infinite recursion. Instead, allow whichever of :die() or TRAPZERR()
    # called this function to continue throwing their exception.
    (( # == 2 )) || {
        :warning.output '::exception.store() expected one exception message and one exit status.'
        return 0
    }
    local exception_message="${1}" exit_status="${2}"

    #FIXME: Actually, in such case, wouldn't it be more robust to attempt to
    #reload module "zsh/parameter"?

    # If any canonical call stack list is undefined or not a list, fail.
    [[ "${(t)funcstack-}${(t)funcfiletrace-}${(t)funcsourcetrace-}" ==\
        'array-'*'array-'*'array-'* ]] || {
        :warning.output '${funcstack}, ${funcfiletrace}, and/or ${funcsourcetrace} undefined or not lists for exception: '${EXCEPTION-}
        return 0
    }

    # If this function is called directly from the command line, fail. (In this
    # case, since this function cannot have been called by :die(), there's no
    # possibility of undesired recursion. Hence, report failure.)
    (( ${#funcstack} >= 2 )) || {
        :warning.output '::exception.store() called directly from command line.'
        return 1
    }

    # If this status is not in [0, 255], fail. See is_integer_nonnegative().
    { [[ ${exit_status} == <-> ]] &&
      (( 0 <= exit_status && exit_status <= 255 )) } || {
        :warning.output '::exception.store() exit status "'${exit_status}'" not an integer in [0, 255].'
        return 0
    }

    # If this status signifies success, coerce this status to signify failure.
    if (( exit_status == 0 )) {
        exit_status=1
    }

    # If ${EXCEPTION} is currently defined, an exception has been thrown but
    # not caught. To preserve such exception, append such exception's message
    # to the passed message.
    #
    # Technically, if the call stack for such uncaught exception is still
    # defined to a nonempty list *AND* the exit status for such uncaught
    # exception is still defined to an integer, such stack and status could be
    # incorporated into such message as well. Since retrieving a human-readable
    # runnable name from such stack is nontrivial (e.g., due to necessarily
    # ignoring runnables matching :die(), TRAPZERR(), and so forth), such
    # incorporation is nontrivial. It currently isn't worth the effort.
    if (( ${+EXCEPTION} )) {
        exception_message+=$'\n\n''Uncaught exception:'$'\n'${EXCEPTION}
    }

    # Store such metadata as documented above.
    typeset -g EXCEPTION=${exception_message}
    integer -g ZY__EXCEPTION_STATUS=${exit_status}
    typeset -ag\
        ZY__EXCEPTION_FUNCSTACK\
        ZY__EXCEPTION_FUNCFILETRACE\
        ZY__EXCEPTION_FUNCSOURCETRACE

    # Omit the current call, which will convey no meaningful context to most
    # users, from the call stack stored for such exception.
    #
    # Do *NOT* quote list slices. (Doing so concatenates all list items.)
    ZY__EXCEPTION_FUNCSTACK=(       ${funcstack[2,-1]} )
    ZY__EXCEPTION_FUNCFILETRACE=(   ${funcfiletrace[2,-1]} )
    ZY__EXCEPTION_FUNCSOURCETRACE=( ${funcsourcetrace[2,-1]} )

    #FIXME: Obsolete! Excise me after fixing digest compilation.
    integer -g ZESHY_EXCEPTION_STATUS=${exit_status}
    typeset -ag\
        ZESHY_EXCEPTION_FUNCSTACK\
        ZESHY_EXCEPTION_FUNCFILETRACE\
        ZESHY_EXCEPTION_FUNCSOURCETRACE
    ZESHY_EXCEPTION_FUNCSTACK=(       ${funcstack[2,-1]} )
    ZESHY_EXCEPTION_FUNCFILETRACE=(   ${funcfiletrace[2,-1]} )
    ZESHY_EXCEPTION_FUNCSOURCETRACE=( ${funcsourcetrace[2,-1]} )

    # If this function was *NOT* called from within a ":try{...}:always{...}:always"
    # block, the exception that TRAPZERR() or :die() subsequently throws will
    # induce zsh to silently unwind the call stack for the current shell
    # without printing such exception. To avoid that, print such exception here
    # *BEFORE* throwing such exception.
    # print "ZY__TRY_LEVEL: ${ZY__TRY_LEVEL[${SHLVL}]-0o0o0}"
    if (( ${ZY__TRY_LEVEL[${SHLVL}]-0} <= 0 )) {
        # If such function is undefined, print a nonfatal warning.
        typeset -f ::exception.print_uncaught &>/dev/null || {
            :warning.output '::exception.print_uncaught() undefined in ::exception.store().'
            return 0
        }

        # Print such exception.
        ::exception.print_uncaught
    }
}

# ....................{ EXCEPTIONS ~ catch                 }....................
#FIXME: It'd be nice to extend such functionality with a list of user-
#configurable hooks called on uncaught exceptions. Not terribly critical at the
#moment, but something to eventually... integrate.
#FIXME: Excise ::print_exception_if_uncaught quickly! It's here only to resolve
#short-term digest compilation issues... which, hopefully, will go away.

# :void ::exception.print_if_uncaught(:void)
#
# While such functionality could be inserted directly into the expansion of
# macro :always(), doing so inflates the implementation of all runnables
# expanding such macro -- in most cases, unreadably so.
function ::exception.print_if_uncaught ::print_exception_if_uncaught() {
    # If an error occurs in this function, throw an exception rather than
    # merely printing a message and setting ${TRY_BLOCK_ERROR} to 1. While
    # doing so does mimic the low-level action of an exception by unwinding the
    # current call stack, it fails to mimic the most significant high-level
    # action of an exception: printing the stack trace!

    (( # == 0 )) || :die 'Expected no arguments.'

    # If not called from within an ":always {...}" block, throw an exception.
    # See die_unless_in_always() for further details.
    (( ${TRY_BLOCK_ERROR--1} >= 0 )) || :die\
        'Not in an ":always {...}" block (or ${TRY_BLOCK_ERROR} "'${TRY_BLOCK_ERROR--1}'" not in [0, 255] and hence an invalid exit status).'

    #FIXME: Rename ${ZY__TRY_LEVEL} to ${ZY__TRY_LEVEL} globally.

    # If list global ${ZY__TRY_LEVEL} is undefined or has no item
    # corresponding to the current shell or such item is non-positive, throw an
    # exception. Assuming the current ":always {...}" block to be preceded by a
    # ":try {...}" block, such item should always be positive. See :try() for
    # further details.
    (( ${ZY__TRY_LEVEL[${SHLVL}]-0} > 0 )) || {
        # Coerce such element to its default value to ensure proper operation
        # hereafter. See :try() for further details.
        typeset -ag ZY__TRY_LEVEL; ZY__TRY_LEVEL[${SHLVL}]=0

        # Throw an appropriate exception.
        if (( ${+ZY__TRY_LEVEL[${SHLVL}]} )) {
            :die '${ZY__TRY_LEVEL['${SHLVL}']} '${ZY__TRY_LEVEL[${SHLVL}]}' <= 0 (e.g., due to no preceding ":try {...}" block).'
        } else {
            :die '${ZY__TRY_LEVEL['${SHLVL}']} undefined (e.g., due to no preceding ":try {...}" block).'
        }
    }

    # Else, such global is sane. Decrement such global to undo its
    # incrementation by the prior ":try{...}" block. See :try() for further
    # details.
    ZY__TRY_LEVEL[${SHLVL}]=$(( ZY__TRY_LEVEL[${SHLVL}] - 1 ))

    # If an exception was caught, clear the canonical string global storing the
    # error message for such exception. (This ensures calls by subsequent
    # ":always {...}" blocks to is_exception_caught() report failure.)
    unset CAUGHT

    # If an exception was thrown and the current "}:always{...}:always" block
    # is the topmost such block, catch such exception. Unlike
    # catch_exception_matching_glob_if_found(), retain the current exit status
    # (i.e., ${TRY_BLOCK_ERROR}) to report such status to the shell.  See
    # catch_exception_matching_glob_if_found() for further details.
    if (( ${+EXCEPTION} && ZY__TRY_LEVEL[${SHLVL}] == 0 )) {
        # Print such exception and associated metadata.
        typeset -f ::exception.print_uncaught &>/dev/null ||
            :die '::exception.print_uncaught() undefined.'
        ::exception.print_uncaught
    }
}


# :void ::exception.print_uncaught()
#
# Print a stack trace for the currently uncaught exception.
function ::exception.print_uncaught() {
    (( ! # )) || :die 'Expected no arguments.'

    # If ${funcstack} is undefined or not a list, throw an exception.
    [[ "${(t)funcstack-}" == 'array-'* ]] || :die\
        'List global ${funcstack} undefined for exception: '${EXCEPTION-}

    # If called directly from the command line *OR* no exception is
    # currently thrown, throw an exception.
    (( ${#funcstack} >= 2 && ${+EXCEPTION} )) || :die\
        'No exception thrown (i.e., called directly from the command line and/or ${EXCEPTION} undefined).'

    #FIXME: Re-enable such logging functionality *AFTER* we've added a new
    #${ZY_IS_EXCEPTIONS_LOG} boolean global defaulting to false. For
    #now, such logging is far too verbose to be enabled by default.

    # If the ${ZY_USER_LOG_EXCEPTION_FILENAME} string global both exists
    # or is non-empty, create all parent directories of this logfile.
    if { false } && [[ -n ${ZY_USER_LOG_EXCEPTION_FILENAME-} ]] {
        command mkdir -p -- "${ZY_USER_LOG_EXCEPTION_FILENAME:h}"
        # print 'Making logdir: '${ZY_USER_LOG_EXCEPTION_FILENAME:h}
    # Else, default such global to the absolute path of the bit bucket.
    # While non-ideal, doing so dramatically simplifies logic below by
    # ensuring that the value of such global is the absolute path of a
    # user-writable file.
    #
    # Note that this variable assignment must be performed *BEFORE* the
    # following block expands this variable.
    } else {
        local ZY_USER_LOG_EXCEPTION_FILENAME='/dev/null'
        # print 'Redirecting logfile to devnull.'
    }

    # Redirect the exception stack trace printed below to both:
    #
    # * Standard error.
    # * The tail of the user-specific exception logfile.
    {
        # If print_exception() is defined, call such function.
        if { typeset -f print_exception &>/dev/null } {
            print_exception
        # Else, print such exception manually. If an exception is thrown
        # sufficiently early in zeshy startup, print_exception() will *NOT* have
        # been defined yet.
        } else {
            # Print such exception message to standard output rather than error
            # (e.g., by calling :warning.output()). as such output will be teed
            # as needed below.
            print -r 'zeshy: '"${EXCEPTION}"
            print -r 'zeshy: Failed with exit status '${ZY__EXCEPTION_STATUS-1}'.'

            # Print a stack trace. Ideally, such trace would only be
            # conditionally printed when the current user configuration requests
            # that *OR* when this is a debug build of zeshy, as under
            # :print_exception(). However, any exception thrown prior to
            # :print_exception()'s definition has been thrown sufficiently early
            # in the startup process that the user-configurable global
            # requesting such traces (i.e.,
            # ${ZY_ERROR_HANDLER_IS_PRINTING_CALL_STACK}) is unlikely to have
            # been defined. Indeed, no exceptions should be thrown so early,
            # suggesting a critical failure of startup logic. For safety, we
            # prefer to *ALWAYS* print stack traces of such early exceptions.
            #
            # See output_call_stack_lists_with_style_prefix() for related logic.
            local   caller_name filename frame_prefix='    \_'
            integer caller_line frame_index

            for frame_index ({1..${#funcstack}}) {
                caller_name="${funcstack[${frame_index}]}"
                caller_line="${funcfiletrace[${frame_index}]##*:}"
                   filename="${funcfiletrace[${frame_index}]%:*}"

                if { typeset -f -- "${caller_name}" &>/dev/null } {
                    caller_name+='()'
                }
                print -r --\
                    "${frame_prefix} ${caller_name} { ${filename}: ${caller_line} }"

                frame_prefix=" ${frame_prefix}"
            }
        }
    # Append such logfile by such stack track. To prevent infinite exception
    # handler recursion on write failure, print a non-fatal warning rather than
    # ignoring such failure. The latter would implicitly throw another
    # exception from our "ZERR" trap handler, inviting chaos.
    } 1>&2 >>!"${ZY_USER_LOG_EXCEPTION_FILENAME}" || {
        print 'Exception logfile "'${ZY_USER_LOG_EXCEPTION_FILENAME}'" unwritable.' 1>&2
        return 0
    }

    # Catch such exception by unsetting all globals previously set by
    # ::exception.store(). See catch_exception() for further details.
    unset\
        EXCEPTION\
        ZY__EXCEPTION_STATUS\
        ZY__EXCEPTION_FUNCSTACK\
        ZY__EXCEPTION_FUNCFILETRACE\
        ZY__EXCEPTION_FUNCSOURCETRACE

    # Return success to avoid triggering TRAPZERR() and hence another exception.
    return 0
}

# ....................{ EXCEPTIONS ~ command               }....................
#FIXME: Hardly the ideal implementation. While we *DO* need to declare this
#function here to ensure exceptions on missing commands run by early-time
#functionality, this function should be generalized to support a list of hooks
#to be iteratively called. Moreover, these hooks should support package
#manager-specific lookup ala modern Linux distributions.

# :void command_not_found_handler(:str command_name *:str command_args)
function command_not_found_handler() {
    (( # )) || :die\
        'Expected one command name and zero or more command arguments.'

    # Dismantled, this is:
    #
    # * IFS=' ', temporarily restoring the internal field separator to a space,
    #   ensuring that "${*[...]}" delimits passed command arguments with spaces.  
    IFS=' ' :die\
        'Command "'${1}'" not found.'$'\n\n''Command arguments:'$'\n    '${*[2,-1]}
}

# ....................{ INTERRUPTION                       }....................
#FIXME: It appears this may encourage non-halting interrupts, which is bad. I
#have no idea why, but strongly suspect calling curse_call_stack() in this
#context to be the culprit. Disable for now.
# integer TRAPINT(integer signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
#function TRAPINT() {
#    integer signal_number=${1}

    # Print the current call stack to indicate the point of interruption.
#    curse_call_stack

    # Store the interrupted line in the history. By default, zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
#    zle && print -sr -- "${BUFFER}"

    # Arcanely uncanny bit-munging. Exit status is always a 1-byte integer.
    # Non-zero exit status with:
    #
    # * The high bit unset signifies a command or function-specific error.
    # * The high bit set signifies a signal-specific error. All bits excluding
    #   the high bit signify the signal number.
    #
    # Hence, constructing a signal-specific exit status requires merely adding
    # 128 to the desired signal number. Moreover, zsh interprets non-zero trap
    # function return values as the exit status to be returned from running the
    # default handler for the trap. Since we would like to continue running the
    # default handler for the trap (SIGINT, in this case), this function returns
    # a non-zero value. Rather than hard-coding the desired signal number, reuse
    # the number zsh passed as the first argument to this function.
#    return $(( 128 + ${signal_number} ))
#}

# ....................{ OPTIONS                            }....................
# Map from parsed option name to optional value. As expected, unparsed options
# remain preserved in the current argument list.
local -A arg_options

# List of shell commands to be run parsed from options "-c" and "--command".
local -a arg_shell_commands

# List of shell options to be enabled parsed from options "-o" and "--option".
local -a arg_shell_options

#FIXME: I'm fairly assured that passing multiple commands and options with
#long-form options works as advertised. I strongly doubt, however, that passing
#multiple commands and options with short-form options works as advertised. If
#not, we'll probably want to drop the "-M" and manually map short- to long-form
#arguments following option parsing. (Simple, if a tad tedious.)
#FIXME: Add an option for profiling zsh startup. Yes, zsh supports this.
#Exceptionally cool; I had no idea! See Dennis' great answer here:
#
#http://stackoverflow.com/questions/4351244/can-i-profile-my-zshrc-zshenv
#http://stackoverflow.com/questions/6693515/zsh-how-to-time-a-block-of-code
#
#We should most certainly add a run_profiled() function for printing a timing
#profile after running the passed command. There appear to be several ways of
#doing this: the "setopt xtrace" approach of the first URL above; the
#"time ( ... )" approach of the second URL above; and the "zprof" module. I'm
#unclear which is better but am currently leaning towards the latter. Regardless
#of which approach we choose, output to standard error by default, so as to
#ensure expected behavior under process substitution. (Naturally, a secondary
#function could be implemented to log to a passed file, instead.)
#FIXME: Hmm; yes, the "zprof" approach appears superior. Its output rocks, as
#expected. Mimics "gprof", so there you go. It's a bit wieldy to use, requiring
#an unload of the module to disable profiling, but... no problems, given a
#run_profiled() helper.

# Parse passed options *BEFORE* operating on any zeshy files, as the former
# could modify the behavior of the latter (e.g., by preventing zeshy from
# recompiling and loading its digest file). If such parsing fails, set option
# "-h" to non-zero exit status, instructing the end of this script to print help
# to standard error and return with such status. See
# set_map_to_arg_options_with_help_from().
#
# For readability, map short- to long-form options. Map option
# "--no-zeshy-dot-dir" to "--zeshy-dot-dir", thus implicitly setting the latter
# to the empty string on parsing the former.
zparseopts -M -D -E -A arg_options --\
    h=-help -help\
    v=-verbose -verbose\
    -compile-digest\
    -compile-digest-if-zeshy-changed\
    -digest-debug\
    -digest-release\
    -version\
    c+:=arg_shell_commands -command+:=arg_shell_commands\
    o+:=arg_shell_options -option+:=arg_shell_options\
    -zeshy-dot-dir:: -no-zeshy-dot-dir=-zeshy-dot-dir ||
    arg_options[--help]='failed'
#print -- "passed option names (${#arg_options}): ${(k)arg_options}"

# ....................{ GLOBALS                            }....................
#FIXME: In isolation, ${ZY_USER_DIGEST_FILE_IS_INDEPENDENT} is a horrid name.
#We *STILL* have no idea what such boolean actually implies when we see it in
#code. Rename to something suitably readable.
#FIXME: ${ZY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZY_HOME} is also moderately
#horrible. Consider truncating as much as readably feasible.

# While other methods for achieving the same effect exist (e.g., touching
# zeshy's user configuration directory when passed option "--compile-digest"),
# such methods have non-idempotent and hence unexpected side effects.
integer -g\
    ZY_USER_DIGEST_FILE_IS_INDEPENDENT\
    ZY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZY_HOME

# ....................{ DEBUG                              }....................
# [status=:bool] :debug.is()
alias :debug.is='false'

# :full :line.run_if_debug(:str line)
alias :line.run_if_debug='# [DEBUG]'

# :str :stdout.echo_if_debug(:str line)
alias :stdout.echo_if_debug=':line.run_if_debug [[ -o interactive ]] && print -r -- "zeshy:"'

# ....................{ GLOBALS ~ arg                      }....................
#FIXME: Actually, this is *GORRAM* nonsensical. Look: zeshy, like most modern
#software, is intrinsically tied to git. Since the existence of a ".git"
#directory reliably implies this directory to be under git control, replace this
#fragile @ZY_IS_DEBUG@ nonsense with a simple efficient test:
#
#    if [[ -d "${ZY_HOME}/../src/../.git" ]] {
#       arg_options[--compile-digest-if-zeshy-changed]=
#       (( ${+arg_options[--digest-release]} )) || arg_options[--digest-debug]=
#    } else {
#       (( ${+arg_options[--digest-debug]} )) || arg_options[--digest-release]=
#    }
#
#Note this test effectively ensures the mandatory precondition that
#'"${ZY_HOME:t}" == src'. While we could do so manually, the above single
#condition ensures both conditions at the same time.
#FIXME: The existence of two redundant boolean command-line options for
#governing digest optimization (i.e., "--digest-debug" and "--digest-release")
#is unhelpful. Why? Because they're mutually exclusive. What is the semantic if
#both are passed? There is none. Instead:
#
#* Remove the "--digest-release" option.
#* Improve the "--digest-debug" option to accept an optional boolean argument,
#  either:
#  * 1 if compiling a debug digest.
#  * 0 if compiling a release digest.
#* If passed with no argument, this option's argument should default to 1.
#* If unpassed, this option's argument should default to 0.

# All lines containing "ZY_IS_DEBUG" prefixed and suffixed by "@" are removed
# from this parcel on zeshy installation and hence only apply to uninstalled
# zeshy instances (e.g., developer-specific git repositories).

# If running zeshy uninstalled, always test the zeshy codebase for changes
# requiring digest recompilation.
arg_options[--compile-digest-if-zeshy-changed]=  # @ZY_IS_DEBUG@

# If running zeshy uninstalled and option "--digest-release" was *NOT* passed,
# enable option "--digest-debug" by defaut.
(( ${+arg_options[--digest-release]} )) || arg_options[--digest-debug]=  # @ZY_IS_DEBUG@

# If at least one command-line option was passed, handle all options upon which
# zeshy startup subsequently depends (e.g., digest-specific options).
if (( ${#arg_options} )) {
    # Options "--verbose" and "--digest-debug" are synonyms.
    if (( ${+arg_options[--verbose]} )) {
        arg_options[--digest-debug]=
    }

    # If passed option "--digest-release", switch to a release build.
    # Specifically, disable option "--digest-debug", this option's antonym.
    # Oddly, zsh requires quoting map keys when unsetting such keys (possibly
    # due to their being prefixed by "--"?).
    if (( ${+arg_options[--digest-release]} )) {
        unset 'arg_options[--digest-debug]'
    }

    # If passed option "--digest-debug", switch to a debug build. By default, we
    # compile a release build.
    if (( ${+arg_options[--digest-debug]} )) {
        alias :debug.is='true'
        alias :line.run_if_debug=''
    }

    if (( ${+arg_options[--compile-digest]} )) {
        ZY_USER_DIGEST_FILE_IS_INDEPENDENT=1
    }
    if (( ${+arg_options[--compile-digest-if-zeshy-changed]} )) {
        ZY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZY_HOME=1
    }
}

# ....................{ GLOBALS ~ path                     }....................
#FIXME: For safety, *ALL* of such globals should probably be frozen as
#constants. Attempting to change such globals at runtime is likely to make life
#unpleasant and broken.
#FIXME: Actually, there is *NO* reason to redeclare either ${ZY_HOME} or
#${ZY_MAIN_SCRIPT} here. Both "bin/zeshy" and "src/.zshrc" guarantee such
#globals to be set to sane paths. Indeed, if either such string global is
#undefined *OR* not a string *OR* expands to the empty string here, we should
#simply throw an exception. This allows us to excise all of the convoluted
#canonicalization of such paths below as simply unnecessary. Simplify!
#
#Or perhaps not? Such canonicalization isn't *THAT* difficult. The current
#approach permits users to source zeshy into existing zsh setups -- which,
#while perhaps unrecommended, is at least interesting. If we do elect to
#preserve canonicalization, we'll want to improve such functionality.
#Specifically:
#
#    # This is completely wrong. Or, it's usually right, but it's occasionally
#    # wrong -- and hence wrong.
#    ZY_MAIN_SCRIPT="${0}"
#
#    # Instead, we want this. This is *ALWAYS* guaranteed to be right. The
#    # "(%)" enables prompt expansions; the "%x" is a prompt expansion
#    # expanding to the absolute path of the currently sourced script. Double-
#    # check this, of course... but stackoverflow is rarely wrong.
#    ZY_MAIN_SCRIPT="${(%):-%x}"
#
#We'll want to ensure we make the same change elsewhere, of course. "${0}"
#should (basically) never be used anywhere.

typeset -g\
    ZY_HOME\
    ZY_DOT_DIR\
    ZY_DOT_DIR_BASENAME='.zeshy'\
    ZY_MAIN_SCRIPT="${0}"\
    ZY_OVERLAY_DIR\
    ZY_BOOTSTRAP_DIRNAME\
    ZY_SCRIPT_FILENAME\
    ZY_SCRIPT_DIRNAME

# Absolute path of the top-level directory containing the zeshy codebase. If
# such path has *NOT* already been set (e.g., by "/etc/profile.env" on zeshy
# installation), assume such directory to be the parent directory of the
# current script.
[[ -n ${ZY_HOME} ]] || {
    # List containing either one list item expanding to the absolute path of
    # the parent directory containing this script if found or no list items
    # otherwise. Dismantled, this is:
    #
    # * "${...:h}", expanding to such directory's absolute or relative path.
    # * "(:A)", converting such path from relative to absolute if the former.
    typeset -a ZY_HOME_CANONICALIZED
    ZY_HOME_CANONICALIZED=( "${ZY_MAIN_SCRIPT:h}"(:A) )

    # If such list is empty, such directory does not exist, implying such
    # script also (somehow!) does not exist. In such case, report failure.
    (( ${#ZY_HOME_CANONICALIZED} )) || {
        :warning.output 'Main script "'${ZY_MAIN_SCRIPT}'" not found.'
        return 1
    }

    # Else, set such global accordingly.
    ZY_HOME=${ZY_HOME_CANONICALIZED[1]}
}

# Default such directory to "~/.zeshy".
ZY_DOT_DIR=${HOME}'/'${ZY_DOT_DIR_BASENAME}

#FIXME: We're no longer satisfied with such nomenclature, particularly as it
#diverges from internal local variable nomenclature. Rename "_DIR" to
#"_DIRNAME" everywhere *ON A CASE-BY-CASE BASIS* (to risky to do so all in one
#fell swoop), and likewise for "_FILE"- and "_PATH"-suffixed global names.

# While ${ZY_OVERLAY_DIR} is currently synonymous with ${ZY_HOME}, it's
# depressingly easy to conceive of contexts in which the two differ.
ZY_OVERLAY_DIR=${ZY_HOME}

# Absolute path of the directory containing all top-level zeshy scripts
# critical for bootstrapping the zeshy language. In particular, this includes:
#
# * The system inspector, uniquely identifying the current system.
# * The digest handler, compiling zeshy into zsh digest files.
# * The macro preprocessor, expanding macros in zeshy code.
ZY_BOOTSTRAP_DIRNAME=${ZY_HOME}'/..-soil'

#FIXME: Replace "[[ -n "${ZY_DOT_DIR}" ]] ||" with a similar alias to
#is_zeshy_debug_and<>, probably named is_zeshy_dot_dir_or<>. See below!
#FIXME: Actually, setting such global to the empty string is somewhat dangerous
#as Zeshy functions failing to properly test such global for emptiness prior to
#expansion will end up attempting to read and write from directories resembling
#"/.zeshy/config/posix", *WHICH IS TOTALLY BAD.* To avert this, there's really
#no choice but to *UNSET* this global here at the top-level and then define a
#convenience alias resembling:
#
#    alias is_zeshy_dot_dir_or='(( ${+ZY_DOT_DIR} )) ||'
#
#Dead simple, really. We just need to do it. *AND DO IT SOON.* This is bloody
#dangerous, and quite unfriendly.
#FIXME: I see two amenable solutions (in no particular order):
#
#1. If passed "--no-zeshy-dot-dir", unset *ALL* such globals. This is a pretty
#   sweet solution, frankly. We could simply perform such unsetting *AFTER*
#   exporting all such globals here. (Should work, no?)
#2. If passed "--no-zeshy-dot-dir", be clever and set ZY_DOT_DIR="/dev/null".
#   This is the one system-wide path pretty much guaranteed to exist on all
#   *nix's and *NOT* be a directory. Hence, any attempt to read from or write
#   no any path "${ZY_DOT_DIR}/pathname" will always and reliably fail. That
#   said, it's a tad lazy: the failure doesn't show up until attempting an
#   actual file operation. The former solution spits up an error much earlier,
#   which is great.
#2a. If we adopt the approach of 2., note that we setting ZY_DOT_DIR=$'\0' is
#    a much better solution *GUARANTEED* to always produce failure.
#FIXME: Actually test this. Shouldn't be terribly difficult: just temporarily
#move "~leycec/.zeshy" aside and pass "--no-zeshy-dot-dir" to an interactively
#run "zeshy" process. If "~leycec/.zeshy" doesn't appear, we've done something
#spectacularly right. Huzza!
#FIXME: We should automatically enable option "--no-zeshy-dot-dir" whenever the
#filesystem hosting the desired ${ZY_DOT_DIR} is read-only. This is
#particularly important for running Zeshy under read-only filesystems (e.g.,
#squashfs), as required for running from archival media (e.g., CD, DVD) or
#read-only flash hardware (e.g., routers).
#FIXME: Actually, *THIS WHOLE BLOODY IDEA IS NONSENSICAL*. No, really; look at
#the extreme, unwieldy, kludgy extents we go to to try to maintain the fiction
#of being able to run zeshy without compiling or caching to a directory. Look:
#it probably is feasible, but it sure as heck ain't worth it. There's
#effectively no benefit in it anyway. Consider the original use case: Gentoo
#installation. Great. Just pass "zeshy --dot-dir=\"${S}\" install_zeshy" in the
#ebuild. My God. It's absurdly simple. Of *COURSE* zeshy can write to its own
#directory, even under ebuild installation. *sigh* This is a clear case of
#losing the forest for the trees. So here's what we're gonna do:
#
#* Excise all of this nonsense. Grep the codebase for '-n "${ZY_DOT_DIR}"'
#  and unwind such foolishness.
#* Excise option "--no-zeshy-dot-dir" both above and in usage documentation.
#* If ${ZY_DOT_DIR} is *NOT* writable by the current user, throw an
#  exception *EARLY*. (We probably already do this; just make sure.)

# If passed the dot directory option, replace such default. If passed the non-
# dot directory option, this silently replaces such default with the empty
# string, thus disabling use of such directory.
if (( ${+arg_options[--zeshy-dot-dir]} )) {
    ZY_DOT_DIR="${arg_options[--zeshy-dot-dir]}"
# If the current user's ${HOME} is the root directory, the current user is
# either "cron" or a subsidiary thereof. In such case, default this directory to
# under "/var/".
} elif [[ "${HOME}" == '/' ]] {
    ZY_DOT_DIR='/var/cache/zeshy'
}

# User-specific top-level paths.
typeset -g\
    ZY_USER_CACHE_DIR="${ZY_DOT_DIR}/cache"\
    ZY_USER_CONFIG_DIRNAME="${ZY_DOT_DIR}/config"\
    ZY_USER_OVERLAY_DIR="${ZY_DOT_DIR}/src"

#FIXME: Rename ${ZY_USER_DIR_STACK_FILE} to ${ZY_USER_DIRSTACK_FILENAME}.

# User-specific cache paths.
typeset -g\
    ZY_USER_COMPLETION_STARTUP_FILE="${ZY_USER_CACHE_DIR}/completion_startup"\
    ZY_USER_COMPLETION_RESULTS_DIR="${ZY_USER_CACHE_DIR}/completion_results"\
    ZY_USER_DIGEST_ROOT_DIRNAME="${ZY_USER_CACHE_DIR}/digest"\
    ZY_USER_DIR_STACK_FILE="${ZY_USER_CACHE_DIR}/dir_stack"\
    ZY_USER_LOG_DIRNAME="${ZY_USER_CACHE_DIR}/log"

#FIXME: Excellent. For user sanity, we'll additionally want to ensure that all
#files of filetype ".log" in ${ZY_USER_LOG_DIRNAME} are rotated on becoming
#too large. Naturally, only a finite number of rotated logs for each logfile
#should be maintained (e.g., 8). This prevents logfiles from silently consuming
#all diskspace without user knowledge and is hence essential.

# User-specific log paths.
typeset -g\
    ZY_USER_LOG_EXCEPTION_FILENAME="${ZY_USER_LOG_DIRNAME}/exception.log"

#FIXME: Nonsense. Replace file this with a new dynamically defined function
#:set_zeshy_name_globals() internally defining the list globals currently
#serialized to this file (namely, ${ZY_ALIAS_NAMES},
#${ZY_FUNCTION_NAMES}, and ${ZY_FUNCTION_NAMES}). At the moment, we
#never actually *USE* this file for anything. We simply write to it in
#::precompile_zeshy_cache() and define its documentation as:
#
#declare_global_with_stdin string ZY_USER_NAMES_FILE <<'/---'
#Absolute path of the user-specific `zsh` script declaring and defining list
#globals containing the names of all `zeshy` aliases, functions, and globals.
#/---
#
#Ludicrous. (And not ludicrous speed, either. That would be good. This isn't.)
typeset -g ZY_USER_NAMES_FILE="${ZY_USER_CACHE_DIR}/names.zsh"

# ....................{ SOURCERS                           }....................
ZY__HELP_FUNCS+='
:full ::script_zsh.source(+:str filenames)

Source all passed `zeshy`-specific `zsh` scripts.

Since general-purpose sourcing of `zsh` scripts requires additional
functionality to ensure compliance with vanilla `zsh` options, this function
is private and intended _only_ for sourcing of `zeshy` scripts early in
`zeshy` startup.

== Globals ==

For each such script, this function sets the following string globals
intended for use within such script _before_ sourcing such script:

* ${ZY_SCRIPT_FILENAME}, the absolute path of such script.
* ${ZY_SCRIPT_DIRNAME}, the absolute path of such script''s directory.

== Failure ==

If any such script reports failure, then:

* If there exists an uncaught exception, the current call stack is silently
  unwinded. Since an uncaught exception exists, a stack trace describing such
  failure is already guaranteed to be printed; throwing another exception
  would only print another such trace, obscuring the original documenting the
  underlying issue. (Less is more.)
* Else, an exception is thrown.
'
function ::script_zsh.source() {
    ::script_zsh.source_or_fail "${@}" || {
        # If an uncaught exception exists, unwind the call stack. (See above.)
        if (( ${+CAUGHT} )) {
            :call_stack.unwind
        # Else if the absolute path of the responsible script exists, throw an
        # exception containing such path.
        } elif (( ${+ZY_SCRIPT_FILENAME} )) {
            :die 'Script "'${ZY_SCRIPT_FILENAME}'" failed.'
        # Else, throw an ambiguous exception.
        } else {
            :die 'Unknown script failed.'
        }
    }
}


ZY__HELP_FUNCS+='
:full ::script_zsh.source_or_fail(+:str filenames)

Source all passed `zeshy` scripts, reporting failure on the first such script
to either not exist _or_ report failure or reporting success otherwise
(i.e., if all such scripts both exist _and_ report success).

== Motivation ==

The source() builtin currently appears to fail to signal `TRAPZERR` and hence
induce exceptions on script failures, possibly due to such builtin reporting
exit status of 126 on such failures. Until the underlying issue is resolved,
this function implements a suitable short-term solution.
'
function ::script_zsh.source_or_fail() {
    (( # )) || :die 'Expected one or more script filenames.'
    local -a filename_canonical

    # Source these scripts.
    local filename
    for   filename ("${@}") {
        # If this script is not found, attempt to find such script.
        [[ -e ${filename} ]] || {
            # If this script is relative rather than absolute...
            if [[ ${filename[1]} != '/' ]] {
                # If string global ${ZY_SCRIPT_DIRNAME} is defined
                # (hopefully implying the current script to have been sourced
                # by this function), attempt to find such script under the
                # directory containing the current script.
                if (( ${+ZY_SCRIPT_DIRNAME} )) {
                    filename=${ZY_SCRIPT_DIRNAME}'/'${filename}
                # Else, print a non-fatal warning. (This should *NEVER* be the
                # case, but hardly constitutes a fatal error.)
                } else {
                    :warning.output\
                        'Script path "'${filename}'" not absolute.'
                }
            }

            # If this script is still not found, suffix its filename by ".zy"
            # if not already suffixed by a filetype.
            [[ -e ${filename} ]] || {
                # If not already suffixed by a filetype, do so.
                [[ -n ${filename:e} ]] || filename+='.zy'

                # If such script is still not found, throw an exception.
                [[ -e ${filename} ]] ||
                    :die 'Script "'${filename}'" not found.'
            }
        }

        # If this script is *NOT* a file, throw an exception. The source()
        # builtin reports failure if this script does not exist but *NOT* if
        # this script is a directory rather a file -- despite the fact that
        # that builtin only accepts files.
        [[ -f ${filename} ]] || :die 'Script "'${filename}'" not a file.'

        # Absolute path of this script and this script's parent directory,
        # globalized for script use.
        ZY_SCRIPT_FILENAME=${filename}
        ZY_SCRIPT_DIRNAME=${filename:h}

        # Source this script.
        :stdout.echo_if_debug 'Sourcing "'${filename}'".'
        builtin source -- "${filename}" || return ${?}
    }
}

# ....................{ LOAD                               }....................
#FIXME: Right. The thing is, "bin/zeshy" should pass option "NO_RCS" to *ANY*
#zsh interpreter it runs, including the zsh interpreter implicitly run due to
#the shebang line. (If need be, we can guarantee this by making "bin/zeshy" a
#Bourne shell script running the true zsh script "bin/zeshy.zsh" with option
#"NO_RCS"). In such case, zeshy will only ever be genuinely loaded once,
#obviating any need for global ${ZY_PID_LAST_LOADED_BY} and the related
#contortions both below and in "/bin/zeshy". In truth, this will probably have
#to wait until we rewrite "/bin/zeshy" as a C driver.
#FIXME: O.K.; we've refactored "/bin/zeshy" to *ALWAYS* pass "-o no_rcs" to the
#zsh interpreter, implying we *SHOULD* theoretically be able to excise
#${ZY_PID_LAST_LOADED_BY} and related logic below. Do so, then test such
#revisions by restarting zeshy as both root and non-root users.

# If sourcing the current script under zsh startup logic (e.g., from a zsh
# script with basename matching either ".zlogin", ".zprofile", or ".zshrc"),
# prevent zsh from reloading zeshy if already loaded earlier during such logic.
#
# Ideally, the current script should only ever be sourced by the "zeshy" script
# installed with zeshy. Ideally, zsh startup logic should avoid sourcing the
# current script. Since zeshy is valid zsh, however, this script is sourceable
# as is by any zsh script or shell -- including zsh startup scripts. In such a
# case, failing to prevent zsh from reloading zeshy induces the following:
#
# * Some process runs the "zeshy" script as a new child process.
# * This process runs under "zsh" due to such script's shebang line.
# * This process sources at least ".zshrc" and possibly also ".zlogin" and
#   ".zprofile", depending on runtime context.
# * Sourcing such script could source the current script, loading zeshy.
# * After sourcing the current script, control returns to the "zeshy" script,
#   which either:
#   * Sources the current script, reloading zeshy.
#   * Replaces this process with a new process running "zsh" passed the current
#     script as its first argument and hence reloading zeshy twice:
#     * Once by zsh startup logic, as above.
#     * Once by the first argument passed to such script.
#
# In either case, zsh loads zeshy at least twice and possibly more. Avoid this!
#print "zeshy: argv[0]=$0}"
#print "zeshy: command line=$(< /proc/$$/cmdline)"
#print "zeshy: process ID (current)=$$"
#print "zeshy: process ID (parent!)=${PPID}"
#print "zeshy: process ID (cached.)=${ZY_PID_LAST_LOADED_BY-}"
#print "zeshy: passed option names=${(k)arg_options}"

typeset -gi ZY_PID_LAST_LOADED_BY

# If the caller requests not reloading zeshy when previously loaded under the
# current shell and zeshy has indeed already been loaded, do not do so again.
if (( ZY_PID_LAST_LOADED_BY == $$ )) {
    # If the following core function is undefined, zeshy cannot have been
    # previously loaded for the current shell. But the current conditional
    # implies zeshy was previously loaded for such shell! This contradiction can
    # only mean one thing: throw an exception.
    typeset -f :is_version_at_least &>/dev/null ||
        :die 'zeshy unexpectedly unloaded (i.e., zeshy last loaded by current process '$$', but zeshy function :is_version_at_least() undefined).'
# Else, zeshy has not yet been loaded. Do so! Specifically:
#
# * If such shell is a login shell, establish sensible login shell settings.
#   See set_shell_login_defaults() for further details.
# * Source all zeshy configuration files.
# * If no zeshy digest file has been compiled or such file requires
#   recompilation (e.g., due to upgrading zeshy, editing zeshy configuration
#   files, or installing new command or uninstalling old commands from the
#   current ${PATH}), recompile such digest.
# * Prepend such digest to the current ${FPATH}, thus effectively loading all
#   zeshy functions. For efficiency, the zsh autoload system delays defining
#   these functions until the first call to such functions.
# * Perform all zeshy startup tasks, including:
#   * Defining all zeshy aliases and globals.
#   * Calling all user-defined startup hooks.
} else {
    # If the current shell is a login shell, set login-specific behavior.
    if [[ -o login ]] {
        ::script_zsh.source\
            ${ZY_BOOTSTRAP_DIRNAME}'/if_login/login'
    }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # While such autoload *DOES* render all compiled zeshy functions
    # immediately callable, calling most such functions (e.g., print_message())
    # is inherently unsafe as zeshy has yet to be started up and hence to
    # define globals referenced by such functions.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Autoload zeshy's user digest file, recompiling such file if needed.
    ::script_zsh.source ${ZY_BOOTSTRAP_DIRNAME}'/digest'

    #FIXME: Sadly, the following appears to no longer work as advertised, as
    #this file is now sourced from a function context by ".zshrc". Since such
    #logic is somewhat expensive *AND* appears to be inducing other subtle
    #errors on initial startup, we've disabled it for now. However, we'll
    #eventually need to add it back. Or perhaps not? Right. Not. It's *WAY* too
    #fragile (and probably can't be coerced back anyway, given the function
    #context issue). So what do we do? Simple. We improve the logic that
    #dynamically defines ::startup_zeshy_globals() to ensure that *ALL*
    #declarations of read-only globals are prefixed by a command undclearing
    #such globals: e.g.,
    #
    #     typeset +r -- "${readonly_global_name}"
    #     unset      -- "${readonly_global_name}"
    #
    #Arguably, that's what we should have done originally in the first place.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # This *MUST* be performed from a global rather than function context.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Undefine all globals defined by such recompilation. The reasons are subtle but
    # the logic flows like butter. zeshy may (and often does) declare globals to be
    # read-only. Sadly, zsh fails on attempting to redefine read-only globals. Since
    # the subsequent call to startup_zeshy() and hence startup_zeshy_globals() does
    # just that, undefine zeshy-specific globals prior to such calls. Do so in the
    # root global context (i.e., in this component outside of functions) to
    # guarantee expected behavior. "'tis all a tad silly and worm-bitten, but such
    # is life in the tranche of code trenches."
    #
    # Since zsh never fails on redefining aliases or functions, do not bother
    # undefining either. We could, but there's little point (or profit) in it.
    #
    # Unfortunately, the above sourcing exposes function but *NOT* alias
    # declarations. Since undefine_variable_from<> is an alias, manually
    # implement the following:
    #
    #     # Must be "*" rather than "@".
    #     >>> :List.is_nonempty ZY_GLOBAL_NAMES and
    #     ...     undefine_variable_from "${ZY_GLOBAL_NAMES[*]}"
    :stdout.echo_if_debug 'Starting up.'
    # print "dir stack [main/before]: ${ZY_USER_DIR_STACK_FILE}"
    # if [[ -n "${ZY_GLOBAL_NAMES-}" ]] {
    #     typeset +r -- "${ZY_GLOBAL_NAMES[@]}"
    #     unset      -- "${ZY_GLOBAL_NAMES[@]}"
    # }

    # Startup zeshy, having recompiled zeshy's user digest file above and hence
    # defined all autoloads applicable to such user.
    startup_zeshy
    # print "dir stack [main/after]: ${ZY_USER_DIR_STACK_FILE}"
    :stdout.echo_if_debug 'Started up.'

    # Ensure this conditional evaluates to true on the next attempt to load
    # zeshy under the current shell by setting such process ID to that of this
    # shell after successfully loading zeshy. (The "after" is key here!)
    ZY_PID_LAST_LOADED_BY=${$}
}

#FIXME: Unset such globals at the same place that we undefine the corresponding
#setter functions. Since the former *MUST* happen here, that suggests we should
#shift the latter here.

# Undefine documentation-specific maps defined at the top of this script. As the
# prior conditional calling load_zeshy() calling :compile_zeshy() has already
# serialized such maps onto on-disk key value stores, such maps are no longer
# needed. As such maps consume non-trivial resources (typically 8MB to 16MB of
# memory), safely delete such maps here after their serialization to disk above.
unset --\
    ZY_ALIAS_NAME_TO_HELP\
    ZY_FUNCTION_NAME_TO_HELP\
    ZY_GLOBAL_NAME_TO_HELP

# ....................{ OPTIONS ~ last                     }....................
# If at least one command-line option was passed, handle all remaining options
# *AFTER* both autoloading and starting up zeshy.
if (( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) {
    # Handle help options *BEFORE* all other remaining options, which
    # immediately return if passed and hence assume priority. If passed, ignore
    # all other options and if:
    #
    # * The above option parsing failed as signified by option value "failed",
    #   print usage help to standard error and return with non-zero exit status.
    # * Else, print help to standard output and return with zero exit status.
    if (( ${+arg_options[--help]} )) {
        if [[ ${arg_options[--help]} == 'failed' ]] {
            print_zeshy_help_usage 1>&2
            :die 'Passed invalid or unknown options.'
        } else {
            print_zeshy_help_usage
            return 0
        }
    }

    # If passed a version option, behave similarly to above.
    if (( ${+arg_options[--version]} )) {
        print_zeshy_version
        return 0
    }

    # Set all passed options *BEFORE* running the passed commands, ensuring such
    # commands run under such options rather than the default zeshy environment.
    # Iterate list elements in pairs ignoring the first such element, as below.
    local placeholder arg_shell_option
    for   placeholder arg_shell_option ("${arg_shell_options[@]}") {
    #   print "zeshy: passed option \"${arg_shell_option}\""
        setopt "${arg_shell_option}"
    }

    # Run all passed commands. Since every other element parsed into such list
    # is either "-c" or "--command" and hence ignorable, iterate elements in
    # pairs ignoring the first such element.
    local placeholder arg_shell_command
    for   placeholder arg_shell_command ("${arg_shell_commands[@]}") {
    #   print "zeshy: passed command \"${arg_shell_command}\""
        run_code "${arg_shell_command}"
    }
}

# ....................{ PROFILING ~ end                    }....................
# If debugging zeshy, print a human-readable synopsis of zeshy startup time. For
# accuracy, minimize shell overhead by:
#
# * Printing such synopsis as a single statement.
# * Avoiding calling zeshy-specific functions to do so.
:line.run_if_debug printf "zeshy: Startup in %.4f seconds (wall clock)."$'\n' $(( EPOCHREALTIME - ZY_TIME_START ))

# ....................{ ARGUMENTS                          }....................
# If the caller passed at least one nonempty non-option argument (i.e., an
# argument neither prefixed by "-" or expanding to the empty string), source the
# first such argument as the path of a zeshy script and pass such script all
# remaining such arguments. To avoid unfairly budgeting the time spent sourcing
# such script to zeshy startup, do so *AFTER* printing zeshy's startup time.
if [[ -n ${*} ]] {
#   :stdout.echo_if_debug "zeshy: sourcing \"${@}\"..."

    #FIXME: The output is still subpar. We *REALLY* just want to slightly tweak
    #output_call_stack() so that such function omits the first element on the
    #stack if such element is the absolute path of this "main" script. Very
    #simple. Just need to do it, as ever! Then, remove the "or die..." below.

    # If such script fails, print a human-readable exception. Failing to do so
    # results in unreadable errors resembling:
    #
    # >>> ~/tmp/tmp.zeshy
    # /home/leycec/zsh/zeshy/src/main() failed with exit status 1
    #  "~/tmp/tmp.zeshy" { /home/leycec/zsh/zeshy/src/main: 1398 }
    #   "/home/leycec/zsh/zeshy/src/main" { /usr/local/bin/zeshy: 206 }
    ::script_zsh.source "${@}" ||
        :die 'Script "'${*}'" failed with exit status '${status}'.'
}

# ....................{ MAIN                               }....................
# Avoid implicitly returning with non-zero exit status, as occurs when the prior
# statement is a conditional evaluating to false.
#print 'returning zsh!'
return 0
