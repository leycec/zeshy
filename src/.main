#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "LICENSE" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Main entry point into zeshy. This zsh script bootstraps zeshy into the current
# shell environment by conditionally compiling the subset of the zeshy codebase
# specific to the current system and user into a zsh digest file and autoloading
# such file.

#FIXME: We've made a vital err, though it's none too late to rectify. It's
#quite simple: while the present verb-noun nomenclature does promote
#readability, it also significantly hinders queryability and hence writability.
#Since the latter is arguably much more significant than the former (given the
#already inherent difficulty of writing versus merely reading working code), we
#*SHOULD* have optimized our nomenclature for writability rather than
#readability. Sadly, we didn't. Given that we've yet to formally publish,
#however, time yet remains to correct this callous misstep. How? Simple.
#
#Adopt noun-verb nomenclature, delimiting the two with conventional
#object-oriented dot syntax. In zeshy's case, such dot signifies conventional
#static functions, but the intent is similar. For example:
#
#    # Instead of this nomenclature...
#    :die_unless_var_string "${string_name__sn}"
#    :is_string_empty "${(P)string_name__sn}"
#    :set_string_to_string "${string_name__sn}" oboy
#
#    # ...we really wanted *THIS* nomenclature.
#    :var:die_unless_string "${string_name__sn}"
#    :string.is_empty "${(P)string_name__sn}"
#    :string:set "${string_name__sn}" oboy
#
#    # ...we really wanted *THIS* nomenclature.
#    :var.die_unless_string "${string_name__sn}"
#    :string:is_empty "${(P)string_name__sn}"
#    :string.set "${string_name__sn}" oboy
#
#Pretty simple. Note the latter nomenclature also solves a hitherto unresolved
#issue we'd simply ignored until now: how best to lexically disambiguate
#runnables requiring the first argument be a variable *NAME* from those
#requiring such argument be a variable *VALUE*. Given dot-delimited syntax,
#however, the answer is simple:
#
#* Delimit runnable names requiring the first argument be a variable name by
#  "." (e.g., ":string."), conveniently coinciding with similar "."-delimited
#  runnable prototype argument type syntax (e.g., ":string.string", signifying
#  a string argument referring to another string variable) as well as with
#  conventional object-oriented syntax.
#* Delimit runnable names requiring the first argument be a variable value by
#  ":" (e.g., ":string:"), conveniently coinciding with conventional use of ":"
#  to denote static function calls in conventional high-level languages.
#FIXME: The above implies we'll need to adjust function prototype argument type
#syntax from ":string:int" to ":string.int". For clarity, this is essential.
#FIXME: Hmm; that's still not *QUITE* right, however. Consider existing
#function :set_string_to_path_basename(). What's the noun here? Ideally "path",
#right? But that gives us :path.set_string_to_basename(), which doesn't quite
#read sensibly. After all, that would imply the first argument to be a string
#path; but that's actually the *SECOND* argument to such function. So, we need
#a slight rethink. How about:
#
#* :string.set_to_path_basename(). (Complies with above, but obstructs
#  queryability. We want to group all path-related functions together.)
#* :path:string.set_to_basename(). (Ugh. Also sort of complies with above, but
#  implies a different argument order than such function accepts. Or perhaps we
#  then need to simply have such function accept arguments in the inverse
#  order? Hmmm; yes, perhaps that's best. Contemplate a bit more.)
#
#Assuming we adopt the latter, we'd then prototype such function as:
#
#    :void :path:string.set_to_basename(
#        :string_path   path_name,
#        :string.string string_name)
#
#A bit odd, certainly, but not *TOO* terribly far beyond the pale. The dominant
#noun here is "path", so this does actually seem quite a bit better than the
#current approach.
#FIXME: To best achieve such restructuring, we'll probably have to wait until
#*AFTER* we complete a working implementation of global file contents
#search-and-replacement. Given that, we then write a script in which we print a
#newline-delimited list of all function names; in another script, take
#reasonably small subsets of such list (say, only 10 function names at a
#time), and rename such group of functions all at once. Then, try reloading
#zeshy. For stability and sanity reasons, we really want to minimize the number
#of concurrent renames performed at one time: e.g.,
#
#    :dir:replace_file_text_matching_glob_by_text_recursively\
#        /home/leycec/zsh/zeshy/src\
#        ':set_string_to_path_basename' ':path:string.set_to_basename'\
#        ':is_path' ':path:is'\
#        ':is_file' ':file:is'\
#        ':is_dir'  ':dir:is'
#FIXME: Actually, since ksh uses "!" for redirection syntax *AND* such zsh has
#long intended to support such syntax, perhaps we should leverage "!" rather
#than ".", above, which then frees up "." for conventional use: e.g.,
#
#    # Rather than this nomenclature...
#    :void :path:string.set_to_basename(
#        :string_path   path_name,
#        :string.string string_name)
#
#    # ...how about this nomenclature?
#    :void :path.string!set_to_basename(
#        :string_path   path_name,
#        :string!string string_name)
#
#Oh, nevermind. While that *DOES* read a bit better, it also doesn't work, due
#to "!" already being reserved for history expansion. Right. Then, we must ask
#ourselves, what sort of operations are more likely: those operating on
#variable names or those operating on string values? Presumably, the latter.
#
#Honestly, the nomenclature below does seem to read better than that above:
#
#    # Rather than this nomenclature...
#    :void :path:string.set_to_basename(
#        :string_path   path_name,
#        :string.string string_name)
#
#    # ...how about this nomenclature?
#    :void :path.string:set_to_basename(
#        :string_path   path_name,
#        :string:string string_name)
#
#Let's just ignore conventional high-level language syntax. Both zsh and zeshy
#are anything but conventional; so, there's little pragmatic incentive to
#trying to hew to conventional syntactic precedent. Instead, we want to hew to
#what intuitively reads better: and that's plainly the latter approach above:
#:path.string:set_to_basename(). Why? Three simple reasons:
#
#* The "." delimiter is a much stronger visual delimiter than the ":"
#  delimiter, which serves more as a conjoiner than delimiter. Hence, "."
#  rather than ":" should be used as the principal namespace delimiter.
#* Moreover, ":" implies something that "." doesn't: assignment, coinciding
#  exactly with such usage above.
#* Such approach preserves existing ":string:string" argument type syntax,
#  which is nice. ":string.string" reads *MUCH* more awkwardly, seeming to
#  imply such argument to somehow be a string embedded within a string object.
#
#O.K.; we're moderately convinced. :path.string:set_to_basename() appears to
#really be the right approach here. Go, go! This then gives us:
#
#    :dir:replace_file_text_matching_glob_by_text_recursively\
#        /home/leycec/zsh/zeshy/src\
#        ':set_string_to_path_basename' ':path.string:set_to_basename'\
#        ':is_path' ':path.is'\
#        ':is_file' ':file.is'\
#        ':is_dir'  ':dir.is'
#
#Yup. That's convinced us. Significantly better readability. Hey, lo: let's sow!

#FIXME: Given short form while, case, etc. statements, there's no longer a need
#for long form-specific reserved words. I believe the full set of such words is,
#according to section "RESERVED WORDS" of "man zshmisc": "esac", "do", "done",
#"fi", and "end". To minimize the number of reserved words, disable such
#reservation as follows:
#
#   disable -r 'do' 'done' 'end' 'esac' 'fi'
#
#Note that we'll probably need to temporarily re-enable such words when sourcing
#exogenous zsh shell scripts. Replacing "disable" with "enable" above should do it.

#FIXME: It'd be nice, though hardly necessary, to define a new
#command_not_found_handler() function throwing a well-formatted exception. Per
#zsh documentation:
#
#    "If  no external command is found but a function command_not_found_handler exists the
#     shell executes this function with all command line arguments.  The  function  should
#     return  status zero if it successfully handled the command, or non-zero status if it
#     failed.  In the latter case the standard handling is applied: `command not found' is
#     printed  to  standard error and the shell exits with status 127."

#FIXME: When "zsh" is upgraded while zeshy is running, things go downhill pretty
#quickly until such zeshy sessions are restarted. For example, if no exception
#has yet been thrown and hence functions throw() and catch() not autoloaded,
#then the next fatal error will trigger unhelpful zsh errors resembling
#"zsh: throw: command not found". It'd be quite nice to detect such upgrade and:
#
#* For each running interactive zeshy shell, implicitly restart such shell on
#  the next prompt display (i.e., after completing the current command).
#* For each running non-interactive zeshy shell, well... there's probably not
#  much we can efficiently do. Hopefully, such shell completes quickly!
#FIXME: It'd be nice to profile zeshy a bit to see what's consuming the most
#time. (I suspect the single "autoload -w" statement loading the digest, but
#one never knows, really.) Perhaps add a new "--profile-zeshy-startup" option.
#FIXME: It'd be *GREAT* to optimize release builds by stripping all comments
#from components -- particularly for top-level components sourced over and over.
#Unfortunately, we basically need a zsh parser to do so reliably; also, note
#that the license-specific comments must *NOT* be deleted. (Though, presumably
#one could delete all comments indiscriminantly and then manually prepend back
#the canonical license comments.) Hmm; a bit odd, but zsh introduces the
#following parameter expansion flag: "${(Z:C:)string_name}". Basically, "Z" is
#the bigger brother of "z" splitting strings on shell words. To quote the
#release notes, "(Z:C:) parses comments and strips them". At also strips
#extraneous unquoted whitespace, which also seems desirable. So... this seems
#like a hell of a long shot, but couldn't we just:
#
#* Load the file to be stripped into a local string variable.
#* Strip comments from such variable with "${(Z:C)...}", implicitly also
#  converting such string into a list.
#* Convert such list back into a string with a simple
#  "join_list_on_newline script_lines", or some such.
#* Serialize out the resulting string. Would it actually work? I have no idea.
#  But the following command-line test run looks *REALLY* promising:
#
#    >>> string m; m="$(< main)"
#    >>> print "${(Z:C:)m}" | less
#
#  Wow! The output looks perfectly safe for sourcing. It does include redundant
#  substrings of semicolons (e.g., "; ; ; ; ; ; ; ;"), but that at least is
#  easily globally substituted out. To truly test this, we'll want to take
#  something that's genuinely zsh with no extraneous zeshy -- say
#  "/usr/share/zsh/5.0.0/functions/v Completion/Unix/_git", the largest such
#  autoloadable function. If this works on *THAT* file, it probably works
#  anywhere. Worth a shot, anyway, due to the simplicity of the implementation.
#  zsh does all the heavy lifting here, as is sensible and gentlemanly.

# ....................{ WELCOME                            }....................
#FIXME: This is a horrible hack. Make this go away as soon as we stop exporting.
#FIXME: Hmm; while we no longer export, it's unclear whether this *IS* a hack.
#Increasingly, such operation appears requisite and hence must *NOT* be
#excised. (Probably, anyway.) Document why this is the case.

# Undefine all zeshy-specific globals (i.e., prefixed by "ZESHY_").
unset -m 'ZESHY_*'

# ....................{ PROFILING                          }....................
# Set the current time since the Unix epoch *BEFORE* all subsequent operations
# to ensure reasonable profiling results.

# Load module "datetime", providing timing-related globals expanded below. Defer
# loading all other modules *AFTER* initiating such timing to improve fidelity.
zmodload zsh/datetime

# Time in partial seconds since the Unix epoch at which zeshy was first loaded
# (i.e., at which the current script was first sourced).
float ZESHY_TIME_START="${EPOCHREALTIME}"

# ....................{ OUTPUTTERS                         }....................
# For safety, define such runnable as an alias rather than function. While both
# are undefinable (either accidentally or maliciously), the former is expanded
# at function definition rather than call time and hence guaranteed to exist
# for all functions defined below.

# [stderr = :string] :warning.output(:string warning_message)
alias :warning.output='{
    print -r -- "zeshy: $(< /dev/stdin)" 1>&2
} <<<'

# ....................{ DOCUMENTATION                      }....................
#FIXME: In reflection, attempting to formally document all objects defined by
#top-level parcels by appending to lists ${ZESHY_CORE_HELP_*} is a fundamentally
#bad idea for several obvious reasons:
#
#* Mandatory slowdown serving no purpose on every zeshy invocation. (Bad!)
#* Requires subsequent reintegration during zeshy precompilation with the "real"
#  documentation subsystem established by @{00-declare}.
#
#And probably more reasons. Excise all lists ${ZESHY_CORE_HELP_*} and shift all
#such documentation to a new parcel @{always/00-core/05-help} structured as:
#
#    always/00-core/05-help/
#        main
#        login
#        digest
#        compile
#
#In other words such directory contains one parcel for each top-level parcel of
#the same name, documenting all objects in such parcel. Simple. Efficient. Go!

# Lists of alias, function, and global documentation specific to top-level zeshy
# components (e.g., "main", "compile"). Each list element is a help string
# documenting some alias, function, or global defined by such a component. Avoid
# documenting such lists formally, which we delete below to conserve space.
local -a\
    ZESHY_CORE_HELP_ALIASES\
    ZESHY_CORE_HELP_FUNCTIONS\
    ZESHY_CORE_HELP_GLOBALS

# ....................{ GLOBALS                            }....................
typeset -g ZESHY_VERSION='0.1.0'

# If the major version of the current zsh interpreter is less than 5, such
# interpreter is older than zeshy requires. In such case, print an error message
# to standard error and fail. If the current shell is interactive, avoid exiting
# such shell (and hence hiding such message) by returning instead.
#
# Note that there exist various methods of comparing version specifiers, with
# the customary tradeoffs in complexity versus efficiency. In particular, zsh
# defines the autoloadable script "is-at-least" and zeshy the function
# :is_version_at_least(). While either does reliably compare arbitrary version
# specifiers, the former requires sourcing an external script iterating with
# doubly nested "while" loops and the latter embedding a nearly 200-line
# function in the root script sourced on every zeshy startup.
#
# Fortunately, the following simpler method presents itself.
if [[ "${ZSH_VERSION}" == <0-4>.* ]] {
    :warning.output\
        "zsh ${ZSH_VERSION} detected but zsh 5.0.0 or newer required."
    return 1
}

#FIXME: Ugh. Untrue, actually.

# Prohibit duplicate paths in canonical path list globals (e.g., ${path}).
# Since ${path} in particular is central to sane operation, do so prior to
# subsequent logic.
#
# If the current script was *NOT* transitively sourced from a function (i.e.,
# if such script was sourced only from the top level of other zsh scripts or
# directly from the command line), prohibiting such paths reduces to a single
# call to typeset(). Unfortunately, if the current script was transitively
# sourced from a function, the same call also silently erases such lists.
# (Which is bad.)
#
# In the latter case, avoid such erasure by explicitly copying the
# corresponding string globals to temporary string locals *BEFORE* calling
# typeset(). (While list rather than string globals could also be preserved,
# string copies are moderately more efficient than list copies.)
if (( ${zsh_eval_context[(ie)shfunc]} <= ${#zsh_eval_context} )) {
    # String locals preserving such string and hence list globals.
    local -a PATH_OLD CDPATH_OLD FPATH_OLD MANPATH_OLD
    PATH_OLD=${PATH}
    CDPATH_OLD=${CDPATH}
    FPATH_OLD=${FPATH}
    MANPATH_OLD=${MANPATH}

    # Prohibit duplicate paths in such list globals. Since such declaration
    # occurs in a function context, explicitly globalize such variables to
    # avoid their implicit localization.
    typeset -gU path cdpath fpath manpath

    # Restore such string and hence list globals.
    PATH=${PATH_OLD}
    CDPATH=${CDPATH_OLD}
    FPATH=${FPATH_OLD}
    MANPATH=${MANPATH_OLD}

    # Undefine such string locals.
    unset PATH_OLD CDPATH_OLD FPATH_OLD MANPATH_OLD
# Else, a single call to typeset() suffices.
} else {
    typeset -U path cdpath fpath manpath
}
# print "path: ${PATH}"

# ....................{ OPTIONS                            }....................
# Set the following shell options under *ALL* zeshy sessions.
#
# * File globbing:
#   * "brace_ccl", parsing brace expansions *NOT* of the form "{x,y,z}",
#     "{n1..n2}", or "{n1..n2..n3}" as ASCII character classes (e.g., "{0-9}",
#     expanding to whitespace-delimited digits 0 through 9).
#   * "extended_glob", parsing "#", "~", and "^" as extended globbing
#     modifiers.
#   * "glob_dots", permitting "."-prefixed pathnames to be globbed by globs
#     *NOT* explicitly prefixed by "." (e.g., "*").
#   * "no_case_glob", globbing case-insensitively.
#   * "no_equals", preventing "="-prefixed unquoted shell words from being
#     expanded to the absolute path of the command following such prefix.  Such
#     syntax obstructs unquoted shell word usage for little to no benefit.
#     Specifically:
#     * Such syntax fails to report failure if such command does *NOT* exist.
#     * Builtin which() and history modifier ":c" already provide the same
#       functionality, the former correctly reporting failure if such command
#       does *NOT* exist.
#   * "numeric_glob_sort", sorting globbed numeric filenames (i.e., globbed
#     filenames containing at least one run of two or more digits) numerically
#     rather than lexicographically.
setopt\
    brace_ccl\
    extended_glob\
    glob_dots\
    no_case_glob\
    no_equals\
    numeric_glob_sort\

#FIXME: For efficiency, compress *ALL* of the following discrete calls to
#setopt() into the prior single massive call to such builtin.
#FIXME: We almost certainly set several options already enabled by default. This
#isn't simply inefficient: it's fairly harmful, as it obstructs a clear
#understanding of how "far" zeshy differs from default zsh. Indeed, the number
#of options set in such single call to setopt() is a useful proxy for the number
#of differences between zeshy and stock zsh.
#
#Is there a way to determine the minimum set of options differing between the
#two? Yes! When called without arguments, setopt() has been implemented in a
#fairly clever fashion to *ONLY* output those options differing from zsh
#defaults, providing a simple means of determining what should be set below.
#FIXME: Note that, between "bin/zeshy" and "src/.zshrc", the following options
#are guaranteed to always be set here:
#
#* "no_unset", reporting failure on attempts to expand undefined variables.
#* "warn_create_global", warning on attempts to set undeclared variables.
#
#Hence, don't bother reenabling such options.

# Enforce strictness, as under conventional high-level languages.
setopt no_unset           # exception on attempting to expand unset parameters
setopt warn_create_global # warning on attempting to set undeclared parameters
setopt no_err_exit        # zeshy implements more robust error handling
setopt no_err_return      # zeshy implements more robust error handling

# Variable assignment.
setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"
setopt no_ksh_typeset     # perform word splitting on variable assignment

# Avoid printing previously assigned variables when calling typeset() with
# variables with no new assignments (e.g., "typeset specular_reflection").
setopt typeset_silent

# Variable expansion.
setopt c_bases           # print non-base 10 integers in C format (e.g., "0x33")

# Shell parsing.
setopt no_ksh_arrays      # enable 1-based lists subscriptable without braces
setopt no_ksh_autoload    # treat autoloaded files as function definitions
setopt magic_equal_subst  # enable filename expansion on "="-prefixed strings
setopt short_loops        # enable "for ... (...) { ... }"-style shell constructs

# Shell quoting.
setopt no_csh_junkie_quotes  # allow unescaped newlines in quotes
setopt no_sh_word_split  # do not field split unquoted parameters
setopt rc_quotes         # parse '' as ' in single quotes (e.g., '''' == "'")

# Command execution.
setopt no_print_exit_value  # do not print "zsh: exit $?" on command failure

# Report failure on *ANY* pipeline element failing. By default, zsh only
# reports failure on the rightmost pipeline element failing, obscuring failure
# reported by all preceding elements.
setopt pipe_fail

# Track and hence print line numbers for eval() expressions relative to the
# environment enclosing such eval() rather than such expressions themselves. The
# latter, which remains the zsh default, produces largely unreadable errors.
setopt no_eval_lineno

# Command history.
setopt hist_fcntl_lock   # prefer fcntl()- to ad hoc-based history file locking
setopt hist_lex_words    # ensure accurate parsing of commands saved to disk
setopt hist_no_store     # do not add history-specific command lines
setopt hist_reduce_blanks # reduce extraneous whitespace in history items
setopt hist_subst_pattern # permit extended globbing with ":s" and ":&"

# When adding history items, also remove all older duplicates of such items.
setopt hist_ignore_all_dups

# Do not add whitespace-prefixed command lines to the history.
setopt hist_ignore_space

# Reload command lines performing history expansion into the editing buffer
# rather than executing such lines immediately.
setopt hist_verify

# Append history items to the history file as such items are entered rather than
# when the shell exits, for safety. This also has a pleasant side effect of
# sharing the history file between multiple shell sessions.
setopt inc_append_history

# Path changing.
setopt auto_cd           # automatically "cd" to directories in command position
setopt auto_pushd        # automatically "pushd" directories onto the dirstack
setopt pushd_ignore_dups # do not push duplicate directories onto the dirstack
setopt pushd_silent      # run "pushd" and "popd" silently

# Avoid interactively confirming star-style path removal (e.g., "rm *"). While
# nice, zeshy already interactively confirms *ALL* attempted path removals.
# Since zeshy's default behavior is arguably safer than zsh's, avoid redundant
# confirmations of such removal.
setopt rm_star_silent

# Silently reduce non-matching globs to the empty string rather than printing an
# error message. While the latter appears preferable, zsh fails to also:
#
# * Signal ZERR and hence call TRAPZERR() on non-matching globs, thus failing to
#   throw exceptions or print stack traces on glob failure.
# * Permit the printed error message to be customized. The error messages zsh
#   prints are largely unhelpful for non-interactive scripts (e.g.,
#   "zsh: no matches found: Tomoe(:A)"), offering no human-readable context for
#   script debugging or development.
#
# Hence, we reluctantly disable errors on non-matching globs. zeshy scripts and
# functions must test for glob failure by testing list emptiness. With practice,
# this should (!) become second nature: e.g.,
#
#     >>> list glob_match; glob_match=( "PiKHAL/TiKHAL"(:A) )
#     >>> is_nonempty "${glob_match}" or die "\"PiKHAL/TiKHAL\" not found"
setopt null_glob

# File writing.
setopt no_clobber        # forbid ">" from truncating existing files

# PCRE matching.
#
# This enables Perl-Compatible Regular Expression (PCRE) matching via the "=~"
# test operator, by implicitly loading the "zsh/pcre" module when requested.
# This module matches the entire match into "${MATCH}" and each group match
# into array elements of "${match[@]}" where the first match is "${match[1]}".
# For additional documentation on the "zsh/pcre" module, see:
# http://zsh.sourceforge.net/Doc/Release/zsh-Modules.html#SEC192
#
# Note that traditional glob matching is always available via the "==" test
# operator: e.g.,
#     [[ $(whence -cp fahey) == *" not found" ]] && echo "Farewell."
setopt rematch_pcre      # prefer Perl-Compatible Regular Expression matching

# Process control.
setopt long_list_jobs    # list jobs in long format

# Shell I/O.
setopt no_flow_control   # disable interactive flow control (e.g., ^S, ^Q)
setopt ignore_eof        # do not treat ^D as "exit", interactively
setopt interactive_comments  # enable "#" comments in interactive commands
setopt print_eight_bit   # enable 8-bit output for completion lists

# Shell prompt.
#
# Enable variable substitution in prompt definitions. This dynamically re-
# expands each prompt definition and variables referenced in that definition
# immediately prior to displaying that prompt; by default, on the other hand,
# zsh statically caches the expansion of each prompt definition for quick re-
# use when displaying those prompts. (While marginally faster, the latter is
# remarkably less useful as it requires redefining and exporting a prompt to
# alter the display of that prompt.)
setopt prompt_subst

# Tab completion.
setopt auto_menu         # use menu completion after two tabs
setopt complete_in_word  # complete inside words
setopt no_list_ambiguous # only list matches if ambiguous

# ....................{ BUILTINS                           }....................
# Disable the following builtins:
#
# * "r", expanding to "fc -e -", repeating the prior interactive command. Since
#   all reasonably modern shells provide a generalized form of such
#   functionality through <Up>, there exists no reason to reserve an eminently
#   useful single letter for an unused command.
disable r

# ....................{ MODULES                            }....................
# Load all zsh modules required by this parcel or parcel "digest". Note zsh
# module "zsh/datetime" to have already been loaded above.

# Wrap system call stat() with zsh function zstat(). Do not load this module
# with "zmodload zsh/stat", as that wraps such call with zsh function stat()
# conflicting with external POSIX command "stat". Do not bother autoloading such
# module on the first call to zstat(), as zeshy startup *ALWAYS* calls such
# function. See parcel "digest" for further details.
zmodload -F zsh/stat b:zstat

# Expose zsh's internal C-based hash tables as zsh-based dictonaries. Do not
# bother autoloading such module on the first expansion of such a dictionary,
# due to the overwhelming number and basic essentiality of such dictionaries.
# These include:
#
# * ${funcstack}, the stack of functions, scripts, and "eval" statements on the
#   current call path.
# * ${functions}, the set of all currently defined functions, permitting
#   redefinition and subsequent restoration of new function implementations.
zmodload zsh/parameter

# ....................{ EXCEPTIONS ~ throw                 }....................
# void :call_stack.unwind(void)
#
# Unwind the current call stack by intentionally triggering a fatal internal
# error. Specifically, silently attempt to redefine a local string constant --
# logic inspired directly by the canonical zsh function throw(). For reasons
# not entirely clear, such logic is *NOT* replaceable by customary commands
# signalling errors (e.g., "return 1").
#
# For robustness, implement such logic as an alias rather than function. While
# functions may be (either maliciously or accidentally) undefined at runtime
# and hence are *NOT* reliably callable by low-level exception handlers,
# aliases are expanded at function and script definition time and hence
# guaranteed to be expanded in such handlers below.
alias :call_stack.unwind='{
    readonly THROW=
    THROW= 2>/dev/null
}'

function TRAPZERR() {
    #FIXME: Such logic differs from that of :die(), which sets such status to
    #"${pipestatus[-1]}". While such differences may well be justified (e.g.,
    #due to the nature of trap handlers versus customary functions), we should
    #at least research and document the necessity of such differences.

    # Exit status of the prior command inducing the current error signal.
    integer exit_status=${status}
#   print -r -- "TRAPZERR() triggered with ${exit_status}"

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :die().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If this handler recursively triggered itself, halt such recursion by
    # printing such exception without calling additional functionality and
    # immediately returning. Specifically, unless the last instance of this
    # function in the current call stack is the first element of such stack
    # (signifying the current call), this function signalled an error. Avoid
    # another such error and thus infinite recursion by returning.
    #
    # If ${funcstack} is undefined, default such index to 1, ensuring such
    # conditional fails. An appropriate error will be returned below.
    #
    # Technically, this trap handler *COULD* have simply been called by a valid
    # script with filename "TRAPZERR". While unlikely, such edge case remains
    # marginally likelier than Schroedinger's Cat. Guard against this inanity by
    # only falling into such conditional if the runnable at such index is *NOT*
    # a script. See is_call_stack_index_script() for further details.
    if (( ${funcstack[(I)TRAPZERR]-1} != 1 )) &&
       [[ ${funcsourcetrace[${funcstack[(I)TRAPZERR]}]-} != *':0' ]] {
        # Print an exception message to standard error.
        {
            print
            :warning.output 'TRAPZERR() threw exception: '${*}
            :warning.output 'TRAPZERR() failed with exit status '${exit_status}
            print 'current call stack:'

            # Print an exception stack trace.
            local runnable_name
            for   runnable_name ("${funcstack[@]}") {
                print '  \_ '${runnable_name}'()'
            }
        } 1>&2

        # Unwind the current call stack and shell. (See below.)
        return ${exit_status}
    }

    # If such function is undefined, print a nonfatal warning. Since the end of
    # this function already throws an exception, do *NOT* report failure and
    # hence induce infinite recursion.
    #
    # Since this is a trap handler, avoid the following customary approach to
    # testing function existence (which assumes both module "zsh/parameter"
    # *AND* feature "parameters" from such module to have been loaded):
    #
    #    if (( ${+functions[::store_exception_status]} )) { ... }
    typeset -f ::store_exception_status &>/dev/null || {
        :warning.output '::store_exception_status() undefined in TRAPZERR().'
        return ${exit_status}
    }

    # If any list variable expanded below is undefined or not a list, fail.
    [[ ${(t)funcstack-} == 'array-'* ]] || {
        :warning.output '${funcstack} undefined in TRAPZERR().'
        return ${exit_status}
    }

    #FIXME: Insufficient, as backgrounding "vim" demonstrates. The crux of the
    #issue is the second condition (${#funcstack} == 1), which excludes
    #backgrounding commands called from within zeshy functions. What we
    #*REALLY* need is some means of determining whether or not we're
    #backgrounding something. That shouldn't be terribly difficult, right?
    #Surely there's a trap handler for that. Investigate.
    #FIXME: This is almost certainly Linux-specific. Or is it? It's merely a
    #nicety, so it doesn't particularly matter *TOO* much, but still.
    #FIXME: Abstract this into a new TRAPZERR() hook and shift elsewhere --
    #ideally, a new parcel (e.g., @{*-main/zsh/trap}).

    # If such status is 20 *AND* the call stack contains only the call to this
    # trap handler, such handler was triggered by the non-erroneous interactive
    # backgrounding of a foregrounded process (e.g., via <Ctrl-z>). In such
    # case, report success rather than unwinding such stack.
    if (( exit_status == 20 && ${#funcstack} == 1 )) {
        # print '20! current call stack:'
        # local runnable_name
        # for   runnable_name ("${funcstack[@]}") {
        #     print '  \_ '${runnable_name}'()'
        # }
        return 0
    }

    # Else, convert such error into an exception. Since zsh only passes this
    # handler an exit status, do *NOT* bother fabricating an error message.
    # Subsequent exception handling should do so already.
    ::store_exception_status '' "${exit_status}"

    # Run all external hooks registered for such signal.
    typeset -ag ZESHY_HOOK_CODE_RUN_ON_SIGNAL_ZERR
    local hook_code
    for   hook_code ("${ZESHY_HOOK_CODE_RUN_ON_SIGNAL_ZERR[@]}") {
        eval "${hook_code}"
    }

    # Return such command's status as this trap's status. This pantomimes the
    # result of enabling shell option "ERR_RETURN". See "man zshoptions" for
    # further details.
    return ${exit_status}
}

# :void :die(:string... exception_messages?)
#
# To comply with existing zsh code, preserve the original exception global
# rather than declaring a zeshy-specific alternative (e.g.,
# ${ZESHY_EXCEPTION_MESSAGE}).
function :die() {
    # Get the exit status to be associated with such exception from the current
    # runtime environment rather than expecting such status to be explicitly
    # passed. Specifically, get the exit status of the prior command --
    # regardless of whether such command resided in a pipeline or not.
    #
    # ${pipestatus} is a canonical list global whose elements are the exit
    # statuses of each subcommand of the prior pipe command or of the prior
    # command if not a pipe command. Conversely, ${?} and ${status} are
    # canonical integer globals containing the exit status of the prior command
    # *ONLY* when not such a subcommand. Since the former plainly subsumes the
    # latter, defer to the former. Consider:
    #
    #     # Define helper functions.
    #     >>> pipe_status() { print ${pipestatus[-1]} }
    #     >>> exit_status() { print $? }
    #
    #     # ${pipestatus} provides the required values.
    #     >>> true; pipe_status  # this works...
    #     0
    #     >>> true; true | false || pipe_status  # ...and so does this.
    #     1
    #
    #     # Neither ${?} or ${status} provide the required values.
    #     >>> true; exit_status  # this works...
    #     0
    #     >>> true; true | false || exit_status  # ...but this doesn't.
    #     0
    integer exit_status=${pipestatus[-1]}

    # If this function is recursively calling itself, halt such recursion by
    # printing such exception without calling additional functionality and
    # immediately returning. See TRAPZERR().
    if (( ${funcstack[(I):die]-1} != 1 )) &&
       [[ ${funcsourcetrace[${funcstack[(I):die]}]-} != *':0' ]] {
        # Print an exception message to standard error.
        {
            print
            :warning.output ':die() threw exception: '${*}
            :warning.output ':die() failed with exit status '${exit_status}
            print 'current call stack:'

            # Print an exception stack trace.
            local runnable_name
            for   runnable_name ("${funcstack[@]}") {
                print '  \_ '${runnable_name}'()'
            }
        } 1>&2

        # Unwind the current call stack.
        :call_stack.unwind
    }

    # If such function is defined, globalize such exception.
    if { typeset -f ::store_exception_status &>/dev/null } {
        ::store_exception_status "${*}" "${exit_status}"
    # Else, print a nonfatal warning. Since the end of this function already
    # throws an exception, refrain from doing so here.
    } else {
        print '::store_exception_status() undefined in throw_exception().' 1>&2
    }

    # By default, zsh coerces integer global ${TRY_BLOCK_ERROR} to -1. On
    # entry, "}:always{...}:always" blocks set such integer to the exit status
    # of the last command in the corresponding ":try{...}" block. If such
    # integer is 0, this function was called from within the
    # "}:always{...}:always" block of such a ":try{...}" block whose last
    # command succeeded. While rare, handle such case by coercing the current
    # "}:always{...}:always" block to report failure rather than success.
    if (( ${TRY_BLOCK_ERROR--1} == 0 )) {
        TRY_BLOCK_ERROR=1
    }

    # Unwind the current call stack.
    :call_stack.unwind
}

# string ::store_exception_status(string error_message, int exit_status)
function ::store_exception_status() {
    # Validate sanity. Since :die() calls this function, avoid calling such
    # function; in the event of an error, simply print a message to standard
    # error and report success. Do *NOT* report failure. Since this function is
    # called by both :die() and TRAPZERR(), reporting failure here could induce
    # infinite recursion. Instead, allow whichever of :die() or TRAPZERR()
    # called this function to continue throwing their exception.
    (( # == 2 )) || {
        :warning.output '::store_exception_status() expected one exception message and one exit status.'
        return 0
    }
    local exception_message="${1}" exit_status="${2}"

    #FIXME: Actually, in such case, wouldn't it be more robust to attempt to
    #reload module "zsh/parameter"?

    # If any canonical call stack list is undefined or not a list, fail.
    [[ "${(t)funcstack-}${(t)funcfiletrace-}${(t)funcsourcetrace-}" ==\
        'array-'*'array-'*'array-'* ]] || {
        :warning.output '${funcstack}, ${funcfiletrace}, and/or ${funcsourcetrace} undefined or not lists for exception: '${EXCEPTION-}
        return 0
    }

    # If this function is called directly from the command line, fail. (In this
    # case, since this function cannot have been called by :die(), there's no
    # possibility of undesired recursion. Hence, report failure.)
    (( ${#funcstack} >= 2 )) || {
        :warning.output '::store_exception_status() called directly from command line.'
        return 1
    }

    # If such status is not in [0, 255], fail. See is_integer_nonnegative() for
    # further details.
    { [[ "${exit_status}" == <-> ]] &&
      (( 0 <= exit_status && exit_status <= 255 )) } || {
        :warning.output '::store_exception_status() exit status "'${exit_status}'" not an integer in [0, 255].'
        return 0
    }

    # If such status signifies success, coerce such status to signify failure.
    if (( exit_status == 0 )) {
        exit_status=1
    }

    # If ${EXCEPTION} is currently defined, an exception has been thrown but
    # not caught. To preserve such exception, append such exception's message
    # to the passed message.
    #
    # Technically, if the call stack for such uncaught exception is still
    # defined to a nonempty list *AND* the exit status for such uncaught
    # exception is still defined to an integer, such stack and status could be
    # incorporated into such message as well. Since retrieving a human-readable
    # runnable name from such stack is nontrivial (e.g., due to necessarily
    # ignoring runnables matching :die(), TRAPZERR(), and so forth), such
    # incorporation is nontrivial. It currently isn't worth the effort.
    if (( ${+EXCEPTION} )) {
        exception_message+=$'\n\n''Uncaught exception:'$'\n'${EXCEPTION}
    }

    # Store such metadata as documented above.
    typeset -g EXCEPTION="${exception_message}"
    integer -g ZESHY_EXCEPTION_STATUS="${exit_status}"
    typeset -ag\
        ZESHY_EXCEPTION_FUNCSTACK\
        ZESHY_EXCEPTION_FUNCFILETRACE\
        ZESHY_EXCEPTION_FUNCSOURCETRACE

    # Since this function call will convey no meaningful context to most users,
    # omit such call from the call stack stored for such exception.
    #
    # Do *NOT* quote list slices. (Doing so concatenates all list items.)
    ZESHY_EXCEPTION_FUNCSTACK=(       ${funcstack[2,-1]} )
    ZESHY_EXCEPTION_FUNCFILETRACE=(   ${funcfiletrace[2,-1]} )
    ZESHY_EXCEPTION_FUNCSOURCETRACE=( ${funcsourcetrace[2,-1]} )

    # If this function was *NOT* called from within a ":try{...}:always{...}:always"
    # block, the exception that TRAPZERR() or :die() subsequently throws will
    # induce zsh to silently unwind the call stack for the current shell
    # without printing such exception. To avoid that, print such exception here
    # *BEFORE* throwing such exception.
    # print "ZESHY_TRY_LEVEL: ${ZESHY_TRY_LEVEL[${SHLVL}]-0o0o0}"
    if (( ${ZESHY_TRY_LEVEL[${SHLVL}]-0} <= 0 )) {
        # If such function is undefined, print a nonfatal warning.
        typeset -f ::print_exception_uncaught &>/dev/null || {
            :warning.output '::print_exception_uncaught() undefined in ::store_exception_status().'
            return 0
        }

        # Else, call such function to print such exception.
        ::print_exception_uncaught
    }
}

# ....................{ EXCEPTIONS ~ catch                 }....................
#FIXME: It'd be nice to extend such functionality with a list of user-
#configurable hooks called on uncaught exceptions. Not terribly critical at the
#moment, but something to eventually... integrate.
#FIXME: Rename to ::print_exception_if_uncaught().

# void ::print_exception_if_uncaught(void)
#
# While such functionality could be inserted directly into the expansion of
# "}--", doing so inflates the implementation of all runnables expanding such
# alias -- in some cases, unreadably so. 
function ::print_exception_if_uncaught() {
    # If an error occurs in this function, throw an exception rather than merely
    # printing a message and setting ${TRY_BLOCK_ERROR} to 1. While doing so
    # does mimic the low-level action of an exception by unwinding the current
    # call stack, it fails to mimic the most significant high-level action of an
    # exception: printing the stack trace!

    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # If not called from within an "}:always{...}:always" block, throw an
    # exception. See die_unless_in_always() for further details.
    (( ${TRY_BLOCK_ERROR--1} >= 0 )) || :die\
        'Not in an "}:always{...}:always" block (or ${TRY_BLOCK_ERROR\} '${TRY_BLOCK_ERROR--1}' not in [0, 255] and hence an invalid exit status).'

    # Else if list global ${ZESHY_TRY_LEVEL} is undefined or has no item
    # corresponding to the current shell or such item is non-positive, throw an
    # exception. Assuming the current "}:always{...}:always" block to be
    # preceded by a sane ":try{...}" block, such item should always be
    # positive. See :try() for further details.
    (( ${ZESHY_TRY_LEVEL[${SHLVL}]-0} > 0 )) || {
        # Coerce such element to its default value to ensure proper operation
        # hereafter. See :try() for further details.
        typeset -ag ZESHY_TRY_LEVEL; ZESHY_TRY_LEVEL[${SHLVL}]=0

        # Throw an appropriate exception.
        if (( ${+ZESHY_TRY_LEVEL[${SHLVL}]} )) {
            :die '${ZESHY_TRY_LEVEL['${SHLVL}']} '${ZESHY_TRY_LEVEL[${SHLVL}]}' <= 0 (e.g., due to no preceding ":try{").'
        } else {
            :die '${ZESHY_TRY_LEVEL['${SHLVL}']} undefined (e.g., due to no preceding ":try").'
        }
    }

    # Else, such global is sane. Decrement such global to undo its
    # incrementation by the prior ":try{...}" block. See :try() for further
    # details.
    ZESHY_TRY_LEVEL[${SHLVL}]=$(( ZESHY_TRY_LEVEL[${SHLVL}] - 1 ))

    # If an exception was caught, clear the canonical string global storing the
    # error message for such exception. (This ensures calls by subsequent
    # "}:always{...}:always" blocks to is_exception_caught() report failure.)
    unset CAUGHT

    # If an exception was thrown and the current "}:always{...}:always" block
    # is the topmost such block, catch such exception. Unlike
    # catch_exception_matching_glob_if_found(), retain the current exit status
    # (i.e., ${TRY_BLOCK_ERROR}) to report such status to the shell.  See
    # catch_exception_matching_glob_if_found() for further details.
    if (( ${+EXCEPTION} && ZESHY_TRY_LEVEL[${SHLVL}] == 0 )) {
        # Print such exception and associated metadata.
        typeset -f ::print_exception_uncaught &>/dev/null ||
            :die '::print_exception_uncaught() undefined.'
        ::print_exception_uncaught
    }
}

# void ::print_exception_uncaught(void)
function ::print_exception_uncaught() {
    # Redirect all output printed below to standard error. Yes, a single
    # suffixing "} 1>&2" actually suffices. You rock, zsh! (Sometimes.)
    {
        # Validate sanity.
        (( # == 0 )) || :die 'Expected no arguments.'

        # If ${funcstack} is undefined or not a list, throw an exception.
        [[ "${(t)funcstack-}" == 'array-'* ]] || :die\
            'List global ${funcstack} undefined for exception: '${EXCEPTION-}

        # If called directly from the command line *OR* no exception is
        # currently thrown, throw an exception.
        (( ${#funcstack} >= 2 && ${+EXCEPTION} )) || :die\
            'No exception thrown (i.e., called directly from the command line and/or ${EXCEPTION} undefined).'

        # If print_exception() is defined, call such function.
        if { typeset -f print_exception &>/dev/null } {
            print_exception
        # Else, print such exception manually. If an exception is thrown
        # sufficiently early in zeshy startup, print_exception() will *NOT* have
        # been defined yet.
        } else {
            :warning.output "${EXCEPTION}"
            :warning.output 'Failed with exit status '${ZESHY_EXCEPTION_STATUS-1}'.'

            # Print a stack trace. Ideally, such trace would only be
            # conditionally printed when the current user configuration requests
            # that *OR* when this is a debug build of zeshy, as under
            # :print_exception(). However, any exception thrown prior to
            # :print_exception()'s definition has been thrown sufficiently early
            # in the startup process that the user-configurable global
            # requesting such traces (i.e.,
            # ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_STACK}) is unlikely to have
            # been defined. Indeed, no exceptions should be thrown so early,
            # suggesting a critical failure of startup logic. For safety, we
            # prefer to *ALWAYS* print stack traces of such early exceptions.
            #
            # See output_call_stack_lists_with_style_prefix() for related logic.
            local   caller_name filename frame_prefix='    \_'
            integer caller_line frame_index

            for frame_index ({1..${#funcstack}}) {
                caller_name="${funcstack[${frame_index}]}"
                caller_line="${funcfiletrace[${frame_index}]##*:}"
                   filename="${funcfiletrace[${frame_index}]%:*}"

                if { typeset -f -- "${caller_name}" &>/dev/null } {
                    caller_name+='()'
                }
                print -r --\
                    "${frame_prefix} ${caller_name} { ${filename}: ${caller_line} }"

                frame_prefix=" ${frame_prefix}"
            }
        }
    } 1>&2

    # Catch such exception by unsetting all globals previously set by
    # ::store_exception_status(). See catch_exception() for further details.
    unset\
        EXCEPTION\
        ZESHY_EXCEPTION_STATUS\
        ZESHY_EXCEPTION_FUNCSTACK\
        ZESHY_EXCEPTION_FUNCFILETRACE\
        ZESHY_EXCEPTION_FUNCSOURCETRACE

    # Return success to avoid triggering TRAPZERR() and hence another exception.
    return 0
}

# ....................{ EXCEPTIONS ~ command               }....................
#FIXME: Hardly the ideal implementation. While we *DO* need to declare such
#function here to ensure exceptions on missing commands run by early-time
#functionality, such function should be generalized to support a list of hooks
#to be iteratively called. Moreover, such hooks should support package
#manager-specific lookup ala modern Linux distributions.

# :void command_not_found_handler(
#     :string command_name, :string... command_args?)
function command_not_found_handler() {
    (( # )) || :die\
        'Expected one command name and zero or more command arguments.'
    :die 'Command "'${1}'" not found.'$'\n\n''Command arguments:'$'\n    '${*}
}

# ....................{ INTERRUPTION                       }....................
#FIXME: It appears this may encourage non-halting interrupts, which is bad. I
#have no idea why, but strongly suspect calling curse_call_stack() in this
#context to be the culprit. Disable for now.
# integer TRAPINT(integer signal_number = SIGINT)
#
# Trap SIGINT (i.e., signal interrupt, as after a user-driven <Ctrl-C> event).
#function TRAPINT() {
#    integer signal_number=${1}

    # Print the current call stack to indicate the point of interruption.
#    curse_call_stack

    # Store the interrupted line in the history. By default, zsh omits such
    # lines -- somewhat unhelpfully. Dismantled, this is:
    #
    # * "zle", true only if the history is currently active.
    # * "-s", output the interrupted line to the history rather than stdout.
    # * "-r", preserve escapes from "echo" command manipulation.
    # * "--", prevent dash prefixes in the interrupted line from being
    #   misinterpreted as "print" command options.
    # * "${BUFFER}", the interrupted line.
#    zle && print -sr -- "${BUFFER}"

    # Arcanely uncanny bit-munging. Exit status is always a 1-byte integer.
    # Non-zero exit status with:
    #
    # * The high bit unset signifies a command or function-specific error.
    # * The high bit set signifies a signal-specific error. All bits excluding
    #   the high bit signify the signal number.
    #
    # Hence, constructing a signal-specific exit status requires merely adding
    # 128 to the desired signal number. Moreover, zsh interprets non-zero trap
    # function return values as the exit status to be returned from running the
    # default handler for the trap. Since we would like to continue running the
    # default handler for the trap (SIGINT, in this case), this function returns
    # a non-zero value. Rather than hard-coding the desired signal number, reuse
    # the number zsh passed as the first argument to this function.
#    return $(( 128 + ${signal_number} ))
#}

# ....................{ OPTIONS                            }....................
# Map from parsed option name to optional value. As expected, unparsed options
# remain preserved in the current argument list.
local -A arg_options

# List of shell commands to be run parsed from options "-c" and "--command".
local -a arg_shell_commands

# List of shell options to be enabled parsed from options "-o" and "--option".
local -a arg_shell_options

#FIXME: I'm fairly assured that passing multiple commands and options with
#long-form options works as advertised. I strongly doubt, however, that passing
#multiple commands and options with short-form options works as advertised. If
#not, we'll probably want to drop the "-M" and manually map short- to long-form
#arguments following option parsing. (Simple, if a tad tedious.)
#FIXME: Add an option for profiling zsh startup. Yes, zsh supports this.
#Exceptionally cool; I had no idea! See Dennis' great answer here:
#
#http://stackoverflow.com/questions/4351244/can-i-profile-my-zshrc-zshenv
#http://stackoverflow.com/questions/6693515/zsh-how-to-time-a-block-of-code
#
#We should most certainly add a run_profiled() function for printing a timing
#profile after running the passed command. There appear to be several ways of
#doing this: the "setopt xtrace" approach of the first URL above; the
#"time ( ... )" approach of the second URL above; and the "zprof" module. I'm
#unclear which is better but am currently leaning towards the latter. Regardless
#of which approach we choose, output to standard error by default, so as to
#ensure expected behavior under process substitution. (Naturally, a secondary
#function could be implemented to log to a passed file, instead.)
#FIXME: Hmm; yes, the "zprof" approach appears superior. Its output rocks, as
#expected. Mimics "gprof", so there you go. It's a bit wieldy to use, requiring
#an unload of the module to disable profiling, but... no problems, given a
#run_profiled() helper.

# Parse passed options *BEFORE* operating on any zeshy files, as the former
# could modify the behavior of the latter (e.g., by preventing zeshy from
# recompiling and loading its digest file). If such parsing fails, set option
# "-h" to non-zero exit status, instructing the end of this script to print help
# to standard error and return with such status. See
# set_map_to_arg_options_with_help_from().
#
# For readability, map short- to long-form options. Map option
# "--no-zeshy-dot-dir" to "--zeshy-dot-dir", thus implicitly setting the latter
# to the empty string on parsing the former.
zparseopts -M -D -E -A arg_options --\
    h=-help -help\
    v=-verbose -verbose\
    -compile-digest\
    -compile-digest-if-zeshy-changed\
    -digest-debug\
    -digest-release\
    -version\
    c+:=arg_shell_commands -command+:=arg_shell_commands\
    o+:=arg_shell_options -option+:=arg_shell_options\
    -zeshy-dot-dir:: -no-zeshy-dot-dir=-zeshy-dot-dir ||
    arg_options[--help]='failed'
#print -- "passed option names (${#arg_options}): ${(k)arg_options}"

# ....................{ GLOBALS                            }....................
#FIXME: In isolation, ${ZESHY_USER_DIGEST_FILE_IS_INDEPENDENT} is a horrid name.
#We *STILL* have no idea what such boolean actually implies when we see it in
#code. Rename to something suitably readable.
#FIXME: ${ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME} is also moderately
#horrible. Consider truncating as much as readably feasible.

# While other methods for achieving the same effect exist (e.g., touching
# zeshy's user configuration directory when passed option "--compile-digest"),
# such methods have non-idempotent and hence unexpected side effects.
integer -g\
    ZESHY_USER_DIGEST_FILE_IS_INDEPENDENT\
    ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME

# ....................{ DEBUG                              }....................
# [status: bool] :is_debugging(void)
alias :is_debugging='false'

# [stdout: string, stderr: string, status: int] :run_line_if_debugging(
#     string line)
alias :run_line_if_debugging='# [DEBUG]'

# string :output_line_if_debugging(string line)
alias :output_line_if_debugging=':run_line_if_debugging [[ -o interactive ]] && print -r -- "zeshy:"'

# ....................{ GLOBALS ~ arg                      }....................
#FIXME: Actually, this is *GORRAM* nonsensical. Look: zeshy, like most modern
#software, is intrinsically tied to git. Since the existence of a ".git"
#directory reliably implies such directory to be under git control, replace such
#fragile @ZESHY_IS_DEBUG@ nonsense with a simple efficient test:
#
#    if [[ -d "${ZESHY_HOME}/../src/../.git" ]] {
#       arg_options[--compile-digest-if-zeshy-changed]=
#       (( ${+arg_options[--digest-release]} )) || arg_options[--digest-debug]=
#    } else {
#       arg_options[--digest-release]=
#    }
#
#Note such test effectively ensures the mandatory precondition that
#'"${ZESHY_HOME:t}" == src'. While we could do so manually, the above single
#condition ensures both conditions at the same time.

# All lines containing "ZESHY_IS_DEBUG" prefixed and suffixed by "@" are removed
# from this parcel on zeshy installation and hence only apply to uninstalled
# zeshy instances (e.g., developer-specific git repositories).

# If running zeshy uninstalled, always test the zeshy codebase for changes
# requiring digest recompilation.
arg_options[--compile-digest-if-zeshy-changed]=  # @ZESHY_IS_DEBUG@

# If running zeshy uninstalled and option "--digest-release" was *NOT* passed,
# enable option "--digest-debug" by defaut.
(( ${+arg_options[--digest-release]} )) || arg_options[--digest-debug]=  # @ZESHY_IS_DEBUG@

# If at least one command-line option was passed, handle all options upon which
# zeshy startup subsequently depends (e.g., digest-specific options).
if (( ${#arg_options} )) {
    # Options "--verbose" and "--digest-debug" are synonyms.
    if (( ${+arg_options[--verbose]} )) {
        arg_options[--digest-debug]=
    }

    # If passed option "--digest-release", switch to a release build.
    # Specifically, disable option "--digest-debug", this option's antonym.
    # Oddly, zsh requires quoting map keys when unsetting such keys (possibly
    # due to their being prefixed by "--"?).
    if (( ${+arg_options[--digest-release]} )) {
        unset 'arg_options[--digest-debug]'
    }

    # If passed option "--digest-debug", switch to a debug build. By default, we
    # compile a release build.
    if (( ${+arg_options[--digest-debug]} )) {
        alias :is_debugging='true'
        alias :run_line_if_debugging=''
    }

    if (( ${+arg_options[--compile-digest]} )) {
        ZESHY_USER_DIGEST_FILE_IS_INDEPENDENT=1
    }
    if (( ${+arg_options[--compile-digest-if-zeshy-changed]} )) {
        ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME=1
    }
}

# ....................{ GLOBALS ~ path                     }....................
#FIXME: For safety, *ALL* of such globals should probably be frozen as
#constants. Attempting to change such globals at runtime is likely to make life
#unpleasant and broken.
#FIXME: Actually, there is *NO* reason to redeclare either ${ZESHY_HOME} or
#${ZESHY_MAIN_SCRIPT} here. Both "bin/zeshy" and "src/.zshrc" guarantee such
#globals to be set to sane paths. Indeed, if either such string global is
#undefined *OR* not a string *OR* expands to the empty string here, we should
#simply throw an exception. This allows us to excise all of the convoluted
#canonicalization of such paths below as simply unnecessary. Simplify!

typeset -g\
    ZESHY_HOME\
    ZESHY_DOT_DIR\
    ZESHY_DOT_DIR_BASENAME='.zeshy'\
    ZESHY_MAIN_SCRIPT="${0}"\
    ZESHY_OVERLAY_DIR\
    ZESHY_SEED_DIRNAME\
    ZESHY_SCRIPT_FILENAME

# Absolute path of the top-level directory containing the zeshy codebase. If
# such path has *NOT* already been set (e.g., by "/etc/profile.env" on zeshy
# installation), assume such directory to be the parent directory of the
# current script.
[[ -n ${ZESHY_HOME} ]] || {
    # List containing either one list item expanding to the absolute path of
    # the parent directory containing this script if found or no list items
    # otherwise. Dismantled, this is:
    #
    # * "${...:h}", expanding to such directory's absolute or relative path.
    # * "(:A)", converting such path from relative to absolute if the former.
    typeset -a ZESHY_HOME_CANONICALIZED
    ZESHY_HOME_CANONICALIZED=( "${ZESHY_MAIN_SCRIPT:h}"(:A) )

    # If such list is empty, such directory does not exist, implying such
    # script also (somehow!) does not exist. In such case, report failure.
    (( ${#ZESHY_HOME_CANONICALIZED} )) || {
        :warning.output 'Main script "'${ZESHY_MAIN_SCRIPT}'" not found.'
        return 1
    }

    # Else, set such global accordingly.
    ZESHY_HOME=${ZESHY_HOME_CANONICALIZED[1]}
}

# Default such directory to "~/.zeshy".
ZESHY_DOT_DIR=${HOME}'/'${ZESHY_DOT_DIR_BASENAME}

#FIXME: We're no longer satisfied with such nomenclature, particularly as it
#diverges from internal local variable nomenclature. Rename "_DIR" to
#"_DIRNAME" everywhere *ON A CASE-BY-CASE BASIS* (to risky to do so all in one
#fell swoop), and likewise for "_FILE"- and "_PATH"-suffixed global names.

# While ${ZESHY_OVERLAY_DIR} is currently synonymous with ${ZESHY_HOME}, it's
# depressingly easy to conceive of contexts in which the two differ.
ZESHY_OVERLAY_DIR=${ZESHY_HOME}

#FIXME: Document me.
# Absolute path of the directory containing all top-level zeshy scripts.
ZESHY_SEED_DIRNAME=${ZESHY_HOME}'/..-seed'

#FIXME: Replace "[[ -n "${ZESHY_DOT_DIR}" ]] ||" with a similar alias to
#is_zeshy_debug_and<>, probably named is_zeshy_dot_dir_or<>. See below!
#FIXME: Actually, setting such global to the empty string is somewhat dangerous
#as Zeshy functions failing to properly test such global for emptiness prior to
#expansion will end up attempting to read and write from directories resembling
#"/.zeshy/config/posix", *WHICH IS TOTALLY BAD.* To avert this, there's really
#no choice but to *UNSET* this global here at the top-level and then define a
#convenience alias resembling:
#
#    alias is_zeshy_dot_dir_or='(( ${+ZESHY_DOT_DIR} )) ||'
#
#Dead simple, really. We just need to do it. *AND DO IT SOON.* This is bloody
#dangerous, and quite unfriendly.
#FIXME: I see two amenable solutions (in no particular order):
#
#1. If passed "--no-zeshy-dot-dir", unset *ALL* such globals. This is a pretty
#   sweet solution, frankly. We could simply perform such unsetting *AFTER*
#   exporting all such globals here. (Should work, no?)
#2. If passed "--no-zeshy-dot-dir", be clever and set ZESHY_DOT_DIR="/dev/null".
#   This is the one system-wide path pretty much guaranteed to exist on all
#   *nix's and *NOT* be a directory. Hence, any attempt to read from or write
#   no any path "${ZESHY_DOT_DIR}/pathname" will always and reliably fail. That
#   said, it's a tad lazy: the failure doesn't show up until attempting an
#   actual file operation. The former solution spits up an error much earlier,
#   which is great.
#2a. If we adopt the approach of 2., note that we setting ZESHY_DOT_DIR=$'\0' is
#    a much better solution *GUARANTEED* to always produce failure.
#FIXME: Actually test this. Shouldn't be terribly difficult: just temporarily
#move "~leycec/.zeshy" aside and pass "--no-zeshy-dot-dir" to an interactively
#run "zeshy" process. If "~leycec/.zeshy" doesn't appear, we've done something
#spectacularly right. Huzza!
#FIXME: We should automatically enable option "--no-zeshy-dot-dir" whenever the
#filesystem hosting the desired ${ZESHY_DOT_DIR} is read-only. This is
#particularly important for running Zeshy under read-only filesystems (e.g.,
#squashfs), as required for running from archival media (e.g., CD, DVD) or
#read-only flash hardware (e.g., routers).
#FIXME: Actually, *THIS WHOLE BLOODY IDEA IS NONSENSICAL*. No, really; look at
#the extreme, unwieldy, kludgy extents we go to to try to maintain the fiction
#of being able to run zeshy without compiling or caching to a directory. Look:
#it probably is feasible, but it sure as heck ain't worth it. There's
#effectively no benefit in it anyway. Consider the original use case: Gentoo
#installation. Great. Just pass "zeshy --dot-dir=\"${S}\" install_zeshy" in the
#ebuild. My God. It's absurdly simple. Of *COURSE* zeshy can write to its own
#directory, even under ebuild installation. *sigh* This is a clear case of
#losing the forest for the trees. So here's what we're gonna do:
#
#* Excise all of this nonsense. Grep the codebase for '-n "${ZESHY_DOT_DIR}"'
#  and unwind such foolishness.
#* Excise option "--no-zeshy-dot-dir" both above and in usage documentation.
#* If ${ZESHY_DOT_DIR} is *NOT* writable by the current user, throw an
#  exception *EARLY*. (We probably already do this; just make sure.)

# If passed the dot directory option, replace such default. If passed the non-
# dot directory option, this silently replaces such default with the empty
# string, thus disabling use of such directory.
if (( ${+arg_options[--zeshy-dot-dir]} )) {
    ZESHY_DOT_DIR="${arg_options[--zeshy-dot-dir]}"
# If the current user's ${HOME} is the root directory, the current user is
# either "cron" or a subsidiary thereof. In such case, default this directory to
# under "/var/".
} elif [[ "${HOME}" == '/' ]] {
    ZESHY_DOT_DIR='/var/cache/zeshy'
}

# User-specific top-level paths.
typeset -g\
    ZESHY_USER_CACHE_DIR="${ZESHY_DOT_DIR}/cache"\
    ZESHY_USER_CONFIG_DIRNAME="${ZESHY_DOT_DIR}/config"\
    ZESHY_USER_OVERLAY_DIR="${ZESHY_DOT_DIR}/src"

# User-specific cache paths.
typeset -g\
    ZESHY_USER_COMPLETION_STARTUP_FILE="${ZESHY_USER_CACHE_DIR}/completion_startup"\
    ZESHY_USER_COMPLETION_RESULTS_DIR="${ZESHY_USER_CACHE_DIR}/completion_results"\
    ZESHY_USER_DIGEST_ROOT_DIRNAME="${ZESHY_USER_CACHE_DIR}/digest"\
    ZESHY_USER_DIR_STACK_FILE="${ZESHY_USER_CACHE_DIR}/dir_stack"

#FIXME: Nonsense. Just dynamically define a new function
#:set_zeshy_name_globals() internally defining such list globals (namely,
#${ZESHY_ALIAS_NAMES}, ${ZESHY_FUNCTION_NAMES}, and ${ZESHY_FUNCTION_NAMES}).
#At the moment, note we never actually *USE* this file for anything. We simply
#write to it in ::precompile_zeshy_cache() and define its documentation as:
#
#declare_global_with_stdin string ZESHY_USER_NAMES_FILE <<'/---'
#Absolute path of the user-specific `zsh` script declaring and defining list
#globals containing the names of all `zeshy` aliases, functions, and globals.
#/---
#
#Ludicrous. (And not ludicrous speed, either. That would be good. This isn't.)
typeset -g ZESHY_USER_NAMES_FILE="${ZESHY_USER_CACHE_DIR}/names.zsh"

# ....................{ SOURCERS                           }....................
#FIXME: Call such function wherever we currently call source().
#FIXME: Document me.

# :full ::script.source(:string... filenames)
#
# Source all passed `zeshy` scripts, reporting failure on the first such script
# to either _not_ exist or report failure _or_ reporting success otherwise
# (i.e., if all such scripts both exist and report success).
#
# == Motivation ==
#
# The source() builtin currently appears to fail to signal `TRAPZERR` and hence
# induce exceptions on script failures, possibly due to such builtin reporting
# exit status of 126 on such failures. Until the underlying issue is resolved,
# this function implements a suitable short-term solution.
function ::script.source() {
    # Validate sanity.
    (( # )) || :die 'Expected one or more script filenames.'
    local filename

    # Source such scripts.
    for filename ("${@}") {
        # If such script is not found, attempt to find such script.
        [[ -e ${filename} ]] || {
            # If such script is relative rather than absolute *AND* if
            # ${ZESHY_SCRIPT_FILENAME} is nonempty (hopefully implying the
            # current script to have been sourced by this function), attempt to
            # find such script under the directory owning the current script.
            if [[ ${filename[1]} != '/' && -n ${ZESHY_SCRIPT_FILENAME-} ]] {
                filename=${ZESHY_SCRIPT_FILENAME:h}'/'${filename}
            }

            # If such script is still not found, attempt to append such
            # filename by ".zy" if not already suffixed by a filetype.
            [[ -e ${filename} ]] || {
                # If such filename is *NOT* already suffixed by ".zy", do so.
                [[ ${filename[-3,-1]} == '.zy' ]] || filename+='.zy'

                # If such script is still not found, throw an exception.
                [[ -e ${filename} ]] ||
                    :die 'Script "'${filename}'" not found.'
            }
        }

        # If such script is *NOT* a file, throw an exception. While source()
        # does report failure if such script does not exist, such builtin does
        # *NOT* report failure if such script is a directory rather a file.
        # Since this function accepts only files, test whether such file is
        # actually a file *BEFORE* calling such builtin.
        [[ -f ${filename} ]] || :die 'Script "'${filename}'" not a file.'

        # If such path is relative rather than absolute, print a non-fatal
        # warning. This should *NEVER* be the case, but hardly constitutes a
        # fatal error.
        [[ ${filename[1]} == '/' ]] || :warning.output\
            'Script "'${filename}'" not an absolute path.'

        # Set such global to such path.
        ZESHY_SCRIPT_FILENAME=${filename}

        # Source such script.
        builtin source -- "${filename}" || return ${?}
    }
}

# :full ::script.source_or_unwind_call_stack(
#     :string... filenames)
#
# Source all passed `zeshy` scripts, silently unwinding the current call stack
# on the first such script to either _not_ exist or report failure. See
# ::script.source().
#
# == Motivation ==
#
# If any such script fails, the current call stack is silently unwound rather
# than a descriptive exception being thrown. Why? If such script fails, a stack
# trace describing the fatal error or exception responsible for such failure
# will have already been printed; in such case, throwing an exception here
# would result in another such trace, obscuring the prior trace describing the
# real issue. (Less is more.)
function ::script.source_or_unwind_call_stack() {
    ::script.source "${@}" || :call_stack.unwind
}

# ....................{ LOAD                               }....................
#FIXME: Right. The thing is, "bin/zeshy" should pass option "NO_RCS" to *ANY*
#zsh interpreter it runs, including the zsh interpreter implicitly run due to
#the shebang line. (If need be, we can guarantee this by making "bin/zeshy" a
#Bourne shell script running the true zsh script "bin/zeshy.zsh" with option
#"NO_RCS"). In such case, zeshy will only ever be genuinely loaded once,
#obviating any need for global ${ZESHY_PID_LAST_LOADED_BY} and the related
#contortions both below and in "/bin/zeshy". In truth, this will probably have
#to wait until we rewrite "/bin/zeshy" as a C driver.
#FIXME: O.K.; we've refactored "/bin/zeshy" to *ALWAYS* pass "-o no_rcs" to the
#zsh interpreter, implying we *SHOULD* theoretically be able to excise
#${ZESHY_PID_LAST_LOADED_BY} and related logic below. Do so, then test such
#revisions by restarting zeshy as both root and non-root users.

# If sourcing the current script under zsh startup logic (e.g., from a zsh
# script with basename matching either ".zlogin", ".zprofile", or ".zshrc"),
# prevent zsh from reloading zeshy if already loaded earlier during such logic.
#
# Ideally, the current script should only ever be sourced by the "zeshy" script
# installed with zeshy. Ideally, zsh startup logic should avoid sourcing the
# current script. Since zeshy is valid zsh, however, this script is sourceable
# as is by any zsh script or shell -- including zsh startup scripts. In such a
# case, failing to prevent zsh from reloading zeshy induces the following:
#
# * Some process runs the "zeshy" script as a new child process.
# * This process runs under "zsh" due to such script's shebang line.
# * This process sources at least ".zshrc" and possibly also ".zlogin" and
#   ".zprofile", depending on runtime context.
# * Sourcing such script could source the current script, loading zeshy.
# * After sourcing the current script, control returns to the "zeshy" script,
#   which either:
#   * Sources the current script, reloading zeshy.
#   * Replaces this process with a new process running "zsh" passed the current
#     script as its first argument and hence reloading zeshy twice:
#     * Once by zsh startup logic, as above.
#     * Once by the first argument passed to such script.
#
# In either case, zsh loads zeshy at least twice and possibly more. Avoid this!
#print "zeshy: argv[0]=$0}"
#print "zeshy: command line=$(< /proc/$$/cmdline)"
#print "zeshy: process ID (current)=$$"
#print "zeshy: process ID (parent!)=${PPID}"
#print "zeshy: process ID (cached.)=${ZESHY_PID_LAST_LOADED_BY-}"
#print "zeshy: passed option names=${(k)arg_options}"

typeset -gi ZESHY_PID_LAST_LOADED_BY

# If the caller requests not reloading zeshy when previously loaded under the
# current shell and zeshy has indeed already been loaded, do not do so again.
if (( ZESHY_PID_LAST_LOADED_BY == $$ )) {
    # If the following core function is undefined, zeshy cannot have been
    # previously loaded for the current shell. But the current conditional
    # implies zeshy was previously loaded for such shell! This contradiction can
    # only mean one thing: throw an exception.
    typeset -f :is_version_at_least &>/dev/null ||
        :die 'zeshy unexpectedly unloaded (i.e., zeshy last loaded by current process '$$', but zeshy function :is_version_at_least() undefined).'
# Else, zeshy has not yet been loaded. Do so! Specifically:
#
# * If such shell is a login shell, establish sensible login shell settings.
#   See set_shell_login_defaults() for further details.
# * Source all zeshy configuration files.
# * If no zeshy digest file has been compiled or such file requires
#   recompilation (e.g., due to upgrading zeshy, editing zeshy configuration
#   files, or installing new command or uninstalling old commands from the
#   current ${PATH}), recompile such digest.
# * Prepend such digest to the current ${FPATH}, thus effectively loading all
#   zeshy functions. For efficiency, the zsh autoload system delays defining
#   these functions until the first call to such functions.
# * Perform all zeshy startup tasks, including:
#   * Defining all zeshy aliases and globals.
#   * Calling all user-defined startup hooks.
} else {
    # If the current shell is a login shell, set login-specific behavior.
    if [[ -o login ]] {
        ::script.source_or_unwind_call_stack\
            ${ZESHY_SEED_DIRNAME}'/if_login/login'
    }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # While such autoload *DOES* render all compiled zeshy functions
    # immediately callable, calling most such functions (e.g., print_message())
    # is inherently unsafe as zeshy has yet to be started up and hence to
    # define globals referenced by such functions.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Autoload zeshy's user digest file, recompiling such file if needed.
    ::script.source_or_unwind_call_stack ${ZESHY_SEED_DIRNAME}'/digest'

    #FIXME: Sadly, the following appears to no longer work as advertised, as
    #this file is now sourced from a function context by ".zshrc". Since such
    #logic is somewhat expensive *AND* appears to be inducing other subtle
    #errors on initial startup, we've disabled it for now. However, we'll
    #eventually need to add it back. Or perhaps not? Right. Not. It's *WAY* too
    #fragile (and probably can't be coerced back anyway, given the function
    #context issue). So what do we do? Simple. We improve the logic that
    #dynamically defines ::startup_zeshy_globals() to ensure that *ALL*
    #declarations of read-only globals are prefixed by a command undclearing
    #such globals: e.g.,
    #
    #     typeset +r -- "${readonly_global_name}"
    #     unset      -- "${readonly_global_name}"
    #
    #Arguably, that's what we should have done originally in the first place.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # This *MUST* be performed from a global rather than function context.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Undefine all globals defined by such recompilation. The reasons are subtle but
    # the logic flows like butter. zeshy may (and often does) declare globals to be
    # read-only. Sadly, zsh fails on attempting to redefine read-only globals. Since
    # the subsequent call to startup_zeshy() and hence startup_zeshy_globals() does
    # just that, undefine zeshy-specific globals prior to such calls. Do so in the
    # root global context (i.e., in this component outside of functions) to
    # guarantee expected behavior. "'tis all a tad silly and worm-bitten, but such
    # is life in the tranche of code trenches."
    #
    # Since zsh never fails on redefining aliases or functions, do not bother
    # undefining either. We could, but there's little point (or profit) in it.
    #
    # Unfortunately, the above sourcing exposes function but *NOT* alias
    # declarations. Since undefine_variable_from<> is an alias, manually
    # implement the following:
    #
    #     # Must be "*" rather than "@".
    #     >>> is_list_nonempty ZESHY_GLOBAL_NAMES and
    #     ...     undefine_variable_from "${ZESHY_GLOBAL_NAMES[*]}"
    :output_line_if_debugging 'Starting up.'
    # print "dir stack [main/before]: ${ZESHY_USER_DIR_STACK_FILE}"
    # if [[ -n "${ZESHY_GLOBAL_NAMES-}" ]] {
    #     typeset +r -- "${ZESHY_GLOBAL_NAMES[@]}"
    #     unset      -- "${ZESHY_GLOBAL_NAMES[@]}"
    # }

    # Startup zeshy, having recompiled zeshy's user digest file above and hence
    # defined all autoloads applicable to such user.
    startup_zeshy
    # print "dir stack [main/after]: ${ZESHY_USER_DIR_STACK_FILE}"
    :output_line_if_debugging 'Started up.'

    # Ensure this conditional evaluates to true on the next attempt to load
    # zeshy under the current shell by setting such process ID to that of this
    # shell after successfully loading zeshy. (The "after" is key here!)
    ZESHY_PID_LAST_LOADED_BY=${$}
}

#FIXME: Unset such globals at the same place that we undefine the corresponding
#setter functions. Since the former *MUST* happen here, that suggests we should
#shift the latter here.
#FIXME: Actually, this is horrible and hopefully no longer needed (assuming
#we've implemented help strings as setter functions, as intended). Excise away!

# Undefine documentation-specific maps defined at the top of this script. As the
# prior conditional calling load_zeshy() calling :compile_zeshy() has already
# serialized such maps onto on-disk key value stores, such maps are no longer
# needed. As such maps consume non-trivial resources (typically 8MB to 16MB of
# memory), safely delete such maps here after their serialization to disk above.
unset --\
    ZESHY_ALIAS_NAME_TO_HELP_STRING\
    ZESHY_FUNCTION_NAME_TO_HELP_STRING\
    ZESHY_GLOBAL_NAME_TO_HELP_STRING

# ....................{ OPTIONS ~ last                     }....................
# If at least one command-line option was passed, handle all remaining options
# *AFTER* both autoloading and starting up zeshy.
if (( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) {
    # Handle help options *BEFORE* all other remaining options, which
    # immediately return if passed and hence assume priority. If passed, ignore
    # all other options and if:
    #
    # * The above option parsing failed as signified by option value "failed",
    #   print usage help to standard error and return with non-zero exit status.
    # * Else, print help to standard output and return with zero exit status.
    if (( ${+arg_options[--help]} )) {
        if [[ ${arg_options[--help]} == 'failed' ]] {
            print_zeshy_help_usage 1>&2
            :die 'Passed invalid or unknown options.'
        } else {
            print_zeshy_help_usage
            return 0
        }
    }

    # If passed a version option, behave similarly to above.
    if (( ${+arg_options[--version]} )) {
        print_zeshy_version
        return 0
    }

    # Set all passed options *BEFORE* running the passed commands, ensuring such
    # commands run under such options rather than the default zeshy environment.
    # Iterate list elements in pairs ignoring the first such element, as below.
    local placeholder arg_shell_option
    for   placeholder arg_shell_option ("${arg_shell_options[@]}") {
    #   print "zeshy: passed option \"${arg_shell_option}\""
        setopt "${arg_shell_option}"
    }

    # Run all passed commands. Since every other element parsed into such list
    # is either "-c" or "--command" and hence ignorable, iterate elements in
    # pairs ignoring the first such element.
    local placeholder arg_shell_command
    for   placeholder arg_shell_command ("${arg_shell_commands[@]}") {
    #   print "zeshy: passed command \"${arg_shell_command}\""
        run_code "${arg_shell_command}"
    }
}

# ....................{ PROFILING ~ end                    }....................
# If debugging zeshy, print a human-readable synopsis of zeshy startup time. For
# accuracy, minimize shell overhead by:
#
# * Printing such synopsis as a single statement.
# * Avoiding calling zeshy-specific functions to do so.
:run_line_if_debugging printf "zeshy: Startup in %.4f seconds (wall clock)."$'\n' $(( EPOCHREALTIME - ZESHY_TIME_START ))

# ....................{ ARGUMENTS                          }....................
# If the caller passed at least one nonempty non-option argument (i.e., an
# argument neither prefixed by "-" or expanding to the empty string), source the
# first such argument as the path of a zeshy script and pass such script all
# remaining such arguments. To avoid unfairly budgeting the time spent sourcing
# such script to zeshy startup, do so *AFTER* printing zeshy's startup time.
if [[ -n ${*} ]] {
#   :output_line_if_debugging "zeshy: sourcing \"${@}\"..."

    #FIXME: The output is still subpar. We *REALLY* just want to slightly tweak
    #output_call_stack() so that such function omits the first element on the
    #stack if such element is the absolute path of this "main" script. Very
    #simple. Just need to do it, as ever! Then, remove the "or die..." below.

    # If such script fails, print a human-readable exception. Failing to do so
    # results in unreadable errors resembling:
    #
    # >>> ~/tmp/tmp.zeshy
    # /home/leycec/zsh/zeshy/src/main() failed with exit status 1
    #  "~/tmp/tmp.zeshy" { /home/leycec/zsh/zeshy/src/main: 1398 }
    #   "/home/leycec/zsh/zeshy/src/main" { /usr/local/bin/zeshy: 206 }
    ::script.source_or_unwind_call_stack "${@}" ||
        :die 'Script "'${*}'" failed with exit status '${status}'.'
}

# ....................{ MAIN                               }....................
# Avoid implicitly returning with non-zero exit status, as occurs when the prior
# statement is a conditional evaluating to false.
#print 'returning zsh!'
return 0

# --------------------( WASTELANDS                         )--------------------
        # [[ ${filename[1]} == '/' ]] || :warning.output\
        # Source such script. If such script fails, silently unwind the current
        # call stack rather than verbosely throwing an exception. Why? If such
        # script fails, a stack trace describing the fatal error or exception
        # responsible for such failure will have already been printed; in such
        # case, throwing an exception here would result in another such trace,
        # obscuring the prior trace describing the real issue. (Less is more.)
        # builtin source -- "${filename}" || :call_stack.unwind

# Source all passed zeshy scripts if found or unwind the current call stack
# otherwise. The source() builtin currently appears to fail to signal TRAPZERR
# and hence induce exceptions on script failures, possibly due to such builtin
# reporting exit status of 126 on such failures. Until the underlying issue is
# resolved, this function implements a suitable short-term solution.

                # If such filename's basename (i.e., filename excluding
                # prefixing path) contains no "." and hence no filetype, append
                # such filename by ".zy".
                # [[ ${filename:t} == *'.'* ]] || filename+='.zy'

# setopt no_glob_assign    # do not glob variable assignments (use lists instead)
# setopt no_ignore_braces  # enable "{...}"-style brace expansion
# setopt no_ignore_close_braces  # render ";" optional for single-line functions
# setopt glob              # enable globbing

#FUXME: Contemplate disabling option "equals", as well. It's a rather silly
#feature, expanding "="-prefixed shell words to the absolute path of the
#corresponding command. It occasionally obstructs usability at the command line
#and in scripts (by requiring quoting), with little clear benefit. After all,
#which() and ":c" suffice for the very same operation. Do many users actually
#meaningfully leverage this feature (i.e., are there any meaningful instances
#where which() and ":c" do *NOT* suffice but "=" does)? We truthfully doubt it.
#   globbing "."-prefixed pathnames "*" to match 

    #FUXME: Rename such global to ${ZESHY_SCRIPT_FILENAME}.
#FUXME: Now that *THIS* function declares string global ${ZESHY_SCRIPT_FILENAME},
#we needn't declare such global as a local in ={compile}. See to it, please.
#FUXME: Actually declare string global ${ZESHY_SCRIPT_FILENAME} above.

    # Else, such script is *NOT* found.
    # } else {
        # If the current script has been sourced from another script that was
        # previously sourced, ${ZESHY_SCRIPT_FILENAME} has been defined. In such
        # case, attempt to find the passed script under the same directory as
        # that of the parent script that sourced the current script.
        # if [[ -n ${ZESHY_SCRIPT_FILENAME-} ]] {
        #     filename=${ZESHY_SCRIPT_FILENAME:h}'/'${filename}
        # }

        # If such script is still *NOT* found, throw an exception.
    #     ... || :die\
    #         'Script "'${filename}'" not found.'
    # }

    # If such script exists, validate such script's path.
    # if [[ -e ${filename} ]] {

        # Else, such script is *NOT* findable by the above means. In such case,
        # throw an exception.
        # } else {
        #     :die 'Script "'${filename}'" not found.'

#FUXME: It's fairly likely that, in many instances where we currently call this
#function, we're failing to supply an absolute path. Correct this by defining a
#new ::script_zeshy_in_dir_current.source_or_unwind_call_stack() function. How do
#we obtain the absolute path of the directory containing the currently
#interpreted script, again?

#FUXME: Subshells are horrible. See "bin/zeshy" for a substantially improved
#method leveraging list assignments.

# Find such path. Embed the trailing "(:A)" in a command substitution rather
# than in the current shell, as zsh interprets the "(:A)" in the latter as a
# literal string rather than shell word modifier: e.g.,
#
#     # This utterly fails. (Thanks, zsh.)
#     >>> zeshy_filename="${0}"(:A) && print "${zeshy_filename}"
#     /usr/bin/zeshy(:A)
#
# See "bin/zeshy" for related logic.
# ZESHY_HOME="$(print -r -- "${ZESHY_MAIN_SCRIPT:h}"(:A))" || {

#FUXME: Honestly: we *NEVER* call throw_exception() anywhere, so what's the
#point? Ditch such obfusctation.
#FUXME: Excise die() as well. When we do, *DON'T* forget to remove "|die" from
#globs below.

        #FUXME: The prevalence of such repeated logic has become fairly
        #unctuous. Shift alias :warning.output() from
        #@{*-start/*-alias/io/output} here.

# , but running under zsh ${ZSH_VERSION}."
#         print "zeshy: Consider upgrading, if feasible. (Sorry. Sumimasen. Entschuldigung.)"
#     } 1>&2
    #FUXME: O.K.; finish implementing this by adding an additional condition

# print -r "fpath: ${FPATH}"
#(( ${+funcstack} )) && 
# Unlike most typeset options (e.g., "-r"), zsh applies option "-U" without
# erasing the contents of such lists. (Rather helpful, that.)

#FUXME: Curious. Neither defining TRAPZERR() *OR* enabling options "ERR_RETURN"
#or "ERR_EXIT" appear to enable such behavior during startup. Yet, such logic
#does clearly enable such behavior *AFTER* startup. So what exactly is
#happening here? While we have no idea, it's clearly a low-level zsh issue.

# function yim() {
#     function zim() { return 1 }
#     print ok
#     die "Ugh."
#     zim
#     print ko
# }
# yim

# function yim() {
#     function zim() { return 1 }
#     print ok
#     false
#     zim
#     print ko
# }
# false
# yim
# setopt err_return
# yim

        # Coerce such integer to customary failure status 1 rather than
        # ${exit_status}. If ${exit_status} is 0,
        # the prior call to ::store_exception_status() will have set the
        # latter to 1 as desired.

    # integer exit_status="${?}"

#FUXME: Hmm; if an unhandled exception is thrown from within a call to builtin
#source(), what happens? So far, the answer appears to be: nothing good.

#FUXME: I've begun to reluctantly realize that if we want zeshy to remain both
#reliably portable, we're going to need to segregate all runnables zeshy defines
#to a zeshy-specific namespace. No, really. Aghast, I noted today an external
#command named "match_parens" installed on my system. Ruby! Hideous stuff. If
#commands have begun eating into the "_"-delimited lowercase words namespace, we
#have no choice but to escalate the namespace war by going one farther. For
#readability, I hereby propose we insulate the *ENTIRE* codebase from conflicts
#with external commands by appending ":" to *ALL* existing and future runnables
#(e.g., function name "die:" rather than "die"). This preserves both readability
#and unique nomenclature, at least in the forseeable future. Make it so, please.
#FUXME: Absolutely. This has become a hard requirement. Consider it, man! Yikes.
#zsh itself defines builtins pcre_compile(), pcre_match(), and pcre_study(). We
#absolutely have to avoid future conflicts... and there's only one way.

#FUXME: Non-ideal. Ideally, replace this with a generic zeshy function accepting
#two version specifiers and reporting success if the former exceeds the latter.
#FUXME: For obvious reasons, such function should be defined and called *AFTER*
#setting core shell options.
#FIMXE: Wait. Such tester, while positively *BANGIN'*, is extreme overkill here.
#But so was the prior tester. If you consider it, since there only exist a
#finite number of prior zsh major version, the test below always reduces to:
#
#    if [[ "${ZSH_VERSION}" == <0-4>.* ]] {
#        print "zeshy: zsh ${ZSH_VERSION} older than requisite version ${ZESHY_ZSH_VERSION_REQUIRED}." 1>&2
#        return 1
#    }
#
#That said, since :is_version_at_least() is awesome, shift such function to a
#new parcel @{20-main/version}. Naturally, all other version-related functions
#in the codebase should be shifted there as well. Sweet!

# If *NOT* running under such version, print an error message to standard error
# and return rather than exiting to avoid exiting interactive shells with non-
# zero exit status.
# autoload -U is-at-least
# is-at-least ${ZESHY_ZSH_VERSION_REQUIRED} || {
#     print "zeshy: zsh ${ZSH_VERSION} older than requisite version ${ZESHY_ZSH_VERSION_REQUIRED}." 1>&2
#     return 1
# }

    # print "zeshy: zsh ${ZSH_VERSION} older than requisite version ${ZESHY_ZSH_VERSION_REQUIRED}." 1>&2
    # return 1

    #FUXME: Pretty terrible. Let's unwind the double loop, yes? To do so, we'll
    #need to guarantee the two lists to have an equal number of items. Or
    #perhaps just iterate, defaulting not-found-items to 0?
    #FUXME: Wait. This is silly, isn't it? Can't we just:
    #
    #* Find out how many items are in the current and minimum version
    #  specifiers, as above.
    #* Take the difference in the sizes of each such list, appending
    #  sufficiently many 0's to the smaller list (if either is smaller) to
    #  ensure they contain the same number of elements.
    #* Join such lists on the empty string back into two strings. (See
    #  join_list(). Yes!)
    #* Strip all non-numeric characters from both strings.
    #FUXME: Wait. That's obvious bollocks. Hmmmmm. Right. Nothing for it but
    #manual iteration. That said, we should ensure that "5.0.0" >= "5.0.0-rc2".
    #To do so, we'll have to handle "-"-prefixed suffixes in a special manner;
    #namely:
    #
    #* Strip such suffixes off each such version into two local strings. Leave
    #  such strings as the empty string if the corresponding version has no such
    #  suffix. If iteration completes without terminating early, then and only
    #  then do we compare such suffixes (stripped of non-numeric prefixes, of
    #  course).
    #* If both such strings are nonempty, report the result of comparing such
    #  strings.
    #* Else if such string for the current version is empty, report success
    #  (e.g., "5.0.0" >= "5.0.0-rc2").
    #* Else, report failure (e.g., "5.0.0-beta2" < "5.0.0").
    #
    #Sweet! Fairly simple.
    #FUXME: Before doing so, if iteration fails to terminate, first check
    #whether (( ${#versions_current} <= ${#versions_minimum} )). If so (e.g.,
    #"5.0" <= "5.0.0"), ... ugh. To simplify this, we really should ensure such
    #lists have the same size. Arguably, the simplest means of doing so would be
    #to count 

    # Such iteration completed without reporting, implying the two versions to
    # be equal and hence the former to be at least the latter. Report success.
    #* Else if such string for the current version is empty, report success
    #  (e.g., "5.0.0" >= "5.0.0-rc2").
    #* Else, report failure (e.g., "5.0.0-beta2" < "5.0.0").

    #While
    # counter-intuitive, "-"-prefixed suffixes commonly signify candidate
    # releases and hence 
    # If at least one such suffix exists...

    # version_current="${version_current%%*-[^0-9]#}"
    # version_minimum_suffix="${version_minimum%%*-[^0-9]#}"
    # "-"-prefixed suffixes of such version specifiers (e.g., the "-rc1" in
    # "8.4.2-rc1") stripped of non-numeric characters - including "-".
    # version_current_suffix="${version_current%%*-[^0-9]#}"
    # version_minimum_suffix="${version_minimum%%*-[^0-9]#}"

    #FUXME: Great. Now that we have such counts, append as many instances of
    #".0" as necessary to the smaller specifier. Simple! See repeat_string().
    #FUXME: Why append 0 to ${version_current}?

    # Split such version on customary version specifier delimiters "." and "-".
# typeset -g ZESHY_USER_VERSION_FILE="${ZESHY_USER_CACHE_DIR}/version"

            # if (( ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_STACK-0} )) ||
            #     { { alias :is_debugging } >/dev/null && :is_debugging } {
        # ZESHY_IS_DEBUG=1
#print "debug: ${ZESHY_IS_DEBUG}"

#FUXME: Silly. We'd *MUCH* rather have a dynamically declared alias :is_debug()
#defaulting to:
#
#    alias :is_debug='false'
#
#Naturally, just redefine such alias to 'true' if actually debugging. Simple,
#and much more usable than this unique brand of nonsense.
# ZESHY_CORE_HELP_GLOBALS+='
# boolean ZESHY_IS_DEBUG
# 
# If true, enable expensive developer-specific logic -- including:
# 
# * Printing verbose debug messages on `zeshy` startup.
# * Printing verbose trace messages on `zeshy` startup to measure startup cost.
# * Recompiling `zeshy`''s user digest file on changes to the `zeshy` codebase. For
#   `zeshy` developers, such recompilation is essential to fast development. For
#   `zeshy` non-developers, detecting such changes is unnecessarily wasteful.
# '
# # By default, disable such logic unless otherwise specified.
# integer -g ZESHY_IS_DEBUG

# if (( ZESHY_IS_DEBUG )) {
#     alias :is_debugging='true'
# } else {
#     alias :is_debugging='false'
# }

#FUXME: Rename to is_zeshy_debug_and().
#FUXME: Eliminate in favor of :is_debugging(), which reads more intuitively.
#Or perhaps not? Contemplate. It really is a bit much to define *BOTH*. Surely
#one or the other would suffice? If not, consider renaming this to something
#more appropriate -- say, :run_code_if_debugging().
#FUXME: Right. I *QUITE* like :run_code_if_debugging().
#FUXME: Regardless of whether we eliminate or merely rename this, we should
#*DEFINITELY* define a new alias replacing all current instances of:
#
#    >>> :output_line_if_debugging "zeshy: conflating \"${ZESHY_SCRIPT_FILENAME}\"..."
#
#...with:
#
#    >>> print_message_if_debugging "Conflating \"${ZESHY_SCRIPT_FILENAME}\"."
#
#...where print_message_if_debugging() is an alias defined as follows:
#
#    alias print_message_if_debugging='is_zeshy_debug_and [[ -o interactive ]] && print "zeshy: "'
#
#Such alias is an obvious improvement over the current fairly hacky approach.
#FUXME: Ah! Yes. I believe I have a dramatic improvement over the implementation
#below. Rename such alias to :run_line_if_debugging() defined as follows:
#
#    alias :run_line_if_debugging='#'
#
#Moderately clever, isn't it? zeshy *GUARANTEEABLY* optimizes away all comments,
#ensuring the expected behavior. This does, however, require such code be listed
#on the *SAME EXACT LINE* as such alias. We'll need to grep through the codebase
#and ensure this, naturally.
#FUXME: In light of such change, we'll need to rename the printer proposed above
#to :output_line_if_debugging(). *shrug*
#
#    alias :output_line_if_debugging=':run_line_if_debugging [[ -o interactive ]] && print "zeshy: "'

# Define such alias to expand to the empty string if zeshy is currently being
# debugged and to the comment prefix otherwise, effectively "optimizing away"
# such lines as under common high-level languages.

# [stdout: string, stderr: string, status: int] is_zeshy_debug_and(
#     string code1, ...)
#
# If the caller requests verbosity, define such alias to run the passed command;
# else, define such alias to ignore such command. The latter reduces debug
# statements to constant time noops, simulating the "compiling away" of such
# statements under conventional high-level language optimization.
# alias is_zeshy_debug_and=': ||'

            # Clear such exception and associated metadata.
#            typeset -f clear_exception &>/dev/null ||
#                die 'clear_exception() undefined.'
#            clear_exception

        #FUXME: Silly. Fold such functionality into ::print_exception_uncaught()
        #and shift clear_exception() elsewhere.

        # If such function is defined, clear such exception.
#        if { typeset -f clear_exception &>/dev/null } {
#            clear_exception
#        # Else, print a nonfatal warning.
#        } else {
#            print 'zeshy: clear_exception() undefined in ::store_exception_status()' 1>&2
#            return 0
#        }

            # If either the current user's zeshy configuration requests printing
            # stack traces on exceptions *OR* zeshy is currently being debugged,
            # print traces. Print such stack with an implementation distilled from
            # output_call_stack_lists_with_style_prefix(). See such function for
            # further details.

    # If such function is *NOT* defined, print an error. Since the tail of this
    # function already throws an exception, do *NOT* return failure (which would
    # trigger TRAPZERR() and hence
    # induce infinite recursion.

#    if (( ${TRY_BLOCK_ERROR--1} < 0 )) {
#        print "zeshy: ::print_exception_if_uncaught() not called within an \"always :{...}:\" block" 1>&2
#        (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#    # Else if list global ${ZESHY_TRY_LEVEL} is not defined or has no element
#    # corresponding to the current shell or such element is non-positive, throw
#    # an exception. Assuming the current "always :{...}:" block was preceded by
#    # a sane "try {...}" block, such element should always be positive. See
#    # try() for further details.
#    } elif (( ${ZESHY_TRY_LEVEL[${SHLVL}]-0} <= 0 )) {
#        # 
#        ZESHY_TRY_LEVEL[${SHLVL}]=0
#
#        if (( ${+ZESHY_TRY_LEVEL[${SHLVL}]} )) {
#            print "zeshy: \${ZESHY_TRY_LEVEL[${SHLVL}]\} ${ZESHY_TRY_LEVEL[${SHLVL}]} <= 0 in ::print_exception_if_uncaught() (e.g., due to no preceding \"try\")" 1>&2
#        } else {
#            print "zeshy: \${ZESHY_TRY_LEVEL[${SHLVL}]\} undefined in ::print_exception_if_uncaught() (e.g., due to no preceding \"try\")" 1>&2
#        }
#
#        (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#    # Else, the current context is sane.
#    } else {
#        # Decrement the shell-specific try level incremented by the prior "try
#        # {...}" block. See try() for further details.
#        ZESHY_TRY_LEVEL[${SHLVL}]=$(( ZESHY_TRY_LEVEL[${SHLVL}] - 1 ))
#
#        # If an exception was thrown and the current "always :{...}:" block is
#        # the topmost such block, catch such exception. Unlike
#        # catch_exception_matching_glob_if_found(), retain the current exit
#        # status (i.e., ${TRY_BLOCK_ERROR}) to report such status to the shell.
#        # See catch_exception_matching_glob_if_found() for further details.
#        if (( ${+EXCEPTION} && ZESHY_TRY_LEVEL[${SHLVL}] == 0 )) {
#            # If either such function is undefined, throw an exception.
#            typeset -f ::print_exception_uncaught &>/dev/null || {
#                print 'zeshy: ::print_exception_uncaught() undefined' 1>&2
#                (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#            }
#            typeset -f clear_exception &>/dev/null || {
#                print 'zeshy: clear_exception() undefined' 1>&2
#                (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#            }

        #FUXME: Fairly certain this is now obsolete by the TRAPZERR() and
        #throw_exception() recursion detectors.

        # If this function is recursively calling itself, halt such recursion by
        # printing such exception without calling additional functionality and
        # returning immediately. See throw_exception() for further details.
#        if (( ${funcstack[(I)::print_exception_uncaught]-1} != 1 )) &&
#           [[ "${funcsourcetrace[${funcstack[(I)::print_exception_uncaught]}]-}" != *':0' ]] {
#            print
#            print "zeshy: ::print_exception_uncaught() threw exception: ${EXCEPTION-}"
#            print "zeshy: ::print_exception_uncaught() failed with exit status ${TRY_BLOCK_ERROR-1}"
#            print "current call stack:"
#
#            local function_name
#            for   function_name ("${funcstack[@]}") {
#                print "  \\_ ${function_name}()"
#            }
#
#            # Report success to avoid triggering TRAPZERR and further recursion.
#            return 0
#        }


# Specifically, unless the last instance of this
    # function in the current call stack is the first element of such stack
    # (signifying the current call), this function threw an exception. Avoid
    # another such exception and thus infinite recursion by returning.
    #
    # If ${funcstack} is undefined, default such index to 1, ensuring such
    # conditional fails. An appropriate exception will be thrown below.
    #
    # Technically, this function *COULD* have simply been called by a valid
    # script named "throw_exception". While unlikely, it remains marginally
    # likelier than Schroedinger's Cat. Guard against such inanity by *ONLY*
    # enabling such condition if the runnable at such index is *NOT* a script.
    # See is_call_stack_index_script() for further details.

#FUXME: If ${EXCEPTION} is already defined when this function is called, such
#exception should be preserved by appending such message to the passed message.
    #FUXME: This requires a *MAJOR* simplification. For one, this function is
    #no longer passed anything and hence should reference globals. For another,
    #we really want to reduce the series of printer calls below to a single
    #printer function. It's time to just do it.
    #FUXME: Actually, two printer calls: 

        #FUXME: O.K.; so, fold the current print_error_status() function into a
        #new print_exception() function and excise print_error_status(). For
        #simplicity, in fact, rename all existing "print_error" functionality to
        #"print_exception". (If we like, we can later differentiate a new
        #print_error() function from such functionality.)

        # If such message exists, print such message.
#        if (( # )) {
#            # If print_exception() is defined, call such function.
#            if { typeset -f print_exception &>/dev/null } {
#                print_exception "${@}"
#            # Else, print such message with a one-liner.
#            } else {
#                print "zeshy: ${EXCEPTION}"
#                print "zeshy: failed with exit status ${ZESHY_EXCEPTION_STATUS-1}"
#            }
#        }

        # Print a description of the passed non-zero exit status.
        # If print_exception_message() is defined, call such function.
#        if { typeset -f print_error_status &>/dev/null } {
#            print_error_status "${exit_status}"
#        # Else, print such message with a one-liner.
#        } else {
#            print
#            print "zeshy: failed with exit status ${exit_status}"
#        }
#       print "printed exit status"

        # If either the current user's zeshy configuration requests printing
        # stack traces on exceptions *OR* zeshy is currently being debugged,
        # print traces.
#        if (( ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_STACK-0} +\
#              ${ZESHY_IS_DEBUG-0} )) {
##           print "printing call stack"
#            # If output_exception_call_stack() is defined, call such function.
#            if { typeset -f output_exception_call_stack &>/dev/null } {
##               print "calling output_call_stack()"
#                output_exception_call_stack
#            # Else, print such stack with an implementation distilled from
#            # output_exception_call_stack(). See such function for further
#            # details.
#            } else {
#                local frame_prefix='    \\_' filename caller_name
#                integer funcstack_size=${#funcstack} i caller_line
##               print "printing stack frame"
#
#                for (( i = 1; i <= funcstack_size; i++ )) {
#                    caller_name="${funcstack[${i}]}"
#                    caller_line="${funcfiletrace[${i}]##*:}"
#                       filename="${funcfiletrace[${i}]%:*}"
#
#                    if { typeset -f -- "${caller_name}" &>/dev/null } {
#                        caller_name+='()'
#                    }
#                    print -r --\
#                        "${frame_prefix} ${caller_name} { ${filename}: ${caller_line} }"
#
#                    frame_prefix=" ${frame_prefix}"
#                }
#            }
#        }
#    } always {
#        # If prior exception handling threw an exception, catch such exception
#        # to prevent uncaught exceptions from recursively triggering TRAPZERR().
#        # Since aliases and functions typically throw exceptions *AND* cannot be
#        # guaranteed to exist (e.g., due to intentional or unintentional
#        # deletion), avoid expanding aliases or calling functions below.
#        # Specifically, print and delete such exception and return success from
#        # this "always {...}" block. See
#        # catch_exception_matching_glob_if_found() for further details.
#        if (( ${+EXCEPTION} )) {
#            print "zeshy: exception handler threw exception \"${EXCEPTION}\""
#            unset EXCEPTION
#            TRY_BLOCK_ERROR=0
#        # Else if the last command of prior exception handling failed with
#        # nonzero exit status, print such failure and again return success.
#        } elif (( ${TRY_BLOCK_ERROR-0} > 0 )) {
#            print "zeshy: exception handler failed with exit status ${TRY_BLOCK_ERROR}"
#            TRY_BLOCK_ERROR=0
#        }

#FUXME: die() should arguably be refactored into an alias expanding to simply
#throw_exception(). In any case, throw_exception() should suffice for all
#top-level use now. Refactor all top-level parcels to simply call
#throw_exception() instead and shift die() to, say, @{00-declare/00-pcre}.

#ZESHY_CORE_HELP_ALIASES+='
#string die(string error_message1 = "", ...)
#
#Throw an exception with the passed error message (defaulting to the empty
#string). If such exception remains uncaught (i.e., _not_ handled by an
#`always :{...}:` block on the current call stack), such message and related
#metadata will be printed to standard error and failure returned from such stack.
#
#== Exception Metadata ==
#
#Such metadata includes the following:
#
#* If boolean ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_STACK} is enabled, a stack
#  trace of the current call path. See output_call_stack() for further details.
#* If boolean ${ZESHY_ERROR_HANDLER_IS_PRINTING_DOCUMENTATION} is enabled,
#  documentation for the function or script throwing such exception. See
#  print_exception_thrower_documentation() for further details.
#* If boolean ${ZESHY_ERROR_HANDLER_IS_PRINTING_CALL_SOURCE} is enabled, the
#  source code of the function or script throwing such exception. See
#  print_exception_thrower_implementation() for further details.
#'
#function die() {
#    # Exit status of the prior command. zsh defines "pipestatus" to be a global
#    # list with elements the return values of each subcommand of the prior pipe
#    # command or of the prior command if not a pipe command. Conversely, zsh
#    # defines "?" to be a global integer with the return value of the prior
#    # command. Since the former subsumes the latter *AND* the latter fails to
#    # provide the return value of the prior command when a subcommand of a pipe
#    # command, we defer to the former. For example, consider:
#    #
#    #     # Define helper functions.
#    #     >>> pipe_status() { print ${pipestatus[-1]} }
#    #     >>> exit_status() { print $? }
#    #
#    #     # Show "pipestatus" to return the required values.
#    #     >>> true; pipe_status  # this works...
#    #     0
#    #     >>> true; true | false || pipe_status  # ...and so does this.
#    #     1
#    #
#    #     # Show "?" to *NOT* return the required values.
#    #     >>> true; exit_status  # this works...
#    #     0
#    #     >>> true; true | false || exit_status  # ...but this doesn't.
#    #     0
#    integer exit_status=${pipestatus[-1]}
#
#    # If the prior command succeeded, coerce such exit status into an error.
#    if (( ${exit_status} == 0 )) {
#        exit_status=1
#    }
#
#    # Handle such exception.
#    ::print_exception_uncaught "${@}" "${exit_status}"
#
#    #FIXME: Suffix the exception name by the name of the function directly
#    #responsible for throwing this exception. See curse_exception_status()
#    #for simple logic getting this function name.
#
#    # If throw_function() is still defined, unwind the current call stack,
#    # returning the current user to an interactive prompt if the current shell
#    # is interactive or exiting such shell otherwise.
#    if { typeset -f throw_exception &>/dev/null } {
#        throw_exception ZeshyException
#    # Else, something awful. Print a bleak warning.
#    } else {
#        print 'zeshy: throw_exception() undefined (e.g., due to exception handler throwing exception)' 1>&2
#    }
#
#    # Return success to avoid triggering TRAPZERR and hence another exception.
#    return 0
#}

# This does *NOT* constitute an error.
    # Save the exit status of the prior command prior to overwriting this status
    # by handling such error.

    #FUXME: Technically, naming an otherwise valid zeshy script
    #"throw_exception" would *COMPLETELY* screw up zeshy operation. (Ditto for
    #"::print_exception_uncaught" below.) This is fairly easy, if noxiously
    #obnoxious, to guard against. Just do it!

    # Since
    # continuing on is likely to throw another exception, inducing
    # infinite recursion.
    #
    # To detect such condition
    # efficiently, search from the end (i.e., root) of the current call stack
    # for the first runnable with the same name as this is *NOT* the first, a
    # witch! (i.e., if any element of such stack other
    # than the first is such function)

        # If the current call stack contains this function at any position other
        # than the first (corresponding to the current call), this function
        # transitively threw an exception. Blithely continuing on is likely to
        # transitively throw another such exception, resulting in infinite
        # recursion. To halt such recursion before it obliterates existence,
        # print an error and return immediately on detecting such recursion. To
        # do so efficiently, search from the end (i.e., root) of such stack; if
        # the first matching caller is not the first, a witch! As below, return
        # success to avoid triggering TRAPZERR and hence another exception.
        #
        # If ${funcstack} is undefined, default such index to 1, ensuring such
        # conditional fails. An appropriate exception will be thrown below.
        # If the call stack for such uncaught exception is still defined *AND*
        # nonempty, incorporate such stack into such message.

#        if (( ${+ZESHY_EXCEPTION_FUNCSTACK} && ${#ZESHY_EXCEPTION_FUNCSTACK} )) {
#            # If the exit status for such uncaught exception is still defined,
#            # incorporate such status into such message.
#            if (( ${+ZESHY_EXCEPTION_STATUS} )) {
#                exception_message+=$'\n\n'"${+ZESHY_EXCEPTION_FUNCSTACK[}Uncaught exception:"$'\n'"${EXCEPTION}"
#            } else {
#            }
#        # Else, append such exception's message as is.
#        } else {

#        # See is_integer_nonnegative() for details.
#        (( # )) || die 'Expected optional error message and one exit status.'
#        local exit_status="${@[-1]}"
#        { [[ "${exit_status}" == <-> ]] &&
#          (( 0 <= exit_status && exit_status <= 255 )) } ||
#            die "Exit status \"${exit_status}\" not an integer in [0, 255]."

        # Pop such status from the list of passed arguments.
#        set -- ${@[1,-2]}
#   integer exit_status="${exit_status}"
    # If the prior command succeeded, coerce such exit status to the default
    # exit status signifying failure.
#    if (( exit_status == 0 )) {
#        exit_status=1
#    }

#Trap SIGZERR, a `zsh`-specific signal on non-zero exit status from `zsh`
#builtins and functions and external commands. Doing so effectively globally
#enables shell option `ERR_RETURN`, ensuring that on any command returning
#*failure* (i.e., non-zero exit status):
#
#* If the current shell is interactive, implicitly throw an exception unwinding
#  the call stack of such shell. If such exception is uncaught, return the
#  current user to the prompt.
#* Else, the current shell is non-interactive. Immediately exit such shell with
#  non-zero exit status.
#* If the calling shell fails to handle such exit status (e.g., with
#  `or true`) and is also running `zeshy`, repeat the above logic until either
#  exiting all non-interactive shells or returning to an interactive shell.
#
#In either case, handle such error according to the current user''s `zeshy`
#configuration (e.g., by printing a stack trace, documentation, and/or source
#code related to such error). See die() for further details.
#
#Unlike shell option `ERR_EXIT`, this handler explicitly unwinds the call stack
#of only the current shell rather than all parent shells.

#FUXME: Signal handling requires generalization. Rename our current
#implementation of TRAPZERR() to die_from_command_error(). Initialize a new
#list global ${ZESHY_TRAPZERR_HOOKS} to contain only such function name. Define
#a new TRAPZERR() iterating through ${ZESHY_TRAPZERR_HOOKS} and calling each
#such function.
#FUXME: This documentation could certainly use streamlining.

    # Handle such exception and return such command's exit status, mimicking the
    # action of "setopt ERR_RETURN". (See "man zshoptions" for further details.)
#   ::print_exception_uncaught "${exit_status}"

    #FUXME: Once we've refactored everything appropriately, dropkick the call
    #to ::print_exception_uncaught().
    #FUXME: Actually, we may *NOT* be able to treat such errors as exceptions.
    #After all, where would we get... Oh, nevermind. There *IS* no exception
    #message. Naturally, we have to construct it ourselves from the current call
    #path (namely, the caller name) and ...
    #FUXME: Oh, wait. We need a new zeshy global caching the contents of the
    #current call path -- say, ${ZESHY_EXCEPTION_FUNCFILETRACE} -- to be
    #displayed by ::print_exception_uncaught() when such function is eventually
    #subsequently called. throw_exception() should handle this!
    #FUXME: Note that throw_exception() needs to handle an additional task as
    #well. If (( ${ZESHY_TRY_LEVEL[${SHLVL}]-0} <= 0 )) evaluates to true in
    #such function, then such function needs to explicitly call
    #::print_exception_if_uncaught(). Hmm. Actually, I suppose
    #throw_exception() could simply call
    #::print_exception_if_uncaught() as is -- at least, if it were
    #not for the initial checks such function performed. To amend this, the
    #easiest solution is probably as follows:
    #
    #function throw_exception() {
    #   ...
    #   try {
    #   }:always{
    #   }:
    #}
    #
    #Or perhaps not. That *WOULD* work, but it does seem rather... hacky, yes?
    #The alternative is simply to split the meaningful latter half of
    #::print_exception_if_uncaught() into a separate function
    #print_exception_uncaught() and then have throw_exception() call such
    #function.
    #FUXME: Incidentally, rename ::print_exception_if_uncaught() to
    #::print_exception_if_uncaught_in_always(). The verb "unhandled" encapsulates
    #the exact concept of an uncaught exception being propagated up by the
    #topmost "always :{...}:" block. In such case, the new function previously
    #described would be named ::print_exception_if_uncaught(). So, we have:
    #
    #* ::print_exception_if_uncaught_in_always() calling...
    #* ::print_exception_if_uncaught().
    #
    #Then throw_exception() calls ::print_exception_if_uncaught() as well. Done!
    #FUXME: Wait. O.K.; nice idea, but throw_exception() needs to just copy the
    #few shared lines of code from ::print_exception_if_uncaught(). The two
    #differ too widely. *shrug*
    #FUXME: What we *DO* need is a shared function ::store_exception_status()
    #called by both this and throw_exception(). Such function is passed the
    #exception message *AND* exit status associated with such exception and:
    #
    #* Copies such message into string global ${EXCEPTION}.
    #* Copies such status into integer global ${ZESHY_EXCEPTION_STATUS}.
    #* Copies list globals ${funcstack} and ${funcfiletrace} into list globals
    #  ${ZESHY_EXCEPTION_FUNCSTACK} and ${ZESHY_EXCEPTION_FUNCFILETRACE}.
    #
    #Bloody sweet, yah?

#FUXME: Interesting. I believe we've implemented the entire exception handling
#apparatus here somewhat improperly, largely because we rarely bother catching
#thrown exceptions. When a thrown exception is caught and hence handled, its
#error message should *NOT* be printed to standard error. Clearly, right? But
#that's not how die() currently behaves. Instead, die() currently prints the
#passed error message to standard error immediately -- regardless of whether
#such exception is ever caught higher up the call stack. This is nonsensical.
#So how do we reliably correct this? I'm not terribly sure. A couple choices:
#
#* Since ${CAUGHT} is a shell-specific global *AND* since exceptions can't
#  traverse shell boundaries, we could define a new global
#  ${ZESHY_EXCEPTION_MESSAGE} set by die() to the passed error message. This
#  is probably the most sensible choice. die() should then *NOT* call
#  ::print_exception_uncaught(). The question is: what calls ::print_exception_uncaught()?
#  Specifically, does zsh call TRAPZERR() on unhandled exceptions? I suspect
#  not, in which case I have no idea how to sanely respond to this. I will note
#  that canonical function throw() sets a global ${EXCEPTION} containing the
#  string passed to throw(), which could conceivably replace our use of
#  ${ZESHY_EXCEPTION_MESSAGE} above.
#* Wait. No. The *SENSIBLE* thing to do is simply test for whether or not
#  ${EXCEPTION} is set and nonempty in TRAPZERR(), implying such exception was
#  unhandled. Yes?
#* If that fails, the next best thing will be to check immediately before
#  displaying the shell prompt whether or not ${EXCEPTION} is set and nonempty,
#  at which point such exception could be displayed.
#
#While the latter approach will definitely work if all else fails for exceptions
#thrown in the top-level shell, it fails for exceptions thrown in subshells --
#in which case the current approach is the only reliable solution.
#
#Wait. Technically, we could employ a hybrid approach. Hardly ideal, but a bit
#better than the current approach:
#
#* If ${SHLVL} indicates the current shell to be the top-level shell *AND* such
#  shell is interactive (implying zeshy is handling the prompt), then and only
#  then throw exceptions without also printing exception messages. In such case,
#  implement the above solution of checking immediately before displaying the
#  shell prompt whether or not ${EXCEPTION} is set and nonempty, at which point
#  such exception should be displayed.
#* Else, the current shell is a subshell. Since exceptions cannot cross shell
#  boundaries *AND* since unhandled exceptions do *NOT* appear to trigger
#  TRAPZERR(), throw exceptions by printing exception messages. This prevents
#  callers in the same subshell from catching and stifling such exceptions,
#  but... There appears to be no sane workaround, I'm afraid.
#FUXME: Hmm. The zsh implementation of throw() concludes on this odd bit:
#
#    ## Raise an error, but don't show an error message.
#    #THROW= 2>/dev/null
#
#Honestly, throw() appears to be neither raising an error *OR* showing an error
#message. What happens if we try assigning the exception message to ${THROW}
#*AFTER* calling throw() in die() below?
#FUXME: Thought. Define a new alias try() defined as follows:
#
#    alias try='TRY_BLOCK_ERROR=-2
#    '
#
#This allows us to test whether or not we're in a block possibly handling
#exceptions. Hmm...
#FUXME: That's a first start. But don't forget that "always {...}" resets
#${TRY_BLOCK_ERROR} on entry, thereby "erasing" the assignment such integer by
#*ANOTHER* "try {...}" block containing such "always {...}". To fix this
#properly, we need to leverage a global list and then pop such list on entering
#such "always {...}".
#FUXME: O.K.; such list should be indexed by ${SHLVL}. Treat each list element
#as an integer initialized to 0, incremented on each expansion of try(), and
#decremented on each expansion of a new alias named -- say:
#
#* assuredly().
#* certainly().
#* surely().
#* truly().
#
#Both surely() and truly() read well. By the phrase "tried and true", I'm
#inclined toward truly() at the moment -- but either would do. That being said,
#truly() means little to nothing. surely() at least implies something. truly()
#is simply superificial Victorian verbiage for flair. So, perhaps surely(), eh?
#Bah! In the end, truly() simply reads too well. I just couldn't pull the
#trigger on surely(). This is probably for the best. Gotta go with the gut, in
#the end.
#FUXME: This is some absolutely crazy stuff. But it actually appears to work.
#I'm sure it'll break *HORRIBLY* at some unforseen future date -- but for now,
#seemingly good? Extensive testing required, of course, but... *shrug*
#FUXME: Incidentally, we'll probably want to undefine
#catch_exception_matching_glob_if_found() and shift its documentation to
#truly_catch_exception_matching_glob_if_found(). Basically, *NO* zeshy code should ever
#be calling catch*() anything *ANYWHERE*. In particular, if one were to attempt
#to call catch_exception_matching_glob_if_found() from within a truly() block, 
#FUXME: We need to document a caveat, now. truly() blocks aren't *QUITE* truly.
#Basically, the code of the truly() block...

#   (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#           ::print_exception_uncaught "${EXCEPTION}" "${TRY_BLOCK_ERROR}"
            #FUXME: Don't forget to erase the other ${ZESHY_EXCEPTION_*} globals
            #both here and wherever else we catch exceptions! Grep the codebase
            #for the following line. Since this is becoming unsettingly
            #redundant, we should probably define a new catch_exception()
            #function implementing such behavior. Naturally, call such function
            #both here and in catch_exception_matching_glob_if_found().
            #catch_exception() should make the customary sanity checks, of
            #course.

#FUXME: Define new functions
#output_call_stack_with_funcstack_and_funcfiletrace() and
#print_exception_call_stack(). The former is the lowest-level function for
#doing so; the latter calls the former with list globals storing such call
#stacks for the currently thrown exception. Likewise, output_call_stack() should
#call output_call_stack_with_funcstack_and_funcfiletrace() with the current such
#globals. Sweet, yes?

# Main entry point into zeshy, a shell programming language implemented in pure
# zsh. This script initializes the current zsh environment with support for
# zeshy.

#is _not_ necessarily in
#canonical form and hence may _not_ be an absolute path. 
#
#such script sets this global to the initial
#value of ${0} (i.e., the relative or absolute path with which such script was
#externally run) rather than canonicalizing such value into an absolute path. To
#ensure such path is absolute, consider passing such path to canonicalize_path().
#
#== Implementation Details ==
#
#Such script sets this global to ${0}, the relative or absolute path with which
#such script was externally run. To ensure such path is absolute, consider
#subsequently passing such path to canonicalize_path().

#FUXME: Actually, move the commentary from "bin/zeshy" to here.
#[stderr: string] ::print_exception_uncaught(
#    string error_message1 = "", ...,
#    integer exit_status)
#
#Print the passed exception message (defaulting to the empty string) and exit
#status (presumably associated with such exception via `zsh` integer global
#${TRY_BLOCK_ERROR}) to standard error.
#'

    # Announce such exception globally. Subsequent exception handling
    # functionality tests the global to decide whether an exception was called.
#   typeset -g EXCEPTION="${*}"

# Subsequent exception handling. Record a. Associate the current
    #FUXME: Decent message, but hardly ideal. Instead, check if a function
    #get_exception_message_for_signal_zerr() (or some such) is defined and, if
    #so, defer to such function; else, this seems an adequate fallback.
#   ::store_exception_status "${funcstack[2]-}() failed with " "${exit_status}"
    #FUXME: O.K.; so we currently just pass an empty exception message. Ensure
    #that ::print_exception_uncaught() doesn't attempt to display such message,
    #please!
    #FUXME: Actually, rather than have an empty message, it'd be great to do the
    #following:
    #
    #* If function 

#FUXME: Rename output_call_stack() to output_call_stack(). I'm not really
#concerned that such function fails to page output. It does pretty much
#everything else expected of a high-level printer, so... There you go.
#If this function was called from within the topmost `always {...}` block of the
#call path for the current shell _and_ such block failed to catch a thrown
#exception, catch such exception. Specifically, print such exception to standard
#error, .

# See die() for further
#details, which calls this function to perform such printing.
#metadata requested by the current user 

#alias '}--'='    if (( ${ZESHY_TRY_LEVEL[${SHLVL}]-0} <= 0 )) {
#        if (( ${+ZESHY_TRY_LEVEL[${SHLVL}]} == 0 )) {
#            print "zeshy: \${ZESHY_TRY_LEVEL[${SHLVL}]\} undefined" 1>&2
#        } else {
#            print "zeshy: \"always\" block preceded by no \"try\" block" 1>&2
#            ZESHY_TRY_LEVEL[${SHLVL}]=0
#        }
#
#        (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#    } else {
#        ZESHY_TRY_LEVEL[${SHLVL}]=$(( ZESHY_TRY_LEVEL[${SHLVL}] - 1 ))
#
#        if (( ${+EXCEPTION} && ZESHY_TRY_LEVEL[${SHLVL}] == 0 )) {
#            (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#
#            ::print_exception_uncaught "${TRY_BLOCK_ERROR}"
#            print ok
#        }
#    }

        # If an exception was thrown, handle such exception (hopefully) without
        # inducing additional exceptions. Specifically, return success from both
        # the current function and "always {...}"
        # block *AND* "catch" such exception as documented above. For
        # robustness, inline such test rather than calling
        # catch_exception_matching_glob_if_found(). Since no function is
        # guaranteed to exist , . See such function for further details.
            # If catch_exception_matching_glob_if_found() is still defined, catch such exception
            # and print a warning.
#            if { typeset -f catch_exception_matching_glob_if_found &>/dev/null } {
#                # Call such function to catch such exception.  While
#                # catch_exception_matching_glob_if_found() has been aliased to disable filename
#                # globbing for such function and hence could be passed an
#                # unquoted glob, quote such glob for safety (e.g., when such
#                # alias is intentionally or unintentionally deleted).
#                if { catch_exception_matching_glob_if_found '*' } {
#                    # If such function set ${CAUGHT} to the thrown string, print
#                    # such string. This is the typical case.
#                    if (( ${+CAUGHT} )) {
#                        print "zeshy: exception handler threw exception \"${CAUGHT}\""
#                    # Else, ${CAUGHT} remains unset. While this should never
#                    # happen, one can never be too careful.
#                    } else {
#                        print "zeshy: exception handler failed with non-zero exit status"
#                    }
#                }
#            # Else, something awful. Print a despicable warning.
#            } else {
#                print 'zeshy: catch_exception_matching_glob_if_found() undefined (e.g., due to exception handler throwing exception)'
#            }

#FUXME: Excise. We now implement zeshy-specific analogues of such functions.
# Astonishingly, zsh implements throw() and catch() as user-defined functions
# autoloaded from list ${fpath} for the current user. Autoload such functions
# before called by functions below. Defer all other autoloads to
# startup_zeshy_autoloads().
#autoload -U throw catch

# The catch() implementation selectively disables filename globbing for such
# function by defining an alias of the same name. Since such alias is
# unavailable on the first call to catch(), define such alias here.
#alias catch='noglob catch'

#FUXME: Shift to @{always/exception}. There's really no rational reason to have
#this here. Refactor ::print_exception_uncaught() to manually implement such globbing and
#resultant handling. Yum!
#ZESHY_CORE_HELP_ALIASES+='
#[status: boolean] catch_exception_matching_glob_if_found(string exception_glob)
#
#Catch an exception matching the passed glob thrown by the `{...}` block
#preceding the `always {...}` block presumably calling this function if an
#exception was thrown matching such glob or return failure otherwise. In the
#former case, this function ``catches'' such exception by setting string global
#${CAUGHT} to ${EXCEPTION} (i.e., the string that was thrown), unsetting
#${EXCEPTION}, and returning success. If no exception was thrown _or_ was but
#fails to match such glob _or_ this function was _not_ called in an
#`always {...}` block, failure is returned. See throw_exception() for further
#details.
#'
## Permit globs to be passed unquoted to catch_exception_matching_glob_if_found()
## by disabling filename globbing for such function.
#alias    catch_exception_matching_glob_if_found='noglob catch_exception_matching_glob_if_found'
#function catch_exception_matching_glob_if_found() {
#    # Validate sanity. Since this function is typically called from within
#    # exception handlers (i.e., "always {...}" blocks), return failure from such
#    # handler rather than throwing yet another exception.
#    (( # == 1 )) || {
#        print "zeshy: catch_exception_matching_glob_if_found() expected one glob but received:\n${*}" 1>&2
#        (( ${TRY_BLOCK_ERROR-0} )) || TRY_BLOCK_ERROR=1
#        return 1
#    }
#    die_unless_in_always
#
#    # If an exception was thrown *AND* such exception matches such glob, return
#    # success from both the current function and "always {...}" block *AND*
#    # "catch" such exception as documented above.
#    if (( ${+EXCEPTION} )) && [[ "${EXCEPTION}" == ${~1} ]] {
#        TRY_BLOCK_ERROR=0
#        typeset -g CAUGHT="${EXCEPTION}"
#        unset EXCEPTION
#        return 0
#    }
#
#    # Else, return failure.
#    return 1
#}

    #FUXME: I have no idea what this does. It doesn't appear to be strictly
    #necessary, in any case. Disabled for now.
    #FUXME: I get it. I think throw() is actually trying to induce an error
    #here. Which is a bit odd, admittedly. This sort-of implies that zsh does
    #something internally to know that a call to throw() should unwind the
    #current call stack. Without having actually looked, I have no idea what.
    #It doesn't particularly matter, I suppose, as return 1 suffices as well.
    #FUXME: "return 1" does *NOT* suffice. The error this induces appears to
    #produce exactly the sort of stack-unwinding that exception handling
    #requires. Interesting... Document, anyway.

    #FUXME: Correct documentation.
    # Return failure, triggering TRAPZERR() and hence 
#   return 1

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with rethrow_exception().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If this function was not called from within an "always {...}" block *OR*
    # if ${TRY_BLOCK_ERROR} is undefined (which it should never be), throw an
    # exception. By definition, we are not currently in an exception handler, so
    # this is always safe.

    # If the caller passed either no pattern or more than one patterns, print a
    # fatal error and return failure.
        # Since this function was not called from within an "always {...}"
        # block, there's little point in setting ${TRY_BLOCK_ERROR} to nonzero
        # exit status to indicate failure. Instead, simply return such status.
#       return 1

    # throwing an
    # fatal error and return failure. See throw_exception() for further details.
#FUXME: Excise after we refactor everything to call
#truly_catch_exception_matching_glob_if_found() instead.
#FUXME: Excise. No longer required!
#alias truly:='always {
#    if (( ${ZESHY_TRY_LEVEL[${SHLVL}]-0} <= 0 )) {
#        if (( ${+ZESHY_TRY_LEVEL[${SHLVL}]} == 0 )) {
#            print "zeshy: \${ZESHY_TRY_LEVEL[${SHLVL}]\} undefined" 1>&2
#        } else {
#            print "zeshy: \"truly\" block not paired with prior \"try\" block" 1>&2
#        }
#
#        if (( ${TRY_BLOCK_ERROR-0} == 0 )) {
#            TRY_BLOCK_ERROR=1
#        }
#    } else {
#        ZESHY_TRY_LEVEL[${SHLVL}]=$(( ZESHY_TRY_LEVEL[${SHLVL}] - 1 ))
#
#        if (( ZESHY_TRY_LEVEL[${SHLVL}] == 0 )) {
#            ::print_exception_uncaught "${TRY_BLOCK_ERROR}"
#            print ok
#        }
#    }'

    #FUXME: If the current shell is non-interactively interpreting a script
    #(e.g., driven by a shebang) and such script fails, the following command
    #prints an unhelpful error resembling:
    #
    #/home/leycec/zsh/zeshy/src/main() failed with exit status 1
    # "./tmp/tmp.zeshy" { /home/leycec/zsh/zeshy/src/main: 1398 }
    #  "/home/leycec/zsh/zeshy/src/main" { /usr/local/bin/zeshy: 206 }
    #
    #In fact, I suspect that whenever this source() fails, it always do so with
    #an unhelpful message.


#    if (( ${+ZESHY_TRY_LEVEL[${SHLVL}]} == 0 )) {
#        TRY_BLOCK_ERROR=1
#        print "zeshy: \${+ZESHY_TRY_LEVEL[${SHLVL}]}" 1>&2
#        false
#    } elif (( ZESHY_TRY_LEVEL[${SHLVL}] <= 0 )) {
#        TRY_BLOCK_ERROR=1
#        print "zeshy: \"truly\" block not paired with prior \"try\" block ()" 1>&2
#        false
#    } 

                # catch() with the above alias and hence could write "catch *"
                # rather than "catch '*'". However, note that the former fails
                # with obscure errors when such alias is (either intentionally
                # or unintentionally) deleted. For safety, quote such glob.
#FUXME: Fantastic idea. Unfortunately, it doesn't work for the intended use
#case. The reason appears to be that zsh performs command substitutions *BEFORE*
#applying the assignment to the temporary integer global ${COLUMNS}. This can be
#circumvented by implementing a new die_evaluated() function evaluating the
#passed string in the context of such assignment. Rather ugly, but there we are.

# Wrap the die() function in an alias of the same name to ensure error messages
# are formatted to a reduced terminal width. This ensures commands resembling
# the following behave as expected:
#
#     >>> die "Runnable info() already defined as: $(print_runnable info)"
#
# In the prior example, the embedded call to print_runnable() calls
# print_message_heading() calling get_terminal_width() to restrict such heading
# to the current terminal width. When print_error() becomes available during
# zeshy startup, die() defers to such function for printing exception messages.
# Since such function confines such messages to an ANSI box, however, such
# messages and hence the prior heading embedded in such message should actually
# be restricted to less than the current terminal width (namely, to the
# current terminal width minus the width of the left and right box borders).
#
# This alias ensures such restriction by temporarily overriding the current
# terminal width for the duration of the call to die() if the helper function
# get_terminal_width_for_errors() is defined or doing nothing otherwise.
#alias die='COLUMNS="$(\
#    if { typeset -f get_terminal_width_for_errors &>/dev/null } {
#        get_terminal_width_for_errors
#    } else {
#        print -r -- "${COLUMNS}"
#    })" die'

        #FUXME: Ensure tighter bounds on such status -- specifically, that it
        #resides in the range [
#setopt notify            # report background job status immediately only before prompt printing
        # Print a blank line.
#       print

#FUXME: Nonsense. I mean, imagine having to run "ZESHY_IS_DEBUG= zeshy" just
#to enable release logic? We need instead two new options "--debug" and
#"--no-debug". Fairly straightforward here. For the moment, option "--verbose"
#should simply enable option "--debug", under which all debug handling should
#be centralized. Then, by default under git, just enable option "--debug".

# If the current script resides in a developer-specific git repository rather
# than a general-purpose installed copy of zeshy, implicitly enable developer-
# specific debug options. Developers may prevent this by setting environment
# variable ZESHY_IS_DEBUG to the empty string when running zeshy: e.g.,
#
#     >>> ZESHY_IS_DEBUG= zeshy
#
# zeshy's install script removes all lines containing "@ZESHY_IS_DEBUG@" and
# hence the entirety of the conditional below, ensuring these options remain
# disabled by default under installed copies of zeshy.
#if (( ${ZESHY_IS_DEBUG-1} )) {                            # @ZESHY_IS_DEBUG@
#    arg_options[--compile-digest-if-zeshy-changed]=  # @ZESHY_IS_DEBUG@
#    arg_options[--verbose]=                               # @ZESHY_IS_DEBUG@
#}                                                         # @ZESHY_IS_DEBUG@

#If this path is the empty string, `zeshy` avoids reading from or writing to this
#directory or files or subdirectories of this directory. For sanity, `zeshy` loads
#with default user settings _and_ sources the entire `zeshy` codebase. Since this
#is understandably slow, avoid passing option `--no-zeshy-dot-dir` except where
#required (e.g., package manager installation).

# Avoid declaring boolean globals for command-line options "--compile-digest" or
# "--compile-digest-if-zeshy-changed". While doing so is certainly
# feasible, such globals have no bearing on post-startup behavior  persist past  complicate post-startup behavior; in particular,

# If true, recompile zeshy's user digest file -- regardless of whether a
# dependency of such file has changed since such file's last compilation. Do
# *NOT* bother declaring this boolean. Unlike
# ${ZESHY_USER_DIGEST_FILE_IS_DEPENDENT_ON_ZESHY_HOME}, of which post-startup
# testing by is_zeshy_dot_digest_outdated() appears reasonable, post-startup
# testing by the same function of this global is nonsensical. When the caller
# passes "--compile-digest", they expect such recompilation to occur only once
# at initial startup and then subsequently revert to normalcy -- *NOT* to force
# is_zeshy_dot_digest_outdated() to return true on all subsequent calls.
#
# on the next `zeshy` startup. Note that regardless
#of the value of this boolean, `zeshy` always recompiles such digest on upgrading
#such codebase to a new version

#FUXME: Booleans should be converted from string to integer types. Tests must
#be modified accordingly, I'm afraid.
#FUXME: This is completely backwards. Such global should be set *AFTER* option
#"--verbose" is parsed and then set to the same value as such option. To ensure
#such option is set when running zeshy from a git repository, change the logic
#below to the following:
#
#   if [[ -n "${ZESHY_IS_DEBUG:-@ZESHY_IS_DEBUG@}" ]] { arg_options[--compile-digest-if-zeshy-changed]=; arg_options[--verbose]= }
#
#Such conditional has two consequences:
#
#1. It can still be overriden when running zeshy from a git repository, but
#   defaults to nonempty in such case.
#2. By compacting such conditional onto a single line, zeshy's install script
#   can simply delete *ALL* lines containing "@ZESHY_IS_DEBUG@". Hence, when
#   *NOT* running zeshy from a git repository, such conditional will never be
#   evaluated at all -- exactly as desired.
#3. When *NOT* running zeshy from a git repository, such behavior is easily
#   emulated by simply passing such command-line options to zeshy. Done!

# zeshy's installation script defaults such boolean to true if installing a
# debug build and false otherwise. When uninstalled (e.g., run from a git
# repository), such boolean defaults to true.
#integer -g ZESHY_IS_DEBUG=1 #@ZESHY_IS_DEBUG@

# If debugging zeshy, forcefully enable debug-specific options *BEFORE* testing
# whether or not at least one such option was passed.
#if (( ZESHY_IS_DEBUG )) {
#    arg_options[--compile-digest-if-zeshy-changed]=
#    arg_options[--verbose]=
#}

#If `zeshy`\''s user configuration enables debugging, run the passed command;
#typeset -g ZESHY_USER_DIGEST_FILENAME="${ZESHY_USER_CACHE_DIR}/digest.zwc"
#FUXME: zeshy's install script should replace such string with a value
#corresponding to whether or not a release or debug build is being installed.

#   if [[ -n '@ZESHY_IS_DEBUG@' ]] { arg_options[--compile-digest-if-zeshy-changed]=; arg_options[--verbose]= }
    # Undefine all aliases defined by such recompilation. The reasons why are,
    # unsurprisingly, subtle. The subsequent call to startup_zeshy() and hence
    # startup_zeshy_globals() may declare list or map globals containing
    # unquoted elements equal to zeshy-specific global alias names (e.g., "is"),
    # in which case such call will fail with an unhelpful parse error if such
    # global aliases exist. Undefining all aliases undefines such problematic
    # global aliases, as desired.
#   if [[ -n "${ZESHY_ALIAS_NAMES-}" ]] {
#       unalias -- "${ZESHY_ALIAS_NAMES[@]}"
#   }

#FUXME: Actually use such alias in lieu of current is_zeshy_debug_and() use.
#is_zeshy_debug_and command="print -r -- 'zeshy: 

#FUXME: Rename to ${ZESHY_IS_DEBUG}. ${ZESHY_IS_DEBUG} 'tis a silly name.

# Printing traces is essential, particularly at zeshy
        # bootstrap (before such # function is autoloaded from zeshy's user digest file.
#If the zeshy function to do so has not
        # yet been defined, attempt a stub implementation... 
# Explicitly load only the subset of requisite zsh modules (i.e., C-based shared
# libraries bundled with zsh) for which no appropriate autoloadable function
# exists. Since all other requisite zsh modules supply autoloadable functions
# implicitly loading their parent module on the first call to such function, we
# explicitly load no other modules.

#FUXME: Oh. Wait. But then we can't define any other user paths, *INCLUDING
#THOSE IN CONFIG FILES*. Right. That doesn't work.
#FUXME: Wait. This exposes a fatal flaw with the current approach: passing
#"--no-zeshy-dot-dir" will permanently compile Zeshy (until the next
#compilation without such option, anyway) without *SOME* dot directory files,
#as such files are compiled from "if_config/zeshy". That, in turn, suggests
#that we need to shift such globals from such configuration file *BACK* here.
#No choice, really; they depend on passed command line options and hence cannot
#be baked into Zeshy's user digest.
#system-wide directory containing the 
# See declare_alias(),
# declare_function(), and declare_global() for further details.
#FUXME: Nice, but a bit belated... I finally discovered how to reliably use curly braces for all
#conditional blocks. It's astonishingly simple: delimit the test in curly braces, too!
#
#    # Hence, this...
#    if true; then
#       print ok
#    fi
#
#    # ...is always reliably reducible to this.
#    if { true } {
#       print ok
#    }
#
#This extends to while, case, etc. statements. *sigh*

#setopt extended_history  # save timestamps in history
# Ignore duplicate history items during <Ctrl-[rs]>-style history searches.
#setopt hist_find_no_dups

# Prefer expiring duplicate to non-duplicate history items, when required due to
# reaching the maximum history size. Avoid also setting "hist_ignore_all_dups",
# which conflicts with this option.
#setopt hist_expire_dups_first

                # Note that although zsh "info"
                # documentation is section "Exception Handling" explicitly
                # states the catch glob expression to *NOT* require quoting
                # (e.g., "catch *"), doing so silently fails without actually
                # catching anything!

#Since this path may be the empty string, no Zeshy functionality may assume such
#path to be non-empty. Test this global for non-emptiness before reading from or
#writing to this directory or files or subdirectories of this directory.

#FUXME: Either the documentation or implementation is wrong. In any case, I'm
#not convinced *EITHER* is right. We really want to implicitly throw exceptions
#on triggering TRAPZERR(), don't we? As stated below, throwing exceptions
#interacts sanely with "always" blocks -- this doesn't. It's still a sane
#implementation, but one wonders if we can't do better.
            # If an exception was thrown, print such exception.
#           if (( ${+EXCEPTION} ))
#           then print "zeshy: exception handler threw exception \"${EXCEPTION}\""
            # Else, a command returned non-zero exit status.
#           else print "zeshy: exception handler failed with non-zero exit status"
#           fi
            # While zsh should set global ${CAUGHT} to the name of the uncaught
            # exception, it infrequently appears not to. Handle this.
#Handle the exception resulting from the passed presumably non-zero exit status,
#typically by printing such exception to standard error if desired by the current
#user.

#return non-zero exit
#status, effectively throwing an exception as discussed under TRAPZERR().
#set_function_documentation handle_exception '
#string handle_exception(integer exit_status)
#
#Handle the exception resulting from the passed presumably non-zero exit status,
#typically by printing such exception to standard error if desired by the current
#user.
#'
#function handle_exception() {

# This placeholder implementation called only when
# bootstrapping Zeshy will be replaced when loading Zeshy''s digest file.
    # Before calling *ANY* functions throwing exceptions on failure, 

    #FUXME: Is this overkill? What happens if we return 1 instead? Forcefully
    #trigger this... and see!
    #FUXME: Uhm; we already validate this below. Hmm.
    # Validate passed arguments. Avoid returning non-zero exit status on fatal
    # errors, as such status triggers an exception and hence infinite recursion.
#   (( # == 1 )) || {
#       print 'zeshy: handle_exception() expected one exit status' 1>&2
#       return 0
#   }

    # See is_integer_nonnegative() for implementation details.
#   local exit_status="${1}"
#   [[ "${exit_status}" == <-> ]] || {
#       print "zeshy: handle_exception() exit status \"${exit_status}\" not a positive integer" 1>&2
#       return 0
#   }

    #FUXME: Consider catching exceptions thrown by Zeshy startup and responding
    #appropriately...somehow.
#   }
#${#} -ge 1 and
#(( ${#} )) and is_string_nonempty "${@}"

#FUXME: Option parsing has become sufficiently long to warrant extrication into
#a new top-level component "options". Since sourcing files is moderately
#expensive and since we don't need to source such file unless passed at least
#one option, consider the following efficient conditional:
#
#(( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) &&
#    source options
#
#Assuming no options to be passed (as will be the typical case under release
#builds), this should actually be faster than the current method (as we manually
#test whether each option is enabled or not).

    #FUXME: Extract into a new throw_exception() function for use in the
    #new die() function.
# ....................{ PRINTERS                           }....................
# Declare placeholder functions to be overridden after loading the Zeshy digest.

#set_function_documentation say '
#void say(string message = "")
#
#Print the passed message suffixed by a trailing newline to standard output.
#This placeholder implementation called only when bootstrapping Zeshy will be
#replaced when loading Zeshy''s digest file.
#'
#function say() {
    #FUXME: Quite certain we want to replace all "[[ -o interactive ]] && say"
    #and "interactively say" with merely "say". (The former are patently silly
    #and, let's be honest, dangerous, by duplicating logic *EVERYWHERE*.) That
    #said, I'm not convinced that the solution here is to simply prepend this
    #statement with "[[ -o interactive ]] && "; the problem, of course, are
    #pipes. We want functions like the following to work:
    #    function testem() { say 'Oh, hello!'; }
    #    testem | cat
#    print "zeshy: ${@}"
#}
#
#set_function_documentation cry '
#void cry(string message = "")
#
#Print the passed message suffixed by a trailing newline to standard error.
#This placeholder implementation called only when bootstrapping Zeshy will be
#replaced when loading Zeshy''s digest file.
#'
#function cry() {
    # Print this message. Do *NOT* call print() as "print -u2 -- "${message}".
    # While that appears superficially identical to the following call, passing
    # the desired file descriptor as an argument fails to preserve interleaving
    # with prior commands printing to file descriptor 1 (i.e., standard out).
#    print "zeshy: ${@}" 1>&2
#}

#FUXME: Add ANSI coloring to sayed messages if on an ANSI-capable terminal.
#Also, consider prefixing messages under cron with: "["$(date +'%F %T')"].

#FUXME: *WAIT*. We only need to define a placeholder say() and cry() here
#prefixing *ALL* passed messages with "zeshy: ".
#The real say() and cry() implementations should be subsequently defined by
#the currently enabled theme. Make it so with a sprinkle of ANSI excellence.
#(( ${#arg_options} + ${#arg_shell_commands} + ${#arg_shell_options} )) and {
#           print 'printing usage!'
#           print 'exiting zsh!'
            #FUXME: Revert to return_true() after correcting startup regression.
#           exit_zsh
# While is_zeshy_debug_and<> is expanded frequently enough to warrant such
# alias, this boolean is expanded only once elsewhere. Avoid alias overkill.
# If Zeshy's codebase resides in a directory with basename "src", implicitly
# enable all options below. Such options are generally desirable when debugging
# Zeshy's developer-specific codebase, naturally residing under directory "src".
# In other words, this is a special case facilitating developer torpitude.
# (Hopefully, the cost of such test for non-developers is negligible......)
#[[ "${ZESHY_HOME}" == *'/src' ]] && {
#if (( ${+arg_options[--verbose]} ))
#then alias is_zeshy_debug_and=''
#else alias is_zeshy_debug_and='true ||'
#fi
#FUXME: This is terrible. I've since stumbled on the obvious solution: restore
#global boolean ${ZESHY_IS_DEBUG}, but do so *AT THE TOP OF THIS FILE*
#rather than in the configuration file. Default such global as follows:
#
#    ZESHY_IS_DEBUG=${ZESHY_IS_DEBUG-'@ZESHY_IS_DEBUG@'}
#
#So, the caller can override such global which defaults to non-empty. On
#installation, Zeshy's install script should (obviously) delete the hard-coded
#'@ZESHY_IS_DEBUG@' (i.e., replace such string with the empty string).
#Perfectimo.
#detecting an upgrade to new versions of Zeshy.
# Absolute paths for Zeshy-specific directories and files. See commentary below.
#   ZESHY_DOT_DIR\
#   ZESHY_DOT_DIR_BASENAME\
#   ZESHY_USER_CACHE_DIR\
#   ZESHY_USER_CONFIG_DIRNAME\
#   ZESHY_USER_OVERLAY_DIR\
#   ZESHY_USER_DIGEST_FILENAME\
#   ZESHY_USER_VERSION_FILE

# In either case, such alias
# eliminates the non-negligible cost of testing option
# "--verbose" each debug statement, thus simulating conventional
# debug statements.
#
# While zsh implements no conventional debug-specific builtins (e.g., assert()),
# it does offer a sufficiently general-purpose, language-level device for
# simulating such builtins: aliases.
#
# Conventional high-level language compilers and interpreters reduce debug
# statements to noops when targeting release builds, eliminating the otherwise
# non-negligible cost of such statements. While zsh provides no conventional
# debug-specific builtins (e.g., assert), it does offer a general-purpose,
# language-level mechanism for simulating such builtins: aliases.
#
# Default such alias to ignore the passed command. If Zeshy's user configuration
# files enable debugging, redefine such alias after sourcing such files to run
# the passed command instead.

# If such scripts enable Zeshy debugging, redefine is_zeshy_debug_and<>
# defined at the top of this component to run the passed command instead.
#FUXME: Rename to ZESHY_USER_CACHE_DIGEST_FILE.
#FUXME: Rename to ZESHY_USER_CACHE_VERSION_FILE.
#is -n "${ZESHY_IS_DEBUG-}" si and printf\
#FUXME: Parse ${arg_options} and ${arg_shell_commands} here. Test a bit, of course.

#   typeset -p ZESHY_COLOR
#   typeset -gAx ZESHY_COLOR
#   typeset -p ZESHY_COLOR
    #   print -l "===ZESHY_GLOBAL_NAMES===" "${ZESHY_GLOBAL_NAMES[@]}"
    #   print "glob: ${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY}"
# Unfortunately, at least the sourcing of Zeshy component "autoload" must be
# performed from a global rather than function context. The reason is, of course, subtle:
# zsh fails
# to to properly unset globals declared from a function transitively called
    # Do so.
#   load_zeshy
#   typeset -p ZESHY_COLOR

#set_function_documentation load_zeshy '
#void load_zeshy(void)
#
#Load Zeshy into the current zsh shell. '
#function load_zeshy() {
#    # Validate passed arguments.
#    (( # == 0 )) || die 'expected no arguments'

#FUXME: O.K.; interesting. This *CAN'T* be a function. Fair and simple enough.
#typeset -gAx ZESHY_COLOR
    #FUXME: Kill this. Kill this soon. (You know you want to...)
#   setup_zeshy
    # Delay validating passed arguments aside from the number of such arguments
    # to subsequent serialization of such arguments to disk following digest
    # recompilation. This permits an intuitive calling style of calling this
    # function before declaring the function name passed to this function.
# Declare set_function_documentation() before defining the other two, as
# the latter depend on the former.
# Consider calling document_function() instead.
#To subsequently print such
#documentation, call print_function_documentation().
    # Validate passed arguments.
#   local function_name="${1}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_DOCUMENTATION
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_HELP_STRING
#    ZESHY_FUNCTION_NAME_TO_HELP_STRING[${1}]="${2}"
#typeset -Agx ZESHY_FUNCTION_NAME_TO_DOC_STRING
#    ZESHY_FUNCTION_NAME_TO_DOC_STRING[${1}]="${2}"

#is_boolean_true ZESHY_IS_DEBUG and printf\
#FUXME: Source all remaining arguments via source_shell_script().
# Source such arguments *AFTER* printing Zeshy's startup time to avoid
# incrementing such time by the time required to source such arguments.
#FUXME: If ${ZESHY_IS_DEBUG}, print out a brief line printing timing statistics:
#namely, how quickly Zeshy started up. *ALWAYS* start timing as the first line
#of this file, since we won't have access to ${ZESHY_IS_DEBUG} for a bit of
#time. (What's the best way to perform shell profiling? Google us up.) Hmm;
#don't adopt the "zprof" solution, which imposes a bit too much overhead. We
#want a no-overhead -- the "times" command looks particularly helpful. Is there
#any way to reset the "times" timer? Alternatively, if we could somehow run this
#entire script prefixed by "time"... Heavy-weight, though. "times" would be
#preferable, really. Perhaps an initial implementation should just do:
#
#local ZESHY_TIME_STARTUP
#[[ -x "${${:-lsb_release}:c}" ]] &&
#  ZESHY_TIME_STARTUP="$(date "+%s%N)"
#
#Only trouble there is that the default profile may not have been established.
#Ah-ha! Knew it. zsh helpfully provides a builtin module circumventing such
#difficulties: "zsh/datetime". So, at the very top of this script:
#
## Load module "datetime", providing global list ${epochtime} expanded below.
#zmodload zsh/datetime
#
## Time in seconds and nanoseconds since the Unix epoch at which Zeshy was first
## loaded (i.e., at which the current script was first sourced).
#export -i ZESHY_TIME_START ZESHY_STARTUP_TIME_NANOSECONDS
#
## Get such times from global list ${epochtime}, whose:
##
## * First shell word has the current time in seconds since the Unix epoch.
## * Second shell word has the current time in nanoseconds since the epoch.
##
## For reliability, expand such shell words at the same time.
#for ZESHY_TIME_START ZESHY_STARTUP_TIME_NANOSECONDS in ${epochtime}
#do; done
#
#Brilliant! Make it so.
# accuracy, avoid calling Zeshy-specific functions to do so.
    # Time in seconds and nanoseconds since the Unix epoch at which Zeshy
    # startup completed.
#   float ZESHY_TIME_START="${EPOCHREALTIME}"

    # Print such synopsis as a single statement to minimize shell overhead.
# Time in seconds and nanoseconds since the Unix epoch at which Zeshy was first
# loaded (i.e., at which the current script was first sourced).
#integer ZESHY_TIME_START ZESHY_STARTUP_TIME_NANOSECONDS

# Set such times from global list ${epochtime}, whose:
#
# * First shell word has the current time in seconds since the Unix epoch.
# * Second shell word has the current time in nanoseconds since the epoch.
#
# For reliability, expand such shell words at the same time.
#for ZESHY_TIME_START ZESHY_STARTUP_TIME_NANOSECONDS in ${epochtime}
#do; done
    # Time in seconds and nanoseconds since the Unix epoch at which Zeshy
    # startup completed.
#   integer ZESHY_STARTUP_END_TIME_SECONDS ZESHY_STARTUP_END_TIME_NANOSECONDS

    # Set such times. See the top of this script for further details.
#   for ZESHY_STARTUP_END_TIME_SECONDS ZESHY_STARTUP_END_TIME_NANOSECONDS in\
#       ${epochtime}; do; done

#FUXME: Rename "curse_" to "print_" here and below, and reform handle_exception()
#to simply redirect output of such functions to standard error. Simple: centralize
#such redirection in one place rather than in every print statement in such
#functions.

#       print 1>&2  # print a blank line to standard error
#if (( #arg_options ))
#then for key ("${(k)arg_options}") print "arg_options[${key}]=${arg_options[${key}]}"
#else print "arg_options empty; args: ${*}"
#fi
#FUXME: Rename "print_" back to "print_" *EVERYWHERE*.
#FUXME: Rename "curse_" to "admit_" (?) *EVERYWHERE*. To search for applicable alternatives,
#search synonyms of "complain" and "confess". Ah! Right. Why not "curse". I
#still quite like it after all these years. It's readily replaceable, anyway, if
#we elect for something else. O.K.; go "curse" it!
#zeshy_alias_cli_substitution_names_for_gui_commands
#zeshy_alias_clies_substituting_gui_commands
#zeshy_alias_clies_for_gui_commands
#zeshy_alias_clies_for_cli_commands
#zeshy_alias_cli_substitutions_graphical
#zeshy_interactive_selfaliases_graphical
#zeshy_alias_cli_substitution_names_run_disowned
#zeshy_command_names

#zeshy_alias_cli_substitution_names_run_disowned
#zeshy_alias_cli_substitution_names

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: This isn't right at all. *IT'S FAIRLY IMPORTANT WE FIX THIS PRIOR
    #TO RELEASE*. Basically, shouldn't we *ALWAYS* throw an exception? That
    #ensures expected behavior in Zeshy scripts with respect to "always"
    #blocks, whereas the current implementation completely falls down. I have
    #no idea why we adopted the current implementation, in fact. It seems
    #blatantly brain-dead...and not in the kitsch Peter Jackson way, either.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If called under an interactive shell, unwind the call stack to return the
    # current user to an interactive prompt; otherwise, exit this shell script.
    #
    # Note that the simpler command "return ${exit_status}" implicitly invokes
    # the "err_return" and TRAPZERR() handlers and hence (ultimately) performs
    # the same logic, but that such invocation produces less readable stack
    # traces. Consequently, we prefer the present implementation.
#   if [[ -o interactive ]]
#   then throw ZeshyException
#   else exit ${exit_status}
#   fi

#       print 1>&2  # print a blank line to standard error
#       print_exception_status "${1}"
#then ZESHY_IS_LOADING=
#print "zeshy: ZESHY_IS_LOADING=${ZESHY_IS_LOADING}"

# Load Zeshy and grace the saffron skies with fullsome zest! All shell commands
# following this conditional may safely access all Zeshy aliases, globals, and
# functions. Specifically:
#
# * If loading Zeshy, do so.
# * Else if Zeshy has not been previously loaded under the current shell (as
#   implied by the lack of get_zeshy_version()), throw an exception.
#if [[ -n "${ZESHY_IS_LOADING}" ]]
#then load_zeshy
#elif ! typeset -f -- get_zeshy_version &>/dev/null
#then die "get_zeshy_version() not defined and hence Zeshy not loaded"
#fi

#FUXME: O.K.; the whole "--no-zeshy-reload-by-same-process" thing doesn't work,
#since zsh oddly executes the passed script *BEFORE* performing startup
#behavior. Extremely unexpected, but there you are. I see no sane way around
#this without the general rule: Zeshy prohibits reloading itself from the same
#process. Period. That's it. Sorry, but them's the unfortunate breaks.

# If non-empty, make and use the user-specific Zeshy directory ${ZESHY_DOT_DIR}
# and all subdirectories and files of such directory; else, load Zeshy with
# default configuration and shell settings and no digest file. Unlike the
# similar boolean ${ZESHY_IS_LOADING}, publish this boolean globally; numerous
# Zeshy functions called after startup need to know about the "situation."
#export ZESHY_DOT_DIR=1

# ....................{ LOCALS                             }....................
# If non-empty, load Zeshy; else, only handle arguments passed to this script.
#local ZESHY_IS_LOADING=1

#FUXME: If ignoring the Zeshy user directory, disable the corresponding boolean.
#(( ${+arg_options[--no-zeshy-dot-dir]} )) && ZESHY_DOT_DIR=

#FUXME: Consider renaming "ZESHY_USER_" to "ZESHY_USER_" everywhere. Much more
#explanatory and slightly conciser.

#   -no-zeshy-dot-dir -no-zeshy-reload-by-same-process ||
#print "zeshy: funcstack[1]=${funcstack[1]}"
#sleep 2
#exit
#, but Zeshy has been at least partially previously loaded"
    # Bootstrap Zeshy by loading core aliases, globals, and autoloads, the minimal
    # clique of Zeshy components. All subsequent Zeshy functions are implicitly
    # loaded on the first call to such functions by the autoload system.
    # Specifically, set global string ${PATH} and a sane umask and source the
    # expected startup scripts (e.g., under "/etc/profile.d/").
#FUXME: We really need such boolean? Hmmm. Probably. But let's make sure.
#FUXME: Woops. This is pretty much completely wrong for actual Zeshy
#installations (e.g., into "/usr/share/zeshy", containing the current contents
#of "~/zsh/zeshy/src"). ZESHY_HOME and ZESHY_HOME should *ALWAYS* be the
#same exact thing. Hence, remove the latter and set the former as follows:
#
#[[ -n "${ZESHY_HOME-}" ]] || export ZESHY_HOME="${0:h}"(:A)
#
#We should probably remove all setting of such variable from
#"etc/{zlogin,zprofile,zshrc}", perhaps suggesting "etc/{zlogin,zshrc}" should
#be removed entirely and "etc/zprofile" reduced to just running "zeshy". (Or
#perhaps just "etc/zshrc" reduced to running "zeshy" and the others removed?)

# as the latter establishes the global ${PATH} required by the former. To avoid
# reduplication,
#
# (e.g., for
# finding commands in the global ${PATH} with word modifier ":c").
#    # See "compile" for further details on clever expressions like this.
#   [[ -x "${${:-lsb_release}:c}" ]] &&
#FUXME: This conditional needs testing, clearly.
#FUXME: Damn. It's broken. zsh doesn't set it as I expected; hence, we need to
#manually parse an option "--no-reload". Do so above and test for
#"(( ${+arg_options[--no-reload]} ))" here. I'm fairly sure we can just replace
#the "false &&" with the above test... and everything (might) just work. Ah;
#well, yes. *TECHNICALLY*, the logic below would work -- but it's overkill.
#Wait...no, it's not. It's the option name that's wrong: it's too succinct.
#Rename such option to "--no-reload-by-same-process". Bit if a mouthful, but
#that accurately describes what we *REALLY* want. And given that crazy name,
#I'm happy to leave this option undocumented, you know?

# Parse passed options *AFTER* performing login-specific logic, as the latter
# establishes the global ${PATH} required by the former (e.g., for finding
# commands in the global ${PATH} with word modifier ":c").
#
# Parse passed options *BEFORE* operating on any additional Zeshy files or operating
# on user-specific Zeshy files, as the
# former could modify the behavior of the latter (e.g., by preventing Zeshy from
# recompiling and loading its digest file).
    #FUXME: Do we need test against *BOTH* $$ and ${PPID}? It can't hurt, of
    #course... but it would be nice to ascertain which we require.
#   if [[ "${ZESHY_PID_IF_ZSH_STARTUP}" == ($$|${PPID}) ]]

#[[ "${funcstack[1]}" == */(.|)(zshrc|zprofile|zlogin) ]] && {
#* If [[ "${ZESHY_PID_IF_ZSH_STARTUP-}" -eq "${PPID}" ]], then:
#  * Zeshy has already been loaded by the parent process and hence (hopefully)
#    inherited by the current process. Return immediately.
#* If [[ "${funcstack[1]}" == "*/(.|)(zprofile|zshrc)" ]], then:
#  * Set ${ZESHY_PID_IF_ZSH_STARTUP} as a global export in "src/main" ala:
#    typeset -igx ZESHY_PID_IF_ZSH_STARTUP="${PID}"

# Due to portability
# concerns, avoid exporting globals via "export" prior to enabling
    # If interactive, immediately return back to zsh; otherwise, exit the
    # current script.
#   if [[ -o interactive ]]
#   then return 1
#   else   exit 1
#   fi

#   print "defaulting \"ZESHY_HOME\" to \"${ZESHY_HOME}\"" 1>&2
#   print "consider running \"zeshy\" rather than sourcing \"${0}\"" 1>&2

# Absolute directory of the Zeshy library.
#ZESHY_HOME="${ZESHY_HOME}/src"

# * Incorporate ZSH-lovers fixes, including:
#   * Use suffix aliases.
# * The new trap support obsoletes an astonishing quantity of prior
#   functionality (e.g., try()). Such functionality should be retained (???...
#   perhaps not), but exported out of this component into a new component: say,
#   "zeshy/shell/job".
# * zimport() can profitably be renamed require(). The latter captures the
#   intent and implementation much more succinctly and without the awkward
#   prefixing 'z'.
# * We only call a match_*() function once in this file. It's absurd to maintain
#   such complexity here; offload all match_*() functionality to
#   "zeshy/type/regex" and, if still required here, simply inline. I believe we
#   can use simple glob-style matching, instead.
# * Ultimately, Zeshy should auto-compile the recursive entirety of all Zeshy
#   function definitions into a single so-called "digest" file at, say,
#   "~/.zeshy/digest.zwc". Such a file is autoloadable by:
#
#       # ...implicitly autoloading such digest.
#       fpath=( "~/.zeshy/digest.zwc" "${fpath[@]}" )
#
#       # ...explicitly autoloading such digest.
#       autoload -Uw "~/.zeshy/digest.zwc"
#
#   I'm unsure if the former supercedes the latter. (Probably not, no.) Both
#   required, perhaps.
#
#   What's nice about this is that such a digest file appears to come prepended
#   with a list of all functions defined by such digest, thus rendering
#   autoloading of digest files terrifically fast. Auto-generating such a digest
#   on any change to any Zeshy file or directory is, unfortunately, not quite so
#   easy. We'll need to write something resembling:
#
#       if is "$(get_path_mtime "~/.zeshy/digest.zwc") equals SOMETHING si; then
#           zcompile "~/.zeshy/digest.zwc" "${ZESHY_HOME}/src/"**/*(.)
#       fi
#
#   However, it's unclear just how aggregating multiple files into one handles
#   initialization code. Clearly, it either doesn't or does but simply lumps all
#   initialization together. Either case is bad. We'll need to rewrite Zeshy to:
#
#   * Perform all non-costly initialization up-front in Zeshy .main or core.
#   * Perform all costly initialization in the functions requiring such
#     initialization as the first line of such functions. You know that grind...
#'zeshy: zsh 4.0.3 < 5.0.0'
#'zeshy: zsh 4.0.3 < 5.0.0'
#'zeshy: installed zsh 4.0.3 < required zsh 5.0.0'
#'zeshy: zsh 4.0.3 < required zsh 5.0.0'
#'zeshy: installed zsh version 4.0.3 < required zsh version 5.0.0'

#   print "zeshy: requires zsh ${ZESHY_ZSH_VERSION_REQUIRED} but running zsh ${ZSH_VERSION}" 1>&2
# Since zsh 
# Indeed, zsh has no corresponding option
# "no_rm_recursive_silent" for interactively confirming option "-r" when passed
# to command "rm". Zeshy, on the other hand, confirms both star-globbed and
# recursive removal. Since recursive removal is (arguably) less safe than even
# star-globbed removal, Zeshy's behavior may be (arguably) safer than the
# default zsh behavior. Indeed, Zeshy interactively confirms all attempted path
# removal -- regardless of the number of such paths.
#FUXME: Doesn't appear to work as advertised, sadly.
#setopt no_global_export   # prevent "typeset -x" from implying "typeset -xg"

# List of all Zeshy-specific globals defined while sourcing Zeshy, if
# recompiling the Zeshy digest file. Defining such list globally permits us to
# undefine such globals in a global context, below.
#typeset -a ZESHY_GLOBAL_NAMES

# If recompiling the Zeshy digest file and hence sourcing Zeshy scripts
# defining globals, undefine such globals prior to initializing Zeshy. Why?
# The reason may be subtle, but the logic flows like butter. Zeshy may and
# typically does declare globals to be read-only. Understandably, zsh fails on
# attempting to redefine such globals. The subsequent call to startup_zeshy()
# and hence startup_zeshy_globals() does just that, requiring such globals be
# undefined prior to such calls. Oh, 'tis all a tad silly and worm-bitten, but
# so goes life in the tranche of code trenches.
#(( #ZESHY_GLOBAL_NAMES )) and {
#    unfreeze_variable "${ZESHY_GLOBAL_NAMES[@]}"
#    undefine_variable "${ZESHY_GLOBAL_NAMES[@]}"
#    undefine_variable ZESHY_GLOBAL_NAMES
#}

# Delete all Zeshy-specific globals defined by and imported from the parent
# shell, locally preserving global ${ZESHY_HOME} for subsequent use. Failure to
# delete such globals results in a subtle issue when compiling the Zeshy digest
# file, which persists such globals to startup_zeshy_globals() by differencing
# the lists of globals defined before and after such compilation. Failing to
# delete such globals ensures the two lists to be effectively identical, thus
# preventing persistence of Zeshy globals into the Zeshy digest file.
#
# See undefine_variable_matching() for details on variable deletion.
#local zeshy_home="${ZESHY_HOME-}"
#typeset +r -m 'ZESHY_*'
#unset      -m 'ZESHY_*'
#typeset -p -m 'ZESHY_*'

# Restore ${ZESHY_HOME}, deleting the temporary ${zeshy_home}. We're good to go.
#typeset +gx ZESHY_HOME="${zeshy_home}"
#unset zeshy_home

#[[ -n "${ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY+x}" ]] and {
#    print 'Eh??!?!?'
#    typeset -p ZESHY_GLOB_SHELL_EMULATABLE_DIRECTLY
#}
#       [[ -f "${filename}" ]] || die "\"${filename}\" not a zeshy script"
# ....................{ TRAPS ~ errors                     }....................
# void source_zeshy_component(
#   string component_name1, string component_name2, ...)
#
# Source the passed Zeshy components (i.e., zsh scripts in this directory).
#function source_zeshy_component() {
#    (( # >= 1 )) || die 'expected at least one component name'
#    for filename ("${@}") {
#       say "sourcing \"${ZESHY_HOME}/${filename}\"..."
#        source "${ZESHY_HOME}/${filename}"
#    }
#}

#source_zeshy_component alias global autoload
    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
#   (( funcstack_size >= 2 )) || die 'call stack empty'
#   (( ++funcstack_size ))

#   for (( i = 2; i <= funcstack_size; i++ )) {
#   [[ "${funcstack[-1]}" == TRAPZERR ]] && return $(( 128 + ${1} ))
#   print "TRAP! oldest caller: ${funcstack[-1]}"
#   integer signal_number=${1}
#   return $(( 128 + ${signal_number} ))
#   return ${exit_status}
#   print "zeshy: ${caller_name} failed with exit status ${exit_status}" 1>&2
#   cry "\"${caller_name}\" failed with exit status ${exit_status}"
        #FUXME: I have no idea why we were doing this. It doesn't seem
        #particularly intelligent, however... So stop.
        # If this is the most recent stack frame, recall the name of the second-
        # most recent stack frame that called that frame and line number of that
        # call for subsequent pretty printing.
#       (( i == 2 )) && caller_line_first="${caller_line}"
#       (( i == 3 )) && caller_name_first="${caller_name}"

        # If this frame is the handle_exception() function typically calling
        # this function, avoid meaninglessly printing such frame.
#       [[ "${caller_name}" == handle_exception ]] && continue

#       [[ "${funcname}" == '(eval)' ]] || funcname="${funcname}()"
        # Temporarily redefine cry() in a manner consistent with exception handling.
#       function cry() { print -- "zeshy: ${*}" 1>&2; }

# Depending
# on the current user's Zeshy configuration, such function prints stack traces,
# documentation, and source code.
# according to the current user's Zeshy
# configuration of the
# current user (e.g., by printing a stack trace).
#
# Unlike "setopt ERR_RETURN", this handler calls handle_exception(). Depending
# on the current user's Zeshy configuration, such function prints stack traces,
# documentation, and source code.
#
# and hence implicitly throws an exception unwinding the
# call stack of the current shell on *ANY* command returning non-zero exit
# status, as if such command had instead thrown an exception.
#
# If such shell fails to
# handle such exception, zsh implicitly rethrows such exception to the shell
# calling the calling shell. This process proceeds until either some calling
# shell handles such exception, in which case no further shells are unwound,
# or no shell handles such exception, in which case the current user receives an
# uncaught exception. In the
# Specifically, print a
# complete stack trace and . Such unwind exits all intermediate subshells
# (e.g., non-interactive Zeshy functions or scripts) to the originating shell
# (e.g., the interactive Zeshy or zsh shell transitively responsible for running
# the failed command), but not necessarily any other active shell.
#   integer signal_number=${1} exit_status=${?}
    # Print a complete stack trace. If some function called this function (i.e.,
    # this function was not called directly from the prompt), prefix such trace
    # with that function's name and exit status; otherwise, no such prefix.
#   if (( ${#funcstack} >= 2 ))
#   then handle_exception\
#       "\"${funcstack[2]}\" failed with exit status ${exit_status}."
#   else handle_exception
#   fi

    # Omit the current function call by starting from the second stack frame.
    # If there exists no such frame, return with failure.
#   (( funcstack_size >= 2 )) || {
#       cry 'call stack empty'
#       return_false
#   }

    # Print a prefixing header with the passed message.
#   cry "${1:-}" 1>&2

# Do not return non-zero
        # exit status, as that recursively triggers TRAPZERR().
#           cry 'exception not found'
#           return 0
#       }
    #FUXME: Clearly not right if calling from within a trap handler, as this
    #would trigger another trap calling this function, and so on. For the
    #duration of all functions called by handle_current_exception(), we need to
    #temporarily replace exception throwing with just printing to standard
    #error and returning immediately. That said, I wonder if zsh doesn't already
    #somehow handle this? Specifically, what happens if we *DO* just throw an
    #exception here? Perhaps everything magically works out. Test up. Ah! I get
    #it.

# For safety, trap functions and functions transitively called by such functions
# require only zsh functionality (i.e., no Zeshy-specific syntactic sugar). This
# comprises all functions defined up to and including the "TRAPS" section.

# the notice stream
# of the cron logging facility if a cron-job and to the standard output stream
# otherwise.
#say 'finalizing aliases...'
#source "${ZESHY_HOME}/alias"
#say 'finalizing globals...'
#source "${ZESHY_HOME}/global"
#say 'finalizing autoloads...'
#source "${ZESHY_HOME}/import"
#say 'finalizing startup...'
#   [[ -f  "${filename}" ]] || die "\"${filename}\" not found"
#   source "${filename}"
# * I've been operating under the assumption zsh variables require quoting to
#   preserve spaces. It appears that is *NOT* the case, under default zsh shell
#   options. It doesn't hurt anything as is, but we could probably stand to
#   remove most if not all existing quoting. Ah; I see, somewhat. Lists must
#   always be quoted, but scalars need never be. Still, 'tis a confusing
#   distinction. We're better off persisting with the current method, I reckon.

# zeshy: consider upgrading zsh to ${ZESHY_ZSH_VERSION_REQUIRED}" 2>&1

#FUXME: *BRILLIANT IDEA*. Stack traces are great. But, with longer function
#implementations, output like:
#
#   curse_call_stack: make_and_install_kernel() failed with exit status 1
#        \_ TRAPZERR() { /root/.zeshy/digest.zwc/make_and_install_kernel: 34 }
#         \_ make_and_install_kernel() { /bin/zsh: 130 }
#
#...isn't really helpful. What is the 34th line of that function excluding
#comments? Right. There's no easy way to peruse that function's commented
#implementation and discern just where the fault lies. Hence, a solution:
#
#* Add a new "ZESHY_DEBUG" config global. (Think we might have one already, yes?)
#* If enabled, curse_call_stack() should implicitly with no external effort
#  append something resembling "which ${funcname[2]}" to its output. That's
#  closer to what we want, but still incomplete: "which" has no option for
#  prefixing each line of output with its line number, which is what we need.
#  I guarantee there's an "awk" script to do it, though. Search us up the fix!

#       (( i == 3 )) && {
#           funcname_first="${funcname}"
#           fileline_first="${fileline}"
#       }
    # Message to print. (Yes, its declaration and definition must be separate.)
    # Message to print. (Yes, its declaration and definition *MUST* be separate.
    # I'm not entirely clear why, but declaring and defining the message in the
    # same command induces inexplicably, undebuggably subtle errors.)
#   print "script name: $(get_script_name)"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.notice -- "${message}"
#   [[ -n "${ZESHY_IS_CRONJOB}" ]] && logger -p cron.err -- "${message}"
#   elif [[ "${#funcstack}" -gt 0 &&
#            "${funcstack[-1]}" != (get_script_name|say|msay|cry) ]]; then

#       if "${funcstack[${i}]}" == "${funcfiletrace[${i}]}"
#       print "${frame_prefix} ${funcname}() {${filename}:${fileline}}"

# This
# Each such frame signifies a previously called function, sourced file, or evaluated "eval". Each call
# stack of such frames signifies a stack trace of the complete code path from
# the most to least recently called function, source file, or evaluated "eval".

    # Continue the default trap handler, as under TRAPZERR(). 

# After any command returns non-zero exit status but prior to executing the next
# such command, instruct zsh to:
#
# * Execute the TRAPZERR() trap function.
# * Unwind the call stack, exiting all intermediate shells, back to the
#   originating shell -- typically, the interactive shell from which the failing
#   command was transitively run.
# * If the failing command was run directly by some zsh function:
#   * Return from that function with that command's non-zero exit status.
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

# * Execute the ZERR trap, if set.
# * Execute the TRAPZERR trap function, if defined.
# * If the failing command or function was itself called from a function:
#   * Return from that function with that command or function e return value .
# Terminate the current shell, returning the non-zero exit status of the prior
# command.
#
# The combination of enabling this option and defining TRAPZERR() as below
# offers a robust alternative to the customary command "set -e", whose
# default implementation dangerously terminates the current shell on failure.
#setopt err_return

    #FUXME: Hmm. If called from a pipe (e.g., "false or die "false!"), we really
    #want to use "${pipestatus[-2]}" here rather than "${?}".
#   if (( # == 0 ))
#   then say
#   else say "${1:-}"
#   fi

    #FUXME: Truncate.
    # Arcane bit-munging. Exit codes are of size "char" (i.e., a single byte).
    # Non-zero exit statuss with high bit set signify signal-driven fatal errors
    # and with high bit unset signify command-specific fatal errors. In the
    # former case, all bits excluding the high bit signify the signal number.
    # Hence, signal-driven exit statuss are constructable by adding 128 to the
    # signal number.
    #
    # SIGINT signifies fatal error of signal number 2. Rather than hard-code
    # that constant, we note:
    #
    # * zsh passes the signal number as the first argument to trap functions.
    # * zsh continues handling trap function-trapped signals as if untrapped
    #   when receiving non-zero exit statuss from such functions. In such cases,
    #   zsh returns this exit status as the signal result to calling processes.
    # 
    # Since we prefer zsh handle the actual interrupt as such with the same
    # exit status as it would customarily return, the result follows.
#   return ${exit_status}
#   return $(( ${exit_status} + 128 + ${signal_number} ))

    # Die with the prior return code.
#   ::print_exception_uncaught ${exit_status}

# void ::print_exception_uncaught(int exit_status = 1)
#
# Exit the currently executed script or function with the passed return code.
#::print_exception_uncaught() {
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }
#   if is_interactive; then
#   then print 'throwing exception'; throw ZeshyException

    # If the current context is a function called from an interactive and/or
    # login shell, unwind the call stack; otherwise, kill the current process.
#    if is_interactive
#    then throw ZeshyException
#    else exit ${1:-${ZESHY_STATUS_FAILURE}}
#    fi
#    print 'still here!'
#}

#set -e

#FUXME: zsh fails to trigger ZERR traps from within the sourcing of zprofile and
#zshrc. I have no idea why. Since the following line does nothing to help,
#however, I can only assume this is somehow the intended behavior. Nonetheless,
#file a mailing list comment.
#trap TRAPZERR ZERR
#trap 'curse_call_stack; throw ZeshyException' ZERR

#   if is_interactive
#   then return $(( ${exit_status} + 128 + ${signal_number} ))
#   else exit       ${exit_status}
#   fi
 #   throw ZeshyException
#   print 'still here...'
#   for ((i = 1; i <= ${#funcstack}; i++)) { print "${i}: ${funcstack[${i}]}" }

    # Terminate the current shell, returning the non-zero exit status of the prior
    # command. This effectively enables "set -e" (i.e., the ERR_EXIT option,
    # terminating the current shell on SIGZERR signals).
#   eval 'throw ZeshyException'; return ${exit_status}
#   ::print_exception_uncaught ${exit_status}

# * Uhm; how did I never see this? zsh supports loop syntax resembling:
#   for d (../**/*) {
#   }
#   No need for cumbersome "for d in (../**/*); do ... done" nonsense. 

#FUXME: This is likely a zsh bug, perhaps corrected in some subsequent version.
#But throwing uncaught exceptions from interactive functions appears to
#literally undefine the calling function. Yes, this makes no sense.

    #FUXME: Given the new stack trace facilities, this probably no longer applies.
    # Unset the script name, if set. This forces the get_script_name() function
    # to obtain the name of the most recently called non-trivial function, which
    # is of considerably more assistance when an error occurs.
#   local ZESHY_SCRIPT_FILENAME=

#   print
#   print     -- "${message} (stdout)"
#   print -u2 -- "${message} (stderr)"

#   elif is_interactive; then
        #FUXME: This is actually the reverse of what one might want. We should
        #select the *LAST* function on the function stack. 
#       typeset -i i
#       for (( i = ${#funcstack}; i >= 1; i-- )); do
#           print "${i}th function: ${funcstack[${i}]}"
#           [[ "${funcstack[${i}]}" == /* ]] && 
#
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
 
        # Ignore all intermediary I/O- and error handling-specific function
        # calls. Skip the first stack frame corresponding to the current
        # function by starting at the second stack frame.
#       typeset -i funcstack_size=${#funcstack}
#       for (( i = 2; i <= funcstack_size; i++ )); do
#           print "${i}th function: ${funcstack[${i}]}"
            # Order ignorable function names by likelihood, for "efficiency."
#           case "${funcstack[${i}]}" in
#               run*|die*|say*|msay*|cry*|ask_*) continue ;;
#               *) break ;;
#           esac
#       done
         
        # If after ignoring non-relevant functions there still exists at least
        # one function on the callstack, return that function's name.
#       if (( i <= funcstack_size )); then
            # If this name is an absolute path, return that path's basename.
#           if [[ "${funcstack[${i}]}" == /* ]]
#           then print "${funcstack[${i}]:t}"
            # Otherwise, return this name as is.
#           else print "${funcstack[${i}]}"
#           fi
        # Otherwise, return the default name.
#       else print 'zeshy'
#       fi
    # Otherwise, return the default name.
#   else print 'zeshy'
#   fi

# Math module supplementing zsh's rudimentary math functionality with essential
# math operations (e.g., exponentiation).
#zmodload zsh/mathfunc

# Load broadly applicable zsh modules.
#load_default_modules

# ....................{ DEFAULTS                           }....................
# void load_default_modules()
#
# Load broadly applicable zsh modules.
#load_default_modules() {
    # Stat module wrapping the stat() system call with the zstat() zsh function. Do
    # not load this module via "zmodload zsh/stat", as that wraps the stat() system
    # call with a stat() zsh function, conflicting with the "stat" command.
#   zmodload -F zsh/stat b:zstat

    # Math module. While zsh provides rudimentary math functionality out of the box,
    # some pivotal functions (e.g., exponentiation) are only provided by this.
#   zmodload zsh/mathfunc

    # Module exposing zsh's C-based internal dictionaries as zsh-based associative
    # arrays, including:
    #
    # * "$funcstack", having the current function call stack for user inspection.
    # * "$functions", having the current set of all functions for redefinition and
    #   later restoration of differing function definitions.
#   zmodload zsh/parameter

    # Perl-Compatible Regular Expression (PCRE) module. Note that, although
    # enabling the "rematch_pcre" option below implicitly loads this module on the
    # first use of the "=~" operator in a test, all code prior to that will not
    # have access to methods exposed by this module. Thus, simply import it
    # explicitly.
    #
    # See "String matching" below for use notes.
#   zmodload zsh/pcre

    # Utility module adding additional built-ins, including the commonly called
    # "zformat", "zparseopts", and "zstyle" functions.
#   zmodload zsh/zutil

# void _zeshy_bootstrap(string filename1, string filename2, ...)
#
# Source the passed Zeshy components in the passed order.
#_zeshy_bootstrap() {
#    for script_file in "${@}"; do
#        if [[ ! -f "${script_file}" ]]; then
#            print "zeshy: \"${script_file}\" not found or not a file" 1>&2
#            exit 1
#        fi
#        
#        source "${script_file}"
#    done
#}

#   _zeshy_init_bootstrap "${ZESHY_HOME}/src/init/if_shell_interactive/"*
## void _zeshy_init(void)
#_zeshy_init() {
#}
#
## Call and then immediately unset (i.e., delete) _zeshy_main().
#_zeshy_init
#unfunction _zeshy_init

# Import Zeshy Core defining import() prior to importing other dependencies.
#[[ $(whence -w zimport) =~ ': function' ]] ||
#    source "${ZESHY_HOME}/src/init/core"

# in a
# "system-sensitive" manner: i.e., importing only specific dependencies
# relevant to the current system.
    # Add Zeshy's "site-functions/" to the function path, if that directory exists.
#   is_dir "${ZESHY_HOME}/site-functions" and
#       fpath=( "${ZESHY_HOME}/site-functions" "${fpath[@]}" )

    #FUXME: Old.
    # Match all non-dotfiles in the current directory via the "(^D)" modifier:
    # i.e., all files and directories except this one. Since Zeshy components 
    # explicitly import dependencies, importation order is *NOT* important.
#   string import_script_path
#   for import_script_path in "${ZESHY_HOME}/src/zeshy"/*(^D); do
#       zimport "${import_script_path}"
#   done
#       [[ $(basename "${import_script_path}") =~\
#           "^(\..*|${ZESHY_MAIN_SCRIPT_BASENAME})$" ]] ||

# ....................{ PATHS                              }....................
# Absolute path to the current script.
#local zeshy_core_path=$(readlink --canonicalize-existing "${0}")

# Directory having the current script. This environment variable should have
# been permanently added to the current system on Zeshy installation. If it was
# not, however, ensure that it at least temporarily exists now.
#[[ -n "${ZESHY_HOME-}" ]] ||
#    export ZESHY_HOME=$(readlink --canonicalize-existing $(dirname "${zeshy_core_path}")"/../..")

    # Import all non-dotfiles in this directory with the "(^D)" modifier (i.e.,
    # all files and directories *NOT* prefixed by a "."). Since Zeshy scripts
    # explicitly import dependencies, order of import is mostly insignificant.

#   if is -z\
#       "${ZESHY_IMPORTED_PATH_TO_MTIME[(I)"${zeshy_script_path}"]}" or
#       "${ZESHY_IMPORTED_PATH_TO_MTIME["${zeshy_script_path}"]}" -ne\
#       "${zeshy_script_mtime}" si; then

# This glob expression matches the basename of all non-executable readable
# files residing under every path in the function path list, "${fpath}". Via
# zsh mandate, every such file basename corresponds to the autoloadable
# function name defined in the file. Thus, matching these basenames also
# matches all autoloadable function names.
#
# * "-.x" ignores non-executable files. While not strictly necessary, forum
# posters suggest this beneficially permits you to ignore undesirable autoloads
# by chmodding away their executable bit.  * "-.r" ignores non-readable files.
# This is strictly necessary.  * ":t" extracts the "tail" (i.e., basename) of
# the current file. This is a history modifier extracting each file's filename
# sans absolute path.
# 
#for autoload_function_name in ${^fpath}/*(N-.r:t); do

#FUXME: I suppose I don't quite understand why we can't simply implement this as
#some variant of '"${@}" 1>/dev/null 2>&1'. Doesn't that work as is?
#run_quietly() { run "${(q)@}" 1>/dev/null 2>&1 }

#   is "${#command}" exceeds 0 si or die 'expected exactly one command'
#
#global_alias to='|'

    # Decompacted:
    # 
    # * "1", the passed name.
    # * "(P)", the variable the passed name refers to.
    # * "-", the value to expand this variable to if unset:
    #   in this case, simply the empty string.
    # * "-z", true only if this variable is the empty string and hence unset.
#    is -z "${(P)1-}" si

# ....................{ COMMANDS ~ return codes            }....................
# void try_as_superuser(string command)
#
# Run the passed command as the superuser and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as_superuser() {
#    run_as_superuser "${@}" or die
#}

# int get_last_status(void)
# 
# Return the return code returned by the previous command.
#alias get_last_status='is_ok'

# bool is_ok(void)
#
# Return success if the previous command succeeded. Otherwise, return failure.
#is_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_status=${?}
#    die_unless_no_args
#    return ${prior_command_status}
#}

# bool is_error(void)
#
# Return success if the previous command failed. Otherwise, return failure.
#is_error() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_status=${?}
#    die_unless_no_args
#    is ${prior_command_status} -ne ${ZESHY_STATUS_SUCCESS} si
#}

# string canonicalize_path_nonfatal(string pathname)
#
# Get the canonicalized form of the passed absolute path. Unlike the
# canonicalize_path() function, this function does not raise an exception when
# the passed path does not exist; it simply canonicalizes as much of this path
# as exists.
#canonicalize_path_nonfatal() {
#    die_unless_one_arg 'expected exactly one pathname'
#    readlink --canonicalize-missing "${1}"
#}

#FUXME: This and try() now obsolete by TRAPZERR(). Excise everywhere.
# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_as() {
#    die_unless_at_least_two_args\
#        'expected exactly one username and one command'
#
#    # Locally set "${ZESHY_RUN_AS}". The run() function notes this variable as
#    # set and behaves accordingly...
#    string ZESHY_RUN_AS="${1}"; shift
#
#    # Call try() with all remaining arguments: the command to be run.
#    try "${(q)@}"
#}

# void try(string command)
#
# Run the passed command and, if it fails with error, terminate the current
# execution environment with the same error.
#try() {
#    run "${(q)@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly(string command)
#
# Run the passed command run_quietly and, if it fails with error, terminate the
# current execution environment with the same error.
#try_run_quietly() {
#    run_quietly try "${@}" or die "\"${@}\" returned error code ${?}"
#}

# void try_run_quietly_as(string username, string command)
#
# Run the passed command as the passed user run_quietly and, if it fails with error,
# terminate the current execution environment with the same error.
#try_run_quietly_as() {
#    run_quietly try_as "${@}" or die "\"${@}\" returned error code ${?}"
#}

# bool or(...)
#
# Return true if at least one of the passed command's returned successfully.
#global_alias or='||'

# bool and(...)
#
# Return true if both of the passed command's returned successfully.
#global_alias and='&&'

# bool not(...)
#
# Negate the passed command's return code.
#alias not='!'

#FUXME: This function appears to be functionally obsolete now. If so, kill and
#rename which_command() to this.
# Aliases.
#alias which_binary="which_command"
#alias which_binary_nonfatal="which_command"

# string which_command(string command)
#
# Print the absolute path to the passed command: e.g.,
#
#     >>> which_command zsh /bin/zsh
#
# If the passed command is a string, all but the first whitespace-delimited word
# of the string is ignored: e.g.,
#
#     >>> which_command "zsh -x -o shwordsplit scr" /bin/zsh
#
# If the passed command is not found, if multiple binaries are passed, or if no
# command is passed, prints an error and dies.
#which_command() {
#Call the whence() built-in outside of "local" so as to retain the return
    # code. (ZSH == FAIL on that one.) 
#    string command_path; command_path="$(which_command "${@}")"
#    die_unless_ok "\"${1}\" not found"
#    print "${command_path}"
#}
#
# Identical to the which_command() function except that, if the passed command
# does not exist, returns nothing rather than dies.

#FUXME: No longer meaningful under TRAPZERR(); excise.
# void die_unless_ok(string error_message)
#
# Die with the passed error message unless the previous command succeeded.
#die_unless_ok() {
#    # Cache the prior command's return code, as our initial sanity check on
#    # arguments replaces this code with its own.
#    integer prior_command_status=${?}
#    die_unless_one_arg 'expected exactly one error message'
#    is ${prior_command_status} -eq ${ZESHY_STATUS_SUCCESS} si or die "${1}"
#}

# void say_import(string script_name)
#
# Echo a message informing the user that the passed script name is being
# imported. This function should be called prior to actually importing that
# script if feasible.
#say_import() {
#    die_unless_one_arg 'expected exactly one script name'
#
#    say "loading \"${1}\"..."
#}

    # If the caller has supplied no explicit "${ZESHY_SCRIPT_FILENAME}", supply a
    # default.  Failing to do this encourages the say() function to use the
    # name of this function as its script name, producing unaesthetic results.
#   "${ZESHY_SCRIPT_FILENAME:=zeshy}"

        # Print the passed error message followed by a complete backtrace.
#   cry "${@}"
#   curse_call_stack
 #
    # Shells differentiate
    # fatal from non-fatal errors by setting the high bit (i.e., 2^7 = 128).
    # According to "zshbuiltins", this forces zsh to continue handling the
    # signal as if untrapped and hence returning the same exit status. Having no
    # arcanely carnal knowledge of the Linux signal implementation, it's unclear
    # why setting the high bit 

    #FUXME: Old.
    # If the passed path is a directory, only import filename
    # "${ZESHY_MAIN_SCRIPT_BASENAME}" in this directory.
#   is -d "${zeshy_script_path}" si and
#       zeshy_script_path="${zeshy_script_path}/${ZESHY_MAIN_SCRIPT_BASENAME}"
    
    # If this path does not exist, die.
#   is -f "${zeshy_script_path}" si or die "\"${zeshy_script_path}\" not found"
 #
#FUXME: Impossible to remember, I'm afraid. Perhaps "fail_if_error", instead?
# int fail_if_previous_command_failed(void)
# 
# Return from the current function with failure if the previous command or
# function also returned with failure.
#alias fail_if_previous_command_failed="is_ok || return ${ZESHY_STATUS_FAILURE}"

#; ZESHY_IMPORTED_PATH_TO_MTIME=( )
#   typeset -Ax ZESHY_IMPORTED_PATH_TO_MTIME; ZESHY_IMPORTED_PATH_TO_MTIME=( )
 # The "-Ax" option to the "typeset" commands defines each such variable as an
# [A]ssociative array (i.e., a dictionary) and e[x]ported to the global
# environment for later access.

# Ascertain whether we are running as a cronjob and, if so, alter output
# appropriately. In particular, print the current date as a timestamp prior to
# printing all other output.

#   die_unless_at_least_one_arg 'expected at least one string'

#   # If no string was passed, attempt to read "stdin" for piped input.
#   if is_one_arg; then
#       set -- "${1}" "$(< /dev/stdin)"
#   fi

#   pcre_compile "${1}" || die "\"${1}\" not a valid regular expression"
#   pcre_match "${2}" || return ${?}
#   return ${ZESHY_STATUS_SUCCESS}

# This function returns success 
# If this regular expression matched at least one group, this function returns
# this group as a string for caller convenience... Else, this function returns
# nothing. In the former case, callers may retrieve the set of all groups via
# the global "${match}" array. (See above.)

    # When the whence() built-in fails, it prints the name of the passed command
    # followed by "not found". Thus, if it prints such a message, the passed
    # command does not exist. Note that testing the return code is problematic
    # here, since setting a local variable always forces the return code to 0
    # (i.e., success). 
#   if [[ "${command_path}" == *" not found" ]]; then
#       return ${ZESHY_STATUS_FAILURE}
#   else
#       echo "${command_path}"
#       return ${ZESHY_STATUS_SUCCESS}
#   fi

    # O.K., this is tricksy: if the eventual caller explicitly quote-protected
    # the passed command name, there exists another "layer" of quote-protection
    # to unravel. Do so, alas.
#   if ! is_installed "${command_name}" && is_installed "${(Q)command[1]}"; then
#       command_name="${(Q)command[1]}"
#   fi

    #echo "PID: $$"
    #echo "current_process_basename:"
    #get_current_process_basename
    #echo "current_process_command_line:"
    #get_current_process_command_line

# ....................{ GLOB EXPRESSIONS                   }....................
# string *glob_non_dotfiles_in(string dirname)
#
# Glob all non-dotfiles (i.e., all files and directories whose first character
# is not a '.' dot) in the passed directory.
#glob_non_dotfiles_in() {
#    [[ ${#} -eq 1 ]] || die "expected exactly one directory name"
#    local dirname="${1}"
#    [[ -d "${dirname}" ]] || "\"${dirname}\" not a directory"
#
#    # Glob all non-dotfiles via the "(^D)" modifier.
#    echo "${dirname}"/*(^D)
#}

 # Enable variable substitution in prompt expansions in a "synchronous" fashion.
# Enabling this re-evaluates each prompt expansion after perform each
# interactive command with the current values of those variables without
# having to manually recreate the prompt each time.
#setopt promptsubst

#The existence of this variable also
# serves to inform callers as to whether or not this script has been imported
# yet and, when it has, to avoid reimporting it.

# Directory above the directory having the current script. This environment
# variable should have been permanently added to the current system as well.
#[[ -n "${ZESHY_ROOT}" ]] ||  
#    export ZESHY_ROOT=$(readlink --canonicalize-existing "${ZESHY_HOME}/..")

#FUXME: Harvest comments from the now-dead portion of zimport_file().
#
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#O.K.; the game plan:
#* Separate each function into a separate file. No symlinks. I know; I know.
#  This is awful. But zsh is as it is on this score. There's no fixing that.
#* Initialization needs to be centralized into a set of core files. Here's
#  what I'm thinking, now: cleave the "src/" directory into:
#  * "src/root", containing "zprofile", "zlogin", and "zshrc".
#  * "src/main", containing this file, "core", and all other initialization as
#    perhaps another file or two ("globals"? bah!). All global variable
#    declarations need to be shifted here.
#  * "src/auto/generic", containing the bulk of Zeshy as such autoloadable function
#    files. All such functions are safely applicable to all systems.
#  * "src/auto/command", allowing for conditionally autoloaded command-specific
#    function directories (e.g., "src/auto/command/ssh").
# * We need one digest for all of "generic" and one digest for each immediate
#   subdirectory of "src/auto/command", the latter conditionally autoloaded if
#   such command exists.
# * This scheme clearly allows for things like "src/auto/os", should we require
#   it. I'm currently considering trashing that... just assume GNU/Linux, for
#   the moment. (Time!)
# * Hmm; perhaps?:
#   "src/catabolize/".
#   "src/initialize/".
#   "src/bootstrap/".
#   "src/framework/".
#   "src/profile/".
#   "src/context/".
# * Ah; O.K.; how about just:
#   "src/construct/".
#   "src/bootstrap/".
#   "src/autoload/always".
#   "src/autoload/if_installed".
# * Or mayhap:
#   "src/boot/".
#   "src/init/".
#   "src/auto/always".
#   "src/auto/if_installed".
#
#Yes, it's lame. But our hands are really constrained, here.
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!
