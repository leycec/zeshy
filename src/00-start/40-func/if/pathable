#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *pathable-conditional function definers* (i.e., functions dynamically
defining other functions with bodies depending on the pathability of passed
commands).
/---

# ....................{ DECLARERS                          }....................
declare_function_with_stdin <<'/---'
void :declare_func_if_pathable_or_noop[
    args: (
        string func_prototype,
        string func_body_prefix,
        string if_command_pathable1, string then_func_body1, ...,
    stdin: documentation]

Declare and define the function identified by the passed function prototype as
the first function body whose preceding command is pathable, prefixed by the
passed function body prefix and documented by the help string passed on
standard input (e.g., as a here-document or -string). If no such commands are
pathable, success is reported without declaring, defining, or documenting such
function. See :define_func_if_pathable_or_noop() for further details.
/---
function :declare_func_if_pathable_or_noop() {
    die_unless_args_4_or_more\
        'Expected one function prototype, one function body prefix, and one or more pairs of one test and one function body.'
    ::declare_func_if_defined_by_func_or_noop :define_func_if_pathable "${@}"
}

declare_function_with_stdin <<'/---'
void :declare_func_if_pathable_in_list_order_or_noop[
    args: (
        string func_prototype,
        string func_body_prefix,
        string if_command_pathable1, string then_func_body1, ...,
        string command_names_list_name)
    stdin: documentation]

Declare and define the function identified by the passed function prototype as
the first function body whose preceding command is pathable tested in the order
such commands appear in the passed list of command names, prefixed by the
passed function body prefix and documented by the help string passed on
standard input (e.g., as a here-document or -string). If no such commands are
pathable, success is reported without declaring, defining, or documenting such
function. See :define_func_if_pathable_in_list_order_or_noop() for further
details.
/---
function :declare_func_if_pathable_in_list_order_or_noop() {
    die_unless_args_5_or_more\
        'Expected one function prototype, one function body prefix, and one or more pairs of one command name and one function body, and one list name.'
    ::declare_func_if_defined_by_func_or_noop\
        :define_func_if_pathable_in_list_order "${@}"
}

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
[status = :bool] :define_func_if_pathable(
    :string func_name,
    :string func_body_prefix,
    :string if_command_pathable1, :string then_func_body1, ...)

Define the passed function as the first *function body* (i.e., arbitrary code
implementing such function) whose preceding command is *pathable* (i.e., in the
current command hash and hence typically in the current ${PATH}), prefixed by
the passed *function body prefix* (i.e., arbitrary code unconditionally
prepended to such function's implementation). If all such conditions fail,
success is reported without defining such function. See
:define_func_if_pathable_in_list_order() for further details.
/---
function :define_func_if_pathable() {
    # Validate sanity.
    die_unless_args_4_or_more\
        'Expected one function name, one function body prefix, and one or more pairs of one command name and one function body.'

    # Define a private variable whose existence is tested by
    # :define_func_if_pathable_in_list_order(), allowing us to pass
    # such function an empty list name. See such function for further details.
    :bool zeshy_is_in_test_order__

    # Defer to such function with an empty list name.
    :define_func_if_pathable_in_list_order "${@}" ''
}

declare_function_with_stdin <<'/---'
[status = :bool] :define_func_if_pathable_in_list_order(
    :string func_name,
    :string func_body_prefix,
    :string if_command_pathable1, :string then_func_body1, ...,
    :string command_names_list_name)

Define the passed function as the first *function body* (i.e., arbitrary code
implementing such function) whose preceding command is *pathable* (i.e., in the
current command hash and hence typically in the current ${PATH}) tested in the
order such commands appear in the passed list of command names, prefixed by the
passed *function body prefix* (i.e., arbitrary code unconditionally prepended
to such function's implementation). If no such commands are pathable, success
is reported without defining such function: e.g.,.

.:define_func_if_pathable_in_list_order()
==========================================
[source]
------------------------------------------
>>> :list order; order=( anarchism capitalism communism socialism )
>>> commands[anarchism]='true'
>>> :undefine_map_key commands capitalism communism socialism
>>> :define_func_if_pathable_in_list_order :output_alternative\
...     'die_if_args'\
...     'anarchism' ':output_string\
...         "Political theory founded on the observation that since few men are
...          wise enough to rule themselves, even fewer are wise enough to rule
...          others."'\
...     'capitalism' ':output_string "Under capitalism, man exploits man."'\
...     'communism'  ':output_string "Under communism, it's just the opposite."'\
...     'socialism'  ':output_string\
...         "Socialism is the only system for nationalizing compassion so that
...          individuals may be done with it."'\
...     order
>>> :print_function :output_alternative
function :output_alternative() {
    (( # )) && die "Expected no arguments."
    :output_string\
        "Political theory founded on the observation that since few men are
         wise enough to rule themselves, even fewer are wise enough to rule
         others."'
}
------------------------------------------
==========================================

== Search Algorithm ==

This function algorithmically attempts to find the first such command name
pathable by the current user. Specifically:

* For each item of the passed list:
** If such item is not a passed command name, an exception is thrown.
** Else, such item is a passed command name. If such command is pathable,
   define the passed function as the concatenation of:
*** The passed function body prefix.
*** The passed function body following such command in the argument list.
*** The passed function body suffix.

== Command Alternatives ==

Such function requires exactly one of the passed commands, each presumably an
alternative implementation of the same functionality required by such function.
Each such command is followed by a function body, presumably running the
preceding command.

Together, the set of such command names and corresponding function bodies
constitutes an ad-hoc map from the former to the latter. For caller
convenience, such map must be passed as pairs of arguments rather than as the
name of an actual map.

== Command List ==

Each item of the passed list (ideally, list set) must equal such a command
name. Hence, the size of such list must be less than or equal to the number of
such names. If there exist exactly as many such items as names, _all_ such
commands will be tested for pathability. If, however, there exist fewer such
items than names, only the proper subset of such commands appearing in such
list will be tested for pathability (i.e., commands _not_ appearing in such
list will be silently ignored).

== Command Order ==

*Only such list defines the order in which such commands are tested.* The
order in which such command names and function bodies are passed to this
function is insignificant.

Consider globalizing such list to a user-editable configuration file,
permitting users to customize such order and hence which commands this function
should prefer to implement the passed function in terms of.
/---
function :define_func_if_pathable_in_list_order() {
    # Localize arguments, suffixed to protect code evaluated below.
    die_unless_args_5_or_more\
        'Expected one function name, one function body prefix, one or more pairs of one command name and one function body, and one list name.'
    :string\
        func_name__dfipilo="${1}"\
        func_body_prefix__dfipilo="${2}"\
        list_name__dfipilo="${@[-1]}"\
        test__dfipilo\
        test_error__dfipilo
    :bool is_pathable__dfipilo
    :map command_name_to_func_body__dfipilo
    shift_args_2
    pop_arg

    # If the number of remaining arguments is odd and hence does *NOT*
    # constitute a map from command name to function body, throw an exception.
    (( # % 2 == 0 )) or :die 'Expected even number of arguments.'

    # Localize such map.
    command_name_to_func_body__dfipilo=( "${@}" )

    # If a private variable defined only by :define_func_if_pathable() is
    # defined, the passed list name is necessarily empty. In such case, default
    # such name to that of a local list containing all passed command names in the passed order.
    #
    # While this does *NOT* constitute an error, such list name being empty
    # without such variable also being set does. To distinguish between the
    # two, test such variable rather than such list name.
    if (( ${+zeshy_is_in_test_order__} )) {
        :list command_names__dfipilo

        # If such list name is *NOT* empty, throw an exception.
        :is -z "${list_name__dfipilo}" :si or :die\
             '${zeshy_is_in_test_order__} defined but list name "'${list_name__dfipilo}'" nonempty.'

        # Set such list name to the list defined below.
        list_name__dfipilo='command_names__dfipilo'

        # See set_list_to_map_keys() for further details.
        command_names__dfipilo=( ${(k@)command_name_to_func_body__dfipilo} )
        # :output_string "command names: ${command_names__dfipilo[@]}"
    # Else, such private variable is undefined. In such case, behave as
    # documented above - which is to say, normally.
    } else {
        :die_unless_var_list "${list_name__dfipilo}"
    }

    # For each command in such list, test if such command is pathable and, if
    # so, define such function in context of such command.
    :string command_name__dfipilo
    for     command_name__dfipilo ("${(@P)list_name__dfipilo}") {
        # If such map contains no such command, throw an exception.
        (( ${+command_name_to_func_body__dfipilo[${command_name__dfipilo}]} )) or :die\
            'Function '${func_name__dfipilo}'() command "'${command_name__dfipilo}'" unrecognized.'

        # If such command contains no whitespace, skip to the next command
        # unless such command is pathable. See is_pathable() for further
        # details.
        if :is "${command_name__dfipilo}" != *' '* :si {
            (( ${+commands[${command_name__dfipilo}]} )) or continue
        # Else, such command contains whitespace. In such case, assume such
        # command to be a conditional testing the existence of two or more
        # commands. To do so, programmatically convert such string into a true
        # zsh test (e.g., from "catabolic and collapse" to
        # "(( ${+commands[catabolic]} )) && (( ${+commands[collapse]} ))").
        } else {
            # To permit map lookups below, preserve the original command string
            # by performing modifications on this local copy.
            test__dfipilo="${command_name__dfipilo}"

            # If such conditional contains inherently dangerous shell-reserved
            # characters, throw an exception. This includes "`", the obsoleted
            # command substitution prefix, and "$", both the expansion and new
            # command substitution prefix. While command substitutions are
            # patently unsafe (e.g., "$(rm -rf /)"), expansions also support
            # dynamic evaluation of arbitrary code (e.g.,
            # ":string evil='rm -rf /'; : ${(e)evil}") and hence are little
            # safer. Prohibit both by prohibiting their prefixing characters.
            :is "${test__dfipilo}" != *['$`'*] :si or :die\
                'Function '${func_name__dfipilo}'() test "'${test__dfipilo}'" contains unsafe shell-reserved characters "$" and/or "`".'

            # Globally replace in such conditional (in order):
            #
            # * All space-delimited words "or" and "and" with "||" and "&&".
            #   Since both "or" and "and" are valid shell identifiers, do so
            #   *BEFORE* replacing shell identifier characters.
            # * All longest contiguous substrings of shell identifier characters
            #   (signifying unquoted command names) with a test testing the
            #   existence of such command. While command names can technically
            #   contain arbitrary characters, we currently only support common
            #   command names containing no shell-reserved characters and hence
            #   requiring no quoting or escaping.
            test__dfipilo="${${${test__dfipilo// ##or ##/ || }// ##and ##/ && }//(#m)[[:IDENT:]]##/(( \${+commands[${MATCH}]\} ))}"  # unhighlight vim: "}"
            # print "command conditional: ${test__dfipilo}" 1>&2

            # Skip to the next command unless such test dynamically succeeds.
            # If such test fails, such test was either syntactically invalid
            # *OR* syntactically valid and genuinely failed. Discriminate
            # between the two and, in the former case, throw an exception.
            { eval "${test__dfipilo}" } :silent_stderr or {
                # Capture such output, ignoring the expected failure.
                test_error__dfipilo="$(
                    { eval "${test__dfipilo}" } :to_stdout or ignore_failure)"

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                :is -n "${test_error__dfipilo}" :si or continue

                # Else, such test is syntactically invalid. Convert such
                # nonfatal error into a fatal exception. For readability, strip the
                # prefixing "zsh: " from such error message.
                :die 'Command-dependent function '${func_name__dfipilo}'() test "'${test__dfipilo}'" invalid:'$'\n'${test_error__dfipilo#zsh: }
            }
        }

        # Since the current iteration did not continue, such command or
        # commands is pathable. Define such function as such command.
        :define_func "${func_name__dfipilo}" \
"    ${func_body_prefix__dfipilo}
    ${command_name_to_func_body__dfipilo[${command_name__dfipilo}]}"

        # Cease iteration.
        report_success
    }

    # If no such command exists, report failure.
    report_failure
}

# --------------------( WASTELANDS                         )--------------------
        # If such list is *NOT*, throw an exception.
        # :is "${(tP)list_name__dfipilo-}" == 'array'* :si or :die\
        #      'List ${'${list_name__dfipilo}'} undefined or not a list.'

# Declare and define the passed function as the first function body whose
# preceding condition succeeds, prefixed by the passed function body prefix and
# documented by the help string passed on standard input (e.g., as a here-
# document or -string). If all such conditions fail, success is reported without
# declaring, defining, or documenting such function.

    # Validate sanity.
    # die_unless_args_5_or_more\
    #     'Expected one function prototype, one function body prefix, one or more pairs of one test and one function body, and one list name.'
    # :string\
    #     func_prototype__efipiloon="${1}"\
    #     func_name__efipiloon\
    #     func_help__efipiloon
    # shift_arg

    # # Function name declared by such prototype.
    # :set_string_to_runnable_prototype_name\
    #     func_name__efipiloon "${func_prototype__efipiloon}"

    # # Documentation passed on standard input.
    # :set_string_to_stdin_help func_help__efipiloon

    # # Undefine such function if currently defined, guaranteeing that testing
    # # whether such function is defined after attempting to do so succeeds only
    # # such attempt succeeds. See :undefine_func() for further details.
    # unfunction -- "${func_name__efipiloon}"

    # # Attempt to define such function.
    # :define_func_if_pathable_in_list_order_or_noop "${func_name__efipiloon}" "${@}"

    # # If such function is defined, such attempt succeeded. In such case,
    # # document such function. See :is_func() for further details.
    # if (( ${+functions[${func_name__efipiloon}]} )) {
    #     :declare_func <<<"${func_prototype__efipiloon}"$'\n\n'"${func_help__efipiloon}"
    # }
