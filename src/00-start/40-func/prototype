#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *runnable prototypes* (i.e., strings documenting function and alias
signatures -- including attributes, return types, names, and argument types and
order -- in a machine-readable format resembling that of conventional C
function prototypes).
/---

#FIXME: Wierd. Frankly, we should probably just shift such functionality to the
#prior prototype parcel at @{*-declare/*-set}; then, excise this parcel.
#FIXME: After excising this parcel, this entire tree @{*-func} should be
#renamed so as to be sourced *AFTER* all alias trees (e.g., after
#@{*-alias_block_dynamic}.

# ....................{ RENAMERS                           }....................
declare_function_with_stdin <<'/---'
void :rename_runnable_prototype(
    string string_name, string runnable_name)

Rename the single runnable name declared by the value (i.e., runnable
prototype) of the passed string variable to the passed name. If such prototype
declares two or more names (e.g., via `{...,...}` syntax), an exception is
thrown. See :set_string_to_runnable_prototype_name() for further details.
/---
function :rename_runnable_prototype() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one runnable name.'
    :string string_name__rrp="${1}" runnable_name__rrp="${2}" prototype__rrp
    :is -n "${runnable_name__rrp}" :si or :die 'Runnable name empty.'

    # If such variable is not a string, throw an exception. See
    # die_unless_string() for further details.
    :is "${(tP)string_name__rrp-}" == 'scalar'* :si or :die\
        'Variable ${'${string_name__rrp}'} undefined or not a string.'

    # Value of such variable, hopefully signifying a runnable prototype.
    prototype__rrp="${(P)string_name__rrp}"

    # If such prototype is syntactically invalid, throw an exception.
    :is "${prototype__rrp}" =~\
        "${ZESHY_PROTOTYPE_RUNNABLE_NAME_SUFFIXED_PREFIXED_PCRE}" :si or :die\
        'Runnable prototype "'${prototype__rrp}'" invalid or declares two or more runnable names.'

    # If either such name or prefixing and suffixing substrings were *NOT*
    # captured, throw an exception.
    (( ${#match} >= 3 )) or :die\
        'PCRE matching runnable prototype "'${prototype__rrp}'" invalid.'

    # Rename such prototype.
    :set_string_to_string\
        "${string_name__rrp}"\
        "${match[1]}${runnable_name__rrp}${match[3]}"
}

# --------------------( WASTELANDS                         )--------------------
    # Rename such prototype. See :set_string_to_string() for further details.
    # :noop "${(P)string_name__rrp::=${match[1]}${runnable_name__rrp}${match[3]}}"

# ....................{ SETTERS                            }....................
# declare_function_with_stdin <<'/---'
# void :set_string_to_runnable_prototype_name(
#     string string_name, string runnable_prototype)
# 
# Set the passed string variable to the single runnable name declared by the
# passed *runnable prototype* (i.e., string documenting a function or alias
# signature -- including attributes, return types, names, and argument types and
# order -- in a machine-readable format resembling that of conventional C
# function prototypes). If such prototype declares two or more names (e.g., via
# `{...,...}` syntax), an exception is thrown.
# /---
# function :set_string_to_runnable_prototype_name() {
#     # Validate sanity.
#     die_unless_args_2 'Expected one string name and one runnable prototype.'
#     :string string_name__sstrpn="${1}" prototype__sstrpn="${2}"
#     :is -n "${prototype__sstrpn}" :si or :die 'Runnable prototype empty.'
# 
#     # If such variable is not a string, throw an exception. See
#     # die_unless_string() for further details.
#     :is "${(tP)string_name__sstrpn-}" == 'scalar'* :si or :die\
#         'Variable ${'${string_name__sstrpn}'} undefined or not a string.'
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     :is "${prototype__sstrpn}" =~\
#         "${ZESHY_PROTOTYPE_RUNNABLE_NAME_PCRE}" :si or :die\
#         'Runnable prototype "'${prototype__sstrpn}'" invalid or declares two or more runnable names.'
# 
#     # If such name was *NOT* captured into ${match[1]}, throw an exception.
#     (( ${#match} )) or :die\
#         'Runnable prototype "'${prototype__sstrpn}'" name uncaptured.'
# 
#     # If such name was captured but is empty, throw an exception. (While this
#     # *SHOULD* always be the case, forcibly guaranteeing this guards against
#     # silent-but-deadly PCRE regressions.)
#     :is -n "${match[1]}" :si or :die\
#         'Runnable prototype "'${prototype__sstrpn}'" name empty.'
# 
#     # Set such string to such name. See :set_string_to_string() for further
#     # details.
#     :noop "${(P)string_name__sstrpn::=${match[1]}}"
# }

# Set the passed string variable to the single runnable name matched with the
# passed PCRE from the passed *runnable prototype* (i.e., string documenting a
# 
# == Prototype PCRE ==
# 
# Such PCRE must capture only a single runnable name into the first match group
# (i.e., `${match[1]}`). While such PCRE may optionally match and capture
# additional prototype syntax, this function ignores all but such name.

    # die_unless_args_3\
    #     'Expected one string name, one runnable prototype, and one runnable prototype PCRE.'
    # :string\
    #     string_name__sstrpn="${1}"\
    #     prototype__sstrpn="${2}"\
    #     prototype_pcre__sstrpn="${3}"
    # :is -n "${prototype__sstrpn}" :si or :die\
    #     'Runnable prototype empty.'
    # :is -n "${prototype_pcre__sstrpn}" :si or :die\
    #     'Runnable prototype PCRE empty.'

#FUXME: Implement :set_string_to_func_prototype_name().
#FUXME: Implement :set_string_to_alias_prototype_name().
#, string runnable_prototype_pcre

# Else, capture such name.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :set_string_to_func_prototype_name().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
