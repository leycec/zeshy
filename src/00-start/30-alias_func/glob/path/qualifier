#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *glob qualifiers* (i.e., `(#q`- and `)`-delimited expressions suffixing
path-specific globs).

== See Also ==

* Section ``Glob Qualifiers'' of `man zshexpn`, documenting such qualifiers.
* @{path/qualifier}, a parcel handling path qualifiers _not_ prefixed by path-
  specific globs and hence _not_ requiring the early-time compilation of
  function attribute `<globbable>` this parcel requires.
/---

# ....................{ TESTERS                            }....................
#FIXME: Great example, but overlong. Split below.
:declare_func_ '<globbable> [status = :bool] :is_glob_qualified_path(
    :string glob,
    :string glob_qualifier1, ...)' :declare_func{
    # Report success if some such path matches.
    :list pathnames
    :set_list_to_glob_qualified_paths pathnames "${@}"
    is_list_nonempty pathnames
}:declare_func <<'/---'
Report success if at least one existing path matches both the passed glob _and_
all passed glob qualifiers. See :set_list_to_glob_qualified_paths()
for further details: e.g.,

.:is_glob_qualified_path()
==========================================
[source]
------------------------------------------
>>> :string on_mondays=\
...    "Both Plato and Xenophon attribute to Socrates and obviously share with
...     him an awareness of the destructive effects of work on the worker as a
...     citizen and a human being. Herodotus identified contempt for work as an
...     attribute of the classical Greeks at the zenith of their culture. To
...     take only one Roman example, Cicero said that \"whoever gives his labor
...     for money sells himself and puts himself in the rank of slaves.\" His
...     candor is now rare, but contemporary primitive societies which we are
...     wont to look down upon have provided spokesmen who have enlightened
...     Western anthropologists. The Kapauku of West Irian, according to
...     Posposil, have a conception of balance in life and accordingly work only
...     every other day, the day of rest designed \"to regain the lost power and
...     health.\" Our ancestors, even as late as the eighteenth century when
...     they were far along the path to our present predicament, at least were
...     aware of what we have forgotten, the underside of industrialization.
...     Their religious devotion to \"St. Monday\" – thus establishing a de
...     facto five-day week 150-200 years before its legal consecration – was
...     the despair of the earliest factory owners. They took a long time in
...     submitting to the tyranny of the bell, predecessor of the time clock. In
...     fact it was necessary for a generation or two to replace adult males
...     with women accustomed to obedience and children who could be molded to
...     fit industrial needs. Even the exploited peasants of the ancient regime
...     wrested substantial time back from their landlord's work. According to
...     Lafargue, a fourth of the French peasants' calendar was devoted to
...     Sundays and holidays, and Chayanov's figures from villages in Czarist
...     Russia – hardly a progressive society – likewise show a fourth or fifth
...     of peasants' days devoted to repose. Controlling for productivity, we
...     are obviously far behind these backward societies. The exploited muzhiks
...     would wonder why any of us are working at all. So should we."
>>> make_dir on_diversity
>>> :is_glob_qualified_path ?n_d?v?rs?t? '/^F' 'u'"$(get_user)" and
...     get_string_line "${on_mondays}" -1
would wonder why any of us are working at all. So should we.
------------------------------------------
==========================================
/---

# ....................{ GETTERS                            }....................
#FIXME: Refactor into
#:set_string_to_glob_qualified_path_first_if_found().
:declare_func_ '<globbable> [stdout = :string, status = :bool]
    get_path_globbed_matching_qualifier_first_if_found(
        :string glob,
        :string glob_qualifier1, ...)' :declare_func{
    # If at least one pathname matches, get the first; else, fail. For
    # simplicity, implement such test as an "and" rather than "if" conditional.
    :list pathnames
    :set_list_to_glob_qualified_paths pathnames "${@}"
    is_list_nonempty pathnames and :output_string "${pathnames[1]}"
}:declare_func <<'/---'
Get the first passed path that exists _and_ matches the passed glob and all
passed glob qualifiers or return failure if no such path exists. See
get_path_matching_qualifier_first_if_found() for further details: e.g.,

.get_path_globbed_matching_qualifier_first_if_found()
==========================================
[source]
------------------------------------------
>>> get_path_globbed_matching_qualifier_first_if_found /bin/mk[a-z]## rAR xEX
/bin/mkdir
------------------------------------------
==========================================

== Exception Handling ==

There exists no corresponding get_path_globbed_matching_qualifier_first(). While
implementing such function is certainly feasible, any exceptions thrown by such
implementation would be unlikely to be human-readable (e.g.,
`no path matches glob "'imprimi_potest/'*(#q'w/')"`). Instead, simply call this
function and throw an exception if such call fails: e.g.,

.get_path_globbed_matching_qualifier_first_if_found() Exception Handling
==========================================
[source]
------------------------------------------
>>> :string on_divinity=\
...    "Confronted, when the weather is fine and I am in propitious emotional
...     circumstances, with certain landscapes, certain works of art, certain
...     human beings, I know, for the time being, that God's in his heaven and
...     all's right with the world. On other occasions, skies and destiny being
...     inclement, I am no less immediately certain of the malignant
...     impersonality of an uncaring universe. Every human being has had similar
...     experiences. This being so, the sensible thing to do would be to accept
...     the facts and frame a metaphysic to fit them. But with that talent for
...     doing the wrong thing, that genius for perversity, so characteristically
...     human, men have preferred, especially in recent times, to take another
...     course. They have either denied the existence of these psychological
...     facts; or if they have admitted them, have done so only to condemn as
...     evil all such experiences as cannot be reconciled in a logical system
...     with whatever particular class of experiences they have chosen,
...     arbitrarily, to regard as \"true\" and morally valuable. Every man tries
...     to pretend that he is consistently one kind of person and does his best
...     consistently to worship one kind of God. And this despite the fact that
...     he experiences diversity and actually feels himself in contact with a
...     variety of divinities."
>>> get_path_globbed_matching_qualifier_first_if_found /etc/[a-z]##tab ^u0 or\
...     get_string_line "${on_worship}" 1
Confronted, when the weather is fine and I am in propitious emotional
------------------------------------------
==========================================
/---

# ....................{ SETTERS                            }....................
:declare_func_ '<globbable> :void :set_list_to_glob_qualified_paths(
    :string:list? list_name,
    :string glob,
    :string glob_qualifier, ...)' :declare_func{
    # Localize arguments.
    :string list_name__sltpgmq="${1}" glob__sltpgmq="${2}"
    shift_args 2

    # Qualify such glob with such qualifiers.
    :qualify_glob glob__sltpgmq "${@}"

    # Perform such match.
#   :output_string "glob: ${glob__sltpgmq}"
    set_list_to_evaluation "${list_name__sltpgmq}" '${~glob__sltpgmq}'
}:declare_func <<'/---'
Set the passed list to the subset of passed paths that exist _and_ match both
the passed glob and all passed glob qualifiers: e.g.,

.:set_list_to_glob_qualified_paths()
==========================================
[source]
------------------------------------------
>>> :list pseudo_files
>>> :set_list_to_glob_qualified_paths pseudo_files /proc/[a-z]## -.L0
>>> :output_string "${pseudo_files[1,3]}"
/proc/buddyinfo /proc/cgroups /proc/cmdline
------------------------------------------
==========================================

== Qualifier Syntax ==

For convenience, glob qualifiers may be formatted as any of the following:

* Undelimited strings (e.g., `^-U`, matching files _not_ owned by the current
  effective user after resolving symbolic links).
* `(`- and `)`-delimited strings (e.g., `(^-U)`).
* `(#q`- and `)`-delimited strings (e.g., `(#q^-U)`).
/---

# ....................{ QUALIFIERS                         }....................
:declare_func_ ':void :qualify_glob(
    :string:string? glob_name,
    :string qualifier1, ...)' :declare_func{
    # Localize arguments.
    :string glob_name__qg="${1}" glob_qualifiers__qg
    shift_arg

    # If only passed one such qualifier, suffix such string by such qualifier,
    # delimited by "(#q" and ")" if not already delimited by either "(" and ")"
    # *OR* "(#q" and ")". For efficiency and implementation differences between
    # this and the alternative case, implement such cases independently.
    if { is_arg } {
        glob_qualifiers__qg="${1}"
        :is "${glob_qualifiers__qg}" == '('(|'#q')*')' :si or
              glob_qualifiers__qg="(#q${glob_qualifiers__qg})"
    # Else, multiple qualifiers were passed. Iteratively suffix such string with
    # such qualifiers, delimited by "(#q" and ")" if not already.
    } else {
        # For efficiency, append onto a local string rather than calling
        # :suffix_string() each iteration.
        :string glob_qualifier__qg
        for     glob_qualifier__qg ("${@}") {
            # If such qualifier is unsafely delimited by "(" and ")", convert
            # "(" to "(#q". zsh requires each of a series of multiple qualifiers
            # to be prefixed by "(#q" rather than "(".
            if :is "${glob_qualifier__qg}" != '(#q'*')' :si {
                glob_qualifiers__qg+="(#q${${glob_qualifier__qg#(}%)})"
            } else {
                glob_qualifiers__qg+="${glob_qualifier__qg}"
            }
        }
    }

    # Suffix such glob by such qualifiers.
    :suffix_string "${glob_name__qg}" "${glob_qualifiers__qg}"
}:declare_func <<'/---'
Append the first passed string with the concatenation of all remaining passed
strings converted to *glob qualifiers* (i.e., `(#q`- and `)`-delimited strings
to be appended to pathname globs, filtering undesirable pathnames from the set
of all pathnames matching such globs): e.g.,

.:qualify_glob()
==========================================
[source]
------------------------------------------
>>> :string glob='/etc/**/*.lisp'
>>> :qualify_glob glob '-.' 'u0'
>>> ::output_string "${glob}"
/etc/**/*.lisp(#q-.)(#qu0)
>>> :list pathnames; pathnames=( ${~glob} )
>>> ::output_strings_newlined "${pathnames[@]}"
/etc/gentoo-init.lisp
/etc/lisp-config.lisp
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
# ....................{ CONVERTERS                         }....................
#FUXME: Excise.
#FUXME: Command substitution is highly inefficient. Refactor into:
#     void :set_string_to_glob_qualifier(string string_name, string text1, ...)

# declare_function_with_stdin <<'/---'
# string convert_string_to_glob_qualifier(string text1, ...)
# 
# Convert each passed string to a *glob qualifier* delimited by `(#q` and `)`, if
# not already, and return the concatenated results: e.g.,
# 
# .convert_string_to_glob_qualifier()
# ==========================================
# [source]
# ------------------------------------------
# >>> convert_string_to_glob_qualifier '-.' 'a+40000'
# (#q-.)(#qa+40000)
# ------------------------------------------
# ==========================================
# /---
# function convert_string_to_glob_qualifier() {
#     # Validate sanity.
#     die_unless_args 'Expected one or more qualifier strings.'
#     string glob_qualifier
# 
#     # If only passed one such qualifier and such qualifier is not already
#     # delimited by either `(` and `)` *OR* `(#q` and `)`, delimit such qualifier
#     # by the latter. This logic differs slightly from that when passed more than
#     # one such qualifier, since in the latter case `(` and `)` qualifiers
#     # constitute invalid syntax and hence must be replaced.
#     #
#     # For efficiency, inline such test both here and below.
#     if { is_arg } {
#         glob_qualifier="${1}"
# 
#         if is "${glob_qualifier}" != '('(|'#q')*')' si {
#             return_string "(#q${glob_qualifier})"
#         } else {
#             return_string "${glob_qualifier}"
#         }
#     # Else, more than one such qualifier was passed. For each such qualifier not
#     # already delimited by `(#q` and `)`, do so. If such qualifier is unsafely
#     # already delimited by `(` and `)`, convert the `(` to `(#q`. The reason is
#     # subtle: qualifier syntax permits `(` prefixes only if there exists one such
#     # qualifier; in all other cases, `(#q` prefixes are required instead.
#     } else {
#         string glob_qualifier glob_qualifiers
#         for    glob_qualifier ("${@}") {
#             if is "${glob_qualifier}" != '(#q'*')' si {
#                 glob_qualifiers+="(#q${${glob_qualifier#(}%)})"
#             } else {
#                 glob_qualifiers+="${glob_qualifier}"
#             }
#         }
#         return_string "${glob_qualifiers}"
#     }
# }

    # :string glob="${1}"
    # shift_arg
    # Delimit such qualifiers, if not already.
    # glob+="$(convert_string_to_glob_qualifier "${@}")"
    # # Perform such match.
    # set_list_to_paths_globbed pathnames "${glob}"

    # # Delimit such qualifiers, if not already.
    # glob+="$(convert_string_to_glob_qualifier "${@}")"

    # # Perform such match.
    # set_list_to_paths_globbed pathnames "${glob}"

# glob__sltpgmq+="$(convert_string_to_glob_qualifier "${@}")"

    # inline such test both here and
    # below.
    # delimit such qualifier
    # by the latter. This logic differs slightly from that when passed more than
    # one such qualifier, since in the latter case "(" and ")" qualifiers
    # constitute invalid syntax and hence must be replaced.

            # only performed qualifier syntax allows "("
            # prefixes only if there exists one such qualifier; in all other
            # cases, "(#q" prefixes must be used instead.

#FUXME: In lieu of unit tests...
#function   lieu() {
#}

#   if { is_list_nonempty pathnames } {
#       return_string  "${pathnames[1]}"
    # Else, fail.
#   } else {
#       report_failure
#   }

#As under :set_list_to_glob_qualified_paths(),
#such qualifier may be parenthesized (e.g., `(.-)`) or not (e.g., `.-`)

#   pathname_match=( "${^@}"${~qualifier__sltpmq} ) or ignore_failure
#   set_list_to_paths_globbed ${list_name__sltpgmq} "${glob__sltpgmq}"

#, matching the same
    # Set such list. Since such setting tends to return spurious non-zero exit
    # status (e.g., if any globbed path is not readable by the current user),
    # ignore the resulting status.
#   eval ${list_name__sltpmq}'=( ${~glob__sltpmq} )' or ignore_failure

#, ignoring non-fatal errors induced by such match. See
    # :set_list_to_glob_qualified_paths() for further details
#There are many kinds of gods. Therefore there are many kinds of men.

#   die_unless_path "${pathname}"

#Return success if at least one path matches all passed glob qualifiers, each of
#which may be either parens-delimited (e.g., `(^-U)`) or not (e.g., `^-U`): e.g.,

#FUXME: Create a new :is_glob_qualified_path() accepting a glob as well.

    # Return such qualifier.
#   :output_string "${glob_qualifier}"
#FUXME: Rename to convert_string_to_glob_qualifier().

    # If such path exists, match such qualifier. Since no glob qualifier ever
    # matches a nonextant path, ignore nonextant paths.
#   is_path "${pathname}" and {

#. See section "Glob Qualifiers" in "man zshexpn" for further details
#       "${list_name__sltpmq}" '${~glob__sltpmq}${~glob_qualifier__sltpmq}'
#   die_unless_path "${pathname}"
        # If such qualifiers are not already parens-delimited, do so.
#       :is_string_matches_glob "${glob_qualifier}" '\((|\#q)*\)' or
#           glob_qualifier="(#q${glob_qualifier})"

        #FUXME: Hmm; does non-zero exit status actually indicate a match failure in
        #all possible cases? Negligibly minor optimization, but somewhat
        #intellectually intriguing.

#, expanded immediately after expanding such path and hence equivalent to "${pathname}"${~glob}
# Get the absolute path of the first directory in the passed list of dirnames
# that exists and is writable by the current user after resolving symbolic links
# or raise an exception if no such directory exists.
    # List of pathnames filtered from the list of passed pathnames. Dismantled,
    # this is:
    #
    # * "${^@}", iteratively expanding to each passed pathname.
    # * "(${glob_qualifiers}), excluding pathnames not matching the passed glob
    #   qualifiers.
    # * "[1]", excluding all but the first such match. (Yes, this is somewhat
    #   silly. While *WE* know this glob expression is guaranteed to match at
    #   most one pathname, zsh doesn't. For safety, GLOB_ASSIGN is not globally
    #   enabled. While this function could locally enable such option, that
    #   hardly seems sensible.)
#FUXME: We should probably rename all functions matching is_*_match() to
#is_*_matching_*() (e.g., from :is_string_matches_glob() to is_string_matchesing(), from
#is_string_matches_pcre_multiline() to is_string_matchesing_pcre_line()). Extending this
#to get_*_match() functions seems somewhat absurd, however: e.g., from
#get_string_pcre_multiline_match_index_all() to get_string_matches_pcre_line() is terrible
#and doesn't even make sense.
# boolean :is_glob_qualified_pathing_glob_qualifier(
#function :is_glob_qualified_pathing_glob_qualifier() {

#
        #Interestingly, this also allows us to obsolete the need to explicitly
        #pass in human-readable labels. Indeed, I now believe we should entirely
        #excise the passed ${match_type_singular} and ${match_type_plural}
        #arguments in favor of an internal lookup table from 
