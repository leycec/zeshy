#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *globbable list getters* (i.e., functions getting list items and indices
by matching such items against glob expressions).
/---

#FIXME: Refactor all getters to setters.

# ....................{ GETTERS                            }....................
:func_ '<globbable> :string get_list_item_first_matching_glob(
    :string:list? list_name, :string glob)' :func{
    # Localize arguments.
    :string match__glimgf

    # Get such match if found or throw an exception.
    if { match__glimgf="$(get_list_item_first_matching_glob_if_found "${@}")" } {
        return_string "${match__glimgf}"
    } else {
        :string list_name__glimgf="${1}" glob__glimgf="${2}"
        :die 'List ${'${list_name__glimgf}'} item matching "'${glob__glimgf}'" not found.'
    }
}:func <<'/---'
Get the first item of the passed list matching the passed glob or throw an
exception if no such item matches: e.g.,

.get_list_item_first_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_sectarianism; on_sectarianism=(
...    "Nevertheless this business of legislating religious beliefs into law"
...    "has never been more than sporadically successful in this country –"
...    "Sunday closing laws here and there, birth control legislation in spots,"
...    "the Prohibition experiment, temporary enclaves of theocracy such as"
...    "Voliva's Zion, Smith's Nauvoo, a few others. The country is split up"
...    "into such a variety of faiths and sects that a degree of uneasy"
...    "tolerance now exists from expedient compromise; the minorities"
...    "constitute a majority of opposition against each other. Could it be"
...    "otherwise here? Could any one sect obtain a working majority at the"
...    "polls and take over the country? Perhaps not – but a combination of a"
...    "dynamic evangelist, television, enough money, and modern techniques of"
...    "advertising and propaganda might make Billy Sunday's efforts look like"
...    "a corner store compared to Sears Roebuck. Throw in a depression for"
...    "good measure, promise a material heaven here on earth, add a dash of"
...    "anti-Semitism, anti-Catholicism, anti-Negroism, and a good large dose"
...    "of anti-\"furriners\" in general and anti-intellectuals here at home"
...    "and the result might be something quite frightening – particularly when"
...    "one recalls that our voting system is such that a minority distributed"
...    "as pluralities in enough states can constitute a working majority in"
...    "Washington... The capacity of the human mind for swallowing nonsense"
...    "and spewing it forth in violent and repressive action has never yet"
...    "been plumbed." )
>>> get_list_item_first_matching_glob on_sectarianism *'anti-'[[:WORD:]]*
anti-Semitism, anti-Catholicism, anti-Negroism, and a good large dose
------------------------------------------
==========================================
/---

:func_ '<globbable> [stdout = :string, status = :bool]
    get_list_item_first_matching_glob_if_found(
        :string:list? list_name, :string glob)' :func{
    # Localize arguments.
    :string list_name__glimgfif="${1}"
    :int index__glimgfif

    # Get such item if found or fail. Since subscript flag "(r)" expands to
    # the empty string if no such item matches and hence is indistinguishable
    # from a successful match of the empty string (e.g., "*"), avoid such flag.
    index__glimgfif="$(get_list_index_first_matching_glob_if_found "${@}")" and
        :output_string "${${(@P)list_name__glimgfif}[${index__glimgfif}]}"
}:func <<'/---'
Get the first item of the passed list matching the passed glob or return
failure if no item matches: e.g.,

.get_list_item_first_matching_glob_if_found()
==========================================
[source]
------------------------------------------
>>> :list on_testimony; :on_testimony=(
...    "In the Twentieth Century of my trespass on earth,"
...    "having exterminated one billion heathens,"
...    "heretics, Jews, Moslems, witches, mystical seekers,"
...    "black men, Asians, and Christian brothers,"
...    "every one of them for his own good,"
...    ""
...    "a whole continent of red men for living in unnatural community"
...    "and at the same time having relations with the land,"
...    "one billion species of animals for being sub-human,"
...    "and ready to take on the bloodthirsty creatures from the other planets,"
...    "I, Christian man, groan out this testament of my last will." )
>>> get_list_item_first_matching_glob_if_found on_testimony ?p?c?l?ps? or
...     :output_string "We shall not all sleep, but we shall be changed . . ."
We shall not all sleep, but we shall be changed . . .
------------------------------------------
==========================================
/---

# ....................{ GETTERS ~ index                    }....................
#FIXME: Indominitable examples, but a tad overlang. Shift half of each elsewhere
#-- ideally into the corresponding setters.

:func_ '<globbable> :int get_list_index_first_matching_glob(
    :string:list? list_name, :string glob)' :func{
    # Get such index if found or throw an exception.
    :string index__glimgf
    set_integer_to_list_index_first_matching_glob index__glimgf "${@}"
    :output_string "${index__glimgf}"
}:func <<'/---'
Get the 1-based index of the first item in the passed list matching the passed
glob expression or throw an exception if no such item matches: e.g.,

.get_list_index_first_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_tumescence; :on_tumescence=(
...     "I give my blood fifty parts polystyrene,"
...     "twenty-five parts benzene, twenty-five parts good old gasoline,"
...     "to the last bomber pilot aloft, that there shall be one acre"
...     "in the dull world where the kissing flower may bloom,"
...     "which kisses you so long your bones explode under its lips."
...     ""
...     "My tongue goes to the Secretary of the Dead"
...     'to tell the corpses, "I'm sorry, fellows,'
...     "the killing was just one of those things"
...     "difficult to pre-visualize — like a cow,"
...     'say, getting blown up by lightning."'
...     ""
...     "My stomach, which has digested"
...     "four hundred treaties giving the Indians"
...     "eternal right to their land, I give to the Indians,"
...     "I throw in my lungs full of tumors, from faithfully"
...     "smoking the peace pipe before every massacre."
...     ""
...     "My soul I leave to the bee"
...     "that he may sting it and die, my brain"
...     "to the fly, his back the hysterical green color of slime,"
...     "that he may suck on it and die, my flesh to the advertising man,"
...     "the anti-prostitute, who loathes human flesh for money." )
>>> get_list_index_first_matching_glob on_tumescence *'to the'[[:blank:]]*
3
------------------------------------------
==========================================
/---

:func_ '<globbable> [stdout = :int, status = :bool]
    get_list_index_first_matching_glob_if_found(
        :string:list? list_name, :string glob)' :func{
    # Get such index if found or report failure.
    :string index__glimgfif
    set_integer_to_list_index_first_matching_glob_if_found\
        index__glimgfif "${@}" and :output_string "${index__glimgf}"
}:func <<'/---'
Get the 1-based index of the first item in the passed list matching the passed
glob expression or report failure if no such item matches: e.g.,

.get_list_index_first_matching_glob_if_found()
==========================================
[source]
------------------------------------------
>>> :list on_madness; :on_madness=(
...     "I assign my crooked backbone"
...     "to the dice maker, to chop up into dice,"
...     "for casting lots as to who shall see his own blood"
...     "on his shirt front and who his brother's,"
...     "for the race isn't to the swift but to the crooked."
...     ""
...     "To the last man surviving on earth"
...     "I give my eyelids worn out by fear, to wear"
...     "in his long nights of radiation and silence,"
...     "so that his eyes can't close, for regret"
...     "is like tears seeping through closed eyelids."
...     "
...     "I give the emptiness my hand: the pinkie picks no more noses,"
...     "slag clings to the black stick of the ring finger,"
...     "a bit of flame jets from the tip of the fuck-you finger,"
...     "the first finger accuses the heart, which has vanished,"
...     "on the thumb stump wisps of smoke ask a ride into the emptiness."
...     ""
...     "In the Twentieth Century of my nightmare"
...     "on earth, I swear on my chromium testicles"
...     "to this testament"
...     "and last will"
...     "of my iron will, my fear of love, my itch for money, and my madness." )
>>> get_list_index_first_matching_glob_if_found on_madness *'on_sanity'* or
...     :output_string "Lieutanant! This corpse will not stop burning!"
Lieutanant! This corpse will not stop burning!
------------------------------------------
==========================================
/---

#FIXME: Add examples.
:func_ '<globbable> [stdout = :int, status = :bool]
    get_list_index_first_matching_glob_after_index_if_found(
        :string:list? list_name, :string glob, :int? start_index)' :func{
    # Validate sanity.
    :string\
        list_name__glmifafif="${1}"\
        glob__glmifafif="${2}"\
        index_start__glmifafif="${3}"\
        list_size__glmifafif
    :int index__glmifafif
    :list list_copy__glmifafify
    die_unless_list_index "${list_name__glmifafif}" "${index_start__glmifafif}"

    # Begin searching at the next such index. Since zsh supplies no builtin
    # means of finding from some index (subscript flag "(i)" always matches from
    # index 1), consider the following clever alternative:
    #
    # * Copy the *ENTIRE* subset of such list after such index into a new list.
    # * Search such list with subscript flag "(i)".
    # * Offset the matching index if found by the passed index.
    #
    # In the worst case, such copy duplicates such list. While unfortunate, this
    # is considerably faster (if memory intensive) than manual iteration.
    list_copy__glmifafif=(
        "${${(@P)list_name__glmifafif}[$(( index_start__glmifafif + 1 )),]}" )

    # Get such index if found or report failure.
    index__glmifafif="$(get_list_index_first_matching_glob_if_found\
        list_copy__glmifafif "${glob__glmifafif}")"  and
        :output_string $(( index__glmifafif + index_start__glmifafif ))
}:func <<'/---'
Get the 1-based index of the first item in the passed list matching the
passed glob _after_ the passed index or report failure if no such item matches.
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to get_list_index_first_matching_glob() in light of nomenclature
#elsewhere (e.g., get_list_index_first_equaling()). Quite a bit more readable,
#in any case. Perform such renamings above and below, naturally.
#function get_list_index_first_matching_glob_if_found() {
#    # Validate sanity.
#    die_unless_args_2 'Expected one list name and one glob.'
#    string list_name__glimgfif="${1}" glob__glimgfif="${2}"
#    integer list_index__glimgfif
#    :die_unless_var_list "${list_name__glimgfif}"
#
#    # 1-based index of the first matching item. Dismantled, this is:
#    #
#    # * '@P', expanding to the passed list.
#    # * 'i', expanding to the index of the first item matching...
#    # * "${~glob__glimgfif}", the passed glob as a glob rather than literal.
#    list_index__glimgfif="${${(@P)list_name__glimgfif}[(i)${~glob__glimgfif}]}"
#
#    # Get such index if found or report failure.
#    (( list_index__glimgfif <= $(get_list_size "${list_name__glimgfif}") )) and
#        :output_string "${list_index__glimgfif}"
#}

#function get_list_index_first_matching_glob() {
#    # Validate sanity.
#    die_unless_args_2 'Expected one list name and one glob.'
#    string index__glimgf
#
#    # Get such index if found or throw an exception.
#    if { index__glimgf="$(get_list_index_first_matching_glob_if_found "${@}")" } {
#        return_string "${index__glimgf}"
#    } else {
#        string list_name__glimgf="${1}" glob__glimgf="${2}"
#        die 'List ${'${list_name__glimgf}'} contains no item matching "'${glob__glimgf}'".'
#    }
#}

# Yes, the distinctions in nomenclature between this and subsequent functions is
# intended. See @{glob/variable/string/string} for additional justifications.

#>>> Political tags -- such as royalist, communist, democrat, populist, fascist, liberal, conservative, and so forth -- are never basic criteria. The human race divides politically into those who want people to be controlled and those who have no such desire. The former are idealists acting from highest motives for the greatest good of the greatest number. The latter are surly curmudgeons, suspicious and lacking in altruism. But they are more comfortable neighbors than the other sort. 

#   if { index__glimgfif="$(get_list_index_first_matching_glob_if_found "${@}")" } {
#       return_string "${${(@P)list_name__glimgfif}[${index__glimgfif}]}"
#   } else {
#       report_failure
#   }

#FUXME: Rename to
#set_list_to_list_items_between_items_matching_glob(). For simplicity, such
#function should behave inclusively in all cases. This will require a minor
#change here (...for the better, simplifying the implementation below) and
#wherever this function is called. If the caller requires exclusivity on either
#end, they'll simply have to call shift_list() and/or pop_list() -- quite
#doable, really. There's *NO* way to meaningfully embed such operations in this
#function's nomenclature; so, this is absolutely the way to go.

        # Since such match is exclusive, offset such index to the prior item.
#       (( --index_end__sltlebmi ))

#FUXME: Terrible name, really. Consider renaming to
#remove_list_items_before_match_and_after_match() or
#remove_list_items_around_items_matching_globs(). Yes,
#the latter I should think.
#Equivalently, remove all items from the passed list either:
#
#* Preceding the first item matching the first passed glob, excluding such
#  item. If no such item matches, throw an exception.
#* Following the next item matching the second passed glob, including such
#  item. If no such item matches, remove no such items, thus
#  mimicking remove_list_nonmatches_before().
#   string list_name__rlebmaafm="${1}"
#   shift_arg

    # Remove such non-matches.
#   set_list_to_list_items_between_items_matching_globs\
#       "${list_name__rlebmaafm}" "${list_name__rlebmaafm}" "${@}"

#FUXME: Rename to remove_list_items_not_matching_glob(). Trying to grok the current function
#name severely hurts my head. (A bad thing.)
# or die "list \"${list_name_source__sltleami}\" contains no item matching \"${glob__sltleami}\""
#FUXME: Rename to set_list_to_list_items_matching_glob_first_until_next(). Scratch that. How
#about set_list_to_list_items_after_match_until_match_inclusive() or simply
#set_list_to_list_items_between_items_matching_globs()? Right. The latter reads
#particularly well.
#FUXME: Drop the optional default value here and elsewhere. Unhelpful and
#obfuscatory.

    #FUXME: Call die_unless_list_index() instead.
    # Validate such index, permitting index 0 as well as normal 1-based indices.
#   __list_size__="$(get_list_size "${list_name}")"
#   (( __offset__ >= 0 && __offset__ < __list_size__ )) or
#       die "list \"${list_name}\" index ${__offset__} not in [0, ${__list_size__})"

    #FUXME: Shouldn't this defer to get_list_index_first_matching_glob_if_found()?
    # Return such index if found or throw an exception.
#   integer __index__
#   if { __index__="$(get_list_index_first_matching_glob_if_found "${@}")" } {
#       return_string "${__index__}"
#   } else {
#       string list_name="${1}" __glob__="${2}"
#       die "no item of list \"${list_name}\" matching \"${__glob__}\""
#   }

#FUXME: Once we validate this works as expected, implement the converse
#get_last_list_item_matching() function by using flag "(R)" where we
#currently use flag "(r)".

    #FUXME: Shouldn't this defer to get_list_item_first_matching_glob_if_found()?
    # Return such item if found or throw an exception. Avoid subscript flag
    # "(r)", which expands to the empty string if no such item matches. Such
    # expansion is indistinguishable from a successful match, if the first such
    # match is the empty string (e.g., with glob "*").
#   integer __index__
#   if { __index__="$(get_list_index_first_matching_glob_if_found "${@}")" }
#       return_string "${${(@P)list_name}[${__index__}]}"
#   } else {
#       string list_name="${1}" __glob__="${2}"
#       die "no item of list \"${list_name}\" matching \"${__glob__}\""
#   }

#   string text="${1}" glob_first="${2}" glob_next
#   glob_next="${4-${glob_first}}"
# void remove_list_nonmatches_before_match_first_or_match_next_and_after(
# after and
# including the first item matching the first passed glob until but
# excluding the next item matching the second passed glob. If no item
# matches the first passed glob, throw an exception. However, if no item
# matches the second passed glob, simply include all remaining items, thus
# mimicking set_list_to_list_items_after_item_matching_glob().
    #FUXME: It might actually be more efficient to copy the entire subset of the
    #passed list following such index into a new temporary list for searching,
    #as "(i)" *WOULD* work on such temporary. Actually, yes... this is most
    #certainly more efficient.
#   for (( ++__index__; __index__ <= __list_size__; ++__index__ )) {
#       :is_string_matches_glob\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    #FUXME: Not right. An empty item could in fact match a non-empty glob
    #(e.g., "*"), in which case testing emptiness does not suffice. Instead,
    #call get_list_index_first_matching_glob() and note this subtlety.
    # Get the first match. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'r', expanding to the first item matching...
    # * "${~glob}", the passed glob as a glob rather than raw string.
#   __item__="${${(@P)list_name}[(r)${~__glob__}]}"

    # Throw an exception if no item matches.
#   die_if_string_empty "${__item__}"\
#       "no item of list \"${list_name}\" matches \"${__glob__}\""

    # Otherwise, return such item.
#   print_string "${__item__}"
    # Find the first match.
#   integer __index__ __list_size__
#   __list_size__="$(get_list_size "${list_name}")"
#   for (( __index__ = 0; __index__ < __list_size__; ++__index__ )) {
#       :is_string_matches_glob\
#           "${${(@P)list_name}[${__index__}]}" "${glob}" and break
#   }

    # Throw an exception if no item matches.
#   (( __index__ < __list_size__ )) or
#       die "no item of list \"${list_name}\" matches \"${__glob__}\""

# void set_list_to_list_excluding_items_preceding_match(
# void set_list_to_list_excluding_matches(
# void set_list_to_list_including_only_matches(
#FUXME: Order of function arguments is, arguably, somewhat ad hoc. Switch the
#source_list_name and glob arguments, perhaps?
# void remove_list_items_matching(
#   string source_list_name, string glob,
#   string target_list_name = "${source_list_name}")
#
# Copy all items of the passed source list *NOT* matching the passed glob
# into the passed target list (defaulting to the passed source list). If passed
# only two arguments, remove all matching source list items "in-place." This
# function implements the inverse of retain_list_items_matching().
#function set_list_to_list_without_items_matching() {
#function remove_list_items_matching() {
#   if is_args_2; then
#       list_name_source="${list_name_target}"
#       __glob__="${2}"
#   else
#       list_name_source="${2}"
#       __glob__="${3}"
#   fi
