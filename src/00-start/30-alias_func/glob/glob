#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *extended glob expressions* (i.e., `zsh`-specific string-matching
patterns roughly analogous to extended regular expressions).

== See Also ==

* Section ``FILENAME GENERATION'' of `man zshexpn`, documenting glob syntax.
/---

# Functions attributed as "<globbable>" must be declared *BEFORE* defining
# functions calling such functions. Since zeshy implements such attribute as
# aliases of the same names *AND* since zsh expands aliases at function
# definition rather than call time, such aliases should be declared *BEFORE*
# definitions expanding such aliases. While nonfatal, failure to do fails to
# disable filename globbing when calling such functions from other functions.

#FIXME: Insanity, but the good kind! Well, mostly. Turns out there's a flag to
#enable error-checking on parameter expansion globbing:
#
#X      With  this  flag,  parsing  errors occurring with the Q, e and # flags or the
#       pattern matching forms such as `${name#pattern}' are reported.   Without  the
#       flag, errors are silently ignored.
#
#Hence, whenever we perform such matching, use the "(X)" flag as well. (Perhaps
#confine such flag to only debug mode? Or does it not impact performance at all?
#I suspect not, in which case -- go flag crazy!)

# ....................{ GLOBALS                            }....................
#FIXME: Replace current magic strings with these everywhere.
declare_global_with_stdin string\
    ZESHY_GLOB_ENABLE_CAPTURING_UNGROUPED='(#m)' <<'/---'
Globbing flag enabling *ungrouped capturing* on successful matches with globs
containing such flag. Immediately after such matches, `zsh` will silently set
the following canonical scalar globals:

* ${MATCH}, a string global expanding to the currently matched substring.
* ${MBEGIN}, an integer global expanding to the 1-based index of the matched
  string at which such substring starts.
* ${MEND}, an integer global expanding to the 1-based index of the matched
  string at which such substring ends.
/---

declare_global_with_stdin string\
    ZESHY_GLOB_ENABLE_CAPTURING_GROUPED='(#b)' <<'/---'
Globbing flag capturing each subsequent parenthesised group into the
corresponding element of list global ${match}.

Globbing flag enabling *grouped capturing* on successful matches with globs
containing such flag. Immediately after such matches, `zsh` will silently set
the following canonical nonscalar globals:

* ${match}, a list global containing each match group captured within such
  substring (e.g., `${match[1]}`, the first match group).
* ${mbegin}, a list global containing each 1-based index of the matched string
  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
  at which the first match group starts).
* ${mend}, a list global containing each 1-based index of the matched string
  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
  at which the first match group ends).
/---

# ....................{ ENABLERS                           }....................
:func_ ':void :enable_glob_capturing_ungrouped(
    :string:string? glob_string_name)' :func{
    # Unconditionally prefix such glob by such globbing flag. (If such glob
    # already contains such flag, prefixing yet another does no harm.)
    :prefix_string "${1}" "${ZESHY_GLOB_ENABLE_CAPTURING_UNGROUPED}"
}:func <<'/---'
Modify the value (presumably, glob) of the passed string variable to enable
*ungrouped capturing* on successful string matches with such glob (i.e., to set
scalar globals ${MATCH}, ${MBEGIN}, and ${MEND} on such matches). Specifically,
this function prefixes such value by globbing flag `(#m)` if such value does
_not_ already contain such substring. See ${ZESHY_GLOB_ENABLE_CAPTURING_UNGROUPED} for
further details.
/---

#FIXME: Correct documentation.
:func_ ':void :enable_glob_capturing_grouped(
    :string:string glob_string_name)' :func{
    # Validate sanity.
    :string glob_name__egcg="${1}"

    # If such glob does *NOT* already contain the flag enabling group capturing,
    # prefix such glob with such flag. Such logic contrasts with that of
    # convert_string_to_glob_capturing_substrings(), which always prefixes its
    # glob with flag "(#m)". While the position of "(#m)" within a glob is
    # irrelevant, the position of "(#b)" within a glob is relevant and hence
    # must not be changed if already present.
    :is "${(P)glob_name__egcg}" == *"${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED}"* :si or
        :prefix_string "${glob_name__egcg}" "${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED}"

    # In either case, unconditionally enable ungrouped capturing.
    :enable_glob_capturing_ungrouped "${glob_name__egcg}"
}:func <<'/---'
Modify the value (presumably, glob) of the passed string variable to enable
both *grouped* and *ungrouped capturing* on successful string matches with such
glob (i.e., to set scalar globals ${MATCH}, ${MBEGIN}, and ${MEND} _and_
nonscalar globals ${match}, ${mbegin}, and ${mend} on such matches).
Specifically, this function prefixes such value by whichever of globbing flags
`(#m)` and `(#b)` such value does _not_ already contain. See
${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED} for further details.
/---

# ....................{ TESTERS                            }....................
:func_ '[status = :bool] :is_string_has_glob_syntax(:string text)'
:func{
    :is "${1}" == *['[]<>()|+*?#~^']* :si
}:func <<'/---'
Report success if the passed string contains at least one *glob-reserved
character* (i.e., character with syntactic meaning in glob expressions and hence
_not_ interpreted as the corresponding raw character unless explicitly escaped).
Notably, this includes most ASCII punctuation (e.g., `[`, `<`, `(`, `|`).
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to :is_string_contains_chars_glob(). "_has" is simply too
#ambiguously awkward of a noun for sensible nomenclature.

    # die_unless_arg 'Expected one string variable.'

# ....................{ CONVERTERS                         }....................
#FUXME: Command substitution is highly inefficient. Refactor to:
#     void set_string_to_glob_capturing_substrings(string string_name, string glob)
#FUXME: Actually, just modify such string to operate in-place on a passed
#string variable. Simple. Efficient. *sigh*
#FUXME: Actually, we've defined replacement functions :enable_glob_capturing_ungrouped()
#and so forth. Replace *ALL* calls to these functions with calls to those.

# declare_function_with_stdin <<'/---'
# <globbable> string convert_string_to_glob_capturing_substrings(string glob)
# 
# Convert the passed glob to capture matched substrings, if not already doing so.
# On each successful match, such glob sets the following canonical globals:
# 
# * ${MATCH}, a string global expanding to the currently matched substring.
# * ${MBEGIN}, an integer global expanding to the 1-based index of the matched
#   string at which such substring starts.
# * ${MEND}, an integer global expanding to the 1-based index of the matched
#   string at which such substring ends.
# 
# Specifically, this function prefixes the passed glob with globbing flag `(#m)`
# if such glob does not already contain such flag.
# /---
# function convert_string_to_glob_capturing_substrings() {
#     # If such glob already contains "(#m)", prefixing yet another does no harm.
#     die_unless_arg 'Expected one glob.'
#     :output_string "${ZESHY_GLOB_ENABLE_CAPTURING_UNGROUPED}${1}"
# }

#FUXME: Refactor as discussed above.
#FUXME: Actually, this function appears to be uselessly obsoleted by the
#considerably more powerful convert_string_to_glob_capturing_groups_and_substrings().
#Hence, shift this function's implementation there and excise this function.

# declare_function_with_stdin <<'/---'
# <globbable> string convert_string_to_glob_capturing_groups(string glob)
# 
# Convert the passed glob to capture match groups, if not already doing so. On
# each successful match, such glob sets the following canonical globals:
# 
# * ${match}, a list global containing each match group captured within such
#   substring (e.g., `${match[1]}`, the first match group).
# * ${mbegin}, a list global containing each 1-based index of the matched string
#   at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
#   at which the first match group starts).
# * ${mend}, a list global containing each 1-based index of the matched string
#   at which the corresponding match group ends (e.g., `${mend[1]}`, the index
#   at which the first match group ends).
# 
# Specifically, this function prefixes the passed glob with globbing flag `(#b)`
# if such glob does not already contain such flag.
# /---
# function convert_string_to_glob_capturing_groups() {
#     # Validate sanity.
#     die_unless_arg 'Expected one glob.'
#     :string glob="${1}"
# 
#     # If such glob does *NOT* already enable globbing flag "(#b)", prefix such
#     # glob with such flag. Such logic contrasts with that of
#     # convert_string_to_glob_capturing_substrings(), which always prefixes its
#     # glob with flag "(#m)". While the position of "(#m)" within a glob is
#     # irrelevant, the position of "(#b)" within a glob is relevant and hence
#     # must not be changed if already present.
#     if is "${glob}" != *"${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED}"* si {
#         :output_string   "${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED}${glob}"
#     # Else, do not.
#     } else {
#         :output_string "${glob}"
#     }
# }

#FUXME: Refactor as discussed above.
# declare_function_with_stdin <<'/---'
# <globbable> string convert_string_to_glob_capturing_groups_and_substrings(
#     string glob)
# 
# Convert the passed glob to capture match groups _and_ matched substrings, if not
# already doing so. On each successful match, such glob sets the following
# canonical globals:
# 
# * All list globals set by convert_string_to_glob_capturing_groups() (i.e.,
#   ${match}, ${mbegin}, and ${mend}). See such function for further details.
# * All string globals set by convert_string_to_glob_capturing_substrings() (i.e.,
#   ${MATCH}, ${MBEGIN}, and ${MEND}). See such function for further details.
# 
# Specifically, this function prefixes the passed glob with globbing flags
# `(#b)(#m)` if such glob does not already contain such flags. According to `zsh`
# documentation:
# 
# [quote, `man zshexpn`]
# ____________________________________________________________________
# Unlike backreferences _(i.e., match groups)_, there is no speed penalty for
# using match references _(i.e., matched substrings)_.
# ____________________________________________________________________
# 
# Hence, if capturing match groups, it costs us nothing and conceivably gains us
# something to also capture matched substrings.
# /---
# function convert_string_to_glob_capturing_groups_and_substrings() {
#     # Validate sanity.
#     die_unless_arg 'Expected one glob.'
#     convert_string_to_glob_capturing_groups "${ZESHY_GLOB_ENABLE_CAPTURING_UNGROUPED}${1}"
# }

# == Scalar Match Globals ==
# 
# Enabling such capturing instructs `zsh` to set the following scalar match
# globals on successful matches with such glob:
# 
# * ${MATCH}, a string global expanding to the currently matched substring.
# * ${MBEGIN}, an integer global expanding to the 1-based index of the matched
#   string at which such substring starts.
# * ${MEND}, an integer global expanding to the 1-based index of the matched
#   string at which such substring ends.

# into string global ${MATCH}.
# Convert the passed glob to capture matched substrings, if not already doing so.
# On each successful match, such glob sets the following canonical globals:
# 
# * ${MATCH}, a string global expanding to the currently matched substring.
# * ${MBEGIN}, an integer global expanding to the 1-based index of the matched
#   string at which such substring starts.
# * ${MEND}, an integer global expanding to the 1-based index of the matched
#   string at which such substring ends.
# 
# Specifically, this function prefixes the passed glob with globbing flag `(#m)`
# if such glob does not already contain such flag.

# For efficiency, inline the call to
    # convert_string_to_glob_capturing_substring().
