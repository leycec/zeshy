#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Core zeshy functions attributed with "<globbable>" should be declared *BEFORE*
# defining other zeshy functions calling such functions. Since zeshy implements
# such attribute as aliases of the same names *AND* since zsh expands aliases at
# function definition rather than call time, such aliases should be declared
# *BEFORE* definitions expanding such aliases. While nonfatal, failure to do
# fails to disable filename globbing when calling such functions from other
# zeshy functions.

#FIXME: Insanity, but the good kind! Well, mostly. Turns out there's a flag to
#enable error-checking on parameter expansion globbing:
#
#X      With  this  flag,  parsing  errors occurring with the Q, e and # flags or the
#       pattern matching forms such as `${name#pattern}' are reported.   Without  the
#       flag, errors are silently ignored.
#
#Hence, whenever we perform such matching, use the "(X)" flag as well. (Perhaps
#confine such flag to only debug mode? Or does it not impact performance at all?
#I suspect not, in which case -- go flag crazy!)

declare_parcel_as_script_with_stdin <<'/---'
Handle core glob functionality.

== See Also ==

* Section ``FILENAME GENERATION'' of `man zshexpn`, documenting glob syntax.
/---

# ....................{ GLOBALS                            }....................
#FIXME: Replace current magic strings with these everywhere.
declare_global_with_stdin string ZESHY_GLOB_CAPTURE_MATCH='(#m)' <<'/---'
Globbing flag capturing the current match into string global ${MATCH}.
/---

declare_global_with_stdin string ZESHY_GLOB_CAPTURE_GROUPS='(#b)' <<'/---'
Globbing flag capturing each subsequent parenthesised group into the
corresponding element of list global ${match}.
/---

# ....................{ ENABLERS                           }....................
declare_function_with_stdin <<'/---'
<globbable> void :enable_glob_capturing(string string_name)

Modify the value of the passed string variable (presumably a glob) to enable
*match capturing* on successful matches with such glob (i.e., to set the scalar
globals ${MATCH}, ${MBEGIN}, and ${MEND} on such matches). Specifically, such
value will be prefixed by globbing flag `(#m)` if such value does not already
contain such substring.

== Scalar Match Globals ==

Enabling match capturing instructs `zsh` to set the following scalar match
globals on successful matches with such glob:

* ${MATCH}, a string global expanding to the currently matched substring.
* ${MBEGIN}, an integer global expanding to the 1-based index of the matched
  string at which such substring starts.
* ${MEND}, an integer global expanding to the 1-based index of the matched
  string at which such substring ends.
/---
function :enable_glob_capturing() {
    # Unconditionally prefix such glob by such globbing flag. (If such glob
    # already contains such flag, prefixing yet another does no harm.)
    die_unless_arg 'Expected one string variable.'
    :prefix_string "${1}" "${ZESHY_GLOB_CAPTURE_MATCH}"
}

# ....................{ CONVERTERS                         }....................
#FIXME: Command substitution is highly inefficient. Refactor to:
#     void set_string_to_glob_capturing_substrings(string string_name, string glob)
#FIXME: Actually, just modify such string to operate in-place on a passed
#string variable. Simple. Efficient. *sigh*
#FIXME: Actually, we've defined replacement functions :enable_glob_capturing()
#and so forth. Replace *ALL* calls to these functions with calls to those.

declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_substrings(string glob)

Convert the passed glob to capture matched substrings, if not already doing so.
On each successful match, such glob sets the following canonical globals:

* ${MATCH}, a string global expanding to the currently matched substring.
* ${MBEGIN}, an integer global expanding to the 1-based index of the matched
  string at which such substring starts.
* ${MEND}, an integer global expanding to the 1-based index of the matched
  string at which such substring ends.

Specifically, this function prefixes the passed glob with globbing flag `(#m)`
if such glob does not already contain such flag.
/---
function convert_string_to_glob_capturing_substrings() {
    # If such glob already contains "(#m)", prefixing yet another does no harm.
    die_unless_arg 'Expected one glob.'
    output_string "${ZESHY_GLOB_CAPTURE_MATCH}${1}"
}

#FIXME: Refactor as discussed above.
declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_groups(string glob)

Convert the passed glob to capture match groups, if not already doing so. On
each successful match, such glob sets the following canonical globals:

* ${match}, a list global containing each match group captured within such
  substring (e.g., `${match[1]}`, the first match group).
* ${mbegin}, a list global containing each 1-based index of the matched string
  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
  at which the first match group starts).
* ${mend}, a list global containing each 1-based index of the matched string
  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
  at which the first match group ends).

Specifically, this function prefixes the passed glob with globbing flag `(#b)`
if such glob does not already contain such flag.
/---
function convert_string_to_glob_capturing_groups() {
    # Validate sanity.
    die_unless_arg 'Expected one glob.'
    :string glob="${1}"

    # If such glob does *NOT* already enable globbing flag "(#b)", prefix such
    # glob with such flag. Such logic contrasts with that of
    # convert_string_to_glob_capturing_substrings(), which always prefixes its
    # glob with flag "(#m)". While the position of "(#m)" within a glob is
    # irrelevant, the position of "(#b)" within a glob is relevant and hence
    # must not be changed if already present.
    if is "${glob}" != *"${ZESHY_GLOB_CAPTURE_GROUPS}"* si {
        output_string   "${ZESHY_GLOB_CAPTURE_GROUPS}${glob}"
    # Else, do not.
    } else {
        output_string "${glob}"
    }
}

#FIXME: Refactor as discussed above.
declare_function_with_stdin <<'/---'
<globbable> string convert_string_to_glob_capturing_groups_and_substrings(
    string glob)

Convert the passed glob to capture match groups _and_ matched substrings, if not
already doing so. On each successful match, such glob sets the following
canonical globals:

* All list globals set by convert_string_to_glob_capturing_groups() (i.e.,
  ${match}, ${mbegin}, and ${mend}). See such function for further details.
* All string globals set by convert_string_to_glob_capturing_substrings() (i.e.,
  ${MATCH}, ${MBEGIN}, and ${MEND}). See such function for further details.

Specifically, this function prefixes the passed glob with globbing flags
`(#b)(#m)` if such glob does not already contain such flags. According to `zsh`
documentation:

[quote, `man zshexpn`]
____________________________________________________________________
Unlike backreferences _(i.e., match groups)_, there is no speed penalty for
using match references _(i.e., matched substrings)_.
____________________________________________________________________

Hence, if capturing match groups, it costs us nothing and conceivably gains us
something to also capture matched substrings.
/---
function convert_string_to_glob_capturing_groups_and_substrings() {
    # Validate sanity.
    die_unless_arg 'Expected one glob.'
    convert_string_to_glob_capturing_groups "${ZESHY_GLOB_CAPTURE_MATCH}${1}"
}

# --------------------( WASTELANDS                         )--------------------
# Convert the passed glob to capture matched substrings, if not already doing so.
# On each successful match, such glob sets the following canonical globals:
# 
# * ${MATCH}, a string global expanding to the currently matched substring.
# * ${MBEGIN}, an integer global expanding to the 1-based index of the matched
#   string at which such substring starts.
# * ${MEND}, an integer global expanding to the 1-based index of the matched
#   string at which such substring ends.
# 
# Specifically, this function prefixes the passed glob with globbing flag `(#m)`
# if such glob does not already contain such flag.

# For efficiency, inline the call to
    # convert_string_to_glob_capturing_substring().
