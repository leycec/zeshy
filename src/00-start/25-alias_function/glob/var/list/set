#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *globbable list setters* (i.e., functions setting lists and list items by
matching such items against glob expressions).
/---

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_matching_glob(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all items in the passed source list matching the
passed glob: e.g.,

.set_list_to_list_items_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_linearity on_cyclicity; on_cyclicity=(
...    "Catch! calls the Once-ler."
...    "He lets something fall."
...    "It's a Truffula Seed."
...    "It's the last one of all!"
...    "You're in charge of the last of the Truffula Seeds."
...    "And Truffula Trees are what everyone needs."
...    "Plant a new Truffula. Treat it with care."
...    "Give it clean water. And feed it fresh air."
...    "Grow a forest. Protect it from axes that hack."
...    "Then the Lorax"
...    "and all of his friends"
...    "may come back." )
>>> set_list_to_list_items_matching_glob on_linearity on_cyclicity *'last*'
>>> print_list on_linearity
1: It's the last one of all!
2: You're in charge of the last of the Truffula Seeds.
------------------------------------------
==========================================
/---
function set_list_to_list_items_matching_glob() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one target list name, one source list name, and one glob.'
    :string\
        list_name_target__sltlimg="${1}"\
        list_name_source__sltlimg="${2}"\
        glob__sltlimg="${3}"
    die_unless_lists\
        "${list_name_target__sltlimg}"\
        "${list_name_source__sltlimg}"

    # Remove non-matching items. Dismantled, this is:
    #
    # * "(M)" and ":#", removing all such source list items not matching...
    # * "${~glob__sltlimg}", such glob as a glob rather than literal.
    eval ${list_name_target__sltlimg}'=(
        "${(M)'${list_name_source__sltlimg}'[@]:#${~glob__sltlimg}}" )'
}

declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_not_matching_glob(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all items in the passed source list _not_ matching
the passed glob: e.g.,

.set_list_to_list_items_not_matching_glob()
==========================================
[source]
------------------------------------------
>>> :list on_profit on_medicine; on_medicine=(
...    "When at last we are sure"
...    "You've been properly pilled,"
...    "Then a few paper forms"
...    "Must be properly filled"
...    "So that you and your heirs"
...    "May be properly billed." )
>>> set_list_to_list_items_not_matching_glob on_profit on_medicine *'o'*
>>> print_list on_profit
1: When at last we are sure
------------------------------------------
==========================================
/---
function set_list_to_list_items_not_matching_glob() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one target list name, one source list name, and one glob.'
    :string\
        list_name_target__sltling="${1}"\
        list_name_source__sltling="${2}"\
        glob__sltling="${3}"
    die_unless_lists\
        "${list_name_target__sltling}"\
        "${list_name_source__sltling}"

    # Remove non-matching items. Dismantled, this is:
    #
    # * ":#", removing all such source list items matching...
    # * "${~glob__sltling}", such glob as a glob rather than literal.
    eval ${list_name_target__sltling}'=(
        "${'${list_name_source__sltling}'[@]:#${~glob__sltling}}" )'
}

# ....................{ SETTERS ~ range                    }....................
declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_after_item_matching_glob(
    string target_list_name, string source_list_name, string glob)

Set the passed target list to all items of the passed source list after and
including the first item matching the passed glob or throw an exception if no
such item matches.
/---
function set_list_to_list_items_after_item_matching_glob() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one target list name, one source list name, and one glob.'
    :string\
        list_name_target__sltliaimg="${1}"\
        list_name_source__sltliaimg="${2}"\
        glob__sltliaimg="${3}"
    :int index__sltliaimg
    die_unless_lists\
        "${list_name_target__sltliaimg}"\
        "${list_name_source__sltliaimg}"

    # Get the first matching index.
    index__sltliaimg="$(get_list_index_first_matching_glob\
        "${list_name_source__sltliaimg}" "${glob__sltliaimg}")"

    # Set such list.
    eval ${list_name_target}'=(
        "${'${list_name_source__sltliaimg}'[${index__sltliaimg},]}" )'
}

declare_function_with_stdin <<'/---'
<globbable> void set_list_to_list_items_between_items_matching_globs(
    string target_list_name,
    string source_list_name,
    string start_glob,
    string end_glob)

Set the passed target list to all items of the passed source list that:

* Follow the first item matching the first passed glob, including such item. If
  no such item matches, throw an exception.
* Precede the next item matching the second passed glob, including such item. If
  no such item matches, include all remaining items, thus mimicking
  set_list_to_list_items_after_item_matching_glob().
/---
function set_list_to_list_items_between_items_matching_globs() {
    # Validate sanity.
    die_unless_args_4\
        'Expected one target list name, one source list name, one start glob, and one end glob.'
    :string\
        list_name_target__sltlibimg="${1}"\
        list_name_source__sltlibimg="${2}"\
        glob_start__sltlibimg="${3}"\
        glob_end__sltlibimg="${4}"
    :int index_start__sltlibimg index_next__sltlibimg
    die_unless_lists\
        "${list_name_target__sltlibimg}"\
        "${list_name_source__sltlibimg}"

    # Get the first matching index.
    index_start__sltlibimg="$(get_list_index_first_matching_glob\
        "${list_name_source__sltlibimg}" "${glob_start__sltlibimg}")"

    # Get the next matching index if found.
    if { index_end__sltlibimg="$(get_list_index_first_matching_glob_after_index_if_found\
        "${list_name_source__sltlibimg}"\
        "${glob_start__sltlibimg}"\
        "${index_start__sltlibimg}")" } {
    # Else, default to the last index.
    } else {
        index_end__sltlibimg="$(get_list_size "${list_name_source__sltlibimg}")"
    }

    # Set such list.
    eval ${list_name_target__sltlibimg}'=(
        "${'${list_name_source__sltlibimg}'[${index_start__sltlibimg},${index_end__sltlibimg}]}" )'
}

# ....................{ SETTERS ~ index                    }....................
#FIXME: Add examples.
declare_function_with_stdin <<'/---'
<globbable> void set_integer_to_list_index_first_matching_glob(
    string integer_name, string list_name, string glob)

Set the passed integer to the 1-based index of the first argument the caller
passed matching the passed glob or throw an exception if no such argument
matches. See set_integer_to_list_index_first_matching_glob_if_found() for
further details.
------------------------------------------
==========================================
/---
function set_integer_to_list_index_first_matching_glob() {
    set_integer_to_list_index_first_matching_glob_if_found "${@}" or
        die_unless_list_item_matches_glob "${@[2,3]}"
}

declare_function_with_stdin <<'/---'
<globbable> [status: boolean]
    set_integer_to_list_index_first_matching_glob_if_found(
        string integer_name, string list_name, string glob)

Set the passed integer to the 1-based index of the first argument the caller
passed matching the passed glob or report failure if no such argument
matches.
------------------------------------------
==========================================
/---
function set_integer_to_list_index_first_matching_glob_if_found() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one integer name, one list name, and one glob.'
    :string\
        integer_name__sitlifmgif="${1}"\
        list_name__sitlifmgif="${2}"\
        glob__sitlifmgif="${3}"
    :int list_index__sitlifmgif
    die_unless_list "${list_name__sitlifmgif}"

    # 1-based index of the first matching item. Dismantled, this is:
    #
    # * '@P', expanding to the passed list.
    # * 'i', expanding to the index of the matching first item.
    # * "${~glob__sitlifmgif}", treating such glob as a glob rather than a raw
    #   string literal.
    list_index__sitlifmgif="${${(@P)list_name__sitlifmgif}[(i)${~glob__sitlifmgif}]}"

    #FIXME: No! Nonsense. Inline nothing. Actually call such function.

    # Set such index if found or report failure. For efficiency, inline such
    # test. See get_list_size() for further details.
    (( list_index__sitlifmgif <= ${#${(@P)list_name__sitlifmgif}} )) and
        :set_int_to_int\
            "${integer_name__sitlifmgif}" "${list_index__sitlifmgif}"
}

# --------------------( WASTELANDS                         )--------------------
    # Set such index if found or throw an exception.
