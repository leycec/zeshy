#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *core function definers* (i.e., functions dynamically defining other
functions).
/---

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void define_function(string function_name, string function_body)

Define the passed function as the passed *function body* (i.e., such function's
implementation excluding `function ${function_name} () {` prefix and `}`
suffix). If such function has already been declared, an exception is thrown:
e.g.,

.define_function()
==========================================
[source]
------------------------------------------
>>> define_function "moral = choice" 'output_string\
...    "With the myth of the State out of the way, the real mutuality and
...     reciprocity of society and individual became clear. Sacrifice might be
...     demanded of the individual, but never compromise: for though only the
...     society could give security and stability, only the individual, the
...     person, had the power of moral choiceâ€”the power of change, the essential
...     function of life. The Odonian society was conceived as a permanent
...     revolution, and revolution begins in the thinking mind."
>>> get_string_line $("moral = choice") 1
With the myth of the State out of the way, the real mutuality and
------------------------------------------
==========================================

== Motivation ==

This function is principally useful for defining functions with *dynamic
implementations* (i.e., function bodies dynamically synthesized at runtime).

Since `zsh` allows functions with names containing shell-reserved characters to
be defined by double-quoting such names (e.g.,
`function "Fisheye Placebo"() { :output_string "You are free." }`), this
function does _not_ need to be called to define functions with such names.
Interestingly, this differs from the case of defining aliases with such names;
due to undocumented subtleties, :define_alias() should always be called to
define such aliases.
/---
function define_function() {
    # Validate sanity.
    die_unless_args_2 'Expected one function name and one function body.'
    :string function_name__df="${1}"

    #FIXME: Not fond of this approach. Just perform the following equivalent,
    #simpler, more efficient test:
    #
    #    if (( ${+functions[${function_name__df}]} )) {
    #
    #Do *NOT* adjust is_function() accordingly. Such function accepts multiple
    #arguments, which the above approach does not accomodate. (Note this.)

    # If such function already exists, throw an exception. See is_function()
    # for further details.
    if { { typeset -f -- "${function_name__df}" } silent: } {
        die "function ${function_name__df}() already exists:"$'\n'"$(which -- "${function_name__df}")"
    }

    # Declare such function.
    redefine_function "${@}"
}

declare_function_with_stdin <<'/---'
void redefine_function(string function_name, string function_body)

(Re)define the passed function as the passed function body, regardless of
whether such function has been previously defined. See define_function() for
further details: e.g.,

.redefine_function()
==========================================
[source]
------------------------------------------
>>> redefine_function "The Age of Decreasing Numbers" 'print_string\
...    "Civilization is a subset of nature even if we're not aware of it, and
...     the dark side of our recent increase was a decrease in topsoil and
...     forests and fossil fuels and the Earth's capacity to absorb industrial
...     waste without catastrophic change. Now these things have decreased so
...     far that our habit of increase can no longer feed itself."'
>>> get_string_line $("The Age of Decreasing Numbers") 1
Civilization is a subset of nature even if we're not aware of it, and
>>> redefine_function "The Age of Decreasing Numbers" 'print_string\
...    "With the housing crash, the falling dollar, and the decline in middle
...     class income, we're already tasting the coming age of numbers getting
...     smaller. Next: the stock market, easy credit, the GNP, energy
...     production, energy consumption, and human population."
>>> get_string_line $("The Age of Decreasing Numbers") 1
With the housing crash, the falling dollar, and the decline in middle
------------------------------------------
==========================================
/---
function redefine_function() {
    # Validate sanity.
    die_unless_args_2 'Expected one function name and one function body.'
    :string function_name__rf="${1}" function_body__rf="${2}"
    is -n "${function_name__rf}" si or die 'Expected nonempty function name.'
#   :output_line_if_debugging "zeshy: defining ${function_name__rf}()..."

    #FIXME: Erroneous, since such function name could contain double quotes.
    #Given map global ${functions}, however, there's really no need to go
    #through such convolutions. As with define_alias(), all we have to do is:
    #
    #    functions[${function_name__rf}]="${function_body__rf}"
    #
    #This eliminates both this *AND* the inefficient (and dangerous) eval()
    #below. Before implementing it, however, just make sure that such
    #assignment actually reports failure status on attempting to define
    #syntactically invalid function bodies. (Such issue doesn't arise with
    #aliases, as *ALL* alias bodies are syntactically valid until expanded, at
    #which point whether they are valid or not depends on surrounding code.)
    #
    #If it doesn't -- and it might not -- we're afraid the current
    #implementation must stay.
    #FIXME: Interesting! In zsh, scalar assignments *ALWAYS* succeed: e.g.,
    #
    #    >>> functions[yim]='{' and print ok
    #    zsh: parse error near `{'
    #    zsh: invalid function definition
    #    ok
    #
    #We've verified zsh to print such error to standard error, as desired. So,
    #while we can't test return status, we *CAN* simply perform such assignment
    #in a subshell... Ugh. That's even more inefficient than the eval()-based
    #approach below. Ah-ha! We know how to do this. Get ready:
    #
    #    #FIXME: Fairly sure this is how we unset a key, yes? Test on a simple
    #    #map at the CLI.
    #
    #    # First, undefine such function. We're redefining it immediately
    #    # afterwards, so what does this gain us? Simple: if such redefinition
    #    # fails, our having undefined such function beforehand ensures that we
    #    # can efficiently test whether such redefinition succeeded by testing
    #    # whether such function exists. Convolute? You bet. Efficient? You bet.
    #    unset functions[${function_name__rf}]
    #
    #    # Attempt to define such function, squelching *ANY* errors if printed.
    #    # (Yes, this works. I've tried it.)
    #    { functions[${function_name__rf}]="${function_body__rf}" } silent_stderr:
    #
    #    # If such function was *NOT* defined, such function body is
    #    # syntactically invalid.
    #    (( ${+functions[${function_name__rf}]} )) or {
    #        # Capture such output, ignoring the expected failure.
    #        :string function_error__rf; function_error__rf="$({
    #            functions[${function_name__rf}]="${function_body__rf}"
    #        } to_stdout:)"
    #
    #        ...
    #    }
    #
    #Simpler, more efficient, and less error prone than the current approach.
    #This means success for all!

    # Function to be defined. For obscure error handling reasons, the eval()
    # call below is repeated twice. While localizing the function definition as
    # a variable is hardly essential, it does streamline such calls below.
    :string function__rf='function "'${function_name__rf}'" () {
    '${function_body__rf}'
}'

    # Temporarily enable shell option "EVAL_LINENO". If such eval() call fails
    # with a syntax error, enabling this option ensures the line number zsh
    # embeds in the error will be relative to such function body rather than to
    # the current function (i.e., redefine_error()).
    :enable_option_local eval_lineno

    # Declare such function. To prevent errors if such function name contains
    # double quotes, avoid directly interpolating such function name.
    #
    # If such declaration fails, zsh outputs an error message to standard error
    # and reports failure, inducing zeshy to throw an exception resembling
    # "(eval):2: parse error near `]]'". For readability, capture and convert
    # such output into a human-readable exception message.
    { eval "${function__rf}" } silent_stderr: or {
        # Capture such output, ignoring the expected failure.
        :string function_error__rf; function_error__rf="$({
            eval "${function__rf}"
        } to_stdout: or ignore_failure)"

#       print "error: ${function_error__rf}"
        # If such error message is in canonical zsh format (e.g.,
        # "(eval):244: parse error near `()'"), convert such message
        # to human-readable form. In particular, append the actual line of code
        # in such function body inducing such error. Dismantled, this is:
        #
        # * "(#b)", enabling match group capturing.
        # * "(<->##)", matching such line as one or more digits into
        #   ${match[1]}. See is_integer() for further details.
        # * "(*)", matching the actual error message into ${match[2]}.
        if [[ "${function_error__rf}" == (#b)'(eval):'(<->##)': '(*) ]] {
            :string parse_error__rf
            :int line_number__rf line_number_start__rf line_number_end__rf
            :list function_body_lines__rf

            # Parse error emitted by zsh, stripped of delimiting whitespace.
            parse_error__rf="${${match[2]##[[:space:]]##}%%[[:space:]]##}"

            # Capitalize the first character of such error. (Unfortunately,
            # parameter expansion flag "(C)" capitalizes the first character of
            # all words of such parameter.)
            parse_error__rf[1]="${(C)parse_error__rf[1]}"

            # Line number of such error. Such number is relative to the
            # function definition rather than function body and hence is one
            # larger than it should be. Amend this.
            line_number__rf=$(( match[1] - 1 ))

            # Line number of the second lines preceding and succeeding such
            # error, for textual context.
            line_number_start__rf=$(( line_number__rf - 2 ))
            line_number_end__rf=$((   line_number__rf + 2 ))

            # List of function body lines, split on newline. See
            # set_list_to_string_lines() for further details.
            function_body_lines__rf=( ${(f)function_body__rf} )

            # Constrain such numbers to [1, ${max_line_number}], where
            # ${max_line_number} is the number of lines in such function body.
            if (( line_number_start__rf < 1 )) {
                  line_number_start__rf=1
            }
            if (( line_number_end__rf > ${#function_body_lines__rf} )) {
                  line_number_end__rf=${#function_body_lines__rf}
            }

            # String of relative function body lines, numbered for convenience.
            :string function_body_context__rf

            #FIXME: Hardly an ideal implementation. Ideally, we should implement
            #a function leveraging color styles printing such textual context
            #with decent aesthetics. To do so, we'll need test here whether such
            #function exists; if it does, call it, passing such call
            #"${function_body__rf}" and the desired function line; else, defer
            #to the default implementation below. (Actually, don't we have an
            #existing function for numbering arbitrary code lines? I recall such
            #function requiring a bit of touch-up, as well...)

            # Append each such line prefixed by its line number to such string.
            :int    i__rf=${line_number_start__rf}
            for ((; i__rf <= ${line_number_end__rf}; i__rf++ )) {
                function_body_context__rf+=$'\n'" [${i__rf}]  ${function_body_lines__rf[${i__rf}]}"
            }

            # Set such error message.
            function_error__rf="${parse_error__rf} on line ${line_number__rf} of function ${function_name__rf}():"$'\n'${function_body_context__rf}
        }

        # Throw such exception.
        die "${function_error__rf}"
    }
#    print -r -- "function \"${function_name__rf}\" () {
#    ${function_body__rf}
#}"

    #FIXME: Again, simply test (( ${+functions[${function_name__rf}]} )).

    # If such function was *NOT* successfully defined *AND* no errors or
    # warnings were printed, throw an exception. While this should never happen,
    # of course, it occasionally does (much to our horrified chagrin).
    #
    # This is purely a precaution to avoid silent regressions.
    typeset -f -- "${function_name__rf}" &>/dev/null or
        die "Function ${function_name__rf}() not definable with body:"$'\n'"${function_body__rf}"
}

#FIXME: In lieu of unit tests...
# function siml() {
#    # This should fail with a parse error.
#    define_function yu '()'
# }

# --------------------( WASTELANDS                         )--------------------
# # If compiling a debug build of zeshy, V
# if { :is_debugging } {
# } else {
#     function :define_function_to_report_success() {
#         die_unless_arg 'Expected one function name.'
#         define_function "${1}" 'report_success'
#     }
#     function :define_function_to_report_failure() {
#         die_unless_arg 'Expected one function name.'
#         define_function "${1}" 'report_failure'
#     }
# }
        # If such command (or commands) is pathable, define such function to run
        # such command and cease iteration.
#       if (( is_pathable__dfip )) {

        # By default, the current command is assumed to *NOT* be pathable unless
        # explicitly proven otherwise.
        # is_pathable__dfip=0

            # { eval 'if '${command_name__dfip}' {
            #     is_pathable__dfip=1
            # }' } silent_stderr: or {

            #FUXME: While safe, there exists no guarantee such conditional will
            #actually interpret as valid zsh. An exception should be thrown when
            #this is not the case. Unfortunately, doing so is nontrivial (and
            #requires subshells); basically:

            #FUXME: Actually, it'd be simpler to just quote-protect each command
            #name to prevent such interpretation. Do so!
# >>> :string alternative
# >>> for     alternative ("${ZESHY_ALTERNATIVES[@]}") {
# ...     :undefine_map_key commands ${alternative}
# ... }

# ==  ==
# 
# This function defines 
# Specifically, synthesize such function as the following code (in order):
# 
# . The passed *function body prefix* (i.e., code to be unconditionally prepended
#   to the command-specific function body).
# . The passed *function body* (i.e., code comprising ) corresponding
# . The passed *function body suffix* (i.e., code to be unconditionally appended
#   to the selected function body).

    # All standard output and error printed by the latter of the two eval()
    # calls below.
    # :string 

# Unlike aliases, this functions do _not_ `zsh` already permits functions with names containing shell-
# reserved characters to be defined by double-quoting such names (as in the above
# example). Hence, 

    #FUXME: Uhm; this still shouldn't work. Declaring such function in any pipe
    #subcommand other than the last does so only in the corresponding subshell.
    #Instead, we'll need to use the coprocess approach. Unfortunately, we're
    #getting into a bit of a chicken-and-egg issue here. We *DEFINITELY* don't
    #want to inline our coprocess implementation here; it's simply too delicate.
    #Instead, we'll need to leave this function *UNDEFINED* until after defining
    #such coprocess functionality -- which, I believe, is all segregated to
    #@{15-alias}. That being the case, this function should be shifted to
    #@{20-function} and reimplemented in terms of coprocesses.
    #FUXME: Ah. Wait. Declaring such function in a subshell should be reasonably
    #efficient. Certainly, since coprocesses also require subshells and impose
    #even *MORE* inefficiencies, declaring such function in a subshell will
    #certainly be no worse. So, simply declare such function in a subshell
    #*FIRST* to ascertain whether or not such definition is erroneous. If so,
    #propagate such error as an exception; else, declare such function in the
    #current shell. Reasonably simple, eh?

    # If such function body is syntactically invalid, throw an exception.
    # Technically, shifting this conditional into the prior block would slightly
    # improve efficiency -- while indenting this conditional two tabs to the
    # right and hence rendering it unreadable. (You decide.)
    # if [[ -n "${function_error__rf}" ]] {

    # Declare such function. To prevent errors if such function name contains
    # double quotes, avoid directly interpolating such function name.
    #
    # If such function body is syntactically invalid, zsh prints a nonfatal
    # warning to standard error and returns successfully; else, neither standard
    # output or error are printed to. Deciding whether an error occurred thus
    # requires capturing standard output and error to a string local and testing
    # whether such local is nonempty or not. Since capturing such output with a
    # conventional command substitution declares such function only in a
    # subshell rather than the current shell (e.g.,
    # function_error="$(eval "function ..." 2>&1)"), capture such output with a
    # pipe in the current shell instead.
    #
    # Ideally, that would simply suffice: pipe such output into the necessary
    # read() command and test the result. Naturally, it doesn't. While it
    # remains unclear why eval() behaves in this manner, one thing is clear: if
    # eval() succeeds in defining such function *AND* is piped into *ANYTHING*,
    # eval() silently fails and undefines such function. While this is fairly
    # crazy, the solution is fairly simple: only pipe eval() output if a prior
    # eval() call passed the same arguments returns non-zero exit status. This
    # is the most obscure code in any language I've ever had the shame to admit
    # having contributed. It's hard to be proud of something like this.
    # eval "${function__rf}" || {
    #     # Dismantled, this is:
    #     #
    #     # * "|&", piping both standard output and error from such eval() call.
    #     # * "IFS='' read -r -d ''", capturing all piped standard output and
    #     #   error to ${function_error}.
    #     eval "${function__rf}" |& IFS='' read -r -d '' function_error__rf
    # }

#FUXME: Arguably complex enough to warrant shifting to a new parcel
#@{20-function/define}.
#FUXME: Right. We *HAVE* to do so anyway, to ensure access to coprocess
#functionality. See below. For now, the following two functions remain *BROKEN*.
#FUXME: O.K.; while we *REALLY* don't want to adopt a coprocess approach,
#there's no compelling reason to leave these here. Shift into new parcel
#@{00-core/declare/function}. Then also define our new
#:declare_function_if_pathable() function in the same parcel.
