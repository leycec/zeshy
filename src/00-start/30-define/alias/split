#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *split alias definers* (i.e., functions dynamically defining alias-like
runnables split into two or three low-level aliases, the former typically
accepting one or more passed arguments operated on by the latter).
/---

# ....................{ DEFINERS                           }....................
#FIXME: Document me. (Wow! This is well and truly insane. But it has the
#benefit of actually working, unlike effectively *EVERYTHING* else attempted.)
#FIXME: Note the prefixing newline to separate such evaluation from the last
#argument passed to such alias, as required.
#FIXME: Actually, this is fairly wierd. For one, it's a bit unsafe. We need to
#throw exceptions if such alias doesn't exist. For another, couldn't we just
#eval() the contents of a local string variable? Hmm; perhaps not, given the
#perennial quoting issues surrounding eval(). If that could be made to work
#reliably, however, that would probably be preferable. (Why? Consider what would
#happen if such function attempted to dynamically define another function after
#calling a split alias. Since ::expand_alias_split() would have been defined...
#Actually, we see no issue there. Perhaps it's all sweet?)
alias_global '}:'='
    eval :::expand_alias_split'

# ....................{ DEFINERS                           }....................
#FIXME: Improve documentation!
declare_function_with_stdin <<'/---'
void :define_alias_split(
    string alias_name,
    string args_list_name,
    string alias_expansion)

Define the passed *split alias* (i.e., alias-like runnable split into two or
three low-level aliases, the former accepting one or more passed arguments
operated on by the latter) to expand to the passed code with the passed list
locally defined to all arguments passed to such alias. This function implicitly
suffixes such alias name by `:{` _and_ requires the last argument all callers
pass to such alias be `}:`. If such alias has already been declared, an
exception is thrown.
/---
function :define_alias_split() {
    # Validate sanity.
    die_unless_args_3 'Expected one alias name, one argument list name, and one alias expansion.'
    :string alias_name="${1}" list_name_args="${2}" alias_expansion="${3}"
    is -n "${alias_name}" si or die\
        'Expected nonempty split alias name.'
    is -n "${alias_expansion}" si or die\
        'Expected nonempty split alias '${alias_name}'() expansion.'
    is "${list_name_args}" == ${~ZESHY_VAR_NAME_GLOB} si or die\
        'Argument list name "'${list_name_args}'" invalid.'

    # Suffix such alias name by ":{".
    alias_name+=':{'

    #FIXME: Actually, it's unlikely that the current definition of "}:" *DOES*
    #guarantee its undefinition in the event of an exception. Why? Because such
    #exception will have been undefined prior to the expansion of "}:"!  If
    #this is the case, we'll probably need to implicitly undefine "}:" in the
    #low-level exception handler in @{main}. (We'll also want to reduce the
    #start of the definition of "}:" to merely:
    #
    #    alias_global ''}:''=''
    #        undefine_alias "}:"
    #        '${alias_expansion}'

    # Escape all single quotes in such expansion, which we interpolate in a
    # single-quoted manner into the temporary definition of "}:" below.
    alias_expansion="${alias_expansion//'/''}"  # ...to stifle vim errors: '"

    #FIXME: Update commentary.

    # Define such alias to temporarily define simple alias "}:" to:
    #
    # * Undefine itself in an "always ~{...}~" block, guaranteeing "}:" to be
    #   undefined even in the event of an exception being thrown prior to the
    #   expansion of "}:".
    # * Set such list to all arguments passed to such alias.
    define_alias "${alias_name}" '
        alias '':::expand_alias_split''=''
            unalias ":::expand_alias_split"
            '${alias_expansion}'''

        :list '${list_name_args}'
        :set_list_to_strings '${list_name_args}
}

declare_function_with_stdin <<'/---'
void :undefine_alias_split(string alias_name1, ...)

Undefine all passed split aliases. See :define_alias_split() for further
details.
/---
function :undefine_alias_split() {
    # Since split aliases are implemented as simple aliases with names suffixed
    # by ":{", undefine such aliases accordingly.
    die_unless_args 'Expected one or more split alias names.'
    undefine_alias_nonsuffix ${^@}':{'
}

#FIXME: In lieu of unit tests...
function lile() {
    # Define such alias to locally define all passed arguments as integers
    # initialized to 42. (Undefine such alias if already defined.)
    { :undefine_alias_split sese } silent_stderr: or ignore_failure
    :define_alias_split sese args__s '
    die_unless_list_nonempty args__s\
        "Expected one or more integer variable names."
    print_list args__s

    :string arg__s
    for     arg__s ("${args__s[@]}") {
        :die_unless_var_name "${arg__s}"
        :int "${arg__s}"=42
    }'

    # Dynamically define a function expanding such alias *AFTER*
    # dynamically defining such alias above.
    redefine_function stile '
        # Expand the previously defined alias.
        sese:{ humdo lumro stimly }:

        # Ensure such variables were properly defined.
        :print_var humdo lumro stimly'

    # Call such function.
    stile
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Agh! A bigger problem looms: the passed alias expansion
    #${alias_expansion} is interpolated into a string in such a manner that
    #single quotes (and *ONLY* single quotes, yes?) in such string must be
    #escaped. We think, anyway. Examine further.

        # alias_global ''}:''=''
        #     } always ~{
        #         undefine_alias "}:"
        #     }~

        #     '${alias_expansion}'''

        # :try {
        #     :list '${list_name_args}'
        #     :set_list_to_strings '${list_name_args}

    # string alias_name,
    # string alias_expansion,
    # string local_scalar_var_name_1, ...)
