#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *split alias definers* (i.e., functions dynamically defining alias-like
runnables split into two or three low-level aliases, the former typically
accepting one or more passed arguments operated on by the latter).
/---

#FIXME: Switch to an alternative syntactic style: e.g.,
#
#* ":sese::: humdo lumro stimly :::". (This one, we should think. The ":::"
#  maintains conformance with our syntactic namespace as well as aesthetically
#  appearing to be a horizontal barrier and hence delimiter.)
#* ":sese:: humdo lumro stimly ::". (Or perhaps this one? Clearly, either "::"
#  or ":::" achieve the desired effect. Since all other such global aliases are
#  exactly two characters *AND* since ":::" renders the resulting command
#  somewhat long, "::" might be the more desirable choice here.)
#* ":sese... humdo lumro stimly ...". (Aside from the fact that "..." is a
#  common English grammatical unit and hence intrinsically fails as a global
#  alias, "..." does *NOT* appear to be a horizontal barrier.)
#* ":sese~{ humdo lumro stimly }~". (No; avoid use of "{" in such delimiter,
#  which would imply the enclosed shell words to be evaluated code!)
#
#There we have it! ":sese:: humdo lumro stimly ::" it is.

# ....................{ GLOBALS                            }....................
#FIXME: Document ${ZESHY_ALIAS_SPLIT_EXPANSION__} *WITHOUT* defining such
#global. Is this feasible?

# ....................{ DEFINERS                           }....................
#FIXME: Document me. (Wow! This is well and truly insane. But it has the
#benefit of actually working, unlike effectively *EVERYTHING* else attempted.)
#FIXME: Note the prefixing newline to separate such evaluation from the last
#argument passed to such alias, as required.
#FIXME: Note that if such string local is undefined, eval() reports failure
#with a suitable error message, inducing zeshy to implicitly throw a
#human-readable exception without requiring manual intervation on our part.
alias_global '::'='
    eval "${ZESHY_ALIAS_SPLIT_EXPANSION__}"'

# ....................{ DEFINERS                           }....................
#FIXME: Improve documentation!
declare_function_with_stdin <<'/---'
void :define_alias_split(
    string alias_name,
    string args_list_name,
    string alias_expansion)

Define the passed *split alias* (i.e., alias-like runnable split into two or
three low-level aliases, the former accepting one or more passed arguments
operated on by the latter) to expand to the passed code with the passed list
locally defined to all arguments passed to such alias. This function implicitly
suffixes such alias name by `::` _and_ requires the last argument all callers
pass to such alias also be `::`. If such alias has already been declared, an
exception is thrown.

== Implementation ==

Specifically, this function defines such alias to:

* Define string local ${ZESHY_ALIAS_SPLIT_EXPANSION__} to temporarily:
** Undefine itself.
** Run such expansion.
* Set such list to all arguments passed to such alias.
/---
function :define_alias_split() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one alias name, one argument list name, and one alias expansion.'
    :string\
        alias_name__das="${1}"\
        list_name_args__das="${2}"\
        alias_expansion__das="${3}"
    is -n "${alias_name__das}" si or die\
        'Expected nonempty split alias name.'
    is -n "${alias_expansion__das}" si or die\
        'Expected nonempty split alias '${alias_name__das}'() expansion.'
    is "${list_name_args__das}" == ${~ZESHY_VAR_NAME_GLOB} si or die\
        'Argument list name "'${list_name_args__das}'" invalid.'

    # Suffix such alias name by the standard split alias suffix.
    alias_name__das+='::'

    #FIXME: Actually, it's unlikely that the current definition of "}:" *DOES*
    #guarantee its undefinition in the event of an exception. Why? Because such
    #exception will have been undefined prior to the expansion of "}:"!  If
    #this is the case, we'll probably need to implicitly undefine "}:" in the
    #low-level exception handler in @{main}. (We'll also want to reduce the
    #start of the definition of "}:" to merely:
    #
    #    alias_global ''}:''=''
    #        undefine_alias "}:"
    #        '${alias_expansion}'

    # Escape all single quotes in such expansion, which we interpolate in a
    # single-quoted manner into the temporary definition of "}:" below.
    alias_expansion__das="${alias_expansion__das//'/''}"  # ...to stifle vim errors: '"

    #FIXME: Update commentary.

    # Define such alias to temporarily define string local ${ZESHY_ALIAS_SPLIT_EXPANSION__} to:
    #
    # * Undefine itself in an "always ~{...}~" block, guaranteeing "}:" to be
    #   undefined even in the event of an exception being thrown prior to the
    #   expansion of "}:".
    # * Set such list to all arguments passed to such alias.
    define_alias "${alias_name__das}" '
        :string   ZESHY_ALIAS_SPLIT_EXPANSION__=''
            unset ZESHY_ALIAS_SPLIT_EXPANSION__
            '${alias_expansion__das}'''
        :list '${list_name_args__das}'
        :set_list_to_strings '${list_name_args__das}
}

declare_function_with_stdin <<'/---'
void :undefine_alias_split(string alias_name1, ...)

Undefine all passed split aliases. See :define_alias_split() for further
details.
/---
function :undefine_alias_split() {
    # Since split aliases are implemented as simple aliases with names suffixed
    # by ":{", undefine such aliases accordingly.
    die_unless_args 'Expected one or more split alias names.'
    undefine_alias_nonsuffix ${^@}'::'
}

#FIXME: In lieu of unit tests...
function lile() {
    # Define such alias to locally define all passed arguments as integers
    # initialized to 42. (Undefine such alias if already defined.)
    { :undefine_alias_split sese } silent_stderr: or ignore_failure
    :define_alias_split sese args__s '
    die_unless_list_nonempty args__s\
        "Expected one or more integer variable names."
    print_list args__s

    :string arg__s
    for     arg__s ("${args__s[@]}") {
        :die_unless_var_name "${arg__s}"
        :int "${arg__s}"=42
    }'

    # Dynamically define a function expanding such alias *AFTER*
    # dynamically defining such alias above.
    redefine_function stile '
        # Expand the previously defined alias.
        sese:: humdo lumro stimly ::

        # Ensure such variables were properly defined.
        :print_var humdo lumro stimly'

    # Call such function.
    stile
}

# --------------------( WASTELANDS                         )--------------------
 # in an `always ={...}=` block, guaranteeing `::` to be
 #  undefined even in the event of an exception being thrown prior to the
 #  expansion of "}:"
 
#FUXME: Actually, this is fairly wierd. For one, it's a bit unsafe. We need to
#throw exceptions if such alias doesn't exist. For another, couldn't we just
#eval() the contents of a local string variable? Hmm; perhaps not, given the
#perennial quoting issues surrounding eval(). If that could be made to work
#reliably, however, that would probably be preferable. (Why? Consider what would
#happen if such function attempted to dynamically define another function after
#calling a split alias. Since ::expand_alias_split() would have been defined...
#Actually, we see no issue there. Perhaps it's all sweet?)

    # :append_list_with_list_local:: list_src list_trg1 list_trg2 ::

    # :append_list_with_list_local::: list_src list_trg1 list_trg2 :::

    # :append_list_with_list_local... list_src list_trg1 list_trg2 ...

    # :append_list_with_list_local--- list_src list_trg1 list_trg2 ---

    # always ={ ugh }=
    # :sese={ humdo lumro stimly }=
    # :sese-{ humdo lumro stimly }-
    # :sese::: humdo lumro stimly :::
    # :sese... humdo lumro stimly ...
    # :sese=== humdo lumro stimly ===
    # :sese%%% humdo lumro stimly %%%
    # :sese~~~ humdo lumro stimly ~~~
    # :sese___ humdo lumro stimly ___
    # :sese-~= humdo lumro stimly =~-
    # :sese:{ humdo lumro stimly }:
    # :sese@{ humdo lumro stimly }@
    # :sese@@ humdo lumro stimly @@
    # :sese++ humdo lumro stimly ++
    # :sese^^ humdo lumro stimly ^^
    # :sese,, humdo lumro stimly ,,
    # :sese~~ humdo lumro stimly ~~
    # :sese%% humdo lumro stimly %%
    # :sese== humdo lumro stimly ==
    # :sese:: humdo lumro stimly ::
    # :sese:. humdo lumro stimly .:
    # :sese// humdo lumro stimly //
    # :sese/+ humdo lumro stimly +/
    # :sese/~ humdo lumro stimly ~/

    #FUXME: Agh! A bigger problem looms: the passed alias expansion
    #${alias_expansion} is interpolated into a string in such a manner that
    #single quotes (and *ONLY* single quotes, yes?) in such string must be
    #escaped. We think, anyway. Examine further.

        # alias_global ''}:''=''
        #     } always ={
        #         undefine_alias "}:"
        #     }~

        #     '${alias_expansion}'''

        # :try {
        #     :list '${list_name_args}'
        #     :set_list_to_strings '${list_name_args}

    # string alias_name,
    # string alias_expansion,
    # string local_scalar_var_name_1, ...)
