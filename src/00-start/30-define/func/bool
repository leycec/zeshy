#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *boolean function definers* (i.e., functions dynamically defining other
functions unconditionally accepting no arguments, returning no output, and
reporting either boolean true or false).
/---

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void :define_func_to_report_bool(string function_name, bool function_status)

Define the passed function to unconditionally accept no arguments, return no
output, and report success if the value of the passed boolean variable is true
or failure otherwise. Such function will have the following signature:

------------------------------------------
[status: ${function_status}] ${function_name}(void)
------------------------------------------
/---
function :define_func_to_report_bool() {
    # Validate sanity. See die_unless_boolean() for further details.
    die_unless_args_2 'Expected one function name and one function status.'
    :string function_name__dftrb="${1}" function_status__dftrb="${2}"

    # If such string is *NOT* a non-negative integer, throw an exception. While
    # we *COULD* strcitly require that such string be a boolean, doing so would
    # complicate logic elsewhere while adding comparatively little benefit here.
    # See :is_int() for further details.
    [[ "${function_status__dftrb}" == <-> ]] || die\
        'String "'${function_status__dftrb}'" not boolean.'

    # Conditionally define such function.
    if (( ${function_status__dftrb} )) {
        :define_func_to_report_success "${function_name__dftrb}"
    } else {
        :define_func_to_report_failure "${function_name__dftrb}"
    }
}

declare_function_with_stdin <<'/---'
void :define_func_to_report_success(string function_name)

Define the passed function to unconditionally accept no arguments, return no
output, and report success. Such function will have the following signature:

------------------------------------------
[status: true] ${function_name}(void)
------------------------------------------
/---
function :define_func_to_report_success() {
    die_unless_arg 'Expected one function name.'
    :define_func "${1}" "die_if_args${ZESHY_ASCII_NEWLINE}report_success"
}

declare_function_with_stdin <<'/---'
void :define_func_to_report_failure(string function_name)

Define the passed function to unconditionally accept no arguments, return no
output, and report failure. Such function will have the following signature:

------------------------------------------
[status: false] ${function_name}(void)
------------------------------------------
/---
function :define_func_to_report_failure() {
    die_unless_arg 'Expected one function name.'
    :define_func "${1}" "die_if_args${ZESHY_ASCII_NEWLINE}report_failure"
}

# --------------------( WASTELANDS                         )--------------------
    # [[ "${function_status__dftrb}" == (0|1) ]] || die\
# void :define_func_to_report_bool(string function_name, bool bool_name)
# 
# Define the passed function to unconditionally accept no arguments, return no
# output, and report success if the value of the passed boolean variable is true
# or failure otherwise. Such function will have the following signature:
# 
# ------------------------------------------
# [status: ${(P)bool_name}] ${function_name}(void)
# ------------------------------------------
# /---
# function :define_func_to_report_bool() {
#     # Validate sanity. See die_unless_boolean() for further details.
#     die_unless_args_2 'Expected one function name and one boolean name.'
#     :string function_name__dftrb="${1}" bool_name__dftrb="${2}"
# 
#     # If such boolean variable does not exist, throw an exception. See
#     # :is_bool() for further details.
#     [[ "${(tP)bool_name__dftrb}" == 'integer'* &&
#        "${(P)bool_name__dftrb}" == (0|1) ]] || die\
#         '${'${bool_name__dftrb}'} undefined or not boolean.'
# 
#     # Conditionally define such function.
#     if (( ${(P)bool_name__dftrb} )) {
#         :define_func_to_report_success "${function_name__dftrb}"
#     } else {
#         :define_func_to_report_failure "${function_name__dftrb}"
#     }
# }

# # If compiling a debug build of zeshy, V
# if { :is_debugging } {
# } else {
#     function :define_func_to_report_success() {
#         die_unless_arg 'Expected one function name.'
#         :define_func "${1}" 'report_success'
#     }
#     function :define_func_to_report_failure() {
#         die_unless_arg 'Expected one function name.'
#         :define_func "${1}" 'report_failure'
#     }
# }
        # If such command (or commands) is pathable, define such function to run
        # such command and cease iteration.
#       if (( is_pathable__dfip )) {

        # By default, the current command is assumed to *NOT* be pathable unless
        # explicitly proven otherwise.
        # is_pathable__dfip=0

            # { eval 'if '${command_name__dfip}' {
            #     is_pathable__dfip=1
            # }' } silent_stderr: or {

            #FUXME: While safe, there exists no guarantee such conditional will
            #actually interpret as valid zsh. An exception should be thrown when
            #this is not the case. Unfortunately, doing so is nontrivial (and
            #requires subshells); basically:

            #FUXME: Actually, it'd be simpler to just quote-protect each command
            #name to prevent such interpretation. Do so!
# >>> :string alternative
# >>> for     alternative ("${ZESHY_ALTERNATIVES[@]}") {
# ...     :undefine_map_key commands ${alternative}
# ... }

# ==  ==
# 
# This function defines 
# Specifically, synthesize such function as the following code (in order):
# 
# . The passed *function body prefix* (i.e., code to be unconditionally prepended
#   to the command-specific function body).
# . The passed *function body* (i.e., code comprising ) corresponding
# . The passed *function body suffix* (i.e., code to be unconditionally appended
#   to the selected function body).

    # All standard output and error printed by the latter of the two eval()
    # calls below.
    # :string 

# Unlike aliases, this functions do _not_ `zsh` already permits functions with names containing shell-
# reserved characters to be defined by double-quoting such names (as in the above
# example). Hence, 

    #FUXME: Uhm; this still shouldn't work. Declaring such function in any pipe
    #subcommand other than the last does so only in the corresponding subshell.
    #Instead, we'll need to use the coprocess approach. Unfortunately, we're
    #getting into a bit of a chicken-and-egg issue here. We *DEFINITELY* don't
    #want to inline our coprocess implementation here; it's simply too delicate.
    #Instead, we'll need to leave this function *UNDEFINED* until after defining
    #such coprocess functionality -- which, I believe, is all segregated to
    #@{15-alias}. That being the case, this function should be shifted to
    #@{20-function} and reimplemented in terms of coprocesses.
    #FUXME: Ah. Wait. Declaring such function in a subshell should be reasonably
    #efficient. Certainly, since coprocesses also require subshells and impose
    #even *MORE* inefficiencies, declaring such function in a subshell will
    #certainly be no worse. So, simply declare such function in a subshell
    #*FIRST* to ascertain whether or not such definition is erroneous. If so,
    #propagate such error as an exception; else, declare such function in the
    #current shell. Reasonably simple, eh?

    # If such function body is syntactically invalid, throw an exception.
    # Technically, shifting this conditional into the prior block would slightly
    # improve efficiency -- while indenting this conditional two tabs to the
    # right and hence rendering it unreadable. (You decide.)
    # if [[ -n "${function_error__rf}" ]] {

    # Declare such function. To prevent errors if such function name contains
    # double quotes, avoid directly interpolating such function name.
    #
    # If such function body is syntactically invalid, zsh prints a nonfatal
    # warning to standard error and returns successfully; else, neither standard
    # output or error are printed to. Deciding whether an error occurred thus
    # requires capturing standard output and error to a string local and testing
    # whether such local is nonempty or not. Since capturing such output with a
    # conventional command substitution declares such function only in a
    # subshell rather than the current shell (e.g.,
    # function_error="$(eval "function ..." 2>&1)"), capture such output with a
    # pipe in the current shell instead.
    #
    # Ideally, that would simply suffice: pipe such output into the necessary
    # read() command and test the result. Naturally, it doesn't. While it
    # remains unclear why eval() behaves in this manner, one thing is clear: if
    # eval() succeeds in defining such function *AND* is piped into *ANYTHING*,
    # eval() silently fails and undefines such function. While this is fairly
    # crazy, the solution is fairly simple: only pipe eval() output if a prior
    # eval() call passed the same arguments returns non-zero exit status. This
    # is the most obscure code in any language I've ever had the shame to admit
    # having contributed. It's hard to be proud of something like this.
    # eval "${function__rf}" || {
    #     # Dismantled, this is:
    #     #
    #     # * "|&", piping both standard output and error from such eval() call.
    #     # * "IFS='' read -r -d ''", capturing all piped standard output and
    #     #   error to ${function_error}.
    #     eval "${function__rf}" |& IFS='' read -r -d '' function_error__rf
    # }

#FUXME: Arguably complex enough to warrant shifting to a new parcel
#@{20-function/define}.
#FUXME: Right. We *HAVE* to do so anyway, to ensure access to coprocess
#functionality. See below. For now, the following two functions remain *BROKEN*.
#FUXME: O.K.; while we *REALLY* don't want to adopt a coprocess approach,
#there's no compelling reason to leave these here. Shift into new parcel
#@{00-core/declare/function}. Then also define our new
#:declare_function_if_pathable() function in the same parcel.
