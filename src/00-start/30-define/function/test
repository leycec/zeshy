#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *conditionally function definers* (i.e., functions dynamically defining
other functions in a conditional manner usually dependent on current system and
user state).
/---

# ....................{ DEFINERS                           }....................
#FIXME: Rename to :define_function_if_or_noop().

declare_function_with_stdin <<'/---'
void :define_function_if(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string if_test1, string then_function_body1, ...)

Define the passed function as the first *function body* (i.e., arbitrary code
implementing such function) whose preceding *condition* (i.e., arbitrary code
interpretable as an `if` statement test implicitly delimited by `{` and `}`)
succeeds, prefixed by the passed *function body prefix* (i.e., arbitrary code
unconditionally prepended to such function's implementation) and suffixed by the
passed *function body suffix* (i.e., arbitrary code unconditionally appended to
such function's implementation). If no such condition succeeds, this function
reports success without defining such function: e.g.,

.:define_function_if()
==========================================
[source]
------------------------------------------
>>> :list ZESHY_DISORDERS; ZESHY_DISORDERS=( heathen mad nihilist )
>>> :undefine_map_key commands heathen mad nihilist
>>> :define_function_if\
...     :output_disorder\
...     'die_if_args' ''\
...     :is_heathen 'output_string\
...         "A benighted creature who has the folly to worship something that he
...          can see and feel."'\
...     :is_mad 'output_string\
...         "Affected with a high degree of intellectual independence."'\
...     :is_nihilist 'output_string\
...         "A Russian who denies the existence of anything but Tolstoi. The
...          leader of the school is Tolstoi."'\
...     else 'output_string\
...         "CYNIC, n. A blackguard whose faulty vision sees things as they are,
...          not as they ought to be."'\
>>> :print_function :output_disorder
function :output_disorder() {
    (( # )) && die "Expected no arguments."
    output_string\
        "CYNIC, n. A blackguard whose faulty vision sees things as they are,
         not as they ought to be."
}
------------------------------------------
==========================================

== Else Conditions ==

This function treats any condition equal to `else` or `true` as an *else
condition* (i.e., fallback, such that if no prior condition succeeds, the passed
function will be defined as the function body following such condition). Any
conditions following such condition will be ignored. See the example above.
/---
function :define_function_if() {
    # Validate sanity.
    die_unless_args_5_or_more\
        'Expected one function name, one function body prefix, one function body suffix, and one or more pairs of one test and one function body.'
    :string\
        function_name__dfi="${1}"\
        function_body_prefix__dfi="${2}"\
        function_body_suffix__dfi="${3}"\
        function_body__dfi
    :map test_to_function_body__dfi
    shift_args_3

    # If the number of remaining arguments is *NOT* even and hence does *NOT*
    # constitute a map, throw an exception. See :die_unless_arg_count_even()
    # for further details. (Such exception handler calls the currently undefined
    # tester :is_int_even() and hence cannot be called here.)
    (( # % 2 == 0 )) or die\
        'Expected each test to be paired with a function body.'

    # For each paired condition and function body, test if such condition
    # succeeds and, if so, define such function as such body.
    :string test__dfi function_body_then__dfi
    for     test__dfi function_body_then__dfi ("${@}") {
        # If such condition is "else", convert such condition to "true",
        # guaranteeing such condition to succeed as desired.
        if is "${test__dfi}" == 'else' si {
            test__dfi='true'
        }

        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize with :define_function_if_pathable().
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # If such condition fails, such test was either syntactically invalid
        # *OR* syntactically valid and genuinely failed. Discriminate between
        # the two. In the former case, throw an exception. In the latter case,
        # skip to the next condition.
        { eval "${test__dfi}" } silent_stderr: or {
            # Capture such output, ignoring the expected failure.
            :string test_error__dfi; test_error__dfi="$(
                { eval "${test__dfi}" } to_stdout: or ignore_failure)"

            # If such test failed with no error, such test is syntactically
            # valid and genuinely failed. Skip to the next command.
            is -n "${test_error__dfi}" si or continue

            # Else, such test is syntactically invalid. Convert such
            # nonfatal error into a fatal exception. For readability, strip the
            # prefixing "zsh: " from such error message.
            die 'Test-dependent function '${function_name__dfi}'() test "'${test__dfi}'" invalid:'${ZESHY_ASCII_NEWLINE}${test_error__dfi#zsh: }
        }

        # Else, such condition succeeded. Enable the corresponding body.
        function_body__dfi="${function_body_then__dfi}"

        # Cease iteration.
        break
    }

    # If such body was defined above, define such function as such body.
    if is -n "${function_body__dfi}" si {
        define_function "${function_name__dfi}" \
"    ${function_body_prefix__dfi}
    ${function_body__dfi}
    ${function_body_suffix__dfi}"
    }
}

# ....................{ DEFINERS ~ pathable                }....................
declare_function_with_stdin <<'/---'
void :define_function_if_pathable_or_noop(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string command_name1, string function_body1, ...)

Define the passed function as the concatenation of the passed function body
prefix, the function body following the first passed *pathable command name*
(i.e., in the current ${PATH}) tested in the passed order, and the passed
function body suffix if at least one such command is pathable or return
silently otherwise. See :define_function_if_pathable_in_list_order_or_noop()
for further details.
------------------------------------------
==========================================
/---
function :define_function_if_pathable_or_noop() {
    # Validate sanity.
    die_unless_args_5_or_more\
        'Expected one function name, one function body prefix, one function body suffix, and one or more pairs of one command name and one function body.'

    # Define a private variable whose existence is tested by
    # :define_function_if_pathable_in_list_order_or_noop(), allowing us to pass
    # such function an empty list name. See such function for further details.
    :string __zeshy_define_function_if_pathable_sans_list

    # Defer to such function with an empty list name.
    :define_function_if_pathable_in_list_order_or_noop "${@}" ''
}

declare_function_with_stdin <<'/---'
void :define_function_if_pathable_in_list_order_or_noop(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string command_name1, string function_body1, ...,
    string command_names_list_name)

Define the passed function as the concatenation of the passed function body
prefix, the function body following the first passed *pathable command name*
(i.e., in the current ${PATH}) tested in the order such commands appear in the
passed list, and the passed function body suffix if at least one such command
is pathable or return silently otherwise: e.g.,

.:define_function_if_pathable_in_list_order_or_noop()
==========================================
[source]
------------------------------------------
>>> :list order; order=( anarchism capitalism communism socialism )
>>> commands[anarchism]='true'
>>> :undefine_map_key commands capitalism communism socialism
>>> :define_function_if_pathable_in_list_order_or_noop :output_alternative\
...     'die_if_args' ''\
...     'anarchism' 'output_string\
...         "Political theory founded on the observation that since few men are
...          wise enough to rule themselves, even fewer are wise enough to rule
...          others."'\
...     'capitalism' 'output_string "Under capitalism, man exploits man."'\
...     'communism'  'output_string "Under communism, it's just the opposite."'\
...     'socialism'  'output_string\
...         "Socialism is the only system for nationalizing compassion so that
...          individuals may be done with it."'\
...     order
>>> :print_function :output_alternative
function :output_alternative() {
    (( # )) && die "Expected no arguments."
    output_string\
        "Political theory founded on the observation that since few men are
         wise enough to rule themselves, even fewer are wise enough to rule
         others."'
}
------------------------------------------
==========================================

== Search Algorithm ==

This function algorithmically attempts to find the first such command name
pathable by the current user. Specifically:

* For each item of the passed list:
** If such item is not a passed command name, an exception is thrown.
** Else, such item is a passed command name. If such command is pathable,
   define the passed function as the concatenation of:
*** The passed function body prefix.
*** The passed function body following such command in the argument list.
*** The passed function body suffix.

== Command Alternatives ==

Such function requires exactly one of the passed commands, each presumably an
alternative implementation of the same functionality required by such function.
Each such command is followed by a function body, presumably running the
preceding command.

Together, the set of such command names and corresponding function bodies
constitutes an ad-hoc map from the former to the latter. For caller
convenience, such map must be passed as pairs of arguments rather than as the
name of an actual map.

== Command Order ==

*Only the passed list defines the order in which such commands are tested.* The
order in which such command names and function bodies are passed to this
function is insignificant.

Globalizing the passed list to a configuration file permits users to customize
such order and hence which commands this function should prefer to implement
the passed function in terms of.
/---
function :define_function_if_pathable_in_list_order_or_noop() {
    # Validate sanity.
    die_unless_args_6_or_more\
        'Expected one function name, one function body prefix, one function body suffix, one or more pairs of one command name and one function body, and one list name.'
    :string\
        function_name__dfipilo="${1}"\
        function_body_prefix__dfipilo="${2}"\
        function_body_suffix__dfipilo="${3}"\
        list_name__dfipilo="${@[-1]}"\
        test__dfipilo\
        test_error__dfipilo
    :bool is_pathable__dfipilo
    :map command_name_to_function_body__dfipilo
    shift_args_3
    pop_arg

    # If the number of remaining arguments is odd and hence does *NOT*
    # constitute a map from command name to function body, throw an exception.
    (( # % 2 == 0 )) or die 'Expected even number of arguments.'

    # Localize such map.
    command_name_to_function_body__dfipilo=( "${@}" )

    # If a private variable defined only by :define_function_if_pathable() is
    # defined, the passed list name is necessarily empty. In such case, default
    # such name to that of a local list containing all passed command names in the passed order.
    #
    # While this does *NOT* constitute an error, such list name being empty
    # without such variable also being set does. To distinguish between the
    # two, test such variable rather than such list name.
    if (( ${+__zeshy_define_function_if_pathable_sans_list} )) {
        # If such list name is *NOT* empty, throw an exception.
        is -z "${list_name__dfipilo}" si or die\
             '${__zeshy_define_function_if_pathable_sans_list} defined but list name "'${list_name__dfipilo}'" nonempty.'

        # Set such list name to the list defined below.
        list_name__dfipilo='command_names__dfipilo'

        # See set_list_to_map_keys() for further details.
        :list command_names__dfipilo; command_names__dfipilo=(
            ${(k@)command_name_to_function_body__dfipilo} )
        # output_string "command names: ${command_names__dfipilo[@]}"
    # Else, such private variable is undefined. In such case, behave as
    # documented above - which is to say, normally.
    } else {
        # If such list is *NOT*, throw an exception.
        is "${(tP)list_name__dfipilo-}" == 'array'* si or die\
             'List ${'${list_name__dfipilo}'} undefined or not a list.'
    }

    # For each command in such list, test if such command is pathable and, if
    # so, define such function in context of such command.
    :string command_name__dfipilo
    for     command_name__dfipilo ("${(@P)list_name__dfipilo}") {
        # If such map contains no such command, throw an exception.
        (( ${+command_name_to_function_body__dfipilo[${command_name__dfipilo}]} )) or die\
            'Function '${function_name__dfipilo}'() command "'${command_name__dfipilo}'" unrecognized.'

        # If such command contains no whitespace, skip to the next command
        # unless such command is pathable. See is_pathable() for further
        # details.
        if is "${command_name__dfipilo}" != *' '* si {
            (( ${+commands[${command_name__dfipilo}]} )) or continue
        # Else, such command contains whitespace. In such case, assume such
        # command to be a conditional testing the existence of two or more
        # commands. To do so, programmatically convert such string into a true
        # zsh test (e.g., from "catabolic and collapse" to
        # "(( ${+commands[catabolic]} )) && (( ${+commands[collapse]} ))").
        } else {
            # To permit map lookups below, preserve the original command string
            # by performing modifications on this local copy.
            test__dfipilo="${command_name__dfipilo}"

            # If such conditional contains inherently dangerous shell-reserved
            # characters, throw an exception. This includes "`", the obsoleted
            # command substitution prefix, and "$", both the expansion and new
            # command substitution prefix. While command substitutions are
            # patently unsafe (e.g., "$(rm -rf /)"), expansions also support
            # dynamic evaluation of arbitrary code (e.g.,
            # ":string evil='rm -rf /'; : ${(e)evil}") and hence are little
            # safer. Prohibit both by prohibiting their prefixing characters.
            is "${test__dfipilo}" != *['$`'*] si or die\
                'Function '${function_name__dfipilo}'() test "'${test__dfipilo}'" contains unsafe shell-reserved characters "$" and/or "`".'

            # Globally replace in such conditional (in order):
            #
            # * All space-delimited words "or" and "and" with "||" and "&&".
            #   Since both "or" and "and" are valid shell identifiers, do so
            #   *BEFORE* replacing shell identifier characters.
            # * All longest contiguous substrings of shell identifier characters
            #   (signifying unquoted command names) with a test testing the
            #   existence of such command. While command names can technically
            #   contain arbitrary characters, we currently only support common
            #   command names containing no shell-reserved characters and hence
            #   requiring no quoting or escaping.
            test__dfipilo="${${${test__dfipilo// ##or ##/ || }// ##and ##/ && }//(#m)[[:IDENT:]]##/(( \${+commands[${MATCH}]\} ))}"  # unhighlight vim: "}"
            # print "command conditional: ${test__dfipilo}" 1>&2

            # Skip to the next command unless such test dynamically succeeds.
            # If such test fails, such test was either syntactically invalid
            # *OR* syntactically valid and genuinely failed. Discriminate
            # between the two and, in the former case, throw an exception.
            { eval "${test__dfipilo}" } silent_stderr: or {
                # Capture such output, ignoring the expected failure.
                test_error__dfipilo="$(
                    { eval "${test__dfipilo}" } to_stdout: or ignore_failure)"

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                is -n "${test_error__dfipilo}" si or continue

                # Else, such test is syntactically invalid. Convert such
                # nonfatal error into a fatal exception. For readability, strip the
                # prefixing "zsh: " from such error message.
                die 'Command-dependent function '${function_name__dfipilo}'() test "'${test__dfipilo}'" invalid:'$'\n'${test_error__dfipilo#zsh: }
            }
        }

        # Since the current iteration did not continue, such command or
        # commands is pathable. Define such function as such command.
        define_function "${function_name__dfipilo}" \
"    ${function_body_prefix__dfipilo}
    ${command_name_to_function_body__dfipilo[${command_name__dfipilo}]}
    ${function_body_suffix__dfipilo}"

        # Cease iteration.
        report_success
    }

    # If no such command exists, return silently.
    report_success
}

# --------------------( WASTELANDS                         )--------------------
    # output_string "command count: ${#command_name_to_function_body__dfipilo}"
    # for command_name function_body (
    #     "${(kv@)command_name_to_function_body__dfipilo}") {
    #     output_string "${command_name} -> ${function_body}"
    # }
    # print "3: ${3}\n4: ${4}"

 # avoid defining such function. Do *NOT* report
    # failure and hence induce an exception, as this function is commonly called
    # during digest compilation from the top-level.
# declare_function_with_stdin <<'/---'
# void :define_function_if_pathable_or_noop(
#     string function_name,
#     string function_body_prefix,
#     string function_body_suffix,
#     string command_name1, string function_body1, ...,
#     string pathables_list_name)
# 
# Define the passed function whose implementation requires any one of several
# *command alternatives* (i.e., external commands offering similar functionality)
# to run the first such command in the passed list of such alternatives that is
# currently *pathable* (i.e., in the current command hash, typically synonymous
# with in the current user's ${PATH}), given:
# 
# * An optional passed list of such alternatives, in descending order of
#   preference. If _not_ passed, such order defaults to the order in which such
#   conditions are defined and hence tested.
# * The passed *function body prefix* (i.e., code to be unconditionally prepended
#   to the command-specific function body).
# * The passed *function body suffix* (i.e., code to be unconditionally appended
#   to the command-specific function body).
# * A map from each command name in the passed list of such alternatives to the
#   command-specific function body running such command. For convenience, such map
#   should be passed as pairs of additional arguments rather than as an actual
#   map.
# 
# For example:
# 
# .:define_function_if_pathable()
# ==========================================
# [source]
# ------------------------------------------
# >>> :list ZESHY_ALTERNATIVES; ZESHY_ALTERNATIVES=(
# ...     anarchism capitalism communism socialism )
# >>> commands[anarchism]='true'
# >>> :undefine_map_key commands capitalism communism socialism
# >>> :define_function_if_pathable\
# ...     :output_alternative\
# ...     'die_if_args' ''\
# ...     'anarchism' 'output_string\
# ...         "Political theory founded on the observation that since few men are
# ...          wise enough to rule themselves, even fewer are wise enough to rule
# ...          others."'\
# ...     'capitalism' 'output_string "Under capitalism, man exploits man."'\
# ...     'communism'  'output_string "Under communism, it's just the opposite."'\
# ...     'socialism'  'output_string\
# ...         "Socialism is the only system for nationalizing compassion so that
# ...          individuals may be done with it."'\
# ...     ZESHY_ALTERNATIVES
# >>> :print_function :output_alternative
# function :output_alternative() {
#     (( # )) && die "Expected no arguments."
#     output_string\
#         "Political theory founded on the observation that since few men are
#          wise enough to rule themselves, even fewer are wise enough to rule
#          others."'
# }
# >>> :output_alternative
# Political theory founded on the observation that since few men are
# wise enough to rule themselves, even fewer are wise enough to rule
# others.
# ------------------------------------------
# ==========================================
# /---
# function :define_function_if_pathable_or_noop() {
#     # Validate sanity.
#     die_unless_args_5_or_more\
#         'Expected one function name, one function body prefix, one function body suffix, one or more pairs of one command name and one function body, and optional pathables list name.'
#     :string\
#         function_name__dfip="${1}"\
#         function_body_prefix__dfip="${2}"\
#         function_body_suffix__dfip="${3}"
#     shift_args_3
# 
#     # Define a private variable tested by
#     # :define_function_if_pathable_in_list_order_or_noop(). See such function for
#     # further details.
#     __zeshy_define_function_if_pathable_sans_list
# 
#     #FIXME: Optional arguments are terrible, rendering the resulting function
#     #fragile and difficult to reliably extend. Instead, define a new function
#     #:define_function_if_pathable_in_list_order(). While this function could
#     #probably be redefined to call such function, the most efficient
#     #refactoring is probably to also define a new private function:
#     #
#     #"void ::define_function_if_map_pathable_in_list_order(
#     #    string function_name,
#     #    string function_body_prefix,
#     #    string function_body_suffix,
#     #    string command_to_function_body_map_name,
#     #    string pathables_list_name)"
#     #
#     #Then refactor both this function and
#     #:define_function_if_pathable_in_list_order() to call
#     #::define_function_if_map_pathable_in_list_order(). Nice, possibly?
# 
#     # If the number of passed arguments is even, such list name was passed.
#     if (( # % 2 == 0 )) {
#         # Localize and remove such list name from the argument list.
#         list_name_pathables__dfip="${@[-1]}"
#         pop_arg
# 
#         # If such list is not, throw an exception.
#         is "${(tP)list_name_pathables__dfip-}" == 'array'* si or die\
#              '${'${list_name_pathables__dfip}'} undefined or not a list.'
#     }
# 
#     # If the number of remaining arguments is *NOT* even and hence does *NOT*
#     # constitute a map from command name to function body, throw an exception.
#     (( # % 2 == 0 )) or die 'Expected even number of arguments.'
# 
#     # Localize such map.
#     command_name_to_function_body__dfip=( "${@}" )
# 
#     # If such list name was *NOT* passed, default such name to a local list of
#     # all command names to be tested in the passed order. See
#     # set_list_to_map_keys() for further details.
#     if [[ -z "${list_name_pathables__dfip}" ]] {
#         :list list_pathables__dfip
#         list_pathables__dfip=( ${(k@)command_name_to_function_body__dfip} )
#         list_name_pathables__dfip='list_pathables__dfip'
#     }
# 
#     # For each command in the passed list of command alternatives, test if such
#     # command exists and, if so, define such function with such command.
#     :bool is_pathable__dfip
#     :string command_name__dfip
#     for     command_name__dfip ("${(@P)list_name_pathables__dfip}") {
#         # If such map contains no such command, throw an exception.
#         (( ${+command_name_to_function_body__dfip[${command_name__dfip}]} )) or die\
#             'Command-dependent function '${function_name__dfip}'() command "'${command_name__dfip}'" unimplemented.'
# 
#         # If such command contains whitespace, assume such command to be a
#         # conditional testing the existence of two or more commands. To do so,
#         # programmatically convert such string into a true zsh test (e.g., from
#         # "catabolic and collapse" to
#         # "(( ${+commands[catabolic]} )) && (( ${+commands[collapse]} ))").
#         if is "${command_name__dfip}" == *' '* si {
#             # To permit map lookups below, preserve the original command string
#             # by performing modifications on this local copy.
#             :string test__dfip="${command_name__dfip}"
# 
#             # If such conditional contains inherently dangerous shell-reserved
#             # characters, throw an exception. This includes "`", the obsoleted
#             # command substitution prefix, and "$", both the expansion and new
#             # command substitution prefix. While command substitutions are
#             # patently unsafe (e.g., "$(rm -rf /)"), expansions also support
#             # dynamic evaluation of arbitrary code (e.g.,
#             # ":string evil='rm -rf /'; : ${(e)evil}") and hence are little
#             # safer. Prohibit both by prohibiting their prefixing characters.
#             is "${test__dfip}" != *['$`'*] si or die\
#                 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" contains unsafe shell-reserved characters "$" and/or "`".'
# 
#             # Globally replace in such conditional (in order):
#             #
#             # * All space-delimited words "or" and "and" with "||" and "&&".
#             #   Since both "or" and "and" are valid shell identifiers, do so
#             #   *BEFORE* replacing shell identifier characters.
#             # * All longest contiguous substrings of shell identifier characters
#             #   (signifying unquoted command names) with a test testing the
#             #   existence of such command. While command names can technically
#             #   contain arbitrary characters, we currently only support common
#             #   command names containing no shell-reserved characters and hence
#             #   requiring no quoting or escaping.
#             test__dfip="${${${test__dfip// ##or ##/ || }// ##and ##/ && }//(#m)[[:IDENT:]]##/(( \${+commands[${MATCH}]\} ))}"   # hack vim highlighting issues: "}"
#             # print "command conditional: ${test__dfip}" 1>&2
# 
#             # Skip to the next command unless such test dynamically succeeds.
#             # If such test fails, such test was either syntactically invalid
#             # *OR* syntactically valid and genuinely failed. Discriminate
#             # between the two and, in the former case, throw an exception.
#             { eval "${test__dfip}" } silent_stderr: or {
#                 # Capture such output, ignoring the expected failure.
#                 :string test_error__dfip; test_error__dfip="$(
#                     { eval "${test__dfip}" } to_stdout: or ignore_failure)"
# 
#                 # If such test failed with no error, such test is syntactically
#                 # valid and genuinely failed. Skip to the next command.
#                 is -n "${test_error__dfip}" si or continue
# 
#                 # Else, such test is syntactically invalid. Convert such
#                 # nonfatal error into a fatal exception. For readability, strip the
#                 # prefixing "zsh: " from such error message.
#                 die 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" invalid:'$'\n'${test_error__dfip#zsh: }
#             }
#         # Else, such command contains no whitespace. Skip to the next command
#         # unless such command is pathable. See is_pathable() for further details.
#         } else {
#             (( ${+commands[${command_name__dfip}]} )) or continue
#         }
# 
#         # Since the current iteration did *NOT* continue, such command or
#         # commands is pathable. Define such function with such command.
#         define_function "${function_name__dfip}" \
# "    ${function_body_prefix__dfip}
#     ${command_name_to_function_body__dfip[${command_name__dfip}]}
#     ${function_body_suffix__dfip}"
# 
#         # Cease iteration.
#         report_success
#     }
# 
#     # If no such command exists, avoid defining such function. Do *NOT* report
#     # failure and hence induce an exception, as this function is commonly called
#     # during digest compilation from the top-level.
#     report_success
# }

# >>> :output_alternative
# Political theory founded on the observation that since few men are
# wise enough to rule themselves, even fewer are wise enough to rule
# others.
 # In such case, list name is nonempty, throw an exception unless the
    # corresponding variable exists and is of type list.
    # if [[ -n "${list_name__dfipilo}" ]] {
    # is "${(tP)map_name__dfipilo-}" == 'association'* si or die\
    #      'Map ${'${map_name__dfipilo}'} undefined or not a map.'

# declare_function_with_stdin <<'/---'
# void ::define_function_if_map_pathable_in_list_order(
#     string function_name,
#     string function_body_prefix,
#     string function_body_suffix,
#     string command_name_to_function_body_map_name,
#     string command_names_list_name)
# 
# Define the passed function as the concatenation of the passed function body
# prefix, the value of the first key of the passed map that is pathable (tested
# in the order that such keys appear in the passed list), and the passed function
# body suffix if at least one such key is pathable or return silently otherwise.
# See :define_function_if_pathable_in_list_order() for further details.
# /---
# function ::define_function_if_map_pathable_in_list_order() {
#     # Validate sanity.
#     die_unless_args_5\
#         'Expected one function name, one function body prefix, one function body suffix, one map name, and one list name.'
#     :string\
#         function_name__dfimpilo="${1}"\
#         function_body_prefix__dfimpilo="${2}"\
#         function_body_suffix__dfimpilo="${3}"\
#         map_name__dfimpilo="${4}"\
#         list_name__dfimpilo="${5}"
#     :bool is_pathable__dfimpilo
# 
#     # If such variables are not of the expected types, throw exceptions.
#     is "${(tP)map_name__dfimpilo-}" == 'association'* si or die\
#          'Map ${'${map_name__dfimpilo}'} undefined or not a map.'
#     is "${(tP)list_name__dfimpilo-}" == 'array'* si or die\
#          'List ${'${list_name__dfimpilo}'} undefined or not a list.'
# 
#     # For each command in such list, test if such command is pathable and, if
#     # so, define such function in context of such command.
#     eval '
#     :string command_name__dfimpilo
#     for     command_name__dfimpilo ("${(@P)list_name__dfimpilo}") {
#         # If such map contains no such command, throw an exception.
#         (( ${+map_name__dfimpilo[${command_name__dfimpilo}]} )) or die\
#             ''Command-dependent function ''${function_name__dfimpilo}''() command "''${command_name__dfimpilo}''" unimplemented.''

#FUXME: Revise to no longer accept an optional final "else" fallback.

    # If the number of remaining arguments is odd and hence does *NOT*
    # constitute a map, the last such argument is the fallback body. For
    # simplicity, default the current body to such fallback. If at least one
    # such condition succeeds, the iteration below will override such default
    # with the corresponding body.
    # if (( # % 2 == 1 )) {
    #     function_body__dfi="${@[-1]}"
    #     pop_arg
    # }

# >>> :output_disorder
# CYNIC, n. A blackguard whose faulty vision sees things as they are,
# not as they ought to be.

# _or_ to the fallback function body if no such condition succeeds and
# such body was passed, prefixed by the passed *function body prefix* (i.e.,
# arbitrary code to be unconditionally prepended to such body) and suffixed by the
# passed *function body suffix* (i.e., arbitrary code to be unconditionally
# appended to such body). If no such condition succeeds _and_ no fallback function
# body was passed, such function will _not_ be defined: e.g.,

    # If no such condition succeeded *AND* a fallback body was passed, enable
    # such body.
    # if is -z "${function_body__dfi}" and
    #       -n "${function_body_fallback__dfi}" si {
    #     function_body__dfi="${function_body_fallback__dfi}"
    # }
# 
#     pop_arg
# 
#     # If the number of remaining arguments is *NOT* even and hence does *NOT*
#     # constitute a map, throw an exception.
#     (( # % 2 == 0 )) or die\
#         'Expected each test to be paired with a function body.'

    # Remove such arguments from the argument list. All remaining arguments
    # constitute the map from command name to function body.

    # If no such condition succeeded *AND* a fallback body was passed, enable
    # such body.
    # if is -z "${function_body__dfi}" and
    #       -n "${function_body_fallback__dfi}" si {
    #     function_body__dfi="${function_body_fallback__dfi}"
    # }

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                # if is -z "${test_error__dfip}" si {
                #     continue
                # # Else, such test is syntactically invalid. Convert such
                # # nonfatal error into a fatal exception.
                # } else {
                #     # For readability, strip the prefixing "zsh: ".
                #     test_error__dfip="${test_error__dfip#zsh: }"
                #     die 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" failed:'$'\n'${test_error__dfip}
                # }
