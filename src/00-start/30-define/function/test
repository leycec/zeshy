#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *conditionally function definers* (i.e., functions dynamically defining
other functions in a conditional manner usually dependent on current system and
user state).
/---

# ....................{ DEFINERS                           }....................
#FIXME: Revise to no longer accept an optional final "else" fallback.
#FIXME: Rename to :define_function_if_or_noop().

declare_function_with_stdin <<'/---'
void :define_function_if(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string if_test1, string then_function_body1, ...)

Define the passed function as the first *function body* (i.e., arbitrary code
implementing such function) whose preceding *condition* (i.e., arbitrary code
interpretable as an `if` statement test implicitly delimited by `{` and `}`)
succeeds, prefixed by the passed *function body prefix* (i.e., arbitrary code
unconditionally prepended to such function's implementation) and suffixed by the
passed *function body suffix* (i.e., arbitrary code unconditionally appended to
such function's implementation). If no such condition succeeds, this function
reports success without defining such function: e.g.,

.:define_function_if()
==========================================
[source]
------------------------------------------
>>> :list ZESHY_DISORDERS; ZESHY_DISORDERS=( heathen mad nihilist )
>>> :undefine_map_key commands heathen mad nihilist
>>> :define_function_if\
...     :output_disorder\
...     'die_if_args' ''\
...     :is_heathen 'output_string\
...         "A benighted creature who has the folly to worship something that he
...          can see and feel."'\
...     :is_mad 'output_string\
...         "Affected with a high degree of intellectual independence."'\
...     :is_nihilist 'output_string\
...         "A Russian who denies the existence of anything but Tolstoi. The
...          leader of the school is Tolstoi."'\
...     else 'output_string\
...         "CYNIC, n. A blackguard whose faulty vision sees things as they are,
...          not as they ought to be."'\
>>> :print_function :output_disorder
function :output_disorder() {
    (( # )) && die "Expected no arguments."
    output_string\
        "CYNIC, n. A blackguard whose faulty vision sees things as they are,
         not as they ought to be."
}
------------------------------------------
==========================================

== Else Conditions ==

This function treats any condition equal to `else` or `true` as an *else
condition* (i.e., fallback, such that if no prior condition succeeds, the passed
function will be defined as the function body following such condition). Any
conditions following such condition will be ignored. See the example above.
/---
function :define_function_if() {
    # Validate sanity.
    die_unless_args_5_or_more\
        'Expected one function name, one function body prefix, one function body suffix, and one or more pairs of one test and one function body.'
    :string\
        function_name__dfi="${1}"\
        function_body_prefix__dfi="${2}"\
        function_body_suffix__dfi="${3}"\
        function_body__dfi
    :map test_to_function_body__dfi
    shift_args_3

    # If the number of remaining arguments is *NOT* even and hence does *NOT*
    # constitute a map, throw an exception. See :die_unless_arg_count_even()
    # for further details. (Such exception handler calls the currently undefined
    # tester :is_int_even() and hence cannot be called here.)
    (( # % 2 == 0 )) or die\
        'Expected each test to be paired with a function body.'

    # For each paired condition and function body, test if such condition
    # succeeds and, if so, define such function as such body.
    :string test__dfi function_body_then__dfi
    for     test__dfi function_body_then__dfi ("${@}") {
        # If such condition is "else", convert such condition to "true",
        # guaranteeing such condition to succeed as desired.
        if is "${test__dfi}" == 'else' si {
            test__dfi='true'
        }

        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize with :define_function_if_pathable().
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # If such condition fails, such test was either syntactically invalid
        # *OR* syntactically valid and genuinely failed. Discriminate between
        # the two. In the former case, throw an exception. In the latter case,
        # skip to the next condition.
        { eval "${test__dfi}" } silent_stderr: or {
            # Capture such output, ignoring the expected failure.
            :string test_error__dfi; test_error__dfi="$(
                { eval "${test__dfi}" } to_stdout: or ignore_failure)"

            # If such test failed with no error, such test is syntactically
            # valid and genuinely failed. Skip to the next command.
            is -n "${test_error__dfi}" si or continue

            # Else, such test is syntactically invalid. Convert such
            # nonfatal error into a fatal exception. For readability, strip the
            # prefixing "zsh: " from such error message.
            die 'Test-dependent function '${function_name__dfi}'() test "'${test__dfi}'" invalid:'$'\n'${test_error__dfi#zsh: }
        }

        # Else, such condition succeeded. Enable the corresponding body.
        function_body__dfi="${function_body_then__dfi}"

        # Cease iteration.
        break
    }

    # If such body was defined above, define such function as such body.
    if is -n "${function_body__dfi}" si {
        define_function "${function_name__dfi}" \
"    ${function_body_prefix__dfi}
    ${function_body__dfi}
    ${function_body_suffix__dfi}"
    }
}

declare_function_with_stdin <<'/---'
void :define_function_if_pathable(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string command_name1, string function_body1, ...,
    string pathables_list_name)

Define the passed function whose implementation requires any one of several
*command alternatives* (i.e., external commands offering similar functionality)
to run the first such command in the passed list of such alternatives that is
currently *pathable* (i.e., in the current command hash, typically synonymous
with in the current user's ${PATH}), given:

* The passed list of such alternatives, in descending order of preference.
* The passed *function body prefix* (i.e., code to be unconditionally prepended
  to the command-specific function body).
* The passed *function body suffix* (i.e., code to be unconditionally appended
  to the command-specific function body).
* A map from each command name in the passed list of such alternatives to the
  command-specific function body running such command. For convenience, such map
  should be passed as pairs of additional arguments rather than as an actual
  map.

For example:

.:define_function_if_pathable()
==========================================
[source]
------------------------------------------
>>> :list ZESHY_ALTERNATIVES; ZESHY_ALTERNATIVES=(
...     anarchism capitalism communism socialism )
>>> commands[anarchism]='true'
>>> :undefine_map_key commands capitalism communism socialism
>>> :define_function_if_pathable\
...     :output_alternative\
...     'die_if_args' ''\
...     'anarchism' 'output_string\
...         "Political theory founded on the observation that since few men are
...          wise enough to rule themselves, even fewer are wise enough to rule
...          others."'\
...     'capitalism' 'output_string "Under capitalism, man exploits man."'\
...     'communism'  'output_string "Under communism, it's just the opposite."'\
...     'socialism'  'output_string\
...         "Socialism is the only system for nationalizing compassion so that
...          individuals may be done with it."'\
...     ZESHY_ALTERNATIVES
>>> :print_function :output_alternative
function :output_alternative() {
    (( # )) && die "Expected no arguments."
    output_string\
        "Political theory founded on the observation that since few men are
         wise enough to rule themselves, even fewer are wise enough to rule
         others."'
}
>>> :output_alternative
Political theory founded on the observation that since few men are
wise enough to rule themselves, even fewer are wise enough to rule
others.
------------------------------------------
==========================================
/---
function :define_function_if_pathable() {
    # Validate sanity.
    die_unless_args_6_or_more\
        'Expected one function name, one function body prefix, one function body suffix, one or more pairs of one command name and one function body, and one pathables list name.'
    :string\
        function_name__dfip="${1}"\
        function_body_prefix__dfip="${2}"\
        function_body_suffix__dfip="${3}"\
        list_name_pathables__dfip="${@[-1]}"
    :map command_name_to_function_body__dfip

    # If such list is not, throw an exception.
    is "${(tP)list_name_pathables__dfip-}" == 'array'* si or die\
         '${'${list_name_pathables__dfip}'} undefined or not a list.'

    # Remove such arguments from the argument list. All remaining arguments
    # constitute the map from command name to function body.
    shift_args_3
    pop_arg

    # If the number of remaining arguments is *NOT* even and hence does *NOT*
    # constitute a map, throw an exception.
    (( # % 2 == 0 )) or die 'Expected even number of arguments.'

    # Convert all remaining arguments to such map.
    command_name_to_function_body__dfip=( "${@}" )

    # For each command in the passed list of command alternatives, test if such
    # command exists and, if so, define such function with such command.
    :bool is_pathable__dfip
    :string command_name__dfip
    for     command_name__dfip ("${(@P)list_name_pathables__dfip}") {
        # If such map contains no such command, throw an exception.
        (( ${+command_name_to_function_body__dfip[${command_name__dfip}]} )) or die\
            'Command-dependent function '${function_name__dfip}'() command "'${command_name__dfip}'" unimplemented.'

        # If such command contains whitespace, assume such command to be a
        # conditional testing the existence of two or more commands. To do so,
        # programmatically convert such string into a true zsh test (e.g., from
        # "catabolic and collapse" to
        # "(( ${+commands[catabolic]} )) && (( ${+commands[collapse]} ))").
        if is "${command_name__dfip}" == *' '* si {
            # To permit map lookups below, preserve the original command string
            # by performing modifications on this local copy.
            :string test__dfip="${command_name__dfip}"

            # If such conditional contains inherently dangerous shell-reserved
            # characters, throw an exception. This includes "`", the obsoleted
            # command substitution prefix, and "$", both the expansion and new
            # command substitution prefix. While command substitutions are
            # patently unsafe (e.g., "$(rm -rf /)"), expansions also support
            # dynamic evaluation of arbitrary code (e.g.,
            # ":string evil='rm -rf /'; : ${(e)evil}") and hence are little
            # safer. Prohibit both by prohibiting their prefixing characters.
            is "${test__dfip}" != *['$`'*] si or die\
                'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" contains unsafe shell-reserved characters "$" and/or "`".'

            # Globally replace in such conditional (in order):
            #
            # * All space-delimited words "or" and "and" with "||" and "&&".
            #   Since both "or" and "and" are valid shell identifiers, do so
            #   *BEFORE* replacing shell identifier characters.
            # * All longest contiguous substrings of shell identifier characters
            #   (signifying unquoted command names) with a test testing the
            #   existence of such command. While command names can technically
            #   contain arbitrary characters, we currently only support common
            #   command names containing no shell-reserved characters and hence
            #   requiring no quoting or escaping.
            test__dfip="${${${test__dfip// ##or ##/ || }// ##and ##/ && }//(#m)[[:IDENT:]]##/(( \${+commands[${MATCH}]\} ))}"   # hack vim highlighting issues: "}"
            # print "command conditional: ${test__dfip}" 1>&2

            # Skip to the next command unless such test dynamically succeeds.
            # If such test fails, such test was either syntactically invalid
            # *OR* syntactically valid and genuinely failed. Discriminate
            # between the two and, in the former case, throw an exception.
            { eval "${test__dfip}" } silent_stderr: or {
                # Capture such output, ignoring the expected failure.
                :string test_error__dfip; test_error__dfip="$(
                    { eval "${test__dfip}" } to_stdout: or ignore_failure)"

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                is -n "${test_error__dfip}" si or continue

                # Else, such test is syntactically invalid. Convert such
                # nonfatal error into a fatal exception. For readability, strip the
                # prefixing "zsh: " from such error message.
                die 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" invalid:'$'\n'${test_error__dfip#zsh: }
            }
        # Else, such command contains no whitespace. Skip to the next command
        # unless such command is pathable. See is_pathable() for further details.
        } else {
            (( ${+commands[${command_name__dfip}]} )) or continue
        }

        # Since the current iteration did *NOT* continue, such command or
        # commands is pathable. Define such function with such command.
        define_function "${function_name__dfip}" \
"    ${function_body_prefix__dfip}
    ${command_name_to_function_body__dfip[${command_name__dfip}]}
    ${function_body_suffix__dfip}"

        # Cease iteration.
        report_success
    }

    # If no such command exists, avoid defining such function. Do *NOT* report
    # failure and hence induce an exception, as this function is commonly called
    # during digest compilation from the top-level.
    report_success
}

# --------------------( WASTELANDS                         )--------------------
    # If the number of remaining arguments is odd and hence does *NOT*
    # constitute a map, the last such argument is the fallback body. For
    # simplicity, default the current body to such fallback. If at least one
    # such condition succeeds, the iteration below will override such default
    # with the corresponding body.
    # if (( # % 2 == 1 )) {
    #     function_body__dfi="${@[-1]}"
    #     pop_arg
    # }

# >>> :output_disorder
# CYNIC, n. A blackguard whose faulty vision sees things as they are,
# not as they ought to be.

# _or_ to the fallback function body if no such condition succeeds and
# such body was passed, prefixed by the passed *function body prefix* (i.e.,
# arbitrary code to be unconditionally prepended to such body) and suffixed by the
# passed *function body suffix* (i.e., arbitrary code to be unconditionally
# appended to such body). If no such condition succeeds _and_ no fallback function
# body was passed, such function will _not_ be defined: e.g.,

    # If no such condition succeeded *AND* a fallback body was passed, enable
    # such body.
    # if is -z "${function_body__dfi}" and
    #       -n "${function_body_fallback__dfi}" si {
    #     function_body__dfi="${function_body_fallback__dfi}"
    # }
# 
#     pop_arg
# 
#     # If the number of remaining arguments is *NOT* even and hence does *NOT*
#     # constitute a map, throw an exception.
#     (( # % 2 == 0 )) or die\
#         'Expected each test to be paired with a function body.'

    # Remove such arguments from the argument list. All remaining arguments
    # constitute the map from command name to function body.

    # If no such condition succeeded *AND* a fallback body was passed, enable
    # such body.
    # if is -z "${function_body__dfi}" and
    #       -n "${function_body_fallback__dfi}" si {
    #     function_body__dfi="${function_body_fallback__dfi}"
    # }

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                # if is -z "${test_error__dfip}" si {
                #     continue
                # # Else, such test is syntactically invalid. Convert such
                # # nonfatal error into a fatal exception.
                # } else {
                #     # For readability, strip the prefixing "zsh: ".
                #     test_error__dfip="${test_error__dfip#zsh: }"
                #     die 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" failed:'$'\n'${test_error__dfip}
                # }
