#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *caller* (i.e., the runnable calling the current runnable) aliases.
/---

# Avoid calling functions in alias expansions to avoid polluting the call stack.

# ....................{ EXCEPTIONS                         }....................
declare_alias_with_stdin\
    'void die_unless_caller(void)'\
    'is_caller or die\
        "No runnable called the current runnable (e.g., due to being called directly from the command line)."' <<'/---'
Throw an exception with a stock message if the current runnable was called
directly from the command line (i.e., unless such runnable was called by another
runnable). See is_caller() for further details.
/---

declare_alias_with_stdin\
    'void die_unless_caller_equals(string caller_name)'\
    '{
        string caller_name__duce="$(get_stdin)"
        is_caller_equals "${caller_name__duce}" or die\
            "Caller \"$(get_caller)\" not \"${caller_name__duce}\"."
    } <<<' <<'/---'
 <<'/---'
Throw an exception with the passed message unless the name of the caller's
caller is the passed name. See is_caller_equals() for further details.
/---

# ....................{ TESTERS                            }....................
declare_alias_with_stdin '[status: boolean] is_caller(void)'\
    '(( ${#funcstack} >= 2 ))' <<'/---'
Report success if the current runnable was _not_ called directly from the
command line (i.e., if such runnable was called by another runnable): e.g.,

.is_caller()
==========================================
[source]
------------------------------------------
>>> string on_defeat_in_detail=\
...    "It's our differences. That's all the media and the politicians are ever
...     talking about – the things that separate us, things that make us
...     different from one another. That's the way the ruling class operates in
...     any society. They try to divide the rest of the people. They keep the
...     lower and the middle classes fighting with each other so that they, the
...     rich, can run off with all the fucking money. Fairly simple thing.
...     Happens to work. You know? Anything different – that's what they're
...     gonna talk about – race, religion, ethnic and national background, jobs,
...     income, education, social status, sexuality, anything they can do to
...     keep us fighting with each other, so that they can keep going to the
...     bank. You know how I define the economic and social classes in this
...     country? The upper class keeps all of the money, pays none of the taxes.
...     The middle class pays all of the taxes, does all of the work. The poor
...     are there just to scare the shit out of the middle class. Keep 'em
...     showing up at those jobs."
>>> is_caller or get_string_line "${on_defeat_in_detail}" -1
showing up at those jobs.
------------------------------------------
==========================================
/---

#FIXME: Add examples.
declare_alias_with_stdin\
    '[status: boolean] is_caller_equals(string caller_name)'\
    '{
        die_unless_caller
        is "$(get_caller)" == "$(get_stdin)" si
    } <<<' <<'/---'
Report success if the caller's name equals the passed string. See get_caller()
for further details on such name.
/---

# ....................{ GETTERS                            }....................
declare_alias_with_stdin 'string get_caller(void)' '{
    die_unless_caller
    output_string "${funcstack[2]}"
}' <<'/---'
Get the name of the *caller* (i.e., runnable calling the current runnable) if
the current runnable was called by another runnable or throw an exception
otherwise. If such caller was:

* A `zeshy` function, this is such function's name.
* A `zeshy` script, this is the absolute _or_ relative path such script was
  originally run as.
* An evaluation, this is `(eval)`.

This alias is intended to be expanded from command substitutions: e.g.,

.get_caller()
==========================================
[source]
------------------------------------------
>>> string on_going_away=\
...    "The planet isn't going anywhere. We are. We're going away. Pack your
...     shit, folks. We're going away and we won't leave much of a trace,
...     either. Thank God for that. Maybe a little styrofoam. The planet'll be
...     here and we'll be long gone. Just another failed mutation. Just another
...     closed-end biological mistake, an evolutionary cul-de-sac. The planet'll
...     shake us off like a bad case of fleas, a surface nuisance."
>>> function "${on_going_away}" () { on_the_big_electron }
>>> function on_the_big_electron() { get_string_line "$(get_caller)" 1 }
>>> "${on_going_away}"
The planet isn't going anywhere. We are. We're going away. Pack your
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
# ....................{ EXCEPTIONS                         }....................
# While function implementations are complicated by needing to avoid modifying
# the call stack under examination, reimplementing such functions as aliases
# introduces worse issues (e.g., inability to pass optional exception messages).

#declare_function_with_stdin <<'/---'
#void die_unless_caller(
#    string error_message =
#        "No runnable called the current runnable (e.g., due to being called directly from the command line).")
#
#Throw an exception with the passed message unless this function's caller was
#itself called by a runnable. See is_caller() for further details.
#/---
#function die_unless_caller() {
#    # Validate sanity.
#    die_unless_args_0_to_1 'Expected optional error message.'
#
#    # Test such name. To avoid modifying the call stack, inline such
#    # implementation. See is_caller() for further details.
#    (( ${#funcstack} >= 3 )) or
#        die "${2:-No runnable called the current runnable (e.g., due to being called directly from the command line).}"
#}
#
#declare_function_with_stdin <<'/---'
#void die_unless_caller_equals(
#    string caller_name,
#    string error_message = "\"${caller_name}\" not this runnable\'s caller.")
#
#Throw an exception with the passed message unless the name of the caller's
#caller is the passed name. See is_caller_equals() for further details.
#/---
#function die_unless_caller_equals() {
#    # Validate sanity.
#    die_unless_args_1_to_2\
#        'Expected one caller name and optional error message.'
#    string caller_name="${1}"
#
#    # Test such name. To avoid modifying the call stack, inline such
#    # implementation. See is_caller_equals() for further details.
#    (( ${#funcstack} >= 3 )) and is "${funcstack[3]}" == "${caller_name}" si or
#        die "${2:-Caller \"${caller_name}\" not \"${caller_name}\" not this runnable\'s caller.}"
#}
#
## ....................{ TESTERS                            }....................
#declare_function_with_stdin <<'/---'
#[status: boolean] is_caller(void)
#
#Return success if this function's caller was itself called by a runnable. Hence,
#return success if neither this function or this function's caller was called
#directly from the command line: e.g.,
#
#.is_caller()
#==========================================
#[source]
#------------------------------------------
#>>> string on_defeat_in_detail=\
#...    "It's our differences. That's all the media and the politicians are ever
#...     talking about – the things that separate us, things that make us
#...     different from one another. That's the way the ruling class operates in
#...     any society. They try to divide the rest of the people. They keep the
#...     lower and the middle classes fighting with each other so that they, the
#...     rich, can run off with all the fucking money. Fairly simple thing.
#...     Happens to work. You know? Anything different – that's what they're
#...     gonna talk about – race, religion, ethnic and national background, jobs,
#...     income, education, social status, sexuality, anything they can do to
#...     keep us fighting with each other, so that they can keep going to the
#...     bank. You know how I define the economic and social classes in this
#...     country? The upper class keeps all of the money, pays none of the taxes.
#...     The middle class pays all of the taxes, does all of the work. The poor
#...     are there just to scare the shit out of the middle class. Keep 'em
#...     showing up at those jobs."
#>>> is_caller or get_string_line "${on_defeat_in_detail}" -1
#showing up at those jobs.
#------------------------------------------
#==========================================
#/---
#function is_caller() {
#    # ${funcstack[1]} is always "is_caller", ${funcstack[2]} the name of the
#    # function or script calling this function, and ${funcstack[3]} that of the
#    # function or script calling the function or script calling this function
#    # (i.e., the desired caller), if such function or script exists. Test for
#    # the latter. Avoid calling get_list_size(), which increments the size of
#    # such stack.
#    die_if_args
#    (( ${#funcstack} >= 3 ))
#}
#
#declare_function_with_stdin <<'/---'
#[status: boolean] is_caller_equals(string caller_name)
#
#Return success if the name of the *caller's caller* (i.e., the function or
#script calling the function or script calling this function) is equal to the
#passed name.
#/---
#function is_caller_equals() {
#    # Validate sanity.
#    die_unless_arg 'Expected one caller name.'
#    string caller_name="${1}"
#    die_unless_caller
#
#    # Test such name. Avoid calling is_caller(), get_caller(), or
#    # is_string_equals().
#    (( ${#funcstack} >= 3 )) and is "${funcstack[3]}" == "${caller_name}" si
#}
#
## ....................{ GETTERS                            }....................
##FUXME: Rename to simply get_caller().
#declare_function_with_stdin <<'/---'
#[status: boolean] get_caller(void)
#
#Get the name of the *caller's caller* (i.e., the function or script calling the
#function or script calling this function). If no such function or script exists,
#this function was called directly from the command line or by a function or
#script called directly from the command line, in which case an exception is
#thrown.
#
#Interestingly, this function returns the correct name when called from a
#subshell capturing output by process substitution: e.g.,
#
#.get_caller()
#==========================================
#[source]
#------------------------------------------
#>>> string on_going_away=\
#...    "The planet isn't going anywhere. We are. We're going away. Pack your
#...     shit, folks. We're going away and we won't leave much of a trace,
#...     either. Thank God for that. Maybe a little styrofoam. The planet'll be
#...     here and we'll be long gone. Just another failed mutation. Just another
#...     closed-end biological mistake, an evolutionary cul-de-sac. The planet'll
#...     shake us off like a bad case of fleas, a surface nuisance."
#>>> function "${on_going_away}" () { on_the_big_electron }
#>>> function on_the_big_electron() { get_string_line "$(get_caller)" 1 }
#>>> "${on_going_away}"
#The planet isn't going anywhere. We are. We're going away. Pack your
#------------------------------------------
#==========================================
#/---
#function get_caller() {
#    # Validate sanity. Avoid calling die_unless_caller(), for obvious reasons.
#    die_if_args
#    (( ${#funcstack} >= 3 )) or
#        die 'no caller (due to being called directly from the command line)'
#
#    # Get such name.
#    return_string "${funcstack[3]}"
#}

#FUXME: This is insanity. While such runnables *CAN* be implemented as
#functions, that is cleary the wrong approach. Reimplement as aliases and
#briefly discuss why.
#if the current call stack contains at least one function or
#script, excluding the current call to this function and this function's caller.
#This function returns success unless called directly from the command line _or_
#by a function or script called directly from the command line: e.g.,

#>>> function timbered() { choir }
#>>> function choir() { print_string "caller: $(get_caller)()" }
#>>> timbered
#caller: timbered()

#Report success if the *caller's name* (i.e., the function name for functions,
#absolute or relative filename for scripts, and "(eval)" for evaluations) is the
#passed string. See get_caller() for further details on such names.

#Interestingly, this alias returns the correct name when expanded from a subshell
#capturing output by process substitution: e.g.,

#If no such function or script exists,
#this function was called directly from the command line or by a function or
#script called directly from the command line, in which case an exception is
#thrown.
#
#Get the name of the *caller's caller* (i.e., the function or script calling the
#function or script calling this function). If no such function or script exists,
#this function was called directly from the command line or by a function or
#script called directly from the command line, in which case an exception is
#thrown.

#caller of the current runnable was itself called by
#another runnable (i.e., if this function's caller was called directly from the command line: e.g.,
    # Avoid calling die_unless_caller(), for obvious reasons.
#   (( ${#funcstack} >= 3 )) or
#       die 'no caller (due to being called directly from the command line)'

#function is_caller() {
#    # ${funcstack[1]} is always "is_caller", ${funcstack[2]} the name of the
#    # function or script calling this function, and ${funcstack[3]} that of the
#    # function or script calling the function or script calling this function
#    # (i.e., the desired caller), if such function or script exists. Test for
#    # the latter. Avoid calling get_list_size(), which increments the size of
#    # such stack.
#    die_if_args
#    (( ${#funcstack} >= 3 ))
#}

#if the current call stack contains at least one function or
#script, excluding the current call to this function and this function's caller.
#This function returns success unless called directly from the command line _or_
#by a function or script called directly from the command line: e.g.,

#>>> function timbered() { choir }
#>>> function choir() { print_string "caller: $(get_caller)()" }
#>>> timbered
#caller: timbered()
