#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *`zsh` option* (i.e., shell properties set and unset by calling builtins
set(), setopt(), and unseptopt()) aliases.
/---

# ....................{ GETTERS                            }....................
#FIXME: To be of any use, this needs to be a setter rather than getter. As a
#getter, this is typically returning only the enabled options inherited by a
#command substitution subshell.
#FIXME: Rename to :set_string_to_option_state_chars().
#FIXME: Refactor into a function as well. Little point in retaining this is an
#alias. *shakes head*

declare_alias_with_stdin 'string get_shell_options_enabled_as_characters(void)'\
    'output_string ${-}' <<'/---'
Get the subset of all currently enabled `zsh` options to which `zsh` assigns a
unique character (e.g., option `monitor` assigned letter `m`) as an undelimited
string of such characters: e.g.,

.get_shell_options_enabled_as_characters()
==========================================
[source]
------------------------------------------
>>> get_shell_options_enabled_as_characters
4679CEGHJNRXZgikmsu
>>> disable_shell_option monitor
>>> get_shell_options_enabled_as_characters
4679CEGHJNRXZgiksu
------------------------------------------
==========================================
/---

# ....................{ [EN|DIS]ABLERS                     }....................
# To allow shell options specific to the current context to be enabled and
# disabled (e.g., "local_options", "local_patterns", "local_traps"), such
# runnables *MUST* be defined as aliases rather than functions.
#
# Hypothetically speaking, if such runnables were defined as functions, the
# following less efficient implementation would probably suffice:
#
#    function :enable_option() {
#        die_unless_args 'Expected one or more option names.'
#        :string option_name
#        for     option_name ("${@}") {
#            :die_unless_option "${option_name}"
#            options[${option_name}]='on'
#        }
#    }

#FIXME: Add examples.
declare_alias_with_stdin\
    'void :enable_option(string option_name1, ...)'\
    'setopt' <<'/---'
Globally enable all passed `zsh` options in the current shell.
/---

declare_alias_with_stdin\
    'void :disable_option(string option_name1, ...)'\
    'unsetopt' <<'/---'
Globally disable all passed `zsh` options in the current shell.
/---

# ....................{ ENABLERS ~ local                   }....................
#FIXME: The following aliases *MUST* throw exceptions before enabling or
#disabling such options when *NOT* expanded from within a function. Why? Because
#option "local_options" is ignored when not applied within a function, in which
#case such options would erroneously be globally enabled or disabled. How about
#expanding a new alias:
#
#declare_alias_with_stdin 'void die_unless_context_function(void)'\
#   'is_context_function or die\
#       "die_unless_context_function() not expanded within a function."'

declare_alias_with_stdin\
    'void :enable_option_local(string option_name1, ...)'\
    'setopt -- local_options' <<'/---'
Locally enable all passed `zsh` options in the current context (e.g., block,
script, function). Such options revert to their current global values on leaving
such context: e.g.,

.:enable_option_local()
==========================================
[source]
------------------------------------------
>>> function risky_non_business() {
...     :enable_option_local no_warn_create_global
...     a_new_hopelessness="None shall pass."
... }
>>> risky_non_business                    # this does not print a warning!
>>> an_old_cheerfulness="One must fall."  # this does
zsh: scalar parameter an_old_cheerfulness created globally in function
------------------------------------------
==========================================
/---

declare_alias_with_stdin\
    'void :disable_option_local(string option_name1, ...)'\
    'setopt -- local_options
     unsetopt -- ' <<'/---'
Locally disable all passed `zsh` options in the current context (e.g., block,
script, function). Such options revert to their current global values on leaving
such context: e.g.,

.:enable_option_local()
==========================================
[source]
------------------------------------------
>>> function risky_non_business() {
...     :enable_option_local no_warn_create_global
...     a_new_hopelessness="None shall pass."
... }
>>> risky_non_business                      # this does not print a warning!
>>> an_old_cheerfulness="Some shall pass."  # this does
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Remove the "_shell" everywhere below.

# ....................{ TESTERS                            }....................
# Avoid expanding such alias to "is_shell_option_enabled interactive". While
# correct, such expansion is markedly slower than merely testing such option
# directly. This alias is expanded frequently enough to warrant optimization.
#declare_alias_with_stdin '[status: bool] is_shell_interactive(void)'\
#    'is -o interactive si' <<'/---'
#Report success if standard input to the current shell _was_ attached to a
#terminal device on initial execution of such shell. When testing whether
#standard input to the current shell is _currently_ attached to a terminal
#device, consider calling :is_stdin_terminal() instead. Standard input
#to the current shell could have been initially attached to a terminal device
#but since closed, in which case relying on the return value from this function
#would be problematic.
#/---
#
#declare_alias_with_stdin '[status: bool] is_shell_login(void)'\
#    'is -o login si' <<'/---'
#Report success if the first argument passed to the current shell was `-'. The
#startup process running the `login` command typically passes such argument to
#startup shells on successful login.
#/---

#Localize the passed `zsh` options to the current context (e.g., block, script,
#function). Such options revert to their global values on leaving such context:
#e.g.,
