#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *local declarers* (i.e., aliases declaring local variables).
/---

#FIXME: Shift all other non-constant local declarers here.
#FIXME: Move to ={*-start/*-alias/*-core/*-var}.

# ....................{ DECLARERS                          }....................
:alias_command ':void :map(:string... var_names_and_values)'\
    'local -A --' <<'/---'
Locally declare all passed *map variables* (i.e., whose values are non-scalar
unordered collections of key-value pairs of untyped string literals, variously
referred at as *associative arrays*, *hash maps*, and *tables*), initialized to
the empty map: e.g.,

.:map()
==========================================
[source]
------------------------------------------
>>> :map on_slavery; on_slavery=(
...     "When"     "the entirety of your earnings are exhausted on food and"
...     "shelter," "your labors are no longer viewed as an opportunity for"
...     "economic" "advancement but rather as an act of self-preservation. In"
...     "the"      "real world, that's called slavery."
... )
>>> :string.output "${on_slavery[the]}"
real world, that's called slavery.
------------------------------------------
==========================================

== Caveats ==

All caveats applicable to lists also apply to maps. At declaration time, map
variables _cannot_ be initialized, exported, or declared read-only. See
:list().

=== Circumvention ====

While export constraints on list variables are circumventable by declaring such
variables via :string,list_tied_on_char_global_export(), there exists no
corresponding :string,map_tied_on_char_global_export(). Yet, a similar (if
heavier) solution applies to maps as well. In the script to be sourced, export
strings explicitly converted from the maps to be exported as follows:

.Exporting Maps as Strings
==========================================
[source]
------------------------------------------
>>> :map on_rapacity; on_rapacity=(
...    "Where" "hunters and woodcutters once slept in their boots by the dying"
...    "light" "of their thousand fires and went on, old teutonic forebears"
...    "with"  "eyes incandesced by the visionary light of a massive rapacity,"
...    "wave"  "on wave of the violent and the insane, their brains stoked with"
...    "spoorless" "analogues of all that was, lean aryans with their abrogate"
...    "semitic"   "chapbook reenacting the dramas and parables therein and"
...    "mindless"  "and pale with a longing that nothing save dark's total"
...    "restitution" "could appease." )
>>> :string_global_export ON_RESTITUTION
>>> :map.join_to_string_on_separator on_rapacity ON_RESTITUTION ':'
------------------------------------------
==========================================

In the parent shell or script sourcing the prior script, manually convert such
imported string back into the original map as follows:

.Importing Maps as Strings
==========================================
[source]
------------------------------------------
>>> :map on_rapacity
>>> :map.split_from_string_on_separator on_rapacity "${ON_RESTITUTION}" ':'
>>> :string.output "${on_rapacity[Where]}"
hunters and woodcutters once slept in their boots by the dying
------------------------------------------
==========================================
/---

# For readability, "string" is intentionally *NOT* abbreviated to "str". As an
# ad-hoc heuristic, all zeshy primitives must contain at least one vowel --
# which "str" clearly does not. Interestingly, all other canonical primitive
# type abbreviations adhere to such heuristic (e.g., "bool", "char", "int").

:alias_command ':void :string(:string... var_names_and_values)'\
    'local --' <<'/---'
Locally declare all passed *string variables* (i.e., whose values are any
single- or double-quoted string, integer, or float), initialized to the
`=`-prefixed value suffixing each if any or the empty string otherwise.
/---

# ....................{ DECLARERS ~ float                  }....................
# While zsh already provides builtin float() for declaring local floats, such
# builtin expands to "typeset -E" (i.e., scientific notation) rather than
# "typeset -F" (i.e., decimal notation). Given the prevalence of the latter and
# relative obscurity of the former, this seems a curious if lamentable choice.

:alias_command ':void :float(:string... var_names_and_values)'\
    'local -F --' <<'/---'
Locally declare all passed *float variables* (i.e., whose values are fractional
numbers) coerced to 10 fractional digits on parameter expansion, initialized to
the `=`-prefixed value suffixing each if any or 0.0 otherwise. See
:float_of_fractional_digit_count().
/---

:alias_command ':void :float_of_fractional_digit_count(
    :int fractional_length = 10, :string... var_names_and_values)'\
    'local -F' <<'/---'
Locally declare all passed float variables coerced to the passed number of
fractional digits on parameter expansion, initialized to the `=`-prefixed value
suffixing each if any or 0.0 otherwise: e.g.,

.:float_of_fractional_digit_count()
==========================================
[source]
------------------------------------------
>>> :float_of_fractional_digit_count 3 prouhet_thue_morse=0.412154033640 zero=0
>>> :string.output "${prouhet_thue_morse}" $(( prouhet_thue_morse ** 2 ))
0.412 0.16987094744572223
>>> :string.output "${zero}" $(( zero ** 2 ))
0.000 1.
------------------------------------------
==========================================

== Parameter Expansion ==

On parameter expansion, each such variable will be coerced as follows:

* If the number of fractional digits in such expansion equals the passed number
  of fractional digits, the former will remain unchanged (e.g., preserving
  6.626 if such number is 3).
* If the number of fractional digits in such expansion is greater than the
  passed number of fractional digits, the former will be truncated to such
  number (e.g., truncating 6.62606957 to 6.626 if such number is 3).
* Else, the number of fractional digits in such expansion is less than the
  passed number of fractional digits. In such case, the former will be padded
  to such number with sufficiently many rightmost zeros (e.g., padding 6.6 to
  6.600 if such number is 3).

== Arithmetic Expansion and Tests ==

As the prior example demonstrates, such coercion applies to neither *arithmetic
expansion* (i.e., `$((`- and `))`-delimited expressions) nor *arithmetic tests*
(i.e., `((`- and `))`-delimited expressions). Internally, such variables thus
retain full precision.
/---

:alias_command ':void :float_of_significant_figure_count(
    :int length = 10, :string... var_names_and_values)'\
    'local -E' <<'/---'
Locally declare all passed float variables converted to scientific notation
(with significand coerced to the passed number of significant figures) on
parameter expansion, initialized to the `=`-prefixed value suffixing each if
any or 0.0 otherwise: e.g.,

.:float_of_significant_figure_count()
==========================================
[source]
------------------------------------------
>>> :float_of_significant_figure_count 3 gelfond=22.140692632779269 one=1.0
>>> :string.output "${gelfond}" $(( sqrt(gelfond) ))
2.21e+01 4.7053897426249405
>>> :string.output "${one}" $(( sqrt(one) ))
1.00e+00 1.
------------------------------------------
==========================================

== Parameter Expansion ==

On parameter expansion, each such variable will be converted from a float to a
human-readable string in `zsh`-specific scientific notation.

=== Scientific Notation ===

The string each such variable expands to will be formatted as follows:

* If such variable is 0.0, such string will be formatted as `0.0000000000e+00`
  (assuming a default of 10 significant figures).
* If such variable is in `(0.0, 1.0)` (i.e., between 0.0 and 1.0 non-
  inclusive), such string will be formatted as `${significand}e-${exponent}`,
  where:
** `(( variable == significand * (10 ** -exponent) ))`.
** `${significand}` is the *significand* satisfying the above equation, coerced
   to the passed number of significant figures (as
   <<:float_of_significant_figure_count.count,detailed below>>).
** `${exponent}` is the two-digit *exponent* satisfying the above equation.
* Else, such variable is _not_ in `[0.0, 1.0)`. In such case, such string will
  be formatted as `${significand}e+${exponent}`, where:
** `(( variable == significand * (10 ** exponent) ))`.

[[:float_of_significant_figure_count.count]]
=== Significant Figures ===

The number of significant figures each such variable expands to will be coerced
as follows:

* If the number of significant figures in such expansion equals the passed number
  of significant figures, the former will remain unchanged (e.g., preserving
  1.41 as `1.41e+00` if such number is 3).
* If the number of significant figures in such expansion is greater than the
  passed number of significant figures, the former will be truncated to such
  number (e.g., truncating 1.41421356237309 to `1.41e+00` if such number is 3).
* Else, the number of significant figures in such expansion is less than the
  passed number of significant figures. In such case, the former will be padded
  to such number with sufficiently many rightmost zeros (e.g., padding 1.4 to
  `1.400e+00` if such number is 3).

== Arithmetic Expansion and Tests ==

As the prior example demonstrates, such coercion applies to neither *arithmetic
expansion* (i.e., `$((`- and `))`-delimited expressions) nor *arithmetic tests*
(i.e., `((`- and `))`-delimited expressions). Internally, such variables thus
retain full precision.
/---

# ....................{ DECLARERS ~ int                    }....................
:alias_command ':void :int(:string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *integer variables* (i.e., whose values are non-
fractional numbers), initialized to the `=`-prefixed value suffixing each if
any or 0 otherwise.
/---

# Curiously, zsh type "integer" does *NOT* suffice here.
:alias_command ':void :int_of_base(
    :int base, :string... var_names_and_values)'\
    'local -i'  <<'/---'
Locally declare all passed integers variables in the passed base, initialized
to the `=`-prefixed value suffixing each if any or 0 otherwise: e.g.,

.:int_of_base()
==========================================
[source]
------------------------------------------
>>> :int_of_base 16 factory_farming=4277009102
>>> :string.output "${factory_farming}"
0xFEEDFACE
------------------------------------------
==========================================

== Usage ==

On expansion, such integers will be implicitly converted to the equivalent
values in such base. Additionally, if such base is:

* `8`, such integers will be pretty printed in *octal format* and hence:
** Prefixed with a C-style `0`.
* `16`, such integers will be pretty printed in *hexadecimal format* and hence:
** Prefixed with a C-style `0x`.
** Digits in the range [10, 15] will be printed as capitalized letters in the
   range [A, F], per tradition.
/---

# ....................{ DECLARERS ~ list                   }....................
:alias_command ':void :list(:string... var_names_and_values)'\
    'local -a --' <<'/---'
Locally declare all passed *list variables* (i.e., whose values are non-scalar
ordered collections of untyped string literals, commonly referred at as
*arrays*), initialized to the empty list: e.g.,

.:list()
==========================================
[source]
------------------------------------------
>>> :list on_complicity; on_complicity=(
...     "It is the fundamental duty of the citizen to resist and to restrain"
...     "the violence of the state. Those who choose to disregard this"
...     "responsibility can justly be accused of complicity in war crimes,"
...     "which is itself designated as 'a crime under international law' in"
...     "the principles of the Charter of Nuremberg."
... )
>>> :string.output "${on_complicity[1]}"
It is the fundamental duty of the citizen to resist and to restrain
------------------------------------------
==========================================

== Caveats ==

Due to inadequacies in `zsh`, `zeshy`, and the UNIX shell environment,
declaration of *nonscalar variables* (i.e., lists, maps) is somewhat more
constrained than that of *scalar variables* (i.e., floats, integers, strings).
Specifically, at declaration time, nonscalar variables _cannot_ be:

* Initialized (e.g., `:list on_limits=( Any number is a limit )`), directly implying the next constraint.
* Declared read-only (e.g., `:list -r on_limits=( and perfection doesn\'t have limits. )`). 
* Exported (e.g., `:list -x on_limits=( Perfect speed, my son, is being there. )`).

=== Export Constraints ===

Due to prehistoric inadequacies in the UNIX shell environment, nonscalar
variables cannot be exported to such environment and hence cannot be imported
by either parent shells or scripts sourcing the current script _or_ by children
scripts run by the current shell or script. Oddly, the export() builtin
silently accepts nonscalar types without error by silently ignoring the implied
`typeset` option `-x`. Since this is demonstrably unhelpful, we provide _no_
*nonscalar exporters* (i.e., hypothetical functions :list_global_export() or
:map_global_export()).

With some effort, however, this constraint can be reliably circumvented.

==== Circumvention ====

:string,list_tied_on_char_global_export() globally declares both an exported
string _and_ unexported list variable, each of whose values are implicitly
``tied'' together. Since modifying one modifies the other, lists tied in such
fashion are referred to as *string-tied lists.*

A parent shell or script may losslessly import one or more lists defined within
a child script by leveraging string-tied lists, as follows (in order):

. Declare each such list in such child script with
  :string,list_tied_on_char_global_export().
. Declare each such list in such parent shell or script with any variant of
  :string,list_tied_on_char() (e.g., including
  :string,list_tied_on_char_global_export() if desired) with the same string
  variable names such child script originally passed to
  :string,list_tied_on_char_global_export(). Since lists are unexportable, list
  variable names may differ between such child and parent shell or script.
. Source such child script from such parent shell or script _after_ declaring
  such lists in such parent shell or script. By `zsh` design, such declarations
  erase all prior contents of such list and string variables.

While robust, the efficiency of such approach is a function of the size of such
lists and hence strings. See such aliases for further details.
/---

:alias_command ':void :string,list_tied_on_char(
    :string string_name_and_value,
    :string list_name,
    :char separator = ":")'\
    'typeset -T --' <<'/---'
Locally declare the passed string and list variables ``tied'' on the passed
separating character (defaulting to `:`), overwriting any prior values for
either variables if previously declared. If such string variable's name is
suffixed by a `=`-prefixed value (as below), such string is initialized to such
value and such list to such value split on such separator; else, such string is
initialized to the empty string and such list to the empty list: e.g.,

.:string,list_tied_on_char()
==========================================
[source]
------------------------------------------
>>> :string,list_tied_on_char\
...     ON_WILDNESS="In wildness is the preservation of the world."\
...     on_wildness ' '
>>> :string.output "${on_wildness[2]}" "${on_wildness[5]}" "${on_wildness[8]}"
wildness preservation world
>>> on_wildness=( Let us consider the way in which we spend our lives. )
>>> :string.output "${ON_WILDNESS}"
Let us consider the way in which we spend our lives.
------------------------------------------
==========================================

== Synchronization ==

After declaration, the values of such variables are implicitly synchronized.
Setting or appending such string sets such list to the result of splitting such
string on such separator. Likewise, setting or appending such list sets such
string to the result of concatenating such list items on such separator.

== Caveats ==

Callers should take precautions to ensure that list elements _not_ contain the
passed separating character. `zsh` silently fails to escape such characters in
such elements _and_ fails to ignore such characters when explicitly escaped in
such elements, corrupting the value of the tied string: e.g.,

.:string,list_tied_on_char()
==========================================
[source]
------------------------------------------
>>> :string,list_tied_on_char ON_HEAVEN on_heaven ':'
>>> on_heaven=( "/heaven/i:s/home" "/utopia/i:s/here" "/nirvana/is/now." )
>>> :string.output "${ON_HEAVEN}"
/heaven/i:s/home:/utopia/i:s/here:/nirvana/is/now.
>>> :string,list_tied_on_char\
...     ON_HEAVEN='/heaven/i\:s/home:/utopia/i\:s/here:/nirvana/is/now.'\
...     on_heaven ':'
>>> :string.output "${on_heaven[1]}\n${on_heaven[2]}\n${on_heaven[3]}"
/heaven/i\
s/home
/utopia/i\
------------------------------------------
==========================================
/---

# ....................{ DECLARERS ~ listset                }....................
#FIXME: Define equivalent :string,listset_tied_on_char() declarers.  As
#={compile} demonstrates, "typeset -TU --" actually works (i.e., the "-U"
#properly applies to the list but not string).

:alias_command ':void :listset(:string... var_names_and_values)'\
    'typeset -aU --'  <<'/---'
Locally declare all passed *listset variables* (i.e., whose values are
non-scalar ordered collections of untyped, unique string literals, commonly
referred at as *ordered sets*), initialized to the empty list: e.g.,

.:listset()
==========================================
[source]
------------------------------------------
>>> :listset on_commodities; on_commodities=(
...     "What we kids didn't understand was that we were living in a
...     "commercial, commodity culture. Everything in our environment had been"
...     "bought and sold. As middle class Americans, we basically grew up on a"
...     "movie set. The conscious values that are pushed are only part of the"
...     "picture. The medium itself plays a much bigger part than anyone"
...     "realizes: the creation of illusion. We are living surrounded by"
...     "illusion, by professionally created fairy tales. We barely have"
...     "contact with the real world."
...     "contact with the real world."
... )
>>> :string.output "${on_commodities[-2]}"
illusion, by professionally created fairy tales. We barely have
>>> on_commodities[1]+=( "contact with the real world." )
>>> :string.output "${on_commodities[2]}"
commercial, commodity culture. Everything in our environment had been
------------------------------------------
==========================================

== Uniqueness ==

Listsets are lists implicitly ignoring duplicate list items, guaranteeing all
listset items to be unique within such listsets. Specifically, listsets ignore:

* Attempts to add duplicate items to existing listsets.
* Duplicate items in definitions of new listsets.

== Caveats ==

All caveats applicable to lists also apply to listsets. At declaration time,
listset variables _cannot_ be initialized, exported, or declared read-only. See
:list().
/---

# ....................{ DECLARERS ~ sub                    }....................
# While zsh currently lacks builtin support for boolean types, such types are
# readily implementable with either:
#
# * Integer types. Mapping boolean false to integer 0 and boolean true to
#   integer 1 yields both an efficient representation and means of testing
#   boolean truth: e.g.,
#
#    >>> integer is_television_truth
#    >>> (( is_television_truth )) or
#    ...     :string.output "You do whatever the tube tells you."
#    "You do whatever the tube tells you."
#
# * String types. Mapping boolean false to the empty string and boolean true to
#   any nonempty string yields a slightly less efficient representation and means
#   of testing boolean truth: e.g.,
#
#    >>> string is_television_reality
#    >>> is -n "${is_television_reality}" or
#    ...     :string.output "You even think like the tube."
#
# Since testing for integer zeroness is more efficient than testing for string
# emptiness *AND* since integers are already constrained to integral values
# containing customary boolean values 0 and 1, zeshy adopts integers rather
# than strings for its boolean implementation.

:alias_command ':void :bool(:string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *boolean variables* (i.e., whose values are either
${true} or ${false}), initialized to the `=`-prefixed value suffixing each if
any or ${false} otherwise: e.g.,

==========================================
[source]
------------------------------------------
>>> :bool is_television_truth
>>> (( is_television_truth )) :or get_string_line\
... "Television is not the truth. Television's a god-damned amusement park.
...  Television is a circus, a carnival, a traveling troupe of acrobats,
...  storytellers, dancers, singers, jugglers, sideshow freaks, lion tamers,
...  and football players. We're in the boredom-killing business. So if you
...  want the Truth, go to God! Go to your gurus. Go to yourselves! Because
...  that's the only place you're ever gonna find any real truth. But, man,
...  you're never gonna get any truth from us. We'll tell you anything you
...  wanna hear. We lie like hell. We'll tell you that Kojak always gets the
...  killer and that nobody ever gets cancer at Archie Bunker's house. And no
...  matter how much trouble the hero is in, don't worry. Just look at your
...  watch. At the end of the hour, he's gonna win. We'll tell you any shit
...  you want to hear." 1
Television is not the truth. Television's a god-damned amusement park.
------------------------------------------
==========================================

== Caveats ==

Due to `zsh` constraints and as in numerous other languages (e.g., Perl, C, C++,
Objective-C), *booleans are indistinguishable from integers.* Specifically,
integer 0 signifies boolean false and all nonzero integers (e.g., 1, -1) boolean
true. Since explicitly declaring booleans as such improves clarity, (possible)
forwards compatibility, and symmetry with existing types, consider declaring
booleans as such rather than as integers.
/---

#FIXME: Add example.
:alias_command ':void :char(:string... var_names_and_values)'\
    'local --' <<'/---'
Locally declare all passed *character variables* (i.e., whose values are
strings of length 1), initialized to the `=`-prefixed value suffixing each if
any or the empty string otherwise.

== Caveats ==

By `zsh` constraints and as in various other languages (e.g., JavaScript,
Python), *characters are indistinguishable from strings.* Since explicitly
declaring characters as such improves clarity, forwards compatibility, and
symmetry with existing types, consider explicitly declaring characters as such.
/---

:alias_command ':void :file_descriptor(
    :string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *file descriptor variables* (i.e., whose values are
non-negative integers uniquely identifying currently open files), initialized
to the `=`-prefixed value suffixing each if any or 0 (i.e., the canonical file
descriptor for standard input) otherwise.
/---

# --------------------( WASTELANDS                         )--------------------
# Listsets implicitly ignore attempts to add
# items already in such listsets.
#  meaningless if even a
# single list element contains a single such character

#  (e.g.,
# `:string,list_tied_on_char ON_LAW='True law is right reason in agreement with nature.' on_law ':'`)

# initialized to the `=`-prefixed value
# suffixing such string if any or to the empty string and empty list otherwise.
# 
#  Such string is initialized to the 
# 
# by such
# declaration with the customary `=`-delimited initialization, such list is also
# implicitly defined by such declaration to coincide with such string; else, such
# string is initialized to the empty string and such list to the empty list.
# 
# initialized to the `=`-prefixed value suffixing each if
# any or 0 otherwise.

# . Declare such lists in both the parent shells and scripts _and_ child scripts
# 
# to be exported to parent shells and scripts
# 
# String-tied lists declared in one script are losslessly importable into another
# script or shell as follows:
# 
# by redeclaring such lists in the latter , declare the same string-tied lists as the
# former, such lists will be restored in the latter on sourcing the former.
# Specifically, the sourcing script or shell _must_ call
# :string,list_tied_on_char() or some variant thereof (e.g.,
# :string,list_tied_on_char_global_export()) with the same string variable names
# as the former originally passed to :string,list_tied_on_char_global_export().
# Since lists cannot be exported, the list names each declares may differ.

# == Caveats ==
# 
# Due to current inadequacies in both `zsh` and `zeshy`, all non-scalar variables
# and hence map variables are only initializable _after_ declaring such variables.

# * Declaring the same string-tied lists in both the former and latter.
#   Specifically, the sourcing script or shell _must_ call
#   :string,list_tied_on_char() or some variant thereof (e.g.,
#   :string,list_tied_on_char_global_export()) with the same string names as
#   the sourced script originally passed to
#   :string,list_tied_on_char_global_export().
# * Sourcing th
# 
# If a script declares string-tied lists. Any
# parent shell or script may losslessly import the same lists by (in any order):
# 
# Consider a source script declaring one or more lists tied in such fashion. Any
# parent shell or script may losslessly import the same lists by:
# 
# * 
# sourcing such script may losslessly import such lists by passing the same :string,list_tied_on_char_global_export() with the same
# string and list names
# 
# Suppose a script declares one or more lists tied in such fashion.
# 
# Parent shells and scripts sourcing a script may losslessly import such lists by :string,list_tied_on_char_global_export() with the same
# string and list names
# 
# Such list is 
# 
# Parent shells and scripts sourcing scripts declaring lists
# tied in such fashion thus import the string tied to such list, which may 
# 
# If the parent shell or script
# then expands :string,list_tied_on_char_global_export() with the same
# string and list names, the desired list from the sourced script will be
# successfully imported into the parent shell or script. Since `zsh` internally
# manages such importation, this approach should be reasonably efficient. See such
# alias for further details.
# 
# will
# successfully import the string tied to such list
# 
# If the script to be sourced declares the list to be exported
# via such alias, the parent shell or script sourcing the former script will
# successfully import the string tied to such list.
# 
# If the parent shell or script
# then expands :string,list_tied_on_char_global_export() with the same
# string and list names, the desired list from the sourced script will be
# successfully imported into the parent shell or script. Since `zsh` internally
# manages such importation, this approach should be reasonably efficient. See such
# alias for further details.

# While *scalar variables* (i.e., floats, integers, strings) are relatively
# unconstrained, *nonscalar variables* (i.e., lists, maps) are constrained by 
# following declaration-time limitations:
# 
# * nonscalar variables are neither
# initializable nor declarable to be read-only at declaration timeNon
# 
# Due to current inadequacies in `zsh`, nonscalar variables are neither
# initializable nor declarable to be read-only at declaration time.

# === Initialization and Type Constraints ==

# Let `${f}` be such a float. If:
# 
# * `(( f == 0 ))`, such notation formats `${f}` as `0.0000000000e+00` (assuming
#   10 significant figures).
# * `(( f > 0 ))`, such notation formats `${f}` as `${a}e+${b}`, where `${a}` is
#   the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
#   exponent such that `(( f == A * 10 ** b ))`.
# * `(( f < 0 ))`, such notation formats `${f}` as `${a}e-${b}`, where `${a}` is
#   the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
#   exponent such that `(( f == A * 10 ** -b ))`.
#
# Since this does _not_ apply to arithmetic expansion, such floats internally
# retain all data for subsequent calculation.

# Curiously, builtin float() does *NOT* suffice here.

# == Global Declarers ==

# non-numeric scalar
# variables
# :alias_command\
#     ':void string_constant_global(:string var_name1, ...)'\
#     'typeset -gr --' <<'/---'
# Declare the passed string constants globally _not_ exported to the calling
# shell, defined to the following `=`-delimited string if specified or to the
# empty string otherwise. Attempting to subsequently redefine such constant throws
# an exception.
# /---
# 
# :alias_command\
#     ':void string_constant_global_export(:string var_name1, ...)'\
#     'export -r --' <<'/---'
# Declare the passed string constants globally exported to the calling shell. See
# string_constant_global() for further details.
# /---

# :alias_command ':void string_global(:string var_name1, ...)'\
#     'typeset -g --' <<'/---'
# Declare the passed strings globally _not_ exported to the calling shell. See
# :string() for further details.
# /---
# 
# :alias_command\
#     ':void string_global_export(string var_name1, ...)'\
#     'export --' <<'/---'
# Declare the passed strings globally exported to the calling shell. See :string()
# for further details.
# /---

#FUXME: Excise everywhere in favor of :string().
# :alias_command ':void string(:string var_name1, ...)'\
#     'local --' <<'/---'
# Declare
# /---
