#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *argument option setters* (i.e., functions setting variables
corresponding to `-`-prefixed arguments passed to functions and scripts).
/---

# ....................{ ALIASES                            }....................
# Declare aliases for corresponding functions declared below *BEFORE* defining
# such functions, ensuring such aliases exist at function definition time. Do
# so only for the subset of such functions incestuously calling each other.
:alias_simple set_integer_to_arg_index_first_equaling_item='set_integer_to_arg_index_first_equaling_item "${@}"'
:alias_simple set_integer_to_arg_option_index_last='set_integer_to_arg_option_index_last "${@}"'
:alias_simple set_integer_to_arg_nonoption_count='set_integer_to_arg_nonoption_count "${@}"'
:alias_simple set_integer_to_arg_nonoption_index_first='set_integer_to_arg_nonoption_index_first "${@}"'
:alias_simple set_integers_to_arg_nonoption_count_and_index_first='set_integers_to_arg_nonoption_count_and_index_first "${@}"'

# Declare aliases for corresponding glob functions declared below (and hence
# prefixed by "noglob" here) *BEFORE* defining such functions, as above.
:alias_simple set_integer_to_arg_index_first_matching_glob='noglob set_integer_to_arg_index_first_matching_glob "${@}"'
:alias_simple set_integer_to_arg_index_first_matching_glob_if_found='noglob set_integer_to_arg_index_first_matching_glob_if_found "${@}"'

# ....................{ SETTERS                            }....................
:declare_alias_simple\
    'void set_args(string arg1, ...)'\
    'set --' <<'/---'
Set the current argument list to the passed argument list.
/---

# ....................{ SETTERS ~ equal                    }....................
:document_alias_simple <<'/---'
[status: bool] set_integer_to_arg_index_first_equaling_if_found(
    string integer_name, string arg)

Set the passed integer variable to the 1-based index of the first argument the
caller passed equaling the passed string or report failure if no such argument
exists.
/---
function set_integer_to_arg_index_first_equaling_if_found() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one string.'
    :string integer_name__sitaifeif="${@[-2]}" glob__sitaifeif="${@[-1]}"

    # Set such integer.
    set_integer_to_list_index_first_matching_glob_if_found\
        "${integer_name__sitaifeif}" args__sitaifeif "${glob__sitaifeif}"
}

# ....................{ SETTERS ~ match                    }....................
#FIXME: Add examples.
:document_alias_simple <<'/---'
void set_integer_to_arg_index_first_matching_glob(
    string integer_name, string glob)

Set the passed integer variable to the 1-based index of the first argument the
caller passed matching the passed glob or throw an exception if no such
argument matches. See set_integer_to_arg_index_first_matching_glob_if_found()
for further details.
/---
function set_integer_to_arg_index_first_matching_glob() {
    # Ideally, this function would simply defer to function
    # set_integer_to_arg_index_first_matching_glob_if_found(). Unfortunately,
    # since zsh expands aliases prior to calling functions, doing so would
    # require temporarily disabling the alias of the same name before calling
    # such function, calling such function, and then reenabling such alias.
    #
    # In short, it's more unreliable trouble than its worth. Instead, simply
    # reimplement set_integer_to_arg_index_first_matching_glob_if_found().
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one glob.'
    :string integer_name__sitaifmg="${@[-2]}" glob__sitaifmg="${@[-1]}"
    :list args__sitaifmg
    pop_args_2
          arg_index__sitaifmg="${@[(i)${~glob__sitaifmg}]}"
    if (( arg_index__sitaifmg <= ${#} )) {
        :set_int_to_int\
            "${integer_name__sitaifmg}" "${arg_index__sitaifmg}"
    #FIXME: Should probably simply call a new function
    #die_unless_arg_matches_glob().
    # See die_unless_list_item_matches_glob().
    } else {
        die "Argument list contains no item matching \"${glob}\"."
    }
}

:document_alias_simple <<'/---'
[status: bool] set_integer_to_arg_index_first_matching_glob_if_found(
    string integer_name, string glob)

Set the passed integer variable to the 1-based index of the first argument the
caller passed matching the passed glob or report failure if no such argument
matches.
/---
function set_integer_to_arg_index_first_matching_glob_if_found() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_integer_to_arg_index_first_matching_glob().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one integer name, and one glob.'
    :string integer_name__sitaifmg="${@[-2]}" glob__sitaifmg="${@[-1]}"
    :int arg_index__sitaifmg
    pop_args_2

    # Set such index if found or report failure. Ideally, we would simply call
    # set_integer_to_list_index_first_matching_glob_if_found() here.
    # Unfortunately, since all functions implicitly locally define lists ${@}
    # and ${argv}, neither such list may be passed to such function as is.
    # Instead, we would need to explicitly copy either such list into a list
    # local guaranteed to be unique to this function (e.g.,
    # 'args__sitaifmg=( "${@}" )'). Since such copy imposes undue overhead in
    # the event of both large argument lists and arguments, avoid such copy by
    # implementing such function locally. See such function for further details.
       arg_index__sitaifmg="${@[(i)${~glob__sitaifmg}]}"
    (( arg_index__sitaifmg <= ${#} )) and :set_int_to_int\
        "${integer_name__sitaifmg}" "${arg_index__sitaifmg}"
}

# ....................{ SETTERS ~ option                   }....................
:document_alias_simple <<'/---'
void set_integer_to_arg_option_index_last(string integer_name)

Set the passed integer variable to the 1-based index of the last *option
argument* (i.e., argument prefixed by `-`) the caller passed or 0 if no such
argument was passed.  See set_integer_to_arg_nonoption_index_first() for
further details.
/---
function set_integer_to_arg_option_index_last() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :string integer_name___sitaoil="${@[-1]}"
    :int nonoption_index_first__sitaoil placeholder__sitaoil
    :die_unless_var_integer "${integer_name__sitaoil}"
    pop_arg

    # Get the index of the first non-option argument. See
    # set_integer_to_arg_nonoption_count() for further details.
    set_integers_to_arg_nonoption_count_and_index_first\
        placeholder__sitaoil nonoption_index_first__sitaoil

    # Set the index of the last option argument.
    :set_int_to_int "${integer_name__sitaoil}"\
        $(( nonoption_index_first__sitaoil - 1 ))
}

# ....................{ SETTERS ~ nonoption                }....................
:document_alias_simple <<'/---'
void set_integer_to_arg_nonoption_count(string integer_name)

Set the passed integer variable to the number of *non-options arguments* (i.e.,
arguments _not_ prefixed by `-`) the caller passed. See
set_integer_to_arg_nonoption_index_first() for further details.
/---
function set_integer_to_arg_nonoption_count() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :string integer_name__sitanc="${@[-1]}"
    :int placeholder__sitanc
    :die_unless_var_integer "${integer_name__sitanc}"
    pop_arg

    # Defer to the function below, discarding the value of the second integer
    # variable passed to such function. Since the implementation of such
    # function is somewhat nontrivial, this provides a somewhat "cleaner"
    # solution than reimplementing such function.
    set_integers_to_arg_nonoption_count_and_index_first\
        "${integer_name__sitanc}" placeholder__sitanc
}

:document_alias_simple <<'/---'
void set_integer_to_arg_nonoption_index_first(string integer_name)

Set the passed integer variable to the 1-based index of the first *non-option
argument* (i.e., argument _not_ prefixed by `-`) the caller passed.

== Implementation ==

Specifically, set such variable to:

* If the caller passed an argument equal to `-` or `--`, one greater than the
  index of such argument. By POSIX design, such arguments prematurely terminate
  option arguments.
* Else if the caller passed at least one argument _not_ prefixed by `-`, the
  index of the first such argument.
* Else, one greater than the number of arguments the caller passed. This
  corresponds to default `zsh` behavior for builtin list index modifiers `(i)`
  and `(I)`.
/---
function set_integer_to_arg_nonoption_index_first() {
    # See set_integer_to_arg_nonoption_count() for further details.
    die_unless_args 'Expected zero or more arguments and one integer name.'
    :string integer_name__sitanif="${@[-1]}"
    :int placeholder__sitanif
    :die_unless_var_integer "${integer_name__sitanif}"
    pop_arg
    set_integers_to_arg_nonoption_count_and_index_first\
        placeholder__sitanif "${integer_name__sitanif}"
}

:document_alias_simple <<'/---'
void set_integers_to_arg_nonoption_count_and_index_first(
    string integer_name_count,
    string integer_name_index_first)

Set the first passed integer variable to the number of *non-option arguments*
(i.e., arguments _not_ prefixed by `-`) the caller passed and the second passed
integer to the 1-based index of the first such argument. See
set_integer_to_arg_nonoption_count() and
set_integer_to_arg_nonoption_index_first() for further details.
/---
function set_integers_to_arg_nonoption_count_and_index_first() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected zero or more arguments, one argument count integer name, and one argument index integer name.'
    :string\
        integer_name_count__sitancaif="${@[-2]}"\
        integer_name_index_first__sitancaif="${@[-1]}"
    :int index_first__sitancaif
#   print "count: ${integer_name_count__sitancaif}\nindex_first: ${integer_name_index_first__sitancaif}"
    pop_args_2

    # If such arguments contain "-" or "--", such index is one after the index
    # of such argument.
    index_first__sitancaif="${@[(i)-|--]}"
    if (( index_first__sitancaif <= # )) {
          index_first__sitancaif+=1
    # Else, such index is the index of the first argument *NOT* prefixed by "-"
    # if such argument exists or the number of such arguments otherwise.
    } else {
        index_first__sitancaif="${@[(i)[^-]*]}"
    }

    # Set such integers.
    :set_int_to_int "${integer_name_count__sitancaif}"\
        $(( # - index_first__sitancaif + 1 ))
    :set_int_to_int "${integer_name_index_first__sitancaif}"\
        ${index_first__sitancaif}
#   print "arg count: ${#}"
#   print "arg nonoption first index \"${integer_name_index__sitancaif}\": ${(P)integer_name_index__sitancaif}"
#   print "arg nonoption count: $(( # - ${(P)integer_name_index__sitancaif} + 1 ))"
#   print "count integer name: ${integer_name_count__sitancaif}"
}

#FIXME: In lieu of unit tests...
#function tyam() {
#    integer count index_first index_last
#    set_integers_to_arg_nonoption_count_and_index_first count index_first
#    set_integer_to_arg_option_index_last index_last
#    print "args: ${*}\narg nonoption count: ${count}\narg nonoption first index: ${index_first}\narg option last index: ${index_last}\n"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}

# ....................{ SETTERS ~ map                      }....................
#FIXME: zparseopts() documentation is rather... dense. It'd be helpful to
#synopsize the most commonly used option specifications syntax in documentation
#below.
#FIXME: Fix example below.

:document_alias_simple <<'/---'
[stdout: string, status: bool]
    set_map_list_to_arg_options_nonoptions_with_help(
        string arg_options_map_name,
        string arg_nonoptions_list_name,
        string option_spec1, ...,
        string help_message)

Set the passed map to all *options* (i.e., arguments prefixed by `-`) in the
current argument list and the passed list to all *non-options* (i.e., arguments
_not_ prefixed by `-`) in the current argument list if such options are valid
under the passed zparseopts()-formatted options specifications _or_ print the
print the passed help message and report failure otherwise. For safety, the
current argument list remains unmodified. See `info zsh[i][zparseopts]` for
further details on options specifications: e.g.,

.set_map_list_to_arg_options_nonoptions_with_help()
==========================================
[source]
------------------------------------------
# Set command-line arguments.
>>> set_args -d --ad --alive 42 "glass_arm.shattering"

# Parse such arguments.
>>> map arg_options
>>> set_map_to_arg_options_with_help_from 'arg_options d e -ad -or: -alive:: "
Usage: doa [OPTION]... [FILE]...

Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.

Options:
  -h, --help          print this help text and exit
  -d                  return non-zero exit status if such files fail to run
  -e                  evaluate rather than run the passed files
  --ad                switch from a Julian to Gregorian calendar
  --or DEATHS         set the maximum number of DEATHS
  --alive [LIVES]     set the starting number of LIVES (default: 3)
"'

# Check parsed options.
>>> :output_string "option \"--alive\": ${arg_options[--alive]}"
option "--alive": 42
>>> is_map_key arg_options "-d" and print "option \"-d\": enabled"
option "-d": enabled
------------------------------------------
==========================================

== Map Options ==

For each unique option in the current argument list (e.g.,
`--thoughtcrime="is death"`), this function adds a corresponding key-value pair
to the passed map such that such key is the option name including `-` or `--`
prefix (e.g., `--thoughtcrime`) and such value the option value excluding
separating `=` or whitespace if the caller defined such a value or the empty
string otherwise.

For convenience, this function silently defines zparseopts()-formatted options
specifications for options `-h` and `--help` if _not_ defined by the passed
specifications.
/---
# Function set_map_list_to_arg_options_nonoptions_with_help() accepts a variable
# number of both arguments and options specifications. Differentiating between
# the two requires the alias expanding such function append a placeholder after
# the passed arguments, which such function then searches for. 
:alias_simple set_map_list_to_arg_options_nonoptions_with_help='set_map_list_to_arg_options_nonoptions_with_help "${@}" "${ZESHY_ASCII_PLACEHOLDER}"'
function set_map_list_to_arg_options_nonoptions_with_help() {
    # Validate sanity.
    die_unless_args_4_or_more\
        "Expected zero or more arguments, one map name, one list name, one or more option specifiers, and one help string."
    :string\
        map_name__smtaowhf\
        list_name__smtaowhf\
        help_message__smtaowhf\
    :int index_arg_last_plus_one__smtaowhf
    :list option_specs__smtaowhf

    # Index one after that of the last argument in the caller's argument list.
    set_integer_to_arg_index_first_equaling\
        index_arg_last_plus_one__smtaowhf "${ZESHY_ASCII_PLACEHOLDER}"

    # Localize all passed variables following such index.
    map_name__smtaowhf="${@[      index_arg_last_plus_one__smtaowhf + 1]}"
    list_name__smtaowhf="${@[     index_arg_last_plus_one__smtaowhf + 2]}"
    option_specs__smtaowhf=( "${@[index_arg_last_plus_one__smtaowhf + 3,-2]}" )
    help_message__smtaowhf="${@[-1]}"

    # Validate such variables.
    die_unless_map "${map_name__smtaowhf}"
    die_unless_list "${list_name__smtaowhf}"

    # Reduce the current argument list to the caller's argument list. See
    # pop_args() for further details.
    argv[${index_arg_last_plus_one__smtaowhf},-1]=()

    #FIXME: Actually test whether or not such specifications are already passed.

    # Add options specifications for options `-h` and `--help` if *NOT* defined
    # by the passed specifications.
    option_specs__smtaowhf+=( 'h' '-help=h' )

    #FIXME: We should probably also pass option "-K":
    #
    # -K
    #     With this option, the arrays specified with the -a and -A
    #     options and with the `=ARRAY' forms are kept unchanged when
    #     none of the SPECS for them is used.  This allows assignment
    #     of default values to them before calling zparseopts.

    # Set such map by parsing options via the passed (and canonical help) option
    # specifications, preserving unparsed options for subsequent parsing by the
    # caller. If such parsing fails, print the passed help text and return from
    # the caller or script with non-zero exit status. Dismantled, this is:
    #
    # * "-D", removing *ONLY* parsed options from the current argument list.
    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
    #   option specification, thus ignoring all unspecified options.
    # * "-M", parsing "="-prefixed substrings in option specifications as the
    #   map key to parse such option into (e.g., "-help=h" parses long option
    #   "--help" into map key ${arg_options[-h]} rather than
    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
    #   target list or map name to parse such option into.
    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
    #   either the option values if passed or the empty string if not passed.
    zparseopts -M -D -E -A "${map_name__smtaowhf}" --\
        "${option_specs__smtaowhf[@]}" or {
        #FIXME: Unsurprisingly, this looks completely awkward. Contemplate.
        print_warning 'Invalid command-line argument(s).'
        :output_string "${help_message__smtaowhf}"
        report_failure
    }

    # Set such list to all unparsed arguments.
    list_name__smtaowhf=( "${@}" )
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Terrible. Refactor using the standard method above of passing the entire
#argument list to a function of the same. In this case, however, doing so will
#somewhat change the calling semantics. Rather than this alias removing all
#parsed arguments from the current argument list, such list will be unchanged.
#Arguably, the latter behavior coincides much better with "setter_"
#nomenclature. If removing all parsed arguments from the current argument list
#is still desired, callers may do so by simply differencing the...
#FUXME: O.K.; perhaps not. To preserve such functionality, this function should
#probably be refactored as follows:
#
#    void set_map_list_to_arg_options_nonoptions_with_help(
#        string arg_options_map_name,
#        string arg_nonoptions_list_name,
#        string option_spec1?, ...,
#        string help_message)
#
#Hence, such function sets a passed map to argument options and a passed list to
#argument non-options. It does so by simply copying the current argument list to
#the latter list *AFTER* calling zparseopts(). Tada!

    #FUXME: To implement this, we'll need to pass something highly unlikely will
    #ever be passed as a real argument -- say,
    #"${ZESHY_ASCII_PLACEHOLDER}" -- and then parse
    #that below, denoting the end of the passed argument list. *shrug*

#    list args__sitaifmg
#    pop_args_2
#
#    #FUXME: Absurdly inefficient, though it works. Optimize sanely.
#    # Copy the passed argument list into a local list. The function below
#    # requires a list name *NOT* conflicting with local variable names.
#    args__sitaifmg=( "${@}" )
#
#    # Set such integer.
#    set_integer_to_list_index_first_matching_glob_if_found\
#        "${integer_name__sitaifmg}" args__sitaifmg "${glob__sitaifmg}"

# Note: the corresponding aliases are declared above.

#FUXME: As the nomenclature below demonstrates, suffixing alias names by "_for"
#rather than "_from" for aliases accepting multiple arguments in a single string
#produces a more legible calling convention. Change "_from" to "_for"
#everywhere, please.

    #FUXME: Clearly, this no longer works. As this function is now (rightly!) a
    #function, the caller must implement such functionality. Which is probably a
    #good thing, honestly. Correct documentation above, if necessary.
# If the current argument list contains either such option (i.e.,
#the caller passed such options), this function prints the passed help message
#and reports success: e.g.,

    # If passed a help option, ignore all other options, print the passed help
    # text, and return from the caller function or script.
#   if { is_map_key "${map_name__smtaowhf}" "-h" } {
#       :output_string "${args__smtaowhf}"
#   }

#FUXME: O.K.; all of the below are fairly horrible. Reimplement as proper
#functions by passing the argument list from an alias to function of the same
#name. This should also allow us to eliminate the absurd "_from" syntax below,
#which is *ABSOLUTELY ESSENTIAL* (because it's horrible). Look: any function
#incurring the cost of expanding such aliases can certainly afford the
#negligible cost of passing their argument list to another function for testing.
#Make it so, please.

#:declare_alias_simple <<'/---'
#void set_map_to_arg_options_with_help_from(
#    string map_name,
#    string option_spec1, ...,
#    string help_message)
#
#Parse and remove `-`-prefixed options from the current argument list via the
#passed zparseopts()-formatted options specifications into the passed map.
#Preserve all other arguments in the current argument list for subsequent parsing
#by the caller. Due to `zsh` constraints, arguments must be passed
#whitespace-delimited in a single shell word (e.g., single- or double-quoted
#string). See `info zsh[i][zparseopts]` for further details on the format for
#options specifications.
#
#Parse options `-h` and `--help` by printing the passed help message and
#returning from the caller function or script with zero exit status. If parsing
#fails, also print such message but return with nonzero exit status: e.g.,
#
#.set_map_to_arg_options_with_help_from()
#==========================================
#[source]
#------------------------------------------
## Set command-line arguments.
#>>> set_args -d --ad --alive 42 "glass_arm.shattering"
#
## Parse such arguments.
#>>> map arg_options
#>>> set_map_to_arg_options_with_help_from 'arg_options d e -ad -or: -alive:: "
#Usage: doa [OPTION]... [FILE]...
#
#Run the passed FILEs as "Dead or Alive" modules under the passed OPTIONs.
#
#Options:
#  -h, --help          print this help text and exit
#  -d                  return non-zero exit status if such files fail to run
#  -e                  evaluate rather than run the passed files
#  --ad                switch from a Julian to Gregorian calendar
#  --or DEATHS         set the maximum number of DEATHS
#  --alive [LIVES]     set the starting number of LIVES (default: 3)
#"'
#
## Check parsed options.
#>>> print_string "option \"--alive\": ${arg_options[--alive]}"
#option "--alive": 42
#>>> is_map_key arg_options "-d" and print "option \"-d\": enabled"
#option "-d": enabled
#------------------------------------------
#==========================================
#/---
#alias set_map_to_arg_options_with_help_from='{
#    # Validate sanity.
#    list  args__smtaowhf; set_list_to_stdin_words args__smtaowhf
#    (( ${#args__smtaowhf} >= 3 )) ||
#        die "Expected one map name, one or more option specifiers, and one help string."
#    string\
#        map_name__smtaowhf="${args__smtaowhf[1]}"\
#        help_message__smtaowhf="${args__smtaowhf[-1]}"
#    die_unless_map "${map_name__smtaowhf}"
#
#    # Remove the first and last passed argument having parsed such arguments.
#    shift_list args__smtaowhf
#    pop_list   args__smtaowhf
#
#    # Parse options under the passed (and canonical help) option specifications,
#    # preserving unparsed options for subsequent parsing by the caller. If such
#    # parsing fails, print the passed help text and return from the caller or
#    # script with non-zero exit status. Dismantled, this is:
#    #
#    # * "-D", removing *ONLY* parsed options from the current argument list.
#    # * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
#    #   option specification, thus preserving all unspecified options.
#    # * "-M", parsing "="-prefixed substrings in option specifications as the
#    #   map key to parse such option into (e.g., "-help=h" parses long option
#    #   "--help" into map key ${arg_options[-h]} rather than
#    #   ${arg_options[--help]}). By default, "="-prefixed substrings denote the
#    #   target list or map name to parse such option into.
#    # * "-A arg_options", parsing passed options into map ${arg_options}. Map
#    #   keys are option names (e.g., "-c", "--iapropaganda") and map values
#    #   either the option values if passed or the empty string if not passed.
#    if { not zparseopts -M -D -E -A "${map_name__smtaowhf}" --\
#        "${args__smtaowhf[@]}" h -help=h } {
#        print_warning "Invalid command-line argument(s)."
#        :output_string "${help_message__smtaowhf}"
#        report_failure
#    }
#
#    # If passed a help option, ignore all other options, print the passed help
#    # text, and return from the caller function or script.
#    if { is_map_key "${map_name__smtaowhf}" "-h" } {
#        return_string "${args__smtaowhf}"
#    }
#} <<<'

#   :die_unless_vars_integer\
#       "${integer_name_count__sitancaif}"\
#       "${integer_name_index_first__sitancaif}"
# For efficiency, inline such implementations. See
    # :set_int_to_int() for further details.
#    noop ${(P)integer_name_count__sitancaif::=$(( # - index_first__sitancaif + 1 ))}
#    noop ${(P)integer_name_index_first__sitancaif::=${index_first__sitancaif}}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with set_integer_to_arg_nonoption_index_first() and
    # set_integer_to_arg_option_index_last().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#function set_integer_to_arg_nonoption_index_first() {
#    # Validate sanity.
#    die_unless_args 'Expected zero or more arguments and one integer name.'
#    string integer_name__sitanif="${@[-1]}"
#    integer arg_nonoption_index_first__sitanif
#    pop_arg
#
#    # If such arguments contain "-" or "--", such index is one after the index
#    # of such argument.
#    arg_nonoption_index_first__sitanif="${@[(i)-|--]}"
#    if (( arg_nonoption_index_first__sitanif <= # )) {
#          arg_nonoption_index_first__sitanif+=1
#    # Else, such index is the index of the first argument *NOT* prefixed by "-"
#    # if such argument exists or the number of such arguments otherwise.
#    } else {
#        arg_nonoption_index_first__sitanif="${@[(i)[^-]*]}"
#    }
#
#    # Set such integer.
#    :set_int_to_int "${integer_name__sitanif}"\
#        "${arg_nonoption_index_first__sitanif}"
#}

    # Set the index of the first non-option argument.
#    :set_int_to_int "${integer_name_index__sitancaif}"\
#        "${arg_nonoption_index_first__sitancaif}"
#
#    # Set the number of such arguments.
#    :set_int_to_int "${integer_name_count__sitancaif}"\
#        $(( # - ${(P)integer_name_index__sitancaif} + 1 ))

#, parsing arguments `-` and `--` as ending option arguments.

#FUXME: Also, our creation of local variables on the caller's behalf if not
#already declared is amusing, but highly incongruous. Consider it: when can a
#caller reasonably expect a setter to declare a variable for itself? Solipsistic
#answer: when such setter is an alias. But this is turn requires the caller to
#somehow know whether a setter is an alias or function, an implementation detail
#the caller should *NEVER* be knowledgable of. In other words, declaring local
#variables on the caller's behalf is breaking bad and should be desisted.
#Instead, just throw an exception if such variable does not exist (as usual).

#    # Validate sanity.
#    list args__seitancafif; set_list_to_stdin_words args__seitancafif
#    (( ${#args__seitancafif} == 2 )) or die "expected two integer names"
#    string\
#        count_integer_name__seitancafif="${args__seitancafif[1]}"\
#        index_integer_name__seitancafif="${args__seitancafif[2]}"
#
#    # Get the index of the first non-option argument.
#    set_integer_to_arg_nonoption_index_first\
#        "${index_integer_name__seitancafif}"
##   print "arg count: ${#}"
##   print "arg nonoption first index \"${index_integer_name__seitancafif}\": ${(P)index_integer_name__seitancafif}"
##   print "arg nonoption count: $(( # - ${(P)index_integer_name__seitancafif} + 1 ))"
#
#    # Set such integer.
##   print "count integer name: ${count_integer_name__seitancafif}"
#    :is_var "${count_integer_name__seitancafif}" or
#        integer "${count_integer_name__seitancafif}"
#    :set_int_to_int "${count_integer_name__seitancafif}"\
#        $(( # - ${(P)index_integer_name__seitancafif} + 1 ))
#} <<<'

# Due to `zsh` constraints,
#integer names must be passed whitespace-delimited in a single shell word (e.g.,
#single- or double-quoted string).

#   :die_unless_int "${integer_name__sitanc}"
#== Premature Denotation ==
#
#By precedent, the first passed argument equal to `-` or `--` prematurely
#terminates option arguments. If such an argument was passed, the passed integer
#will be set to one greater than the index of such argument rather than the index
#of the first passed non-option argument.

    #FUXME: Replace implementation with a single expansion of
    #set_integers_to_arg_nonoption_count_and_index_first().

#alias set_integer_to_arg_nonoption_index_first='{
#    #FUXME: Replace implementation with a single expansion of
#    #set_integers_to_arg_nonoption_count_and_index_first().
#
#    # Validate sanity.
#    list args__seitanfi
#    set_list_to_stdin_words args__seitanfi
#    (( ${#args__seitanfi} == 1 )) or die "expected one integer name"
#    string integer_name__seitanfi="${args__seitanfi[1]}"
#    integer arg_nonoption_index_first__seitanfi
#
#    # If sanity.contain "-" or "--", the index of the first non-option
#    # in such arguments is one after the index of such "-" or "--".
#    arg_nonoption_index_first__seitanfi=${@[(i)-|--]}
#    if (( arg_nonoption_index_first__seitanfi <= # )) {
#        noop $(( ++arg_nonoption_index_first__seitanfi ))
#    # Otherwise, the index of the first non-option in such arguments is the
#    # index of the argument *NOT* prefixed by "-" or the number of such
#    # arguments if all arguments are prefixed by "-" or no arguments are passed.
#    } else {
#        arg_nonoption_index_first__seitanfi=${@[(i)[^-]*]}
#    }
#
#    # Set such integer.
#    :is_var "${integer_name__seitanfi}" or
#        integer "${integer_name__seitanfi}"
#    :set_int_to_int "${integer_name__seitanfi}"\
#        "${arg_nonoption_index_first__seitanfi}"
#} <<<'

#alias set_integer_to_arg_nonoption_count='
#{
#    # Validate sanity.
#    list args__seitanc; set_list_to_stdin_words args__seitanc
#    (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#
#    # Defer to the above alias with a placeholder first index integer name.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        "${args__seitanc[1]} index_integer_name__seitanc"
##   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
#} <<<'

#FUXME: Globally rename "_arg_nonoption_index_first" to
#"_arg_nonoption_index_first".

#:declare_alias_simple <<'/---'
#void set_integer_to_arg_nonoption_count(string integer_name)
#
#Set the passed integer to the number of *non-options arguments* the caller
#passed (i.e., arguments not prefixed by `-`). Parse arguments `-` and `--` as
#ending option arguments.
#/---
#alias set_integer_to_arg_nonoption_count='
#{
#    # Validate sanity.
#    list args__seitanc; set_list_to_stdin_words args__seitanc
#    (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#
#    # Defer to the above alias with a placeholder first index integer name.
#    set_integers_to_arg_nonoption_count_and_index_first\
#        "${args__seitanc[1]} index_integer_name__seitanc"
##   print "arg nonoption count \"${args__seitanc[1]}\": ${(P)args__seitanc[1]}"
#} <<<'

    # Validate sanity.
#   list args__seitanc; set_list_to_stdin_words args__seitanc
#   (( ${#args__seitanc} == 1 )) or die "expected one integer name"
#   string integer_name__seitanc="${args__seitanc[1]}"

    # Get the index of the first non-option argument.
#   set_integer_to_arg_nonoption_index_first arg_nonoption_index_first__seitanc
#   print "arg count: ${#}"
#   print "arg nonoption first index: ${arg_nonoption_index_first__seitanc}"
#   print "arg nonoption count: $(( # - arg_nonoption_index_first__seitanc + 1 ))"

    # Set such integer.
#    :is_var_integer "${integer_name__seitanc}" or integer "${integer_name__seitanc}"
#   :set_int_to_int "${integer_name__seitanc}"\
#       $(( # - arg_nonoption_index_first__seitanc + 1 ))

#FUXME: Rename to set_list_to_arg_options_with_help_from() and accept the first
#passed argument as a list name. In other words, stop assuming a list name of
#${arg_options} as we currently do.

#boolean is_arg_nonoptions_1_to_3{void}
#boolean is_arg_nonoptions_1_to_3<void>
#Return true if the number of non-options in the current argument list (i.e.,
#arguments not prefixed by "-") is . This alias parses arguments "-" and "--"
#as the last options in such list.

#set_integer_to_arg_nonoption_count __nonoptions__ and
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#'
#alias is_arg_nonoptions_1_to_3='
#{
#    integer __nonoptions__; set_integer_to_arg_nonoption_count __nonoptions__
#    print "non-option count: ${__nonoptions__}"
#    (( 1 <= __nonoptions__ && __nonoptions__ <= 3 ))
#}
#'
#function tyam() {
#   set_integer_to_arg_nonoption_count y
#   print "arg nonoption count: $y"
#    is_arg_nonoptions_1_to_3 and print "...between 1 to 3"
#}
#function tyim() {
#    tyam
#    tyam -a
#    tyam -a a
#    tyam -a -a y
#    tyam -a a z z z
#}
    #FUXME: Such functionality, duplicated above, should arguably be
    #encapsulated into a single function -- perhaps, print_message set_integer_locally()
    #or set_integer_declaratively(). Hmm; how about
    #set_integer_declared_locally_unless_found() or
    #set_integer_and_localize_unless_declared() or
    #set_integer_localized_if_unset()? Yes; the latter, I should think. Ah; wait.
    #The syntax is rather ugly, requiring a composite herestring. *shrug*

#   :set_int_to_int "${integer_name_seitanfi}" $(( arg_nonoption_index_first_seitanfi ))
#   list __args__; __args__=( ${(z)"$(< /dev/stdin)"} )
# Get the number of non-options passed (i.e., non-"-"-prefixed arguments).
    #FUXME: Be nice to extract this into a new set_integer_to_evaluation().
    #Actually, how about a more general set_scalar_to_evaluation()? Right. That
    #seems perfect.

#   noop ${(P)__integer_name__::=$(( __arg_nonoption_index_first__ ))}
#   noop ${(P)__integer_name__::=$(( # - __arg_nonoption_index_first__ + 1 ))}
        # Else, if at least one sanity.is not prefixed by "-", such
        # argument is the first non-option in such arguments.
        # Otherwise, set such index to the size of such list plus one.
#       (( __arg_option_last_index__ <= # )) or 
#           (( __arg_option_last_index__ <= # )) or 
#       then noop ${(P)__integer_name__::=$(( __arg_option_last_index__ ))}
#       else 
#       fi

#   noop  ${(P)__integer_name__::=${@[(i)-|--]}}
#   if (( ${(P)__integer_name__} <= # ))

#FUXME: Completely unrelated to this component, but we can now actually create
#sensible return_string()-style aliases! Oh, man; pretty sweet. Finally found
#it.

    #FUXME: Validate the passed argument is a single argument. Just revert to
    #the traditional argument parsing to do so.
    # Validate sanity.
#   string __integer_name__; __integer_name__="$(get_stdin_piped)"
