#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *string globbers* (i.e., functions matching strings against extended glob
expressions).
/---

#FIXME: This parcel is excessively inefficient. The core issue are the
#subshells, which should be supplanted for equivalent setters *QUICKLY*. No,
#really. These functions are called *ALL OVER THE PLACE*, including in large-
#scale iteration for defining CLI aliases. Heaps. Heaps! So optimize that.

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
<globbable> void :die_unless_string_matches_glob(
    string text,
    string glob,
    string error_message =
        "String \"${text}\" unmatched by glob \"${glob}\".")

Throw an exception with the passed message unless the passed string matches the
passed glob. See :is_string_matches_glob() for further details.
/---
function :die_unless_string_matches_glob() {
    die_unless_args_2_to_3\
        'Expected one string, one glob, and optional error message.'
    :string text="${1}" glob="${2}"
    :is_string_matches_glob "${text}" "${glob}" or die\
        "${3-String \"$(truncate_string_readable: "${text}")\" unmatched by glob \"${glob}\".}"
#   output_string $'\n'"glob: ${glob}"
}

declare_function_with_stdin <<'/---'
<globbable> void :die_unless_string_matches_glob_grouped(
    string text,
    string glob,
    string error_message =
        "String \"${text}\" unmatched by glob \"${glob}\".")

Throw an exception with the passed message unless the passed string matches the
passed glob. If such string matches such glob, set match globals ${MATCH},
${MBEGIN}, ${MEND}, ${match}, ${mbegin}, and ${mend}. See
:is_string_matches_glob_grouped() for further details.
/---
function :die_unless_string_matches_glob_grouped() {
    die_unless_args_2_to_3\
        'Expected one string, one glob, and optional error message.'
    :string text="${1}" glob="${2}"
    :is_string_matches_glob_grouped "${text}" "${glob}" or die\
        "${3-String \"$(truncate_string_readable: "${text}")\" unmatched by glob \"${glob}\".}"
#   output_string "glob: ${glob}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
<globbable> [status: bool] :is_string_matches_glob(string text, string glob)

Report success if the passed string matches the passed glob. If such glob is
syntactically invalid (e.g., `[^]]`), an exception is thrown. If such string
matches such glob, scalar globals ${MATCH}, ${MBEGIN}, and ${MEND} will be set
to their customary values. For both efficiency and safety, this function does
_not_ set nonscalar globals ${match}, ${mbegin}, or ${mend} unless such glob
contains ${ZESHY_GLOB_ENABLE_CAPTURING_GROUPED} (i.e., `(#b)`). Alternately, consider
calling :is_string_matches_glob_grouped() to have such globals set: e.g.,

.:is_string_matches_glob()
==========================================
[source]
------------------------------------------
>>> :string on_law=\
...    "If you reason instead of repeating what is taught you; if you analyze
...     the law and strip off those cloudy fictions with which it has been
...     draped in order to conceal its real origin, which is the right of the
...     stronger, and its substance, which has ever been the consecration of
...     all the tyrannies handed down to mankind through its long and bloody
...     history; when you have comprehended this, your contempt for the law will
...     be profound indeed. You will understand that to remain the servant of
...     the written law is to place yourself every day in opposition to the law
...     of conscience, and to make a bargain on the wrong side; and, since this
...     struggle cannot go on forever, you will either silence your conscience
...     and become a scoundrel, or you will break with tradition, and you will
...     work with us for the utter destruction of all this injustice, economic,
...     social and political."
>>> :is_string_matches_glob "${on_law}" ut(#c2,)?r*d?str?ct??n and print_string\
...    "Men lived thousands of years before the first States were constituted."
Men lived thousands of years before the first States were constituted.
------------------------------------------
==========================================

== Motivation ==

Enabling *ungrouped capturing* (i.e., setting ${MATCH}, ${MBEGIN}, and ${MEND}
on successful matches) costs little while yielding measurable benefit. To
quote `zsh` documentation:

[quote, `man zshexpn`]
____________________________________________________________________
Unlike backreferences _(i.e., captured groups)_, there is no speed penalty for
using match references _(i.e., captured ungrouped substrings)_.
____________________________________________________________________

Since ungrouped capturing should arguably be enabled by default (and is for the
comparable PCRE-based match operator `=~`), this and all similar string
globbers implicitly enable such capturing.
/---
function :is_string_matches_glob() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one glob.'
    :string text="${1}" glob="${2}"
#   output_string_to_stderr "glob: ${glob}"

    # Set scalar globals on successful matches (e.g., ${MATCH}).
    :enable_glob_capturing_ungrouped glob

    # Perform such test. If such glob is syntactically invalid, zsh emits a
    # nonfatal warning to standard error and reports failure; if such glob is
    # syntactically valid but such test fails, zsh reports failure without
    # printing to standard error. In the former case, this function converts
    # such nonfatal warning to a fatal exception; in the latter case, this
    # function merely reports failure.
    #
    # If such test fails, distinguish the two cases by capturing and testing
    # standard error produced by such test.
    #
    # If such test succeeds, such glob *MUST* be syntactically valid. In such
    # case, report success.
    { is "${text}" == ${~glob} si } silent_stderr: or {
        # Repeat such test, capturing standard error if any and ignoring the
        # expected failure. For efficiency, capture such error *ONLY* if such
        # test fails. Subshells are non-negligibly inefficient!
        :string error; error="$(
            { is "${text}" == ${~glob} si } to_stdout: or ignore_failure)"

        # If such error is nonempty, such glob *MUST* be syntactically invalid.
        # Convert such nonfatal error into a fatal exception.
        if { is_string_nonempty "${error}" } {
            # If such error is prefixed by "zsh: ", remove such prefix.
            remove_string_prefix error 'zsh: '
            die 'Glob "'${glob}'" invalid:'${ZESHY_ASCII_NEWLINE}${error}
        # Else, such glob is syntactically valid but such test failed. In such
        # case, report failure.
        } else {
            report_failure
        }
    }
}

declare_function_with_stdin <<'/---'
<globbable> [status: bool] :is_string_matches_glob_grouped(
    string text, string glob)

Report success if the passed string matches the passed glob. If such glob is
syntactically invalid (e.g., `[^]]`), an exception is thrown. If such string
matches such glob, globals ${MATCH}, ${MBEGIN}, ${MEND}, ${match}, ${mbegin},
and ${mend} will be set to their customary values. If capturing only one match
group, consider calling get_string_match_group_first() or
get_string_match_group_first_if_found() instead. See
:enable_glob_capturing_grouped() for further details: e.g.,

.:is_string_matches_glob_grouped()
==========================================
[source]
------------------------------------------
>>> :string glob="crazy, ([[:alpha:]]##)" on_awareness=\
...    "The first characteristic is a slowing down of time, a concentration in
...     the present. One's normally compulsive concern for the future decreases,
...     and one becomes aware of the enormous importance and interest of what is
...     happening at the moment. Other people, going about their business on the
...     streets, seem to be slightly crazy, failing to realize that the whole
...     point of life is to be fully aware of it as it happens. One therefore
...     relaxes, almost luxuriously, into studying the colors in a glass of
...     water, or in listening to the now highly articulate vibration of every
...     note played on an oboe or sung by a voice."
>>> :is_string_matches_glob_grouped "${on_awareness}" "${glob}"
>>> output_string "${match[1]}"
failing
>>> get_string_text_matching_glob_group_if_found\
...     "${on_awareness}" "${glob}"
failing
------------------------------------------
==========================================
/---
function :is_string_matches_glob_grouped() {
    # Validate sanity.
    die_unless_args_2 'Expected one string and one glob.'
    :string text="${1}" glob="${2}"

    # Set nonscalar globals on successful matches (e.g., ${match}).
    :enable_glob_capturing_grouped glob

    # Test such string.
    :is_string_matches_glob "${text}" "${glob}"
}

#FIXME: In lieu of unit tests...
#function unia() {
#    string text="$(get_locale_pcre_yes)" glob="*\\[([^\\]]#)\\]*" stderr
#    eval 'is "${text}" == ${~glob} si' and print 'ok' or print 'ko'
#    match=()
#    :is_string_matches_glob_grouped 'End the entrails.' 'Swift the river' and
#        print 'ok' or print 'ko'
#    :is_string_matches_glob_grouped "$(get_locale_pcre_yes)" '*\[([^\]]#)\]*' and
#        print "group: ${match[1]}" or print 'ko'
#}

# ....................{ GETTERS                            }....................
#FIXME: Refactor into a setter :set_int_to_string_text_matching_glob_count().
#FIXME: Ridiculously awesome example, but overlang. Split in twain.
declare_function_with_stdin <<'/---'
<globbable> int get_string_text_matching_glob_count(
    string text, string glob)

Get the number of substrings in the passed string matching the passed glob:
e.g.,

.get_string_text_matching_glob_count()
==========================================
[source]
------------------------------------------
>>> :string on_sufficiency=\
...    "No man can serve two masters: for either he will hate the one, and love
...     the other; or else he will hold to the one, and despise the other. Ye
...     cannot serve God and Mammon.
...     Therefore I say unto you, Take no thought for your life, what ye shall
...     eat, or what ye shall drink; nor yet for your body, what ye shall put
...     on. Is not the life more than meat, and the body than raiment?
...     Behold the fowls of the air: for they sow not, neither do they reap, nor
...     gather into barns; yet your heavenly Father feedeth them. Are ye not
...     much better than they?
...     Which of you by taking thought can add one cubit unto his stature?
...     And why take ye thought for raiment? Consider the lilies of the field,
...     how they grow; they toil not, neither do they spin:
...     and yet I say unto you, That even Solomon in all his glory
...     was not arrayed like one of these.
...     Wherefore, if God so clothe the grass of the field, which today is, and
...     tomorrow is cast into the oven, shall he not much more clothe you, O ye
...     of little faith?
...     Therefore take no thought, saying, What shall we eat? or, What shall we
...     drink? or, Wherewithal shall we be clothed?
...     Take therefore no thought for the morrow: for the morrow shall take
...     thought for the things of itself. Sufficient unto the day is the evil
...     thereof."
>>> get_string_text_matching_glob_count\
...    "${on_sufficiency}" ('field'|'raiament')
4
------------------------------------------
==========================================
/---
function get_string_text_matching_glob_count() {
    :int match_count=0
    for_string_matches_glob "${@}" 'match_count+=1'
    output_string ${match_count}
}

# ....................{ GETTERS ~ group                    }....................
declare_function_with_stdin <<'/---'
<globbable> string get_string_text_matching_glob_group(
    string text, string glob, int group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first such
group) captured after successfully matching the passed string with the passed
glob or throw an exception if such match fails or no such group exists: e.g.,

.get_string_text_matching_glob_group()
==========================================
[source]
------------------------------------------
>>> :string on_fellowship=\
...    "I came to the conclusion long ago, after prayerful search and study and
...     discussion with as many people as I could meet, that all religions were
...     true and also that all had some error in them, and that whilst I hold by
...     my own, I should hold others as dear as Hinduism, from which it
...     logically follows that we should hold all as dear as our nearest kith
...     and kin and that we should make no distinction between them. So we can
...     only pray, if we are Hindus, not that a Christian should become a Hindu,
...     or if we are Mussalmans, not that a Hindu or a Christian should become a
...     Mussalman, nor should we even secretely pray that anyone should be
...     converted, but our inmost prayer should be that a Hindu should be a
...     better Hindu, a Muslim a better Muslim, a Christian a better Christian.
...     That is the fundamental truth of fellowship."
>>> get_string_text_matching_glob_group "${on_fellowship}" *('Mus'[^ ]##)* 1
Mussalmans
------------------------------------------
==========================================
/---
function get_string_text_matching_glob_group() {
    get_string_text_matching_glob_group_if_found "${@}" or
        :die_unless_string_matches_glob "${@[1,2]}"
}

declare_function_with_stdin <<'/---'
<globbable> [stdout: string, status: bool]
    get_string_text_matching_glob_group_if_found(
        string text, string glob, integer group_index = 1)

Get the match group with the passed 1-based index (defaulting to the first such
group) captured after successfully matching the passed string with the passed
glob or return failure if such match fails or no such group exists: e.g.,

.get_string_text_matching_glob_group_if_found()
==========================================
[source]
------------------------------------------
>>> :string on_warranties=\
...    "[Along with the standard computer warranty agreement which said that if
...     the machine 1) didn't work, 2) didn't do what the expensive
...     advertisements said, 3) electrocuted the immediate neighborhood, 4) and
...     in fact failed entirely to be inside the expensive box when you opened
...     it, this was expressly, absolutely, implicitly and in no event the fault
...     or responsibility of the manufacturer, that the purchaser should
...     consider himself lucky to be allowed to give his money to the
...     manufacturer, and that any attempt to treat what had just been paid for
...     as the purchaser's own property would result in the attentions of
...     serious men with menacing briefcases and very thin watches. Crowley had
...     been extremely impressed with the warranties offered by the computer
...     industry, and had in fact sent a bundle Below to the department that
...     drew up the Immortal Soul agreements, with a yellow memo form attached
...     just saying: \"Learn, guys . . .\"]"
>>> get_string_text_matching_glob_group_if_found\
...     "${on_warranties}" *([[:digit:]]') ')([[:graph:]]##)* 2
didn't
------------------------------------------
==========================================
/---
function get_string_text_matching_glob_group_if_found() {
    # Validate sanity.
    die_unless_args_2_to_3\
        'Expected one string, one glob, and optional group index.'
    :string text="${1}" glob="${2}" group_index="${3:-1}"
    :die_unless_int_positive "${group_index}"

    # If such string matches, return such group. Avoid double-quoting such glob.
    if { :is_string_matches_glob_grouped "${text}" "${glob}" } {
        return_string "${match[${group_index}]}"
    # Else, return failure.
    } else {
        report_failure
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: After learning that matching with "=~" *ALWAYS* unconditionally sets
#scalar globals ${MATCH}, ${MEND}, ${MBEGIN} and nonscalar global ${match}, it
#strikes me as exceedingly silly that we don't at least unconditionally set
#scalar globals ${MATCH}, ${MEND}, and ${MBEGIN} when calling such functions.
#It's best not to unconditionally set ${match} by embedding "(#b)", of course,
#as "(#b)(...)" and "(#B)(...)" are the best glob equivalent to PCRE-style
#"(...)" capturing and "(?:...)" non-capturing. This implies we should shift the
#implementation of is_string_matches_glob_capturing_()...
#
#Hmmm; this thought appears to be incomplete. Is the above still applicable?

#FUXME: But that's not all. :is_string_matches_glob_safely() necessarily leverages
#coprocesses and hence is both less efficient and robust than we generally
#require. While I concur that we should retain such function as is, we should
#probably be calling an alternative new function
#:is_string_matches_glob_unsafe() from all functions currently calling the prior
#function. I know; I know. Neither approach is ideal, but this is probably the
#less objectionable of the two. (We *WOULD* like to be able to use coprocesses
#elsewhere, at some point.)

    # # Set nonscalar globals on successful matches (e.g., ${match}).
    # :enable_glob_capturing_grouped glob

    # # If such string matches, return such group. Avoid double-quoting such glob.
    # if is "${text}" == ${~glob} si {

# function :is_string_matches_glob() {
#     die_unless_args_2 'Expected one string and one glob.'
#     is_string_matches_glob_safely\
#         "${1}" "$(convert_string_to_glob_capturing_substrings "${2}")"
# }

# declare_function_with_stdin <<'/---'
# <globbable> [status: bool] is_string_matches_glob_safely(
#     string text, string glob)
# 
# Report success if the passed string matches the passed glob. If such glob is
# syntactically invalid (e.g., `[^]]`), an exception is thrown. (This differs
# substantially from `zsh`\'s customary behavior of only printing nonfatal
# warnings on syntactically invalid globs): e.g.,
#
# .is_string_matches_glob_safely()
# ==========================================
# [source]
# ------------------------------------------
# >>> :string on_entheogens=\
# ...    'The idea of mystical experiences resulting from drug use is not readily
# ...     accepted in Western societies. Western culture has, historically, a
# ...     particular fascination with the value and virtue of man as an
# ...     individual, self-determining, responsible ego, controlling himself and
# ...     his world by the power of conscious effort and will. Nothing, then,
# ...     could be more repugnant to this cultural tradition than the notion of
# ...     spiritual or psychological growth through the use of drugs. A
# ...     "drugged" person is by definition dimmed in consciousness, fogged in
# ...     judgment, and deprived of will. But not all psychotropic (consciousness-
# ...     changing) chemicals are narcotic and soporific, as are alcohol, opiates,
# ...     and barbiturates. The effects of what are now called psychedelic (mind-
# ...     manifesting) chemicals differ from those of alcohol as laughter differs
# ...     from rage, or delight from depression. There is really no analogy
# ...     between being "high" on LSD and "drunk" on bourbon. True, no one in
# ...     either state should drive a car, but neither should one drive while
# ...     reading a book, playing a violin, or making love. Certain creative
# ...     activities and states of mind demand a concentration and devotion that
# ...     are simply incompatible with piloting a death-dealing engine along a
# ...     highway.'
# >>> is "${on_entheogens}" == (#thc)(#cbd) si
# zsh: run_code:56: bad pattern: (#thc)(#cbd)
# >>> is_string_matches_glob_safely "${on_entheogens}" (#thc)(#cbd)
# ┎┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈• is_string_matches_glob_safely •┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┒
# ┋ is_string_matches_glob_safely() failed with exit status 1.                  ┋
# ┋ Glob "(#thc)(#cbd)" invalid:                                                ┋
# ┋     run_code:56: bad pattern: (#thc)(#cbd)                                  ┋
# ┖┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┚
# ┖• die() { /home/leycec/.zeshy/cache/digest/debug.zwc/is_string_matches_glob_safely: 28 }
#  ┖• is_string_matches_glob_safely() { /bin/zsh: 2 }
# ------------------------------------------
# ==========================================
# /---

#FUXME: Rename to :is_string_matches_glob_safe_by_coprocess(). It's critical
#we inform the caller that we're internally closing and reopening the coprocess.
#Likewise, all functions transitively calling *THIS* function should be
#similarly renamed. Note that, while the glob test this function internally
#performs *APPEARS* to be side-effect free and hence call the safer function
#:run_code_silent_and_set_string_to_stderr_by_subshell() internally, such test
#sets global variables (e.g., ${match}) and hence *MUST* be run in the current
#shell with a coprocess.
#FUXME: *WAIT*. We've uncovered how to implement this safely. Happily,
#:redefine_func() demonstrates how to do so already: first perform a silent
#match in the current shell *WITHOUT* a coprocess and then if such match reports
#failure reperform such match in a command substitution to capture stderr. In
#the latter case, if stderr is nonempty, a glob error occurred, so throw stderr
#as an exception; else, no such error occurred, implying the match simply
#failed, so report failure from such function. Efficient. Safe. Requires *NO*
#coprocess and only requires a subshell when such match fails. (Since
#coprocesses always require a subshell, the above is in fact a significantly
#more efficient approach.) Go-go-go!
#FUXME: After implementing the above correction, rename such function to simply
#::is_string_matches_glob(). Yay!

    # Test to be performed. For obscure error handling reasons, we interpolate
    # such test into several eval() calls below.
    #
    # Note that such glob *MUST* be left unquoted here.
    # test='is "${text}" == ${~glob} si'

    # Perform such test. If such glob is syntactically invalid, zsh emits a
    # nonfatal warning to standard error and reports failure; if such glob is
    # syntactically valid but such test fails, zsh reports failure without
    # printing to standard error. In the former case, this function converts
    # such nonfatal warning to a fatal exception; in the latter case, this
    # function merely reports failure.
    #
    # If such test fails, distinguish the two cases by capturing and testing
    # standard error produced by such test.
    #
    # If such test succeeds, such glob *MUST* be syntactically valid. In such
    # case, report success.
    # { eval "${test}" } silent_stderr: or {
    #     # Capture such error, ignoring the expected failure.
    #     :string error; error="$(
    #         { eval "${test}" } to_stdout: or ignore_failure)"

    # Since zsh fails to signal a trap (and hence fatal
    # exception) on syntactic errors in such glob, forcefully capture standard
    # error into a string local to be subsequently tested.
    #
    # If such test succeeds, such glob *MUST* be syntactically valid. Return
    # success.

    # Test such match. Avoid quoting such glob. Since such test fails to signal
    # fatal errors and hence throw exceptions on glob syntax errors, forcefully
    # capture standard error into a string local to be subsequently tested.
    #
    # If such test succeeds, such glob *MUST* be syntactically valid. Return
    # success.
#     if { :run_code_silent_and_set_string_to_stderr_by_coprocess\
#         'is "${text}" == ${~glob} si' stderr } {
# #       'is "${text}" == '${(q)glob}' si' stderr } {
#         report_success
    # Else, such test failed. Since this implies that either such glob is
    # syntactically invalid *OR* such glob is syntactically valid and such
    # string fails to match such glob, examine the captured standard error to
    # determine which occurred.
    #
    # If such glob is syntactically invalid, throw an exception with the error
    # reported by zsh. See is_string_nonempty() for further details.
    # } elif { is -n "${stderr}" si } {
    #     # If such error is prefixed by "zsh: ", remove such prefix.
    #     stderr="$(remove_string_prefix "${stderr}" 'zsh: ')"
    #     die "Glob \"${glob}\" invalid:${ZESHY_ASCII_NEWLINE}    ${stderr}"
    # # Else, such glob is syntactically valid and such string fails to match such
    # # glob. Return failure, "damn your eyes!"
    # } else {
    #     report_failure
    # }

#FUXME: Rename to :is_string_matches_glob_safely_by_coprocess(). It's critical
#we inform the caller that we're internally closing and reopening the coprocess.
#Likewise, all functions transitively calling *THIS* function should be
#similarly renamed.

# ; the latter (slightly) reduce match efficiency.
# Consider calling :is_string_matches_glob_grouped() or prefix such glob
# with `(#b)` to set all such globals: e.g.,

#FUXME: Rename to is_string_matches_glob_grouped().
#   string text="${1}" glob
#   glob="$(convert_string_to_glob_capturing_substrings "${2}")"
#   output_string "glob: ${glob}"
#   is "${text}" == ${~glob} si
#   string text="${1}" glob
#   glob="$(convert_string_to_glob_capturing_groups_and_substrings "${2}")"
#   is "${text}" == ${~glob} si
#   is "${text}" == ${~glob} si
#       string text="${1}" glob="${2}"
#       die "String \"$(truncate_string_readable: "${text}")\" unmatched by glob \"${glob}\"."
#   }

#...    "Good evening, London. I thought it time we had a little talk. Are you
#...     sitting comfortably? Then I'll begin...
#...     It's always the children who suffer, as you're well aware. Poor little
#...     mites. What are they to make of it? What are they to make of your
#...     bullying, your despair, your cowardice and all your fondly nurtured
#...     bigotries? Really, it's not good enough, is it? And it's no good
#...     blaming the drop in work standards upon bad management, either...
#...     Though, to be sure, the management is very bad. In fact, let us not
#...     mince words ... the management is terrible! We've had a string of
#...     embezzlers, frauds, liars and lunatics making a string of catastrophic
#...     decisions. This is plain fact.
#...     But who elected them? It was you! You who appointed these people! You
#...     who gave them the power to make your decisions for you! While I'll admit
#...     that anyone can make a mistake once, to go on making the same lethal
#...     errors century after century seems to me nothing short of deliberate.
#...     You have encouraged these malicious incompetents, who have made your
#...     working life a shambles. You have accepted without question their
#...     senseless orders. You have allowed them to fill your workspace with
#...     dangerous and unproven machines.
#...     All you had to say was \"NO.\" 

#FUXME: Honestly, the distinction between this function and the function
#immediately following this function is utter *BANALITY*. No such distinction
#exists for 
#FUXME: The current "matches_glob" and "matches_pcre" nomenclature is fairly
#off-kilter, frankly. Contemplate globally renaming such substrings to
#"matches_glob" and "matches_pcre" everywhere.

#FUXME: Also, note that glob expressions *CAN* match at the beginning and end of
#strings: flags "s" and "e" in the same section as above. Between this and
#backreferencing, I believe we've largely obsoleted our need for regular
#expression matching in the Zeshy codebase and should probably substitute all
#such matching with more efficient and certainly elegant glob matching.
#FUXME: O.K.; the current nomenclature of prefixing only PCRE matching functions
#is no longer tenable. Why? For one, it's unclear which actually *IS* more
#efficient. In some cases, the PCRE version is clearly more efficient (e.g.,
#for_string_text_matching_pcre:(), which unlike for_string_matches_glob() does *NOT* fork a
#subshell for each match). We need to manually suffix all of the below with
#"_glob". I know; I know. But it just needs to be done.
#FUXME: Ah-ha! While the current approach of single-quoting passed globs
#certainly works, wouldn't it be preferable if we could just pass globs as is
#(i.e., unquoted)? Turns out, we can! At least, I *THINK* we can. It requires
#testing, but "man zshmisc" suggests that prefixing each call to a function
#accepting such globs with "noglob " disables implicit filename globbing of
#shell words and hence permits passing unquoted globs. (This must be how the
#canonical catch() function works...) Naturally, writing "noglob " everywhere
#would be silly -- so we implement the same clever hack catch() implements.
#Namely, we alias the same name to expand to itself prefixed by "noglob ": e.g.,
#
#    alias :is_string_matches_glob='noglob :is_string_matches_glob'
#
#And we should be good to go. Thanks to digest magic, just add each such alias
#*IMMEDIATELY BEFORE THE FUNCTION IT EXPANDS*, below. This will help us to
#maintain all of this abominable machinery, which I must say... ROCKS!

#slightly reduces match efficiency
#This function does _not_ necessarily provide such command access to
#${match}, ${mbegin}, or ${mend}, as doing so slightly reduces match efficiency.

    #FUXME: In fact, do this *EVERYWHERE* in this component. If there's no
    #performance impact (and there isn't), there's no compelling reason *NOT* to
    #do so.

    # Induce the passed glob to capture matched substrings.
#FUXME: Hmm. Niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiice. It turns out it *IS*
#possible to match globs iteratively in a manner similar to that of regular
#expressions. Should be fairly efficient, as well. First, note that parameter
#expansion "${string//(#m)${~glob}/${MATCH}}" is a noop iteratively replacing
#all substrings matching glob ${glob} with themselves. That isn't terribly
#useful, but note that this is generalizable into a similar parameter
#expansion "${string//(#m)${~glob}/$(run_code_on_match "${command}" "${MATCH}"; print_string "${MATCH}")}". Now *THIS* is clever. Unsure why I didn't think of it earlier,
#honestly. For each match, pass such match to helper function
#run_code_on_match() evaluating the passed "${command}", presumably passed
#the current match with standard output and error redirected to the bit bucket
#(to avoid mucking up the current match). Then, assuming such evaluation does
#not throw an exception, print such match, thus avoiding changing such string.
#Ah! Note that if we run the simpler parameter expansion
#"noop ${string//(#m)${~glob}/$(run_code_on_match "${command}" "${MATCH}")}",
#we achieve the same effect! No need to worry about whether or not we replace
#matched substrings, since we don't bother assigning the resulting string. Nice.
#In fact, it might even (slightly) improve efficiency to just replace all
#matches with the empty string (e.g., ";print;"), resulting in a smaller
#temporary string to be retained in-memory.

#declare_function_with_stdin <<'/---'
#[status: bool] is_string_contains_glob_characters(string text)
#
#Report success if the passed string contains at least one glob-reserved
#character. This includes most ASCII punctuation (e.g., `[`, `<`, `(`, `|`, `+`).
#/---
#function is_string_contains_glob_characters() {
#    die_unless_arg 'expected one string'
#    :is_string_matches_glob "${1}" *[\[\]\<\>\(\)\|+*?#~^]*
#}

    # Validate passed arguments
#   die_unless_args_2\
#       'expected one string and one glob expression'
#   string text="${1}" glob="${2}"

    #FUXME: Fairly silly, premature optimization. I mean, how often will an
    #empty string or glob or glob with no glob-reserved characters be passed?
    #This can all pretty much be reduced to a single command calling
    #for_string_match(). The implementation should resemble the corresponding
    #PCRE implementation. See such function!

    # If either such string or glob is empty, there can be no possible matches.
#   if is -z "${text}" or -z "${glob}" si {
#       return_string 0
    # If such glob contains no glob-reserved characters, such glob is a string
    # literal. Get the number of instances of such literal in such string.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_text_count "${text}" "${glob}")"
    # Else, count with brute-force iteration. While zsh offers no flags or
    # functions for optimizing counting, iterating a counter while removing each
    # match until no matches remain suffices to yield the number of matches.
#   } else {
#       integer match_count=-1
#       string text_old

#       # For efficiency, avoid calling is_string_equals().
#       until { is "${text_old}" == "${text}" si } {
#           (( ++match_count ))
#           text_old="${text}"
#           text="${text/${~glob}/}"
#       }

#       return_string ${match_count}
#   }

#capture groups into canonical list globals (i.e., ${match}, ${mbegin}, ${mend})
#and substrings into canonical string globals (i.e., ${MATCH}, ${MBEGIN},
#${MEND}). .

#This function does _not_ implicitly capture match groups into canonical `zsh`
#globals (e.g., `${match}`). To perform such capturing, consider calling
#:is_string_matches_glob_grouped() instead.

#   die_unless_args_2 'expected one string and one glob'
#   is "${1}" == ${~2} si
#...     Personal success is not wrong. But it is limited in importance, and once
#...     you have enough of it it is a shame to keep striving for that, instead
#...     of for truth, beauty, or justice."
    # If not containing globbing flags "(#b)" or "(#m)", prefix such glob with
    # such strings. For efficiency, inline such tests.
#   is "${glob}" == *'(#b)'* si or glob="(#b)${glob}"
#   is "${glob}" == *'(#m)'* si or glob="(#m)${glob}"

    # Return such glob.
#   return_string "${glob}"

#   die_unless_arg 'expected one glob'
#   string glob="${1}"

    # If not containing globbing flag "(#m)", prefix such glob with such flag.
#   if is "${glob}" == *'(#m)'* si {
#       return_string "(#m)${glob}"
    # Else, do not.
#   } else {
#       return_string "${glob}"
#   }

#FUXME: Note that for_string_text_matching_pcre:() documents similar globals. We should
#aggregate such documentation into a single function and cross-reference such
#function everywhere else.
#FUXME: Rename to is_string_matches_captivated() or
#is_string_matches_capturing(). The latter reads poorly, so... the former? Both
#read poorly, actually. How about :is_string_matches_glob_grouped()? Nice one!
#Actually, is_string_matches_captivatingly()... nah. Scratch that. Insanity. Go
#:is_string_matches_glob_grouped().
#FUXME: Call convert_string_to_glob_capturing_groups_and_substrings() internally
#for improved generality.

#* `${MATCH}`, a string global expanding to the entire matched substring.
#* `${match}`, a list global containing each match group captured within such
#  substring (e.g., `${match[1]}`, the first match group).
#* `${mbegin}`, a list global containing each 1-based index of the passed string
#  at which the corresponding match group starts (e.g., `${mbegin[1]}`, the index
#  at which the first match group starts).
#* `${mend}`, a list global containing each 1-based index of the passed string
#  at which the corresponding match group ends (e.g., `${mend[1]}`, the index
#  at which the first match group ends).

#When successfully matching, such glob sets list globals `${match}`, `${mbegin}`,
#and `${mend}` containing matched groups. See :is_string_matches_glob_grouped()
#for further details.

#In such case, access such groups after calling this function with the following
#list globals:
#
#* `${match}`, each element the substring captured by the match group with the
#  same list index or the empty string if no such substring was captured (e.g.,
#  `${match[1]}`, the substring captured by the first match group).
#* `${mbegin}`, each element the index of the passed string at which the
#  substring captured by the match group with the same list index begins (e.g.,
#  `${mbegin[1]}`, the string index at which the first match group begins).
#* `${mend}`, each element the index of the passed string at which the substring
#  captured by the match group with the same list index ends (e.g., `${mend[1]}`,
#  the string index at which the first match group ends).

#FUXME: Rename to convert_string_to_glob_matching_lines(), in keeping with
#convert_string_to_pcre_matching_lines() nomenclature.
#FUXME: Rename to convert_string_to_glob_capturing_groups() or
#convert_string_to_glob_matching_groups(). Hmmm; the former's a bit more verbose
#but much more explanatory and hence preferable. I mean, every glob "matches
#groups" already, so the latter conveys no meaningful information.
    #FUXME: Extract into a new get_string_text_count() function.
    # If the passed glob expression contains no glob-reserved characters,
    # matching matches such expression as is. Thusly, the length of each match
    # is the length of such expression. The difference between the passed string
    # and a string with all such matches removed divided by the length of each
    # match yields the number of matches. Clever logic obscenely wins.
#   } elif { not is_string_contains_glob_characters "${glob}" } {
#       return_string "$(get_string_text_count "${text}" "${glob}")"
#       string text_matches_deleted="${text//${glob}/}"
#       return_string $(( (${#text} - ${#text_matches_deleted}) / ${#glob} ))

# (i.e., saving `(` and
#`)`-delimited match groups in global list ${match})
#   if is "${text}" == ${~glob} si
#FUXME: Rename to get_string_text_matching_glob_group(). The current function name is
#exceptionally ambiguous; after all, there could be multiple means of specifying
#which match to retrieve, of which group indices are merely the most obvious.
    #FUXME: Verify whether this suffices for instances of "${match[1]}" and so
    #forth in the replacement. I strongly suspect not (...in fact, let us say,
    #obviously not), in which case we require a separate
    #replace_string_match_with_evaluation() function.
#FUXME: I've never enjoyed pretending such functions to be getters. Rename to
#convert_string_to_glob_capturing_groups().
#FUXME: Rename to convert_string_to_glob_matching_lines()... or perhaps simply
#convert_string_to_glob_matching_lines(). Yes! The latter. Perfect.
# Such strings must be quote protected to be matched as specified when globbing.
#FUXME: No longer convinced this function is a good idea. The principle issue is
#quoting, which plays poorly with and in any case obstructs construction of
#string globs. Excise this function.

#FUXME: This needs a rename. It can currently be read in two very different
#ways, and the expected reading is *NOT* the actual reading. How about
#is_string_matches_capturing_groups_groups() or
#:is_string_matches_glob_grouped()? I prefer the former, I reckon. The added
#"_with" makes all the difference for readability here.
#FUXME: Rename to enable_glob_group_capturing()?
#FUXME: Rename to enable_glob_line_matching()?
# * Ah-ha! I finally found how to do proper matching with glob expressions:
#   flag "b". To quote, "Activate backreferences for parenthesised groups in the
#   pattern...". See "man zshexpn" for details. Sweetness.

    # Sadly, neither sed, awk, grep, or zsh itself have any coherent means of
    # matching individual occurences of a substring. Fortunately, zsh does have
    # a simple mechanism for *ELIMINATING* such matches. Hence, we do so
    # iteratively until all such matches are eliminated.
#FUXME: Ehrm; I'm quite sure there's a simple parameter expansion flag already
#implementing this. Man up "zshexpn", please. 

# Among other uses, this function counts occurrences of characters and substrings in strings#
# See also get_integer_of_matches(), similar but slightly more efficient by
# matching via one regular rather than multiple glob expressions.
