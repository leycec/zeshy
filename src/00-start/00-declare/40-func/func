#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *function declarers* (i.e., functions declaring, but _not_ necessarily
defining, other functions).
/---

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

#FIXME: We can do *CONSIDERABLY* more with :func_(). Given the
#acquisition of function prototypes prior to their definitions, we can
#automatically synthesize function argument validation! Specifically:
#
#* If the current digest file is *NOT* an optimized build:
#  * Prepend an expression resembling
#    '$(( # == ${num_args_expected} )) || :die\
#        "Function ${func_name}() expects ${num_args_expected} rather than ${#} arguments:"$'\n'${func_prototype}
#  * For all arguments of type ":string" either prefixed or suffixed by a
#    string matching glob "(bool|float|int|list|map|string)_name", append the
#    previously prepended expression with a call to function
#    "die_unless_var_${var_type}", passing such call the numbered argument
#    corresponding to such variable name.
#    *ACTUALLY*, we probably want a new syntax for specifying the type of the
#    variable a pointer variable points to: e.g.,
#
#    :void :set_list_to_cthulhu(:string:list list_name)
#
#    Then, we simply perform such validation in a deterministic manner
#    dependenly *ONLY* on such type. Much more sensible. Make it so!
#
#There's probably a great deal more we could accomplish as well, but that
#certainly seems a respectable starting place. The helpful aspect of this whole
#thing isn't necessarily the code savings in reduced verbosity (though that's
#excellent as well, of course): it's the fact that this is pretty much the
#*ONLY* way to reliably elide such validation out of optimized builds.
#Pretty awesome, honestly.
#FIXME: Also consider implementing the following prototype validation features:
#
#* Optional type validation. It's easy to conceive of functions that (typically
#  for efficiency) depend on downstream functions to validate types. Indeed, in
#  a chain of such functions, it's often unnecessary for any functions except
#  the deepest in the call stack (e.g., :set_string_to_string()) to validate
#  the types of passed variables. Hence, we'll want a new syntactic construct
#  to permit callers to selectively disable such validation on a per-argument
#  basis. Fortunately, we already have a similar syntax for arguments
#  themselves: the eroteme. For example:
#
#    # Given this prototype, zeshy validates the type of the first argument.
#    [status = :bool] :set_int_to_arg_index_first_equaling_if_found(
#        :string:int int_name, :string arg)
#
#    # Given this prototype, however, zeshy does *NOT* validate the type of the
#    first argument.
#    [status = :bool] :set_int_to_arg_index_first_equaling_if_found(
#        :string:int? int_name, :string arg)
#
#  The only difference between the two, of course, is the "?" suffixing the
#  type of the first argument. Simple, no?
#
#* Argument subtypes. The typical example here are, say, positive integers:
#
#    [status = :bool] :get_arg_index(:int_positive arg_index)
#
#  Subtypes should be readily generalizable as follows:
#
#  * If there exists a runnable with name ":die_unless_${arg_type#:}", pass
#    such argument to such runnable in the preamble for such function.
#  * Of course, subtypes should be subject to suffixing erotemes as well.
#
#* Default value assignment. By default, argument names suffixed by a "="-
#  prefixed default value should *NOT* be programmatically assigned such value;
#  leave that to the implementation of such function. That said, there are
#  numerous cases (particularly exception handlers) where it'd be absurdly
#  convenient to have some means of :func_() assigning such argument
#  such value if unpassed. So, here's how: argument names suffixed by a ":="-
#  prefixed default value should be programmatically assigned such value.
#  What's nice about such syntax is that it leverages existing zsh syntax for
#  an orthogonal purpose. Here's a typical use:
#
#    :func_ '<globbable> :void :die_unless_string_matches_glob(
#        :string text,
#        :string glob,
#        :string error_message :=
#            "String \"${text}\" unmatched by glob \"${glob}\".")'
#
#  As such example demonstrates, default string (but *NOT* integer or float,
#  clearly) values should be assigned under parameter expansion flag "(e)",
#  ensuring expansion of expansions embedded in such values (as above).
#
#* New return pseudo-type ":full". We're increasingly tired of repeating the
#  return channel list "[stdout = :string, stderr = :string, status = :int]"
#  for runnables running arbitrary commands. Note this will require us to
#  differentiate between pseudo-types ":full" and ":void", necessitating a
#  minor change to PCRE group capturing (but probably *NOT* to parsing, as I
#  believe we currently don't parse return types or channels). And -- yes,
#  we've extensively searched for adequate synonyms of full, and none suffice.
#  In the end, the two most compelling reasons for full are:
#  * It reads as equally well as an adjective as void (e.g., "full function",
#    "void function").
#  * It's the obvious antonym of void and equally as many characters, sufficing
#    for the pendant in all of us.

#FIXME: It could also be nice to concoct opt-in syntax for having zeshy
#automatically synthesize argument localization on behalf of declared
#functions. This should absolutely *NOT* happen by default (...just consider
#functions accepting variable names, for example), necessitating we devise no
#syntax. Since such syntax should apply to the *ENTIRE* argument list (i.e.,
#either zeshy localizes *ALL* passed arguments or it localizes none), there
#exist a number of approaches:
#
#1. A new runnable attribute "<localize>" (e.g.,
#   "<localize> :void :my_func(:string my_arg)").
#
#O.K.; forget the other approaches. The above is pretty awesome. It's a wee
#verbose, yes: but given the import, this doesn't seem horribly out of place.
#Indeed, we could then provide a second related attribute for localizing
#attributes suffixed by a function name-derived acronym. Wait; that's actually
#*VERY* bad, as functions defined by such a function would silently alter their
#definition (thus almost certainly breaking) on mere function renames, which is
#horrible. So *NEVER, EVER* go down that road. (Thanks.)
#
#Anyway: the above approach fairly rocks. So, hey-ho: let's go.
#FIXME: Wait. Rather than having a function-wide localization attribute, it'd
#probably be significantly more helpful going forward to have an
#argument-specific syntax -- ideally, only a single character prefixing or
#suffixing such argument's type. For example:
#
#    # In this case, the string but *NOT* integer would be localized.
#    :void my_func(:=string my_string, :int my_int)
#
#    # Alternative syntax to the above:
#    :void my_func(`:string my_string, :int my_int)
#    :void my_func(^:string my_string, :int my_int)
#    :void my_func(&:string my_string, :int my_int)
#    :void my_func(|:string my_string, :int my_int)
#    :void my_func(\:string my_string, :int my_int)
#    :void my_func(/:string my_string, :int my_int)
#    :void my_func(@:string my_string, :int my_int)
#    :void my_func(>:string my_string, :int my_int)
#    :void my_func(<:string my_string, :int my_int)
#    :void my_func(v:string my_string, :int my_int)
#    :void my_func(+:string my_string, :int my_int)
#    :void my_func(~:string my_string, :int my_int)
#    :void my_func(#:string my_string, :int my_int)
#    :void my_func(*:string my_string, :int my_int)
#    :void my_func(!:string my_string, :int my_int)
#    :void my_func(:string= my_string, :int my_int)
#    :void my_func($:string my_string, :int my_int)
#    :void my_func(:string $my_string, :int my_int)
#
#The above example suggests either a "^" or "@" prefixing such argument's type
#to be appropriate syntax here. We're currently partial towards "^". given
#zsh's current usage of such character prefixing variable names in parameter
#expansions... Hmm; perhaps those two usages have nothing in common, after all.
#Indeed, given that "@" signifies the passed argument list, perhaps a "@"
#prefix is the more appropriate, here. It reads a bit awkwardly, though; the
#"@" sign is so aesthetically strong as to compell the eye away from the
#remainder of the prototype, when such sign is arguably semantically
#insignificant by compare to the remainder of such prototype.
#
#We're currently partial towards either "^" prefixing the argument type *OR*
#"$" prefixing the argument name. The latter is reasonably interesting,
#directly implying such argument to be expandable as that name within the
#function body, whereas the former is more indicative of "copying" the
#following argument declaration into the head of the function body. Either way,
#we probably can't go *TOO* wrong here.
#FIXME: Actually, "$" is horrible, for a variety of obvious reasons -- chief of
#which is that it implies :func_() internally expands "$"-prefixed
#variable names embedded in function prototypes *BEFORE* parsing such
#prototypes, which is *NOT* at all the case. Given that, we're currently
#trending towards either "`" or "^". And we have to say, "`" appears
#surprisingly attractive. Consider:
#
#* "`" is semantically "free." zeshy currently avoids all internal use of "`",
#  unlike "^". "`" has no implicit meaning in a zeshy context and hence may be
#  repurposed with alternative semantics.
#* "`" is a conventional delimiting prefix in many languages.
#" "`" is syntactically and aesthetically "quiet" (i.e., visually unobtrusive).
#
#Honestly, I say we go with "`".
#FIXME: That said, "^" *DOES* get the idea across a bit more intuitively. Hmm;
#or *DOES* it, really? "`" *DOES* quite remind one of the use of single quotes
#in math jargon to denote derivative variables, which localized variables
#arguably are. Wow! There's a fairly compelling justification, if ever we heard
#one. And we've heard a few now.
#FIXME: After deep and reasonably lengthy contemplation, we've decided upon a
#syntactic technique hereafter referred to as "relaxation directives" --
#each consisting of the same single character and prefixing the syntactic
#element they "relax." What do we mean "relax"? Simple: they instruct our
#parser to relax what it would customarily do and *NOT* do that thing. To
#prevent semantic ambiguity and simplify lexical parsing (e.g., with the "?"
#suffixing argument names), all relaxation directives *PREFIX* their syntactic
#element. Horever, we haven't quite fixed upon a character; examples include:
#
#    :void my_func(`:string `my_string `= 'yumyum', :int my_int)
#    :void my_func(^:string ^my_string ^= 'yumyum', :int my_int)
#    :void my_func(*:string *my_string *= 'yumyum', :int my_int)
#    :void my_func(?:string ?my_string ?= 'yumyum', :int my_int)
#    :void my_func(/:string /my_string /= 'yumyum', :int my_int)
#    :void my_func(|:string |my_string |= 'yumyum', :int my_int)
#    :void my_func(%:string %my_string %= 'yumyum', :int my_int)
#    :void my_func(#:string #my_string #= 'yumyum', :int my_int)
#    :void my_func(~:string ~my_string ~= 'yumyum', :int my_int)
#    :void my_func(!:string !my_string != 'yumyum', :int my_int)
#
#While "!" is nice, when used with "!=", it implies a negative constraint
#(e.g., that such function throws an exception if such argument equals such
#string). Hence, prefer something else.
#
#O.K.; "*" is probably the most compelling prefix character. In PCREs, such
#character implies "0 or more"; here, it simply implies "0". Hmmm... Right.
#That's not quite aligned at all, is it?
#
#O.K.; "`" really remains an extraordinarily compelling choice here. A few
#meager reasons why:
#
#* It's probably the most aesthetically unobtrusive choice. Which is exactly
#  what we we want in this case, since relaxation directives are more-or-less
#  internal optimization concerns of negligible concern to end users.
#* It's also the most syntactically unobtrusive choice. We don't use "`"
#  anywhere within the codebase, leaving such character free for use here.
#* It's an appropriate prefix.
#
#And there you have it.
#
#That said, "^" remains a compelling choice as well, for similar reasons and
#due to implying "not" or "negation" somewhat more clearly than "`" due to its
#association with binary XOR operations. (Actually, that clearly has nothing to
#do with negation, so ignore that one.)
#
#Hmm. Nah; "^" is somewhat too loud and already used extensively in the
#codebase for alternative purposes. Let's run with "`"!
#FIXME: Implementing the above change requires another run-through the
#codebase, replacing existing usage of "?" with "`". Not a significant concern,
#of course, so we'll need to run-through anyway to implement delocalization.
#So, when we're at the point where we're ready to delocalize, also implement
#the above. Yeah: yay!
#FIXME: Actually, even the above is a bit... amiss. The default should be to
#localize, as that's what end users rightfully expect of reasonably high-level
#languages. They can elect to localize manually, of course, but that could
#simply be regarded as an optimization, which we syntactically denote with "?".
#Then, the following syntax serves to disable localization enabled by default:
#
#    :void my_func(?:string my_string{__mf}, ?:int my_int{__mf})
#
#Quite readable, we trust.

#FIXME: As an aside, it *IS* feasible to reliably localize strings indirectly
#referring to variable names. Just employ a new "{"- and "}"-delimited syntax,
#inspired by CLI aliases: e.g.,
#
#    :void my_func(`:string my_string{__mf}, `:int my_int{__mf})
#
#This results in the following localization within such function body:
#
#    :string my_string__mf="${1}" my_int__mf="${2}"
#
#...but in the following function prototype when presented to external users:
#
#    :void my_func(:string my_string, :int my_int)
#
#For readability, external prototypes omit all compilation-specific syntactic
#directives. Nice, eh?
#FIXME: Actually, employing "{"- and "}"-delimited syntax here is overly
#cumbersome (both to write and to parse), as we only genuinely require a single
#delimiting character for such purposes -- say, "^" or "+": e.g.,
#
#    :void my_func(`:string:string string_name+__mf, `:int int+__mf)
#    :void my_func(`:string:string string_name/__mf, `:int int/__mf)
#    :void my_func(`:string:string string_name#__mf, `:int int#__mf)
#    :void my_func(`:string:string string_name%__mf, `:int int%__mf)
#    :void my_func(`:string:string string_name|__mf, `:int int|__mf)
#    :void my_func(`:string:string string_name^__mf, `:int int^__mf)
#    :void my_func(`:string:string string_name*__mf, `:int int*__mf)
#    :void my_func(`:string:string string_name~__mf, `:int int~__mf)
#    :void my_func(`:string:string string_name.__mf, `:int int.__mf)
#    :void my_func(`:string:string string_name;__mf, `:int int;__mf)
#
#Right. So, "/" is pretty clearly the winner here. Such character implies an
#either-or conditional, which is indeed semantically the case here, as well as
#not overtly conflicting with existing syntax (e.g., unlike "#"). That said,
#"+" remains a compelling choice as well (for patently clear reasons).
#
#    :void func(`:string+glob glob+__mf, `:int+positive int+__mf)
#    :void func(`:string/glob glob/__mf, `:int/positive int/__mf)
#    :void func(`:string/glob glob+__mf, `:int/positive int+__mf)
#
#Oh, my. "+" is *CLEARLY* the superior choice here.
#FIXME: As the prior example demonstrates, we need to support "+" delimitation
#in both argument types *AND* names. In the former case, such "+" delimits the
#argument type to be declared during localization (e.g., ":string") from the
#stricter suffix of the validating exception handler (e.g., ":string_glob"); in
#the latter case, such "+" delimits the argument name to be externally
#published (e.g., "glob") from the argument name to be internally declared
#during localization (e.g., "glob__mf").
#FIXME: Wait. As the prior explanation suggests, "+" would literally imply
#opposite semantics under such syntax! Which is bad. To correct this, note that
#we (probably) want to separate argument types for localization purposes from
#argument types for validation purposes. Since the two need not have anything
#to do with one another, consider this:
#
#    :void func(
#        `:string/:string_glob glob+__mf,
#        `:int/:int_positive int+__mf)
#    :void func(
#        `:string/glob glob+__mf,
#        `:int/positive int+__mf)
#
#Somewhat more verbose, of course, but substantially more generalizable. Hmm;
#since most cases *WILL* duplicate the argument type for localization  in the
#argument type for validation, however, perhaps we might provide a shorthand
#abbreviation for doing so? Consider:
#
#    :void func(`:string+_glob glob+__mf, `:int+_positive int+__mf)
#
#Uh; right. You know, that looks good. Let's just dispense with this kludgy "/"
#business. If the two argument types differ that substantially, the function
#body should just manually call the desired exception handler.
#
#It *IS* odd, however, that the above example would be localized as
#":string glob__mf" and validated as ":string.die_unless_glob glob__mf".
#Oh; nevermind. That makes perfectly consistent internal sense, as well. O.K.;
#O.K.; "+" it is for both. Yay!
#FIXME: Hmm; there exists an interesting edge case suggesting "+" may *NOT*
#necessarily be the most appropriate signifier. Ideally, it would be nice to
#permit not merely the type but value of the variable to which indirect
#arguments refer to be validated; "+" syntax, however, only supports the
#latter. Consider:
#
#    :void :func.set_string_to_orthonormal_prefix(
#        :string:int+negative int_name+__mf,
#        `:string+glob glob+__mf,
#        `:int+positive int+__mf)
#
#So, the variable referred to by the first argument above would have its type
#validated by calling :var.is_type_int() and its value validated by calling
#:int.is_negative(). Actually, that works perfecetly with "+" syntax, which is
#mildly pleasing to the rain-besought ego.

#FIXME: Replace the current "<globbable>" attribute by a new argument
#pseudo-type ":glob", which function parsing should then internally detect and
#set a local boolean if at least one argument has such type: e.g.,
#
#    # Shift from this...
#    <globbable> [status = :bool] :is_string_matches_glob(
#        :string text, :string glob)
#
#    # ...to this.
#    [status = :bool] :is_string_matches_glob(:string text, :glob glob)
#
#I think we can all agree the latter to be demonstrably superior.
#FIXME: Actually, for readability (and orthogonality with existing subtypes
#like ":int_positive"), such subtype should really be ":string_glob": e.g.,
#
#    [status = :bool] :is_string_matches_glob(:string text, :string_glob glob)
#
#We'll need to globally replace everywhere we previously wrote ":glob", sadly.

#FIXME: I'm beginning to question the wisdom of maintaining separate
#"_with_stdin" versions. Since AsciiDoc syntax *FUNDAMENTALLY* conflicts with
#single- and double-quoted string syntax, I see little point in continuing to
#maintain such versions. The work involved has been a headache from the start.
#It also renders the codebase less readable than it should be. Ideally,
#everything should resemble:
#
#    declare_function <<'/---'
#    ...
#    /---
#
#Rather than:
#
#    declare_function_with_stdin <<'/---'
#    ...
#    /---
#
#To synopsize:
#
#* Change declare_function() to require documentation passed as stdin. (Indeed,
#  such documentation should be optional for aliases and globals but *NOT*
#  functions; in the former case, the alias or global to be declared can be
#  specified entirely in separate arguments. Since this is *NOT* the case for
#  functions, require stdin.)
#* Inline the run_runnable_with_stdin() implementation in each such function,
#  for both simplicity and efficiency. (It's not terribly complex, really.)
#* Replace all existing calls to declare_function_with_stdin() with
#  declare_function().
#FIXME: This largely obsoletes the run_runnable_with_stdin() function, which,
#due to its still usefulness, should be shifted into "runnable/command/command"
#(or a similar parcel nearby).

#FIXME: It'd be great to add an additional runnable attribute -- this time,
#applicable to both aliases and functions. You may have noted extreme repetition
#in declaring hooks: e.g.,
#
#  :run_hook_on_zeshy_precompile precompile_zeshy_terminal_colors
#
#  declare_function_with_stdin <<'/---'
#  void precompile_zeshy_terminal_colors()
#
#  Define terminal color globals to be compiled into zeshy's user digest file.
#  /---
#  function precompile_zeshy_terminal_colors() { ... }
#
#To reduce such redundancy, support a new attribute "hooks: ...", where "..." is
#either the name of a single hook function or a list of such names. This reduces
#the above example to simply:
#
#  declare_function_with_stdin <<'/---'
#  <hooks: on_zeshy_precompile> void precompile_zeshy_terminal_colors()
#
#  Define terminal color globals to be compiled into zeshy's user digest file.
#  /---
#  function precompile_zeshy_terminal_colors() { ... }
#
#If such function also needed to be run on, say, zeshy startup, this could be
#expanded to:
#
#  declare_function_with_stdin <<'/---'
#  <hooks: (on_zeshy_precompile, on_zeshy_startup)>
#       void precompile_zeshy_terminal_colors()
#
#  Define terminal color globals to be compiled into zeshy's user digest file.
#  /---
#  function precompile_zeshy_terminal_colors() { ... }
#
#Alias and function prototype parsing should then parse such list (e.g., by
#"borrowing" the similar parsing we've already implemented for argument lists)
#and for each such string, prefix such string with "run_hook_on_", throw an
#exception if the result is not an existing function, and otherwise run such
#function with all such alias and function names.

#FIXME: Remove all reference to {prepend,append,set}_args_with_stdin() from the
#Zeshy codebase, excluding set_args_with_stdin() where called from herestring-
#style aliases. In all other cases, such calls are highly dangerous and should
#be eliminated.
#FIXME: Wait. I believe we *MIGHT* be able to resuscitate such function *IF* we
#can augment them as follows (...no idea if this works, but it seems worth a
#try):
#
#* If standard input is an open pipe *AND* if list global ${pipestatus} is of
#  size larger than one, then doesn't that definitively suggest the current
#  function is directly piped standard input? Naturally, we should extensively
#  test this in vanilla zsh before running around like a mad badger attempting
#  to implement this in Zeshy. Ah; perhaps not. For example, for the first
#  function called in such a pipe, wouldn't ${pipestatus} be the empty list?

# ....................{ GLOBALS ~ private                  }....................
:document_global <<'/---'
:string ZESHY_DECLARE_FUNC_PROTOTYPE__

Private prototype for the currently declared function, specific to
:func_() and intended to be referenced only by such function.
/---
typeset -g ZESHY_DECLARE_FUNC_PROTOTYPE__ 

:document_global <<'/---'
:string ZESHY_DECLARE_FUNC_ARGS__

Private string of all arguments for the currently declared function, parsed
from such function's prototype. Such string is specific to :func_() and
intended to be referenced only by such function.

== Caveats ==

Due to internal complexity, such arguments cannot reasonably be split into a
list (e.g., as with ${ZESHY_DECLARE_FUNC_NAMES__}) or map (e.g., as with
${ZESHY_DECLARE_FUNC_ATTRS__}), but must instead by split in a just-in-time
manner with iterative PCRE-based matching.
/---
typeset -g ZESHY_DECLARE_FUNC_ARGS__

:document_global <<'/---'
:map ZESHY_DECLARE_FUNC_ATTRS__

Private map from attribute name to value for the currently declared function,
parsed from such function's prototype. Such map is specific to :func_()
and intended to be referenced only by such function.
/---
typeset -gA ZESHY_DECLARE_FUNC_ATTRS__

:document_global <<'/---'
:list ZESHY_DECLARE_FUNC_NAMES__

Private list of all function names for the currently declared function, parsed
from such function's prototype. Such list is specific to :func_() and
intended to be referenced only by such function.
/---
typeset -ga ZESHY_DECLARE_FUNC_NAMES__

# ....................{ ALIASES                            }....................
#FIXME: Document me.
alias -g ':func{'='
    :var.die_unless_type_list ZESHY_DECLARE_FUNC_NAMES__
    (( ${#ZESHY_DECLARE_FUNC_NAMES__} )) || :die\
        ''List ${ZESHY_DECLARE_FUNC_NAMES__} empty (e.g., as :func_() not previously called).''
    function "${ZESHY_DECLARE_FUNC_NAMES__[@]}" () {'

#FIXME: Document me.
alias '}:func'='}
    ::func_.stop'

# ....................{ DECLARERS                          }....................
#FIXME: Document me.
# :void {:func_, ::func_.start}(:string func_prototype)
function :func_ ::func_.start() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one function prototype.'

    # To safeguard against (accidental or intentional) deletion of globals
    # referenced below and elsewhere, forcefully redeclare such globals.
    typeset -g  ZESHY_DECLARE_FUNC_PROTOTYPE__ ZESHY_DECLARE_FUNC_ARGS__
    typeset -gA ZESHY_DECLARE_FUNC_ATTRS__
    typeset -ga ZESHY_DECLARE_FUNC_NAMES__

    # Globalize such prototype.
    ZESHY_DECLARE_FUNC_PROTOTYPE__="${1}"

    # Parse the map of function attributes and list of function names declared
    # from such prototype.
    :set_map,list,string_to_func_prototype_attrs,names,args\
        ZESHY_DECLARE_FUNC_ATTRS__\
        ZESHY_DECLARE_FUNC_NAMES__\
        ZESHY_DECLARE_FUNC_ARGS__\
        "${ZESHY_DECLARE_FUNC_PROTOTYPE__}"
    # print -r "args: ${ZESHY_DECLARE_FUNC_ARGS__}"

    # If any such function already exists, throw an exception.
    :die_if_func "${ZESHY_DECLARE_FUNC_NAMES__[@]}"
}

#FIXME: Document me. For up-to-date commentary, see the implementation of
#::func_.stop().

#FIXME: Document me. And oh, cripes -- is this function gonna need it.
#FIXME: Implement support for validating variable types (e.g.,
#":string:list", ":int").
#FIXME: Implement support for default argument handling. Since arguments
#can be directly set by index (e.g., "argv[1]='ok'"), this should be more
#than feasible. It will, however, require us to reexamine *ALL* current
#prototypes for valid default value definitions. (Ugh; we know.) Or, I
#suppose we could just defer such examination until the inevitable bugs
#crop up. Yah. Probably the latter.
#FIXME: Avoid performing such validation if compiling an optimized zeshy build.

# :void ::func_.stop[stdin: :string func_asciidoc]
function ::func_.stop() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'
    local func_preamble

    # If any such variable is either undefined or of unexpected type, throw an
    # exception. See :var.die_unless_type_string(), :var.die_unless_type_map(), and
    # :var.die_unless_type_list() for further details.
    :var.die_unless_type_string ZESHY_DECLARE_FUNC_PROTOTYPE__ ZESHY_DECLARE_FUNC_ARGS__
    :var.die_unless_type_map  ZESHY_DECLARE_FUNC_ATTRS__
    :var.die_unless_type_list ZESHY_DECLARE_FUNC_NAMES__

    # Define integer locals declared above by parsing each argument in the
    # argument list embedded in such function's prototype.
    ::func_.stop_parse_prototype

    # Declare and redefine each such function to begin with such preamble.
    # Alias :func{() previously defined such function, internally
    # stored by zsh in pre-parsed form (i.e., *NOT* stripped of all ignorable
    # lexical constructs, including comments and negligible whitespace). Hence,
    # such definitions retains all comments and negligible whitespace. As we
    # shall see, this is *NOT* necessarily a good thing.
    #
    # Redefining such function here reduces such function to its post-parsed
    # form (i.e., stripped of all ignorable lexical constructs).
    #
    # Hence, functions defined by :declare_func() fundamentally differ to
    # those defined by builtin function(). The former omits all ignorable
    # lexical constructs internally preserved by the latter, a seemingly
    # trivial fact that nonetheless provokes non-trivial side effects: e.g.,
    #
    # * While the pre- and post-parsed definitions for functions defined by
    #   builtin function() almost always differ, the pre- and post-parsed
    #   definitions for functions defined by this function are guaranteed to
    #   *NEVER* differ.
    # * Canonical integer global ${LINENO} corresponds to the current line
    #   number of the current function or script's pre-parsed definition.
    # * Similarly, line numbers suffixing canonical list global ${functrace}
    #   correspond to the line number of the listed function or script's
    #   pre-parsed definition on which the "next" function or script in the
    #   call stack was called.
    # * There currently exists no generally reliably means of accessing the
    #   pre-parsed definition of *ANY* function or script -- particularly if
    #   such function derives from a digest file, as all zeshy functions do.
    # * The prior observations directly imply that the definitions of functions
    #   defined by this function (but *NOT* by builtin function()) may be
    #   correlated with line numbers: both the current line number and the line
    #   numbers recorded on the call stack (e.g., due to thrown exceptions).
    # * The prior implication itself implies that functions defined by this
    #   function (but *NOT* by builtin function()) may support otherwise
    #   unsupportable functionality, including:
    #   * On detecting an uncaught exception, printing the lines of the
    #     function responsible for initially throwing such exception.
    local func_name
    for   func_name ("${ZESHY_DECLARE_FUNC_NAMES__[@]}") {

        # Redefine such function in a manner preserving post-parsed form (i.e.,
        # containing no comments or negligible whitespace).
        functions[${func_name}]=${func_preamble}$'\n'${functions[${func_name}]}

        # If such prototype declared attributes, handle such attributes.
        if (( ${#ZESHY_DECLARE_FUNC_ATTRS__} )) {
            # If such attributes include "globbable," disable filename globbing
            # for all arguments passed to such function by defining a simple
            # alias of the same name shadowing such function. See
            # is_list_contains() for further details.
            #
            # For safety (in the event of function names containing alias-
            # reserved characters), call :define_alias_simple() rather than
            # attempting to manually define such alias.
            if (( ${ZESHY_DECLARE_FUNC_ATTRS__[(i)globbable]} <=\
                 ${#ZESHY_DECLARE_FUNC_ATTRS__} )) {
                :define_alias_simple "${func_name}" "noglob ${(q)func_name}"
            }
        }

        #FIXME: This is fairly lame. See @{*-alias} for commentary.

        # Add such function to the current parcel.
        add_parcel_function "${ZESHY_PARCEL_NAME}" "${func_name}"
    }

    # Document such functions with such documentation *AFTER* successfully
    # defining such functions above.
    ::document_func_with_prototype,stdin_if_found_or_noop\
        "${ZESHY_DECLARE_FUNC_NAMES__[@]}"\
        "${ZESHY_DECLARE_FUNC_PROTOTYPE__}"

    # Undefine all such globals, ensuring this function will subsequently throw
    # an exception if called prior to :func_().
    unset\
        ZESHY_DECLARE_FUNC_PROTOTYPE__\
        ZESHY_DECLARE_FUNC_ATTRS__\
        ZESHY_DECLARE_FUNC_NAMES__\
        ZESHY_DECLARE_FUNC_ARGS__
}

# :void ::func_.stop_parse_prototype()
function ::func_.stop_parse_prototype() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'

    # Parse the minimum and maximum number of arguments such function accepts
    # *BEFORE* parsing such arguments. All reasonably sane implementations of
    # argument parsing require such numbers (e.g., to reliably index and expand
    # optional and variadic arguments and arguments following such arguments).
    #
    # Superficially, this appears to necessitate two parse passes over the
    # argument list: the first pass obtaining such numbers and the second pass
    # actually parsing such arguments. In practice, however, careful choices in
    # runnable prototype syntax reduce the first pass to efficient string
    # munging operations requiring *NO* explicit iteration. Indeed, note that:
    #
    # * Omitting single- and double-quoted strings, each "," in an argument
    #   list suggests such function to accept one more mandatory argument.
    # * Omitting single- and double-quoted strings, each "?" and "=" in an
    #   argument list suggests such function to accept one more optional
    #   argument.
    # * Each mandatory argument increases the maximum number of arguments such
    #   function accepts by one.
    # * Each optional argument reduces the minimum number of arguments such
    #   function accepts by one.
    #
    # Efficiently determining such numbers thus reduces to counting the number
    # of unquoted ",", "?", and "=" characters in such argument list.
    #
    # Unfortunately, while such determination *IS* demonstrably efficient,
    # conforming to the algorithm implemented below requires reparsing the
    # argument list once for each optional (but *NOT* variadic) argument such
    # function accepts. (Why? Because each additional optional argument implies
    # such function to accept one additional possible number of arguments and
    # each such number necessitates distinct code validation and hence
    # algorithmic handling here.)
    #
    # Unfortunately, eliminating such reparsing would require persisting a list
    # of argument metadata during the first and only pass for subsequent lookup
    # (as detailed below), itself imposing non-negligible inefficiencies. The
    # question then reduces to: which is less efficient, reparsing each
    # argument multiple times or parsing such arguments into a list only once?
    #
    # To answer this question, consider the common case. If most or even many
    # zeshy functions accepted optional arguments and hence required such
    # reparsing, such reparsing would indeed be non-ideal. In practice, few
    # zeshy functions accept optional arguments (due to readability and
    # writability concerns associated with such arguments). Since the common
    # case imposes no argument reparsing, reparsing poses no imposition.
    #
    # Note that the above two parse passes are technically invertable by
    # parsing all arguments into a list of all argument in the first pass and
    # iterating over such list in the second. In practice, the infrastructure
    # required by such iteration imposes significant space and time costs.
    #
    # For example, consider the following "inverted" implementation:
    #
    #    local -a args_metadata
    #    while {
    #        pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
    #    } {
    #        ...
    #        args_metadata+=(
    #            "${arg_count_max}"
    #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"
    #            "${arg_is_optional}"
    #            "${arg_is_variadic}" )
    #    }

    #    for arg_count ({${arg_count_min}..${arg_count_max}}) {
    #        ...
    #        for arg_index arg_type arg_is_optional arg_is_variadic (
    #            "${args_metadata[@]}") {
    #            ...
    #        }
    #        ...
    #    }

    # Map from the name of an alias defining variables of a certain type
    # (e.g., ":string") to the space-delimited string assigning one local
    # variable to each argument of such type (e.g., 'my_string="${1}"').
    local -A arg_definer_to_definitions

    # Map from the name of a function testing whether passed arguments are of a
    # certain type (e.g., :int.is()) to the space-delimited string expanding
    # all arguments of such type (e.g., '"${1}" "${@[2,-2]}" "${@[-1]}"').
    local -A arg_tester_to_values

    # Map from the name of a function testing whether the values of variables
    # referred to by passed arguments are of a certain type (e.g., :int.is())
    # to the space-delimited string expanding all such variables (e.g.,
    # '"${(P)1}" "${(P)@[-1]}"').
    #
    # Ideally, we would simply append such expansions to prior map local
    # ${arg_tester_to_values}. Before applying parameter expansion flag "(P)"
    # to arguments, however, we *MUST* validate such arguments to refer to
    # valid variables -- which ${arg_tester_to_values} already accomplishes.
    # Since zsh maps are inherently unordered, we cannot also validate such
    # variable values with the same map and expect the prior validation to be
    # deterministically performed before the latter. Separating the two into
    # two different map locals allows such validation to be ordered thusly.
    local -A arg_var_tester_to_values

    # Canonical string global ${ZPCRE_OP}, localized to avoid overwriting
    # either global or caller-specific versions of such variable.
    local ZPCRE_OP

    # Code validating the number of arguments passed to such function.
    local code_arg_count

    # Code localizing and/or validating arguments passed to such function.
    local code_args_local_or_valid

    # String prefixing each line of such code with indentation appropriate to
    # the current outermost indentation level (i.e., of code nested directly in
    # the current function body).
    local code_indentation_outer

    # String prefixing each line of such code with indentation appropriate to
    # the current innermost indentation level (i.e., of code nested directly in
    # the current if conditional of the current function body).
    local code_indentation_inner

    # Space-delimited string of all expansions of arguments to be validated.
    local arg_values

    # Current argument name, type, and subtype.
    local arg_name arg_type arg_subtype

    # Name of the alias localizing the current argument.
    local arg_definer

    # Name of the function validating the current argument.
    local arg_tester

    # Argument list with all single- and double-quoted strings removed,
    # preventing subsequent parsing from erroneously counting ignorable ",",
    # "?", and "=" characters in such strings.
    local func_args_sans_quotes="${ZESHY_DECLARE_FUNC_ARGS__//(\'([^\']|\'\')#\'|\"(\\\"|[^\"])#\")}"

    # Argument list reduced to all remaining "," characters, whose string
    # length plus one is the maximum number of arguments such function accepts.
    local func_args_commas="${func_args_sans_quotes//[^,]##}"

    # Argument list reduced to all remaining "?" and "=" characters, whose
    # string length subtracted from the prior maximum is the minimum number of
    # arguments such function accepts.
    local func_args_equals="${func_args_sans_quotes//[^?=]##}"

    # Such minimum and maximum number.
    integer arg_count_max=$(( ${#func_args_commas} + 1 ))
    integer arg_count_min=$(( arg_count_max - ${#func_args_equals} ))

    # Number of optional arguments required by the current argument count
    # below. If such function accepts no optional arguments, this number
    # remains 0; else, this number varies between the maximum and minimum
    # number of arguments such function accepts.
    integer arg_count_optional

    # Index of the current argument in the argument list.
    integer arg_index

    # Non-positive integer (i.e., strictly less than or equal to 0) by which to
    # offset the current argument index below. If such function accepts no
    # optional arguments, this integer remains 0; else, this integer is
    # decremented once for each optional argument rejected by the current
    # argument count. (See below for gritty details.)
    integer arg_index_offset

    # 1 if the current argument is optional and 0 otherwise.
    integer arg_is_optional

    # 1 if the current argument is variadic and 0 otherwise.
    integer arg_is_variadic

    # 1 if a prior argument was optional and 0 otherwise.
    integer arg_was_optional

    # 1 if a prior argument was variadic and 0 otherwise.
    integer arg_was_variadic

    # 1 if at least one argument is optional and 0 otherwise.
    integer args_is_optional=$(( arg_count_min != arg_count_max ))

    # Code indentation prefixes. If at least one argument is optional, all
    # localization and validation code will be embedded within if conditionals
    # rather than directly within the function body; in such case, indent such
    # code by one additional level of indentation.
    code_indentation_outer=$'\n''    '
    code_indentation_inner=${code_indentation_outer}
    if (( args_is_optional )) {
        code_indentation_inner+='    '
    }

    # For efficiency, compile such PCRE. See for_string_text_matching_pcre:()
    # for further details.
    pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}"
    pcre_study
    # print -r "${ZESHY_DECLARE_FUNC_NAMES__[1]} args: ${ZESHY_DECLARE_FUNC_ARGS__}"

    # For each possible number of arguments between the minimum and maximum
    # established above, define code validating the types of all passed
    # arguments when the caller passes that number of arguments.
    integer arg_count
    for     arg_count ({${arg_count_min}..${arg_count_max}}) {
        # Clear such maps. See :clear_map() for further details.
        set -A arg_definer_to_definitions
        set -A arg_tester_to_values

        # Revert local variables declared above specific to the following loop.
        arg_count_optional=$(( arg_count - arg_count_min ))
        arg_index_offset=0
        arg_was_optional=0
        arg_was_variadic=0

        # Parse each such argument into canonical list global ${match}, whose
        # indices we localize as human-readable integers above.
        ZPCRE_OP='0 0'
        while {
            pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
        } {
            # If such argument is neither optionalized or defaulted, such
            # argument is non-optional and hence mandatory. Note such fact.
            if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_OPTIONAL}]-}${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_VALUE}]-}" ]] {
                arg_is_optional=0
            # Else, such argument is optional.
            #
            # If the current argument count supports no additional optional
            # arguments, the current optional argument is unpassed.
            } elif (( ! arg_count_optional )) {
                # Since such argument is unpassed and hence has no assigned
                # index at function call time, decrement all subsequent
                # argument indices by one.
                arg_index_offset+=-1

                #FIXME: Insufficient. Before skipping to the next argument, 
                #instead:
                #
                #* Test whether the current optional argument was assigned a
                #  default value.
                #* If so, append:
                #  * An assignment of such argument to such value...
                #  * To a (possibly new?) string or map local.
                #
                #The antler-mantled devil is the details, however. First, we
                #need to resolve the order in which we perform such defaulting:
                #do we default unpassed arguments *BEFORE* performing
                #localization and validation? That would certainly seem to be
                #the simplest implementation, but arguably *NOT* the most
                #efficient. Why? Because that order implies we need to perform
                #in-place modification of ${argv} list items. Now, when the
                #optional arguments to be defaulted are the absolute last
                #arguments, such modification simply appends to such list and
                #hence is arguably inefficient; in all other cases, however,
                #we'd need to either:
                #
                #* Shift all arguments following such unpassed arguments to the
                #  right in ${argv} -- which is neither simple *OR* efficient.
                #* Call set(), replacing the current argument list entirely.
                #  While considerably simpler, it's that much less efficient.
                #
                #The alternative, of course, is to:
                #
                #* Append an appropriate entry to map
                #  ${arg_definers_to_definitions}, assigning such local to such
                #  default value (rather than the customary indexed argument
                #  expansion performed below).
                #
                #O.K.; that's pretty much the obvious thing to do. It's both
                #simple and efficient, requiring no modification to either
                #${argv} or logic below.
                #FIXME: Wait. No, merely appending to
                #${arg_definers_to_definitions} fails. Why? Because:
                #
                #* The assignments implied by such map are performed *AFTER*
                #  validating argument values. But we *REALLY* want default
                #  values to be validated (particularly if such values embed
                #  command substitutions).
                #* Which brings us to... command substitutions. For simplicity,
                #  ${arg_definers_to_definitions} assumes all assignments
                #  implied by key-value pairs *ALWAYS* succeed -- which, of
                #  course, will *NOT* be the case for default values embedding
                #  command substitutions.
                #
                #Hmm. Honestly, the set() approach *DOES* seem to be the
                #simplest, when one takes into account both localization and
                #validation. Perhaps more importantly, adopting such approach
                #should reduce the amount of preamble code output for functions
                #accepting defaulted arguments. Why? Because, under such
                #approach, we need to no longer treat defaulted arguments as
                #optional, thus reducing the number of possible argument
                #counts. Indeed, under such approach, only optionalized
                #arguments increase such number, reducing if conditional
                #fan-out below.
                #
                #Hmm; or perhaps not? If one considers it, the set() approach
                #really does introduce considerably more complexity than it
                #erases. We *REALLY* want a
                #${arg_definers_to_definitions}-style approach. Now, we *CAN*
                #reuse such map to safely *DECLARE* defaulted arguments; we
                #just can't use such map to safely *DEFINE* defaulted
                #arguments. To accomplish the latter, we'll simply need to
                #append to a new newline-delimited *STRING* local
                #${arg_defaults}. Sweet, no?

                # If specified, assign such argument a default value.

                # Skip to the next argument.
                continue
            # Else, the current argument count admits such optional argument.
            #
            # If a prior argument is variadic, throw an exception. Explicitly
            # ignore the valid case that the current argument is both variadic
            # and optional. See above for further details.
            } elif (( arg_was_variadic )) {
                ::func_.die_of_cause\
                    'accepts both optional and variadic arguments'
            # Else, such argument is validly optional.
            } else {
                # Note such fact.
                arg_is_optional=1

                # Decrement the current optional argument count, implying such
                # count to subsequently support one less optional argument.
                # (The current optional argument "consumes" one of the
                # available optional argument "slots" permitted by such count.)
                arg_count_optional+=-1
            }

            # Decrement such argument index by such offset. See above!
            arg_index+=${arg_index_offset}

            # If such argument is *NOT* variadic (i.e., was *NOT* suffixed by
            # an ellipse), handle such argument. Do so *AFTER* decrementing
            # such argument index and hence testing whether such argument is
            # optional, as we further munge such index below.
            if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_VARIADIC}]-}" ]] {
                # Note such fact.
                arg_is_variadic=0

                # If such argument follows a variadic argument, such argument
                # cannot be reliably indexed by its positive index (i.e.,
                # relative to the start of such argument list). Since such
                # argument can, however, be reliably indexed by its negative
                # index (i.e., relative to the end of such argument list),
                # replace the former with the latter. Happily, such conversion
                # applies regardless of whether such variadic argument was
                # optional or mandatory.
                #
                # Since negative sign "-" conflicts with parameter expansion
                # syntax, negative indices may only be referenced by indexing
                # canonical list global ${@} or ${argv} with such index. For
                # brevity, we prefer the former. Since subsequent logic may
                # conditionally prefix such string with parameter expansion
                # flags (e.g., "(P)"), avoid delimiting such string with "${"
                # and "}" until *AFTER* performing such logic below.
                if (( arg_was_variadic )) {
                    arg_index='@['$(( arg_index - arg_count_max - 1 ))']'
                }
            # Else, such argument is variadic.
            #
            # If a prior argument is also variadic, throw an exception. Such
            # case implies such function to accept two or more variadic
            # argument lists of arbitrary count, implying there exists no
            # general means of deciding which such list a passed string was
            # intended to belong to.
            } elif (( arg_was_variadic )) {
                ::func_.die_of_cause\
                    'accepts two or more variadic arguments'
            # If a prior argument is optional, throw an exception. Such case
            # implies such function to accept one or more optional arguments
            # *AND* one or more variadic argument lists of arbitrary count,
            # implying there exists no general means of deciding which such
            # argument a passed string was intended to correspond to.
            #
            # Test such condition *AFTER* testing whether a prior argument is
            # variadic. If such function accepts an optional variadic argument
            # following a prior variadic argument, the prior exception is more
            # explanatory than this exception.
            } elif (( arg_was_optional )) {
                ::func_.die_of_cause\
                    'accepts both optional and variadic arguments'
            # Else, such argument is validly variadic.
            } else {
                # Note such fact.
                arg_is_variadic=1

                # Index such argument and all subsequent optional variadic
                # arguments with an argument range starting at the current
                # positive index and ending at the negative index of the last
                # such argument. See above for related logic.
                arg_index='@['${arg_index}','$(( arg_index - arg_count_max - 1 ))']'
            }

            #FIXME: For efficiency, shift "arg_was_variadic=1" immediately
            #above.

            # If such argument was optional and/or variadic, notify subsequent
            # parse iterations of such fact. For safety, set such booleans
            # *AFTER* all possible tests of such booleans above.
            if (( arg_is_optional )) { arg_was_optional=1 }
            if (( arg_is_variadic )) { arg_was_variadic=1 }

            # Argument name and type, localized for efficient reuse below.
            arg_name=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME}]}
            arg_type=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE}]}

            #FIXME: Define a new exception handler
            #::func_.die_of_cause_argument_type() and call such handler
            #everywhere below in place of the current logic.

            # If such type is nonscalar (i.e., list or map), throw an
            # exception. By definition, argument types are *ALWAYS* scalar.
            [[ "${arg_type}" != ':'('list'|'map')('_'*|) ]] ||
                ::func_.die_of_cause_arg_type\
                    'nonscalar, but zsh only supports scalar argument types (e.g., `:bool`, `:char`, `:float`, `:int`, `:string`)'

            # If localizing such argument (i.e., if such argument name is
            # unrelaxed), note such fact by appending an initialization of such
            # name to such value to the appropriate type-specific string.
            if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED}]}" ]] {
                # If such argument is a string referring to another variable's name,
                # localize such argument merely as a string.
                if [[ "${arg_type}" == ':string:'* ]] {
                    arg_definer=':string'
                # Else, such argument is a scalar value. Localize such value to
                # be of such type.
                } else {
                    arg_definer=${arg_type}
                }

                # If such type is *NOT* the name of an existing alias, throw an
                # exception. See :is_alias_simple() for details.
                (( ${+aliases[${arg_definer}]} )) || 
                    ::func_.die_of_cause_arg_type\
                        'unrecognized, requiring undefined alias '${arg_definer}'() to locally declare such argument'

                # Map such alias name to such argument definition.
                arg_definer_to_definitions[${arg_definer}]+=' '${arg_name}'="${'${arg_index}'}"'
            }

            # If validating such argument (i.e., if such argument type is
            # unrelaxed and unequal to ":string"), note such fact by appending
            # an expansion of such argument to the appropriate type-specific
            # string. Technically, *ALL* function arguments are untyped scalars
            # and hence strings, implying no validation to be required for
            # arguments of type ":string".
            if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED}]}" &&
                  "${arg_type}" != ':string' ]] {
                #FIXME: As expected, "+"-style subtypes are insufficient.
                #Consider how one would validate a string argument referring to
                #a function. In such case, ":string/func" fails, as there
                #exists no function :string.is_func(). We thus require a new
                #syntactic element implying function :func.is() instead. And
                #for that, "/" clearly applies: e.g.,
                #
                #    :void ::var.die_unless_passes_tester(
                #        :string/var var_name1, ...,
                #        :string/func tester_name,
                #        :string/alias_simple alias_name)
                #
                #Given that we now have two validation-specific "types",
                #abandon the current "subtype" nomenclature in favor of:
                #
                #* The "/"-prefixed major type. If unspecified, such type
                #  defaults to the portion of such type preceding the "+" if
                #  any (e.g., the ":string" in ":string+glob").
                #* The "+"-prefixed minor type.
                #
                #What's awesome about this is that major and minor types can be
                #elegantly combined in the expected way: e.g.,
                #
                #    :void ::test(:string/var+nonempty var_name)
                #
                #Hence, "/" and "+" are both essential syntax. Neither
                #obsoletes or obviates the other. Make it so, please!
                #FIXME: Hey, it gets even better! The above syntax clearly
                #obsoletes our existing (and frankly rather kludgy) handling of
                #variable indirection. Specifically, arguments of type
                #":string/var+${var_type}" clearly obsolete prior type
                #":string:${var_type}". Hence, do away with *ALL* ":string:"
                #handling below. However, note that repeating ":string/var+"
                #everywhere in list- and map-centric function prototypes will
                #get old fairly quickly. We might consider a new argument type
                #prefix: ":*", shorthand for ":string/var+". Hence, the
                #following prototypes are equivalent:
                #
                #    :void ::handle(:string/var+char char_name+__h)
                #    :void ::handle(:*char char_name+__h)
                #    :void ::handle(*:char char_name+__h)
                #    :void ::handle(:char *char_name+__h)
                #
                #Well, three choices anyway. Contemplate a bit further.
                #FIXME: O.K.; C adopted "char *p" syntax to imply that "*p" is
                #the manner with which you access the data such pointer refers
                #to. In zeshy, however, we have no pointers, so that doesn't
                #apply; moreover, we've always thought such syntax to be
                #inherently irrational, in that the "*" modifies the type of
                #such variable and hence should be associated with such type
                #rather than such pointer name. Hence, either ":*char" or
                #"*:char" would be appropriate here. Indeed, for the same
                #reason, "*:char" is probably the most appropriate choice.
                #(Adopting C syntax would also be in poor taste here, as that
                #would tacitly imply zeshy to support pointers, which it
                #clearly does not.)
                #
                #However, "*:char" has one additional advantage over ":*char":
                #the former supports custom user-defined types leveraging a
                #user-specific prefix (e.g., "*@bytes"), whereas the latter
                #obstructs such use. Right then! We shay go with:
                #
                #    :void ::handle(*:char char_name+__h)
                #FIXME: If both "*" and a major subtype are specified, throw an
                #exception. That is to say, prohibit the second argument here:
                #
                #    :void ::handle(:int number, :char/var char_name+__h)

                # Major and minor argument subtypes, localized for efficient
                # reuse below.
                arg_subtype_major="${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}"
                arg_subtype_minor="${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}"

                # If such argument is a string referring to another variable's name,
                # validate the latter to exist *AND* be of the expected type.
                # To implement the latter, validate such argument by calling a
                # function :string.${arg_subtype_major}.
                if [[ "${arg_subtype_major}" == 'var' ]] {
                    # If such argument type is *NOT* ":string", throw an
                    # exception. While integer arguments could technically
                    # refer to variables whose names are themselves integers,
                    # such edge-case seems both implausible and error-prone. In
                    # practice, only strings refer to other variables.
                    [[ "${arg_type}" == ':string' ]] ||
                        ::func_.die_of_cause_arg_type\
                            'not a string but indirectly refers to variables by name; consider prefixing such type by "*" or ":string/var" instead'

                    # If such argument is subtyped, such subtype constraints
                    # the value of the variable such argument refers to rather
                    # than such variable's type. In contrast to the customary
                    # case (in which we validate only such argument's value),
                    # this necessitates we validate both such argument's value
                    # (i.e., such variable's type) *AND* such variable's value.
                    # In turn, this necessitates we duplicate the logic
                    # validating such argument's value below to also validate
                    # such variable's value here.
                    #
                    # Since such variable's type
                    # must also be 
                    #
                    # Given this, such argument
                    # must be expanded with parameter expansion flag "(P)"
                    # rather than as is, requiring 
                    if [[ -n "${arg_subtype}" ]] {
                        # Name of the function validating such variable values.
                        arg_tester=${arg_type[9,-1]}'.is_'${arg_subtype}

                        # If such function does *NOT* exist, throw an
                        # exception. For efficiency, inline such test. See
                        # :func.is() for further details.
                        (( ${+functions[${arg_tester}]} )) ||
                            ::func_.die_of_cause_arg_type\
                                'unrecognized, requiring undefined function '${arg_tester}'() to validate the variable such argument refers to'

                        # Map such function name to such variable expansion.
                        #
                        # If such argument is variadic, such argument implies
                        # an indirectly subtyped variadic argument list (e.g.,
                        # as ":void func(:string:int+nonzero int1, ...)").
                        # Unfortunately, such edge case provokes a subtle
                        # contradiction:
                        #
                        # * Expanding variadic arguments requires use of ranged
                        #   indices ("${@[2,-2]}").
                        # * Expanding indirect arguments requires use of
                        #   parameter expansion flag "(P)" ("${(P)2}").

                        # * Parameter expansion flag "(P)" only non-
                        #   erroneously applies to single rather than ranged
                        #   expansions (e.g., to "${(P)2}" rather than
                        #   "${(P)@[2,-2]}"), Technically, zsh *DOES* silently
                        #   permit "(P)" to be used in conjunction with ranged
                        #   expansions, but in such case only expands to the
                        #   value of the variable referred to by the first such
                        #   index -- which, ultimately, is of little use.
                        #
                        # Syllogism (i.e., logic puzzle) enthusiasts will be
                        # quick to note the implication above. Happily, such
                        # conundrum is efficiently correctable by detecting
                        # such edge case and, in such case, performing global
                        # string replacement to iteratively replace all
                        # argument values in such range by the values of the
                        # variables the former refer to instead (e.g.,
                        # expanding the indices ranging @[2,-2] as
                        # "${@[2,-2]//(#m)*/${(P)MATCH}}" rather than
                        # "${(P)@[2,-2]}"). Dismantled, this is:
                        #
                        # * "(#m)", enabling canonical string global ${MATCH}.
                        # * "*", capturing the name of the variable referred to
                        #   by the current argument to ${MATCH}.
                        # * "${(P)MATCH}", expanding to such variable's value.
                        if (( arg_is_variadic )) {
                            arg_var_tester_to_values[${arg_tester}]+=' "${(P)'${arg_index}'//(#m)*/${(P)MATCH}}"'
                        # Else, such argument is non-variadic and hence refers
                        # to a single variable. In such case, parameter
                        # expansion flag "(P)" may be applied per usual.
                        } else {
                            arg_var_tester_to_values[${arg_tester}]+=' "${(P)'${arg_index}'}"'
                        }
                    }

                    # Name of the function validating such argument values. For
                    # simplicity, use the same string local as above to do so.
                    # To avoid complications, redefine such local *AFTER*
                    # possibly defining such local above.
                    arg_tester=':var.is_type_'${arg_type[9,-1]}
                # Else, such argument is a scalar value. Validate such value to
                # be of such type.
                } else {
                    arg_tester=${arg_type}'.is'

                    # If such argument is subtyped, suffix such function name
                    # by such subtype.
                    if [[ -n "${arg_subtype}" ]] {
                        arg_tester+='_'${arg_subtype}
                    }
                }

                # If such function does *NOT* exist, throw an exception.  For
                # efficiency, inline such test. See :func.is() for details.
                (( ${+functions[${arg_tester}]} )) ||
                    ::func_.die_of_cause_arg_type\
                        'unrecognized, requiring undefined function '${arg_tester}'() to validate such argument'

                # Map such function name to such argument expansion.
                arg_tester_to_values[${arg_tester}]+=' "${'${arg_index}'}"'
            }
        }

        # If localizing and/or validating at least one such argument, do
        # so. Technically, there exist three possible map locals to be tested
        # here: the two tested below and ${arg_var_tester_to_values}, *NOT*
        # tested below. Since prior logic guarantees ${arg_tester_to_values} to
        # be nonempty whenever ${arg_var_tester_to_values} is nonempty,
        # however, the latter need *NOT* be explicitly tested here.
        if (( ${#arg_definer_to_definitions} +\
              ${#arg_tester_to_values} )) {
            # If such function accepts at least one optional argument, subsequent
            # argument type validation assumes such function's caller passed the
            # current number of arguments. Prefix such validation by an if
            # conditional guaranteeing such assumption.
            if (( args_is_optional )) {
                # Indent the following if conditional.
                code_args_local_or_valid+=${code_indentation_outer}

                # If passed the minimum number of arguments, start such if
                # conditional. (While we could just as well invert such logic,
                # such logic is optimized for the presumably common case of the
                # caller *NOT* passing optional arguments.)
                if (( arg_count == arg_count_min )) {
                    code_args_local_or_valid+='if (( # == '${arg_count}' )) {'
                # Else if passed the maximum number of arguments, end such if
                # conditional. Since the prior conditional already terminated
                # on "}", omit such delimiter here.
                } elif (( arg_count == arg_count_max )) {
                    code_args_local_or_valid+=' else {'
                # Else, extend such if conditional.
                } else {
                    code_args_local_or_valid+=' elif (( # == '${arg_count}' )) {'
                }
            }

            # For efficiency, combine the following two related iterations:
            #
            # * For each function name and corresponding string expanding all
            #   arguments validated by calling such function (i.e., key-value
            #   pairs of map ${arg_tester_to_values}), do so.
            # * For each function name and corresponding string expanding all
            #   variables referred to by arguments and validated by calling
            #   such function (i.e., key-value pairs of map
            #   ${arg_var_tester_to_values}), do so. While the first iteration
            #   validates such variables as existing and of the expected type,
            #   this iteration validates the values such variables expand to
            #   and hence must be performed *AFTER* the first iteration.
            for arg_tester arg_values (
                "${(kv@)arg_tester_to_values}"
                "${(kv@)arg_var_tester_to_values}") {
                code_args_local_or_valid+=${code_indentation_inner}${arg_tester}${arg_values}' || ::func.die_unless_arg_values_pass_tester "${@}" '''${arg_values}''' '${(q)arg_tester}
            }

            # For each alias name and corresponding string localizing arguments
            # into locals declared by expanding such alias, do so *AFTER*
            # prior iteration validates all such arguments. Since such
            # localization consists only of simple string assignments (e.g.,
            # 'my_var="${1}"') and hence is guaranteed to succeed, no exception
            # handling is required.
            for arg_definer arg_values (
                "${(kv@)arg_definer_to_definitions}") {
                code_args_local_or_valid+=${code_indentation_inner}${arg_definer}${arg_values}
            }

            # If such function accepts at least one optional argument and hence
            # prefixed such validation by an if conditional, end such conditional.
            if (( args_is_optional )) {
                code_args_local_or_valid+=${code_indentation_outer}'}'
            }
        }
    }

    # Substring prefixing argument count-specific exception messages.
    local die_arg_count_prefix=' || :die "Function ${funcstack[1]}() expected '

    # Substring suffixing argument count-specific exception messages.
    local die_arg_count_suffix='."$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY_DECLARE_FUNC_PROTOTYPE__}'$''\n\n''"Arguments passed:"$''\n''"${*}"'

    # Validate the number of arguments passed to such function.
    #
    # If such function is variadic, such function accepts a countably
    # infinite number of arguments only bounded below by such minimum.
    if (( arg_was_variadic )) {
        code_arg_count='(( # >= '${arg_count_min}' )) || ::func.die_of_arg_count_not_exceeding "${@}" '${arg_count_min}
    # Else, such function is non-variadic, in which case such function
    # accepts a number of arguments bounded by such minimum and maximum.
    #
    # If such minimum and maximum are equal, simplify such test as such.
    } elif (( arg_count_min == arg_count_max )) {
        code_arg_count='(( # == '${arg_count_min}' )) || ::func.die_of_arg_count_not_equaling "${@}" '${arg_count_min}
    # Else, such minimum and maximum are unequal.
    } else {
        code_arg_count='(( '${arg_count_min}' <= # && # <= '${arg_count_max}' )) || ::func.die_of_arg_count_not_ranging "${@}" '${arg_count_min}' '${arg_count_max}
    }

    # String expanded by the caller at the start of such function's body, thus
    # performing the above validation *BEFORE* all other function logic.
    func_preamble="${code_arg_count}${code_args_local_or_valid}"
    # print -r "${func_name} preamble: ${func_preamble}"$'\n\n'
}

#FIXME: In lieu of unit tests...
# :func_ 'string :sami(string yimlo = "hello")'
# :func{
#     local yimlo="${1}"
#     print -r "yolo: ${yimlo}"
# }:func <<'/---'
# Sami says, "Yimlo!"
# /---
# () {
#     :sami 'YumYumEugh'
# }

# ....................{ OBSOLETE                           }....................
#FIXME: Don't neglect to delete such map immediately after use in
#precompilation!
#FIXME: Actually, when we replace such map entirely with equivalent dynamically
#synthesized functions, this (clearly) ceases to become an issue. Make it so;
#then, excise or at least heavily refactor such map.

# Map each function name to the help string documenting such function.
typeset -Ag ZESHY_FUNCTION_NAME_TO_HELP

#FIXME: This map can probably go away too. I'm unconvinced that recording alias,
#function, and global synonyms is genuinely worth the effort. After all, when we
#migrate to a function- rather than map-based help system, we *CAN* and probably
#should just define equivalent functions for all such synonyms and then entirely
#forget about the fact that they were synonyms in the first place. (This
#obviously applies to alias and global synonyms, as well.) Doing is both simpler
#and more efficient, since these three maps need no longer be compiled into or
#loaded from the digest file.
#FIXME: The only legitimate use of this map was checking whether or not such
#function had been previously declared. But that will *STILL* be easy to check
#when we migrate to a function-based help system, since in that case we simply
#test for the existence of such help function, in which case we know whether
#such function had been previously declared or not. Since such test is both
#simple and efficient, there truly exists no compelling reason at all to keep
#these maps around. Excise! Excise!

# Map each function name to the first name declared for such function.
typeset -Agx ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST

# ....................{ DECLARERS                          }....................
#FIXME: Obsolete. Replace with calls to :declare_func-().

function declare_function() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one help string.'
    local help__df="${1}" function_name__df
    local -a function_names__df help_match__df

    #FIXME: Most function prototypes passed to this function are now *BROKEN*
    #by recent syntactic improvements. Since permitting this function to
    #attempt to parse such prototypes below would induce unhelpful and largely
    #ignoreable exceptions, avoid doing so by returning immediately. Yes, this
    #effectively reduces all calls to this and declare_function_with_stdin() to
    #noops -- implying we *REALLY* need to excise them.
    return 0

    # Unless such string matches the function help PCRE, throw an exception.
    [[ "${help__df}" =~\
       "${ZESHY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE}" ]] || :die\
        'Function prototype "'${help__df}'" invalid.'
#   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
#       print "match ${match_index}: ${match[${match_index}]}"
#   }

    # List of substrings captured by the prior match. The PCRE-based iteration
    # performed by set_lists_to_runnable_prototype_name_or_names:() below
    # overwrites ${match}, necessitating we preserve it here.
    help_match__df=( "${match[@]}" )

    # List of function names declared by such prototype.
    set_list_and_map_to_runnable_prototype_name_or_names:\
        function_names__df\
        ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST\
        "${help_match__df[2]-}"\
        "${help_match__df[3]-}"

    # If such function has attributes, match such attributes.
    if [[ -n "${help_match__df[1]}" ]] {
        # List of function attributes split from such string. Split on commas
        # after truncating:
        #
        # * Optional whitespace surrounding commas (e.g., from " , " to ",").
        # * Optional trailing commas and/or whitespace.
        local -a attributes__df; attributes__df=(
            "${(s:,:)${help_match__df[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]#,#[[:space:]]#}"
        )
#       for ((match_index=1; match_index <= ${#attrs}; ++match_index)) {
#           print "attr ${match_index}: ${attrs[${match_index}]}"
#       }

        # If such attributes include "globbable," disable filename globbing for
        # all arguments passed to such function names. See is_list_contains()
        # for further details.
        if (( ${attributes__df[(i)globbable]} <= ${#attributes__df} )) {
            #FIXME: For efficiency, this and the following loop should be
            #centralized into a single loop. This will become increasingly vital
            #as the number of such loops in this function inevitably
            #proliferates.
            for function_name__df ("${function_names__df[@]}") {
                # For safety (in the event of function names containing alias-
                # reserved characters), call :define_alias_simple() rather than manually
                # defining such alias.
                :define_alias_simple\
                    "${function_name__df}" "noglob ${(q)function_name__df}"
            }
        }
    }

    # Map the first function name to such help string. Note the choice of
    # mapping function name synonyms to the first function name in
    # set_list_and_map_to_runnable_prototype_name_or_names:, as well; this is
    # *NOT* a coincidence, as could be inferred.
    ZESHY_FUNCTION_NAME_TO_HELP[${function_names__df[1]}]="${help__df}"

    # Add all such functions to the current parcel.
    for function_name__df ("${function_names__df[@]}") {
        add_parcel_function "${ZESHY_PARCEL_NAME}" "${function_name__df}"
    }
}

#FIXME: Obsolete. Replace with calls to :declare_func().
function declare_function_with_stdin() {
    run_runnable_with_stdin declare_function
}

# --------------------( WASTELANDS                         )--------------------
                    # ::func_.die_of_cause\
                    # 'argument ${'${arg_name}'} type '${arg_type}$([[ -z "${arg_subtype}" ]] || print -r -- '+'${arg_subtype})' unrecognized (i.e., function '${arg_tester}'() undefined)'
                            # 'argument ${'${arg_name}'} type '${arg_type[9,-1]}$([[ -z "${arg_subtype}" ]] || print -r -- '+'${arg_subtype})' unrecognized (i.e., function '${arg_tester}'() undefined)'

                    #FUXME: Ugh. Need a new argument exception handler.
            #FUXME: If such type is nonscalar (e.g., prefixed by either ":list"
            #or ":map"), we need to throw an exception. Argument values are, by
            #definition, *ONLY* scalar.

                # If such argument is a string referring to another variable's name,
                # validate the latter to exist *AND* be of the expected type. For
                # efficiency, obtain such type with raw string indices rather
                # than globbed match groups (e.g., ':string:'(#b)(*)).
                # if [[ "${arg_type}" == ':string:'* ]] {

    #FUXME: Correct comment in line with ${arg_definer_to_definitions}.
    # Map from argument variable type (i.e., the type of the variable referred
    # to by an argument) to space-delimited string of the indices of all
    # arguments of such type to be programmatically validated. Since the

# -- aside from the observation that we
                #no longer want to skip straightaway to the next argument. Oh,
                #we?
                # Decrement the argument index offset. Prior iteration
                # assigned each argument an index under the assumption that
                # all optional arguments are passed. However, the current
                # argument count implies the current optional argument to
                # *NOT* be passed, implying all subsequent argument indices
                # to be one larger than previously assumed. Correct this!

            # In
            # such case,  or
            # otherwise ignore such argument.

                    #FUXME: Insufficient. Before applying parameter expansion
                    #flag "(P"), we *MUST* guarantee such argument to refer to
                    #a valid variable. Since simply appending to
                    #${arg_tester_to_values} does *NOT* guarantee this, we
                    #require yet another map local:
                    #${arg_var_tester_to_expansions}. This, in turn, implies we
                    #should rename "arg_tester" everywhere here to
                    #"arg_tester".
                    #FUXME: Actually, even that fails to suffice. We clearly
                    #*CANNOT* combine "(P)" with ranged indices (e.g.,
                    #"${@[2,-2]}"). Experimental use suggests that, in such
                    #cases, zsh fails to print an error or report failure, but
                    #instead simply returns the value of the variable referred
                    #to by the first such index. Clearly, this is terrible. To
                    #avoid such edge cases, prohibit function arguments
                    #satisfying all of the following edge case constraints:
                    #indirect, subtyped, variadic arguments: e.g.,
                    #
                    #    :void err(:string:int+positive my_int1, ...)
                    #
                    #Such arguments are fairly edge case, anyway. Technically,
                    #we *COULD* programmatically validate such variables by
                    #manually iterating such arguments...
                    #FUXME: Wait. We've just devised an efficient workaround,
                    #which is fairly awesome:
                    #
                    #* For all indirect, subtyped, variadic arguments (i.e.,
                    #  just test "(( arg_is_variadic ))" here, suffix
                    #  ${arg_index} by '//(#m)*/${(P)MATCH}', ensuring such
                    #  argument indices are expanded as follows:
                    #    "${@[2,-2]//(#m)*/${(P)MATCH}}"
                    #
                    #Excrutiatingly clever. Huzzah!

        #FUXME: O.K.; so, we still need to handle default values. Lookin' good
        #on pretty much everything else, but the time already invested in this
        #*DOES* somewhat astonish the rabid-eyed mind.

    # Space-delimited string of all expansions of arguments to be localized.
    # local arg_definitions

            #FUXME: Replicate such logic for both ${arg_definer_to_definitions}
            #and ${arg_var_tester_to_values}, iterating ${arg_tester_to_values}
            #*BEFORE* ${arg_var_tester_to_values} *BEFORE*
            #${arg_definer_to_definitions}. Order is quite important here.

 # Hence,
            # perform only attempt
            # to expand such variables here *AFTER* performing such iteration.
                #FUXME: Indentation is conditional here. The current
                #indentation is appropriate *ONLY* if the current argument
                #count requires a wrapping if conditional; else, such
                #indendation is too much. We probably want a new string local
                #${code_indentation_inner} to correct this. Given the above changes,
                #boolean ${args_is_optional} indicates whether or not we
                #require one or two levels of indentation *BEFORE* iterating
                #anything, implying ${code_indentation_inner} may be set as a
                #string constant *BEFORE* such iteration *AFTER* setting such
                #boolean ala:
                #
                #     code_indentation_inner=$'\n''    '
                #     if (( args_is_optional )) {
                #         code_indentation_outer=${code_indentation_inner}
                #         code_indentation_inner+='    '
                #     }
                #
                #Elegant, no? Note that new string local
                #${code_indentation_outer} is only ever expanded by functions
                #accepting optional arguments, justifying the logic above.
                #
                #Then replace the current code below with:
                #
                #     code_args_local_or_valid+=${code_indentation_inner}${arg_tester}${arg_values}' || ::func.die_unless_arg_values_pass_tester "${@}" '''${arg_values}''' '${(q)arg_tester}

            #FUXME: Erroneous test. During the first iteration of argument
            #counts for functions accepting optional arguments, no optional
            #arguments will be enabled, in which case the conditional below
            #fails when it *SHOULD* succeed. What we *REALLY* want to test is
            #just "(( arg_count_min != arg_count_max ))" instead. That said, to
            #avoid repetitious tests, we really want to encapsulate such
            #outcome in a new boolean local declared and defined far above as
            #follows:
            #
            #    integer args_is_optional=$(( arg_count_min != arg_count_max ))
            #
            #Then, test such integer here and below as follows:
            #
            #    if (( args_is_optional )) {

        #FUXME: Inefficient. Surely a simpler test presents itself?
        # if (( ${#arg_definer_to_definitions} +\
        #       ${#arg_tester_to_values} +\
        #       ${#arg_var_tester_to_values} )) {

            #FUXME: Given such changes, we will only be testing existing
            #boolean ${arg_was_optional} in *ONE* place. Is there no better
            #way?

                    #FUXME: Note such assignment must be performed *AFTER*
                    #performing the above. Performing such assignment in the
                    #opposite order overwrites such function name.

                        #FUXME: Differentiate exception message from that thrown
                        #below.

                        #FUXME: The type printed should be the ORIGINAL type as
                        #specified in such prototype -- not our munged type.
                        #Happily, this is achievable without modification of
                        #existing logic by expanding ${match} indices instead
                        #here (and for orthogonality, below as well).

    #FUXME: Correct comment in line with ${arg_definer_to_definitions}.
    # Map from argument type to space-delimited string of the indices of all
    # arguments of such type to be programmatically validated.

                    #FUXME: Document me.
                    # arg_type=${arg_type[9,-1]}

                    #FUXME: Insufficient. Such argument must be expanded with
                    #parameter expansion flag "(P)" below, implying we require
                    #a new string local ${arg_expansion_flag} initialized here
                    #and expanded below. However, don't neglect to initialize
                    #such local to the empty string in all other cases! Since
                    #this is mildly annoying, a better approach might simply be
                    #to define a new string local ${arg_index_prefix}
                    #initialized immediately prior to this if conditional above
                    #as:
                    #
                    #    arg_index_prefix=...
                    #FUXME: Wait. That's fairly silly; what we *REALLY* want to
                    #do is munge ${arg_index} before this and the prior if
                    #conditionals such that:
                    #
                    #* if [[ "${arg_index}" == *','* ]] ||
                    #     (( arg_index < 0 )) {
                    #     arg_index='@['${arg_index}']'
                    #  }
                    #
                    #Not terribly efficient, but you get the topical idea. It's
                    #critical, as well, *NOT* to delimit ${arg_index} by "${"
                    #and "}" (although the latter would technically be O.K.),
                    #due to the need to conditionally embed parameter expansion
                    #flags (e.g., "(P)") between such "${" and the subsequent
                    #index below.
                    #FUXME: Document me. In particular, note that use of "(P)"
                    #below requires such logic differ from that below.

                #FUXME: We've just recalled that it's inefficient to
                #perform list expansions resembling "${@[1]}" when merely
                #"${1}" suffices. Hence, we'll want to be a bit more
                #thorough here. Since this applies to the prior conditional
                #as well, refactor as follows:
                #
                #* Hmm; need to think a bit more about this...

                    #FUXME: Wait. We obviously need to perform *TWO*
                    #validations in such case and hence must duplicate the
                    #appending to map local ${arg_tester_to_values} below
                    #with a separate (but similar) appending to such local with
                    #such subtype here, validating such variable's value rather
                    #than type.

                        #FUXME: Suspiciously similar to the function name set
                        #below. Hmm...

        #FUXME: This has become ludicrously trivial. Moreover, such triviality
        #exposes a minor (perhaps, major?) flaw: .
            #FUXME: Reinterpreting "$'\n''    '" each iteration presumably
            #entails a cost. Supplant all such substrings below by a new string
            #local constant declared and defined above and expanded here:

            # Begin such validation by calling such function with such argument
            # values. Ideally, such validation would pass such exception message
            # directly to the appropriate exception handler (e.g.,
            # :die_unless_var_int_of_cause()). In practice, however, such message
            # depends on which argument failed such validation and hence can only be
            # constructed *AFTER* finding such argument.

            #FUXME: Fairly inefficient and horribly kludgy. Happily, we can
            #dispense with this entirely by:
            #
            #* Shift the conditional constructing ${arg_tester} to the
            #  iteration above where we currently map
            #  ${arg_tester_to_values}.
            #* Rename map ${arg_tester_to_values} to
            #  ${arg_tester_to_indices_valid}.
            #* Key such map with ${arg_tester} rather than ${arg_type}.
            #* Revise this iteration accordingly.
            #
            #We'll probably want to shift the test of whether such function
            #exists above as well. While slightly less efficient, doing so
            #allows us to construct considerably more useful exception
            #messages. (Or perhaps not? We *COULD* theoretically "de-parse"
            #${arg_tester} into what the corresponding
            #"${arg_type}+${arg_subtype} would have been above. But that does
            #seem rather... well, fragile. Probably avoid that for now, we
            #should think.)

            # # If such type contains a null character, split such type on such
            # # character into such argument's actual type and subtype.
            # if [[ "${arg_type}" == (#b)(*)$'\0'(*) ]] {
            #     arg_type="${match[1]}"
            #     arg_subtype="${match[2]}"
            # # Else, such type is already such argument's actual type.
            # } else {
            #     arg_subtype=
            # }

            #FUXME: No such testers currently exist. We'll need to perform
            #global search and replacements across the entire codebase. *sigh*

            # # If such argument is a string referring to another variable's name,
            # # validate the latter to exist *AND* be of the expected type. For
            # # efficiency, match such type with hard-coded character indices rather
            # # than match groups (e.g., via ':string:'(#b)(*)).
            # if [[ "${arg_type}" == ':string:'* ]] {
            #     arg_tester=':'${arg_type[9,-1]}':is'
            # # Else, such argument is a scalar value. Assuming such type to be
            # # prefixed by ":", validate such argument to be of such type
            # # stripped of such prefix.
            # } else {
            #     arg_tester=':'${arg_type[2,-1]}'.is'
            # }

            # # If such argument is subtyped, suffix such tester by such subtype.
            # if [[ -n "${arg_subtype}" ]] {
            #     arg_tester+='_'${arg_subtype}
            # }

            # # If such function does *NOT* exist, throw a custom exception.
            # :func.is "${arg_tester}" || ::func_.die_of_cause\
            #     'argument type '${arg_type}' unrecognized (i.e., function '${arg_tester}'() undefined)'

                #FUXME: Not quite. We need to test for argument types matching
                #":string:"* and reduce such types to merely ":string". Simple,
                #but will probably require the return of string local
                #${arg_definer} and what not. *sigh*

#, the latter specific to validation
                # Name of the alias localizing such argument.
                # arg_definer=${arg_type}
    # Name of the alias localizing the current argument.
    # local arg_definer

# Assuming such type to be
                # prefixed by ":", validate such argument to be of such type
                # stripped of such prefix.

    #FUXME: How many of the variables below are still requisite?

    # Substring prefixing argument variable type-specific exception messages.
    # local die_arg_var_type_prefix

                #FUXME: No such testers currently exist. We'll need to perform
                #global search and replacements across the entire codebase. *sigh*

                # # If such argument has a validation-specific subtype, map such
                # # expansion to such type and subtype. For generality, delimit
                # # the two by a null character.
                # if [[ -n "${arg_subtype}" ]] {
                #     arg_tester_to_values[${arg_type}$'\0'${arg_subtype}]+=' "${@['${arg_index}']}"'
                # # Else, such argument only has a type. Map such expansion to
                # # only such type.
                # } else {
                #     arg_tester_to_values[${arg_type}]+=' "${@['${arg_index}']}"'
                # }

                # # If such argument is subtyped, suffix such tester by such subtype.
                # if [[ -n "${arg_subtype}" ]] {
                #     arg_tester+='_'${arg_subtype}
                # }

                #FUXME: We need to actually handle such null-delimited types
                #below.

                # # If such argument has a validation-specific subtype, map such
                # # expansion to such type and subtype. For generality, delimit
                # # the two by a null character.
                # if [[ -n "${arg_subtype}" ]] {
                #     arg_tester_to_values[${arg_type}$'\0'${arg_subtype}]+=' "${@['${arg_index}']}"'
                # # Else, such argument only has a type. Map such expansion to
                # # only such type.
                # } else {
                #     arg_tester_to_values[${arg_type}]+=' "${@['${arg_index}']}"'
                # }

            # } elif [[ "${arg_type}" == ':'${~operable_name_char_class} ]] {
            #     arg_tester=':'${arg_type[2,-1]}'.is'
            # # Else, validate such argument to be of such type.
            # } else {
            #     arg_tester=':'${arg_type}'.is'
            # }

                # [[ -z "${arg_subtype}" ]] || ::func_.die_of_cause\
                #     'argument type '${arg_type}'+'${arg_subtype}' '

        # validate all such arguments to be of such type.
            # note such fact by appending
            # such argument index to the parameter expansion-delimited string
            # of all indices of such type.

            #FUXME: Replicate such logic for ${arg_definer_to_definitions}.
            #Naturally, prefix such argument expansions below by something
            #resembling " ${arg_name}=" rather than merely " ".

            #FUXME: Define a new code-specific string local ${localize_args}
            #above and append to such local here. Such local should probably be
            #reverted at the beginning of iteration above to the empty string,
            #and then interpolated into existing code-specific string local
            #${code_args_local_or_valid} (implying such string should perhaps be
            #renamed) *AFTER* appending all validation code to such string and
            #hence *AFTER* the following for loop, but *BEFORE* terminating the
            #current if conditional in ${code_args_local_or_valid}.
            #FUXME: Wait; for efficiency, we want to aggregate such
            #localizations based on type (much as we currently do with
            #validation code), suggesting we should instead:
            #
            #* Declare a new map local ${arg_tester_to_values_local} above.
            #* Append to such map local here (if unrelaxed, of course).
            #* Rename ${arg_tester_to_values} to ${arg_tester_to_values_valid}.
            #* For efficiency, localize the current argument type here: e.g.,
            #  arg_type="${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"

#FUXME: Redeclare as global constants, once we fix @{compile} (...or was it @{wain}?)
#to support global constants again: e.g.,
#
# # Something resembling...
# integer -gr\
#     ZESHY_PROTOTYPE_RUNNABLE_ARG_MATCH_INDEX_TYPE=1\
#     ZESHY_PROTOTYPE_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED=2\
#     ZESHY_PROTOTYPE_RUNNABLE_ARG_MATCH_INDEX_NAME=3\
#     ZESHY_PROTOTYPE_RUNNABLE_ARG_MATCH_INDEX_IS_OPTIONAL=4\
#     ZESHY_PROTOTYPE_RUNNABLE_ARG_MATCH_INDEX_VALUE=5\
#     ZESHY_PROTOTYPE_RUNNABLE_ARG_MATCH_INDEX_IS_VARIADIC=6

    #FUXME: Replace with the equivalent globals declared above.

    # # Human-readable names of canonical list global ${match} indices. While
    # # such indices are both unnecessary and slightly inefficient, their use
    # # dramatically improves the readability and stability of argument parsing.
    # # Likewise, declaring such integer locals as globals would slightly
    # # mitigate such inefficiency at a cost of harming such stability (as such
    # # globals could be externally unset at any time). In the end, the current
    # # implementation seems a sensible tradeoff on all fronts.

    # # Current argument's optional type relaxant, signifying such type to *NOT*
    # # require validation (i.e., throwing an exception if the passed argument's
    # # value violates such type). If absent, such type will be validated below;
    # # else, such function must manually validate such argument if desired.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_unvalidated=1

    # # Current argument's mandatory type.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_type=2

    # # Current argument's optional name relaxant, signifying such argument to
    # # *NOT* require localization (i.e., copied into a local variable of the
    # # same name). If absent, such argument will be localized below; else, such
    # # function must manually localize such argument if desired..
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_unlocalized=3

    # # Current argument's mandatory name.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_name=4

    # # Current argument's optional eroteme (i.e., "?"), signifying such
    # # argument to be optional. If unspecified, such argument is mandatory.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_optional=5

    # # Current argument's optional default value relaxant, signifying such value
    # # to *NOT* require setting (i.e., setting such argument when unpassed to
    # # such value *BEFORE* possibly localizing such argument). If absent, such
    # # argument will be localized below; else, such function must manually
    # # default such argument to such value if desired.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_value_is_undefaulted=6

    # # Current argument's optional default value.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_value=7

    # # Current argument's optional ellipse (i.e., "..."), signifying such
    # # argument and hence function to be variadic.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_variadic=8

            #FUXME: Since most arguments will be at least localized or
            #validated, localize such type here: e.g.,
            #
            # arg_type="${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"

                #FUXME: Obsolete.
                # # Note such function to accept one variadic argument list.
                # args_is_variadic=1

            #FUXME: Obsolete.
            # } elif (( args_is_variadic && ! arg_is_variadic )) {
                #FUXME: Obsolete.
                # Note such function to accept at least one optional argument.
                # args_is_optional=1

        #FUXME: Reverting these strikes us as... overkill. Contemplate
        #excising both.
        #FUXME: Obsolete.
        # Technically, ${args_is_optional} need *NOT* be reverted here; since
        # ${args_is_variadic} must be, however, revert both for orthogonality.
        # ${args_is_variadic} must be reverted as such boolean tracks whether a
        # prior argument was variadic rather than merely whether such function
        # accepts a variadic argument list.
        # args_is_optional=0
        # args_is_variadic=0

    #FUXME: Unconvinced we still require these, given the greater utility of
    #${arg_was_optional} and ${arg_was_variadic}. Contemplate excising.

    # # 1 if such function accepts at least one optional argument and 0
    # # otherwise.
    # integer args_is_optional

    # # 1 if such function accepts one variadic argument list and 0 otherwise.
    # integer args_is_variadic

            #FUXME: This condition no longer behaves as expected, as the first
            #conditional above sets ${args_is_variadic} if the *CURRENT*
            #argument is variadic (not merely if a prior argument is variadic).
            #While we could hack about this with an additional boolean local,
            #what's really called for here is to:
            #
            #* Replace the immediately prior "if (( arg_is_variadic )) {"
            #  conditional with the variadic conditional far above, which
            #  seamlessly corrects such issue in the proper manner. However,
            #  doing so also complicates validation (e.g., to prevent functions
            #  from accepting both variadic and optional arguments).
            #* The solution then is to cease performing such validation within
            #  this loop but far above outside *ALL* iteration. Can we actually
            #  efficiently do this? The answer, of course, is yes.
            #  Specifically:
            #  * Set ${args_is_optional} in the manner shown above.
            #  * Set ${args_is_variadic} by globbing ${func_args_sans_quotes},
            #    which already provides us the quoteless argument list, for:
            #    *(#b)('? '#|)', '#'...'. Wait. Globs don't work here, alas, as
            #    we require a nongreedy match. Instead, match
            #    ${func_args_sans_quotes} against the PCRE:
            #    '^.*?(\?\s*+)?,\s*+\.\.\..*$'. O.K.; that definitely works. If
            #    such PCRE matches, then:
            #    * Set ${args_is_variadic} to 1.
            #    * Additionally, if "(( ! ${#match} ))", then such function
            #      erroneously accepts at least one optional argument and one
            #      non-optional variadic argument. In such case, throw an
            #      exception. (Excised from similar logic above.)
            #FUXME: Or perhaps not? While that *WOULD* work, we're somewhat
            #wary about yet another parse pass over the argument list. Instead,
            #perhaps we should contemplate the changes required to make this
            #work as is. Oh; right. Just restore ${arg_was_variadic}. We note
            #that we'd need to do that *ANYWAY*, so... no loss.

    #FUXME: Unsure whether we still desire this. Contemplate.
    # If the minimum and maximum number of arguments such function accepts
    # differ, such function accepts at least one optional argument. Note this.
    # if (( arg_count_min != arg_count_max )) {
    #     args_is_optional=1
    # }

            #FUXME: Actually, such test is unnecessary. Simply modify such PCRE
            #to match *EITHER* an eroteme *OR* equals sign suffixing an
            #argument name but not both. This is trivially simple, thankfully.

            # Else, such argument is optional.
            #
            # If such argument is suffixed by both an eroteme *AND* default
            # value, throw an exception. While either implies such argument to
            # be optional, each implies distinct, conflicting semantics.
            # } elif [[\
            #     -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_optional}]-}" ||
            #     -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_value}]-}" ]] ||\
            #     ::func_.die_of_cause\
            #         'argument '${match[ZESHY_RUNNABLE_ARG_MATCH_INDEX_name]}' suffixed by both "?" and "="'

            #FUXME: This and the following test, as well as the setting of
            #${args_is_variadic}, 

            #FUXME: Generalize to support localization as well. Since
            #localization and validation share the same ultimate desires here
            #(namely, appending to list ${args_index_type_optional_variadic}),
            #this would probably be simplified by logic resembling:
            #
            #    arg_type_is_validated=$((
            #        1 - ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_unvalidated}]} ))
            #    arg_is_localized=$((
            #        1 - ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_unlocalized}]} ))
            #
            #    if (( arg_type_is_validated || arg_is_localized )) {
            #        args_metadata+=(
            #            "${arg_count_max}"
            #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_name}]}"
            #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"
            #            "${arg_is_optional}"
            #            "${arg_is_variadic}"
            #            "${arg_is_localized}"
            #            "${arg_type_is_validated}"
            #        )
            #    }
            #
            #As the above example implies, rename such list local to simply
            #${args_metadata}. (Judicious.)
            #
            #Reasonably clever; no extraneous if conditionals required. Wait;
            #the first doesn't quite work, as we need to prevent validation of
            #":string" types. So:
            #
            #    if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_unvalidated}]}" &&
            #             "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}" != ':string' ]] {
            #        arg_type_is_validated=1
            #    } else {
            #        arg_type_is_validated=0
            #    }
            #FUXME: Actually, ${args_index_type_optional_variadic} is hideous.
            #We can obviate both such list *AND* the following iteration
            #requiring such list by instead appending directly to keys of map
            #${arg_tester_to_values} here. To do so sanely, however, we *NEED*
            #to know the maximum number of arguments. We can accomplish this by
            #parsing such argument list twice: once without grouping and
            #optimized so as to match only unquoted "," as significant for
            #argument counting purposes, and the second actually parsing each
            #argument. However, to conform to the algorithm implemented below,
            #we would need to reperform such second round of argument parsing
            #a number of times equal to the number of optional arguments
            #accepted by such function.
            #
            #While such reparsing would be nonideal if the common case in zeshy
            #were functions accepting numerous optional arguments, the actual
            #common case in zeshy is the opposite: functions accepting at most
            #one (and typically no) optional arguments. Given that, there will
            #be *NO* reparsing in the common case. Indeed, such an approach
            #should dramatically improve the efficiency of the common case by
            #eliminating the need both to append an excrutiating number of
            #strings to list ${args_index_type_optional_variadic} *AND* to
            #iterate over such list.
            #
            #Note as well that the first parse can be dramatically optimized by
            #matching with a different (and hopefully much simplified) PCRE:
            #one performing no grouping and effectively matching only single-
            #and double-quoted strings (to ignore the nonsignificant commas
            #embedded in such strings) *AND* commas outside of such strings.
            #Actually, that's not quite true: we need to match commas,
            #erotemes, and equals signs, the latter two of which help us
            #calculate the minimum argument count, which we also need under
            #such refactoring. That said, such PCRE needn't actually match any
            #real argument syntax or structure, since the subsequent parse pass
            #will do so already.
            #
            #But it's *NOT* simply efficiency, though that is a dreaded
            #concern: it's elegance, or the lack thereof. The current approach
            #is horribly inelegant, requiring ever more strings be continually
            #appended to and parsed from such list. Let's do away with too fell
            #birds by one bright stone, shall we?
            #FUXME: Wooh. Just realized we don't even need to use PCRE matching
            #to count character instances in a string; we should be able to use
            #glob-driven global string replacement ala:
            #
            #    # Argument list with all single- and double-quoted strings
            #    # removed, preventing subsequent parsing from erroneously
            #    # counting ignorable ",", "?", and "=" characters
            #    # embedded in single- and double-quoted strings.
            #    local func_args_sans_quotes="${ZESHY_DECLARE_FUNC_ARGS__//('([^']|'')#'|\"([^\"]|\\\")#\")}"
            #
            #    # Argument list reduced to all remaining "," characters, whose
            #    # string length plus one offers the maximum number of arguments
            #    # such function accepts.
            #    local func_args_commas="${func_args_sans_quotes//[^,]##}"
            #
            #    # Argument list reduced to all remaining "?" and "=" characters,
            #    # whose string length subtracted from such maximum number 
            #    # offers the minimum number of arguments such function accepts.
            #    local func_args_equals="${func_args_sans_quotes//[^?=]##}"
            #    # Minimum and maximum number of arguments such function accepts.
            #    arg_count_max=$(( ${#func_args_commas} + 1 ))
            #    arg_count_min=$(( arg_count_max - ${#func_args_equals} ))
            #
            #Good Lord. Not a single instance of explicit iteration to be
            #found. Go, go, go!

    #FUXME: Such condition is already implied by ${args_is_variadic},
    #suggesting we should simply excise this boolean in favor of that.
    # 1 if a prior argument was variadic and 0 otherwise.
    # integer arg_was_variadic

    #FUXME: Arguably shift everything below to a separate function.

    # Compile such PCRE. For efficiency, avoid optionally optimizing such
    # PCRE by calling pcre_study(). (Ad-hoc profiling suggests such
    # optimization to consume more time than it saves.) See
    # for_string_text_matching_pcre:() for further details.
    # pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}"

    # Parse each such argument into canonical list global ${match}, whose
    # indices we localize as human-readable integers above.
    # local ZPCRE_OP='0 0'
    # while {
    #     pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
    # } {
    #     # Since the current argument may (but not necessarily) be passed,
    #     # increment the maximum argument count.
    #     arg_count_max+=1

    #     # If such argument is *NOT* variadic (i.e., was *NOT* suffixed by
    #     # an ellipse), note such fact. Test this condition *BEFORE* testing
    #     # whether such argument is optional, to prevent the latter's
    #     # enabling of boolean ${args_is_optional} when such argument is
    #     # both variadic and optional from triggering an exception here.
    #     if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_variadic}]-}" ]] {
    #         arg_is_variadic=0
    #     # Else, such argument is variadic.
    #     #
    #     # If a prior argument is optional, throw an exception. Such case
    #     # implies such function to accept one or more optional arguments
    #     # *AND* one or more variadic argument lists of arbitrary count,
    #     # implying there exists no general means of deciding which such
    #     # argument a passed string was intended to correspond to.
    #     } elif (( args_is_optional )) {
    #         ::func_.die_of_cause\
    #             'accepts both optional and variadic arguments'
    #     # If a prior argument is also variadic, throw an exception.  Such
    #     # case implies such function to accept two or more variadic
    #     # argument lists of arbitrary count, implying there exists no
    #     # general means of deciding which such list a passed string was
    #     # intended to belong to.
    #     } elif (( args_is_variadic )) {
    #         ::func_.die_of_cause\
    #             'accepts two or more variadic argument lists'
    #     # Else, such argument is validly variadic. Note such fact and such
    #     # function to accept one variadic argument list.
    #     } else {
    #         arg_is_variadic=1
    #         args_is_variadic=1
    #     }

    #     # If such argument is mandatory (i.e., was neither suffixed by an
    #     # eroteme *OR* a default value), note such fact and increment the
    #     # minimum argument count.
    #     if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_optional}]-}${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_value}]-}" ]] {
    #         arg_is_optional=0
    #         arg_count_min+=1
    #     # Else, such argument is optional.
    #     #
    #     # If such argument is suffixed by both an eroteme *AND* default
    #     # value, throw an exception. While either implies such argument to
    #     # be optional, each implies distinct, conflicting semantics.
    #     } elif [[\
    #         -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_optional}]-}" ||
    #         -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_value}]-}" ]] ||\
    #        ::func_.die_of_cause\
    #            'argument '${match[ZESHY_RUNNABLE_ARG_MATCH_INDEX_name]}' suffixed by both "?" and "="'
    #     # If a prior argument is also variadic, throw an exception,
    #     # explicitly ignoring the valid case that the current argument is
    #     # both variadic and optional. See above for further details.
    #     } elif (( args_is_variadic && ! arg_is_variadic )) {
    #         ::func_.die_of_cause\
    #             'accepts both optional and variadic arguments'
    #     # Else, such argument is validly optional. Note such fac and such
    #     # function to accept at least one optional argument.
    #     } else {
    #         arg_is_optional=1
    #         args_is_optional=1
    #     }

    #     #FUXME: Generalize to support localization as well. Since
    #     #localization and validation share the same ultimate desires here
    #     #(namely, appending to list ${args_index_type_optional_variadic}),
    #     #this would probably be simplified by logic resembling:
    #     #
    #     #    arg_type_is_validated=$((
    #     #        ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_unvalidated}]} ))
    #     #    arg_is_localized=$((
    #     #        1 - ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_is_unlocalized}]} ))
    #     #
    #     #    if (( arg_type_is_validated || arg_is_localized )) {
    #     #        args_metadata+=(
    #     #            "${arg_count_max}"
    #     #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_name}]}"
    #     #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"
    #     #            "${arg_is_optional}"
    #     #            "${arg_is_variadic}"
    #     #            "${arg_is_localized}"
    #     #            "${arg_type_is_validated}"
    #     #        )
    #     #    }
    #     #
    #     #As the above example implies, rename such list local to simply
    #     #${args_metadata}. (Judicious.)
    #     #
    #     #Reasonably clever; no extraneous if conditionals required. Wait;
    #     #the first doesn't quite work, as we need to prevent validation of
    #     #":string" types. So:
    #     #
    #     #    if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_unvalidated}]}" &&
    #     #             "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}" != ':string' ]] {
    #     #        arg_type_is_validated=1
    #     #    } else {
    #     #        arg_type_is_validated=0
    #     #    }
    #     #FUXME: Actually, ${args_index_type_optional_variadic} is hideous.
    #     #We can obviate both such list *AND* the following iteration
    #     #requiring such list by instead appending directly to keys of map
    #     #${arg_tester_to_values} here. To do so sanely, however, we *NEED*
    #     #to know the maximum number of arguments. We can accomplish this by
    #     #parsing such argument list twice: once without grouping and
    #     #optimized so as to match only unquoted "," as significant for
    #     #argument counting purposes, and the second actually parsing each
    #     #argument. However, to conform to the algorithm implemented below,
    #     #we would need to reperform such second round of argument parsing
    #     #a number of times equal to the number of optional arguments
    #     #accepted by such function.
    #     #
    #     #While such reparsing would be nonideal if the common case in zeshy
    #     #were functions accepting numerous optional arguments, the actual
    #     #common case in zeshy is the opposite: functions accepting at most
    #     #one (and typically no) optional arguments. Given that, there will
    #     #be *NO* reparsing in the common case. Indeed, such an approach
    #     #should dramatically improve the efficiency of the common case by
    #     #eliminating the need both to append an excrutiating number of
    #     #strings to list ${args_index_type_optional_variadic} *AND* to
    #     #iterate over such list.
    #     #
    #     #Note as well that the first parse can be dramatically optimized by
    #     #matching with a different (and hopefully much simplified) PCRE:
    #     #one performing no grouping and effectively matching only single-
    #     #and double-quoted strings (to ignore the nonsignificant commas
    #     #embedded in such strings) *AND* commas outside of such strings.
    #     #Actually, that's not quite true: we need to match commas,
    #     #erotemes, and equals signs, the latter two of which help us
    #     #calculate the minimum argument count, which we also need under
    #     #such refactoring. That said, such PCRE needn't actually match any
    #     #real argument syntax or structure, since the subsequent parse pass
    #     #will do so already.
    #     #
    #     #But it's *NOT* simply efficiency, though that is a dreaded
    #     #concern: it's elegance, or the lack thereof. The current approach
    #     #is horribly inelegant, requiring ever more strings be continually
    #     #appended to and parsed from such list. Let's do away with too fell
    #     #birds by one bright stone, shall we?
    #     #FUXME: Wooh. Just realized we don't even need to use PCRE matching
    #     #to count character instances in a string; we should be able to use
    #     #glob-driven global string replacement ala:
    #     #
    #     #    # Argument list with all single- and double-quoted strings
    #     #    # removed, preventing subsequent parsing from erroneously
    #     #    # counting ignorable ",", "?", and "=" characters
    #     #    # embedded in single- and double-quoted strings.
    #     #    local func_args_sans_quotes="${ZESHY_DECLARE_FUNC_ARGS__//('([^']|'')#'|\"([^\"]|\\\")#\")}"
    #     #
    #     #    # Argument list reduced to all remaining "," characters, whose
    #     #    # string length plus one offers the maximum number of arguments
    #     #    # such function accepts.
    #     #    local func_args_commas="${func_args_sans_quotes//[^,]##}"
    #     #
    #     #    # Argument list reduced to all remaining "?" and "=" characters,
    #     #    # whose string length subtracted from such maximum number 
    #     #    # offers the minimum number of arguments such function accepts.
    #     #    local func_args_equals="${func_args_sans_quotes//[^?=]##}"
    #     #    # Minimum and maximum number of arguments such function accepts.
    #     #    arg_count_max=$(( ${#func_args_commas} + 1 ))
    #     #    arg_count_min=$(( arg_count_max - ${#func_args_equals} ))
    #     #
    #     #Good Lord. Not a single instance of explicit iteration to be
    #     #found. Go, go, go!

    #     # If such argument's type is *NOT* to be ignored (i.e., is to be
    #     # validated), validate such type. To avoid overriding canonical
    #     # list global ${match} with matches captured below, do so *AFTER*
    #     # performing all other argument parsing above.
    #     if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_unvalidated}]}" ]] {
    #         # If such type is *NOT* ":string", validate such type. (Since
    #         # all arguments are untyped scalars from the low-level zsh
    #         # perspective, there exists no validation to be performed for
    #         # arguments of type ":string".)
    #         [[ "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}" == ':string' ]] || 
    #             args_index_type_optional_variadic+=(
    #                 "${arg_count_max}"
    #                 "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"
    #                 "${arg_is_optional}"
    #                 "${arg_is_variadic}" )
    #     }
    # }

    # #FUXME: Arguably shift everything below to a separate function.
    # #FUXME: How many of the variables below are still requisite?

    # # Code validating the number of arguments passed to such function.
    # local code_arg_count
    # 
    # # Code validating the types of arguments passed to such function.
    # local code_args_local_or_valid

    # # Name of the function validating the current argument type.
    # local arg_tester

    # # Substring prefixing argument variable type-specific exception messages.
    # local die_arg_var_type_prefix

    # # Number of optional arguments required by the current argument count
    # # below. If such function accepts no optional arguments, this number
    # # remains 0; else, this number varies between the maximum and minimum
    # # number of arguments such function accepts.
    # integer arg_count_optional

    # # Non-positive integer (i.e., strictly less than or equal to 0) by which to
    # # offset the current argument index below. If such function accepts no
    # # optional arguments, this integer remains 0; else, this integer is
    # # decremented once for each optional argument rejected by the current
    # # argument count. (See below for gritty details.)
    # integer arg_index_offset

    # # 1 if a prior argument was variadic and 0 otherwise.
    # integer arg_was_variadic

    # # For each possible number of arguments between the minimum and maximum
    # # established above, define code validating the types of all passed
    # # arguments when the caller passes that number of arguments.
    # integer arg_count
    # for     arg_count ({${arg_count_min}..${arg_count_max}}) {
    #     # Clear such map. See :clear_map() for further details.
    #     set -A arg_tester_to_values

    #     # Revert local variables declared above specific to the following loop.
    #     arg_count_optional=$(( arg_count - arg_count_min ))
    #     arg_index_offset=0
    #     arg_was_variadic=0

    #     # Define such map by parsing the previously defined 4-tuple list of all
    #     # relevant argument metadata.
    #     local arg_index
    #     for   arg_index arg_type arg_is_optional arg_is_variadic (
    #         "${args_index_type_optional_variadic[@]}") {

    #         # If such argument is optional, ...
    #         if (( arg_is_optional )) {
    #             # If the current argument count permits no additional optional
    #             # arguments. ignore such argument.
    #             (( arg_count_optional )) || {
    #                 # Decrement the argument index offset. Prior iteration
    #                 # assigned each argument an index under the assumption that
    #                 # all optional arguments are passed. However, the current
    #                 # argument count implies the current optional argument to
    #                 # *NOT* be passed, implying all subsequent argument indices
    #                 # to be one larger than previously assumed. Correct this!
    #                 arg_index_offset+=-1

    #                 # Skip to the next argument.
    #                 continue
    #             }

    #             # Else, such argument count supports such argument. Decrement
    #             # such count, implying such count to now support one less
    #             # subsequent optional argument. (The current optional argument
    #             # "consumes" one of the available optional argument "slots"
    #             # permitted by such count.)
    #             arg_count_optional+=-1
    #         }

    #         # Decrement such argument index by such offset. See above!
    #         arg_index+=${arg_index_offset}

    #         # If such argument is variadic, index such argument and all
    #         # subsequent optional variadic arguments with an argument range
    #         # starting at the current positive index and ending at the negative
    #         # index of the last such argument. See below for related logic.
    #         if (( arg_is_variadic )) {
    #             arg_index=${arg_index}','$(( arg_index - arg_count_max - 1 ))

    #             # Note such fact for testing by subsequent iteration.
    #             arg_was_variadic=1
    #         # Else if such argument follows a variadic argument, such argument
    #         # cannot be reliably indexed by its positive index (i.e., relative
    #         # to the start of such argument list). Since such argument can,
    #         # however, be reliably indexed by its negative index (i.e.,
    #         # relative to the end of such argument list), replace the former
    #         # with the latter.
    #         #
    #         # Since the negative sign "-" conflicts with parameter expansion
    #         # syntax, negative indices may only be referenced by indexing canonical
    #         # list global ${@} or ${argv} with such index.
    #         #
    #         # Happily, such conversion applies equally well regardless of whether
    #         # such variadic argument was optional or mandatory.
    #         } elif (( arg_was_variadic )) {
    #             arg_index=$(( arg_index - arg_count_max - 1 ))
    #         # Else such argument precedes a variadic argument if any, In such
    #         # case, such argument is reliably indexable by its positive index
    #         # and hence requires no adjustment,
    #         }

    #         # Append such index to the space-separated and parameter expansion-
    #         # delimited string of all indices of such argument's type.
    #         arg_tester_to_values[${arg_type}]+=' "${@['${arg_index}']}"'
    #     }

    # integer arg_count_min=0 arg_count_max=0

    # List of argument-specific metadata for all arguments whose types are to
    # be programmatically validated (excluding of type ":string", requiring no
    # such validation). Such validation typically depends on the maximum number
    # of arguments accepted by such function, a quantity available only *AFTER*
    # parsing all such arguments. Such parsing thus appends this list by such
    # metadata, which post-parsing then converts into such validation. Such
    # metadata comprises a conceptual 4-tuple
    # (${arg_index} ${arg_type} ${arg_is_optional} ${arg_is_variadic}).
    # local -a args_index_type_optional_variadic

    # decide how
    # best to index optional and variadic arguments 
    #
    # , runnable
    # argument parsing requires.
    #
    #FUXME: Obsolete.
    # If such argument string is *NOT* the empty string, such function accepts
    # at least one argument. In such case, parse such arguments.
    # if [[ -n "${ZESHY_DECLARE_FUNC_ARGS__}" ]] {

    # Current argument type's optional eroteme (i.e., "?"), signifying that
    # such function's definition should *NOT* be prefixed by a call to an
    # exception handler throwing an exception if such argument violates the
    # constraints of such type (e.g., a non-numeric string passed where an
    # integer was expected). If unspecified, such definition is prefixed by
    # such a call.
    # integer -r ZESHY_RUNNABLE_ARG_MATCH_INDEX_type_is_ignorable=2

    # such function's definition should *NOT* be prefixed by a call to an
    # exception handler throwing an exception if such argument violates the
    # constraints of such type (e.g., a non-numeric string passed where an
    # integer was expected). If unspecified, such definition is prefixed by
    # such a call.

#FUXME: This file grows exceedingly long. While such exceptions *COULD* be
#shifted to @{*-test}, doing so would prohibit their documentation there,
#further complicating matters. Instead, contemplate concocting a new
#@{40-func/} parcel tree, shifting this parcel there as @{func}, concocting
#a new parcel @{die} there as well, and shifting all exception handlers below
#to the latter parcel.

    # Pop such argument off such list. See pop_arg() for further details.
    # argv[-1]=()

    #FUXME: Excissively verbose, particularly when replicated across
    #*EVERY* single zeshy function. See above for further details.

    # # Validate the number of arguments passed to such function.
    # #
    # # If such function is variadic, such function accepts a countably
    # # infinite number of arguments only bounded below by such minimum.
    # if (( args_is_variadic )) {
    #     code_arg_count='(( # >= '${arg_count_min}' ))'${die_arg_count_prefix}'at least '${arg_count_min}' arguments but received only ${#}'${die_arg_count_suffix}
    # # Else, such function is non-variadic, in which case such function
    # # accepts a number of arguments bounded by such minimum and maximum.
    # #
    # # If such minimum and maximum are equal, simplify such test as such.
    # } elif (( arg_count_min == arg_count_max )) {
    #     code_arg_count='(( # == '${arg_count_min}' ))'${die_arg_count_prefix}${arg_count_min}' arguments but received ${#}'${die_arg_count_suffix}
    # # Else, such minimum and maximum are unequal.
    # } else {
    #     code_arg_count='(( '${arg_count_min}' <= # && # <= '${arg_count_max}' ))'${die_arg_count_prefix}'between '${arg_count_min}' and '${arg_count_max}' arguments but received ${#}'${die_arg_count_suffix}
    # }

    # (( ${#funcstack} >= 2 )) || :die 'Called directly from the command line.'
    # Shift and pop such arguments off. See shift_arg() and pop_args_2() for
    # further details.
    # argv[1]=()
    # argv[-2,-1]=()

    #         # List of all argument indices to be tested. Unlike
    #         # ${arg_values_string}, such list consists only of integers.
    #         local -a arg_values

    #         # Convert the passed list of 

    #         # Iterate arguments by index until finding the first failing argument.
    #         # Such indices encompass both index ranges (e.g., "@[3,-1]") and
    #         # negative indices (e.g., "@[-1]" and hence are *NOT* strictly
    #         # integers.
    #         local arg_index
    #         for   arg_index ('${arg_values}') {
    #             # Strip "@[" and "]" delimiters, if found.
    #             arg_index="${${arg_index#@\[}%]}"

    #             # If such index is comma-separated, split such index into two
    #             # indices signifying an index range and iteratively test all
    #             # arguments in such range.
    #             if [[ "${arg_index}" == (#b)([^,]##),(*) ]] {
    #                 for arg_index ({${match[1]}..${match[2]}}) {
    #                     .
    #                 }
    #             # Else, such index is a single integer. Test such argument.
    #             } else {
    #                 '${arg_tester}' "${@[${arg_index}]}" || '
    #         
    #         # If such tester tests variable rather than value types, tailor such
    #         # exception message to variable types. There exist two cases to
    #         # distinguish here:
    #         #
    #         # 1. Such variable does not exist.
    #         # 2. Such variable does exist but is of a different type.
    #         if (( arg_type_is_var_type )) {
    #             die_arg_var_type_prefix=':die "Function ${funcstack[1]}() expected argument ${arg_index} referencing variable of type '${arg_type[8,-1]}' but variable \$\{${@[${arg_index}]}\} '

    #             #FUXME: The type printed above is a high-level zeshy-specific type;
    #             #The type printed below is a low-level zsh-specific type.
    #             #Naturally, the latter should be converted to the former.

    #             code_args_local_or_valid+='{
    #                 if { :is_var } {
    #                     '${die_arg_var_type_prefix}'has type ${(tP)@[${arg_index}]} and value:"$''\n''"${@[${arg_index}]}"
    #                 } else {
    #                     '${die_arg_var_type_prefix}'not found."
    #                 }
    #             }'
    #         # Else, tailor such exception message to value types.
    #         } else {
    #             code_args_local_or_valid+=':die "Function ${funcstack[1]}() expected argument ${arg_index} of type '${arg_type}' but received:"$''\n''"${@[${arg_index}]}"'
    #         }

    #         # End such exception message and such validation.
    #         code_args_local_or_valid+='$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY_DECLARE_FUNC_PROTOTYPE__}'
    #     }
    # }'
    #     }

    #     #FUXME: Document me.
    #     if (( args_is_optional )) {
    #         code_args_local_or_valid+='
    # }'
    #     }

            # Delimit each such index by '"${' and '}"' (e.g., convert "1 3 4" to
            # '"${1}" "${3}" "${4}"). Such operation must *NOT* be double-quoted.
            # See "README.dev" for further details. Dismantled, this is:
            #
            # * "=", splitting such indices on whitespace.
            # * "(#m)*", capturing the current index to string global ${MATCH}.

            #FUXME: Excissively verbose, particularly when replicated across
            #*EVERY* single zeshy function. Encapsulate all functionality following
            #the first "||" below with new exception handlers resembling
            #::func_.die_of_cause(). However, such handlers should accept
            #function names rather than prototypes; given the former, such handlers
            #may losslessly obtain the latter by calling the corresponding setter.
            #FUXME: O.K.; we've now drafted
            #::func.die_unless_arg_values_pass_tester() below. Call
            #such function here.
            #FUXME: If you consider it, there's no genuine reason not to simply
            #delimit such indices by "${" and "}" in the prior iteration above
            #at the point where such indices are appended to such key value.
            #Doing so should improve efficiency here by quite a bit, not to
            #mention simplifying everything a tad.

            # } else {
            #     arg_index='${'${arg_index}'}'
            # }

    # Name of the function or script calling this function. See get_caller()
    # for further details.
    # caller_name="${funcstack[2]}"

        # Ensure such argument index actually is.
                # There exist two
                # cases to distinguish here:
                #
                # 1. Such 
                # 2. Such variable does exist but is of a different type.

        # Strip "@[" and "]" delimiters, if found.
        # arg_index="${${arg_index#@\[}%]}"

        # # If such index is comma-separated, split such index into two
        # # indices signifying an index range and iteratively test all
        # # arguments in such range.
        # if [[ "${arg_index}" == (#b)([^,]##),(*) ]] {
        #     for arg_index ({${match[1]}..${match[2]}}) {
        #         .
        #     }
        # # Else, such index is a single integer. Test such argument.
        # } else {

    #FUXME: Definitely non-ideal. Such low-level details should be handled by a
    #new setter managing such effluvia for us -- say,
    #:set_string_to_func_prototype(),
    #:set_string_to_global_prototype(), and so on. For now, just implement the
    #former function. Should be readily doable, based on the logic below.
    # local func_prototype_setter_name="${ZESHY_HELP_SETTER_NAME_PREFUX}func_prototype:${func_name}"
    # :func.die_unless "${func_prototype_setter_name}"
    # "${func_prototype_setter_name}" func_prototype

        #     code_args_local_or_valid+='
        # '${arg_tester}' '${${=arg_values}//(#m)*/\"\${${MATCH}}\"}' || {

 # enabling such validation only if the caller passed the
        # current number of arguments.
    # 1 if the current argument type is a variable type (i.e., the type of the
    # variable to which such argument's value refers, such as ":string:int")
    # and 0 if such type is a value type (i.e., the type of such argument's
    # value, such as ":int_positive"). The former are the zsh equivalent of
    # pointer indirection; the latter are customary arguments.
    # integer arg_type_is_var_type
    #             arg_type_is_var_type=0
    #             arg_type_is_var_type=1

# } elif (( arg_index > arg_index_variadic_first )) {
# the number of optional arguments required by the current
        # argument count *AND* argument index offset to their initial values.
        #FUXME: Arguably, all interior logic here could be shifted into a new
        #private utility function.
        #
        # {optional argument}
        # arg_count_max = 4
        # arg_count_min = 2
        # arg_count     = 2
        # arg_count_optional = arg_count - arg_count_min = 0
        # 1 [2] 3 [4] (fake indices here)
        # 1     2     (desired indices to be rewritten to)
        # 0 -1 -1 -1  (value of ${arg_index_offset} after parsing)
        #
        # arg_count_max = 6
        # arg_count_min = 3
        # arg_count     = 3
        # arg_count_optional = arg_count - arg_count_min = 0
        # 1 [2 3] 4 [5] 6 (fake indices here)
        # 1       2     3 (desired indices to be rewritten to)
        # 0 -1-2 -2 -3 -3 (value of ${arg_index_offset} after parsing)
        # 0  0 0  0  0  0 (value of ${arg_count_optional} after parsing)
        #
        # arg_count_max = 6
        # arg_count_min = 3
        # arg_count     = 4
        # arg_count_optional = arg_count - arg_count_min = 1
        # 1 [2 3] 4 [5] 6 (fake indices here)
        # 1  2    3     4 (desired indices to be rewritten to)
        # 0  0-1 -1 -2 -2 (value of ${arg_index_offset} after parsing)
        # 1  1 0  0  0  0 (value of ${arg_count_optional} after parsing)
        #
        #We could probably relate ${arg_index_offset} and
        #${arg_count_optional}, but it hardly seems worth it. O.K.; so, integer
        #local ${arg_count_optional} suggests the following algorithm:
        #
        #* Define such integer above.
        #* Set such integer as above here.
        #* If the current argument is optional in the iteration below *AND*
        #  such integer is positive, decrement such integer by 1, signifying
        #  such iteration to have handled an additional optional argument
        #  admitted by the current argument count.
        #* Else, continue (literally) to the next argument in such iteration.
        #
        #And... that's it! Surprisingly straightforward.

            #FUXME: How to implement optional and variadic argument indices? Hmm.
            #
            # [optiona]
            # arg_min_count = 2
            # arg_max_count = 4
            # arg_optional_count = 2 = arg_max_count - arg_min_count
            #
            #   ? ?
            # 1 2 3 4
            # to check 2, this suffices: "(( # >= 3 ))"
            # to check 3, this suffices: "(( # == 4 ))"
            #
            # [optiona]
            # arg_min_count = 5
            # arg_max_count = 5
            # arg_optional_count = 0 = arg_max_count - arg_min_count
            #
            # {non-optional case}
            # arg_max_count = 5
            # #             = 9
            # 1 2  3 4 5 6 7   8  9 (true indices in reality)
            # 1 2  3           4  5 (fake indices here)
            # 1 2 [3 4 5 ...] -2 -1 (desired indices to be rewritten to)
            # 3-5-1=-3
            #
            # {optional case}
            # arg_max_count = 5
            # 1 2  3           4  5
            # 1 2 [3 4 5 ...] -2 -1
            # ...hmm; looks the same as above, eh?
            #
            #If a variadic argument is present, all indices following such
            #argument should be negative rather than positive. However, this
            #can only be achieved *AFTER* parsing such arguments. To do so,
            #we'll need to preserve the index of the variadic argument in the
            #iteration above -- say, as ${arg_index_variadic_first}. Easily
            #done, at least. Seems sensible, no?
            #
            #Of course, the above assumes such variadic argument to be nonoptional.
            #If optional, things change somewhat -- not substantially, but they
            #*DO* change. Contemplate.
            #FUXME: Right. Optional arguments are best handled by dynamically
            #declaring argument count-specific variants of map
            #${arg_tester_to_values}: e.g.,
            #
            # if (( arg_is_optional )) {
            #     local args_list_name="arg_tester_to_values_if_args_${arg_index}_or_more"
            #     local -A ${args_list_name}
            #     ...
            # }
            #
            #Actually, such lists should be declared by the prior iteration. Then
            #test here whether "(( args_is_optional ))", implying at least one
            #optional argument to exist. If this is the case, then *ALL*
            #non-optional arguments preceding the first optional argument need to
            #be appended to the appropriate key values of *ALL* such lists (since,
            #of course, such non-optional arguments must be unconditionally
            #validated regardless of how many arguments were passed).

                # Note the index of the first variadic argument.
                # arg_index_variadic_first="${arg_count_max}"

    # Index of the first variadic argument. Defaulting such index to an
    # arbitrarily large value ensures that tests of whether or not the current
    # argument index follows that of a variadic argument fail below unless this
    # function actually accepts such a variadic argument.
    # integer arg_index_variadic_first=32768

            # Else, such argument is mandatory.
                #FUXME: Obsolete?
                # # If such argument is also variadic, ...
                # if (( arg_is_variadic )) {
                # # Else, such argument is non-variadic.
                # } else {
                # }

                    # the caller
                    # default to the value 
                    #
                    # ensuring subsequent
                    # argument indices are 

        # 1     2     (true indices in reality)
                # for    such
                # iteration to have handled an additional optional argument
                # admitted by the current argument count.

            # # If such argument is optional, ...
            # if (( arg_is_optional )) {
            #     true
            # # Else if such argument is variadic, ...
            # } elif (( arg_is_variadic )) {
            #     # If such argument is mandatory, index all arguments in the range
            #     # of such variadic argument list, beginning with such positive
            #     # index and ending with the negative index of the last argument in
            #     # such list. See below for related logic.
            #     if ! (( arg_is_optional )) {
            #         arg_index="@[${arg_index},"$(( arg_index - arg_count_max - 1 ))']'
            #     # Else, such argument is optional.
            #     } else {
            #         true
            #     }
            # # Else, such argument is mandatory.
            # #
            # } elif (( arg_index > arg_index_variadic_first )) {
            #     arg_index='@['$(( arg_index - arg_count_max - 1 ))']'
            # }

# Construct code validation of such type to the string of all
        # validation for such function.

    #FUXME: Huzzah! We've uncovered an elegant way of implementing optional
    #arguments: simply wrap *EVERYTHING* relating to argument type validation
    #below in an outer loop resembling:
    #
    #integer arg_count
    #for     arg_count ({${arg_count_min}..${arg_count_max}}) {
    #    ...
    #}
    #
    #*NOTHING* else changes. Given such structure, we intuit that there should
    #be no need for dynamically declared map variables and such. Retaining the
    #current logic and variables *SHOULD* suffice. "Hey, ho! Off and away we go."

            # if (( args_is_variadic && arg_count_min != arg_count_max )) {
            #     ::func_.die_of_cause 'accepts both optional and variadic arguments'
            # }

# and increment the minimum argument
            # count as well
                    #FUXME: Document me.
                    # args_map_name="arg_tester_to_values_if_args_${arg_count_max}_or_more"
                    # local -A ${args_map_name}

    #FUXME: Document me, if still used.
    # local args_map_name

    #FUXME: Actually, the following iteration appears to be unnecessary. We can
    #probably embed the following statement in the prior iteration:
    #
    #    arg_tester_to_values[${arg_type}]+=" ${arg_index}"
    #
    #However, to support optional and variadic arguments, we'll probably want
    #to embed delimiting characters indicating the current argument index in
    #the above string value to be either optional and variadic. For example,
    #optional argument indices could be indicated as follows:
    #
    #    arg_tester_to_values[${arg_type}]+=" ${arg_index}?"
    #
    #Variadic argument indices could be indicated as follows:
    #
    #    arg_tester_to_values[${arg_type}]+=" ${arg_index}."
    #
    #Dead simple. Both time- and space-efficient to parse. So, let's do that.

    #FUXME: Implement me as commented above. We'll likely want to:
    #
    #* Append all such code to string local ${func_preamble},
    #  defined by the caller.
    #* If such type:
    #  * Matches glob ":string:(#b)([a-zA-Z0-9-_])", call
    #    :die_unless_var_${match[1]}_of_cause().
    #  * Matches glob ":(#b)([a-zA-Z0-9-_])", call
    #    :die_unless_${match[1]}_of_cause(). Throw an exception
    #    here if such exception handler does not exist.
    #* How do we handle optional arguments? Right. By the above
    #  guarantee, an argument list cannot contain both optional
    #  and variadic arguments. Given that, if the current
    #  argument is optional, simply assume no variadicity (on
    #  good faith) and... What? Hmm; right. For now, since the
    #  function will almost certainly be setting such optional
    #  value to its default if unpassed, we'll probably want
    #  to (within such appended code, of course):
    #  * Test whether such argument was passed by checking the
    #    number of passed arguments. That's easily enough
    #    tested for functions with only one optional argument,
    #    of course, but for functions accepting more than one,
    #    the algorithm becomes a bit more complex. In any case,
    #    we won't know the maximum number of arguments until
    #    *AFTER* parsing, suggesting we'll probably want to
    #    append to a list local for each optional argument
    #    type (to be handled after iteration). Say, append the
    #    name, type, and index of such argument as three
    #    separate list items, then iterate such list
    #    three-at-a-time? Seems tolerable enough.
    #  * In any case, if such test implies such argument to
    #    have been passed, validate such argument's type; else,
    #    assume the default value the function itself supplies
    #    to be of the correct type. (Sane assumption, in most
    #    cases. Yay!)
    #* Don't forget to handle variadic arguments! (Ugh.)
    #  We'll probably only be able to handle type validation
    #  for such arguments *AFTER* parsing all arguments and
    #  hence determining how many (if any) arguments follow
    #  such variadic list. Unctuous, but not infeasible. See
    #  the discussion above for optional arguments. Probably a
    #  similar post-iteration implementation, we should think.
    #FUXME: Actually, for efficiency, perform low-level raw
    #string indexing with hard-coded indices rather than
    #capturing match groups with "(#b)" above. Happily, this
    #also has the beneficial side-effect of preserving
    #${match}, which may prove essential later.

                    #FUXME: Obsolete.
                    # # if such argument is variadic, note such fact.
                    # if (( arg_is_variadic )) {
                    #     args_index_type_optional_variadic+=( "${arg_max_count}" 1 0 )
                    # # Else if such argument is optional, note such fact.
                    # } elif (( arg_is_optional )) {
                    #     args_index_type_optional_variadic+=( "${arg_max_count}" 0 1 )
                    # }

            # If such argument is optional, note such function to accept at
            # least one optional argument. Perform such test *AFTER* the
            # variadic-specific logic above possibly adjusts such boolean.
            # if (( arg_is_optional )) {
            #     args_is_optional=1
            # }

                # If such argument is both variadic *AND* optional, ignore the
                # latter fact. This barefaced kludge prevents validation below
                # from throwing an exception due to such function accepting
                # both variadic and optional arguments. In general, there
                # exists no reliable means of distinguishing such arguments
                # apart, constituting a fatal error. In this case, however,
                # assuming the variadic argument to also be the only optional
                # argument, there exists no conflict between the two, in which
                # case condition is genuinely ignorable.
                # if (( arg_is_optional )) {
                #     arg_is_optional=0
                # }

 # For
                # simplicity, print only the first function name in such
                # exception message.
    #FUXME: Utterly horrid. Good God; the hacks we employed both here and
    #above. Excise this away by returning to what we had before: just perform
    #such test twice, once when the current argument is variadic and  once when
    #the current argument is optional. Dramatically more elegant. *sigh*

    # If such function accepts both optional and variadic arguments, there
    # exists no general-purpose means of distinguishing the two for *ANY*
    # purposes (let alone for argument validation coded below). Since this
    # signifies a fatal error, throw an exception.
    #
    # We maintain booleans for tracking whether such function accepts variadic
    # but *NOT* optional arguments. Happily, testing whether the minimum and
    # maximum number of arguments such function accepts suffices to test
    # whether such function accepts optional arguments.
    #
    # While such test *COULD* be tested for above with multiple discrete tests
    # (e.g., if the current argument is optional, testing for prior variadic
    # arguments, and the inverse if the current argument is variadic), the
    # current approach is considerably more intelligible.
    # if (( args_is_variadic && arg_count_min != arg_count_max )) {
    #     ::func_.die_of_cause 'accepts both optional and variadic arguments'
    # }

# arg_index_start arg_index_end
            # Test such argument(s).

                # args_map_name="args_index_type_optional_variadic_if_args_${arg_count_max}_or_more"
    #FUXME: Documentation unsurprisingly obsolete, as is this list's name.
    #Resurrect the prior list's name and documentation from the wastelands.

    # Map from argument index to a character signifying optional metadata
    # associated with such argument:
    #
    # * "?", signifying such argument to be optional.
    # * ".", signifying such argument to be variadic.

#, each
    # item of whuch signifies the expected :
        #FUXME: Hmm; such operation works, but how and where? Well, we suppose
        #we'll need to shift back such map appending back here. *sigh*

            # if (( arg_count_max == arg_count_min )) {
            #     arg_index=$(( arg_index - arg_count_max - 1 ))
            # } else {
            #     arg_index=$(( arg_index - arg_count_max - 1 ))
            # }

        #FUXME: We need to strip "?" and "." characters optionally suffixing
        #such indices from such string of indices prior to munging it below.
        # args_index_type_optional_variadic.

    #FUXME: Obsolete.
    # List of argument-specific metadata for all arguments with types other
    # than simply ":string" to be validated. Such validation typically
    # depends on the maximum number of arguments accepted by such function, a
    # quantity available only *AFTER* parsing all such arguments. Such parsing
    # thus appends such metadata to this list, which post-parsing iteration
    # then converts into such validation.
    # local -a args_index_name_type_optional_variadic

    #FUXME: Document me.
    # local arg_index_suffix

    #FUXME: Document optional and variadic argument-specific suffixes.

                    #FUXME: Obsolete.
                    # args_index_name_type_optional_variadic+=(
                    #     "${arg_count_max}"
                    #     "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_name}]}"
                    #     "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"
                    #     "${arg_is_optional}"
                    #     "${arg_is_variadic}"
                    # )

                    #FUXME: Arguably not the best way to do things. Wouldn't
                    #the following be preferable:
                    #
                    # if (( arg_is_optional )) {
                    #     args_index_type_optional_variadic[${arg_index}]='?'
                    # } elif (( arg_is_variadic )) {
                    #     args_index_type_optional_variadic[${arg_index}]='.'
                    # }
                    #
                    #Then, just efficiently check such list item below. That
                    #circumvents the need to unpack such suffixes, which does
                    #indeed appear to pose an undue burden on logic below.

                    # If such argument is optional, suffix such index by an
                    # arbitrary character indicating that fact.
                    # if (( arg_is_optional )) {
                    #     arg_index_suffix='?'
                    # # Else if such argument is variadic, suffix such index by
                    # # an arbitrary character indicating that fact.
                    # } elif (( arg_is_variadic )) {
                    #     arg_index_suffix='.'
                    # # Else, suffix such index by no such character.
                    # } else {
                    #     arg_index_suffix=
                    # }

                    # # Append such argument's index to the space-delimited
                    # # string of all indices with such argument's type.
                    # arg_tester_to_values[${arg_type}]+=" ${arg_index}${arg_index_suffix}"

    # against such prototype constraints parsed above.
    # Whitespace-delimited string of all argument expansions to be passed to
    # the current argument type validator (e.g., '"${1}" "${3}" "${4}").
    # local arg_values

        #FUXME: Combine this and the subsequent assignment, ideally later.

        # Delimit each such index by '"${' and '}"' (e.g., convert "1 3 4" to
        # '"${1}" "${3}" "${4}"). Such assignment must *NOT* be double-quoted.
        # See "README.dev" for further details. Dismantled, this is:
        #
        # * "=", splitting such indices on whitespace.
        # * "(#m)*", capturing the current index to string global ${MATCH}.
        # arg_values=${${=arg_values}//(#m)*/\"\${${MATCH}}\"}

            # code_args_local_or_valid+='''Function ${funcstack[1]}() argument ${arg_index} references variable ${''${@[${arg_index}]}''} either not found or not of expected type '${arg_type[8,-1]}'.'''
        # "Function ${funcstack[1]}() expected argument ${arg_index} of type '${arg_type}' but received:"$''\n''"${@[${arg_index}]}"$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY_DECLARE_FUNC_PROTOTYPE__}'
# '$''\n\n''"Argument ${arg_index}:"$''\n''"${@[${arg_index}]}"

#(i.e., rejected by function '${arg_tester}'())
        #FUXME: Ugh. This does *NOT* suffice, principally due to the horrid
        #ambiguity of the resulting exception messages. No, my good friends;
        #we'll need to manually call a tester instead and when such tester
        #fails manually iterate such arguments until finding the failing
        #argument.
        #FUXME: Ugh. Even *THAT* fails to suffice. Why? Because we've
        #wrongfully conflated the two sorts of validation performed here.
        #:die_unless_var_*() functions require a *COMPLETELY* different calling
        #convention: namely, they require such arguments to be localized and
        #the names of such local variables to be passed rather than their
        #indices. Regardless of the calling convention, however, we'll still
        #need to implement the prior FUXME comment in both cases. *sigh*
        #FUXME: Such localization would be greatly simplified by *ALWAYS*
        #unconditionally localizing non-variadic arguments. That said, the
        #inefficiency costs are (indeed) annoyingly cloying in that case.
        #FUXME: Wait. Nevermind. We convoluted ourselves here. Obviously, the
        #calling conventions are the same in both cases. So, just apply the
        #initial FUXME above. (My, what convolutions of an unwitty demagouge.)

        # :func.die_unless "${arg_tester}"
    #FUXME: Rename, as such variable is reused below in a different context.

    #FUXME: Should arguably be shifted to @{*-pcre} and converted into a string
    #global accessed both here and in that parcel.
    #FUXME: Actually, this is altogether silly. Excised!

    # Character class matching all permissible characters in operable names.
    # See @{*-pcre} for further details.
    # local operable_name_char_class='[a-zA-Z0-9-_]'

        #FUXME: This could absolutely benefit from a significantly more
        #informative message. This will probably happen *ALL* the time.

        # Name of the function performing such validation.
        # Delimit each such index by '"${' and '}"' (e.g., convert "1 3 4" to
        # '"${1}" "${3}" "${4}"). Such assignment must *NOT* be double-quoted.
        # See "README.dev" for further details. Dismantled, this is:
        #
        # * "=", splitting such indices on whitespace.
        # * "(#m)*", capturing the current index to string global ${MATCH}.
        # arg_values=${${=arg_values}//(#m)*/\"\${${MATCH}}\"}

        # Append code calling such function with each such arguments.
        # code_args_local_or_valid+=$'\n'${arg_type_checker}' '${arg_values}

        #FUXME: Inefficient in the common case there exist multiple
        #arguments of the same type to be tested. Ideally, we want only a
        #single function call validating all such arguments together,
        #suggesting we probably need a new local map from... say,
        #"${check_func_name}" keys to "${arg_index1} ${arg_index2} ..."
        #values. Not terribly arduous to maintain or parse, happily.

    # Map from function names validating variable types to space-delimited
    # strings listing the indices of all arguments to be validated by such
    # function.
    # local -A var_type_checker_to_arg_values

        # arg_name\
        # arg_type\
            #FUXME: Do we still require ${arg_is_optional}?

                #FUXME: Nonsensical hack. Just add a new boolean
                #${args_is_optional} above, defaulting to 0.

                # If such argument is both variadic *AND* optional, reduce the
                # total number of maximum arguments by one. This barefaced
                # kludge prevents validation below from throwing an exception
                # due to such function accepting both variadic and optional
                # arguments. In general, there exists no reliable means of
                # distinguishing such arguments apart, constituting a fatal
                # error. In this case, however, assuming the variadic argument
                # to also be the only optional argument, there exists no
                # conflict between the two.
                #
                # Since variadic functions accept a countably infinite number
                # of arguments and hence have no maximum argument count,
                # decrement such count rather than incrementing the minimum
                # argument count. While either suffices to squelch such
                # validation below, the latter erroneously renders such
                # argument non-optional. (In any event, we trudge onward.)
                # if (( arg_is_optional )) {
                #     arg_count_max+=-1
                # }

    #FUXME: Hmm; why don't we also define ${args_is_variadic} here too?

                # # arg_type="${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"

                # # If such type is *NOT* ":string", validate such type. (Since
                # # all arguments are untyped scalars from the low-level zsh
                # # perspective, there exists no validation to be performed for
                # # arguments of type ":string".)
                # if [[ "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}" != ':string' ]] {
                # # if [[ "${arg_type}" != ':string' ]] {
                #     arg_names_types+=(
                #         "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_name}]}"
                #         "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}" )
                #     arg_name="${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_name}]}"

                #     # If such argument is optional, ...
                #     if (( arg_is_optional )) {
                #         true
                #     # Else, such argument is mandatory.
                #     } else {
                #         # If such argument is a string referring to another
                #         # variable's name, validate that such variable exists
                #         # *AND* is of the expected type.
                #         if [[ "${arg_type}" ==\
                #             ':string:'${~operable_name_char_class} ]] {
                #             # Name of the function performing such tests.
                #             test_func_name=":die_unless_var_${arg_type[9,-1]}_of_cause"
                #             :func.die_unless "${test_func_name}"

                #             # test_arg_types+=""
                #         }
                #     }

    # # Total number of optional arguments for such function.
    # integer arg_count_optional=0

    # See
    # :func.die_unless() and :define_function() for further details.
    # { typeset -f -- "${ZESHY_DECLARE_FUNC_NAMES__[@]}" } 1>/dev/null || {
    #     local func_name
    #     for   func_name ("${ZESHY_DECLARE_FUNC_NAMES__[@]}") {
    #         if (( ${+functions[${func_name}]} )) {
    #             :die "Function ${func_name}() already exists:"$'\n'"$(which -- "${func_name}")"
    #         }
    #     }
    # }

                            # If such function does *NOT* exist, throw an
                            # exception.

            #FUXME: If there exists at least one optional argument *FOLLOWING*
            #a variadic argument list, throw an exception, as there exists no
            #means of distinguishing the two. 

            # # If such argument follows a variadic argument list, throw an
            # # exception, as there exists no means of distinguishing the two.
            # } elif (( args_is_variadic )) {
            #     #FUXME: Insufficient. We *ALSO* need to throw an exception if
            #     #optional arguments precede variadic arguments. Given that,
            #     #we'll probably want to validate this constraint *AFTER*
            #     #parsing all arguments. Then simply perform the following test
            #     #below after iteration and excise this conditional here:
            #     #
            #     #if (( args_is_variadic && arg_count_min != arg_count_max )) {
            #     #    :die '...'
            #     #}
            #     #
            #     #No need to add or track a new boolean, which is nice.

            #     ::func_.die_of_cause:die ${(e)error_prefix}' accepts both optional and variadic arguments:'${(e)error_suffix}

            # If such argument is suffixed by both an eroteme *AND* default
            # value, print a nonfatal warning. While redundant, such edge case
            # does *NOT* warrant a fatal exception.

# error_prefix error_suffix
    #FUXME: Nonsense. Just concoct a new private exception handler -- say,
    # :void ::func_.die_of_cause(:string exception_message)

    # Substrings prefixing and suffixing all exception messages thrown below.
    # For efficiency, require such strings be expanded below with parameter
    # expansion flag "(e)", delaying the cost of forking a subshell until
    # necessary. For readability, list only the first function name declared by
    # such prototype.
    # error_prefix='Function ${ZESHY_DECLARE_FUNC_NAMES__[1]}()$(::get_parcel_preposition)'
    # error_suffix='$''\n\n''${ZESHY_DECLARE_FUNC_PROTOTYPE__}'

        #FUXME: Insufficient. We *ALSO* need to throw an exception if
        #optional arguments precede variadic arguments. Given that,
        #we'll probably want to validate this constraint *AFTER*
        #parsing all arguments. Then simply perform the following test
        #below after iteration and excise this conditional here:
        #
        #if (( args_is_variadic && arg_count_min != arg_count_max )) {
        #    :die '...'
        #}
        #
        #No need to add or track a new boolean, which is nice.

                #FUXME: $(::get_parcel_preposition_if_found_or_noop) is
                #horrible, isn't it? ${ZESHY_PARCEL_NAME} should *ALWAYS* be
                #set to a non-empty string, implying we should just excise such
                #function and expand such low-level string global here and
                #everywhere similar else.
                #FUXME: Hmm; define a new string local above:
                #   #  For simplicity, print only the first function name in such message.
                #   local error_message_prefix='Function '${ZESHY_DECLARE_FUNC_NAMES__[1]}'() in parcel '${ZESHY_PARCEL_NAME-(undefined)}

    #FUXME: Terrifically silly. We can simply rewrite this to read:
    #    die_arg_count_prefix=' || :die "Function ${funcstack[1]}() expects '
    #
    #Obvious, if moderately clever. Given that, shift this and the
    #following if conditional to the very end of
    #::func_.stop_parse_prototype(). (Yes!)

        # functions[${func_name}]="${functions[${func_name}]}"
    #FUXME: Getting a bit old, honestly. Just declare appropriate type testers
    #and exception handlers in @{*-test}. Sadly, this implies pretty much
    #shifting the *ENTIRETY* of @{var/type} into @{*-test} -- but it's
    #difficult to see an alternative. Repetition of the code below is simply
    #horrible, and nseds to cease sooner than later.

        #FUXME: Technically, such function name could contain double quotes. In
        #such case, we'll need to prefix such quotes by "\" to prevent errors
        #when throwing exceptions below. Define a new string local
        #${func_name_sanitized} here and then use such local in exception
        #messages below.
        #FUXME: Right; such function name could even contain command
        #substitutions (e.g., "$(...)"). So, we'll need to prefix all
        #characters with a special meaning in double quotes (e.g., "`", '"',
        #"$") *NOT* already prefixed by "\" by "\". We seem to recall already
        #implementing such functionality somewhere. Hmm... Oh, yes; doesn't
        #either "(qq)" or "(qqq)" achieve the desired effect?

#$'\n\n"'${(qq)ZESHY_DECLARE_FUNC_PROTOTYPE__}.
# ${func_name} prototype: ${ZESHY_DECLARE_FUNC_PROTOTYPE__}"$'\n\n'
    # [[ "${(t)ZESHY_DECLARE_FUNC_NAMES__-}" == "array"* ]] || :die\
    #     ''List ${ZESHY_DECLARE_FUNC_NAMES__} undefined or not a list (e.g., as :func_() not previously called).''

    # [[ "${(t)ZESHY_DECLARE_FUNC_ATTRS__-}" == 'association'* ]] || :die\
    #     'Map ${ZESHY_DECLARE_FUNC_ATTRS__} undefined or not a map.'
    # [[ "${(t)ZESHY_DECLARE_FUNC_NAMES__-}" == 'array'* ]] || :die\
    #     'List ${ZESHY_DECLARE_FUNC_NAMES__} undefined or not a list.'

    # [[ "${(t)ZESHY_DECLARE_FUNC_PROTOTYPE__-}${(t)ZESHY_DECLARE_FUNC_ARGS__-}" == 'scalar'*'scalar'* ]] || :die\
    #     'Strings ${ZESHY_DECLARE_FUNC_PROTOTYPE__} and/or ${ZESHY_DECLARE_FUNC_ARGS__} undefined or not strings (e.g., as :func_() not previously called).'

    #FUXME: O.K.; this is *GREAT* for parsing merely argument lists, but fails
    #to account for argument channels. We only care about the "args = "
    #argument channel, for obvious reasons. So, if such string is prefixed by
    #"[", we'll need to reparse the substring of such string following the "("
    #in "args = (" and preceding the corresponding ")" *BACK* into such string.
    #This sort-of implies we'll need to add a new PCRE string global to
    #@{*-pcre} to perform such matching. *sigh*
    #FUXME: Wait. *ACTUALLY*, why don't we just modify the existing PCRE string
    #global ${ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NAMES_ARGS_PCRE} to capture *ONLY*
    #the contents of the "args =" channel into such match group?  Indeed, using
    #"(?|...)"-style capturing, we should be able to ensure that such match
    #group contains the desired substring regardless of whether it was embedded
    #in a channel or not. Sweet, no?

 # the following indices of canonical list
        # global ${match}:
        #
        # * 1, such argument's mandatory type.
        # * 2, such argument type's optional eroteme (i.e., "?"), signifying
        #   that such function's definition should *NOT* be prefixed by a call
        #   to an exception handler throwing an exception if such argument
        #   violates the constraints of such type (e.g., a non-numeric string
        #   passed where an integer was expected). If unspecified, such
        #   definition is prefixed by such a call.
        # * 3, such argument's mandatory name.
        # * 4, such argument's optional eroteme (i.e., "?"), signifying such
        #   argument to be optional. If unspecified, such argument is mandatory.
        # * 5, such argument's optional default value.
        # * 6, such argument's optional ellipse (i.e., "..."), signifying such
        #   argument and hence function to be variadic.
#FUXME: Print nonfatal warnings for function prototypes containing two or more
#instances of the variadic specifier "...", as there typically exists no
#generally reliable means of differentiating which variadic list passed
#arguments belong to.

# initially validate the passed
    # argument list against the prototype constraints parsed above.
    # Redefine such function in terms of such prototype.
#     ::declare_func_redefinition
# 
# # :void ::declare_func_redefinition()
# function ::declare_func_redefinition() {
#     # Validate sanity.
#     (( # == 0 )) || :die 'Expected no arguments.'
# }

            # coerce the maximum argument count to a suitably small integer
            # effectively guaranteeing such count.
    # [[ "${(t)ZESHY_DECLARE_FUNC_PROTOTYPE__-}${(t)ZESHY_DECLARE_FUNC_ARGS__-}" == 'scalar'*'scalar'* ]] || :die\
    #     'Strings ${ZESHY_DECLARE_FUNC_PROTOTYPE__} and/or ${ZESHY_DECLARE_FUNC_ARGS__} undefined or not strings (e.g., as :func_() not previously called).'

#FUXME: Unfortunately, it's fairly evident we have an efficiency problem.
#Startup up time discernably scale linearly with function declarations, which
#isn't good. Ideally, such declarations should be negligible. We strongly
#suspect the culprits to be the gamut of eval() statements such declarations
#perform. So, one by one, we'll probably want to iteratively excise *ALL* such
#statements from both this and prior parcels -- and this function is a perfect
#place to start.

#FUXME: Document me. However, leave the comment below *HERE*.

# If ${ZESHY_DECLARE_FUNC_PROTOTYPE__} is undefined or of an unexpected type,
# throw an exception.  Since ::declare_func_prototype,attrs,names()
# subsequently validates both ${ZESHY_DECLARE_FUNC_ATTRS__} and
# ${ZESHY_DECLARE_FUNC_NAMES__}, avoid doing so here. See :var.die_unless_type_string()
# for further details.

# alias '}:func'='}
#     [[ "${(t)ZESHY_DECLARE_FUNC_PROTOTYPE__-}" == "scalar"* ]] || :die\
#         ''Variable ${ZESHY_DECLARE_FUNC_PROTOTYPE__} undefined or not a string (e.g., as :func_() not previously called).''
#     ::declare_func_prototype,attrs,names\
#         "${ZESHY_DECLARE_FUNC_PROTOTYPE__}"\
#            ZESHY_DECLARE_FUNC_ATTRS__\
#            ZESHY_DECLARE_FUNC_NAMES__'

# void ::declare_func_prototype,attrs,names[
#    args: (
#        string func_prototype,
#        string func_attrs_map_name,
#        string func_names_list_name),
#    stdin: string func_asciidoc]
# function ::declare_func_prototype,attrs,names() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one function prototype, one function attributes map name, and one function names list name.'
#     local\
#         func_prototype__dfwpban="${1}"\
#         func_attrs_map_name__dfwpban="${2}"\
#         func_names_list_name__dfwpban="${3}"
#     # print -r "${(@P)func_names_list_name__dfwpban}"
# 
#     # If any such variable is undefined or not of the expected type, throw an
#     # exception. See :var.die_unless_type_list() and :var.die_unless_type_map() for further
#     # details.
#     [[ "${(tP)func_attrs_map_name__dfwpban-}" == "association"* ]] || :die\
#         'Map ${'${func_attrs_map_name__dfwpban}'} undefined or not a map.'
#     [[ "${(tP)func_names_list_name__dfwpban-}" == "array"* ]] || :die\
#         'List ${'${func_names_list_name__dfwpban}'} undefined or not a list.'
# 
#     # For each such function...
#     eval '
#     local func_name__dfwpban
#     for   func_name__dfwpban ("${'${func_names_list_name__dfwpban}'[@]}") {
#         # If such prototype declared attributes, handle such attributes.
#         if (( ${#'${func_attrs_map_name__dfwpban}'} )) {
#             # If such attributes include "globbable," disable filename globbing
#             # for all arguments passed to such function by defining a simple
#             # alias of the same name shadowing such function. See
#             # is_list_contains() for further details.
#             #
#             # For safety (in the event of function names containing alias-
#             # reserved characters), call :define_alias_simple() rather than
#             # attempting to manually define such alias.
#             if (( ${'${func_attrs_map_name__dfwpban}'[(i)globbable]} <=\
#                  ${#'${func_attrs_map_name__dfwpban}'} )) {
#                 :define_alias_simple\
#                     "${func_name__dfwpban}" "noglob ${(q)func_name__dfwpban}"
#             }
#         }
# 
#         #FUXME: This is fairly lame. See @{*-alias} for commentary.
# 
#         # Add such function to the current parcel.
#         add_parcel_function "${ZESHY_PARCEL_NAME}" "${func_name__dfwpban}"
#     }'
# 
#     # Document such functions with such documentation *AFTER* successfully
#     # defining such functions above.
#     ::document_func_with_prototype,stdin_if_found_or_noop\
#         "${(@P)func_names_list_name__dfwpban}"\
#         "${func_prototype__dfwpban}"
# }

    #FUXME: Inefficient. Refactor to something resembling:
    #    { typeset -f -- "${@}" } :silent_stdout

    # # Documentation passed on standard input.
    # :set_string_to_stdin_help func_asciidoc__dfwpban

    # # Document such functions with such documentation.
    # ::document_func_with_prototype,asciidoc\
    #     "${(@P)func_names_list_name__dfwpban}"\
    #     "${func_prototype__dfwpban}"\
    #     "${func_asciidoc__dfwpban}"

#FUXME: Document me.
# void ::func_.stop()
# function ::func_.stop() {
#     # Validate sanity.
#     (( # == 0 )) || :die 'Expected no arguments.'
# }

    # Declare all functions parsed from the previously passed prototype.

    # If string global ${ZESHY_DECLARE_FUNC_PROTOTYPE__} (previously set by
    # :func_() to this function's prototype) is either *NOT* defined or
    # of the expected type, :func_() cannot have been previously
    # called; in such case, throw an exception. See :var.die_unless_type_string() for
    # further details.

#FUXME: O.K.; this is great, but there's a wee annoying flaw: syntax errors.
#They'll be reported as errors for a function named "::func", which isn't
#helpful in the least. Perhaps more importantly, they'll be largely unhelpful,
#as current syntax errors are. Fortunately, both are correctable by:
#
#* Embedding such definition in a :try{...}:catch{...}:catch block. Yes, this
#  *DOES* incur a slight performance penalty, but... *shrug* The demonstrable
#  gain in significantly more readable syntax errors than we currently receive
#  makes this an absolutely beneficial tradeoff.
#* Ah! Sweet. Great. So, the "catch" portion of that block will need to match
#  "${EXCEPTION}" against a glob matching only function definition errors.
#  Fortunately, that's *VERY* easy to match. How? Just check :redefine_func().
#  We already do it there.
#* So, we'll need to strip that glob out into a new string global -- say,
#  ${ZESHY_FUNC_ERROR_GLOB}.
#* If '"${EXCEPTION}" == ${~ZESHY_FUNC_ERROR_GLOB}', we'll need to:
#  * Catch such exception. Problem is, we haven't defined such functionality
#    yet! *Ugh.* On the bright side, such functionality *SHOULD* be fairly
#    simple to inline here. That said, do we *REALLY* want to walk that road?
#    We might need such catching elsewhere in @{*-declare}. In such case,
#    consider shifting such functionality to a new parcel here -- say,
#    @{15-catch}.
#  * Throw a new exception describing such error. Unfortunately, since the
#    function failed to be defined, we can't reuse the core of :redefine_func()
#    printing the function line of such syntax error. Well, shucks. We *COULD*
#    conceivably get around that by examining the current call stack and
#    manually parsing such file for such function definition. We'll probably
#    have to end up doing that. But it's a bit overkill for the moment. For
#    now, just replace the "::func" in such error message with the actual
#    function name and clean the message up a bit (e.g., capitalizing such
#    message), as :redefine_func() currently does. Nice!
#FUXME: Actually, while the above *WOULD* work, it's also rather inefficient. A
#substantially more efficient approach leverages a mechanism we technically
#don't yet support but readily could (and indeed *SHOULD*): TRAPZERR() hooks.
#We've intended to add them for some time, and now we have a demonstrable
#justification for doing so. Specifically:
#
#* In a new parcel here -- say, @{*-start/*-declare/15-trap} -- define:
#  * A new list global ${ZESHY_TRAP_ZERR_HOOKS}.
#  * A new function :add_trap_zerr_hook().
#* Modify the existing TRAPZERR() in @{main} to:
#  * Test whether list global ${ZESHY_TRAP_ZERR_HOOKS} exists *AFTER* storing
#    such exception.
#  * If such test succeeds, evaluate each item of such list.
#* Define a new function ::munge_...
#* Call :add_trap_zerr_hook here from the top-level, passing such function a
#FUXME: Wait. All of the above assumes we can actually obtain the error message
#from within TRAPZERR() -- which, of course, we can't. So, we *WILL* have wrap
#this in a :try{...}:catch{...}:catch block temporarily redirecting or
#capturing standard error. *Ugh*. As we will know, such capturing will probably
#prove obscenely impossible, particularly at this early stage. Hmm.
#FUXME: We see, now. The core issue is that we're defining such function with a
#temporary name. But if you consider it, we *DON'T* have to do that. Why?
#Because the following *ACTUALLY* works (...I know, right!):
#
#    >>> :string yim='simpo'
#    >>> function "${yim}" "yohimbo" () { print ok }
#    >>> simpo; yohimbo
#    ok
#    ok
#
#What this implies, in turn, is that we can significantly improve both the
#efficiency and error reporting of :func_() and cohorts. Specifically:
#
#* Define new map global ${ZESHY_DECLARE_FUNC_ATTRS__}.
#* Define new list global ${ZESHY_DECLARE_FUNC_NAMES__}.
#* Refactor :func_() to call:
#     :set_map,list_to_runnable_prototype_attrs,names\
#          ZESHY_DECLARE_FUNC_ATTRS__\
#          ZESHY_DECLARE_FUNC_NAMES__\
#          "${func_prototype}"
#* Redefine :func{() like so:
#    alias ':func{'='
#        [[ "${(tP)ZESHY_DECLARE_FUNC_NAMES__-}" == "array"* ]] || :die\
#            ''List ${ZESHY_DECLARE_FUNC_NAMES__} undefined or not a list (i.e., :func_() not previously called).''
#        (( ${#ZESHY_DECLARE_FUNC_NAMES__} )) || :die\
#            ''List ${ZESHY_DECLARE_FUNC_NAMES__} empty.''
#        function "${ZESHY_DECLARE_FUNC_NAMES__[@]}" () {'
#* Define new function ::declare_func_prototype,attrs,names().
#* Refactor both ::declare_func() and :declare_func() to internally call
#  ::declare_func_prototype,attrs,names(). Hence, ::declare_func() should
#  no longer call :declare_func() and :declare_func() should no longer call
#  :set_map,list_to_runnable_prototype_attrs,names().
#* Rename @{*-start/*-func/prototype} to @{*-start/*-func/func}.
#* Shift :declare_func() to @{*-start/*-func/func}. It's no longer required
#  here, but *IS* required elsewhere by early-time functionality.
#* Throw exceptions on attempting to redefine previously defined functions.
#  (Note we should be doing the same with aliases as well, which we believe we
#  currently no longer do.) Such exception should probably be thrown by
#  :func_() *BEFORE* the redefinition of such function even takes place.
#
#Awesome, no? Not terribly arduous. Note this implies we no longer need to
#redefine all functions twice -- which, while certainly nice, does imply we'll
#need to redefine all functions for reduction purposes during precompilation.

#FUXME: Ugh! Given the refactoring described above, this is somewhat nonsense.
#In particular, we needn't define such function here (since it's already
#defined, of course!) and hence needn't pass such body. I believe the remainder
#is still essential, however.
#FUXME: Indeed, this clearly implies both :define_func() and :redefine_func()
#should be shifted back to @{*-func/func}. *sigh*

    # If string global ${ZESHY_DECLARE_FUNC_PROTOTYPE__} (previously set by
    # :func_() to this function's prototype) is either *NOT* defined or
    # of the expected type, :func_() cannot have been previously
    # called; in such case, throw an exception. See :var.die_unless_type_string() for
    # further details.

    # [[ "${(t)ZESHY_DECLARE_FUNC_PROTOTYPE__-}${(t)ZESHY_DECLARE_FUNC_ATTRS-}${(t)ZESHY_DECLARE_FUNC_NAMES__-}" ==\
    #     'scalar'*'association'*'array'* ]] || :die\
    #     'Variables ${ZESHY_DECLARE_FUNC_PROTOTYPE__}, ${ZESHY_DECLARE_FUNC_ATTRS__}, and/or ${ZESHY_DECLARE_FUNC_NAMES__} undefined or not of the expected type (e.g., as :func_() not previously called).'

    # If function ::func() (previously defined by :func{() to this
    # function's body) is *NOT* defined, :func{() cannot have been
    # previously called; in such case, throw an exception. See
    # :func.die_unless() for further details.
    # (( ${+functions[::func]} )) || :die\
    #     'Function ::func() undefined (i.e., :func{() not previously called).'

    # Undefine such placeholder function, ensuring exceptions on subsequent
    # calls to this function *NOT* preceded by calls to :func{().
    # unfunction ::func

 # Probably the most interesting documentation to be included
#is the commentary below beginning:
#   "# Technically, doing so redefines such function at least twice:"
    # If function ::func() (previously defined by :func{() to this
    # function's body) is *NOT* defined, :func{() cannot have been
    # previously called; in such case, throw an exception. See
    # :func.die_unless() for further details.
    # (( ${+functions[::func]} )) || :die\
    #     'Function ::func() undefined (i.e., :func{() not previously called).'

    # Undefine such placeholder function, ensuring exceptions on subsequent
    # calls to this function *NOT* preceded by calls to :func{().
    # unfunction ::func

 # *AFTER* successfully
    # defining such functions above
        #FUXME: Absurdly inefficient. Instead, this function should accept an
        #additional argument providing the name of a function to be called here
        #defining such function. Consider defining a function ::define_func().

        # print -r "func name: ${func_name__dfwpban}"
        # Define such function.
        # :define_func "${func_name__dfwpban}" "${func_body__dfwpban}"

    # Documentation passed on standard input.
    # :set_string_to_stdin_help func_asciidoc

    # # For each such function...
    # local func_name
    # for   func_name ("${func_names[@]}") {
    #     # Define such function.
    #     :define_func "${func_name}" "${func_body}"

    #     # If such prototype declared attributes, handle such attributes.
    #     if (( ${#func_attrs} )) {
    #         # If such attributes include "globbable," disable filename globbing
    #         # for all arguments passed to such function by defining a simple
    #         # alias of the same name shadowing such function. See
    #         # is_list_contains() for further details.
    #         #
    #         # For safety (in the event of function names containing alias-
    #         # reserved characters), call :define_alias_simple() rather than
    #         # attempting to manually define such alias.
    #         if (( ${func_attrs[(i)globbable]} <= ${#func_attrs} )) {
    #             :define_alias_simple\
    #                 "${func_name}" "noglob ${(q)func_name}"
    #         }
    #     }

    #     #FUXME: This is fairly lame. See @{*-alias} for commentary.

    #     # Add such function to the current parcel.
    #     add_parcel_function "${ZESHY_PARCEL_NAME}" "${func_name}"
    # }

        # # If such exception handler exists, defer to such handler.
        # if (( ${+functions[::die_with_func_error]} )) {
        #     ::die_with_func_error "${func}"
        # # Else, redefine such function again. Since the prior exception handler
        # # *SHOULD* always exist, this fallback will probably never see the
        # # light of day. Which is good, because the output is terrible.
        # } else {
        #     eval "${func}"
        # }

        #FUXME: O.K.; we'll need to shift such functionality here. This is
        #fairly important, as such functionality performs several nice safety
        #checks on our behalf (e.g., ensuring such function isn't currently
        #defined and such).

    # Such
    # correlation allows a raft of , including .

    #FUXME: Horrible. Refactor in terms of the following predefined setters:
    #
    #    :set_string_to_stdin_help()
    #    :set_string_to_help_prototype()
    #    :set_list_to_runnable_prototype_names()

    # [[ -n "${ZESHY_DECLARE_FUNC_PROTOTYPE__}" ]] || :die\
    #     'Function prototype empty.'
#FUXME: Given the previously defined documenters -- namely, :document_func(),
#we can (and *SHOULD*) now shift documentation back here from below.

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

#FUXME: Matching function prototypes is feasible with one or possibly more PCREs
#but *NOT* globs, due to the need to match arbitrarily many function names and
#argument specifiers. This is essential, since:
#
#* If AsciiDoc is installed, function prototypes should be dynamically marked up
#  with AsciiDoc-specific notation, which I believe even supports colors.
#* Else, function prototypes should be styled with conventional color styles.

#     # For each such name, define a setter setting a passed string variable to
#     # such documentation. To avoid quoting issues with reserved characters in
#     # such documentation, set such variable via a here-document.
#     local runnable_name
#     for   runnable_name ("${runnable_names[@]}") {
#         setter_name=":set_string_to_"${runnable_type}"_help:${runnable_name}"
#         functions[${setter_name}]='
#     die_unless_arg "Expected one string name."
#     set_string_to_stdin "${1}" <<''/---''
# '${runnable_help}'
# /---'
#     }

# function ::define_func_setting_string_to_string() {
# function ::document_operable() {
# function ::document_operable_type_names_with_help() {

#FUXME: Hmm. Probably just forego this function, yes? Inline it above.

    #FUXME: O.K.; we need a function here parsing all prototype names from such
    #documentation. Ugh.

#FUXME: Documentation functions should continue working after zeshy startup. To
#make this work, we'll need to redefine them in a precompile_zeshy_() function
#to ensure that the digest file contains the redefinition. Honestly, I'm not
#entirely convinced we want to serialize such documentation to disk; of course,
#we *DO*. But that invokes a few not-so-subtle issues. For now, just retain
#documentation in memory until it becomes a demonstrable problem.
#FUXME: After having performed a great deal of online research, "gzip" appears
#to be the canonical go-to for small text file compression.
#FUXME: Hmmmm. No. Scratch that. We really need a filesystem-based approach.
#O.K.; so, here's the idea:
#
#* Shift the definitions of set_alias_documentation(), etc. to this component,
#  replacing all current calls to such functions with hard-coded additions to
#  such map globals. *DO IT.* Trust me. This is needed to ensure that such
#  functions are compiled into Zeshy's digest file.
#* *DON'T* redefine declare_alias(), declare_function(), or declare_global().
#  Instead redefine set_alias_documentation(), etc. to write to disk rather to
#  such map globals in the precompile_zeshy_*() function defined below, thus
#  ensuring the redefinition of such functions is compiled into Zeshy's digest.
#
#Bam. Nice one, eh?

#FUXME: Rename the ${ZESHY_HELP_GLOBALS}, etc. globals to
#${ZESHY_CORE_HELP_GLOBALS}, etc. Such globals, *DISTINCT* from the above, now
#apply *ONLY* to top-level components (e.g., src/{main,compile,...}). For
#efficiency (and simplicity), retain the current approach of simply appending to
#such lists. Then during zeshy precompilation (as implemented by
#"always/zsh/help/precompile"), simply iterate over each such list and for each
#help string simply call declare_global(), etc. Ultra-simple and efficient.
#After doing so, all documentation resides in the
#${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals as desired.

#FUXME: We'll probably need to generalize out function prototype parsing into a
#new setter function, to be called by both :declare_function() and
#:declare_function_if_pathable().

#FUXME: Rename to :set_list_and_map_to_runnable_prototype_name_or_names().
#This function *WILL* be generalized to support parsing of global name synonyms,
#as well.
#FUXME: Actually call such function above *AND* in declare_alias().
#FUXME: Actually document such function.
    #FUXME: Abstract retrieval of runnable names to a helper function for reuse
    #under aliases.

#FUXME: Rename to ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}. Now that we're
#eliminating ${ZESHY_FUNCTION_NAME_TO_HELP}, such map had might as well include
#all declared function names.

# Map all names (including the first) for functions with multiple names to the
# first names declared for such functions.
# See ${ZESHY_PARCEL_NAME_TO_HELP} for further details.

#    # List of function names matched from such string.
#    local -a function_names__df
#
#    # Current function name iterated in such list.
#    local function_name__df
#
#    # If such function only has one name, match such name.
#    function_name__df="${help_match__df[2]-}"
#    if [[ -n "${function_name__df}" ]] {
#        function_names__df=( "${function_name__df}" )
#
#        # If such function has already been declared, print a warning.
#        if (( ${+ZESHY_FUNCTION_NAME_TO_HELP[${function_name__df}]} )) {
#            print "zeshy: function ${function_name__df}() in parcel @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
#        }
#    # Else, such function has multiple names. Since single- and double-quoted
#    # function names may contain commas, such names cannot be split on commas as
#    # with function attributes above. Rather, match such names with iteration.
#    } else {
#        # Prepare to match such names.
#        pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_NAME_NEXT_PCRE}"
#        pcre_study
#
#        # Match such names, recording each to be a synonym of the first such
#        # name matched above. See for_string_text_matching_pcre:() for further details.
#        local ZPCRE_OP='0 0'
#        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match__df[3]}" } {
#            function_name__df="${match[1]}"
#            function_names__df+="${function_name__df}"
#            ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST[${function_name__df}]="${function_names__df[1]}"
#
#            # If such function has already been declared, print a warning.
#            if (( ${+ZESHY_FUNCTION_NAME_TO_HELP[${function_name__df}]} )) {
#                print "zeshy: function ${function_name__df}() in parcel @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
#            }
#        }
#    }

#   for ((match_index=1; match_index <= ${#names}; ++match_index)) {
#       print "name ${match_index}: ${names[${match_index}]}"
#   }

#`zsh` already provides intuitive syntax for defining functions (even those
#with names containing shell-reserved characters), this function is largely
#useful only for defining functions dynamically: e.g.,

        # * "read -t 0", reading standard input only if such input is nonempty.
        #   See :is_stdin_readable_sans_blocking() for further details.
#   }" |& { read -t 0 && IFS='' read -r -d '' function_error__rf }
#    eval "function \"\${function_name__rf}\" () {
#    ${function_body__rf}
#}" || {
    # Technically, shifting this conditional into the prior block would slightly
    # improve efficiency -- while also r
#requires 
#The syntax for cross-referencing another `zeshy` entity depends on the type of
#such entity, typically in a human-readable manner corresponding to underlying
#`zsh` syntax.
#; such parcel names are the absolute path of the existing `zeshy` script
#declaring such parcel.
#
#paths (i.e., prefixed and internally delimited by
#the directory separator '/' and ). Since parcels
#are only abstractions, such paths need _not_ exist. Assuming the customary
#<<parcel.relations.1to1,one-to-one relationship>> between parcels and scripts,
#however, each parcel name is customarily the absolute path of the existing shell
#script declaring such parcel.

# See declare_function_with_stdin() for further details.
# instead rather than single- or double-
#quoted string function arguments 

#Parcel help strings are *pure-AsciiDoc*. Unlike alias, global, and function help
#strings, parcel help strings support no `zeshy`-specific prefixing declarations
#or prototypes. After all, given the abstract nature of parcels, what _exactly_
#would be declared or prototyped?
#FUXME: Add declare_component() and declare_component_with_stdin() functions.
#It bears considering how we'll actually associate components with aliases,
#functions, and globals, considering that zsh does not support nested data
#structures. I suppose we'll need to pack everything into a map. How about
#${ZESHY_COMPONENT_NAME_TO_ALIAS_NAME} (and so forth for globals and functions),
#with structure resembling:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'declare' 'declare_alias:declare_function:declare_global'
#  )
#
#Hence, values are ":"-delimited function names. For globals, this clearly
#suffices, as global names are sufficiently constrained. For aliases and
#functions, however, we'll need to support double-quoted strings. Just double-
#quoted, to make things *MOSTLY* simple. The only complexity there is
#remembering to quote-protect embedded '"' characters in alias and function
#names.
#FUXME: Wait. Component names *MUST* also include internal structure --
#subdirectories (i.e., parent components), in this case. The above should be:
#
#  ZESHY_COMPONENT_NAME_TO_FUNCTION_NAME=(
#      'always/00-startup/00-declare/declare'
#          'declare_alias:declare_function:declare_global'
#  )
#
#The reason why, of course, is that component names are only unique within such
#subdirectories.
#FUXME: Actually, avoid double-quoting strings containing colons. The far
#simpler solution is to prefix colons in alias and function names with "\". Such
#list is then splittable with a slightly more efficient PCRE matching colon
#separators with negative lookahead: e.g., "(?!\\):". Since there's no character
#alias and function names *CANNOT* contain, it's doubtful there's a more
#efficient approach. (Actually, I suppose we could try to find a UTF-8 character
#in the range 127 to 255 guaranteed... ah; forget it. Way too much bit hackery.)
#In any case, "(?!\\):" should certainly be efficient enough for *MOST* cases.
#FUXME: To minimize the number of characters that need to be escaped, why don't
#we just use null instead of colon? That then raises the obvious question: why
#don't we just stipulate that zeshy-specific alias and function names *CANNOT*
#contain nulls? To be fair, though, this single use probably doesn't warrant
#prohibiting nulls entirely. Just use a PCRE resembling "(?!\\)\0". (Yes, I've
#checked the PCRE documentation: a lone "\0" does indeed refer to binary zero.)
#Bam!

#FUXME: On calling declare_component(), we'll need to set a global caching the
#current component name (complete with subdirectories) -- say,
#${ZESHY_COMPONENT_NAME_CURRENT}. There's no need to persist such global after
#sourcing all zeshy components, so we should probably undefine it after that.

#FUXME: The above globals raise the obvious question: should we keep them in
#memory or serialize them to disk? For the most, I strongly suspect they're
#sufficiently small to impose no burden in memory. If this ever changes, we
#simply offload them to disk with a KVS-based implementation. Simple, no?

#* `zsh` global, prefix such name with `${` and suffix such name with `}` (e.g.,
#  `${ZESHY_FUNCTION_NAME_TO_DOCUMENTATION}`).
#* `zsh` alias or function, suffix such alias or function name with `()` (e.g.,
#  `declare_function()`). If both an alias _and_ function share such name, the
#  cross-reference refers only to the alias (in keeping with zsh behavior). For
#  genericity, this is generally preferable to the next two disambiguations.
#* `zsh` alias unambiguously (if a function of the same name also exists), prefix
#  such name with `alias:` and suffix such name with `()` (e.g., `alias:die()`).
#* `zsh` function unambiguously (if an alias of the same name also exists),
#  prefix such name with `function:` and suffix such name with `()` (e.g.,
#  `function:die()`).

#Cross-referencing by ambiguous suffix rather than unambiguous name induces a
#depth-first search for the first parcel name with such suffix of:
#
#. All `zeshy` overlays in the following order (thus giving official parcels
#  precedent over third-party parcels):
#.. `zeshy://`, the system-wide overlay of official parcels.
#.. `zeshy.user://`, the user-specific overlay of third-party parcels.
#. All overlay subdirectories in lexicographic order.
#
#of all overlays and subdirectories thereof for
#  the first parcel suffixed by a directory separator `/` followed by such
#  suffix, as discussed below. 
#
#starting with the system-wide `zeshy`
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#For convenience, parcels may also be cross-referenced by implicitly performing a
#depth-first search of all `zeshy` overlays starting with the system-wide `zeshy`
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#To cross-reference a parcel by implicitly searching all overlays for the
#first matching parcel, delimit such parcel's name (truncated as above) by `@{`
#and `}` (e.g., `@{/if_pathable/cataclysm}`). Omitting an explicit overlay label
#thus prompts `zeshy` to iteratively search every overlay for such parcel in the
#following order:
#
#. `zeshy`, thus giving highest precedent to core parcels bundled by default with
#  `zeshy`.
#. `party`.
#
#  of all `zeshy` overlays beginning at the system-
#  wide overlay `zeshy://` and proceeding to the user-specific overlay `zeshy.user://`)
#  then the system-wide `zeshy`
#
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#See convert_path_to_parcel() for further details on parcel names.
#
#For convenience, parcels may be cross-referenced either by explicitly declaring
#such parcel's name or implicitly searching all overlays for the
#first matching parcel. In either case, parcel names should omit the absolute
#path of the overlay containing such parcel (e.g., for the parcel declared by the
#script with absolute path `/usr/share/zeshy/always/variable/type`, reference
#such parcel as `/always/variable/type` rather than the full absolute path).
#
#===== By Explicit Declaration =====
#
#To cross-reference a parcel by explicitly declaring the overlay containing such
#parcel, delimit such parcel's name (truncated as above) by either:
#
#To cross-reference a documented parcel, delimit such parcel's name by `@{` and
#`}`. Assuming such parcel to have been declared by declare_parcel_as_script()
#(as is always the case for all official `zeshy` parcels), the name of such
#parcel is the absolute path of the corresponding `zeshy` script with the overlay
#directory name prefixing such path replaced with `zeshy://` for official scripts
#and `zeshy.user://` for third-party scripts (e.g.,
#`@{zeshy://always/zeshy/zeshy}` cross-refences the parcel declared by script
#`/usr/share/zeshy/always/zeshy/zeshy`).
#
#To obtain the parcel name for any script, simply pass the path of such script to
#convert_path_to_parcel(); the output is the corresponding parcel name.
#
#===== By Implicit Searching =====
#
#For convenience, parcels may also be cross-referenced by implicitly performing a
#depth-first search of all `zeshy` overlays starting with the system-wide `zeshy`
#overlay and all subdirectories of such overlays in lexicographic order for the
#first parcel name suffixed by the specified string.
#
#To cross-reference a parcel by implicitly searching all overlays for the
#first matching parcel, delimit such parcel's name (truncated as above) by `@{`
#and `}` (e.g., `@{/if_pathable/cataclysm}`). Omitting an explicit overlay label
#thus prompts `zeshy` to iteratively search every overlay for such parcel in the
#following order:
#
#. `zeshy`, thus giving highest precedent to core parcels bundled by default with
#  `zeshy`.
#. `party`.
#
#
##=== Cross-referencing Parcels ===
##
##Due to the context-dependent nature of parcel names, cross-referencing parcels
#entails somewhat more effort than cross-referencing aliases, functions, and
#globals. While alias, function, and global names are necessarily unique in their
#respective namespaces and hence unambiguously cross-referenceable, parcel names
#are unique only in their ``full'' form as system- and user-specific absolute
#paths -- and hence _not_ unambiguously cross-referenceable cross-system or
#-user. Which is slightly bad.
#
#To rectify this, note that all `zeshy` scripts and hence parcels reside under
#one of two root *overlays* (i.e., top-level directories
#
#* The system-wide overlay (e.g., `/usr/share/zeshy`). Such scripts are bundled
#  by default with all `zeshy` installations and hence form the portable core of
#  `zeshy` guaranteed to exist wherever `zeshy` exists.
#* The user-specific overlay (e.g., `/home/leycec/.zeshy/overlay`). Such scripts
#  are _not_ bundled by default with `zeshy` and hence constitute non-portable
#  (if exceptionally neato) third-party addons, extensions, plugins, and so on.
#
#Since the absolute paths of such overlays are necessarily system- and user-
#specific, `zeshy` currently recognizes only the following system- and user-
#agnostic labels:
#
#* `zeshy`, for parcels residing in the system-wide overlay.
#* `party`, for parcels residing in the user-specific overlay.
#
#To rectify this, `zeshy` assigns each *overlay* (i.e., top-level directory
#containing `zeshy` scripts to be compiled into `zeshy`\'s user digest file) a
#path-agnostically human-readable label. Since all cross-referencable `zeshy`
#scripts reside in exactly one overlay (ignoring hard and soft link shenanigans),
#the replacement of the absolute path of the overlay containing a parcel in such
#parcel's name with the corresponding label
#the combination of such a label _and_ the fragment of a parcel's name following
#the absolute path of the overlay containing such parcel uniquely identifies such
#parcel cross-system and -user.
#
#==== Overlay Labels ====
#
#All `zeshy` scripts and hence parcels reside in one of two overlays:
#
#* The system-wide overlay (e.g., `/usr/share/zeshy`). Such scripts are bundled
#  by default with all `zeshy` installations and hence form the portable core of
#  `zeshy` guaranteed to exist wherever `zeshy` exists.
#* The user-specific overlay (e.g., `/home/leycec/.zeshy/overlay`). Such scripts
#  are _not_ bundled by default with `zeshy` and hence constitute non-portable
#  (if exceptionally neato) third-party addons, extensions, plugins, and so on.
#
#Since the absolute paths of such overlays are necessarily system- and user-
#specific, `zeshy` currently recognizes only the following system- and user-
#agnostic labels:
#
#* `zeshy`, for parcels residing in the system-wide overlay.
#* `party`, for parcels residing in the user-specific overlay.
#
#==== Parcel Cross-reference Syntax ====
#
#For convenience, parcels may be cross-referenced either by explicitly declaring
#the overlay containing such parcel or implicitly searching all overlays for the
#first matching parcel. In either case, parcel names should omit the absolute
#path of the overlay containing such parcel (e.g., for the parcel declared by the
#script with absolute path `/usr/share/zeshy/always/variable/type`, reference
#such parcel as `/always/variable/type` rather than the full absolute path).
#
#===== By Explicit Declaration =====
#
#To cross-reference a parcel by explicitly declaring the overlay containing such
#parcel, delimit such parcel's name (truncated as above) by either:
#
#* `@zeshy{` and `}`, for parcels residing in the system-wide overlay (e.g.,
#  `@zeshy{/always/variable/type}`).
#* `@party{` and `}`, for parcels residing in the user-specific overlay (e.g.,
#  `@party{/if_pathable/sushi}`).
#
#===== By Implicit Searching =====
#
#To cross-reference a parcel by implicitly searching all overlays for the
#first matching parcel, delimit such parcel's name (truncated as above) by `@{`
#and `}` (e.g., `@{/if_pathable/cataclysm}`). Omitting an explicit overlay label
#thus prompts `zeshy` to iteratively search every overlay for such parcel in the
#following order:
#
#. `zeshy`, thus giving highest precedent to core parcels bundled by default with
#  `zeshy`.
#. `party`.
#
#
##Set the documentation for the function named by the function prototype prefixing
#the passed string to such string. 
#FUXME: As expected, '/---' is a fairly
#ridiculous heredoc delimiter. I'd like to transition to something either
#Pythonic or zshish: namely, either: "'''" (i.e., three single quotes) or
#"```". O.K.; so, "'''" and variants thereof (e.g., "''''") doesn't work, as
#AsciiDoc already arrogates such string to itself. "```", however, is
#particularly zshish and *NOT* already arrogated by AsciiDoc. Sadly, however,
#vim refuses to syntax highlight it. O.K.; bloody hell. It's astonishingly
#difficult to invent a delimiter satisfying readability, vim parsability, and
#non-AsciiDoc parsability. How about either '-"-' or '_"_'? Actually, those
#still require a bit too much typing (and are awkward to type on most
#keyboards). How about simply "-=-"? Ah, hell. I really like '-"-'! So, there it
#is. Globally replace heredoc delimiters with '-"-', as above. Hmm; O.K., the
#typability constraint is rather important. I'd rather not have to rely on vim
#registers, again. So, perhaps '-=-', yes? It's hardly inspiring, but suffices.
#Nice, I actually like having "/" in there for vertical emphasis. That leaves us
#with "/---", which is also free in AsciiDoc. What say you? I like it. It hits all
#the right boxes: readily typeable (at least on Dvorak and Kinesis), non-
#conflicting with AsciiDoc, parsed by vim, and moderately zsh-ish. (Moderately.)
#It even moderately resembles the upper half of a face: e.g.,
#   /---  /---
#    o    -
#...which could have iconography implications later. Say:
#
#      /--- /---
#      z=esh=y
#
#      /---
# zeshy = zsh
#
#O.K., they're hardly impressive. Well, to be pondered in any case! Right. Don't
#bother trying to connect "/---" into an icon. This, however, could prove useful:
#
#   z sh
#   | ||
#   zeshy

#FUXME: Not terribly fond of the noun "component", to be honest. It's rather
#lengthy. Conceivable alternatives:
#
#* "bundle". Decent, but I rather prefer "parcel".
#* "container". Non-ideal. Containers are lists and maps.
#* "capsule". Nice!
#* "parcel". Nice!
#* "package". Non-ideal. Packages are a larger-scale abstraction.
#* "unit". Possibly nice? A bit too terse and ambiguous, perhaps.
#
#Right. "parcel" really strikes me as the ideal candidate, at the moment. Shall
#we run with it?
#'@' followed by the label of such
#
#either:
#
##FUXME: Not quite right. Let's use such syntax to incrementally search in the
##following overlays (in order) for such parcel: `zeshy`, `user`.
#* `@{` and `}`, for parcels residing in the system-wide `zeshy` overlay and
#  hence bundled by default with all `zeshy` installations (e.g.,
#  `/usr/share/zeshy`).
#
#* `@${overlay_name}{` and `}`, for parcels residing in the named overlay. For
#  portability, only the following overlay names are currently recognized:
#** `zeshy`, if such parcel resides in the system-wide `zeshy` overlay (e.g.,
#   `/usr/share/zeshy`).
#** `home`, if such parcel resides in the user-specific `zeshy` overlay (e.g.,
#   `/home/leycec/.zeshy/overlay`).
#
#For example:
#
#, a human-readable 
#different overlay from
#  the current parcel, where `${overlay_name}` is either:
#
#same overlay as the current parcel.
#
#While alias, function, and global names are necessarily unique in their
#respective namespaces and hence unambiguously cross-referenceable, parcel names
#are unique only in their "full" form as system- and user-specific absolute
#paths -- and hence _not_ unambiguously cross-referenceable cross-system.
#Fortunately, rectifying this is simple: 
#
#To cross-reference a documented parcel, delimit such parcel's name -- omitting
#the absolute path of the overlay root containing the parcel -- by `@{` and `}`.
#
#Hence,
#parcel names should 
#
#`zeshy` rectifies this by .
#Consequently, 
#
#either:
#
#* As an absolute path relative to and hence omitting the system-specific
#  directory of the overlay root (e.g., `@{/always/variable/type}`, rather than
#  `@{/usr/share/zeshy/always/variable/type}`). Since 
##** `path`, to reference such parcel with a system- and user-specific path
##   despite  (e.g.,
#   `/home/leycec/.zeshy/overlay`).
#Declare the passed `zeshy` script (defaulting to the currently sourced script)
#to be a new parcel, documented with standard input. Consider calling this rather
#than declare_parcel_as_script(), which requires passing an AsciiDoc-incompatible
#string argument rather than AsciiDoc-compatible standard input. See
#declare_function_with_stdin() for further details.

#Since 
#Calling this function is generally preferable to
#calling declare_parcel_as_script(), which requires passing an AsciiDoc-incompatible
#string argument rather than AsciiDoc-compatible standard input. 
#At the moment, this means: *``parcels structure `zeshy` documentation.''* And
#that's it. At such time as `zsh` adds native support for declaring package-
#like abstractions, however, this could conceivably change.

#parcels will (of course) cleanly extended with such support.
# Thus, the necessity of a
#`zeshy`-specific abstraction allowing for such compilation.
#Record the passed parcel (defaulting to the current parcel) as containing the
#passed function.
#Add the passed alias to the passed parcel. Since parcels are only abstractions,
#``add'' in this case only means recording such parcel as containing such alias.
# share a one-to-one relationship with their owner scripts.
#Hence, a
#single script declares such parcel's
#name is the absolute path of
#such script. All other scripts in such passel refer to such parcel by such path.

#In this case,
#such parcel is declared by a single such script but defined
#one such script declares such parcel and 
#That is, for the single
#, there exists a corresponding parcel whose name is the
#absolute path of such script. 

#In this case, there
#typically exists 

#However, this is hardly the only possible type of relationship between parcels and scripts.
#, though _not_
#necessarily referring to extant files or directories.
    # Add each such function to the current parcel. For efficiency, inline such
    # iteration. See add_parcel_alias() for further details.
#   for function_name__df ("${function_names__df[@]}") {
#       ZESHY_PARCEL_NAME_TO_FUNCTION_NAMES[${ZESHY_PARCEL_NAME}]+=$'\0'"${2//$'\0'/\\$'\0'}"
#   }

#Handle *parcel* (i.e., `zeshy`-specific abstractions containing aliases,
#parcels, and functions) declarers.
#FUXME: Actually call this in such functions.
#FUXME: So what should component documentation contain? It's fairly simple, I
#think: *ALL* component documentation should be AsciiDoc. We could support a
#prefixing prototype, but I fail to see how that's helpful. The current
#component name is perfectly inferrable from the current path -- no need to
#duplicate it unnecessarily. Great!
#FUXME: Rename to run_function_passed_stdin() or run_runnable_with_stdin().
#FUXME: A bit discontent with the current structure. Shift this and
#declare_function_with_stdin() to a new component "00-function". Rename this
#component to "declare", retaining all existing functions. Shift "define" and
#"document" here. Last, shift declare_function*() documentation to
#"00-function". I know, I know. But it's worth it.
#FUXME: O.K.; the above is essentially correct. What we specifically want,
#however, are the following three subcomponents with the expected content:
#"00-function", "alias", and "global". Simple. Elegant. Go-go!

# Component "document" declares and documents all other pertinent globals (e.g.,
# ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}).
#FUXME: I submit we should define a syntax for embedding function attributes in
#function documentation and having declare_function() itself parse and handle
#such attributes. For the moment, I can only think of one such attribute:
#"globbable". Define such attribute like so:
#
#   <globbable> void happy_go_lucky()
#
#Dead simple, yes? What's great about this is that it formally associates the
#attribute with the function's documentation, which we can later highlight
#accordingly.
#       # Function prototype prefixing such help string.
#       string help_prototype

#       # If such string contains a blank line (i.e., "\n\n"), crudely match the
#       # substring preceding such line as the function prototype.
#       if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
#           help_prototype="${match[1]}"
#       # Else if such string contains a newline (i.e., "\n"), crudely match the
#       # substring preceding such newline as the function prototype.
#       } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
#       # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       die 'function help string invalid (see "print_help declare_function" for details):
#'"${help_prototype}"

                #FUXME: If such function name contains spaces or other awkward
                #characters, this is likely to fail -- probably silently!
                #Command-line experimentation suggests that creating such an
                #alias requires *EXTREME* quoting and quote-protection of such
                #quotes. Since this is fairly odd, it's conceivable it's a bug.
                #Here's what the horrid syntax looks like:
                #
                #  >>> alias \"hm\ mm\"="print ik"
                #  >>> "hm mm"
                #  ik
                #
                #So, both the prefixing and suffixing '"' as well as internal
                #whitespace have to be explicitly escaped. Certainly doable;
                #it's just... annoying! I suspect the "=" character also needs
                #be escaped. Anything else? *sigh*
                #FUXME: Given the complexity, we might want to define a function
                #accepting a desired alias name and expansion as two separate
                #parameters and defining such alias -- say, :define_alias_simple()?

    #FUXME: Leveraging the above regular expressions, parse function name
    #synonyms and attributes. See above for the algorithm.

    # Store such documentation for subsequent parsing.
#   ZESHY_HELP_GLOBAL+="${1}"

    #FUXME: This is incorrect, as it fails to declare globals if a local of the
    #same name exists. See :is_var_global() for a solution.
    #FUXME: If such global has been declared, we should probably print a
    #warning to standard error if its declared type differs from the
    #documentation-declared type. The implementation is a bit tedious,
    #however, requiring a new map ZESHY_GLOBAL_DECLARATOR_TO_TYPE
    #dynamically constructed from its converse for performing efficient
    #lookups. Clearly, not a priority for the moment.
    # If such global has not yet been declared, do so. See :is_var() for
    # further details.
#   [[ -n "${(P)global_name__dg+x}" ]] || {

#FUXME: Restore the ${ZESHY_FUNCTION_NAME_TO_HELP}, etc. globals back to this
#component. Use such globals rather than ${ZESHY_HELP_GLOBALS}, etc. in
#function implementations below.
#FUXME: Consequently, declare_function() should immediately parse the passed
#help string's function prototype for only the following bits of metadata:
#
#* The list of all function attributes.
#* The list of all function names.
#
#Given the latter, set ${ZESHY_FUNCTION_NAME_TO_HELP} with the *FIRST* such
#function name and set ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST} as
#discussed below from all such function names to the first such function name.
#
#Then, given the former, if such attributes contain "globbable", define one
#"noglob" alias for each function name. Awesomeness!
#FUXME: Honestly, I don't see why we shouldn't support the same syntax for
#aliases. Hence, both functions should call an underlying function passed the
#names of the maps to... Ah, wait. No, no. Aliases don't genuinely support
#synonyms. We could fake it, I suppose. But I'm unsure whether there's any
#value in that. For now, confine such parsing to functions.

#FUXME: How should function synonyms be handled? For proper HTML construction,
#the fact that one function is a synonym of another *REALLY* needs to be
#embedded in either this data structure or another. How about a map
#${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}? Given the following
#function declaration:
#
#  function func1 func2 func3() { ... }
#
#...we would populate such map as follows:
#
#  ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST=(
#      'func1' 'func1'
#      'func2' 'func1'
#      'func3' 'func1'
#  )
#
#Hence, given a function name, it's (largely) trivial and reasonably efficient
#to find all synonyms of such function. We arbitrarily choose the first function
#name to be the "source" to which all synonyms refer, including such function
#name itself. Note that functions with no synonyms should *NOT* be defined by
#such map. We could certainly admit that, but it serves no purpose and
#(potentially) squanders quite a bit of safe.
#   print "attrs: ${attrs[@]}"
#   print "names: ${names[@]}"
    #FUXME: Right. We don't actually need the list of names, due to our helpful
    #choice of global data structure. Instead, we only need to record the
    #*FIRST* function name in a string local.

        # Match the first such name, which by the definition of such PCRE is
        # guaranteed to exist. See for_string_text_matching_pcre:() for further details.
#       pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names_string}"
#       function_names+="${match[1]}"

        #FUXME: Rather than append to such list, do the following:
        #
        #* Set the above string local to the first match.
        #* For all subsequent matches, map from such match to such string local
        #  in global ${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST}.
        #
        #To do so simply (and efficiently!), do something resembling:
        #
        # This should be guaranteed to match and hence always return success.
#       while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${help_match[3]}" } {
#           names+="${match[1]}"
#       }

        # Such names as a raw string. Since iteration overwrites list global
        # ${match}, copy such string before overwriting it below.
#       local names_string="${help_match[3]}"

    #FUXME: We'll clearly need to convert a few of the locals below into globals
    #above. Let's cross that tepid bridge when we trip into it.

        #FUXME: Actually, only print the first line of such documentation. Also, use
        #a different color for such line; say, regular red or cyan?
        #FUXME: Actually, print as follows:
        #
        #* If such prototype contains a blank line (i.e., "\n\n\n"), print from the
        #  first line of such prototype up to the next line that comes first of
        #  either such blank line or 5. (This avoids inevitable problems with
        #  pathological documentation.)
        #* Else, print only the first line of such documentation. This is only an
        #  unlikely edge case, so it needn't be too fancy; pretty much everyone will
        #  follow zeshy precedent of a blank line, I reckon.

    #string pcre_return_type=${pcre_ident}
        #string pcre_function_name_list='\{\s*+([^}]*?)(?:'${pcre_comma}')?\}'
#FUXME: Actually, defer such definition to the same precompilation function
#iterating and serializing all documentation to disk. The reason? Simplicity,
#centralizing all function prototype parsing into a single function. Such
#parsing is rapidly becoming too complex to duplicate between multiple
#functions.
#FUXME: Function name synonyms should be implemented as symbolic links in the
#documentation directory. Consequently, no parsing of function name synonyms is
#desirable in declare_function() itself. In fact, we can reduce the current
#temporary maps ZESHY_ALIAS_NAME_TO_DOCUMENTATION and so on to corresponding
#lists ZESHY_USER_HELP_ALIASES and so on. Just append each passed
#documentation string as is to the desired list.
#FUXME: Define a new declare_function_glob() or
#declare_function_sans_filename_globbing() or
#declare_function_and_disable_filename_globbing(). Yes, the latter. While
#verbose, that's not necessarily a bad thing in this case, as such function
#dramatically alters function parsing. In any case, such function should
#define a new alias of the same name expanding as follows:
#
#    alias ${function_name}:catch"noglob ${function_name}"
#
#Test if such alias already exists before doing so, in which case throw an
#exception or perhaps merely print a warning. (Nah, exception!)

    #FUXME: Actually define set_string_with_stdin(). Simplicity incarnate.
    # Document such input. See set_string_with_stdin() for further details.
#Prefer globals
    # "${match[1]}" and "${match[2]}" to human-readable local variables to
    # avoid polluting the local shell environment any further. 
#FUXME: I'm unclear why this needs to be an alias. If we were declaring such
#variable locally, I could see it, but... yeah; I think I slightly erred in
#implementing this as an alias. Convert to a function and reap the rewards of
#simplicity.

# ....................{ SETTERS                            }....................
#function set_alias_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_CORE_HELP_ALIASES+="${1}"
#}

#function set_function_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_HELP_FUNCTION+="${1}"
#}

#function set_global_documentation() {
#    (( # == 1 )) || die 'expected one documentation string'
#    ZESHY_HELP_GLOBAL+="${1}"
#}

    # If such documentation is prefixed by an alias prototype, match the
    # relevant alias name from such prototype. While zsh permissively allows
    # alias name declarations to be quoted and hence contain arbitrary
    # characters as with functions, such aliases are not runnable: e.g.,
    #
    #   >>> alias "o w s"="print 'revolt is dead; long live revolt'"
    #   >>> o\ w\ s
    #   zsh: command not found: o w s
    #
    # For simplicity, use a similar glob expression as declare_function().
#   if [[ "${documentation}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'<']##)'<'* ]]
#   then ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${match[1]}]="${documentation}"
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation[1,40]}...\" not prefixed by an alias prototype"
#   fi

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
        # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi
#FUXME: declare_function() is arguably a bit more than mere documentation, now.
#Ditto for declare_global(). Perhaps we should contemplate a nomenclature
#change -- say, to prototype_function() or declare_function(). Yes, "declare"
#strikes me as the proper verb here. It applies to globals as well!
#FUXME: O.K., O.K. Stop the "<>" nonsense with aliases. It's useful for
#referencing aliases to distinguish them from functions but completely unuseful
#for prototyping aliases. Alias prototype syntax should be a proper subset of
#function prototype syntax. (Note this is really the only way to do the PEG, as
#well; can you imagine duplicating the bloody function PEG for aliases with only
#ignorable differences?)

#FUXME: Ensure this is performed in, say, "main":
#
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
# ....................{ DOCUMENTATION                      }....................
# Map from Zeshy-specific alias name to documentation for such alias.
#local -A ZESHY_ALIAS_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific function name to documentation for such function.
#local -A ZESHY_FUNCTION_NAME_TO_DOCUMENTATION

# Map from Zeshy-specific global name to documentation for such global.
#local -A ZESHY_GLOBAL_NAME_TO_DOCUMENTATION

# Avoid documenting the following three functions, subsequently undefined during
# Zeshy startup and hence inaccessible to callers.

# void set_alias_documentation(string alias_name, string documentation)
#
# Document the passed alias with the passed string.
#function set_alias_documentation() {
#    (( # == 2 )) || die 'expected one alias name and one help string'
#    ZESHY_ALIAS_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_function_documentation(string function_name, string documentation)
#
# Document the passed function with the passed string.
#function set_function_documentation() {
#    (( # == 2 )) || die 'expected one function name and one help string'
#    ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

# void set_global_documentation(string global_name, string documentation)
#
# Document the passed global with the passed string.
#function set_global_documentation() {
#    (( # == 2 )) || die 'expected one global name and one help string'
#    ZESHY_GLOBAL_NAME_TO_DOCUMENTATION[${1}]="${2}"
#}

    # If such documentation is prefixed by a function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "[^[:space:]]##", matching the function return type.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([^'(']##)", matching the function name into ${match[1]}.
    # * '(', matching the beginning of the function argument list.
#   if [[ "${documentation__df}" ==\
#       (#b)[[:space:]]#[^[:space:]]##[[:space:]]##([^'(']##)'('* ]]; then
#       # Attempt to split such function name on " [or] " delimiters.
#       local    function_name__df="${match[1]}"
#       local -a function_names__df
#       function_names__df=( "${(s: [or] :)function_name__df}" )

        # If such function name contains no such delimiters, document as is.
#       if (( ${#function_names__df} == 1 ))
#       then ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name__df}]="${documentation__df}"
        # Else, such function name contains at least one such delimiter.
        # Document each split function name with such documentation.
#       else
#           for function_name_split ("${function_names__df[@]}") {
#                   print "function name split: ${function_name_split}"
#               ZESHY_FUNCTION_NAME_TO_DOCUMENTATION[${function_name_split__df}]="${documentation__df}"
#           }
#       fi
#           print "function name: ${match[1]}"
    # Else, throw an exception with a portion of such documentation.
#   else die "help string \"${documentation__df[1,40]}...\" not prefixed by a function prototype"
#   fi

#names following the `(`- and `)`-bracketed argument list or `[`- and `]`-
#bracketed argument channel list signifies such function to be annotated by such

#declare_function_with_stdin <<'/---'
#void declare_function_with_stdin_and_disable_filename_globbing[
#    stdin: string documentation]
#
#Set the documentation for the function named by the function prototype prefixing
#standard input to such input and disable filename globbing on all arguments
#callers subsequently pass to such function. While the latter admittedly has
#little to do with function documentation, bundling the two together simplifies
#life. See declare_function_with_stdin() and
#disable_function_filename_globbing() for further details.
#/---

#FUXME: Actually, no one'll ever call this function. Rename to
#declare_function_with_stdin_and_disable_function_filename_globbing() and
#implement accordingly. Yes, this is an obscenely long function name. No, in
#this particular instance, I don't particularly care. There's no reasonable
#abbreviation permitting the function name and heredoc declaration to reside on
#the same line, so such function is called like so:
#
#    declare_function_with_stdin_and_disable_function_filename_globbing\
#        <<'/---'
#    ...
#    /---
#FUXME: Document declare_function_with_stdin() as well. In the documentation,
#note the reason for needing declare_function_with_stdin() to be the fact that
#both single- and double-quoted strings interface poorly with AsciiDoc syntax.
#Specifically, AsciiDoc's frequent use of:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.
#
#Fortunately, zsh supplies a third alternative: here-documents. Since zsh
#writes here-documents to standard input, this function expects non-empty
#standard input. See declare_function() for further details.

#While function documentation can be passed as a
#conventional string argument to declare_function() rather than as standard
#input to this function, such documentation adheres to 
#http://asciidoc.org[AsciiDoc] syntax containing syntactic constructs
#containing characters conflicting with
#conventional single- or double-quoted zsh strings:
#
#* Paired single quotes (e.g., ``the bastion'', an aesthetically double-
#  quoted string) conflicts with single-quoted escapes in single-quoted strings.
#* Paired backticks (e.g., `the stranger', a passthrough monospaced string)
#  conflicts with backtick-style process substitutions in double-quoted strings.

#Set the documentation for the globally exported variable named by the variable
#declaration prefixing the passed string to such string. Documentation consists
#of a variable declaration in Zeshy-specific C-like syntax and a variable
#description in http://asciidoc.org[AsciiDoc].
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.

#Set the documentation for the function named by the function prototype prefixing
#the passed string to such string. Documentation consists of a function prototype
#in Zeshy-specific C-like syntax and a function description in
#http://asciidoc.org[AsciiDoc].
#Function documentation consists of a function prototype and description
#delimited by mandatory whitespace. A function prototype consists of one or more
#return types, one or more function names, and zero or more function arguments;
#a function description consists of arbitrary http://asciidoc.org[AsciiDoc] with
#additional support for conveniently cross-referencing other Zeshy documentation.

#Alias documentation consists of an alias prototype and description delimited by
#mandatory whitespace. An alias prototype consists of one or more return types,
#one alias name, and zero or more arguments; an alias description consists of
#arbitrary http://asciidoc.org[AsciiDoc] with additional support for conveniently
#cross-referencing other Zeshy documentation.

#== Alias Prototypes ==
#
#Alias prototypes follow a C-like syntax supporting zsh features not commonly
#found in conventional high-level languages: return and argument channels. Since
#zsh does _not_ currently support alias prototypes, we cannot coerce zsh to
#respect or enforce such prototypes at runtime. Zeshy can, however, convert such
#prototypes to syntax-highlighted, contextually-linked specifications in end-
#consumer documentation.

#Since zsh expands aliases inline, aliases cannot accept arbitrary arguments not
#accepted by the command such alias expands to.

#FUXME: Obscenely out-of-date. Significantly expand, noting that the alias
#documentation PEG is effectively the proper subset of the function
#documentation PEG excluding function name synonyms and replacing "(" and ")"
#with "<" and ">".
#While all function implementations remain free to
#dynamically redefine their signatures and hence deviate from such static
#documentation, developers should question the cognitive cost of such functions!

#FUXME: There is one other matter, of course: standard input. And
#come to think, this is also a concern for function documentation as well.
#How do we document whether a function accepts standard input and, when it does
#so, where it places such input in relation to other accepted arguments if any?
#*UGH*. Super annoying that I neglected to account for stdin. *sigh*
#FUXME: O.K.; I think I have a working syntax. The idea is simple: zsh
#extensions to C-like function prototype syntax are "["- and "]"-delimited.
#Since herestring-driven aliases unpack stdin into customary arguments, we have
#an stdin argument syntax resembling:
#
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#
#What's nice is that, as a function, it would simply be written as:
#
#[stdout: float] ukigumo(string dirname, integer mtime)
#
#Simple, concise, and consistent. Excellent. The above syntax naturally extends
#to support standard input being assigned to only one argument, like so:
#
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Ugh. So, that works, but doesn't really coincide with above. How about:
#
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(stdin: string dirname, integer mtime)
#
#Right. That works. It's obviously tempting to reduce every "[" and "]" to a
#"(" and ")" at this point, but that reduces the resulting prototype to a
#slightly less readable mish-a-mash ala LISP (*shudder*):
#
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#Hmm. Is that *REALLY* less readable? Frankly, it seems *MORE* readable. Right.
#O.K.; so, in this instance only, contemplate LISP-ish syntax. I can't believe
#I'm muttering that, but... well, it is much easier to remember and hence to
#write, and reads quite well as well. So, there you are!
#
#Right. There's just one final thing: input pipes. Quite a few functions only
#expect piped standard input, not just any ol' standard input. So, we'll need to
#also support something resembling:
#
#(stdout: float) ukigumo(piped stdin: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(stdin-pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(pipe: string dirname, integer mtime)
#(stdout: float) ukigumo(piped: string dirname, integer mtime)
#
#The latter, I should think. "piped" implies "stdin" and more, so prefixing with
#or otherwise explicitly stating "stdin" is unnecessary. Well! That should do it,
#no? We'll need to slightly revise both the PEG and examples below, but better
#now that after we've begun using this syntax everywhere, eh? :}
#
#Ah, right: one final thing. The ":" implies mandatory and, in most cases, piped
#standard input is optional. How about a new "?" suffix for optional input, ala:
#
#(stdout: float) ukigumo(piped? string dirname, integer mtime)
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#
#BRILLIANT. Bravo, senior Cecil. Bravo.
#
#Note, however, that optional piped input is probably unhelpful and should
#arguably be eliminated from the Zeshy codebase. Hence, for now, just document
#the "stdin:"-style syntax.
#FUXME: O.K.; so, the above syntax isn't *QUITE* right. Since we're *NEVER*
#passing in standard input as an optional argument, any standard input passed is
#always as a second "channel" completely outside the scope of sanity.
#Also note that *_from()-style aliases *APPEAR* to the caller to accept a single
#string rather than standard input, suggesting an additional "string:" channel.
#Revert to "["-style syntax, for clarity. This suggests the following syntax:
#
#    # A function accepting a string *AND* standard input.
#    [stdout: void] set_string_to_stdin_pipe[
#       args: string string_name, stdin: string input]
#
#    # A function accepting one or more integers on standard input.
#    [stdout: string] get_stdin_integers[
#       args: void, stdin: (integer int1, ...)]
#
#    # Equivalent to the prior prototype.
#    [stdout: string] get_stdin_integers[stdin: (integer int1, ...)]
#
#    # A herestring-style alias.
#    [stdout: float] ukigumo[string: (string dirname, integer mtime)]
#
#So, the fundamental idea is that "args:" and "stdin:" both default to "void",
#as for return types. Either or neither may be specified, with predictable
#consequences in any case. Beautiful, no? (Well, certainly *LOGICAL*!)

#Tester functions returning only boolean exit status and no standard output or
#error may thus map return types `[status: boolean]` (e.g.,
#`[status: boolean] is_dir_too_terrible_to_behold(string dirname)`).

#Being unprototyped, zsh function argument order and type is not
#statically predefined at function declaration time but may conditionally
#dynamically depend on local, global, and/or external state. For example,
#While perfectly documenting all possible function argument dynamics is both unfeasible and undesirable,
#conditionally depend and hence arguably more involved
#(though not necessarily beneficially) than those of conventional high-level languages.

#Documenting all possible function prototype dynamics is both unfeasible and
#undesirable. For sanity, function documentation assumes function signatures to
#be statically predefined at function declaration time as in normal high-level languages. Function implementations remain
#free to dynamically redefine and hence stray from such documentation as
#necessary, although this is generally discouraged.

#For brevity, functions may specify a single return type as in conventional
#high-level languages (e.g., `integer`).
# Zeshy documents such values in one of two ways:
#With a single type as in conventional high-level languages (e.g., `integer`),
#signifying such function to return a string of standard output convertible
#without error to such type, an empty string of standard error, and zero exit
#status (i.e., success). Since most functions only write to standard output and
#throw exceptions rather than return non-zero exit status on error, this
#shorthand notation simplifies most functions'' documentation.

#| Digit                 | <- | ``0'' | DigitNonZero
#| DigitNonZero          | <- | ``1'' | ``2'' | ``3'' | ``4'' | ``5'' | ``6'' |
#                               ``7'' | ``8'' | ``9''
#| Integer               | <- | ``-''? (``0'' | DigitNonZero Digit*)

#FUXME: I've performed an obscene amount of research on lightweight
#documentation formats and the winner *HANDS DOWN* is AsciiDoc. The syntax
#absolutely rocks, is near infinitely extendable with "pluginname:string"-style
#syntax and third-party plugins, exports beautiful HTML, LaTeX, PDF, man pages,
#DocBook, and so on. All Git documentation is written in AsciiDoc (which should
#absolutely tell you something: this is Linus' Git, after all). Markdown and
#Textile are rather outdated at this point. The only genuine competitor is the
#official Python documentation language, RestructuredText (reST). I'll admit:
#reST is powerful. Probably nearly as or even slightly more powerful than
#AsciiDoc. But in the end, that doesn't really matter... because the syntax is
#absolute shite. I mean, *LOOK AT THAT SYNTAX*. What the bloody hell were they
#thinking? They could have simply adopted the de facto e-mail-style markup
#syntax from which AsciiDoc (and Markdown and Textile and pretty much every
#other lightweight documentation language) is descended. But *NO*, they had to
#reinvent the friggin' wheel. And they failed. They thoroughly failed. Thank the
#Nordic Gods, then, for AsciiDoc.

#[stdout: float] ukigumo(stdin -> [string dirname, integer mtime])
#(stdout: float) ukigumo(stdin: (string dirname, integer mtime))
#[stdout: float] ukigumo(stdin: [string dirname, integer mtime])
#[stdout: float] ukigumo(string dirname, integer mtime) <- stdin
#[stdout: float] ukigumo[stdin: (string dirname, integer mtime)]
#[stdout: float] ukigumo(stdin -> string dirname, integer mtime)

#FUXME: set_function_documentation() will need to detect whether passed standard
#input and, if so, ... Hmm. Actually, we should probably just do so in the high-
#level functions themselves (e.g., declare_function()). That necessitates
#pushing such documentation to the end of this file, but... *shrug*. That's
#fine, and arguably even preferred here (since it centralizes all documentation
#in one place). Arguably, we should then provide distinct high-level functions
#entitled declare_function_from_stdin() and so forth. The issue with
#trying to make a single "smart" declare_function() implicitly detecting open
#standard input is that such functions will be called from the top-level during
#Zeshy startup and hence cannot distinguish external from internal standard
#input. Subvert such confusion with distinct functions only accepting standard
#input.

#set_alias_documentation declare_global '
#void declare_global<string documentation>
#
#If called when recompiling Zeshy''s user digest file, globally export the global
#prefixing the passed string with the Zeshy-specific type (e.g., "list", "float")
#prefixing the passed string *AND* document such global with such string; else,
#do nothing.
#'
#alias declare_global='
#{
#    # Localize the passed herestring.
#    local documentation__dg="$(< /dev/stdin)"
#...
#} <<<'

#Document the function named in the function prototype prefixing the passed
#documentation, which consists of a function prototype in C-like syntax
#followed by function description in AsciiDoc.
#
#whose syntax supports zsh features not commonly found in
#conventional high-level languages (e.g., function name synonyms, tristate return
#values). For completeness, we specify such syntax with a Parser Expression
#Grammar (PEG):
#
#Such types should correspond to the actual variable type (if
#any) the function implementation copies such argument into.
#
#values are *NEVER* evaluated by Zeshy and hence may contain executable code that
#could, whenever evaluated, have dangerous side-effects. 
#
#assigning each argument a
#mandatory name and type and optional default value.
#
#While argument names need
#not correspond to the variable name (if any) the function implementation copies
#such argument into, argument types and optional default value should, of course.
#
#(e.g., "function name synonym pseudonym nom_de_guerre nom_de_plume() { true }",
#a function callable as either name(), synonym(), pseudonym(), nom_de_guerre(),
#or nom_de_plume()).
#
#by listing all such names in whitespace-
#delimited fashion (e.g., .
#at least one name  also arbi:
#a
#Most function names as in conventional high-level languages (e.g., "integer"),
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#
#For functions with only one name, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#For functions with multiple names, call this function as follows:
#
#    declare_function ''
#    RETURN_TYPE FUNCTION_NAME_1 [or] FUNCTION_NAME_2 [or] ... FUNCTION_NAME_N(
#        ARG_TYPE_1 ARG_NAME_1 {= ARG_DEFAULT_VALUE_1},
#        ARG_TYPE_2 ARG_NAME_2 {= ARG_DEFAULT_VALUE_2}, ...)
#
#    HUMAN_READABLE_DOCUMENTATION
#    ''
#    function FUNCTION_NAME_1 FUNCTION_NAME_2 ... FUNCTION_NAME_N() {
#        FUNCTION_IMPLEMENTATION
#    }
#
#Capitalized strings above denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific variable type such function returns.
#  Technically, all zsh functions "return" three values (in the low-level sense):
#  a string of standard output, a string of standard error, and an exit status.
#  Practically, most zsh functions avoid writing to standard error and only .
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#  FUXME: Rewrite this section after implementing the above additions. It gets a
#  bit complicated, but... heck, it''ll definitely be worth it.
#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.
#* "FUNCTION_NAME_2", the second name for such function. While most functions have
#
#  As in C-like languages, type "void" signifies such function to return no
#  standard output and/or error.
#
#Function prototypes follow the familiar "RETURN_TYPE FUNCTION_NAME 
#
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#While zsh does not support function prototypes, this function
#adopts conventional high-level language function prototype syntax for documentation-specific purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#named by the C-style function prototype of the passed
#documentation string. Since zsh permits no function prototyping, this function
#adopts conventional high-level language function prototype syntax for documentation purposes.
#While Zeshy cannot enforce such prototype at runtime, it can at least convert such prototype into
#appropriately .
#the return type, argument types, or argument order of 
#at runtime, it can convert such prototype into 
#
#syntax does *NOT* constitute 
#While such syntax does *NOT* constitute an enforcable
#familiar C, C++, C#, Java, python etc. syntax for function prototypes for documentation purposes, which must follow one of the following formats:
#
#* 
#  "RETURN_TYPE FUNCTION_NAME ([or] FUNCTION_NAME_SYNONYM ...)
#
#, which must thus be prefixed  with such documentation. 
#
#This function is deleted by Zeshy immediately before compiling its user digest
#file and hence only callable from the global context of Zeshy components.

#FUXME: It'd be great to support a distinction between standard output and
#error return values in function prototypes. How about something resembling:
#
#    # Function returning a string of standard output and no standard error.
#    [string, void] do_something()
#
#    # Or perhaps the more verbose:
#    [stdout: string, stderr: void] do_something()
#
#    # Actually, we could support both (obviously), which we should do. Ah;
#    # actually, we should probably just add such "stdout:" and "stderr:"
#    # labels on printing human-readable documentation to users, yes? Ah;
#    # perhaps not. It'd certainly be more intelligible to developers browsing
#    # the code to see "[stdout: string, stderr: void]" versus the former.
#    # The more verbose version also lends itself well to specifying exit
#    # status, as below.
#
#Since most functions return no standard error, retain support for shorthand:
#
#    # Same as above, shorthand.
#    string do_something()
#
#While most functions return 0 exit status, some do not. How about this:
#
#    # Function returning a string of standard output and no standard error
#    # and non-zero exit status on failure.
#    [string, void, boolean] do_something()
#
#    # Or, again:
#    [stdout: string, stderr: void, status: boolean] do_something()
#
#Status may either be "void" (i.e., always returns 0), "boolean" (i.e.,
#either returns 0 or 1), or "integer" (i.e., returns a variety of statuses.
#
#Ah! Another way in which the labels are demonstrably superior: in may cases,
#we'll want to specify "stdout" and "status" but not "stderr". So, that's just:
#
#    [stdout: string, status: boolean] do_something()
#
#Naturally, order no longer matters. Sweet! I'm thinking we *ABSOLUTELY*
#shouldn't support the abbreviated "[stdout, void, boolean]" style, yes? Far too
#much ambiguity and head-scratching.
#FUXME: The specification below has become sufficiently complex to warrant a BNF.
#I know, I know. But we'll make it simple and concise, with adequate commenting.
#There's really no better way.

# ....................{ GLOBALS                            }....................
#FUXME: This is terrible. Eliminate such global entirely; instead, simply
#attempt to run a dynamically constructed command
#${variable_type}_global_export().

#set_global_documentation ZESHY_GLOBAL_TYPE_TO_DECLARATOR '
#map ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#
#Map variable type to the declarator (i.e., command prefix) declaring and
#exporting globals of such type.
#'
#typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR
#ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
#    # String types.
#    string    'export'
#    boolean   'export'
#    character 'export'

    # Integer types.
#    integer         'export -i'
#    file_descriptor 'export -i'
#
    # Float types.
#    float 'export -F'
#
#    # List types.
#    list     'export -a'
#    list_set 'export -Ua'
#
#    # While "export -a" succeeds (as above), "export -A" fails with error.
#    # Hence, revert to builtin typeset().
#    map 'typeset -Agx'
#)

        # If such global''s type is not a Zeshy-specific type, throw an
        # exception. See is_map_key() for implementation details.
#       (( ${+ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} )) ||
#           die "\"${match[1]}\" not a zeshy type"

        # Declare such global.
#       ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

# ....................{ MAIN                               }....................
#FUXME: Not quite right. We also want to undefine all of the above aliases and
#functions before Zeshy digest compilation, suggesting we create a new
#precompilation hook performing all such undefinitions. I can't imagine that
#order matters, there; so, just add a customary precompilation hook here.

#:run_hook_on_zeshy_precompile precompile_zeshy_documentation_undefine

#declare_function '
#void precompile_zeshy_documentation_undefine()
#
#Undefine all documentation-defining runnables (e.g., set_alias_documentation(),
#declare_global()) *AFTER* sourcing all Zeshy components calling such runnables
#and hence having defined all available documentation. To  Zeshy caches 
#The documentation such runnables
#'
#function precompile_zeshy_documentation_undefine() {
#    # Undefine lower-level documentators, hereafter replaced by the previously
#    # defined higher-level documentators. Do so here for code convenience rather
#    # than necessity.
#    unfunction\
#        set_alias_documentation\
#        set_function_documentation\
#        set_global_documentation
#}

#FUXME: Rename "[or]" to "[or]" everywhere. Avoid simply "or", as that isn't
#subject to global replacement.
# For simplicity, this function ignores 
# such low-level distinctions, accepts
# (e.g., "boolean", "list", "string"). If 
#
#While most functions have only one name, zsh does permit additional names to be
#declared in function declarations with the above whitespace-delimited syntax.
#
#Capitalized strings denote the following semantics:
#
#* "RETURN_TYPE", the Zeshy-specific type of variable returned by such function
#  (e.g., "boolean", "list", "string").
#* "FUNCTION_NAME_1", the first name for such function. While most functions have
#  only one name, zsh permits additional names to be declared in a function
#  declaration with the above whitespace-delimited syntax.

# *BEFORE* compiling Zeshy''s user digest file
# (i.e., at the top level of Zeshy components and in precompilation hooks).
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #FUXME: *THIS IS ABSURD*. It's currently working, yes. But there's no
    #reason to perform such heavy-weight functionality here. Shift *ALL* such
    #documentation functionality to "always/00-setup/00-document/document".
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Define declare_function() before declare_alias(), which documents itself
# with the former function.
# For efficiency when not recompiling Zeshy's user digest file, default such
# runnables to noop. When recompiling such file, redefine such runnables to
# actually document the passed object.
#alias declare_alias=':' declare_function=':' declare_global=':'

# Define aliases subsequently expanded by Zeshy's user configuration files,
# defined here rather than in "config" to avoid excessive global variables.
# (Namely, a new global boolean ${ZESHY_USER_DIGEST_FILE_IS_OUTDATED} would be
# required for tracking such state.)
