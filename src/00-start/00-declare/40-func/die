#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *function declarer exception handlers* (i.e., functions throwing
exceptions resulting from validation errors in declared functions).
/---

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

# ....................{ EXCEPTIONS ~ prototype             }....................
#FIXME: Document me.
# :void ::die_of_func_prototype(:string exception_message)
function ::die_of_func_prototype() {
    (( # == 1 )) || :die 'Expected one exception message.'
    :die 'Function '${ZESHY_DECLARE_FUNC_NAMES__[1]}'()'$(::get_parcel_preposition)' '${1}$':\n\n'${ZESHY_DECLARE_FUNC_PROTOTYPE__}
}

# ....................{ EXCEPTIONS ~ arg count             }....................
#FIXME: Document me.
# :void ::func.die_of_arg_count_not_equaling(
#     :string func_arg1?, ...,
#     :int_nonnegative func_arg_count_actual,
#     :int_nonnegative func_arg_count_expected)
function ::func.die_of_arg_count_not_equaling() {
    (( # >= 2 )) || :die\
        'Expected one or more arguments, one actual argument count, and one expected argument count.'
    ::func.die_of_arg_count "${@[1,-3]}"\
        "${@[-1]} arguments but received ${@[-2]}"
}

#FIXME: Document me.
# :void ::func.die_of_arg_count_not_exceeding(
#     :string func_arg1?, ...,
#     :int_nonnegative func_arg_count_actual,
#     :int_nonnegative func_arg_count_min)
function ::func.die_of_arg_count_not_exceeding() {
    (( # >= 2 )) || :die\
        'Expected one or more arguments, one actual argument count, and one minimum argument count.'
    ::func.die_of_arg_count "${@[1,-3]}"\
        "at least ${@[-1]} arguments but received only ${@[-2]}"
}

#FIXME: Document me.
# :void ::func.die_of_arg_count_not_ranging(
#     :string func_arg1?, ...,
#     :int_nonnegative func_arg_count_actual,
#     :int_nonnegative func_arg_count_min,
#     :int_nonnegative func_arg_count_max,)
function ::func.die_of_arg_count_not_ranging() {
    (( # >= 3 )) || :die\
        'Expected one or more arguments, one actual argument count, one minimum argument count, and one maximum argument count.'
    ::func.die_of_arg_count "${@[1,-4]}"\
        "between ${@[-2]} and ${@[-1]} arguments but received ${@[-3]}"
}

#FIXME: Document me.
# :void ::func.die_of_arg_count(
#     :string func_arg1?, ...,
#     :string exception_message)
function ::func.die_of_arg_count() {
    # Validate sanity.
    (( # >= 1 )) || :die\
        'Expected zero or more arguments and one exception message.'
    local exception_message="${@[-1]}" func_name func_prototype
    (( ${#funcstack} >= 3 )) || :die 'Called directly from the command line.'

    # Such function's name.
    func_name=${funcstack[3]}

    # Such function's prototype.
    :set_string_to_func_prototype func_prototype "${func_name}"

    # Throw such exception message, appropriately prefixed and suffixed.
    :die 'Function '${func_name}'() expected '${exception_message}'.'$'\n\n''Function prototype:'$'\n'${func_prototype}$'\n\n''Arguments passed:'$'\n'${(qq)@[1,-2]}
}

# ....................{ EXCEPTIONS ~ arg type              }....................
#FIXME: Document me.
# :void ::func.die_unless_arg_expansions_pass_tester(
#     :string      func_arg1, ...,
#     :string      func_arg_indices,
#     :string:func tester_name)
function ::func.die_unless_arg_expansions_pass_tester() {
    # Localize arguments.
    (( # >= 3 )) || :die\
        'Expected one or more arguments, one argument indices string, and one type tester function name.'
    local\
        arg_indices_string="${@[-2]}"\
        arg_tester_name="${@[-1]}"\
        arg_value\
        error_message\
        func_prototype

    # Pop such arguments off. See pop_args_2() for further details.
    argv[-2,-1]=()

    # Validate sanity.
    :die_unless_func "${arg_tester_name}"
    (( ${#funcstack} >= 2 )) || :die 'Called directly from the command line.'

    # List of all argument indices to be tested. While the passed space-
    # delimited string contains only "@["- and "]"-delimited integers and
    # innteger ranges, this list contains only actual integers.
    local -a arg_indices

    # Such function's prototype.
    :set_string_to_func_prototype func_prototype "${func_name}"

    # Convert such space-delimited string to such list. Dismantled, this is:
    # 
    # * 
    local arg_index_string arg_index_min arg_index_max
    for   arg_index_string (${(z)arg_indices_string}) {
        # Strip such string of "${@[" and "]}" delimiters.
        arg_index_string="${${arg_index#\$\{@\[}%]\}}"

        # If the result is comma-separated, such result signifies a range of
        # argument indices.
        if [[ "${arg_index_string}" == (#b)([^,]##),(*) ]] {
            # Capture such bounds from such string.
            arg_index_min=${match[1]}
            arg_index_max=${match[2]}

            # If such upper bound is a negative index, convert such bound into
            # a positive index to ensure the enumeration below behaves sanely.
            if (( arg_index_max < 0 )) {
                arg_index_max=$(( # + arg_index_max + 1 ))
            }

            # Append all such indices to such list.
            arg_indices+=( {${arg_index_min}..${arg_index_max}} )
        # Else, such result is a single index. Append such index to such list.
        } else {
            arg_indices+=${arg_index_string}
        }
    }

    # Iterate arguments by index until finding the first failing argument.
    # Such indices encompass both index ranges (e.g., "@[3,-1]") and
    # negative indices (e.g., "@[-1]" and hence are *NOT* strictly
    # integers.
    local arg_index
    for   arg_index ("${arg_indices}") {
        # If such argument index is not an integer *OR* is not a valid index
        # for the passed argument list, throw an exception. Curiously,
        # attempting the latter test with "@" rather than "argv" results in a
        # parse error of "zsh: bad substitution". *shrug*
        :die_unless_int "${arg_index}"
        (( ${+argv[${arg_index}]} )) || :die\
            'Argument '${arg_index}' referenced, but only '${#}' arguments passed.'

        # Value of such argument.
        arg_value="${@[${arg_index}]}"

        # Test such value.
        "${arg_tester_name}" "${arg_value}" || {
            # Start such exception message.
            error_message='Function '${funcstack[2]}'() expected argument '${arg_index}' '

            # If such tester tests variable types rather than variable values,
            # tailor such exception message to the former.
            if [[ "${arg_tester_name}" == (#b)':is_var_'(*) ]] {
                # Continue such message.
                error_message+='to reference variable of type :'${match[1]}', but variable ${'${arg_value}'} '

                #FIXME: The type printed above is a high-level zeshy-specific type;
                #The type printed below is a low-level zsh-specific type.
                #Naturally, the latter should be converted to the former; this
                #will probably require a map from zsh- to zeshy-specific types.

                # If such variable exists, such variable cannot be of the
                # expected type. Tailor such message appropriately.
                if { :is_var } {
                    error_message+='has type '${(tP)arg_value}' and value:'$'\n'${(P)arg_value}
                # Else, such variable does not exist. Tailor such message.
                } else {
                    error_message+='not found.'
                }
            # ELse if such tester tests variable values, tailor such message.
            } elif [[ "${arg_tester_name}" == (#b)':is_'(*) ]] {
                error_message+='of type :'${match[1]}' but received:'$'\n'${arg_value}
            # Else such function is of unexpected form. Throw an exception.
            } else {
                :die 'Argument tester function '${arg_tester_name}'() unrecognized (i.e., not prefixed by ":is_").'
            }

            # Throw such exception, suffixed by such function prototype.
            :die ${error_message}$'\n\n''Function prototype:'$'\n'${func_prototype}
        }
    }
}

# --------------------( WASTELANDS                         )--------------------
