#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *function prototype parsers* (i.e., functions parsing function
prototypes, typically as a prerequisite to processing function declarations).
/---

# ....................{ PARSERS                            }....................
#FIXME: Document me.
#FIXME: Shift ::func_.stop() here; then, merge ::func_.parse_args() into such
#function. Maintaining an artificial distinction between the two functions is
#patently nonsensical.

# :void ::func_.parse_args()
function ::func_.parse_args() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'

    # Parse the minimum and maximum number of arguments such function accepts
    # *BEFORE* parsing such arguments. All reasonably sane implementations of
    # argument parsing require such numbers (e.g., to reliably index and expand
    # optional and variadic arguments and arguments following such arguments).
    #
    # Superficially, this appears to necessitate two parse passes over the
    # argument list: the first pass obtaining such numbers and the second pass
    # actually parsing such arguments. In practice, however, careful choices in
    # runnable prototype syntax reduce the first pass to efficient string
    # munging operations requiring *NO* explicit iteration. Indeed, note that:
    #
    # * Omitting single- and double-quoted strings, each "," in an argument
    #   list suggests such function to accept one more mandatory argument.
    # * Omitting single- and double-quoted strings, each "?" and "=" in an
    #   argument list suggests such function to accept one more optional
    #   argument.
    # * Each mandatory argument increases the maximum number of arguments such
    #   function accepts by one.
    # * Each optional argument reduces the minimum number of arguments such
    #   function accepts by one.
    #
    # Efficiently determining such numbers thus reduces to counting the number
    # of unquoted ",", "?", and "=" characters in such argument list.
    #
    # Unfortunately, while such determination *IS* demonstrably efficient,
    # conforming to the algorithm implemented below requires reparsing the
    # argument list once for each optional (but *NOT* variadic) argument such
    # function accepts. (Why? Because each additional optional argument implies
    # such function to accept one additional possible number of arguments and
    # each such number necessitates distinct code validation and hence
    # algorithmic handling here.)
    #
    # Unfortunately, eliminating such reparsing would require persisting a list
    # of argument metadata during the first and only pass for subsequent lookup
    # (as detailed below), itself imposing non-negligible inefficiencies. The
    # question then reduces to: which is less efficient, reparsing each
    # argument multiple times or parsing such arguments into a list only once?
    #
    # To answer this question, consider the common case. If most or even many
    # zeshy functions accepted optional arguments and hence required such
    # reparsing, such reparsing would indeed be non-ideal. In practice, few
    # zeshy functions accept optional arguments (due to readability and
    # writability concerns associated with such arguments). Since the common
    # case imposes no argument reparsing, reparsing poses no imposition.
    #
    # Note that the above two parse passes are technically invertable by
    # parsing all arguments into a list of all argument in the first pass and
    # iterating over such list in the second. In practice, the infrastructure
    # required by such iteration imposes significant space and time costs.
    #
    # For example, consider the following "inverted" implementation:
    #
    #    local -a args_metadata
    #    while {
    #        pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
    #    } {
    #        ...
    #        args_metadata+=(
    #            "${arg_count_max}"
    #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_type}]}"
    #            "${arg_is_absentable}"
    #            "${arg_is_variadic}" )
    #    }

    #    for arg_count ({${arg_count_min}..${arg_count_max}}) {
    #        ...
    #        for arg_index arg_subtype_local arg_is_absentable arg_is_variadic (
    #            "${args_metadata[@]}") {
    #            ...
    #        }
    #        ...
    #    }

    # Map from the name of an alias defining variables of a certain type
    # (e.g., ":string") to the space-delimited string assigning one local
    # variable to each argument of such type (e.g., 'my_string="${1}"').
    local -A arg_declarer_to_declarations

    # Map from the name of a function testing whether passed arguments are of a
    # certain type (e.g., :int.is()) to the space-delimited string expanding
    # all arguments of such type (e.g., '"${1}" "${@[2,-2]}" "${@[-1]}"').
    local -A arg_tester_to_expansions

    # Map from the name of a function testing whether the values of variables
    # referred to by passed arguments are of a certain type (e.g., :int.is())
    # to the space-delimited string expanding all such variables (e.g.,
    # '"${(P)1}" "${(P)@[-1]}"').
    #
    # Ideally, we would simply append such expansions to prior map local
    # ${arg_tester_to_expansions}. Before applying parameter expansion flag "(P)"
    # to arguments, however, we *MUST* validate such arguments to refer to
    # valid variables -- which ${arg_tester_to_expansions} already accomplishes.
    # Since zsh maps are inherently unordered, we cannot also validate such
    # variable values with the same map and expect the prior validation to be
    # deterministically performed before the latter. Separating the two into
    # two different map locals allows such validation to be ordered thusly.
    local -A arg_var_tester_to_expansions

    # Canonical string global ${ZPCRE_OP}, localized to avoid overwriting
    # either global or caller-specific versions of such variable.
    local ZPCRE_OP

    # Code validating the number of arguments passed to such function.
    local code_arg_count

    # Code defaulting defaultable arguments *NOT* passed to such function for
    # all possible argument counts.
    local code_args_default

    # Code defaulting defaultable arguments *NOT* passed to such function for
    # the current argument count.
    local code_args_default_current

    # Code localizing and/or validating arguments passed to such function.
    local code_args_local_or_valid

    # String prefixing each line of such code with indentation appropriate to
    # the current outermost indentation level (i.e., of code nested directly in
    # the current function body).
    local code_indentation_outer=$'\n''    '

    # String prefixing each line of such code with indentation appropriate to
    # the current next-most-outermost indentation level (i.e., of code nested
    # directly in code nested directly in the current function body).
    local code_indentation_inner=${code_indentation_outer}'    '

    # String prefixing each line of such code with indentation appropriate to
    # the current innermost indentation level (i.e., of code nested directly in
    # the current if conditional of the current function body).
    local code_indentation_inner_if_nested_or_outer=${code_indentation_outer}

    # Current argument name.
    local arg_name

    # String with which to expand the current argument if such argument is
    # expandable or the empty string otherwise. Possible values include:
    #
    # * A positive integer (e.g., the "1" in "${1}"), expanding all non-
    #   defaulted arguments preceding the first variadic argument (if any).
    # * A negative integer (e.g., the "@[-1]" in "${@[-1]}"), expanding all
    #   non-defaulted arguments preceding the first variadic argument (if any).
    # * A range of integers (e.g., "the "@[2,-2]" in "${@[2,-2]}"), expanding
    #   all variadic arguments.
    # * Such argument's name (e.g., the "zod" in "${zod}"), expanding all
    #   defaulted, localized arguments.
    #
    # Since non-localized arguments are only validatable by expanding such
    # arguments by their index in the argument list, we prefer to expand all
    # arguments by their index if present in such list. This includes all
    # passed arguments but *NOT* unpassed defaulted arguments, which being
    # unpassed are only expandable by their local variable name if localized.
    local arg_name_expansion

    # Current argument type and subtypes.
    local arg_type arg_subtype_local arg_subtype_major arg_subtype_minor

    # Current argument default value if any or the empty string otherwise.
    # By PCRE design, such value is guaranteed to be a zsh value (i.e., either
    # a single- or double-quoted string, integer, or float). Since the length
    # of such value is thus nonzero if defined or zero otherwise, such length
    # suffices to indicate whether a default value was specified. Hence, no
    # boolean ${arg_has_default_value} is required.
    local arg_default_value

    # Name of the alias localizing the current argument.
    local arg_declarer

    # Name of the function validating the current argument.
    local arg_tester

    # Name of the alias or function reporting success when the current function
    # call allows default arguments, indicated by function attribute
    # "default_args_if". (If such attribute is unspecified, such call *ALWAYS*
    # allows default arguments; in such case, this name defaults to the empty
    # string, implying unconditional success.)
    local args_is_defaultable_tester

    # Space-delimited string of all expansions of arguments to be validated.
    local args_expansions

    # Argument list with all single- and double-quoted strings removed,
    # preventing subsequent parsing from erroneously counting ignorable ",",
    # "?", and "=" characters in such strings.
    local func_args_sans_quotes="${ZESHY_DECLARE_FUNC_ARGS__//(\'([^\']|\'\')#\'|\"(\\\"|[^\"])#\")}"

    # Argument list reduced to all remaining "," characters, whose string
    # length plus one is the maximum number of arguments such function accepts.
    local func_args_commas="${func_args_sans_quotes//[^,]##}"

    # Argument list reduced to all remaining "?" and "=" characters, whose
    # string length subtracted from the prior maximum is the minimum number of
    # arguments such function accepts.
    local func_args_equals="${func_args_sans_quotes//[^?=]##}"

    #FIXME: Can we not simply increment ${arg_count} instead? That could be
    #mildly dangerous, of course, so examine the codebase carefully.

    # Current argument count *AFTER* adding all unpassed defaultable arguments
    # to the current argument list, initialized to their default values.
    integer arg_count_after_default

    # Maximum number of arguments (i.e., number of mandatory *AND* optional
    # arguments such function accepts).
    integer arg_count_max=$(( ${#func_args_commas} + 1 ))

    # Minimum number of arguments (i.e., number of mandatory arguments such
    # function accepts).
    integer arg_count_min=$(( arg_count_max - ${#func_args_equals} ))

    # Number of optional arguments required by the current argument count
    # below. If such function accepts no optional arguments, this number
    # remains 0; else, this number varies between the maximum and minimum
    # number of arguments such function accepts.
    integer arg_count_optional

    # Index of the current argument in the argument list.
    integer arg_index

    # 1 if the current argument is absentable and 0 otherwise.
    integer arg_is_absentable

    # 1 if the current argument indirectly refers to another variable by name
    # and 0 otherwise.
    integer arg_is_indirect

    # 1 if the current argument will be localized by such function's preamble
    # or 0 otherwise. Since all arguments are localized by default, this is
    # only 0 for arguments with explicitly relaxed names.
    integer arg_is_localized

    # 1 if the current argument will be validated by such function's preamble
    # or 0 otherwise. Since all arguments are validated by default, this is
    # only 0 for arguments with explicitly relaxed types *OR* type ":string"
    # (which by definition are *ALWAYS* valid).
    integer arg_is_validated

    # 1 if the current argument is variadic and 0 otherwise.
    integer arg_is_variadic

    #FIXME: Such boolean is excisable by the same approach with which we
    #obsoleted ${arg_was_optional}: namely, globbing the raw argument list for
    #a substring matching ",[ $'\n']#...". That said, that *IS* somewhat more
    #difficult to reliably and efficiently glob for. Contemplate.

    # 1 if a prior argument was variadic and 0 otherwise.
    integer arg_was_variadic

    # 1 if at least one argument is optional and 0 otherwise.
    integer args_is_optional=$(( arg_count_min != arg_count_max ))

    # If such such function accepts at least one optional argument...
    if (( args_is_optional )) {
        # Since all localization and validation code will be embedded in
        # if conditionals (rather than directly within such function's body),
        # prefix each line of such code by an additional indentation level.
        code_indentation_inner_if_nested_or_outer+='    '

        # If such function only conditionally defaults arguments (e.g., only
        # when called directly from the command line), ensure this.
        if (( ${+ZESHY_DECLARE_FUNC_ATTRS__[default_args_if]} )) {
            # Name of the alias or function reporting success when such
            # function accepts default arguments.
            args_is_defaultable_tester=${ZESHY_DECLARE_FUNC_ATTRS__[default_args_if]}

            # If such alias or function does *NOT* exist, throw an exception.
            # See :alias_simple.is() and :func.is() for further details.
            (( ${+aliases[${args_is_defaultable_tester}]} +
               ${+functions[${args_is_defaultable_tester}]} )) ||
               ::func_.die_of_cause 'attribute "default_args_if" alias or function '${args_is_defaultable_tester}'() undefined'
        }
    }

    # For efficiency, compile such PCRE. See for_string_text_matching_pcre:()
    # for further details.
    pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}"
    pcre_study
    # print -r "${ZESHY_DECLARE_FUNC_NAMES__[1]} args: ${ZESHY_DECLARE_FUNC_ARGS__}"

    # For each possible number of arguments between the minimum and maximum
    # established above, define code validating the types of all passed
    # arguments when the caller passes that number of arguments.
    #
    # By design, iterate from the minimum to maximum number of arguments rather
    # than the converse. Why? In a word: defaults. Unpassed defaultable
    # arguments must be assigned default values in a rightmost manner (i.e.,
    # the rightmost defaultable argument in a function prototype must be
    # defaulted first, then the next rightmost defaultable argument, and so on
    # until all unpassed defaultable arguments have been defaulted). By
    # iterating from the minimum to maximum number of arguments, we allow the
    # algorithm below to iteratively "mark" leftmost defaultable arguments as
    # passed until the current argument count indicates all such arguments to
    # have been passed, at which point all remaining defaultable arguments are
    # unpassed and hence assigned default values in a rightmost manner.
    integer arg_count
    for     arg_count ({${arg_count_min}..${arg_count_max}}) {
        # Clear such maps. See :clear_map() for further details.
        set -A arg_declarer_to_declarations
        set -A arg_tester_to_expansions

        # Revert local variables declared above specific to the following loop.
        arg_count_after_default=${arg_count}
        arg_count_optional=$(( arg_count - arg_count_min ))
        arg_index=0
        arg_was_variadic=0
        code_args_default_current=

        # Parse each such argument into canonical list global ${match}, whose
        # indices we localize as human-readable integers above.
        ZPCRE_OP='0 0'
        while {
            pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
        } {
            # For efficiency and readability, localize argument match metadata.
            arg_name=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME}]}
            arg_type=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE}]}
            arg_subtype_local=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_LOCAL}]}
            arg_default_value=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE}]}

            #FIXME: Are all the following booleans still requisite?

            # Likewise, localize boolean-specific argument match metadata.  For
            # efficiency, initialize each such boolean to the length of the
            # corresponding match substring.
            #
            # While most such substrings are guaranteed to be of length either
            # 0 and 1 and hence strictly boolean, some such substrings *ALWAYS*
            # have length greater than 1 if matched and hence are *NOT*
            # strictly boolean. Happily, due to the way zsh interprets tests of
            # the form "(( arg_is_variadic ))", such caveat is ignorable.
            arg_is_absentable=${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE}]}
            arg_is_indirect=${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_INDIRECT}]}
            arg_is_variadic=${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_VARIADIC}]-}

            # Localize such argument *UNLESS* such name is relaxed.
            arg_is_localized=$((
                1 - ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED}]} ))

            # Validate such argument *UNLESS* such type is relaxed.
            arg_is_validated=$((
                1 - ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED}]} ))

            # Increment the current argument index.
            arg_index+=1

            # If such argument is indirect (i.e., refers to a variable by
            # name), default such local subtype to ":string". (By PCRE design,
            # such subtype is guaranteed to be the empty string and hence
            # safely replaceable by a sane default.)
            if (( arg_is_indirect )) {
                arg_subtype_local=':string'
            # Else, such argument is direct.
            #
            # If such argument is a string glob, notify the caller such
            # function accepts at least one such argument.
            } elif [[ "${arg_type}" == ':string+glob' ]] {
                func_was_arg_glob=1
            # Else if such argument's local subtype is nonscalar (i.e., list or
            # map), throw an exception. By zsh mandate, arguments are
            # *ALWAYS* passed as untyped strings and hence cannot
            # encapsulate nonscalar data without indirection.
            } elif [[ "${arg_subtype_local}" == ':'('list'|'map') ]] {
                ::func_.die_of_cause_arg_type_direct\
                    'nonscalar, but zsh only supports scalar argument types'
            }

            # If such argument is defaultable and hence optional...
            if (( ${#arg_default_value} )) {
                # If the number of optional arguments the current argument
                # count accepts is positive, the current optional argument has
                # effectively been "passed". In such case, decrement such
                # number by 1, implying such count to now accept one less
                # optional argument. (The current optional argument "consumes"
                # one available optional argument "slot" under such count.)
                if (( arg_count_optional )) {
                    arg_count_optional+=-1
                # Else, such argument is unpassed.
                #
                # If defaulting such argument (i.e., if such default value is
                # unrelaxed), do so.

                #FIXME: Close, but no e-cigar. While this test is appropriate,
                #we need an "} else {" branch whose body is *IDENTICAL* to that
                #of the "} elif (( arg_is_absentable )) {" branch below.
                #Clearly, the two should be unified. The simplest way is
                #probably as follows:
                #
                #} else {
                #    arg_is_absentable=1
                #}
                #
                #Then, convert such "} elif (( arg_is_absentable )) {" branch
                #to a new "if (( arg_is_absentable )) {" conditional.

                } elif (( ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED}]} )) {
                    # Increment the current argument count to reflect the
                    # insertion of such argument's default value into the
                    # current argument list.
                    arg_count_after_default+=1

                    # If such argument is the last explicit argument such
                    # function accepts (ignoring all subsequent optional
                    # variadic list arguments), efficiently append such
                    # argument's default value to the current argument list.
                    if (( arg_index == arg_count_max )) {
                        code_args_default_current+='argv+='${arg_default_value}
                    # Else if such argument is the first explicit argument such
                    # function accepts, inefficiently replace the current
                    # argument list with one in which the indices of all other
                    # explicit arguments are increased by 1 and the first index
                    # of such list is set to such argument's default value.
                    } elif (( arg_index == 1 )) {
                        code_args_default_current+='argv=( '${arg_default_value}' "${@}" )'
                    # Else such argument is neither the first or last explicit
                    # argument such function accepts and hence is both preceded
                    # *AND* succeeded by at least one such argument. In such
                    # case, an efficient alternative to replacing the current
                    # argument list presents itself: append such argument's
                    # default value to the prior argument. (Yes, this works.)
                    } else {
                        code_args_default_current+='argv['$(( arg_index - 1 ))']+='${arg_default_value}
                    }
                }
            # Else if such argument is absentable and hence optional...
            } elif (( arg_is_absentable )) {
                # If such argument is passed, handle such case. See above for
                # related logic.
                if (( arg_count_optional )) {
                    arg_count_optional+=-1
                # Else, such argument is unpassed.
                } else {
                    #FIXME: Document me.
                    arg_is_localized=0
                    arg_is_validated=0

                    # Since unpassed arguments cannot be indexed, assign the
                    # next argument such index instead. To permit prior logic
                    # to access the index such argument would have had if
                    # passed (e.g., to insert a default value for such argument
                    # into the current argument list when unpassed), decrement
                    # such index *AFTER* performing all prior logic.
                    arg_index+=-1
                }
            }

            #FIXME: Since these two cases no longer share any code (aside from
            #the easly replicable line "arg_count_optional+=-1"), split them
            #here into two top-level if conditional branches. Yay!
            #FIXME: Obsolete. See above!

            # If such argument is either absentable or defaultable, such
            # argument is optional. Note such fact.
            if (( arg_is_absentable + ${#arg_default_value} )) {
                # If the current argument count supports at least one more
                # optional argument, such argument has been passed.
                if (( arg_count_optional )) {
                    # Decrement the current optional argument count, implying such
                    # count to subsequently support one less optional argument.
                    # (The current optional argument "consumes" one of the
                    # available optional argument "slots" permitted by such count.)
                    arg_count_optional+=-1
                #FIXME: Compact the following two conditional branches.

                # Else the current argument count supports no additional
                # optional arguments, implying such argument to be unpassed.
                } else {
                    # If defaulting such argument (i.e., if such argument is
                    # assigned an unrelaxed default value), do so.
                    if (( ${#arg_default_value} &&
                        ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED}]} )) {
                        #FIXME: Document me.
                        #FIXME: Actually, since this is more general than our
                        #current defaulting technique, there's no sensible
                        #reason we can't use this approach to default *ALL*
                        #unpassed defaultable arguments -- not simply those
                        #also variadic. Although the resulting logic will not
                        #be quite as efficient, default arguments should only
                        #ever be used in cases where efficiency doesn't
                        #terribly matter anyway (e.g., front-facing CLI
                        #aliases). The tangible benefits in both generality and
                        #simplicity make this a more than worthwhile tradeoff.
                        #FIXME: So. The current approach *DOES* appear to
                        #generalize pleasantly, but also produces overly
                        #verbose and inefficient code for functions accepting
                        #two or more defaultable arguments. Which is mildly
                        #disconcerting. Clearly, we need some means of
                        #compacting multiple assignments together. For example:
                        #
                        #* If the first argument is defaultable and unpassed
                        #  *AND* there exist any other defaultable, unpassed
                        #  arguments, then since we have to replace the entire
                        #  argument list anyway, we'd might as well compact the
                        #  second default value assignment into the first:
                        #  e.g.,
                        #
                        #    # For a function with prototype:
                        #    # :void :yum(
                        #    #     :string x = 'yay',
                        #    #     :int j, :int k, :int l,
                        #    #     :string y = 'yay',
                        #    #     :int a, :int b, :int c)
                        #    # ...we might want a preamble containing:
                        #    if (( # == 6 )) {
                        #        code_args_local_or_valid+='argv=( '${arg_default_value_x}' "${@[1,3]}" "${arg_default_value_y}" "${@[4,6]}" )'
                        #    } elif (( # == 7 )) {
                        #        code_args_local_or_valid+='argv[4]+="${arg_default_value_y}"
                        #    }
                        #
                        #Brutal. There's clearly a way to identify and handle
                        #such cases; now, we just have to doctor it up.
                        #FIXME: O.K.; to reasonably implement this, we'll want
                        #a new string local ${code_args_default} to which we
                        #append here rather than to ${code_args_local_or_valid}.
                        #Ensure that we:
                        #
                        #* Reset 'code_args_default=' each loop iteration.
                        #* Test '[[ -n "${code_args_default}" ]]' far below; if
                        #  such test succeeds, then and only then append
                        #  ${code_args_local_or_valid} by ${code_args_default}.
                        #  As the above example demonstrates, we test for the
                        #  current argument count exactly. We do *NOT* need an
                        #  "else" branch (indeed, that would be quite
                        #  counterproductive); we do, however, need to track
                        #  whether this is the first such branch. Fortunately,
                        #  the latter is trivial by simply noting whether or
                        #  not '[[ -n "${code_args_default}" ]]'.
                        #* Moreover, *ALL* such branches must clearly be
                        #  emitted before subsequent logic. This suggests,
                        #  clearly, that we actually need *TWO* new string
                        #  locals:
                        #  * ${code_args_default_current}, containing only the
                        #    set of all "argv"-specific commands for the
                        #    current argument count. Reset such string each
                        #    loop iteration.
                        #  * ${code_args_default}, containing *ALL* such
                        #    default value-specific logic. Do *NOT* reset such
                        #    string each loop iteration. Expand such string
                        #    into ${func_preamble} at the end of this function.

                        # Increment the current argument count to reflect the
                        # insertion of such argument's default value into the
                        # current argument list.
                        arg_count_after_default+=1

                        # If such argument is also variadic, ...
                        if (( arg_is_variadic )) {
                            # Initiate such conditional.
                            code_args_local_or_valid+=${code_indentation_outer}'if (( # == '${arg_count}' )) {'${code_indentation_inner}

                            # If such argument is the last explicit argument
                            # such function accepts (ignoring all subsequent
                            # optional variadic list arguments), efficiently
                            # append such argument's default value to the
                            # current argument list.
                            if (( arg_index == arg_count_max )) {
                                code_args_default_current+='argv+='${arg_default_value}
                            # Else if such argument is the first explicit argument
                            # such function accepts, inefficiently replace the
                            # current argument list with one in which the
                            # indices of all other explicit arguments are
                            # increased by 1 and the first index of such list
                            # is set to such argument's default value.
                            } elif (( arg_index == arg_count_max )) {
                                code_args_default_current+='argv=( '${arg_default_value}' "${@}" )'
                            # Else such argument is neither the first or last
                            # explicit argument such function accepts and hence
                            # is both preceded *AND* succeeded by at least one
                            # such argument. In such case, an efficient
                            # alternative to replacing the current argument
                            # list presents itself: append such argument's
                            # default value to the prior argument.
                            # (Astonishingly, this actually works.)
                            } else {
                                code_args_default_current+='argv['$(( arg_index - 1 ))']+='${arg_default_value}
                            }

                            # Terminate such conditional.
                            code_args_local_or_valid+=${code_indentation_outer}'}'
                        }

                        # Expand such argument after such assignment by name.
                        arg_name_expansion=${arg_name}
                    # Else such argument is *NOT* defaultable. Since prior
                    # conditionals guarantee such argument to be unpassed and
                    # either absentable *OR* defaultable, such argument is
                    # unpassed and absentable, suggesting such argument to not
                    # exist and hence be neither localizable or validatable. To
                    # guarantee this, skip to the next argument entirely.
                    } else {
                        # Since unpassed arguments cannot be indexed, assign the
                        # next argument such index instead. To permit prior logic
                        # to access the index such argument would have had if
                        # passed (e.g., to insert a default value for such argument
                        # into the current argument list when unpassed), decrement
                        # such index *AFTER* performing all prior logic.
                        arg_index+=-1

                        #FIXME: Erroneous. In particular, we need to ensure
                        #argument-specific booleans are set in the expected way
                        #(e.g., ${arg_was_variadic}, ${arg_was_optional}) --
                        #not to mention our decrementation of ${arg_index}.
                        #Given this, we probably require a new boolean
                        #(*groan*, we know...) ${arg_is_skippable}. *WAIT*. No,
                        #we can certainly be a bit cleverer than that. We can
                        #implicitly force skipping without explicitly doing so
                        #by coercively replacing the call to continue here
                        #with simply:
                        #
                        #    arg_is_localized=0
                        #    arg_is_validated=0
                        #
                        #Of course, that requires a new boolean
                        #${arg_is_validated} -- but, given that we already have
                        #the former, orthogonality suggests we'll probably end
                        #up requiring the latter at some point anyway. So it
                        #costs us little to nothing to go ahead and define it.
                        #FIXME: Actually, we *SHOULD* just be able to literally
                        #continue to the next argument here. If we're currently
                        #unable to do so, that indicates an overly complex and
                        #logically cumbersome algorithm - which, obviously,
                        #should be addressed anyway. A few thoughts on how to
                        #make this possible:
                        #
                        #* Shift the variadicity conditional below *ABOVE* the
                        #  current optionality conditional.
                        #* Document why we do so.
                        #
                        #And...that should be it? Unlikely, but possible. Grok
                        #the codebase a deeper to see if we haven't missed
                        #anything too elephantine.

                        continue
                    }
                }
            }

            # If such argument is *NOT* variadic (i.e., was *NOT* suffixed by
            # an ellipse), handle such argument. Do so *AFTER* decrementing
            # such argument index and hence testing whether such argument is
            # optional, as we further munge such index below.
            if (( ! arg_is_variadic )) {
                # If such argument does *NOT* follow a variadic argument, such
                # argument, such argument is reliably expandable by its
                # positive index (i.e., relative to the beginning of such
                # argument list).
                if (( ! arg_was_variadic )) {
                    arg_name_expansion=${arg_index}
                # Else such argument follows a variadic argument and hence a
                # countably infinite number of arguments. In such case,
                # such argument is only reliably expandable by its negative
                # index (i.e., relative to the end of such argument list).
                # Happily, the same index applies regardless of whether such
                # variadic argument was mandatory or optional.
                #
                # Since negative sign "-" conflicts with parameter expansion
                # syntax, negative indices may only be referenced by indexing
                # canonical list global ${@} or ${argv} with such index. For
                # brevity, we prefer the former. Since subsequent logic may
                # conditionally prefix such string with parameter expansion
                # flags (e.g., "(P)"), avoid delimiting such string with "${"
                # and "}" until *AFTER* performing such logic below.
                } else {
                    arg_name_expansion='@['$(( arg_index - arg_count_max - 1 ))']'
                }
            # Else, such argument is variadic.
            } else {
                # If a prior argument is also variadic, throw an exception.
                # Such case implies such function to accept two or more
                # variadic argument lists of arbitrary count, implying there
                # exists no general means of deciding which such list a passed
                # string was intended to belong to.
                (( ! arg_was_variadic )) || ::func_.die_of_cause_arg_variadic\
                    'accepts two or more variadic arguments'

                # If another argument is optional, throw an exception. Such case
                # implies such function to accept one or more optional arguments
                # *AND* one or more variadic argument lists of arbitrary count,
                # implying there exists no general means of deciding which such
                # argument a passed string was intended to correspond to.
                #
                # Test such condition *AFTER* testing whether a prior argument is
                # variadic. If such function accepts an optional variadic argument
                # following a prior variadic argument, the prior exception is more
                # explanatory than this exception.
                #
                # The test that follows is an extreme optimization of:
                #
                #    if (( args_is_optional )) && {
                #       (( ! arg_is_optional )) ||
                #       (( arg_count_max - arg_count_min > 1 )) } { ... }
                #
                # As such logic implies, testing whether such function accepts
                # at least one optional argument is insufficient. Such argument
                # could in fact be the current variadic argument, a valid edge
                # case we explicitly support. Hence, also test whether the
                # current variadic argument is optional. If so, test whether
                # any other argument is optional (as implied by the number of
                # optional arguments being greater than 1, thus ignoring the
                # current validly optional variadic argument).
                #
                # To understand why the above test reduces to the optimization
                # below, recall that:
                #
                # * ${arg_is_optional} is 1 if the current variadic argument is
                #   optional and 0 otherwise.
                # * (( arg_count_max - arg_count_min )) is 1 if the current
                #   variadic argument is optional and 0 otherwise.
                # 
                # In either case, subtracting either from the other *ALWAYS*
                # results in 0; in any other case, the same subtraction *NEVER*
                # results in 0. Hence, such test suffices. (Convenient.)
                (( ! arg_is_optional - arg_count_max - arg_count_min )) ||
                    ::func_.die_of_cause_arg_variadic\
                        'accepts both optional and variadic arguments'

                # Notify subsequent parse iterations of such fact. For safety,
                # set such boolean *AFTER* all tests of such boolean above.
                arg_was_variadic=1

                # Expand such argument and all subsequent optional variadic
                # arguments with an argument range starting at the current
                # positive index and ending at the negative index of the last
                # such argument. See above for related logic.
                arg_name_expansion='@['${arg_index}','$(( arg_index - arg_count_max - 1 ))']'
            }

            # If localizing such argument, do so.
            if (( arg_is_localized )) {
                # If such such argument is *NOT* variadic, localize such
                # argument as a new local scalar variable.
                if (( ! arg_was_variadic )) {
                    # Note that if such argument is indirect, prior logic ensures
                    # such argument's local subtype to be ":string".
                    #
                    # If such subtype is *NOT* the name of an existing alias, throw
                    # an exception. See :is_alias_simple() for details.
                    (( ${+aliases[${arg_subtype_local}]} )) ||
                        ::func_.die_of_cause_arg_type\
                            'local subtype '${arg_subtype_local}' unrecognized (i.e., alias '${arg_subtype_local}'() locally declaring such argument undefined)'

                    # If such argument is non-defaulted, such argument is passed.
                    # In such case, map such subtype to a definition copying such
                    # argument value to a local variable.
                    if (( ! ${#arg_default_value} )) {
                        arg_declarer_to_declarations[${arg_subtype_local}]+=' '${arg_name}'="${'${arg_name_expansion}'}"'
                    # Else, such argument is defaulted and hence unpassed.  Since
                    # subsequent logic defaults such argument, declare such
                    # argument as a local variable initialized to either (depending
                    # on type) the empty string, 0, or 0.0.
                    } else {
                        arg_declarer_to_declarations[${arg_subtype_local}]+=' '${arg_name}
                    }
                #FIXME: Implement me. To do so sanely:
                #
                #* Declare new string local ${code_args_local_variadic} above.
                #* Clear such string each argument count iteration.
                #* Since there exists at most one variadic argument each
                #  such iteration, set such string in the conditional branch
                #  below to code performing all required pop and shift
                #  operations. Since we know the current argument index and
                #  count, this should be perfectly feasible.
                #* Unconditionally expand such string into
                #  ${code_args_local_or_}.
                #FIXME: Note a mild optimization, as well:
                #"if (( arg_count == 1 )) {", then we don't need to pop or
                #shift anything. Nice.

                # Else such such argument is variadic and hence cannot be
                # localized as a new local scalar variable. Instead, reduce the
                # current argument list to only such variadic arguments.
                } else {
                }
            }

            # If validating such argument (i.e., if such argument type is
            # unrelaxed and unequal to ":string"), do so. Since *ALL* function
            # arguments are technically untyped scalars and hence strings,
            # arguments of type ":string" are *ALWAYS* inherently valid.
            if (( arg_is_validated )) && [[ "${arg_type}" != ':string' ]] {
                # Such argument's major and minor validation-specific subtypes.
                arg_subtype_major=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}
                arg_subtype_minor=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}

                # If such argument is indirect, such subtype applies to
                # the value of the variable such argument refers to rather
                # than such variable's type. In contrast to the customary
                # case (in which we validate only such argument's value),
                # this necessitates we validate both such argument's value
                # (i.e., such variable's type) *AND* such variable's value.
                #
                # There exist two principal means of doing so:
                #
                # 1. Create one new function
                #    "var.is_${subtype_major}_${subtype_minor}" for each
                #    existing function
                #    "${subtype_major}.is_${subtype_minor}" (e.g.,
                #    a new function var.is_int_positive() corresponding to
                #    existing function int.is_positive()). This has the
                #    minor advantage of requiring no changes to the logic
                #    below, but has the uncomfortably distinct disadvantage
                #    of effectively doubling the number of tester
                #    functions in the core zeshy codebase.
                # 2. Call the existing function
                #    "${subtype_major}.is_${subtype_minor}" with such
                #    variable's value by directly passing such argument
                #    expanded by parameter expansion flag "(P)". This has
                #    the minor disadvantage of requiring we duplicate logic
                #    validating such argument's value below to also
                #    validating such variable's value here, but the
                #    comfortably distinct advantage of requiring no
                #    significant changes to the core zeshy codebase.
                #
                # Three pence for the grizzly gentleman in the well-bearded
                # coat if you can guess which approach we adopted.
                #
                # For simplicity, validate such variable's value *BEFORE*
                # validating such argument's value (i.e., such variable's
                # type). While such validation could be performed in either
                # order, this order simplifies such logic substantially.
                if (( arg_is_indirect )) {
                    # Name of the function validating such variable's value.
                    arg_tester=':'${arg_subtype_major]}'.is_'

                    # If such argument has a minor subtype, suffix such function.
                    [[ -z "${arg_subtype_minor}" ]] ||
                        arg_tester+='_'${arg_subtype_minor}

                    # If such function does *NOT* exist, throw an
                    # exception. For efficiency, inline such test. See
                    # :func.is() for further details.
                    (( ${+functions[${arg_tester}]} )) ||
                        ::func_.die_of_cause_arg_type\
                            'unvalidatable (i.e., function '${arg_tester}'() validating variables referred to by such argument undefined)'

                    # Map such function name to such variable expansion.
                    #
                    # If such argument is variadic, such argument implies
                    # an indirectly subtyped variadic argument list (e.g.,
                    # as ":void func(:string:int+nonzero int1, ...)").
                    # Unfortunately, such edge case provokes a subtle
                    # contradiction:
                    #
                    # * Expanding variadic arguments requires use of ranged
                    #   indices ("${@[2,-2]}").
                    # * Expanding indirect arguments requires use of
                    #   parameter expansion flag "(P)" ("${(P)2}").

                    # * Parameter expansion flag "(P)" only non-
                    #   erroneously applies to single rather than ranged
                    #   expansions (e.g., to "${(P)2}" rather than
                    #   "${(P)@[2,-2]}"), Technically, zsh *DOES* silently
                    #   permit "(P)" to be used in conjunction with ranged
                    #   expansions, but in such case only expands to the
                    #   value of the variable referred to by the first such
                    #   index -- which, ultimately, is of little use.
                    #
                    # Syllogism (i.e., logic puzzle) enthusiasts will be quick
                    # to note the implication above. Happily, such conundrum is
                    # efficiently correctable by detecting such edge case and,
                    # in such case, performing global string replacement to
                    # iteratively replace all argument values in such range by
                    # the values of the variables the former refer to instead
                    # (e.g., expanding the indices ranging @[2,-2] as
                    # "${@[2,-2]//(#m)*/${(P)MATCH}}" rather than
                    # "${(P)@[2,-2]}"). Dismantled, this is:
                    #
                    # * "(#m)", enabling canonical string global ${MATCH}.
                    # * "*", capturing the name of the variable referred to
                    #   by the current argument to ${MATCH}.
                    # * "${(P)MATCH}", expanding to such variable's value.
                    if (( arg_is_variadic )) {
                        arg_var_tester_to_expansions[${arg_tester}]+=' "${(P)'${arg_name_expansion}'//(#m)*/${(P)MATCH}}"'
                    # Else, such argument is non-variadic and hence refers to a
                    # single variable. In such case, parameter expansion flag
                    # "(P)" may be applied per usual.
                    } else {
                        arg_var_tester_to_expansions[${arg_tester}]+=' "${(P)'${arg_name_expansion}'}"'
                    }
                }

                # Now validate such argument's value.
                #
                # If such argument has a major subtype, verify such subtype.
                #
                # Specifically, if such argument is *NOT* indirect but such
                # major subtype is "var", such argument is actually indirect.
                # While indirection is usually specified by type indirective
                # "*", type prefix ":string/var" also suffices.
                #
                # If such argument is additionally *NOT* locally declared as a
                # string, throw an exception. While integer arguments could
                # technically refer to variables whose names are themselves
                # integers, such edge-case seems both implausible and fragile.
                if [[ -n "${arg_subtype_major}" ]] {
                    if [[ "${arg_subtype_major}" == 'var' &&
                          "${arg_subtype_local}" != ':string' ]] {
                        ::func_.die_of_cause_arg_type_direct\
                            'refers to variables by name but not locally declared as a string'
                    }
                # Else, such argument has no major subtype. Since such subtype
                # is required for validation...
                } elif {
                    # ...if such argument is indirect, convert such major and
                    # minor subtypes to their standard format for direct
                    # arguments (e.g., from "*:int" to ":string/var+int"),
                    # simplifying validation below.
                    if (( arg_is_indirect )) {
                        arg_subtype_minor=${arg_subtype_major}
                        arg_subtype_major='var'
                    # ...else, default such major subtype to such local
                    # subtype, stripped of ":" prefix if any.
                    } else {
                        arg_subtype_major=${arg_subtype_local#:}
                    }
                }

                # Name of the function validating such argument's value.
                arg_tester=':'${arg_subtype_major}'.is'

                # If such argument has a minor subtype, suffix such function.
                [[ -z "${arg_subtype_minor}" ]] ||
                    arg_tester+='_'${arg_subtype_minor}

                # If such function does *NOT* exist, throw an exception.  For
                # efficiency, inline such test. See :func.is() for details.
                (( ${+functions[${arg_tester}]} )) ||
                    ::func_.die_of_cause_arg_type\
                        'unvalidatable (i.e., function '${arg_tester}'() validating such argument undefined)'

                # Map such function name to such argument's expansion.
                arg_tester_to_expansions[${arg_tester}]+=' "${'${arg_name_expansion}'}"'
            }
        }

        # If defaulting at least one argument for the current argument count...
        if [[ -n "${code_args_default_current}" ]] {
            # If defaulting at least one argument for a prior argument count,
            # there already exists an if conditional doing so. In such case,
            # continue such conditional with a new branch.
            if [[ -n "${code_args_default}" ]] {
                code_args_default+=${code_indentation_outer}
            # Else, no such conditional exists, so begin one anew.
            } else {
                code_args_default+=${code_indentation_outer}
            }

            #FIXME: Incorporate ${args_is_defaultable_tester} logic from below.

            code_args_default+=${code_args_default_current}${code_indentation_outer}'}'
        }

        #    if (( # == 6 )) {
        #        code_args_local_or_valid+='argv=( '${arg_default_value_x}' "${@[1,3]}" "${arg_default_value_y}" "${@[4,6]}" )'
        #    } elif (( # == 7 )) {
        #        code_args_local_or_valid+='argv[4]+="${arg_default_value_y}"
        #    }
        #
        #Brutal. There's clearly a way to identify and handle
        #such cases; now, we just have to doctor it up.
        #FIXME: O.K.; to reasonably implement this, we'll want
        #a new string local ${code_args_default} to which we
        #append here rather than to ${code_args_local_or_valid}.
        #Ensure that we:
        #
        #* Reset 'code_args_default=' each loop iteration.
        #* Test '[[ -n "${code_args_default}" ]]' far below; if
        #  such test succeeds, then and only then append
        #  ${code_args_local_or_valid} by ${code_args_default}.
        #  As the above example demonstrates, we test for the
        #  current argument count exactly. We do *NOT* need an
        #  "else" branch (indeed, that would be quite
        #  counterproductive); we do, however, need to track
        #  whether this is the first such branch. Fortunately,
        #  the latter is trivial by simply noting whether or
        #  not '[[ -n "${code_args_default}" ]]'.

        #FIXME: The current test is insufficient. Specifically, this:
        #    if (( ${#arg_declarer_to_declarations} +\
        #          ${#arg_tester_to_expansions} )) {
        #...should also include a test of "+ ${#code_args_local_variadic}" or
        #some such. *yawn morosely*

        # If localizing and/or validating at least one such argument, do
        # so. Technically, there exist three possible map locals to be tested
        # here: the two tested below and ${arg_var_tester_to_expansions}, *NOT*
        # tested below. Since prior logic guarantees ${arg_tester_to_expansions} to
        # be nonempty whenever ${arg_var_tester_to_expansions} is nonempty,
        # however, the latter need *NOT* be explicitly tested here.
        if (( ${#arg_declarer_to_declarations} +\
              ${#arg_tester_to_expansions} )) {
            # If such function accepts at least one optional argument, subsequent
            # argument type validation assumes such function's caller passed the
            # current number of arguments. Prefix such validation by an if
            # conditional guaranteeing such assumption.
            if (( args_is_optional )) {
                # Indent the following if conditional.
                code_args_local_or_valid+=${code_indentation_outer}

                # If parsing the maximum number of arguments, end the current if
                # conditional. Since the prior branch of such conditional
                # already ended on "}", omit such delimiter here. Since the
                # maximum argument count allows no optional and hence no
                # default arguments, do *NOT* test
                # ${args_is_defaultable_tester} as below.
                if (( arg_count_after_default == arg_count_max )) {
                    code_args_local_or_valid+=' else {'
                # Else we are parsing less than such number of arguments.
                } else {
                    # If parsing the minimum number of arguments, start such if
                    # conditional. Avoid delimiting such conditional yet, as
                    # subsequent logic may interpose additional tests.
                    #
                    # Curiously, note that such test implicitly accounts for
                    # variadicity. Why? Consider. If one argument is variadic,
                    # then by the prior constraints such argument must also be
                    # the *ONLY* optional argument such function accepts.
                    # There then exist only two cases with respect to the
                    # number of arguments such function accepts. Either such
                    # function is passed:
                    #
                    # 1. The minimum number of arguments and hence *NOT* passed
                    #    such optional variadic argument, which the branch
                    #    below suffices to test.
                    # 2. The maximum number of non-variadic arguments and hence
                    #    passed at least such optional variadic argument, which
                    #    the branch above suffices to test.
                    if (( arg_count_after_default == arg_count_min )) {
                        code_args_local_or_valid+='if (( # == '${arg_count_after_default}' ))'
                    # Else, extend such if conditional in a similar manner.
                    } else {
                        code_args_local_or_valid+=' elif (( # == '${arg_count_after_default}' ))'
                    }

                    #FIXME: This *MUST* be shifted above to where we now handle
                    #argument defaults in a better generalized manner.
                    #FIXME: Moreover, string local ${args_definitions_default}
                    #should now be excised.

                    # If such function only conditionally accepts default
                    # arguments *AND* the current argument count accepts at
                    # least one such argument, additionally test whether the
                    # current function call accepts default arguments.
                    if (( ${#args_is_defaultable_tester} &&\
                          ${#args_definitions_default} )) {
                        code_args_local_or_valid+=' { '${args_is_defaultable_tester}' }'
                    }

                    #FIXME: If some such argument is variadic *AND* passed, we
                    #need to emit code *HERE* popping all prior non-variadic
                    #arguments and shifting all subsequent non-variadic
                    #arguments off the argument list. The problem is that we
                    #don't have the index of such variadic argument here. This
                    #is probably easiest corrected by converting
                    #${arg_was_variadic} from a boolean into the nonzero index
                    #of such argument if present or 0 otherwise.
                    #FIXME: There's another subtler problem as well: we only
                    #want to pop and shift arguments if *ALL* such arguments
                    #have been localized. If even a single such argument has
                    #*NOT* been localized, it would make little sense to pop
                    #and shift only some of the arguments (i.e., the localized
                    #ones), as the function body would still in that case be
                    #unable to expand such variadic argument list as "${@}".
                    #
                    #Hence, we need some means of tracking whether or not all
                    #non-variadic arguments were localized. Since we have
                    #existing means, we'll need to gin up
                    #yet-another-arg-count-integer:
                    #
                    #    integer arg_count_localized
                    #
                    #Such integer can be efficiently incremented each argument
                    #count iteration as follows:
                    #
                    #    arg_count_localized+=$(( arg_is_localized ))
                    #
                    #Wait. Simpler way. We only require a new boolean:
                    #
                    # # 1 if at least one non-variadic argument is *NOT*
                    # # localized and 0 otherwise (i.e., if all such arguments
                    # # are localized).
                    # integer arg_was_unlocalized
                    #
                    # Or perhaps such boolean's opposite? Whichever's simpler!

                    # Terminate the current branch of such if conditional.
                    code_args_local_or_valid+=' {'
                }
            }

            # For efficiency, combine the following two related iterations:
            #
            # * For each function name and corresponding string expanding all
            #   arguments validated by calling such function (i.e., key-value
            #   pairs of map ${arg_tester_to_expansions}), do so.
            # * For each function name and corresponding string expanding all
            #   variables referred to by arguments and validated by calling
            #   such function (i.e., key-value pairs of map
            #   ${arg_var_tester_to_expansions}), do so. While the first iteration
            #   validates such variables as existing and of the expected type,
            #   this iteration validates the values such variables expand to
            #   and hence must be performed *AFTER* the first iteration.
            for arg_tester args_expansions (
                "${(kv@)arg_tester_to_expansions}"
                "${(kv@)arg_var_tester_to_expansions}") {
                code_args_local_or_valid+=${code_indentation_inner_if_nested_or_outer}${arg_tester}${args_expansions}' || ::func.die_unless_arg_values_pass_tester "${@}" '''${args_expansions}''' '${(q)arg_tester}
            }

            # For each alias name and corresponding string localizing arguments
            # into locals declared by expanding such alias, do so. By design,
            # such declarations consist only of simple string assignments
            # *ALWAYS* succeeding and hence requiring no exception handling
            # (e.g., 'my_var="${1}"'). For efficiency, iterate only by keys
            # (rather than by both keys and values).
            for arg_declarer ("${(k@)arg_declarer_to_declarations}") {
                code_args_local_or_valid+=${code_indentation_inner_if_nested_or_outer}${arg_declarer}${arg_declarer_to_declarations[${arg_declarer}]}
            }

            # If such function accepts at least one optional argument and hence
            # prefixed such validation by an if conditional, end such conditional.
            if (( args_is_optional )) {
                code_args_local_or_valid+=${code_indentation_outer}'}'
            }
        }
    }

    # Substring prefixing argument count-specific exception messages.
    local die_arg_count_prefix=' || :die "Function ${funcstack[1]}() expected '

    # Substring suffixing argument count-specific exception messages.
    local die_arg_count_suffix='."$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY_DECLARE_FUNC_PROTOTYPE__}'$''\n\n''"Arguments passed:"$''\n''"${*}"'

    # Validate the number of arguments passed to such function.
    #
    # If such function is variadic, such function accepts a countably
    # infinite number of arguments only bounded below by such minimum.
    if (( arg_was_variadic )) {
        code_arg_count=${code_indentation_outer}'(( # >= '${arg_count_min}' )) || ::func.die_of_arg_count_not_exceeding "${@}" '${arg_count_min}
    # Else, such function is non-variadic, in which case such function
    # accepts a number of arguments bounded by such minimum and maximum.
    #
    # If such minimum and maximum are equal, simplify such test as such.
    } elif (( arg_count_min == arg_count_max )) {
        code_arg_count=${code_indentation_outer}'(( # == '${arg_count_min}' )) || ::func.die_of_arg_count_not_equaling "${@}" '${arg_count_min}
    # Else, such minimum and maximum are unequal.
    } else {
        code_arg_count=${code_indentation_outer}'(( '${arg_count_min}' <= # && # <= '${arg_count_max}' )) || ::func.die_of_arg_count_not_ranging "${@}" '${arg_count_min}' '${arg_count_max}
    }

    # String expanded at the start of such function's body, thus localizing and
    # validing arguments *BEFORE* all user-defined logic.
    #
    # Strip a prefixing newline from such preamble, if any. While it would
    # clearly be preferable to avoid emitting such newline in the first place,
    # such newline has two possible sources (either ${code_args_default} or
    # ${code_arg_count}, depending on whether at least one unpassed argument is
    # defaulted) and hence is non-trivially removable. This is much simpler.
    func_preamble=${${:-${code_args_default}${code_arg_count}${code_args_local_or_valid}}#$'\n'}
    # print -r "${func_name} preamble: ${func_preamble}"$'\n\n'
}

# --------------------( WASTELANDS                         )--------------------
                        #FUXME: Actually, the approach pursued below should
                        #*ALSO* suffice in this case as well. Hence, we want to
                        #implement such approach if either:
                        #
                        #* Such argument is *NOT* localized.
                        #* Such argument is variadic.
                        #
                        #The two cases are similar, because (of course)
                        #variadic arguments are *NOT* localized. Yay!

                        # # If such argument is *NOT* localized, throw an
                        # # exception.
                        # #
                        # # While we *MAY* support non-localized defaultable
                        # # arguments in the future, doing so now would impose
                        # # complexities and inefficiencies for little gain.
                        # (( arg_is_localized )) ||  ::func_.die_of_cause\
                        #     'argument ${'${arg_name}'} assigned a default value; consider either eliminating such assignment or refactoring such argument to be non-variadic'

                        # # If such argument is also variadic, throw an
                        # # exception. While assigning the first argument of an
                        # # unpassed variadic list a default value is feasible,
                        # # doing so imposes hitherto unaddressed complexities;
                        # # given the conditional logic below, we would need to
                        # # prepend ${code_args_local_or_valid} with an
                        # # additional if conditional (probably with only a
                        # # single branch) testing whether 
                        # #
                        # # e.g.,
                        # #
                        # # * Why permit only the first argument of such a list
                        # #
                        # # While we *MAY* support variadiac defaultable
                        # # arguments in the future, doing so now would impose
                        # # complexities and inefficiencies for little gain.
                        # (( ! arg_is_variadic )) || ::func_.die_of_cause\
                        #     'variadic argument ${'${arg_name}'} assigned a default value; consider either eliminating such assignment or refactoring such argument to be non-variadic'

                    #FUXME: Silly. Since we now know beforehand whether there
                    #exists an optional argument, this is removable; instead,
                    #just test where we handle variadic-specific logic:
                    #
                    #    (( ! args_is_optional )) || ::func_.die_of_cause_arg_variadic\
                    #         'accepts both optional and variadic arguments'

                    # If a prior argument is variadic, throw an exception. Note
                    # we ignore the valid case that the current argument is
                    # both variadic and absentable (e.g., ":int arg1?, ...").
                    # (( ! arg_was_variadic )) ||
                    #     ::func_.die_of_cause_arg_variadic\
                    #         'accepts both optional and variadic arguments'

# - precisely as tested for here
                # Then such test reduces to either:
                #
                # * "(( arg_count_max - arg_count_min == 1 ))", if the
                #   current variadic argument is optional.
                # * "(( arg_count_max - arg_count_min == 0 ))", if the
                #   current variadic argument is mandatory.

                # if (( args_is_optional &&\
                      # arg_count_max - arg_count_min - arg_is_optional > 1 )) {
                # if (( arg_count_max - arg_count_min >= 2 ))

            #FUXME: Erhm; there *IS* no boolean local ${arg_is_defaultable}, at
            #the moment. Honestly, do we even still require
            #${arg_was_optional}?
            #FUXME: Optimizable by shifting above?

    # # 1 if a prior argument was optional (i.e., either defaulted *OR*
    # # optionalized) and 0 otherwise.
    # integer arg_was_optional

    #     arg_was_optional=0

    #         # If such argument was optional and/or variadic, notify subsequent
    #         # parse iterations of such fact. For safety, set such boolean
    #         # *AFTER* all tests of such boolean above.
    #         if (( arg_is_absentable + arg_is_defaultable )) {
    #             arg_was_optional=1
    #         }

            # # Else, such argument is variadic.
            # #
            # # If a prior argument is also variadic, throw an exception. Such
            # # case implies such function to accept two or more variadic
            # # argument lists of arbitrary count, implying there exists no
            # # general means of deciding which such list a passed string was
            # # intended to belong to.
            # } elif (( arg_was_variadic )) {
            #     ::func_.die_of_cause_arg_variadic\
            #         'accepts two or more variadic arguments'
            # # If a prior argument is optional, throw an exception. Such case
            # # implies such function to accept one or more optional arguments
            # # *AND* one or more variadic argument lists of arbitrary count,
            # # implying there exists no general means of deciding which such
            # # argument a passed string was intended to correspond to.
            # #
            # # Test such condition *AFTER* testing whether a prior argument is
            # # variadic. If such function accepts an optional variadic argument
            # # following a prior variadic argument, the prior exception is more
            # # explanatory than this exception.
            # } elif (( arg_was_optional )) {
            #     ::func_.die_of_cause_arg_variadic\
            #         'accepts both optional and variadic arguments'
            # # Else, such argument is validly variadic.

 # Alternatively, since it's clear this is only an
        #optimization concern and a mild one at that, we should probably simply
        #excise such conditional.
            #FUXME: Due to the "! arg_is_variadic" constraint below, this is
            #probably shiftable into the prior conditional, no?
            #FUXME: Actually, even this condition isn't *QUITE* sufficient. We
            #also want to avoid localizing unpassed absentable arguments, for
            #obvious reasons (e.g., to ensure unpassed arguments are
            #distinguishable from the empty string, 0, and 0.0). This probably
            #ties into our currently erroneous use of "continue" above; oh,
            #right. In the above case, we simply coerce "arg_is_localized=0",
            #suggesting we should probably do the same (for both orthogonality
            #and consistency) when "(( arg_is_variadic ))".

                        #FUXME: And another subtle point: after implementing
                        #such conditional logic, the size of the current
                        #argument list is increased by 1 for each defaulted
                        #argument, implying that the ${code_args_local_or_valid}-
                        #based conditional below will be testing the wrong
                        #argument count. Happily, this is easily correctable by
                        #maintaining a new argument count incremented by 1 here
                        #for each defaulted argument:
                        #
                        #    integer arg_count_after_default

                        #FUXME: The right idea; however, we need to be doing
                        #just the *OPPOSITE*. If the current argument is both
                        #unpassed *AND* undefaulted (which can occur due to any
                        #number of root causes, such as being absentable *OR*
                        #being relaxedly defaultable), we need to:
                        # arg_count_after_default-=1

            # For each alias name and corresponding string localizing arguments
            # into locals declared by expanding such alias, do so *BEFORE*
            # assigning unpassed defaultable arguments default values.
            #
            # Naturally, the reasons why are somewhat subtle. Technically, such
            # declarations and assignments *COULD* be combined. For example:
            #
            #     # Rather than separating such statements like so...
            #     :string mu="${1}" wu="${2}" nothing something
            #     nothing="Nothing lasts but nothing is lost."
            #     something="$(false)"
            #
            #     # ...we could simply combine such statements.
            #     :string\
            #         mu="${1}"\
            #         wu="${2}"\
            #         nothing="Nothing lasts but nothing is lost."\
            #         something="$(false)"
            #
            # When *NOT* preceded by a declaration, assigning a variable a
            # string embedding at least one process substitution reporting
            # failure (e.g., 'something="$(false)"') itself reports failure and
            # hence implicitly throws an exception. This is good.
            #
            # When preceded by a declaration, however, such assignment *ALWAYS*
            # reports success and hence ignores such failure. This is bad.
            #
            # Separating declarations and assignments thus preserves essential
            # errors, reducing the former to simple string assignments *ALWAYS*
            # succeeding and hence requiring no exception handling (e.g.,
            # 'my_var="${1}"').
            #
            # For efficiency, iterate only by keys (rather than by both keys
            # and values).

            #FUXME: Excise. See above.

            # Assign unpassed defaultable arguments default values *BEFORE*
            # subsequent iteration validates such arguments.
            # code_args_local_or_valid+=${args_definitions_default}

    #FUXME: Improve commentary.

    # If defaulting at least one argument, delimit that from subsequent logic
    # by a newline.
    # if [[ -n "${code_args_default}" ]] {
    #     code_args_default+=$'\n'
    # }

                        #FUXME: Actually, only do this if we're also localizing
                        #such argument. If we're *NOT*, we have no choice but
                        #to treat such assignment as if relaxed.
                        #FUXME: Oh, yes -- and we clearly need to handle
                        #relaxation as well.

                        # Append an assignment of such argument to such default
                        # value to the newline-delimited string of such
                        # assignments.
                        # args_definitions_default+=${code_indentation_outer}${arg_name}'='${arg_default_value}

    # Newline-delimited string of all assignments of unpassed defaultable
    # arguments to default values: e.g.,
    #
    #     problem="The problem is not to find the answer."
    #     answer="It’s to face the answer."
    #
    # Since delimiting such assignments by newline suffices, prefer appending
    # such assignments to a string rather than list (for efficiency).
    # local args_definitions_default

        # args_definitions_default=

#[[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED}]}"
                        #FUXME: The above example brings up a subtle point:
                        #when some but not all multiple defaultable arguments
                        #are unpassed, decide which such arguments to default
                        #and which *NOT* to default in a rightmost manner
                        #(i.e., default rightmost defaultable arguments first).
                        #Do we currently do this? Suspicions say, "wat."

# This should substantially (hopefully!)
                        #simplify logic elsewhere as well.
                        #FUXME: Actually, as the description below suggests,
                        #this won't be terribly difficult to support at all.
                        #Specifically:
                        #
                        #* If such defaultable argument is also variadic,
                        #  prepend ${code_args_local_or_valid} with an
                        #  additional if conditional (probably with only a
                        #  single branch) testing whether such argument was
                        #  passed or not.
                        #* If unpassed, the body of such conditional should
                        #  directly modify the argument list to interpose such
                        #  argument's default value directly into the current
                        #  argument list as follows:
                        #  * If such argument is the last argument, efficiently
                        #    append such default value to such list with:
                        #    argv+="${arg_default_value}"
                        #  * Else, inefficiently inject such default value into
                        #    the appropriate position of such list. This should
                        #    require at least two commands:
                        #    1. Shift all subsequent arguments down by one
                        #       index. Does something like the following
                        #       actually work? We strongly doubt it, but
                        #       certainly worth a lucky try. Yes, it does!
                        #       Huzzah: e.g.,
                        #       argv[${arg_index},-1]=( "${@[${arg_index}]}" )
                        #    2. Inject such default value into the proper
                        #       index: e.g.,
                        #       argv[${arg_index}]="${arg_default_value}"
                        #    Actually, given such operations, we *CAN* combine
                        #    them into the following single efficient command:
                        #
                        #    argv[$(( arg_index - 1 ))]+="${arg_default_value}"
                        #
                        #    Wait! That works for all indices except the first,
                        #    of course, which requires an inefficient but still
                        #    compact single command: e.g.,
                        #
                        #    argv=( "${arg_default_value}" "${@}" )
                        #
                        #In the above examples, note that ${arg_index} has
                        #probably already been decremented by 1 and hence
                        #incorrect. Handle this... erhm, "appropriately": e.g.,
                        #    argv[${arg_index}]+="${arg_default_value}"

                        #FUXME: While such code does appear to work here, would
                        #it not be more logically consistent to shift it below
                        #where we append to ${code_args_local_or_valid}
                        #en-masse? Hmm; certainly not, as we require the index
                        #of such argument. Note this below.

                            # If such argument is the last standard argument
                            # such function accepts (ignoring all subsequent
                            # optional variadic list arguments, of course), 

                    #FUXME: Unlike all other instances of relaxation, 

                #FUXME: Uh oh. Such conditionals appear to suffice in all cases
                #*EXCEPT* where variadic arguments are passed, in which case...
                #what? Do we perhaps need to shift such "==" comparisons below
                #to ">=" instead? Contemplate.

# In such case, test for implying at least one optional argument to be
                # tested for.
            #FUXME: Slightly more efficient to initialize such index to 1 above
            #and set this

                        # impose ineffectual complexities.
            # If localizing such argument (i.e., if such argument name is
            # unrelaxed), do so.
            # if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED}]}" ]] {

    #FUXME: How do variadic arguments semantically interact with default
    #values? Not terribly well, one should think. Perhaps forbid such
    #combination with a thrown exception, for the moment?
