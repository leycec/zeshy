#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *function prototype parsers* (i.e., functions parsing function
prototypes, typically as a prerequisite to processing function declarations).
/---

# ....................{ PARSERS                            }....................
#FIXME: Complete such documentation. Oh, cripes -- does this function need it.
#FIXME: If compiling an optimized zeshy build, disable argument count and
#argument validation below. Do *NOT* disable argument defaulting or
#localization, for obvious reasons.

:document_func <<'/---'
:void ::func_.stop[stdin: :string func_asciidoc]

Terminate the current function declaration, documenting such function with the
passed AsciiDoc-formatted help string. Specifically:

* Prefix such function's body by autogenerated code defaulting, localizing,
  and/or validating such function's arguments. This function generates such
  code by iteratively parsing every argument in the argument list specified by
  such function's prototype, previously declared by :func_().
/---
function ::func_.stop() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'

    #FIXME: We declare *ALOT* of locals here, thus allocating and deallocating
    #storage for all such locals on each function declaration. Arguably, such
    #locals would be better defined in @{compile} and then forcefully reset
    #here, a substantially faster operation than such large-scale reallocation.
    #This has a number of immediate beneficial side effects, including:
    #
    #* ${code_prefix} need no longer be declared as a global -- and, in fact,
    #  would require no refactoring whatsoever.
    #* In truth, we shouldn't even need to reset any such locals here. Why?
    #  Because *WE ALREADY DO SO* on each argument count iteration. Nice!
    #  * After examination, the only locals definitively requiring
    #    reinitialization are:
    #
    #    args_is_string_glob=0
    #    args_is_unlocalized=0
    #
    #* While reallocating scalar variables probably isn't terribly costing,
    #  reallocating the following three non-scalar maps almost certainly is.
    #  Avoiding such reallocation alone makes the effort worthwhile.
    #
    #That said, when we do so, we'll need to rename all such locals into
    #pseudo-globals: e.g., from
    #${arg_declarer_to_declarations} to
    #${ZESHY_FUNC_ARG_DECLARER_TO_DECLARATIONS__}. In short, prefix each local
    #name by "ZESHY_FUNC_" and suffix by "__".
    #FIXME: Indeed, the prior discussion applies equally well to the globals
    #declared below. Convert all such globals to similar locals; all told, this
    #should *DRAMATICALLY* reduce nonscalar variable reallocations, which is
    #(probably!) exceptionally critical to obtaining tolerable performance.

    (( ${+ZESHY_DECLARE_FUNC_PROTOTYPE__} +\
       ${+ZESHY_DECLARE_FUNC_ARGS__} +\
       ${+ZESHY_DECLARE_FUNC_ATTRS__} +\
       ${+ZESHY_DECLARE_FUNC_NAMES__} )) || :die\
       'Alias "}:func"() not preceded by function :func_() or alias ":func{"().'

    # Map from the name of an alias defining variables of a certain type
    # (e.g., ":string") to the space-delimited string assigning one local
    # variable to each argument of such type (e.g., 'my_string="${1}"').
    local -A arg_declarer_to_declarations

    # Map from the name of a function testing whether passed arguments are of a
    # certain type (e.g., :int.is()) to the space-delimited string expanding
    # all arguments of such type (e.g., '"${1}" "${@[2,-2]}" "${@[-1]}"').
    local -A arg_tester_to_expansions

    # Map from the name of a function testing whether the values of variables
    # referred to by passed arguments are of a certain type (e.g., :int.is())
    # to the space-delimited string expanding all such variables (e.g.,
    # '"${(P)1}" "${(P)@[-1]}"').
    #
    # Ideally, we would simply append such expansions to prior map local
    # ${arg_tester_to_expansions}. Before applying parameter expansion flag "(P)"
    # to arguments, however, we *MUST* validate such arguments to refer to
    # valid variables -- which ${arg_tester_to_expansions} already accomplishes.
    # Since zsh maps are inherently unordered, we cannot also validate such
    # variable values with the same map and expect the prior validation to be
    # deterministically performed before the latter. Separating the two into
    # two different map locals allows such validation to be ordered thusly.
    local -A arg_var_tester_to_expansions

    # Canonical string global ${ZPCRE_OP}, localized to avoid overwriting
    # either global or caller-specific versions of such variable.
    local ZPCRE_OP

    # Prototype-dependent code prepending such function's body, ensuring such
    # function defaults, localizes, and validates all prototyped arguments
    # *BEFORE* user-defined logic.
    local func_preamble

    #FIXME: Arguably, we've defined 4 redundant locals easily replaceable by a
    #single new string local entitled ${runnable_name}. These are:
    #
    #* ${func_callback}.
    #* ${arg_declarer}.
    #* ${arg_tester}.
    #* ${args_is_defaultable_tester}.

    # Name of the callback function such function is to be registered with if
    # such prototype specifies function attribute "callback" or the empty
    # string otherwise.
    local func_callback

    # Code defaulting defaultable arguments *NOT* passed to such function for
    # the current argument count.
    local code_args_default_current

    # Code localizing and/or validating arguments passed to such function for
    # all possible argument counts.
    local code_args_local_or_valid

    # Code localizing and/or validating arguments passed to such function for
    # the current argument count.
    local code_args_local_or_valid_current

    # Code localizing variadic arguments passed to such function by removing
    # all non-variadic arguments from the current argument list and hence
    # reducing such list to only variadic arguments. Since non-variadic
    # arguments may only be removed from such list *AFTER* localizing such
    # arguments, separate such code into different string locals.
    local code_args_local_variadic

    #FIXME: Refactor as a global constant declared above. Any other constants
    #to be extracted? Probably not, but worth a glimmer.
    #FIXME: Actually, see above! We simply need to shift all such local
    #variable declarations to @{compile} instead.

    # String prefixing each line of code. Since zsh internally reformats *ALL*
    # functions with proper indentation, omit indentation from such prefix.
    local code_prefix=$'\n'' '

    # Current argument name.
    local arg_name

    # String with which to expand the current argument if such argument is
    # expandable or the empty string otherwise. Possible values include:
    #
    # * A positive integer (e.g., the "1" in "${1}"), expanding all non-
    #   defaulted arguments preceding the first variadic argument (if any).
    # * A negative integer (e.g., the "@[-1]" in "${@[-1]}"), expanding all
    #   non-defaulted arguments preceding the first variadic argument (if any).
    # * A range of integers (e.g., "the "@[2,-2]" in "${@[2,-2]}"), expanding
    #   all variadic arguments.
    local arg_param

    # Current argument type and subtypes.
    local arg_type arg_subtype_local arg_subtype_major arg_subtype_minor

    # Current argument default value if any or the empty string otherwise.
    # By PCRE design, such value is guaranteed to be a zsh value (i.e., either
    # a single- or double-quoted string, integer, or float). Since the length
    # of such value is thus nonzero if defined or zero otherwise, such length
    # suffices to indicate whether a default value was specified. Hence, no
    # boolean ${arg_has_default_value} is required.
    local arg_default_value

    # Name of the alias localizing the current argument.
    local arg_declarer

    # Name of the function validating the current argument.
    local arg_tester

    # Space-delimited string of all expansions of arguments to be validated.
    local args_expansions

    # Parse the minimum and maximum number of arguments such function accepts
    # *BEFORE* parsing such arguments. All reasonably sane implementations of
    # argument parsing require such numbers (e.g., to reliably index and expand
    # optional and variadic arguments and arguments following such arguments).
    #
    # Superficially, this appears to necessitate two parse passes over the
    # argument list: the first pass obtaining such numbers and the second pass
    # actually parsing such arguments. In practice, however, careful choices in
    # runnable prototype syntax reduce the first pass to efficient string
    # munging operations requiring *NO* explicit iteration. Indeed, note that:
    #
    # * Omitting single- and double-quoted strings, each "," in an argument
    #   list suggests such function to accept one more mandatory argument.
    # * Omitting single- and double-quoted strings, each "?" and "=" in an
    #   argument list suggests such function to accept one more optional
    #   argument.
    # * Each mandatory argument increases the maximum number of arguments such
    #   function accepts by one.
    # * Each optional argument reduces the minimum number of arguments such
    #   function accepts by one.
    #
    # Efficiently determining such numbers thus reduces to counting the number
    # of unquoted ",", "?", and "=" characters in such argument list.
    #
    # Unfortunately, while such determination *IS* demonstrably efficient,
    # conforming to the algorithm implemented below requires reparsing the
    # argument list once for each optional (but *NOT* variadic) argument such
    # function accepts. (Why? Because each additional optional argument implies
    # such function to accept one additional possible number of arguments and
    # each such number necessitates distinct code validation and hence
    # algorithmic handling here.)
    #
    # Unfortunately, eliminating such reparsing would require persisting a list
    # of argument metadata during the first and only pass for subsequent lookup
    # (as detailed below), itself imposing non-negligible inefficiencies. The
    # question then reduces to: which is less efficient, reparsing each
    # argument multiple times or parsing such arguments into a list only once?
    #
    # To answer this question, consider the common case. If most or even many
    # zeshy functions accepted optional arguments and hence required such
    # reparsing, such reparsing would indeed be non-ideal. In practice, few
    # zeshy functions accept optional arguments (due to readability and
    # writability concerns associated with such arguments). Since the common
    # case imposes no argument reparsing, reparsing poses no imposition.
    #
    # Note that the above two parse passes are technically invertable by
    # parsing all arguments into a list of all argument in the first pass and
    # iterating over such list in the second. In practice, the infrastructure
    # required by such iteration imposes significant space and time costs.
    #
    # For example, consider the following "inverted" implementation:
    #
    #    local -a args_metadata
    #    while {
    #        pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
    #    } {
    #        ...
    #        args_metadata+=(
    #            "${arg_count_max}"
    #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE}]}"
    #            "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE}]}"
    #            "${arg_is_variadic}" )
    #    }
    #
    #    for arg_count ({${arg_count_min}..${arg_count_max}}) {
    #        ...
    #        for arg_index arg_subtype_local arg_is_absentable arg_is_variadic (
    #            "${args_metadata[@]}") {
    #            ...
    #        }
    #        ...
    #    }

    # Argument list with all single- and double-quoted strings removed,
    # preventing subsequent parsing from erroneously counting ignorable ",",
    # "?", and "=" characters in such strings. Since the syntax with which
    # single quotes are escaped in single-quoted strings and double quotes in
    # double-quoted strings differ, such glob matches such escapes differently.
    local arg_list_sans_quotes="${ZESHY_DECLARE_FUNC_ARGS__//(\'([^\']|\'\')#\'|\"(\\\"|[^\"])#\")}"

    # Maximum number of arguments (i.e., number of mandatory *AND* optional
    # arguments such function accepts), equivalent to the number of ","
    # characters in such argument list plus one. Such number excludes all
    # optional arguments in a variadic argument list except the first; since
    # there exists no maximum number of such optional arguments, such arguments
    # must be counted manually at function call time. Dismantled, this is:
    #
    # * "//[^,]##", removing all non-comma characters from such argument list.
    #   Commas unequivocally delimit arguments, permitting efficient counting.
    integer arg_count_max=$(( ${#${arg_list_sans_quotes//[^,]##}} + 1 ))

    # Minimum number of arguments (i.e., number of mandatory arguments such
    # function accepts), equivalent to the maximum number of arguments minus
    # the number of "?" and "=" characters in such argument list plus one.
    # Dismantled, this is:
    #
    # * "//[^?=]##", removing all characters except question marks and equal
    #   signs from such argument list. (Both unequivocally denote optional
    #   arguments, permitting efficient counting.)
    integer arg_count_min=$(( arg_count_max - ${#${arg_list_sans_quotes//[^?=]##}} ))

    # Current argument count *AFTER* adding all unpassed defaultable arguments
    # to the current argument list, initialized to their default values.
    integer arg_count_after_default

    # Number of optional arguments required by the current argument count
    # below. If such function accepts no optional arguments, this number
    # remains 0; else, this number varies between the maximum and minimum
    # number of arguments such function accepts.
    integer arg_count_optional

    # Index of the current argument in the argument list.
    integer arg_index

    # 1 if the current argument indirectly refers to another variable by name
    # and 0 otherwise.
    integer arg_is_indirect

    # 1 if the current argument is variadic and 0 otherwise.
    integer arg_is_variadic

    # 1 if a prior argument was variadic and 0 otherwise.
    integer arg_was_variadic

    # 1 if at least one argument is a string glob and 0 otherwise.
    integer args_is_glob

    # 1 if at least one non-variadic argument is unlocalized and 0 otherwise
    # (i.e., if all such arguments are localized).
    integer args_is_unlocalized

    # For efficiency, compile such PCRE. See for_string_text_matching_pcre:()
    # for further details.
    pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}"
    pcre_study
    # print -r "${ZESHY_DECLARE_FUNC_NAMES__[1]} args: ${ZESHY_DECLARE_FUNC_ARGS__}"

    # For each possible number of arguments between the minimum and maximum
    # established above, define code validating the types of all passed
    # arguments when the caller passes that number of arguments.
    #
    # By design, iterate from the minimum to maximum number of arguments rather
    # than the converse. Why? In a word: defaults. Unpassed defaultable
    # arguments must be assigned default values in a rightmost manner (i.e.,
    # the rightmost defaultable argument in a function prototype must be
    # defaulted first, then the next rightmost defaultable argument, and so on
    # until all unpassed defaultable arguments have been defaulted). By
    # iterating from the minimum to maximum number of arguments, we allow the
    # algorithm below to iteratively "mark" leftmost defaultable arguments as
    # passed until the current argument count indicates all such arguments to
    # have been passed, at which point all remaining defaultable arguments are
    # unpassed and hence assigned default values in a rightmost manner.
    integer arg_count
    for     arg_count ({${arg_count_min}..${arg_count_max}}) {
        #FIXME: Are all the following locals still requisite?

        # Clear such maps. See :clear_map() for further details.
        set -A arg_declarer_to_declarations
        set -A arg_tester_to_expansions

        # Revert local variables declared above specific to the following loop.
        arg_count_after_default=${arg_count}
        arg_count_optional=$(( arg_count - arg_count_min ))
        arg_index=0
        code_args_local_or_valid_current=
        code_args_default_current=
        code_args_local_variadic=

        # Parse each such argument into canonical list global ${match}, whose
        # indices we localize as human-readable integers above.
        ZPCRE_OP='0 0'
        while {
            pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${ZESHY_DECLARE_FUNC_ARGS__}"
        } {
            #FIXME: Are all the following locals still requisite?

            # For efficiency and readability, localize argument match metadata.
            arg_name=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME}]}
            arg_type=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE}]}
            arg_subtype_local=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_LOCAL}]}

            #FIXME: O.K.; if a default value is indeed set, we only ever expand
            #such value twice below for the current argument -- implying we
            #should excise such local and simply expand such string manually
            #wherever we require it.

            arg_default_value=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE}]}

            # Likewise, localize boolean-specific argument match metadata.  For
            # efficiency, initialize each such boolean to the length of the
            # corresponding match substring.
            #
            # While most such substrings are guaranteed to be of length either
            # 0 and 1 and hence strictly boolean, some such substrings *ALWAYS*
            # have length greater than 1 if matched and hence are *NOT*
            # strictly boolean. Happily, due to the way zsh interprets tests of
            # the form "(( arg_is_variadic ))", such caveat is ignorable.
            arg_is_indirect=${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_INDIRECT}]}
            arg_is_variadic=${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_VARIADIC}]-}

            # Increment the current argument index.
            arg_index+=1

            # If such argument is indirect (i.e., refers to a variable by
            # name), default such local subtype to ":string". (By PCRE design,
            # such subtype is guaranteed to be the empty string and hence
            # safely replaceable by a sane default.)
            if (( arg_is_indirect )) {
                #FIXME: If such argument defines *ANY* local subtype, throw an
                #exception before overwriting such subtype here.

                arg_subtype_local=':string'
            # Else, such argument is direct.
            #
            # If such argument is a string glob, notify the caller such
            # function accepts at least one such argument.
            } elif [[ "${arg_type}" == ':string+glob' ]] {
                args_is_glob=1
            # Else if such argument's local subtype is nonscalar (i.e., list or
            # map), throw an exception. By zsh mandate, arguments are
            # *ALWAYS* passed as untyped strings and hence cannot
            # encapsulate nonscalar data without indirection.
            } elif [[ "${arg_subtype_local}" == ':'('list'|'map') ]] {
                ::func_.die_of_cause_arg_type_direct\
                    'nonscalar, but zsh only supports scalar argument types'
            }

            # If such argument is *NOT* variadic...
            if (( ! arg_is_variadic )) {
                # If such argument does *NOT* follow a variadic argument, such
                # argument is reliably expandable by its positive index (i.e.,
                # relative to the beginning of the current argument list).
                if (( ! arg_was_variadic )) {
                    arg_param=${arg_index}
                # Else such argument follows a variadic argument and hence a
                # countably infinite number of arguments. In such case,
                # such argument is only reliably expandable by its negative
                # index (i.e., relative to the end of the current argument
                # list). Happily, the same index applies regardless of whether
                # such variadic argument was mandatory or optional.
                #
                # Since negative sign "-" conflicts with parameter expansion
                # syntax, negative indices may only be referenced by indexing
                # canonical list global ${@} or ${argv} with such index. For
                # brevity, we prefer the former. Since subsequent logic may
                # conditionally prefix such string with parameter expansion
                # flags (e.g., "(P)"), avoid delimiting such string with "${"
                # and "}" until *AFTER* performing such logic below.
                } else {
                    arg_param='@['$(( arg_index - arg_count_max - 1 ))']'
                }
            # Else such argument is variadic.
            } else {
                # If a prior argument is also variadic, throw an exception.
                # Such case implies such function to accept two or more
                # variadic argument lists of arbitrary count, implying there
                # exists no general means of deciding which such list a passed
                # string was intended to belong to.
                (( ! arg_was_variadic )) || ::func_.die_of_cause_arg_variadic\
                    'accepts two or more variadic arguments'

                # If another argument is optional, throw an exception. Such case
                # implies such function to accept one or more optional arguments
                # *AND* one or more variadic argument lists of arbitrary count,
                # implying there exists no general means of deciding which such
                # argument a passed string was intended to correspond to.
                #
                # Test such condition *AFTER* testing whether a prior argument is
                # variadic. If such function accepts an optional variadic argument
                # following a prior variadic argument, the prior exception is more
                # explanatory than this exception.
                #
                # The test that follows is an extreme optimization of:
                #
                #    if (( arg_count_max != arg_count_min )) && {
                #       (( ! arg_is_optional )) ||
                #       (( arg_count_max - arg_count_min > 1 )) } { ... }
                #
                # As such logic implies, testing whether such function accepts
                # at least one optional argument is insufficient. Such argument
                # could in fact be the current variadic argument, a valid edge
                # case we explicitly support. Hence, also test whether the
                # current variadic argument is optional. If so, test whether
                # any other argument is optional (as implied by the number of
                # optional arguments being greater than 1, thus ignoring the
                # current validly optional variadic argument).
                #
                # To understand why the test above reduces to the optimization
                # below, recall:
                #
                # * ${arg_is_optional} is 1 if the current variadic argument is
                #   optional and 0 otherwise.
                # * (( arg_count_max - arg_count_min )) is 1 if the current
                #   variadic argument is optional and 0 otherwise.
                # 
                # In either case, subtracting either from the other *ALWAYS*
                # results in 0; in any other case, the same subtraction *NEVER*
                # results in 0. Hence, such test suffices. (Convenient.)

                #FIXME: There's only one problem here: we longer define
                #${arg_is_optional}! We'll need, therefore, to refactor this
                #into... well, something. Fortunately, we shouldn't need to
                #account for relaxation; we *SHOULD*, however, need to detect
                #both absentable and defaultable syntax: e.g.,
                #
                # (( ! (\
                #     ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE}]} +\
                #     ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE}]})\
                #     - arg_count_max - arg_count_min )) ||
                #
                #Fairly intense, but the eyeballs suggest that should work.

                (( ! arg_is_optional - arg_count_max - arg_count_min )) ||
                    ::func_.die_of_cause_arg_variadic\
                        'accepts both optional and variadic arguments'

                # Notify subsequent parse iterations of such fact. For safety,
                # set such boolean *AFTER* all tests of such boolean above.
                arg_was_variadic=1

                # Expand such argument and all subsequent optional variadic
                # arguments with an argument range starting at the current
                # positive index and ending at the negative index of the last
                # such argument. See above for related logic.
                arg_param='@['${arg_index}','$(( arg_index - arg_count_max - 1 ))']'
            }

            # If such argument is defaultable and hence optional...
            if (( ${#arg_default_value} )) {
                # If the number of optional arguments the current argument
                # count accepts is positive, the current optional argument has
                # effectively been "passed". In such case, decrement such
                # number by 1, implying such count to now accept one less
                # optional argument. (The current optional argument "consumes"
                # one available optional argument "slot" under such count.)
                if (( arg_count_optional )) {
                    arg_count_optional+=-1
                # Else, such argument is unpassed.
                #
                # If defaulting such argument (i.e., if such default value is
                # unrelaxed), do so.
                } elif (( ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED}]} )) {
                    # Increment the current argument count to reflect the
                    # insertion of such argument's default value into the
                    # current argument list.
                    arg_count_after_default+=1

                    # If such argument is the last explicit argument such
                    # function accepts (ignoring all subsequent optional
                    # variadic list arguments), efficiently append such
                    # argument's default value to the current argument list.
                    if (( arg_index == arg_count_max )) {
                        code_args_default_current+='argv+='${arg_default_value}
                    # Else if such argument is the first explicit argument such
                    # function accepts, inefficiently replace the current
                    # argument list with one in which the indices of all other
                    # explicit arguments are increased by 1 and the first index
                    # of such list is set to such argument's default value.
                    } elif (( arg_index == 1 )) {
                        code_args_default_current+='argv=( '${arg_default_value}' "${@}" )'
                    # Else such argument is neither the first or last explicit
                    # argument such function accepts and hence is both preceded
                    # *AND* succeeded by at least one such argument. In such
                    # case, an efficient alternative to replacing the current
                    # argument list presents itself: append such argument's
                    # default value to the prior argument. (Yes, this works.)
                    } else {
                        code_args_default_current+='argv['$(( arg_index - 1 ))']+='${arg_default_value}
                    }
                # Else, such unpassed argument is undefaulted and hence absent.
                } else {
                    # Absent arguments are *NOT* in the current argument list
                    # and hence cannot be indexed. Preserve the current
                    # argument index for the next argument.
                    arg_index+=-1

                    # Skip to the next argument.
                    continue
                }
            # Else if such argument is absentable and hence also optional...
            } elif (( ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE}]} )) {
                # If such argument is passed, handle such case. See above.
                if (( arg_count_optional )) {
                    arg_count_optional+=-1
                # Else, such argument is unpassed. See above.
                } else {
                    arg_index+=-1
                    continue
                }
            }

            # If localizing such argument, do so.
            if (( ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED}]} )) {
                # If such argument is *NOT* variadic, localize such argument in
                # the expected way (i.e., via a local scalar variable).
                if (( ! arg_is_variadic )) {
                    # Note that if such argument is indirect, prior logic ensured
                    # such argument's local subtype to be ":string".

                    # If such subtype is *NOT* the name of an existing alias, throw
                    # an exception. See :is_alias_simple() for details.
                    (( ${+aliases[${arg_subtype_local}]} )) ||
                        ::func_.die_of_cause_arg_type\
                            'local subtype '${arg_subtype_local}' unrecognized (i.e., alias '${arg_subtype_local}'() localizing such argument undefined)'

                    # Map such subtype to a definition assigning such argument
                    # value to a local variable of the same name.
                    arg_declarer_to_declarations[${arg_subtype_local}]+=' '${arg_name}'="${'${arg_param}'}"'
                # Else such argument is variadic, signifying an arbitrary
                # number of such arguments. Since such arguments are
                # unavailable until function call time and hence *NOT*
                # localizable at function definition time (i.e., now) as a
                # hard-coded set of local variables, localize such arguments by
                # reducing the current argument list to only such arguments.
                } else {
                    # If such argument is *NOT* the first argument, remove all
                    # prior arguments from the current argument list. Since zsh
                    # offers a simple builtin for removing prefixing but *NOT*
                    # suffixing arguments, such code is simpler than below.
                    if (( arg_index != 1 )) {
                        code_args_local_variadic+=${code_prefix}'shift '$(( arg_index - 1 ))
                    }

                    # If such argument is *NOT* the last argument, remove all
                    # subsequent arguments from the current argument list.
                    if (( arg_index != arg_count_max )) {
                        # If such argument is the second-to-last argument,
                        # remove only the last argument. See pop_arg().
                        if (( arg_index + 1 == arg_count_max )) {
                            code_args_local_variadic+=${code_prefix}'argv[-1]=()'
                        # Else, such argument precedes the second-to-last
                        # argument.  Remove all subsequent arguments with
                        # ranged indices. See shift_args_2().
                        } else {
                            code_args_local_variadic+=${code_prefix}'argv['$(( arg_index - arg_count_max ))',-1]=()'
                        }
                    }
                }
            # Else, note at least one argument to be unlocalized.
            } else {
                args_is_unlocalized=1
            }

            # If validating such argument (i.e., if such argument type is
            # unrelaxed and unequal to ":string"), do so. Since *ALL* function
            # arguments are technically untyped scalars and hence strings,
            # arguments of type ":string" are *ALWAYS* inherently valid.
            if (( ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED}]} )) &&
               [[ "${arg_type}" != ':string' ]] {
                # Such argument's major and minor validation-specific subtypes.
                arg_subtype_major=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}
                arg_subtype_minor=${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}

                # If such argument is indirect, such subtype applies to
                # the value of the variable such argument refers to rather
                # than such variable's type. In contrast to the customary
                # case (in which we validate only such argument's value),
                # this necessitates we validate both such argument's value
                # (i.e., such variable's type) *AND* such variable's value.
                #
                # There exist two principal means of doing so:
                #
                # 1. Create one new function
                #    "var.is_${subtype_major}_${subtype_minor}" for each
                #    existing function
                #    "${subtype_major}.is_${subtype_minor}" (e.g.,
                #    a new function var.is_int_positive() corresponding to
                #    existing function int.is_positive()). This has the
                #    minor advantage of requiring no changes to the logic
                #    below, but has the uncomfortably distinct disadvantage
                #    of effectively doubling the number of tester
                #    functions in the core zeshy codebase.
                # 2. Call the existing function
                #    "${subtype_major}.is_${subtype_minor}" with such
                #    variable's value by directly passing such argument
                #    expanded by parameter expansion flag "(P)". This has
                #    the minor disadvantage of requiring we duplicate logic
                #    validating such argument's value below to also
                #    validating such variable's value here, but the
                #    comfortably distinct advantage of requiring no
                #    significant changes to the core zeshy codebase.
                #
                # Three pence for the grizzly gentleman in the well-bearded
                # coat if you can guess which approach we adopted.
                #
                # For simplicity, validate such variable's value *BEFORE*
                # validating such argument's value (i.e., such variable's
                # type). While such validation could be performed in either
                # order, this order simplifies such logic substantially.
                if (( arg_is_indirect )) {
                    # Name of the function validating such variable's value.
                    arg_tester=':'${arg_subtype_major]}'.is_'

                    # If such argument has a minor subtype, suffix such function.
                    [[ -z "${arg_subtype_minor}" ]] ||
                        arg_tester+='_'${arg_subtype_minor}

                    # If such function does *NOT* exist, throw an
                    # exception. For efficiency, inline such test. See
                    # :func.is() for further details.
                    (( ${+functions[${arg_tester}]} )) ||
                        ::func_.die_of_cause_arg_type\
                            'unvalidatable (i.e., function '${arg_tester}'() validating variables referred to by such argument undefined)'

                    # Map such function name to such variable expansion.
                    #
                    # If such argument is variadic, such argument implies
                    # an indirectly subtyped variadic argument list (e.g.,
                    # as ":void func(:string:int+nonzero int1, ...)").
                    # Unfortunately, such edge case provokes a subtle
                    # contradiction:
                    #
                    # * Expanding variadic arguments requires use of ranged
                    #   indices ("${@[2,-2]}").
                    # * Expanding indirect arguments requires use of
                    #   parameter expansion flag "(P)" ("${(P)2}").

                    # * Parameter expansion flag "(P)" only non-
                    #   erroneously applies to single rather than ranged
                    #   expansions (e.g., to "${(P)2}" rather than
                    #   "${(P)@[2,-2]}"), Technically, zsh *DOES* silently
                    #   permit "(P)" to be used in conjunction with ranged
                    #   expansions, but in such case only expands to the
                    #   value of the variable referred to by the first such
                    #   index -- which, ultimately, is of little use.
                    #
                    # Syllogism (i.e., logic puzzle) enthusiasts will be quick
                    # to note the implication above. Happily, such conundrum is
                    # efficiently correctable by detecting such edge case and,
                    # in such case, performing global string replacement to
                    # iteratively replace all argument values in such range by
                    # the values of the variables the former refer to instead
                    # (e.g., expanding the indices ranging @[2,-2] as
                    # "${@[2,-2]//(#m)*/${(P)MATCH}}" rather than
                    # "${(P)@[2,-2]}"). Dismantled, this is:
                    #
                    # * "(#m)", enabling canonical string global ${MATCH}.
                    # * "*", capturing the name of the variable referred to
                    #   by the current argument to ${MATCH}.
                    # * "${(P)MATCH}", expanding to such variable's value.
                    if (( arg_is_variadic )) {
                        arg_var_tester_to_expansions[${arg_tester}]+=' "${(P)'${arg_param}'//(#m)*/${(P)MATCH}}"'
                    # Else, such argument is non-variadic and hence refers to a
                    # single variable. In such case, parameter expansion flag
                    # "(P)" may be applied per usual.
                    } else {
                        arg_var_tester_to_expansions[${arg_tester}]+=' "${(P)'${arg_param}'}"'
                    }
                }

                # Now validate such argument's value.
                #
                # If such argument has a major subtype, verify such subtype.
                #
                # Specifically, if such argument is *NOT* indirect but such
                # major subtype is "var", such argument is actually indirect.
                # While indirection is usually specified by type indirective
                # "*", type prefix ":string/var" also suffices.
                #
                # If such argument is additionally *NOT* locally declared as a
                # string, throw an exception. While integer arguments could
                # technically refer to variables whose names are themselves
                # integers, such edge-case seems both implausible and fragile.
                if [[ -n "${arg_subtype_major}" ]] {
                    if [[ "${arg_subtype_major}" == 'var' &&
                          "${arg_subtype_local}" != ':string' ]] {
                        ::func_.die_of_cause_arg_type_direct\
                            'refers to variables by name but not locally declared as a string'
                    }
                # Else, such argument has no major subtype. Since such subtype
                # is required for validation...
                } elif {
                    # ...if such argument is indirect, convert such major and
                    # minor subtypes to their standard format for direct
                    # arguments (e.g., from "*:int" to ":string/var+int"),
                    # simplifying validation below.
                    if (( arg_is_indirect )) {
                        arg_subtype_minor=${arg_subtype_major}
                        arg_subtype_major='var'
                    # ...else, default such major subtype to such local
                    # subtype, stripped of ":" prefix if any.
                    } else {
                        arg_subtype_major=${arg_subtype_local#:}
                    }
                }

                # Name of the function validating such argument's value.
                arg_tester=':'${arg_subtype_major}'.is'

                # If such argument has a minor subtype, suffix such function.
                [[ -z "${arg_subtype_minor}" ]] ||
                    arg_tester+='_'${arg_subtype_minor}

                # If such function does *NOT* exist, throw an exception.  For
                # efficiency, inline such test. See :func.is() for details.
                (( ${+functions[${arg_tester}]} )) ||
                    ::func_.die_of_cause_arg_type\
                        'unvalidatable (i.e., function '${arg_tester}'() validating such argument undefined)'

                # Map such function name to such argument's expansion.
                arg_tester_to_expansions[${arg_tester}]+=' "${'${arg_param}'}"'
            }
        }

        # If defaulting at least one argument for the current argument count,
        # do so. Since subsequent localization and validation code assumes all
        # such arguments to already have been defaulted, guarantee this by
        # prefixing such function's preamble by such defaults.
        if [[ -n "${code_args_default_current}" ]] {
            # If at least one argument has been defaulted, continue the if
            # conditional doing so with a new branch.
            if [[ -n "${func_preamble}" ]] {
                func_preamble+=' el'
            }

            # Default such arguments only for the current argument count.
            func_preamble+='if (( # == '${arg_count}' )) {'${code_args_default_current}${code_prefix}'}'
        }

        # For efficiency, combine the following two related iterations:
        #
        # * For each function name and corresponding string expanding all
        #   arguments validated by calling such function (i.e., key-value
        #   pairs of map ${arg_tester_to_expansions}), do so.
        # * For each function name and corresponding string expanding all
        #   variables referred to by arguments and validated by calling
        #   such function (i.e., key-value pairs of map
        #   ${arg_var_tester_to_expansions}), do so. While the first iteration
        #   validates such variables as existing and of the expected type,
        #   this iteration validates the values such variables expand to
        #   and hence must be performed *AFTER* the first iteration.
        for arg_tester args_expansions (
            "${(kv@)arg_tester_to_expansions}"
            "${(kv@)arg_var_tester_to_expansions}") {
            code_args_local_or_valid_current+=${code_prefix}${arg_tester}${args_expansions}' || ::func.die_unless_arg_values_pass_tester "${@}" '''${args_expansions}''' '${(q)arg_tester}
        }

        # For each alias name and corresponding string localizing arguments
        # into locals declared by expanding such alias, do so. By design,
        # such declarations consist only of simple string assignments
        # *ALWAYS* succeeding and hence requiring no exception handling
        # (e.g., 'my_var="${1}"'). For efficiency, iterate only by keys
        # (rather than by both keys and values).
        for arg_declarer ("${(k@)arg_declarer_to_declarations}") {
            code_args_local_or_valid_current+=${code_prefix}${arg_declarer}${arg_declarer_to_declarations[${arg_declarer}]}
        }

        # If localizing a variadic argument, do so *AFTER* localizing
        # non-variadic arguments. Since localizing the former removes *ALL* of
        # the latter from the current argument list, only do so *AFTER* all of
        # the latter have been copied from such list into local variables.
        if [[ -n "${code_args_local_variadic}" ]] {
            # If at least one non-variadic argument is unlocalized, throw
            # an exception. Removing such arguments from the current argument
            # list would prevent subsequent code from expanding such arguments.
            (( ! args_is_unlocalized )) || ::func_.die_of_cause\
                'variadic argument unlocalizable due to unlocalized non-variadic arguments; consider either prefixing such variadic argument name by "`" or removing such prefix from all non-variadic argument names'

            # Localize such variadic argument.
            code_args_local_or_valid_current+=${code_args_local_variadic}
        }

        # If localizing and/or validating at least one argument, do so.
        if [[ -n "${code_args_local_or_valid_current}" ]] {
            #FIXME: Insufficient test. To be honest, we may have no means of
            #reliably testing this at the moment. Such test needs to treat
            #unrelaxed defaultable arguments as mandatory rather than optional;
            #such arguments will have been defaulted if unpassed and hence
            #guaranteed to be passed, ensuring such arguments to be mandatory.

            # If such function accepts no optional arguments, such function
            # *ALWAYS* accepts the same number of arguments, implying such code
            # to *NOT* need embedding in an if conditional testing such number.
            if (( arg_count_min == arg_count_max )) {
                code_args_local_or_valid+=${code_args_local_or_valid_current}
            # Else such function accepts at least one optional argument and
            # hence accepts a variable number of arguments, implying such code
            # to need embedding in an if conditional testing such number.
            } else {
                # If the current argument count is the maximum, terminate the
                # current if conditional with a last branch. Since the prior branch
                # of such conditional already ended on "}", omit such prefix here.
                if (( arg_count_after_default == arg_count_max )) {
                    code_args_local_or_valid+=' else'
                # Else the current argument count is less than the maximum.
                } else {
                    # If the current argument count is the minimum, initiate a
                    # new if conditional. Curiously, note that such test
                    # implicitly accounts for variadicity. Why? Consider. If
                    # one argument is variadic, then by the prior constraints
                    # such argument must also be the *ONLY* optional argument
                    # such function accepts. There then exist only two cases
                    # with respect to the number of arguments such function
                    # accepts. Either such function is passed:
                    #
                    # 1. The minimum number of arguments and hence *NOT* passed
                    #    such optional variadic argument, which the branch
                    #    below suffices to test.
                    # 2. The maximum number of non-variadic arguments and hence
                    #    passed at least such optional variadic argument, which
                    #    the branch above suffices to test.
                    if (( arg_count_after_default == arg_count_min )) {
                        code_args_local_or_valid+=${code_prefix}
                    # Else the current argument count is more than the minimum.
                    # Continue the current if conditional with a new branch.
                    } else {
                        code_args_local_or_valid+=' el'
                    }

                    # Test such branch.
                    code_args_local_or_valid+='if (( # == '${arg_count_after_default}' ))'
                }

                # Implement such branch's body.
                code_args_local_or_valid+=' {'${code_args_local_or_valid_current}${code_prefix}'}'
            }
        }
    }

    # If defaulting arguments, customize such code for interpolation below.
    if [[ -n "${func_preamble}" ]] {
        # Name of the alias or function testing at runtime whether the current
        # function call conditionally accepts unpassed defaultable arguments
        # (e.g., only when called directly from the command line) or the empty
        # string if such function *ALWAYS* accepts such arguments.
        local args_is_defaultable_tester=${ZESHY_DECLARE_FUNC_ATTRS__[default_args_if]-}

        # If only conditionally accepting such arguments, do so only when such
        # condition succeeds at runtime.
        if [[ "${args_is_defaultable_tester}" ]] {
            # If such alias or function does *NOT* exist, throw an exception.
            # See :alias_simple.is() and :func.is().
            (( ${+aliases[${args_is_defaultable_tester}]} +
               ${+functions[${args_is_defaultable_tester}]} )) ||
               ::func_.die_of_cause 'attribute "default_args_if" alias or function '${args_is_defaultable_tester}'() undefined'

            # Default such arguments only if such condition succeeds.
            func_preamble='if { '${args_is_defaultable_tester}' } {'${code_prefix}${func_preamble}${code_prefix}'}'
        }

        # Delimit such code from subsequent code.
        func_preamble+=${code_prefix}
    }

    # Validate the number of arguments passed to such function.
    #
    # If such function is variadic, such function accepts a countably
    # infinite number of arguments only bounded below by such minimum.
    if (( arg_was_variadic )) {
        func_preamble+=${code_prefix}'(( # >= '${arg_count_min}' )) || ::func.die_of_arg_count_not_exceeding "${@}" '${arg_count_min}
    # Else, such function is non-variadic, in which case such function
    # accepts a number of arguments bounded by such minimum and maximum.
    #
    # If such minimum and maximum are equal, simplify such test as such.
    } elif (( arg_count_min == arg_count_max )) {
        func_preamble+=${code_prefix}'(( # == '${arg_count_min}' )) || ::func.die_of_arg_count_not_equaling "${@}" '${arg_count_min}
    # Else, such minimum and maximum are unequal.
    } else {
        func_preamble+=${code_prefix}'(( '${arg_count_min}' <= # && # <= '${arg_count_max}' )) || ::func.die_of_arg_count_not_ranging "${@}" '${arg_count_min}' '${arg_count_max}
    }

    # If localizing and/or validating arguments, do so.
    if [[ -n "${code_args_local_or_valid}" ]] {
        func_preamble+=${code_args_local_or_valid}
    }

    # If performing any such code, delimit such code from subsequent
    # user-defined code.
    if [[ -n "${func_preamble}" ]] {
        func_preamble+=${code_prefix}
    }
    print -r "${func_name} preamble: ${func_preamble}"$'\n\n'

    #FIXME: Awesome commentary. So awesome, in fact, that it absolutely belongs
    #in the formal documentation for this function. Please shift us there.

    # Declare and redefine each such function to begin with such preamble.
    # Alias :func{() previously defined such function, internally stored by zsh
    # in pre-parsed form (i.e., *NOT* stripped of all ignorable lexical
    # constructs including comments and negligible whitespace). Hence, such
    # definitions preserve comments and negligible whitespace. As we shall see,
    # this is *NOT* a good thing.
    #
    # Redefining such function here reduces such function to its post-parsed
    # form (i.e., stripped of all ignorable lexical constructs).
    #
    # Hence, functions defined by :func_() fundamentally differ to
    # those defined by builtin function(). The former omits all ignorable
    # lexical constructs internally preserved by the latter, a seemingly
    # trivial fact that nonetheless provokes non-trivial side effects: e.g.,
    #
    # * While the pre- and post-parsed definitions for functions defined by
    #   builtin function() almost always differ, the pre- and post-parsed
    #   definitions for functions defined by this function are guaranteed to
    #   *NEVER* differ.
    # * Canonical integer global ${LINENO} corresponds to the current line
    #   number of the current function or script's pre-parsed definition.
    # * Similarly, line numbers suffixing canonical list global ${functrace}
    #   correspond to the line number of the listed function or script's
    #   pre-parsed definition on which the "next" function or script in the
    #   call stack was called.
    # * There currently exists no generally reliably means of accessing the
    #   pre-parsed definition of *ANY* function or script -- particularly if
    #   such function derives from a digest file, as all zeshy functions do.
    # * The prior observations directly imply that the definitions of functions
    #   defined by this function (but *NOT* by builtin function()) may be
    #   correlated with line numbers: both the current line number and the line
    #   numbers recorded on the call stack (e.g., due to thrown exceptions).
    # * The prior implication itself implies that functions defined by this
    #   function (but *NOT* by builtin function()) may support otherwise
    #   unsupportable functionality, including:
    #   * On detecting an uncaught exception, printing the lines of the
    #     function responsible for initially throwing such exception.
    local func_name
    for   func_name ("${ZESHY_DECLARE_FUNC_NAMES__[@]}") {
        # Redefine such function in a manner preserving post-parsed form (i.e.,
        # containing no comments or negligible whitespace).
        functions[${func_name}]=${func_preamble}${functions[${func_name}]}

        # If such function accepts at least one string glob argument, prefix
        # all calls to such function by "noglob" to prevent zsh from expanding
        # such arguments as file globs. To do so, define a simple alias of the
        # same name shadowing all calls to such function in such manner.
        if (( args_is_glob )) {
            :define_alias_simple "${func_name}" "noglob ${(q)func_name}"
        }

        # If such function is to be called back (i.e., called on some
        # subsequent event), register such callback.
        if (( ${+ZESHY_DECLARE_FUNC_ATTRS__[callback]} )) {
            func_callback='func.callback_'${ZESHY_DECLARE_FUNC_ATTRS__[callback]}
            :func.die_unless "${func_callback}"
            "${func_callback}" "${func_name}"
        }

        #FIXME: This is fairly lame. See @{*-alias} for commentary.

        # Add such function to the current parcel.
        add_parcel_function "${ZESHY_PARCEL_NAME}" "${func_name}"
    }

    # Document such functions with such documentation *AFTER* successfully
    # defining such functions above.
    ::document_func_with_prototype,stdin_if_found_or_noop\
        "${ZESHY_DECLARE_FUNC_NAMES__[@]}"\
        "${ZESHY_DECLARE_FUNC_PROTOTYPE__}"

    # Undefine all such globals, ensuring subsequent calls to this function
    # *NOT* preceded by calls to :func_() throw exceptions.
    unset\
        ZESHY_DECLARE_FUNC_PROTOTYPE__\
        ZESHY_DECLARE_FUNC_ATTRS__\
        ZESHY_DECLARE_FUNC_NAMES__\
        ZESHY_DECLARE_FUNC_ARGS__
}

# --------------------( WASTELANDS                         )--------------------
    #FUXME: Such boolean is excisable by the same approach with which we
    #obsoleted ${arg_was_optional}: namely, globbing the raw argument list for
    #a substring matching ",[ $'\n']#...". Indeed, since we only need to detect
    #the existence of any such substring without regard to how many such
    #substrings exist, no counting is required, reducing such operation to an
    #efficient glob. Right. While this is almost certainly the way to go, give
    #the algorithm a once-over below to confirm intuitions.
    #FUXME: Oh, wait. Yes, we *DO* need to count such instances. O.K.; just
    #stick with the current implementation, one should think.

    # 1 if the current argument will be localized by such function's preamble
    # or 0 otherwise. Since all arguments are localized by default, this is
    # only 0 for arguments with explicitly relaxed names.
    # integer arg_is_localized

    #         # Localize such argument *UNLESS* such name is relaxed.
    #         arg_is_localized=$((
    #             ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED}]} ))

    # 1 if the current argument will be validated by such function's preamble
    # or 0 otherwise. Since all arguments are validated by default, this is
    # only 0 for arguments with explicitly relaxed types *OR* type ":string"
    # (which by definition are *ALWAYS* valid).
    # integer arg_is_validated

            # Validate such argument *UNLESS* such type is relaxed.
            # arg_is_validated=$((
            #     ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED}]} ))

    # 1 if the current argument is absentable and 0 otherwise.
    # integer arg_is_absentable
            # arg_is_absentable=${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE}]}

    # 1 if at least one argument is optional and 0 otherwise.
    # integer args_is_optional=$(( arg_count_min != arg_count_max ))

    # If such such function accepts at least one optional argument...
    # if (( args_is_optional )) {
    #     # If such function only conditionally defaults arguments (e.g., only
    #     # when called directly from the command line), ensure this.
    #     if (( ${+ZESHY_DECLARE_FUNC_ATTRS__[default_args_if]} )) {
    #         # Name of the alias or function reporting success when such
    #         # function accepts default arguments.
    #         args_is_defaultable_tester=${ZESHY_DECLARE_FUNC_ATTRS__[default_args_if]}

    #         # If such alias or function does *NOT* exist, throw an exception.
    #         # See :alias_simple.is() and :func.is() for further details.
    #         (( ${+aliases[${args_is_defaultable_tester}]} +
    #            ${+functions[${args_is_defaultable_tester}]} )) ||
    #            ::func_.die_of_cause 'attribute "default_args_if" alias or function '${args_is_defaultable_tester}'() undefined'
    #     }
    # }

    #That said, that *IS* somewhat more
    #difficult to reliably and efficiently glob for. Contemplate.
    #FUXME: The following two locals are only expanded in one place each and
    #hence *SHOULD* be replaceable by in-place expansions. However, will use of
    #"#" complicate matters here?

    # # Argument list reduced to all remaining "," characters, whose string
    # # length plus one is the maximum number of arguments such function accepts.
    # local arg_list_commas="${arg_list_sans_quotes//[^,]##}"

    # # Argument list reduced to all remaining "?" and "=" characters, whose
    # # string length subtracted from the prior maximum is the minimum number of
    # # arguments such function accepts.
    # local arg_list_erotemes_and_equals="${arg_list_sans_quotes//[^?=]##}"

    # # Maximum number of arguments (i.e., number of mandatory *AND* optional
    # # arguments such function accepts).
    # integer arg_count_max=$(( ${#arg_list_commas} + 1 ))

    # # Minimum number of arguments (i.e., number of mandatory arguments such
    # # function accepts).
    # integer arg_count_min=$(( arg_count_max - ${#arg_list_erotemes_and_equals} ))

    # If any such global is either undefined or of unexpected type, this call
    # was *NOT* preceded by a call to ::func_.start() - so throw an exception.
    # :var.die_unless_type_string ZESHY_DECLARE_FUNC_PROTOTYPE__ ZESHY_DECLARE_FUNC_ARGS__
    # :var.die_unless_type_map  ZESHY_DECLARE_FUNC_ATTRS__
    # :var.die_unless_type_list ZESHY_DECLARE_FUNC_NAMES__

        # If such function is attributed, handle such attributes.
        # if (( ${#ZESHY_DECLARE_FUNC_ATTRS__} )) {

    # * Such argument's name (e.g., the "zod" in "${zod}"), expanding all
    #   defaulted, localized arguments.
    #
    # Since non-localized arguments are only validatable by expanding such
    # arguments by their index in the argument list, we prefer to expand all
    # arguments by their index if present in such list. This includes all
    # passed arguments but *NOT* unpassed defaulted arguments, which being
    # unpassed are only expandable by their local variable name if localized.

    # will subsequently throw
    # an exception if called prior to :func_().

#, set by the call to ::func_.parse_args() below
 # See :var.die_unless_type_string(), :var.die_unless_type_map(), and
    # :var.die_unless_type_list() for further details.
# function ::func_.parse_args() {
    # # Validate sanity.
    # (( ! # )) || :die 'Expected no arguments.'

#FUXME: Shift ::func_.stop() here; then, merge ::func_.parse_args() into such
#function. Maintaining an artificial distinction between the two functions is
#patently nonsensical.

    #FUXME: Can we not simply increment ${arg_count} instead? That could be
    #mildly dangerous, of course, so examine the codebase carefully.

    #FUXME: In hindsight, significant overkill. Since zsh output already
    #indents function bodies as desired, it's only essential that we prefix
    #each line as follows to ensure proper lexical behavior:
    #
    # local code_indent=' '
    # local code_indent_newlined=$'\n'' '
    #
    #And that's it. Replace all ${code_indent*} locals below with the
    #dramatically simpler pair above.

    # # Single level of indentation.
    # local code_indent=$'\t'

    # # String prefixing each line of such code with indentation appropriate to
    # # the current outermost indentation level (i.e., of code nested directly in
    # # the current function body).
    # local code_indent_outer=$'\n'${code_indent}

    # # String prefixing each line of such code with indentation appropriate to
    # # the current next-most-outermost indentation level (i.e., of code nested
    # # directly in code nested directly in the current function body).
    # local code_indent_inner=${code_indent_outer}${code_indent}

    # # String prefixing each line of such code with indentation appropriate to
    # # the current innermost indentation level (i.e., of code nested directly in
    # # the current if conditional of the current function body).
    # local code_indent_inner_if_nested_or_outer=${code_indent_outer}

            # If no argument has yet been defaulted, open a new if conditional.
            # if [[ -z "${func_preamble}" ]] {
            #     #FUXME: Inefficient. Just preinitialize
            #     func_preamble=${code_prefix}

        # Since all localization and validation code will be embedded in
        # if conditionals (rather than directly within such function's body),
        # prefix each line of such code by an additional indentation level.
        # code_indent_inner_if_nested_or_outer+=${code_indent}

    #FUXME: Rename -- say, to ${arg_parameter}.
        #FUXME: Obsolete. Excise.

    #     # If localizing and/or validating at least one such argument, do
    #     # so. Technically, there exist three possible map locals to be tested
    #     # here: the two tested below and ${arg_var_tester_to_expansions}, *NOT*
    #     # tested below. Since prior logic guarantees ${arg_tester_to_expansions} to
    #     # be nonempty whenever ${arg_var_tester_to_expansions} is nonempty,
    #     # however, the latter need *NOT* be explicitly tested here.
    #     if (( ${#arg_declarer_to_declarations} +\
    #           ${#arg_tester_to_expansions} +\
    #           ${#code_args_local_variadic} )) {
    #         # If such function accepts at least one optional argument, subsequent
    #         # argument type validation assumes such function's caller passed the
    #         # current number of arguments. Prefix such validation by an if
    #         # conditional guaranteeing such assumption.
    #         if (( args_is_optional )) {
    #             # Indent the following if conditional.
    #             code_args_local_or_valid_current+=${code_indent_outer}

    #             # If parsing the maximum number of arguments, end the current if
    #             # conditional. Since the prior branch of such conditional
    #             # already ended on "}", omit such delimiter here. Since the
    #             # maximum argument count allows no optional and hence no
    #             # default arguments, do *NOT* test
    #             # ${args_is_defaultable_tester} as below.
    #             if (( arg_count_after_default == arg_count_max )) {
    #                 code_args_local_or_valid_current+=' else {'
    #             # Else we are parsing less than such number of arguments.
    #             } else {
    #                 # If parsing more than the minimum number of arguments,
    #                 # continue the current if conditional with a new branch.
    #                 #
    #                 # Curiously, note that such test implicitly accounts for
    #                 # variadicity. Why? Consider. If one argument is variadic,
    #                 # then by the prior constraints such argument must also be
    #                 # the *ONLY* optional argument such function accepts.
    #                 # There then exist only two cases with respect to the
    #                 # number of arguments such function accepts. Either such
    #                 # function is passed:
    #                 #
    #                 # 1. The minimum number of arguments and hence *NOT* passed
    #                 #    such optional variadic argument, which the branch
    #                 #    below suffices to test.
    #                 # 2. The maximum number of non-variadic arguments and hence
    #                 #    passed at least such optional variadic argument, which
    #                 #    the branch above suffices to test.
    #                 if (( arg_count_after_default > arg_count_min )) {
    #                     code_args_local_or_valid_current+=' el'
    #                 }

    #                 # Complete the current branch of such if conditional.
    #                 code_args_local_or_valid_current+='if (( # == '${arg_count_after_default}' )) {'
    #             }
    #         }

    #         # For efficiency, combine the following two related iterations:
    #         #
    #         # * For each function name and corresponding string expanding all
    #         #   arguments validated by calling such function (i.e., key-value
    #         #   pairs of map ${arg_tester_to_expansions}), do so.
    #         # * For each function name and corresponding string expanding all
    #         #   variables referred to by arguments and validated by calling
    #         #   such function (i.e., key-value pairs of map
    #         #   ${arg_var_tester_to_expansions}), do so. While the first iteration
    #         #   validates such variables as existing and of the expected type,
    #         #   this iteration validates the values such variables expand to
    #         #   and hence must be performed *AFTER* the first iteration.
    #         for arg_tester args_expansions (
    #             "${(kv@)arg_tester_to_expansions}"
    #             "${(kv@)arg_var_tester_to_expansions}") {
    #             code_args_local_or_valid+=${code_indent_inner_if_nested_or_outer}${arg_tester}${args_expansions}' || ::func.die_unless_arg_values_pass_tester "${@}" '''${args_expansions}''' '${(q)arg_tester}
    #         }

    #         # For each alias name and corresponding string localizing arguments
    #         # into locals declared by expanding such alias, do so. By design,
    #         # such declarations consist only of simple string assignments
    #         # *ALWAYS* succeeding and hence requiring no exception handling
    #         # (e.g., 'my_var="${1}"'). For efficiency, iterate only by keys
    #         # (rather than by both keys and values).
    #         for arg_declarer ("${(k@)arg_declarer_to_declarations}") {
    #             code_args_local_or_valid+=${code_indent_inner_if_nested_or_outer}${arg_declarer}${arg_declarer_to_declarations[${arg_declarer}]}
    #         }

    #         # If localizing a variadic argument, do so.
    #         if [[ -n "${code_args_local_variadic}" ]] {
    #             # If at least one non-variadic argument is unlocalized, throw
    #             # an exception. Since variadic arguments are localized by
    #             # removing *ALL* non-variadic arguments from the current
    #             # argument list, doing so when at least one such argument is
    #             # unlocalized and hence uncopied into a local variable would
    #             # prevent subsequent code from accessing such argument.
    #             (( ! args_is_unlocalized )) || ::func_.die_of_cause\
    #                 'variadic argument unlocalizable due to unlocalized non-variadic arguments; consider either prefixing such variadic argument name by "`" or removing such prefix from all non-variadic argument names'

    #             # Localize such variadic argument.
    #             code_args_local_or_valid+=${code_args_local_variadic}
    #         }

    #         # If such function accepts at least one optional argument and hence
    #         # prefixed such validation by an if conditional, end such conditional.
    #         if (( args_is_optional )) {
    #             code_args_local_or_valid+=${code_indent_outer}'}'
    #         }
    #     }
    # }

            # Since variadic arguments are localized by
            # removing *ALL* non-variadic arguments from the current
            # argument list, doing so when at least one such argument is
            # unlocalized and hence uncopied into a local variable would
            # prevent subsequent code from accessing such argument.

    # String expanded at the start of such function's body, thus localizing and
    # validing arguments *BEFORE* all user-defined logic.
    # func_preamble+=${code_args_local_or_valid}

    #FUXME: For a similar reason, we don't actually need a separate string
    #local ${code_arg_count} either. Instead, append ${func_preamble} directly.

    # Code validating the number of arguments passed to such function.
    # local code_arg_count

        # If such function only conditionally accepts default arguments (e.g.,
        # only when called directly from the command line), default such
        # arguments only if such condition succeeds.
        # if (( ${+ZESHY_DECLARE_FUNC_ATTRS__[default_args_if]} )) {

#reporting success when such
            # function accepts default arguments.
    #FUXME: If one considers it, we don't actually require
    #${code_args_default}. Instead, since ${code_args_default} *ALWAYS*
    #prefixes ${func_preamble}, simply:
    #
    #* Operate directly on ${func_preamble} instead.
    #* Excise ${code_args_default}.
    #* Rename ${code_args_default_current} to ${code_args_default}.

    # Code defaulting defaultable arguments *NOT* passed to such function for
    # all possible argument counts.
    # local code_args_default

        # such code should *ALWAYS* prefixes such function preamble,
                #FUXME: Implement me. To do so sanely:
                #
                #* Declare new string local ${code_args_local_variadic} above.
                #* Clear such string each argument count iteration.
                #* Since there exists at most one variadic argument each
                #  such iteration, set such string in the conditional branch
                #  below to code performing all required pop and shift
                #  operations. Since we know the current argument index and
                #  count, this should be perfectly feasible.
                #* Unconditionally expand such string into
                #  ${code_args_local_or_}.
                #FUXME: Note a mild optimization, as well:
                #"if (( arg_count == 1 )) {", then we don't need to pop or
                #shift anything. Nice.

            # Indent the if conditional branch emitted below.
            # code_args_default+=${code_indent}

            # there already exists an if conditional doing so. In such case,
            # continue such conditional with a new branch.
            # If defaulting at least one argument for a prior argument count,
            # there already exists an if conditional doing so. In such case,
            # continue such conditional with a new branch.
        #FUXME: Such test does work, but is becoming increasingly fragile,
        #inefficient, and cumbersome. It may be preferable, at some point, to:
        #
        #* Declare a new string local ${code_args_local_or_valid_current}.
        #* Reset such string to the empty string each argument count iteration.
        #* Append localization and validation code to such string (rather than
        #  ${code_args_local_or_valid}).
        #* If ${code_args_local_or_valid_current} (after all such possible
        #  appendings) is nonempty, append ${code_args_local_or_valid} by (in
        #  order):
        #  * An if conditional branch testing the current argument code (as
        #    below).
        #  * ${code_args_local_or_valid_current}.
        #  * Code delimiting such branch.
        #
        #Note this also eliminates the need for one of the "if ((
        #args_is_optional )) {" tests below -- and should, in general, produce
        #somewhat more streamlined code.

                # Indent the following if conditional.
                # code_args_local_or_valid+=${code_indent_outer}

                    # if (( arg_count_after_default > arg_count_min )) {
                    #     code_args_local_or_valid+=' el'
                    # } else {
                    #     ${code_indent_outer}
                    # }

            # subsequent
            # argument type validation assumes such function's caller passed the
            # current number of arguments. Prefix such validation by an if
            # conditional guaranteeing such assumption.
            # *NOT* conditionally dependent on the current argument count
            # and hence .

                    # if (( arg_count_after_default == arg_count_min )) {
                    #     code_args_local_or_valid_current+='if (( # == '${arg_count_after_default}' ))'
                    # # Else, extend such if conditional in a similar manner.
                    # } else {
                    #     code_args_local_or_valid_current+=' elif (( # == '${arg_count_after_default}' ))'
                    # }

#Avoid delimiting such conditional yet, as
                    # subsequent logic may interpose additional tests.
                    # Terminate the current branch of such if conditional.
                    # code_args_local_or_valid+=' {'

                    #FUXME: If some such argument is variadic *AND* passed, we
                    #need to emit code *HERE* popping all prior non-variadic
                    #arguments and shifting all subsequent non-variadic
                    #arguments off the argument list. The problem is that we
                    #don't have the index of such variadic argument here. This
                    #is probably easiest corrected by converting
                    #${arg_was_variadic} from a boolean into the nonzero index
                    #of such argument if present or 0 otherwise.
                    #FUXME: There's another subtler problem as well: we only
                    #want to pop and shift arguments if *ALL* such arguments
                    #have been localized. If even a single such argument has
                    #*NOT* been localized, it would make little sense to pop
                    #and shift only some of the arguments (i.e., the localized
                    #ones), as the function body would still in that case be
                    #unable to expand such variadic argument list as "${@}".
                    #
                    #Hence, we need some means of tracking whether or not all
                    #non-variadic arguments were localized. Since we have
                    #existing means, we'll need to gin up
                    #yet-another-arg-count-integer:
                    #
                    #    integer arg_count_localized
                    #
                    #Such integer can be efficiently incremented each argument
                    #count iteration as follows:
                    #
                    #    arg_count_localized+=$(( arg_is_localized ))
                    #FUXME: Wait. Simpler way. We only require a new boolean:
                    #
                    # # 1 if at least one non-variadic argument is *NOT*
                    # # localized and 0 otherwise (i.e., if all such arguments
                    # # are localized).
                    # integer args_is_unlocalized
                    #
                    # Maintaining such boolean should be a relative cinch.

                        # # If such argument is the second argument, remove the
                        # # first argument. See shift_arg() for further details.
                        # if (( arg_index == 2 )) {
                        #     code_args_local_variadic+=${code_indent_inner}'argv[1]=()'
                        # # Else, such argument follows the second argument.
                        # # Remove all prior arguments with ranged indices. See
                        # # shift_args_2() for further details.
                        # } else {
                        #     code_args_local_variadic+=${code_indent_inner}'argv[-1]=()'
                        # }

                # As an absurdly minor optimization, only do so if there exists 
                    # # If such argument is non-defaulted, such argument is passed.
                    # # In such case, map such subtype to a definition copying such
                    # # argument value to a local variable.
                    # if (( ! ${#arg_default_value} )) {
                    #     arg_declarer_to_declarations[${arg_subtype_local}]+=' '${arg_name}'="${'${arg_param}'}"'
                    # # Else, such argument is defaulted and hence unpassed.  Since
                    # # subsequent logic defaults such argument, declare such
                    # # argument as a local variable initialized to either (depending
                    # # on type) the empty string, 0, or 0.0.
                    # } else {
                    #     arg_declarer_to_declarations[${arg_subtype_local}]+=' '${arg_name}
                    # }

        #FUXME: Almost certainly a minor bug: after all, why would we *EVER*
        #want to reset such fact?
        # arg_was_variadic=0

                #FUXME: Close, but no e-cigar. While this test is appropriate,
                #we need an "} else {" branch whose body is *IDENTICAL* to that
                #of the "} elif (( arg_is_absentable )) {" branch below.
                #Clearly, the two should be unified. The simplest way is
                #probably as follows:
                #
                #} else {
                #    arg_is_absentable=1
                #}
                #
                #Then, convert such "} elif (( arg_is_absentable )) {" branch
                #to a new "if (( arg_is_absentable )) {" conditional.
                #FUXME: Actually, there's little impactful point to such
                #complexity; just concoct an "} else {" branch here resembling:
                #
                # } else {
                #     arg_index+=-1
                #     continue
                # }
                #
                #That's it, folks. Yay!

            # If such argument is *NOT* variadic (i.e., was *NOT* suffixed by
            # an ellipse), handle such argument. Do so *AFTER* decrementing
            # such argument index and hence testing whether such argument is
            # optional, as we further munge such index below.

            #FUXME: Since these two cases no longer share any code (aside from
            #the easly replicable line "arg_count_optional+=-1"), split them
            #here into two top-level if conditional branches. Yay!
            #FUXME: Obsolete. See above!

            # # If such argument is either absentable or defaultable, such
            # # argument is optional. Note such fact.
            # if (( arg_is_absentable + ${#arg_default_value} )) {
            #     # If the current argument count supports at least one more
            #     # optional argument, such argument has been passed.
            #     if (( arg_count_optional )) {
            #         # Decrement the current optional argument count, implying such
            #         # count to subsequently support one less optional argument.
            #         # (The current optional argument "consumes" one of the
            #         # available optional argument "slots" permitted by such count.)
            #         arg_count_optional+=-1
            #     #FUXME: Compact the following two conditional branches.

            #     # Else the current argument count supports no additional
            #     # optional arguments, implying such argument to be unpassed.
            #     } else {
            #         # If defaulting such argument (i.e., if such argument is
            #         # assigned an unrelaxed default value), do so.
            #         if (( ${#arg_default_value} &&
            #             ! ${#match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED}]} )) {
            #             #FUXME: Document me.
            #             #FUXME: Actually, since this is more general than our
            #             #current defaulting technique, there's no sensible
            #             #reason we can't use this approach to default *ALL*
            #             #unpassed defaultable arguments -- not simply those
            #             #also variadic. Although the resulting logic will not
            #             #be quite as efficient, default arguments should only
            #             #ever be used in cases where efficiency doesn't
            #             #terribly matter anyway (e.g., front-facing CLI
            #             #aliases). The tangible benefits in both generality and
            #             #simplicity make this a more than worthwhile tradeoff.
            #             #FUXME: So. The current approach *DOES* appear to
            #             #generalize pleasantly, but also produces overly
            #             #verbose and inefficient code for functions accepting
            #             #two or more defaultable arguments. Which is mildly
            #             #disconcerting. Clearly, we need some means of
            #             #compacting multiple assignments together. For example:
            #             #
            #             #* If the first argument is defaultable and unpassed
            #             #  *AND* there exist any other defaultable, unpassed
            #             #  arguments, then since we have to replace the entire
            #             #  argument list anyway, we'd might as well compact the
            #             #  second default value assignment into the first:
            #             #  e.g.,
            #             #
            #             #    # For a function with prototype:
            #             #    # :void :yum(
            #             #    #     :string x = 'yay',
            #             #    #     :int j, :int k, :int l,
            #             #    #     :string y = 'yay',
            #             #    #     :int a, :int b, :int c)
            #             #    # ...we might want a preamble containing:
            #             #    if (( # == 6 )) {
            #             #        code_args_local_or_valid+='argv=( '${arg_default_value_x}' "${@[1,3]}" "${arg_default_value_y}" "${@[4,6]}" )'
            #             #    } elif (( # == 7 )) {
            #             #        code_args_local_or_valid+='argv[4]+="${arg_default_value_y}"
            #             #    }
            #             #
            #             #Brutal. There's clearly a way to identify and handle
            #             #such cases; now, we just have to doctor it up.
            #             #FUXME: O.K.; to reasonably implement this, we'll want
            #             #a new string local ${code_args_default} to which we
            #             #append here rather than to ${code_args_local_or_valid}.
            #             #Ensure that we:
            #             #
            #             #* Reset 'code_args_default=' each loop iteration.
            #             #* Test '[[ -n "${code_args_default}" ]]' far below; if
            #             #  such test succeeds, then and only then append
            #             #  ${code_args_local_or_valid} by ${code_args_default}.
            #             #  As the above example demonstrates, we test for the
            #             #  current argument count exactly. We do *NOT* need an
            #             #  "else" branch (indeed, that would be quite
            #             #  counterproductive); we do, however, need to track
            #             #  whether this is the first such branch. Fortunately,
            #             #  the latter is trivial by simply noting whether or
            #             #  not '[[ -n "${code_args_default}" ]]'.
            #             #* Moreover, *ALL* such branches must clearly be
            #             #  emitted before subsequent logic. This suggests,
            #             #  clearly, that we actually need *TWO* new string
            #             #  locals:
            #             #  * ${code_args_default_current}, containing only the
            #             #    set of all "argv"-specific commands for the
            #             #    current argument count. Reset such string each
            #             #    loop iteration.
            #             #  * ${code_args_default}, containing *ALL* such
            #             #    default value-specific logic. Do *NOT* reset such
            #             #    string each loop iteration. Expand such string
            #             #    into ${func_preamble} at the end of this function.

            #             # Increment the current argument count to reflect the
            #             # insertion of such argument's default value into the
            #             # current argument list.
            #             arg_count_after_default+=1

            #             # If such argument is also variadic, ...
            #             if (( arg_is_variadic )) {
            #                 # Initiate such conditional.
            #                 code_args_local_or_valid+=${code_indent_outer}'if (( # == '${arg_count}' )) {'${code_indent_inner}

            #                 # If such argument is the last explicit argument
            #                 # such function accepts (ignoring all subsequent
            #                 # optional variadic list arguments), efficiently
            #                 # append such argument's default value to the
            #                 # current argument list.
            #                 if (( arg_index == arg_count_max )) {
            #                     code_args_default_current+='argv+='${arg_default_value}
            #                 # Else if such argument is the first explicit argument
            #                 # such function accepts, inefficiently replace the
            #                 # current argument list with one in which the
            #                 # indices of all other explicit arguments are
            #                 # increased by 1 and the first index of such list
            #                 # is set to such argument's default value.
            #                 } elif (( arg_index == arg_count_max )) {
            #                     code_args_default_current+='argv=( '${arg_default_value}' "${@}" )'
            #                 # Else such argument is neither the first or last
            #                 # explicit argument such function accepts and hence
            #                 # is both preceded *AND* succeeded by at least one
            #                 # such argument. In such case, an efficient
            #                 # alternative to replacing the current argument
            #                 # list presents itself: append such argument's
            #                 # default value to the prior argument.
            #                 # (Astonishingly, this actually works.)
            #                 } else {
            #                     code_args_default_current+='argv['$(( arg_index - 1 ))']+='${arg_default_value}
            #                 }

            #                 # Terminate such conditional.
            #                 code_args_local_or_valid+=${code_indent_outer}'}'
            #             }

            #             # Expand such argument after such assignment by name.
            #             arg_param=${arg_name}
            #         # Else such argument is *NOT* defaultable. Since prior
            #         # conditionals guarantee such argument to be unpassed and
            #         # either absentable *OR* defaultable, such argument is
            #         # unpassed and absentable, suggesting such argument to not
            #         # exist and hence be neither localizable or validatable. To
            #         # guarantee this, skip to the next argument entirely.
            #         } else {
            #             # Since unpassed arguments cannot be indexed, assign the
            #             # next argument such index instead. To permit prior logic
            #             # to access the index such argument would have had if
            #             # passed (e.g., to insert a default value for such argument
            #             # into the current argument list when unpassed), decrement
            #             # such index *AFTER* performing all prior logic.
            #             arg_index+=-1

            #             #FUXME: Erroneous. In particular, we need to ensure
            #             #argument-specific booleans are set in the expected way
            #             #(e.g., ${arg_was_variadic}, ${arg_was_optional}) --
            #             #not to mention our decrementation of ${arg_index}.
            #             #Given this, we probably require a new boolean
            #             #(*groan*, we know...) ${arg_is_skippable}. *WAIT*. No,
            #             #we can certainly be a bit cleverer than that. We can
            #             #implicitly force skipping without explicitly doing so
            #             #by coercively replacing the call to continue here
            #             #with simply:
            #             #
            #             #    arg_is_localized=0
            #             #    arg_is_validated=0
            #             #
            #             #Of course, that requires a new boolean
            #             #${arg_is_validated} -- but, given that we already have
            #             #the former, orthogonality suggests we'll probably end
            #             #up requiring the latter at some point anyway. So it
            #             #costs us little to nothing to go ahead and define it.
            #             #FUXME: Actually, we *SHOULD* just be able to literally
            #             #continue to the next argument here. If we're currently
            #             #unable to do so, that indicates an overly complex and
            #             #logically cumbersome algorithm - which, obviously,
            #             #should be addressed anyway. A few thoughts on how to
            #             #make this possible:
            #             #
            #             #* Shift the variadicity conditional below *ABOVE* the
            #             #  current optionality conditional.
            #             #* Document why we do so.
            #             #
            #             #And...that should be it? Unlikely, but possible. Grok
            #             #the codebase a deeper to see if we haven't missed
            #             #anything too elephantine.

            #             continue
            #         }
            #     }
            # }

                    #FUXME: Document me.
                    # arg_is_localized=0
                    # arg_is_validated=0

                    # # Since unpassed arguments cannot be indexed, assign the
                    # # next argument such index instead. To permit prior logic
                    # # to access the index such argument would have had if
                    # # passed (e.g., to insert a default value for such argument
                    # # into the current argument list when unpassed), decrement
                    # # such index *AFTER* performing all prior logic.
                    # arg_index+=-1

# for related logic
    # # Substring prefixing argument count-specific exception messages.
    # local die_arg_count_prefix=' || :die "Function ${funcstack[1]}() expected '

    # # Substring suffixing argument count-specific exception messages.
    # local die_arg_count_suffix='."$''\n\n''"Function prototype:"$''\n'''${(qq)ZESHY_DECLARE_FUNC_PROTOTYPE__}'$''\n\n''"Arguments passed:"$''\n''"${*}"'

#Or perhaps such boolean's opposite? Whichever's simpler!
        #     # Default such arguments only if such condition succeeds,
        #     # delimiting such code from subsequent code by a newline.
        #     code_args_default=${code_indent}'if { '${args_is_defaultable_tester}' } {'${code_indent_outer}${code_args_default}${code_indent_outer}'}'$'\n'
        # # Else such function *ALWAYS* accepts default arguments. In such case,
        # # simply delimit such code as above.
        # } else {
        #     code_args_default+=$'\n'
        # }

    # Name of the alias or function reporting success when the current function
    # call allows default arguments, indicated by function attribute
    # "default_args_if". (If such attribute is unspecified, such call *ALWAYS*
    # allows default arguments; in such case, this name defaults to the empty
    # string, implying unconditional success.)
    # local args_is_defaultable_tester

                    #FUXME: This *MUST* be shifted above to where we now handle
                    #argument defaults in a better generalized manner.
                    #FUXME: Moreover, string local ${args_definitions_default}
                    #should now be excised.

                    # If such function only conditionally accepts default
                    # arguments *AND* the current argument count accepts at
                    # least one such argument, additionally test whether the
                    # current function call accepts default arguments.
                    # if (( ${#args_is_defaultable_tester} &&\
                    #       ${#args_definitions_default} )) {
                    #     code_args_local_or_valid+=' { '${args_is_defaultable_tester}' }'
                    # }

            #FUXME: Incorporate ${args_is_defaultable_tester} logic from below.

            # # Default such arguments only for the current argument count.
            # code_args_default+='if (( # == '${arg_count}' ))'

            # # If such function only conditionally accepts default arguments,
            # # default such arguments only if such condition also succeeds.
            # if (( ${#args_is_defaultable_tester} )) {
            #     code_args_default+=' { '${args_is_defaultable_tester}' }'
            # }

            # # Default such arguments.
            # code_args_default+=' {'${code_args_default_current}${code_indent_outer}'}'

            # Default all such arguments for the current argument count.
        #FUXME: In fact, the above streamlining should obviate the need for a
        #separate 

        #FUXME: The current test is insufficient. Specifically, this:
        #    if (( ${#arg_declarer_to_declarations} +\
        #          ${#arg_tester_to_expansions} )) {
        #...should also include a test of "+ ${#code_args_local_variadic}" or
        #some such. *yawn morosely*

    #FUXME: Actually, stripping a prefixing newline should no longer be
    #necessary; we now ensure ${code_args_default} *NEVER* begins with such a
    #newline, and should make similar changes above to ensure ${code_arg_count}
    #only begins with a newline when preceded by a nonempty
    #${code_args_default}. The simplest means of effecting this is probably to:
    #
    #* *ALWAYS* suffix ${code_args_default} by a newline.
    #* *NEVER* prefix ${code_args_count} by a newline -- just by indentation.

    # # String expanded at the start of such function's body, thus localizing and
    # # validing arguments *BEFORE* all user-defined logic.
    # #
    # # Strip a prefixing newline from such preamble, if any. While it would
    # # clearly be preferable to avoid emitting such newline in the first place,
    # # such newline has two possible sources (either ${code_args_default} or
    # # ${code_arg_count}, depending on whether at least one unpassed argument is
    # # defaulted) and hence is non-trivially removable. This is much simpler.
    # func_preamble=${${:-${code_args_default}${code_arg_count}${code_args_local_or_valid}}#$'\n'}

            # # If defaulting at least one argument for a prior argument count,
            # # there already exists an if conditional doing so. In such case,
            # # continue such conditional with a new branch.
            # if [[ -n "${code_args_default}" ]] {
            #     code_args_default+=${code_indent_outer}
            # # Else, no such conditional exists, so begin one anew.
            # } else {
            #     code_args_default+=${code_indent_outer}
            #     code_args_default+=' el'
            # }

                        #FUXME: Actually, the approach pursued below should
                        #*ALSO* suffice in this case as well. Hence, we want to
                        #implement such approach if either:
                        #
                        #* Such argument is *NOT* localized.
                        #* Such argument is variadic.
                        #
                        #The two cases are similar, because (of course)
                        #variadic arguments are *NOT* localized. Yay!

                        # # If such argument is *NOT* localized, throw an
                        # # exception.
                        # #
                        # # While we *MAY* support non-localized defaultable
                        # # arguments in the future, doing so now would impose
                        # # complexities and inefficiencies for little gain.
                        # (( arg_is_localized )) ||  ::func_.die_of_cause\
                        #     'argument ${'${arg_name}'} assigned a default value; consider either eliminating such assignment or refactoring such argument to be non-variadic'

                        # # If such argument is also variadic, throw an
                        # # exception. While assigning the first argument of an
                        # # unpassed variadic list a default value is feasible,
                        # # doing so imposes hitherto unaddressed complexities;
                        # # given the conditional logic below, we would need to
                        # # prepend ${code_args_local_or_valid} with an
                        # # additional if conditional (probably with only a
                        # # single branch) testing whether 
                        # #
                        # # e.g.,
                        # #
                        # # * Why permit only the first argument of such a list
                        # #
                        # # While we *MAY* support variadiac defaultable
                        # # arguments in the future, doing so now would impose
                        # # complexities and inefficiencies for little gain.
                        # (( ! arg_is_variadic )) || ::func_.die_of_cause\
                        #     'variadic argument ${'${arg_name}'} assigned a default value; consider either eliminating such assignment or refactoring such argument to be non-variadic'

                    #FUXME: Silly. Since we now know beforehand whether there
                    #exists an optional argument, this is removable; instead,
                    #just test where we handle variadic-specific logic:
                    #
                    #    (( ! args_is_optional )) || ::func_.die_of_cause_arg_variadic\
                    #         'accepts both optional and variadic arguments'

                    # If a prior argument is variadic, throw an exception. Note
                    # we ignore the valid case that the current argument is
                    # both variadic and absentable (e.g., ":int arg1?, ...").
                    # (( ! arg_was_variadic )) ||
                    #     ::func_.die_of_cause_arg_variadic\
                    #         'accepts both optional and variadic arguments'

# - precisely as tested for here
                # Then such test reduces to either:
                #
                # * "(( arg_count_max - arg_count_min == 1 ))", if the
                #   current variadic argument is optional.
                # * "(( arg_count_max - arg_count_min == 0 ))", if the
                #   current variadic argument is mandatory.

                # if (( args_is_optional &&\
                      # arg_count_max - arg_count_min - arg_is_optional > 1 )) {
                # if (( arg_count_max - arg_count_min >= 2 ))

            #FUXME: Erhm; there *IS* no boolean local ${arg_is_defaultable}, at
            #the moment. Honestly, do we even still require
            #${arg_was_optional}?
            #FUXME: Optimizable by shifting above?

    # # 1 if a prior argument was optional (i.e., either defaulted *OR*
    # # optionalized) and 0 otherwise.
    # integer arg_was_optional

    #     arg_was_optional=0

    #         # If such argument was optional and/or variadic, notify subsequent
    #         # parse iterations of such fact. For safety, set such boolean
    #         # *AFTER* all tests of such boolean above.
    #         if (( arg_is_absentable + arg_is_defaultable )) {
    #             arg_was_optional=1
    #         }

            # # Else, such argument is variadic.
            # #
            # # If a prior argument is also variadic, throw an exception. Such
            # # case implies such function to accept two or more variadic
            # # argument lists of arbitrary count, implying there exists no
            # # general means of deciding which such list a passed string was
            # # intended to belong to.
            # } elif (( arg_was_variadic )) {
            #     ::func_.die_of_cause_arg_variadic\
            #         'accepts two or more variadic arguments'
            # # If a prior argument is optional, throw an exception. Such case
            # # implies such function to accept one or more optional arguments
            # # *AND* one or more variadic argument lists of arbitrary count,
            # # implying there exists no general means of deciding which such
            # # argument a passed string was intended to correspond to.
            # #
            # # Test such condition *AFTER* testing whether a prior argument is
            # # variadic. If such function accepts an optional variadic argument
            # # following a prior variadic argument, the prior exception is more
            # # explanatory than this exception.
            # } elif (( arg_was_optional )) {
            #     ::func_.die_of_cause_arg_variadic\
            #         'accepts both optional and variadic arguments'
            # # Else, such argument is validly variadic.

 # Alternatively, since it's clear this is only an
        #optimization concern and a mild one at that, we should probably simply
        #excise such conditional.
            #FUXME: Due to the "! arg_is_variadic" constraint below, this is
            #probably shiftable into the prior conditional, no?
            #FUXME: Actually, even this condition isn't *QUITE* sufficient. We
            #also want to avoid localizing unpassed absentable arguments, for
            #obvious reasons (e.g., to ensure unpassed arguments are
            #distinguishable from the empty string, 0, and 0.0). This probably
            #ties into our currently erroneous use of "continue" above; oh,
            #right. In the above case, we simply coerce "arg_is_localized=0",
            #suggesting we should probably do the same (for both orthogonality
            #and consistency) when "(( arg_is_variadic ))".

                        #FUXME: And another subtle point: after implementing
                        #such conditional logic, the size of the current
                        #argument list is increased by 1 for each defaulted
                        #argument, implying that the ${code_args_local_or_valid}-
                        #based conditional below will be testing the wrong
                        #argument count. Happily, this is easily correctable by
                        #maintaining a new argument count incremented by 1 here
                        #for each defaulted argument:
                        #
                        #    integer arg_count_after_default

                        #FUXME: The right idea; however, we need to be doing
                        #just the *OPPOSITE*. If the current argument is both
                        #unpassed *AND* undefaulted (which can occur due to any
                        #number of root causes, such as being absentable *OR*
                        #being relaxedly defaultable), we need to:
                        # arg_count_after_default-=1

            # For each alias name and corresponding string localizing arguments
            # into locals declared by expanding such alias, do so *BEFORE*
            # assigning unpassed defaultable arguments default values.
            #
            # Naturally, the reasons why are somewhat subtle. Technically, such
            # declarations and assignments *COULD* be combined. For example:
            #
            #     # Rather than separating such statements like so...
            #     :string mu="${1}" wu="${2}" nothing something
            #     nothing="Nothing lasts but nothing is lost."
            #     something="$(false)"
            #
            #     # ...we could simply combine such statements.
            #     :string\
            #         mu="${1}"\
            #         wu="${2}"\
            #         nothing="Nothing lasts but nothing is lost."\
            #         something="$(false)"
            #
            # When *NOT* preceded by a declaration, assigning a variable a
            # string embedding at least one process substitution reporting
            # failure (e.g., 'something="$(false)"') itself reports failure and
            # hence implicitly throws an exception. This is good.
            #
            # When preceded by a declaration, however, such assignment *ALWAYS*
            # reports success and hence ignores such failure. This is bad.
            #
            # Separating declarations and assignments thus preserves essential
            # errors, reducing the former to simple string assignments *ALWAYS*
            # succeeding and hence requiring no exception handling (e.g.,
            # 'my_var="${1}"').
            #
            # For efficiency, iterate only by keys (rather than by both keys
            # and values).

            #FUXME: Excise. See above.

            # Assign unpassed defaultable arguments default values *BEFORE*
            # subsequent iteration validates such arguments.
            # code_args_local_or_valid+=${args_definitions_default}

    #FUXME: Improve commentary.

    # If defaulting at least one argument, delimit that from subsequent logic
    # by a newline.
    # if [[ -n "${code_args_default}" ]] {
    #     code_args_default+=$'\n'
    # }

                        #FUXME: Actually, only do this if we're also localizing
                        #such argument. If we're *NOT*, we have no choice but
                        #to treat such assignment as if relaxed.
                        #FUXME: Oh, yes -- and we clearly need to handle
                        #relaxation as well.

                        # Append an assignment of such argument to such default
                        # value to the newline-delimited string of such
                        # assignments.
                        # args_definitions_default+=${code_indent_outer}${arg_name}'='${arg_default_value}

    # Newline-delimited string of all assignments of unpassed defaultable
    # arguments to default values: e.g.,
    #
    #     problem="The problem is not to find the answer."
    #     answer="Its to face the answer."
    #
    # Since delimiting such assignments by newline suffices, prefer appending
    # such assignments to a string rather than list (for efficiency).
    # local args_definitions_default

        # args_definitions_default=

#[[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED}]}"
                        #FUXME: The above example brings up a subtle point:
                        #when some but not all multiple defaultable arguments
                        #are unpassed, decide which such arguments to default
                        #and which *NOT* to default in a rightmost manner
                        #(i.e., default rightmost defaultable arguments first).
                        #Do we currently do this? Suspicions say, "wat."

# This should substantially (hopefully!)
                        #simplify logic elsewhere as well.
                        #FUXME: Actually, as the description below suggests,
                        #this won't be terribly difficult to support at all.
                        #Specifically:
                        #
                        #* If such defaultable argument is also variadic,
                        #  prepend ${code_args_local_or_valid} with an
                        #  additional if conditional (probably with only a
                        #  single branch) testing whether such argument was
                        #  passed or not.
                        #* If unpassed, the body of such conditional should
                        #  directly modify the argument list to interpose such
                        #  argument's default value directly into the current
                        #  argument list as follows:
                        #  * If such argument is the last argument, efficiently
                        #    append such default value to such list with:
                        #    argv+="${arg_default_value}"
                        #  * Else, inefficiently inject such default value into
                        #    the appropriate position of such list. This should
                        #    require at least two commands:
                        #    1. Shift all subsequent arguments down by one
                        #       index. Does something like the following
                        #       actually work? We strongly doubt it, but
                        #       certainly worth a lucky try. Yes, it does!
                        #       Huzzah: e.g.,
                        #       argv[${arg_index},-1]=( "${@[${arg_index}]}" )
                        #    2. Inject such default value into the proper
                        #       index: e.g.,
                        #       argv[${arg_index}]="${arg_default_value}"
                        #    Actually, given such operations, we *CAN* combine
                        #    them into the following single efficient command:
                        #
                        #    argv[$(( arg_index - 1 ))]+="${arg_default_value}"
                        #
                        #    Wait! That works for all indices except the first,
                        #    of course, which requires an inefficient but still
                        #    compact single command: e.g.,
                        #
                        #    argv=( "${arg_default_value}" "${@}" )
                        #
                        #In the above examples, note that ${arg_index} has
                        #probably already been decremented by 1 and hence
                        #incorrect. Handle this... erhm, "appropriately": e.g.,
                        #    argv[${arg_index}]+="${arg_default_value}"

                        #FUXME: While such code does appear to work here, would
                        #it not be more logically consistent to shift it below
                        #where we append to ${code_args_local_or_valid}
                        #en-masse? Hmm; certainly not, as we require the index
                        #of such argument. Note this below.

                            # If such argument is the last standard argument
                            # such function accepts (ignoring all subsequent
                            # optional variadic list arguments, of course), 

                    #FUXME: Unlike all other instances of relaxation, 

                #FUXME: Uh oh. Such conditionals appear to suffice in all cases
                #*EXCEPT* where variadic arguments are passed, in which case...
                #what? Do we perhaps need to shift such "==" comparisons below
                #to ">=" instead? Contemplate.

# In such case, test for implying at least one optional argument to be
                # tested for.
            #FUXME: Slightly more efficient to initialize such index to 1 above
            #and set this

                        # impose ineffectual complexities.
            # If localizing such argument (i.e., if such argument name is
            # unrelaxed), do so.
            # if [[ -z "${match[${ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED}]}" ]] {

    #FUXME: How do variadic arguments semantically interact with default
    #values? Not terribly well, one should think. Perhaps forbid such
    #combination with a thrown exception, for the moment?
