#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under ={help} in the main codebase.

# ....................{ SETTERS ~ func                     }....................
# Define such function *BEFORE*:
#
# * Documenting such function, as :func.document() transitively calls such
#   function.
# * Defining and documenting all subsequent functions, for the same reason.

function ::operable.set_setter_of_type,metadata_type() {
    (( # == 4 )) || :die\
        'Expected one operable name, one string name, one operable type, and one metadata type.'
    :string.set "${2}" "::${3}.set_${4}:${1}"
}
:func.document <<'/---'
:void ::operable.set_setter_of_type,metadata_type(
    :string operable_name,
    ^:string setter_name,
    :string operable_type,
    :string metadata_type)

Set the passed string variable to the name of the function setting a passed
string variable to the metadata of the passed type of the passed operable of
the passed type (e.g., `::func.set_prototype:string.set()` for the prototype
for function string.set()).

== Motivation ==

This function serves as an ad-hoc means of persisting static *RTTI* (run-time
type information) on arbitrary *operables* (i.e., aliases, functions, globals).
By dynamically associating such operables with typed metadata in the guise of
global string constants, this function is at the core of several other `zeshy`
subsystems requiring run-time metadata -- in particular, the help subsystem.

== Types ==

If such metadata type is:

* `prototype`, such function sets such variable to such operable's prototype.
* `asciidoc`, such function sets such variable to such operable's AsciiDoc.

If such operable type is:

* `alias_simple`, such function sets such variable to such simple alias'
  metadata.
* `alias_global`, such function sets such variable to such global alias'
  metadata.
* `alias_suffix`, such function sets such variable to such suffix alias'
  metadata.
* `func`, such function sets such variable to such function's metadata.
* `global`, such function sets such variable to such global's metadata.
/---

# ....................{ SETTERS ~ func                     }....................
:func.document <<'/---'
:void :func.set_asciidoc(:string/func func_name, ^:string string_name)

Set the passed string variable to all previously declared AsciiDoc-formatted
documentation for the passed function.
/---
function :func.set_asciidoc() {
    (( # == 2 )) || :die 'Expected one function name and one string name.'
    ::operable.set_metadata_of_type,metadata_type "${@}" 'func' 'asciidoc'
}

:func.document <<'/---'
:void :func.set_prototype(:string/func func_name, ^:string string_name)

Set the passed string variable to the previously declared prototype for the
passed function.
/---
function :func.set_prototype() {
    (( # == 2 )) || :die 'Expected one function name and one string name.'
    ::operable.set_metadata_of_type,metadata_type "${@}" 'func' 'prototype'
}

# ....................{ SETTERS ~ operable                 }....................
#FIXME: Document me.
:func.document <<'/---'
:void ::operable.set_metadata_of_type,metadata_type(
    :string operable_name,
    ^:string metadata_name,
    :string operable_type,
    :string metadata_type)
/---
function ::operable.set_metadata_of_type,metadata_type() {
    # Validate sanity.
    (( # == 4 )) || :die\
        'Expected one operable name, one string name, one operable type, and one metadata type.'
    local metadata_setter__osmotmt

    # Name of such setter function.
    ::operable.set_setter_of_type,metadata_type\
        "${1}" metadata_setter__osmotmt "${3}" "${4}"

    # Set such string.
    :func.die_unless "${metadata_setter__osmotmt}"
    "${metadata_setter__osmotmt}" "${2}"
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ OBSOLETE                           }....................
#FUXME: Excise all functionality below.
#FUXME: Document me.

# ....................{ SETTERS ~ func                     }....................
#FUXME: Document me.

# :void :func.set_prototype(
#     :string/func func_name, ^:string string_name)
function :func.set_prototype() {
    (( # == 2 )) || :die 'Expected one function name and one string name.'
    ::operable.set_prototype_of_type "${@}" 'func'
}

# ....................{ SETTERS ~ operable                 }....................
#FUXME: Implement ::set_string_to_operable_type_asciidoc() along similar lines.
#FUXME: Document me.

# # :void ::operable.set_prototype_of_type(
# #     :string/func operable_name,
# #     ^:string string_name,
# #     :string operable_type)
# function ::operable.set_prototype_of_type() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one operable name, one string name, and one operable type.'
#     local\
#         operable_name__sstrtp="${1}"\
#         string_name__sstrtp="${2}"\
#         operable_type__sstrtp="${3}"\
#         prototype_setter_name__sstrtp
# 
#     #FUXME: Nonsense. Call ::operable.set_prototype_setter_of_type() instead.
# 
#     # Name of the function setting such string to such operable's prototype.
#     # See ::operable.document_prototype,asciidoc_of_type() for such
#     # function's definition.
#     prototype_setter_name__sstrtp="::set_string_to_${operable_type__sstrtp}_prototype:${operable_name__sstrtp}"
#     :func.die_unless "${prototype_setter_name__sstrtp}"
#     "${prototype_setter_name__sstrtp}" "${string_name__sstrtp}"
# }
# 
# # :void ::operable.set_prototype_of_type(
# #     :string operable_name,
# #     ^:string prototype_name,
# #     :string operable_type)
# :func.document <<'/---'
# :void ::operable.set_asciidoc_setter_of_type(
#     :string operable_name,
#     ^:string setter_name,
#     :string operable_type)
# 
# Set the passed string variable to the name of the function setting a passed
# string variable to the AsciiDoc of the passed operable of the passed type
# (e.g., `::func.set_asciidoc:string.set()` for function string.set()).
# /---
# 
# function ::operable.set_prototype_of_type() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one operable name, one string name, and one operable type.'
#     local\
#         operable_name__sstrtp="${1}"\
#         string_name__sstrtp="${2}"\
#         operable_type__sstrtp="${3}"\
#         prototype_setter_name__sstrtp
# 
#     #FUXME: Nonsense. Call ::operable.set_prototype_setter_of_type() instead.
# 
#     # Name of the function setting such string to such operable's prototype.
#     # See ::operable.document_prototype,asciidoc_of_type() for such
#     # function's definition.
#     prototype_setter_name__sstrtp="::set_string_to_${operable_type__sstrtp}_prototype:${operable_name__sstrtp}"
#     :func.die_unless "${prototype_setter_name__sstrtp}"
#     "${prototype_setter_name__sstrtp}" "${string_name__sstrtp}"
# }

    # ::operable.set_prototype_of_type "${@}" 'func'
    # local\
    #     operable_name__osmotmt="${1}"\
    #     string_name__osmotmt="${2}"\
    #     operable_type__osmotmt="${3}"\
    #     metadata_type__osmotmt="${4}"\
    #     metadata_setter__osmotmt

    # # Name of such setter function.
    # ::operable.set_setter_of_type,metadata_type\
    #     "${operable_name__osmotmt}"\
    #     metadata_setter__osmotmt\
    #     "${operable_type__osmotmt}"\
    #     "${metadata_type__osmotmt}"

    # # Set such string.
    # :func.die_unless "${prototype_setter_name__osmotmt}"
    # "${metadata_setter__osmotmt}" "${string_name__osmotmt}"

#FUXME: Generalize for all possible metadata by refactoring into:
#FUXME: Implement ::set_string_to_operable_type_asciidoc() along similar lines.

# :func.document <<'/---'
# :void ::operable.set_prototype_setter_of_type(
#     :string operable_name,
#     ^:string setter_name,
#     :string operable_type)
# 
# Set the passed string variable to the name of the function setting a passed
# string variable to the prototype of the passed operable of the passed type
# (e.g., `::func.set_prototype:string.set()` for the prototype for function string.set()).
# /---
# function ::operable.set_prototype_setter_of_type() {
#     (( # == 3 )) || :die\
#         'Expected one operable name, one string name, and one operable type.'
#     :string.set "${2}" "::${3}.set_prototype:${1}"
# }

#FUXME: This could really benefit from an example.
    # local\
    #     operable_name__ospsot="${1}"\
    #     prototype_setter_name__ospsot="${2}"\
    #     operable_type__ospsot="${3}"
