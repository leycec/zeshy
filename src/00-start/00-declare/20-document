#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

#FIXME: We need to support disjunctive prototypes. Consider this function,
#which can be called in at least two fundamentally distinct ways. To permit
#this, I suggest extending our "{...,...}" syntax yet again as follows:
#
#    {void declare_global(
#        string global_type,
#        string global_name_with_optional_value,
#        string documentation),
#     void declare_global(string documentation)}
#
#We *REALLY* don't want to have to implement a non-regular context-free parser.
#Fortunately, we won't have to. Simply hard-code an outermost "(...|...)"-style
#PCRE, where the first sub-PCRE in such PCRE matches the conventional singular
#prototype (i.e., lacking exterior "{" and "}" delimeters) and the final
#sub-PCRE in such PCRE matches the above plural prototype (i.e., with exterior
#"{" and "}" delimeters).
#FIXME: Document the fact that global values may actually be delimited by an
#arbiratry number of "=" delimiters, in which case this function defines *ALL*
#such globals to be synonyms of each other assigned the same initial value.
#Required elsewhere. Sweet, eh?

#FIXME: Naturally, AsciiDoc will be an only optional dependency for users
#attempting to build the documentation. If not installed, we'll just display
#function documentation as is when a user runs "help function". If installed,
#we'll probably want to pipe function documentation dynamically through either
#the ASCII or man page exporters. (Sweeeeeet, no?)
#FIXME: Source code highlighting is simple. Just write:
#
#    [source,bash]
#    ----
#    INSERT CODE HERE
#    ----
#
#Sadly, neither Pygments or other less popular alternatives support zsh yet.
#Hence, "bash" suffices. Then, we want to selectively prefer "pygments" where
#available. To do so, we'll need to output the following at the very top of each
#AsciiDoc document we send to "asciidoc":
#
#    8<---------------
#    = Title
#    :source-highlighter: pygments
#
#This is an AsciiDoc header instructing "asciidoc" to prefer the "pygments"
#backend for the [source] filter. For further details, see:
#    https://groups.google.com/forum/?fromgroups=#!topic/asciidoc/ReIM4z-zi9I
#FIXME: Avoid repetition. In particular, replace "[source,bash]" with simply
#"[source]" everywhere by setting the default "language" in the AsciiDoc
#document header, like so:
#
#    :language: bash
#
#The same style can be extended to set default table attributes as follows:
#
#    :grid:  none
#    :frame: topbot

#FIXME: We're certain we've documented this elsewhere, but the correct approach
#to documentation is to segregate *EACH* bit of documentation into its own
#setter function setting a passed string variable to the documentation for the
#desired object: e.g.,
#
#    # Set such string variable to the help string for function
#    # ::define_func().
#    void ::set_string_to_help:func::define_func(void string_name)
#
#Naturally, *ALL* such setters should be compiled into a *NEW, SEPARATE* digest
#file (e.g., "~/.zeshy/cache/digest/help.zwc"), which doesn't depend on whether
#or not this is a debug or release build of zeshy and hence applies to *ALL*
#possible main zeshy digests.
#
#How does segregating such setters to such digest help us? Simple. By default,
#such digest is *NOT* listed in the function path ${fpath}. In fact, *ONLY* low-
#level helper functions (e.g., :print_help_function()) internally and only
#temporarily prepend such digest to a local shadowing of ${fpath}. Indeed, such
#functions should probably temporarily reduce ${fpath} to *ONLY* such digest.
#
#Indeed, such technique provides a memorable means of implementing highly
#efficient, pure-zeshy read-only key-value stores, as I believe we've remarked
#elsewhere.
#FIXME: I'm unsure if I've documented it anywhere... so, it had might as well be
#here. The nomenclature for synthesized help function names should be:
#
#* For aliases, "::set_string_to_help:alias:${alias_name}".
#* For functions, "::set_string_to_help:function:${function_name}".
#* For globals, "::set_string_to_help:global:${global_name}".
#
#Simple. Note that in the case of normal ":"-suffixed aliases and functions,
#the corresponding help function names will also be suffixed by ":" -- which is,
#of course, perfect. Lookin good, eh?

#FIXME: It'd be great to support specification of whether a function or alias
#argument is actually mandatory or optional in variadic lists. For example, in
#the following function prototype, all arguments except the first menu name are
#actually optional -- but we have no way of indicating that at the moment:
#
#    string show_info_menu_with_options(
#        string info_option1, string info_option2, ...,
#        string menu_name1, string menu_name2, ...)
#
#I propose a simple suffix "?" on all optional variadic arguments: e.g.,
#
#    string show_info_menu_with_options(
#        string info_option1?, string info_option2?, ...,
#        string menu_name1, string menu_name2?, ...)
#
#Fairly simple *AND* legible, yes?

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

# ....................{ GLOBALS                            }....................
typeset -g ZESHY_HELP_SETTER_NAME_PREFIX=':set_string_to_help:'

# ....................{ DOCUMENTERS                        }....................
#FIXME: Document me.
# void :document_alias_simple[stdin: string alias_documentation]
function :document_alias_simple() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'alias_simple'
}

#FIXME: Document me.
# void :document_alias_global[stdin: string alias_documentation]
function :document_alias_global() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'alias_global'
}

#FIXME: Document me.
# void :document_alias_suffix[stdin: string alias_documentation]
function :document_alias_suffix() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'alias_suffix'
}

#FIXME: Document me.
# void :document_func[stdin: string func_documentation]
function :document_func() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'func'
}

#FIXME: Document me.
# void :document_global[stdin: string global_documentation]
function :document_global() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'
    local global_help global_name global_prototype global_asciidoc

    # Documentation passed on standard input.
    :set_string_to_stdin_help global_help

    # Split such documentation into prototype and non-prototype portions.
    :set_strings_to_help_prototype_asciidoc\
        global_prototype global_asciidoc "${global_help}"

    #FIXME: Define such setter!

    # Global name declared by such documentation's prototype.
    :set_string_to_global_prototype_name global_name "${global_prototype}"

    # Document such names.
    ::document_operable_typed_with_prototype_asciidoc\
        "${global_name}" 'global' "${global_prototype}" "${global_asciidoc}"
}

# ....................{ DOCUMENTERS ~ private              }....................
#FIXME: Document me.
# void ::document_runnable[
#     args:  string runnable_type,
#     stdin: string runnable_documentation]
function ::document_runnable() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one runnable type.'
    local\
        runnable_type="${1}"\
        runnable_help\
        runnable_prototype\
        runnable_asciidoc
    local -a runnable_names

    # Documentation passed on standard input.
    :set_string_to_stdin_help runnable_help

    # Split such documentation into prototype and non-prototype portions.
    :set_strings_to_help_prototype_asciidoc\
        runnable_prototype runnable_asciidoc "${runnable_help}"

    # Set of all runnable names declared by such documentation's prototype.
    :set_list_to_runnable_prototype_names runnable_names "${runnable_prototype}"

    # Document such names.
    ::document_operable_typed_with_prototype_asciidoc\
        "${runnable_names[@]}"\
        'runnable'\
        "${runnable_prototype}"\
        "${runnable_asciidoc}"
}

#FIXME: Document me.
# void ::document_alias_typed_with_prototype_asciidoc(
#     string alias_name1, ...,
#     string alias_type,
#     string alias_prototype,
#     string alias_asciidoc)
function ::document_alias_typed_with_prototype_asciidoc() {
    # Validate sanity.
    (( # >= 4 )) || :die\
        'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
    local alias_type="${@[-3]}"

    # If such type is unrecognized, throw an exception.
    [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
        'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # Document such alias.
    ::document_operable_typed_with_prototype_asciidoc\
        "${@[1,-4]}" "alias_${alias_type}" "${@[-2]}" "${@[-1]}"
}

#FIXME: Document me.
# void ::document_func_with_prototype_asciidoc(
#     string func_name1, ...,
#     string func_prototype,
#     string func_asciidoc)
function ::document_func_with_prototype_asciidoc() {
    (( # >= 3 )) || :die\
        'Expected one or more function names, one function prototype, and one asciidoc string.'
    ::document_operable_typed_with_prototype_asciidoc\
        "${@[1,-3]}" 'func' "${@[-2]}" "${@[-1]}"
}

#FIXME: Document me.
# void ::document_operable_typed_with_prototype_asciidoc(
#     string operable_name1, ...,
#     string operable_type,
#     string operable_prototype,
#     string operable_asciidoc)
function ::document_operable_typed_with_prototype_asciidoc() {
    # Validate sanity.
    (( # >= 4 )) || :die\
        'Expected one or more operable names, one type string, one prototype string, and one asciidoc string.'
    local\
        operable_type="${@[-3]}"\
        prototype="${@[-2]}"\
        asciidoc="${@[-1]}"\
        heredoc_delimiter='/---/---/---'\
        prototype_setter_name\
        asciidoc_setter_name

    # Pop such arguments from the argument list. See pop_args_3() for further
    # details.
    argv[-3,-1]=()

    # If either such prototype or AsciiDoc contains a line equal to the
    # here-doc delimiter delimiting such strings below, throw an exception.
    if [[ "${prototype}"$'\n'"${asciidoc}" == (|*$'\n')"${heredoc_delimiter}"(|$'\n'*) ]] {
        :die 'Documentation line equals here-doc delimiter "'${heredoc_delimiter}'".'
    }

    # For each such operable name, define:
    #
    # * A setter setting a passed string variable to such prototype.
    # * A setter setting a passed string variable to such AsciiDoc.
    #
    # To avoid quoting issues with reserved characters in such documentation,
    # set such variable via a here-document.
    local operable_name
    for   operable_name ("${@}") {
        # Names of such functions to be defined.
        prototype_setter_name="${ZESHY_HELP_SETTER_NAME_PREFIX}${operable_type}_prototype:${operable_name}"
        asciidoc_setter_name="${ZESHY_HELP_SETTER_NAME_PREFIX}${operable_type}_asciidoc:${operable_name}"

        # Define such functions.
        functions[${prototype_setter_name}]='
    die_unless_arg "Expected one string name."
    set_string_to_stdin "${1}" <<'''${heredoc_delimiter}'''
'${prototype}'
'${heredoc_delimiter}
        functions[${asciidoc_setter_name}]='
    die_unless_arg "Expected one string name."
    set_string_to_stdin "${1}" <<'''${heredoc_delimiter}'''
'${asciidoc}'
'${heredoc_delimiter}
    }
}

# --------------------( WASTELANDS                         )--------------------
    # # Validate sanity.
    # (( # >= 4 )) || :die\
    #     'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
    # local\
    #     alias_type="${@[-3]}"\
    #     prototype="${@[-2]}"\
    #     asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_3() for further
    # # details.
    # argv[-3,-1]=()

    # # If such type is unrecognized, throw an exception.
    # [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
    #     'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # # Document such alias.
    # ::document_operable_typed_with_prototype_asciidoc\
    #     "${@}" "alias_${alias_type}" "${prototype}" "${asciidoc}"

    # # Validate sanity.
    # (( # >= 3 )) || :die\
    #     'Expected one or more function names, one function prototype, and one asciidoc string.'
    # local prototype="${@[-2]}" asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_2() for further
    # # details.
    # argv[-2,-1]=()

    # # Document such function.
    # ::document_operable_typed_with_prototype_asciidoc\
    #     "${@}" 'func' "${prototype}" "${asciidoc}"

#FUXME: Rename to ::document_operable_typed_with_prototype_asciidoc().
#FUXME: Actually, rename to ::document_operable_with_prototype_asciidoc().

 # IMPORTANT: Note in such documentation that neither such
#prototype or AsciiDoc may contain
#FUXME: Arguably, such functions pertain to a new parcel -- say, @{20-document}.
