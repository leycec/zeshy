#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

#FIXME: We need to support disjunctive prototypes. Consider this function,
#which can be called in at least two fundamentally distinct ways. To permit
#this, I suggest extending our "{...,...}" syntax yet again as follows:
#
#    {void declare_global(
#        string global_type,
#        string global_name_with_optional_value,
#        string documentation),
#     void declare_global(string documentation)}
#
#We *REALLY* don't want to have to implement a non-regular context-free parser.
#Fortunately, we won't have to. Simply hard-code an outermost "(...|...)"-style
#PCRE, where the first sub-PCRE in such PCRE matches the conventional singular
#prototype (i.e., lacking exterior "{" and "}" delimeters) and the final
#sub-PCRE in such PCRE matches the above plural prototype (i.e., with exterior
#"{" and "}" delimeters).
#FIXME: Document the fact that global values may actually be delimited by an
#arbiratry number of "=" delimiters, in which case this function defines *ALL*
#such globals to be synonyms of each other assigned the same initial value.
#Required elsewhere. Sweet, eh?

#FIXME: Naturally, AsciiDoc will be an only optional dependency for users
#attempting to build the documentation. If not installed, we'll just display
#function documentation as is when a user runs "help function". If installed,
#we'll probably want to pipe function documentation dynamically through either
#the ASCII or man page exporters. (Sweeeeeet, no?)
#FIXME: Source code highlighting is simple. Just write:
#
#    [source,bash]
#    ----
#    INSERT CODE HERE
#    ----
#
#Sadly, neither Pygments or other less popular alternatives support zsh yet.
#Hence, "bash" suffices. Then, we want to selectively prefer "pygments" where
#available. To do so, we'll need to output the following at the very top of each
#AsciiDoc document we send to "asciidoc":
#
#    8<---------------
#    = Title
#    :source-highlighter: pygments
#
#This is an AsciiDoc header instructing "asciidoc" to prefer the "pygments"
#backend for the [source] filter. For further details, see:
#    https://groups.google.com/forum/?fromgroups=#!topic/asciidoc/ReIM4z-zi9I
#FIXME: Avoid repetition. In particular, replace "[source,bash]" with simply
#"[source]" everywhere by setting the default "language" in the AsciiDoc
#document header, like so:
#
#    :language: bash
#
#The same style can be extended to set default table attributes as follows:
#
#    :grid:  none
#    :frame: topbot

#FIXME: We're certain we've documented this elsewhere, but the correct approach
#to documentation is to segregate *EACH* bit of documentation into its own
#setter function setting a passed string variable to the documentation for the
#desired object: e.g.,
#
#    # Set such string variable to the help string for function
#    # ::define_func().
#    void ::set_string_to_help:func::define_func(void string_name)
#
#Naturally, *ALL* such setters should be compiled into a *NEW, SEPARATE* digest
#file (e.g., "~/.zeshy/cache/digest/help.zwc"), which doesn't depend on whether
#or not this is a debug or release build of zeshy and hence applies to *ALL*
#possible main zeshy digests.
#
#How does segregating such setters to such digest help us? Simple. By default,
#such digest is *NOT* listed in the function path ${fpath}. In fact, *ONLY* low-
#level helper functions (e.g., :print_help_function()) internally and only
#temporarily prepend such digest to a local shadowing of ${fpath}. Indeed, such
#functions should probably temporarily reduce ${fpath} to *ONLY* such digest.
#
#Indeed, such technique provides a memorable means of implementing highly
#efficient, pure-zeshy read-only key-value stores, as I believe we've remarked
#elsewhere.
#FIXME: I'm unsure if I've documented it anywhere... so, it had might as well be
#here. The nomenclature for synthesized help function names should be:
#
#* For aliases, "::set_string_to_help:alias:${alias_name}".
#* For functions, "::set_string_to_help:function:${function_name}".
#* For globals, "::set_string_to_help:global:${global_name}".
#
#Simple. Note that in the case of normal ":"-suffixed aliases and functions,
#the corresponding help function names will also be suffixed by ":" -- which is,
#of course, perfect. Lookin good, eh?

#FIXME: It'd be great to support specification of whether a function or alias
#argument is actually mandatory or optional in variadic lists. For example, in
#the following function prototype, all arguments except the first menu name are
#actually optional -- but we have no way of indicating that at the moment:
#
#    string show_info_menu_with_options(
#        string info_option1, string info_option2, ...,
#        string menu_name1, string menu_name2, ...)
#
#I propose a simple suffix "?" on all optional variadic arguments: e.g.,
#
#    string show_info_menu_with_options(
#        string info_option1?, string info_option2?, ...,
#        string menu_name1, string menu_name2?, ...)
#
#Fairly simple *AND* legible, yes?

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

# ....................{ DOCUMENTERS                        }....................
#FIXME: Document me.
# void :document_alias_simple[stdin: alias_documentation]
function :document_alias_simple() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'alias_simple'
}

#FIXME: Document me.
# void :document_alias_global[stdin: alias_documentation]
function :document_alias_global() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'alias_global'
}

#FIXME: Document me.
# void :document_alias_suffix[stdin: alias_documentation]
function :document_alias_suffix() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'alias_suffix'
}

#FIXME: Document me.
# void :document_func[stdin: func_documentation]
function :document_func() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable 'func'
}

#FIXME: Document me.
# void :document_global[stdin: global_documentation]
function :document_global() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'
    local global_help global_name global_prototype

    # Documentation passed on standard input.
    :set_string_to_stdin_help global_help

    # Prototype prefixing such documentation.
    :set_string_to_help_prototype global_prototype "${global_help}"

    #FIXME: Define such setter!

    # Global name declared by such documentation's prototype.
    :set_string_to_global_prototype_name global_name "${global_prototype}"

    # Document such names.
    ::document_operable_of_type_with_help\
        "${global_name}" 'global' "${global_help}"
}

# ....................{ DOCUMENTERS ~ private              }....................
#FIXME: Document me.
# void ::document_runnable[
#     args:  runnable_type,
#     stdin: runnable_documentation]
function ::document_runnable() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one runnable type.'
    local runnable_type="${1}" runnable_help runnable_prototype
    local -a runnable_names

    # Documentation passed on standard input.
    :set_string_to_stdin_help runnable_help

    # Prototype prefixing such documentation.
    :set_string_to_help_prototype runnable_prototype "${runnable_help}"

    # Set of all runnable names declared by such documentation's prototype.
    :set_list_to_runnable_prototype_names runnable_names "${runnable_prototype}"

    # Document such names.
    ::document_operable_of_type_with_help\
        "${runnable_names[@]}" "${runnable_type}" "${runnable_help}"
}

#FIXME: Document me.
# void ::document_operable_of_type_with_help(
#     string operable_name1, ...,
#     string operable_type,
#     string operable_help)
function ::document_operable_of_type_with_help() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more operable names, one operable type, and one help string.'
    local operable_type="${@[-2]}" operable_help="${@[-1]}" setter_name

    # Pop such type and documentation from the argument list. See pop_args_2()
    # for further details.
    argv[-2,-1]=()

    # For each such name, define a setter setting a passed string variable to
    # such documentation. To avoid quoting issues with reserved characters in
    # such documentation, set such variable via a here-document.
    local operable_name
    for   operable_name ("${@}") {
        setter_name=":set_string_to_${operable_type}_help:${operable_name}"
        functions[${setter_name}]='
    die_unless_arg "Expected one string name."
    set_string_to_stdin "${1}" <<''/---''
'${operable_help}'
/---'
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Arguably, such functions pertain to a new parcel -- say, @{20-document}.
