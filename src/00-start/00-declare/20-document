#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

#FIXME: We *ABSOLUTELY* need to declare this parcel earlier -- at least before
#={15-set}. Assuming we need to call any functions from such parcel, we'll have
#to split ={15-set} into two new trees -- say, ={15-set} defining only the
#small subset of setters required by this parcel and ={25-set} defining the
#remainder. How large of a subset is this, anyway?

#FIXME: For efficiency, declaration functions in this and other parcels should
#only define help functions when actually compiling help documentation and
#hence utilizing such functions. (Or do we *ALWAYS* compile such
#documentation?) Contemplate.

#FIXME: Document the fact that global values may actually be delimited by an
#arbiratry number of "=" delimiters, in which case this function defines *ALL*
#such globals to be synonyms of each other assigned the same initial value.
#Required elsewhere. Sweet, eh?

#FIXME: We're certain we've documented this elsewhere, but the correct approach
#to documentation is to segregate *EACH* bit of documentation into its own
#setter function setting a passed string variable to the documentation for the
#desired object: e.g.,
#
#    # Set such string variable to the help string for function
#    # ::define_func().
#    void ::set_string_to_help:func::define_func(void string_name)
#
#Naturally, *ALL* such setters should be compiled into a *NEW, SEPARATE* digest
#file (e.g., "~/.zeshy/cache/digest/help.zwc"), which doesn't depend on whether
#or not this is a debug or release build of zeshy and hence applies to *ALL*
#possible main zeshy digests.
#
#How does segregating such setters to such digest help us? Simple. By default,
#such digest is *NOT* listed in the function path ${fpath}. In fact, *ONLY* low-
#level helper functions (e.g., :print_help_function()) internally and only
#temporarily prepend such digest to a local shadowing of ${fpath}. Indeed, such
#functions should probably temporarily reduce ${fpath} to *ONLY* such digest.
#
#Indeed, such technique provides a memorable means of implementing highly
#efficient, pure-zeshy read-only key-value stores, as I believe we've remarked
#elsewhere.

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

# ....................{ SETTERS                            }....................
#FIXME: Document me.

# :void ::help.set_to_stdin[
#     args = (^:string documentation_name),
#     stdin = (:string documentation)]
function ::help.set_to_stdin() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception; else, set the passed string to such input.
    :string.set_to_stdin_if_found "${1}" || :die\
        'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'
}

#FIXME: Document me.

# :void ::help.set_prototype,asciidoc(
#     :string documentation,
#     ^:string prototype_name,
#     ^:string asciidoc_name)
function ::help.set_prototype,asciidoc() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one help string, one prototype string, and one AsciiDoc string name.'
    local\
        help__ssthp="${1}"\
        prototype_name__ssthp="${2}"\
        asciidoc_name__ssthp="${3}"

    # If such documentation contains a blank line (i.e., "\n\n"), assume the
    # substring preceding such line to be the expected prototype. Else, throw
    # an exception.
    [[ ${help__ssthp} == ${~ZESHY_HELP_GLOB} ]] || :die\
        'Documentation invalid (i.e., contains no blank line separating prototype from non-prototype sections):'$'\n\n'${help__ssthp}

    # Set such strings.
    :string.set "${prototype_name__ssthp}" "${match[1]}"
    :string.set "${asciidoc_name__ssthp}"  "${match[2]}"
}

# ....................{ DOCUMENTERS ~ alias                }....................
#FIXME: Document me.
# :void :alias_simple.document[stdin = (:string alias_documentation)]
function :alias_simple.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable_type,label_with_stdin 'alias_simple' 'Simple alias'
}

#FIXME: Document me.
# :void :alias_global.document[stdin = (:string alias_documentation)]
function :alias_global.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable_type,label_with_stdin 'alias_global' 'Global alias'
}

#FIXME: Document me.
# :void :alias_suffix.document[stdin = (:string alias_documentation)]
function :alias_suffix.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable_type,label_with_stdin 'alias_suffix' 'Suffix alias'
}

#FIXME: Document me.
# :void ::alias.document_prototype,stdin_of_type_if_found_or_noop[
#     args = (
#         :string/alias alias_name1, ...,
#         :string alias_prototype,
#         :string alias_type)
#     stdin = (:string alias_asciidoc)]
function ::alias.document_prototype,stdin_of_type_if_found_or_noop() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more alias names, one alias prototype, and one alias type.'
    local alias_prototype="${@[-2]}" alias_type="${@[-1]}"

    # If such type is unrecognized, throw an exception.
    [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
        'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # If such documentation was passed, document such aliases.
    ::document_operable_with_type,prototype,stdin_if_found_or_noop\
        "${@[1,-3]}" "alias_${alias_type}" "${alias_prototype}"
}

# ....................{ DOCUMENTERS ~ func                 }....................
#FIXME: Document me.
# :void :func.document[stdin = (:string func_documentation)]
function :func.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::document_runnable_type,label_with_stdin 'func' 'Function'
}

#FIXME: Document me.
# :void ::func.document_with_prototype,stdin_if_found_or_noop[
#    args = (
#        :string func_name1, ...,
#        :string func_prototype),
#    stdin = (:string func_asciidoc)]
function ::func.document_with_prototype,stdin_if_found_or_noop() {
    (( # >= 2 )) || :die\
        'Expected one or more function names and one function prototype.'
    ::document_operable_with_type,prototype,stdin_if_found_or_noop\
        "${@[1,-2]}" 'func' "${@[-1]}"
}

# ....................{ DOCUMENTERS ~ global               }....................
#FIXME: Document me.
# :void :global.document[stdin = (:string global_documentation)]
function :global.document() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'
    local global_help__dg global_prototype__dg global_asciidoc__dg
    local -a global_names__dg

    # Documentation passed on standard input.
    ::help.set_to_stdin global_help__dg

    # Split such documentation into prototype and non-prototype portions.
    ::help.set_prototype,asciidoc\
        "${global_help__dg}" global_prototype__dg global_asciidoc__dg

    # Global name declared by such documentation's prototype.
    :set_list_to_global_prototype_names\
        global_names__dg "${global_prototype__dg}"

    # Document such names.
    ::document_operable_with_type,prototype,asciidoc\
        "${global_names__dg[@]}"\
        'global'\
        "${global_prototype__dg}"\
        "${global_asciidoc__dg}"
}

# ....................{ DOCUMENTERS ~ low-level            }....................
#FIXME: Document me.
# void ::document_operable_with_type,prototype,stdin_if_found_or_noop[
#     args: (
#        string operable_name1, ...,
#        string operable_type,
#        string operable_prototype),
#     stdin: string runnable_documentation]
function ::document_operable_with_type,prototype,stdin_if_found_or_noop() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more operable names, one operable type, and one operable prototype.'
    local operable_asciidoc__dotpwsifon

    # If documentation was passed on standard input, document such operables
    # with such documentation.
    if { :string.set_to_stdin_if_found operable_asciidoc__dotpwsifon } {
        ::document_operable_with_type,prototype,asciidoc\
            "${@}" "${operable_asciidoc__dotpwsifon}"\
    }
}

#FIXME: Document me.
# void ::document_runnable_type,label_with_stdin[
#     args: (string runnable_type, string runnable_label),
#     stdin: string runnable_documentation]
function ::document_runnable_type,label_with_stdin() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one runnable type and one runnable label.'
    local\
        runnable_type="${1}"\
        runnable_label="${2}"\
        runnable_help\
        runnable_prototype\
        runnable_asciidoc
    local -a runnable_names

    # Documentation passed on standard input.
    ::help.set_to_stdin runnable_help

    # Split such documentation into prototype and non-prototype portions.
    ::help.set_prototype,asciidoc\
         "${runnable_help}" runnable_prototype runnable_asciidoc

    # Set of all runnable names declared by such documentation's prototype.
    ::runnable_prototype.set_names_of_label\
        "${runnable_prototype}" runnable_names "${runnable_label}"

    # Document such names.
    ::document_operable_with_type,prototype,asciidoc\
        "${runnable_names[@]}"\
        "${runnable_type}"\
        "${runnable_prototype}"\
        "${runnable_asciidoc}"
}

#FIXME: Document me.
#FIXME: Suffix all locals with "__dotwpa", as globals are operables too.

# void ::document_operable_with_type,prototype,asciidoc(
#     string operable_name1, ...,
#     string operable_type,
#     string operable_prototype,
#     string operable_asciidoc)
function ::document_operable_with_type,prototype,asciidoc() {
    # Validate sanity.
    (( # >= 4 )) || :die\
        'Expected one or more operable names, one type string, one prototype string, and one asciidoc string.'
    local\
        operable_type="${@[-3]}"\
        prototype="${@[-2]}"\
        asciidoc="${@[-1]}"\
        heredoc_delimiter='/---/---/---'\
        prototype_setter_name\
        asciidoc_setter_name

    # Pop such arguments from the argument list. See pop_args_3() for further
    # details.
    argv[-3,-1]=()

    # If either such prototype or AsciiDoc contains a line equal to the
    # here-doc delimiter delimiting such strings below, throw an exception.
    [[ "${prototype}"$'\n'"${asciidoc}" != (|*$'\n')"${heredoc_delimiter}"(|$'\n'*) ]] || :die\
        'Documentation contains here-doc delimiter "'${heredoc_delimiter}'" reserved for internal zeshy use only.'

    # For each such operable name, define:
    #
    # * A setter setting a passed string variable to such prototype.
    # * A setter setting a passed string variable to such AsciiDoc.
    #
    # To avoid quoting issues with reserved characters in such documentation,
    # set such variable via a here-document.
    local operable_name
    for   operable_name ("${@}") {
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize changes to such names with
        # ::set_string_to_operable_type_prototype() and
        # ::set_string_to_operable_type_asciidoc().
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # Names of such functions to be defined.
        prototype_setter_name="::set_string_to_${operable_type}_prototype:${operable_name}"
        asciidoc_setter_name="::set_string_to_${operable_type}_asciidoc:${operable_name}"

        # If any such function is already defined, throw an exception.
        :func.die_if "${prototype_setter_name}" "${asciidoc_setter_name}"

        #FIXME: We'll need to shift set_string_to_stdin() to @{*-set} for
        #reliability with early-defined functions (e.g., :declare_alias()).

        # Define such functions.
        functions[${prototype_setter_name}]='
    (( # == 1 )) || :die "Expected one string name."
    set_string_to_stdin "${1}" <<'''${heredoc_delimiter}'''
'${prototype}'
'${heredoc_delimiter}
        functions[${asciidoc_setter_name}]='
    (( # == 1 )) || :die "Expected one string name."
    set_string_to_stdin "${1}" <<'''${heredoc_delimiter}'''
'${asciidoc}'
'${heredoc_delimiter}
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: It'd be great to support specification of whether a function or alias
#argument is actually mandatory or optional in variadic lists. For example, in
#the following function prototype, all arguments except the first menu name are
#actually optional -- but we have no way of indicating that at the moment:
#
#    string show_info_menu_with_options(
#        string info_option1, string info_option2, ...,
#        string menu_name1, string menu_name2, ...)
#
#I propose a simple suffix "?" on all optional variadic arguments: e.g.,
#
#    string show_info_menu_with_options(
#        string info_option1?, string info_option2?, ...,
#        string menu_name1, string menu_name2?, ...)
#
#Fairly simple *AND* legible, yes?

#FUXME: I'm unsure if I've documented it anywhere... so, it had might as well be
#here. The nomenclature for synthesized help function names should be:
#
#* For aliases, "::set_string_to_help:alias:${alias_name}".
#* For functions, "::set_string_to_help:function:${function_name}".
#* For globals, "::set_string_to_help:global:${global_name}".
#
#Simple. Note that in the case of normal ":"-suffixed aliases and functions,
#the corresponding help function names will also be suffixed by ":" -- which is,
#of course, perfect. Lookin good, eh?

# ....................{ GLOBALS                            }....................
# typeset -g ZESHY_HELP_SETTER_NAME_PREFIX=':set_string_to_'

#FUXME: Document me.
# typeset -g ZESHY_OPERABLE_PROTOTYPE_SETTER_NAME_PREFIX=':set_string_to_prototype_'

#FUXME: Obsolete. Excise everywhere!

#FUXME: Replace with a new function ::func.document_with_type,prototype,stdin_if_found_or_noop() implemented as above.

# void ::func.document_with_prototype,asciidoc(
#     args: (
#         string alias_name1, ...,
#         string alias_type,
#         string alias_prototype),
#     stdin: string runnable_documentation]
# function ::func.document_with_prototype,asciidoc() {
#     (( # >= 3 )) || :die\
#         'Expected one or more function names, one function prototype, and one asciidoc string.'
#     ::document_operable_with_type,prototype,asciidoc\
#         "${@[1,-3]}" 'func' "${@[-2]}" "${@[-1]}"
# }

    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, silently report
    # succes. See ::help.set_to_stdin() for further details.
    # read -t 0 || return 0
    # print 'stdin exists!'
    # if { read -t 0 } {
    #     print 'stdin exists.'
    #     if { read -t 0 } {
    #         print 'stdin still exists.'
    #     }
    # } else {
    #     print 'stdin doesn''t exist!'
    #     return 0
    # }

    # Documentation passed on standard input.
    # ::help.set_to_stdin operable_asciidoc__dotpwsifon

    # # Document such names.
    # ::document_operable_with_type,prototype,asciidoc\
    #     "${@[1,-3]}"\
    #     "${operable_type__dotpwsifon}"\
    #     "${operable_prototype__dotpwsifon}"\
    #     "${operable_asciidoc__dotpwsifon}"

        # operable_type__dotpwsifon="${@[-2]}"\
        # operable_prototype__dotpwsifon="${@[-1]}"\

#FUXME: Use of "typed" rather than "type" nomenclature is somewhat awkward.
#Contemplate a global rename from the former to the latter.
#FUXME: Indeed, rename to simply ::document_alias_type_prototype,asciidoc().
#FUXME: Actually, rename to
#::document_stdin_with_alias_type,prototype,asciidoc_if_found_or_noop() and
#refactor to internally call ::document_runnable_type,label_with_stdin() instead.
#FUXME: Excise this.
#FUXME: Document me.
# void ::document_alias_typed_with_prototype,asciidoc(
#     string alias_name1, ...,
#     string alias_type,
#     string alias_prototype,
#     string alias_asciidoc)
# function ::document_alias_typed_with_prototype,asciidoc() {
#     # Validate sanity.
#     (( # >= 4 )) || :die\
#         'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
#     local alias_type="${@[-3]}"
# 
#     # If such type is unrecognized, throw an exception.
#     [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
#         'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'
# 
#     # Document such alias.
#     ::document_operable_with_type,prototype,asciidoc\
#         "${@[1,-4]}" "alias_${alias_type}" "${@[-2]}" "${@[-1]}"
# }

    # Shift such arguments off. See shift_arg_2() for further details.
    # argv[1,2]=()

    # (( # == 3 )) || :die\
    #     'Expected one alias type, one alias prototype, and one asciidoc string.'
#FUXME: Rename to ::func.document_prototype,asciidoc().
    #FUXME: Define such setter!

    # # Validate sanity.
    # (( # >= 4 )) || :die\
    #     'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
    # local\
    #     alias_type="${@[-3]}"\
    #     prototype="${@[-2]}"\
    #     asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_3() for further
    # # details.
    # argv[-3,-1]=()

    # # If such type is unrecognized, throw an exception.
    # [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
    #     'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # # Document such alias.
    # ::document_operable_with_type,prototype,asciidoc\
    #     "${@}" "alias_${alias_type}" "${prototype}" "${asciidoc}"

    # # Validate sanity.
    # (( # >= 3 )) || :die\
    #     'Expected one or more function names, one function prototype, and one asciidoc string.'
    # local prototype="${@[-2]}" asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_2() for further
    # # details.
    # argv[-2,-1]=()

    # # Document such function.
    # ::document_operable_with_type,prototype,asciidoc\
    #     "${@}" 'func' "${prototype}" "${asciidoc}"

#FUXME: Rename to ::document_operable_with_type,prototype,asciidoc().
#FUXME: Actually, rename to ::document_operable_with_prototype,asciidoc().

 # IMPORTANT: Note in such documentation that neither such
#prototype or AsciiDoc may contain
#FUXME: Arguably, such functions pertain to a new parcel -- say, @{20-document}.
