#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle global variable declarers.
/---

#FIXME: There may, after all, be a means of defining non-scalar globals in a
#similar manner. Consider the dynamic block alias resembling:
#
#    :declare_global_list_ my_list :declare_global_list{
#        # This appears to be a list.
#        'But,' 'good Sir,' 'is it' my list?
#    }:declare_global_list <<'/---'
#    My list.
#    /---
#
#Is such alias implementable? Possibly. Consider the following:
#
#    :alias_simple :declare_global_list{='
#        : "${(zAP)ZESHY_DECLARE_GLOBAL_LIST_NAME__::='
#    :alias_simple }:declare_global_list='}"'
#
#Let's be honest: it probably won't work. But it's a fairly clever try. Shall
#we at least try her out?

# ....................{ GLOBALS                            }....................
# Due to a chicken-and-the-egg problem, all such globals are subsequently
# documented under @{help} in the main codebase.

#FIXME: Shift to @{*-glob}.
#FIXME: Actually, shift this to @{*-main/zsh/var/var}.

# Glob matching zsh variable names. Dismantled, this is:
#
# * "[a-zA-Z_]", matching the first character of a valid zsh variable name.
# * "[a-zA-Z0-9_]#", matching all remaining characters of such name.
typeset -g ZESHY_VAR_NAME_GLOB='[a-zA-Z_][a-zA-Z0-9_]#'

#FIXME: Shift to @{*-glob}.
#FIXME: Actually, just excise.

# Glob matching zsh variable names preceding the value to initialize such names
# to in "zeshy"-specific global declarations. Dismantled, this is:
#
# * '(#b)((...)#)', capturing all such names to ${match[1]}. 
# * '(#B)(...=)', matching but *NOT* capturing each such "="-suffixed name.
# * '(*)', capturing such value to ${match[2]}.
typeset -g ZESHY_DECLARATION_GLOBAL_NAMES_AND_VALUE_GLOB='(#b)((#B)('${ZESHY_VAR_NAME_GLOB}'=)#)(*)'

#FIXME: Declare a new map ${ZESHY_GLOBAL_NAME_TO_GLOBAL_NAME_FIRST}. While
#recording synonyms will (of course) be nice, the principal use of such map
#should be in printing a warning or dying entirely if such global has already
#been declared... which I believe we currently don't check!
#FIXME: Waaait! No. Probably just excise this global. See @{10-function}.

# Map from global names to the help strings documenting such globals. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.
typeset -Ag ZESHY_GLOBAL_NAME_TO_HELP

# ....................{ DECLARERS                          }....................
:func_ ':void :declare_global[
    args =  (:string_nonempty global_type,
             :string global_names_and_optional_value),
    stdin = (:string global_asciidoc)]' :func{
    # Localize arguments.
    local\
        global_type__dg="${1}"\
        global_names_and_value__dg="${2}"\
        global_value__dg\
        global_definer__dg\
        global_asciidoc__dg
    integer is_global_value__dg
    local -a global_names__dg

    # Documentation passed on standard input.
    :set_string_to_stdin_help global_asciidoc__dg

    # If one or more global names *AND* optional value was declared, note this.
    :set_list,string,bool_to_global_names,value,is_value\
        global_names__dg\
        global_value__dg\
        is_global_value__dg\
        "${global_names_and_value__dg}"

    # If such value is nonempty and such type is nonscalar, throw an exception.
    # See function documentation for further details.
    if (( is_global_value__dg )) &&
       [[ "${global_type__dg}" == ':'('list'|'map')('_'*|) ]] {
        :die ${global_type__dg}' global(s) "'${global_names__dg[*]}'" nonscalar and hence uninitializable to "'${global_value__dg}'".'
    }

    # Name of the alias declaring globals of such type. Since nonscalar globals
    # cannot be exported *AND* since unconditionally exporting scalar globals
    # introduces unwanted side effects (e.g., inheritance of such globals by
    # child shells, conflicting with discovery of zeshy-specific globals at
    # digest file recompilation time), declare such global to be non-exported.
    global_definer__dg="${global_type__dg}_global"

    #FIXME: Start here on the morrow.

    # For each such global...
    local global_name__dg
    for   global_name__dg ("${global_names__dg[@]}") {
        # Function defining such global.
        local global_definer=":define_global_${global_type}"
        :die_unless_func "${global_definer}"

        # Define such global.
        "${global_definer}" "${global_name}" "${global_code}"

        # Append such global to the current parcel *AFTER* successfully defining
        # such global.
        add_parcel_global "${ZESHY_PARCEL_NAME}" "${global_name__dg}"
    }

    # If such alias does not exist, throw an exception. Since such alias
    # could technically also be a function, match both. See is_runnable()
    # for further details.
#   print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
    whence -- "${declarator__dg}" &>/dev/null || :die\
        'Global type "'${global_type__dg}'" unrecognized (i.e., '${declarator__dg}'() undefined).'

    # Declare such globals. Since the declarator is typically an alias rather
    # than function or pathable, zsh requires evaluating rather than running
    # such declarator. While acceptable, this is somewhat... annoying.
    #
    # Before doing so, we should ideally test whether such global already exists
    # and if so either throw an exception or print a warning. Unfortunately,
    # there exists no efficient means of implementing such test. While there do
    # exist efficient means of testing whether a variable either local or global
    # exists and whether such variable in the *CURRENT* scope is local or global,
    # the only means of testing whether a global exists is to parse the output
    # of "typeset -gx +" for a line matching such global's name. While such
    # parsing could conceivably be efficient for infrequent purposes, declaring
    # globals is not an infrequent purpose.
    local global_name__dg
    for   global_name__dg ("${global_names__dg[@]}") {
        # If such value exists, declare such global initialized to such value.
        # Since such name *MUST* be expanded before evaluating such statement,
        # this eval() *CANNOT* be extracted outside this "for" loop as would
        # commonly be the case.
        if [[ -n "${global_value__dg}" ]] {
            eval ${declarator__dg}' '${global_name__dg}'="${global_value__dg}"'
        # Else, declare such global initialized to a default value.
        } else {
            eval ${declarator__dg}' '${global_name__dg}
        }

        # Map such global to such help string.
        ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"

        # Add such global to the current parcel.
        add_parcel_global "${ZESHY_PARCEL_NAME}" "${global_name__dg}"
    }

    # Document such globals with such documentation *AFTER* successfully
    # defining such globals above.
    ::document_global_typed_with_prototype,asciidoc\
        "${global_names[@]}"\
        "${global_type}"\
        "${global_prototype}"\
        "${global_asciidoc}"
}:func <<'/---'
FIXME: Placeholder.
/---

# ....................{ OBSOLETE                           }....................
#FIXME: Excise *ALL* such functionality.
#FIXME: Optional arguments are terrible. Require passed types *AND* names. (If
#the caller only wants to document an existing global, they can very well call
#:document_global() -- which, of course, is how we should have designed such
#functionality originally. *sigh*)

declare_function_with_stdin <<'/---'
void declare_global(
    string global_type = "",
    string global_name_with_optional_value = "",
    string documentation)

Declare the specified variable to be an exported global contained by the current
parcel and documented by the passed help string, where such variable is
specified by either:

* The passed variable type and name arguments, if such arguments are passed.
* The variable declaration prefixing the passed help string, otherwise.

If a variable name is passed, a `zeshy`-specific variable type must also be
passed (e.g., `boolean`, `string`). If such name contains a `=` delimiter _and_
such type is:

* *Scalar* (e.g., `integer`, `string`), the (possibly empty) substring of such
  name following such delimiter defines the *initial value* to initialize such
  global to: e.g.,
+
.declare_global() Scalar Initialization
==========================================
[source]
------------------------------------------
>>> declare_global string on_industry=\
...     "If a man walk in the woods for love of them half of each day, he is in
...      danger of being regarded as a loafer; but if he spends his whole day as
...      a speculator, shearing off those woods and making Earth bald before her
...      time, he is esteemed an industrious and enterprising citizen. As if a
...      town had no interest in its forests but to cut them down!"\
...     "Most men would feel insulted if it were proposed to employ them in
...      throwing stones over a wall, and then in throwing them back, merely
...      that they might earn their wages. But many are no more worthily
...      employed now."
>>> get_string_line "${on_industry}" -1
town had no interest in its forests but to cut them down!
------------------------------------------
==========================================
* *Nonscalar* (e.g., `list`, `map`), an exception is thrown. As with customary
  `zsh` variable declarations, nonscalar globals may only be initialized to an
  initial value _after_ rather than when declaring such globals: e.g.,
+
.declare_global() Nonscalar Initialization
==========================================
[source]
------------------------------------------
>>> declare_global "
...     list on_anarchism
...
...     Anarchism is not a romantic fable but the hardheaded realization, based
...     on five thousand years of experience, that we cannot entrust the
...     management of our lives to kings, priests, politicians, generals, and
...     county commissioners."
>>> on_anarchism=(
...     "Anarchism is founded on the observation that since few men are wise"
...     "enough to rule themselves, even fewer are wise enough to rule others."
... )
>>> print_string "${on_anarchism[1]}"
Anarchism is founded on the observation that since few men are wise
------------------------------------------
==========================================

== Variable Type ==

A global's type may be any alphanumeric string for which an alias of the same
name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
global type but `order_of_the_blackened_denarius` is not, since
file_descriptor_global_export() is an existing alias but
order_of_the_blackened_denarius_global_export() is (hopefully) not.

`zeshy` provides numerous such aliases and hence variable types, including:
boolean(), character(), file_descriptor(), float(), integer(), list(),
list_set(), map(), and string().

== Variable Documentation ==

Global help strings consist of:

. A *variable declaration* in `zeshy`-specific C-like syntax consisting of one
  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`), if such type and name
  were _not_ passed as arguments already.
. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
  with `zeshy`-specific markup for cross-referencing other `zeshy` documentation.
  Since single- and double-quoted `zsh` string syntax conflicts with such syntax,
  consider passing such description to declare_global_with_stdin() as a
  here-document on standard input instead.

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):

.Variable Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
| GlobalName            | <- | AlphanumericString
|===============================================================================
/---
# Technically, this function *COULD* attempt to initialize nonscalar globals to
# initial values. Doing so, however, requires the following inconveniences:
#
#* Disabling filename globbing on this function by adding function attribute
#  "<globbable>". This permits shell-reserved delimiters (e.g., "[", "]") to be
#  used for delimiting such values.
#* Delimiting such values by "[" and "]" rather than "(" and ")". The latter
#  induces zsh to compact all list or map elements into a single string.
#* Suffixing each list or map element line by "\".
#
# Of these, the latter is arguably the most unctuous, substantially impeding the
# conversion of existing nonscalar initializations to such format. In any case,
# such inconveniences remain *TOO* inconvenient.
function declare_global() {
    # Validate passed arguments.
    (( # == 1 || # == 3 )) || :die\
        'Expected either: one help string; or one variable type, one variable name (with optional "="-delimited variable value), and one help string.'
    local\
        help__dg="${@[-1]}"\
        global_type__dg\
        global_names_string__dg\
        global_value__dg\
        declarator__dg
    integer is_global_type_nonscalar__dg
    list global_names__dg

    # Truncate such help string from the argument list. See pop_arg() for
    # further details.
    argv[-1]=()

    # If passed a variable type and name and help string, localize such
    # arguments. As this is the common case, handle this condition first. Note
    # this test accounts for the prior removal of the last argument.
    if (( # == 2 )) {
        # Localize such arguments.
        global_type__dg="${1}"
        global_names_string__dg="${2}"

        # Prepend such help string with such variable declaration.
        help__dg="${global_type__dg} ${global_names_string__dg}"$'\n\n'"${help__dg}"

        # If such variable names string matches a single variable name, set the
        # list of such names to such name.
        if [[ "${global_names_string__dg}" ==\
               ${~ZESHY_VAR_NAME_GLOB} ]] {
            global_names__dg=( "${global_names_string__dg}" )
        # Else if such variable names string matches "="-delimited variable
        # assignment syntax, split such string on the final "=" into one
        # substring of one or more variable names and one variable value.
        #
        # Since zsh prohibits variable names but *NOT* values from containing
        # "=", attempting to split such names on "=" via parameter expansion
        # flag "(s)" does *NOT* suffice. Instead, match such names iteratively
        # with predefined PCREs.
        } elif [[ "${global_names_string__dg}" ==\
                   ${~ZESHY_DECLARATION_GLOBAL_NAMES_AND_VALUE_GLOB} ]] {
            # Such variable names string reduced to only such names.
            global_names_string__dg="${match[1]}"

            # Such variable value.
            global_value__dg="${match[2]}"

            # Prepare to match such names from such string. See
            # for_string_text_matching_pcre:() for further details.
            pcre_compile -- "${ZESHY_PROTOTYPE_GLOBAL_NAMES_NEXT_PCRE}"
            pcre_study

            # Append each such name to such list.
            local ZPCRE_OP='0 0'
            while {
                pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${global_names_string__dg}"
            } {
                global_names__dg+="${match[1]}"
            }
        # Else, such variable names string is invalid. Throw an exception.
        } else {
            :die 'Global declaration "'${global_type__dg}' '${global_names_string__dg}'" invalid.'
        }
    # Else, only a help string was passed. Dynamically parse such type and name
    # from the variable declaration prefixing such string.
    } else {
        #FIXME: Generalize to support variable name synonyms, as with aliases
        #and functions. Don't bother trying to wrestle support for "="-delimited
        #assignment into such syntax, however. Not worth it; clearly, if the
        #caller wants to assign a global, they should use the existing syntax.

        # Match the variable type and name from such declaration or throw an
        # exception if such match fails. Dismantled, this is:
        #
        # * "(#b)", capturing match groups into list global ${match}.
        # * "[[:space:]]#", matching optional whitespace.
        # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
        # * "[[:space:]]##", matching mandatory whitespace.
        [[ "${help__dg}" ==\
            (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##(${~ZESHY_VAR_NAME_GLOB})* ]] || :die\
             'Global prototype "'${help__dg}'" invalid.'

        # Localize such type and name.
        global_type__dg="${match[1]}"
        global_names__dg=( "${match[2]}" )
    }

    # If such type is empty, throw an exception.
    [[ -n "${global_type__dg}" ]] || :die 'Expected nonempty global type.'

    # If such value is nonempty and such type is nonscalar, throw an exception.
    # See function documentation for further details.
    if [[ -n "${global_value__dg}" &&\
             "${global_type__dg}" == (list|map)(_*|) ]] {
        :die ${global_type__dg}' global(s) "'${global_names__dg[*]}'" nonscalar and hence uninitializable to "'${global_value__dg}'".'
    }

    # Set the name of the alias declaring globals of such type. Since nonscalar
    # globals cannot be exported and since unconditionally exporting all scalar
    # globals introduces unwanted side effects (e.g., inheritance of all scalar
    # globals by child shells, conflicting with discovery of zeshy-specific
    # globals at digest file recompilation time), declare such global to be
    # non-exported.
    declarator__dg="${global_type__dg}_global"

    # If such alias does not exist, throw an exception. Since such alias
    # could technically also be a function, match both. See is_runnable()
    # for further details.
#   print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
    whence -- "${declarator__dg}" &>/dev/null || :die\
        'Global type "'${global_type__dg}'" unrecognized (i.e., '${declarator__dg}'() undefined).'

    # Declare such globals. Since the declarator is typically an alias rather
    # than function or pathable, zsh requires evaluating rather than running
    # such declarator. While acceptable, this is somewhat... annoying.
    #
    # Before doing so, we should ideally test whether such global already exists
    # and if so either throw an exception or print a warning. Unfortunately,
    # there exists no efficient means of implementing such test. While there do
    # exist efficient means of testing whether a variable either local or global
    # exists and whether such variable in the *CURRENT* scope is local or global,
    # the only means of testing whether a global exists is to parse the output
    # of "typeset -gx +" for a line matching such global's name. While such
    # parsing could conceivably be efficient for infrequent purposes, declaring
    # globals is not an infrequent purpose.
    local global_name__dg
    for   global_name__dg ("${global_names__dg[@]}") {
        # If such value exists, declare such global initialized to such value.
        # Since such name *MUST* be expanded before evaluating such statement,
        # this eval() *CANNOT* be extracted outside this "for" loop as would
        # commonly be the case.
        if [[ -n "${global_value__dg}" ]] {
            eval ${declarator__dg}' '${global_name__dg}'="${global_value__dg}"'
        # Else, declare such global initialized to a default value.
        } else {
            eval ${declarator__dg}' '${global_name__dg}
        }

        # Map such global to such help string.
        ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"

        # Add such global to the current parcel.
        add_parcel_global "${ZESHY_PARCEL_NAME}" "${global_name__dg}"
    }
#   print -r -- "${declarator__dg} ${global_name__dg}:catch\"${(P)global_name__dg}\""
}

declare_function_with_stdin <<'/---'
<globbable> void declare_global_with_stdin[
    args: (string global_type?,
           string global_name?,
           string global_value1?, ...),
    stdin: string documentation]

Declare the specified variable to be an exported global contained by the current
parcel and documented by the passed help string, where such variable is
specified as under declare_global(). See declare_function_with_stdin() for
further details.
/---
function declare_global_with_stdin() {
    run_runnable_with_stdin declare_global "${@}"
}

# --------------------( WASTELANDS                         )--------------------
    # Validate sanity.
    # (( # == 3 )) || :die\
    #     'Expected one one global type and one "="-delimited string of one or more global names and optional value.'
    # # If such type is empty, throw an exception.
    # [[ -n "${global_type__dg}" ]] || :die 'Global type empty.'

    #     is_global_value=1
    # # Else, only one or more global names were declared. Parse such names.
    # } else {
    # }

#FUXME: Rename to ${ZESHY_PROTOTYPE_GLOBAL_NAMES_AND_VALUE_GLOB}.
# Avoid declaring documentation maps (e.g., ${ZESHY_GLOBAL_NAME_TO_HELP}); a
# precompilation hook subsequently undefines such maps to conserve memory.

# Glob matching all "="-suffixed zsh variable names preceding the value
# initializing such names to in "="-delimited global definitions. Dismantled,
# this is:
#
# * '(#b)((...)#)', capturing all such names to ${match[1]}. 
# * '(#B)(...=)', matching but *NOT* capturing each such "="-suffixed name.
# * '(*)', capturing such value to ${match[2]}.
# typeset -gx ZESHY_DECLARATION_GLOBAL_NAMES_GLOB='(#b)((#B)('${ZESHY_VAR_NAME_GLOB}'=)#)(*)'

    # # Parent directory of the current script.
    # local script_dirname; script_dirname="$(dirname -- "${ZESHY_SCRIPT_NAME}")/"

    # # ................{ GLOBALS ~ parcel                   }....................
    # # Document globals previously defined by @{*-parcel} under such parcel.
    # set_parcel_as_script "${script_dirname}"*'-parcel'

        #FUXME: This could probably be generalized to support "="-delimited
        #assignment, but I have doubts as to whether that'd be widely useful.
#Specifically, such glob captures 
#
#all `=`-suffixed global names preceding the
#value such globals will be initialized to in `=`-delimited global declarations
#into the following groups:

        #FUXME: Improper. As with aliases and functions, we instead want to
        #define a 
        # Declare such global initialized to such value. Note that such value
        # defaults to the empty string if undefined. If such type is numeric, zsh will silently "do the
        # right thing" and cast from the empty string to the intended default
        # numeric value on its assignment below.
        # declare such globals initialized to such value.

    # declare such globals initialized to such value.
#    if [[ -n "${global_value__dg}" ]] {
#        # If such type is nonscalar, throw an exception. See function
#        # documentation for further details.
#        [[ "${global_type__dg}" == (list|map)(_*|) ]] &&
#            die "${global_type__dg} global \"${global_name__dg}\" nonscalar and hence not initializable to \"${global_value__dg}\"."
#
#        # Initialize such globals.
#        for global_name__dg ("${global_names__dg[@]}") {
#            eval ${declarator__dg}' '${global_name__dg}'="${global_value__dg}"'
#        }
#    # Else, declare such globals initialized to default values.
#    } else {
#        for global_name__dg ("${global_names__dg[@]}") {
#            eval ${declarator__dg}' '${global_name__dg}
#        }
#    }

#       die "Global \"${global_name__dg}\" type \"${global_type__dg}\" unrecognized (${declarator__dg}() undefined)."
        # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    # If such name is syntactically invalid, throw an exception.
#    [[ "${global_name__dg}" == ${~ZESHY_VAR_NAME_GLOB} ]] ||
#        die "Global name \"${global_name__dg}\" syntactically invalid."
#           (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||

    # If such name contains a "=", split such name on the first "=" into the
    # genuine name and initial value (respectively). Since zsh prohibits
    # variable names from containing "=", such logic is inherently safe.
#    if [[ "${global_name__dg}" == (#b)([[:IDENT:]]##)'='(*) ]] {
#        global_name__dg="${match[1]}"
#        global_value__dg="${match[2]}"
##       print -r -- "global type: ${global_type__dg}; name: ${global_name__dg}; value: ${global_value__dg}"
#    }

#Map *synonymized function names* (i.e., function names for functions with
#multiple names) to the first function names declared for such functions. Since
#all first function names thus map to themselves, this map contains the identity
#map. To conserve memory, this map does _not_ map *non-synonymized function
#names* (i.e., function names for functions with only one name): e.g.,

    # If such type is nonscalar (i.e., either a list or map), then...
#   if [[ "${global_type__dg}" == (list|map)(_*|) ]] {
        # Set a boolean marking such fact.
#       is_global_type_nonscalar__dg=1

        # Set the name of the alias declaring globals of such type. Since
        # nonscalars cannot be exported, only declare such global to be global.
        # See parcel "list" for further details and below for a related subtle
        # complication.
#       declarator__dg="${global_type__dg}_global"
    # Else, such type is scalar (i.e., either a float, integer, or string).
#   } else {
        # Set the name of the alias declaring globals of such type. Since
        # all scalars can be exported, declare such global to be an exported
        # global.
#       declarator__dg="${global_type__dg}_global_export"
#   }

    # If such type is nonscalar, an unfortunate complication arises due to
    # subtle dependencies elsewhere in the zeshy codebase on such declaration.
    # Expanding such alias to declare such global suffices for all customary
    # intentions but fails to tag such global with option "-x" (exported).
    # But isn't that exactly what we want? The answer, of course, is "Nah."
    # The reason why lies in the untidy bowels of the top-level parcel
    # "compile", which lists the names of all globals by running
    # "typeset +gx". Running any permutation of such command (e.g.,
    # "typeset +g +", "typeset -g +") prepends such listed names with
    # unwanted attributes (e.g., "integer 10 readonly !"), which must then
    # be coercively parsed out of such names -- an overly inefficient and
    # complex operation. The only sane behavior is to tag such globals with
    # option "-x", even though zsh ignores such option on nonscalar globals.
    #
    # The simplest means of doing so would be to simply define appropriate
    # declarator aliases suffixed by "_global_export". However, we
    # explicitly omit such aliases to avoid confusion. The solution, of
    # course, is a hideous hack: expand the appropriate declarator alias
    # suffixed by "_global" and manually insert the required option "-x"
    # into the resulting expansion immediately before the suffixing "--".
    # While hardly ideal, this has the benefit of actually *WORKING*.
#   if (( is_global_type_nonscalar__dg )) {
        # Such declarator's expansion. See get_alias_expansion() for details.
#       local declarator_expansion__dg
#       declarator_expansion__dg="$(whence -- "${declarator__dg}")"

        # If such expansion is *NOT* suffixed by "--", throw an exception.
#       [[ "${declarator_expansion__dg}" == *' --' ]] ||
#           die "global \"${global_name__dg}\" declarator ${declarator__dg}() expansion not suffixed by \"--\":"$'\n'"${declarator_expansion__dg}"

        # Inject option "-x" before the first "--" in such expansion.
#       declarator_expansion__dg="${declarator_expansion__dg/ --/ -x --}"
#       print -r -- "${declarator_expansion__dg}"
#   }

    # Alias declaring globals of such type.
#   declarator__dg="${global_type__dg}_global_export"
        # Remove such type and name from the argument list. All remaining
        # arguments comprise such global's initial value, if any.
#       shift 2

        # If passed at least two initial values, such global must be nonscalar
        # (e.g., list, map). Sadly, defining the initial value for a nonscalar is
        # somewhat more subtle than defining the initial value for a scalar.
#       if (( # )) {
            # Since users may alias type names (e.g., aliasing "list" to
            # "array"), there exists no generic means of testing whether such
            # type genuinely represents a nonscalar -- aside from matching such
            # declarator's expansion against the set of all possible typeset()
            # calls, which is practically (if not theoretically) infeasible.
            # Since the "eval" below will throw an exception (albiet with an
            # unhelpful error message) if such type is scalar, this is O.K...

            # Ignore the first (i.e., ${global_value__dg}) and last (i.e.,
            # ${argv[-1]}) elements of such value that signify ignorable zeshy-
            # specific delimiters (e.g., "[", "]"). See pop_arg() for further
            # details.
#           argv[-1]=()

            # zsh requires nonscalar declaration and definition be separated.
            # Delimit such definition with zsh-specific delimiters "(" and ")".
#           eval "
#               ${declarator__dg} ${global_name__dg}
#               ${global_name__dg}:catch( \"\${@}\" )"
#           print "global ${global_name__dg} initial value: ${(q)*}"
#           print "global ${global_name__dg}:catch${(P)global_name__dg}"
        # Else, such global is scalar.
#       } else {
#           eval "${declarator__dg} ${global_name__dg}:catch\"\${global_value__dg}\""
#       }
#FUXME: Actually, we should explicitly prohibit attempts to initialize nonscalar
#types, since doing so requires the following inconveniences:
#
#* Delimiting such nonscalar value by "[" and "]" rather than "(" and ")".
#* Suffixing each list or map line by "\".
#
#Frankly, this is absurd. Note why we prohibit this below and then excise all
#such functionality.
#>>> declare_global string on_restoration=\
#...    "As I conclude I reflect on my childhood experience when I would visit a
#...     stream next to our home to fetch water for my mother. I would drink
#...     water straight from the stream. Playing among the arrowroot leaves I
#...     tried in vain to pick up the strands of frogs' eggs, believing they were
#...     beads. But every time I put my little fingers under them they would
#...     break. Later, I saw thousands of tadpoles: black, energetic and
#...     wriggling through the clear water against the background of the brown
#...     earth. This is the world I inherited from my parents."\
#...    "Today, over 50 years later, the stream has dried up, women walk long
#...     distances for water, which is not always clean, and children will never
#...     know what they have lost. The challenge is to restore the home of the
#...     tadpoles and give back to our children a world of beauty and wonder."

#FUXME: Documentation desynchronized again. Note that "(" and ")" *CAN*
#technically be used in list or map initial values now but that doing so
#implicitly discards all argument quoting and hence is functionally useless. As
#before, use "[" and "]". Note that empty lists and maps cannot be declared as
#"${variable_name}:catch[]" but as "${variable_name}:catch[ ]". (zsh thinks the former is
#attempting to declare a function! *sigh*)
#FUXME: Also, document why this function is "globbable" (i.e., to allow list and
#map definition). Note this prevents filename globbing, of course. But that's
#perfectly sensible, since we're defining *GLOBALS*, which should probably never
#attempt filename globbing. There might be a slim use case there, but I'm having
#trouble seeing it. Document; document; document!
#<globbable> 
#If a variable name is passed _and_ such name contains a `=` delimiter,
#initialize such variable to the concatenation of the remainder of such name
#following such delimiter and all additional arguments (excluding the last
#argument, specifying the help string). If the passed variable type is nonscalar
#(i.e., either `list` or `map`), both such remainder and the second-to-last
#arguments are ignored. `zsh` reserves the nonscalar delimiters `(` and `)` for
#itself, requiring such delimiters either be quoted (e.g., `\'(\'`, `\')\'`),
#escaped (e.g., `\(`, `\)`), or simply replaced with delimiters _not_ reserved
#by `zsh` in this context (e.g., `[`, `]`): e.g.,

#>>> declare_global map on_industry=[
#...     "If"    "a man walk in the woods for love of them half of each day,"
#...     "he"    "is in danger of being regarded as a loafer; but if he spends"
#...     "his"   "whole day as a speculator, shearing off those woods and making"
#...     "Earth" "bald before her time, he is esteemed an industrious"
#...     "and"   "enterprising citizen. As if a town had no interest in
#...     "its"   "forests but to cut them down!" ]\
#...     "Most men would feel insulted if it were proposed to employ them in
#...      throwing stones over a wall, and then in throwing them back, merely
#...      that they might earn their wages. But many are no more worthily
#...      employed now."
#>>> print_string "${on_industry[If]}"
#a man walk in the woods for love of them half of each day,
            # Quote-protect all shell-reserved remaining element of such value,
            # delimiting such value with zsh-specific delimiters "(" and ")".
# Unlike above, do *NOT* quote-protect such
        # value. Scalar values require no 
#               ${global_name__dg}:catch( \${(q)@} )"
        # If such value is delimited by "(" and ")", such type must necessarily
        # be nonscalar. Testing such value rather than type is both more
        # efficient (as there exist at least four core types to be matched) and
        # generic (as users may define additional types).
#       if [[ "${global_value__dg}" == '('*')' ]] {
            # Ignore the first (i.e., ${global_value__dg}) and last (i.e., ${argv[-1]})
            # elements of such value. Such elements signify ignorable zeshy-
            # specific delimiters (e.g., "\(", "\)", "[", "]"). See pop_arg()
            # for further details.
#           ${argv[-1]}:catch()

            # zsh requires nonscalar declaration and definition be separated.
            # Quote-protect all shell-reserved remaining element of such value,.
            # Ignore the first and last characters of such value (i.e., "(" and
            # ")"),
            #  manually re-
            # delimiting such value with zsh-specific delimiters "(" and ")".
#           eval "${declarator__dg} ${global_name__dg}; ${global_name__dg}:catch(" "${(q)}" ')'
#FUXME: Documentation desynchronized again. We've reverted back to "(" and ")"
#syntax, in light of "noglob" appearning to work as advertised. Note the one
#mildly interesting caveat to be that empty lists and maps cannot be declared as
#"${variable_name}:catch()" but as "${variable_name}:catch( )". (zsh thinks the former is
#attempting to declare a function! *sigh*)
#FUXME: Of necessity, we no longer ignore the "(" and ")" in list and map
#initializations. They're required (but actually work, now).
#       if [[ "${global_type__dg}" == (list|map|list_*|map_*) ]] {
        # If passed at least two initial values, such global must be nonscalar
        # (e.g., list, map). Sadly, defining the initial value for a nonscalar is
        # somewhat more subtle than defining the initial value for a scalar.
#       if (( # )) {
#               die "scalar global \"${global_name__dg}\" initialized to nonscalar value: ${global_value__dg} ${*}"

#FUXME: Documentation significantly desynchronized. For example, defining list
#and map globals is now exceedingly simple. Any delimiters (not merely "\(" and
#"\)") may be used, as zeshy simply ignores the first and last shell words of
#such globals' initial value. Sweet!
#   if (( # >= 2 )) { print "argv[1]: ${1}\nargv[2]: ${2}\nargv[3]: ${3}" }
#Set the documentation for the global exported variable named by the variable
#declaration prefixing standard input to such input. Consider calling this rather
#than declare_global(), which requires passing a string argument rather than
#standard input. See declare_function_with_stdin() for further details.
#...     "The ways by which you may get money almost without exception lead
#...      downward. To have done anything by which you earned money merely is to
#...      have been truly idle or worse. If the laborer gets no more than the
#...      wages which his employer pays him, he is cheated, he cheats himself."
        # Else, no type was passed. Default such type to string.
#       } elif (( # == 2 )) {
            # Avoid shifting the argument list. By definition, no initial value
            # was passed.
#           type__dg='string'
#           name__dg="${1}"
#       }
    #FUXME: When passed a global type and name (rather than embedded in such
    #help string), prepend such type and name to such help string.

#FUXME: The documentation introduction is also completely wrong, both here and
#below. *sigh*
#Set the documentation for the global exported variable named by the variable
#declaration prefixing the passed string to such string and, if such variable has
#not already been declared, declare such variable to be global, exported, and of
#the documented type. Variable documentation
#FUXME: Woops. O.K.; we basically have to transition *EVERY* global declaration
#from the current form:
#
#  declare_global_with_stdin <<'/---'
#  string ZESHY_PARCEL_NAME
#
#  Current parcel name.
#  /---
#
#...to:
#
#  declare_global_with_stdin <<'/---'
#  Current parcel name.
#  /--- \
#  string ZESHY_PARCEL_NAME
#
#Yes, this actually works (so long as whitespace exists between the global type
#and the prior help string -- hence the space preceding the "\"). It's also
#*DRAMATICALLY* better for the following reasons:
#
#* It actually permits constant globals to be declared. Yes, we'll need a new
#  declare_global_constant_with_stdin(), but that's Aeon's play. Such function
#  must require such global name contain a "=" followed by a value: e.g.,
#
#  declare_global_with_stdin <<'/---'
#  Current parcel name constant.
#  /---\
#      string_constant ZESHY_PARCEL_NAME_CONSTANT='/proc/self/root/striker'
#* Which brings us to the *REAL* reason (though even the above is compelling):
#  permitting lists and maps to be declared without extreme repetition. With the
#  current approach, declaring lists and maps requires repeating such objects'
#  names at least *THREE* times, which is obscene. The above approach eliminates
#  all such repetition.
#
#Naturally, to support this, declare_global() must be revised to accept at least
#three mandatory arguments: the global type, name, and help string (in that order,
#for orthogonality). Wait, scratch that: the help string, global type, and name.
#If such name contains a "=", such global must be defined in an "eval" statement,
#appending all additional arguments; else, throw an exception if any additional
#arguments were passed. And that's it, you know? Instantaneous awesomeness. We
#shouldn't really require any bizarre parsing; just split the global name on the
#first "=" in such name: everything to the left is the "true" name and everything
#to the right the first shell word of such global's initial value to be "eval"-ed.
#FUXME: See parcel "alias_cli" for efficient splitting logic.
#FUXME: O.K.; so, to avoid "zsh: unknown file attribute" errors on defining maps
#and lists, we'll need to define an alias as follows:
#
#    alias declare_global_constant_with_stdin="noglob declare_global_constant_with_stdin"
#
#Oh, bloody hell. That only *SUPERFICIALLY* works. For some reason, zsh still
#aggregates everything between bare "(" and ")" characters into a single function
#argument. This can be hacked around in one of two equally ugly ways:
#
#* Just allow the caller to omit the "(" and ")" characters. Since the type is
#  also passed, we *KNOW* whether it's a list or map and hence that we need to
#  add such characters back into the "eval" we perform.
#* Force the caller to pass explicitly escaped "(" and ")" characters. There are
#  three ways of doing that: single- or double-quoting each such character or
#  preceding each such character with "\". The latter's probably the least ugly.
#
#Actually, there's another way still -- and it's reasonably slick. Just require
#"[" and "]" in place of "(" and ")", then internally convert such characters to
#"(" and ")".
#
#Again, all of these work. We probably shouldn't allow the characters to be
#omitted -- that just looks crass. I'd like to support *BOTH* of the remaining
#methods (i.e., escaped "(" and "[" instead of "("). Great! Go-go-go.
#FUXME: Oh, hell. "[" and "]" are cool, but just a *TAD* excessive. No need to
#make this full-on python, right? Just settle for escaped parens, for now.
#FUXME: Don't bother with the noglob alias above. Callers still rightly expect
#filename globbing to be in effect. (After all, defining lists often *REQUIRES*
#such globbing.)
#FUXME: Naturally, zsh strips the quoting around passed arguments. If required,
#add such quoting back for "eval" purposes with '"'${^@}'"'.
#FUXME: Sweet! If the passed type is scalar, we do *NOT* need to "eval" such
#declaration. Yes, this actually works:
#
#   >>> string   defi="zimo=ok"
#   >>> string ${defi}
#   >>> print ${zimo}
#ok
#FUXME: Oh, wait. No, we still need the "eval", as the type is also dynamic.

    #FUXME: *sigh* This function *APPENDS* stdin, not *PREPENDS* stdin, as
    #expected by the function above. But due to the variadic definition of the
    #function above, we'd rather not change such function's signature. Yes? No?
    #FUXME: Throw an exception if such name is syntactically invalid. We'll
    #probably want to shift a bit of "zsh/variable" functionality here to do so.
    #Perhaps just the requisite PCRE, yes?

#FUXME: Rename to declare_global_with_stdin_help(). Consider also renaming alias
#and function declarers.
#           eval "${declarator__dg} ${name__dg}; ${name__dg}:catch(" "'"${^@}"'" ')'
    # Such global's help string, type, and name.
    # Validate passed arguments.
#   (( # == 1 || # == 3 )) ||
#       die 'expected either one help string or one help string, one type name, and one global name'

#declare_function_with_stdin <<'/---'
#void declare_global(string documentation)
#
#Set the documentation for the global exported variable named by the variable
#declaration prefixing the passed string to such string and, if such variable has
#not already been declared, declare such variable to be global, exported, and of
#the documented type. Variable documentation consists of:
#
#. A *variable declaration* in Zeshy-specific C-like syntax, consisting of one
#  variable type and name (e.g., `list DOG_EAT_DOG_WORLD`).
#. A *variable description* in http://asciidoc.org[AsciiDoc] syntax, augmented
#  with Zeshy-specific markup for cross-referencing other Zeshy documentation.
#
#== Variable Documentation Grammar ==
#
#For completeness, we specify such syntax as a
#http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)]:
#See the <<declare_function.peg,function documentation PEG>> from which this PEG
#derives for all productions not listed here (e.g., AsciiDoc, Type, Whitespace):
#
#.Variable Documentation Grammar
#[cols=">strong,^,<"]
#|===============================================================================
#| GlobalDocumentation   | <- | GlobalDeclaration Whitespace+ AsciiDoc
#| GlobalDeclaration     | <- | Whitespace* Type Whitespace+ GlobalName
#| GlobalName            | <- | AlphanumericString
#|===============================================================================
#
#== Variable Type ==
#
#A variable's type may be any alphanumeric string for which an alias of the same
#name suffixed by `_global_export` exists. Hence, `file_descriptor` is a valid
#variable type but `order_of_the_blackened_denarius` is not, since
#file_descriptor_global_export() is an existing alias but
#order_of_the_blackened_denarius_global_export() is (hopefully) not.
#
#Zeshy provides numerous such aliases and hence variable types, including:
#`boolean`, `character`, `file_descriptor`, `float`, `integer`, `list`,
#`list_set`, `map`, and `string`.
#/---
#function declare_global() {
#    # Validate passed arguments.
#    (( # == 1 )) || die 'expected one help string'
#    local help__dg="${1}"
#
#    # If such documentation is prefixed by a variable declaration, match the
#    # variable name and type from such declaration. Dismantled, this is:
#    #
#    # * "(#b)", capturing match groups into global list ${match}.
#    # * "[[:space:]]#", matching optional whitespace.
#    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
#    # * "[[:space:]]##", matching mandatory whitespace.
#    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
#    #
#    # Else throw an exception with a portion of such documentation.
#    [[ "${help__dg}" ==\
#        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
#        die_for_declarator_type_with_help 'global' "${help}"
#
#    # Before attempting to declare such global, we should test whether such a
#    # global already exists and if so either throw an exception or print a
#    # warning. There exists no efficient means of performing such test, however.
#    # While there do exist efficient means of testing whether a variable either
#    # local or global exists and whether such variable in the current scope is
#    # local or global, the only means of testing whether a global exists is to
#    # parse the output of "typeset -gx +" for a line matching such global's
#    # name. While such parsing could conceivably be efficient for infrequent
#    # purposes, this function does not follow an infrequent purpose.
#
#    # Such global's declared type and name.
#    local global_type__dg="${match[1]}" global_name__dg="${match[2]}"
#
#    # Alias declaring globals of such type.
#    local declarator__dg="${global_type__dg}_global_export"
#
#    # If such alias does not exist, throw an exception. Since such alias
#    # could technically also be a function, match both. See is_runnable()
#    # for further details.
##       print "global type: ${global_type__dg}; global name: ${global_name__dg}; declarator: ${declarator__dg}"
#    whence -- "${declarator__dg}" &>/dev/null ||
#        die "type \"${global_type__dg}\" unrecognized (${declarator__dg}() undefined)"
#
#    # Declare such global. Since the declarator is typically an alias rather
#    # than function or pathable, zsh requires evaluating rather than running
#    # such declarator. While acceptable, this is somewhat... annoying.
#    eval "${declarator__dg} \"\${global_name__dg}\""
#
#    # Add such global to the current parcel.
#    add_parcel_global "${ZESHY_PARCEL_NAME}" "${global_name__dg}"
#
#    # Map such global to such help string.
#    ZESHY_GLOBAL_NAME_TO_HELP[${global_name__dg}]="${help__dg}"
#}

#FUXME: It'd be *GREAT* to revise the basic "list" and "map" aliases 
# See @{parcel} for such global's declaration.
# See @{function} for such global's declaration.
#FUXME: The global below efficiently obsoletes *ALL* other bizarre schemes we'd
#considered for recording synonyms (particularly, the use of symbolic links
#within the KVS directory for function documentation). Whenever the caller
#requests documentation for some function ${function_name}, perform the
#following mapping:
#
#  function_name="${ZESHY_FUNCTION_NAME_TO_FUNCTION_NAME_FIRST[${function_name}]-${function_name}}"
# Prefix this parcel name with an integer to ensure zeshy sources this parcel
# before parcels depending on this parcel (e.g., "parcel" itself).

#       {
        # Global prototype prefixing such help string.
#       string help_prototype

        # If such string contains a newline (i.e., "\n"), crudely match the
        # substring preceding such newline as the global prototype.
#       if [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#           help_prototype="${match[1]}"
        # Else, abandon all hope.
#       } else {
#           help_prototype="${help}"
#       }

#       die 'global help string invalid (see "print_help declare_global" for details):
#'"${help_prototype}"
#   }
