#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

#FIXME: Subsequently document this parcel and all runnables such parcel
#declares.

# ....................{ SETTERS                            }....................
#FIXME: Replace *ALL* calls to run_runnable_with_stdin() with calls to this
#function; then, excise the former.

function :set_string_to_declarator_help() {
    # Validate sanity.
    (( # == 1 )) || die 'Expected one string name.'
    local string_name__sstdh="${1}"

    # If such variable is not a string, throw an exception. See
    # die_unless_string() for further details.
    [[ "${(tP)string_name__sstdh-}" == 'scalar'* ]] || die\
        'Variable ${'${string_name__sstdh}'} not a string or not found.'

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception. See :is_stdin_readable_sans_blocking() for
    # further details.
    #
    # Since there exists no demonstrable reason to prohibit empty
    # documentation, such exception should ideally only be thrown in the latter
    # case. Unfortunately, differentiating between the two cases is
    # sufficiently non-trivial as to be effectively infeasible this early in
    # digest compilation.
    #
    # Ideally, such cases could be differentiated by either:
    #
    # * Inlining the implementation of :is_stdin_readable_noninteractive()
    #   here (e.g., "not :is_stdin_terminal and :is_stdin_open"). While
    #   inlining the former condition :is_stdin_terminal() would be trivial,
    #   inlining the latter condition :is_stdin_open() would require also
    #   inlining :set_string_to_symlink_target_last() (and all functions such
    #   function transitively calls) and hence be non-trivial.
    # * Inlining the implementation of :is_stdin_here_doc_or_string() here.
    #   Since this would require again inlining
    #   :set_string_to_symlink_target_last() as above, such approach is equally
    #   non-trivial.
    #
    # Given the earliness of this function, we adopt a single-line solution --
    # which, as an unfortunate by-product, prohibits empty documentation.
    read -t 0 || die\
        'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'

    # Set such string to standard input and hence such documentation. See
    # :set_string_to_string() and get_stdin() for further details.
    : "${(P)string_name__sstdh::=$(< /dev/stdin)}"
}

# ....................{ RUNNERS                            }....................
function run_runnable_with_stdin() {
    # Validate sanity.
    (( # )) || die 'Expected one runnable name and optional arguments.'
    local runnable_name__rrws="${1}"
    shift

    #FIXME: Improper test, since such test fails when passed the empty string
    #in a valid here-document string, which should (for convenience) succeed.
    #FIXME: Interesting. Under at least Linux, this is testable by noting that
    #"readlink -f /dev/stdin" succeeds and outputs a string resembling
    #"/tmp/zshFtb89B (deleted)". While we *COULD* capture such output and glob
    #for '/tmp/zsh'?*' (deleted)', such approach is both inefficient and overly
    #Linux-specific for such an early-time operation as this. A possibly
    #simpler test is as follows:
    #
    #* If :set_string_to_zsh_temp_prefix() prefixes the output of
    #  "command readlink -f /dev/stdin", standard input is... wait. We wanted
    #  *SIMPLER*. O.K., O.K.; how about just:
    #   * If "/dev/stdin" is a broken symbolic link, assume such link to have
    #     been the product of a here-document or -string, as expected.
    #   * Else implement the contents of :is_stdin_file_simple(), yes?
    #FIXME: No, no, no. *THINK*. What are we trying to accomplish here? This:
    #
    #* If the current process is *NOT* running headless *AND* standard input is
    #  *NOT* attached to a terminal, throw an exception. (Since, in such case,
    #  attempting to read from standard input is guaranteed to be terrible.)
    #
    #Happily, such test is both efficient and simple:
    #
    #{ (( ${+TERM} )) && ! [[ -t 0 ]] } || die 'Standard input empty.'
    #
    #Wait. Obviously, this reduces to the even simpler test:
    #
    #if [[ -t 0 ]] {
    #    die 'Documented not passed on standard input.'
    #}
    #
    #Wait. Insufficient. This suffices if the current process is *NOT*
    #headless. But what if it is? Then we just need to test whether standard
    #input is open or not. This is readily cross-platform-portable, as currently
    #implemented by get_file_descriptor_file_device().
    #FIXME: Hm; wait. Testing whether standard input is open or not is actually
    #non-trivial, as such function attests. The simplest solution then will be
    #to test whether standard input is a here-document or -string. This is
    #somewhat more confined than we would like, but... well, there's really no
    #sane alternative. That said, even testing this is non-trivial, as it
    #requires obtaining the transitive target of such file descriptor.
    #FIXME: Oh, *SCREW IT.* The current implementation is basically the only
    #sane implementation. We'll need to document why, of course. See above!

    # If standard input is empty, throw an exception. See
    # :is_stdin_readable_sans_blocking() for further details.
    read -t 0 || die 'Standard input empty.'

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${runnable_name__rrws}" &>/dev/null ||
        die "runnable \"${runnable_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${runnable_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
    # If standard input is attached to an interactive terminal, throw an
    # exception. (While the prior test should ensure this, one can never be too
    # sure. Since we close such input below, it's critical we only close non-
    # interactive input.)
    # if [[ -t 0 ]] {
    #     die 'Standard input attached to an interactive terminal.'
    # }
    # # Close standard input. See close_stdin() for further details.
    # exec 0<&-

    # If standard input is either the empty string *OR* unreadable
    # If at least one byte of standard input is readable without blocking, throw an exception. See
