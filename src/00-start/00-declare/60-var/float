#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *float variable declarators* (i.e., aliases declaring fractional numeric
variables).
/---

# ....................{ FLOATS                             }....................
# While zsh already provides builtin float() for declaring local floats, such
# builtin expands to "typeset -E" (i.e., scientific notation) rather than
# "typeset -F" (i.e., decimal notation). Given the prevalence of the latter and
# relative obscurity of the former, this seems a curious (if lamentable) choice.
# Replace such builtin with an alias expanding to the expected "typeset"
# command.

:alias_simple.declare\
    'void :float(string variable_name1, ...)'\
    'local -F --' <<'/---'
Declare the passed float variables locally, initialized to the following `=`-
delimited float if specified or to 0.0 otherwise.
/---

#FIXME: Excise after replacing with the prior alias everywhere.
:alias_simple.declare\
    'void float(string variable_name1, ...)'\
    'local -F --' <<'/---'
Declare
/---

:alias_simple.declare\
    'void float_global(string variable_name1, ...)'\
    'typeset -Fg --' <<'/---'
Declare the passed float variables globally _not_ exported to the calling shell.
See :float() for further details.
/---

:alias_simple.declare\
    'void float_global_export(string variable_name1, ...)'\
    'export -F --' <<'/---'
Declare the passed float variables globally, exported to the calling shell.
See :float() for further details.
/---

# ....................{ FLOATS ~ constant                  }....................
:alias_simple.declare\
    'void :float_const(string variable_name1, ...)'\
    'local -Fr --' <<'/---'
Declare the passed float constants locally, defined to the following `=`-
delimited float if specified or to 0.0 otherwise. If such constant is (attempted
to be) redefined, an exception is thrown. See :float() for further details.
/---

:alias_simple.declare\
    'void float_constant_global_export(string variable_name1, ...)'\
    'export -Fr --' <<'/---'
Declare the passed float constants globally, exported to the calling shell. See
:float_const() for further details.
/---

# ....................{ FLOATS ~ type                      }....................
# Builtin float() does *NOT* suffice.
:alias_simple.declare\
    'void float_with_fractional_digits(
        integer length = 10, string variable_name1, ...)'\
    'local -F' <<'/---'
Declare the passed floats locally. On parameter (but _not_ arithmetic)
expansion, such floats will be implicitly truncated to the passed number of
fractional digits (defaulting to 10). Since this does _not_ apply to arithmetic
expansion, such floats internally retain all data for calculation purposes. See
:float() for further details: e.g.,

.float_with_fractional_digits()
==========================================
[source]
------------------------------------------
>>> float_with_fractional_digits 3 prouhet_thue_morse=0.412154033640
>>> print_string "${prouhet_thue_morse}" $(( prouhet_thue_morse ** 2 ))
0.412 0.16987094744572223
------------------------------------------
==========================================
/---

# Builtin float() does *NOT* suffice.
:alias_simple.declare\
    'void float_with_significant_figures(
        integer length = 10, string variable_name1, ...)'\
    'local -E' <<'/---'
Declare the passed floats locally. On parameter (but _not_ arithmetic)
expansion, such floats will be implicitly converted to *scientific notation*
with the significand truncated to the passed number of significant figures.

Let `${f}` be such a float. If:

* `(( f == 0 ))`, such notation formats `${f}` as `0.0000000000e+00` (assuming
  10 significant figures).
* `(( f > 0 ))`, such notation formats `${f}` as `${a}e+${b}`, where `${a}` is
  the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
  exponent such that `(( f == A * 10 ** b ))`.
* `(( f < 0 ))`, such notation formats `${f}` as `${a}e-${b}`, where `${a}` is
  the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
  exponent such that `(( f == A * 10 ** -b ))`.

Since this does _not_ apply to arithmetic expansion, such floats internally
retain all data for subsequent calculation. See :float() for further details:
e.g.,

.float_with_significant_figures()
==========================================
[source]
------------------------------------------
>>> float_with_significant_figures 3 gelfonds_constant=22.140692632779269
>>> print_string "${gelfonds_constant}" $(( sqrt(gelfonds_constant) ))
2.214e+01 4.7053897426249405
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
# Replace such builtin with an alias expanding to the expected "typeset"
# command.
