#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by alias, function, and global declarers.

# ....................{ GLOBALS                            }....................
#FIXME: Rename ${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAMES} to
#${ZESHY_DECLARATOR_PROTOTYPE_ALIAS_NAMES_PCRE} and similarly for all other
#globals below containing "_PROTOTYPE". The focus is not the help string; the
#focus is the declarator itself. The help string is only optionally along for
#the ride, now.

# Exported string PCRE globals, defined and documented below.
typeset -g\
    ZESHY_DECLARATION_GLOBAL_NAME_PCRE\
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAMES\
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES\
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES\
    ZESHY_HELP_PCRE_RUNNABLE_PROTOTYPE_NAME

# Define such PCREs in an anonymous block to permit definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
    # PCRE matching the start of a zeshy help string. Dismantled, this is:
    #
    # * "(?s)", inducing '.' to match all characters including newline.
    local pcre_start='(?s)^\s*+'

    # Comma preceded and followed by optional whitespace.
    local pcre_comma='\s*+,\s*+'

    # Abstract identifier used *ONLY* for descriptive purposes (e.g., function
    # argument names) and hence defined in a fairly crude but efficient manner.
    # Such PCRE is *NOT* intended to match actual zsh syntax (e.g., global
    # names). See ${ZESHY_DECLARATOR_PCRE_GLOBAL_NAME} below, in particular.
    local pcre_identifier='[a-zA-Z0-9-_]++'

    # zsh variable name. See the subsequently defined
    # ${ZESHY_VAR_NAME_GLOB} for further details.
    local pcre_global_name='[a-zA-Z_][a-zA-Z0-9_]*+'

    # Unquoted runnable name. While quoted runnable names may contain all
    # possible characters, unquoted runnable names are constrained so as *NOT*
    # to conflict with prototype syntax. For simplicity, extend
    # ${pcre_identifier} with punctuation guaranteed to avoid such conflict.
    local pcre_runnable_name_unquoted='[a-zA-Z0-9-_:]++'

    # Runnable attributes. zeshy currently prohibits single- and double-quoted
    # attribute names, thus simplifying matching.
    local pcre_runnable_attributes='(?:<\s*+([^>]*+)>\s++)?'

    # Runnable return types. zeshy currently prohibits single- and double-quoted
    # return types, thus simplifying matching.
    local pcre_return_channel_grouped='('${pcre_identifier}')\s*+:\s*+('${pcre_identifier}')'
    local pcre_return_type_grouped='(?:void|('${pcre_identifier}'))'
    local                    pcre_return_type=${pcre_identifier}
    local pcre_return_channels_grouped='\[\s*+([^]]*+)\]'
    local         pcre_return_channels='\[\s*+[^]]*+\]'
    local pcre_return_type_or_channels='(?:'${pcre_return_type}'|'${pcre_return_channels}')\s++'
    local pcre_return_type_or_channels_grouped='(?:'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')\s++'

    # Runnable names. Since zsh permits single- and double-quoted alias and
    # function names, matching requires more than merely class negation. While
    # reliably quoting alias names is non-trivial (unlike functions), it *IS*
    # feasible. See :define_alias() for further details.
    #
    # Strictly speaking, only function syntax supports synonyms under plain zsh.
    # Since such support is a superficial convenience, however, there exists no
    # reason *NOT* to extend such support to alias syntax as well. Hence, we do.
    local pcre_runnable_name_unquoted_grouped='('${pcre_runnable_name_unquoted}')'
    local pcre_runnable_name_quoted_single_grouped="'((?:[^']|'')*)'"
    local          pcre_runnable_name_quoted_single="'(?:[^']|'')*'"
    local pcre_runnable_name_quoted_double_grouped='"((?:[^"]|\\")*)"'
    local          pcre_runnable_name_quoted_double='"(?:[^"]|\\")*"'
    local pcre_runnable_name_grouped='(?|'${pcre_runnable_name_unquoted_grouped}'|'${pcre_runnable_name_quoted_single_grouped}'|'${pcre_runnable_name_quoted_double_grouped}')'
    local         pcre_runnable_name='(?:'${pcre_runnable_name_unquoted}'|'${pcre_runnable_name_quoted_single}'|'${pcre_runnable_name_quoted_double}')'
    local pcre_runnable_names_grouped='\{\s*+((?:'${pcre_runnable_name}'(?:'${pcre_comma}'|\s++))*'${pcre_runnable_name}')(?:'${pcre_comma}')?\s*+\}'
    local pcre_runnable_name_or_names_grouped='(?:'${pcre_runnable_name_grouped}'|'${pcre_runnable_names_grouped}')\s*+'

    # Function arguments.
    local pcre_arg_value_quoted_double='"(?:\\"|$\([^)]*+\)|[^"])*"'
    local pcre_arg_value_quoted_single=${pcre_runnable_name_quoted_single}
    local pcre_arg_value_number='-?\d++\.\d++|-?\d++'
    local pcre_arg_value_content=${pcre_arg_value_quoted_double}'|'${pcre_arg_value_quoted_single}'|'${pcre_arg_value_number}
    local pcre_arg_value_equals='\s*+=\s*+'
    local pcre_arg_value_grouped=${pcre_arg_value_equals}'('${pcre_arg_value_content}')'
    local         pcre_arg_value=${pcre_arg_value_equals}'(?:'${pcre_arg_value_content}')'
    local pcre_arg_grouped='('${pcre_identifier}')\s++('${pcre_identifier}')(?:'${pcre_arg_value_grouped}')?'
    local            pcre_arg=${pcre_identifier}'\s++'${pcre_identifier}'(?:'${pcre_arg_value}')?'
    local pcre_args_list_grouped='((?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}')(?:'${pcre_comma}')?'
    local          pcre_args_list='(?:'${pcre_arg}${pcre_comma}')*'${pcre_arg}'(?:'${pcre_comma}')?'
    local pcre_args_grouped='\(\s*+(?:void|'${pcre_args_list_grouped}')?\s*+\)'
    local         pcre_args='\(\s*+(?:void|'${pcre_args_list}')?\s*+\)'
    local pcre_arg_channel_grouped='('${pcre_identifier}')\s*+:\s*+(?:(void|'${pcre_arg}')|('${pcre_args}'))'
    local            pcre_arg_channel=${pcre_identifier}'\s*+:\s*+(?:void|'${pcre_arg}'|'${pcre_args}')'
    local pcre_arg_channels='\[\s*+((?:'${pcre_arg_channel}${pcre_comma}')*'${pcre_arg_channel}')(?:'${pcre_comma}')?\s*+\]'
    local pcre_args_or_channels_grouped='(?:'${pcre_args_grouped}'|'${pcre_arg_channels}')'

    # Function description. Ignore cross-references embedded in the following
    # AsciiDoc-specific passthrough syntactic constructs, which AsciiDoc and hence
    # zeshy ignores for parsing purposes:
    #
    # * "`"-delimited passthrough quotes.
    # * "pass:["- and "]"-delimited passthrough macros.
    # * "+++"-delimited passthrough macros.
    # * "$$"-delimited passthrough macros.
    # * "\n----"-delimited listing blocks.
    # * "\n...."-delimited literal blocks.
    # * "\n////"-delimited comment blocks.
    # * "\n++++"-delimited passthrough blocks.
    # * "\n[literal]"-prefixed literal paragraphs.
    # * "\n "- and "\n\t"-prefixed literal lines.
    #
    # Ignore cross-references embedded in the following AsciiDoc-specific anchored
    # syntactic constructs, which AsciiDoc anchors for subsequent cross-referencing
    # and hence should not themselves contain cross-references:
    #
    # * "\n."-prefixed block titles.
    local pcre_asciidoc_quote_backtick='\b`\N*?`\b'
    local pcre_asciidoc_macro_pass='pass:\[(?:\\\]|\N)*?\]'
    local pcre_asciidoc_macro_plus='\+\+\+\N*?\+\+\+'
    local pcre_asciidoc_macro_dollar='\$\$\N*?\$\$'
    local pcre_asciidoc_block_listing='-{4,}+\n.*?\n-{4,}+'
    local pcre_asciidoc_block_literal='\.{4,}+\n.*?\n\.{4,}+'
    local pcre_asciidoc_block_comment='/{4,}+\n.*?\n/{4,}+'
    local pcre_asciidoc_block_pass='\+{4,}+\n.*?\n\+{4,}+'
    local pcre_asciidoc_block_title_or_line_literal='(?:\.|[ \t]++)\N+'
    local pcre_asciidoc_paragraph_literal='^\[literal\]\n.*?(?:\n\n|\Z)'
    local pcre_asciidoc_cross_reference='((?:'${pcre_asciidoc_quote_backtick}'|\b(?:'${pcre_asciidoc_macro_pass}'|'${pcre_asciidoc_macro_plus}'|'${pcre_asciidoc_macro_dollar}')\b|^(?:'${pcre_asciidoc_block_listing}'|'${pcre_asciidoc_block_literal}'|'${pcre_asciidoc_block_comment}'|'${pcre_asciidoc_block_pass}'|'${pcre_asciidoc_block_title_or_line_literal}')$|'${pcre_asciidoc_paragraph_literal}'|.)*?)([$@]\{'${pcre_identifier}'\}|(?:(alias|function):)?'${pcre_identifier}'\(\))'
    local pcre_asciidoc_suffix='(.*)'
    local pcre_asciidoc='\s*+(.*)'

    # PCRE matching the next "="-suffixed global name in "="-delimited global
    # definitions. Such syntax mimics conventional "="-delimited variable
    # assignments in zsh and hence prohibits whitespace.
    ZESHY_DECLARATION_GLOBAL_NAME_PCRE='('${pcre_global_name}')='

    # PCRE matching all alias names in alias prototypes.
    ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAMES="${pcre_start}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}"

    # PCRE matching all function attributes and names in function prototypes.
    ZESHY_HELP_PCRE_FUNCTION_PROTOTYPE_ATTRIBUTES_AND_NAMES="${pcre_start}${pcre_runnable_attributes}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}"

    #FIXME: Exclude attributes and names.
    # PCRE matching all semantic substrings in function prototypes, excluding
    # attributes and names. This includes return types, arguments, and AsciiDoc.
    ZESHY_HELP_PCRE_FUNCTION_SANS_PROTOTYPE_ATTRIBUTES_AND_NAMES="${pcre_start}${pcre_runnable_attributes}${pcre_return_type_or_channels_grouped}${pcre_runnable_name_or_names_grouped}${pcre_args_or_channels_grouped}${pcre_asciidoc}"'()$'

    # PCRE matching the next runnable name in a list of such names.
    ZESHY_HELP_PCRE_RUNNABLE_PROTOTYPE_NAME=${pcre_runnable_name_grouped}'(?:'${pcre_comma}')?'
}

# --------------------( WASTELANDS                         )--------------------
    # PCRE matching all global names preceding the value to initialize such
    # namess to in "="-delimited global definitions. Such syntax mimics
    # conventional "="-delimited variable assignments in zsh and hence prohibits
    # whitespace.
#    ZESHY_DECLARATION_PCRE_GLOBAL_NAMES='((?:'${pcre_global_name}'=)+)(.*)'
#
#    # PCRE matching the next "="-suffixed global name in such definitions.
#    ZESHY_DECLARATION_PCRE_GLOBAL_NAME='('${pcre_global_name}')='

# This PCRE is *ONLY* used to validate such syntax and hence
    # captures no substrings.
    # PCRE matching the next "="-suffixed global name in a "="-delimited global
    # definition optionally followed by the final "="-prefixed global value.
    # Such syntax mimics conventional "="-delimited zsh variable assignments in
    # zsh and hence prohibits whitespace.

    # PCRE matching all global names preceding the value to initialize such
    # names to in "="-delimited global definitions. Such syntax mimics
    # conventional "="-delimited variable assignments in zsh and hence prohibits
    # whitespace.
#   ZESHY_DECLARATOR_PCRE_GLOBAL_NAMES='((?:'${pcre_global_name_ungrouped}'=)+)'
    # PCRE matching the next global name in a list of such names.

    # Function names. Since functions but *NOT* aliases support synonyms,
    # function and alias name syntax must be handled distinctly.
#   local pcre_function_name_grouped='('${pcre_runnable_name_content}')'
#   local       pcre_function_name='(?:'${pcre_runnable_name_content}')'
#   local pcre_function_names='\{\s*+((?:'${pcre_runnable_name}'(?:'${pcre_comma}'|\s++))*'${pcre_runnable_name}')(?:'${pcre_comma}')?\s*+\}'
#   local pcre_function_name_or_names='(?:'${pcre_runnable_name_grouped}'|'${pcre_function_names}')\s*+'

    # Alias names. Since zsh permits single- and double-quoted alias names,
    # matching requires more than class negation. While quoting alias names is
    # is non-trivial (unlike functions), it *IS* feasible. See :define_alias()
    # for further details.
#   local pcre_alias_name_grouped='('${pcre_runnable_name_content}')'
