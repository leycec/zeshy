#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs required by alias, function, and global declarers.

#FIXME: We may want to reconsider our current variadic argument syntax. Why?
#Quite simply, because other languages do it rather differently:
#
#    # C.
#    double average(int count, ...) { }
#
#    # Java.
#    double average(int count, int... numbers) { }
#
#    # Python.
#    def average(count, *numbers):
#        nil
#
#    # Ruby.
#    def obj.average(count, *numbers); end
#
#    # C++11 templates.
#    template<typename... Values> class tuple;
#
#So, there exist two fundamental different sorts of syntax. In summary:
#
#* "..." suffixing the variadic argument type.
#* "*" prefixing the variadic argument name.
#
#Either case is considerably more terse than our current approach. Hence, ditch
#the current ", ..." syntax in favor of either of the above. Consider:
#
#    :func ':void :yum(:string hello, :int... nums)' { ... }
#    :func ':void :yum(:string hello, :int *nums)' { ... }
#
#To determine which to choose, note we already have a type prefix "^" but no
#type suffix. When combining "^" with both of the two above, we receive:
#
#    :func ':void :yum(:string hello, ^:int... nums)' { ... }
#    :func ':void :yum(:string hello, ^:int *nums)' { ... }
#
#While "..." combines somewhat more readably with "^" than "*" does, the *REAL*
#issue is the use of "*" to signifier pointers in C and C++. Hence, shall we
#not go with type suffix "..." to denote variadicity? Minor changes required,
#of course, but hopefully nothing *TOO* inauspicious.
#
#Oh, and let's not bother contemplating a name suffix "...", as that results in
#not entirely sensible syntax. After all, variadicity arguably applies more to
#the argument type than name (as it results in a list rather than scalar
#variable with such name). Hence, avoid this:
#
#    :func ':void :yum(:string hello, ^:int nums...)' { ... }

#FIXME: We need to support disjunctive prototypes. Consider this function,
#which can be called in at least two fundamentally distinct ways. To permit
#this, I suggest extending our "{...,...}" syntax yet again as follows:
#
#    {void declare_global(
#        string global_type,
#        string global_name_with_optional_value,
#        string documentation),
#     void declare_global(string documentation)}
#
#We *REALLY* don't want to have to implement a non-regular context-free parser.
#Fortunately, we won't have to. Simply hard-code an outermost "(...|...)"-style
#PCRE, where the first sub-PCRE in such PCRE matches the conventional singular
#prototype (i.e., lacking exterior "{" and "}" delimeters) and the final
#sub-PCRE in such PCRE matches the above plural prototype (i.e., with exterior
#"{" and "}" delimeters).

# ....................{ GLOBALS                            }....................
#FIXME: There should exist *NO* tangible syntactic differences between alias
#and function prototypes, implying all use of "_ALIAS" and "_FUNC" in
#nomenclature below should be flattened to merely "_RUNNABLE".
#FIXME: Excise ${ZESHY_PROTOTYPE_RUNNABLE_NAMES_PCRE},
#${ZESHY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE}, and
#${ZESHY_PROTOTYPE_FUNC_SANS_ATTRS_AND_NAMES_PCRE}. (Yay!)
#FIXME: Document all remaining globals.
#FIXME: Consider excising ${ZESHY_PROTOTYPE_GLOBAL_NAMES_NEXT_PCRE}, which
#*SHOULD* now be obsoleted by simpler string splitting.
typeset -g ZESHY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE

# PCRE globals defined below.
typeset -g\
    ZESHY_PROTOTYPE_GLOBAL_NAMES_VALUE_PCRE\
    ZESHY_PROTOTYPE_GLOBAL_NAMES_NEXT_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NAMES_ARGS_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_NAME_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_NAME_SUFFIXED_PREFIXED_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_NAMES_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NEXT_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_NAMES_NEXT_PCRE\
    ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE

# ....................{ MAIN                               }....................
# Define such PCREs in an anonymous block, allowing definition of locals. Since
# subsequent locals often depend on prior locals, only define one local a line.
() {
    # PCRE matching one or more whitespace characters.
    local pcre_spaces='\s++'

    # PCRE matching zero or more whitespace characters.
    local pcre_spaces_optional='\s*+'

    # PCRE matching the start of a zeshy help string. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   vexsome default, "." matches all characters excluding newline.)
    local pcre_start='(?s)^'${pcre_spaces_optional}

    # Empty group, typically used to align group indices in a list of
    # "(?|"-driven alternatives.
    local pcre_empty_group='()'

    # Caret.
    local pcre_caret_spaced='\^'${pcre_spaces}
    local pcre_caret_spaced_grouped='('${pcre_caret_spaced}')'

    # Comma preceded and followed by optional whitespace.
    local pcre_comma_spaced=${pcre_spaces_optional}','${pcre_spaces_optional}
    local pcre_comma_spaced_optional='(?:'${pcre_comma_spaced}')?'

    # Comma preceded by optional whitespace, followed by optional whitespace
    # regardless of whether such comma matched.
    local pcre_comma_spaced_optional_spaces='(?:'${pcre_spaces_optional}',)?'${pcre_spaces_optional}

    # Equals sign preceded and followed by optional whitespace.
    local pcre_equals_spaced=${pcre_spaces_optional}'='${pcre_spaces_optional}

    # Ellipse (i.e., three consective periods).
    local pcre_ellipse='\.\.\.'
    local pcre_ellipse_grouped='('${pcre_ellipse}')'

    #FIXME: For more efficient matching, extract the ${pcre_spaces_optional}
    #out of this match; since "=" may also be prefixed by optional spaces,
    #match ${pcre_spaces_optional} before either "?" or "=".

    # Eroteme (i.e., question mark).
    local pcre_eroteme_optional='[?]?'
    local pcre_eroteme_optional_grouped='(\?)?'

    # Forward slash.
    local pcre_slash_forward='/'

    # Grave accent (i.e., backtick).
    local pcre_grave_spaced_optional='(?:`'${pcre_spaces_optional}')?'
    local pcre_grave_spaced_optional_grouped='(`'${pcre_spaces_optional}')?'

    #FIXME: Permit arbitrary whitespace surrounding such syntax; then, rename
    #such locals accordingly.

    # Plus sign.
    local pcre_plus='\+'

    # Integer or float (i.e., real number).
    local pcre_number='-?\d++(?:\.\d++)?'

    # Single-quoted string in zsh format and hence supporting escaped single
    # quotes (i.e., "''").
    local          pcre_quotes_single="'(?:[^']|'')*'"
    local pcre_quotes_single_grouped="'((?:[^']|'')*)'"

    # Double-quoted string in zsh format and hence supporting escaped double
    # quotes (i.e., '\"'). Unlike the prior PCRE, character class [^"] also
    # matches "\" and hence must be matched *AFTER* matching the latter.
    local          pcre_quotes_double='"(?:\\"|[^"])*"'
    local pcre_quotes_double_grouped='"((?:\\"|[^"])*)"'

    #FIXME: Theoretically, command substitutions can themselves nest command
    #substitutions. Matching such syntax will probably require context-free
    #matching here.

    # Double-quoted string in the above format, optionally containing command
    # substitutions themselves containing double-quoted strings (e.g., 
    # "We're $(on "a ladder to") God").
    local pcre_quotes_double_with_substitutions='"(?:\\"|\$\([^)]*+\)|[^"])*"'

    #FIXME: Unused, but preserved for its helpful documentation, which should
    #be moved to formal AsciiDoc.
    # Pseudo-type signifying such runnable to return a maximal amount of data,
    # equivalent to explicitly specifying the return channel list
    # "[stdout = :string, stderr = :string, status = :int]".
    # local pcre_full=':full'

    #FIXME: Unused, but preserved for its helpful documentation, which should
    #be moved to formal AsciiDoc.
    # Pseudo-type signifying such runnable to return a minimal amount of data,
    # equivalent to explicitly specifying the return channel list
    # "[stdout = :void, stderr = :void, status = :true]".
    #
    # Since the empty argument list "()" more orthogonally, concisely, and
    # readably signifies a runnable to accept no arguments than the C-style
    # argument list "()", this pseudo-type only applies to return types.
    # local pcre_void=':void'

    # Human-readable operable (i.e., alias, function, variable) type.
    #
    # Such PCRE is *NOT* intended to match the full gamut of actual zsh syntax
    # for operable types -- which, since zeshy defines such types by simple
    # aliases, technically include single- and double-quoted strings. Rather,
    # such PCRE matches only the subset of characters zeshy names such types
    # with (i.e., alphanumeric letters, underscore, hyphen, and colon).
    local pcre_operable_type='[a-zA-Z0-9-_:]++'
    local pcre_operable_type_grouped='('${pcre_operable_type}')'

    # Human-readable operable name, principally runnable argument names.
    # Such PCRE matches all characters matched by the prior PCRE excluding
    # colon, as argument names hypothetically correspond to local variable
    # names and hence prohibit colons. As above, such PCRE is *NOT* intended to
    # match the full gamut of actual zsh syntax. See ${pcre_global_name} below.
    local pcre_operable_name='[a-zA-Z0-9-_]++'
    local pcre_operable_name_grouped='('${pcre_operable_name}')'

    # Human-readable operable name prefixed by a plus sign.
    local         pcre_operable_name_plussed_optional='(?:'${pcre_plus}${pcre_operable_name}')?'
    local pcre_operable_name_plussed_optional_grouped='(?:'${pcre_plus}${pcre_operable_name_grouped}')?'

    # Human-readable operable name prefixed by a forward slash.
    local         pcre_operable_name_slashed_optional='(?:'${pcre_slash_forward}${pcre_operable_name}')?'
    local pcre_operable_name_slashed_optional_grouped='(?:'${pcre_slash_forward}${pcre_operable_name_grouped}')?'

    #FIXME: Sweet. This is effectively complete. Now, we just need to actually
    #*USE* ${ZESHY_PROTOTYPE_GLOBAL_PCRE} (and hence ${pcre_global_grouped}).
    #To do so, the first incremental step will probably be to implement a new
    #setter :global_prototype.set_names() in @{*-set}.

    # Global variable. Such syntax mimics conventional "="-delimited variable
    # assignments in zsh and hence prohibits whitespace. See
    # ${ZESHY_VAR_NAME_GLOB} for further details on variable name syntax.
    local pcre_global_type=${pcre_operable_type}
    local pcre_global_type_grouped='('${pcre_global_type}')'
    local pcre_global_name='[a-zA-Z_][a-zA-Z0-9_]*+'
    local pcre_global_name_grouped='('${pcre_global_name}')'
    local pcre_global_names_grouped='((?:'${pcre_global_name}'=)*'${pcre_global_name}')'
    local pcre_global_name_or_names_grouped='(?:'${pcre_global_name_grouped}'|'${pcre_global_names_grouped}')'
    local pcre_global_value_grouped='(?:=('${pcre_quotes_double}'|'${pcre_quotes_single}'|'${pcre_number}'))?'

    # Runnable attributes.
    local pcre_attr_name=${pcre_operable_name}
    local pcre_attr_name_grouped='('${pcre_attr_name}')'
    local         pcre_attr_value=${pcre_equals_spaced}'(?:'${pcre_quotes_double}'|'${pcre_quotes_single}')'
    local pcre_attr_value_grouped=${pcre_equals_spaced}'(?|'${pcre_quotes_double_grouped}'|'${pcre_quotes_single_grouped}')'
    local                 pcre_attr=${pcre_attr_name}'(?:'${pcre_attr_value}')?'
    local pcre_attr_grouped=${pcre_attr_name_grouped}'(?:'${pcre_attr_value_grouped}')?'
    local pcre_attr_list='(?:'${pcre_attr}${pcre_comma_spaced}')*'${pcre_attr}
    local pcre_attr_list_grouped='('${pcre_attr_list}')'
    local pcre_attrs_prefix='(?:<'${pcre_spaces_optional}
    local pcre_attrs_suffix=${pcre_comma_spaced_optional_spaces}'>'${pcre_spaces}')?'
    local         pcre_attrs=${pcre_attrs_prefix}${pcre_attr_list}${pcre_attrs_suffix}
    local pcre_attrs_grouped=${pcre_attrs_prefix}${pcre_attr_list_grouped}${pcre_attrs_suffix}

    # Runnable return types. zeshy currently prohibits single- and double-quoted
    # return types, thus simplifying matching.
    local            pcre_return_type=${pcre_operable_type}
    local pcre_return_type_grouped='('${pcre_operable_type}')'
    local            pcre_return_channel_name=${pcre_operable_name}
    local pcre_return_channel_name_grouped='('${pcre_operable_name}')'
    local         pcre_return_channel=${pcre_return_channel_name}${pcre_equals_spaced}${pcre_return_type}
    local pcre_return_channel_grouped=${pcre_return_channel_name_grouped}${pcre_equals_spaced}${pcre_return_type_grouped}
    local pcre_return_channel_list='(?:'${pcre_return_channel}${pcre_comma_spaced}')*'${pcre_return_channel}
    local pcre_return_channel_list_grouped='('${pcre_return_channel_list}')'
    local pcre_return_channels_prefix='\['${pcre_spaces_optional}
    local pcre_return_channels_suffix=${pcre_comma_spaced_optional_spaces}'\]'
    local         pcre_return_channels=${pcre_return_channels_prefix}${pcre_return_channel_list}${pcre_return_channels_suffix}
    local pcre_return_channels_grouped=${pcre_return_channels_prefix}${pcre_return_channel_list_grouped}${pcre_return_channels_suffix}
    local         pcre_return_type_or_channels='(?:'${pcre_return_type}'|'${pcre_return_channels}')'${pcre_spaces}
    local pcre_return_type_or_channels_grouped='(?:'${pcre_return_type_grouped}'|'${pcre_return_channels_grouped}')'${pcre_spaces}

    # Runnable names.
    #
    # While zsh permits zeshy unquoted alias and function names to contain a
    # surprisingly wide array of characters, zeshy constrains such names so as
    # to avoid conflicting with other prototype syntax.
    #
    # Since zsh permits single- and double-quoted alias and function names
    # containing arbitrary and hence all possible characters, matching such
    # names requires more than merely class negation.
    #
    # While zsh only supports synonymous functions (e.g.,
    # "function name1 name2() { ... }"), there exists no reason *NOT* to extend
    # such support to aliases as well. (So, we do.)
    local pcre_runnable_name_unquoted=${pcre_operable_type}
    local pcre_runnable_name_unquoted_grouped='('${pcre_runnable_name_unquoted}')'
    local         pcre_runnable_name='(?:'${pcre_runnable_name_unquoted}'|'${pcre_quotes_double}'|'${pcre_quotes_single}')'
    local pcre_runnable_name_grouped='(?|'${pcre_runnable_name_unquoted_grouped}'|'${pcre_quotes_double_grouped}'|'${pcre_quotes_single_grouped}')'
    local pcre_runnable_names_list='(?:'${pcre_runnable_name}${pcre_comma_spaced}')*'${pcre_runnable_name}
    local pcre_runnable_names_list_grouped='('${pcre_runnable_names_list}')'
    local pcre_runnable_names_prefix='\{'${pcre_spaces_optional}
    local pcre_runnable_names_suffix=${pcre_comma_spaced_optional_spaces}'\}'
    local pcre_runnable_names_grouped=${pcre_runnable_names_prefix}${pcre_runnable_names_list_grouped}${pcre_runnable_names_suffix}
    local pcre_runnable_name_or_names_grouped='(?:'${pcre_runnable_name_grouped}'|'${pcre_runnable_names_grouped}')'${pcre_spaces_optional}

    # Runnable arguments.
    local         pcre_arg_type_uncaretted=${pcre_operable_type}${pcre_operable_name_slashed_optional}${pcre_operable_name_plussed_optional}
    local pcre_arg_type_uncaretted_grouped=${pcre_empty_group}${pcre_operable_type_grouped}${pcre_operable_name_slashed_optional_grouped}${pcre_operable_name_plussed_optional_grouped}
    local         pcre_arg_type_caretted=${pcre_caret_spaced}${pcre_operable_type}${pcre_operable_name_plussed_optional}
    local pcre_arg_type_caretted_grouped=${pcre_caret_spaced_grouped}${pcre_empty_group}${pcre_operable_type_grouped}${pcre_operable_name_plussed_optional_grouped}
    local         pcre_arg_type=${pcre_grave_spaced_optional}'(?:'${pcre_arg_type_uncaretted}'|'${pcre_arg_type_caretted}')'
    local pcre_arg_type_grouped=${pcre_grave_spaced_optional_grouped}'(?|'${pcre_arg_type_uncaretted_grouped}'|'${pcre_arg_type_caretted_grouped}')'
    local         pcre_arg_name=${pcre_grave_spaced_optional}${pcre_operable_name}${pcre_operable_name_plussed_optional}
    local pcre_arg_name_grouped=${pcre_grave_spaced_optional_grouped}${pcre_operable_name_grouped}${pcre_operable_name_plussed_optional_grouped}
    local       pcre_arg_default_value='(?:'${pcre_quotes_double_with_substitutions}'|'${pcre_quotes_single}'|'${pcre_number}')'
    local pcre_arg_default_value_grouped='('${pcre_quotes_double_with_substitutions}'|'${pcre_quotes_single}'|'${pcre_number}')'
    local         pcre_arg_default='(?:'${pcre_spaces_optional}'(?:'${pcre_eroteme_optional}'|'${pcre_grave_spaced_optional}'='${pcre_spaces_optional}${pcre_arg_default_value}'))?'
    local pcre_arg_default_grouped='(?:'${pcre_spaces_optional}'(?:'${pcre_eroteme_optional_grouped}'|'${pcre_grave_spaced_optional_grouped}'='${pcre_spaces_optional}${pcre_arg_default_value_grouped}'))?'
    local pcre_arg_is_variadic='(?:'${pcre_comma_spaced}${pcre_ellipse}')?'
    local pcre_arg_is_variadic_grouped='(?:'${pcre_comma_spaced}${pcre_ellipse_grouped}')?'
    local pcre_arg=${pcre_arg_type}${pcre_spaces}${pcre_arg_name}${pcre_arg_default}${pcre_arg_is_variadic}
    local pcre_arg_grouped=${pcre_arg_type_grouped}${pcre_spaces}${pcre_arg_name_grouped}${pcre_arg_default_grouped}${pcre_arg_is_variadic_grouped}
    local       pcre_arg_list_optional='(?:(?:'${pcre_arg}${pcre_comma_spaced}')*'${pcre_arg}')?'
    local pcre_arg_list_optional_grouped='((?:'${pcre_arg}${pcre_comma_spaced}')*'${pcre_arg}')?'
    local pcre_args_prefix='\('${pcre_spaces_optional}
    local pcre_args_suffix=${pcre_comma_spaced_optional_spaces}'\)'
    local         pcre_args=${pcre_args_prefix}${pcre_arg_list_optional}${pcre_args_suffix}
    local pcre_args_grouped=${pcre_args_prefix}${pcre_arg_list_optional_grouped}${pcre_args_suffix}
    print -r "args grouped: ${pcre_args_grouped}"

    # Runnable argument channels.
    local pcre_arg_channel_name=${pcre_operable_name}
    local pcre_arg_channel_name_grouped='('${pcre_arg_channel_name}')'
    local         pcre_channel_value=${pcre_args}
    local pcre_channel_value_grouped=${pcre_args_grouped}
    local  pcre_arg_channel=${pcre_arg_channel_name}${pcre_equals_spaced}${pcre_channel_value}
    local pcre_arg_channel_stdin='stdin'${pcre_equals_spaced}${pcre_channel_value}
    local pcre_arg_channel_args_grouped='args'${pcre_equals_spaced}${pcre_channel_value_grouped}
    local pcre_arg_channel_grouped=${pcre_arg_channel_name_grouped}${pcre_equals_spaced}${pcre_channel_value_grouped}
    local pcre_arg_channel_list='(?:'${pcre_arg_channel}${pcre_comma_spaced}')*'${pcre_arg_channel}
    local pcre_arg_channel_list_grouped='('${pcre_arg_channel_list}')'
    local pcre_arg_channels_prefix='\['${pcre_spaces_optional}
    local pcre_arg_channels_suffix=${pcre_comma_spaced_optional_spaces}'\]'
    local         pcre_arg_channels=${pcre_arg_channels_prefix}${pcre_arg_channel_list}${pcre_arg_channels_suffix}
    local pcre_arg_channels_grouped=${pcre_arg_channels_prefix}${pcre_arg_channel_list_grouped}${pcre_arg_channels_suffix}
    local pcre_arg_channels_args_grouped=${pcre_arg_channels_prefix}'(?|'${pcre_arg_channel_args_grouped}${pcre_comma_spaced}${pcre_arg_channel_stdin}'|'${pcre_arg_channel_stdin}'|'${pcre_arg_channel_stdin}${pcre_comma_spaced}${pcre_arg_channel_args_grouped}'|'${pcre_arg_channel_args_grouped}')?'${pcre_arg_channels_suffix}
    local         pcre_args_or_channels='(?:'${pcre_args}'|'${pcre_arg_channels}')'
    local pcre_args_or_channels_grouped='(?:'${pcre_args_grouped}'|'${pcre_arg_channels_grouped}')'
    local pcre_args_or_channels_args_grouped='(?|'${pcre_args_grouped}'|'${pcre_arg_channels_args_grouped}')'

    #FIXME: We don't appear to use these anywhere, at the moment. Don't get us
    #wrong: they look great. But they should probably be shifted somewhere into
    #the main codebase (e.g., @{*-main/zeshy/help}.

    # Function description. Ignore cross-references embedded in the following
    # AsciiDoc-specific passthrough syntactic constructs, which AsciiDoc and hence
    # zeshy ignores for parsing purposes:
    #
    # * "`"-delimited passthrough quotes.
    # * "pass:["- and "]"-delimited passthrough macros.
    # * "+++"-delimited passthrough macros.
    # * "$$"-delimited passthrough macros.
    # * "\n----"-delimited listing blocks.
    # * "\n...."-delimited literal blocks.
    # * "\n////"-delimited comment blocks.
    # * "\n++++"-delimited passthrough blocks.
    # * "\n[literal]"-prefixed literal paragraphs.
    # * "\n "- and "\n\t"-prefixed literal lines.
    #
    # Ignore cross-references embedded in the following AsciiDoc-specific anchored
    # syntactic constructs, which AsciiDoc anchors for subsequent cross-referencing
    # and hence should not themselves contain cross-references:
    #
    # * "\n."-prefixed block titles.
    local pcre_asciidoc_quote_backtick='\b`\N*?`\b'
    local pcre_asciidoc_macro_pass='pass:\[(?:\\\]|\N)*?\]'
    local pcre_asciidoc_macro_plus='\+\+\+\N*?\+\+\+'
    local pcre_asciidoc_macro_dollar='\$\$\N*?\$\$'
    local pcre_asciidoc_block_listing='-{4,}+\n.*?\n-{4,}+'
    local pcre_asciidoc_block_literal='\.{4,}+\n.*?\n\.{4,}+'
    local pcre_asciidoc_block_comment='/{4,}+\n.*?\n/{4,}+'
    local pcre_asciidoc_block_pass='\+{4,}+\n.*?\n\+{4,}+'
    local pcre_asciidoc_block_title_or_line_literal='(?:\.|[ \t]++)\N+'
    local pcre_asciidoc_paragraph_literal='^\[literal\]\n.*?(?:\n\n|\Z)'
    local pcre_asciidoc_cross_reference='((?:'${pcre_asciidoc_quote_backtick}'|\b(?:'${pcre_asciidoc_macro_pass}'|'${pcre_asciidoc_macro_plus}'|'${pcre_asciidoc_macro_dollar}')\b|^(?:'${pcre_asciidoc_block_listing}'|'${pcre_asciidoc_block_literal}'|'${pcre_asciidoc_block_comment}'|'${pcre_asciidoc_block_pass}'|'${pcre_asciidoc_block_title_or_line_literal}')$|'${pcre_asciidoc_paragraph_literal}'|.)*?)([$@]\{'${pcre_operable_name}'\}|(?:(alias|func):)?'${pcre_operable_name}'\(\))'
    local pcre_asciidoc_suffix='(.*)'
    local pcre_asciidoc='\s*+(.*)'

    # PCRE capturing all names and optional value in global prototypes.
    ZESHY_PROTOTYPE_GLOBAL_NAMES_VALUE_PCRE=${pcre_global_name_or_names_grouped}${pcre_global_value_grouped}

    # PCRE capturing the next name in a "="-delimited list of such names,
    # presumably captured from a global prototype.
    ZESHY_PROTOTYPE_GLOBAL_NAMES_NEXT_PCRE=${pcre_global_name_grouped}'='

    # PCRE matching all attributes and names in function prototypes.
    ZESHY_PROTOTYPE_FUNC_ATTRS_AND_NAMES_PCRE=${pcre_start}${pcre_attrs_grouped}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}

    # PCRE capturing all attributes, names, and arguments in runnable
    # prototypes.
    ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NAMES_ARGS_PCRE=${pcre_start}${pcre_attrs_grouped}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}${pcre_args_or_channels_args_grouped}
    print -r 'runnable prototype PCRE: '$'\n'${ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NAMES_ARGS_PCRE}

    # PCRE capturing a single name in runnable prototypes declaring only one
    # such name.
    ZESHY_PROTOTYPE_RUNNABLE_NAME_PCRE=${pcre_start}${pcre_attrs}${pcre_return_type_or_channels}${pcre_runnable_name_grouped}

    # PCRE capturing a single name in runnable prototypes declaring only one
    # such name *AND* the substrings prefixing and suffixing such name.  To
    # assist subsequent substitutions, preserve otherwise negligible syntax and
    # whitespace in such prefix and suffix by expanding ungrouped rather than
    # grouped PCREs. (The latter discard all negligible syntax and whitespace.)
    ZESHY_PROTOTYPE_RUNNABLE_NAME_SUFFIXED_PREFIXED_PCRE=${pcre_start}'('${pcre_attrs}${pcre_return_type_or_channels}')'${pcre_runnable_name_grouped}'('${pcre_args_or_channels}')'

    # PCRE matching all names in runnable prototypes.
    ZESHY_PROTOTYPE_RUNNABLE_NAMES_PCRE=${pcre_start}${pcre_attrs}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}${pcre_args_or_channels}

    # PCRE capturing the next attribute in a comma-delimited list of such
    # attributes, presumably captured from a runnable prototype.
    ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NEXT_PCRE=${pcre_attr_grouped}${pcre_comma_spaced_optional}

    # PCRE capturing the next name in a comma-delimited list of such names,
    # presumably captured from a runnable prototype.
    ZESHY_PROTOTYPE_RUNNABLE_NAMES_NEXT_PCRE=${pcre_runnable_name_grouped}${pcre_comma_spaced_optional}

    # PCRE capturing the next argument in a comma-delimited list of such
    # arguments, presumably captured from a runnable prototype.
    ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE=${pcre_arg_grouped}${pcre_comma_spaced_optional}
    # print -r "arg pcre: ${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}"

#(?s)^\s*+(?:<\s*+((?:[a-zA-Z0-9-_]++(?:\s*+=\s*+(?:"(?:\\"|[^"])*"|'(?:[^']|'')*'))?\s*+,\s*+)*[a-zA-Z0-9-_]++(?:\s*+=\s*+(?:"(?:\\"|[^"])*"|'(?:[^']|'')*'))?)(?:\s*+,\s*+)?\s*+>\s++)?
#(?:[a-zA-Z0-9-_:]++|\[\s*+(?:[a-zA-Z0-9-_]++\s*+=\s*+[a-zA-Z0-9-_:]++\s*+,\s*+)*[a-zA-Z0-9-_]++\s*+=\s*+[a-zA-Z0-9-_:]++(?:\s*+,\s*+)?\s*+\])
#\s++(?:(?|([a-zA-Z0-9-_:]++)|"((?:\\"|[^"])*)"|'((?:[^']|'')*)')|\{\s*+((?:(?:[a-zA-Z0-9-_:]++|"(?:\\"|[^"])*"|'(?:[^']|'')*')\s*+,\s*+)*(?:[a-zA-Z0-9-_:]++|"(?:\\"|[^"])*"|'(?:[^']|'')*'))(?:\s*+,\s*+)?\s*+\})

#FIXME: If, after rigorously eyeballing this, we're still unable to decpiher
#the issue, paste into a "pcretest" session (the library underlying "libpcre").
#Failing that, consider the following URLs:
#
#* http://regex101.com/, a RegexBuddy alternative specific to "libpcre". Yay!
#* https://stackoverflow.com/questions/2348694/how-do-you-debug-a-regex,
#  exhaustive discussion of all alternatives.

    # ..................{ GLOBALS ~ arg indices              }..................
    # Current PCRE match index for groups matched by
    # ${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}. Such PCRE matches a veritably
    # obscene number of groups, necessitating some measure of human-
    # readability. (This is it.)
    integer match_index=1

    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support constant globals. *sigh*

    # For each such group, define a human-readable global expanding to such
    # group's match index. See ={help/declare/pcre} for related documentation.
    local match_index_name
    for   match_index_name (
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_LOCAL
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MAJOR
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MINOR
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_SUFFIX
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE
        ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_VARIADIC
    ) {
        integer -g ${match_index_name}=$(( match_index++ ))
    }
}

# --------------------( WASTELANDS                         )--------------------
    # Colon preceded by optional whitespace followed by mandatory whitespace.
    # local pcre_colon_spaced='\s*+:\s++'

    #FUXME: Shouldn't need the trailing "\s*+". Examine everywhere we expand
    #such PCRE below and (ideally) excise such suffix.

    #FUXME: Permit arbitrary whitespace surrounding such syntax; then, rename
    #such locals accordingly.

    # local pcre_number='-?\d++\.\d++|-?\d++'

    # integer -g\
    #     ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_RELAXED=$(( match_index++ ))\
    #     ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT=$(( match_index++ ))\
    #     ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_LOCAL=$(( match_index++ ))\
    #     ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MAJOR=$(( match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_SUBTYPE_MINOR=$(( match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_IS_RELAXED=$((
    #     match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME_SUFFIX=$(( match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_NAME=$(( match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_ABSENTABLE=$((
    #     match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE_IS_RELAXED=$((
    #     match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_DEFAULT_VALUE=$((
    #     match_index++ ))

    # integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_IS_VARIADIC=$((
    #     match_index++ ))

    # Asterisk (i.e., star).
    # local pcre_star='\*'
    # local pcre_star_optional=${pcre_star}'?'
    # local pcre_star_optional_grouped='('${pcre_star}')?'

#     :global.document <<'/---'
# :int ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE
# 
# When parsing runnable prototype arguments with
# ${ZESHY_PROTOTYPE_RUNNABLE_ARGS_NEXT_PCRE}, the ${match} index for the
# currently parsed argument's mandatory *type* (i.e., concatenation of such
# argument's type indirective, local subtype, major subtype, and minor subtype).
# Such string is unparsed and hence intended _only_ for expansion in human-
# readable exception messages.
# /---
#     integer -g ZESHY_RUNNABLE_ARG_MATCH_INDEX_TYPE=$((
#         match_index++ ))

# While specifying a default value for such argument _also_ signifies such
# argument to be optional, optionality implies such argument to have _no_ value
# rather than simply a default value if unpassed if unpassed. Hence, while
# similarly optional, optionalized arguments and defaulted arguments signify
# differing semantics requiring syntactic distinction.

# == Comparison to Defaulted Arguments ==
    # ${pcre_star_optional}${pcre_operable_type}${pcre_operable_name_slashed_optional}${pcre_operable_name_plussed_optional}
 # rather than an argument of such type
 
#, where `${subtype_major}`
# is such subtype
#, implying such argument to be validated by a call to function
# `${type}.die_unless`
# suffixing the name of the
# function validating such argument in the body of such runnable).

    # Variable value.
    # local pcre_value_quoted_single=${pcre_quotes_single}

    # local pcre_plus_grouped='('${pcre_plus}')'
    # local pcre_plus_optional='(?:'${pcre_plus}')?'
    # local pcre_plus_optional_grouped='('${pcre_plus}')?'

# local pcre_eroteme_grouped='('${pcre_eroteme}')'
    # local          pcre_channel_value='(?:'${pcre_arg}'|'${pcre_args}')'
    # local pcre_channel_value_grouped='(?|('${pcre_arg}')|'${pcre_args_grouped}')'

    # local pcre_arg_channel_sans_args_name='(?!args)'${pcre_arg_channel_name}
    # local pcre_arg_channel_sans_args=${pcre_arg_channel_sans_args_name}${pcre_equals_spaced}${pcre_arg_or_args}
    # local pcre_arg_channel_sans_args_list='(?:'${pcre_arg_channel_sans_args}${pcre_comma_spaced}')*'
    # local pcre_arg_channels_with_args_grouped=${pcre_arg_channels_prefix}${pcre_arg_channel_sans_args_list}${pcre_arg_channel_with_args_grouped}${pcre_arg_channel_list}${pcre_arg_channels_suffix}

    #FUXME: Need a negative assertion preventing the first
    #${pcre_arg_channel_list} from matching "args = " -- perhaps a new
    #${pcre_arg_channel_sans_args_list}.

    # Pseudo-type signifying such runnable to either return or accept nothing,
    # inspired by standard high-level language usage. Unlike pseudo-type ":full"
    # applying only to return values, this pseudo-type applies to both return
    # values and argument lists.
    #
    # Note that, for the latter purpose, an empty argument list also suffices
    # to convey the same purpose. However,
    # ":void my_func[args: ()]"  Technically, runnable prototypes need *NOT*
    #
    # Note that, for the latter purpose, explicitly
    # specifying ":void" is equivalent to specifying no arguments 
    # local pcre_void=':void'

    # local         pcre_args='\(\s*+(?:'${pcre_void}'|'${pcre_args_list}')?\s*+\)'
    # local pcre_args_grouped='\(\s*+(?:'${pcre_void}'|'${pcre_args_list_grouped}')?\s*+\)'

    # Runnable argument channels.
    # local          pcre_arg_or_args='(?:'${pcre_void}'|'${pcre_arg}'|'${pcre_args}')'
    # local pcre_arg_or_args_grouped='(?:('${pcre_void}'|'${pcre_arg}')|('${pcre_args}'))'

    # local         pcre_return_type='(?:'${pcre_full}'|'${pcre_void}'|'${pcre_operable_type}')'
    # local pcre_return_type_grouped='(?:'${pcre_void}'|('${pcre_operable_type}'))'

    # local pcre_return_type=${pcre_operable_type}
    # local pcre_return_type_grouped='(?:'${pcre_void}'|('${pcre_return_type}'))'
    # local         pcre_return_channels='\[\s*+[^]]*+\]'
    # local pcre_return_channels_grouped='\[\s*+([^]]*+)\]'

    #FUXME: Exclude attributes and names.
    # PCRE matching all semantic substrings in function prototypes, excluding
    # attributes and names. This includes return types, arguments, and AsciiDoc.
    # ZESHY_PROTOTYPE_FUNC_SANS_ATTRS_AND_NAMES_PCRE="${pcre_start}${pcre_attrs_grouped}${pcre_return_type_or_channels_grouped}${pcre_runnable_name_or_names_grouped}${pcre_args_or_channels_grouped}${pcre_asciidoc}"'()$'

    # local pcre_global_grouped=${pcre_global_type_grouped}'\s++'${pcre_global_name_or_names_grouped}${pcre_global_value_grouped}

    # PCRE capturing the type, names, and optional value in global prototypes.
    # ZESHY_PROTOTYPE_GLOBAL_TYPE_NAMES_VALUE_PCRE=${pcre_global_grouped}

    # PCRE matching the next "="-suffixed global name in "="-delimited global
    # definitions. Such syntax mimics conventional "="-delimited variable
    # assignments in zsh and hence prohibits whitespace.

    # local pcre_attr_name=${pcre_operable_name}
    # local pcre_attr_name_grouped='('${pcre_attr_name}')'
    # local pcre_attr_value_unquoted=${pcre_operable_name}
    # local pcre_attr_value_unquoted_grouped='('${pcre_attr_value_unquoted}')'
    # local         pcre_attr_value=${pcre_colon_spaced}'(?:'${pcre_quotes_double}'|'${pcre_quotes_single}'|'${pcre_attr_value_unquoted}')'
    # local pcre_attr_value_grouped=${pcre_colon_spaced}'(?|'${pcre_quotes_double_grouped}'|'${pcre_quotes_single_grouped}'|'${pcre_attr_value_unquoted_grouped}')'

    # Abstract identifier used *ONLY* for descriptive purposes (e.g., function
    # argument names) and hence defined in a fairly crude but efficient manner.
    # Such PCRE is *NOT* intended to match actual zsh syntax (e.g., global
    # names). See ${ZESHY_DECLARATOR_PCRE_GLOBAL_NAME} below, in particular.

 # for such types
    # Since
    # all operable types defined by zeshy are unquoted, such PCRE matches only
    # the exact subset of characters used for such types.

    # However, since such support is a superficial convenience, there exists no
    # reason *NOT* to extend such support to alias syntax as well. So, we do.
    # Unquoted runnable name. While quoted runnable names may contain all
    # possible characters, unquoted runnable names are constrained so as *NOT*
    # to conflict with prototype syntax. For simplicity, extend
    # ${pcre_operable_name} with punctuation guaranteed to avoid such conflict.
 # While reliably quoting
    # alias names is non-trivial (unlike functions), it *IS* feasible. See
    # :define_alias_simple() for further details.
    #FUXME: Incorrect. We'll want to support quoted attribute values containing
    #arbitrary characters and hence possibly ">" or ",", requiring more
    #sophisticated parsing here.

    # local pcre_arg_value_content=${pcre_arg_value_quoted_double}'|'${pcre_arg_value_quoted_single}'|'${pcre_arg_value_number}
    # local       pcre_arg_value=${pcre_equals_spaced}'(?:'${pcre_arg_value_content}')'
    # local pcre_arg_value_grouped=${pcre_equals_spaced}'('${pcre_arg_value_content}')'

    # Equals sign preceded and followed by optional whitespace.
    # local pcre_equals_spaced='\s*+=\s*+'

    # local pcre_runnable_names_grouped='\{\s*+((?:'${pcre_runnable_name}'(?:'${pcre_comma_spaced}'|\s++))*'${pcre_runnable_name}')(?:'${pcre_comma_spaced}')?\s*+\}'

    # Runnable attributes. zeshy currently prohibits single- and double-quoted
    # attribute values, thus simplifying matching.
    # local         pcre_attrs='(?:<\s*+[^>]++>\s++)?'
    # local pcre_attrs_grouped='(?:<\s*+([^>]++)>\s++)?'

    #FUXME: Add support for variadic arguments.

    # local             pcre_arg=${pcre_operable_name}'\s++'${pcre_operable_name}'(?:'${pcre_arg_value}')?'
    # local pcre_arg_grouped='('${pcre_operable_name}')\s++('${pcre_operable_name}')(?:'${pcre_arg_value_grouped}')?'

    #FUXME: Correct me. *sigh*
    # local          pcre_args_list='(?:'${pcre_arg}${pcre_comma_spaced}'(?:\.\.\.'${pcre_comma_spaced}')?)*'${pcre_arg}'(?:'${pcre_comma_spaced}')?'
    # local          pcre_args_list='(?:'${pcre_arg}${pcre_comma_spaced}'(?:\.\.\.)?)*'${pcre_arg}'(?:'${pcre_comma_spaced}')?'

    # ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE\
    # ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE="${pcre_start}${pcre_return_type_or_channels}${pcre_runnable_name_or_names_grouped}"

#FUXME: Rename ${ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE} to
#${ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE} and similarly for all other globals below
#containing "_PROTOTYPE". The focus is not the help string; the focus is the
#declarator itself. The help string is only optionally along for the ride, now.

    # PCRE matching all global names preceding the value to initialize such
    # namess to in "="-delimited global definitions. Such syntax mimics
    # conventional "="-delimited variable assignments in zsh and hence prohibits
    # whitespace.
#    ZESHY_DECLARATION_PCRE_GLOBAL_NAMES='((?:'${pcre_global_name}'=)+)(.*)'
#
#    # PCRE matching the next "="-suffixed global name in such definitions.
#    ZESHY_DECLARATION_PCRE_GLOBAL_NAME='('${pcre_global_name}')='

# This PCRE is *ONLY* used to validate such syntax and hence
    # captures no substrings.
    # PCRE matching the next "="-suffixed global name in a "="-delimited global
    # definition optionally followed by the final "="-prefixed global value.
    # Such syntax mimics conventional "="-delimited zsh variable assignments in
    # zsh and hence prohibits whitespace.

    # PCRE matching all global names preceding the value to initialize such
    # names to in "="-delimited global definitions. Such syntax mimics
    # conventional "="-delimited variable assignments in zsh and hence prohibits
    # whitespace.
#   ZESHY_DECLARATOR_PCRE_GLOBAL_NAMES='((?:'${pcre_global_name_ungrouped}'=)+)'
    # PCRE matching the next global name in a list of such names.

    # Function names. Since functions but *NOT* aliases support synonyms,
    # function and alias name syntax must be handled distinctly.
#   local pcre_function_name_grouped='('${pcre_runnable_name_content}')'
#   local       pcre_function_name='(?:'${pcre_runnable_name_content}')'
#   local pcre_function_names='\{\s*+((?:'${pcre_runnable_name}'(?:'${pcre_comma_spaced}'|\s++))*'${pcre_runnable_name}')(?:'${pcre_comma_spaced}')?\s*+\}'
#   local pcre_function_name_or_names='(?:'${pcre_runnable_name_grouped}'|'${pcre_function_names}')\s*+'

    # Alias names. Since zsh permits single- and double-quoted alias names,
    # matching requires more than class negation. While quoting alias names is
    # is non-trivial (unlike functions), it *IS* feasible. See :define_alias_simple()
    # for further details.
#   local pcre_alias_name_grouped='('${pcre_runnable_name_content}')'
