#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under @{help} in the main codebase.

#FIXME: Incidentally, optional arguments are silly. Do other high-level
#languages permit customization of core exception messages? No. Of course not.
#(Well, (O.K.: some do via inheritance, duck typing, and so on. But not
#*REALLY*.)
#If the caller *REALLY* wants a custom exception message, all they have to do
#is call the corresponding tester followed by ":die" and such message. Right?
#Nothing could be simpler. So, sadly, we *REALLY* need to excise this pattern
#of accepting optional error messages from the codebase. (We know; we know.)

# ....................{ EXCEPTIONS                         }....................
# :void :die_unless_var_bool(:string:var var_name1, ...)
function :die_unless_var_bool() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_bool "${@}" ||
        ::die_unless_var_type_with_label "${@}" bool 'boolean'
}

# :void :die_unless_var_char(:string:var var_name1, ...)
function :die_unless_var_char() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_char "${@}" ||
        ::die_unless_var_type_with_label "${@}" char 'character'
}

# :void :die_unless_var_float(:string:var var_name1, ...)
function :die_unless_var_float() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_float "${@}" ||
        ::die_unless_var_type_with_label "${@}" float 'float'
}

# :void :die_unless_var_int(:string:var var_name1, ...)
function :die_unless_var_int() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_int "${@}" ||
        ::die_unless_var_type_with_label "${@}" int 'integer'
}

# :void :die_unless_var_list(:string:var var_name1, ...)
function :die_unless_var_list() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_list "${@}" ||
        ::die_unless_var_type_with_label "${@}" list 'list'
}

# :void :die_unless_var_map(:string:var var_name1, ...)
function :die_unless_var_map() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_map "${@}" ||
        ::die_unless_var_type_with_label "${@}" map 'map'
}

# :void :die_unless_var_string(:string:var var_name1, ...)
function :die_unless_var_string() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_var_string "${@}" ||
        ::die_unless_var_type_with_label "${@}" string 'string'
}

#FIXME: Document me.

# :void ::die_unless_var_type_with_label(
#    :string:var var_name1, ...,
#    :string var_type,
#    :string var_type_label)
function ::die_unless_var_type_with_label() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more variable names, one variable type, and one variable type label.'
    local\
        var_type__duvt="${@[-2]}"\
        var_type_label__duvt="${@[-1]}"\
        var_tester_func_name

    #FIXME: We're seeing such functionality repeated a bit. Perhaps we want to
    #shift :die_unless_func() and :is_func() here as well?

    # If such function does *NOT* exist, throw an exception. See
    # :die_unless_func() for further details.
    var_tester_func_name=":is_var_${var_type__duvt}"
    (( ${+functions[${var_tester_func_name}]} )) || :die\
        'Variable type "'${var_type__duvt}'" unrecognized (i.e., function '${var_tester_func_name}'() undefined).'

    # If such function reports failure for any such variable, throw an
    # exception with such variable's name and type label.
    local var_name__duvt
    for   var_name__duvt ("${@[1,-3]}") {
        "${var_tester_func_name}" "${var_name__duvt}" || {
            # Capitalized and lowercase variants of such variable type label.
            # While demanding the caller pass a strictly lowercase type label
            # would simplify such logic, this remains more robust.
            local\
                var_type_label_capped__duvt="${(C)var_type_label__duvt[1]}${var_type_label__duvt[2,-1]}"
.
                var_type_label_lowered__duvt="${(L)var_type_label__duvt}"

            # Throw such exception.
            :die ${var_type_label_capped__duvt}' ${'${var_name__duvt}'} not found or not a '${var_type_label_lowered__duvt}'.'
        }
    }
}

# ....................{ TESTERS                            }....................
#FIXME: Arguably, the :is_var_*() variants should throw exceptions if any such
#variable does not exist. That's certainly how we implemented such functions
#before; unfortunately, refactoring such functions in such manner will require
#shifting both :die_unless_var() and :is_var() here. But, perhaps we'll
#eventually want to do so anyway? (Probably not an issue, considering how much
#other functionality we've shifted here already.)
#FIXME: However, note that tests for variable existence needn't be performed by
#the above exception handlers, for obvious reasons. For efficiency, then:
#
#* Rename all current :is_var_*() testers to ::is_var_*() (e.g., from
#  :is_var_list() to ::is_var_list()).
#* Make new :is_var_*() testers calling (in order):
#  * :die_unless_var().
#  * ::is_var_*().
#* Call ::is_var_*() rather than :is_var_*() from the corresponding exception
#  handlers.
#FIXME: The additional nice thing about the above approach is that we can then
#shift the front-end :is_var_*() testers, which are no longer required here
#(and should never be) to @{*-main/var/type}.
#FIXME: Actually, given the triviality of such ::is_var_*() functions, it would
#probably be preferable to render them aliases rather than functions. (Again,
#for the *NERY* slight efficiency boost.)

#FIXME: Honestly, we should probably just excise the shorthand :is_var_list(),
#:is_map(), and :is_string() variants entirely. Such variants contribute little
#to nothing, particularly as we're pretty much using them *WRONG* wherever we
#currently call them. (Since we generally want exceptions to be thrown if such
#variables do *NOT* exist, we want to be calling the longhand :is_var_list(),
#:is_var_map(), and :is_vap_string() variants instead.)

# [status = :bool] :is_var_float(:string:var var_name1, ...)
function :is_var_float() {
    (( # )) || :die 'Expected one or more variable names.'
    ::is_var_type_matches_glob "${@}" 'float'
}

# [status = :bool] {:is_var_int, :is_var_bool}(:string:var var_name1, ...)
function :is_var_int :is_var_bool() {
    (( # )) || :die 'Expected one or more variable names.'
    ::is_var_type_matches_glob "${@}" 'integer'
}

# [status = :bool] :is_var_list(:string:var var_name1, ...)
function :is_var_list() {
    (( # )) || :die 'Expected one or more variable names.'
    ::is_var_type_matches_glob "${@}" '(array|list)'
}

# [status = :bool] :is_var_map(:string:var var_name1, ...)
function :is_var_map() {
    (( # )) || :die 'Expected one or more variable names.'
    ::is_var_type_matches_glob "${@}" 'association'
}

# [status = :bool] {:is_var_string, :is_var_char}(:string:var var_name1, ...)
function :is_var_string :is_var_char() {
    (( # )) || :die 'Expected one or more variable names.'
    ::is_var_type_matches_glob "${@}" 'scalar'
}

# ....................{ TESTERS ~ private                  }....................
# [status = :bool] ::is_var_type_matches_glob(
#     :string:var var_name1, ..., :glob type_glob)
function ::is_var_type_matches_glob() {
    # Validate sanity.
    (( # >= 2 )) || :die\
        'Expected one or more variable names and one type glob.'

    # If only one variable name was passed, test such name without iteration.
    if (( # == 2 )) {
        [[ "${(tP)1-}" == ${~2}* ]]
    # Else, multiple variable names were passed.
    } else {
        # Temporarily clear the internal field separator (IFS). Failing to do
        # so here causes each string substitution performed below to be
        # delimited by whitespace; since matching such whitespace is
        # cumbersome, sidestep the issue entirely.
        local IFS=

        # Test such names iteratively. For efficiency, avoid explicit iteration
        # by condensing all such tests into a single dynamically evaluated
        # test. Dismantled, this is:
        #
        # * "${(e)...}", dynamically expanding the result of such expansion
        #   (e.g., "${(t)my_string1-}:${(t)my_string2-}:").
        # * "${...//.../...}", replacing each passed variable name with a string
        #   delimiting such name by "${(t)" and "-}:" (e.g., replacing a passed
        #   variable name "my_int" with "${(t)my_int-}:"), which zsh then expands
        #   to a ":"-delimited string of the types of such variables.
        # * "(#m)*", capturing the current variable name to ${MATCH}.
        # * "(...)(#c{#})", matching as many "scalar"-prefixed type strings as
        #   there were passed variables, implying all such variables to be strings.
        [[ "${(e)${@[1,-2]//(#m)*/\${(t)${MATCH}-\}:}}" ==\
            (${~@[-1]}[^:]#':')(#c${#}) ]]  # quiet vim: "}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Define a new utility function
#
# :void :die_unless_func_succeeds(
#    :string:func func_name,
#    :string func_arg1, ...,
#    :string )

    # :is_var_float "${@}" || {
    #     local var_name
    #     for   var_name ("${@}") {
    #         :is_var_float "${var_name}" || :die\
    #             'Float ${'${var_name}'} not found or not a float.'
    #     }
    # }

 # In such documentation, note the passed label should be
#strictly lowercase.
#FUXME: Document all functions below.

    # See :is_string() for further details.
    # (( # )) || :die 'Expected one or more variable names.'
    # (( # == 1 )) && [[ "${(tP)1-}" == ('array'|'list')* ]] || {
    #     local IFS= [[ "${(e)${@//(#m)*/\${(t)${MATCH}-\}:}}" ==\
    #         (('array'|'list')[^:]#':')(#c${#}) ]]  # quiet vim: "}"
    # }

    # See :is_string() for further details.
    # (( # )) || :die 'Expected one or more variable names.'
    # (( # == 1 )) && [[ "${(tP)1-}" == 'association'* ]] || {
    #     local IFS=
    #     [[ "${(e)${@//(#m)*/\${(t)${MATCH}-\}:}}" ==\
    #         ('association'[^:]#':')(#c${#}) ]]  # quiet vim: "}"
    # }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with testers above and below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    # (( # )) || :die 'Expected one or more variable names.'

    # # If only one variable name was passed, test such name without iteration.
    # (( # == 1 )) &&
    #     [[ "${(tP)1-}" == 'scalar'* ]] ||
    # # Else, multiple variable names were passed.
    # {
    #     # Temporarily clear the internal field separator (IFS). Failing to do
    #     # so here causes each string substitution performed below to be
    #     # delimited by whitespace; since matching such whitespace is
    #     # cumbersome, sidestep the issue entirely.
    #     local IFS=

    #     # Test such names iteratively. For efficiency, avoid explicit iteration
    #     # by condensing all such tests into a single dynamically evaluated
    #     # test. Dismantled, this is:
    #     #
    #     # * "${(e)...}", dynamically expanding the result of such expansion
    #     #   (e.g., "${(t)my_string1-}:${(t)my_string2-}:").
    #     # * "${@//.../...}", replacing each passed variable name with a string
    #     #   delimiting such name by "${(t)" and "-}:" (e.g., replacing a passed
    #     #   variable name "my_int" with "${(t)my_int-}:"), which zsh then expands
    #     #   to a ":"-delimited string of the types of such variables.
    #     # * "(#m)*", capturing the current variable name to ${MATCH}.
    #     # * "(...)(#c{#})", matching as many "scalar"-prefixed type strings as
    #     #   there were passed variables, implying all such variables to be strings.
    #     [[ "${(e)${@//(#m)*/\${(t)${MATCH}-\}:}}" ==\
    #         ('scalar'[^:]#':')(#c${#}) ]]  # quiet vim: "}"
    # }

    # See :is_string() for further details.
    # (( # )) || :die 'Expected one or more variable names.'
    # (( # == 1 )) && [[ "${(tP)1-}" == 'float'* ]] || {
    #     local IFS=
    #     [[ "${(e)${@//(#m)*/\${(t)${MATCH}-\}:}}" ==\
    #         ('float'[^:]#':')(#c${#}) ]]  # quiet vim: "}"
    # }

    # See :is_string() for further details.
    # (( # )) || :die 'Expected one or more variable names.'
    # (( # == 1 )) && [[ "${(tP)1-}" == 'integer'* ]] || {
    #     local IFS=
    #     [[ "${(e)${@//(#m)*/\${(t)${MATCH}-\}:}}" ==\
    #         ('integer'[^:]#':')(#c${#}) ]]  # quiet vim: "}"
    # }

#type_glob="${@[-1]}" 
#FUXME: Too much repetition below. Define a new private utility function
# [status = :bool] ::is_var_type_matches_glob(
#     :string:var var_name1, ..., :glob glob)

#FUXME: Unconvinced the multiple-argument variant of these functions actually
#works! Fairly certain we require parameter expnasion flag "(e)". Contemplate.
#FUXME: Awesome. Replicate below for lists and maps *AFTER* we double-check
#this as working as intended.

#FUXME: Now that we basically no longer need to manually call such low-level
#handlers, there's little reason to retain the shorthand of :is_var_list(),
#:is_map(), and :is_string().

    # if { zselect -t 0 -a zselect_status -r 0 } {
    #     exit_status="${status}"
    # }
