#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to a chicken-and-the-egg problem, all operables defined below are
# subsequently documented under @{help} in the main codebase.

# ....................{ EXCEPTIONS                         }....................
#FIXME: Awesome. Replicate below for lists and maps *AFTER* we double-check
#this as working as intended.
#FIXME: Incidentally, optional arguments are silly. Do other high-level
#languages permit customization of core exception messages? No. Of course not.
#(Well, (O.K.: some do via inheritance, duck typing, and so on. But not
#*REALLY*.)
#If the caller *REALLY* wants a custom exception message, all they have to do
#is call the corresponding tester followed by ":die" and such message. Right?
#Nothing could be simpler. So, sadly, we *REALLY* need to excise this pattern
#of accepting optional error messages from the codebase. (We know; we know.)

# :void :die_unless_list(:string:var var_name1, ...)
function :die_unless_list() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_list "${@}" || {
        local var_name
        for   var_name ("${@}") {
            :is_list "${var_name}" || :die\
                'List ${'${var_name}'} not found or not a list.'
        }
    }
}

# :void :die_unless_map(:string:var var_name1, ...)
function :die_unless_map() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_map "${@}" || {
        local var_name
        for   var_name ("${@}") {
            :is_map "${var_name}" || :die\
                'Map ${'${var_name}'} not found or not a map.'
        }
    }
}

# :void :die_unless_string(:string:var var_name1, ...)
function :die_unless_string() {
    (( # )) || :die 'Expected one or more variable names.'
    :is_string "${@}" || {
        local var_name
        for   var_name ("${@}") {
            :is_string "${var_name}" || :die\
                'String ${'${var_name}'} not found or not a string.'
        }
    }
}

# ....................{ TESTERS                            }....................
# [status = :bool] :is_list(:list:var var_name1, ...)
function :is_list() {
    # See :is_list() for further details.
    (( # )) || :die 'Expected one or more variable names.'
    (( # == 1 )) &&
        [[ "${(tP)1-}" == ('array'|'list')* ]] ||
        [[ "${@//(#m)*/\$\{(t)${MATCH}-\}:}" ==\
            (('array'|'list')[^:]#':')(#c${#}) ]]
}

# [status = :bool] :is_map(:map:var var_name1, ...)
function :is_map() {
    # See :is_map() for further details.
    (( # )) || :die 'Expected one or more variable names.'
    (( # == 1 )) &&
        [[ "${(tP)1-}" == 'association'* ]] ||
        [[ "${@//(#m)*/\$\{(t)${MATCH}-\}:}" ==\
            ('association'[^:]#':')(#c${#}) ]]
}

# [status = :bool] :is_string(:string:var var_name1, ...)
function :is_string() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with testers above.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    (( # )) || :die 'Expected one or more variable names.'

    # If only one variable name was passed, test such name without iteration.
    (( # == 1 )) &&
        [[ "${(tP)1-}" == 'scalar'* ]] ||
    # Else, multiple variable names were passed. Test such names iteratively.
    # For efficiency, avoid explicit iteration by condensing all such tests
    # into a single dynamically evaluated test. Dismantled, this is:
    #
    # * "${@//.../...}", replacing each passed variable name with a string
    #   delimiting such name by "${(t)" and "-}:" (e.g., replacing a passed
    #   variable name "my_int" with "${(t)my_int-}:"), which zsh then expands
    #   to a ":"-delimited string of the types of such variables.
    # * "(#m)*", capturing the current variable name to ${MATCH}.
    # * "(...)(#c{#})", matching as many "scalar"-prefixed type strings as
    #   there were passed variables, implying all such variables to be strings.
        [[ "${@//(#m)*/\$\{(t)${MATCH}-\}:}" == ('scalar'[^:]#':')(#c${#}) ]]
}

# ....................{ TESTERS                            }....................
# [status: bool] :is_stdin_readable_sans_blocking()
function :is_stdin_readable_sans_blocking() {
    # Validate sanity.
    (( # == 0 )) || :die 'Expected no arguments.'

    # Given the criticality and commonality of this test, one would assume there
    # to exist builtins or commands for accomplishing it. One would be wrong.
    # Testing whether such file descriptor and hence input is readable without
    # blocking requires calling the commonly available kernel function select().
    # Ideally, such test would elegantly reduce to the following:
    #
    #     read -t 0 -k 0
    #
    # Dismantled, this is:
    #
    # * "-t 0", testing whether standard input is readable without blocking and
    #   returning immediately if not.
    # * "-k 0", reading 0 bytes from standard input if such input is readable.
    #
    # Unfortunately, "read -t 0 -k 0" always returns failure. This differs from
    # bash, in which "read -t 0 -N 0" conditionally returns success when one
    # expects it to. Hence, this test defers to select() instead.
    #
    # Since zselect() (the zsh select() wrapper) returns failure with exit
    # status 2 when the underlying OS fails to provide a select() function,
    # capture and test such status rather than implicitly returning such status
    # as this function's exit status.
    #
    # Dismantled, this is:
    #
    # * "-t 0", reporting whether input bytes exist to be read without waiting.
    # * "-a ...", setting such list to contain a string resembling either
    #   "-r 0" if standard input is nonempty or "" if standard input is empty.
    #   Since zselect() defaults such list to ${reply} if unpassed *AND* since
    #   such list is commonly used by callers and should *NOT* be overwritten by
    #   such a low-level function as this, explicitly specify such list. Since
    #   this function never references such list, our specifying it here is
    #   simply to avoid overwriting ${reply}. (Frankly, this "unique" choice of
    #   API design is one of the more eclectic that we've ever seen. And we were
    #   proficient in ML... once.)
    # * "-r ...", testing such file descriptor for nonempty reading.
    #
    # Note that the "{" and "}" delimiters surrounding such integer assignment
    # are essential; neglecting delimiters assigns such integer standard input
    # to *THIS* function rather than such exit status. (O^o)
    #
    # Thus does another feeble mind break.
    local        -a zselect_status
    zselect -t 0 -a zselect_status -r 0 || {
        # Preserve the exit status reported by such builtin.
        integer exit_status="${status}"

        # If such status indicates the current kernel to *NOT* provide such
        # function, throw an exception.
        if (( exit_status == 2 )) {
            :die 'Kernel function select() undefined.'
        }

        # Else, report such status. Technically, zselect() reports 0 if *ANY*
        # passed file descriptor is non-blockably readable and 1 otherwise.
        # Since this function tests only standard input, such status exactly
        # coincides with what the caller expects. (Scoooooore!)
        return ${exit_status}
    }
}

# ....................{ MAIN                               }....................
# Load module "zselect", providing builtin zselect() required by standard
# input-specific setters above (e.g., :set_string_to_stdin_help()).
zmodload zsh/zselect

# --------------------( WASTELANDS                         )--------------------
    # if { zselect -t 0 -a zselect_status -r 0 } {
    #     exit_status="${status}"
    # }
