#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under @{help} in the main codebase.

# ....................{ SETTERS                            }....................
#FIXME: Document me.
# :void :int.set(*:int int_name, :int number)
function :int.set() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one integer name and one integer value.'
    local int_name__siti="${1}" int__siti="${2}"
    :var.die_unless_type_int "${int_name__siti}"

    #FIXME: Define such handler. (Ugh.)
    :die_unless_int "${int__siti}"

    # Set such integer via assignment indirection.
    : "${(P)int_name__siti::=${int__siti}}"
}

# :void :list.set_to_string(
#     *:list list_name,
#     :string text1, ...)
function :list.set_to_string() {
    # Validate sanity.
    (( # >= 2 )) || :die 'Expected one list name and one or more strings.'
    local list_name__slts="${1}"
    :var.die_unless_type_list "${list_name__slts}"

    # Set such list to such strings.
    set -A "${list_name__slts}" "${@[2,-1]}"
}

# :void :string.set(
#     *:string string_name,
#     :string text1, ...)
function :string.set() {
    # Validate sanity.
    (( # >= 2 )) || :die 'Expected one string name and one or more strings.'
    local string_name__ssts="${1}"
    :var.die_unless_type_string "${string_name__ssts}"

    # If only one such string was passed, no concatenation is required. In such
    # case, set such variable via assignment indirection.
    if (( # == 2 )) {
        : "${(P)string_name__ssts::=${2}}"
    # Else, two or more such strings were passed, in which case concatenation
    # is required. Set such variable to the undelimited concatenation of all
    # such strings.
    } else {
        # Locally clear canonical string global ${IFS} (i.e., the internal
        # field separator). Since zsh implicitly delimits strings concatenated
        # with "*" by such global's value, clearing such global guarantees
        # undelimited concatenation. This incantation was surprisingly arduous
        # to unearth. In particular, note that if "*" is *NOT* double-quoted,
        # zsh ignores the value of ${IFS} during concatenation and hence
        # delimits such strings by single spaces. (Ugh.)
        local IFS=

        # Set such string with undelimited concatenation.
        : "${(P)string_name__ssts::=${*[2,-1]}}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Refactor to:
# :void :string.set(
#     *:string string_name,
#     :string text1, ...)
