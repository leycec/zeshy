#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under ={help} in the main codebase.

# ....................{ SETTERS ~ int                      }....................
#FIXME: Do we still require this as early-time functionality? We reckon not.
#FIXME: Document me.

# :void :int.set(^:int int_name, :int number)
function :int.set() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one integer name and one integer value.'
    local int_name__siti="${1}" int__siti="${2}"
    :var.die_unless_type_int "${int_name__siti}"

    #FIXME: Define such handler. (Ugh.)
    :die_unless_int "${int__siti}"

    # Set such integer via assignment indirection.
    : "${(P)int_name__siti::=${int__siti}}"
}

# ....................{ SETTERS ~ list                     }....................
# :void :list.set_to_string(^:list list_name, :string text1, ...)
function :list.set_to_string() {
    # Validate sanity.
    (( # >= 2 )) || :die 'Expected one list name and one or more strings.'
    local list_name__slts="${1}"
    :var.die_unless_type_list "${list_name__slts}"

    # Set such list to such strings.
    set -A "${list_name__slts}" "${@[2,-1]}"
}

# ....................{ SETTERS ~ string                   }....................
# :void :string.set(^:string string_name, :string text1, ...)
function :string.set() {
    # Validate sanity.
    (( # >= 2 )) || :die 'Expected one string name and one or more strings.'
    local string_name__ssts="${1}"
    :var.die_unless_type_string "${string_name__ssts}"

    # If only one such string was passed, no concatenation is required. In such
    # case, set such variable via assignment indirection.
    if (( # == 2 )) {
        : "${(P)string_name__ssts::=${2}}"
    # Else, two or more such strings were passed, in which case concatenation
    # is required. Set such variable to the undelimited concatenation of all
    # such strings.
    } else {
        # Locally clear canonical string global ${IFS} (i.e., the internal
        # field separator). Since zsh implicitly delimits strings concatenated
        # with "*" by such global's value, clearing such global guarantees
        # undelimited concatenation. This incantation was surprisingly arduous
        # to unearth. In particular, note that if "*" is *NOT* double-quoted,
        # zsh ignores the value of ${IFS} during concatenation and hence
        # delimits such strings by single spaces. (Ugh.)
        local IFS=

        # Set such string with undelimited concatenation.
        : "${(P)string_name__ssts::=${*[2,-1]}}"
    }
}

#FIXME: Document me.
# [status = :bool] :string.set_to_stdin_if_found[
#     args = (^:string string_name),
#     stdin = (:string stdin)]
function :string.set_to_stdin_if_found() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'

    # If standard input is readable without blocking, set such string to all
    # such input. Ideally, this would be implementable as follows:
    #
    #    IFS= read -r -t 0 -d '' "${1}"
    #
    # Unfortunately, option "-d" requires a nonempty character, implying read()
    # to only read in an explicitly delimited manner. Hence, we defer to the
    # somewhat convolute logic of :is_stdin_readable_sans_blocking() instead.
    :is_stdin_readable_sans_blocking &&
        :string.set "${1}" "$(< /dev/stdin)"
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Refactor to:
# :void :string.set(
#     *:string string_name,
#     :string text1, ...)
