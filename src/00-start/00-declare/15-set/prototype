#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under @{help} in the main codebase.

# ....................{ SETTERS ~ help                     }....................
#FIXME: Document me.
# void :set_strings_to_help_prototype,asciidoc(
#     string prototype_string_name,
#     string asciidoc_string_name,
#     string documentation)
function :set_strings_to_help_prototype,asciidoc() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one prototype string, one AsciiDoc string name, and one help string.'
    local\
        string_name_prototype__ssthp="${1}"\
        string_name_asciidoc__ssthp="${2}"\
        help__ssthp="${3}"

    # If such documentation contains a blank line (i.e., "\n\n"), assume the
    # substring preceding such line to be the expected prototype. Else, throw
    # an exception.
    [[ "${help__ssthp}" == ${~ZESHY_HELP_GLOB} ]] || :die\
        'Documentation invalid (i.e., contains no blank line separating prototype from non-prototype sections):'$'\n\n'${help__ssthp}

    # Set such strings.
    :set_string_to_string "${string_name_prototype__ssthp}" "${match[1]}"
    :set_string_to_string "${string_name_asciidoc__ssthp}"  "${match[2]}"
}

# ....................{ SETTERS ~ alias                    }....................
#FIXME: Document me.
# void :set_string_to_alias_prototype_name(
#     string string_name, string alias_prototype)
function :set_string_to_alias_prototype_name() {
    (( # == 2 )) || :die 'Expected one string name and one alias prototype.'
    ::set_string_to_runnable_prototype_name_with_label "${@}" 'Alias'
}

#FIXME: Document me. 
# :void :set_map,list,string_to_alias_prototype_attrs,names,args(
#     :string:map    alias_attrs_map_name,
#     :string:list   alias_names_list_name,
#     :string:string alias_args_string_name,
#     :string alias_prototype)
function :set_map,list,string_to_alias_prototype_attrs,names,args() {
    (( # == 4 )) || :die\
        'Expected one map name, one list name, one string name, and one alias prototype.'
    ::set_map,list,string_to_runnable_prototype_attrs,names,args_with_label "${@}" 'Alias'
}

# ....................{ SETTERS ~ func                     }....................
#FIXME: Document me.
# :void :set_string_to_func_prototype(
#     :string:string string_name, :string:func func_name)
function :set_string_to_func_prototype() {
    (( # == 2 )) || :die 'Expected one string name and one function name.'
    ::set_string_to_operable_type_prototype "${@}" 'func'
}

#FIXME: Document me.
# :void :set_string_to_func_prototype_name(
#     :string:string string_name, :string func_prototype)
function :set_string_to_func_prototype_name() {
    (( # == 2 )) || :die 'Expected one string name and one function prototype.'
    ::set_string_to_runnable_prototype_name_with_label "${@}" 'Function'
}

#FIXME: Document me.
# :void :set_map,list,string_to_func_prototype_attrs,names,args(
#     :string:map    func_attrs_map_name,
#     :string:list   func_names_list_name,
#     :string:string func_args_string_name,
#     :string func_prototype)
function :set_map,list,string_to_func_prototype_attrs,names,args() {
    (( # == 4 )) || :die\
        'Expected one map name, one list name, one string name, and one function prototype.'
    ::set_map,list,string_to_runnable_prototype_attrs,names,args_with_label "${@}" 'Function'
}

# ....................{ SETTERS ~ global                   }....................
#FIXME: Document me.
# void :set_list_to_global_prototype_names(
#     string list_name, string global_prototype)
function :set_list_to_global_prototype_names() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one list name and one global prototype.'
    local\
        global_names_list_name__sltgpn="${1}"\
        global_prototype__sltgpn="${2}"\
        global_names_and_optional_value__sltgpn\
        placeholder__sltgpn

    # Strip the prefixing type (prefixed by optional whitespace and suffixed by
    # mandatory spaces) from such prototype, thus leaving only the "="-
    # delimited string of one or more global names and optional value required
    # by the call below. Dismantled, this is:
    #
    # * "[[:space:]]#", matching optional prefixing whitespace.
    # * "[^ ]##", matching such type.
    # * " ##", matching one or more mandatory suffixing spaces.
    global_names_and_optional_value__sltgpn="${global_prototype__sltgpn#[[:space:]]#[^ ]## ##}"

    # Parse such global names from such prototype. To centralize logic, also
    # parse such global value despite the caller not requesting such value --
    # which we then promptly discard.
    :set_list,string,bool_to_global_names,value,is_value\
        "${global_names_list_name__sltgpn}"\
        placeholder__sltgpn\
        placeholder__sltgpn\
        "${global_names_and_optional_value__sltgpn}"
}

#FIXME: Document me.
#void :set_list,string,bool_to_global_names,value,is_value(
#    string global_names_list_name,
#    string global_value_string_name,
#    string global_is_value_bool_name,
#    string global_names_and_optional_value)
function :set_list,string,bool_to_global_names,value,is_value() {
    # Validate sanity.
    (( # == 4 )) || :die\
        'Expected one list name, one string name, one boolean name, and one "="-delimited string of one or more global names and optional value.'
    local\
        global_names_list_name__slsbtgnviv="${1}"\
        global_value_string_name__slsbtgnviv="${2}"\
        global_is_value_bool_name__slsbtgnviv="${3}"\
        global_names_and_value__slsbtgnviv="${4}"
    [[ -n "${global_names_and_value__slsbtgnviv}" ]] || :die\
        'Global names and optional value empty.'

    #FIXME: This PCRE isn't *QUITE* as flexible as it should be. Ideally, such
    #PCRE should accept *ANY* unquoted value not containing whitespace. (Why?
    #Because zsh assignments accept exactly that.) At the moment, it only
    #accepts integer unquoted values.

    # If such prototype is syntactically invalid, throw an exception.
    [[ "${global_names_and_value__slsbtgnviv}" =~\
        "${ZESHY_PROTOTYPE_GLOBAL_NAMES_VALUE_PCRE}" ]] || :die\
        'Global declaration'$(::get_parcel_preposition)' invalid:'$'\n'${global_names_and_value__slsbtgnviv}

    # If such match failed to capture such global's names, throw an exception.
    (( ${#match} )) || :die\
        'Global names unparsable from prototype:'$'\n'${global_names_and_value__slsbtgnviv}

    # If such prototype only declares one name, set such list to such name.
    if [[ -n "${match[1]}" ]] {
        :set_list_to_string\
            "${global_names_list_name__slsbtgnviv}" "${match[1]}"
    # Else, such prototype declares multiple equal signs-delimited names.
    # Unlike runnable prototype names, such names are prohibited from
    # containing equals signs and hence may be efficiently split on such.
    } else {
        # If such match failed to capture such names, throw an exception.
        (( ${#match} >= 2 )) || :die\
            'Global names unparsable from prototype:'$'\n'${global_names_and_value__slsbtgnviv}

        # Set such list to such names by splitting on equals signs.
        :set_list_to_string\
            "${global_names_list_name__slsbtgnviv}" "${(s:=:)match[2]}"
    }

    # If such value is defined, set such value and set such boolean to true.
    if (( ${#match} == 3 )) {
        :set_string_to_string\
            "${global_type_string_name__slsbtgnviv}" "${match[3]}"
        :set_int_to_int\
            "${global_is_value_bool_name__slsbtgnviv}" 1
    # Else, set such boolean to false.
    } else {
        :set_int_to_int\
            "${global_is_value_bool_name__slsbtgnviv}" 0
    }
}


# ....................{ SETTERS ~ operable                 }....................
#FIXME: Implement ::set_string_to_operable_type_asciidoc() along similar lines.
#FIXME: Document me.

# :void ::set_string_to_operable_type_prototype(
#     :string:string string_name,
#     :string      operable_type,
#     :string:func operable_name)
function ::set_string_to_operable_type_prototype() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one string name, one operable type, and one operable name.'
    local\
        string_name__sstrtp="${1}"\
        operable_type__sstrtp="${2}"\
        operable_name__sstrtp="${3}"\
        prototype_setter_name__sstrtp

    # Name of the function setting such string to such operable's prototype.
    # See ::document_operable_with_type,prototype,asciidoc() for such
    # function's definition.
    prototype_setter_name__sstrtp="::set_string_to_${operable_type__sstrtp}_prototype:${operable_name__sstrtp}"
    :die_unless_func "${prototype_setter_name__sstrtp}"
    "${prototype_setter_name__sstrtp}" "${string_name__sstrtp}"
}

# ....................{ SETTERS ~ runnable                 }....................
# void ::set_string_to_runnable_prototype_name_with_label(
#     string string_name,
#     string runnable_prototype,
#     string runnable_label)
function ::set_string_to_runnable_prototype_name_with_label() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one string name, one runnable prototype, and one runnable label.'
    local\
        string_name__sstrpn="${1}"\
        prototype__sstrpn="${2}"\
        runnable_label__sstrpn="${3}"
    [[ -n "${prototype__sstrpn}" ]] || :die\
        ${runnable_label__sstrpn}' prototype empty.'

    # If such prototype is syntactically invalid, throw an exception.
    [[ "${prototype__sstrpn}" =~\
        "${ZESHY_PROTOTYPE_RUNNABLE_NAME_PCRE}" ]] || :die\
        ${runnable_label__sstrpn}' prototype'$(::get_parcel_preposition)' invalid or declares two or more '${(L)runnable_label__sstrpn}' names:'${prototype__sstrpn}

    # If such name was *NOT* captured into ${match[1]}, throw an exception.
    (( ${#match} )) || :die\
        ${runnable_label__sstrpn}' name unparsable from prototype:'${prototype__sstrpn}

    # If such name was captured but is empty, throw an exception. (While this
    # *SHOULD* be the case, guaranteeing this guards against regressions.)
    [[ -n "${match[1]}" ]] || :die\
        ${runnable_label__sstrpn}' name empty in prototype:'${prototype__sstrpn}

    # Set such string to such name.
    :set_string_to_string "${string_name__sstrpn}" "${match[1]}"
}

#FIXME: Document me.
# :void ::set_list_to_runnable_prototype_names_with_label(
#     :string:list list_name,
#     :string runnable_prototype,
#     :string runnable_label)
function ::set_list_to_runnable_prototype_names_with_label() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one list name, one runnable prototype, and one runnable label.'
    local placeholder_args__sltrpn
    local -A placeholder_attrs__sltrpn

    # Parse such runnable names from such prototype. To centralize logic, also
    # parse such runnable attributes despite the caller not requesting such
    # attributes -- which we then promptly discard.
    ::set_map,list,string_to_runnable_prototype_attrs,names,args_with_label\
        placeholder_attrs__sltrpn\
        "${1}"\
        placeholder_args__sltrpn\
        "${2}"\
        "${3}"
}

#FIXME: Document me. In particular, note why this function parses such
#arguments into a string variable rather than a nonscalar variable (namely,
#because arguments are considerably more complex than either attributes or
#names and hence could only be sufficiently described by a complex object type,
#which zsh fails to support). Hence, the caller is responsible for parsing such
#arguments but *NOT* attributes or names.

# :void ::set_map,list,string_to_runnable_prototype_attrs,names,args_with_label(
#     :string:map    runnable_attrs_map_name,
#     :string:list   runnable_names_list_name,
#     :string:string runnable_args_string_name,
#     :string runnable_prototype,
#     :string runnable_label)
function ::set_map,list,string_to_runnable_prototype_attrs,names,args_with_label() {
    # Validate sanity.
    (( # == 5 )) || :die\
        'Expected one map name, one list name, one string name, one runnable prototype, and one runnable label.'
    local\
        runnable_attrs_map_name__smltrpan="${1}"\
        runnable_names_list_name___smltrpan="${2}"\
        runnable_args_string_name___smltrpan="${3}"\
        prototype__smltrpan="${4}"\
        runnable_label__smltrpan="${5}"
    local -a prototype_matches__smltrpan
    [[ -n "${prototype__smltrpan}" ]] || :die\
        ${runnable_label__smltrpan}' prototype empty.'

    # If such prototype is syntactically invalid, throw an exception.
    [[ "${prototype__smltrpan}" =~\
        "${ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NAMES_ARGS_PCRE}" ]] || :die\
        ${runnable_label__smltrpan}' prototype'$(::get_parcel_preposition)' invalid:'$'\n\n'${prototype__smltrpan}

    # If such match failed to capture either such runnable's attributes or
    # names, throw an exception.
    # print -r -- "matches: ${match[*]} (${#match})"
    (( ${#match} >= 2 )) || :die\
        ${runnable_label__smltrpan}' attributes, names, and/or arguments unparsable from prototype:'$'\n\n'${prototype__smltrpan}

    # Preserve such matches *BEFORE* attempting attribute matching, which
    # unavoidably overwrites list global ${match}.
    prototype_matches__smltrpan=( "${match[@]}" )
    # integer i__smltrpan; print -r "match prototype: ${prototype__smltrpan}"; for i__smltrpan ({1..${#match}}) { print -r "match ${i__smltrpan}: ${match[${i__smltrpan}]}" }

    # If such prototype declares at least one attribute, parse such attributes
    # and optional suffixing values into such map. Since single- and
    # double-quoted values may contain commas, such attributes must be
    # iteratively matched with a PCRE rather than split on commas.
    if [[ -n "${prototype_matches__smltrpan[1]}" ]] {
        #FIXME: Arguably, we should just define :clear_map() here.
        # Validate sanity.
        local runnable_attrs_map_key__smltrpan
        :die_unless_var_map "${runnable_attrs_map_name__smltrpan}"

        # Clear such map. See :clear_map() for further details.
        set -A "${runnable_attrs_map_name__smltrpan}"

        # Compile such PCRE. For efficiency, avoid optionally optimizing such
        # PCRE by calling pcre_study(). (Ad-hoc profiling suggests such
        # optimization to consume more time than it saves.) See
        # for_string_text_matching_pcre:() for further details.
        pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_ATTRS_NEXT_PCRE}"

        # Match and add each such attribute to such map.
        local ZPCRE_OP='0 0'
        while {
            pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
                "${prototype_matches__smltrpan[1]}"
        } {
            # Map the current attribute to the colon-prefixed value suffixing
            # such attribute if such attribute is suffixed by such a value or
            # to the empty string otherwise. Such indirection is required by
            # zsh setting arbitrary map keys outside of eval() statements. (An
            # eval() statement would also suffice here, if less efficiently.)
            # See :set_map_key_to_string() for further details.
            runnable_attrs_map_key__smltrpan="${runnable_attrs_map_name__smltrpan}[${match[1]}]"
            : "${(P)runnable_attrs_map_key__smltrpan::=${match[2]-}}"
        }
    }

    # If such prototype only declares one name, set such list to such name.
    if [[ -n "${prototype_matches__smltrpan[2]}" ]] {
        :set_list_to_string\
            "${runnable_names_list_name___smltrpan}"\
            "${prototype_matches__smltrpan[2]}"
    # Else, such prototype declares multiple comma-delimited names. Since
    # single- and double-quoted runnable names may contain commas, such names
    # must be iteratively matched with a PCRE rather than split on commas.
    } else {
        #FIXME: Arguably, we should just define :clear_list() here.
        # Validate sanity.
        local runnable_names_list_item__smltrpan
        integer runnable_names_list_index__smltrpan=0
        :die_unless_var_list "${runnable_names_list_name___smltrpan}"

        # If such match failed to capture such names, throw an exception.
        (( ${#prototype_matches__smltrpan} >= 3 )) || :die\
            ${runnable_label__smltrpan}' names unparsable from prototype:'$'\n\n'${prototype__smltrpan}

        # Clear such list. See clear_list() for further details.
        set -A "${runnable_names_list_name___smltrpan}"

        # Compile such PCRE. See above for further details.
        pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_NAMES_NEXT_PCRE}"

        # Match and append each such name to such list.
        local ZPCRE_OP='0 0'
        while {
            pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
                "${prototype_matches__smltrpan[3]}"
        } {
            # Index of the current non-existent list item to be appended.
            runnable_names_list_index__smltrpan+=1

            # Append such name to such list with indirection similar to that
            # performed above. (An eval() statement would also suffice here, if
            # less efficiently.)
            runnable_names_list_item__smltrpan="${runnable_names_list_name___smltrpan}[${runnable_names_list_index__smltrpan}]"
            : "${(P)runnable_names_list_item__smltrpan::=${match[1]}}"
        }
    }

    # Set such string to such arguments, defaulting to the empty string if
    # such runnable accepts no arguments (e.g., "()").
    :set_string_to_string\
        "${runnable_args_string_name___smltrpan}"\
        "${prototype_matches__smltrpan[4]-}"
}

# ....................{ OBSOLETE                           }....................
#FIXME: Everything below should be excised after completing all refactorings in
#this parent parcel.

function run_runnable_with_stdin() {
    # Validate sanity.
    (( # )) || :die 'Expected one runnable name and optional arguments.'
    local runnable_name__rrws="${1}"
    shift

    #FIXME: Improper test, since such test fails when passed the empty string
    #in a valid here-document string, which should (for convenience) succeed.
    #FIXME: Interesting. Under at least Linux, this is testable by noting that
    #"readlink -f /dev/stdin" succeeds and outputs a string resembling
    #"/tmp/zshFtb89B (deleted)". While we *COULD* capture such output and glob
    #for '/tmp/zsh'?*' (deleted)', such approach is both inefficient and overly
    #Linux-specific for such an early-time operation as this. A possibly
    #simpler test is as follows:
    #
    #* If :set_string_to_zsh_temp_prefix() prefixes the output of
    #  "command readlink -f /dev/stdin", standard input is... wait. We wanted
    #  *SIMPLER*. O.K., O.K.; how about just:
    #   * If "/dev/stdin" is a broken symbolic link, assume such link to have
    #     been the product of a here-document or -string, as expected.
    #   * Else implement the contents of :is_stdin_file_simple(), yes?
    #FIXME: No, no, no. *THINK*. What are we trying to accomplish here? This:
    #
    #* If the current process is *NOT* running headless *AND* standard input is
    #  *NOT* attached to a terminal, throw an exception. (Since, in such case,
    #  attempting to read from standard input is guaranteed to be terrible.)
    #
    #Happily, such test is both efficient and simple:
    #
    #{ (( ${+TERM} )) && ! [[ -t 0 ]] } || die 'Standard input empty.'
    #
    #Wait. Obviously, this reduces to the even simpler test:
    #
    #if [[ -t 0 ]] {
    #    die 'Documented not passed on standard input.'
    #}
    #
    #Wait. Insufficient. This suffices if the current process is *NOT*
    #headless. But what if it is? Then we just need to test whether standard
    #input is open or not. This is readily cross-platform-portable, as currently
    #implemented by get_file_descriptor_file_device().
    #FIXME: Hm; wait. Testing whether standard input is open or not is actually
    #non-trivial, as such function attests. The simplest solution then will be
    #to test whether standard input is a here-document or -string. This is
    #somewhat more confined than we would like, but... well, there's really no
    #sane alternative. That said, even testing this is non-trivial, as it
    #requires obtaining the transitive target of such file descriptor.
    #FIXME: Oh, *SCREW IT.* The current implementation is basically the only
    #sane implementation. We'll need to document why, of course. See above!
    #FIXME: This is *HORRIBLY* broken. This so-called "test" is fundamentally
    #broken. Ugh!

    # If standard input is empty, throw an exception. See
    # :is_stdin_readable_sans_blocking() for further details.
    read -t 0 || die 'Standard input empty.'

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${runnable_name__rrws}" &>/dev/null ||
        die "runnable \"${runnable_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${runnable_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: To avoid redefining such logic thrice more (e.g., for the htree alias
#subtypes), generalize such logic into a new low-level private utility function
#::set_string_to_operable_prototype(), naturally called here.

# in parcel @{'${ZESHY_PARCEL_NAME-N/A}'}

#FUXME: Since we really don't care terribly much about function and alias
#synonyms, it's likely that we'll no longer require the passed map argument
#*AFTER* implementing the refactorings in @{*-func}. Cut such argument and
#rename to :set_list_to_runnable_prototype_name_or_names().

# # void set_list_and_map_to_runnable_prototype_name_or_names:(
# #     string list_name,
# #     string map_name,
# #     string matched_runnable_name,
# #     string matched_runnable_names)
# function set_list_and_map_to_runnable_prototype_name_or_names: {
#     # Validate sanity.
#     (( # == 4 )) || :die\
#         'Expected one list name, one map name, one matched singular string, and one matched plural string.'
#     local\
#         list_name__sltrpn="${1}"\
#         map_name__sltrpn="${2}"\
#         runnable_name__sltrpn="${3}"\
#         runnable_names__sltrpn="${4}"
# 
#     # If any such variable is undefined or not of the expected type, throw an
#     # exception. See :die_unless_var_list() for further details.
#     [[ "${(tP)list_name__sltrpn-}" == 'array'* ]] || :die\
#         '${'${list_name__sltrpn}'} undefined or not a list.'
#     [[ "${(tP)map_name__sltrpn-}" == 'association'* ]] || :die\
#         '${'${map_name__sltrpn}'} undefined or not a map.'
# 
#     # If such runnable only has one name...
#     if [[ -n "${runnable_name__sltrpn}" ]] {
#         eval '
#         # If such runnable is already declared, print a warning. See
#         # is_map_key() for further details.
#         if (( ${+'${map_name__sltrpn}'[${runnable_name__sltrpn}]} )) {
#             :output_warning "${runnable_name__sltrpn}() in @{${ZESHY_PARCEL_NAME}} already declared."
#         }
# 
#         # Set such list to such name.
#         '${list_name__sltrpn}'=( "${runnable_name__sltrpn}" )
# 
#         # Add the identity mapping to such map.
#         '${map_name__sltrpn}'[${runnable_name__sltrpn}]="${runnable_name__sltrpn}"'
#     # Else, such runnable has multiple names. Since single- and double-quoted
#     # runnable names may contain commas, such names cannot be split on commas as
#     # with runnable attributes elsewhere. Rather, iteratively match such names
#     # with a PCRE.
#     } else {
#         [[ -n "${runnable_names__sltrpn}" ]] || :die\
#             'Both singular and plural function names empty.'
# 
#         # Prepare to match such names. See for_string_text_matching_pcre:() for further
#         # details.
#         pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_NAMES_NEXT_PCRE}"
#         # pcre_study
# 
#         # Match such names.
#         local ZPCRE_OP='0 0'
#         eval 'while {
#             pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${runnable_names__sltrpn}"
#         } {
#             # For convenience, store the currently matched name.
#             runnable_name__sltrpn="${match[1]}"
# 
#             # If such runnable is already declared, print a warning as above.
#             if (( ${+'${map_name__sltrpn}'[${runnable_name__sltrpn}]} )) {
#                 :output_warning "${runnable_name__sltrpn}() in @{${ZESHY_PARCEL_NAME}} already declared."
#             }
# 
#             # Append such name to such list.
#             '${list_name__sltrpn}'+="${runnable_name__sltrpn}"
# 
#             # Map such name to the first such name for such runnable.
#             '${map_name__sltrpn}'[${runnable_name__sltrpn}]="${'${list_name__sltrpn}'[1]}"
#         }
#         
#         # If such list remains empty, throw an exception.
#         (( ${#'${list_name__sltrpn}'} )) || :die\
#             ''Runnable names unparsable (despite multiple names detected) from prototype:''$''\n''${runnable_names__sltrpn}
#         '
#     }
# }

    # :string matched; for matched ("${match[@]}") { matched }
        #FUXME: Overly redundant. We probably want a new private getter (for
        #simplicity, since efficiency doesn't matter here), resembling:
        #function ::get_parcel_if_found_or_noop() {
        #    (( # == 0 )) || :die 'Expected no arguments.'
        #    if [[ -n "${ZESHY_PARCEL_NAME-}" ]] {
        #        print -r 'in parcel @{'${ZESHY_PARCEL_NAME}'}'
        #    }
        #}

        # If such global resides in a parcel, state such parcel in the
        # exception thrown below.
        # local in_parcel__slsbtgnviv
        # if [[ -n "${ZESHY_PARCEL_NAME-}" ]] {
        #     in_parcel__slsbtgnviv='in parcel @{'${ZESHY_PARCEL_NAME}'}'
        # }

        # Throw such exception.

    # # If any such variable is undefined or not of the expected type, throw an
    # # exception. See :die_unless_var_map() and :die_unless_var_list() for further details.
    # [[ "${(tP)runnable_attrs_map_name__smltrpan-}" == 'association'* ]] || :die\
    #     'Map ${'${runnable_attrs_map_name__smltrpan}'} undefined or not a map.'
    # [[ "${(tP)runnable_names_list_name___smltrpan-}" == 'array'* ]] || :die\
    #     'List ${'${runnable_names_list_name___smltrpan}'} undefined or not a list.'

        #FUXME: Such call *WILL* fail both here and below, as such variable is
        #an integer rather than a string. We'll need to define a new
        #:set_int_to_int() function -- which, happily, is quite a bit simpler
        #than :set_string_to_string(), due to the former *NOT* supporting
        #concatenation of multiple passed integers.

#FUXME: Replace all calls to :set_list_to_string() with calls to this.

    # If any such variable is undefined or not of the expected type, throw an
    # exception. Since we call :set_string_to_string() below to set string
    # variables, avoid validating such variables here. See :die_unless_var_list()
    # for further details.
    # [[ "${(tP)global_names_list_name__slsbtgnviv-}" == 'array'* ]] || :die\
    #     'List ${'${global_names_list_name__slsbtgnviv}'} undefined or not a list.'

# Avoid defining comparable setters for non-scalar types (e.g., lists, maps)
# here; such setters depend on considerably more functionality than we would be
# willing to migrate here.

#FUXME: Enormous woops. "read -t 0" is destructive and terrible. To genuinely
#test this, we'll need to both inline *AND* call
#:is_stdin_readable_sans_blocking() here. While absurdly annoying, this is
#certainly feasible.
#FUXME: Ugh. We'll need to load the module defining zselect(), then. And, of
#course, this implies zeshy to then be limited to only OSes defining select().
#Isn't that most of them, however?
#FUXME: O.K.; this works. We'll need to define a new parcel @{10-test} and
#rename this parcel to @{15-set}. Shift :is_stdin_readable_sans_blocking() to
#@{10-test}; then, refactor the setters below to call such function. We know;
#this is terrible. But there you are!
#FUXME: Don't forget to shift the zmodload() call below to @{10-test} too!

    # # If such variable is not a string, throw an exception. See
    # # :die_unless_var_string() for further details.
    # [[ "${(tP)string_name__ssts-}" == 'scalar'* ]] || :die\
    #     'Variable ${'${string_name__ssts}'} undefined or not a string.'

#FUXME: Document me.
#FUXME: Actually, this function will probably be going away. Don't bother
#documenting, for now.

# # void :set_list_to_alias_prototype_names(
# #     string list_name, string alias_prototype)
# function :set_list_to_alias_prototype_names() {
#     (( # == 2 )) || :die 'Expected one list name and one alias prototype.'
#     ::set_list_to_runnable_prototype_names_with_label "${@}" 'Alias'
# }

        #FUXME: *WOO*! We may have uncovered an even more efficient means of
        #implementing this, requiring no such temporary copy: just duplicate
        #the above technique for dynamically setting map key-value pairs here,
        #where the "key" to be set is one past the current last list item. Ya!

        # Temporary list iteritavely appended to below. While such iteration
        # could append directly to the passed list, doing so would require an
        # inefficient eval() statement.
        # local -a runnable_names__smltrpan

        # local runnable_names_list_item__smltrpan
        # integer runnable_names_list_index__smltrpan=0

        # # Clear such list. See clear_list() for further details.
        # set -A "${runnable_names_list_name___smltrpan}"

        # # If such match failed to capture such names, throw an exception.
        # (( ${#prototype_matches__smltrpan} >= 3 )) || :die\
        #     ${runnable_label__smltrpan}' names unparsable from prototype:'$'\n'${prototype__smltrpan}

        # # Compile such PCRE. See for_string_text_matching_pcre:() for further
        # # details.
        # pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_NAMES_NEXT_PCRE}"
        # pcre_study

        # # Match and append each such name to such list.
        # local ZPCRE_OP='0 0'
        # while {
        #     pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
        #         "${prototype_matches__smltrpan[3]}"
        # } {
        #     # Index of the current non-existent list item to be appended.
        #     runnable_names_list_index__smltrpan+=1

        #     # Append such name to such list with indirection similar to that
        #     # performed above. (An eval() statement would also suffice here, if
        #     # less efficiently.)
        #     runnable_names_list_item__smltrpan="${runnable_names_list_name___smltrpan}[${runnable_names_list_index__smltrpan}]"
        #     : "${(P)runnable_names_list_item__smltrpan::=${match[1]}}"
        #     # runnable_names__smltrpan+="${match[1]}"
        # }

        # # If such list remains empty, throw an exception.
        # (( ${#runnable_names__smltrpan} )) || :die\
        #     ${runnable_label__smltrpan}' names unsplittable from prototype:'$'\n'${prototype__smltrpan}

        # # Copy such temporary list to the passed list.
        # set -A\
        #     "${runnable_names_list_name___smltrpan}"\
        #     "${runnable_names__smltrpan[@]}"

#FUXME: Most (if not all) inefficient calls to builtin eval() below can be
#replaced by efficient calls to builtin set(): e.g.,
#
#    set -a "${list_name__sltl}" "${@}"

        # eval ${runnable_names_list_name___smltrpan}'=( "${prototype_matches__smltrpan[2]}" )'

        # eval ${global_names_list_name__slsbtgnviv}'=( "${match[1]}" )'
        # eval ${global_names_list_name__slsbtgnviv}'=( ${(s:=:)match[2]} )'

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception. See :is_stdin_readable_sans_blocking() for
    # further details.
    #
    # Since there exists no demonstrable reason to prohibit empty
    # documentation, such exception should ideally only be thrown in the latter
    # case. Unfortunately, differentiating between the two cases is
    # sufficiently non-trivial as to be effectively infeasible this early in
    # digest compilation.
    #
    # Ideally, such cases could be differentiated by either:
    #
    # * Inlining the implementation of :is_stdin_readable_noninteractive()
    #   here (e.g., "not :is_stdin_terminal and :is_stdin_open"). While
    #   inlining the former condition :is_stdin_terminal() would be trivial,
    #   inlining the latter condition :is_stdin_open() would require also
    #   inlining :set_string_to_symlink_target_last() (and all functions such
    #   function transitively calls) and hence be non-trivial.
    # * Inlining the implementation of :is_stdin_here_doc_or_string() here.
    #   Since this would require again inlining
    #   :set_string_to_symlink_target_last() as above, such approach is equally
    #   non-trivial.
    #
    # Given the earliness of this function, we adopt a single-line solution --
    # which, as an unfortunate by-product, prohibits empty documentation.
    # zselect -t 0 -a zselect_status -r 0 || :die\
    #     'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'

    # # Set such string to standard input. See get_stdin() for further details.
    # :set_string_to_string "${1}" "$(< /dev/stdin)"

    #FUXME: Excise.
    # Unfortunately, running "read -t 0" more than once on the same standard
    # input stream appears to non-idempotently modify such stream in an
    # unreliable manner (e.g., by erasing such stream). Since this is
    # understandably horrible, avoid such bugs by inlining the implementation
    # of :set_string_to_stdin_help() (rather than calling such function).
    #
    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, report failure.
    # See :set_string_to_stdin_help() for further details.
    # zselect -t 0 -a zselect_status -r 0 || return 1
    # read -t 0 || return 1

    # Set such string to standard input. See get_stdin() for further details.
    # :set_string_to_string "${1}" "$(< /dev/stdin)"

    # Set such string to all standard input. Disamntled, this is:
    #
    # * "IFS=", instructing read() to copy all standard input to the first
    #   passed variable rather than splitting such input on the current
    #   internal field separator into all passed variables.
    # * "-r", enabling raw reading (i.e., disabling reading of backslashes as
    #   zsh-specific line continuation and escape characters).
    # * "-t 0", reporting failure without reading if standard input is either
    #   the empty string or unreadable without blocking.
    # * "-d ''", preventing
    # IFS= read -r -t 0 -d '' "${1}"

    # Unfortunately, running "read -t 0" more than once on the same standard
    # input stream appears to non-idempotently modify such stream in an
    # unreliable manner (e.g., by erasing such stream). Since this is
    # understandably horrible, avoid such bugs by inlining the implementation
    # of :set_string_to_stdin_help() (rather than calling such function).
    #
    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, report failure.
    # See :set_string_to_stdin_help() for further details.

# Note that if such prototype defines no optional value,
#such function reports failure whill still setting the first two passed
#variables.
#, along with the related exit status.
#FUXME: Document me.
#[status: bool]
#    :set_string,list,string_to_global_prototype_type,names,value_if_value(
#        string global_type_string_name,
#        string global_names_list_name,
#        string global_value_string_name,
#        string global_prototype)
# function :set_string,list,string_to_global_prototype_type,names,value_if_value() {
#     # Validate sanity.
#     (( # == 4 )) || :die\
#         'Expected one string name, one list name, one string name, and one global prototype.'
#     local\
#         global_type_string_name___sltgpn="${1}"\
#         global_names_list_name___sltgpn="${2}"\
#         global_value_string_name___sltgpn="${3}"\
#         global_prototype__sltgpn="${4}"
#     [[ -n "${global_prototype__sltgpn}" ]] || :die 'Global prototype empty.'
# 
#     # If any such variable is undefined or not of the expected type, throw an
#     # exception. Since we call :set_string_to_string() below to set string
#     # variables, avoid validating such variables here. See :die_unless_var_list()
#     # for further details.
#     [[ "${(tP)global_names_list_name___sltgpn-}" == 'array'* ]] || :die\
#         'List ${'${global_names_list_name___sltgpn}'} undefined or not a list.'
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     [[ "${global_prototype__sltgpn}" =~\
#         "${ZESHY_PROTOTYPE_GLOBAL_TYPE_NAMES_VALUE_PCRE}" ]] || :die\
#         'Global prototype invalid:'$'\n'${global_prototype__sltgpn}
# 
#     # If such match failed to capture such global's names, throw an exception.
#     (( ${#match} >= 2 )) || :die\
#         'Global names unparsable from prototype:'$'\n'${global_prototype__sltgpn}
# 
#     # Set such type.
#     :set_string_to_string "${global_type_string_name___sltgpn}" "${match[2]}"
# 
#     # If such prototype only declares one name, set such list to such name.
#     if [[ -n "${match[2]}" ]] {
#         eval ${global_names_list_name___sltgpn}'=( "${match[2]}" )'
#     # Else, such prototype declares multiple equal signs-delimited names.
#     # Unlike runnable prototype names, such names are prohibited from
#     # containing equals signs and hence may be efficiently split on such.
#     } else {
#         # If such match failed to capture such names, throw an exception.
#         (( ${#match} >= 3 )) || :die\
#             'Global names unparsable from prototype:'$'\n'${global_prototype__sltgpn}
# 
#         # Set such list to such names by splitting on equals signs.
#         eval ${global_names_list_name___sltgpn}'=( ${(s:=:)match[3]} )'
#     }
# 
#     # Set such value if defined or report failure.
#     if (( ${#match} == 4 )) {
#         :set_string_to_string\
#             "${global_type_string_name___sltgpn}" "${match[4]}"
#     } else {
#         return 1
#     }
# }

#FUXME: Document me. Note that if such prototype declares no optional value,
#such value will be set to the empty string if such type... No, wait; that
#doesn't really work. Hmm. How can a nonextant value be reliably signified? A
#number of possible ways:
#
#1. Such function preserves the current value of variable
#   ${global_value_string_name}. Assuming the caller initializes such variable
#   to an exceptionally unlikely value (e.g., $'\n\t\b\0'), the caller can then
#   test whether such variable retains the same value to determine whether such
#   global had a value passed. The downside, of course, is the inherent
#   unreliability of such an approach.
#2. Such function reports failure if no such value was provided.
#
#Honestly, the latter is the obvious route forward. What sort of nomenclature
#should we concoct, however? Consider:
#
#* :set_string,list,string_to_global_prototype_type,names,value_if_value_or_type,names().
#
#We know; that's a *CRAZY* long nomenclature, but... *shrug*.
#
#Wait; why *CAN'T* we just set such value to the empty string? We mean, really;
#is there any difference in the end at all? Hmm; yes, actually, there is. Go
#with the above, we should think.

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See :die_unless_var_string() and :die_unless_var_list() for further
    # details.
    # [[ "${(tP)global_type_string_name___sltgpn-}${(tP)global_value_string_name___sltgpn-}" ==\
    #     'scalar'*'scalar'* ]] || :die\
    #     'Strings ${'${global_type_string_name___sltgpn}'} and/or ${'${global_value_string_name___sltgpn}'} undefined or not strings.'

#FUXME: If we're going to go this far (and we certainly are), we'd might as
#well also define setters for lists and maps, which we should then leverage
#below inplace of inlined eval() statements.

#FUXME: Call such function elsewhere rather than manually inlining such logic
#everywhere. We should have probably done this *MUCH* sooner.

        # 'Documentation "'${help__ssthp%%$'\n'*}'..." invalid (i.e., contains no blank line separating prototype from non-prototype sections).'

    #FUXME: For efficiency, congeal *ALL* of the eval() statements below into a
    #single statement. Yes; muhaha!
    #FUXME: Hmm; nevermind. So be it, eval()!

        #FUXME: Bad! Split the attribute string apart into its constituent
        #components into such map. We'll need a PCRE-based loop, as below. Map:
        #
        #* Unvalued attributes (e.g., "<globbable>") to keys with empty values.
        #* Valued attributes (e.g., "<deprecated = '3.0'>") to keys with the
        #  corresponding values.

        # List of attributes split from such string. Split on commas
        # after truncating:
        #
        # * Optional whitespace surrounding commas (e.g., from " , " to ",").
        # * Optional trailing commas and/or whitespace.
        # eval ${runnable_attrs_map_name__smltrpan}'=(
        #     "${(s:,:)${match[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]#,#[[:space:]]#}" )'
#       for ((match_index=1; match_index <= ${#attrs}; ++match_index)) {
#           print "attr ${match_index}: ${attrs[${match_index}]}"
#       }

        # If such list remains empty, throw an exception.
        # (( ${#'${runnable_names_list_name___smltrpan}'} )) || :die\
        #     ${runnable_label__smltrpan}'' names unsplittable from prototype:''$''\n''${prototype__smltrpan}

            # If such attribute is valueless (e.g., *NOT* suffixed by a
            # colon-prefixed value), key such attribute to the empty string.
            # if [[ -z "${match[2]}" ]] {
            #     : "${(P)runnable_attrs_map_key__smltrpan::=}"
            # # Else, such attribute is suffixed by a colon-prefixed value. Key
            # # such attribute to such value.
            # } else {
            # }

            # Key
            # such attribute to such value
            # String indexing the passed map with the current attribute name,
            # as zsh requires for setting map keys outside of eval()
            # statements.
        # Preserve such names *BEFORE* matching, which overwrites ${match}.
        # local runnable_names__smltrpan
        # runnable_names__smltrpan="${prototype_matches__smltrpan[3]}"

#FUXME: Such function should be obsoleted in favor of
#::set_map,list_to_runnable_prototype_attributes_names().

# void :set_list_to_runnable_prototype_names(
#     string list_name, string runnable_prototype)
# function :set_list_to_runnable_prototype_names() {
#     # Validate sanity.
#     (( # == 2 )) || :die 'Expected one list name and one runnable prototype.'
#     local list_name__sltrpn="${1}" prototype__sltrpn="${2}"
#     [[ -n "${prototype__sltrpn}" ]] || :die 'Runnable prototype empty.'
# 
#     # If such variable is undefined or not a list, throw an exception. See
#     # :die_unless_var_list() for further details.
#     [[ "${(tP)list_name__sltrpn-}" == 'array'* ]] || :die\
#         '${'${list_name__sltrpn}'} undefined or not a list.'
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     [[ "${prototype__sltrpn}" =~\
#         "${ZESHY_PROTOTYPE_RUNNABLE_NAMES_PCRE}" ]] || :die\
#         'Runnable prototype "'${prototype__sltrpn}'" invalid.'
# 
#     # If no such names were captured, throw an exception.
#     (( ${#match} )) || :die\
#         'Runnable prototype "'${prototype__sltrpn}'" names uncaptured.'
# 
#     # If such runnable only has one name, set such list to such name.
#     if [[ -n "${match[1]}" ]] {
#         eval ${list_name__sltrpn}'=( "${match[1]}" )'
#     # Else, such runnable has multiple comma-delimited names. Since single- and
#     # double-quoted runnable names may themselves contain commas, such names
#     # must be iteratively matched with a PCRE rather than split on commas.
#     } else {
#         local runnable_names__sltrpn
# 
#         # Preserve such names *BEFORE* such matching, which overwrites ${match}.
#         runnable_names__sltrpn="${match[2]}"
# 
#         # Compile such PCRE. See for_string_text_matching_pcre:() for further
#         # details.
#         pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_NAMES_NEXT_PCRE}"
#         pcre_study
# 
#         # Match and append each such name to such list.
#         local ZPCRE_OP='0 0'
#         eval 'while {
#             pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${runnable_names__sltrpn}"
#         } {
#             '${list_name__sltrpn}'+="${match[1]}"
#         }
# 
#         # If such list remains empty, throw an exception.
#         (( ${#'${list_name__sltrpn}'} )) || :die\
#             ''Runnable prototype "''${prototype__sltrpn}''" names unparsed (despite detecting multiple names).'''
#     }
# }

#[[:space:]]#(#b)(^$'\n']##)$'\n'[[:space:]]#$'\n'*
#FUXME: This is terrible. Excise!
# function die_for_declarator_type_with_help() {
#     # Validate sanity.
#     (( # == 2 )) || :die 'Expected one type string and one help string.'
# #   print -r -- "arg count: ${#}; args: ${*}"
#     local type="${1}" help="${2}"
# 
#     # Function prototype prefixing such help string.
#     local help_prototype
# 
#     # If such string contains a blank line (i.e., "\n\n"), crudely match the
#     # substring preceding such line as the function prototype.
#     if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
#         help_prototype="${match[1]}"
#     # Else if such string contains a newline (i.e., "\n"), crudely match the
#     # substring preceding such newline as the function prototype.
#     } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#         help_prototype="${match[1]}"
#     # Else, abandon all hope.
#     } else {
#         help_prototype="${help}"
#     }
# 
#     # Throw an exception suffixed by such prototype.
#     :die "${(C)type} documentation invalid (see \"print_help declare_${type}\"):
# ${help_prototype}"
# }

    # If such documentation contains a newline (i.e., "\n"), assume the
    # substring preceding such newline as the function prototype.
    # } elif [[ "${help__ssthp}" == (#b)([^$'\n']##)$'\n'* ]] {
    #     prototype__ssthp="${match[1]}"
    # # Else, abandon all hope.
    # } else {
    #     prototype__ssthp="${help}"

#FUXME: Rename to :set_string_to_stdin_help().
        # Shift such variable name from the argument list. See shift_arg() for
        # further details.
        # argv[1]=()

#FUXME: Document this parcel and all runnables such parcel declares.

    # If such variable is not a string, throw an exception. See
    # :die_unless_var_string() for further details.
    # [[ "${(tP)string_name__sstdh-}" == 'scalar'* ]] || :die\
    #     'Variable ${'${string_name__sstdh}'} undefined or not a string.'

    # If standard input is attached to an interactive terminal, throw an
    # exception. (While the prior test should ensure this, one can never be too
    # sure. Since we close such input below, it's critical we only close non-
    # interactive input.)
    # if [[ -t 0 ]] {
    #     die 'Standard input attached to an interactive terminal.'
    # }
    # # Close standard input. See close_stdin() for further details.
    # exec 0<&-

    # If standard input is either the empty string *OR* unreadable
    # If at least one byte of standard input is readable without blocking, throw an exception. See
