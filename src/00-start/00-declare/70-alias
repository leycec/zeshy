#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *simple alias* (i.e., aliases expanded only in command position)
declarers and definers.
/---

# ....................{ GLOBALS                            }....................
# Due to a chicken-and-the-egg problem, all such globals are subsequently
# documented under @{help} in the main codebase.

# ....................{ DECLARERS                          }....................
#FIXME: This has become non-orthogonal. We declare functions with merely
#:func() but aliases with :alias_command.declare(); clearly, the latter should
#be renamed to merely :alias_command(). Note, however, that we already have a
#rudimentary low-level alias :alias_command() effectively equivalent to
#:alias_command.define(). Hence, perhaps we should (in order):
#
#* Rename :alias_command() to :alias_command.define().
#* Rename :alias_command.declare() to :alias_command().

:func_ ':void :alias_command.declare[
    args =  (`:string `alias_prototype,
             `:string `alias_expansion),
    stdin = (`:string `alias_asciidoc)]' :func{
    ::alias.declare_of_type "${@}" 'simple'
}:func <<'/---'
Declare one or more *simple aliases* (i.e., aliases expanded only in command
position) identified by the passed prototype, expanding to the passed expansion
and documented by the documentation passed on standard input (e.g., as a
here-document or -string). If any such aliases have already been declared or
defined, an exception is thrown. See ::alias.declare_of_type() for further details:
e.g,

.:alias_command.declare()
==========================================
[source]
------------------------------------------
>>> :alias_command.declare\
...    'void :preserve_string(string text)'\
...    '{ :string in_memoria; in_memoria="$(get_stdin)" } <<<' <<'/---'
... It is not enough to fight for the land; it is even more important to
... enjoy it. While you can. While it's still here.
... /---
>>> :preserve_string\
...    "So get out there and hunt and fish and mess around with your friends,
...     ramble out yonder and explore the forests, climb the mountains, bag the
...     peaks, run the rivers, breathe deep of that yet sweet and lucid air,
...     sit quietly for a while and contemplate the precious stillness, the
...     lovely, mysterious, and awesome space."
>>> get_string_line "${in_memoria}"
It is not enough to fight for the land; it is even more important to
------------------------------------------
==========================================
/---

:func_ ':void :alias_global.declare[
     args =  (`:string `alias_prototype,
              `:string `alias_expansion),
     stdin = (`:string `alias_asciidoc)]' :func{
    ::alias.declare_of_type "${@}" 'global'
}:func <<'/---'
Declare one or more *global aliases* (i.e., aliases expanded in any position of
a command) identified by the passed prototype, expanding to the passed
expansion and documented by the documentation passed on standard input (e.g.,
as a here-document or -string). If any such aliases have already been declared
or defined, an exception is thrown. See ::alias.declare_of_type() for further details:
e.g,

.:alias_global.declare()
==========================================
[source]
------------------------------------------
>>> :alias_global.declare\
...    'void :compensate_string(string text)'\
...    '
...     { :string_global in_honoraria; in_honoraria="$(get_stdin)" } <<<' <<'/---'
... Enjoy yourselves, keep your brain in your head and your head firmly
... attached to the body, the body active and alive, and I promise you this
... much; I promise you this one sweet victory over our enemies, over those
... desk-bound men and women with their hearts in a safe deposit box, and
... their eyes hypnotized by desk calculators.
... /---
>>> :string.output "I promise you this; " :compensate_string\
...    "You will outlive the bastards."
>>> :string.output "${in_honoraria}"
You will outlive the bastards.
------------------------------------------
==========================================
/---

:func_ ':void :alias_suffix.declare[
    args =  (`:string `alias_prototype,
             `:string `alias_expansion),
    stdin = (`:string `alias_asciidoc)]' :func{
    ::alias.declare_of_type "${@}" 'suffix'
}:func <<'/---'
Declare one or more *suffix aliases* (i.e., aliases expanded when files of such
filetype are in command position) identified by the passed prototype, expanding
to the passed expansion and documented by the documentation passed on standard
input (e.g., as a here-document or -string). If any such aliases have already
been declared or defined, an exception is thrown. See ::alias.declare_of_type() for
further details: e.g,

.:alias_suffix.declare()
==========================================
[source]
------------------------------------------
>>> :alias_suffix.declare\
...    'string :stabilize_pdf(string pdf_filename)'\
...    ':string.output\
...       "But the profoundest implications of the decreased work week were
...        philosophical and ecological: mankind, the Ecotopians assumed, was
...        not meant for production, as the 19th and 20th centuries believed.
...        Instead, humans were meant to take their modest place in the
...        seamless, stable-state web of living organisms, disturbing that web
...        as little as possible."
...
...     {
...         :string pdf_filename="$(get_stdin)" pdf_media_type
...         :set_string_to_file_media_type pdf_media_type "${pdf_filename}"
...         :string.output "${pdf_filename}: ${pdf_media_type}"
...     } <<<' <<'/---'
... This would mean sacrifice of present consumption, but it would ensure
... future survival.
... /---
>>> make_file "Ernest Callenbach.epub"
>>> get_string_line "$(Ernest Callenbach.pdf)" -1
Ernest Callenbach.pdf: application/pdf
------------------------------------------
==========================================
/---

# ....................{ DECLARERS ~ low-level              }....................
:func_ ':void ::alias.declare_of_type[
    args =  (:string alias_prototype,
             :string alias_expansion,
             :string alias_type),
    stdin = (:string alias_asciidoc)]' :func{
    # Declare locals. Since
    # ::alias.document_prototype,stdin_of_type_if_found_or_noop() already
    # validates such type, avoid doing so here.
    local -A alias_attrs
    local -a alias_names

    #FIXME: While the codebase contains considerably fewer aliases than
    #functions, it still contains a great many aliases. In other words,
    #consider inlining such logic as done for functions.

    # List of all alias names declared by such prototype.
    :alias_prototype.set_attrs,names\
        "${alias_prototype}" alias_attrs alias_names

    # For each such alias...
    local alias_name
    for   alias_name ("${alias_names[@]}") {
        # Function defining such alias.
        local alias_definer=":define_alias_${alias_type}"
        :func.die_unless "${alias_definer}"

        # Define such alias.
        "${alias_definer}" "${alias_name}" "${alias_expansion}"

        #FIXME: This is fairly lame. For one, such function fails to
        #distinguish between alias types; for another, a new function
        #:add_parcel_current_alias_command() should probably be defined passing
        #canonical global "${ZESHY_PARCEL_NAME}" to a new function
        #:add_parcel_alias_command().

        # Append such alias to the current parcel *AFTER* successfully defining
        # such alias.
        add_parcel_alias "${ZESHY_PARCEL_NAME}" "${alias_name}"
    }

    # Document such aliases with such documentation *AFTER* successfully
    # defining such aliases above.
    ::alias.document_prototype,stdin_of_type_if_found_or_noop\
        "${alias_names[@]}"\
        "${alias_type}"\
        "${alias_prototype}"
}:func <<'/---'
Declare an alias of the passed type residing in the current parcel with
prototype and hence name parsed from either the passed optional prototype _or_
the non-optional documentation passed on standard input (e.g., as a
here-document or -string), defined to expand to the passed optional expansion.
If such expansion is _not_ passed, such alias must be manually defined (e.g.,
by subsequently calling :alias_command()).

== Caveats ==

This function is a low-level helper intended to be called only by high-level
alias declarators (e.g., :define_alias_command()). For forwards compatibility
with future revisions, call such functions rather than this function.

== Alias Type ==

The passed type must match one of the following strings:

* `simple`, declaring simple aliases. See :alias_command.declare() for further
  details.
* `global`, declaring global aliases. See :alias_global.declare() for further
  details.
* `suffix`, declaring suffix aliases. See :alias_suffix.declare() for further
  details.

== Alias Name ==

The name(s) for such alias is parsed from (in order):

* If an optional prototype is passed, such prototype (e.g., the `:la_ss_az` in
  `void :la_ss_az(string lsz)`).
* Else if a prototype prefixes the passed non-optional documentation, such
  prototype (e.g., the `:5_meo_dmt` in
  `void :5_meo_dmt(string dmt)
  +
  Among the many mysteries and insults presented by DMT, it offers a final
  mockery of our drug laws: Not only have we criminalized naturally occurring
  substances, like cannabis; we have criminalized one of our own
  neurotransmitters.`).
* Else, an exception is thrown.

=== Alias Synonyms ===

As with function prototypes, such prototype may declare one or more names for
such alias (e.g., the `:ska_maria_pastora` and `:hojas_de_maria` in
`string {:ska_maria_pastora,:hojas_de_maria}()`)). If an optional expansion
is passed, all such names will be synonymously defined as aliases of the passed
type expanding to such expansion.

== Alias Documentation ==

The passed documentation consists of:

. An optional *alias prototype* in `zeshy`-specific C-like syntax consisting of
  one or more alias return types, one alias name, and zero or more alias
  arguments (e.g.,
  `string parable_of_the_box(integer derrick, character jensen)`), if such
  prototype was _not_ passed as an argument already.
. An *alias description* in http://asciidoc.org[AsciiDoc] syntax, augmented with
  `zeshy`-specific markup for cross-referencing other `zeshy` documentation
  (e.g., `The *box* is +full+ of salmon, and a *man* sits +atop+ the box.`).
  Since single- and double-quoted `zsh` string syntax conflicts with such syntax,
  consider passing such description to :alias_command.declare() as a
  here-document on standard input instead.

For completeness, we specify such syntax as a
http://en.wikipedia.org/wiki/Parsing_expression_grammar[Parser Expression Grammar (PEG)].
See the <<declare_function.peg,function documentation PEG>> from which this PEG
derives for all productions not listed here (e.g., ReturnTypes, Whitespace):

.Alias Documentation Grammar
[cols=">strong,^,<"]
|===============================================================================
| AliasDocumentation    | <- | AliasPrototype Whitespace+ AsciiDoc
| AliasPrototype        | <- | Whitespace* ReturnTypes
                               Whitespace+ AliasName
                               Whitespace* AliasArgs
| AliasName             | <- | AlphanumericString
| AliasArgs             | <- | ArgumentList | ArgumentChannels
| AliasArgChannels      | <- | ``['' Whitespace* ( AliasArgChannel Whitespace*
                               ``,'' Whitespace*)* AliasArgChannel Whitespace*
                               ``]''
| AliasArgChannel       | <- | AliasArgChannelName Whitespace* ``:'' Whitespace*
                               (Argument | ArgumentList)
| AliasArgChannelName   | <- | ``args'' | ``argstring'' | ``stdin''
|===============================================================================

== Alias Prototypes and AsciiDoc ==

With only minor exception, alias prototypes and AsciiDoc support the same
syntax as that supported by function prototypes and AsciiDoc. See
:func_() for further details.
/---

# ....................{ DEFINERS                           }....................
:func_ ':void :define_alias_command(
    :string alias_name, :string alias_expansion)' :func{
    # Localize arguments.
    local alias_name="${1}" alias_code="${2}"

    # If such alias already exists, throw an exception. See :is_alias_command()
    # for further details.
    if (( ${+aliases[${alias_name}]} +\
          ${+dis_aliases[${alias_name}]} )) {
        :die "Simple alias ${alias_name}() already defined:
$(alias -- "${alias_name}")"
    }

    # Define such alias.
    :redefine_alias_command "${alias_name}" "${alias_code}"
}:func <<'/---'
Define the passed simple alias to expand to the passed expansion. If such alias
has already been defined, an exception is thrown. See :alias_command.declare()
for further details: e.g.,

.:define_alias_command()
==========================================
[source]
------------------------------------------
>>> :define_alias_command "propaganda = explanation" ':string.output\
...    "Israel is an embattled country. They rely very heavily on U.S. support.
...     So they have developed a very sophisticated system of propaganda. They
...     don't call it propaganda. They call it hasbarah. It is the only country
...     I know of in the world that refers to propaganda as explanation. The
...     Ministry of Propaganda is the Ministry of Explanation. The idea being
...     that our position on everything is so obviously correct that if we only
...     explain it to people, they will see that it is right."'
>>> get_string_line "$("propaganda = explanation")" -1
explain it to people, they will see that it is right.
------------------------------------------
==========================================

== Motivation ==

`zsh`\'s otherwise intuitive `=`-delimited syntax for defining aliases requires
explicitly escaping alias-reserved characters (e.g., `"`, `=`, whitespace) in
alias names and hence does _not_ constitute a general-purpose solution. As the
prior example demonstrates, this function suffers no such deficiencies.
/---

:func_ ':void :define_alias_global(
    :string alias_name, :string alias_expansion)' :func{
    # Localize arguments.
    local alias_name="${1}" alias_code="${2}"

    # If such alias already exists, throw an exception. See :is_alias_global()
    # for further details.
    if (( ${+galiases[${alias_name}]} +\
          ${+dis_galiases[${alias_name}]} )) {
        :die "Global alias ${alias_name}() already defined:
$(alias -- "${alias_name}")"
    }

    # Define such alias.
    :redefine_alias_global "${alias_name}" "${alias_code}"
}:func <<'/---'
Define the passed global alias to expand to the passed expansion. If such alias
has already been defined, an exception is thrown. See :alias_global.declare()
and :define_alias_command() for further details: e.g.,

.:define_alias_global()
==========================================
[source]
------------------------------------------
>>> :define_alias_global "dominion = balance" '
...     :string.output\
...        "People were to be happy not to the extent they dominated their
...         fellow creatures on the earth, but to the extent they lived in
...         balance with them. As a basic philosophy, the idea of political
...         power is to put technology and social structure at the service of
...         humankind, rather than the other way around."'
>>> get_string_line "$(:string.output "dominion = balance")" 1
People were to be happy not to the extent they dominated their
------------------------------------------
==========================================
/---

:func_ ':void :define_alias_suffix(
    :string filetype, :string alias_expansion)' :func{
    # Localize arguments.
    local filetype="${1}" alias_code="${2}"

    # If such alias already exists, throw an exception. See :is_alias_suffix()
    # for further details.
    if (( ${+saliases[${filetype}]} +\
          ${+dis_saliases[${filetype}]} )) {
        :die 'Suffix alias for filetype "'${filetype}'" already defined:'$'\n'$(alias -s -- "${filetype}")
    }

    # Define such alias.
    :redefine_alias_suffix "${filetype}" "${alias_code}"
}:func <<'/---'
Define the passed global alias to expand to the passed expansion. If such alias
has already been defined, an exception is thrown. See :alias_suffix.declare()
and :define_alias_command() for further details: e.g.,

.:define_alias_suffix()
==========================================
[source]
------------------------------------------
>>> :define_alias_suffix epub ':string.output\
...    "In a world threatened by disintegration, in which our grand inquisitors
...     run the risk of establishing forever the kingdom of death, it [my
...     generation] knows that it should, in an insane race against the clock,
...     restore among the nations a peace that is not servitude, reconcile anew
...     labour and culture, and remake with all men the Ark of the Covenant. It
...     is not certain that this generation will ever be able to accomplish
...     this immense task, but already it is rising everywhere in the world to
...     the double challenge of truth and liberty and, if necessary, knows how
...     to die for it without hate."'
>>> make_file "Albert Camus.epub"
>>> get_string_line "$("Albert Camus.epub")" -1
to die for it without hate.
------------------------------------------
==========================================
/---

# ....................{ REDEFINERS                         }....................
:func_ ':void :redefine_alias_command(
    :string_nonempty alias_name, :string alias_expansion)' :func{
    # Localize arguments.
    local alias_name="${1}" alias_code="${2}"

    # Declare such alias. Since zsh dynamically expands aliases at their point
    # of use, alias() attempts no parsing or syntactic validation of the
    # contents of such expansion. Such redefinition should *ALWAYS* succeed.
    #
    # Note such redefinition to also be implementable with the following
    # less efficient and considerably more fragile alternative, requiring
    # characters reserved for use in alias definitions (e.g., "=") to be
    # explicitly escaped rather than merely double- or single-quoted:
    #
    #    alias_name="${alias_name//(#m)([\"=[:space:]])/\\${MATCH}}"
    #    alias -- "${alias_name}"="${alias_code}"
    aliases[${alias_name}]="${alias_code}"
#   print "redefine alias name: ${alias_name__ra}"
}:func <<'/---'
Define the passed simple alias to expand to the passed string, regardless of
whether such alias has already been defined. See :alias_command.declare() for
further details: e.g.,

.:redefine_alias_command()
==========================================
[source]
------------------------------------------
>>> :redefine_alias_command "separate = ego" ':string.output\
...    "The prevalent sensation of oneself as a separate ego enclosed in a bag
...     of skin is a hallucination which accords neither with Western science
...     nor with the experimental philosophy-religions of the East — in
...     particular the central and germinal Vedanta philosophy of Hinduism."
>>> get_string_line "$("separate = ego")" 1
The prevalent sensation of oneself as a separate ego enclosed in a bag
>>> :redefine_alias_command "separate = ego" ':string.output\
...    "This hallucination underlies the misuse of technology for the violent
...     subjugation of man's natural environment and, consequently, its eventual
...     destruction. We are therefore in urgent need of a sense of our own
...     existence which is in accord with the physical facts and which overcomes
...     our feeling of alienation from the universe."
>>> get_string_line "$("separate = ego")" -1
our feeling of alienation from the universe.
------------------------------------------
==========================================
/---

:func_ ':void :redefine_alias_global(
    :string_nonempty alias_name, :string alias_expansion)' :func{
    # Localize arguments.
    local alias_name="${1}" alias_code="${2}"

    # Declare such alias. See :redefine_alias_suffix() for further details.
    galiases[${alias_name}]="${alias_code}"
#   print "redefine alias name: ${alias_name__ra}"
}:func <<'/---'
Define the passed global alias to expand to the passed string regardless of
whether such alias has already been defined. See :alias_global.declare() for
further details: e.g.,

.:redefine_alias_global()
==========================================
[source]
------------------------------------------
>>> :redefine_alias_global "horizon = anarchism" '
...    :string.output\
...    "Therefore, the subject is not whether we accomplish Anarchism today,
...     tomorrow, or within ten centuries, but that we walk towards Anarchism
...     today, tomorrow, and always."'
>>> get_string_line "$(:string.output "horizon = anarchism")" -1
today, tomorrow, and always.
>>> :redefine_alias_global "horizon = anarchism" '
...    :string.output\
...    "Anarchism is the abolition of exploitation and oppression of man by
...     man, that is, the abolition of private property and government;
...    Anarchism is the destruction of misery, of superstitions, of hatred."'
>>> get_string_line "$(:string.output "horizon = anarchism")" -1
Anarchism is the destruction of misery, of superstitions, of hatred.
------------------------------------------
==========================================
/---

:func_ ':void :redefine_alias_suffix(
    :string_nonempty filetype, :string alias_expansion)' :func{
    # Localize arguments.
    local filetype="${1}" alias_code="${2}"

    # Declare such alias. See :redefine_alias_suffix() for further details.
    saliases[${filetype}]="${alias_code}"
#   print "redefine alias name: ${filetype__ra}"
}:func <<'/---'
Define the passed suffix alias to expand to the passed string regardless of
whether such alias has already been defined. See :alias_suffix.declare() for
further details: e.g.,

.:redefine_alias_suffix()
==========================================
[source]
------------------------------------------
>>> :redefine_alias_suffix mobi ':string.output\
...    "In reality very little was known about the proles. It was not necessary
...     to know much."'
>>> make_file "George Orwell.mobi"
>>> get_string_line "$("George Orwell.mobi")" 1
In reality very little was known about the proles. It was not necessary
>>> :redefine_alias_suffix mobi ':string.output\
...    "So long as they continued to work and breed, their other activities
...     were without importance. Left to themselves, like cattle turned loose
...     upon the plains of Argentina, they had reverted to a style of life
...     that appeared to be natural to them, a sort of ancestral pattern."'
>>> get_string_line "$("George Orwell.mobi")" 1
So long as they continued to work and breed, their other activities
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: Refactor so as to pass ${alias_type} as the last rather than first
#argument.

    # Localize arguments. Since ::document_alias_typed_with_prototype,asciidoc()
    # already validates such type, do *NOT* bother doing so here.
    # local alias_type="${1}" alias_prototype="${2}" alias_code="${3}" alias_args

    # (( # == 3 )) || :die\
    #     'Expected one alias type, one alias prototype, and one alias expansion.'
    # (( # == 2 )) || :die\
    #     'Expected one alias prototype and one alias expansion.'

# [[ -n "${alias_name}" ]] || :die 'Alias name empty.'
    # (( # == 2 )) || :die 'Expected one alias name and one alias expansion.'
# one
# minor and one major exception. See declare_function() for all other details.
# 
# === Minor Exception ===
# 
# Function prototypes permit multiple names. Alias prototypes permit only one.
# 
# === Major Exception ===
# 
# #FUXME: *major sigh* None of this applies anymore, despite the intensity of the
# #effort devoted to its documentation. Thanks to dynamic block aliases, such
# #bereft nonesense as compacting all arguments into a single string argument.
# 
# Function prototypes permit only two argument channel names: `args` and `stdin`.
# Alias prototypes permit a third argument channel specific to herestring-driven
# aliases: `argstring`.
# 
# By design, zsh aliases are expanded inline and hence cannot accept arbitrary
# arguments not accepted by the commands such aliases expand to. As example, the
# alias `l` declared by `alias l=ls` accepts only the arguments accepted by
# command `ls` -- no more, no less.
# 
# Herestring-driven aliases circumvent such constraints by accepting a single
# herestring argument embedding one or more ``real'' arguments to be passed such
# alias. Since such aliases _always_ accept a single herestring, declaring a
# single-string argument list conveys no meaningful information. Rather, such
# aliases should declare a herestring-specific argument channel `argstring`
# accepting the argument list embedded in such herestring. For clarity, consider
# optionally suffixing aliases defined in this way with `_from': e.g.,
# 
# .Herestring-driven Alias
# ==========================================
# [source]
# ------------------------------------------
# declare_alias '
# void set_args_to_string_split_on_words_from[
#     argstring: (string text1, string text2, ...)]
# 
# Set the current argument list to the passed strings split on shell words: e.g.,
# 
#     >>> string on_relations=\
#     ...    "All fixed, fast-frozen relations, with their train of ancient and
#     ...     venerable prejudices and opinions, are swept away, all new-formed
#     ...     ones become antiquated before they can ossify. All that is solid
#     ...     melts into air, all that is holy is profaned, and man is at last
#     ...     compelled to face with sober senses his real conditions of life, and
#     ...     his relations with his kind."
#     >>> set_args_to_string_split_on_words_from "${on_relations}"
#     >>> print_string ${3}
#     fast-frozen
# '
# alias set_args_to_string_split_on_words_from='
# {
#     # Validate passed arguments.
#     list args__sltssowf
#     set_list_to_stdin_words args__sltssowf
#     (( ${#args__sltssowf} >= 1 )) or die 'expected at least one string'
# 
#     # Temporary list to split such strings into.
#     list words__sltssowf
# 
#     # Split such strings.
#     set_list_to_string_words words__sltssowf "${args__sltssowf[@]}"
# 
#     # Set the current argument list to such words.
#     set_args "${words__sltssowf[@]}"
# 
#     # Delete such temporary list.
#     undefine_variable words__sltssowf
# } <<<'
# ------------------------------------------
# ==========================================

    # Documentation passed on standard input.
    # ::help.set_to_stdin alias_asciidoc

#FUXME: Excise!
# Map each alias name to the help string documenting such alias.
# typeset -Ag ZESHY_ALIAS_NAME_TO_HELP

#FUXME: Excise!
# Map each alias name to the first name declared for such alias.
# typeset -Ag ZESHY_ALIAS_NAME_TO_ALIAS_NAME_FIRST

    # If such type is unrecognized, throw an exception.
    # [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
    #     'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

# function ::alias.declare_of_type() {
#     # Validate sanity.
#     (( 1 <= # && # <= 3 )) || :die\
#         'Expected one alias type, optional alias prototype, and optional alias expansion.'
#     local\
#         alias_type="${1}"\
#         alias_prototype="${2-}"\
#         alias_expansion="${3-}"\
#         alias_help
#     local -a alias_help_match alias_names
# 
#     # If such type is unrecognized, throw an exception.
#     [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
#         'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'
# 
#     # Documentation passed on standard input.
#     ::help.set_to_stdin alias_help
# 
#     ::document_alias_typed_with_prototype,asciidoc
# 
#     #FIXME: Horrible. Refactor in terms of the following predefined setters:
#     #
#     #    :set_string_to_help_prototype()
#     #    :set_list_to_runnable_prototype_names()
#     #    :document_alias_of_type()
# 
#     # If passed a prototype, prefix such documentation with such prototype.
#     if (( # )) {
#         alias_help="${alias_prototype}"$'\n\n'"${alias_help}"
#     }
# 
#     # Match the alias name from the prototype prefixing such documentation or
#     # throw an exception if such match fails.
#     [[ "${alias_help}" =~ "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_PCRE}" ]] || :die\
#         'Alias prototype "'${alias_help}'" invalid.'
# 
#     # List of substrings captured by the prior match. The PCRE-based iteration
#     # performed by set_lists_to_runnable_prototype_name_or_names:() below
#     # overwrites ${match}, necessitating we preserve it here.
#     alias_help_match=( "${match[@]}" )
# 
#     # List of alias names declared by such prototype.
#     set_list_and_map_to_runnable_prototype_name_or_names:\
#         alias_names\
#         ZESHY_ALIAS_NAME_TO_ALIAS_NAME_FIRST\
#         "${alias_help_match[1]-}"\
#         "${alias_help_match[2]-}"
# 
#     # For each such name...
#     local alias_name
#     for   alias_name ("${alias_names[@]}") {
#         # If an expansion was passed for such alias, define such alias.
#         if [[ -n "${alias_expansion}" ]] {
#             # Function defining such alias.
#             local alias_definer=":define_alias_${alias_type}"
# 
#             # If such function does *NOT* exist, throw an exception. See
#             # :func.die_unless() for further details.
#             (( ${+functions[${alias_definer}]} )) || :die\
#                 'Function '${alias_definer}'() undefined.'
# 
#             # Define such alias.
#             "${alias_definer}" "${alias_name}" "${alias_expansion}"
#         }
# 
#         # Add such alias to the current parcel.
#         add_parcel_alias "${ZESHY_PARCEL_NAME}" "${alias_name}"
#     }
# 
#     # Map the first such name to such documentation. See declare_function()
#     # for further details.
#     ZESHY_ALIAS_NAME_TO_HELP[${alias_names[1]}]="${alias_help}"
# }

#FUXME: Rename to ::alias.declare_of_type_type().

#FUXME: Optional arguments are terrible. Require passed prototypes *AND*
#expansions. (If the caller only wants to document an existing alias, they can
#very well call :document_alias() -- which, of course, is how we should have
#designed such functionality originally. *sigh*)

#FUXME: Optional arguments are terrible. Require a passed prototype and *AND*
#expansion. See above.

# Declare a *suffix alias* (i.e., alias expanded when a file of such filetype is
# in command position) residing in the current parcel with prototype and hence
# name parsed from either the passed optional prototype _or_ the non-optional
# documentation passed on standard input (e.g., as a here-document or -string),
# defined to expand to the passed optional expansion. If such expansion is _not_
# passed, such alias must be manually defined (e.g., by subsequently calling
# :alias_suffix()). See ::alias.declare_of_type() for further details: e.g,

# Declare a *global alias* (i.e., alias expanded in any position of a command)
# residing in the current parcel with prototype and hence name parsed from either
# the passed optional prototype _or_ the non-optional documentation passed on
# standard input (e.g., as a here-document or -string), defined to expand to the
# passed optional expansion. If such expansion is _not_ passed, such alias must
# be manually defined (e.g., by subsequently calling :alias_global()). See
# ::alias.declare_of_type() for further details: e.g,

# Declare a *simple alias* (i.e., alias expanded only in command position)
# residing in the current parcel with prototype and hence name parsed from either
# the passed optional prototype _or_ the non-optional documentation passed on
# standard input (e.g., as a here-document or -string), defined to expand to the
# passed optional expansion. If such expansion is _not_ passed, such alias must
# be manually defined (e.g., by subsequently calling :alias_command()). See
# ::alias.declare_of_type() for further details: e.g,

    #FUXME: Glob ${ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE} is insufficient.
    #Due to apparent laziness, such glob validates only the return type and
    #alias name but *NOT* alias arguments accepted by such argument. While
    #such validation isn't (yet) critical to operation, it could certainly
    #stand to be improved.

#FUXME: Create a new parcel tree @{*-define/*-alias} containing subparces
#@{simple}, @{global}, and @{suffix}, each providing declarators and definers
#specific to that alias type.
#FUXME: To readily create such parcels, define a new low-level helper
#::alias.declare_of_type(). Such function should be called by high-level alias
#declarators (e.g., :alias_command.declare()). The current implementation of
#:alias_command.declare() should basically be shifted wholesale into
#::alias.declare_of_type(). But how will ::alias.declare_of_type() know which alias type to
#declare and define? Simple: it inspects the call stack, a method guaranteed to
#work both reliably and efficiently. This then reduces us to:
#
#function :alias_command.declare() {
#    ::alias.declare_of_type "${@}"
#}
#
#Pretty intense, eh?
#FUXME: Since this reduces such high-level declarators to effectively nothing,
#rename this parcel back to @{*-declare/*-alias} and define all such
#declarators in this parcel.

# names containing such characters requires explicitly escaping such characters
# and hence is neither intuitive or safe. This function amends this: e.g.,

    # If private variable ${zeshy_alias_type__} is undefined or not defined as
    # a string, the caller is *NOT* a high-level alias declarator as expected.
    # In such case, throw an exception. See :var.die_unless_type_string() for further
    # details.
    # [[ "${(t)zeshy_alias_type__-}" == 'scalar'* ]] || die\
    #     'Variable ${zeshy_alias_type__} undefined or not a string, as not called by high-level alias declarator (e.g., :alias_command.declare()).'

 # See :var.die_unless() for further
 #    # details.
 #    (( ${+zeshy_alias_type__} )) || die\
    #FUXME: Support alias name synonyms.

    # If passed at least a prototype, handle such string. Since this is the
    # common case, test such condition first.
    # if (( # )) {
        # Localize such prototype and optional passed expansion.
        # alias_prototype__da="${1}"
        # alias_expansion__da="${2-}"

        # Match the alias name from such prototype prefixing such string or
        # throw an exception if such match fails.
#         [[ "${alias_prototype__da}" =~\
#            "${ZESHY_PROTOTYPE_ALIAS_NAMES_PCRE}" ]] ||
#             die_for_declarator_type_with_help 'alias' "${help__da}"
# #       print -r -- "defined alias ${alias_name__da}:catch\"${alias_expansion__da}\""
#     # Else, only a help string was passed.
#     } else {

        # If also passed an expansion, handle such string.
        # if (( # == 2 )) {
        # }

# If such prototype is _not_ passed and such documentation is prefixed by no such
# prototype, an exception is thrown.
# 
# Declare the specified alias to be contained by the current parcel and documented
# by the passed help string, where such alias is specified by either:
# 
# * The passed alias prototype, if such argument is passed.
# * The alias prototype prefixing the passed help string, otherwise.
# 
# If an alias expansion is passed, define such alias to expand to such string;
# else, such alias must be subsequently defined: e.g,

    #FUXME: This function should also accept only two arguments (i.e., the same
    #as three arguments with an empty help string).

    # Validate sanity.
    # (( # == 1 || # == 3 )) || die\
    #     'Expected either one help string or one alias prototype, one alias expansion, and one help string.'
    # local\
    #     help__da="${@[-1]}"\
    #     alias_prototype__da\
    #     alias_expansion__da\
    #     alias_name__da
    # local -a help_match__da alias_names__da

# declare_function_with_stdin <<'/---'
# void :alias_command.declare[
#     args: (string alias_prototype = "",
#            string alias_expansion = ""),
#     stdin: string alias_asciidoc]
# 
# Declare the specified alias to be contained by the current parcel and documented
# by the passed help string, where such alias is specified as under
# declare_alias(). See declare_function_with_stdin() for further details.
# /---
# function :alias_command.declare() {
#     run_runnable_with_stdin declare_alias "${@}"
# }

    #    # Sanitize such name, escaping all alias-reserved characters. Unlike
    #    # functions, merely double quoting alias names does *NOT* suffice.
    # Sanitize such name, escaping all alias-reserved characters. Unlike
    # functions, merely double quoting alias names does *NOT* suffice.
    # alias_name__dfa="${1//(#m)([\"=[:space:]])/\\${MATCH}}"
#   if [[ "${alias_name__dfa}" == *':'* ]] { print -r -- "colon alias: \"${alias_name__dfa}\"=\"${alias_expansion__dfa}\"" }

    #FUXME: Not fond of this approach. Just perform the following equivalent,
    #simpler, more efficient test:
    #
    #    if (( ${+aliases[${alias_name__dfa}]} )) {
    #
    #Do *NOT* adjust is_alias_nonsuffix() accordingly. Such function accepts
    #multiple arguments, which the above approach does not accomodate. (Note
    #this.)
    #FUXME: Incidentally, given the syntactic difficulties imposed by the
    #alias() builtin for defining alias names containing reserved characters,
    #it's probably *MUCH* simpler to define aliases dynamically be setting
    #the corresponding keys of map global ${aliases}: e.g.,
    #
    #    aliases[${alias_name__dfa}]="${alias_expansion__dfa}"
    #
    #That shouldn't require *ANY* of the above escaping, right? Test it out.
    # Technically, the following less
    # efficient alternative also suffices to implement such test:
    #
    #    if (( ${+aliases[${alias_name__dfa}]} +\
    #          ${+galiases[${alias_name__dfa}]} +\
    #          ${+dis_aliases[${alias_name__dfa}]} +\
    #          ${+dis_galiases[${alias_name__dfa}]} )) { ... }

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :redefine_alias_command().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Sanitize such name, escaping all alias-reserved characters. Unlike
    # functions, merely double quoting alias names does *NOT* suffice.
    # alias_name__dfa="${1//(#m)([\"=[:space:]])/\\${MATCH}}"
#   if [[ "${alias_name__dfa}" == *':'* ]] { print -r -- "colon alias: \"${alias_name__dfa}\"=\"${alias_expansion__dfa}\"" }

    #FUXME: Not fond of this approach. Just perform the following equivalent,
    #simpler, more efficient test:
    #
    #    if (( ${+aliases[${alias_name__dfa}]} )) {
    #
    #Do *NOT* adjust is_alias_nonsuffix() accordingly. Such function accepts
    #multiple arguments, which the above approach does not accomodate. (Note
    #this.)
    #FUXME: Incidentally, given the syntactic difficulties imposed by the
    #alias() builtin for defining alias names containing reserved characters,
    #it's probably *MUCH* simpler to define aliases dynamically be setting
    #the corresponding keys of map global ${aliases}: e.g.,
    #
    #    aliases[${alias_name__dfa}]="${alias_expansion__dfa}"
    #
    #That shouldn't require *ANY* of the above escaping, right? Test it out.

    # If such alias already exists, throw an exception. See
    # is_alias_nonsuffix() for further details.
#     if { alias -- "${alias_name__dfa}" &>/dev/null } {
#         die "Alias ${alias_name__dfa}() already exists:
# $(alias -- "${alias_name__dfa}")"
#     }

    # Map such alias to such help string.
#    ZESHY_ALIAS_NAME_TO_HELP[${alias_name__da}]="${help__da}"
#
#    # Add such alias to the current parcel.
#    add_parcel_alias "${ZESHY_PARCEL_NAME}" "${alias_name__da}"

    # If such alias has already been declared, print a warning.
#    if (( ${+ZESHY_ALIAS_NAME_TO_HELP[${alias_name__da}]} )) {
#        print "zeshy: alias ${alias_name__da}() in parcel @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
#    }

# Global map from alias names to the help strings documenting such aliases. See
# ${ZESHY_FUNCTION_NAME_TO_HELP} for further details.

#   if [[ "${alias_name__dfa}" == *':'* ]] { print -r -- "colon alias (before): \"${alias_name__dfa}\"=\"${alias_expansion__dfa}\"" }
#   if [[ "${alias_name__dfa}" == *'"'* ]] { print -r -- "quoted alias: ${alias_name__dfa}" }
#   print "define alias name: ${alias_name__dfa}"

#FUXME: It'd be great to support an optional suffixing argument to
#declare_alias(): the alias expansion to expand such alias to. This eliminates
#the unctuous duplication inherent in the current approach, while still
#admitting such approach. The resulting prototype would resemble:
#
#   void declare_alias(string alias_asciidoc, string expansion = "")
#
#Note this cannot be scaled to functions without stupid and extreme hardship
#(i.e., single- or double-quoting the entire function body *OR* escaping all
#shell-reserved characters in such body, which is equally absurd).
#FUXME: Actually, the above should be revised. Since alias prototype syntax is
#basically guaranteed *NOT* to conflict with zsh syntax, we want to change
#declare_alias() to support the following argument signature:
#
#void declare_alias(
#    string alias_prototype = "",
#    string alias_expansion = "",
#    string alias_asciidoc)
#
#For example, rather than:
#
#   :alias_command.declare <<'/---'
#   [status: true] report_success()
#
#   Return from the current runnable with *success* (i.e., zero exit status).
#   /---
#   alias report_success="return ${ZESHY_STATUS_SUCCESS}"
#
#We would have:
#
#   :alias_command.declare\
#       '[status: true] report_success()'\
#       "return ${ZESHY_STATUS_SUCCESS}" <<'/---'
#   Return from the current runnable with *success* (i.e., zero exit status).
#   /---
#
#Pretty awesome, no? At that point, we've basically invented a zsh prototyping
#language with real-world effects. *ALL* aliases should really be migrated to
#the above definition, to reduce codebase redundancy. (That said, we should
#continue to support the single-argument version for orthogonality with
#declare_function().)
#
#Note that this isn't simply to reduce redundancy, however. Consider deprecating
#aliases, which we'll certainly want to do at some point. To support alias
#depcrecation, declare_alias() requires the alias expansion, which it then
#prepends with a statement printing the desired deprecation message. Critical!

#Set the documentation for the alias named by the variable declaration prefixing
#standard input to such input. Consider calling this rather than declare_alias(),
#which requires passing a string argument rather than standard input. See
#declare_function_with_stdin() for further details.
        #FUXME: This could probably be generalized to support "="-delimited
        #assignment, but I have doubts as to whether that'd be widely useful.

    # Unless such string matches the function help PCRE, throw an exception.
#   [[ "${help__da}" =~\
#      "${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}" ]] ||
#       die_for_declarator_type_with_help 'alias' "${help__da}"
#   for ((match_index=1; match_index <= ${#match}; ++match_index)) {
#       print "match ${match_index}: ${match[${match_index}]}"
#   }

#Set the documentation for the alias named by the alias prototype prefixing the
#passed string to such string. 
#by association with 
#only at the end of
#expressions, typically for filetypes).

    #FUXME: Fixup! We don't have to do much parsing here. Aliases can't be
    #globbable (as that's how we make things globbable in the first place) and
    #can't have synonyms, so we just need to parse the straightup alias name.
    #That still requires a bit of work, but by leveraging the above regular
    #expressions shouldn't be *TOO* terribly convoluted.
    #FUXME: O.K.; match similarly to declare_function() below, but using the
    #following PCRE instead: ${ZESHY_HELP_PCRE_ALIAS_PROTOTYPE_NAME}.
