#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *local declarers* (i.e., aliases declaring local variables).
/---

#FIXME: Shift all other non-constant local declarers here.
#FIXME: Move to ={*-start/*-alias/*-core/*-var}.

# ....................{ DECLARERS                          }....................
:alias_command.declare ':void :map(:string... var_names_and_values)'\
    'local -A --' <<'/---'
Locally declare all passed *map variables* (i.e., whose values are non-scalar
unordered collections of key-value pairs, variously referred at as *associative
arrays*, *hash maps*, and *tables*), initialized to the empty map: e.g.,

.:map()
==========================================
[source]
------------------------------------------
>>> :map on_slavery; on_slavery=(
...     "When"     "the entirety of your earnings are exhausted on food and"
...     "shelter," "your labors are no longer viewed as an opportunity for"
...     "economic" "advancement but rather as an act of self-preservation. In"
...     "the"      "real world, thatâ€™s called slavery."
... )
------------------------------------------
==========================================

== Caveats ==

Due to current inadequacies in both `zsh` and `zeshy`, all non-scalar variables
and hence map variables are only initializable _after_ declaring such variables.
/---

# For readability, "string" is intentionally *NOT* abbreviated to "str". As an
# ad-hoc heuristic, all zeshy primitives must contain at least one vowel --
# which "str" clearly does not. Interestingly, all other canonical primitive
# type abbreviations adhere to such heuristic (e.g., "bool", "char", "int").

:alias_command.declare ':void :string(:string... var_names_and_values)'\
    'local --' <<'/---'
Locally declare all passed *string variables* (i.e., whose values are any
single- or double-quoted string, integer, or float), initialized to the
`=`-prefixed value suffixing each if any or the empty string otherwise.
/---

# ....................{ DECLARERS ~ float                  }....................
# While zsh already provides builtin float() for declaring local floats, such
# builtin expands to "typeset -E" (i.e., scientific notation) rather than
# "typeset -F" (i.e., decimal notation). Given the prevalence of the latter and
# relative obscurity of the former, this seems a curious if lamentable choice.

:alias_command.declare ':void :float(:string... var_names_and_values)'\
    'local -F --' <<'/---'
Locally declare all passed *float variables* (i.e., whose values are fractional
numbers) coerced to 10 fractional digits on parameter expansion, initialized to
the `=`-prefixed value suffixing each if any or 0.0 otherwise. See
:float_of_fractional_digit_count().
/---

:alias_command.declare ':void :float_of_fractional_digit_count(
    :int length = 10, :string... var_names_and_values)'\
    'local -F' <<'/---'
Locally declare all passed float variables coerced to the passed number of
fractional digits on parameter expansion, initialized to the `=`-prefixed value
suffixing each if any or 0.0 otherwise: e.g.,

.:float_of_fractional_digit_count()
==========================================
[source]
------------------------------------------
>>> :float_of_fractional_digit_count 3 prouhet_thue_morse=0.412154033640 zero=0
>>> :string.output "${prouhet_thue_morse}" $(( prouhet_thue_morse ** 2 ))
0.412 0.16987094744572223
>>> :string.output "${zero}" $(( zero ** 2 ))
0.000 1
------------------------------------------
==========================================

== Parameter Expansion ==

On parameter expansion, each such variable will be implicitly coerced like so:

* If the number of fractional digits in such expansion equals the passed number
  of fractional digits, the former will remain unaltered (e.g., preserving
  6.626 if such number is 3).
* If the number of fractional digits in such expansion is greater than the
  passed number of fractional digits, the former will be truncated to such
  number (e.g., truncating 6.62606957 to 6.626 if such number is 3).
* Else, the number of fractional digits in such expansion is less than the
  passed number of fractional digits. In such case, the former will be padded
  to such number with sufficiently many rightmost zeros (e.g., padding 6.6 to
  6.600 if such number is 3).

== Arithmetic Expansion and Tests ==

As the prior example demonstrates, such coercion applies to neither *arithmetic
expansion* (i.e., `$((`- and `))`-delimited expressions) nor *arithmetic tests*
(i.e., `((`- and `))`-delimited expressions). In calculations, such variables
thus internally retain full precision.
/---

#FIXME: Revise documentation as above.
:alias_command.declare ':void :float_of_significant_figure_count(
    :int length = 10, :string... var_names_and_values)'\
    'local -E' <<'/---'
Declare the passed floats locally. On parameter (but _not_ arithmetic)
expansion, such floats will be implicitly converted to *scientific notation*
with the significand truncated to the passed number of significant figures: e.g.,

.:float_of_significant_figure_count()
==========================================
[source]
------------------------------------------
>>> :float_of_significant_figure_count 3 gelfonds_constant=22.140692632779269
>>> :string.output "${gelfonds_constant}" $(( sqrt(gelfonds_constant) ))
2.214e+01 4.7053897426249405
------------------------------------------
==========================================

== Parameter Expansion ==

Let `${f}` be such a float. If:

* `(( f == 0 ))`, such notation formats `${f}` as `0.0000000000e+00` (assuming
  10 significant figures).
* `(( f > 0 ))`, such notation formats `${f}` as `${a}e+${b}`, where `${a}` is
  the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
  exponent such that `(( f == A * 10 ** b ))`.
* `(( f < 0 ))`, such notation formats `${f}` as `${a}e-${b}`, where `${a}` is
  the truncation of `${A}`, `${A}` the significand, and `${b}` the two-digit
  exponent such that `(( f == A * 10 ** -b ))`.

Since this does _not_ apply to arithmetic expansion, such floats internally
retain all data for subsequent calculation.
/---

# ....................{ DECLARERS ~ int                    }....................
:alias_command.declare ':void :int(:string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *integer variables* (i.e., whose values are non-
fractional numbers), initialized to the `=`-prefixed value suffixing each if
any or 0 otherwise.
/---

# Curiously, zsh type "integer" does *NOT* suffice here.
:alias_command.declare ':void :int_of_base(
    :int base, :string... var_names_and_values)'\
    'local -i'  <<'/---'
Locally declare all passed integers variables in the passed base, initialized
to the `=`-prefixed value suffixing each if any or 0 otherwise: e.g.,

.:int_of_base()
==========================================
[source]
------------------------------------------
>>> :int_of_base 16 factory_farming=4277009102
>>> :string.output "${factory_farming}"
0xFEEDFACE
------------------------------------------
==========================================

== Usage ==

On expansion, such integers will be implicitly converted to the equivalent
values in such base. Additionally, if such base is:

* `8`, such integers will be pretty printed in *octal format* and hence:
** Prefixed with a C-style `0`.
* `16`, such integers will be pretty printed in *hexadecimal format* and hence:
** Prefixed with a C-style `0x`.
** Digits in the range [10, 15] will be printed as capitalized letters in the
   range [A, F], per tradition.
/---

# ....................{ DECLARERS ~ derived                }....................
# While zsh currently lacks builtin support for boolean types, such types are
# readily implementable with either:
#
# * Integer types. Mapping boolean false to integer 0 and boolean true to
#   integer 1 yields both an efficient representation and means of testing
#   boolean truth: e.g.,
#
#    >>> integer is_television_truth
#    >>> (( is_television_truth )) or
#    ...     :string.output "You do whatever the tube tells you."
#    "You do whatever the tube tells you."
#
# * String types. Mapping boolean false to the empty string and boolean true to
#   any nonempty string yields a slightly less efficient representation and means
#   of testing boolean truth: e.g.,
#
#    >>> string is_television_reality
#    >>> is -n "${is_television_reality}" or
#    ...     :string.output "You even think like the tube."
#
# Since testing for integer zeroness is more efficient than testing for string
# emptiness *AND* since integers are already constrained to integral values
# containing customary boolean values 0 and 1, zeshy adopts integers rather
# than strings for its boolean implementation.

:alias_command.declare ':void :bool(:string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *boolean variables* (i.e., whose values are either
${true} or ${false}), initialized to the `=`-prefixed value suffixing each if
any or ${false} otherwise: e.g.,

==========================================
[source]
------------------------------------------
>>> :bool is_television_truth
>>> (( is_television_truth )) :or get_string_line\
... "Television is not the truth. Television's a god-damned amusement park.
...  Television is a circus, a carnival, a traveling troupe of acrobats,
...  storytellers, dancers, singers, jugglers, sideshow freaks, lion tamers,
...  and football players. We're in the boredom-killing business. So if you
...  want the Truth, go to God! Go to your gurus. Go to yourselves! Because
...  that's the only place you're ever gonna find any real truth. But, man,
...  you're never gonna get any truth from us. We'll tell you anything you
...  wanna hear. We lie like hell. We'll tell you that Kojak always gets the
...  killer and that nobody ever gets cancer at Archie Bunker's house. And no
...  matter how much trouble the hero is in, don't worry. Just look at your
...  watch. At the end of the hour, he's gonna win. We'll tell you any shit
...  you want to hear." 1
Television is not the truth. Television's a god-damned amusement park.
------------------------------------------
==========================================

== Caveats ==

Due to `zsh` constraints and as in numerous other languages (e.g., Perl, C, C++,
Objective-C), *booleans are indistinguishable from integers.* Specifically,
integer 0 signifies boolean false and all nonzero integers (e.g., 1, -1) boolean
true. Since explicitly declaring booleans as such improves clarity, (possible)
forwards compatibility, and symmetry with existing types, consider declaring
booleans as such rather than as integers.
/---

#FIXME: Add example.
:alias_command.declare ':void :char(:string... var_names_and_values)'\
    'local --' <<'/---'
Locally declare all passed *character variables* (i.e., whose values are
strings of length 1), initialized to the `=`-prefixed value suffixing each if
any or the empty string otherwise.

== Caveats ==

By `zsh` constraints and as in various other languages (e.g., JavaScript,
Python), *characters are indistinguishable from strings.* Since explicitly
declaring characters as such improves clarity, forwards compatibility, and
symmetry with existing types, consider explicitly declaring characters as such.
/---

:alias_command.declare ':void :file_descriptor(
    :string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *file descriptor variables* (i.e., whose values are
non-negative integers uniquely identifying currently open files), initialized
to the `=`-prefixed value suffixing each if any or 0 (i.e., the canonical file
descriptor for standard input) otherwise.
/---

# --------------------( WASTELANDS                         )--------------------
# Curiously, builtin float() does *NOT* suffice here.

# == Global Declarers ==

# non-numeric scalar
# variables
# :alias_command.declare\
#     ':void string_constant_global(:string var_name1, ...)'\
#     'typeset -gr --' <<'/---'
# Declare the passed string constants globally _not_ exported to the calling
# shell, defined to the following `=`-delimited string if specified or to the
# empty string otherwise. Attempting to subsequently redefine such constant throws
# an exception.
# /---
# 
# :alias_command.declare\
#     ':void string_constant_global_export(:string var_name1, ...)'\
#     'export -r --' <<'/---'
# Declare the passed string constants globally exported to the calling shell. See
# string_constant_global() for further details.
# /---

# :alias_command.declare ':void string_global(:string var_name1, ...)'\
#     'typeset -g --' <<'/---'
# Declare the passed strings globally _not_ exported to the calling shell. See
# :string() for further details.
# /---
# 
# :alias_command.declare\
#     ':void string_global_export(string var_name1, ...)'\
#     'export --' <<'/---'
# Declare the passed strings globally exported to the calling shell. See :string()
# for further details.
# /---

#FUXME: Excise everywhere in favor of :string().
# :alias_command.declare ':void string(:string var_name1, ...)'\
#     'local --' <<'/---'
# Declare
# /---
