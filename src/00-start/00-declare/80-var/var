#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *local declarers* (i.e., aliases declaring local variables).
/---

#FIXME: Shift all other non-constant local declarers here.
#FIXME: Move to ={*-start/*-alias/*-core/*-var}.

# ....................{ DECLARERS                          }....................
:alias_command.declare ':void :int(:string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *integer variables* (i.e., whose values are non-
fractional numbers), initialized to the `=`-prefixed value suffixing each if
any or 0 otherwise.
/---

#FIXME: Add example.
:alias_command.declare ':void :map(:string... var_names_and_values)'\
    'local -A --' <<'/---'
Locally declare all passed *map variables* (i.e., whose values are non-scalar
unordered collections of key-value pairs, variously referred at as *associative
arrays*, *hash maps*, and *tables*), initialized to the empty map: e.g.,

.:map()
==========================================
[source]
------------------------------------------
>>> :map 
------------------------------------------
==========================================

== Caveats ==

Due to current inadequacies in both `zsh` and `zeshy`, all non-scalar variables
and hence map variables _must_ be initialized _after_ declaring such variables.
/---

# For readability, "string" is intentionally *NOT* abbreviated to "str". As an
# ad-hoc heuristic, all zeshy primitives must contain at least one vowel --
# which "str" clearly does not. Interestingly, all other canonical primitive
# type abbreviations adhere to such heuristic (e.g., "bool", "char", "int").

:alias_command.declare ':void :string(:string... var_names_and_values)'\
    'local --' <<'/---'
Locally declare all passed *string variables* (i.e., whose values are any
single- or double-quoted string, integer, or float), initialized to the
`=`-prefixed value suffixing each if any or the empty string otherwise.
/---

# ....................{ DECLARERS ~ arg                    }....................
# Curiously, the zsh type "integer" does *NOT* suffice here.

:alias_command.declare ':void :int_in_base(
    :int base, :string... var_names_and_values)'\
    'local -i'  <<'/---'
Locally declare all passed integers variables in the passed base, initialized
to the `=`-prefixed value suffixing each if any or 0 otherwise: e.g.,

.:int_in_base()
==========================================
[source]
------------------------------------------
>>> :int_in_base 16 factory_farming=4277009102
>>> :string.output "${factory_farming}"
0xFEEDFACE
------------------------------------------
==========================================

== Usage ==

On expansion, such integers will be implicitly converted to the equivalent
values in such base. Additionally, if such base is:

* `8`, such integers will be pretty printed in *octal format* and hence:
** Prefixed with a C-style `0`.
* `16`, such integers will be pretty printed in *hexadecimal format* and hence:
** Prefixed with a C-style `0x`.
** Digits in the range [10, 15] will be printed as capitalized letters in the
   range [A, F], per tradition.
/---

# ....................{ DECLARERS ~ derived                }....................
# While zsh currently lacks builtin support for boolean types, such types are
# readily implementable with either:
#
# * Integer types. Mapping boolean false to integer 0 and boolean true to
#   integer 1 yields both an efficient representation and means of testing
#   boolean truth: e.g.,
#
#    >>> integer is_television_truth
#    >>> (( is_television_truth )) or
#    ...     :string.output "You do whatever the tube tells you."
#    "You do whatever the tube tells you."
#
# * String types. Mapping boolean false to the empty string and boolean true to
#   any nonempty string yields a slightly less efficient representation and means
#   of testing boolean truth: e.g.,
#
#    >>> string is_television_reality
#    >>> is -n "${is_television_reality}" or
#    ...     :string.output "You even think like the tube."
#
# Since testing for integer zeroness is more efficient than testing for string
# emptiness *AND* since integers are already constrained to integral values
# containing customary boolean values 0 and 1, zeshy adopts integers rather
# than strings for its boolean implementation.

:alias_command.declare ':void :bool(:string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *boolean variables* (i.e., whose values are either
${true} or ${false}), initialized to the `=`-prefixed value suffixing each if
any or ${false} otherwise: e.g.,

==========================================
[source]
------------------------------------------
>>> :bool is_television_truth
>>> (( is_television_truth )) :or get_string_line\
... "Television is not the truth. Television's a god-damned amusement park.
...  Television is a circus, a carnival, a traveling troupe of acrobats,
...  storytellers, dancers, singers, jugglers, sideshow freaks, lion tamers,
...  and football players. We're in the boredom-killing business. So if you
...  want the Truth, go to God! Go to your gurus. Go to yourselves! Because
...  that's the only place you're ever gonna find any real truth. But, man,
...  you're never gonna get any truth from us. We'll tell you anything you
...  wanna hear. We lie like hell. We'll tell you that Kojak always gets the
...  killer and that nobody ever gets cancer at Archie Bunker's house. And no
...  matter how much trouble the hero is in, don't worry. Just look at your
...  watch. At the end of the hour, he's gonna win. We'll tell you any shit
...  you want to hear." 1
Television is not the truth. Television's a god-damned amusement park.
------------------------------------------
==========================================

== Caveats ==

Due to `zsh` constraints and as in numerous other languages (e.g., Perl, C, C++,
Objective-C), *booleans are indistinguishable from integers.* Specifically,
integer 0 signifies boolean false and all nonzero integers (e.g., 1, -1) boolean
true. Since explicitly declaring booleans as such improves clarity, (possible)
forwards compatibility, and symmetry with existing types, consider declaring
booleans as such rather than as integers.
/---

#FIXME: Add example.
:alias_command.declare ':void :char(:string... var_names_and_values)'\
    'local --' <<'/---'
Locally declare all passed *character variables* (i.e., whose values are
strings of length 1), initialized to the `=`-prefixed value suffixing each if
any or the empty string otherwise.

== Caveats ==

By `zsh` constraints and as in various other languages (e.g., JavaScript,
Python), *characters are indistinguishable from strings.* Since explicitly
declaring characters as such improves clarity, forwards compatibility, and
symmetry with existing types, consider explicitly declaring characters as such.
/---

:alias_command.declare ':void :file_descriptor(
    :string... var_names_and_values)'\
    'integer --' <<'/---'
Locally declare all passed *file descriptor variables* (i.e., whose values are
non-negative integers uniquely identifying currently open files), initialized
to the `=`-prefixed value suffixing each if any or 0 (i.e., the canonical file
descriptor for standard input) otherwise.
/---

# --------------------( WASTELANDS                         )--------------------
# == Global Declarers ==

# non-numeric scalar
# variables
# :alias_command.declare\
#     ':void string_constant_global(:string var_name1, ...)'\
#     'typeset -gr --' <<'/---'
# Declare the passed string constants globally _not_ exported to the calling
# shell, defined to the following `=`-delimited string if specified or to the
# empty string otherwise. Attempting to subsequently redefine such constant throws
# an exception.
# /---
# 
# :alias_command.declare\
#     ':void string_constant_global_export(:string var_name1, ...)'\
#     'export -r --' <<'/---'
# Declare the passed string constants globally exported to the calling shell. See
# string_constant_global() for further details.
# /---

# :alias_command.declare ':void string_global(:string var_name1, ...)'\
#     'typeset -g --' <<'/---'
# Declare the passed strings globally _not_ exported to the calling shell. See
# :string() for further details.
# /---
# 
# :alias_command.declare\
#     ':void string_global_export(string var_name1, ...)'\
#     'export --' <<'/---'
# Declare the passed strings globally exported to the calling shell. See :string()
# for further details.
# /---

#FUXME: Excise everywhere in favor of :string().
# :alias_command.declare ':void string(:string var_name1, ...)'\
#     'local --' <<'/---'
# Declare
# /---
