#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *list variable declarators* (i.e., aliases declaring sequential array
variables).

== Caveats ==

By compare to the relatively unencumbered *scalar variables* (i.e., floats,
integers, and strings), *nonscalar variables* (i.e., lists and maps) suffer
important limitations.

=== Initialization and Type Constraints ==

Due to current inadequacies in `zsh`, lists and maps cannot be initialized _or_
declared to be read-only at declaration time.

=== Export Constraints ==

Due to prehistoric inadequacies in the UNIX shell environment, nonscalar
variables cannot be exported to the shell environment and hence
cannot be imported by either parent shells or scripts sourcing the current
script _or_ by child scripts run by the current shell or script. Oddly, builtin
export() silently accepts both list and map types, removing the implied option
`-x` without error. Since this is unhelpful, `zeshy` defines no nonscalar
exported types (e.g., list_global_export(), map_global_export()).

With some effort, this constraint can be circumvented.

==== Circumventing Export Constraints on Lists ====

string_and_list_tied_on_character_global_export() declares both a globally
exported string _and_ a global (but unexported) list whose values are implicitly
``tied'' together. If the script to be sourced declares the list to be exported
via such alias, the parent shell or script sourcing the former script will
successfully import the string tied to such list. If the parent shell or script
then expands string_and_list_tied_on_character_global_export() with the same
string and list names, the desired list from the sourced script will be
successfully imported into the parent shell or script. Since `zsh` internally
manages such importation, this approach should be reasonably efficient. See such
alias for further details.

==== Circumventing Export Constraints on Maps ====

While there exists no corresponding alias
string_and_map_tied_on_character_global_export(), a similar (if slightly
heavier) approach applies reasonably efficiently to maps as well. In the script
to be sourced, manually export a corresponding string as follows:

.Exporting Maps as Strings
==========================================
[source]
------------------------------------------
>>> map on_massive_rapacity; on_massive_rapacity=(
...    "Where" "hunters and woodcutters once slept in their boots by the dying"
...    "light" "of their thousand fires and went on, old teutonic forebears"
...    "with"  "eyes incandesced by the visionary light of a massive rapacity,"
...    "wave"  "on wave of the violent and the insane, their brains stoked with"
...    "spoorless" "analogues of all that was, lean aryans with their abrogate"
...    "semitic"   "chapbook reenacting the dramas and parables therein and"
...    "mindless"  "and pale with a longing that nothing save dark's total"
...    "restitution" "could appease." )
>>> string_global_export ON_TOTAL_RESTITUTION
>>> ON_TOTAL_RESTITUTION="$(join_map_on_string on_massive_rapacity ':')"
------------------------------------------
==========================================

In the parent shell or script sourcing the former script, manually convert such
imported string back into the original map as follows:

.Importing Maps as Strings
==========================================
[source]
------------------------------------------
>>> map on_massive_rapacity
>>> set_map_to_string_split_on_string\
...     on_massive_rapacity "${ON_TOTAL_RESTITUTION}" ':'
>>> print_string "${on_massive_rapacity[Where]}"
hunters and woodcutters once slept in their boots by the dying
------------------------------------------
==========================================
/---

# ....................{ LISTS                              }....................
:alias_command.declare\
    'void :list(string var_name1, ...)'\
    'local -a --' <<'/---'
Declare the passed list variables locally, initialized to the empty list.
/---

#FIXME: Excise after replacing with the prior alias everywhere.
:alias_command.declare\
    'void list(string var_name1, ...)'\
    'local -a --' <<'/---'
Declare
/---

:alias_command.declare\
    'void list_global(string var_name1, ...)'\
    'typeset -ag --' <<'/---'
Declare the passed list variables globally _not_ exported to the calling shell.
See :list() for further details.
/---

# ....................{ LISTS ~ tie                        }....................
# Ideally, this alias would be renamed to list_and_string_tied_on_character().
# However, the arguments of the underlying expansion cannot be reordered to
# accomodate such name. This is the best we can do, we're afraid.
:alias_command.declare\
    'void string_and_list_tied_on_character(
        str string_name,
        str list_name,
        char separator = ":")'\
    'typeset -T --' <<'/---'
Declare the passed string and list ``tied'' on the passed separating character
(defaulting to `:`) locally, overwriting any prior values for either variables
if previously declared. If such string is defined by such declaration with the
customary `=`-delimited initialization, such list is also implicitly defined by
such declaration to coincide with such string; else, such string is initialized
to the empty string and such list to the empty list.

After declaration, `zsh` silently synchronizes the values of the two variables.
Setting or appending such string sets such list to the result of splitting such
string on such separator. Similarly, setting or appending such list sets such
string to the result of joining such list's elements on such separator: e.g.,

.string_and_list_tied_on_character()
==========================================
[source]
------------------------------------------
>>> string_and_list_tied_on_character\
...     ON_WILDNESS="In wildness is the preservation of the world."\
...     on_wildness ' '
>>> print_string "${on_wildness[2]}" "${on_wildness[5]}" "${on_wildness[8]}"
wildness preservation world
>>> on_wildness=( Let us consider the way in which we spend our lives. )
>>> print_string "${ON_WILDNESS}"
Let us consider the way in which we spend our lives.
------------------------------------------
==========================================

== Limitations ==

Callers should take precautions to ensure that list elements _not_ contain the
passed separating character. `zsh` silently fails to escape such characters in
such elements _and_ fails to ignore such characters when explicitly escaped in
such elements, rendering the value of the tied string meaningless if even a
single list element contains a single such character: e.g.,

.string_and_list_tied_on_character()
==========================================
[source]
------------------------------------------
>>> string_and_list_tied_on_character ON_HEAVEN on_heaven ':'
>>> on_heaven=( "/heaven/i:s/home" "/utopia/i:s/here" "/nirvana/is/now." )
>>> print_string "${ON_HEAVEN}"
/heaven/i:s/home:/utopia/i:s/here:/nirvana/is/now.
>>> string_and_list_tied_on_character\
...     ON_HEAVEN='/heaven/i\:s/home:/utopia/i\:s/here:/nirvana/is/now.'\
...     on_heaven ':'
>>> print_string "${on_heaven[1]}\n${on_heaven[2]}\n${on_heaven[3]}"
/heaven/i\
s/home
/utopia/i\
------------------------------------------
==========================================
/---

:alias_command.declare\
    'void string_and_list_global_tied_on_character(
        string string_name, string list_name, character separator = ":")'\
    'typeset -Tg --' <<'/---'
Declare the passed string and list ``tied'' on the passed separating character
(defaulting to `:`) globally, but _not_ exported to the calling shell. See
string_and_list_tied_on_character() for further details.
/---

:alias_command.declare\
    'void string_and_list_global_export_tied_on_character(
        string string_name, string list_name, character separator = ":")'\
    'export -T --' <<'/---'
Declare the passed string and list ``tied'' on the passed separating character
(defaulting to `:`) globally, exporting the string but _not_ list to the calling
shell. See string_and_list_tied_on_character() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
#in such string appears to convert such
#characters to spaces in such elements, rendering the value of the tied list
#equally meaningless: e.g.,

#Such declaration sets such string to the
#empty string and such list to the empty list. Hence, define such string or list only _after_ this
#declaration. If preferred, such string but _not_ list may be initialized by this
#declaration. After declaration, `zsh` implicitly synchronizes the values of the
#two variables as follows:

#FUXME: Actually, it's fairly clear that neither lists or maps can be frozen.
# To perform the latter, consider
#calling freeze_variable() after initializing such list or map after declaring
#such list or map. While cumbersome, `zsh` currently affords no alternatives:
#
#.Read-List
#==========================================
#[source]
#------------------------------------------
#>>> get_string_ansiless_length_printable "${ZESHY_ASCII_NEWLINE}"
#0
#------------------------------------------
#==========================================
#>>> list sequence; sequence=( 'value 1' 'value 2' 'value 3' 'value 4' )
#>>> freeze_variable sequence

#:alias_command.declare <<'/---'
#void list_global_export(string var_name1, string var_name2, ...)
#
#Declare the passed *list* (i.e., sequential array) globally exported to the
#calling shell.
#/---
#alias list_global_export='export -a --'

#:alias_command.declare <<'/---'
#void list_set_global_export(string var_name1, string var_name2, ...)
#
#Declare the passed *list set* (i.e., sequential array ignoring duplicate values)
#globally exported to the calling shell.
#/---
#alias list_set_global_export='export -Ua --'

#FIXME: Rename to list_and_string_tied_on_character() and reorder arguments
#appropriately. The list is usually the first-class object; the string is just
#an innocent (if occasionally useful) bystander.
