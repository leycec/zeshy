#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *integer variable declarators* (i.e., aliases declaring non-fractional
numeric variables).
/---

#FIXME: Rename "integer" to "int".

# ....................{ INTEGERS                           }....................
:declare_alias_simple 'void :int(string variable_name1, ...)'\
    'integer --' <<'/---'
Declare the passed integer variables locally, initialized to the following
`=`-delimited integer if specified or to 0 otherwise.
/---

:declare_alias_simple 'void integer_global(string variable_name1, ...)'\
    'integer -g --' <<'/---'
Declare the passed integer variables globally _not_ exported to the calling
shell. See :int() for further details.
/---

:declare_alias_simple\
    'void integer_global_export(string variable_name1, ...)'\
    'export -i --' <<'/---'
Declare the passed integer variables globally exported to the calling shell.
See :int() for further details.
/---

# ....................{ INTEGERS ~ constant                }....................
:declare_alias_simple\
    'void :int_const(string variable_name1, ...)'\
    'integer -r --' <<'/---'
Declare the passed integer constants locally, defined to the following
`=`-delimited integer if specified or to 0 otherwise. If such constant is
(attempted to be) redefined, an exception is thrown. See :int() for further
details.
/---

:declare_alias_simple\
    'void integer_constant_global_export(string variable_name1, ...)'\
    'export -ir --' <<'/---'
Declare the passed integer constants globally exported to the calling shell.
See :int_const() for further details.
/---

# ....................{ INTEGERS ~ base                    }....................
# Note that "integer" does *NOT* suffice here.
:declare_alias_simple\
    'void integer_in_base(integer base, string variable_name1, ...)'\
    'local -i'  <<'/---'
Declare the passed integer variables locally in the passed base. On expansion,
such integers will be implicitly converted to the equivalent values in such
base. Additionally, if such base is:

* `8`, such integers will be pretty printed in *octal format* and hence:
** Prefixed with a C-style `0`.
* `16`, such integers will be pretty printed in *hexadecimal format* and hence:
** Prefixed with a C-style `0x`.
** Digits in the range [10, 15] will be printed as capitalized letters in the
   range [A, F], per tradition.

See :int() for further details: e.g.,

.integer_in_base()
==========================================
[source]
------------------------------------------
>>> integer_in_base 16 factory_farming=4277009102
>>> print_string    "${factory_farming}"
0xFEEDFACE
------------------------------------------
==========================================
/---

# ....................{ INTEGERS ~ file descriptor         }....................
:declare_alias_simple\
    'void :file_descriptor(string variable_name1, ...)'\
    ':int' <<'/---'
Declare the passed file descriptor variables locally, initialized to the
following `=`-delimited file descriptor if specified or to 0 (i.e., the
canonical file descriptor for standard input) otherwise.
/---

#FIXME: Excise me.
:declare_alias_simple\
    'void file_descriptor(string variable_name1, ...)'\
    'integer' <<'/---'
Declare
/---

:declare_alias_simple\
    'void file_descriptor_global(string variable_name1, ...)'\
    'integer_global' <<'/---'
Declare the passed file descriptor variables globally _not_ exported to the
calling shell. See file_descriptor() for further details.
/---

:declare_alias_simple\
    'void file_descriptor_global_export(string variable_name1, ...)'\
    'integer_global_export' <<'/---'
Declare the passed file descriptor variables globally exported to the calling
shell. See file_descriptor() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
## zsh already provides builtin integer() for declaring local integers.

#FUXME: Theoretically, integers should provide a much more efficient type for
#housing booleans than strings. After all, there's no need for string handling,
#which, to support arbitrarily long strings containing null characters, do not
#cleanly map to C strings and hence require more under-the-scenes handling than
#simple integers (which probably map fairly reasonably to underlying C types).
#In short, testing "(( boolean_variable ))" for the truth of a boolean should be
#significantly faster (aggregated over all such tests) than testing
#"[[ -n ${boolean_variable} ))".
#FUXME: Integers actually make a *VASTLY* preferable core type for implementing
#booleans than strings. Testing integer zeroness or non-zeroness is more
#efficient *AND* readable than the equivalent string emptiness or nonemptiness
#tests. Moreover, it just makes intuitive sense to represent booleans as
#integers constrained to 0 and 1. To effect this change, we'll need to:
#
#* Revise "00-startup/02-constants/boolean".
#* Revise "variable/boolean".
#
#That *SHOULD* be it. But I'm sure everything will break anyway. *sigh*

#boolean duality translates better onto integers
#than strings,
#* `10`, such integers will be converted to *decimal format*, the default format.
#(i.e., non-fractional number) 
