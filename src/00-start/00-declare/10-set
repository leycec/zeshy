#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

# ....................{ SETTERS                            }....................
#FIXME: Call such function elsewhere rather than manually inlining such logic
#everywhere. We should have probably done this *MUCH* sooner.

function :set_string_to_string() {
    # Validate sanity.
    (( # >= 2 )) || :die 'Expected one string name and one or more strings.'
    local string_name__ssts="${1}"

    # If such variable is not a string, throw an exception. See
    # die_unless_string() for further details.
    [[ "${(tP)string_name__ssts-}" == 'scalar'* ]] || :die\
        'Variable ${'${string_name__ssts}'} undefined or not a string.'

    # If only one such string was passed, no concatenation is required. In such
    # case, set such variable via assignment indirection.
    if (( # == 2 )) {
        : "${(P)string_name__ssts::=${2}}"
    # Else, two or more such strings were passed, in which case concatenation
    # is required. Set such variable to the undelimited concatenation of all
    # such strings.
    } else {
        # Shift such variable name from the argument list. See shift_arg() for
        # further details.
        argv[1]=()

        # Locally clear canonical string global ${IFS} (i.e., the internal
        # field separator). Since zsh implicitly delimits strings concatenated
        # with "*" by such global's value, clearing such global guarantees
        # undelimited concatenation. This incantation was surprisingly arduous
        # to unearth. In particular, note that if "*" is *NOT* double-quoted,
        # zsh ignores the value of ${IFS} during concatenation and hence
        # delimits such strings by single spaces. (Ugh.)
        local IFS=

        # Set such string with undelimited concatenation.
        noop "${(P)string_name__ssts::=${*}}"
    }
}

#FIXME: Replace *ALL* calls to run_runnable_with_stdin() with calls to this
#function; then, excise the former.
#FIXME: Document me.

function :set_string_to_declarer_help() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'
    local string_name__sstdh="${1}"

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception. See :is_stdin_readable_sans_blocking() for
    # further details.
    #
    # Since there exists no demonstrable reason to prohibit empty
    # documentation, such exception should ideally only be thrown in the latter
    # case. Unfortunately, differentiating between the two cases is
    # sufficiently non-trivial as to be effectively infeasible this early in
    # digest compilation.
    #
    # Ideally, such cases could be differentiated by either:
    #
    # * Inlining the implementation of :is_stdin_readable_noninteractive()
    #   here (e.g., "not :is_stdin_terminal and :is_stdin_open"). While
    #   inlining the former condition :is_stdin_terminal() would be trivial,
    #   inlining the latter condition :is_stdin_open() would require also
    #   inlining :set_string_to_symlink_target_last() (and all functions such
    #   function transitively calls) and hence be non-trivial.
    # * Inlining the implementation of :is_stdin_here_doc_or_string() here.
    #   Since this would require again inlining
    #   :set_string_to_symlink_target_last() as above, such approach is equally
    #   non-trivial.
    #
    # Given the earliness of this function, we adopt a single-line solution --
    # which, as an unfortunate by-product, prohibits empty documentation.
    read -t 0 || :die\
        'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'

    # Set such string to standard input and hence such documentation. See
    # get_stdin() for further details.
    :set_string_to_string "${string_name__sstdh}" "$(< /dev/stdin)"
}

# ....................{ SETTERS ~ prototype                }....................
function :set_string_to_runnable_prototype_name() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one string name and one runnable prototype.'
    local string_name__sstrpn="${1}" prototype__sstrpn="${2}"
    [[ -n "${prototype__sstrpn}" ]] || :die 'Runnable prototype empty.'

    # If such prototype is syntactically invalid, throw an exception.
    [[ "${prototype__sstrpn}" =~\
        "${ZESHY_PROTOTYPE_RUNNABLE_NAME_PCRE}" ]] || :die\
        'Runnable prototype "'${prototype__sstrpn}'" invalid or declares two or more runnable names.'

    # If such name was *NOT* captured into ${match[1]}, throw an exception.
    (( ${#match} )) || :die\
        'Runnable prototype "'${prototype__sstrpn}'" name uncaptured.'

    # If such name was captured but is empty, throw an exception. (While this
    # *SHOULD* always be the case, forcibly guaranteeing this guards against
    # silent-but-deadly PCRE regressions.)
    [[ -n "${match[1]}" ]] || :die\
        'Runnable prototype "'${prototype__sstrpn}'" name empty.'

    # Set such string to such name.
    :set_string_to_string "${string_name__sstrpn}" "${match[1]}"
}

#FIXME: Since we really don't care terribly much about function and alias
#synonyms, it's likely that we'll no longer require the passed map argument
#*AFTER* implementing the refactorings in @{*-func}. Cut such argument and
#rename to :set_list_to_runnable_prototype_name_or_names().

# void set_list_and_map_to_runnable_prototype_name_or_names:(
#     string list_name,
#     string map_name,
#     string matched_runnable_name,
#     string matched_runnable_names)
function set_list_and_map_to_runnable_prototype_name_or_names: {
    # Validate sanity.
    (( # == 4 )) || :die\
        'Expected one list name, one map name, one matched singular string, and one matched plural string.'
    local\
        list_name__sltrpn="${1}"\
        map_name__sltrpn="${2}"\
        runnable_name__sltrpn="${3}"\
        runnable_names__sltrpn="${4}"

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_list() for further details.
    [[ "${(tP)list_name__sltrpn-}" == 'array'* ]] || :die\
        '${'${list_name__sltrpn}'} undefined or not a list.'
    [[ "${(tP)map_name__sltrpn-}" == 'association'* ]] || :die\
        '${'${map_name__sltrpn}'} undefined or not a map.'

    # If such runnable only has one name...
    if [[ -n "${runnable_name__sltrpn}" ]] {
        eval '
        # If such runnable is already declared, print a warning. See
        # is_map_key() for further details.
        if (( ${+'${map_name__sltrpn}'[${runnable_name__sltrpn}]} )) {
            print "zeshy: ${runnable_name__sltrpn}() in @{${ZESHY_PARCEL_NAME}} already declared." 1>&2
        }

        # Set such list to such name.
        '${list_name__sltrpn}'=( "${runnable_name__sltrpn}" )

        # Add the identity mapping to such map.
        '${map_name__sltrpn}'[${runnable_name__sltrpn}]="${runnable_name__sltrpn}"'
    # Else, such runnable has multiple names. Since single- and double-quoted
    # runnable names may contain commas, such names cannot be split on commas as
    # with runnable attributes elsewhere. Rather, iteratively match such names
    # with a PCRE.
    } else {
        # Prepare to match such names. See for_string_text_matching_pcre:() for further
        # details.
        pcre_compile -- "${ZESHY_PROTOTYPE_RUNNABLE_NAME_NEXT_PCRE}"
        pcre_study

        # Match such names.
        local ZPCRE_OP='0 0'
        eval 'while {
            pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${runnable_names__sltrpn}"
        } {
            # For convenience, store the currently matched name.
            runnable_name__sltrpn="${match[1]}"

            # If such runnable is already declared, print a warning as above.
            if (( ${+'${map_name__sltrpn}'[${runnable_name__sltrpn}]} )) {
                print "zeshy: ${runnable_name__sltrpn}() in @{${ZESHY_PARCEL_NAME}} already declared" 1>&2
            }

            # Append such name to such list.
            '${list_name__sltrpn}'+="${runnable_name__sltrpn}"

            # Map such name to the first such name for such runnable.
            '${map_name__sltrpn}'[${runnable_name__sltrpn}]="${'${list_name__sltrpn}'[1]}"
        }'
    }
}

# ....................{ RUNNERS                            }....................
function run_runnable_with_stdin() {
    # Validate sanity.
    (( # )) || :die 'Expected one runnable name and optional arguments.'
    local runnable_name__rrws="${1}"
    shift

    #FIXME: Improper test, since such test fails when passed the empty string
    #in a valid here-document string, which should (for convenience) succeed.
    #FIXME: Interesting. Under at least Linux, this is testable by noting that
    #"readlink -f /dev/stdin" succeeds and outputs a string resembling
    #"/tmp/zshFtb89B (deleted)". While we *COULD* capture such output and glob
    #for '/tmp/zsh'?*' (deleted)', such approach is both inefficient and overly
    #Linux-specific for such an early-time operation as this. A possibly
    #simpler test is as follows:
    #
    #* If :set_string_to_zsh_temp_prefix() prefixes the output of
    #  "command readlink -f /dev/stdin", standard input is... wait. We wanted
    #  *SIMPLER*. O.K., O.K.; how about just:
    #   * If "/dev/stdin" is a broken symbolic link, assume such link to have
    #     been the product of a here-document or -string, as expected.
    #   * Else implement the contents of :is_stdin_file_simple(), yes?
    #FIXME: No, no, no. *THINK*. What are we trying to accomplish here? This:
    #
    #* If the current process is *NOT* running headless *AND* standard input is
    #  *NOT* attached to a terminal, throw an exception. (Since, in such case,
    #  attempting to read from standard input is guaranteed to be terrible.)
    #
    #Happily, such test is both efficient and simple:
    #
    #{ (( ${+TERM} )) && ! [[ -t 0 ]] } || die 'Standard input empty.'
    #
    #Wait. Obviously, this reduces to the even simpler test:
    #
    #if [[ -t 0 ]] {
    #    die 'Documented not passed on standard input.'
    #}
    #
    #Wait. Insufficient. This suffices if the current process is *NOT*
    #headless. But what if it is? Then we just need to test whether standard
    #input is open or not. This is readily cross-platform-portable, as currently
    #implemented by get_file_descriptor_file_device().
    #FIXME: Hm; wait. Testing whether standard input is open or not is actually
    #non-trivial, as such function attests. The simplest solution then will be
    #to test whether standard input is a here-document or -string. This is
    #somewhat more confined than we would like, but... well, there's really no
    #sane alternative. That said, even testing this is non-trivial, as it
    #requires obtaining the transitive target of such file descriptor.
    #FIXME: Oh, *SCREW IT.* The current implementation is basically the only
    #sane implementation. We'll need to document why, of course. See above!

    # If standard input is empty, throw an exception. See
    # :is_stdin_readable_sans_blocking() for further details.
    read -t 0 || die 'Standard input empty.'

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${runnable_name__rrws}" &>/dev/null ||
        die "runnable \"${runnable_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${runnable_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Document this parcel and all runnables such parcel declares.

    # If such variable is not a string, throw an exception. See
    # die_unless_string() for further details.
    # [[ "${(tP)string_name__sstdh-}" == 'scalar'* ]] || :die\
    #     'Variable ${'${string_name__sstdh}'} undefined or not a string.'

    # If standard input is attached to an interactive terminal, throw an
    # exception. (While the prior test should ensure this, one can never be too
    # sure. Since we close such input below, it's critical we only close non-
    # interactive input.)
    # if [[ -t 0 ]] {
    #     die 'Standard input attached to an interactive terminal.'
    # }
    # # Close standard input. See close_stdin() for further details.
    # exec 0<&-

    # If standard input is either the empty string *OR* unreadable
    # If at least one byte of standard input is readable without blocking, throw an exception. See
