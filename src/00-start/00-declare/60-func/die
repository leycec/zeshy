#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *function declarer exception handlers* (i.e., functions throwing
exceptions resulting from validation errors in declared functions).
/---

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under @{help} in the main codebase.

# ....................{ EXCEPTIONS ~ cause                 }....................
:func.document <<'/---'
:void ::func_.die_of_cause(:string exception_message)

Throw an exception with the passed message, presumably detailing a syntactic or
semantic error in the currently declared function prototype. This private
exception handler is intended to be called _only_ by ::func_.stop().

== Message Format ==

For convenience, such message is expected to be a lowercase sentence fragment:

* Prefixed by `Function ${func_name}() `, where `${func_name}` is the first
  function name such prototype declares. (For simplicity, any subsequent
  function name such prototype declares is currently ignored.)
* Suffixed by such prototype.
/---
function ::func_.die_of_cause() {
    (( # == 1 )) || :die 'Expected one exception message.'
    :die 'Function '${ZESHY__FUNC_NAMES[1]}'()'$(::parcel.get_preposition)' '${1}$':\n\n'${ZESHY__FUNC_PROTOTYPE}
}

# ....................{ EXCEPTIONS ~ cause : type          }....................
:func.document <<'/---'
:void ::func_.die_of_cause_arg_type(:string exception_message)

Throw an exception with the passed message, presumably detailing a syntactic or
semantic error in the currently parsed argument type in the currently declared
function prototype. This private exception handler is intended to be called
_only_ by ::func_.stop().
/---
function ::func_.die_of_cause_arg_type() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one exception message.'
    local arg_name arg_type

    # Such argument's current name and type.
    ::func_.set_arg_name arg_name
    ::func_.set_arg_type arg_type

    # Throw such exception.
    ::func_.die_of_cause 'argument ${'${arg_name}'} type '${arg_type}' '${1}
}

:func.document <<'/---'
:void ::func_.die_of_cause_arg_type_direct(:string exception_message)

Throw an exception with the passed message, presumably detailing a semantic error in the currently parsed argument type in the currently declared
function prototype correctable by revising such argument to refer to a variable
by name. This private exception handler is intended to be called _only_ by
::func_.stop().
/---
function ::func_.die_of_cause_arg_type_direct() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one exception message.'
    local arg_type_source arg_type_target

    # Such argument's current type.
    ::func_.set_arg_type arg_type_source

    # If such argument has a major subtype of "var", the caller guaranteed such
    # argument to also have a minor subtype. Recommend such argument be
    # refactored to refer to a variable of such minor subtype prefixed by ":"
    # (e.g., from ":string/var+int" to "^:int").
    if [[ ${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]} == 'var' ]] {
        # If such argument has a minor subtype (declaring the type of the
        # variable referred to), such type is truncatable with "^". Do so.
        if [[ -n ${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]} ]] {
            arg_type_target='^:'${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}
        # Else, such argument refers to variables of any type and hence must be
        # refactored as follows.
        } else {
            arg_type_target=':string/var'
        }
    # Else, recommend such argument be refactored to refer to a variable of
    # such argument's local subtype (e.g., from ":list" to "^:list").
    } else {
        arg_type_target='^'${ZESHY__FUNC_ARG_SUBTYPE_LOCAL}

        # If such argument has a minor subtype, append such type.
        if [[ -n ${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]} ]] {
            arg_type_target+='+'${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}
        }
    }

    # Throw an exception reflecting such argument's current type.
    ::func_.die_of_cause_arg_type\
        ${1}'; consider refactoring such argument into a string referring to a variable via type indirection (e.g., from "'${arg_type_source}'" to "'${arg_type_target}'")'
}

# ....................{ EXCEPTIONS ~ cause : variadic      }....................
:func.document <<'/---'
:void ::func_.die_of_cause_arg_variadic(:string exception_message)

Throw an exception with the passed message, presumably detailing a semantic
error in the variadicity of the currently parsed argument in the currently
declared function prototype. This private exception handler is intended to be
called _only_ by ::func_.stop().
/---
function ::func_.die_of_cause_arg_variadic() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one exception message.'
    local arg_name_source arg_name_target arg_type_source arg_type_target

    # Such argument's current name and type.
    ::func_.set_arg_name arg_name_source
    ::func_.set_arg_type arg_type_source

    # Argument type and name to recommend such argument be refactored as,
    # stripping all suffixing digits from such name.  Dismantled, this is:
    #
    # * "%%", greedily removing the longest matching suffix.
    # * "<->##", matching one or more digits.
    arg_type_target='^:list'
    arg_name_target=${arg_name_source%%<->##}

    # If such argument is mandatory, constrain such list to be non-empty.
    if (( ! arg_is_optional )) {
        arg_type_target+='+nonempty'
    }

    # Throw an exception reflecting such argument's current type and name.
    ::func_.die_of_cause\
        ${1}'; consider converting the variadic argument list beginning with argument ${'${arg_name_source}'} into a string indirectly referring to a list (e.g., from "'${arg_type_source}' '${arg_name_source}', ..." to "'${arg_type_target}' '${arg_name_target}'"'
}

# ....................{ EXCEPTIONS ~ arg count             }....................
:func.document <<'/---'
:void ::func.die_of_arg_count_not_equaling(
    :string func_arg1?, ...,
    :int+nonnegative func_arg_count_expected)

Throw an exception due to the passed argument list (presumably, the same list
passed to the calling function) _not_ containing the passed number of arguments
(presumably, required by such function's prototype). This private exception
handler is intended to be programmatically prefixed to function bodies _only_
by ::func_.stop().
/---
function ::func.die_of_arg_count_not_equaling() {
    (( # )) || :die\
        'Expected one or more arguments and one expected argument count.'
    ::func.die_of_arg_count "${@[1,-2]}"\
        "${@[-1]} arguments but received ${#@[1,-2]}"
}

:func.document <<'/---'
:void ::func.die_of_arg_count_not_exceeding(
    :string func_arg1?, ...,
    :int+nonnegative func_arg_count_min)

Throw an exception due to the passed argument list (presumably, the same list
passed to the calling function) _not_ containing at least the passed number of
arguments (presumably, required by such function's prototype). This private
exception handler is intended to be programmatically prefixed to function
bodies _only_ by ::func_.stop().
/---
function ::func.die_of_arg_count_not_exceeding() {
    (( # )) || :die\
        'Expected one or more arguments, one actual argument count, and one minimum argument count.'
    ::func.die_of_arg_count "${@[1,-3]}"\
        "at least ${@[-1]} arguments but received only ${#@[1,-2]}"
}

:func.document <<'/---'
:void ::func.die_of_arg_count_not_ranging(
    :string func_arg1?, ...,
    :int+nonnegative func_arg_count_min,
    :int+nonnegative func_arg_count_max,)

Throw an exception due to the passed argument list (presumably, the same list
passed to the calling function) containing fewer than the passed minimum number
of arguments or more than the passed maximum number of arguments (presumably,
required by such function's prototype). This private exception handler is
intended to be programmatically prefixed to function bodies _only_ by
::func_.stop().
/---
function ::func.die_of_arg_count_not_ranging() {
    (( # >= 2 )) || :die\
        'Expected one or more arguments, one minimum argument count, and one maximum argument count.'
    ::func.die_of_arg_count "${@[1,-3]}"\
        "between ${@[-2]} and ${@[-1]} arguments but received ${#@[1,-3]}"
}

:func.document <<'/---'
:void ::func.die_of_arg_count(
    :string func_arg1?, ...,
    :string exception_message)

Throw an exception due to the passed argument list (presumably, the same list
passed to the calling function) containing an unexpected number of arguments
detailed by the passed exception message. This private exception handler is
intended to be called _only_ by higher-level argument count exception handlers
(e.g., ::func.die_of_arg_count_not_equaling()).
/---
function ::func.die_of_arg_count() {
    # Validate sanity.
    (( # >= 1 )) || :die\
        'Expected zero or more arguments and one exception message.'
    local exception_message="${@[-1]}" func_name func_prototype
    (( ${#funcstack} >= 3 )) || :die 'Called directly from the command line.'

    # Such function's name.
    func_name=${funcstack[3]}

    # Such function's prototype.
    :func.set_prototype "${func_name}" func_prototype

    # Throw such exception message, appropriately prefixed and suffixed.
    :die 'Function '${func_name}'() expected '${exception_message}'.'$'\n\n''Function prototype:'$'\n'${func_prototype}$'\n\n''Arguments passed:'$'\n'${(qq)@[1,-2]}
}

# ....................{ EXCEPTIONS ~ arg type              }....................
:func.document <<'/---'
:void ::func.die_unless_arg_expansions_pass_tester(
    :string func_arg1, ...,
    :string func_arg_expansions,
    :string/func tester_name)

Throw an exception unless the passed function reports success when passed the
subset of passed arguments (presumably, the same arguments passed to the
calling function) indicated by the passed space-delimited string of argument
expansions (e.g., `"${1}" "${@[-2]}"`, indicating only the first and
second-to-last arguments to be passed to the passed function). While arguably
awkward, such calling conventions abstract and hence simplify exception
handling of erroneous arguments in the calling function.

== Function Prototype ==

This exception handler expects the passed function to be prototyped as follows:
`[status = :bool] ${tester_name}(${arg_type} arg1, ...)`, where `${arg_type}`
is the argument type expected by such function (e.g., `:string`).
/---
function ::func.die_unless_arg_expansions_pass_tester() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more arguments, one argument indices string, and one type tester function name.'
    local\
        arg_indices_string="${@[-2]}"\
        arg_tester_name="${@[-1]}"\
        arg_value\
        error_message\
        func_prototype

    # Pop such arguments off. See pop_args_2() for further details.
    argv[-2,-1]=()

    # Validate sanity.
    :func.die_unless "${arg_tester_name}"
    (( ${#funcstack} >= 2 )) || :die 'Called directly from the command line.'

    # List of all argument indices to be tested. While the passed space-
    # delimited string contains only "@["- and "]"-delimited integers and
    # innteger ranges, this list contains only actual integers.
    local -a arg_indices

    # Such function's prototype.
    :func.set_prototype "${func_name}" func_prototype

    # Convert such space-delimited string to such list.
    local arg_index_string arg_index_min arg_index_max
    for   arg_index_string (${(z)arg_indices_string}) {
        # Strip such string of "${@[" and "]}" delimiters.
        arg_index_string="${${arg_index#\$\{@\[}%]\}}"

        # If the result is comma-separated, such result signifies a range of
        # argument indices.
        if [[ "${arg_index_string}" == (#b)([^,]##),(*) ]] {
            # Capture such bounds from such string.
            arg_index_min=${match[1]}
            arg_index_max=${match[2]}

            #FIXME: Shift such function to ={*-test/var}.
            :int.die_unless "${arg_index_min}" "${arg_index_max}"

            # If such upper bound is a negative index, convert such bound into
            # a positive index to ensure the enumeration below behaves sanely.
            if (( arg_index_max < 0 )) {
                arg_index_max=$(( # + arg_index_max + 1 ))
            }

            # Append all such indices to such list.
            arg_indices+=( {${arg_index_min}..${arg_index_max}} )
        # Else, such result is a single index. Append such index to such list.
        } else {
            :int.die_unless "${arg_index_string}"
            arg_indices+=${arg_index_string}
        }
    }

    # Iterate arguments by index until finding the first failing argument.
    # Such indices encompass both index ranges (e.g., "@[3,-1]") and negative
    # indices (e.g., "@[-1]" and hence are *NOT* strictly integers.
    local arg_index
    for   arg_index ("${arg_indices}") {
        # If such argument index is not an integer *OR* is not a valid index
        # for the passed argument list, throw an exception. Curiously,
        # attempting the latter test with "@" rather than "argv" results in a
        # parse error of "zsh: bad substitution". *shrug*
        :die_unless_int "${arg_index}"
        (( ${+argv[${arg_index}]} )) || :die\
            'Argument '${arg_index}' referenced, but only '${#}' arguments passed.'

        # Value of such argument.
        arg_value="${@[${arg_index}]}"

        # Test such value.
        "${arg_tester_name}" "${arg_value}" || {
            # Start such exception message.
            error_message='Function '${funcstack[2]}'() expected argument '${arg_index}' '

            # If such tester tests variable types rather than variable values,
            # tailor such exception message to the former.
            if [[ "${arg_tester_name}" == (#b)':var.is_type_'(*) ]] {
                # Continue such message.
                error_message+='to reference variable of type :'${match[1]}', but variable ${'${arg_value}'} '

                #FIXME: The type printed above is a high-level zeshy-specific type;
                #The type printed below is a low-level zsh-specific type.
                #Naturally, the latter should be converted to the former; this
                #will probably require a map from zsh- to zeshy-specific types.

                # If such variable exists, such variable cannot be of the
                # expected type. Tailor such message. See :var.is().
                if (( ${+parameters[${arg_value}]} )) {
                    error_message+='is of type "'${(tP)arg_value}'".'
                # Else, such variable does not exist. Tailor such message.
                } else {
                    error_message+='not found.'
                }
            # ELse if such tester tests variable values, tailor such message.
            } elif [[ "${arg_tester_name}" == (#b)':'([^.]##)'.is'('_'*|) ]] {
                # Such argument's type, reconstructed from such tester name.
                # Specifically, assume the "."-prefixed portion of such name to
                # supply the major subtype such argument was prototyped with.
                local arg_type=${match[1]}

                # If such tester name implies such argument to have been
                # prototyped with a minor subtype, append such subtype.
                if [[ -n ${match[2]} ]] {
                    arg_type+='/'${match[2]}
                }

                # Tailor such message to such argument's type and value.
                error_message+='of type "'${arg_type}'" but received:'$'\n'${arg_value}
            # Else such function is of unexpected form. Throw an exception.
            } else {
                :die 'Argument tester function '${arg_tester_name}'() unrecognized (i.e., name unmatched by glob ":*.is*").'
            }

            # Throw such exception, suffixed by such function prototype.
            :die ${error_message}$'\n\n''Function prototype:'$'\n'${func_prototype}
        }
    }
}

# ....................{ SETTERS                            }....................
#FIXME: Rename to ::func.set_arg_type_prototype().
:func.document <<'/---'
:void ::func_.set_arg_type(^:string arg_type)

Set the passed string variable to the the current argument's *full type* (i.e.,
`/`- and `+`-delimited concatenation of such argument's subtypes and related
syntactic constructs) as declared by the current function prototype (e.g.,
`:string/var+scalar` for an argument with local, major, and minor subtypes
`:string`, `var`, and `scalar`). This private setter is intended to be called
_only_ by exception handlers called by ::func_.stop().
/---
function ::func_.set_arg_type() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'
    local arg_type_name__fsat=${1} arg_type__fsat

    # Obtain such type from such subtypes.
    arg_type__fsat=${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE_IS_INDIRECT}]}${ZESHY__FUNC_ARG_SUBTYPE_LOCAL}
    if [[ -n ${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]} ]] {
        arg_type__fsat+='/'${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MAJOR}]}
    }
    if [[ -n ${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]} ]] {
        arg_type__fsat+='/'${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_SUBTYPE_MINOR}]}
    }

    # Set such type.
    :string.set "${arg_type_name__fsat}" "${arg_type__fsat}"
}

#FIXME: Rename to ::func.set_arg_name_prototype().
:func.document <<'/---'
:void ::func_.set_arg_name(^:string arg_name)

Set the passed string variable to the current argument's *full name* (i.e.,
`+`-delimited concatenation of such argument's mandatory name and optional name
suffix) as declared by the current function prototype (e.g., `trinity+test` for
an argument with name `trinity` and name suffix `test`). This private setter is
intended to be called _only_ by exception handlers called by ::func_.stop().
/---
function ::func_.set_arg_name() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'
    local arg_name_name__fsan=${1} arg_name__fsan

    # Obtain such name from such subnames.
    arg_name__fsan=${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME}]}
    if [[ -n ${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME_SUFFIX}]} ]] {
        arg_name__fsan+='+'${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME_SUFFIX}]}
    }

    # Set such name.
    :string.set "${arg_name_name__fsan}" "${arg_name__fsan}"
}

# --------------------( WASTELANDS                         )--------------------
            # } else {
            #     # Such argument's current type.
            #     local arg_type
            #     ::func_.set_arg_type arg_type

            # } elif [[ "${arg_tester_name}" == (#b)(':'[^.]##)'.is'('_'*|) ]] {
            #     error_message+='of type '${match[1]}' but received:'$'\n'${arg_value}

# into such argument's original type
# string, as matched by the current PCRE-based iteration (e.g., from local,
# major, and minor subtypes `:string`, `var`, and `scalar` to original type
# string `:string/var+scalar). This private setter is intended to be called
# _only_ by exception handlers called by ::func_.stop().

                    # error_message+='is of type '${(tP)arg_value}' and value:'$'\n'${(P)arg_value}

# the `+`-delimited concatenation of the
# current argument's mandatory name and optional name suffix (if any), as matched
# by the current PCRE-based iteration (e.g., from name `trinity` and suffix
# `test` to `trinity+test`). Such concatenation reconstructs such argument's
# original name as declared by the current function's prototype. This private
# setter is intended to be called _only_ by exception handlers called by
# ::func_.stop().

                # if { :var.is } {
    # arg_name_source=${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_NAME}]}
    #FUXME: Such local references are now broken due to recent optimizations.
    #Repair, please.

    # local arg_type_target='*'

    # # If such argument has a major subtype of "var", the caller guaranteed such
    # # argument to also have a minor subtype. Recommend such argument be
    # # refactored to refer to a variable of such minor subtype prefixed by ":"
    # # (e.g., from ":float/var+int" to "*:int").
    # if [[ "${arg_subtype_major}" == 'var' ]] {
    #     arg_type_target+=':'${arg_subtype_minor}

    # Argument type to recommend such argument be refactored as.

        # 'argument ${'${arg_name}'} type '${match[${ZESHY_RUNNABLE_PROTOTYPE_ARG_MATCH_INDEX_TYPE}]}' '${1}
#FUXME: Consider renaming to merely ::func_.die_of_cause().

#invalid, as 
#     local arg_type_label=${arg_type}
# 
#     # If such argument is subtyped, append such label by such types.
# [[ -z "${arg_subtype}" ]] || print -r -- '+'${arg_subtype}
# 
#     ::func_.die_of_cause\
#         'argument ${'${arg_name}'} type '${arg_type_label}' invalid, as '${1}

#FUXME: Consider renaming to merely ::func_.die_of(). Indeed, we can profitably
#drop the redundant "_cause" elsewhere. Exception handlers leverage somewhat
#different nomenclature than the remainder of the codebase -- and that's good.
#In the case of *.die_of*() handlers, the preposition "of" already implies such
#function to accept an exception message; so, we needn't ever state that.
#Indeed, attempting to add "_cause" induces trouble. As example, which would we
#prefer: ::func_.die_of_arg_type_cause() or ::func_.die_of_cause_arg_type()?
#For orthogonality, probably the latter; 

            # If either such string is not an integer, throw an exception.

#FUXME: Why pass the actual argument count? Since we also pass the argument
#list, we already know such argument count. Refactor. Simplify.

    # :int_nonnegative func_arg_count_actual,

# Throw an exception due to the passed argument list (ideally, the same list
# passed to the calling function) _not_ containing exactly as many arguments as
# required by such function's prototype. This private exception handler is
# intended to be programmatically prepended onto function bodies _only_ by
# ::func_.stop() and cohorts.
