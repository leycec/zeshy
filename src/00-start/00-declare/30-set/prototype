#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

# Due to chicken-and-the-egg conundra, all operables defined below are
# subsequently documented under ={help} in the main codebase.

# ....................{ SETTERS ~ alias                    }....................
#FIXME: Document me.

# void :alias_prototype.set_name(
#     :string alias_prototype, ^:string string_name)
function :alias_prototype.set_name() {
    (( # == 2 )) || :die 'Expected one alias prototype and one string name.'
    ::callable_prototype_of_label.set_name "${1}" 'Alias' "${2}"
}

#FIXME: Document me.

# :void :alias_prototype.set_attrs,names(
#     :string alias_prototype,
#     ^:map attrs_name,
#     ^:list names_name)
function :alias_prototype.set_attrs,names() {
    (( # == 3 )) || :die\
        'Expected one alias prototype, one map name, and one list name.'
    ::callable_prototype_of_label.set_attrs,names
        "${1}" 'Alias' "${2}" "${3}"
}

# ....................{ SETTERS ~ func                     }....................
#FIXME: Document me.

# :void :func_prototype.set_name(
#     :string func_prototype, ^:string string_name)
function :func.set_prototype_name() {
    (( # == 2 )) || :die 'Expected one function prototype and one string name.'
    ::callable_prototype_of_label.set_name_of_label "${1}" 'Function' "${2}"
}

# ....................{ SETTERS ~ global                   }....................
#FIXME: Document me.

# :void :global_prototype.set_names(
#     :string global_prototype, ^:list list_name)
function :global_prototype.set_names() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one global prototype and one list name.'
    local\
        global_prototype__sltgpn="${1}"\
        global_names_name__sltgpn="${2}"\
        global_names_and_optional_value__sltgpn\
        placeholder__sltgpn

    # Strip the prefixing type (prefixed by optional whitespace and suffixed by
    # mandatory spaces) from such prototype, thus leaving only the "="-
    # delimited string of one or more global names and optional value required
    # by the call below. Dismantled, this is:
    #
    # * "[[:space:]]#", matching optional prefixing whitespace.
    # * "[^ ]##", matching such type.
    # * " ##", matching one or more mandatory suffixing spaces.
    global_names_and_optional_value__sltgpn="${global_prototype__sltgpn#[[:space:]]#[^ ]## ##}"

    # Parse such global names from such prototype. To centralize logic, also
    # parse such global value despite the caller not requesting such value --
    # which we then promptly discard.
    :set_list,string,bool_to_global_names,value,is_value\
        "${global_names_name__sltgpn}"\
        placeholder__sltgpn\
        placeholder__sltgpn\
        "${global_names_and_optional_value__sltgpn}"
}

#FIXME: Refactor to :global_prototype.set_names,value,is_value().
#FIXME: Actually, this function should simply be inlined into ={global}. Note
#that, after doing so, we may dutifully shift :int.set() back to ={*-main}.
#FIXME: Document me.

#void :set_list,string,bool_to_global_names,value,is_value(
#    string global_names_list_name,
#    string global_value_string_name,
#    string global_is_value_bool_name,
#    string global_names_and_optional_value)
function :set_list,string,bool_to_global_names,value,is_value() {
    # Validate sanity.
    (( # == 4 )) || :die\
        'Expected one list name, one string name, one boolean name, and one "="-delimited string of one or more global names and optional value.'
    local\
        global_names_list_name__slsbtgnviv="${1}"\
        global_value_string_name__slsbtgnviv="${2}"\
        global_is_value_bool_name__slsbtgnviv="${3}"\
        global_names_and_value__slsbtgnviv="${4}"
    :var.die_unless_type_list "${global_names_list_name__slsbtgnviv}"
    [[ -n "${global_names_and_value__slsbtgnviv}" ]] || :die\
        'Global names (and optional value) empty.'

    # If such prototype is syntactically invalid, throw an exception.
    [[ ${global_names_and_value__slsbtgnviv} =~\
       ${ZESHY_GLOBAL_PROTOTYPE_PCRE} ]] || :die\
        'Global declaration'$(::parcel.get_preposition)' invalid:'$'\n'${global_names_and_value__slsbtgnviv}

    # If such match failed to capture such global's names, throw an exception.
    (( ${#match} )) || :die\
        'Global names unparsable from prototype:'$'\n'${global_names_and_value__slsbtgnviv}

    # If such prototype only declares one name, set such list to such name. See
    # :list.set_to_string().
    if [[ -n "${match[1]}" ]] {
        set -A ${global_names_list_name__slsbtgnviv} "${match[1]}"
    # Else, such prototype declares multiple equal signs-delimited names.
    # Unlike runnable prototype names, such names are prohibited from
    # containing equals signs and hence may be efficiently split on such.
    } else {
        # If such match failed to capture such names, throw an exception.
        (( ${#match} >= 2 )) || :die\
            'Global names unparsable from prototype:'$'\n'${global_names_and_value__slsbtgnviv}

        # Set such list to such names split on equals signs. See
        # :list.set_to_string_split_on_string().
        set -A ${global_names_list_name__slsbtgnviv} "${(s:=:)match[2]}"
    }

    # If such value is defined, set such value and set such boolean to true.
    if (( ${#match} == 3 )) {
        :string.set\
            "${global_type_string_name__slsbtgnviv}" "${match[3]}"
        :int.set\
            "${global_is_value_bool_name__slsbtgnviv}" 1
    # Else, set such boolean to false.
    } else {
        :int.set\
            "${global_is_value_bool_name__slsbtgnviv}" 0
    }
}

# ....................{ SETTERS ~ callable                 }....................
# See ={*-func/begin} for related parsing logic.

# :void ::callable_prototype_of_label.set_name(
#     :string callable_prototype,
#     :string callable_label,
#     ^:string string_name)
function ::callable_prototype_of_label.set_name() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one callable prototype, one callable label, and one string name.'
    local\
        prototype__cpsnol="${1}"\
        string_name__cpsnol="${2}"\
        label__cpsnol="${3}"

    # If such prototype is syntactically invalid or declares more than a single
    # runnable name, throw an exception.
    [[ ${prototype__cpsnol} =~\
       ${ZESHY_RUNNABLE_PROTOTYPE_NAME_PCRE} ]] || :die\
        ${label__cpsnol}' prototype'$(::parcel.get_preposition)' invalid or declares two or more '${(L)label__cpsnol}' names:'${prototype__cpsnol}

    # If such match failed to capture such name, throw an exception.
    (( ${#match} )) || :die\
        ${label__cpsnol}' name unparsable from prototype:'$'\n\n'${prototype__cpsnol}

    # Set such string to such name.
    :string.set "${string_name__cpsnol}" "${match[1]}"
}

#FIXME: Document me.

# :void ::callable_prototype_of_label.set_names(
#     :string callable_prototype,
#     :string callable_label,
#     ^:list names_name)
function ::callable_prototype_of_label.set_names() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one callable prototype, one callable label, and one list name.'
    local\
        prototype__cpolsn="${1}"\
        label__cpolsn="${2}"\
        names_name__cpolsn="${3}"
    :var.die_unless_type_list "${names_name__cpolsn}"

    # If such prototype is syntactically invalid, throw an exception.
    [[ ${prototype__cpolsn} =~\
       ${ZESHY_RUNNABLE_PROTOTYPE_NAMES_PCRE} ]] || :die\
        ${label__cpolsn}' prototype'$(::parcel.get_preposition)' invalid:'${prototype__cpolsn}

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with ::callable_prototype_of_label.set_attrs,names().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # If such prototype only specifies one name, set such list to such name.
    if [[ -n ${match[1]-} ]] {
        # Set such list. See :list.set_to_string().
        set -A ${names_name__cpolsn} "${match[1]}"
    # Else, such prototype specifies multiple comma-delimited names. Since
    # single- and double-quoted callable names may contain commas, such names
    # must be iteratively matched with a PCRE rather than split on commas.
    } else {
        local names__cpolsn names_item__cpolsn

        # Index of the current non-existent list item to be appended.
        integer names_index__cpolsn=1

        # If such match failed to capture such names, throw an exception.
        (( ${#match} == 2 )) || :die\
            ${label__cpolsn}' names unparsable from prototype:'$'\n\n'${prototype__cpolsn}

        # Comma-delimited string of such names, cached here to permit canonical
        # list global ${match} to be reused for iteration below.
        names__cpolsn="${match[2]}"

        # Clear such list. See :list.clear() for further details.
        set -A ${names_name__cpolsn}

        pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"

        # Match and append each such name to such list by indirection like that
        # above. (An eval() statement would also suffice, if less efficiently.)
        local ZPCRE_OP='0 0'
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names__cpolsn}" } {
            names_item__cpolsn=${names_name__cpolsn}'['$(( names_index__cpolsn++ ))']'
            : "${(P)names_item__cpolsn::=${match[1]}}"
        }
    }
}

#FIXME: Document me.

# :void ::callable_prototype_of_label.set_attrs,names(
#     :string callable_prototype,
#     :string callable_label,
#     ^:map attrs_name,
#     ^:list names_name)
function ::callable_prototype_of_label.set_attrs,names() {
    # Validate sanity.
    (( # == 4 )) || :die\
        'Expected one callable prototype, one callable label, one map name, and one list name.'
    local\
        prototype__cpolsan="${1}"\
        label__cpolsan="${2}"\
        attrs_name__cpolsan="${3}"\
        names_name__cpolsan="${4}"
    local -a match__cpolsan
    :var.die_unless_type_map  "${attrs_name__cpolsan}"
    :var.die_unless_type_list "${names_name__cpolsan}"

    # Canonical string global ${ZPCRE_OP}, localized to avoid overwriting
    # either global or caller-specific versions of such variable.
    local ZPCRE_OP

    # If such prototype is syntactically invalid, throw an exception.
    [[ ${prototype__cpolsan} =~\
       ${ZESHY_RUNNABLE_PROTOTYPE_ATTRS_NAMES_PCRE} ]] || :die\
        ${label__cpolsan}' prototype'$(::parcel.get_preposition)' invalid:'${prototype__cpolsan}

    # Preserve such matches *BEFORE* matching attributes and hence overwriting
    # canonical list global ${match}.
    match__cpolsan=( "${match[@]}" )
    # integer i__cpolsan; print -r "match prototype: ${prototype__cpolsan}"; for i__cpolsan ({1..${#match}}) { print -r "match ${i__cpolsan}: ${match[${i__cpolsan}]}" }

    # If such prototype specifies at least one attribute, parse such attributes
    # and optional suffixing values into such map. Since single- and
    # double-quoted values may contain commas, such attributes must be
    # iteratively matched with a PCRE rather than split on commas.
    if [[ -n ${match__cpolsan[1]} ]] {
        # Validate sanity.
        local attrs_key__cpolsan

        # Compile such PCRE. For efficiency, avoid optionally optimizing such
        # PCRE by calling pcre_study(). (Ad-hoc profiling suggests such
        # optimization to consume more time than it saves.) See
        # for_string_text_matching_pcre:() for further details.
        pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_ATTRS_NEXT_PCRE}"

        # Match and add each such attribute to such map.
        ZPCRE_OP='0 0'
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${match__cpolsan[1]}" } {
            # Map the current attribute to the colon-prefixed value suffixing
            # such attribute if such attribute is suffixed by such a value or
            # to the empty string otherwise. Such indirection is required by
            # zsh setting arbitrary map keys outside of eval() statements. (An
            # eval() statement would also suffice here, if less efficiently.)
            # See :set_map_key_to_string() for further details.
            attrs_key__cpolsan="${attrs_name__cpolsan}[${match[1]}]"
            : "${(P)attrs_key__cpolsan::=${match[2]-}}"
        }
    }

    # If such prototype only specifies one name, set such list to such name.
    if [[ -n ${match__cpolsan[2]-} ]] {
        # If such match failed to capture such name, throw an exception.
        (( ${#match} == 2 )) || :die\
            ${label__cpolsan}' names unparsable from prototype:'$'\n\n'${prototype__cpolsan}

        # Set such list. See :list.set_to_string().
        set -A ${names_name__cpolsan} "${match__cpolsan[2]}"
    # Else, such prototype specifies multiple comma-delimited names. Since
    # single- and double-quoted callable names may contain commas, such names
    # must be iteratively matched with a PCRE rather than split on commas.
    } else {
        local names_item__cpolsan

        # Index of the current non-existent list item to be appended.
        integer names_index__cpolsan=1

        # If such match failed to capture such names, throw an exception.
        (( ${#match__cpolsan} == 3 )) || :die\
            ${label__cpolsan}' names unparsable from prototype:'$'\n\n'${prototype__cpolsan}

        # Clear such list. See :list.clear() for further details.
        set -A ${names_name__cpolsan}

        # Match and append each such name to such list by indirection like that
        # above. (An eval() statement would also suffice, if less efficiently.)
        pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
        ZPCRE_OP='0 0'
        while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${match__cpolsan[3]}" } {
            names_item__cpolsan=${names_name__cpolsan}'['$(( names_index__cpolsan++ ))']'
            : "${(P)names_item__cpolsan::=${match[1]}}"
        }
    }
}

# ....................{ OBSOLETE                           }....................
#FIXME: Everything below should be excised after completing all refactorings in
#this parent parcel.

function run_runnable_with_stdin() {
    # Validate sanity.
    (( # )) || :die 'Expected one runnable name and optional arguments.'
    local runnable_name__rrws="${1}"
    shift

    #FIXME: Improper test, since such test fails when passed the empty string
    #in a valid here-document string, which should (for convenience) succeed.
    #FIXME: Interesting. Under at least Linux, this is testable by noting that
    #"readlink -f /dev/stdin" succeeds and outputs a string resembling
    #"/tmp/zshFtb89B (deleted)". While we *COULD* capture such output and glob
    #for '/tmp/zsh'?*' (deleted)', such approach is both inefficient and overly
    #Linux-specific for such an early-time operation as this. A possibly
    #simpler test is as follows:
    #
    #* If :set_string_to_zsh_temp_prefix() prefixes the output of
    #  "command readlink -f /dev/stdin", standard input is... wait. We wanted
    #  *SIMPLER*. O.K., O.K.; how about just:
    #   * If "/dev/stdin" is a broken symbolic link, assume such link to have
    #     been the product of a here-document or -string, as expected.
    #   * Else implement the contents of :is_stdin_file_simple(), yes?
    #FIXME: No, no, no. *THINK*. What are we trying to accomplish here? This:
    #
    #* If the current process is *NOT* running headless *AND* standard input is
    #  *NOT* attached to a terminal, throw an exception. (Since, in such case,
    #  attempting to read from standard input is guaranteed to be terrible.)
    #
    #Happily, such test is both efficient and simple:
    #
    #{ (( ${+TERM} )) && ! [[ -t 0 ]] } || die 'Standard input empty.'
    #
    #Wait. Obviously, this reduces to the even simpler test:
    #
    #if [[ -t 0 ]] {
    #    die 'Documented not passed on standard input.'
    #}
    #
    #Wait. Insufficient. This suffices if the current process is *NOT*
    #headless. But what if it is? Then we just need to test whether standard
    #input is open or not. This is readily cross-platform-portable, as currently
    #implemented by get_file_descriptor_file_device().
    #FIXME: Hm; wait. Testing whether standard input is open or not is actually
    #non-trivial, as such function attests. The simplest solution then will be
    #to test whether standard input is a here-document or -string. This is
    #somewhat more confined than we would like, but... well, there's really no
    #sane alternative. That said, even testing this is non-trivial, as it
    #requires obtaining the transitive target of such file descriptor.
    #FIXME: Oh, *SCREW IT.* The current implementation is basically the only
    #sane implementation. We'll need to document why, of course. See above!
    #FIXME: This is *HORRIBLY* broken. This so-called "test" is fundamentally
    #broken. Ugh!

    # If standard input is empty, throw an exception. See
    # :stdin.is_nonempty() for further details.
    read -t 0 || die 'Standard input empty.'

    # Unless such function exists, throw an exception. See is_runnable() for
    # further details.
    whence -- "${runnable_name__rrws}" &>/dev/null ||
        die "runnable \"${runnable_name__rrws}\" undefined"

    # Run such runnable. See get_stdin() for further details.
    "${runnable_name__rrws}" "${@}" "$(< /dev/stdin)"

    # Close standard input. See close_stdin() for further details.
    exec 0<&-
}

# --------------------( WASTELANDS                         )--------------------
        # # If such match failed to capture such name, throw an exception.
        # (( ${#match} == 1 )) || :die\
        #     ${label__cpolsn}' names unparsable from prototype:'$'\n\n'${prototype__cpolsn}

    #FUXME: This PCRE isn't *QUITE* as flexible as it should be. Ideally, such
    #PCRE should accept *ANY* unquoted value not containing whitespace. (Why?
    #Because zsh assignments accept exactly that.) At the moment, it only
    #accepts integer unquoted values.

# :void ::callable_prototype.set_attrs,names,args,stdin_of_label(
#     :string callable_prototype,
#     ^:map attrs_name,
#     ^:list names_name,
#     ^:string args_name,
#     ^:string stdin_name,
#     :string callable_label)
# function ::callable_prototype.set_attrs,names,args,stdin_of_label() {
#     # Validate sanity.
#     (( # == 6 )) || :die\
#         'Expected one callable prototype, one map name, one list name, two string names, and one callable type.'
#     local\
#         prototype__smltrpan="${1}"\
#         attrs_name__smltrpan="${2}"\
#         names_name__smltrpan="${3}"\
#         args_name__smltrpan="${4}"\
#         stdin_name__smltrpan="${5}"\
#         label__smltrpan="${6}"
#     local -a match__smltrpan
#     :var.die_unless_type_list "${names_name__smltrpan}"
#     :var.die_unless_type_map  "${attrs_name__smltrpan}"
# 
#     # Canonical string global ${ZPCRE_OP}, localized to avoid overwriting
#     # either global or caller-specific versions of such variable.
#     local ZPCRE_OP
# 
#     # Clear such map. See :map.clear(). (Ordinarily, orthogonality would imply
#     # we also clear such list here. Unlike such map, however, such list need
#     # only be conditionally cleared. It's complicated. And boring. Be gone!)
#     set -A ${attrs_name__smltrpan}
# 
#     #FUXME: In the optimized version of this function inlined into
#     #:func_.start(), use a new exception handler defined in @{*-func/die}
#     #rather than calling :die() everywhere below. Or perhaps leverage an
#     #existing exception handler already implemented, yes?
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     [[ ${prototype__smltrpan} =~\
#        ${ZESHY_RUNNABLE_PROTOTYPE_PCRE} ]] || :die\
#         ${label__smltrpan}' prototype'$(::parcel.get_preposition)' invalid:'$'\n\n'${prototype__smltrpan}
# 
#     # If such match failed to capture either such callable's attributes or
#     # names, throw an exception.
#     # print -r -- "matches: ${match[*]} (${#match})"
#     (( ${#match} >= ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ARGS )) || :die\
#         ${label__smltrpan}' attributes, names, and/or arguments unparsable from prototype:'$'\n\n'${prototype__smltrpan}
# 
#     # Preserve such matches *BEFORE* attempting attribute matching, which
#     # unavoidably overwrites list global ${match}.
#     match__smltrpan=( "${match[@]}" )
#     # integer i__smltrpan; print -r "match prototype: ${prototype__smltrpan}"; for i__smltrpan ({1..${#match}}) { print -r "match ${i__smltrpan}: ${match[${i__smltrpan}]}" }
# 
#     # If such prototype specifies at least one attribute, parse such attributes
#     # and optional suffixing values into such map. Since single- and
#     # double-quoted values may contain commas, such attributes must be
#     # iteratively matched with a PCRE rather than split on commas.
#     if [[ -n ${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ATTRS}]} ]] {
#         # Validate sanity.
#         local attrs_key__smltrpan
# 
#         # Compile such PCRE. For efficiency, avoid optionally optimizing such
#         # PCRE by calling pcre_study(). (Ad-hoc profiling suggests such
#         # optimization to consume more time than it saves.) See
#         # for_string_text_matching_pcre:() for further details.
#         pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_ATTRS_NEXT_PCRE}"
# 
#         # Match and add each such attribute to such map.
#         local ZPCRE_OP='0 0'
#         while {
#             pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
#                 "${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ATTRS}]}"
#         } {
#             # Map the current attribute to the colon-prefixed value suffixing
#             # such attribute if such attribute is suffixed by such a value or
#             # to the empty string otherwise. Such indirection is required by
#             # zsh setting arbitrary map keys outside of eval() statements. (An
#             # eval() statement would also suffice here, if less efficiently.)
#             # See :set_map_key_to_string() for further details.
#             attrs_key__smltrpan="${attrs_name__smltrpan}[${match[1]}]"
#             : "${(P)attrs_key__smltrpan::=${match[2]-}}"
#         }
#     }
# 
#     # If such prototype only specifies one name, set such list to such name. See
#     # :list.set_to_string().
#     if [[ -n ${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_NAME}]} ]] {
#         set -A\
#             ${names_name__smltrpan}\
#             "${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_NAME}]}"
#     # Else, such prototype specifies multiple comma-delimited names. Since
#     # single- and double-quoted callable names may contain commas, such names
#     # must be iteratively matched with a PCRE rather than split on commas.
#     } else {
#         local names_item__smltrpan
# 
#         # Index of the current non-existent list item to be appended.
#         integer names_index__smltrpan=1
# 
#         # Clear such list. See :list.clear() for further details.
#         set -A ${names_name__smltrpan}
# 
#         # Compile such PCRE. See above for further details.
#         pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
# 
#         # Match and append each such name to such list by indirection like that
#         # above. (An eval() statement would also suffice, if less efficiently.)
#         local ZPCRE_OP='0 0'
#         while {
#             pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
#                 "${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_NAMES}]}"
#         } {
#             names_item__smltrpan=${names_name__smltrpan}'['$(( names_index__smltrpan++ ))']'
#             : "${(P)names_item__smltrpan::=${match[1]}}"
#         }
#     }
# 
#     #FUXME: Since this will be inherently optimized by inlining such logic,
#     #ignore such inefficiencies for now.
# 
#     # Initialize such argument and standard input lists to the empty string.
#     :string.set "${args_name__smltrpan}" ''
#     :string.set "${stdin_name__smltrpan}" ''
# 
#     # If such prototype specifies an argument list, set such string.
#     if [[ -n ${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ARGS}]} ]] {
#         # Discard the ")" suffixing such match. See ={*-pcre}.
#         :string.set\
#             "${args_name__smltrpan}"\
#             "${match__smltrpan[${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ARGS}][1,-2]}"
#     # Else, such prototype specifies one or two argument channels. Parse the
#     # argument lists for such channels into the corresponding strings.
#     } else {
#         # If such match failed to capture such channels, throw an exception.
#         (( ${#match__smltrpan} >=\
#            ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_ARGS )) || :die\
#             ${label__smltrpan}' argument channels unparsable from prototype:'$'\n\n'${prototype__smltrpan}
# 
#         # For the match indices corresponding to the names of the first and
#         # second argument channels (if any), ...
#         integer arg_channel_name_match_index__smltrpan
#         for     arg_channel_name_match_index__smltrpan (
#             ${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_FIRST_NAME}
#             ${ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_ARG_CHANNEL_SECOND_NAME}
#         ) {
#             # If such channel is either the argument list (as is the customary
#             # case) or the standard input list, set the corresponding string.
#             case ${match__smltrpan[${arg_channel_name_match_index__smltrpan}]-} {
#             'args') {
#                 # Discard the ")" suffixing such match. See ={*-pcre}.
#                 :string.set\
#                     "${args_name__smltrpan}"\
#                     "${match__smltrpan[$(( arg_channel_name_match_index + 1 ))][1,-2]}"
#                 ;;
#             'stdin') {
#                 # Discard the ")" suffixing such match. See ={*-pcre}.
#                 :string.set\
#                     "${stdin_name__smltrpan}"\
#                     "${match__smltrpan[$(( arg_channel_name_match_index + 1 ))][1,-2]}"
#                 ;;
#             # Else if such channel name is empty, such channel *MUST* be an
#             # unspecified second channel. Since such channel is optional, this
#             # is *NOT* an error. (Simply ignore this.)
#             '')
#                 ;;
#             # Else, such channel is unrecognized. Throw an exception!
#             *) {
#                 :die\
#                     ${label__smltrpan}' argument channel '' unrecognized in prototype:'$'\n\n'${prototype__smltrpan}
#             }
#         }
#     }
# }

#FUXME: Optimize such function, thus optimizing ::func_.start(). This is quite
#crucial. See such function for specific details on what and how to optimize.
#FUXME: One prominent way we could optimize such function, aside from the
#obvious externalization of locals as globals, is to dramatically reduce PCRE
#${ZESHY_RUNNABLE_PROTOTYPE_PCRE} to the absolute minimum
#required for matching such syntactic constructs; at the moment, such PCRE does
#that as well as validate the entirety of runnable prototype syntax. It's the
#latter part we'd luck to cut. And while doing so is certainly feasible and
#would certainly improve matching efficiency, doing so would also require we
#perform validation elsewhere. Is this feasible? Probably, but we'll need to
#look into it in greater detail.
#
#Before we consider an example, however, we should note that extracting
#validation out of such PCRE has the extreme benefit of permitting us to print
#human-readable parse errors. At the moment, all we can do is print a single
#unhelpful blanket message (e.g., "zeshy: Function prototype invalid:"). Since
#that's essentially unacceptable, we'll need to extract such validation out
#*ANYWAY*. It *WILL* happen.
#
#As example of how one might do so, consider validation of "<"- and
#">"-delimited runnable attributes. Since this function iteratively matches
#each such attribute, we would need such iteration to *ALSO* perform
#validation. But this should be no terrible burden; simple keep track of the
#current match indices and throw an exception if the start index for the
#current match is *NOT* one character after the end index for the prior match.
#Additionally, after matching, throw an exception if the the end index for the
#prior match is *NOT* the last character of such attributes string.
#
#And that's it. Since this is clearly efficiently implementable and clearly
#improves both efficiency and exception readability, we have the green light.
#FUXME: Concurrent with doing so, we'll need to also generalize the current
#argument matching logic. Currently, we only match conventional arguments.
#However, since :func.stop() *WILL* (at some point) need to validate standard
#input-driven arguments as well, this function will need to be generalized to
#set an additional list (or perhaps only string scalar?) containing all such
#arguments. This, unfortunately, will require substantial changes to our
#current PCRE design -- but that can't be helped, we're afraid. We should have
#simply designed such PCRE correctly in the first place.
#
#All of which begs the question: does *ANY* function except :func.start()
#require the full breadth of this function's feature set? We're guessing not,
#in which case:
#
#* This function should simply be inlined as is into :func.start() and
#  optimized directly there.
#* A new function ::callable_prototype.set_attrs,names_of_label() should be
#  defined, setting only such structures.
#* Existing function ::callable_prototype.set_names_of_label() should be
#  reimplemented so as to simply match such names rather than deferring to
#  another matching function. The latter approach is almost comically
#  inefficient (and somewhat obfuscatory), which may actually matter (due to
#  such function's possible frequent use elsewhere).

#FUXME: Document me. In particular, note why this function parses such
#arguments into a string variable rather than a nonscalar variable (namely,
#because arguments are considerably more complex than either attributes or
#names and hence could only be sufficiently described by a complex object type,
#which zsh fails to support). Hence, the caller is responsible for parsing such
#arguments but *NOT* attributes or names.


#FUXME: Currently uncalled. Contemplate excising. 
#FUXME: Document me.

# # :void ::callable_prototype_of_label.set_names(
# #     :string callable_prototype,
# #     :string callable_label,
# #     ^:list names_name)
# function ::callable_prototype_of_label.set_names() {
#     # Validate sanity.
#     (( # == 3 )) || :die\
#         'Expected one callable prototype, one callable label, and one list name.'
#     local\
#         prototype__cpolsn="${1}"\
#         label__cpolsn="${2}"\
#         names_name__cpolsn="${3}"
#     :var.die_unless_type_list "${names_name__cpolsn}"
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     [[ ${prototype__cpolsn} =~\
#        ${ZESHY_RUNNABLE_PROTOTYPE_NAMES_PCRE} ]] || :die\
#         ${label__cpolsn}' prototype'$(::parcel.get_preposition)' invalid:'${prototype__cpolsn}
# 
#     #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#     # Synchronize with ::callable_prototype_of_label.set_attrs,names().
#     #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# 
#     # If such prototype only specifies one name, set such list to such name.
#     if [[ -n ${match[1]-} ]] {
#         # If such match failed to capture such name, throw an exception.
#         (( ${#match} == 1 )) || :die\
#             ${label__cpolsn}' names unparsable from prototype:'$'\n\n'${prototype__cpolsn}
# 
#         # Set such list. See :list.set_to_string().
#         set -A ${names_name__cpolsn} "${match[1]}"
#     # Else, such prototype specifies multiple comma-delimited names. Since
#     # single- and double-quoted callable names may contain commas, such names
#     # must be iteratively matched with a PCRE rather than split on commas.
#     } else {
#         local names__cpolsn names_item__cpolsn
# 
#         # Index of the current non-existent list item to be appended.
#         integer names_index__cpolsn=1
# 
#         # If such match failed to capture such names, throw an exception.
#         (( ${#match} == 2 )) || :die\
#             ${label__cpolsn}' names unparsable from prototype:'$'\n\n'${prototype__cpolsn}
# 
#         # Comma-delimited string of such names, cached here to permit canonical
#         # list global ${match} to be reused for iteration below.
#         names__cpolsn="${match[2]}"
# 
#         # Clear such list. See :list.clear() for further details.
#         set -A ${names_name__cpolsn}
# 
#         pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
# 
#         # Match and append each such name to such list by indirection like that
#         # above. (An eval() statement would also suffice, if less efficiently.)
#         local ZPCRE_OP='0 0'
#         while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names__cpolsn}" } {
#             names_item__cpolsn=${names_name__cpolsn}'['$(( names_index__cpolsn++ ))']'
#             : "${(P)names_item__cpolsn::=${match[1]}}"
#         }
#     }
# }

    # Set such list to such matched names. See
    # ::callable_prototype_of_label.set_names().

#FUXME: Document me.

# # :void :func_prototype.set_attrs,names,args,stdin(
# #     :string func_prototype,
# #     ^:map attrs_name,
# #     ^:list names_name,
# #     ^:string args_name,
# #     ^:string stdin_name)
# function :func_prototype.set_attrs,names,args,stdin() {
#     (( # == 5 )) || :die\
#         'Expected one function prototype, one map name, one list name, and two string names.'
#     ::callable_prototype.set_attrs,names,args,stdin_of_label "${@}" 'Function'
# }

    # local placeholder__apsan

    # # Set such metadata.
    # ::callable_prototype.set_attrs,names,args,stdin_of_label\
    #     "${@}" placeholder__apsan placeholder__apsan 'Alias'

    # Set such list to such names.
    # ::callable_prototype_of_label.set_names_with_match_index "${@}" match 1

    # Restore such matches *BEFORE* attempting attribute matching, which
    # unavoidably overwrites list global ${match}.
    # match=( "${match__cpolsan[@]}" )

    # Set such list to such names.
    # ::callable_prototype_of_label.set_names_with_match_index\
    #     "${prototype__cpolsan}"\
    #     "${label__cpolsan}"\
    #     "${names_name__cpolsan}"\
    #     match__cpolsan\
    #     2

    #FUXME: Create ${ZESHY_RUNNABLE_PROTOTYPE_ATTRS_NAMES_PCRE} in ={pcre}.

#FUXME: Defer to such function above.
    # If such prototype only specifies one name, set such list to such name.
    # if [[ -n ${match[1]-} ]] {
    #     # If such match failed to capture such name, throw an exception.
    #     (( ${#match} == 1 )) || :die\
    #         ${label__cpnsol}' names unparsable from prototype:'$'\n\n'${prototype__cpnsol}

    #     # Set such list. See :list.set_to_string().
    #     set -A ${names_name__cpnsol} "${match[1]}"
    # # Else, such prototype specifies multiple comma-delimited names. Since
    # # single- and double-quoted callable names may contain commas, such names
    # # must be iteratively matched with a PCRE rather than split on commas.
    # } else {
    #     local   names_item__cpnsol

    #     # Index of the current non-existent list item to be appended.
    #     integer names_index__cpnsol=1

    #     # If such match failed to capture such names, throw an exception.
    #     (( ${#match} == 2 )) || :die\
    #         ${label__cpnsol}' names unparsable from prototype:'$'\n\n'${prototype__cpnsol}

    #     # Clear such list. See :list.clear() for further details.
    #     set -A ${names_name__cpnsol}

    #     # Match and append each such name to such list by indirection like that
    #     # above. (An eval() statement would also suffice, if less efficiently.)
    #     local ZPCRE_OP='0 0'
    #     while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${match[2]}" } {
    #         names_item__cpnsol=${names_name__cpnsol}'['$(( names_index__cpnsol++ ))']'
    #         : "${(P)names_item__cpnsol::=${match[1]}}"
    #     }
    # }

    # Set such list to such matched names. See
    # ::callable_prototype.set_names_of_label().
    # if [[ -n ${match[1]-} ]] {
    #     (( ${#match} == 1 )) || :die\
    #         ${label__cpnsol}' names unparsable from prototype:'$'\n\n'${prototype__cpnsol}
    #     set -A ${names_name__cpnsol} "${match[1]}"
    # } else {
    #     local   names_item__cpnsol
    #     integer names_index__cpnsol=1
    #     (( ${#match} == 2 )) || :die\
    #         ${label__cpnsol}' names unparsable from prototype:'$'\n\n'${prototype__cpnsol}
    #     set -A ${names_name__cpnsol}
    #     pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
    #     local ZPCRE_OP='0 0'
    #     while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${match[2]}" } {
    #         names_item__cpnsol=${names_name__cpnsol}'['$(( names_index__cpnsol++ ))']'
    #         : "${(P)names_item__cpnsol::=${match[1]}}"
    #     }
    # }

    #     # Compile such PCRE. See above for further details.
    #     pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"

#FUXME: Document me.

# :void ::callable_prototype_of_label.set_names_with_match_index(
#     :string callable_prototype,
#     :string callable_label,
#     ^:list names_name,
#     ^:list match_name,
#     :int match_index)
# function ::callable_prototype_of_label.set_names_with_match_index() {
#     # Validate sanity.
#     (( # == 4 )) || :die\
#         'Expected one callable prototype, one callable label, two list names, and one match index.'
#     local\
#         prototype__cpolsnwmi="${1}"\
#         label__cpolsnwmi="${2}"\
#         names_name__cpolsnwmi="${3}"\
#         match_name__cpolsnwmi="${4}"\
#         match_index__cpolsnwmi="${5}"
#     :var.die_unless_type_list\
#         "${names_name__cpolsnwmi}" "${match_name__cpolsnwmi}"
# 
#     # If such match index is *NOT* a positive integer, throw an exception. See
#     # :int.is_positive().
#     [[ ${match_index__cpolsnwmi} == <-> ]] || :die\
#         "Match index ${match_index__cpolsnwmi} not a non-negative integer."
# 
#     # If such prototype only specifies one name, set such list to such name.
#     if [[ -n ${${(P)match_name__cpolsnwmi[${match_index__cpolsnwmi}]-}} ]] {
#         # If such match failed to capture such name, throw an exception.
#         (( ${#match} >= match_index__cpolsnwmi )) || :die\
#             ${label__cpolsnwmi}' names unparsable from prototype:'$'\n\n'${prototype__cpolsnwmi}
# 
#         # Set such list. See :list.set_to_string().
#         set -A ${names_name__cpolsnwmi} "${match[${match_index__cpolsnwmi}]}"
#     # Else, such prototype specifies multiple comma-delimited names. Since
#     # single- and double-quoted callable names may contain commas, such names
#     # must be iteratively matched with a PCRE rather than split on commas.
#     } else {
#         local names__cpolsnwmi names_item__cpolsnwmi
# 
#         # Index of the current non-existent list item to be appended.
#         integer names_index__cpolsnwmi=1
# 
#         # Increment such match index to the next match, presumably the index to
#         # which the prior match captured such names.
#         match_index__cpolsnwmi+=1
# 
#         # If such match failed to capture such names, throw an exception.
#         (( ${#match} >= match_index__cpolsnwmi )) || :die\
#             ${label__cpolsnwmi}' names unparsable from prototype:'$'\n\n'${prototype__cpolsnwmi}
# 
#         # Comma-delimited string of such names, cached here to permit canonical
#         # list global ${match} to be reused for iteration below.
#         names__cpolsnwmi="${match[${match_index__cpolsnwmi}]}"
# 
#         # Clear such list. See :list.clear() for further details.
#         set -A ${names_name__cpolsnwmi}
# 
#         # Compile such PCRE. See above for further details.
#         pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
# 
#         # Match and append each such name to such list by indirection like that
#         # above. (An eval() statement would also suffice, if less efficiently.)
#         local ZPCRE_OP='0 0'
#         while { pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${names__cpolsnwmi}" } {
#             names_item__cpolsnwmi=${names_name__cpolsnwmi}'['$(( names_index__cpolsnwmi++ ))']'
#             : "${(P)names_item__cpolsnwmi::=${match[1]}}"
#         }
#     }
# }

    # If such name was captured but is empty, throw an exception. (While this
    # *SHOULD* be the case, guaranteeing this guards against regressions.)
    # [[ -n ${match[1]} ]] || :die\
    #     ${label__cpsnol}' name empty in prototype:'${prototype__cpsnol}

    # [[ -n ${prototype__cpnsol} ]] || :die\
    #     ${label__cpnsol}' prototype empty.'

    # local placeholder_args__sltrpn
    # local -A placeholder_attrs__sltrpn

    # # Parse such callable names from such prototype. To centralize logic, also
    # # parse such callable attributes despite the caller not requesting such
    # # attributes -- which we then promptly discard.
    # ::callable_prototype.set_attrs,names,args,stdin_of_label\
    #     "${1}"\
    #     placeholder_attrs__sltrpn\
    #     "${2}"\
    #     placeholder_args__sltrpn\
    #     "${3}"

        # local arg_channel_name__smltrpan

            # Name of such channel.
            # arg_channel_name__smltrpan=${match__smltrpan[${arg_channel_name_match_index__smltrpan}]}

            # # If such channel is either the argument list (as is the customary
            # # case) or the standard input list, set the corresponding string.
            # if [[ ${arg_channel_name__smltrpan} == 'args' ]] {
            #     # Discard the ")" suffixing such match. See ={*-pcre}.
            #     :string.set\
            #         "${args_name__smltrpan}"\
            #         "${match__smltrpan[$(( arg_channel_name_match_index + 1 ))][1,-2]}"
            # # Else if such channel is the standard input list, set such string.
            # } elif [[ ${arg_channel_name__smltrpan} == 'stdin' ]] {

        # If such match failed to capture such names, throw an exception.
        # (( ${#match__smltrpan} >=\
        #    ZESHY_RUNNABLE_PROTOTYPE_MATCH_INDEX_NAMES )) || :die\
        #     ${label__smltrpan}' names unparsable from prototype:'$'\n\n'${prototype__smltrpan}

    # Set such string to such arguments, defaulting to the empty string if
    # such callable accepts no arguments (e.g., "()").

    # Parse such callable names from such prototype. To centralize logic, also
    # parse such callable attributes despite the caller not requesting such
    # attributes -- which we then promptly discard.
    # ::callable_prototype.set_attrs,names,args,stdin_of_label\
    #     "${1}"\
    #     placeholder_attrs__sltrpn\
    #     "${2}"\
    #     placeholder_args__sltrpn\
    #     "${3}"

            #FUXME: Can we not inline such incrementation below: e.g., as
            #
            #    names_item__smltrpan=${names_name__smltrpan}'['$(( names_index__smltrpan++ ))']'
            #
            #Naturally, that will probably require initializing
            #${names_index__smltrpan} to 1 rather than 0, above.

            # Index of the current non-existent list item to be appended.
            # names_index__smltrpan+=1
            # names_item__smltrpan="${names_name__smltrpan}[${names_index__smltrpan}]"

# Do *NOT* quote
        # the result of such split. 
        #FUXME: Arguably, we should just define ::map.clear() here.
        #FUXME: Arguably, we should just define ::list.clear() here.

#FUXME: Refactor to ::callable_prototype.set_name_of_type().

#FUXME: To avoid redefining such logic thrice more (e.g., for the htree alias
#subtypes), generalize such logic into a new low-level private utility function
#::set_string_to_operable_prototype(), naturally called here.

# in parcel @{'${ZESHY_PARCEL_NAME-N/A}'}

#FUXME: Since we really don't care terribly much about function and alias
#synonyms, it's likely that we'll no longer require the passed map argument
#*AFTER* implementing the refactorings in @{*-func}. Cut such argument and
#rename to :set_list_to_runnable_prototype_name_or_names().

# # void set_list_and_map_to_runnable_prototype_name_or_names:(
# #     string list_name,
# #     string map_name,
# #     string matched_runnable_name,
# #     string matched_runnable_names)
# function set_list_and_map_to_runnable_prototype_name_or_names: {
#     # Validate sanity.
#     (( # == 4 )) || :die\
#         'Expected one list name, one map name, one matched singular string, and one matched plural string.'
#     local\
#         list_name__sltrpn="${1}"\
#         map_name__sltrpn="${2}"\
#         runnable_name__sltrpn="${3}"\
#         runnable_names__sltrpn="${4}"
# 
#     # If any such variable is undefined or not of the expected type, throw an
#     # exception. See :var.die_unless_type_list() for further details.
#     [[ "${(tP)list_name__sltrpn-}" == 'array'* ]] || :die\
#         '${'${list_name__sltrpn}'} undefined or not a list.'
#     [[ "${(tP)map_name__sltrpn-}" == 'association'* ]] || :die\
#         '${'${map_name__sltrpn}'} undefined or not a map.'
# 
#     # If such runnable only has one name...
#     if [[ -n "${runnable_name__sltrpn}" ]] {
#         eval '
#         # If such runnable is already declared, print a warning. See
#         # is_map_key() for further details.
#         if (( ${+'${map_name__sltrpn}'[${runnable_name__sltrpn}]} )) {
#             :output_warning "${runnable_name__sltrpn}() in @{${ZESHY_PARCEL_NAME}} already declared."
#         }
# 
#         # Set such list to such name.
#         '${list_name__sltrpn}'=( "${runnable_name__sltrpn}" )
# 
#         # Add the identity mapping to such map.
#         '${map_name__sltrpn}'[${runnable_name__sltrpn}]="${runnable_name__sltrpn}"'
#     # Else, such runnable has multiple names. Since single- and double-quoted
#     # runnable names may contain commas, such names cannot be split on commas as
#     # with runnable attributes elsewhere. Rather, iteratively match such names
#     # with a PCRE.
#     } else {
#         [[ -n "${runnable_names__sltrpn}" ]] || :die\
#             'Both singular and plural function names empty.'
# 
#         # Prepare to match such names. See for_string_text_matching_pcre:() for further
#         # details.
#         pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
#         # pcre_study
# 
#         # Match such names.
#         local ZPCRE_OP='0 0'
#         eval 'while {
#             pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${runnable_names__sltrpn}"
#         } {
#             # For convenience, store the currently matched name.
#             runnable_name__sltrpn="${match[1]}"
# 
#             # If such runnable is already declared, print a warning as above.
#             if (( ${+'${map_name__sltrpn}'[${runnable_name__sltrpn}]} )) {
#                 :output_warning "${runnable_name__sltrpn}() in @{${ZESHY_PARCEL_NAME}} already declared."
#             }
# 
#             # Append such name to such list.
#             '${list_name__sltrpn}'+="${runnable_name__sltrpn}"
# 
#             # Map such name to the first such name for such runnable.
#             '${map_name__sltrpn}'[${runnable_name__sltrpn}]="${'${list_name__sltrpn}'[1]}"
#         }
#         
#         # If such list remains empty, throw an exception.
#         (( ${#'${list_name__sltrpn}'} )) || :die\
#             ''Runnable names unparsable (despite multiple names detected) from prototype:''$''\n''${runnable_names__sltrpn}
#         '
#     }
# }

    # :string matched; for matched ("${match[@]}") { matched }
        #FUXME: Overly redundant. We probably want a new private getter (for
        #simplicity, since efficiency doesn't matter here), resembling:
        #function ::get_parcel_if_found_or_noop() {
        #    (( # == 0 )) || :die 'Expected no arguments.'
        #    if [[ -n "${ZESHY_PARCEL_NAME-}" ]] {
        #        print -r 'in parcel @{'${ZESHY_PARCEL_NAME}'}'
        #    }
        #}

        # If such global resides in a parcel, state such parcel in the
        # exception thrown below.
        # local in_parcel__slsbtgnviv
        # if [[ -n "${ZESHY_PARCEL_NAME-}" ]] {
        #     in_parcel__slsbtgnviv='in parcel @{'${ZESHY_PARCEL_NAME}'}'
        # }

        # Throw such exception.

    # # If any such variable is undefined or not of the expected type, throw an
    # # exception. See :var.die_unless_type_map() and :var.die_unless_type_list() for further details.
    # [[ "${(tP)runnable_attrs_map_name__smltrpan-}" == 'association'* ]] || :die\
    #     'Map ${'${runnable_attrs_map_name__smltrpan}'} undefined or not a map.'
    # [[ "${(tP)runnable_names_list_name__smltrpan-}" == 'array'* ]] || :die\
    #     'List ${'${runnable_names_list_name__smltrpan}'} undefined or not a list.'

        #FUXME: Such call *WILL* fail both here and below, as such variable is
        #an integer rather than a string. We'll need to define a new
        #:int.set() function -- which, happily, is quite a bit simpler
        #than :string.set(), due to the former *NOT* supporting
        #concatenation of multiple passed integers.

#FUXME: Replace all calls to :list.set_to_string() with calls to this.

    # If any such variable is undefined or not of the expected type, throw an
    # exception. Since we call :string.set() below to set string
    # variables, avoid validating such variables here. See :var.die_unless_type_list()
    # for further details.
    # [[ "${(tP)global_names_list_name__slsbtgnviv-}" == 'array'* ]] || :die\
    #     'List ${'${global_names_list_name__slsbtgnviv}'} undefined or not a list.'

# Avoid defining comparable setters for non-scalar types (e.g., lists, maps)
# here; such setters depend on considerably more functionality than we would be
# willing to migrate here.

#FUXME: Enormous woops. "read -t 0" is destructive and terrible. To genuinely
#test this, we'll need to both inline *AND* call
#:stdin.is_nonempty() here. While absurdly annoying, this is
#certainly feasible.
#FUXME: Ugh. We'll need to load the module defining zselect(), then. And, of
#course, this implies zeshy to then be limited to only OSes defining select().
#Isn't that most of them, however?
#FUXME: O.K.; this works. We'll need to define a new parcel @{10-test} and
#rename this parcel to @{15-set}. Shift :stdin.is_nonempty() to
#@{10-test}; then, refactor the setters below to call such function. We know;
#this is terrible. But there you are!
#FUXME: Don't forget to shift the zmodload() call below to @{10-test} too!

    # # If such variable is not a string, throw an exception. See
    # # :var.die_unless_type_string() for further details.
    # [[ "${(tP)string_name__ssts-}" == 'scalar'* ]] || :die\
    #     'Variable ${'${string_name__ssts}'} undefined or not a string.'

#FUXME: Document me.
#FUXME: Actually, this function will probably be going away. Don't bother
#documenting, for now.

# # void :set_list_to_alias_prototype_names(
# #     string list_name, string alias_prototype)
# function :set_list_to_alias_prototype_names() {
#     (( # == 2 )) || :die 'Expected one list name and one alias prototype.'
#     ::callable_prototype.set_names_of_label "${@}" 'Alias'
# }

        #FUXME: *WOO*! We may have uncovered an even more efficient means of
        #implementing this, requiring no such temporary copy: just duplicate
        #the above technique for dynamically setting map key-value pairs here,
        #where the "key" to be set is one past the current last list item. Ya!

        # Temporary list iteritavely appended to below. While such iteration
        # could append directly to the passed list, doing so would require an
        # inefficient eval() statement.
        # local -a runnable_names__smltrpan

        # local runnable_names_list_item__smltrpan
        # integer runnable_names_list_index__smltrpan=0

        # # Clear such list. See :list.clear() for further details.
        # set -A "${runnable_names_list_name__smltrpan}"

        # # If such match failed to capture such names, throw an exception.
        # (( ${#prototype_match__smltrpan} >= 3 )) || :die\
        #     ${runnable_label__smltrpan}' names unparsable from prototype:'$'\n'${prototype__smltrpan}

        # # Compile such PCRE. See for_string_text_matching_pcre:() for further
        # # details.
        # pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
        # pcre_study

        # # Match and append each such name to such list.
        # local ZPCRE_OP='0 0'
        # while {
        #     pcre_match -b -n ${ZPCRE_OP[(w)2]} --\
        #         "${prototype_match__smltrpan[3]}"
        # } {
        #     # Index of the current non-existent list item to be appended.
        #     runnable_names_list_index__smltrpan+=1

        #     # Append such name to such list with indirection similar to that
        #     # performed above. (An eval() statement would also suffice here, if
        #     # less efficiently.)
        #     runnable_names_list_item__smltrpan="${runnable_names_list_name__smltrpan}[${runnable_names_list_index__smltrpan}]"
        #     : "${(P)runnable_names_list_item__smltrpan::=${match[1]}}"
        #     # runnable_names__smltrpan+="${match[1]}"
        # }

        # # If such list remains empty, throw an exception.
        # (( ${#runnable_names__smltrpan} )) || :die\
        #     ${runnable_label__smltrpan}' names unsplittable from prototype:'$'\n'${prototype__smltrpan}

        # # Copy such temporary list to the passed list.
        # set -A\
        #     "${runnable_names_list_name__smltrpan}"\
        #     "${runnable_names__smltrpan[@]}"

#FUXME: Most (if not all) inefficient calls to builtin eval() below can be
#replaced by efficient calls to builtin set(): e.g.,
#
#    set -a "${list_name__sltl}" "${@}"

        # eval ${runnable_names_list_name__smltrpan}'=( "${prototype_match__smltrpan[2]}" )'

        # eval ${global_names_list_name__slsbtgnviv}'=( "${match[1]}" )'
        # eval ${global_names_list_name__slsbtgnviv}'=( ${(s:=:)match[2]} )'

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception. See :stdin.is_nonempty() for
    # further details.
    #
    # Since there exists no demonstrable reason to prohibit empty
    # documentation, such exception should ideally only be thrown in the latter
    # case. Unfortunately, differentiating between the two cases is
    # sufficiently non-trivial as to be effectively infeasible this early in
    # digest compilation.
    #
    # Ideally, such cases could be differentiated by either:
    #
    # * Inlining the implementation of :is_stdin_readable_noninteractive()
    #   here (e.g., "not :is_stdin_terminal and :is_stdin_open"). While
    #   inlining the former condition :is_stdin_terminal() would be trivial,
    #   inlining the latter condition :is_stdin_open() would require also
    #   inlining :set_string_to_symlink_target_last() (and all functions such
    #   function transitively calls) and hence be non-trivial.
    # * Inlining the implementation of :is_stdin_here_doc_or_string() here.
    #   Since this would require again inlining
    #   :set_string_to_symlink_target_last() as above, such approach is equally
    #   non-trivial.
    #
    # Given the earliness of this function, we adopt a single-line solution --
    # which, as an unfortunate by-product, prohibits empty documentation.
    # zselect -t 0 -a zselect_status -r 0 || :die\
    #     'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'

    # # Set such string to standard input. See get_stdin() for further details.
    # :string.set "${1}" "$(< /dev/stdin)"

    #FUXME: Excise.
    # Unfortunately, running "read -t 0" more than once on the same standard
    # input stream appears to non-idempotently modify such stream in an
    # unreliable manner (e.g., by erasing such stream). Since this is
    # understandably horrible, avoid such bugs by inlining the implementation
    # of ::help.set_to_stdin() (rather than calling such function).
    #
    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, report failure.
    # See ::help.set_to_stdin() for further details.
    # zselect -t 0 -a zselect_status -r 0 || return 1
    # read -t 0 || return 1

    # Set such string to standard input. See get_stdin() for further details.
    # :string.set "${1}" "$(< /dev/stdin)"

    # Set such string to all standard input. Disamntled, this is:
    #
    # * "IFS=", instructing read() to copy all standard input to the first
    #   passed variable rather than splitting such input on the current
    #   internal field separator into all passed variables.
    # * "-r", enabling raw reading (i.e., disabling reading of backslashes as
    #   zsh-specific line continuation and escape characters).
    # * "-t 0", reporting failure without reading if standard input is either
    #   the empty string or unreadable without blocking.
    # * "-d ''", preventing
    # IFS= read -r -t 0 -d '' "${1}"

    # Unfortunately, running "read -t 0" more than once on the same standard
    # input stream appears to non-idempotently modify such stream in an
    # unreliable manner (e.g., by erasing such stream). Since this is
    # understandably horrible, avoid such bugs by inlining the implementation
    # of ::help.set_to_stdin() (rather than calling such function).
    #
    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, report failure.
    # See ::help.set_to_stdin() for further details.

# Note that if such prototype defines no optional value,
#such function reports failure whill still setting the first two passed
#variables.
#, along with the related exit status.
#FUXME: Document me.
#[status: bool]
#    :set_string,list,string_to_global_prototype_type,names,value_if_value(
#        string global_type_string_name,
#        string global_names_list_name,
#        string global_value_string_name,
#        string global_prototype)
# function :set_string,list,string_to_global_prototype_type,names,value_if_value() {
#     # Validate sanity.
#     (( # == 4 )) || :die\
#         'Expected one string name, one list name, one string name, and one global prototype.'
#     local\
#         global_type_string_name__sltgpn="${1}"\
#         global_names_list_name__sltgpn="${2}"\
#         global_value_string_name__sltgpn="${3}"\
#         global_prototype__sltgpn="${4}"
#     [[ -n "${global_prototype__sltgpn}" ]] || :die 'Global prototype empty.'
# 
#     # If any such variable is undefined or not of the expected type, throw an
#     # exception. Since we call :string.set() below to set string
#     # variables, avoid validating such variables here. See :var.die_unless_type_list()
#     # for further details.
#     [[ "${(tP)global_names_list_name__sltgpn-}" == 'array'* ]] || :die\
#         'List ${'${global_names_list_name__sltgpn}'} undefined or not a list.'
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     [[ "${global_prototype__sltgpn}" =~\
#         "${ZESHY_GLOBAL_PROTOTYPE_TYPE_NAMES_VALUE_PCRE}" ]] || :die\
#         'Global prototype invalid:'$'\n'${global_prototype__sltgpn}
# 
#     # If such match failed to capture such global's names, throw an exception.
#     (( ${#match} >= 2 )) || :die\
#         'Global names unparsable from prototype:'$'\n'${global_prototype__sltgpn}
# 
#     # Set such type.
#     :string.set "${global_type_string_name__sltgpn}" "${match[2]}"
# 
#     # If such prototype only declares one name, set such list to such name.
#     if [[ -n "${match[2]}" ]] {
#         eval ${global_names_list_name__sltgpn}'=( "${match[2]}" )'
#     # Else, such prototype declares multiple equal signs-delimited names.
#     # Unlike runnable prototype names, such names are prohibited from
#     # containing equals signs and hence may be efficiently split on such.
#     } else {
#         # If such match failed to capture such names, throw an exception.
#         (( ${#match} >= 3 )) || :die\
#             'Global names unparsable from prototype:'$'\n'${global_prototype__sltgpn}
# 
#         # Set such list to such names by splitting on equals signs.
#         eval ${global_names_list_name__sltgpn}'=( ${(s:=:)match[3]} )'
#     }
# 
#     # Set such value if defined or report failure.
#     if (( ${#match} == 4 )) {
#         :string.set\
#             "${global_type_string_name__sltgpn}" "${match[4]}"
#     } else {
#         return 1
#     }
# }

#FUXME: Document me. Note that if such prototype declares no optional value,
#such value will be set to the empty string if such type... No, wait; that
#doesn't really work. Hmm. How can a nonextant value be reliably signified? A
#number of possible ways:
#
#1. Such function preserves the current value of variable
#   ${global_value_string_name}. Assuming the caller initializes such variable
#   to an exceptionally unlikely value (e.g., $'\n\t\b\0'), the caller can then
#   test whether such variable retains the same value to determine whether such
#   global had a value passed. The downside, of course, is the inherent
#   unreliability of such an approach.
#2. Such function reports failure if no such value was provided.
#
#Honestly, the latter is the obvious route forward. What sort of nomenclature
#should we concoct, however? Consider:
#
#* :set_string,list,string_to_global_prototype_type,names,value_if_value_or_type,names().
#
#We know; that's a *CRAZY* long nomenclature, but... *shrug*.
#
#Wait; why *CAN'T* we just set such value to the empty string? We mean, really;
#is there any difference in the end at all? Hmm; yes, actually, there is. Go
#with the above, we should think.

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See :var.die_unless_type_string() and :var.die_unless_type_list() for further
    # details.
    # [[ "${(tP)global_type_string_name__sltgpn-}${(tP)global_value_string_name__sltgpn-}" ==\
    #     'scalar'*'scalar'* ]] || :die\
    #     'Strings ${'${global_type_string_name__sltgpn}'} and/or ${'${global_value_string_name__sltgpn}'} undefined or not strings.'

#FUXME: If we're going to go this far (and we certainly are), we'd might as
#well also define setters for lists and maps, which we should then leverage
#below inplace of inlined eval() statements.

#FUXME: Call such function elsewhere rather than manually inlining such logic
#everywhere. We should have probably done this *MUCH* sooner.

        # 'Documentation "'${help__ssthp%%$'\n'*}'..." invalid (i.e., contains no blank line separating prototype from non-prototype sections).'

    #FUXME: For efficiency, congeal *ALL* of the eval() statements below into a
    #single statement. Yes; muhaha!
    #FUXME: Hmm; nevermind. So be it, eval()!

        #FUXME: Bad! Split the attribute string apart into its constituent
        #components into such map. We'll need a PCRE-based loop, as below. Map:
        #
        #* Unvalued attributes (e.g., "<globbable>") to keys with empty values.
        #* Valued attributes (e.g., "<deprecated = '3.0'>") to keys with the
        #  corresponding values.

        # List of attributes split from such string. Split on commas
        # after truncating:
        #
        # * Optional whitespace surrounding commas (e.g., from " , " to ",").
        # * Optional trailing commas and/or whitespace.
        # eval ${runnable_attrs_map_name__smltrpan}'=(
        #     "${(s:,:)${match[1]//[[:space:]]#,[[:space:]]#/,}%%[[:space:]]#,#[[:space:]]#}" )'
#       for ((match_index=1; match_index <= ${#attrs}; ++match_index)) {
#           print "attr ${match_index}: ${attrs[${match_index}]}"
#       }

        # If such list remains empty, throw an exception.
        # (( ${#'${runnable_names_list_name__smltrpan}'} )) || :die\
        #     ${runnable_label__smltrpan}'' names unsplittable from prototype:''$''\n''${prototype__smltrpan}

            # If such attribute is valueless (e.g., *NOT* suffixed by a
            # colon-prefixed value), key such attribute to the empty string.
            # if [[ -z "${match[2]}" ]] {
            #     : "${(P)runnable_attrs_map_key__smltrpan::=}"
            # # Else, such attribute is suffixed by a colon-prefixed value. Key
            # # such attribute to such value.
            # } else {
            # }

            # Key
            # such attribute to such value
            # String indexing the passed map with the current attribute name,
            # as zsh requires for setting map keys outside of eval()
            # statements.
        # Preserve such names *BEFORE* matching, which overwrites ${match}.
        # local runnable_names__smltrpan
        # runnable_names__smltrpan="${prototype_match__smltrpan[3]}"

#FUXME: Such function should be obsoleted in favor of
#::set_map,list_to_runnable_prototype_attributes_names().

# void :set_list_to_runnable_prototype_names(
#     string list_name, string runnable_prototype)
# function :set_list_to_runnable_prototype_names() {
#     # Validate sanity.
#     (( # == 2 )) || :die 'Expected one list name and one runnable prototype.'
#     local list_name__sltrpn="${1}" prototype__sltrpn="${2}"
#     [[ -n "${prototype__sltrpn}" ]] || :die 'Runnable prototype empty.'
# 
#     # If such variable is undefined or not a list, throw an exception. See
#     # :var.die_unless_type_list() for further details.
#     [[ "${(tP)list_name__sltrpn-}" == 'array'* ]] || :die\
#         '${'${list_name__sltrpn}'} undefined or not a list.'
# 
#     # If such prototype is syntactically invalid, throw an exception.
#     [[ "${prototype__sltrpn}" =~\
#         "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_PCRE}" ]] || :die\
#         'Runnable prototype "'${prototype__sltrpn}'" invalid.'
# 
#     # If no such names were captured, throw an exception.
#     (( ${#match} )) || :die\
#         'Runnable prototype "'${prototype__sltrpn}'" names uncaptured.'
# 
#     # If such runnable only has one name, set such list to such name.
#     if [[ -n "${match[1]}" ]] {
#         eval ${list_name__sltrpn}'=( "${match[1]}" )'
#     # Else, such runnable has multiple comma-delimited names. Since single- and
#     # double-quoted runnable names may themselves contain commas, such names
#     # must be iteratively matched with a PCRE rather than split on commas.
#     } else {
#         local runnable_names__sltrpn
# 
#         # Preserve such names *BEFORE* such matching, which overwrites ${match}.
#         runnable_names__sltrpn="${match[2]}"
# 
#         # Compile such PCRE. See for_string_text_matching_pcre:() for further
#         # details.
#         pcre_compile -- "${ZESHY_RUNNABLE_PROTOTYPE_NAMES_NEXT_PCRE}"
#         pcre_study
# 
#         # Match and append each such name to such list.
#         local ZPCRE_OP='0 0'
#         eval 'while {
#             pcre_match -b -n ${ZPCRE_OP[(w)2]} -- "${runnable_names__sltrpn}"
#         } {
#             '${list_name__sltrpn}'+="${match[1]}"
#         }
# 
#         # If such list remains empty, throw an exception.
#         (( ${#'${list_name__sltrpn}'} )) || :die\
#             ''Runnable prototype "''${prototype__sltrpn}''" names unparsed (despite detecting multiple names).'''
#     }
# }

#[[:space:]]#(#b)(^$'\n']##)$'\n'[[:space:]]#$'\n'*
#FUXME: This is terrible. Excise!
# function die_for_declarator_type_with_help() {
#     # Validate sanity.
#     (( # == 2 )) || :die 'Expected one type string and one help string.'
# #   print -r -- "arg count: ${#}; args: ${*}"
#     local type="${1}" help="${2}"
# 
#     # Function prototype prefixing such help string.
#     local help_prototype
# 
#     # If such string contains a blank line (i.e., "\n\n"), crudely match the
#     # substring preceding such line as the function prototype.
#     if     [[ "${help}" == (#b)([^$'\n']##)$'\n\n'* ]] {
#         help_prototype="${match[1]}"
#     # Else if such string contains a newline (i.e., "\n"), crudely match the
#     # substring preceding such newline as the function prototype.
#     } elif [[ "${help}" == (#b)([^$'\n']##)$'\n'* ]] {
#         help_prototype="${match[1]}"
#     # Else, abandon all hope.
#     } else {
#         help_prototype="${help}"
#     }
# 
#     # Throw an exception suffixed by such prototype.
#     :die "${(C)type} documentation invalid (see \"print_help declare_${type}\"):
# ${help_prototype}"
# }

    # If such documentation contains a newline (i.e., "\n"), assume the
    # substring preceding such newline as the function prototype.
    # } elif [[ "${help__ssthp}" == (#b)([^$'\n']##)$'\n'* ]] {
    #     prototype__ssthp="${match[1]}"
    # # Else, abandon all hope.
    # } else {
    #     prototype__ssthp="${help}"

#FUXME: Rename to ::help.set_to_stdin().
        # Shift such variable name from the argument list. See shift_arg() for
        # further details.
        # argv[1]=()

#FUXME: Document this parcel and all runnables such parcel declares.

    # If such variable is not a string, throw an exception. See
    # :var.die_unless_type_string() for further details.
    # [[ "${(tP)string_name__sstdh-}" == 'scalar'* ]] || :die\
    #     'Variable ${'${string_name__sstdh}'} undefined or not a string.'

    # If standard input is attached to an interactive terminal, throw an
    # exception. (While the prior test should ensure this, one can never be too
    # sure. Since we close such input below, it's critical we only close non-
    # interactive input.)
    # if [[ -t 0 ]] {
    #     die 'Standard input attached to an interactive terminal.'
    # }
    # # Close standard input. See close_stdin() for further details.
    # exec 0<&-

    # If standard input is either the empty string *OR* unreadable
    # If at least one byte of standard input is readable without blocking, throw an exception. See
