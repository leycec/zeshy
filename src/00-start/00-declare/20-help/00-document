#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

#FIXME: Document such parcel.

# Due to a chicken-and-the-egg problem, all functions and globals defined below
# are subsequently documented under ={help} in the main codebase.

#FIXME: Shift all functions declared below to ={10-set} that can reasonably be
#shifted to such parcel. (Perhaps no such functions remain?)

#FIXME: We *ABSOLUTELY* need to declare this parcel earlier -- at least before
#={15-set}. Assuming we need to call any functions from such parcel, we'll have
#to split ={15-set} into two new trees -- say, ={15-set} defining only the
#small subset of setters required by this parcel and ={25-set} defining the
#remainder. How large of a subset is this, anyway?

#FIXME: For efficiency, declaration functions in this and other parcels should
#only define help functions when actually compiling help documentation and
#hence utilizing such functions. (Or do we *ALWAYS* compile such
#documentation?) Contemplate.

#FIXME: Document the fact that global values may actually be delimited by an
#arbiratry number of "=" delimiters, in which case this function defines *ALL*
#such globals to be synonyms of each other assigned the same initial value.
#Required elsewhere. Sweet, eh?

#FIXME: We're certain we've documented this elsewhere, but the correct approach
#to documentation is to segregate *EACH* bit of documentation into its own
#setter function setting a passed string variable to the documentation for the
#desired object: e.g.,
#
#    # Set such string variable to the help string for function
#    # ::define_func().
#    void ::set_string_to_help:func::define_func(void string_name)
#
#Naturally, *ALL* such setters should be compiled into a *NEW, SEPARATE* digest
#file (e.g., "~/.zeshy/cache/digest/help.zwc"), which doesn't depend on whether
#or not this is a debug or release build of zeshy and hence applies to *ALL*
#possible main zeshy digests.
#
#How does segregating such setters to such digest help us? Simple. By default,
#such digest is *NOT* listed in the function path ${fpath}. In fact, *ONLY* low-
#level helper functions (e.g., :print_help_function()) internally and only
#temporarily prepend such digest to a local shadowing of ${fpath}. Indeed, such
#functions should probably temporarily reduce ${fpath} to *ONLY* such digest.
#
#Indeed, such technique provides a memorable means of implementing highly
#efficient, pure-zeshy read-only key-value stores, as I believe we've remarked
#elsewhere.

# See @{global} for help strings for all globals defined below. Likewise, see
# the end of this parcel for help strings for all functions defined below.

# ....................{ SETTERS                            }....................
#FIXME: Document me.

# :void ::help.set_to_stdin[
#     args = (^:string documentation_name),
#     stdin = (:string documentation)]
function ::help.set_to_stdin() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one string name.'

    # If standard input is either the empty string *OR* unreadable without
    # blocking, throw an exception; else, set the passed string to such input.
    :string.set_to_stdin_if_nonempty "${1}" || :die\
        'Documentation empty or not passed on standard input (e.g., as a here-document or -string).'
}

#FIXME: Document me.

# :void ::help.set_prototype,asciidoc(
#     :string documentation,
#     ^:string prototype_name,
#     ^:string asciidoc_name)
function ::help.set_prototype,asciidoc() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one help string, one prototype string, and one AsciiDoc string name.'
    local\
        help__ssthp="${1}"\
        prototype_name__ssthp="${2}"\
        asciidoc_name__ssthp="${3}"

    # If such documentation contains a blank line (i.e., "\n\n"), assume the
    # substring preceding such line to be the expected prototype. Else, throw
    # an exception.
    [[ ${help__ssthp} == ${~ZESHY_HELP_GLOB} ]] || :die\
        'Documentation invalid (i.e., contains no blank line separating prototype from non-prototype sections):'$'\n\n'${help__ssthp}

    # Set such strings.
    :string.set "${prototype_name__ssthp}" "${match[1]}"
    :string.set "${asciidoc_name__ssthp}"  "${match[2]}"
}

# ....................{ SETTERS ~ func                     }....................
#FIXME: Document me.

# :void :func.set_prototype(
#     :string/func func_name, ^:string string_name)
function :func.set_prototype() {
    (( # == 2 )) || :die 'Expected one function name and one string name.'
    ::operable.set_prototype_of_type "${@}" 'func'
}

# ....................{ SETTERS ~ operable                 }....................
#FIXME: Implement ::set_string_to_operable_type_asciidoc() along similar lines.
#FIXME: Document me.

# :void ::operable.set_prototype_of_type(
#     :string/func operable_name,
#     ^:string string_name,
#     :string operable_type)
function ::operable.set_prototype_of_type() {
    # Validate sanity.
    (( # == 3 )) || :die\
        'Expected one operable name, one string name, and one operable type.'
    local\
        operable_name__sstrtp="${1}"\
        string_name__sstrtp="${2}"\
        operable_type__sstrtp="${3}"\
        prototype_setter_name__sstrtp

    #FIXME: Nonsense. Call ::operable.set_prototype_setter_of_type() instead.

    # Name of the function setting such string to such operable's prototype.
    # See ::operable.document_prototype,asciidoc_of_type() for such
    # function's definition.
    prototype_setter_name__sstrtp="::set_string_to_${operable_type__sstrtp}_prototype:${operable_name__sstrtp}"
    :func.die_unless "${prototype_setter_name__sstrtp}"
    "${prototype_setter_name__sstrtp}" "${string_name__sstrtp}"
}

# ....................{ DOCUMENTERS ~ alias                }....................
#FIXME: Document me.
# :void :alias_simple.document[stdin = (:string alias_documentation)]
function :alias_simple.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::callable.document_stdin_of_type,label 'alias_simple' 'Simple alias'
}

#FIXME: Document me.
# :void :alias_global.document[stdin = (:string alias_documentation)]
function :alias_global.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::callable.document_stdin_of_type,label 'alias_global' 'Global alias'
}

#FIXME: Document me.
# :void :alias_suffix.document[stdin = (:string alias_documentation)]
function :alias_suffix.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::callable.document_stdin_of_type,label 'alias_suffix' 'Suffix alias'
}

#FIXME: Rename to ::alias.document_prototype,stdin_if_nonempty_or_noop_of_type().

#FIXME: Document me.
# :void ::alias.document_prototype,stdin_of_type_if_found_or_noop[
#     args = (
#         :string/alias alias_name1, ...,
#         :string alias_prototype,
#         :string alias_type)
#     stdin = (:string alias_asciidoc)]
function ::alias.document_prototype,stdin_of_type_if_found_or_noop() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more alias names, one alias prototype, and one alias type.'
    local alias_prototype="${@[-2]}" alias_type="${@[-1]}"

    # If such type is unrecognized, throw an exception.
    [[ ${alias_type} == ('simple'|'global'|'suffix') ]] || :die\
        'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # If such documentation was passed, document such aliases.
    ::operable.document_prototype,stdin_if_nonempty_or_noop_of_type\
        "${@[1,-3]}" "${alias_prototype}" "alias_${alias_type}"
}

# ....................{ DOCUMENTERS ~ func                 }....................
#FIXME: Document me.
# :void :func.document[stdin = (:string func_documentation)]
function :func.document() {
    (( # == 0 )) || :die 'Expected no arguments.'
    ::callable.document_stdin_of_type,label 'func' 'Function'
}

#FIXME: Rename to ::func.document_prototype,stdin_if_nonempty_or_noop().

#FIXME: Document me.
# :void ::func.document_with_prototype,stdin_if_found_or_noop[
#    args = (
#        :string func_name1, ...,
#        :string func_prototype),
#    stdin = (:string func_asciidoc)]
function ::func.document_with_prototype,stdin_if_found_or_noop() {
    (( # >= 2 )) || :die\
        'Expected one or more function names and one function prototype.'
    ::operable.document_prototype,stdin_if_nonempty_or_noop_of_type\
        "${@[1,-2]}" "${@[-1]}" 'func'
}

# ....................{ DOCUMENTERS ~ global               }....................
#FIXME: Document me.
# :void :global.document[stdin = (:string global_documentation)]
function :global.document() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'
    local global_help__dg global_prototype__dg global_asciidoc__dg
    local -a global_names__dg

    # Documentation passed on standard input.
    ::help.set_to_stdin global_help__dg

    # Split such documentation into prototype and non-prototype portions.
    ::help.set_prototype,asciidoc\
        "${global_help__dg}" global_prototype__dg global_asciidoc__dg

    # Global name declared by such documentation's prototype.
    :global_prototype.set_names "${global_prototype__dg}" global_names__dg 

    # Document such names.
    ::operable.document_prototype,asciidoc_of_type\
        "${global_names__dg[@]}"\
        "${global_prototype__dg}"\
        "${global_asciidoc__dg}"\
        'global'
}

# ....................{ DOCUMENTERS ~ callable             }....................
#FIXME: Document me.

# :void ::callable.document_stdin_of_type,label[
#     args = (:string callable_type, :string callable_label),
#     stdin = (:string callable_documentation)]
function ::callable.document_stdin_of_type,label() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one callable type and one callable label.'
    local\
        callable_type="${1}"\
        callable_label="${2}"\
        callable_help\
        callable_prototype\
        callable_asciidoc
    local -a callable_names

    # Documentation passed on standard input.
    ::help.set_to_stdin callable_help

    # Split such documentation into prototype and non-prototype portions.
    ::help.set_prototype,asciidoc\
         "${callable_help}" callable_prototype callable_asciidoc

    # Set of all callable names declared by such documentation's prototype.
    ::callable_prototype.set_names_of_label\
        "${callable_prototype}" callable_names "${callable_label}"

    # Document such names.
    ::operable.document_prototype,asciidoc_of_type\
        "${callable_names[@]}"\
        "${callable_prototype}"\
        "${callable_asciidoc}"\
        "${callable_type}"
}

# ....................{ DOCUMENTERS ~ operable             }....................
#FIXME: Document me.

# :void ::operable.document_prototype,stdin_if_nonempty_or_noop_of_type[
#     args = (
#        :string operable_name1, ...,
#        :string operable_prototype,
#        :string operable_type)
#     stdin: string runnable_documentation]
function ::operable.document_prototype,stdin_if_nonempty_or_noop_of_type() {
    # Validate sanity.
    (( # >= 3 )) || :die\
        'Expected one or more operable names, one operable prototype, and one operable type.'
    local operable_asciidoc__dotpwsifon

    # If documentation was passed on standard input, document such operables
    # with such documentation.
    if { :string.set_to_stdin_if_nonempty operable_asciidoc__dotpwsifon } {
        ::operable.document_prototype,asciidoc_of_type\
            "${@[1,-2]}" "${operable_asciidoc__dotpwsifon}" "${@[-1]}"
    }
}

#FIXME: Document me.
# :void ::operable.document_prototype,asciidoc_of_type(
#     :string operable_name1, ...,
#     :string operable_prototype,
#     :string operable_asciidoc,
#     :string operable_type)
function ::operable.document_prototype,asciidoc_of_type() {
    # Validate sanity. Since globals are operables and hence must *NOT* be
    # shadowed by locals declared below, mangle the names of such locals.
    (( # >= 4 )) || :die\
        'Expected one or more operable names, one prototype string, one asciidoc string, and one operable type.'
    local\
        prototype__odpaot="${@[-3]}"\
        asciidoc__odpaot="${@[-2]}"\
        operable_type__odpaot="${@[-1]}"\
        heredoc_delimiter__odpaot='/---/---/---'\
        prototype_setter__odpaot\
        asciidoc_setter__odpaot

    # Pop such arguments from the argument list. See pop_args_3() for further
    # details.
    argv[-3,-1]=()

    # If either such prototype or AsciiDoc contains a line equal to the
    # here-doc delimiter delimiting such strings below, throw an exception.
    [[ "${prototype__odpaot}"$'\n'"${asciidoc__odpaot}" != (|*$'\n')"${heredoc_delimiter__odpaot}"(|$'\n'*) ]] || :die\
        'Documentation contains here-doc delimiter "'${heredoc_delimiter__odpaot}'" reserved for internal zeshy use only.'

    # For each such operable name, define:
    #
    # * A setter setting a passed string variable to such prototype.
    # * A setter setting a passed string variable to such AsciiDoc.
    #
    # To avoid quoting issues with reserved characters in such documentation,
    # set such variable via a here-document.
    local operable_name__odpaot
    for   operable_name__odpaot ("${@}") {
        #FIXME: Actually, just eliminate such error-prone redundancy by
        #defining two new setters
        #::operable.set_prototype_setter_of_type() and
        #::operable.set_asciidoc_setter_of_type(), called like so:
        #
        #    local prototype asciidoc
        #    ::operable.set_prototype_setter_of_type\
        #        ':my_func' prototype 'func'
        #    ::operable.set_asciidoc_setter_of_type\
        #        ':my_func' asciidoc 'func'
        #FIXME: Incidentally, neither ::set_string_to_operable_type_prototype()
        #or ::set_string_to_operable_type_asciidoc() appear to exist anymore!
        #Grep the codebase for "::set_string_to_" to help uncover where they
        #lackadaisically tripped off to.
        #FIXME: O.K.; we've now defined general-purpose metadata setter
        #::operable.set_setter_of_type,metadata_type(). Call below. Yay!

        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize changes to such names with
        # ::set_string_to_operable_type_prototype() and
        # ::set_string_to_operable_type_asciidoc().
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # Names of such functions to be defined.
        prototype_setter="::set_string_to_${operable_type__odpaot}_prototype:${operable_name__odpaot}"
        asciidoc_setter="::set_string_to_${operable_type__odpaot}_asciidoc:${operable_name__odpaot}"

        # If any such function is already defined, throw an exception.
        :func.die_if "${prototype_setter}" "${asciidoc_setter}"

        #FIXME: We'll need to shift :string.set_to_stdin() to ={*-set} for
        #reliability with early-defined functions (e.g., :declare_alias()).

        # Define such functions.
        functions[${prototype_setter__odpaot}]='
    (( # == 1 )) || :die "Expected one string name."
    :string.set_to_stdin "${1}" <<'''${heredoc_delimiter__odpaot}'''
'${prototype__odpaot}'
'${heredoc_delimiter__odpaot}
        functions[${asciidoc_setter__odpaot}]='
    (( # == 1 )) || :die "Expected one string name."
    :string.set_to_stdin "${1}" <<'''${heredoc_delimiter__odpaot}'''
'${asciidoc__odpaot}'
'${heredoc_delimiter__odpaot}
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Refactor into
#::operable.document_prototype,stdin_if_found_or_noop_of_type().

        #FUXME: Use of heredoc delimiters is, frankly, overly fragile. (After
        #all, what if such prototype or documentation inexplicably contains
        #such 

#FUXME: Suffix all locals with "__dotwpa", as globals are operables too.

#FUXME: It'd be great to support specification of whether a function or alias
#argument is actually mandatory or optional in variadic lists. For example, in
#the following function prototype, all arguments except the first menu name are
#actually optional -- but we have no way of indicating that at the moment:
#
#    string show_info_menu_with_options(
#        string info_option1, string info_option2, ...,
#        string menu_name1, string menu_name2, ...)
#
#I propose a simple suffix "?" on all optional variadic arguments: e.g.,
#
#    string show_info_menu_with_options(
#        string info_option1?, string info_option2?, ...,
#        string menu_name1, string menu_name2?, ...)
#
#Fairly simple *AND* legible, yes?

#FUXME: I'm unsure if I've documented it anywhere... so, it had might as well be
#here. The nomenclature for synthesized help function names should be:
#
#* For aliases, "::set_string_to_help:alias:${alias_name}".
#* For functions, "::set_string_to_help:function:${function_name}".
#* For globals, "::set_string_to_help:global:${global_name}".
#
#Simple. Note that in the case of normal ":"-suffixed aliases and functions,
#the corresponding help function names will also be suffixed by ":" -- which is,
#of course, perfect. Lookin good, eh?

# ....................{ GLOBALS                            }....................
# typeset -g ZESHY_HELP_SETTER_NAME_PREFIX=':set_string_to_'

#FUXME: Document me.
# typeset -g ZESHY_OPERABLE_PROTOTYPE_SETTER_NAME_PREFIX=':set_string_to_prototype_'

#FUXME: Obsolete. Excise everywhere!

#FUXME: Replace with a new function ::func.document_with_type,prototype,stdin_if_found_or_noop() implemented as above.

# void ::func.document_with_prototype,asciidoc(
#     args: (
#         string alias_name1, ...,
#         string alias_type,
#         string alias_prototype),
#     stdin: string runnable_documentation]
# function ::func.document_with_prototype,asciidoc() {
#     (( # >= 3 )) || :die\
#         'Expected one or more function names, one function prototype, and one asciidoc string.'
#     ::operable.document_prototype,asciidoc_of_type\
#         "${@[1,-3]}" 'func' "${@[-2]}" "${@[-1]}"
# }

    # If standard input is either the empty string *OR* unreadable without
    # blocking, no such documentation was passed; in such case, silently report
    # succes. See ::help.set_to_stdin() for further details.
    # read -t 0 || return 0
    # print 'stdin exists!'
    # if { read -t 0 } {
    #     print 'stdin exists.'
    #     if { read -t 0 } {
    #         print 'stdin still exists.'
    #     }
    # } else {
    #     print 'stdin doesn''t exist!'
    #     return 0
    # }

    # Documentation passed on standard input.
    # ::help.set_to_stdin operable_asciidoc__dotpwsifon

    # # Document such names.
    # ::operable.document_prototype,asciidoc_of_type\
    #     "${@[1,-3]}"\
    #     "${operable_type__dotpwsifon}"\
    #     "${operable_prototype__dotpwsifon}"\
    #     "${operable_asciidoc__dotpwsifon}"

        # operable_type__dotpwsifon="${@[-2]}"\
        # operable_prototype__dotpwsifon="${@[-1]}"\

#FUXME: Use of "typed" rather than "type" nomenclature is somewhat awkward.
#Contemplate a global rename from the former to the latter.
#FUXME: Indeed, rename to simply ::document_alias_type_prototype,asciidoc().
#FUXME: Actually, rename to
#::document_stdin_with_alias_type,prototype,asciidoc_if_found_or_noop() and
#refactor to internally call ::callable.document_stdin_of_type,label() instead.
#FUXME: Excise this.
#FUXME: Document me.
# void ::document_alias_typed_with_prototype,asciidoc(
#     string alias_name1, ...,
#     string alias_type,
#     string alias_prototype,
#     string alias_asciidoc)
# function ::document_alias_typed_with_prototype,asciidoc() {
#     # Validate sanity.
#     (( # >= 4 )) || :die\
#         'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
#     local alias_type="${@[-3]}"
# 
#     # If such type is unrecognized, throw an exception.
#     [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
#         'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'
# 
#     # Document such alias.
#     ::operable.document_prototype,asciidoc_of_type\
#         "${@[1,-4]}" "alias_${alias_type}" "${@[-2]}" "${@[-1]}"
# }

    # Shift such arguments off. See shift_arg_2() for further details.
    # argv[1,2]=()

    # (( # == 3 )) || :die\
    #     'Expected one alias type, one alias prototype, and one asciidoc string.'
#FUXME: Rename to ::func.document_prototype,asciidoc().
    #FUXME: Define such setter!

    # # Validate sanity.
    # (( # >= 4 )) || :die\
    #     'Expected one or more alias names, one alias type, one alias prototype, and one asciidoc string.'
    # local\
    #     alias_type="${@[-3]}"\
    #     prototype="${@[-2]}"\
    #     asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_3() for further
    # # details.
    # argv[-3,-1]=()

    # # If such type is unrecognized, throw an exception.
    # [[ "${alias_type}" == ('simple'|'global'|'suffix') ]] || :die\
    #     'Alias type "'${alias_type}'" unrecognized (i.e., neither "simple", "global", or "suffix").'

    # # Document such alias.
    # ::operable.document_prototype,asciidoc_of_type\
    #     "${@}" "alias_${alias_type}" "${prototype}" "${asciidoc}"

    # # Validate sanity.
    # (( # >= 3 )) || :die\
    #     'Expected one or more function names, one function prototype, and one asciidoc string.'
    # local prototype="${@[-2]}" asciidoc="${@[-1]}"

    # # Pop such arguments from the argument list. See pop_args_2() for further
    # # details.
    # argv[-2,-1]=()

    # # Document such function.
    # ::operable.document_prototype,asciidoc_of_type\
    #     "${@}" 'func' "${prototype}" "${asciidoc}"

#FUXME: Rename to ::operable.document_prototype,asciidoc_of_type().
#FUXME: Actually, rename to ::document_operable_with_prototype,asciidoc().

 # IMPORTANT: Note in such documentation that neither such
#prototype or AsciiDoc may contain
#FUXME: Arguably, such functions pertain to a new parcel -- say, @{20-document}.
