#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *display server testers* (i.e., high-level functions testing whether the
current display server either is a particular such server _or_ belongs to a
particular category of such servers).
/---

# ....................{ GLOBALS                            }....................
# Note that @{inspect} sets string global ${ZESHY_DISPLAY_SERVER_NAME} at the
# beginning of digest compilation.

declare_global_with_stdin string ZESHY_DISPLAY_SERVER_ID <<'/---'
Machine-readable name of the *current display server* (i.e., the core component
of the current windowing system if any, defining the communications protocol
with which client GUI applications receive input and render output). Such
string is guaranteed to be nonempty, but may contain both whitespace and
capitalized letters and hence is _not_ human-readable.
/---

# ....................{ DEFINERS                           }....................
# To add support for a new display server:
#
# * Add a test detecting such server to @{inspect}, setting string global
#   ${ZESHY_DISPLAY_SERVER_NAME} to such server's human-readable name.
# * Add such server's machine-readable name to local list ${display_server_ids}.
# * Match such server's human-readable name below, setting string global
#   ${ZESHY_DISPLAY_SERVER_ID} to such server's machine-readable name.
# * Document :is_os_${ZESHY_DISPLAY_SERVER_ID}(), which this function defines.

declare_function_with_stdin <<'/---'
void ::define_display_server_testers(void)

Define all display server testers to unconditionally report either success or
failure.
/---
function ::define_display_server_testers() {
    # Validate sanity.
    die_if_args

    # List of all machine-readable display server names.
    :list display_server_ids; display_server_ids=(
        # Linux.
        mir wayland x

        # Other.
        cygwin_x quartz surface_flinger
    )

    # True if the current display server is explicitly recognized by zeshy.
    # (Defaults to true.)
    :bool is_display_server_recognized=1

    # True if the current display server supports the X11 protocol. Technically,
    # this boolean is also settable by matching human-readable display server
    # names as below (e.g., enabling this boolean if such name is "XQuartz").
    # Unlike tests for other display servers, however, this test is unlikely to
    # change with time *AND* the most efficient means of setting this boolean.
    :bool is_display_server_trait_x
          is_display_server_trait_x=$(( ${+DISPLAY} ))

    # If the current display server was previously identified by @{inspect}, map
    # from human- to machine-readable display server names (e.g., from "XQuartz"
    # to "quartz"). Technically, such names are also settable by copying the
    # corresponding @{inspect} tests here (e.g., "(( ${+MIR_SOCKET} ))",
    # implying the current display server to be Mir). Since such tests are
    # liable to change with time, however, centralizing such tests in @{inspect}
    # is preferable to repeating such tests here.
    if is -n "${ZESHY_DISPLAY_SERVER_NAME}" si {
        # Define a tester implying the current shell to be running under a
        # display server to report success.
        :define_function_to_report_success :is_display_server

        # Convert such human- to machine-readable display server name.
        case "${ZESHY_DISPLAY_SERVER_NAME}" {
        ('X')
            ZESHY_DISPLAY_SERVER_ID='x'
            :end_case
        (('X'|)'Mir')
            ZESHY_DISPLAY_SERVER_ID='mir'
            :end_case
        (('X'|)'Quartz')
            ZESHY_DISPLAY_SERVER_ID='quartz'
            :end_case
        (('X'|)'Wayland')
            ZESHY_DISPLAY_SERVER_ID='wayland'
            :end_case
        ('Cygwin/X')
            ZESHY_DISPLAY_SERVER_ID='cygwin_x'
            :end_case
        ('Surface Flinger')
            ZESHY_DISPLAY_SERVER_ID='surface_flinger'
            :end_case
        # Else, the current display server is unrecognized.
        (*)
            # Note such fact.
            is_display_server_recognized=0

            # Convert such human- to machine-readable name, resembling that
            # @{identify} applies to ${ZESHY_SYSTEM_ID} in addition to
            # lowercasing such name.
            ZESHY_DISPLAY_SERVER_ID="${(L)ZESHY_DISPLAY_SERVER_NAME//[^[:alpha:]]##/_}"

            # Since zeshy is likely to perform poorly under unrecognized display
            # servers, print a nonfatal warning.
            :output_warning\
                "Display server \"${ZESHY_DISPLAY_SERVER_NAME}\" unrecognized."
        }
    # Else, the current display server was *NOT* previously identified. Assuming
    # the tests performed by @{inspect} to be reliable, this implies the current
    # shell to *NOT* be running under a display server. Define the corresponding
    # tester to report failure.
    } else {
        :define_function_to_report_failure :is_display_server
    }

    # If the current display server was recognized, define the corresponding
    # tester to report success.
    if (( is_display_server_recognized )) {
        :define_function_to_report_success\
            ":is_display_server_${ZESHY_DISPLAY_SERVER_ID}"
    }

    # Define all other display server testers to report failure. For efficiency,
    # remove the current server from the list of all possible servers and
    # iterate such list. See remove_list_items() for further details.
    :string display_server_id_other
    for     display_server_id_other (
        "${display_server_ids[@]:#${ZESHY_DISPLAY_SERVER_ID}}") {
        :define_function_to_report_failure\
            ":is_display_server_${display_server_id_other}"
    }

    # Define testers corresponding to booleans set above accordingly.
    :define_function_to_report_bool\
        :is_display_server_trait_x "${is_display_server_trait_x}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_display_server(void)

Report success if the current process is a child of a *terminal window* (i.e.,
GUI terminal emulator). If this is the case, such window _must_ be a client of
the current windowing system's display server, implying unredirected output from
the current shell to be displayed by such server.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_cygwin_x(void)

Report success if the current display server is *Cygwin/X* (i.e., a Microsoft
Windows-specific port of the X.Org display server running under the Unix-like
Cygwin environment).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_mir(void)

Report success if the current display server is *Mir* (i.e., the compositing
display server underlying recent versions of Ubuntu's Unity UI).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_quartz(void)

Report success if the current display server is the *Quartz Compositor* (i.e.,
the core renderer for Apple OS X, serving as both display server _and_
compositing window manager).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_surface_flinger(void)

Report success if the current display server is *Surface Flinger* (i.e., the
core renderer for Google Android).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_wayland(void)

Report success if the current display server is a *Wayland compositor* (i.e., a
display server supporting the Wayland communication protocol).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_x(void)

Report success if the current display server is *X.Org* (i.e., the current
reference implementation of a display server supporting the X11 communication
protocol forked from the prior reference implementation *XFree86*, managed by
the X.Org Foundation), also referred to as *X*.

== Caveats ==

*This function does returns failure if the current display server supports the
X11 protocol but is _not_ X.Org.* Since the former condition is typically more
interesting than the latter, consider calling :is_display_server_trait_x()
instead.
/---

# ....................{ TESTERS ~ trait                    }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_display_server_trait_x(void)

Report success if the current display server supports *X11* (i.e., the core
communications protocol of the X Window System). Such protocol is also referred
to as *X* or *X.Org* (i.e., the current reference implementation of an X11
display server developed by the X.Org Foundation).

== Caveats ==

*Success implies only that X11 applications may be reliably run.* Success does
_not_ imply that CLI utilities commonly bundled with the X.Org Server (e.g.,
"xauth", "xrdb") are pathable or otherwise available. Rephrased, success only
implies the current display server to _support_ X11 rather than to _be_ the
X.Org Server -- a significantly stronger claim. Indeed, several windowing
systems unaffiliated with the X.Org Foundation provide optional display servers
supporting the X11 protocol but _not_ such CLI utilities (e.g., XWayland, XMir).
/---

# ....................{ MAIN                               }....................
::define_display_server_testers

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename to :is_display_server_trait_x(). Then define an actual function
#:is_display_server_x() reporting success only if the current display server is
#actually X.org. (This is fairly important.)

# declare_function_with_stdin <<'/---'
# [status: bool] :is_display_server_windows(void)
# 
# Report success if the current display server is *Microsoft Windows*. While such
# platform technically provides no such server, this function nonetheless reports
# success on such platform (for both orthogonality and sanity).
# /---

            #FUXME: Convert all non-letters to underscores. Shouldn't be
            #terribly difficult, elsewhere? We should probably be performing the
            #same conversion in similar parcels as well.

            # converting all dashes and contiguous runs of one or more spaces into
            # underscores.
#FUXME: Define statically above.

# If the current OS:
#
# * Is Linux, test for all possible display servers (in descending order
#   of likelihood).
# * Is a proprietary OS mandating a single display server (e.g., OS X, Windows),
#   always succeed.
# * Is any other OS, test for all commonly ported display servers. Since neither
#   Wayland or Mir have been successfully ported to non-Linux OSes, this reduces
#   to testing for X.
# :define_function_if :is_display_server\
#     'die_if_args' ''\
#     ':is_os_trait_linux'\
#         ':is_display_server_x or
#             :is_display_server_wayland or
#             :is_display_server_mir'\
#     ':is_os_trait_darwin or :is_os_windows'\
#         'report_success'\
#         ':is_display_server_x'  # else

# function :is_display_server_x() {
#     # X *ALWAYS* exports such variable to X clients as a string describing the
#     # connection to the current X display server, formatted as a ":"-delimited
#     # optional hostname followed by mandatory display number. In any case, the
#     # existence of such global unambiguously implies the current shell to be
#     # running under X. Indeed, setting such variable in an environment *NOT*
#     # running under X provokes calamity, suggesting that should never happen.
#     #
#     # To corroborate such test, we could also test the existence of at least one
#     # process running "${commands[X]}" as the current user *AND* listening to
#     # the current value of ${DISPLAY}. However, since this function is called
#     # comparatively early in zeshy startup, inlining process testing
#     # functionality here would both be somewhat burdensome and inefficient. In
#     # the immortal words of Malcolm Reynolds, "Frack that."
#     die_if_args
#     (( ${+DISPLAY} ))
# }
# function :is_display_server_mir() {
#     # Mir *ALWAYS* exports such variable to Mir clients as the named socket for
#     # the current Mir display server. To quote a recent Mir commit: "Servers now
#     # set the $MIR_SOCKET environment variable to their own socket name for any
#     # direct children's benefit." See :is_display_server_x() for further
#     # discussion.
#     die_if_args
#     (( ${+MIR_SOCKET} ))
# }
# function :is_display_server_wayland() {
#     # Wayland *ALWAYS* exports such variable to Wayland clients as the named
#     # socket for the current Wayland display server. To quote "man weston":
#     # "Weston will export WAYLAND_DISPLAY with this value in the environment for
#     # all child processes to allow them to connect to the right server
#     # automatically." See :is_display_server_x() for further discussion.
#     die_if_args
#     (( ${+WAYLAND_DISPLAY} ))
# }

# Since multiple OSes offer optional X11 support, define such functions in a
# generic rather than OS-specific manner.

#FUXME: Ideally, the current digest file should depend not only on the current
#OS but on the current display server and window manager. Once that's
#accomplished, such functions should efficiently reduce to *ALWAYS* reporting
#success or failure (as with @{*-test/*-os}).

# (i.e., is either a direct client of such a system or running under  and hence display server.
# (i.e., the core component of windowing systems, defining the communications
# protocol with which client GUI applications receive input and render output).
# Success implies the current shell to be running under a client of a currently
# running display server, typically a GUI terminal (e.g., `terminator`).

# -- the core component of windowing systems, defining the
# communications protocol with which client GUI applications receive input and
# render output -- 

# If the current OS mandates a single monolithic display server, always succeed.
# if { :is_os_trait_darwin or :is_os_windows } {
#     function :is_display_server() {
#         die_if_args
#         report_success
#     }
# # Else if such OS is Linux, test for all possible display servers. For
# # efficiency, test in descending order of likelihood.
# } elif { :is_os_trait_linux } {
#     function :is_display_server() {
#         die_if_args
#         :is_display_server_x or
#             :is_display_server_wayland
#             :is_display_server_mir
#     }
# # Else, test for all possible display servers. Since neither Wayland or Mir have
# # been successfully ported to non-Linux OSes, this currently reduces to testing
# # for the X display server.
# } else {
#     function :is_display_server() {
#         die_if_args
#         :is_display_server_x
#     }
# }

#Since the
# current windowing system may be (and probably is, under recent such systems)
# running multiple display servers,
# *Such success does _not_ imply the current display server to be X11.* , a weaker claim than the implication that such server _is_ X11

#FUXME: Ugh. Detecting whether the current shell is running under Mir or Wayland
#appears to be rather difficult. Neither appears to interect in any way closely
#with the shell. In particular, neither appears to export any requisite global
#variables. So how *DO* we detect such servers? Grep the process list. (Yes,
#this verascibly sucks.) For example, one suggested method online for checking
#whether or not Mir is currently running is:
#
#    >>> ps afx | grep unity-system-compositor
#
#But even *THAT* doesn't necessarily imply that the current shell is running
#under Mir (e.g., such shell could simply be running under a virtual console).
#For a truly reliable check, we'd need to test whether the current shell is
#transitively descended from such process.
#
#Now, you're probably thinking: that's horrible. And it is. *BUT*, since Mir and
#Wayland are effectively Linux-specific (although we recall reading about an
#effort to port Wayland to FreeBSD), we can effectively assume the GNU/Linux
#ecosystem of CLI utilities exists to implement such tests, which dramatically
#simplifies things. In any case, discomforting topics for another langorous day.
