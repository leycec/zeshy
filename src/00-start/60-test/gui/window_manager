#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *window manager testers* (i.e., high-level functions testing whether the
current window manager -- the component of the current windowing system managing
window appearance and placement -- is or is compatible with various well-known
window managers).
/---

#FIXME: This turns out to be *HIGHLY* non-trivial unless external command
#"wmctrl" is installed, in which case this is trivially resolved by parsing the
#output of "wmctrl -m". For further details, see:
#
#    http://askubuntu.com/questions/72549/how-to-determine-which-window-manager-is-running
#
#We're half-inclined to make "wmctrl" at least a soft (i.e., recommended)
#"zeshy" dependency. There's simply no other reliable means of obtaining such
#metadata. (None that I'm willing to stoop to, anyway!)
#
#O.K.; we've manually verified the window manager is reliably obtainable from
#the "Name:" but *NOT* "Class:" field output by "wmctrl -m". (The latter is
#frequently, though not necessarily "N/A".) Note that while the name is case-
#sensitive but usually lowercase (e.g., "compiz", "awesome"), such name is
#actually capitalized under a few window managers (e.g., "FVWM"). In other
#words, force such name to lowercase before testing.
#
#Examples of such output culled from both first- and third-person use:
#
#    >>> wmctrl -m
#    Name: FVWM
#    Class: fvwm
#    PID: N/A
#    Window manager's "showing the desktop" mode: N/A
#
#    >>> wmctrl -m
#    Name: compiz
#    Class: N/A
#    PID: N/A
#    Window manager's "showing the desktop" mode: OFF
#
#Clearly, trivial to match, if a little expensive. We certainly wouldn't want to
#invoke a subshell and perform such parsing on *EVERY* call to a tester function
#defined below, so define a new :set_string_to_window_manager() function. For
#efficiency, such function should internally cache to string global
#${ZESHY_WINDOW_MANAGER} on the first call to such function and thereafter
#reuse the cached value of such global. Testers then call such function without
#having to worry about caching or efficiency.
#
#As a caveat, it should be noted that "wmctrl" is X11-specific and hence Linux-
#specific. Under proprietary operating systems, such function does *NOT* require
#"wmctrl", since the windowing manager in that case is given by the operating
#system name, and hence can be efficiently implemented at digest compile time as
#such. On BSD derivatives, however, I genuinely have no idea how to query for
#such metadata reliably. Perhaps one simply can't? In any case, we should still
#be able to reliably query every non-BSD OS for such metadata. Make it so,
#please!

# ....................{ TESTERS                            }....................
#FIXME: In the general case, :set_string_to_window_manager() is a fairly
#expensive function to call. Hence, defining testers in terms of such function
#may not necessarily be the best call. What we *REALLY* want to do is have the
#current digest conditionally depend not only on the current OS but current
#window manager as well. This would basically require us to push the
#implementation of :set_string_to_window_manager() into @{src/digest} or
#thereabouts, which would be a fairly heavy move. So... perhaps not? Right.
#Unlike desktop environments (e.g., KDE), which *CAN* fairly reliably be
#detected by testing for the existence of guaranteed environment variables
#(e.g., ${KDE_SESSION_ID} or some such), window managers really can't be. So, we
#probably do need to allow the same digest file to be shared between multiple
#managers. Of course, that would preclude us from ever compiling window manager-
#specific code into zeshy, which... is *TERRIBLE*! No, really. We *REALLY* want
#to be able to do that.
#
#Which strongly implies we need to push :set_string_to_window_manager() into
#@{src/digest}. Yes, it's a fairly heavy move. But there's little alternative.
#Actually, I should note we only need to push a subset of such functionality to
#@{src/digest}: basically, just the core logic getting the raw window manager
#name. Don't bother munging it. We just need a unique string for comparison and
#caching purposes -- *NOT* for creating human-readable function names or output
#labels. That means we can reduce such logic in @{src/digest} to:
#
#* If in X (i.e., if `(( ${+DISPLAY} ))`) and either `xprop` or `wmctrl` is
#  pathable, run such command to obtain a raw window manager name. Don't bother
#  lowercasing it or doing *ANYTHING*, really, except returning the raw string.
#* Else, report the current window manager name to be ${OSTYPE}. (Dead simple.)

# ....................{ SETTERS                            }....................
#FIXME: The list of Linux window managers is woefully incomplete. Improve!
#FIXME: If ${ZESHY_WINDOW_MANAGER_NAME} is empty, throw an exception.
declare_function_with_stdin <<'/---'
void :set_string_to_window_manager(string string_name)

Set the passed string to exactly one lowercase word uniquely identifying the
*current window manager* (i.e., the component of the current windowing system
managing windows for the current display of the current display server) if the
current display is managed by a display server or throw an exception otherwise:
e.g.,

.:set_string_to_window_manager()
==========================================
[source]
------------------------------------------
>>> :string window_manager
>>> :set_string_to_window_manager window_manager
>>> output_string "${window_manager}"
fvwm
------------------------------------------
==========================================

== Implementation ==

Under OSes supporting only a single monolithic window manager (e.g., iOS,
Windows), this function unconditionally sets such string to a constant
identifying such manager (e.g., `quartz`, `windows`).

Under all other OSes (e.g., BSD and Linux derivatives), this function
conditionally sets such string to the result of running either reliable window
management commands if pathable (e.g., `wmctrl`, `xprop`) or unreliable process
finders otherwise (e.g., `pgrep`).

== Window Managers ==

This function identifies common window managers as follows (in lexicographic
order grouped by operating system):

.Linux (and Sometimes BSD) Window Managers
[cols=">strong,^,^,<emphasis",options="header"]
|===============================================================================
| Name    | Window Manager | Desktop Environment
| awesome | awesome        | N/A
| compiz  | Compiz         | N/A
| fvwm    | FVWM           | N/A
| kwin    | KWin           | KDE 4
| marco   | Marco          | MATE
| metacity| Metacity       | GNOME 2
| mutter  | Mutter         | GNOME 3
| xfwm4   | Xfwm4          | Xfce4

.OS-specific Window Managers
[cols=">strong,^,^,<emphasis",options="header"]
|===============================================================================
| Name    | Window Manager    | Operating System
| quartz  | Quartz Compositor | OS X
| windows | Windows           | Windows
/---
# If the current OS dictates a stock window manager, define such function to
# unconditionally set such string to such manager's name.
if { :is_os_trait_darwin } {
    function :set_string_to_window_manager() {
        # See below.
        die_unless_arg 'Expected one string name.'
        :string string_name__sstwm="${1}"
        [[ "${(tP)string_name__sstwm-}" == 'scalar'* ]] || die\
            '${'${string_name__sstwm}'} undefined or not a string.'
        : "${(P)string_name__sstwm::=quartz}"
    }
} elif { :is_os_windows } {
    function :set_string_to_window_manager() {
        die_unless_arg 'Expected one string name.'
        :string string_name__sstwm="${1}"
        [[ "${(tP)string_name__sstwm-}" == 'scalar'* ]] || die\
            '${'${string_name__sstwm}'} undefined or not a string.'
        : "${(P)string_name__sstwm::=windows}"
    }
# Else if the current display server supports the X11 protocol and a command for
# querying X11 window properties is pathable, define such function to set such
# string to the output of such command.
} elif { is_pathable 'xprop' } {
    function :set_string_to_window_manager() {
        # Validate sanity.
        die_unless_arg 'Expected one string name.'
        :string\
            string_name__sstwm="${1}" window_id_wm__sstwm wm_name__sstwm

        # If such string is undefined or not of the expected type, throw an
        # exception. See :is_var_string() for further details.
        [[ "${(tP)string_name__sstwm-}" == 'scalar'* ]] || die\
            '${'${string_name__sstwm}'} undefined or not a string.'

        # Get the window ID of the child window of the root window whose window
        # properties reflect the current window manager rather than such window.
        # Default "xprop" output is cumbersome to parse: e.g.,
        #
        #     _NET_SUPPORTING_WM_CHECK(WINDOW): window id # 0x80001a
        #
        # Hence, pass options streamlining such output: e.g.,
        #
        #     _NET_SUPPORTING_WM_CHECK 0x80001a
        window_id_wm__sstwm="$(command xprop -root -notype\
            -f _NET_SUPPORTING_WM_CHECK 32x ' $0' _NET_SUPPORTING_WM_CHECK)"

        # Strip the prefixing property name from such ID.
        window_id_wm__sstwm="${window_id_wm__sstwm##* }"

        # Get the name of the current window manager from such window. Again,
        # default "xprop" output is cumbersome to parse: e.g.,
        #
        #     _NET_WM_NAME(UTF8_STRING) = "FVWM"
        #
        # Hence, pass options streamlining such output: e.g.,
        #
        #     _NET_WM_NAME "FVWM"
        wm_name__sstwm="$(command xprop -id "${window_id_wm__sstwm}" -notype\
            -f _NET_WM_NAME 8u ' $0' _NET_WM_NAME)"

        # Munge such name. Specifically:
        #
        # * Strip the prefixing property name and '"' from such name.
        # * Strip the suffixing '"' from such name.
        # * Lowercase such name.
        # * Convert all spaces in such name to underscores. (Though rare, window
        #   manager names can technically contain spaces.)
        wm_name__sstwm="${(L)${wm_name__sstwm##*\"}[1,-2]// /_}"

        # Set such string. See set_string_to_string() for further details.
        : "${(P)string_name__sstwm::=${wm_name__sstwm}}"
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: O.K.; if we define testers *AFTER* :set_string_to_window_manager(), we
#can actually define them to statically always report either success or failure,
#as in other sibling parcels. That would seem to preferable

#FUXME: Woo! After trolling through the *VERY* simple "wmctrl" codebase
#(basically, a single C file "main.c"), it's clear that we should be able to
#retrieve such name using standard CLI utilities bundled with X.Org. Take a
#look at function wm_info() in such codebase, which (in order):
#
#* Dies unless the root window supports *EITHER* property
#  "_NET_SUPPORTING_WM_CHECK" or "_WIN_SUPPORTING_WM_CHECK".
#* Assuming it does, retrieves the value of the "_NET_WM_NAME" property on the
#  root window.
#
#That's it. Serious! Dead simple, right? So, given that, all we have to do is
#obtain such properties... which, fortuitously, command "xprop -root" provides.
#"We're soo there, dude." Interestingly, despite the simplicity, *NOBODY* else
#appears to have ever thought of this. Not on stackexchange.com; not on
#commandlinefu.com; not on askubuntu.com. Nowhere! Bizarre, but we personally
#vouch for the following as reliably working and *NOT* requiring "wmctrl". Given
#the number of posts on this exact same question, we should probably post this
#to stackexchange (answer our own question! har):
#
#    # Need to also check "_WIN_SUPPORTING_WM_CHECK" if this fails, as above.
#    >>> command xprop -root _NET_SUPPORTING_WM_CHECK
#    _NET_SUPPORTING_WM_CHECK(WINDOW): window id # 0x80001a
#    >>> command xprop -id 0x80001a _NET_WM_NAME
#    _NET_WM_NAME(UTF8_STRING) = "FVWM"
#
#Dark voodoo here, but it *DOES* work reliably. Basically, under X11, the root
#window actually appears to have an invisible pseudo-parent window, which when
#queried provides metadata not about itself but the current window manager. Yes,
#this is insanity. This is X11.
#
#Now, we should note that the above output is somewhat cumbersome to parse and
#will require at least two separate subshells to fully capture, thus justifying
#our use of caching here. We can't avoid the subshells, but we *CAN* avoid the
#parsing by requesting "xprop" output in a simplified format: e.g.,
#
#    # Just capture the second word, below! (Alternately, just truncate
#    # everything preceding the only space in such line. Unsure which is more
#    # efficient, here.)
#    #
#    # Need to also check "_WIN_SUPPORTING_WM_CHECK" if this fails, as above.
#    >>> command xprop -root -notype -f _NET_SUPPORTING_WM_CHECK 32x ' $0' _NET_SUPPORTING_WM_CHECK 
#    _NET_SUPPORTING_WM_CHECK 0x80001a
#
#    # This is slightly harder to parse, since we'll need to strip the
#    # delimiting double quotes. Sadly, there appears to be *NO* means of
#    # instructing "xprop" to drop such quotes. *shrug* Anyway, since they
#    # always appear, they can be efficiently dropped by just stripping
#    # everything preceding the first '"' in such line *AS WELL AS* the final
#    # character of such line. Simple and efficient, if slightly annoying.
#    >>> command xprop -id 0x80001a -notype -f _NET_WM_NAME 8u ' $0' _NET_WM_NAME
#    _NET_WM_NAME "FVWM"
#
#Given the above complexity, we probably want to define a new
#:set_int_to_x_window_id_for_window_manager() setter, performing the first
#operation above. Oh, wait... Since we have *NOTHING* to query the window
#manager about except its name, that's probably a tad overkill. Just perform
#both operations in the same :set_string_to_window_manager() function. "Bam!"
#FUXME: Note there exists a related external command "xwininfo". While the CLI
#interface and output of such command is somewhat more convenient than that of
#"xprop", "xwininfo" sadly lacks support for retrieval of arbitrary window
#properties and hence is useless for our purposes.
#FUXME: While OS X does *NOT* support alternative window managers in the
#technical sense, it does permit window layout customization within the context
#of the only available window manager, Quartz Compositor. Curiously, the OS X
#community has taken to calling such customizations "window managers." They are
#not. Consequently, our job is quite simple under OS X:
#:set_string_to_window_manager() should always set such string to "quartz".

        # If such name requires manual conversion, do so.
        # case "${wm_name__sstwm}" {
        # metacity) wm_name__sstwm='gnome2';;
        # mutter)   wm_name__sstwm='gnome3';;
        # }

        # # Else, convert such name from X11- to zeshy-specific nomenclature.
        # # Specifically, lowercase such name.
        # wm_name__sstwm="${(L)wm_name__sstwm}"

# to dynamically query the current windowing
# system for the window manager managing the current display
# such strings for several
# popular window managers include:
# 
# Such string will be set to exactly one lowercase word uniquely identifying the
# current window manager. Grouped by operating system, such strings for several
# popular window managers include:

# Such string will be set to one or more (typically one) lowercase words uniquely
# identifying the current window manager. Grouped by operating system, these are
# (for a few commonly used window managers map to the following strings:
