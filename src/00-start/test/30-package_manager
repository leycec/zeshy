#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *package manager testers* (i.e., high-level functions testing which of
several possible package managers is available on the current system).

== Linux Distributions ==

GNU/Linux distributions are Unix-like operating systems comprising:

* The Linux kernel.
* A distribution-specific userland comprising at least:
** The GNU userland.
** Typically, at least one package management system (e.g., Portage).
** Typically, at least one a system management daemon (e.g., systemd).

Since all GNU/Linux distributions comprise at least the Linux kernel and GNU
userland, such distributions are principally distinguished by their choice of
package management system(s) and system management daemon(s). Since there exist
considerably fewer package management systems and system management daemons
(both numbering at most in the tens) than there do GNU/Linux distributions
(numbering at least in the thousands), detecting the former is both more
efficient and reliable than detecting the latter.

However, such detection is _not_ merely a matter of efficiency or reliability.
It's a matter of asking the right questions, a prerequisite for receiving the
right answers. In most cases, the right question is _not_ ``What is the current
GNU/Linux distribution?'' The right question is ``Which package management
systems and system management daemons are available on whatever happens to be
the current operating system (which may not even be a GNU/Linux distribution)?''

=== Package Managers ===

There does _not_ exist a one-to-one relationship between GNU/Linux distributions
and package managers. Such managers are also available under other GNU/Linux
distributions directly derived from the parent distribution _and_ non-GNU/Linux
operating systems (e.g., Portage, available under all Gentoo-based GNU/Linux
distributions _and_ such non-GNU/Linux operating systems as Apple OS X and
Gentoo/FreeBSD).

Indeed, there exists a many-to-many relationship between GNU/Linux distributions
and package managers. Multiple such managers are often available under the same
operating system. Apple OS X is the poster child for such ``promiscuity,''
providing one or more of the following package management systems:

* Gentoo Prefix, a subset of Gentoo Linux installing the Portage system under a
  user-configurable offset of the current filesystem.
* Fink, a port of the Debian dpkg system.
* MacPorts, an OS X-specific system inspired by the BSD ports collection.

Since package management systems are neither distribution-specific _or_ mutually
exclusive, `zeshy` attempts to detect all such systems available on the current
operating system -- regardless of whether this is even an operating system
commonly associated with package management systems.
/---

# While we *COULD* persist the sets of all human- and machine-readable names of
# all package management systems available on the current OS, doing so implies
# considerably more effort than we currently care to invest in the matter. For
# now, we only provide specific testers.

# ....................{ DEFINERS                           }....................
# To add support for a new package management system:
#
# * Add a new key-value pair to map local ${package_manager_name_to_found} with:
#   * String key set to such system's machine-readable name.
#   * Boolean value set to whether such system is currently available.
# * Document :is_package_manager_${name}(), where ${name} is such system's
#   machine-readable name.
#
# zeshy uses such systems to automate package handling and hence assumes *ALL*
# such systems to provide dependency resolution (i.e., to both automatically
# track installed dependencies and resolve uninstalled dependencies). The
# following package management systems do *NOT* provide such resolution and
# hence are excluded:
#
# * "slackpkg", the official package management system for Slackware and several
#   Slackware-derived distributions. While there *DO* exist unofficial
#   alternatives providing package management (e.g., "slapt-get", "sbotools"),
#   supporting the rapidly changing landscape of unsupported Slackware packagers
#   would be a bit beyond the pale. All such systems are currently excluded.

declare_function_with_stdin <<'/---'
void ::define_package_manager_testers(void)

Define all package manager testers to unconditionally report either success or
failure.
/---
function ::define_package_manager_testers() {
    # Validate sanity.
    die_if_args

    # Map each recognized package management system to a boolean true if such
    # system is currently available. Such systems are neither operating system-
    # or Linux distribution-specific and hence must be detected by other means
    # (e.g., testing for system-specific pathables).
    :map package_manager_name_to_found; package_manager_name_to_found=(
        alpm     0
        apt      0
        conary   0
        entropy  0
        fink     0
        macports 0
        nix      0
        pbi      0
        pkg_add  0
        pkgng    0
        portage  0
        urpmi    0
        yum      0
        zypp     0
    )

    # Detect operating system-agnostic package management systems.
    package_manager_name_to_found[apt]=$(( ${+commands[apt-get]} ))
    package_manager_name_to_found[portage]=$(( ${+commands[portageq]} ))

    # If the current operating system is GNU/Linux, detect GNU/Linux-
    # specific package management systems.
    if { :is_os_linux_gnu } {
        package_manager_name_to_found[alpm]=$(( ${+commands[pacman]} ))
        package_manager_name_to_found[conary]=$(( ${+commands[conary]} ))
        package_manager_name_to_found[entropy]=$(( ${+commands[equo]} ))
        package_manager_name_to_found[nix]=$(( ${+commands[nix-env]} ))
        package_manager_name_to_found[urpmi]=$(( ${+commands[urpmi]} ))
        package_manager_name_to_found[yum]=$(( ${+commands[yum]} ))
        package_manager_name_to_found[zypp]=$(( ${+commands[zypper]} ))
    # If the current operating system is a BSD derivative, detect BSD-
    # specific package management systems.
    } elif { :is_os_trait_bsd } {
        package_manager_name_to_found[pbi]=$(( ${+commands[pbi-manager]} ))
        package_manager_name_to_found[pkg_add]=$(( ${+commands[pkg_add]} ))
        package_manager_name_to_found[pkgng]=$(( ${+commands[pkg]} ))
    # If the current operating system is OS X, detect OS X-specific package
    # management systems.
    } elif { :is_os_os_x } {
        package_manager_name_to_found[fink]=$(( ${+commands[fink]} ))
        package_manager_name_to_found[macports]=$(( ${+commands[port]} ))
    }

    # Nonzero if at least one such package manager is currently available.
    # Since all values of map ${package_manager_name_to_found} are either 0
    # or 1, concatenating all such values together *ALWAYS* results in a valid
    # nonnegative integer that is 0 only if all such values are 0 (i.e., only if
    # no such package managers are currently available). Since such variable
    # accepts non-boolean values, declare such variable as an integer rather
    # than boolean. Dismantled, this is:
    #
    # * "(v)", concatenating all such values delimited by spaces (e.g.,
    #   "0 1 0 1 0 0 0 0 0 1").
    # * "// ", removing all such spaces (e.g., "0101000001").
    :int is_package_manager
    is_package_manager="${(v)package_manager_name_to_found// }"

    # If no such manager is available, print a nonfatal warning.
    (( is_package_manager )) or :output_warning "No package manager detected."

    # Define testers corresponding to booleans set above accordingly.
    :define_func_to_report_bool :is_package_manager "${is_package_manager}"

    # For each key-value pair of such map, declare the corresponding tester.
    :string package_manager_name is_package_manager
    for     package_manager_name is_package_manager (
        "${(kv@)package_manager_name_to_found}") {
        :define_func_to_report_bool\
            ":is_package_manager_${package_manager_name}"\
            "${is_package_manager}"
    }
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager(void)

Report success at least one *package management system* (i.e., software
automating the installation, upgrade, configuration, and removal of software
packages under the current system) is available on the current system.
/---

# ....................{ TESTERS ~ general                  }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_apt(void)

Report success if Debian's *Advanced Packaging Tool (APT)* (i.e., the operating
system-independent dpkg-based system with which most dpkg-based GNU/Linux
distributions and numerous non-Linux operating systems automate package
management) is currently available. If this is the case, all commands in APT's
official suite (e.g., `apt-cache`, `apt-get`) are guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_portage(void)

Report success if Gentoo's *Portage package management system* (i.e., the
operating system-independent system with which Gentoo Linux and relatives
automate package management) is currently available. If this is the case,
Portage's official package manager `emerge` is guaranteed to be pathable.
/---

# ....................{ TESTERS ~ bsd                      }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_pbi(void)

Report success if PC-BSD's *Push Button Installer (PBI) package management
system* (i.e., the system with which PC-BSD automates package management) is
currently available. If this is the case, PBI's official package manager
`pbi-manager` is guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_pkg_add(void)

Report success if NetBSD and OpenBSD's *pkg_add package management system*
(i.e., the ports collection-based system with which NetBSD, OpenBSD, and
relatives automate package management) is currently available. If this is the
case, all commands commonly provided by such system (e.g., `pkg_add`,
`pkg_delete`) are guaranteed to be pathable.

== Caveats ==

FreeBSD formerly used but recently replaced such system with *pkgng*, a
similar ports collection-based system. OpenBSD and NetBSD both retain such
system. Under NetBSD, such system is referred to as *pkgsrc*.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_pkgng(void)

Report success if FreeBSD's *pkgng package management system* (i.e., the ports
collection-based system with which FreeBSD and relatives automate package
management) is currently available. If this is the case, pkgng's official
package manager `pkg` is guaranteed to be pathable.
/---

# ....................{ TESTERS ~ linux                    }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_alpm(void)

Report success if the *Arch Linux Package Manager (ALPM)* (i.e., the system with
which Arch Linux and relatives automate package management) is currently
available. If this is the case, ALPM's official package manager `pacman` is
guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_conary(void)

Report success if Foresight's *Conary package management system* (i.e., the
system with which Foresight Linux and relatives automate package management) is
currently available. If this is the case, Conary's official package manager
`conary` is guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_entropy(void)

Report success if Sabayon's *Entropy package management system* (i.e., the
system with which Sabyon Linux and relatives automate package management) is
currently available. If this is the case, Entropy's official package manager
`equo` is guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_nix(void)

Report success if NixOS' *Nix package management system* (i.e., the pure-
functional system with which NixOS and relatives automate package management) is
currently available. If this is the case, all commands in Nix's official suite
(e.g., `nix-env`, `nix-store`) are guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_urpmi(void)

Report success if Mageia's *urpmi package management system* (i.e., the system
with which Mageia Linux and relatives automate package management) is currently
available. If this is the case, all commands in urpmi's official suite (e.g.,
`urpme`, `urpmi`) are guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_yum(void)

Report success if the *Yellowdog Updater, Modified (yum) package management
system* (i.e., the Red Hat Package Manager (RPM)-based system with which most
RPM-based GNU/Linux distributions automate package management) is currently
available. If this is the case, yum's eponymous package manager `yum` is
guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_zypp(void)

Report success if SUSE's *ZYpp package management system* (i.e., ``Yellowdog
Updater, Modified'', the Red Hat Package Manager (RPM)-based system with which
most RPM-based GNU/Linux distributions automate package management) is currently
available. If this is the case, ZYpp's official package manager `zypper` is
guaranteed to be pathable.
/---

# ....................{ TESTERS ~ os x                     }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_fink(void)

Report success if OS X's *Fink package management system* (i.e., a third-party
port of Debian's Advanced Packaging Tool (APT) to Apple OS X) is currently
available. If this is the case, Fink's official package manager `fink` is
guaranteed to be pathable.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_macports(void)

Report success if OS X's *MacPorts package management system* (i.e., a
third-party port of FreeBSD's ports collection to Apple OS X) is currently
available. If this is the case, MacPorts' official package manager `port` is
guaranteed to be pathable.
/---

# ....................{ MAIN                               }....................
::define_package_manager_testers

# --------------------( WASTELANDS                         )--------------------
#     package_manager_name_to_found[pkgsrc]=$(( ${+commands[pkgsrc]} ))
# declare_function_with_stdin <<'/---'
# [status: bool] :is_package_manager_pkgsrc(void)
# 
# Report success if NetBSD's *pkgsrc package management system* (i.e., the ports
# collection-based system with which NetBSD and relatives automate package
# management) is currently available. If this is the case, all commands commonly
# provided by such system (e.g., `pkg_add`, `pkg_delete`) are guaranteed to be
# pathable.
# /---

# declare_function_with_stdin <<'/---'
# [status: bool] :is_package_manager_pkgsrc(void)
# 
# Report success if NetBSD's *pkgsrc package management system* (i.e., the
# operating system-independent ports collection-based system with which NetBSD and
# relatives automate package management) is currently available. If this is the
# case, pkgsrc's official package manager `pkgsrc` is guaranteed to be pathable.
# /---

    #FUXME: Also define a new tester :is_package_manager() reporting success if
    #at least one such package manager is currently available. To do so sanely,
    #it'd be great if we could:
    #
    #* Inspect the local context for the set of all boolean variables with names
    #  matching glob "is_package_manager_*". (Quite certain this is feasible,
    #  but we can't recall implementing a function to do so.)
    #* Add all such booleans together. (Again, be nice if we defined a utility
    #  function to do so, since this can be heavily optimized to avoid manual
    #  iteration.)
    #* If the result is nonzero, at least one such package manager is currently
    #  available, in which case such tester should be defined to report success.
    #FUXME: If no package managers are available, print a warning resembling:
    #    :output_warning "No package manager detected."

# * Set such value to the boolean .
#
# boolean local indicating the availability of such system below.,
#   typically initialized by testing whether the lowest-level CLI command for
#   such system is currently pathable.
# * Define a corresponding tester function given such boolean.

    #FUXME: No *WAY* are we manually declaring all such testers. Examining
    #@{var/scope}, it's clear that it's trivial to define a new setter
    #:set_list_to_vars_local() based on the existing get_globals() getter
    #(which has been heavily adorned with FUXME comments describing such
    #transition).
    #
    #Given :set_list_to_vars_local(), then define a new setter
    #:set_list_to_vars_local_matching_glob() internally calling
    #:set_list_to_vars_local() (and probably
    #remove_list_items_not_matching_glob() as well). Yum!
    #FUXME: Actually, just encapsulate such booleans into a map above. Much
    #simpler and more efficient.

    # for  package_manager_count ("${(v@)package_manager_name_to_found}") {
    # }

    # :int package_manager_count=0
    # for  package_manager_count ("${(v*)package_manager_name_to_found}") {
    # }

    # True if the corresponding package management systems are available. Since
    # such systems are neither operating system- or Linux distribution-specific,
    # such systems must be detected by other means -- typically by detecting
    # system-specific pathables.
    # :bool\
    #     is_package_manager_alpm=0\
    #     is_package_manager_apt=0\
    #     is_package_manager_conary=0\
    #     is_package_manager_entropy=0\
    #     is_package_manager_fink=0\
    #     is_package_manager_macports=0\
    #     is_package_manager_pkg_add=0\
    #     is_package_manager_pkgng=0\
    #     is_package_manager_pkgsrc=0\
    #     is_package_manager_portage=0\
    #     is_package_manager_urpmi=0\
    #     is_package_manager_yum=0\
    #     is_package_manager_zypp=0

# == dpkg ==
# 
# In a similar manner to , APT implements a high-level frontend to the low-level dpkg backend
# interfacing  Debian's .deb packages
# following
# package formats as low-level backends:

# system with which Debian Linux and relatives automate package
# management)

#install, upgrade, configure, and remove
    # While
    # such booleans are also settable by matching either machine- or human-
    # readable operating Linux distribution names (e.g., enabling this boolean if such name is
    # "Sabayon"), 

# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_arch(void)
# 
# Report success if the current operating system is a derivative of Arch Linux.
# /---
# 
# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_debian(void)
# 
# Report success if the current operating system is a derivative of Debian Linux.
# /---
# 
# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_gentoo(void)
# 
# Report success if the current operating system is a derivative of Gentoo Linux.
# /---
# 
# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_ubuntu(void)
# 
# Report success if the current operating system is a derivative of Ubuntu Linux.
# /---

# pertaining to the current GNU/Linux
# distribution
# 
# is in fact _not_ what is the current GNU/Linux distributions

# current  either is a particular such server _or_ belongs to a
# particular category of such servers).

# declare_parcel_as_script_with_stdin <<'/---'
# Handle open-source Linux and BSD distributions.
# /---

# function :is_distro_trait_arch() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Arch' si
# }
# function :is_distro_trait_debian() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Debian' si
# }
# function :is_distro_trait_gentoo() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Gentoo' si
# }
# function :is_distro_trait_ubuntu() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Ubuntu' si
# }

#FUXME: Indeed, this has largely been obsoleted by new functionality in
#@{inspect}.
# == See Also ==
# 
# * Canonical list of Linux- and BSD-specific
#   http://linuxmafia.com/faq/Admin/release-files.html[`-release` and `_version` filenames and file contents].

# ....................{ GETTERS                            }....................
#FUXME: Refactor into a setter, naturally.

# declare_function_with_stdin <<'/---'
# integer get_unix_distro_version:(void)
# 
# Get the version number of the current distribution: e.g.,
# 
# .get_unix_distro_version:()
# ==========================================
# [source]
# ------------------------------------------
# >>> get_unix_distro_version:
# 2.1
# /---
# function get_unix_distro_version:() {
#     # Validate sanity.
#     die_if_args
#     :string release_text
#     :list release_files
# 
#     # If "lsb_release" is installed, return such command's output.
#     if { is_pathable lsb_release } {
#         command lsb_release -sr and report_status
#     }
# 
#     # Else, attempt to match such version from a system-wide file.
#     #
#     # List of all files matching /etc/*-release, /etc/*_version, and
#     # /etc/*-version excluding "/etc/lsb-release", specific to the prior
#     # pathable "lsb_release" guaranteed *NOT* to exist on this system.
#     release_files=( /etc/*{-release,-version,_version}~/etc/(lsb|os)-release(.) )
#     die_unless_list_nonempty release_files\
#         'OS distribution version not found (i.e., command "lsb_release" not found and no system-wide release or version files found).'
# 
#     #FUXME: We clearly have no access to function get_file_text() here. Inline
#     #such implementation!
#     #FUXME: Should probably grep the file for a pattern matching a version
#     #specifier, but... *meh* Hmm; actually, yeah. This is rather shoddy. I have
#     #little confidence in the current version. Reconsider!
#     #FUXME: Iteratively search all such files for the first whose contents match
#     #a version specifier. See the "Canonical list..." URL, above.
# 
#     # Get the last column in the text contents of the first such file.
#     release_text="$(get_file_text "${release_files[1]}")"
#     output_string "${release_text[(w)-1]}"
# }

# declare_function_with_stdin <<'/---'
# string get_unix_distro:(void)
# 
# Get the capitalized name of the current distribution: e.g.,
# 
# .get_unix_distro:()
# ==========================================
# [source]
# ------------------------------------------
# >>> get_unix_distro:
# Debian  # under Debian Linux installations
# Gentoo  # under Gentoo Linux installations
# ------------------------------------------
# ==========================================
# /---
# function get_unix_distro:() {
#     # Validate sanity.
#     die_if_args
#     list release_files
# 
#     #FUXME: Actually implement
#     #is_file_text_matching_pcre_group_multiline:!
# 
#     # If "lsb_release" is installed, get such command's output.
#     if { is_pathable lsb_release } {
#         command lsb_release -si and report_status
#     # Else if "/etc/os-release" exists and contains a line prefixed by "NAME=",
#     # get the substring following such prefix. Since such substring may
#     # optionally be delimited by quotes, strip such quotes if found.
#     } elif {\
#         is_file /etc/os-release and
#         is_file_text_matching_pcre_group_multiline: /etc/os-release\
#             '^NAME=(?|"([^"]++)"|([^"]++))$' } {
#         # If such substring is suffixed by a whitespace-prefixed operating
#         # system name (e.g., " Linux"), strip such suffix.
#         remove_string_suffix "${match[1]}" ' Linux'
#         report_success
#     }
# 
#     #FUXME: Generalize such admittedly odd syntax to a new setter
#     #:set_list_to_glob_qualified_paths_not_matching_glob:(). Sweet!
#     #FUXME: As well as doing that, also generalizing the setting of such exact
#     #list below to a new setter set_list_to_unix_files_release_nonstandard:().
#     #Such functionality is shared with get_unix_distro_version:() below and
#     #hence of common interest.
# 
#     # List of all files matching /etc/*-release, /etc/*_version, and
#     # /etc/*-version -- excluding "/etc/lsb-release". While command "lsb_release" and
#     # hence the latter should be unavailable here, better comfy than
#     # core-dumped.
#     release_files=( /etc/*{-release,-version,_version}~/etc/(lsb|os)-release(.) )
# 
#     # If at least one such file matches, take the prefix preceding the last
#     # dash or hyphen in the basename of the first such filename to be the distro
#     # name. Note that some distro names themselves contain dashes and hyphens.
#     # Thus, match suffixes non-greedily.
#     if { is_list_nonempty release_files } {
#         return_string "$(capitalize_string "$(get_path_basename\
#             "${release_files[1]%[_-]*}")")"
#     # Else, return the current operating system name.
#     } else {
#         get_os
#     }
# }

    # get_string_word "$(get_file_text "${release_files[1]}")" -1

#FUXME: Since the concept of "distribution" only applies to open OSes
#(principally Linux and BSD), this parcel is inherently nonportable. Honestly,
#such functionality should at least be shifted to a new tree @{src/if_os/unix}.

#FUXME: Desynchronized with get_unix_distro:() and probably non-working, we're
#afraid. In particular, we want to parse 
    #FUXME: Bit awkward. We really want a new run_code
    # If at least one such file matches, return the last column in the contents
    # of the first such file.
#   if { is_list_nonempty release_files } {
#       get_string_word "$(get_file_text "${release_files[1]}")" -1
    # Else, throw an exception.
#   } else {
#   }
#       string release_filename="${release_files[1]}"
#       if { is_file_text "${release_filename}" } and {
#FUXME: Rename to :is_distro_unix_arch() and similarly elsewhere below. There's
#technically a separate Gentoo BSD, for example, that
