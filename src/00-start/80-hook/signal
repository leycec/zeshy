#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *signal hooks* (i.e., functions called by `zeshy` when the corresponding
signals are triggered).
/---

#FIXME: Implementing hook functions for TRAP${trapname}() functions (e.g.,
#TRAPINT()) would be great. There are a few intricacies involved in doing so,
#however; arguably, the most important (and subtlest) is the return value. If
#*ANY* hook function iteratively called by a TRAP${trapname}() function fails...
#Hmm; right. Perhaps it isn't much of an issue after all. If a hook function
#fails, we'll simply throw an exception, which seems quite alright. Note,
#however, that it could be nice to permit... Ah, right! O.K.; just see
#TRAPZERR(). So, all we want to do is to initially save "${!}" and then to
#return such value as such trap's exit status. That's it. Nice. Next!

# ....................{ GLOBALS                            }....................
:list_global ZESHY_HOOK_CODE_RUN_ON_SIGNAL_ZERR <<'/---'
List of code to be run on `zsh`-specific signal ZERR. See
run_hook_code_on_signal_zerr() for further details.
/---

# ....................{ RUNNERS                            }....................
#FIXME: Rename to :hook.run_on_signal_zerr().
declare_function_with_stdin <<'/---'
:void run_hook_code_on_signal_zerr(:string code)

Run the passed code on `zsh`-specific signal *ZERR* (triggered by any command
reporting unhandled failure) _before_ converting such failure into an exception.
See TRAPZERR() for further details.
/---
function run_hook_code_on_signal_zerr() {
    # Validate sanity.
    die_unless_arg 'Expected one string of code.'
    string code="${1}"

    # Register such hook.
    ZESHY_HOOK_CODE_RUN_ON_SIGNAL_ZERR+="${code}"
}

# --------------------( WASTELANDS                         )--------------------
