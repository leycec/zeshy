#!/usr/bin/env zeshy
# --------------------( LICENSE                           )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.
#
# --------------------( SYNOPSIS                          )--------------------
# Compile zeshy overlays (i.e., directories containing zeshy scripts whose
# dirnames embed metadata dictating how and when such scripts are compiled into
# zeshy's digest file).
#
# --------------------( SYMBOLS                           )--------------------
# In most programming languages, the symbols that language exports for external
# use (e.g., packages, classes, functions, globals) do *NOT* vary with system
# or user configuration. The same version of the same language unconditionally
# exports the same symbols everywhere, forming the language "core".
#
# As expected, `zeshy` behaves different. Most symbols `zeshy` exports for
# external use at the command line and within scripts conditionally vary with
# system and user state, including:
#
# * The output of the system-specific "lsb_release" and/or "uname" commands.
# * The contents of the user-specific `zeshy` configuration at
#   "~/.zeshy/config".
# * The contents of the user-specific ${PATH} (i.e., the set of currently
#   installed and accessible programs).
#
# zeshy monitors such content for changes -- silently, efficiently, and
# entirely automatically. On detecting changes, `zeshy` changes itself. As
# example:
#
# * On switching from a Linux to BSD operating system, `zeshy` supplants the
#   Linux-specific symbols it exports with those specific to BSD.
# * On installing a new program "rtorrent" into the system-wide "/bin"
#   directory in the ${PATH}, `zeshy` exports "rtorrent"-specific symbols.
#
# `zeshy` symbols comprise `zeshy`-specific zsh functions and, to a lesser
# extent, zsh aliases and globals. For efficiency, `zeshy` exports the former
# as a single zsh digest file (i.e., a binary file in a zsh-specific format
# functionally analogous to that of C and C++-style shared libraries).
#
# `zeshy` compiles *ONLY* that subset of itself specific to current system and
# user state into its digest file. Uncompiled code remains inaccessible until
# such state changes (e.g., installing "rtorrent" notifies `zeshy` to compile
# start_rtorrent() and stop_rtorrent() functions into its digest file). For end
# user purposes, `zeshy` *IS* its digest file.
#
# --------------------( OVERLAYS                          )--------------------
# To accomodate system- and user-specific `zeshy` add-ons (e.g., plugins,
# themes), `zeshy` divides itself into overlays: directories with the same
# structure as `zeshy`'s top-level "src" directory. `zeshy` ignores all files
# and directories in an overlay except those with the following
# `zeshy`-specific names:
#
# * `always`, a subdirectory recursively containing only:
#   * `zeshy` scripts, to be unconditionally compiled into `zeshy`\'s digest
#     file. These scripts may reside directly in the mandatory "always"
#     directory or under optional subdirectories. In either case, `zeshy`
#     automatically finds and compiles all zsh functions in all such files.
#   * Subdirectories with arbitrary names and nesting. (`zeshy` automatically
#     finds all scripts in such subdirectories. Subdirectory structure is
#     insignificant and hence only for optional organization.)
# * `if_config`, a subdirectory directly containing only:
#   * `zeshy` configuration files, to be unconditionally copied into the user-
#     specific `~/.zeshy/config` directory if not already found.
# * `if_pathable`, a subdirectory directly containing only:
#   * `zeshy` scripts, each conditionally compiled into `zeshy`\'s digest file
#     _only_ if an executable file of the same case-sensitive basename
#     currently exists in the user-specific ${PATH}.
#   * Subdirectories, each conditionally enabled as a `zeshy` overlay and hence
#     subject to recursive processing (e.g., for an `always` subdirectory) only
#     if an executable file of the same case-sensitive basename currently
#     exists in the user-specific ${PATH}.
# * `if_package_manager`, a subdirectory directly containing only:
#   * Subdirectories, each conditionally enabled as a `zeshy` overlay _only_ if
#     the corresponding package management system is currently available under
#     the current system.

#FIXME: We've recently realized that the current approach we use to compile
#and cache multiple monolithic digest files, each signifying some unique
#combination of runtime system metadata, is fundamentally flawed. Long-standing
#Issues include:
#
#* zy:../../inspect.zy. This brutish and hellish parcel attempts to convert all
#  possible combinations of runtime system metadata into a single digest
#  basename. Doing so requires:
#  * Low-level zsh with access to *NO* high-level zeshy facilities.
#  * Static implementation. The current approach is inimicable to user
#    customization and third-party modification, both core to zeshy philosophy.
#  * Extremely long implementation. Under the current approach, all possible
#    inspection routines are hardcoded into a single parcel.
#  * Duplicate cached code. Due to the use of monolithic digests, code shared
#    in common between multiple digests -- including zeshy core -- will be
#    recompiled into each and every digest.
#
#In short, it sucks. Is there a better Way? *THERE ABSOLUTELY IS.*
#
#The solution is to replace the existing "inspect.zy"-dependent suite of
#overlays (e.g., "if_display_server", "if_package_manager") with a single new
#type of overlay generically encompassing the former: "if_digestable". Such
#overlays are to be structured much like "if_pathable" overlays: e.g.,
#
#    zeshy/src/if_digestable/
#      display_server/
#      display_server_x11/
#        if_pathable/
#        X.zy
#        dpms.zy
#      package_manager_portage/
#        if_pathable/
#        portage.zy
#        service.zy
#
#So, what's going on here? For each basename ${digestable_type} in the
#"if_digestable/" overlay subdirectory (e.g., "display_server"), two
#corresponding predefined tester functions must be defined:
#
#1. :${digestable_type}.is_digestable() (e.g.,
#   :display_server.is_digestable()), reporting success if the corresponding
#   digestable is theoretically available (regardless of whether that
#   digestable's service is currently running or not) on the current system.
#   This tester is called by this "overlay.zy" parcel to decide whether or not
#   a digest should even be compiled for this digestable or not. This implies,
#   of course, that these testers *MUST* be defined prior to "if_digestable/"
#   handling. The main zeshy codebase would be an acceptable home for these
#   testers, at the moment.
#1. :${digestable_type}.is() (e.g., :display_server.is()), reporting success if
#   the corresponding digestable is currently available. This tester is called
#   at zeshy startup to decide whether or a not the previously compiled digest
#   for this digestable should be autoloaded or not. This implies that these
#   testers may be defined very late in the zeshy codebase, if required.
#
#For some digestables, "theoretically" and "currently" are synonymous. For
#package manager digestables, for example, a package manager is both
#theoretically and currently digestable if its most common command is in the
#current ${PATH} (e.g., "emerge", "apt-get"). This is because there typically
#exists no daemon process to which a package manager connects to facilitate its
#work. If it's in the current ${PATH}, it works. Period.
#
#For other digestables, however, "theoretically" and "currently" are entirely
#different beasts. For display server digestables, for example, a display
#server is also theoretically digestable if its most common command is in the
#current ${PATH} (e.g., "startx") but only currently digestable if such a
#server is currently running.
#
#This parcel leverages the :${digestable_type}.is_digestable() tester as
#follows. If this tester reports failure, that digestable's subdirectory is
#ignored; else:
#
#* All contents of that subdirectory are recursively compiled *INTO A BRAND NEW
#  DIGEST FILE* with basename "${digestable_type}.digest" in the current user's
#  digest cache directory. This will require some careful jiggering (e.g., to
#  ensure that nothing defined in that subdirectory is compiled into the main
#  digest file).
#* A snippet of code resembling the following is added to zeshy startup,
#  probably in a new ::startup.load_digestables() function:
#
#    # The :digest.load() function simply autoloads() the passed digest in a
#    # safe manner.
#    ! :${digestable_type}.is || :digest.load "${digestable_type}.digest"
#
#It's friggin' brilliant. We single-handedly do away with the crufty
#"inspect.zy" parcel, permit third-party customization, permit zeshy code in
#these testers, eliminate overlay type explosion (...one overlay type to
#conquest them all!), and so on.
#
#Make it so, please. *THIS IS EXTREMELY HIGH PRIORITY.*

#FIXME: We've recently given an increasing (if often vexatious) degree of
#thought to two pressing issues that all languages inevitably face but largely
#ignore, even late into their lifecycle:
#
#* Backwards incompatibility.
#* Package management.
#
#Most software systems -- be they operating systems or programming languages --
#either do *OR* would prefer to break backwards compatibility at some point in
#their lifecycle. Unfortunately, by failing to prepare upfront for such
#breaking, such systems make the cost of transition across the backwards
#incompatibility barrier sufficiently expensive as to be prohibitive. This is a
#Type-1 error in the classical sense. The remedy, of course, is to design
#systems with sufficient upfront resilience explicitly supporting cleavages in
#backwards compatibility.
#
#Package management is a similar issue. By failing to afford some means of
#built-in, authoritatively homogenous package management, systems defer such
#management to a heterogeny of third-party package managers -- each with their
#own requisites, infrastructure, and incompatibilities between one another.
#Again, this is a Type-1 error in the classical sense. Given the increasingly
#free (as in beer) nature of cloud storage with respect to open-source software
#(see: github), there exists *NO* demonstrable reason for modern languages to
#continue neglecting package management.
#
#Hence, zeshy *MUST* be designed from the ground-up to support both. Happily,
#we believe we've uncovered a simple means of effecting both -- simple, that
#is, when planned for and implemented early enough in the design process. Which
#means that everything below should be considered of high priority.
#
#First, let's dispense with nomenclature. Our current nomenclature sucks, to
#put it bluntly. For one, we appear to reuse the word "overlay" to mean various
#things. We have rooted overlays accessible as a URI protocol (e.g.,
#"zeshy.user://") and conventional overlays accessible under rooted overlays
#(e.g., "zeshy.user://if_pathable/git"). Moreover, the noun "overlay" is in
#common use by other systems (e.g., Gentoo) to refer to something completely
#different. In short, this must stop.
#
#To do so, we introduce two new concepts:
#
#* Silo, a conventional overlay in the prior nomenclature. A silo contains zero
#  or more paths. No silo contains a depo; rather, silos are only contained by
#  depos. A silo name is a single pathname of significance to the zeshy
#  compiler containing no directory separators (e.g., "if_pathable").
#* Depo, a rooted overlay in the prior nomenclature. A depo contains zero or
#  more silos. A depo name is one or more pathnames delimited by directory
#  separators (e.g., "zeshy/0"). While depo authors will probably be expected
#  to conform to some reasonable nomenclature, zeshy itself will impose no hard
#  constraints on depo names (save, of course, that they contain no null
#  characters). That said, the standard nomenclature will be as follows:
#  * "${depo_basename}/${depo_version_major}", where:
#    * "${depo_basename}" is 
#
#The system-wide zeshy directory structure will now resemble:
#
#    # A system-wide symbolic link to the main executable script for the
#    # currently installed version of zeshy. This is absolutely essential! To
#    # avoid the Python conundrum, we should absolutely avoid unversioned files
#    # in "/usr/bin". In particular, do *NOT* install "/usr/bin/zeshy". This
#    # forces script authors to use version-specific shebang lines resembling
#    #     #!/usr/bin/env zeshy0
#    # This is a good thing.
#    /usr/bin/zeshy0 -> /usr/share/zeshy/0/bin/zeshy
#
#    # All zeshy-specific system-wide paths are installed under:
#    /usr/share/zeshy/
#    # All code specific to zeshy 0.x.
#                     0/
#    # All executable scripts specific to this version of zeshy.
#                       bin/
#    # The main executable script for this version of zeshy.
#                         zeshy
#    # The core codebase for this version of zeshy, comprising *ONLY* the
#    # zeshy compiler and preprocessor. All other core functionality resides in
#    # the canonical zeshy depo defined below.
#                       src/
#    # All depos currently installed for this version of zeshy.
#                       depo/
#    # The currently installed codebase for this version of zeshy, itself a
#    # depo! Note the "00-" prefix, ensuring such depo to be sourced on zeshy
#    # startup prior to all other depos (which, presumably, depend upon such
#    # version of zeshy).
#                         000000-zeshy/
#    # All code specific to zeshy 0.0.x. Note that this implies that zeshy will
#    # have version specifiers organized as follows:
#    # * "${version_major}.${version_minor}.${version_micro}", where:
#    #   * "${version_major}" is incremented *ONLY* when backwards
#    #     compatibility is broken in either the compiler or preprocessor.
#    #   * "${version_minor}" is incremented *ONLY* when backwards
#    #     compatibility is broken in the main zeshy codebase.
#    #   * "${version_micro}" is incremented in *ALL* other cases.
#                           0/
#    # The main and only silo for such depo. Since depo names may contain an
#    # arbitrary number of subdepo specifiers (e.g., numeric versions, "alpha",
#    # "beta"), the main silo for a depo *MUST* have an explicit subdirectory
#    # named "silo". The existence of this subdirectory terminates depo name
#    # parsing. Hence, this depo's name is simply "zeshy". (Naturally, we drop
#    # the prefixing "00-", as such prefix conveys nothing meaningful outside
#    # of depo ordering).
#                           silo
#    # The expected subdirectory tree structure.
#                             00-root/
#                             10-soil/
#                             ...
#    # Example third-party depos. (See below for dependency ordering.)
#                         000001-yummy/
#                         000002-sunny/
#    # An example third-party depo now described in detail.
#                         000003-winsome/
#    # All code specific to winsome 3.x.
#                           3/
#    # The main silo for such depo, implying such depo's name to be
#    # "winsome/3".
#                             silo/
#    # An example script in the main silo for such version of winsome.
#                               winsome.zy
#    # A depo-specific silo sourced *ONLY* by the depo installer *BEFORE* such
#    # installer attempts to first install such depo. Such silo defines
#    # critical metadata required for installing such depo: namely, which
#    # versions of zeshy such depo is known to be compatible with *AND* which
#    # other depos (and which versions of such depos) this depo requires. In
#    # short, this is the "setup.py" of the zeshy world.
#                             if_installing/
#    # Such silo *MUST* provide at least one zeshy script of arbitrary name
#    # calling a canonical install function defined by the depo installer --
#    # say, :depo.install(). Such function accepts keyword arguments defining
#    # depo metadata. Notably, the "dependency_depo_to_subdepo" keyword accepts
#    # a map from depo name to subdepo conditional. Since such conditionals may
#    # be one or more either arithmetic or non-arithmetic tests, such
#    # conditionals *MUST* be explicitly specified in full. The variable
#    # "subdepo" in such conditionals will, of course, be dynamically set to
#    # the name of such subdirectory for the currently installed depo if any. 
#    # (If no such depo is installed, such conditional will *NOT* be run.)
#    # Naturally, subdepos may be omitted, implying *ANY* subdepo of such
#    # depo to be acceptable. The # phrase "subdepo" is used below rather than
#    # "version", as subdepo names # are not necessarily version specifiers.
#    # For example: e.g.,
#    #    :depo.install\
#    #        require_depo_to_subdepo = (
#    #          zeshy '(( subdepo >= 0 && subdepo <= 1 ))'
#    #          yummy '[[ ${subdepo} == 'alpha-'* ]]'
#    #          sunny ''
#    #        )
#                               install.zy
#    # A system-wide configuration specific to the current system and hence
#    # distribution (e.g., Gentoo).
#                         999999-system/
#
#    # All zeshy-specific user-specific paths are installed under:
#    ~/.zeshy/
#    # All depos specific to zeshy 0.x are installed under:
#      0/
#    # All cache files specific to such user for such version.
#        cache/
#    # All third-party depos installed by such user for such version.
#        depo/
#    # An example user-specific installed depo.
#          000000-hypermegasuper/
#    # The canonical user-specific codebase for this version of zeshy, itself a
#    # depo! Note the "99-" prefix, ensuring such depo to be sourced on zeshy
#    # startup after all other depos (which, presumably, do *NOT* depend upon
#    # such user-specific codebase).
#          999999-user/
#
#Numerous questions remain, but appear to be readily resolvable. For example,
#note the numeric prefixes for installed depos. The depo installer should
#*AUTOMATICALLY* synthesize such prefixes from the
#"require_depo_to_subdepo" keyword supplied on depo installation. Naturally,
#depos should *NOT* be required to explicitly supply such prefixes (and could
#*NOT* reasonably be expected to, anyway). We believe there exist reasonably
#efficient algorithms for resolving dependencies in an abstract, graph
#algorithm-driven manner. Although we (sadly) can't recall the names of such
#algorithms, we do recall them being not terribly horrific to implement.
#Assuming such algorithm requires a tree or graph structure (which it probably
#does), we may simply use the filesystem itself as our data structure. Assuming
#no cyclic dependencies (which we must obviously guard against), this should
#work splendidly. [Insert neurotic eye tick here.]
#
#Note also that there exist numerous package managers implemented in shell
#scripting languages (e.g., the zsh-specific "Antigen").
#
#Since depos are sorted in lexicographic order, we use 6-digit depo prefixes,
#permitting up to 999,999 depos to be concurrently installed. Naturally, this
#breaks down when the millionth depo is added -- but that will probably never
#happen, and we can throw an exception if someone attempts it.
#
#This does imply that existing depo names will require renaming on installation
#of a new depo that must be sourced earlier in the dependency tree. Since
#directory renaming is of negligible cost *AND* since the number of depos to be
#installed is unlikely to ever exceed one to two orders of magnitude, such cost
#*SHOULD* be ignorable.
#
#If a dependency conflict arises (e.g., two or more depos requiring different
#and hence conflicting subdepos of the same depo), an exception should be
#thrown. This implies, of course, that only one subdepo of a given depo may be
#installed at a time. While not necessarily ideal, that's certainly how *ALL*
#existing languages operate -- and it's difficult to envision how we could do
#demonstrably better, given digest file constraints and the lack of namespaces.
#The question then arises: if only one subdepo can be installed at a time, why
#even have subdepos? Three reasons:
#
#* Orthogonality. Having the major but *NOT* minor version of zeshy be
#  explicitly listed as a subdirectory strikes us as incurably odd.
#* Forwards compatibility. Someday, we might indeed concoct a solution
#  permitting multiple subdepos of the same depo to be concurrently installed.
#* Dependency resolution. *NOT* having subdepos complicates such resolution by
#  requiring that subdepos instead be specified in "if_installing" silos, then
#  requiring that such silos be sourced on attempting to install a new depo
#  depending on such depos. (Ugh.)
#
#zeshy does *NOT* compile all depos together into the same digest file. Rather,
#there exists a one-to-one correspondence between depos and digest files. On
#zeshy startup, the following actions are taken (in order):
#
#* Each depo (in lexicographic order) in the system-wide depo directory for the
#  current version of zeshy is compiled to its own digest file.
#* Each depo (in lexicographic order) in the user-specific depo directory for
#  the current version of zeshy is compiled to its own digest file.
#
#Naturally, just as zeshy has its own functions defined in its digest file for
#restoring globals and aliases required by zeshy, so too should each
#depo-specific digest file have similar functions.
#
#Each digest file is *APPENDED* by default to the function path ${fpath}. By
#default, depos may be reasonably expected to *NOT* attempt to overwrite
#functions or aliases defined by the parent depos on which they depend, in
#which case appending digest files dramatically improves efficiency. In
#particular, this ensures that the zeshy digest file will be searched first --
#which is good. That said, digests should certainly have the option of being
#prepended. Hmm; right. For simplicity, screw efficiency for now! We can always
#jigger this later. For now, let's enforce an reversed one-to-one
#correspondence between the depo order indicated by such 6-digit prefixes and
#the ${fpath} order, implying that each depo should instead be *PREPENDED* to
#the ${fpath} immediately on autoloading such depo's digest. This ensures that
#depos loaded later in the dependency tree may overwrite functions, variables,
#and aliases defined by depons loaded earlier in such tree -- which is exactly
#what we want to support. (If efficiency ever becomes a concern, we can explore
#devices for optimizing this. Until then, simplicity stands.)
#
#*THAT'S IT.* Pretty awesome, altogether. A significant step forward, if
#requiring more than a little work. Say it all together: "It'll be fun!"
#FIXME: O.K.; the above is a great start, but we'd like to amend a few things.
#
#First, depo digest files should *NOT* be automatically autoloaded. That would
#be a terrible idea. That said, we still will need to automatically autoload
#two depos, as these provide the "seeds" with which all other depos are
#manually autoloaded: "999999-system" and "999999-user". (The jury is out on
#whether or not "000000-zeshy" should be autoloaded. Ideally, we think not. A
#default "999999-system" should manually autoload such depo, permitting fine-
#tuning of depo order.)
#
#Adopt the CLI editor (e.g., vi[m], emacsen) whitelisting approach of requiring
#all other depos be manually autoloaded. Since "000000-zeshy" should probably
#*NOT* be autoloading other depos, that leaves just "999999-system" and
#"999999-user". Depos will be autoloaded with a non-ambiguous function call --
#say, :depo.autoload(). For example, "999999-user/rc.zy" might resemble:
#
#    :depo.autoload winsome
#    #:depo.autoload buxsome   # <-- currently broken!
#
#You can see the benefits of the whitelist approach, we assume.
#
#The :depo.install() approach strikes us as horribly clumsy. Rather than
#requiring *ALL* installation metadata be passed at once as keyword arguments,
#such metadata should be passable through small-scale function calls preceding
#the penultimate call to :depo.install(): e.g.,
#
#    # Instead of this...
#    :depo.install\
#        require_depo_to_subdepo = (
#          zeshy '(( subdepo >= 0 && subdepo <= 1 ))'
#          yummy '[[ ${subdepo} == 'alpha-'* ]]'
#          sunny ''
#        )
#
#    # ...do this.
#    :depo.depend zeshy '(( subdepo >= 0 && subdepo <= 1 ))'
#    :depo.depend yummy '[[ ${subdepo} == 'alpha-'* ]]'
#    :depo.depend sunny
#    :depo.install
#
#    # ...or this.
#    :depo.depend\
#        zeshy '(( subdepo >= 0 && subdepo <= 1 ))'\
#        yummy '[[ ${subdepo} == 'alpha-'* ]]'\
#        sunny ''
#    :depo.install
#
#Oh, man. Either of the latter is *SOOOOO* much better.
#
#Numeric prefixes for resolving dependencies is terrible. There exist two sorts
#of dependencies: installation and runtime dependencies. Due to the above
#whitelisting approach, neither the former or latter require such an implicit
#ordering mechanism during resolution. (Phew!) So, happily nix those.
#
#Given that, do we need *ANY* resolution mechanism? Yes. We still require
#installation resolution to determine which depos should be installed and the
#order in which they should be installed. Again, this shouldn't be *TOO*
#troublesome. (See "antigen", eh?)
#
#Multiple subdepos of the same depo *MUST* be concurrently installable.
#Consider the commonplace situation of a system-wide zeshy installation
#providing an outdated subdepo of some depo. Forbidding concurrent installation
#would prevent the user from installing a user-specific updated version of such
#depo, which would be terrible.
#
#Given that, the depo installer *MUST* be permitted to downgrade previously
#installed depos on installation of a new depo with conflicting requirements.
#For example, suppose an example depo 'base' with multiple subdepos 0, 1, and
#2 and a depo "leaf" requiring any "base" version and hence installing 2; then
#suppose a depo "stem" is installed requiring any "base version" <= 1. Given
#such dependency tree, "base" would require a downgrade to version 1. Which is
#fine, of course; we simply need to plan for that.
#
#The end result is that, much as on a Gentoo system, the set of all currently
#installed depos *ALWAYS* constitutes a valid dependency tree. This invariant
#*MUST* absolutely be maintained at all times.
#
#That does leave one (probably more) troubling question, however. Given an
#example depo 'renew' with multiple subdepos 0, 1, and 2, which such subdepo
#does a call of "depo.autoload renew" autoload? Naturally, we would assume 2.
#Given the above depo installer behaviour, we believe that such assumption
#*SHOULD* always be safe. That's fine -- except what happens under a subsequent
#call of "depo.autoload renew/1" in some other depo? That arguably constitutes
#a bug in such depo, as, if such depo truly did require *ONLY* version 1, then
#such requirement should have been stipulated in such depo's installation
#script, in which case version 1 would be the newest version available of
#"nenew" and there exists no quandry. Given that, we may want to consider
#prohibiting calls to specific subdepos for the moment (e.g., by throwing
#exceptions on calls resembling "depo.autoload renew/1").
#
#This implies that, indeed, subdepos probably *ARE* synonymous with version
#specifiers. While we had considered also leveraging subdepos for
#differentiating organizations (e.g., "myorg/renew/1"), organizations would
#probably best be differentiated with a prefixing string (e.g.,
#"myorg.renew/1"). In any case, minor food for aggrieved thought.

#FIXME: Fantastic and fairly essential optimization uncovered. If this is *NOT*
#the first compilation of zeshy by this user (i.e., if a prior now-outdated
#digest file exists), do the following:
#
#* Source this script *UNDER AN OWNED, BACKGROUNDED SUBSHELL*. Oh, yes:
#
#    # Instead of this...
#    source compile
#
#    # ...do this!
#    ( source compile ) &
#* When complete, a pre-command line hook will be run immediately before
#  displaying the prompt at the next interactive command line. Assuming we
#  refactor such hook to reload the current digest file whenever changed (which
#  we absolutely should already do), this will have the extremely beneficial
#  end effect of permitting the user to continue interactively using zeshy
#  *BEFORE* compilation has even finished and then restarting zeshy once such
#  compilation finishes. Awesome, no?

#FIXME: So. We've more-or-less come to the definitive conclusion that the
#current configuration technique is... well, crud. Unpleasant crud. Due to the
#system-, user-, and configuration-specific nature of configuration files,
#zeshy *NEEDS* to be able to both safely create (on installation of new
#pathables), modify (on zeshy upgrade or downgrade), and delete (on
#uninstallation of existing pathables) such files at whim. Clearly, the current
#approach only permits the former.
#
#Migrating to a read-only symlink-based system permits all three. Hence, that's
#*ABSOLUTELY* what we're doing. It's so dramatically saner to do so. This has a
#number of significant benefits, including:
#
#* "~/.zeshy/config" will *ALWAYS* reflect current system, user, and zeshy
#  state.
#
#However, this has one obvious drawback:
#
#* "~/.zeshy/config" will no longer be editable.
#
#However, if one considers it, this isn't *NECESSARILY* a drawback; it's more a
#matter of cultural expectation. Hence, we modify the expectation by:
#
#* Appending a new message to the head of *EVERY* configuration file: e.g.,
#
# --------------------( EDITING                            )--------------------
# Avoid editing this file directly. Run ":config.help" for further details.
#
#O.K.; that's it! Then define function :config.help() to print the following
#terminal-wrapped help text:
#
# --------------------( SYNOPSIS                           )--------------------
# Configuration files are typically only symbolic links to read-only,
# system-wide files of the same basename (e.g.,
# "~/.zeshy/config/00-core/alias", symbolically linking to
# "/usr/share/zeshy/config/00-core/alias") and hence should *NEVER* be edited.
#
# Instead, store all configuration edits in one or more files of any basename
# in the current user-specific zeshy overlay (e.g.,
# "~/.zeshy/source/config.zeshy", storing all such edits for the current user).
#
# --------------------( EDITS                              )--------------------
# To edit the value of any configuration global of:
#
# * Type ":list", consider appending new items to such list in such file(s): e.g.,
#     SOME_ZY_LIST+=( "a new item" )
# * Type ":map", consider either:
#   * Appending new key-value pairs to such map in such file(s): e.g.,
#     SOME_ZY_MAP+=( "a new key" "a new value" )
#   * Modifying existing key-value pairs in such map in such file(s): e.g.,
#     SOME_ZY_MAP[an existing key]="a new value"
# * Any other type (e.g., ":bool", ":float", ":int", ":str"), simply
#   redefine such global in such file(s): e.g.,
#     SOME_ZY_INTEGER=373373
#     SOME_ZY_STRING="a new string value"
#
# --------------------( EXAMPLES                           )--------------------
# The following example creates
#
# #FIXME: Write a real-world example here!
# >>> :script.write_with_stdin ~/.zeshy/source/config.zeshy <<'/---'
# ... #!/usr/bin/env zeshy
# ... /---
#FIXME: Actually, the above example suggests we should eliminate any possible
#confusion by pre-populating "~/.zeshy/source/" with an initial zeshy script of
#basename "config.zy" containing the above documentation. This is great, since
#we then no longer need to create a new function :config.help().

#FIXME: Document our established order of suboverlays in the main overlay,
#probably in parcel documentation. Relevant documentation culled elsewhere
#includes:
#
    # Source zeshy's user configuration files:
    #
    # * *AFTER* sourcing the main zeshy codebase, ensuring such files may expand
    #   standard aliases (e.g., string_export_global<>).
    #
    # The latter point is particularly important. Serializing configuration-
    # specific globals into the user digest suggests that the configuration need
    # *NOT* be sourced on every zeshy startup but only during recompilation, an
    # efficiency improvement.

#FIXME: O.K.; I conceived a simple, but critical, technique for improving
#zeshy's robustness on upgrades: namely, *ALWAYS* explicitly source *ALL*
#configuration files supplied by the current overlay on digest file
#recompilation (i.e., from the overlay itself before copying such files to
#"~/.zeshy/config/"), *BEFORE* resourcing configuration files from
#"~/.zeshy/config/". What does this achieve? Simple. It ensures that any
#globals that might be missing from the current user's configuration will
#simply be set to default zeshy settings. This is substantially better than the
#current approach, which basically ensures "zsh: ZY_EUEUEUBLAHBLAH not
#defined" errors on upgrades. Given how easy this is, there's really no (or
#only little) downside to ramming it through.
#FIXME: ::zeshy.compile_suboverlay_if_config() would be a nice place to add
#update handling for patching locally modified config files against zeshy-
#bundled config files on update.
#FIXME: Hmmmm; no, actually. We want to implement the upgrade process as
#a startup_zeshy_upgrade()-style function in the main zeshy codebase. Why?
#Firstly, such upgrade will inevitably become a bit heavyweight, with
#functionality conditionally depending on which "diff"-style merge commands
#are installed and available to the current user (e.g., "gdiff", "vimdiff").
#Secondly, it's simply cleaner to defer upgrading until *AFTER* zeshy
#has fully bootstrapped itself. Since we already expand config globals
#defensively (e.g., ${ZY_THEME:-vanilla}), this should pose no issues
#even if we were to subsequently, say, rename ${ZY_THEME} to
#${ZY_USER_THEME}.
#FIXME: I should note that upgrading user-specific configuration files
#requires some care. On each zeshy precompilation, we should cache MD5 sums for
#all *SOURCE* configuration files copied from a zeshy overlay to
#"${ZY_USER_CONFIG_DIRNAME}" as values of a new map global -- say,
#${ZY_CONFIG_FILE_TO_MD5_SUM}: e.g.,
#
#  ZY_CONFIG_FILE_TO_MD5_SUM[posix]='595f44fec1e92a71d3e9e77456ba80d2'
#
#Clearly, the filenames should be relative to "if_config/" subdirectories.
#
#Naturally, computing file hashes suggests a new function get_file_md5_sum().
#Such function's implementation is fairly straightforward: if "md5sum" is
#pathable (i.e., the typical Unix command), run such command; else if "md5"
#is pathable (i.e., the BSD equivalent), run such command; else :die. Since
#basically *ALL* OSes are guaranteed to supply one of the two commands, I
#don't see the harm in just shoving it in a new parcel "always/path/file/hash".
#For those very reasons, we probably won't have to bother supporting other
#hashing schemes as a backup (e.g., CRC, "sha256sum"): MD5 utilities are
#ubiquitous.
#
#In any case, why save MD5 sums of source config files? Simple. On upgrade,
#we compare the stored MD5 sums against:
#
#* The corresponding new upgraded config file in "/usr/share/zeshy". Files
#  *NOT* matching such sums were changed in the upgrade.
#* The corresponding config file in "~/.zeshy/config". Files *NOT* matching
#  such sums were changed by the user.
#
#For config files changed in the upgrade but *NOT* by the user, silently
#overwrite the corresponding config file in "~/.zeshy/config" with such upgraded
#config file. However, for config files changed in the upgrade *AND* by the
#user, request the user manually merge such changes -- ideally, by invoking a
#merge utility (e.g., "vimdiff").
#
#For config files *NOT* changed in the upgrade but by the user, silently ignore
#such files. That concludes all possible permutations.
#
#Sweet, no?
#FIXME: Incidentally, the above map should also be used to detect the deletion
#of config files from a zeshy "if_config/" directory. For such files, the user
#should be warned that the corresponding file in "~/.zeshy/config" is obsolete
#and should be moved aside or deleted altogether.
#FIXME: O.K.; the above update logic is great. But there's a somewhat larger
#issue: should we even *BE* auto-copying configuration files to
#"~/.zeshy/config"? The obvious answer is: no, probably not. Let's be honest.
#Such functionality has only ever obstructed us from the developer perspective,
#and it's unclear whether such functionality would be overly beneficial (given
#the upgrade complications) to actual users either. Now, what we *CAN* and
#certainly should do is offer the user some means of configuring zeshy. Hmm;
#but this *IS* all rather complicated, isn't it? The set of applicable
#configuration files depends on the current state of the system. Oh, bloody
#hell. To make configuration feasible *WITHOUT* auto-copying, we'd need to
#implement something resembling "eselect" logic, where we interactively present
#the user a list of all applicable configuration files and have them select
#which they want to copy over. Ugh. O.K.; so, here's what we should probably be
#doing:
#
#* If zeshy is running from a "git" repository (but *NOT* necessarily with option
#  "--debug", since config auto-copying is independent of whether or not we're
#  debugging), disable auto-copying. It's simply not beneficial. It obstructs.
#* Else, enable auto-copying.
#FIXME: Right. So, the above is all sensible -- particularly the caching of MD5
#sums for configuration files. However, we can do better. *MUCH* better. To do
#so, consider a fundamentally different approach. What if, when the user makes
#custom changes to zeshy configuration files, we could store the exact changes
#such user just made to a zsh script? If we could do that (which we demonstrate
#below we can), then we can smoothly automate the upgrade process such that *NO*
#manual user intervention should be required (unlike, say, Gentoo upgrades), as
#follows:
#
#* On detecting a change to the current version of zeshy and hence a probable
#  upgrade:
#  * Check whether the zsh script caching the user's prior changes to
#    configuration files exists. If not, print a warning and do *NOT* proceed
#    with the instructions below. (This implies that such script should always
#    be initialized to a 0-byte file, even when the user has made no changes, to
#    distinguish between the erroneous case that such file has been erroneously
#    deleted or moved and the non-erroneous case that no changes have been made.)
#  * Assuming such script exists, move the user's entire zeshy configuration
#    directory to "/tmp" (e.g., "mv ~/.zeshy/config /tmp"), thus preserving such
#    directory while getting it out of the way.
#  * Copy over all applicable configuration files for the current system from
#    the newly upgraded zeshy, as usual. (No changes here, clearly.)
#  * Now for the critical part: source or run the previously cached zsh script,
#    thus "replaying" all prior custom changes the user made to the old
#    configuration files to the in-memory copy of such globals.
#  * Great! But we're only halfway there, yet. We still need to serialize such
#    changes back to disk -- specifically, to the new configuration files. It's
#    not particularly difficult to write variables back to disk, of course, but
#    we'd love to preserve the original documentation in such file, too.
#    Frankly, the only sane way to do this will be as follows:
#    * Define a new function "string :output_parcel_declarer(string parcel_name)"
#      (or perhaps an equivalent setter, to avoid subshell inefficiency)
#      outputting out a string declaring documentation for the passed parcel.
#    * Define a similar function "string :output_global_declarer(string parcel_name)".
#      That's all we should need for configuration files, which should *NEVER*
#      define new aliases or functions.
#    * Then, programmatically reconstruct each modified configuration file by
#      first overwriting such file with (in order): the corresponding parcel
#      declaration and, for each global previously defined by such file, the
#      corresponding global declaration followed immediately by the new
#      definition of such global.
#
#Hmmm. The latter is particularly problematic, however; while that *WOULD* work,
#it would also completely discard beneficial formatting in modified
#configuration files, which is completely unhelpful.
#
#Before we get to reconsidering that, however, how exactly do we even write such
#script in the first place? First, note that it's trivial to determine which
#configuration files have been modified by simply comparing the mtime (we only
#care about changes to file *CONTENT* here and hence don't care about ctime) of
#each source zeshy configuration file with the mtime of the corresponding target
#user configuration file. There's probably a number of heuristics with which to
#optimize such comparison, but by far the simplest would be to simply
#recursively touch *ALL* target user configuration files (hence changing their
#mtimes to the current time) when copying *ANY* such file; this ensures that
#unchanged files *ALL* share the same mtime, which could readily be stored as a
#global integer to the digest compiled at the same mtime -- say,
#${ZY_USER_CONFIG_DIR_MTIME}. Finding changed configuration files thus
#reduces to a recursive list assignment resembling:
#
#    :int path_mtime
#    :list filenames_config_changed; filenames_config_changed=(
#        "${ZY_USER_CONFIG_DIRNAME}"/**/*(-.e^'\
#            :set_int_to_path_mtime path_mtime "${REPLY}";\
#            (( path_mtime > ZY_USER_CONFIG_DIR_MTIME ))\
#        '^)"
#    ) or =failure.ignore
#
#Ah. Wait. While the above *WOULD* work, it's extreme overkill. We already have
#all the tools required to find changed configuration files without needing to
#touch files or maintain new globals. How? Simple: the digest file. Grab the
#mtime of the current digest file *BEFORE* it's recompiled, then use the above
#recursive list assignment technique to find all files newer than such mtime.
#Done. Solved. Simple. Moving on!
#
#So, we efficiently find all changed files. What then? Then we need to winnow
#down exactly what changed within such files: specifically, which globals were
#changed and how. We'll tackle this in two parts: first, how do we find which
#globals were changed? This part is quite simple, fortunately, thanks to the
#fact that *ALL* configuration globals should be declared with
#:declare_global(). Given the associative mappings between a parcel and all
#globals formally declared by that parcel, we know exactly which globals such
#file defines. Great! So here's how we find which changed. For each changed
#configuration file:
#
#=======================
#Wait. Everything below applies, but it's not quite as efficient as it could be.
#In particular, we should really:
#
#* For each such global, iteratively copy such global to a new global with
#  similar name (e.g., from ${ZY_ALTERNATIVES_SCREENSHOT_SCREEN} to
#  ${ZY_ALTERNATIVES_SCREENSHOT_SCREEN_new}).
#* Source the corresponding source configuration file, thus resetting all
#  globals to their original values.
#* For each such global, compare the stored new value for such global to the
#  current original value for such global.
#
#Fairly obvious, in hindsight. The approach below has us sourcing *TWO* files,
#while the approach above only one. *shrug*
#
#=======================
#
#* Source the corresponding source configuration file, thus resetting all
#  globals to their original values.
#* For each such global, iteratively copy such global to a new global with
#  similar name (e.g., from ${ZY_ALTERNATIVES_SCREENSHOT_SCREEN} to
#  ${ZY_ALTERNATIVES_SCREENSHOT_SCREEN_old}).
#* Source the corresponding target configuration file, thus returning all
#  globals to their changed values.
#* For each such global, compare the stored old value for such global to the
#  new value for such global. This trivially reduces to an "is ... == ..."
#  comparison for scalar globals, of course. For list globals, we *COULD*
#  attempt to flatten such globals to scalars and then perform a similar
#  comparison, but I'm unconvinced that would work reliably on edge cases. For
#  robustness, it'll be necessary to define a new :is_list_equals() function
#  efficiently comparing two lists as follows:
#
#  * If the size of such lists differs, such function can immediately report
#    failure without needing to check list contents.
#  * Else, we'll need to check list contents. To do so reliably necessarily
#    probably requires iteration of some sort. Wait! No, it doesn't. All we need
#    to do is obtain the asymmetric list difference between the two lists. Since
#    there exist two directions for such difference, we'll need to perform such
#    difference twice, resulting in two temporary lists: one from the difference
#    of such lists in one direction and the other from such difference in the
#    other direction. Hmm. Alternately, we could also take the *SYMMETRIC* list
#    intersection between the two lists. If the resulting list is the same size
#    as either input list, then such lists must necessarily be equal. Right? I
#    think so, but contemplate this a bit further. (And actually try it out, of
#    course.)
#
#  For map globals, I hope a similar approach as just delineated would suffice
#  for comparison. In any case, we *CAN* reliably, efficiently compare globals
#  regardless of type.
#* For each global that has been changed by the user, we want to produce one or
#  more lines of zsh code changing the default value for such to the user's
#  custom value for such global. For example, given a list global defaulting to:
#
#    ZY_LIST=( a b c d e f )
#
#  ...and a user's custom value for such global of:
#
#    ZY_LIST=( a b c d e g )
#
#  ...the required line of code is as follows:
#
#    ZY_LIST[6]='g'
#
#  So, how do we find the minimal lines of code effecting such changes? Simple:
#
#  * For scalars, simply forcefully reassign the entire scalar variable to the
#    new value. (We could split this apart into regular expression-based search
#    and replace expressions or some such, but... Well, that's crazy talk. Most
#    scalar configuration globals should be sufficiently short that simply
#    reassigning their values will suffice.)
#  * For lists, we'll need to determine *EXACTLY* which list items changed and
#    then produce a line of code as above reassigning such item. There's
#    probably no efficient means of implementing this aside from the obvious:
#    just iterate over all items and compare each with scalar comparisons. Given
#    that we're ultimately saving the user time by doing so, we reckon they can
#    afford to wait a bit for such process. Of course, this is complicated by
#    the fact that there exist three sorts of meaningful list operations:
#    * List additions (of new items).
#    * List deletions (of existing items).
#    * List item assignments (of existing items).
#    That said, while it *WOULD* be nice to detect additions and deletions and
#    we could theoretically do so, how exactly would one detect the situation of
#    *BOTH* a list addition and deletion? Indeed, the more changes the user
#    makes to a given list, the more it becomes clear that simply tracking all
#    list item assignments that need to made to convert from the source to
#    target lists not only suffices in the general case but is (arguably) the
#    optimal solution.
#  * For maps, identical reasoning holds.
#
#======================
#Actually, we ascertain below that we *REALLY* want to produce customizer
#functions tracking only scalar assignments and list and map item assignments:
#e.g.,
#
#      function "::customize_config_file_global:command/my_command:ZY_MAP"() {
#          # Need to pass an expected old value here, for safety checking.
#          :set_config_file_global_map_key_value_old_and_new\
#              "command/my_command" ZY_MAP 'my key' 'expected old value' 'desired new value'
#
#          # No need to pass an expected old value here, clearly.
#          :append_config_file_global_map_key_value\
#              "command/my_command" ZY_MAP 'my new key' 'desired new value'
#
#          # No need to pass *ANY* values here, clearly.
#          :delete_config_file_global_map_key\
#              "command/my_command" ZY_MAP 'my old key'
#      }
#
#It takes us a bit of thought wrangling to arrive at the above conclusion. But,
#there's the summation of it. Pretty sweet, eh?
#======================
#
#Ultimately, we'll have produced a number of lines resembling:
#
#    ZY_STRING='my new value'
#    ZY_LIST[6]='g'
#    ZY_MAP['my key']='my new value'
#    ZY_MAP['simloo']='gamjee'
#
#Now, what if we group such lines according to the global they act upon into
#small functions outputting such lines (in this example, for configuration file
#"~/.zeshy/config/command/my_command"): e.g.,
#
#    function "::customize_config_file_global::ZY_STRING"() {
#        output_string 'ZY_STRING="my new value"'
#    }
#    function "::customize_config_file_global:command/my_command:ZY_LIST"() {
#        output_string 'ZY_LIST[6]="g"'
#    }
#    function "::customize_config_file_global:command/my_command:ZY_MAP"() {
#        output_string '
#           ZY_MAP["my key"]="my new value"
#           ZY_MAP["simloo"]="gamjee"'
#    }
#
#Great! We're nearly there. We simply cache all such functions to a new digest
#(yup!) -- say "~/.zeshy/digest/config.zwc". We now have a perfectly recoverable
#record of all configuration file changes -- including the exact file, global,
#and code to effect such changes.
#
#What's left? We need to actually apply such changes in a meaningful manner,
#transforming default source zeshy configuration files to custom target user
#configuration files -- while preserving *ALL* original formatting in such files.
#Is this even feasible? The answer, of course, is yes: but we'll have to
#manually parse such files to do it. Fortunately, such files *WILL* adhere to a
#strict syntax. Ours. As currently defined. That's it. So, how do we effect such
#changes? For each such global:
#
#* First, we need to find the line such file defines such global on. This
#  *WOULD* be simple, except that we currently define scalar and nonscalar
#  globals in a slightly different manner, complicating parsing. But it's still
#  not *TOO* bad. Anyway, it's annoying, but very feasible.
#* If such global is a:
#  * Scalar, the prior parsing should probably simply be a direct search-and-
#    replace operation, replacing the current definition of such scalar with the
#    string output by the corresponding ::customize_config_file_global*()
#    function, as above.
#  * List, we could either append such list's definition with the string output
#    by the corresponding ::customize_config_file_global*() (easier, but
#    complicates future edits to such global by the user) *OR* ideally
#    dynamically construct a search-and-replace operation finding the nth item
#    of such list and replacing such item with the desired new value. Since the
#    former approach also requires perfect list parsing and produces a much less
#    desirable outcome, we should definitely aim for the latter approach. Ah!
#    Actually, there are three different type of list changes to consider:
#    * Changes to existing list items, which the above approach handles.
#    * Deletions of existing list items, recorded like so:
#      output_string 'ZY_LIST[5]=()'
#      Not terribly hard to handle. Just perform a search-and-replace where the
#      replacement string is the empty string. Done.
#    * Additions of new list items. We'll want to distinguish this from the case
#      of changing list items... Hmm. Right. I hereby suggest a new approach.
#      Rather than merely outputting code, instead have such functions *CALL*
#      the desired functions effecting such changes: e.g.,
#
#      function "::customize_config_file_global:command/my_command:ZY_MAP"() {
#          :set_config_file_global_map_key_value\
#              "command/my_command" ZY_MAP 'simloo' 'gamjee'
#          :append_config_file_global_map_key_value\
#              "command/my_command" ZY_MAP 'my key' 'my new value'
#          :remove_config_file_global_map_key_value\
#              "command/my_command" ZY_MAP 'unwanted key'
#      }
#
#      O.K.; that's pretty sweet.
#  * Map, pursue an identical approach as for lists.
#
#The inevitable question arises: what if attempting to automatically apply a
#change fails? This *WILL* happen all the time, though hopefully not in the
#common case. Consider, for example, a user customizing the value of a map key
#we remove in a subsequent version of zeshy. What's the right thing to do?
#Simple. Inform the user with a vivid warning on updating zeshy, and allow them
#to manually reapply such change in some fashion if they so desire. But in
#*MOST* cases, the above approach should suffice. I can't think of *ANY* other
#CLI software in existence going to such lengths. Nearly all simply ignore the
#issue. But it's not really ignorable, here.
#
#Actually, it's not necessarily clear that *ANY* changes will fail if we adopt
#the simplest approach of simply tracking low-level list and map item
#assignments (easy) rather than higher-level list and map item additions and
#deletions (*SIGNIFICANTLY* more difficult). In the former case, applying a
#simple list or map item assignment should *ALWAYS* succeed, suggesting we won't
#be able to reliably detect when such an assignment should actually fail. Hmmm;
#I see. Right. To detect failure states, we'll need to revise such customizer
#functions to store not only the desired new value for list and map items but
#the expected old value. Such functions should then ensure that such list or map
#actually contains the expected old value before applying the new value: e.g.,
#
#      function "::customize_config_file_global:command/my_command:ZY_MAP"() {
#          :set_config_file_global_map_key_value_old_and_new\
#              "command/my_command" ZY_MAP 'my key' 'expected old value' 'desired new value'
#      }
#
#O.K.; the prior example *IS* great, but we *WILL* need to track additions and
#deletions, for the obvious reason that deleted keys require no values to be
#passed while added keys require only the new value to be passed. A single
#:set_config_file_global_map_key_value_old_and_new() function, while great, does
#*NOT* suffice to describe map key additions and deletions. (Obvious in
#hindsight, we suppose.) So, we *WILL* need to detect and handle such
#situations. No way around, I'm afraid.
#
#Again, just emit warnings when expectations are not met rather than throwing
#fatal exceptions. (Obviously, don't go through with the change; just skip to
#the next customizer.)
#
#Naturally, this is all an incredible amount of work. We estimate about a
#month's worth. That's a huge investment. But it *WOULD* be worth it. And it
#would work. We're fully confident of that now.
#
#That said, we really want to pluck the low-hanging fruit by implementing MD5-
#based config file updating, first. Way easier and fairly essential to making
#zeshy updates at least moderately sane.

#FIXME: "if_distro" is fairly shoddy. Operation systems authored by the terrible
#twosome (i.e., Microsoft and Apple) provide no choice and hence no
#distributions; as such, "if_distro" should be renamed "if_os" and restructured
#as follows:
#
#if_os/
#  linux/
#  linux.arch/
#  linux.fedora/
#  linux.gentoo/
#  linux.ubuntu/
#  osx/
#  windows/
#
#So, the idea is to construct a dot-delimited topology of operating systems.
#(Avoid using underscores instead of dots here, as underscores typically
#supplant spaces rather than serving as internal structure.) Should be quite
#efficient to construct a function producing the string conforming to such
#topology specific to the current system. The function consuming such string
#should then split such string on "." and, for each matching prefix (e.g.,
#"linux" and "linux.arch" under Arch Linux), append such directory to the
#overlay stack.
#FIXME: O.K.; after a few months of contemplation, it's clear that, while novel
#and fun, the above concept isn't terribly scalable. For example, since both
#Linux and BSD (but neither OS X or Windows) support the concept of a compilable
#kernel, we probably want a shared parent directory of both: "if_os/unix",
#implying directory names "if_os/unix.linux" and "if_os/unix.bsd". But wait! OS
#X is, of course, derived from FreeBSD, implying directory name
#"if_os/unix.os_x". There goes that scheme, then.
#
#There's a larger issue at play, however. Contemplate needing to rename parent
#directory "unix". This would require renaming *ALL* directories prefixed by
#"unix.", as well. Hence, the aforementioned unscalability. Here's what we do
#instead:
#
#if_os/
#  00-common/
#    bsd/
#    linux/
#  bsd_free/
#    bsd/ --> ../00-common/bsd
#  bsd_net/
#    bsd/ --> ../00-common/bsd
#  linux_arch/
#    linux/ --> ../00-common/linux
#  linux_fedora/
#    linux/ --> ../00-common/linux
#  linux_gentoo/
#    linux/ --> ../00-common/linux
#  linux_ubuntu/
#    linux/ --> ../00-common/linux
#  os_x/
#  windows/
#
#Simple solution! In this case, since *NO* OS will ever be named "00-common" (by
#zeshy dictate, if nothing else), we appropriate such name for use in storing
#common OS components shared across multiple OSes. It's important we store such
#components here under "if_os", as their use and application is confined solely
#to such directory.
#
#This scheme has the benefit of *NOT* requiring additional functionality in
#"compile" aside from the following: a map global defined by such parcel named
#${ZY_OS_NAME_UNAME_TO_DIRNAME}, defined as follows:
#
#   ZY_OS_NAME_SYSTEM_TO_DIRNAME=(
#       'gnu/linux~gentoo' 'linux_gentoo'
#       ...
#   )
#
#And so on. In the case of Linux distros, the above system-derived OS name is
#dynamically queried as follows, assuming "lsb_release" to be a command in the
#current user's ${PATH}:
#
#   string os_name_system
#   os_name_system="${(L):-$(uname -o)~$(lsb_release -si)}"
#
#"~" was chosen as delimiter due to the unlikelihood of uname or lsb_release
#ever outputting a tilde. There's no sense at all in leaving things case-
#sensitive; so, coerce such output to lowercase.
#
#In Gentoo's case, "uname -o" outputs "GNU/Linux" and "lsb_release -si" outputs
#"Gentoo" -- which, when concatenated and lowercased, gives "gnu/linux~gentoo",
#matching the above key. Voila!
#
#There's really no simpler way, I'm afraid. (Or that I care to contemplate,
#anyway!) This is it, folks. It's not half bad, when it comes down to it...
#Really.
#FIXME: In the interests of iterative improvement, symbolic links are not a
#terribly robust road to begin walking down. Rather, adopt the following:
#
#if_os/
#  bsd/
#    if_distro/
#      netbsd/
#      freebsd/
#      openbsd/
#  linux/
#    if_distro/
#      arch/
#      gentoo/
#  darwin/
#  windows/
#
#It just makes sense, and you know it. So what if we nest subdirectories two
#levels deeper? This taxonomy is slightly more efficient and *MUCH* more
#rational. Also, no need for the silly map above. Just call the expected
#functions. Note that due to some distros existing under multiple OSes, it's
#insufficient to...
#FIXME: Wait. Precisely *BECAUSE* of that, flatten the above to simply:
#
#if_os/
#  bsd/
#  linux/
#  darwin/
#  windows/
#if_distro/
#  arch/
#  freebsd/
#  gentoo/
#  netbsd/
#  openbsd/
#
#Great! Best of all worlds. Since gentoo utilities should be the exact same under
#BSD (...I believe?), this simplifies a great deal. The inheritence is implicit,
#as it should be. No symlink or dirname nonsense, as before. Excellent!
#FIXME: Hmmm. At first blush, the prior idea is somewhat idealogically difficult
#to swallow: namely, our use of "if_distro" in the absence of a corresponding
#OS. In particular, can we *REALLY* treat distros as cross-platform-portable?
#Maybe. But maybe not. Hmm. O.K.; we get it. The idea *IS* fundamentally sound,
#for the simple reason that we can simply place all cross-platform-portable
#distro code under "40-if_distro" and then place non-cross-platform-portable
#distro code under the specific OS it applies to: e.g.,
#
#30-if_os/
#  bsd/
#    if_distro/
#      netbsd/
#      freebsd/
#      openbsd/
#  linux/
#    if_distro/
#      arch/
#      gentoo/
#  darwin/
#  windows/
#40-if_distro/
#  arch/
#  freebsd/
#  gentoo/
#  netbsd/
#  openbsd/
#
#Superb!
#FIXME: On a somewhat ancillary note, it's essential we avoid symlinks of any
#sort in zeshy. We know, we know. It'd be great to leverage them. *AVOID THAT
#COMPULSION*, however. Why? Simple: Windows. (Yeah; we know.) NTFS does actually
#support both file and directory symlinks (the latter referred to as
#"junctions", for some inane reason -- perhaps they're obsequious Final Fantasy
#fans?), but requires *ADMINISTRATOR* access to create them. What? This is sheer
#nonsense. Unfortunately, because of this core requirement, basically no one
#uses them. Certainly, git does *NOT* support symlink creation on repository
#clone, directly implying zeshy cannot leverage symlinks if it wants to run
#reliably on Windows. Which, belatedly, it does.
#FIXME: Ugh. We were belatedly under the misimpression that different flavors of
#BSD were also referred to as "BSD distributions." This is patently *NOT* the
#case; each BSD derivative is considered a distinct operating system. (A bit
#silly, honestly.) However, given the utility (and, indeed, necessity) of the
#above directory tree structure, we'd still like to consider the Gentoo/FreeBSD
#operating system as a Gentoo distribution running the FreeBSD kernel and
#supporting the *BSD toolchain. Whether or not this actually corresponds to
#official nomenclature in the BSD community is moot, for our purposes. Or...
#perhaps not? For cross-platform portable distributions (e.g., Debian, Gentoo),
#we should probably simply define corresponding testers :is_os_debian(),
#:is_os_gentoo(), and so on. Given that, we really *DON'T* want a top-level
#parcel @{40-if_distro}, as distros genuinely are Linux-specific. This leaves us
#with a tree resembling:
#
#30-if_os/
#  bsd/
#  darwin/
#  debian/
#  freebsd/
#  gentoo/
#  linux/
#    if_distro/
#      arch/
#      fedora/
#  netbsd/
#  openbsd/
#  windows/
#
#Simple. @{compile} then iteratively tests whether or not the current OS applies
#to each subdirectory "${os_name}/" of an "*-if_os/" overlay directory by
#calling the corresponding tester :is_os_${os_name}(): e.g., first :is_os_bsd(),
#then :is_os_darwin(), and so on. Of course, this could be optimized by:
#
#* Defining a new "(...|...)"-style string global ${ZY_OS_GLOB} delimiting
#  all applicable OS-specific "keywords" for the current OS by "|". For example:
#  * If the current OS is Gentoo Linux, set ZY_OS_ID="(linux|gnu|gentoo)".
#  * If the current OS is Gentoo FreeBSD, set ZY_OS_ID="(bsd|freebsd|gentoo)".
#* Use zsh pathname globbing to filter the basenames of all such subdirectories
#  in the above overlay with such glob. Extremely efficient, requiring no
#  iteration (unlike the initial, simplistic solution above).

#FIXME: The current digest file depends on both zeshy-specific state (e.g.,
#whether or not we're compiling a debug build) and system-specific state (e.g.,
#the current OS and windowing manager in use). The current configuration tree
#*NEEDS* to similarly depend on the system- but *NOT* zeshy-specific state. One
#configuration tree should suffice for all possible zeshy states; however, the
#same cannot be said of system states. Users should be able to seemlessly move
#their entire "~/.zeshy" directory between not only different machines running
#the same OS but between different machines running different OSes. To effect
#the latter, we'll need to specifically create an intermediary subdirectory
#directly under "~/.zeshy/config" named after all relevant system state: e.g.,
#
#    ~/.zeshy/
#        config/
#            current -> linux.gentoo.x11/
#            linux.gentoo.mir/
#                00-core/
#                command/
#            linux.gentoo.wayland/
#                00-core/
#                command/
#            linux.gentoo.x11/
#                00-core/
#                command/
#            darwin/
#                00-core/
#                command/
#            windows/
#                00-core/
#                command/
#
#Note the symbolic link "current", linking to configuration tree
#"linux.gentoo.x11/" in the above example. Such directory is both for user
#convenience and zeshy use. Indeed, setting such symlink in a reliable manner
#simplifies our selection of the configuration tree corresponding to the current
#OS and windowing manager. (That is, assuming we set such symlink reliably, *NO*
#existing code in this parcel needs to change to accommodate this improvement.)
#
#Parcel @{digest} should probably maintain such symlink, yes?

#FIXME: Preserve "src/if_pathable" and make a new "src/if_pathables" directory
#(...or perhaps just add support for such syntax to "src/if_pathable"?)
#containing pseudo-code resembling:
#
#* src/if_pathables/"sox or lame or mpg123"
#* src/if_pathables/"vlc and (sox or lame or mpg123)"
#
#For implementation purposes, there exist three possible cases for each subpath
#of such directory:
#
#* Such subpath matches glob "*(' or '*' and '|' and '*' or ')*", implying that
#  such subpath contains a mix of disjunction and conjunction operators. In such
#  case, it isn't really feasible for zeshy to manually parse such subpath and
#  perform the resulting implied test. (There are too many possible combinations
#  for a simple regex to suffice, implying the need for a non-regular CFL parser,
#  clearly outside the scope of even zeshy digest compilation.) Instead, perform
#  the following:
#  * If such subpath matches glob "*[^[:alnum:]-_ ()]*", such subpath contains a
#    shell-reserved character and hence must be rejected. *THROW AN EXCEPTION*.
#    This is critical. Since we "eval" such subpath below, unsafely evaluating
#    any arbitrary filename could have dramatic consequences. (Imagine a third-
#    party zeshy plugin installing "src/if_pathables/$(command rm -R ~/)").
#    * This *MAY* not actually be necessary. Examining the heuristics below, it
#      looks like we never evaluate such strings in a command context: we simply
#      expand ${MATCH} to the corresponding string without evaluating,
#      executing, or otherwise running such string. Right. No safety concerns
#      here, I believe. Don't bother testing or throwing exceptions. Sweet, no?
#  * Perform the following glob replacements on such subpath in order:
#    * "//[[:space:]]##or[[:space:]]##/ || ", replacing " or " with " || ".
#    * "//[[:space:]]##and[[:space:]]##/ && ", replacing " and " with " && ".
#    * "//(#m)[[:alnum:]-_]##/[[ ${MATCH:c} == '/'* ]]", replacing command names
#      with an efficient shell test for whether such command exists.
#  * The resulting expression should be a valid zsh test for whether such
#    commands exist. Evaluate such expression, squelching standard output and
#    error. If the result is true, source such file; otherwise, do not.
#* Else, such subpath contains only all " or " or all " and " operators. In
#  either case, perform a single, compact, safe, and efficient test, ideally in
#  a single zsh statement using lists, implementing the corresponding boolean
#  expression. Zing!
#FIXME: Actually, just *ALWAYS* do the first, more generalized approach above.
#Merely testing for whether to perform the optimized test reduces such
#optimization's efficiency. Given the short length of such strings, I can't see
#the harm is always electing to go the foolproof route, which still appears to
#be reasonably efficient. Yes!
#FIXME: Actually, just reduce the test of whether to adopt the generalized
#approach to matching *' '* (i.e., if such string contains whitespace, assume
#the use of conditional "or" and "and" operators). Such approach is expensive
#enough that we only want to do it if we have to.
#FIXME: :define_func_if_pathable() now implements this *EXACT* logic in low-
#level zsh code, suggesting we should abstract out that section of such
#function's implementation to a function defined... where, exactly? While we
#could certainly defining such function in this parcel, doing so would prevent
#its compilation into the current digest file. *sigh*

#FIXME: Compilation is currently a bit... fragile. If *ANYTHING* goes wrong
#during zeshy codebase sourcing (particularly precompilation, which now
#performs quite a bit of functionality), the digest file is never created or
#created corrupted, which is arguably worse. We should probably be catching
#exceptions and somehow also printing stack traces (...ugh; I'm unsure that's
#possible, actually) when sourcing source and configuration files and when
#calling ::zeshy.precompile(). Convert exception messages into warning messages
#and try to silently continue. Ah; right. Stack traces *SHOULD* be printed by
#:die(), so we're good to go, yes? That's not necessarily how it works under
#conventional high-level languages, but... fuck it. That's how it works here.
#FIXME: It'd be awesomely inspiring to print an in-place rotating ANSI-fueled
#progress sequence (i.e., "\-/|\-/|") during script sourcing. Namely, after
#sourcing every ten or so scripts, rotate such sequence a single character.
#Naturally, confine such logic to VT100-capable terminals. It's essential to do
#so without importing any heavyweight zsh modules or scripts; should be quite
#doable, no? I wouldn't be terribly surprised if the exact sequences to be
#printed are already readily Googleable.
#FIXME: Indeed, digest compilation is decomposable into two segments:
#
#1. Overlay discovery, relatively fast. (Estimated 5% of time spent.)
#2. Script sourcing, relatively slow. (Estimated 95% of time spent.)
#
#Given this, an empty progress bar should be displayed immediately prior to
#overlay discovery, incremented to approximately 5% of the width of the screen
#during such discovery, and then incremented to the remaining screen width
#during such sourcing. Since we know *EXACTLY* how many scripts to be sourced
#before doing so, the latter is readily accomplished; the former, however, must
#be merely guestimated at. For example, we might estimate a maximum of 32
#discovered overlays, and then increment the progress bar accordingly.

# ....................{ COMPILERS                         }....................
#FIXME: While zeshy implements no overlays as symbolic links (due both to the
#cross-platform incompatibility of such links *AND* to the fact that such links
#would generalize the codebase from what would otherwise be an directed acyclic
#graph (DAG) and hence tree into a directed, possibly cyclic graph and hence
#non-tree, which would require more robust and hence inefficient data structures
#to avoid infinite loops), individual users certainly could. The algorithm below
#should explicitly guard against such cyclicity -- ideally, by supporting rather
#than merely ignoring such symbolic links, which will unfortunately require
#additional bookkeeping as suggested above. That said, this shouldn't introduce
#*TOO* much inefficiency, due to the small number of suboverlays.
#
#Namely, we'll need to introduce a new map local
#${ZY_OVERLAY_DIRNAME_VISITED_TO_NIL} or some such, permitting efficient
#lookup of prospective new overlays to determine whether or not they've already
#been visited. Immediately before visiting a suboverlay (i.e., calling the
#corresponding ::zeshy.compile_suboverlay_*() function), perform the following:
#
#* If the absolute path of such suboverlay is already a key of such map, ignore
#  such suboverlay.
#* Else:
#  * Add such suboverlay as a key with value the empty string to such map.
#  * Call the corresponding ::zeshy.compile_suboverlay_*() function.

# :void ::zeshy.compile_overlay_root(:str overlay_dirname)
function ::zeshy.compile_overlay_root() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    local overlay_dirname suboverlay_compiler
    local -aU ZY__OVERLAY_DIRNAMES

    # FIFO stack of the absolute paths of all overlays applicable to the current
    # system, incrementally discovered by depth-first first search (DFS) of root
    # overlays. In zsh, adding and removing the last item of a list is
    # considerably more efficient than the same operation on any other list
    # items. Consequently, FIFO stacks are efficiently implemented in zsh by
    # pushing and popping onto and off the end of lists.
    #
    # This stack contains both overlays and suboverlays (i.e., immediate
    # subdirectories of overlays), each requiring distinct handling. Hence, we
    # distinguish the two by prefixing each of the former with the null
    # character. Since POSIX pathnames are guaranteed to *NOT* contain null
    # characters, using such characters to do so is inherently safe.
    #
    # Initialize such stack to the passed dirname, thus rooting such search to
    # such overlay.
    ZY__OVERLAY_DIRNAMES=( "${1}" )

    # Perform a depth-first search of all applicable overlays in such overlay.
    # While such stack is nonempty, pop the top overlay off such stack and
    # push all immediate subdirectories of such overlay satisfying any
    # conditional requirements of such overlay onto the top of such stack (e.g.,
    # only pushing subdirectories whose basenames match those of existing
    # pathables for "if_pathable" suboverlays).
    while (( ${#ZY__OVERLAY_DIRNAMES} )) {
        # Pop the top overlay off such stack. See pop_list() for further
        # details.
        overlay_dirname="${ZY__OVERLAY_DIRNAMES[-1]}"
        ZY__OVERLAY_DIRNAMES[-1]=()

        # If such overlay is prefixed by the null character, such overlay is a
        # suboverlay. Unlike overlays, suboverlays are typed according to their
        # directory names (e.g., suboverlays matching "*-if_pathable" are
        # pathable suboverlays). Parse such suboverlay's type from its name and
        # call the corresponding compiler function.
        if [[ ${overlay_dirname[1]} == $'\0' ]] {
            # Strip such prefix from such dirname.
            overlay_dirname="${overlay_dirname[2,-1]}"

            # If such suboverlay is a file, source such file. While files are
            # *NOT* suboverlays, ::zeshy.compile_overlay_container() blurs the
            # line between the two by pushing files onto the overlay stack.
            # Doing so permits files directly residing in overlays to order
            # themselves before or after suboverlays in the same overlay (e.g.,
            # an overlay with file "late" and suboverlay "00-early" will source
            # the latter *BEFORE* the former, due to lexicographic order).
            if [[ -f ${overlay_dirname} ]] {
                ::zeshy.compile_overlay_scripts "${overlay_dirname}"
            # Else, such suboverlay is a subdirectory as expected.
            } else {
                # Name of the function compiling such overlay if such overlay
                # requires special handling. Dismantled, this is:
                #
                # * ":t", reducing such directory to its basename.
                # * "##*-", reducing such basename to the substring following
                #   the last "-" in such basename, if found.
                suboverlay_compiler='::zeshy.compile_suboverlay_'${${overlay_dirname:t}##*-}

                # If such function does *NOT* exist, default such function to
                # the standard function compiling overlays requiring no special
                # handling. (Such function is guaranteed to exist.)
                (( ${+functions[${suboverlay_compiler}]} )) ||
                    suboverlay_compiler='::zeshy.compile_suboverlay_simple'

                # Compile such suboverlay.
                :stdout.echo_if_debug 'Searching suboverlay "'${overlay_dirname}'".'
                "${suboverlay_compiler}" "${overlay_dirname}"
            }
        # Else, such overlay is an actual overlay. Unlike suboverlays, overlays
        # are untyped and hence share the same compiler. Compile such overlay.
        } else {
            ::zeshy.compile_overlay_container "${overlay_dirname}"
        }
    }
}

# void ::zeshy.compile_overlay_container(string overlay_dirname)
function ::zeshy.compile_overlay_container() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    local overlay_dirname="${1}"
    local -a overlay_subdirnames
    [[ -d ${overlay_dirname} ]] ||
        :die 'Overlay "'${overlay_dirname}'" not found or not a directory.'
    :stdout.echo_if_debug 'Searching ...overlay "'${overlay_dirname}'".'

    # Avoid sourcing the following types of paths as zeshy overlays or scripts:
    #
    # * zeshy-specific hidden files and subdirectories (i.e., with "."-
    #   prefixed basenames).
    # * "vim"-specific cache files (i.e., with filetype "swp").
    local ZY__SCRIPT_PATHNAME_GLOB_EXCLUDE='~(*/.*|*.swp)'

    # List of all subdirectories in such overlay in reverse lexical order.
    # Such subdirectories are pushed onto the overlay stack below. Since
    # ::zeshy.compile_overlay_root() treats the last item on such stack as the
    # next directory to be visited, reversing their ordering here ensures such
    # function visits such subdirectories in the expected order. (Think reverse
    # Polish notation).
    #
    # Ideally, we would match both simple files and subdirectories with a glob
    # qualifier disjunction (i.e., a syntactic construct matching only paths
    # that are either simple files or subdirectories). Unfortunately, zsh only
    # currently supports glob qualifier conjunctions (e.g., "(-./)", matching
    # paths that are both simple files and directories and hence nothing).
    # However, since the set of all simple files and directories is exactly the
    # negation of the set of all non-special files (i.e., paths that are
    # neither sockets, named pipes, or device files), we negate the latter with
    # "^" to match the former. Dismantled, this is:
    #
    # * "-", transitively resolving all symbolic links.
    # * "On", reversing the order of such paths.
    # * "^=p%", excluding all special files.
    #
    # If such overlay is *NOT* the root overlay, also list and hence push all
    # scripts directly residing in such overlay onto the overlay stack. See ::zeshy.compile_overlay_root().
    if [[ ${overlay_dirname} != ${ZY_OVERLAY_DIR} ]] {
        overlay_subdirnames=(
            "${overlay_dirname}"/*${~ZY__SCRIPT_PATHNAME_GLOB_EXCLUDE}(-On^=p%)
        )
    # Else, such overlay is the root overlay. Since all scripts directly
    # residing in such overlay have already been sourced (including the current
    # script), avoid erroneously resourcing such scripts by listing only
    # overlay subdirectories. Dismantled, this is:
    #
    # * "-/", matching only subdirectories after resolving symbolic links.
    } else {
        overlay_subdirnames=(
            "${overlay_dirname}"/*${~ZY__SCRIPT_PATHNAME_GLOB_EXCLUDE}(-/On)
        )
    }

    # Compile all subdirectories in such overlay, prefixed by the null
    # character. See ::zeshy.compile_overlay_root() for further details.
    ::zeshy.compile_overlay_dirs $'\0'"${^overlay_subdirnames[@]}"
    # print -r -- "pushing: ${overlay_subdirnames[*]}"
}

# void ::zeshy.compile_overlay_scripts(string... filenames)
function ::zeshy.compile_overlay_scripts() {
    ::script_zsh.source "${@}"
}

# void ::zeshy.compile_overlay_dirs(string... dirnames?)
function ::zeshy.compile_overlay_dirs() {
    ZY__OVERLAY_DIRNAMES+=( "${@}" )
}

# ....................{ COMPILERS ~ suboverlay             }....................
# void ::zeshy.compile_suboverlay_simple(string suboverlay_dirname)
function ::zeshy.compile_suboverlay_simple() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one suboverlay dirname.'
    local dirname_suboverlay="${1}"
    [[ -d "${dirname_suboverlay}" ]] ||
        :die "Suboverlay \"${dirname_suboverlay}\" not found or not a directory."

    # Compile all zeshy scripts in such directory.
    ::zeshy.compile_overlay_scripts\
        "${dirname_suboverlay}"/**/${~ZY__SCRIPT_FILENAME_GLOB}
}

# void ::zeshy.compile_suboverlay_if_config(string suboverlay_dirname)
function ::zeshy.compile_suboverlay_if_config() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one suboverlay dirname.'
    local dirname_suboverlay="${1}" filename_trg
    [[ -d "${dirname_suboverlay}" ]] ||
        :die "Suboverlay \"${dirname_suboverlay}\" not found or not a directory."

    # For each configuration file recursively globbed in such suboverlay...
    local filename_src
    for   filename_src (
        "${dirname_suboverlay}/"**/${~ZY__SCRIPT_FILENAME_GLOB}) {
        # Absolute path of the target configuration file in the current user's
        # zeshy dot directory (and hence stripped of the source directory).
        filename_trg="${ZY_USER_CONFIG_DIRNAME}/${filename_src#${dirname_suboverlay}/}"

        #FIXME: *NOT* necessarily. This is a subtle but important point, and we
        #absolutely need to tighten this up. Suppose the following two files:
        #
        #* "src/if_pathable/rsync/if_config/pathable/rsync".
        #* "src/if_pathable/vim/if_config/pathable/rsync".
        #
        #What happens in this case? Clearly, there's a fairly serious issue
        #here: @{rsync} has erroneously declared a configuration file of the
        #same name as @{vim}. Which wins? It's fairly arbitrary. Unfortunately,
        #given the overly simplistic and trusting conditional below, @{vim}
        #would silently fail to copy its configuration file over. @{rsync} wins,
        #with no one the wiser.
        #
        #Catching such errors will require us to declare a local map in
        #top-level function :zeshy.compile() (for efficient lookup) from
        #pathnames relative to "~/.zeshy/config" to the empty string: e.g.,
        #
        #    map ZY_OVERLAY_IF_CONFIG_FILENAMES
        #        ZY_OVERLAY_IF_CONFIG_FILENAMES=( 'pathable/rsync' )
        #
        #Naturally, such map should be initially empty. *BEFORE* performing the
        #conditional below, check whether or not such file has already been
        #copied by this loop, in which case an exception should be thrown.
        #Otherwise, after copying such file, add such file to this map.
        #
        #Simple. We just need to do it.

        # If such file has *NOT* already been copied into the current configuration
        # directory, do so.
        [[ -f "${filename_trg}" ]] || {
            :stdout.echo_if_debug 'Adding configuration "'${filename_trg}'".'

            # Make such file's parent directory, if needed.
            command mkdir -p -- "${filename_trg:h}"

            # Copy such file. Do *NOT* source such file: most configuration files
            # require aliases subsequently declared under the main zeshy codebase.
            command cp -- "${filename_src}" "${filename_trg}"
        }

        # Compile such zeshy script.
        ::zeshy.compile_overlay_scripts "${filename_trg}"
    }
}

# void ::zeshy.compile_suboverlay_if_pathable(string suboverlay_dirname)
function ::zeshy.compile_suboverlay_if_pathable() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one suboverlay dirname.'
    local dirname_suboverlay="${1}"
    local -a pathnames_pathable
    [[ -d "${dirname_suboverlay}" ]] ||
        :die "Suboverlay \"${dirname_suboverlay}\" not found or not a directory."

    # List of the absolute paths of all files and subdirectories of such
    # suboverlay whose basenames are also pathable. Dismantled, this is:
    #
    # * "${dirname_suboverlay}/"*, expanding to each such file or subdirectory.
    # * "(e^'(( ... ))'^)", excluding files and subdirectories failing such test
    #   (i.e., for which such test expands to 0):
    #   * "${REPLY:t}", the basename of such file or subdirectory.
    #   * "${+commands[...]}", expanding to 1 if such basename is pathable or to
    #     0 otherwise.
    # * "|| true", ignoring erroneous failure reported by zsh. (Curiously, zsh
    #   occasionally report failure from such list assignment. It shouldn't.)
    pathnames_pathable=(
        "${dirname_suboverlay}/"*(e^'(( ${+commands[${REPLY:t}]} ))'^)
    ) || true

    # Compile all zeshy scripts in such suboverlay.
    ::zeshy.compile_overlay_scripts "${^pathnames_pathable[@]}"(-.)

    # Compile all subdirectories in such suboverlay.
    ::zeshy.compile_overlay_dirs "${^pathnames_pathable[@]}"(-/)
}

# ....................{ COMPILERS ~ suboverlay : tester    }....................
# void ::zeshy.compile_suboverlay_if_display_server(string suboverlay_dirname)
function ::zeshy.compile_suboverlay_if_display_server() {
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    ::zeshy.compile_suboverlay_with_tester_prefix\
        "${1}" ':is_display_server'
}

# void ::zeshy.compile_suboverlay_if_package_manager(string suboverlay_dirname)
function ::zeshy.compile_suboverlay_if_package_manager() {
    (( # == 1 )) || :die 'Expected one overlay dirname.'
    ::zeshy.compile_suboverlay_with_tester_prefix\
        "${1}" ':is_package_manager'
}

function ::zeshy.compile_suboverlay_with_tester_prefix() {
    # Validate sanity.
    (( # == 2 )) || :die\
        'Expected one suboverlay dirname and one tester prefix.'
    local\
        suboverlay_dirname="${1}"\
        tester_prefix="${2}"\
        tester_any\
        tester_any_dirname
    [[ -d "${suboverlay_dirname}" ]] || :die\
        'Suboverlay "'${suboverlay_dirname}'" not found or not a directory.'

    # If such suboverlay contains a subdirectory "any":
    #
    # * Call the tester whose name is exactly the passed prefix (e.g., tester
    #   :is_display_server() for suboverlay subdirectory
    #   "if_display_server/any").
    # * If such tester succeeds, compile such subdirectory. Ideally, this occurs
    #   if the current system provides at least one of the subject being tested.
    tester_any_dirname="${suboverlay_dirname}/any"
    if [[ -d "${tester_any_dirname}" ]] {
        # If such tester does *NOT* exist, throw an exception. See
        # :die_unless_function() for further details.
        tester_any="${tester_prefix}"
        (( ${+functions[${tester_any}]} )) || :die\
            'Overlay "'${tester_any_dirname}'" uncompileable (i.e., function '${tester_any}'() not found).'

        # Compile such subdirectory if such tester succeeds.
        if { "${tester_any}" } {
            ::zeshy.compile_overlay_dirs "${tester_any_dirname}"
        }
    }

    # If such suboverlay contains a subdirectory "name", perform the following
    # for all immediate subdirectories of such subdirectory:
    #
    # * Call the tester whose name is the basename of such immediate
    #   subdirectory prefixed by such prefix and "_" (e.g., tester
    #   :is_display_server_x() for suboverlay subdirectory
    #   "if_display_server/name/x").
    # * If such tester succeeds, compile such subdirectory. Ideally, this occurs
    #   if the current system provides the subject being tested.
    ::zeshy.compile_suboverlay_subdir_with_tester_prefix\
        "${suboverlay_dirname}/name" "${tester_prefix}_"

    # If such suboverlay contains a subdirectory "trait", perform the following
    # for all immediate subdirectories of such subdirectory:
    #
    # * Call the tester whose name is the basename of such immediate
    #   subdirectory prefixed by such prefix and "_trait" (e.g., tester
    #   :is_display_server_trait_x() for suboverlay subdirectory
    #   "if_display_server/trait/x").
    # * If such tester succeeds, compile such subdirectory. Ideally, this occurs
    #   if the current system provides at least one of the subject being tested
    #   having such trait.
    ::zeshy.compile_suboverlay_subdir_with_tester_prefix\
        "${suboverlay_dirname}/trait" "${tester_prefix}_trait_"
}

function ::zeshy.compile_suboverlay_subdir_with_tester_prefix() {
    # Validate sanity.
    (( # == 2 )) || :die\
        'Expected one suboverlay subdirectory dirname and one tester prefix.'
    local\
        suboverlay_subdirname="${1}"\
        tester_prefix="${2}"\
        tester\
        tester_basename

    # If such subdirectory does *NOT* exist, return silently. Since suboverlays
    # are *NOT* required to provide all or even any such subdirectories (e.g.,
    # "name/", "trait/"), this does *NOT* constitute an error condition.
    [[ -d "${suboverlay_dirname}" ]] || return 0

    # For all immediate subdirectories of such subdirectory for which the
    # tester whose name is the basename of such immediate subdirectory prefixed
    # by such prefix and "_trait", compile such immediate subdirectory.
    local tester_dirname
    for   tester_dirname ("${suboverlay_subdirname}/"*(-/)) {
        # Basename of such subdirectory. See :set_string_to_path_basename()
        # for further details.
        tester_basename="${tester_dirname:t}"

        # If such tester does *NOT* exist, throw an exception. See
        # :die_unless_function() for further details.
        tester="${tester_prefix}${tester_basename}"
        (( ${+functions[${tester}]} )) || :die\
            'Overlay "'${tester_dirname}'" uncompileable (i.e., function '${tester}'() not found).'

        # Compile such subdirectory if such tester succeeds.
        if { "${tester}" } {
            ::zeshy.compile_overlay_dirs "${tester_dirname}"
        }
    }
}
