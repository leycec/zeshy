#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Uncomment after shifting +{parcel} here.

# :parcel <<'/---'
# Handle *macro preprocessor exception handlers* (i.e., functions throwing
# exceptions resulting from macro preprocessing).
# /---

# ....................{ EXCEPTION                          }....................
# :void ::code.preprocess.die(:string exception_message)
#
# Throw an exception with the passed message detailing a fatal error resulting
# from preprocessing code to be preprocessed. This private exception handler is
# intended to be called _only_ by ::code.preprocess().
#
# == Message Format ==
#
# The passed message should be formatted as a lowercase sentence fragment (e.g.,
# `prototype invalid`), which this function then:
#
# * Prefixes by `Parcel +{${parcel_name}} preprocessing failed `, where:
# ** `${parcel_name}` is the name of the preprocessed parcel.
function ::code.preprocess.die() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one exception message.'
    local exception_message=${1}
    [[ -n ${exception_message} ]] ||
        :die 'Expected non-empty exception message.'

    # Throw such exception.
    :die $(::parcel.get)'preprocessing failed '${exception_message}
}

# ....................{ EXCEPTION ~ byte                   }....................
# :void ::code.preprocess.die_at_byte_current(
#     :string exception_message,
#     :int error_byte_first)
#
# Throw an exception with the passed message detailing a fatal error occurring
# at or after the first byte of the current PCRE match of the code passed to the
# most recent call to ::code.preprocess(). This private exception handler is
# intended to be called _only_ by such function.
function ::code.preprocess.die_at_byte_current() {
    # Validate sanity.
    (( # == 1 )) || :die 'Expected one exception message.'
}

# :void ::code.preprocess.die_at_byte(
#     :string exception_message,
#     :int error_byte_first)
#
# Throw an exception with the passed message detailing a fatal error beginning
# at the passed byte index of the code to be preprocessed by the most recent
# call to ::code.preprocess(). This private exception handler is intended to be
# called _only_ by such function.
#
# == Message Format ==
#
# The passed message should be formatted as a lowercase sentence fragment (e.g.,
# `prototype invalid`), which this function then:
#
# * Prefixes by `at line ${line_number} character ${column_number}`, where:
# ** `${line_number}` is the line number in such parcel at which such error
#    began or was otherwise first identified.
# ** `${column_number}` is the character offset on such line at which such error
#    began or was otherwise first identified.
# * Suffixes by such line.
function ::code.preprocess.die_at_byte() {
    # Validate sanity.
    (( # == 2 )) || :die 'Expected one exception message and one byte index.'
    local\
        exception_message=${1}\
        error_byte_first=${2}\
        error_arrow\
        error_line\
        error_line_error_prefix\
        exception_prefix\
        exception_suffix
    integer\
        error_line_number\
        error_line_byte_first\
        error_line_error_byte_first\
        error_line_error_char_first

    # If such index is *NOT* a valid index into such code, throw an exception.
    {
        [[ ${error_byte_first} == <0-9>## ]] && ((
            error_byte_first >= 1 &&
            error_byte_first <= ${#ZESHY__PREPROCESS_CODE}
        ))
    } || :die 'Byte index '${error_byte_first}' not an integer in [1,'${#ZESHY__PREPROCESS_CODE}'].'

    # ..................{ UNIBYTE                             }..................
    # Index of the first byte of the line containing such error. Dismantled,
    # this is:
    #
    # * "%", removing the smallest matching string and hence the last line of
    #   the substring of such code preceding such error including prefixing
    #   newline. If such line is the first line and hence *NOT* prefixed by
    #   newline, no string will be matched or removed, implying such index will
    #   erroneously be reported as ${error_byte_first}. This is corrected below.
    error_line_byte_first=${#ZESHY__PREPROCESS_CODE[1,${error_byte_first}]%$'\n'*}

    # If such line is the first line, such index will erroneously be reported as
    # ${error_byte_first}. Correct this by coercing such index to 1.
    (( error_line_byte_first != error_byte_first )) ||
       error_line_byte_first=1

    # Line containing the first byte of such error. Dismantled, this is:
    #
    # * "%%", removing the longest matching string and hence all lines of the
    #   substring of such code following such line including prefixing newlines.
    error_line=${ZESHY__PREPROCESS_CODE[${error_line_byte_first},-1]%%$'\n'*}

    #FIXME: Clever. Unfortunately, we won't be using it. Why? Because such line
    #numbers are postprocessed and hence bear little relation to the
    #preprocessed line numbers expected by the user. Given that, we'll need to
    #convert the latter to the former -- probably by parsing a commented line
    #number following the offending byte.

    # Line number of the line containing such error. For efficiency, calculate
    # such number as follows:
    #
    # * Remove all non-newline characters in the substring of such code up to
    #   and including the first byte of such error.
    # * Count the byte length of the resulting string, Since the prior operation
    #   guarantees such string to contain only ASCII newline characters, such
    #   byte length is the number of such characters in the original string.
    error_line_number=${#ZESHY__PREPROCESS_CODE[1,${error_byte_first}]//[^$'\n']##}

    # Index of the first byte of such error relative to the first byte of such
    # line.
    error_line_error_byte_first=$((
        error_byte_first - error_line_byte_first + 1 ))

    # Substring up to and including the first byte of such error on such line.
    error_line_error_prefix=${error_line[1,${error_line_error_byte_first}}

    # ..................{ MULTIBYTE                           }..................
    # Human-readable multibyte length of such substring. Since prior code
    # operates under shell option "no_multiybyte" due to ${+backend}
    # requirements and hence in a unibyte manner, locally disable such option.
    setopt local_options multibyte
    error_line_error_char_first=${#error_line_error_prefix}

    # Number of ASCII characters preceding the multiline ASCII arrowhead below.
    error_arrow_padding_length=$(( error_line_error_char_first - 1 ))

    #FIXME: Colorize such output in a user-customizable manner.

    # Multiline ASCII arrow indicating the first character of such error in such
    # line. See :set_string_to_string_ansiless_repeated_to_length().
    error_arrow=${(r:${error_arrow_padding_length}::-:):-}','$'\n'${(r:${error_arrow_padding_length}:: :):-}'v'

    # String prefixing such exception message.
    exception_prefix='at line '${error_line_number}' character '${error_line_error_char_first}' '

    # String suffixing such exception message.
    exception_suffix=':'$'\n\n'${error_arrow}${error_line}

    # Throw such exception.
    ::code.preprocess.die ${exception_prefix}${exception_message}${exception_suffix}
}

# ....................{ EXCEPTION ~ byte : cause           }....................
# :void ::code.preprocess.die_of_syntax_invalid()
#
# Throw an exception detailing an *invalidity* at the current match position
# (i.e., a syntax error in the most recently matched syntactic construct). This
# function implicitly detects such invalidity's type and hence requires no
# explicit message to be passed. This private exception handler is intended to
# be called _only_ by ::code.preprocess().
function ::code.preprocess.die_of_syntax_invalid() {
    # Validate sanity.
    (( ! # )) || :die 'Expected no arguments.'

    # Human-readable name of the type of such construct.
    local construct_type

    # Byte length of the prefix prefixing such construct (e.g., 2 for
    # "<<"-prefixed here-documents).
    integer construct_prefix_byte_length

    # Index of the byte at which to begin iterative globbing of such prefix.
    # Since syntactic prefixes are guaranteed to be between one to three
    # characters, compare only the three characters preceding the first byte of
    # the matched substring against an iterative series of simple globs. For
    # safety, clamp such index to 1.
    #
    # Note that the derivation of
    # ${ZESHY__PREPROCESS_SUBCODE_MACRO_BYTE_FIRST} assumed the character
    # preceding the current match to be unibyte. Is this reliably the case for
    # *ALL* invalid syntax? Happily, yes. By PCRE design, such syntax is
    # *ALWAYS* preceded by a syntactic prefix; by zsh design, *ALL* such
    # prefixes comprise only ASCII characters; hence, the character preceding a
    # match of invalid syntax is guaranteed to be unibyte. Should this ever
    # change, note the following calculation to efficiently yield the index of
    # the first byte of the current match and hence of the character
    # immediately following such syntactic prefix:
    #
    #    integer code_construct_sans_prefix_byte_first=$((
    #        ZESHY__PREPROCESS_CODE_BYTE_LENGTH - ${#MATCH} ))
    integer code_construct_prefix_byte_first=$((
        ZESHY__PREPROCESS_CODE_MACRO_BYTE_FIRST - 3 ))

    # Index of the byte at which to end iterative globbing of such prefix.
    integer code_construct_prefix_byte_last=$((
        ZESHY__PREPROCESS_CODE_MACRO_BYTE_FIRST - 1 ))

    # Clamp such 1-based indices to 1.
    ((  code_construct_prefix_byte_first > 0 )) ||
        code_construct_prefix_byte_first=1
    ((  code_construct_prefix_byte_last  > 0 )) ||
        code_construct_prefix_byte_last=1

    # Prefix prefixing such construct.
    local code_construct_prefix=${ZESHY__PREPROCESS_CODE[${code_construct_prefix_byte_first},${code_construct_prefix_byte_last}]}

    # Identify such construct.
    case ${code_construct_prefix} {
    # The "$'" prefixing print()-quoted strings overlaps the "'" prefixing
    # single-quoted strings and hence is matched first.
    (*'$''')
        construct_type='print()-quoted string'
        construct_prefix_byte_length=2
        ;;
    (*"'")
        construct_type='single-quoted string'
        construct_prefix_byte_length=1
        ;;
    (*'"')
        construct_type='double-quoted string'
        construct_prefix_byte_length=1
        ;;
    (*'\')
        construct_type='escaped character'
        construct_prefix_byte_length=1
        ;;
    (*'`')
        construct_type='"`"-delimited process substitution'
        construct_prefix_byte_length=1
        ;;
    (*'[[')
        construct_type='non-arithmetic test'
        construct_prefix_byte_length=2
        ;;
    (*'$[')
        construct_type='"$["-prefixed arithmetic substitution'
        construct_prefix_byte_length=2
        ;;
    # The "${" prefixing variable expansions overlaps the "{" prefixing blocks
    # and hence is matched first.
    (*'${')
        construct_type='variable expansion'
        construct_prefix_byte_length=2
        ;;
    # See above.
    (*'{')
        construct_type='block'
        construct_prefix_byte_length=1
        ;;
    # The "$((" prefixing arithmetic substitutions overlaps the "((" prefixing
    # arithmetic tests and hence is matched first.
    (*'$((')
        construct_type='"$(("-prefixed arithmetic substitution'
        construct_prefix_byte_length=3
        ;;
    # The "$((" prefixing arithmetic tests overlaps the "(" prefixing both lists
    # and process forks and hence is matched first.
    (*'((')
        construct_type='arithmetic test'
        construct_prefix_byte_length=2
        ;;
    (*'(')
        # If such construct is prefixed by "=(", such construct is either a
        # macro keyword argument, list assignment, *OR* "=("-prefixed process
        # substitution.
        if [[ ${code_construct_prefix} == *'=(' ]] {
            # If such "=(" is preceded by an ASCII character complying with
            # variable name syntax, such construct is either a macro argument
            # *OR* list assignment.
            if [[ ${code_construct_prefix[-3]} =~ ${ZESHY__VAR_NAME_CLASS_REST} ]] {
                # If a macro-specific variable name matched, such construct is a
                # macro keyword argument.
                if [[ -n ${match[${ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_VAR_NAME}]-} ]] {
                    construct_type='macro keyword argument'
                    construct_prefix_byte_length=1
                # Else if a zeshy-specific macro argument matched, such
                # construct is a macro nonscalar argument (e.g., list, map).
                } elif [[ -n ${match[${ZESHY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_ZESHY}]-} ]] {
                    construct_type='macro nonscalar argument'
                    construct_prefix_byte_length=1
                # Else, such construct is a list assignment.
                } else {
                    construct_type='list assignment'
                    construct_prefix_byte_length=1
                }
            # Else, such construct is a "=("-prefixed process substitution.
            } else {
                construct_type='"=("-prefixed process substitution'
                construct_prefix_byte_length=2
            }
        # Else, such construct is either a process fork if the first shell word
        # of such command *OR* a list in a complex command or passed to a macro.
        # Since disambiguating such cases is effectively infeasible, such
        # construct is ambiguously stated to be of either type.
        } else {
            construct_type='list or process fork'
            construct_prefix_byte_length=1
        }
        ;;
    (*(#b)(['$<>'])'(')
        construct_type='"'${match[1]}'"-prefixed process substitution'
        construct_prefix_byte_length=2
        ;;

    #FIXME: For disambiguity in exception messages, unsupported here-documents
    #(i.e., here-documents with non-literal delimiters) should be differentiated
    #from syntactically invalid here-documents: the former are *NOT* invalid in
    #general-purpose zsh code, merely unsupported in zeshy code.  Happily, doing
    #so should be more or less trivial. In fact, we've already done so; see
    #${ZESHY__MACRO_HERE_DOC_UNSUPPORTED_PCRE}. Yay!
    (*'<<')
        construct_type='here-document'
        construct_prefix_byte_length=2;;

    # Else, such construct was unidentifiable. Throw a general-purpose exception
    # located at the start of the current match in such code.
    (*)
        ::code.preprocess.die_at_byte\
            'syntax (of unknown type) invalid'\
            ${ZESHY__PREPROCESS_CODE_MATCH_CURRENT_BYTE_FIRST}
    }

    # Suffix such type by an adjective describing such failure (albeit weakly).
    construct_type+=' invalid'

    # If such construct's prefix is non-positive, throw an exception.
    (( construct_prefix_byte_length > 0 )) ||
        ::code.preprocess.die_at_byte\
            ${construct_type}' with '\
            ${ZESHY__PREPROCESS_CODE_MATCH_CURRENT_BYTE_FIRST}

    # Throw such exception detailing a fatal error beginning at the byte index
    # of the current match offset negatively offset by the byte length of the
    # prefix prefixing the erroneous syntactic construct.
    ::code.preprocess.die_at_byte ${construct_type} $((
        ZESHY__PREPROCESS_CODE_MATCH_CURRENT_BYTE_FIRST -
        construct_prefix_byte_length
    ))
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Rename "::code.preprocess" to "::preprocessor" everywhere.

        # If a variable assignment-specific name matched, such construct *MUST*
        # be a list assignment. In such case, the byte length of all characters
        # prefixng the current byte in such assignment is given by summing:
        #
        # * The byte length of such assignment's variable name.
        # * The byte length of optional whitespace delimiting such assignment's
        #   operator.
        # * The byte length of such assignment's operator, either:
        #   * 1 if such operator is "=".
        #   * 2 if such operator is "+=".
        # * 1, the byte length of such prefixing "(".
        #
        # While non-trivial, such calculation is simple enough to warrant doing.
        # if [[ -n ${match[${ZESHY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_OPERATOR}]-} ]] {
        #     construct_type='list assignment'
        #     construct_prefix_byte_length=$((
        #         ${#match[${ZESHY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_VAR_NAME}]} +
        #         ${#match[${ZESHY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_VAR_NAME_SPACES}]} +
        #         ${#match[${ZESHY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_OPERATOR}]} +
        #         ${#match[${ZESHY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_OPERATOR_SPACES}]} +
        #         1
        #     ));;
        # # Else, such construct *MUST* be a process fork.
        # } else {
        #     construct_type='process fork'
        #     construct_prefix_byte_length=1;;
        # }

    # The "=(" prefixing list assignments overlaps the "=(" prefixing such
    # process substitutions and hence is matched first.
        # of: determining the first byte of such
        # assignment requires subtracting the current byte index by:
    # The "=(" prefixing list assignments overlaps the "=(" prefixing such
    # process substitutions and hence is matched first.
    # (${~ZESHY__VAR_NAME_CLASS_REST}'=(')
    #     construct_type='list assignment'
    #     construct_prefix_byte_length=2;;

# :void ::code.preprocess.die_of_pcre_invalid()
#
# Throw an exception indicating a critical design flaw in
# ${ZESHY__PREPROCESS_PCRE}, preventing such PCRE from matching at the prior
# match position. This private exception handler is intended to be called _only_
# by ::code.preprocess().

#FUXME: Excise.
# function ::code.preprocess.die_of_pcre_invalid() {
#     # Validate sanity.
#     (( ! # )) || :die 'Expected no arguments.'
#
#     # Throw such exception. Since this function is called only when pcre_match()
#     # reports failure *AND* since such failure prevents the current call to such
#     # function from overwriting the value of ${ZPCRE_OP} set by the prior call,
#     # state such exception to occur at the last byte matched by the prior call.
#     # For safety, expand ${ZPCRE_OP}
#     ::code.preprocess.die_at_byte\
#         'unmatchable by preprocessor PCRE' ${ZPCRE_OP[(w)2]}
# }

    # Index of the first byte of the current match and hence of the character
    # immediately following such construct's syntactic prefix. Since the
    # calculation deriving ${ZESHY__PREPROCESS_SUBCODE_MACRO_BYTE_FIRST} assumed
    # the character preceding the current match to be unibyte *AND* since  
    # integer code_construct_sans_prefix_byte_first=$((
    #     ZESHY__PREPROCESS_CODE_BYTE_LENGTH - ${#MATCH} ))
    # integer code_construct_prefix_byte_first=$((
    #     code_construct_sans_prefix_byte_first - 3 ))
    # integer code_construct_prefix_byte_last=$((
    #     code_construct_sans_prefix_byte_first - 1 ))

#  consisting of such construct
    # excluding such construct's syntactic prefix.
    # # List of all lines in the substring of such code up to and including the
    # # first byte of such error.
    # local -a code_lines
    #
    # # List of all lines in the substring of such code up to and including the
    # # first byte of such error. The prior approach provides the index of the
    # # first byte of the line containing such error but *NOT* such line number,
    # # requiring the current approach. See set_list_to_string_lines().
    # code_lines=( "${(@f)ZESHY__PREPROCESS_CODE[1,${error_byte_first}]}" )
    #
    # # Line number of the line containing such error.
    # error_line_number=${#code_lines}

# :void ::code.preprocess.die_of_pcre_bug()
#
# Throw an exception indicating a critical design flaw in
# ${ZESHY__PREPROCESS_PCRE}, preventing such PCRE from matching at the prior
# match position. This private exception handler is intended to be called _only_
# by ::code.preprocess().
# function ::code.preprocess.die_of_pcre_bug() {
#     (( ! # )) || :die 'Expected no arguments.'
#     ::code.preprocess.die_at_byte\
#         'unmatchable by preprocessor PCRE'\
#         ${ZESHY__PREPROCESS_SUBCODE_MATCH_PRIOR_BYTE_LAST}
# }

    # case ${ZESHY__PREPROCESS_CODE[$((
    #     ZESHY__PREPROCESS_CODE_MATCH_CURRENT_BYTE_FIRST - 3 )),$((
    #     ZESHY__PREPROCESS_CODE_MATCH_CURRENT_BYTE_FIRST - 1 ))]} {
    #FUXME: Detect all remaining syntactic construct types.
    #FUXME: For legibility, we should actually grep backward for the first non-
    #variable character preceding "=(". Not terribly difficult.

    #FUXME: Suffix ${exception_prefix} by such line number programmatically
    #derived by grepping the substring of
    #${ZESHY__PREPROCESS_CODE[1,${error_byte_first}]} for the number of newlines
    #in such code. Since we implement such functionality elsewhere
    #(+{func/die}, possibly?), deposit such logic here.
    #FUXME: Once such line number is determined, subtract ${error_byte_first}
    #from the byte index of such line to determine the relative byte index of
    #the character within such line responsible for such error. (Trivial.)
    #Having calculated that, we should print a higher-level language-style arrow
    #above the printed line containing such error visually showing the erroneous
    #character: e.g.,
    #
    #    ---------------,
    #                   v
    #    :string.output "undelimited string: uh oh!
    #
    #...or its alternate:
    #
    #    :string.output "undelimited string: uh oh!
    #                   ^
    #    ---------------|
    #FUXME: Initialize ${exception_suffix} to the contents of such line. (While
    #preceding and subsequent context should at some point also be printed, that
    #exceeds our mandate at the moment.)

#6-1=5+1=6
#
#123456
#<-a->z

#byte '${error_byte_first}',
    # Index of the first byte of such construct relative to the first byte of
    # such line.
    # error_line_error_byte_first=

    # Technically, such line is more efficiently and conveniently obtained via
    # the following approach:
    #
    #     local -a code_lines
    #     code_lines=( "${(@f)ZESHY__PREPROCESS_CODE[1,${error_byte_first}]}" )
    #     error_line=${code_lines[-1]}
    #
    # Unfortunately, such approach provides no means of obtaining the index of
    # the first byte of such line in such code. In such case, the passed index
    # of the first byte of such error would *NOT* be correlatable to such line,
    # rendering such passed index functionally useless. While considerably more
    # verbose, the current approach has the benefit of obtaining both such line
    # *AND* the index of its first byte.

    # Line containing such error. Dismantled, this is:
    #
    # * "%%", removing the longest matching string and hence all lines of the
    #   substring of such code following such line including prefixing newlines.
    # error_line=${ZESHY__PREPROCESS_CODE[${error_line_byte_first},-1]%%$'\n'*}

    # Line containing the first byte of such construct. See
    # set_list_to_string_lines().
    # code_lines=( "${(@f)ZESHY__PREPROCESS_CODE[1,${error_byte_first}]}" )
    # error_line=${code_lines[-1]}

        # error_line_byte_last\
    # Index of the last byte of the line containing such error. Dismantled, this
    # is:
    #
    # * "%%", removing the longest matching string and hence all lines of the
    #   substring of such code following the line containing such error
    #   including prefixing newlines. Since the 
    # error_line_byte_last=$((
    #     error_line_byte_first +
    #     ${#ZESHY__PREPROCESS_CODE[${error_line_byte_first},-1]%%$'\n'*}
    # ))

    # error_line_byte_first=${ZESHY__PREPROCESS_CODE[1,${error_byte_first}]##*($'\n'|)}
    # Human-readable name of the type of such construct, defaulting
    # to a non-fatal warning message in the event that we
    # (erroneously) fail to detect such type below.
    # local construct_type='syntax of unknown type'

# byte index
    # of the current match offset negatively offset by the byte length of the
    # prefix prefixing the erroneous syntactic construct.

    # Number of bytes the first byte of such construct is offset
    # from the first byte matched by such match attempt, defaulting
    # to 0 but typically redefined to either -1 or -2 below.

                #FUXME: For readibility, externalize such logic to a separate
                #exception handler.
#first first responsible for
#    such error (i.e., the line number at which such error ).
