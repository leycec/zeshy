#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Compile PCREs in an optimized manner avoiding unnecessary recompilation.

# ....................{ GLOBALS                            }....................
# Most recently compiled PCRE, as passed to (and internally cached by) the
# most recent call to :pcre_compile(). For efficiency, such function avoids
# recompiling already compiled PCREs by only compiling PCREs differing from
# this global.
#
# Builtin pcre_compile() defined by module `zsh/pcre` permits only a single
# PCRE to be compiled at a time and hence implements a singleton PCRE cache.
# However, such module provides no comparable means of determining whether
# previously compiled PCREs are still compiled (and hence do _not_ require
# recompilation) or have since been supplanted in such cache by newly compiled
# PCREs (and hence require recompilation). Given the expense of recompiling
# PCREs, this is a mildly unfortunate oversight. This global amends that.
typeset -g ZY__PCRE_COMPILED_LAST

# ....................{ EXCEPTIONS                         }....................
# :void ::pcre.compile.die(:str pcre)
#
# Throw an exception describing a fatal syntax error in the passed PCRE.
function ::pcre.compile.die() {
    (( # == 1 )) || :die 'Expected one PCRE.'
    local pcre=${1}

    # Exception message to be thrown.
    local message='PCRE syntax invalid'

    # If PCREs are debuggable on the current system, append a detailed trace of
    # the compilation process followed by the reason for such error.
    if { :pcre.is_debuggable } {
        message+=':'$'\n\n'$(:pcre.debug "${pcre}" '')
    # Else, only append the reason for such error. Specifically:
    #
    # 1. Attempt to compile this PCRE with the pcre_compile() function,
    #    redirecting stderr to stdout to facilitate capturing.
    # 2. Capture the error output by such function.
    # 3. Remove all output preceding and including "error in regex: ".
    } else {
        local pcre_compile_error
        pcre_compile_error=$(pcre_compile -- "${pcre}" 2>&1)
        message+='(i.e., '${pcre_compile_error##*: error in regex: }'):'$'\n\n'${pcre}
    }

    # Throw such message.
    :die "${message}"
}

# ....................{ COMPILER                           }....................
# :void :pcre.compile(:str pcre)
#
# Compile the passed *Perl-compatible regular expression* (PCRE) in an optimized
# manner if differing from the most recently compiled PCRE (i.e., the PCRE
# passed to the most recent call to this function) or report success immediately
# otherwise. Hence, if the passed PCRE has already been compiled by a prior call
# to this function, such PCRE will only be recompiled if another PCRE has been
# compiled over the passed PCRE by a more recent call to this function.
function :pcre.compile() {
    (( # == 1 )) || :die 'Expected one PCRE.'
    local pcre=${1}
    
    # If such PCRE is the empty string, throw an exception. Such PCRE
    # successfully matches *ALL* input and hence is semantically useless.
    # Moreover, such PCRE induces infinite loops on iterative matching and hence
    # constitutes a fatal error, which is less than semantically useless.
    (( ${#pcre} )) || :die 'PCRE empty.'

    # If such PCRE has yet to be compiled *OR* was compiled but has since
    # been replaced in the internal cache by a more recently compiled PCRE,
    # (re)compile such PCRE in an optimized manner.
    if [[ ${ZY__PCRE_COMPILED_LAST} != ${pcre} ]] {
        # Silently compile this PCRE. If compilation fails, throw an exception
        # containing the syntax error such compilation would have printed.
        pcre_compile -- "${pcre}" 2>/dev/null || ::pcre.compile.die "${pcre}"
        pcre_study

        # Avoid unnecessary recompilation on subsequent iterations.
        ZY__PCRE_COMPILED_LAST=${pcre}
    }
}

# --------------------( WASTELANDS                         )--------------------
    # message+=${${:-$(pcre_compile -- "${pcre}" 2>&1)}//error\ in}
    # message+=${${:-$(pcre_compile -- "${pcre}" 2>&1)}##*: error in regex: }
# . If compilation fails, throw an
        # exception containing the fatal error such compilation output *AND* an
        # optional debug trace of such compilation.

# :void :pcre.compile(:str/:yumo.is_nonempty pcre)
# :void :pcre.compile(:str/:func+nonempty pcre)

    #FUXME: *UGH*. For efficiency, we *REALLY* need to reenable the following
    #code. Unfortunately, so long as the codebase contains a single raw
    #low-level call to pcre_compile(), we basically can't. Find and replace all
    #such calls by calls to this function instead.

#FUXME: Define :pcre.compile() and :pcre.compile,set_state() as documented
#below. Specifically:
#
#* :pcre.compile() accepts a single PCRE. Do *NOT* bother accepting optional
#  pcre_compile() arguments, as all such arguments are better embedded directly
#  in such PCRE. Such function should internally:
#  * Test whether such PCRE equals ${ZY__PCRE_COMPILED_LAST}. If so, such
#    function should report success immediately; else, such function should:
#    * Call pcre_compile().
#    * Call pcre_study().
#    * Set ZY__PCRE_COMPILED_LAST to such string only *AFTER* successfully
#      compiling and optimizing such PCRE.
#
#Lovely simple.
#FUXME: Actually, there exists a demonstrably simpler and hence significantly
#better way. :pcre.compile() should simply cache the exact PCRE passed to such
#function to . On a subsequent call to  
