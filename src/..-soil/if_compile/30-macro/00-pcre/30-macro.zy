#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2018 by Cecil Curry.
# See "LICENSE" for additional details.

#FIXME: Convert into parcel documentation.
# --------------------( SYNOPSIS                           )--------------------
# Define PCREs specific to macro preprocessing.

#FIXME: I'm wondering if I wasn't a special brand of insanity when I squandered
#several months of my life attempting to implement this. After all, what's it
#all for? The only purpose to this now appears to be matching "{"- and "}"-
#delimited code blocks passed to macros. Is that correct? If so, *ALL* we had
#to friggin' do was stipulate that all code blocks passed to macros be
#uniquely delimited by "{{" and "}}" instead: e.g.,
#
#   @for :str list_item ("${list_items[@]}") {{
#       :stdout.echo "${list_item}"
#   }}
#
#*THAT'S IT.* Parsing this safely reduces to:
#
#* Splitting the contents of each line following a "@"-prefixed macro name
#  using zsh shell word splitting (i.e., "(z)") into a list of such words.
#* Searching each such list until the next "{{" shell word is found.
#* Repeating this process until the next "}}" shell word is found.
#* The result are all lines and shell words comprising each block argument
#  passed to a macro.
#
#The beautiful thing about using "{{" and "}}" is that such code is valid zsh.
#This contrasts with "{{{" and "}}}", which does *NOT* appear to produce valid
#zsh: e.g.,
#
#    $$$ {{ print ok }}
#    ok
#    $$$ {{{ print ok }}}
#    cursh cursh>
#
#I will be mightily displeased if the entirety of this parcel turns out to be a
#wash, but... at the moment, it's certainly looking that way.  Why. Why did I
#do this.
#FIXME: Oh. Wait. No, that's not *QUITE* right, as macros can be nested, thus
#requiring context-free (i.e., stack-based) parsing of "{{" and "}}"
#delimiters as nested pairs. That's still fairly trivial, we should imagine.
#Or... not, actually. The issue is: which macro do you associate a "{{"- and
#"}}"-delimited code block with? The nested macro or the outer macro?
#Specifically, how do you know when to stop parsing code blocks passed to an
#inner macro and start parsing code blocks passed to the outer macro? How do
#you know where the inner macro ends and the outer macro starts again without
#parsing zsh code? We may need the insanity below after all.
#
#Ah. We solved this already for general-purpose macro code blocks somewhere, we
#believe -- didn't we? Wasn't our idea to parse zeshy scripts in reverse line
#order, or something? It all sounds a bit outlandish now, frankly. *sigh*

#FIXME: O.K.; I appear to have overshot the moon when I tried to reuse the
#same ":"-prefixed namespace for macro, function, and alias names in the vain
#hope that doing so would permit the user to not have to care about the fine
#differences between these three sorts of callables. Let's be plainly honest:
#*THAT'S NOT GOING TO WORK*.
#
#The reason why is simple: scalability. By prefixing macros with ":", the PCRE
#generated below has no means of differentiating macros from functions or
#aliases except by explicitly matching all known macro names in command
#position. *WHAT THE BLOODY HECK WERE WE THINKING?* The current approach
#requires:
#
#* Regenerating and recompiling this PCRE on each new macro declaration and
#  undeclaration.
#* More importantly, embedding all known macro names in this PCRE.
#
#Just consider the number of possible macro names we'll probably eventually
#end up with. Given how useful macros will be, it will (probably) eventually
#be an astronomically large number. Given how the PCRE behaves, we can't adopt
#the alternative of context-switching to zsh code to programmatically test
#whether each ":"-prefixed callable in command position is a known macro name
#or not. (Why not? Because doing so loses PCRE context. Hence, screwed.)
#
#The only alternative is to prefix macros by a unique signifier *NOT* already
#reserved for low-level zsh syntax. Frankly, there aren't terribly many
#available signifiers left. We're probably down to "+", "@", "%", and ",".
#That's it. Of those, "+" and "%" are used in common zsh arithmetic and
#expansion syntax, however, and should probably be out. That leaves "@" and
#",". Since "," is exceptionally awkward as a prefix, we're left with "@".
#
#*WE ARE DELIGHTED.* "@" is a great prefix. While it also has significance in
#zsh list and map syntax, so does ",". Can't get away from that. Intuitively,
#this is absolutely the way to go forward.
#
#In synopsis:
#
#* All macro names *MUST* be prefixed by "@" and matched as such below.
#* Eliminate both the ${ZY__MACRO_NAMES_SEMICOLON_PREFIXED} and
#  ${ZY__MACRO_NAMES_SEMICOLON_UNPREFIXED} list globals and all code
#  leveraging those globals.
#
#This is absolutely essential, folks.

#FIXME: In theory, the above syntactic simplification *COULD* allow us to
#simplify the PCRE below even further. How? By matching macros globally (i.e.,
#in any shell word position) rather than merely in command position. Since
#"@"-prefixed words should be exceedingly rare in real-world zsh code, it's
#reasonably safe to assume all such words to be zeshy-specific macros. Given
#that, it's unclear whether there's any benefit to constraining macro matching
#to just command position. What's the point, you know? We'd might as well go
#the distance and match them everywhere.
#
#It's certainly worth considering, anyway. We currently go to excrutiating
#lengths to match macros only in command position. Matching globally would
#profitably eliminate a good deal of the PCRE below. That said, we'd still
#need to:
#
#* Match macro scalar arguments.
#* Match "{"- and "}"-delimited macro block arguments.
#* Match "("- and ")"-delimited macro list and map arguments. (Maybe? It's
#  currently unclear how critical such arguments are.)
#* Match the end of a macro.
#* Match arbitrary shell words.
#
#The latter will be the hardest part. In theory, we *COULD* offload such
#parsing to zsh ala:
#
#      :list shell_words; shell_words=( "${(z)input_code}" )
#
#Scanning for macros then reduces to searching such list for "@"-prefixed
#strings. Of course, there are a few difficulties with that approach:
#
#* That approach converts newlines to semicolons *AND* discards comments,
#  seemingly preventing us from associating lines of unpreprocessed input code
#  with lines of preprocessed output code to help decipher syntactic errors
#  emitted by the zsh parser. That's not just bad; *THAT'S A DEAL BREAKER.*
#  Unless we can circumvent this, the above "(z)" approach is right out. That
#  said, note that:
#  * Comments are preservable by using "(Z~c~)" instead if we recall right.
#    So, perhaps we still would be able to perform such mapping by suffixing
#    each input line with a comment containing that line's line number *BEFORE*
#    performing such splitting.
#* Once we've found such macro, what do we do with it? We'd *STILL* need to
#  match "{"- and "}"-delimited macro block arguments and find the end of that
#  macro. The most efficient way to do both might be to go back to the
#  original input code and parse that instead. Assuming we use the above
#  "(Z~c~)" approach, we should be able to retrieve the currently matched
#  macro's original line number and then parse that.
#
#*UGH.* Would it be simpler to parse shell words ourselves? Hmmmm.... Right.
#Probably not. Attempting to do that execrable chore is what got us into the
#heap of trouble that happened below. We *REALLY* do not want to go back there.
#Shell word parsing is highly non-trivial. Hmmmm... that said, is it, really?
#Our purposes our rather simple. We don't particularly care about context.
#We *HAVE* already specced out most of the language, below. Perhaps we can
#reuse some of that hard work to parse shell words in a context-neutral manner.
#Of course, what constitutes a shell word *DOES* change with context. But maybe
#we can ignore most or all such changes for simplicity and still get a
#reasonably stable parser up and running? Consider it. If all else fails, the
#"(Z~c~)" approach should certainly work.
#
#Here's an instructive edge-case example to help us decide which of these two
#approaches is more appropriate:
#
#    "${foo//$(@bar bell) @bar bell}"
#
#Simple, right? *WRONG.* We want to parse the inner "@bar bell" in "$(@bar
#bell)" as a macro but *NOT* the outer "@bar bell" in the variable expansion.
#We're not entirely convinced that the "(Z~c~)" approach will support such
#fine-grained parsing. Doesn't such flag parse the input into coarse-grained
#shell words, in which the entire "${foo...}" variable expansion would be
#parsed as a single word -- right?
#
#But that's *NOT* what we want. We want to be able to parse where the start of
#each word is so that we can match a "@" there. To do that, we clearly need to
#be able to pass word terminators: e.g., "||", "&&", ";", newline, "$(", and
#so on. We already do that, so we're golden. Right. That pretty much settles
#it then. We'll be parsing this ourselves, leveraging work already performed
#below. Thankfully, we'll no longer need to recursively parse syntactic
#embeddings. (Praise be to the mournful goddess.) We'll only need to parse
#word terminators in a context-less manner, thus ignoring such finer syntactic
#points such as list context and so on.
#
#Oh, wait. How do we avoid parsing the outer "@bar bell" in the variable
#expansion? *UGH.* Pretty much no way to do that without preserving syntactic
#context across PCRE match attempts -- which, of course, we cannot do. Let's
#see what "(Z~c~)" does with the above edge-case, shall we?
#
#Oh, Gods. You know, we just had a totally crazy thought. It's utterly insane,
#but... what if, for each macro "@muh_macro" we defined a corresponding global
#alias "@muh_macro"? Given such aliases, we could then have zsh expand such
#aliases embedding the input code in a dynamically defined function and
#examining such function's body after definition. Hmm; we're pretty sure that
#discards comments, however, preventing us from correlating the output to the
#input. Anyway, the idea was that we could then just perform a simple diff of
#the output and the input to efficiently find all the places where we should
#perform macro expansions. Yeah; yeah. Pretty crazy, we know. [Verified: yes,
#comments are discarded. That's right out, then. Probably for the best.]
#
#Aww, yah. Nailed it. See the next FIXME comment for details. Given that, it's
#on with the show we go!
#
#O.K.; that's dramatically simpler. Oh, and there's one final benefit to
#matching macros globally -- and it's a real biggy:
#
#* Syntactic context no longer matters, implying that macros could be matched
#  within embedded syntax (e.g., process substitutions) *TO INFINITE DEPTH*.
#
#Yeah. Massive, eh? The current approach is constrained to matching macros
#within embedded syntax (e.g., process substitutions) to... well, we can't
#quite remember, but it's either to only one level of depth or maybe not at
#all. In either case, that's extremely shoddy, and will require quite a bit of
#ugly hand-waving in FAQ entries and such. Not to mention the inevitable
#headaches caused to users (...and myself!) that inevitably forget.
#
#That's obviously shameful. Any alternative circumventing such shoddiness
#should absolutely be contemplated. This is that alternative. (Also, the
#resulting PCRE will be *CONSIDERABLY* easier to debug. It may not actually be
#feasible to ever fully debug the PCRE below. Well, not in my gladspun
#lifespan, anyway.)
#
#Nordic God(s) be praised, but what *WAS* I thinking? I really needed to give
#the current approach to macro syntax a second thought a year or two earlier.
#Instead, I just gritted my teeth and soldiered on -- squandering at least a
#month, if not more, on a fundamentally flawed PCRE design. I'll happily
#admit: I'm fairly frustrated with myself at the moment. Here's hoping that
#future design improvements will come faster, earlier, and more blatantly.
#FIXME: Oh. Oh. Oh. We finally glommed it: an efficient, reasonably simple
#mechanism for reliably "parsing" zsh with zsh itself. Specifically, we use zsh
#to differentiate "@"-prefixed macro-like strings that should be expanded as
#macros from "@"-prefixed macro-like strings that should *NOT* be expanded as
#macros. As we now know, this is a highly non-trivial problem -- sufficiently
#non-trivial, in fact, that we basically cannot do it without a real parser.
#Enter zsh.
#
#The approach outlined below leverages zsh's parsing of command and word macros
#to discover macros at command and word positions in input unpreprocessed code.
#That's all we leverage such parsing for. Our PCRE picks up the remainder of
#the parser slack by parsing macro arguments -- which is also highly non-
#trivial but at least generally feasible, unlike macro detection.
#
#Because this approach leverages both command and word aliases, there now exist
#exactly two and only two types of macros:
#
#* "@"-prefixed command macros, matched only at command position.
#* "@"-prefixed word macros, matched at any shell word position.
#
#That's it. We *NEED* to use low-level zsh aliases for reasons that will
#become subsequently clear and hence have little alternative but to confine
#macro types to the same categories as alias types.
#
#For simplicity, we consider only the case of parsing command macros. Parsing
#word macros is, of course, exactly the same; merely substitute "command" for
#"word." Here's the general algorithmic idea for parsing command macros:
#
#* Create a new PCRE halting matching at each "@"-prefixed macro-like
#  substring of a subject string. This PCRE should *NOT* actually attempt to
#  parse zsh syntax. All it should do is match arbitrary characters preceding
#  a "@"-prefixed macro-like substring and capture the first "@"-prefixed
#  word of such substring. To do so efficiently, note that command macros:
#  * Are matched only at command position and hence *MUST* be prefixed by
#    either a command terminator or the string start (e.g.,
#    "(?>[\n|&({;]|\A)").
#  * Are prefixed by a "@" followed by a character *NOT* already reserved by
#    core zsh syntax. Using a negative character class here allows us to
#    transparently support macro names whose first character is non-ASCII,
#    which is quite essential.
#  This gives a PCRE fragment for matching macro-like substrings resembling:
#      (?>[\n|&({;]|\A)(@[^'"=!#$&|*?()[]{}<>\\;`])
#  We'll need to closely scrutinize and refine that, but it shouldn't be
#  *TOO* far off. The jist is there, anyway.
#* Create a ${ZY__MACROS_MATCHED} list global, initialized to the empty
#  list. This list will contain the names of all "@"-prefixed command macro-
#  like words matched for the current input code.
#* Create a ${ZY__MACRO_PREALIASED} string global, initialized to the
#  contents of the current unpreprocessed input code. This global is used
#  *ONLY* for purposes of differentiating macros from non-macros.
#* Create a ${ZY__MACRO_POSTALIASED} string global, initialized to the
#  empty string. This global is used *ONLY* for purposes of differentiating
#  macros from non-macros.
#* Iteratively match each "@"-prefixed command macro-like word of the input
#  code using the typical pcre_compile(), pcre_study(), pcre_match()-via-
#  ${ZPCRE_OP}-in-a-while-loop approach. For each matching word:
#  * If such word is the name of an existing command macro:
#    * Define a temporary command alias of the name
#      "@@${line_number},${line_at_number},${macro_name}" whose alias
#      expansion is a single newline, where ${line_number} is the line number
#      on which this macro was matched, ${line_at_number} is the number of
#      other "@"-prefixed command macro-like words matched on the same line,
#      and ${macro_name} is this macro's original name sans "@" prefix. For
#      example, if the second "@foo" macro is matched from line 57 of the input
#      code, the following command alias would be created:
#          ${aliases[@@57,2,foo]=$'\n'
#      In theory, expanding to a newline should help preserve syntactic
#      correctness -- even for oddball input. (We'll probably want to consider
#      that a bit more deeply, of course.)
#    * Append the string "@@${line_number},${line_at_number},${macro_name}" to
#      ${ZY__MACROS_MATCHED}.
#    * Replace the currently matched macro's name in
#      ${ZY__MACRO_PREALIASED} with
#      "@@${line_number},${line_at_number},${macro_name}". For example, when
#      the second "@foo" macro is matched from line 57 of the input code:
#
#          # This is the original matched line 57.
#          "${bar$(@foo)// @foo}"
#
#          # This is its replacement line in ${ZY__MACRO_PREALIASED} after
#          # processing both of the above "@foo" instances.
#          "${bar$(@@57,1,foo)// @@57,2,foo}"
#* Dynamically define a new function ::func.postaliased() equal to the value of
#  ${ZY__MACRO_PREALIASED}: e.g.,
#      functions[::func.postaliased]=${ZY__MACRO_PREALIASED}
#  Naturally, we'll need to handle detection of syntactic errors and such. See
#  the existing :func.define() function for similar logic.
#* Due to zsh magic, the body of ::func.postaliased() now contains only
#  "@"-prefixed command macro-like words that are *NOT* in command position.
#  "@"-prefixed command macro-like words in command position have all been
#  replaced by their alias expansion -- namely, a single newline.
#* Undefine all command aliases temporarily defined above: e.g.,
#      unalias -- "${ZY__MACROS_MATCHED[@]}"
#* Create a ${ZY__MACRO_NAMES_UNALIASED} list global, initialized to the
#  empty list. This list will contain all substrings of the form
#  "@@${line_number},${line_at_number},${macro_name}" matched from
#  ${functions[::func.postaliased]}, thus describing all
#  "@"-prefixed command macro-like words that are *NOT* in command position
#  and hence ignorable. All other macro-like words are non-ignorable.
#* Iteratively match each substring of the form
#  "@@${line_number},${line_at_number},${macro_name}" from
#  ${functions[::func.postaliased]} using the typical pcre_compile(),
#  pcre_study(), pcre_match()-via-${ZPCRE_OP}-in-a-while-loop approach. For
#  each matching word:
#  * For each such match, append such match to ${ZY__MACROS_UNALIASED}.
#* Create a ${ZY__MACROS_ALIASED} list global, initialized to the list
#  difference of the ${ZY__MACROS_MATCHED} list minus the
#  ${ZY__MACRO_NAMES_UNALIASED} list. This list now contains all substrings
#  of the form "@@${line_number},${line_at_number},${macro_name}" expanded to
#  newlines in ${functions[::func.postaliased]}, thus describing all
#  "@"-prefixed command macro-like words that are in command position and hence
#  non-ignorable.
#* For each list item of ${ZY__MACROS_ALIASED} sorted in *REVERSE ORDER*
#  (to preserve previously recorded line numbers across macro expansions), find
#  and expand the corresponding macro in the *ORIGINAL* unpreprocessed and
#  still unmodified input code.
#
#Voila! Pretty trivial, actually. It's a bit more complicated than it seems,
#and can probably be significantly optimized from the above cursory outline.
#But, roughly speaking, that should do it. True awesomeness in comment form.
#FIXME: You might notice that, in the above discussion, we contemplate
#recompiling at least three PCREs for each input code to be preprocessed.
#Since the first two PCREs appear to be trivially small, recompiling these
#PCREs is (probably) no hardship. The latter PCRE, however, matches "{"- and
#"}"-delimited macro block arguments in a context-free manner and hence is
#unfathomably large; recompiling this PCRE for each input code is a terrible
#idea. The question then remains: can we do anything?
#
#*YES.* Yes, we can. It's actually quite simple, clever, and kludgy. The
#solution is to aggregate the three PCREs discussed above into a single
#composite PCRE constructed like so:
#
#    ZY__SUBPCRE_1='...'
#    ZY__SUBPCRE_2='...'
#    ZY__SUBPCRE_3='...'
#    ZY__PCRE='(?>a'${ZY__SUBPCRE_1}'|b'${ZY__SUBPCRE_2}'|c'${ZY__SUBPCRE_3}')'
#
#Super clever, yo. (Reasonably clever, anyway.)
#
#The subject string passed to each call to pcre_match() must then be prepended
#by a gating prefix: "a" to select the first PCRE, "b" the second, and "c" the
#third. Since matching a single literal character is trivially fast, this
#should impose no measurable costs while entirely preventing recompilation.
#Extreme shell scripting optimization for the win. "What is this: the Finnish
#64Kb demoscene!?"
#FIXME: Final note: the above alias-based approach works great for detecting
#macro positions everywhere *EXCEPT* in process substitutions: e.g.,
#
#    $$$ alias -g yamyam='print ok'
#    $$$ function yimo() { yamyam; (yamyam); print $(yamyam); print >(yamyam)}
#    $$$ print $functions[yimo]
#    ^^^ print ok
#    ^^^ (
#    ^^^    print ok
#    ^^^ )
#    ^^^ print $(yamyam)
#    ^^^ print >(yamyam)
#
#Note that subshells are process properly, whereas process substitutions are
#not. That mildly sucks. Given how infrequently the zeshy codebase leverages
#process substitutions, however, it could be worse. Also note that even this
#may be reliably worked around, although doing isn't exactly non-trivial and
#would thus best be left for a subsequent iteration of macro preprocessing
#functionality.
#
#The idea is fairly simple:
#
#1. Linearly, non-recursively parse the code for all process substitutions,
#   ignoring single-quoted strings and equivalent syntactic constructs (e.g.,
#   single-quoted heredoc strings). It's quite O.K. if we aren't reliably able
#   to do so for all possible syntactic edge cases; we only want to hit the
#   common cases, at least initially. The non-recursiveness part is essential;
#   if we attempt to parse recursively, then we have no means of maintaining
#   syntactic state. This means, sadly, that we probably also have to ignore
#   process substitutions embedded in double quotes. *collective shrug*
#2. For each matched process substitution, perform macro substitution over the
#   body of that process substitution.
#
#However, at this point, the natural question might arise: why not simply
#implement a proper recursive descent parser? It wouldn't be trivial and it
#wouldn't be fast, but it would be guaranteed to work. Good luck doing so
#without access to proper nestable structures, however. And at that point,
#we'd might as well simply reimplement zeshy in an appropriate host language
#(e.g., D, Rust).
#
#In fact, that argument probably holds for the entirety of this improvement.
#Do we *REALLY* want to go there just for process substitutions whose bodies
#directly containing macros can just as readily be replaced by calls to
#function whose bodies directly contain those macros? We think: maybe not.
#
#The only alternative to the above approach would be:
#
#1. Requiring that macros embedded in process substitutions be prefixed or
#   suffixed by additional unique delimiters hopefully avoiding conflict with
#   substrings already matching such syntax elsewhere. For simplicity, assume
#   suffixed by an additional "@" delimiter.
#2. Lexically preprocessing *ALL* macro-like substrings with some brute-force
#   regular expression -- such as "(\b@\S+@\b)" (but obviously accounting for
#   escaped whitespace and boundary delimiters).
#
#This approach has the distinct advantage of working everywhere we want (e.g.,
#in process substitutions), but the distinct disadvantage of working we do
#*NOT* want as well (e.g., in strings). Which is almost worse.
#
#Ultimately, the only reliable approach is the following:
#
#1. Prohibit macros in process substitutions. There's no way around it. Don't
#   bother implementing any of the above approaches. None suffices for the
#   general case. Unresolvable edge cases are unacceptable in general-purpose
#   parsers and preprocessors, so don't go there.
#2. Promise the eventual implementation of a proper "zeshy" parser.

#FIXME: We need a reasonably complete and comprehensive plan for how to
#actually get macro preprocessing to work -- because, let's be miserably
#honest, the prior default gameplan of "just throw a 16KB PCRE at RegexBuddy
#and hope for the best" is *NOT* a sensible path forward. Instead, here goes
#(in order):
#
#* Correct all remaining compilation errors in this parcel. (Non-trivial, but
#  essential.)
#* Correct function prototype handling. (Non-trivial, but essential. We need to
#  be able to compile new zeshy digests for any sort of real-world work.)
#* Correct all remaining FIXME comments in this module. (Optional, but probably
#  a good idea before getting into the nitty-gritty. Or maybe not?)
#* Copy this parcel *EXACTLY AS IS* to @{*-macro/*-pcre/80-temp}.
#* Make a new parcel @{*-macro/*-pcre/90-unit}.
#* In @{*-macro/*-pcre/80-temp}:
#  * Comment out the current definition of
#    ${ZY__PREPROCESS_PCRE_IF_NONEMPTY}.
#  * Redefine such global to strictly match *ONLY* the empty string. Do it. By
#    order of parcel importation, such redefinition is guaranteed to shadow the
#    older definition of this global in this parcel.
#* In @{*-macro/*-pcre/90-unit}:
#  * Define a first unit test (e.g., as a function
#    :test:preprocessor_pcre.matches_string_empty()) validating that
#    ${ZY__PREPROCESS_PCRE_IF_NONEMPTY} (or some equivalent high-level PCRE)
#    matches the empty string.
#  * Define a simple test scaffold running all functions with names matching
#    the glob:
#        ':test:preprocessor_pcre.'*
#* Back in @{*-macro/*-pcre/80-temp}:
#  * Expand the definition of ${ZY__PREPROCESS_PCRE_IF_NONEMPTY} to also
#    match a single comment. Again, just do it.
#* Back in @{*-macro/*-pcre/90-unit}:
#  * Define a second unit test (e.g., as a function
#    :test:preprocessor_pcre.matches_comment()) validating that
#    ${ZY__PREPROCESS_PCRE_IF_NONEMPTY} (or some equivalent high-level PCRE)
#    matches a single comment.
#
#You probably see where we're going with this. Defining unit tests in parallel
#with PCRE definition is essential to validating the correctness of zsh
#preprocessing *AND* to safeguard against regressions. There's pretty much no
#other reasonable way.
#
#After getting each unit test and corresponding PCRE logic to work,
#incrementally exand the definition of such PCRE to encompass another small
#slice of the zsh language -- until, inevitably, @{90-temp} is equivalent in
#scale to @{30-macro} (but hopefully more correct) and our job is done.

#FIXME: On generalizing the passing of macro keyword arguments to conventional
#functions, we've realized that the brute-force approach of attempting to
#explicitly match such arguments there would be both extremely inefficient and
#obtuse. Indeed, if one considers it, the appropriate solution is simply to
#*MIMIC* the capacity for such arguments to be passed by shadowing functions
#"accepting" keyword arguments with a macro of the same name. Each such macro
#should be implemented by a general-purpose low-level function applicable to
#*ALL* such macros -- say, ::func.map_args_keyword(). Such function may then
#simply expand the value of an appropriate public global set by the
#preprocessor -- say, ${ZY_MACRO_NAME} -- to determine which function
#::func.map_args_keyword() should expand to. Indeed,
#::func.map_args_keyword() should perform the following (in order):
#
#* Declare the following string locals:
#  * ${map_name_current}.
#  * ${map_value_current}.
#  * ${macro_foot}.
#* Set ${ZY_MACRO_EXPANSION} to ${ZY_MACRO_NAME}, thus initializing such
#  expansion to the user-defined function to be ultimately called.
#* Perform PCRE-based iterative matching on *ALL* arguments passed to such
#  function in left-to-right order.
#* If the current argument matches keyword syntax (...which, incidentally,
#  should be declared as a string global in +{pcre/macro} for use in
#  ::func.map_args_keyword()), then:
#  * If ${map_name_current} is the empty string, then:
#    * Set ${map_name_current} to a guaranteeably unique variable name in the
#      context of such expansion.
#    * Initialize ${map_name_current} to such keyword's name, one horizontal
#      space, and such keyword's value.
#    * Append ${macro_foot} by a command unsetting such map.
#  * Else:
#    * Append ${map_name_current} by such keyword's name, one horizontal
#      space, and such keyword's value.
#* Else:
#  * If ${map_name_current} is nonempty, then:
#    * Prepend ${ZY_MACRO_EXPANSION} by a declaration of a new temporary
#      map local whose name is ${map_name_current} and whose value is
#      ${map_value_current} delimited by "(" and ")" characters.
#    * Set ${map_name_current} to the empty string.
#  * In either case, append ${ZY_MACRO_EXPANSION} by the value of the
#    current argument.
#* Append ${ZY_MACRO_EXPANSION} by ${macro_foot}.
#
#Rather simple, if somewhat expensive (requiring a *THIRD* rematching of all
#passed arguments). That said, one can hardly expect to enjoy such a juicy
#nugget of high-level joy as keyword arguments in such a dynamic manner as this
#without expending a little CPU time. So: *shrug*
#FIXME: We could conceivably optimize the above approach by having the
#preprocessor rather than a discrete macro perform such logic. Given the
#already intolerable length and complexity of such preprocessor, that isn't
#necessarily the most agreeable approach -- though, it would eliminate the need
#for rematching *ALL* arguments yet again, which is certainly desirable.
#Perhaps the preprocessor could hand off such logic to a private utility
#function defined in the same parcel tree. Right; that sounds saner.
#
#In such case, rather than defining one actual macro for each such function,
#we would simply define a fake macro. Such macro would exist only for purposes
#of recognizing such functions during PCRE-based iteration and hence would have
#*NO* corresponding entry in ${ZY__MACRO_TO_FUNC_NAME}. Naturally, this
#would require a slight rejiggering of +{pcre/pcre} to match such fake macros.
#But that's certainly no issue.
#FIXME: Great. So, that's how we implement such calls. How do we notate
#functions accepting keyword arguments, however? Happily, that's quite simple.
#We currently prohibit functions accepting map arguments. Instead, the
#function parser should support functions accepting either:
#
#* No map arguments (i.e., the current case).
#* One or more map arguments. In such case, a macro of the same name as such
#  function and expanding to ::func.map_args_keyword() should be declared.
#  Interestingly, the above algorithm inherently supports functions accepting
#  two or more arguments. That said, an exception should be thrown if:
#  * Two consecutive map arguments are declared. In such case, the second map
#    will *ALWAYS* be empty and hence meaningless. (Alternatively, perhaps we
#    could simply print a nonfatal warning?)
#
#Let's ignore list and listset arguments for the moment. While it certainly
#would be nice to permit arguments of such type to be passed, keyword arguments
#strike us as the better "bang-for-buck", at the moment.
#FIXME: Hmmm. Everything above probably needs a close rethink. We wrote
#"...we've realized that the brute-force approach of attempting to explicitly
#match such arguments there [in function bodies] would be both extremely
#inefficient and obtuse." We honestly doubt that's the case. Ideally, keyword
#arguments for neither macros nor functions should permit optional whitespace.
#Hence:
#
#    # Prohibit this...
#    :some_func key = value
#
#    # ...in favour of this.
#    :some_func key=value
#
#Notably, that aligns with both Python convention *AND* zsh syntax. Since
#optional whitespace is then prohibited in keyword arguments, parsing such
#arguments trivially reduces to splitting each passed argument on the first "="
#character in such argument -- which, if dim memory serves, should be
#efficiently implementable *WITHOUT* explicit iteration. Look: if we can avoid
#shadowing functions accepting keyword arguments with macros of the same name
#to implement such functionality, then we *REALLY*, *REALLY* should. Nothing
#good is likely to come of shadowing, and there probably exists no demonstrable
#reason to do so anyway.

#FIXME: Implement support for whitespace-delimited variable assignments of both
#scalar and nonscalar types, including in declarations: e.g.,
#
#    # This is the ultimate end goal: a nonscalar variable declaration also
#    # assigning such variable in a whitespace-delimited manner.
#    :list we_can_do_it = ( yes we can )
#
#Naturally, the first iteration of this concept will simply be to permit
#whitespace-delimited scalar variable assignments outside of declarations:
#e.g.,
#
#    # Here's where we start.
#    :str yummy
#    yummy = 'tummy'
#
#Consider the following approach. After attempting but failing to match a
#command macro name in command position of the current command, attempt to
#match a variable name optionally followed by one or more horizontal characters
#optionally interspersed by line continuations (e.g., via
#${pcre_continuable_spaces_horizontal}) optionally followed by an equals sign
#(optionally preceded by a "+" character so as to match both "=" and "+="
#operations, which operate syntactically identically) optionally followed by
#more such whitespace. If all of the prior substrings match, then we have
#positively identified a whitespace-delimited scalar variable assignment; in
#such case, capture *ALL* remaining non-vertical- whitespace characters up to
#the first vertical whitespace character or end-of-string into a new match
#group.
#
#Note that such variable name will probably need to be unconditionally captured
#into a new match group as well, regardless of whether such variable name is
#followed by such an assignment. Since zeshy function names are *NOT* valid
#variable names, the cost of such capturing is largely ignorable. After all,
#pretty much the *ONLY* time a variable name should ever be in command position
#is if it's being assigned to. Oh, and we'll also have to capture such "=" or
#"+=" operator to be able to distinguish the two. At that point, we'd might as
#well go ahead and also capture the delimiting whitespace, permitting us to
#precisely index bytes. (The alternative, of course, would be to apply a
#${pcre_reset} immediately after matching such "=" or "+=" operator and then
#matching *BACKWARDS* from such point -- perhaps with globbing -- to identify
#such operator and preceding variable name. But... yeah, that strikes us as
#unreasonably silly. An excrutiating amount of work, and for what? Just to
#avoid *ONE* otherwise uncaptured group? Just go the fully monty.)
#
#Since variable assignments are arguably more commonplace than macro calls, the
#preprocessor should first check whether such variable assignment match group
#is nonempty; if it is, the preprocessor simply excises any whitespace
#delimiting such assignment operator and... that's it. If such variable
#assignment match group is empty, then the preprocessor checks whether a
#command macro matched (in the conventional way), and off and away we go.
#
#Honestly, this should be *CONSIDERABLY* simpler than the tortuous gyrations we
#went through to match macros.
#FIXME: Wait. We're increasingly inclined to believe that permitting the "="
#assignment operator to be delimited by optional whitespace is a Bad Idea. It's
#not simply that it introduces yet more inefficiency (although there absolutely
#is that). It's principally that:
#
#* For sanity, the "=" assignment operator in function keyword arguments should
#  definitely *NOT* be delimited by optional whitespace. Permitting such
#  whitespace introduces a gamut of inefficiencies and inelegances in the logic
#  parsing such arguments. More importantly, doing so fundamentally contravenes
#  the core shell tenet that each and every shell word following the first of a
#  command is an argument to that command. This is critical. We absolutely must
#  *NOT* break this.
#* For orthogonality with assignments in other contexts, it follows that the
#  "=" assignment operator in such contexts should also *NOT* be delimited by
#  optional whitespace.
#* There exists another reason as well, however. The current PCRE-based
#  approach can only parse to a finite depth of syntactic embedding. Given this
#  core constraint, we *REALLY* want to minimize syntactic differences between
#  zsh and zeshy beyond macros. Macros are essential, so the finite depth issue
#  can be somewhat overlooked there. (For the moment, anyway.) Permitting
#  optional whitespace around "=" assignment operators, however, is most
#  certainly non-essential and hence should be avoided.
#
#This does *NOT* imply, however, that we should immediately rip out all of our
#variable assignment PCREs. Since variable assignment syntax appears to
#slightly conflict with that of conventional zsh syntax, we probably need to
#continue matching the former so as to disambiguate it from the latter.

#FIXME: Implement support for right-brace macros (e.g., :always, :elif, :else).
#After brief consideration, this *SHOULD* be feasible. The sticky point is not
#matching such macros at such position but duplicating the PCRE fragment
#matching macro arguments. Of course, we'll do just that; we have little choice
#and, anyway, only ever compile such PCRE once. Still, due to such duplication,
#we probably want to hold off on this until later.
#
#Matching "}" braces at the top level should be feasible as follows:
#
#* Define a new ${ZY__MACRO_BRACE_RIGHT_NAME_PLACEHOLDER} string global
#  defining a PCRE placeholder for right-brace macro names.
#* Define a new ${pcre_macro_brace_right} PCRE matching right-brace macros.
#  Such PCRE should (probably) share the same PCRE body as conventional command
#  macros but be prefixed by a distinct PCRE matching only right-brace macro
#  names with a new placeholder.
#* Define new ${char_not_literal_macroable_*} character classes, equivalent to
#  ${char_not_literal_sourceable_*} character classes with exception of
#  explicitly listing "}".
#* Define new ${pcre_literal_macroable_*} PCREs based on such classes,
#  suffixing ${pcre_literal_macroable_rest} by
#  ${pcre_literal_blockable_lookbehind} but otherwise defined as expected.
#* Embed such ${pcre_literal_macroable_*} PCREs in macroable word PCREs.
#* Explicitly match "${pcre_brace_right}" in macroable word PCREs, immediately
#  followed by (in order):
#  * One or more whitespace characters (horizontal and/or vertical) optionally
#    interspersed by line continuations.
#  * ${pcre_macro_brace_right}.
#* Define capture group index globals specific to right-brace macros.
#
#Phew! While each of the above steps is largely trivial, there certainly exist
#more than a few of them. *wet choleric sigh*

#FIXME: For debuggability, we probably want to prepand global PCREs with option
#"(?x)" enabling "extended PCRE" mode. Before doing so, however, we'll need to
#investigate which formerly ignored characters such mode renders reserved;
#this is probably at least "#". all instances of which may now need to be
#explicitly escaped by "\". Following that, append suitable subsections of such
#PCREs by newlines for improved readability.

# ....................{ GLOBALS ~ pcre                     }....................
# PCRE to which ${ZY__PREPROCESS_PCRE} will be set if no macros exist.
typeset -g ZY__PREPROCESS_PCRE_IF_EMPTY

# PCRE to which ${ZY__PREPROCESS_PCRE} will be set if at least one macro exists.
typeset -g ZY__PREPROCESS_PCRE_IF_NONEMPTY

# PCRE matching unsupported here-documents (i.e., here-documents with
# non-literal and hence non-PCRE-matchable delimiters).
typeset -g ZY__MACRO_HERE_DOC_UNSUPPORTED_PCRE

# ....................{ GLOBALS ~ pcre : name              }....................
# Syntactically valid macro name.
typeset -g ZY__MACRO_NAME_VALID_PCRE

#FIXME: In all likelihood, this is probably unbearably inefficient. That said,
#the alternative of switching back and forth between macro regex matching and
#macro preprocessing logic on every single command name is probably even more
#unbearable. At some point, we'll need to deterministically profile which is
#faster and extensively document our findings. Until then... this sadly stays.

# Command nacro name placeholder.
#
# == Motivation ==
#
# Since the set of all such names changes with each call to a command macro
# definer and undefiner (e.g., :macro_command(), :macro_command.undefine()),
# such name *CANNOT* be matched by a static PCRE. Instead, such PCRE embeds an
# arbitrary placeholder to be subsequently substituted by higher-level
# macro-specific PCRE functions (e.g., ::preprocessor_pcres.make()) with a
# dynamically constructed PCRE matching such names.
typeset -g ZY__MACRO_COMMAND_NAME_PLACEHOLDER='ZY__MACRO_COMMAND_NAME'

# ....................{ MAIN                               }....................
#FIXME: Oh, gods. Does any of this still apply? Probably, but shifting the
#chaff from the wheat isn't going to be especially thrilling.

# Declare PCRE globals *NOT* reinitialized on each call to
# ::preprocessor_pcres.make().
#
# For simplicity, the zeshy preprocessor avoids duplicating behaviour already
# implemented by the zsh parser. Since this particularly includes syntactic
# checking, such globals match both syntactically valid *AND* invalid
# constructs. Of course, this has ancillary benefits as well: namely,
# preventing unmatched syntactically invalid constructs from being erroneously
# matched as syntactically valid delimiters. For example, despite syntactic
# ivalidity, "${}" is matched (and ideally ignored) as a variable expansion
# rather than as a "}" block suffix preceded by ignorable garbage.
#
# The PCRE matching double-quoted strings provides a minimum length example
# correcting such issues:
#
#     local pcre_quotes_double='"(?:\\[\\"$`]|[^"$`]|(?&bed)|[^"])*"'
#
# Let's pick this apart. In order:
#
# 1. "\\[\\"$`]", matching any relevant escaped character, where the
#    meaning of "relevant" depends on the current syntactic construct.  In
#    the case of double-quoted strings, these are:
#    * An escaped backslash, preventing such backslash from escaping the
#      following character.
#    * An escaped '"' delimiter, preventing such delimiter from terminating
#      such match.
#    * An escaped "$" or "`" character, preventing such character from
#      initiating a variable expansion, arithmetic substitution, or process
#      substitution (as matched by the following subroutine call).
# 2. "[^"$`]", matching any irrelevant character, where the meaning of
#    "irrelevant" is the inverse of the meaning of "relevant" above
#    excluding backslashes. Since the prior alternative matched all
#    relevant escaped characters, all remaining escaped characters and
#    hence backslashes are irrelevant. Since the last alternative is a
#    fallback matching all characters excluding '"' delimiters, this
#    alternative is technically redundant. However, the following
#    alternative is a PCRE subroutine call -- which, by definition, incurs
#    non-negligible space and time costs. Since such call should be
#    performed *ONLY* if necessary, this alternative matches all characters
#    guaranteed *NOT* to be matched by such call.
# 3. "(?&bed)", matching any variable expansion, arithmetic substitution,
#    or process substitution. All such syntactic constructs are recursively
#    nestable and hence matchable only with subroutine calls. (Since
#    double-quoted strings are only indirectly recursively nestable, such
#    call is replacable in this specific case by the contents of the
#    corresponding PCRE ${pcre_embeddable_or_char_escaped}. In the general case,
#    however, subroutine calls are typically required.)
# 4. "[^"]", a fallback matching any unmatched character *NOT* the
#    terminating '"' delimiter. Assuming the prior alternatives matched
#    such syntactic construct correctly, this should be equivalent to
#    matching any unescaped "$" or "`" character. For robustness, it's
#    simplest to match any non-delimiter.
#
# Syntactic constructs delimited by substrings longer than a single
# character require negative lookahead to properly match. Since such
# lookahead is comparatively inefficient, defer such lookahead to the final
# alternative in the PCRE matching such constructs: e.g.,
#
#     # Instead of this...
#     local pcre_math_substitution_parens='\$\(\((?:\\[\\)$`]|(?!\)\))(?:[^)$`]|(?&bed)|.))*\)\)'
#
#     # ...just do this.
#     local pcre_math_substitution_parens='\$\(\((?:\\[\\)$`]|[^)$`]|(?&bed)|(?!\)\)).)*\)\)'

#FIXME: Excise all unused PCREs below.
#FIXME: Fairly confident that we can further optimize such PCREs by
#globally substituting non-atomic grouping syntax "(?:...)" for atomic
#grouping syntax "(?>...)". The difference between the two is as follows:
#
#* If any alternative in the latter succeeds, such group will *NEVER* be
#  backtracked into -- even if that results in a match failure.
#* By contrast, the former is always backtracked into on subsequent match
#  failures.
#
#We believe we've implicitly designed *ALL* alternation below to not
#require backtracking. That being said, we really won't know until we get
#the backtracking-capable version working first and then attempt to
#optimize into the backtracking-incapable version.
#FIXME: Similarly, most instances of "*", "+", and "?" may be suffixed by
#the possessive quantifier "+" as well.

() {
    # PCRE subroutines defined below, concatenated in a manner preventing such
    # definitions from either matching *OR* capturing in place.
    #
    # Much like programmatic subroutines, PCRE subroutine are self-consistent units
    # preserving a semblance of local scope; for example, PCRE subroutines prevent
    # substrings captured by such calls from leaking to callers (e.g., subroutines,
    # zsh code) by snapshotting the state of all captured substrings on entering
    # such call and restoring such state on leaving such call. In other words,
    # subroutines impose non-negligible time and space costs.
    #
    # For efficiency, subroutines should be leveraged *ONLY* where required.
    # Typically, this means recursion matching delimiter-balanced syntactic
    # constructs in a context-free manner. In all other cases, PCREs should be
    # encapsulated as string variables and interpolated directly where used.
    local pcre_subroutines_body

    # Empty string captured to a group. Since "libpcre" already captures the
    # empty string to unmatched groups (excluding trailing unmatched groups
    # detectable with ${#match}), this PCRE is typically only required to
    # structure group indices in "(?|"-based alternatives.
    local pcre_empty_group='()'

    # ..................{ OPTIONS                            }..................
    # PCRE options. Dismantled, this is:
    #
    # * "(?s)", inducing "." to match all characters including newline. (By
    #   vexsome default, "." matches all characters *EXCLUDING* newline.)
    # * "(?m)", inducing:
    #   * "^" to match either the string start *OR* newline. (By default, "^"
    #     matches only the former.)
    #   * "$" to match either the string end *OR* newline. (By default, "$"
    #     matches only the former.)
    # * "(?x)", enabling "extended PCRE" mode lexing the following substrings
    #   in PCREs as insignificant:
    #   * Unescaped whitespace *NOT* embedded in character classes.
    #   * "#"-prefixed comments (i.e., unescaped "#" characters *NOT* embedded
    #     in character classes and all non-newline characters following such
    #     "#" character).
    # * "(*BSR_ANYCRLF)", forcing "\R" to match *ONLY* ASCII newlines. (By
    #   default, "\R" matches both ASCII and UTF-8-encoded newlines.)
    local pcre_options='(?smx)(*BSR_ANYCRLF)'

    # PCRE options as above, as well as anchoring the current PCRE to the first
    # match point in the the substring currently being searched. For both
    # efficiency and consistency, iterative PCREs (i.e., PCREs iteratively
    # matching consecutive substrings in strings via pcre_match() and
    # ${ZPCRE_OP}) should *ALWAYS* be anchored, ensuring such PCREs only match
    # at the first byte following the last byte of the prior such match rather
    # than at any byte following such byte (the default).
    local pcre_options_anchored=${pcre_options}'\G'

    # ..................{ REPORT                             }..................
    # Note that there exists no corresponding PCRE reporting failure from the
    # current match attempt. In theory, such PCRE is constructable from the
    # "(*COMMIT)" assertion (reporting failure when backtracked into from a
    # subsequent matching failure) and the "(*FAIL)" assertion (forcing
    # backtracking by inducing matching failure) as follows:
    #
    #     local pcre_report_failure='(*COMMIT)(*FAIL)'
    #
    # In practice, such PCRE is effectively useless. For usability, zeshy
    # throws human-readable exceptions on match failure describing the
    # underlying cause by inspecting the contents of the canonical list global
    # ${match}. Unfortunately, zsh fails to set such global on match failure,
    # implying that zeshy *MUST* symbolically signal such failure to itself
    # without physically reporting such failure.
    #
    # Paradoxically, the simplest means of doing so is to report success on
    # match failure in such a way that the ${match} list exhibits such failure.
    # On inspecting ${match} for such failure on match completion, zeshy then
    # throws an appropriate exception specific to such failure.

    # Report success from the current match attempt, immediately returning the
    # currently matched substring and all previously captured groups.
    local pcre_succeed='(*ACCEPT)'

    # ..................{ CLASS                              }..................
    # Character class bodies intended to be embedded *ONLY* in positive
    # character classes (i.e., *NOT* prefixed by "^").

    # ..................{ CLASS ~ space                      }..................
    # Character class matching horizontal ASCII whitespace characters.
    local char_space_horizontal=' \t'

    # Character class matching vertical ASCII whitespace characters.
    local char_space_vertical='\r\n'

    # Character class matching ASCII whitespace characters.
    local char_space=${char_space_horizontal}${char_space_vertical}

    # ..................{ CLASS ~ embeddable                 }..................
    # Character class matching embeddable-reserved characters, including:
    #
    # * "$", prefixing variable expansions *AND* arithmetic and standard
    #   process substitutions.
    # * "`", prefixing non-recursive process substitutions.
    local char_embeddable_prefix='$`'

    # ..................{ CLASS ~ sourceable                 }..................
    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the first of any shell word of a command, excluding
    # embeddable-reserved characters and hence including only:
    #
    # * "<", prefixing "<("- and ")"-delimited process substitutions.
    # * ">", prefixing ">("- and ")"-delimited process substitutions.
    local char_sourceable_nanoword_rest_sans_embeddable='<>'

    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the start of any shell word of a command, including the entirety
    # of the prior class as well as:
    #
    # * "$", prefixing variable expansions *AND* arithmetic and standard
    #   process substitutions.
    #
    # Unlike embeddable-reserved characters, the "`" delimiting "`"-delimited
    # process substitutions is intentionally excluded. (See the definition of
    # subroutine "<emb>" for details.)
    local char_sourceable_nanoword_rest='$'${char_sourceable_nanoword_rest_sans_embeddable}

    # Character class matching sourceable-reserved characters at the start of
    # any shell word *AFTER* the first of a command, including the entirety of
    # the prior class as well as:
    #
    # * "=", prefixing "=("- and ")"-delimited process substitutions.
    local char_sourceable_nanoword_start_word_rest=${char_sourceable_nanoword_rest}'='

    # Character class matching sourceable-reserved characters at the start of
    # the first shell word of a command, including the entirety of the prior
    # class as well as:
    #
    # * "(", prefixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    local char_sourceable_nanoword_start_word_first='('${char_sourceable_nanoword_start_word_rest}

    # ..................{ CLASS ~ passable                   }..................
    # Character class matching sourceable-reserved characters at any character
    # *AFTER* the start of a scalar macro argument. Since "("-prefixed process
    # forks and arithmetic tests are commands and hence *NOT* arguments, "(" is
    # omitted both here and below (e.g., by embedding
    # ${char_sourceable_nanoword_rest}). While "`"-delimited process
    # substitutions are typically ignorable, proper argument matching requires
    # matching such substitutions.
    local char_passable_nanoword_rest=${char_sourceable_nanoword_rest}'`'

    # Character class matching sourceable-reserved characters at the start of a
    # scalar macro argument. Such arguments follow macro names and hence the
    # first shell words of such macros, avoiding the need for a separate PCRE
    # matching characters at the start of such arguments.
    local char_passable_nanoword_start=${char_sourceable_nanoword_start_word_rest}'`'

    # ..................{ CLASS ~ terminator                 }..................
    # Character class matching single-character command terminators in a
    # generic context.
    #
    # Technically, characters this class matches should be prefixed by either
    # horizontal or vertical whitespace when preceded by characters that are
    # *NOT* unspaced command terminators (e.g., "if { true } {"). Since shell
    # word-specific negative lookahead prevents such words from matching "{",
    # however, such technicalities are ignorable.
    #
    # Technically, "{" only conditionally constitutes a command terminator in
    # specific syntactic contexts (namely, after if, elif, for, unless, and
    # while conditionals): e.g.,
    #
    #    # A syntactic context in which "{" is *NOT* a command terminator,
    #    # requiring that :macro() *NOT* be expanded in this syntactic context.
    #    >>> :print { :macro
    #    { :macro
    #
    # Unfortunately, matching such contexts is infeasible in the general case.
    # Macros embedded in the conditional blocks of complex commands require
    # matching, preventing PCRE-based retention of the observation that the
    # current match position is in a complex command and hence preventing
    # matching of "{" block prefixes in a contextual manner: e.g.,
    #
    #    # Matching "{" block prefixes in a contextual manner would erroneously
    #    # prevent # :macro2() from being matched.
    #    >>> !if { :macro1 } { :macro2 }
    #
    # Fortunately, issues only arise in the uncommon (and frankly syntactically
    # unsupported) edge case of literal "{" shell words appearing *AFTER* the
    # first shell words of commands. Hence, such issues are largely ignorable.
    local char_terminator_sourceable=${char_space_vertical}'{'

    # Character class matching the first character of a process substitution,
    # all of which also serve as command terminators.
    #
    # Sadly, this excludes the "`" prefixing "`"-delimited process
    # substitutions. While the "`" is also technically a command terminator,
    # matching such "`" requires an approach like that with which the '"'
    # suffixing double-quoted strings containing process substitutions is
    # matched -- which is to say, highly non-trivial if not infeasible in the
    # general case. Since "`"-delimited process substitutions are largely
    # deprecated in modern shell scripting, "`" is omitted here.
    local char_terminator_process_substitution='$=<>'

    # ..................{ NOT                                }..................
    # Character class bodies intended to be embedded *ONLY* in negative
    # character classes (i.e., prefixed by "^"). Since escaped characters must
    # be explicitly matched and hence *NOT* implicitly matched by these
    # classes, these classes *MUST* contain the character escape "\".
    #
    # This is significant enough to warrant repeating, in bold plaintext:
    # *ALL NEGATIVE CHARACTER CLASSES OPERATING ON ZSH CODE MUST CONTAIN "\".*

    # ..................{ NOT ~ embeddable                   }..................
    # Character class matching invalid characters in embeddable syntactic
    # constructs (e.g., arithmetic substitutions, variable expansions).
    local char_not_embeddable_prefix=${char_embeddable_prefix}'\\'

    # ..................{ NOT ~ literal : sourceable         }..................
    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in an abstract context, equivalent to the set of all
    # characters unconditionally invalid in *ALL* syntactic contexts and hence
    # comprising most zsh-reserved operators conflicting with macro
    # preprocessing. This includes unconditionally meaningful ASCII punctuation
    # as well as:
    #
    # * "&", unconditionally signifying "&"-prefixed command terminators
    #   (e.g., "&", "&&", "&!").
    #
    # This excludes:
    #
    # * "{". While typically signifying either blocks or brace expansions
    #   depending on shell word and character position, such character is
    #   ignorable in certain syntactic contexts (e.g., variable assignments)
    #   and hence omitted here.
    # * "`". While unconditionally signifying "`"-delimited process
    #   substitution in *ALL* syntactic contexts, such substitutions and hence
    #   character are ignorable in most contexts. (See below for details.)
    # * zsh-reserved operators *NOT* conflicting with preprocessing (e.g.,
    #   "*", "!", "^", "?").
    # * zsh-reserved characters conditionally dependent on position in unquoted
    #   shell words, including:
    #   * "}", suffixing blocks only if the last character of such words.
    #   * "#", prefixing comments only if the first character of such words.
    #     In all other lexical contexts, "#" serves as a glob operator.
    #
    # Excluding "`" here implies that macros embedded in "`"-delimited process
    # substitutions immediately following such prefixing "`" will *NOT* be
    # preprocessed as macros; all other macros in such substitutions will be
    # preprocessed as macros, however. Since such substitutions have been
    # officially deprecated by "$("- and ")"-prefixed process substitutions
    # *AND* since the current aapproach significantly improves the simplicity
    # and efficiency of macro PCREs, we adopt the current approach.
    local char_not_literal_universal_rest=${char_space}'''"$;|&<>\\'

    # Character class matching invalid characters at the start of an unquoted
    # shell word *AFTER* the first such word of a command in an abstract
    # context, additionally including:
    #
    # * "#", prefixing comments.
    # * "=", prefixing "=("- and ")"-delimited process substitutions. Such
    #   "=" conflicts with unquoted "=" characters, whereas any following such
    #   "(" conflicts with "("- and ")"- delimited glob qualifiers. In either
    #   case, disambiguation is required.
    local char_not_literal_universal_start_word_rest=${char_not_literal_universal_rest}'#='

    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command in an abstract context, additionally
    # including:
    #
    # * "(", prefixing:
    #   * "("- and ")"-delimited process forks.
    #   * "(("- and "))"-delimited arithmetic tests.
    #
    # Since this only applies to first shell words, any "(" prefixing
    # subsequent shell words signifies a "("- and ")"-delimited glob qualifier.
    local char_not_literal_universal_start_word_first=${char_not_literal_universal_start_word_rest}'('

    # ..................{ NOT ~ literal : sourceable         }..................
    #FIXME: How does "sourceable" differ from "universal"? The latter is fairly
    #explanatory; the former, however, certainly isn't. What exactly do we mean
    #by "generic context" below? Comments above would appear to suggest that
    #"{" is significant only *OUTSIDE* of variable expansion contents; since
    #${char_not_literal_sourceable_start_word_first} matches "{", does this
    #then imply that "sourceable" means "any syntactic context whose valid
    #strings are all sourceable as zsh code"? That would make a semblance of
    #sense, if so. The phrase "generic context" below, however, remains
    #horribly ambiguous -- and should almost certainly be rephrased as
    #"sourceable context", with "sourceable" explicitly defined here.
    #FIXME: O.K.; that's almost certainly what "sourceable" means, due to the
    #addition of only "{" to every character class below.

    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command in a generic context, additionally
    # including:
    #
    # * "{", unconditionally signifying either:
    #   * Blocks, if the first character of the first shell word of a command.
    #   * Brace expansions, if any other character of such words of a command.
    local char_not_literal_sourceable_start_word_first=${char_not_literal_universal_start_word_first}'{'

    # Character class matching invalid characters at the start of an unquoted
    # shell word *AFTER* the first of a command in a generic context.
    local char_not_literal_sourceable_start_word_rest=${char_not_literal_universal_start_word_rest}'{'

    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in a command in a generic context.
    local char_not_literal_sourceable_rest=${char_not_literal_universal_rest}'{'

    # ..................{ NOT ~ literal : backtickable       }..................
    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command in a "`"-delimited process
    # substitution.
    local char_not_literal_backtickable_start_word_first=${char_not_literal_sourceable_start_word_first}'`'

    # Character class matching invalid characters at the start of an unquoted
    # shell word *AFTER* the first of a command in a "`"-delimited process
    # substitution.
    local char_not_literal_backtickable_start_word_rest=${char_not_literal_sourceable_start_word_rest}'`'

    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in a command in a "`"-delimited process substitution.
    local char_not_literal_backtickable_rest=${char_not_literal_sourceable_rest}'`'

    # ..................{ NOT ~ literal : blockable          }..................
    # Character class matching invalid characters at the start of the first
    # unquoted shell word of a command in a block.
    local char_not_literal_blockable_start_word_first=${char_not_literal_sourceable_start_word_first}'}'

    # Character class matching invalid characters at the start of an unquoted
    # shell word *AFTER* the first of a command in a block.
    local char_not_literal_blockable_start_word_rest=${char_not_literal_sourceable_start_word_rest}'}'

    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in a command in a block.
    local char_not_literal_blockable_rest=${char_not_literal_sourceable_rest}'}'

    # ..................{ NOT ~ literal : braceable          }..................
    # Character class matching invalid characters in brace expansions.
    local char_not_literal_braceable='}'${char_not_literal_sourceable_rest}

    # ..................{ NOT ~ literal : parenable          }..................
    # Character class matching unconditionally invalid characters *AFTER* the
    # start of an unquoted shell word in a command in a parens-delimited
    # syntactic construct.
    local char_not_literal_parenable_rest='()'${char_not_literal_sourceable_rest}

    # Character class matching invalid characters at the start of an unquoted
    # shell word in a command in a parens-delimited syntactic construct. Unlike
    # prior classes, this class is invariant with respect to word order; that
    # is, this class unconditionally applies to both the first unquoted shell
    # word and all following such words of a command.
    local char_not_literal_parenable_start=${char_not_literal_parenable_rest}'#'

    # ..................{ NOT ~ literal : passable           }..................
    # Character class matching invalid characters at any position of an
    # unquoted shell word in a scalar macro argument, including:
    #
    # * "}", preventing such word from erroneously consuming block suffixes.
    # * "(", preventing such word from consuming glob qualifier and arithmetic
    #   test prefixes. While both are valid in scalar macro arguments, this
    #   character is matched elsewhere in a syntax-aware manner.
    # * ")", preventing such word from consuming arithmetic test, process
    #   fork, and process substitution suffixes. While the former are valid in
    #   scalar macro arguments, this character is matched elsewhere in a
    #   syntax-aware manner.
    # * "`", preventing such word from erroneously consuming "`"-delimited
    #   process substitution prefixes and suffixes.
    local char_not_literal_passable_core='}()`'

    # Character class matching invalid characters at the start of an unquoted
    # shell word in a scalar macro argument, also including:
    #
    # * Digits, preventing such word from consuming digit-prefixed
    #   redirections (e.g., "1>&2"). For simplicity, scalar macro arguments are
    #   prohibited from matching any redirection. See
    #   ${pcre_literal_passable_start} below.
    # * "&", preventing such word from consuming "&"-prefixed redirections.
    # * "[", preventing such word from consuming non-arithmetic test
    #   delimiters. While valid scalar macro arguments, such delimiters are
    #   matched elsewhere in a syntax-aware manner.
    local char_not_literal_passable_start=${char_not_literal_sourceable_start_word_rest}'0-9[&'${char_not_literal_passable_core}

    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in a scalar macro argument.
    local char_not_literal_passable_rest=${char_not_literal_sourceable_rest}${char_not_literal_passable_core}

    # ..................{ NOT ~ literal : scalarable         }..................
    # Character class matching invalid characters at the start of an unquoted
    # shell word in a scalar variable assignment, including:
    #
    # * "`", delimiting "`"-delimited process substitutions. While typically
    #   ignorable, such substitutions are matched in assignments to ensure
    #   proper matching of assignment boundaries.
    #
    # This excludes:
    #
    # * "{", prefixing both blocks and brace expansions. Since such words do
    #   *NOT* participate in conventional command syntax, all "{" characters
    #   and hence all brace expansions in such words are interpreted as raw
    #   literals rather than as syntactic delimiters.
    # * "}", suffixing both blocks and brace expansions. Unlike "{" characters,
    #   "}" characters in such words are conditionally interpreted as block
    #   suffixes when the last characters of such words. However, variable
    #   assignments are only matched as such at the top level; in all other
    #   syntactic contexts, such assignments are matched as conventional
    #   commands. Since blocks are irrelevant to matching at the top level,
    #   "}" characters are matchable as raw literals for our purposes.
    local char_not_literal_scalarable_start=${char_not_literal_universal_start_word_rest}'`'

    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in a scalar variable assignment.
    local char_not_literal_scalarable_rest=${char_not_literal_universal_rest}'`'

    # ..................{ NOT ~ literal : nonscalarable      }..................
    # Character class matching invalid characters at the start of an unquoted
    # shell word in a nonscalar variable assignment. This includes all invalid
    # characters at the start of an unquoted shell word in a scalar variable
    # assignment as well as:
    #
    # * "(", prefixing glob qualifiers.
    # * ")", suffixing such assignments when *NOT* preceded by a balanced "("
    #   character signifying a glob qualifier.
    local char_not_literal_nonscalarable_start='()'${char_not_literal_scalarable_start}

    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word in a nonscalar variable assignment.
    local char_not_literal_nonscalarable_rest='()'${char_not_literal_scalarable_rest}

    # ..................{ NOT ~ literal : unquoted           }..................
    # Character class matching invalid characters *AFTER* the start of an
    # unquoted shell word (i.e., word containing only unquoted characters).
    local char_not_literal_unquoted_rest=${char_not_literal_parenable_rest}'}[\]*?!^`'

    # Character class matching invalid characters at the start of an unquoted
    # shell word (i.e., word containing only unquoted characters).
    # Equivalently, this is the character class matching all zsh-reserved
    # characters, including both conditionally reserved characters (i.e.,
    # characters only reserved in some but not all syntactic contexts) and
    # unconditionally reserved characters (i.e., characters reserved in all
    # syntactic contexts). This includes:
    #
    # * "#", prefixing comments.
    # * "=", expanding directory aliases.
    # * "~", expanding user home directories.
    local char_not_literal_unquoted_start='#'${char_not_literal_unquoted_rest}'=~'

    # ..................{ NOT ~ macro name                   }..................
    # Character class matching invalid characters *AFTER* the start of a macro
    # name.
    local char_not_macro_name_rest=${char_not_literal_unquoted_rest}'+'

    # Character class matching invalid characters at the start of a macro
    # name. Since this comprises *ALL* PCRE- and zsh-reserved characters, only
    # a handful of the most common punctuation characters are permissible in
    # macro names (e.g., ".", ",", "_", "-").
    #
    # Technically, since PCRE-reserved characters in macro names *COULD* be
    # explicitly escaped, only zsh-reserved characters need to be prohibited.
    # For simplicity, both are currently prohibited.
    #
    # Technically, zsh permits the zsh-reserved characters "!" and "#" to be
    # configured via string global ${histchars}. While we could generalize our
    # current hard-coding of such characters with an expansion of such global
    # here (taking care to escape character class-reserved characters), doing
    # so would unhelpfully render the set of all syntactically valid macro
    # names a dynamic function of current shell state -- implying that some
    # names would be only conditionally syntactically valid. Since that would
    # be unequivocally bad, we ignore such technicalities...
    local char_not_macro_name_start=${char_not_literal_unquoted_start}'+'

    # First character of a macro name.
    local pcre_macro_name_start='[^'${char_not_macro_name_start}']'

    # Any character *AFTER* the first of a macro name.
    local pcre_macro_name_rest='[^'${char_not_macro_name_rest}']'

    # One or more macro name characters, excluding such name's first character.
    local pcre_macro_name_chars_rest_optional=${pcre_macro_name_rest}'*+'

    # Any invalid character of a macro name *AFER* the start of such name.
    local pcre_char_not_macro_name_rest='['${char_not_macro_name_rest}']'

    # ..................{ SPACE                              }..................
    # Horizontal or vertical whitespace ASCII character. Although the builtin
    # character type "\s" already matches both ASCII and non-ASCII whitespace,
    # the latter are inapplicable here. Since zsh lexes only ASCII whitespace
    # characters as whitespace *AND* since there exist substantially more
    # non-ASCII than ASCII whitespace characters, such characters are best
    # matched with explicit character classes instead.
    local pcre_space='['${char_space}']'

    # Horizontal ASCII whitespace character (i.e., space or tab). For
    # efficiency, omit non-ASCII horizontal whitespace characters and hence the
    # generic character type "\h". Since PCRE provides an option for preventing
    # "\R" but *NOT* "\h" from matching UTF-8-encoded characters, we have
    # little choice but to manually define such character class. See subsection
    # "Generic character types" at: http://www.pcre.org/pcre.txt
    local pcre_space_horizontal='['${char_space_horizontal}']'

    # One or two vertical ASCII whitespace characters. Specifically, either:
    #
    # * Unix-specific linefeed (i.e., "\n").
    # * Windows-specific carriage return followed by linefeed (i.e., "\r\n").
    local pcre_space_vertical='\R'

    # One or more horizontal or vertical whitespace ASCII characters.
    local pcre_spaces=${pcre_space}'++'

    # Zero or more horizontal or vertical whitespace ASCII characters.
    local pcre_spaces_optional=${pcre_space}'*+'

    # One or more horizontal whitespace characters.
    local pcre_spaces_horizontal=${pcre_space_horizontal}'++'

    # Zero or more horizontal whitespace characters.
    local pcre_spaces_horizontal_optional=${pcre_space_horizontal}'*+'

    # One or more vertical whitespace characters.
    local pcre_spaces_vertical=${pcre_space_vertical}'++'

    # Any character other than a vertical whitespace character. While PCRE
    # provides no inverse of "\R" as it does with most other generic types
    # (e.g., "\S", "\H", "\V"), a customary negative character class suffices.
    local pcre_char_sans_space_vertical='[^'${char_space_vertical}']'

    # One or more characters other than vertical whitespace characters. Such
    # PCRE matches "\" and hence must be used *ONLY* where escaped characters
    # are insignificant (e.g., comments, single-quoted strings).
    local pcre_chars_sans_space_vertical=${pcre_char_sans_space_vertical}'++'

    # Zero or more characters other than vertical whitespace characters.
    local pcre_chars_sans_space_vertical_optional=${pcre_char_sans_space_vertical}'*+'

    # ..................{ SPACE ~ continuation               }..................
    # Line continuation (i.e., an unescaped backslash followed by a newline),
    # continuing the command corresponding to the current line to the next
    # line. As discussed above, newlines preceded by two backslashes are *NOT*
    # line continuations and must *NOT* be matched as such.
    local pcre_continuation='\\'${pcre_space_vertical}

    # Line continuation followed by optional whitespace.
    local pcre_continuation_spaceable=${pcre_continuation}${pcre_spaces_optional}

    # Line continuation followed by optional horizontal whitespace.
    local pcre_continuation_spaceable_horizontal=${pcre_continuation}${pcre_spaces_horizontal_optional}

    # One or more line continuations.
    local pcre_continuations='(?>'${pcre_continuation}')++'

    # Zero or more line continuations.
    local pcre_continuations_optional='(?>'${pcre_continuation}')*+'

    # One or more line continuations, each followed by optional whitespace.
    local pcre_continuations_spaceable='(?>'${pcre_continuation_spaceable}')++'

    # Zero or more line continuations, each followed by optional whitespace.
    local pcre_continuations_spaceable_optional='(?>'${pcre_continuation_spaceable}')*+'

    # One or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_continuations_spaceable_horizontal='(?>'${pcre_continuation_spaceable_horizontal}')++'

    # Zero or more line continuations, each followed by optional horizontal
    # whitespace.
    local pcre_continuations_spaceable_horizontal_optional='(?>'${pcre_continuation_spaceable_horizontal}')*+'

    # ..................{ SPACE ~ continuable                }..................
    # One or more whitespace characters *NOT* preceded by line continuations,
    # optionally interspersed by line continuations.
    local pcre_spaces_continuable=${pcre_spaces}${pcre_continuations_spaceable_optional}

    # One or more horizontal whitespace characters *NOT* preceded by line
    # continuations, optionally interspersed by line continuations.
    local pcre_spaces_horizontal_continuable=${pcre_spaces_horizontal}${pcre_continuations_spaceable_horizontal_optional}

    # Zero or more line continuations followed by one whitespace character,
    # principally intended for use in lookahead and lookbehind.
    local pcre_continuable_space=${pcre_continuations_optional}${pcre_space}

    # Positive lookahead requiring at least one whitespace character
    # (optionally preceded by line continuations) to match.
    local pcre_is_continuable_space='(?='${pcre_continuable_space}')'

    # Negative lookahead preventing any whitespace characters (optionally
    # preceded by line continuations) from matching.
    local pcre_not_continuable_space='(?!'${pcre_continuable_space}')'

    # Zero or more line continuations followed by one horizontal whitespace
    # character, principally intended for use in lookahead and lookbehind.
    local pcre_continuable_space_horizontal=${pcre_continuations_optional}${pcre_space_horizontal}

    # One or more whitespace characters optionally interspersed by line
    # continuations.
    local pcre_continuable_spaces=${pcre_continuations_optional}${pcre_spaces_continuable}

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations, comprising all whitespace delimiting one shell word
    # from another within a command.
    #
    # *THIS IS THE BIG ONE, FOLKS.*
    local pcre_continuable_spaces_horizontal=${pcre_continuations_optional}${pcre_spaces_horizontal_continuable}
    local pcre_continuable_spaces_horizontal_grouped='('${pcre_continuable_spaces_horizontal}')'

    # Zero or more whitespace characters *OR* line continuations.
    local pcre_continuable_spaces_optional='(?>'${pcre_spaces}'|'${pcre_continuation}')*+'

    # Zero or more horizontal whitespace characters *OR* line continuations.
    local pcre_continuable_spaces_horizontal_optional='(?>'${pcre_spaces_horizontal}'|'${pcre_continuation}')*+'
    local pcre_continuable_spaces_horizontal_optional_grouped='('${pcre_continuable_spaces_horizontal_optional}')'

    # ..................{ SPACE ~ subject                    }..................
    # Start of the subject string (i.e., the string currently being matched).
    local pcre_subject_start='\A'

    # End of the subject string.
    local pcre_subject_end='\z'

    # End of the subject string, immediately reporting success from the current
    # match attempt. Since this PCRE is typically embedded in PCREs matching
    # syntactic constructs and hence delimiting characters, this PCRE is
    # typically only matched within invalid syntactic constructs *NOT*
    # delimited by the required characters.
    #
    # This PCRE ensures that even invalid syntactic constructs will result in
    # match success and hence that the canonical list global ${match} will be
    # set. Note that we use the term "match success" in only the strictest
    # sense. Subsequent logic will inspect such list for the presence of
    # invalid syntactic constructs and throw an exception if detected, thereby
    # converting such "match success" into a genuine failure.
    #
    # See also the related ${pcre_reset_remainder_succeed}.
    local pcre_subject_end_succeed=${pcre_subject_end}${pcre_succeed}
    local pcre_subject_end_succeed_optional='(?>'${pcre_subject_end_succeed}')?+'

    # ..................{ SPACE ~ reset                      }..................
    # Reset matching to the current position in the subject string, ensuring
    # that ${ZPCRE_OP[(w)1]} expands to such position's byte index. This PCRE
    # circumvents the global discrepancy between operator "=~" and builtin
    # pcre_match(): namely, that only the former sets canonical match globals
    # expanding to the byte indices of captured groups (e.g., ${mbegin}),
    # requiring use of this PCRE in the latter to achieve the same effect.
    # Since "=~" cannot be used to iterate matches but pcre_match() can, we
    # *MUST* use the latter and hence this PCRE for iterating macro matches.
    local pcre_reset='\K'

    # Reset matching to the current match position, reporting success from the
    # current match attempt.
    local pcre_reset_succeed=${pcre_reset}${pcre_succeed}

    # Remainder of the subject string (i.e., all text between the current match
    # position inclusive and the end of such string), resetting matching to
    # the current match position and reporting success from the match attempt.
    #
    # This PCRE is intended for use in notifying the caller of invalid syntax
    # (e.g., "'"-prefixed strings with no suffixing "'", signifying an invalid
    # double-quoted string). Specifically, usage of this PCRE guarantees that:
    #
    # * The first byte matched by such attempt will *NOT* immediately follow
    #   the last byte matched by the prior attempt.
    # * The match group capturing the last character of a valid macro will
    #   *NOT* be matched.
    # * The match will contain only such invalid syntax.
    #
    # Hence, invalid syntax is identifiable only by comparison of byte indices.
    # This stands in contrast to standard PCRE conditions identifiable by the
    # nonemptiness of match groups. This disparity is due entirely to recursive
    # syntax. Recursively nestable constructs are matchable only by subroutine
    # calls isolating match groups captured by such calls to such calls and
    # hence preventing logic elsewhere from accessing such groups. Since
    # recursive constructs may contain invalid syntax (e.g., "$(')", a process
    # substitution containing an invalid string), such syntax would be isolated
    # and hence unidentifiable if captured to match groups.
    #
    # ${pcre_reset}, a little known escape sequence unique to Perl and libpcre,
    # circumvents such isolation. By discarding all previously matched
    # characters and hence resetting the current match to the current match
    # position, ${pcre_reset} acts globally in a manner ignoring subroutine
    # call isolation. Such PCRE is usable to effectively "return" arbitrary
    # byte indices to external logic regardless of whether such bytes are
    # embedded in recursive syntax matchable only by subroutine calls.
    #
    # PCREs matching syntactic constructs may leverage ${pcre_reset} by:
    #
    # * Suffixing all recursive subroutine calls (e.g., "(&emb)")
    #   by a PCRE reporting success immediately if the current
    #   match position is the end of such code.
    # * Defining an alternate immediately *AFTER* matching the unique
    #   prefix prefixing such construct, matching either:
    #   * The syntactically valid remainder of such construct.
    #   * ${pcre_reset} followed by the syntactically invalid remainder of such
    #     construct, typically meaning the remainder of such string in the
    #     event of a lack of trailing delimiter.
    #
    # As example, a simplified PCRE matching single-quoted strings:
    #
    #     local pcre_quotes_single="'(?:(?>[^']++|'')*+'"'|${pcre_reset}.*+${pcre_succeed})'
    #
    # With respect to preprocessing, there are two types of invalid syntax:
    #
    # * Constructs invalidly spanning from the current match position to the
    #   end of the subject string (e.g., due to a lack of balanced suffixes).
    #   Since such constructs already consume all remaining text, manually
    #   doing so here is entirely sensible.
    # * Constructs invalidly spanning from the current match position to a
    #   somewhere *NOT* the end of the subject string (e.g., due to erroneous
    #   internal syntax). Since such constructs do *NOT* consume all remaining
    #   text, manually doing so here seems rather insensible. Nonetheless,
    #   since subroutines isolate capture groups and hence appear incapable of
    #   passing information back to their caller via capturing, there appears
    #   to be no other PCRE-based means of notifying callers of syntactic
    #   invalidities in previously called subroutines. Consuming all remaining
    #   text permits callers to match ${pcre_subject_end_succeed}
    #   immediately after calling subroutines, guaranteeing successful
    #   termination and hence the detectability of such invalidities by the
    #   code iterating over such PCREs. Don't think too hard about that.
    local pcre_reset_remainder_succeed=${pcre_reset}'.*+'${pcre_succeed}

    # ..................{ SPACE ~ line                       }..................
    # Start of the current line, consuming one or more prefixing vertical
    # whitespace characters if any. "^" is a zero-width assertion consuming no
    # characters and hence inappropriate for use below (excluding lookahead).
    local pcre_line_start='('${pcre_spaces_vertical}'|'${pcre_subject_start}')'

    # End of the current line *WITHOUT* consuming the suffixing vertical
    # whitespace character if any. Since ${pcre_line_start} already consumes
    # such character as a line prefix, permitting another general-purpose PCRE
    # to consume the same character would prevent either from matching in a
    # general-purpose manner. (That's bad.)
    local pcre_line_end='$'

    # Start of the current line followed by zero or more horizontal whitespace
    # characters *OR* one or more horizontal whitespace characters.
    local pcre_line_start_or_spaces_horizontal='(?>'${pcre_spaces_horizontal}'|'${pcre_line_start}${pcre_spaces_horizontal_optional}')'

    # Zero or more line continuations followed by either the end of the current
    # line *OR* a whitespace character. While consuming suffixing whitespace is
    # typically discouraged, this PCRE is principally intended for use in
    # positive lookahead.
    local pcre_line_end_or_space_continuable=${pcre_continuations_optional}'(?>'${pcre_space_horizontal}'|'${pcre_line_end}')'

    # ..................{ CHAR                               }..................
    # Previous character captured with positive lookbehind. This PCRE typically
    # suffixes top-level PCREs matching possibly invalid syntax. Since such
    # syntax prematurely halts matching and capturing of this group, the
    # emptiness of this group may assist callers in disambiguating between
    # valid and invalid syntax.
    local pcre_char_last_grouped='(?<=(.))'

    # Dollar sign.
    local pcre_dollar='\$'

    # Plus sign.
    local pcre_plus='\+'
    local pcre_plus_optional=${pcre_plus}'?+'

    # ..................{ CHAR ~ quotes                      }..................
    # Double quotes.
    local pcre_quote_double='"'

    # Single quotes.
    local pcre_quote_single="'"

    # ..................{ CHAR ~ extended                    }..................
    # Octothorpe, also known as the "number sign", "pound sign," and "hashtag".
    # Typically, such character does *NOT* require explicit escaping. Since
    # developers frequently enable PCRE option "x" rendering unescaped "#"
    # characters PCRE comment prefixes, such character is escaped here to
    # simplify debugging elsewhere.
    local pcre_hash='\#'

    # Literal space, escaped for the same reason as commented for ${pcre_hash}.
    local pcre_space_literal='\ '

    # ..................{ CHAR ~ brace                       }..................
    # Left brace, conditionally matched elsewhere as either a (in order):
    #
    # * Block prefix when situated in the first shell word of a command and
    #   hence prefixed by one or more whitespace characters or the start of the
    #   subject string. Since PCREs embedding this PCRE guarantee such
    #   constraint, such whitespace is *NOT* matched here.
    # * Brace expansion prefix at all other character positions when followed
    #   by a balanced right brace within the same shell word.
    # * Literal "{" character in all other lexical contexts.
    local pcre_brace_left='\{'

    # Right brace, conditionally matched elsewhere as either a (in order):
    #
    # * Brace expansion suffix when preceded by a balanced left brace within
    #   the same shell word *NOT* signifying a block prefix.
    # * Block suffix when situated as the last character of any shell word of a
    #   command and hence suffixed by at least one whitespace character or the
    #   end of the subject string. While such condition could be asserted here
    #   with positive lookahead, there's no need: the negative lookbehind
    #   suffixing shell words in blocks guarantees such suffixes to either
    #   terminate their shell words or be distinct shell words.
    local pcre_brace_right='\}'
    local pcre_brace_right_optional=${pcre_brace_right}'?+'
    local pcre_brace_right_grouped='('${pcre_brace_right}')'

    # Right brace *NOT* suffixed by zero or more line continuations followed by
    # one or more whitespace characters and hence *NOT* a block suffix.
    local pcre_brace_right_not_block_suffix=${pcre_brace_right}${pcre_not_continuable_space}

    # ..................{ CHAR ~ bracket                     }..................
    # Left bracket.
    local pcre_bracket_left='\['

    # Left bracket *NOT* suffixed by another left bracket and hence *NOT*
    # constituting a non-arithmetic test prefix "[[".
    local pcre_bracket_left_not_test_prefix=${pcre_bracket_left}'(?!'${pcre_bracket_left}')'

    # Right bracket.
    local pcre_bracket_right='\]'

    # Right bracket *NOT* suffixed by another right bracket and hence *NOT*
    # suffixing a "[["- and "]]"-delimited non-arithmetic test.
    local pcre_bracket_right_not_test_suffix=${pcre_bracket_right}'(?!'${pcre_bracket_right}')'

    # ..................{ CHAR ~ paren : left                }..................
    # Left paren.
    local pcre_paren_left='\('
    local pcre_paren_left_optional=${pcre_paren_left}'?+'

    # Negative lookahead preventing a left paren from matching.
    local pcre_not_paren_left='(?!'${pcre_paren_left}')'

    # Left paren *NOT* prefixing a syntactic construct, including:
    #
    # * "("- and ")"-delimited list arguments. For disambiguity with "("- and
    #   ")"-delimited glob qualifiers in such arguments, the "(" prefixing such
    #   lists is necessarily suffixed by at least one whitespace character
    #   optionally preceded by line continuations. Prohibiting such character
    #   from matching here thus prohibits such lists from matching here.
    # * "(("- and "))"-delimited arithmetic tests.
    local pcre_paren_left_not_syntactic_prefix=${pcre_paren_left}'(?!'${pcre_paren_left}'|'${pcre_continuable_space}')'

    # ..................{ CHAR ~ paren : right               }..................
    # Right paren.
    local pcre_paren_right='\)'
    local pcre_paren_right_optional=${pcre_paren_right}'?+'

    # Negative lookahead preventing a right paren from matching.
    local pcre_not_paren_right='(?!'${pcre_paren_right}')'

    # Right paren *NOT* suffixed by another right paren and hence *NOT*
    # suffixing a "(("- and "))"-delimited arithmetic test.
    local pcre_paren_right_not_math_suffix=${pcre_paren_right}${pcre_not_paren_right}

    # Right paren *NOT* suffixed by zero or more line continuations followed by
    # one or more whitespace characters and hence *NOT* suffixing a
    # ")"-suffixed syntactic construct.
    local pcre_paren_right_not_syntactic_suffix=${pcre_paren_right}${pcre_not_continuable_space}

    # ..................{ CHAR ~ equals                      }..................
    # Equals sign.
    local pcre_equals='='

    # Equals sign *NOT* followed by a left paren and hence *NOT* prefixing a
    # "=("- and ")"-delimited process substitution.
    local pcre_equals_not_process_substitution_equals_prefix=${pcre_equals}${pcre_not_paren_left}

    # ..................{ CHAR ~ escape                      }..................
    # "\"-prefixed escaped character *OR* syntactically invalid "\" character
    # at the end of the subject string. By matching all escaped characters,
    # this PCRE solves numerous issues commonly related to such characters:
    #
    # * Escaped backslashes (i.e., "\\") must be matched before matching
    #   subsequent escaped characters, as the former effectively disable
    #   escaping (e.g., "\\n", an escaped backslash preceding the character "n"
    #   rather than an escaped newline).
    # * Line continuations (i.e., "\
    #   ") must be matched as insignificant unquoted characters rather than
    #   significant vertical whitespace.
    local pcre_char_escaped_prefix='\\'
    local pcre_char_escaped=${pcre_char_escaped_prefix}'(?>.|'${pcre_reset_remainder_succeed}')'

    # ..................{ SUBROUTINE CALL                    }..................
    # Recursive syntax is matchable *ONLY* via comparatively inefficient
    # subroutine calls, which subsequent PCREs perform *ONLY* if the character
    # at the current match position is a prefix signifying such syntax (e.g.,
    # "$", prefixing any of several different syntactic constructs). Since such
    # subroutines consume such prefixing characters when called, such PCREs
    # non-consumptively detect such characters with positive lookahead. See
    # ${pcre_subroutines_body}.
    #
    # Subroutine calls matching nestable syntactic constructs *MUST* be
    # suffixed by ${pcre_subject_end_succeed_optional}. Since all such
    # constructs may be either syntactically valid or invalid and in the latter
    # case will have erroneously matched all remaining text in the subject
    # string (e.g., due to missing or unbalanced delimiters), the current match
    # point will be at the end of such string on returning from calls matching
    # syntactically invalid constructs. While reporting failure from such match
    # attempt would be preferable, doing so prevents identifying and hence
    # responding to such failure. Rather, success should be reported.

    # Embeddable syntactic construct (i.e., embeddable only in arithmetic
    # substitutions, double-quoted strings, and variable expansions).
    local pcre_embeddable_body='(?&emb)'${pcre_subject_end_succeed_optional}
    local pcre_embeddable='(?=['${char_embeddable_prefix}'])'${pcre_embeddable_body}

    # Embeddable syntactic construct *OR* "\"-prefixed escaped character. For
    # convenience, since the two are *ALWAYS* matched together, this PCRE
    # matches both (in the optimal order).
    local pcre_embeddable_or_char_escaped=${pcre_char_escaped}'|'${pcre_embeddable}

    # ..................{ SUBROUTINE CALL ~ interpretable    }..................
    # Subroutine matching all possible interpretable syntactic constructs
    # without regard for character or word positions.
    #
    # For simplicity, subsequent PCREs all embed this PCRE and hence call the
    # same subroutine gated by positive lookahead constraining such subroutine
    # call to only a subset of such constructs. Since excluded constructs
    # (e.g., "("-prefixed process forks) are comparatively rare *AND* since
    # this subroutine matches such constructs at the end rather than start of
    # its internal list of alternatives, this reuse incurs little to no
    # performance penalties. This is critical, as the alternative of
    # duplicating this subroutine twice incurs substantially worse penalties at
    # PCRE recompilation time (i.e., on sourcing each zeshy script).
    local pcre_sourceable_body='(?&src)'${pcre_subject_end_succeed_optional}

    # Sourceable syntactic construct at the start of the first shell word of a
    # command (i.e., a construct embeddable at such position regardless of
    # syntactic context and hence replaceable by any arbitrary unquoted shell
    # word in arbitrary code).
    local pcre_sourceable_nanoword_start_word_first='(?=['${char_sourceable_nanoword_start_word_first}'])'${pcre_sourceable_body}

    # Sourceable syntactic construct at the start of any shell word *AFTER* the
    # first of a command.
    local pcre_sourceable_nanoword_start_word_rest='(?=['${char_sourceable_nanoword_start_word_rest}'])'${pcre_sourceable_body}

    # Sourceable syntactic construct at any character *AFTER* the start of a
    # shell word of a command.
    local pcre_sourceable_nanoword_rest='(?=['${char_sourceable_nanoword_rest}'])'${pcre_sourceable_body}

    # ..................{ SUBROUTINE CALL ~ passable         }..................
    # Sourceable syntactic construct at the first character of a scalar macro
    # argument.
    local pcre_passable_nanoword_start='(?=['${char_passable_nanoword_start}'])'${pcre_sourceable_body}

    # Sourceable syntactic construct at any character *AFTER* the start of a
    # scalar macro argument.
    local pcre_passable_nanoword_rest='(?=['${char_passable_nanoword_rest}'])'${pcre_sourceable_body}

    # ..................{ COMMENT                            }..................
    # Comment, necessarily prefixed by either one or more horizontal whitespace
    # characters *OR* the start of the current line. The former constraint
    # implies that comments must be explicitly matched *BEFORE* horizontal
    # whitespace when matching possible alternatives. Likewise, the latter
    # constraint implies that line continuations must be explicitly matched
    # *BEFORE* comments when matching possible alternatives.
    #
    # Note that, when prefixed by neither one or more horizontal whitespace
    # characters *NOR* the start of the current line, the octothorpe (i.e.,
    # "#") unconditionally signifies a filename globbing operator. Yeah.
    local pcre_comment_prefix=${pcre_hash}
    local pcre_comment_body=${pcre_chars_sans_space_vertical_optional}
    local pcre_comment=${pcre_hash}${pcre_comment_body}${pcre_line_end}
    local pcre_comment_optional='(?>'${pcre_comment}')?+'

    # One or more whitespace characters followed by an optional comment.
    local pcre_comment_optional_spaced=${pcre_spaces}${pcre_comment_optional}

    # Zero or more whitespace characters followed by an optional comment when
    # preceded by one or more whitespace characters.
    local pcre_comment_spaced_optional=${pcre_spaces_optional}${pcre_comment_optional}

    # ..................{ VARIABLE                           }..................
    # Variable name.
    local pcre_var_name=${ZY_VAR_NAME_PCRE}
    local pcre_var_name_grouped='('${pcre_var_name}')'

    # ..................{ QUOTES                             }..................
    # Single-quoted string supporting escaped single quotes (i.e., "''").
    local pcre_quote_single_escaped=${pcre_quote_single}${pcre_quote_single}
    local pcre_quotes_single_body='(?>[^'${pcre_quote_single}']++|'${pcre_quote_single_escaped}')*+'
    local pcre_quotes_single=${pcre_quote_single}'(?>'${pcre_quotes_single_body}${pcre_quote_single}'|'${pcre_reset_remainder_succeed}')'

    # Double-quoted string supporting escaped double quotes (i.e., '\"').
    # Unlike the prior PCRE, character class [^"] also matches "\" and hence
    # must be matched *AFTER* matching the latter.
    #
    # Since zsh (appears to, at least) parse terminating '"' delimiters in a
    # phase *BEFORE* that of variable expansions, this PCRE can and possibly
    # should avoid matching such expansions here. Since such behaviour is
    # arguably either a bug or undependable implementation detail, however,
    # syntactic constructs embedded in double quotes are matched similarly to
    # syntactic constructs embedded in other syntax (e.g., arithmetic tests).
    local pcre_quotes_double_body='(?>[^'${pcre_quote_double}${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_quotes_double=${pcre_quote_double}'(?>'${pcre_quotes_double_body}${pcre_quote_double}'|'${pcre_reset_remainder_succeed}')'

    # Single- or double-quoted string.
    local pcre_quotes=${pcre_quotes_single}'|'${pcre_quotes_double}

    # "$'"- and "'"-delimited string, excluding such "$". While internally
    # delimited by single quotes, such string strictly adheres to neither
    # single- nor double-quoted string syntax. Rather:
    #
    # * '"' characters are embeddable in such string by "\"-style escaping ala
    #   double-quoted strings, rather than by repeating such single quotes ala
    #   single-quoted strings.
    # * Embedded syntactic constructs are ignored ala single-quoted strings,
    #   rather than expanded in-place ala double-quoted strings.
    local pcre_quotes_dollar_sans_dollar=${pcre_quote_single}${pcre_quotes_single_body}${pcre_quote_single}

    # ..................{ QUOTES ~ literal                   }..................
    # Single-quoted literal string (i.e., single-quoted string *NOT* supporting
    # escaped single quotes "''").
    local pcre_quotes_single_literal_body='[^'${pcre_quote_single}']*+'
    local pcre_quotes_single_literal=${pcre_quote_single}${pcre_quotes_single_literal_body}${pcre_quote_single}
    local pcre_quotes_single_literal_grouped=${pcre_quote_single}'('${pcre_quotes_single_literal_body}')'${pcre_quote_single}

    # Double-quoted literal string (i.e., double-quoted string *NOT* supporting
    # embedded syntactic constructs), thus prohibiting escaped characters,
    # variable expansions, arithmetic substitutions, and process substitutions.
    local pcre_quotes_double_literal_body='[^'${pcre_quote_double}${char_not_embeddable_prefix}']*+'
    local pcre_quotes_double_literal=${pcre_quote_double}${pcre_quotes_double_literal_body}${pcre_quote_double}
    local pcre_quotes_double_literal_grouped=${pcre_quote_double}'('${pcre_quotes_double_literal_body}')'${pcre_quote_double}

    # Single- or double-quoted literal string. Unlike ${pcre_quotes} and
    # similar top-level PCREs, syntactic invalidities (e.g., the absence of
    # suffixing delimiters) are handled by parent PCREs embedding this PCRE.
    # Attempting to handle such invalidities here would obscure their
    # underlying causes -- namely, by:
    #
    # * Conflating syntactically valid non-literal strings (e.g., strings
    #   containing escaped characters) with syntactically invalid literal
    #   strings (i.e., literal strings with *NO* suffixing delimiter).
    # * Preventing parent PCREs from reporting such invalidities at their
    #   prior match positions (e.g., "<<" here-document prefixes).
    local pcre_quotes_literal_grouped='(?|'${pcre_quotes_single_literal_grouped}'|'${pcre_quotes_double_literal_grouped}')'

    # ..................{ TERMINATOR ~ spaced                }..................
    # Command terminators (i.e., substrings terminating the command preceding
    # such terminator and hence preceding macros) requiring both prefixing and
    # suffixing whitespace. Since matching such terminators is required by
    # subsequently declared PCREs *AND* since matching command terminators
    # *NOT* requiring such whitespace requires subsequently declared PCREs
    # matching shell words, PCREs matching the former are declared
    # significantly earlier than PCREs matching the latter.

    #FIXME: Wait. For a truly general implementation, don't we need to join the
    #set of all global alias names... No. Well, possibly? Do all global aliases
    #terminate commands? They don't *NEED* to, of course, but they probably
    #almost certainly do. Hmm; contemplate further. Perhaps we want a new
    #subtype of global alias that when declared adds the name of such alias to
    #a global private list recording the names of all global aliases that also
    #terminate commands -- say, a new :alias_word_command_terminator().
    #Clearly, implement this *LATER*. For now, hard-coding this suffices.

    # zeshy-specific command terminator.
    local pcre_terminator_spacing_zeshy=':(?>or|and|not)'

    # First character following and hence delimiting a zeshy-specific command
    # terminator, non-consumptively matched with positive lookahead. Since any
    # single character invalid in macro names necessarily implies such
    # boundary, this PCRE matches any PCRE- or zsh- reserved character.
    local pcre_terminator_spacing_suffix='(?='${pcre_char_not_macro_name_rest}'|'${pcre_subject_end}')'

    # Command terminator requiring one or more prefixing *AND* one or more
    # suffixing whitespace characters, each optionally interspersed by line
    # continuations. Since this PCRE matches the latter but *NOT* the former,
    # PCREs embedding this PCRE *MUST* match the former.
    #
    # Technically, some such terminators are only prefixable in a syntactically
    # valid manner by horizontal whitespace characters  (e.g., ":and", ":or")
    # and *NOT* repeatable in a syntactically valid manner (e.g., ":or :or").
    # Since macro preprocessing is largely unconcerned with the syntactic
    # validity of non-macros, however, such technicalities are ignorable.
    local pcre_terminator_spacing=${pcre_terminator_spacing_zeshy}${pcre_terminator_spacing_suffix}

    # ..................{ REDIRECTION ~ sourceable           }..................
    # Since redirections are freely interspersable amongst arguments (e.g.,
    # ":the church {of}>the subgenius", where "{of}>the" is a redirection
    # sandwiched between two arguments "church" and "subgenius"), redirections
    # do *NOT* terminate commands and hence are *NOT* command terminators.
    # Since redirection and command terminator syntax frequently overlaps
    # (e.g., the "&"-prefixed redirection "&>" and the three "&"-prefixed
    # command terminators "&", "&!", and "&&"), disambiguating the two requires
    # redirection syntax conflicting with command terminator syntax to be
    # matched. Unfortunately, this includes most redirection syntax:
    #
    # * Standard redirections:
    #   "<",  "<>",  ">",   ">|",  ">!",  ">>",  ">>|", ">>!",  "<&",   ">&",
    #   "&>", ">&|", ">&!", "&>|", "&>!", ">>&", "&>>", ">>&|", ">>&!", "&>>|",
    #   and "&>>!".
    # * Variable name-prefixed redirections (e.g., "{jhvh_1}<'rebel god'").
    # * "<<"-prefixed here-documents and -strings.
    #
    # Digit-prefixed redirections (e.g., "1>&2") do *NOT* require explicit
    # matched. Since such digits are already matched as unquoted shell words
    # and the remainder of such redirections as standard redirections, no
    # further matching is required to disambiguate such redirections from
    # command terminators,
    #
    # Both "<("- and ">("-prefixed process substitution redirections are
    # explicitly prevented from matching here by negative lookahead. See below.
    #
    # See section "REDIRECTION" of "man zshmisc".

    # "<"-prefixed here-document or "<<"-prefixed here-string. The latter
    # prefix greedily overlaps the former prefix and must hence be matched
    # first. Since here-strings are shell words, since subsequent parsing
    # already matches such words, and since syntactically invalid here-strings
    # must also be matched, only such prefix is matched here.
    local pcre_here_prefix='<'
    local pcre_here=${pcre_here_prefix}'(?>'${pcre_here_prefix}'|(?&doc))|'${pcre_reset_remainder_succeed}')'

    # Negative lookahead preventing a "(" character and hence a "<("- or ">("-
    # prefixed process substitution redirection from matching. Since such
    # redirections are recursively nestable and hence matchable only by
    # subroutine calls exceeding the scope of the comparatively simpler PCREs
    # below, such redirections are matched elsewhere as process substitutions
    # rather than here as redirections.
    local pcre_redirect_not_process_substitution='(?!'${pcre_paren_left}')'

    # ">" character *NOT* followed by a "(" character and hence *NOT*
    # signifying a ">("-prefixed process substitution.
    local pcre_redirect_greater_than_char_optional='>?+'${pcre_redirect_not_process_substitution}

    # One ">" character optionally followed by another, neither signifying a
    # ">("-prefixed process substitution.
    local pcre_redirect_greater_than_char_pair='>'${pcre_redirect_greater_than_char_optional}

    # ">"-prefixed redirection.
    local pcre_redirect_greater_than=${pcre_redirect_greater_than_char_pair}'&?+[!|]?+'

    # "<"-prefixed redirection.
    local pcre_redirect_less_than='<(?>'${pcre_here}'|&|'${pcre_redirect_greater_than_char_optional}')'

    # "&"-prefixed redirection.
    local pcre_redirect_ampersand='&'${pcre_redirect_greater_than_char_pair}'[!|]?+'

    # Redirection *AFTER* the start of a shell word of a command in a generic
    # context.
    local pcre_redirect_sourceable_rest=${pcre_redirect_less_than}'|'${pcre_redirect_greater_than}'|'${pcre_redirect_ampersand}

    # "{"- and "}"-delimited variable name, whose leading "{" conflicts with
    # the "{" prefixing command-terminating blocks and hence requires
    # disambiguation. By "man zshmisc" commentary, "No whitespace is allowed
    # between the closing brace and the redirection character."
    local pcre_redirect_var_name='\{'${pcre_var_name}'\}'
    local pcre_redirect_var_name_optional='(?>'${pcre_redirect_var_name}')?+'

    # "<"- or ">"-prefixed redirection. Due to zeshy's usage of "<"-prefixed
    # here- documents for official documentation, the former appears
    # considerably more frequently than the latter and hence is matched first.
    local pcre_redirect_less_or_greater_than='(?>'${pcre_redirect_less_than}'|'${pcre_redirect_greater_than}')'

    # "<"- or ">"-prefixed redirection optionally preceded by a "{"- and
    # "}"-delimited variable name at the start of a shell word. Since
    # "&"-prefixed redirections are shorthand signifying both standard output
    # and input and hence accept no prefixing variable name, such redirections
    # are matched separately.
    local pcre_redirect_sourceable_start_less_or_greater=${pcre_redirect_var_name_optional}${pcre_redirect_less_or_greater_than}

    # Redirection at the start of any shell word of a command in a generic
    # context.
    local pcre_redirect_sourceable_start=${pcre_redirect_sourceable_start_less_or_greater}'|'${pcre_redirect_ampersand}

    # ..................{ REDIRECTION ~ conditional          }..................
    # Macro argument matching *MUST* halt at the first character signifying a
    # redirection. Technically, zsh permits redirections to be arbitrarily
    # interspersed with arguments passed to conventional builtins, commands,
    # and functions: e.g.,
    #
    #    >>> function :flint_michigan() { print "${@}" }
    #    >>> :flint_michigan 1<&2 =(print gary_indiana) oakland_california
    #    /tmp/zsh3lpV1a oakland_california
    #
    # Permitting redirections to be arbitrarily interspersed with macro
    # arguments makes comparatively less sense. Even where sensible, permitting
    # such edge cases would require preprocessing to shift all such
    # redirections to the end of their respective macro expansions. While
    # performing such shift is trivial, matching and then capturing such
    # redirections in a manner enabling such shifting is highly non-trivial.
    #
    # Consider matching. While matching redirection prefixes is trivial,
    # matching the shell words accepted as arguments by most redirections is
    # highly non-trivial. To avoid erroneously matching adjacent redirection
    # prefixes as a complete redirection (e.g., "&>&>"), such words *MUST* be
    # consumed in a redirection-specific manner prohibiting such adjacency.
    #
    # Consider capturing. To notify the preprocessor of the byte indices of
    # captured redirections, ${ZY__PREPROCESS_PCRE} must also:
    #
    # 1. Capture the substrings of such macro preceding and following each such
    #    redirection. Presumably, this would be non-trivial to design.
    # 2. Capture the remainder of the entire subject string following each such
    #    redirection with positive lookahead. Presumably, this would be trivial
    #    to design but non-negligibly inefficient to perform.
    #
    # While properly handling redirections intermingled in macro arguments is
    # feasible, it's hardly clear that any production code would ever require
    # such edge-case functionality. Given such constraints, redirections must
    # currently suffix (rather than be interspersed with) macro arguments.
    #
    # The following PCREs enforce such restriction.

    # Negative lookahead preventing either a "<"- or ">"-prefixed redirection
    # from matching.
    local pcre_not_redirect_less_or_greater_than='(?!'${pcre_redirect_less_or_greater_than}')'

    # Shortest substring at the start of a scalar macro argument conditionally
    # signifying a redirection. "<" and ">" characters *ALWAYS* unconditionally
    # signify redirections and hence are excluded.
    local pcre_redirect_prefix_conditional='(?>[0-9&]|'${pcre_redirect_var_name}')'

    # Shortest substring at the start of a scalar macro argument conditionally
    # signifying a redirection but *NOT* actually doing so.
    local pcre_redirect_prefix_conditional_not_redirect=${pcre_redirect_prefix_conditional}${pcre_not_redirect_less_or_greater_than}

    # ..................{ LITERAL ~ sourceable               }..................
    # Negative lookahead preventing substrings that would otherwise be matched
    # as unquoted characters from being matched as such. By PCRE design, most
    # command terminators (e.g., "<") are already excluded from unquoted shell
    # words and hence need *NOT* be matched here. Instead, this matches:
    #
    # * zeshy-specific command terminators (e.g., ":not") implemented as and
    #   hence intended to be expanded as global aliases. Usefully, since zsh
    #   expands global aliases in ":is"- and "[["-prefixed tests, preventing
    #   unquoted shell words from containing such aliases implicitly avoids
    #   such conflict. Tests need *NOT* be explicitly matched elsewhere.
    #
    # Notably, this PCRE does *NOT* match redirections technically conflicting
    # with unquoted shell word syntax (e.g., "1>&2", in which such "1" will be
    # erroneously matched as an unquoted shell word). Since redirections and
    # unquoted shell words are matched principally for disambiguation, these
    # technicalities are typically ignorable. Note that redirections prefixed
    # by "{"- and "}"-delimited variable name file descriptors remain prefixed
    # by "{" and hence already prevented from matching such words.
    local pcre_literal_sourceable_lookahead='(?!='${pcre_terminator_spacing}')'

    # Unquoted character at the start of the first such word of a command in a
    # general context.
    local pcre_literal_sourceable_start_word_first=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_sourceable_start_word_first}']|'${pcre_equals_not_process_substitution_equals_prefix}

    # Unquoted character at the start of any such word *AFTER* the first of a
    # command in a general context.
    local pcre_literal_sourceable_start_word_rest=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_sourceable_start_word_rest}']|'${pcre_equals_not_process_substitution_equals_prefix}

    # One or more unquoted characters *AFTER* the start of any such word of a
    # command in a general context, including characters technically invalid at
    # the end of such words (i.e., "}" block suffixes). For efficiency, most
    # subsequent word types treat such suffixes as valid at the end of such
    # words and hence require no distinction between characters valid at the
    # middle and end of such words.
    local pcre_literals_sourceable_rest='[^'${char_not_literal_sourceable_rest}']++'

    # ..................{ LITERAL ~ backtickable             }..................
    # Unquoted character at the start of the first shell word of a command in a
    # "`"-delimited process substitution.
    local pcre_literal_backtickable_start_word_first=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_backtickable_start_word_first}']'

    # Unquoted character at the start of any shell word *AFTER* the first of a
    # command in a "`"-delimited process substitution.
    local pcre_literal_backtickable_start_word_rest=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_backtickable_start_word_rest}']'

    # One or more unquoted characters *AFTER* the start of any shell word of a
    # command in a "`"-delimited process substitution.
    local pcre_literals_backtickable_rest='[^'${char_not_literal_backtickable_rest}']++'

    # ..................{ LITERAL ~ blockable                }..................
    # Unquoted character at the start of the first shell word of a command in a
    # block.
    local pcre_literal_blockable_start_word_first=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_blockable_start_word_first}']|'${pcre_brace_right_not_block_suffix}

    # Unquoted character at the start of any shell word *AFTER* the first of a
    # command in a block.
    local pcre_literal_blockable_start_word_rest=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_blockable_start_word_rest}']|'${pcre_brace_right_not_block_suffix}

    # One or more unquoted characters *AFTER* the start of any such word of a
    # command in a block.
    local pcre_literals_blockable_rest='[^'${char_not_literal_blockable_rest}']++|'${pcre_brace_right_not_block_suffix}

    # ..................{ LITERAL ~ braceable                }..................
    # Brace expansion, whose delimiters conflict with block delimiters and
    # hence require disambiguation. Technically, such expansion prohibits
    # UTF-8-encoded characters. For simplicity, subsequent PCREs ignore such
    # technicality by matching both ASCII and UTF-8-encoded characters.
    # Likewise, since the syntactic structure of such expansions dynamically
    # depends on shell option "brace_ccl" *AND* since such structure is
    # irrelevant to such disambiguation, such PCREs ignore structure.

    # ONe or more characters in a brace expansion.
    local pcre_literal_braceable='[^'${char_not_literal_braceable}']'

    # ONe or more characters in a brace expansion.
    local pcre_literals_braceable=${pcre_literal_braceable}'++'

    # Zero or more characters in a brace expansion.
    local pcre_literals_braceable_optional=${pcre_literal_braceable}'*+'

    # ..................{ LITERAL ~ parenable                }..................
    # Unquoted character at the start of any such word of a command in a
    # paren-delimited syntactic construct.
    local pcre_literal_parenable_start=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_parenable_start}']'

    # One or more unquoted characters *AFTER* the start of any such word of a
    # command in a paren-delimited syntactic construct.
    local pcre_literals_parenable_rest='[^'${char_not_literal_parenable_rest}']++'

    # ..................{ LITERAL ~ passable                 }..................
    # Conditional syntactic suffix (i.e., delimiter suffixing syntactic
    # constructs under certain contexts) prevented from being erroneously
    # matched as such a suffix at any position of a scalar macro argument.
    #
    # This prevents both the "}" suffixing blocks and the ")" suffixing process
    # forks and substitutions from being matched as scalar macro arguments,
    # thereby halting macro argument and hence macro matching (but *NOT*
    # top-level matching in general) on the first such character.
    local pcre_literal_passable_core=${pcre_brace_right_not_block_suffix}'|'${pcre_paren_right_not_syntactic_suffix}

    # Unquoted character at the start of a scalar macro argument. Since
    # "("-prefixed list arguments, "(("-prefixed arithmetic tests, and
    # "[["-prefixed non-arithmetic tests are subsequently matched as
    # zeshy-specific macro arguments, such arguments are prevented from
    # erroneously matching as scalar macro arguments.
    local pcre_literal_passable_start=${pcre_literal_sourceable_lookahead}'[^'${char_not_literal_passable_start}']|'${pcre_paren_left_not_syntactic_prefix}'|'${pcre_bracket_left_not_test_prefix}'|'${pcre_redirect_prefix_conditional_not_redirect}'|'${pcre_literal_passable_core}

    # One or more unquoted characters *AFTER* the start of a scalar macro
    # argument.
    local pcre_literals_passable_rest='[^'${char_not_literal_passable_rest}']++|'${pcre_literal_passable_core}

    # ..................{ LITERAL ~ scalarable               }..................
    # Unquoted character at the start of a shell word in a scalar variable
    # assignment. Since such words do *NOT* participate in conventional command
    # syntax, global aliases and hence zeshy-specific command terminators are
    # matched as raw literals rather than as syntactic constructs. Unlike most
    # other such PCREs, this PCRE is thus *NOT* prefixed by
    # ${pcre_literal_sourceable_lookahead}.
    local pcre_literal_scalarable_start='[^'${char_not_literal_scalarable_start}']'

    # One or more unquoted characters *AFTER* the start of a shell word in a
    # scalar variable assignment.
    local pcre_literals_scalarable_rest='[^'${char_not_literal_scalarable_rest}']++'

    # ..................{ LITERAL ~ nonscalarable            }..................
    # Unquoted character at the start of a shell word in a nonscalar variable
    # assignment. As for scalar variable assignments, such words do *NOT*
    # participate in conventional command syntax and hence are *NOT* prefixed
    # by ${pcre_literal_sourceable_lookahead}.
    local pcre_literal_nonscalarable_start='[^'${char_not_literal_nonscalarable_start}']'

    # One or more unquoted characters *AFTER* the start of a shell word in a
    # nonscalar variable assignment.
    local pcre_literals_nonscalarable_rest='[^'${char_not_literal_nonscalarable_rest}']++'

    # ..................{ LITERAL ~ unquoted                 }..................
    # Unquoted character at the start of an unquoted shell word.
    local pcre_literal_unquoted_start='[^'${char_not_literal_unquoted_start}']'

    # One or more unquoted characters *AFTER* the start of an unquoted shell
    # word.
    local pcre_literals_unquoted_rest='[^'${char_not_literal_unquoted_rest}']++'

    # ..................{ PICOWORD ~ universal               }..................
    # Smallest syntactic component universally applicable to *ALL* syntactic
    # contexts and hence omitting redirections, which scalar macro arguments
    # prohibit.
    local pcre_picoword_universal=${pcre_char_escaped}'|'${pcre_quotes}

    # ..................{ BRACE EXPANSION                    }..................
    #FIXME: Hmm; does omitting redirections imply that we cannot currently
    #match shell words resembling "ok{uh<oh}ko" in a general context? While
    #prohibiting redirections is required in scalar macro arguments, such
    #syntax should be matched in all other contexts.

    # Syntactic component in a brace expansion.
    local pcre_nanoword_braceable=${pcre_literals_braceable_optional}'|'${pcre_picoword_universal}'|'${pcre_sourceable_nanoword_rest}

    # One or more syntactic components in a brace expansion.
    local pcre_nanowords_braceable='(?>'${pcre_nanoword_braceable}')++'

    # Zero or more syntactic components in a brace expansion.
    local pcre_nanowords_braceable_optional='(?>'${pcre_nanoword_braceable}')*+'

    # "{"- and "}"-delimited brace expansion at the start of any shell word
    # *AFTER* the first of a command. Since "{" characters at the start of the
    # first shell word of a command *ALWAYS* constitute block prefixes, such
    # matching applies only to subsequent words.
    #
    # Note that matching in this manner prevents matching of macros accepting
    # no arguments situated in command position of "{"- and "}"-delimited
    # blocks whose "{" delimiter is unsuffixed by whitespace and whose "}"
    # delimiter is unprefixed by whitespace (e.g., "{:gunnm}"). While mildly
    # unfortunate, the alternative is worse (namely, erroneously expanding
    # macro-like substrings in brace expansions).
    local pcre_braceable_start_word_rest=${pcre_brace_left}${pcre_nanowords_braceable_optional}${pcre_brace_right}

    # "{"- and "}"-delimited brace expansion *OR* "{" character balanced by no
    # subsequent "}" character *AFTER* the start of a shell word of a command.
    # In the latter case, such character does *NOT* prefix such word and hence
    # cannot be a block prefix; implying such character to be a literal
    # conflicting with no other matching.
    local pcre_braceable_rest=${pcre_brace_left}${pcre_nanowords_braceable_optional}${pcre_brace_right_optional}

    # ..................{ PICOWORD ~ sourceable              }..................
    # Smallest syntactic component at the start of the first shell word of a
    # command in a general context. "{"- and "}"-delimited brace expansions are
    # prohibited at such position and hence omitted here.
    local pcre_picoword_sourceable_start_word_first=${pcre_picoword_universal}'|'${pcre_redirect_sourceable_start}

    # Smallest syntactic component at the start of any shell word *AFTER* the
    # first of a command in a general context. Since "{"-prefixed redirections
    # take precedence over "{"-prefixed brace expansions, redirections are
    # matched before the latter.
    local pcre_picoword_sourceable_start_word_rest=${pcre_picoword_universal}'|'${pcre_redirect_sourceable_start}'|'${pcre_braceable_start_word_rest}

    # Smallest syntactic component *AFTER* the start of any shell word of a
    # command in a general-purpose context.
    local pcre_picoword_sourceable_rest=${pcre_picoword_universal}'|'${pcre_redirect_sourceable_rest}'|'${pcre_braceable_rest}

    # ..................{ PICOWORD ~ assignable              }..................
    # Smallest syntactic component at the start of a variable assignment. Brace
    # expansions are ignored in such contexts and hence omitted both here and
    # below. Redirections constitute invalid syntax in such contexts but are
    # nonetheless matched for disambiguation with command terminators whose
    # syntax overlaps that of redirections (e.g., "&").
    local pcre_picoword_assignable_start=${pcre_picoword_universal}'|'${pcre_redirect_sourceable_start}

    # Smallest syntactic component *AFTER* the start of a variable assignment.
    local pcre_picoword_assignable_rest=${pcre_picoword_universal}'|'${pcre_redirect_sourceable_rest}

    # ..................{ PICOWORD ~ passable                }..................
    # Smallest syntactic component at the start of a scalar macro argument.
    local pcre_picoword_passable_start=${pcre_picoword_universal}'|'${pcre_braceable_start_word_rest}

    # Smallest syntactic component *AFTER* the start of a scalar macro
    # argument.
    local pcre_picoword_passable_rest=${pcre_picoword_universal}'|'${pcre_braceable_rest}

    # ..................{ NANOWORD ~ backtickable            }..................
    # Syntactic component at the start of the first shell word of a command in
    # a "`"-delimited process substitution.
    local pcre_nanoword_backtickable_start_word_first=${pcre_literal_backtickable_start_word_first}'|'${pcre_picoword_sourceable_start_word_first}'|'${pcre_sourceable_nanoword_start_word_first}

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command in a "`"-delimited process substitution.
    local pcre_nanoword_backtickable_start_word_rest=${pcre_literal_backtickable_start_word_rest}'|'${pcre_picoword_sourceable_start_word_rest}'|'${pcre_sourceable_nanoword_start_word_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command in a "`"-delimited process substitution.
    local pcre_nanowords_backtickable_rest_optional='(?>'${pcre_literals_backtickable_rest}'|'${pcre_picoword_sourceable_rest}'|'${pcre_sourceable_nanoword_rest}')*+'

    # ..................{ NANOWORD ~ parenable               }..................
    # Syntactic component at the start of the first shell word of a command in
    # a paren-delimited syntactic construct.
    local pcre_nanoword_parenable_start_word_first=${pcre_literal_parenable_start}'|'${pcre_picoword_sourceable_start_word_first}'|'${pcre_sourceable_nanoword_start_word_first}

    # Syntactic component at the start of any shell word *AFTER* the first of a
    # command in a paren-delimited syntactic construct.
    local pcre_nanoword_parenable_start_word_rest=${pcre_literal_parenable_start}'|'${pcre_picoword_sourceable_start_word_rest}'|'${pcre_sourceable_nanoword_start_word_rest}

    # Syntactic component *AFTER* the start of a shell word of a command in a
    # paren-delimited syntactic construct.
    local pcre_nanoword_parenable_rest=${pcre_literals_parenable_rest}'|'${pcre_picoword_sourceable_rest}'|'${pcre_sourceable_nanoword_rest}

    # ..................{ NANOWORD ~ passable                }..................
    # Syntactic component at the start of a scalar macro argument.
    local pcre_nanoword_passable_start=${pcre_literal_passable_start}'|'${pcre_picoword_passable_start}'|'${pcre_passable_nanoword_start}

    # Syntactic component *AFTER* the start of a scalar macro argument.
    local pcre_nanoword_passable_rest=${pcre_literals_passable_rest}'|'${pcre_picoword_passable_rest}'|'${pcre_passable_nanoword_rest}

    # ..................{ NANOWORD ~ scalarable              }..................
    # Syntactic component at the start of a shell word of a scalar variable
    # assignment. To ensure proper matching of assignment boundaries,
    # "`"-delimited process substitutions are matched (by embedding
    # ${pcre_passable_nanoword_start}).
    local pcre_nanoword_scalarable_start=${pcre_literal_scalarable_start}'|'${pcre_picoword_assignable_start}'|'${pcre_passable_nanoword_start}

    # Syntactic component *AFTER* the start of a shell word of a scalar
    # variable assignment.
    local pcre_nanoword_scalarable_rest=${pcre_literals_scalarable_rest}'|'${pcre_picoword_assignable_rest}'|'${pcre_passable_nanoword_rest}

    # ..................{ NANOWORD ~ nonscalarable           }..................
    # Syntactic component at the start of a nonscalar item in a nonscalar
    # variable assignment. (See above for commentary.)
    local pcre_nanoword_nonscalarable_start=${pcre_literal_nonscalarable_start}'|'${pcre_picoword_assignable_start}'|'${pcre_passable_nanoword_start}

    # Syntactic component *AFTER* the start of a nonscalar item in a nonscalar
    # variable assignment. (See above for commentary.)
    local pcre_nanoword_nonscalarable_rest=${pcre_literals_nonscalarable_rest}'|'${pcre_picoword_assignable_rest}'|'${pcre_passable_nanoword_rest}

    # ..................{ GLOB                               }..................
    #FIXME: *UGH*. Guess what? While "("- and ")"-delimited glob qualifiers are
    #*NOT* recursively nestable, the more general-purpose "("- and
    #")"-delimited glob expressions *ARE*. Which means that we'll need to
    #substantially generalize away from the former to the latter. Specifically,
    #we'll need to:
    #
    #* Define one new subroutine for each type of word embeddable in such
    #  expression.
    #* Call the subroutine for the current type of word after matching the
    #  first "(" in such word.
    #* Since an unbalanced "(" in a word effectively constitutes invalid syntax
    #  (regardless of whether zsh strictly interprets unbalanced "(" characters
    #  as such), ${pcre_reset_remainder_succeed} should be leveraged as well.
    #* Note that we currently match ")" delimiters in an optional manner,
    #  presumably for generality. We'll need to change that to match both "("
    #  and ")" delimiters in a strictly balanced manner, in keeping with the
    #  prior item. Note that such strictness is absolutely required for proper
    #  matching elsewhere -- notably, to match the ")" delimiting case
    #  statement patterns from the first commands to be run for such patterns,
    #  Such patterns need *NOT* be delimited from such commands with
    #  whitespace! (See below for a crazy example of this.) Since the
    #  delimiting ")" is the only means of differentiating the two, parens in
    #  glob qualifiers *MUST* be matched in a strictly balanced manner.
    #
    #Since there are only two or three places where we're required to match
    #globs, this shouldn't be *TOO* terrible -- merely unctuous.

    # Glob qualifier prefix.
    local pcre_qualifier_prefix=${pcre_paren_left}

    # Glob qualifier suffix.
    local pcre_qualifier_suffix=${pcre_paren_right_optional}

    # ..................{ ASSIGNMENT ~ nonscalar             }..................
    # "("- and ")"-delimited glob qualifier in a shell word in a nonscalar
    # variable assignment, whose ")" suffix conflicts with that of such
    # variable assignment and hence requires disambiguation. Such qualifiers
    # are non-nestable and hence matchable without recursion, but *CAN* nest
    # other syntactic constructs (e.g., single-quoted strings).
    local pcre_qualifier_nonscalarable=${pcre_qualifier_prefix}'(?>'${pcre_nanoword_nonscalarable_rest}')*+'${pcre_qualifier_suffix}

    # Shell word in a nonscalar variable assignment, whose syntax fundamentally
    # conflicts with conventional command syntax and hence requires
    # disambiguation. Specifically:
    #
    # * Vertical whitespace characters merely delimit shell words, rather than
    #   terminating commands as in most other syntactic contexts.
    # * Comments are matched as such, rather than as raw literals as in
    #   embeddable syntactic contexts (e.g., variable expansions).
    # * When prefixing shell words, "(" characters unconditionally signify glob
    #   qualifiers, rather than conditionally signifying "("-prefixed syntactic
    #   constructs (e.g., arithmetic substitutions) when such words are in
    #   command position. Naturally, this stems from the fact that there *IS*
    #   no command position in such assignments.
    # * The ")" suffixing such assignments conflicts with the ")" suffixing
    #   ")"-delimited syntactic constructs (e.g., process forks).
    local pcre_word_nonscalarable='(?>'${pcre_nanoword_nonscalarable_start}'|'${pcre_qualifier_nonscalarable}')(?>'${pcre_nanoword_nonscalarable_rest}'|'${pcre_qualifier_nonscalarable}')*+'
    local pcre_word_nonscalarable_optional='(?>'${pcre_word_nonscalarable}')?+'

    # Zero or more shell words in a nonscalar variable assignment.
    local pcre_words_nonscalarable_optional='(?>'${pcre_word_nonscalarable}'(?>'${pcre_comment_optional_spaced}${pcre_word_nonscalarable}')*+)?+'

    # "("-and ")"-delimited nonscalar variable value (e.g., list, map).
    local pcre_nonscalar_body=${pcre_comment_spaced_optional}${pcre_words_nonscalarable_optional}${pcre_comment_spaced_optional}
    local pcre_nonscalar=${pcre_paren_left}'(?>'${pcre_nonscalar_body}${pcre_paren_right}'|'${pcre_reset_remainder_succeed}')'
    local pcre_nonscalar_grouped='('${pcre_nonscalar}')'

    # ..................{ ASSIGNMENT ~ scalar                }..................
    # Shell word in a scalar variable assignment. Since such assignments are
    # neither prefixed nor suffixed by parens and hence do *NOT* conflict with
    # parens-delimited glob qualifiers, glob qualifiers in such words are
    # simply matched as raw literals.
    local pcre_word_scalarable='(?>'${pcre_nanoword_scalarable_start}')(?>'${pcre_nanoword_scalarable_rest}')*+'
    local pcre_word_scalarable_optional='(?>'${pcre_word_scalarable}')?+'

    # The first shell word of a scalar variable assignment.
    local pcre_word_scalarable_first=${pcre_word_scalarable}
    local pcre_word_scalarable_first_optional=${pcre_word_scalarable_first}'?+'
    local pcre_word_scalarable_first_grouped='('${pcre_word_scalarable_first}')'

    # Zero or more shell words *AFTER* the first such word of a scalar variable
    # assignment, each prefixed by one or more horizontal whitespace characters
    # optionally interspersed by line continuations.
    local pcre_words_scalarable_rest_opotional='(?>'${pcre_continuable_spaces_horizontal}${pcre_word_scalarable}')*+'
    local pcre_words_scalarable_rest_opotional_grouped='('${pcre_words_scalarable_rest_opotional}')'

    # Scalar variable assignment value, comprising zero or more shell words.
    # Curiously, vanilla zsh parses the first such character in such assignment
    # as a command terminator: e.g.,
    #
    #     >>> :str mario_savio; mario_savio= sit-in address at sproul hall
    #     Command "sit-in" not found.
    #     >>> :str mario_savio; mario_savio=sit-in address at sproul hall
    #     Command "address" not found.
    #
    # Since such behaviour appears to be undocumented and in any case is highly
    # non-orthogonal with standard parsing conventions in the remainder of the
    # zsh language, the preprocessor quote-protects all horizontal whitespace
    # characters in such assignments *BEFORE* feeding zsh the result. For
    # simplicity, the first shell word and all remaining shell words of such
    # assignment are captured into two new match groups.
    local pcre_assignment_value_scalarable='(?>'${pcre_word_scalarable_first}${pcre_words_scalarable_rest_opotional}')?+'
    local pcre_assignment_value_scalarable_grouped='(?>'${pcre_word_scalarable_first_grouped}${pcre_words_scalarable_rest_opotional_grouped}')?+'

    # ..................{ ASSIGNMENT ~ value                 }..................
    # Variable assignment operator, comprising either:
    #
    # * "=", signifying an assignment operation.
    # * "+=", signifying an appending operation.
    local pcre_assignment_operator=${pcre_plus_optional}${pcre_equals}
    local pcre_assignment_operator_grouped='('${pcre_assignment_operator}')'

    # Variable assignment value, captured to the same match group regardless of
    # type. Since the "(" prefixing nonscalar variable assignments takes
    # precedence over the otherwise valid "(" character in scalar variable
    # assignments, the former is matched before the latter.
    local pcre_assignment_value='(?>'${pcre_nonscalar}'|'${pcre_assignment_value_scalarable}')'
    local pcre_assignment_value_grouped='(?>'${pcre_nonscalar_grouped}'|'${pcre_assignment_value_scalarable_grouped}')'

    #FIXME: Embed below.

    # zsh-specific "=("-prefixed list assignment, prohibiting whitespace
    # between such "=" and "(" characters. (For the pedantic, we intentionally
    # prefer the terms "nonscalar" and "unspace" throughout this parcel,
    # leading to this admittedly awkward variable name.)
    local pcre_assignment_operator_value_nonscalarable_unspaceable=${pcre_assignment_operator}${pcre_nonscalar}

    # "=("-prefixed list assignment with zero or more horizontal whitespace
    # characters optionally interspersed by line continuations both preceding
    # and following such "=".
    local pcre_assignment_operator_value_nonscalarable_spaceable=${pcre_assignment_operator}${pcre_continuable_spaces_horizontal_optional}${pcre_nonscalar}

    # "="-prefixed variable assignment with zero or more horizontal whitespace
    # characters optionally interspersed by line continuations both preceding
    # and following such "=". For preprocessor efficiency *AND* simplicity,
    # such substrings are captured into distinct match groups. To avoid
    # backtracking in the common case of commands whose names match variable
    # name syntax but are *NOT* variable assignments, prefixing whitespace is
    # matched elsewhere.
    local pcre_assignment_operator_value_spaceable=${pcre_assignment_operator}${pcre_continuable_spaces_horizontal_optional}${pcre_assignment_value}
    local pcre_assignment_operator_value_spaceable_grouped=${pcre_assignment_operator_grouped}${pcre_continuable_spaces_horizontal_optional_grouped}${pcre_assignment_value_grouped}

    # ..................{ KEYWORD ~ value                    }..................
    # Macro keyword argument operator. Unlike variable assignments, keyword
    # arguments do *NOT* exist prior to the macro calls passing such arguments
    # and hence cannot reasonably be appended to. Operator "+=" supported by
    # variable assignments is *NOT* supported here.
    local pcre_keyword_operator=${pcre_equals}
    local pcre_keyword_operator_grouped='('${pcre_keyword_operator}')'

    # Macro scalar keyword argument value. Since scalar variable assignments
    # are commands, the values of such assignments accept one or more shell
    # words. Conversely, since macro arguments are delimited by mandatory
    # horizontal whitespace, the values of scalar keyword arguments accept
    # only one shell words. (Attempting to accept two or more shell words would
    # prevent such arguments from being followed by non-keyword arguments).
    local pcre_keyword_value_scalarable=${pcre_word_scalarable_first_optional}

    # Macro keyword argument value.
    local pcre_keyword_value_grouped='(?'${pcre_nonscalar}'|'${pcre_keyword_value_scalarable}')'

    # "="-prefixed macro keyword argument with zero or more horizontal
    # whitespace characters optionally interspersed by line continuations both
    # preceding and following such "=".
    local pcre_keyword_operator_value_spaceable_grouped=${pcre_keyword_operator_grouped}${pcre_continuable_spaces_horizontal_optional_grouped}${pcre_keyword_value_grouped}
    local pcre_keyword_operator_value_spaceable_optional_grouped='(?>'${pcre_keyword_operator_value_spaceable_grouped}')?+'

    # ..................{ WORD ~ backtickable                }..................
    # First shell word of a command in a "`"-delimited process substitution.
    # List assignments are irrelevant to such matching and hence omitted.
    local pcre_word_backtickable_first='(?>'${pcre_nanoword_backtickable_start_word_first}')'${pcre_nanowords_backtickable_rest_optional}

    # Any shell word *AFTER* the first of a command in a "`"-delimited process
    # substitution.
    local pcre_word_backtickable_rest='(?>'${pcre_nanoword_backtickable_start_word_rest}')'${pcre_nanowords_backtickable_rest_optional}
    local pcre_word_backtickable_rest_optional='(?>'${pcre_word_backtickable_rest}')?+'

    # Zero or more shell words in a "`"-delimited process substitution,
    # delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    local pcre_words_backtickable_optional='(?>'${pcre_word_backtickable_first}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_backtickable_rest_optional}')*+)?+'

    # ..................{ WORD ~ parenable                   }..................
    # "("- and ")"-delimited glob qualifier in a parens-delimited syntactic
    # construct.
    local pcre_qualifier_parenable=${pcre_qualifier_prefix}'(?>'${pcre_nanoword_parenable_rest}')'${pcre_qualifier_suffix}

    # Zero or more syntactic components *AFTER* the start of a shell word in a
    # parens-delimited syntactic construct.
    local pcre_nanowords_parenable_rest_optional='(?>'${pcre_nanoword_parenable_rest}'|'${pcre_qualifier_parenable}')*+'

    # Shell word *AFTER* the first such word of a command in a parens-delimited
    # syntactic construct.
    local pcre_word_parenable_rest='(?>'${pcre_nanoword_parenable_start_word_rest}'|'${pcre_qualifier_parenable}')'${pcre_nanowords_parenable_rest_optional}
    local pcre_word_parenable_rest_optional='(?>'${pcre_word_parenable_rest}')?+'

    # First shell word of a command in a parens-delimited syntactic construct.
    # While the ")" suffixing list assignments conflicts with the ")" suffixing
    # such construct, list assignments are matched elsewhere in a generic
    # manner applicable to *ALL* syntactic contexts.
    local pcre_word_parenable_first='(?>'${pcre_nanoword_parenable_start_word_first}')'${pcre_nanowords_parenable_rest_optional}

    # Zero or more shell words permitting matching of strictly balanced parens,
    # each delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    local pcre_words_parenable_optional='(?>'${pcre_word_parenable_first}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_parenable_rest_optional}')*+)?+'

    # ..................{ WORD ~ passable                    }..................
    # "("- and ")"-delimited glob qualifier in a scalar macro argument.
    local pcre_qualifier_passable=${pcre_qualifier_prefix}'(?>'${pcre_nanoword_passable_rest}')*+'${pcre_qualifier_suffix}

    # Zero or more syntactic components *AFTER* the start of a scalar macro
    # argument.
    local pcre_nanowords_passable_rest_optional='(?>'${pcre_nanoword_passable_rest}'|'${pcre_qualifier_passable}')*+'
    local pcre_nanowords_passable_rest_optional_grouped='('${pcre_nanowords_passable_rest_optional}')'

    # Scalar macro argument.
    local pcre_word_passable='(?>'${pcre_nanoword_passable_start}'|'${pcre_qualifier_passable}')(?>'${pcre_nanoword_passable_rest}'|'${pcre_qualifier_passable}')*+'
    local pcre_word_passable_optional='(?>'${pcre_word_passable}')?+'

    # One or more scalar macro arguments, preceded by one or more horizontal
    # whitespace characters optionally interspersed by line continuations.
    # ${pcre_word_passable} matches escaped characters and hence line
    # continuations, implying the whitespace preceding such PCRE to be more
    # efficiently matchable with ${pcre_spaces_horizontal_continuable} than
    # ${pcre_continuable_spaces_horizontal}. However, embedding the former
    # prevents one or more initial line continuations from matching, requiring
    # explicit matching of such continuations here. (Phew!)
    local pcre_words_passable_spaced=${pcre_continuations_optional}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_passable}')++'

    # ..................{ WORD ~ unquoted                    }..................
    # Unquoted shell word.
    local pcre_word_unquoted=${pcre_literal_unquoted_start}${pcre_literals_unquoted_rest}
    local pcre_word_unquoted_grouped='('${pcre_word_unquoted}')'

    # ..................{ TERMINATOR ~ unspacing             }..................
    # PCREs below match "unspacing" command terminators (i.e., command
    # terminators requiring no prefixing or suffixing whitespace).

    # End of the subject string, capturing the last character of such string to
    # differentiate syntactically invalid from valid subject strings. In the
    # former case, the corresponding capture group will be absent.
    local pcre_terminator_string_end=${pcre_subject_end_succeed}

    # "&"-prefixed command terminator, including:
    #
    # * "&" and "&!", backgrounding the current process.
    # * "&&", a boolean AND command operator.
    #
    # Since redirections do *NOT* terminate commands, this PCRE excludes both
    # "&<"- and "&>"-formatted redirections.
    local pcre_terminator_ampersand='&[&!]?+'

    # "|"-prefixed command terminator, comprising a:
    #
    # * "|" or "|&" pipe.
    # * "||" boolean OR operator.
    local pcre_terminator_pipe='\|[|&]?+'

    # ..................{ TERMINATOR ~ unspacing : case      }..................
    #FIXME: *UGH*. We clearly dropped the ball here. There exists no
    #${pcre_word_backtickable} -- but even if there did, that wouldn't be what
    #we want at all. We want to match a glob pattern comprising a single shell
    #word possibly containing "`"-delimited process substitutions. By design,
    #${pcre_word_backtickable*} PCRES do *NOT* contain such substitutions; they
    #are only embedded in such substitutions.
    #
    #The only PCRE that appears to contain "`"-delimited process substitutions
    #is ${pcre_word_passable}. Unfortunately, ${pcre_literal_passable_start}
    #prevents matching of substrings that we *REALLY* want to permit in
    #patterns (e.g., "[[", a valid substring of a valid example glob "[[]").
    #Hence, we'll need to define a new series of PCREs.
    #
    #Yeah. That sucks. But it appears inescapable. How about
    #${pcre_word_patternable}? Since ${pcre_word_passable} is more restrictive
    #(i.e., specific) than ${pcre_word_patternable}, the former should probably
    #be redefined in terms of the latter.
    #
    #Note that, like ${pcre_word_passable}, ${pcre_word_patternable} will need
    #to match parens in a balanced manner. The existing glob qualifier PCREs
    #should suffice for that, even though glob parens are *NOT* technically
    #qualifiers. Who cares, right? *shrug*
    #FIXME: O.K.; as a temporary measure just to get this parcel compilable
    #again, we've switched ${pcre_word_backtickable} for ${pcre_word_passable}
    #below. That said, we'll want to switch ${pcre_word_passable} for
    #${pcre_word_patternable} when we've got the latter implemented.

    # ")"-suffixed case statement pattern word. While such words are
    # optionally prefixed by a corresponding "(" delimiter, such delimiter is
    # already implicitly matched. For correctness, *ALL* syntactic constructs
    # (including typically ignored "`"-delimited process substitutions) are
    # matched in such word.
    local pcre_terminator_case_pattern_word=${pcre_word_passable}${pcre_paren_right}

    #FIXME: Yikes! It would appear, unfortunately, that zsh does *NOT* require
    #case patterns to be followed by whitespace: e.g.,
    #
    #    >>> case yum { (y)um)print ok;; }
    #    ok
    #
    #Yeah. That's fairly insane. That's also fairly edge-case, so we feel
    #confidently safe in simply ignoring this insanity for the moment. That
    #said, we'll want to generalize this to support such edge-cases at some
    #point. To do so, we'll need to ensure that the ${pcre_word_patternable}
    #PCRE we construct (as documented elsewhere) matches parens in a strictly
    #balanced manner. This is critical here, for obvious reasons.
    #FIXME: After fixing this PCRE to *NOT* require trailing whitespace, we'll
    #also need to fix ${pcre_complex_case_pattern} in the same manner.

    # Case statement pattern, permitting macros situated on the same line as
    # such patterns to be matched as such. Note that such pattern *MUST* be
    # suffixed by one or more whitespace characters; to avoid interfering with
    # subsequent matching (e.g., of spaced terminators), such characters are
    # asserted rather than consumed here.
    local pcre_terminator_case_pattern=${pcre_terminator_case_pattern_word}${pcre_is_continuable_space}
    local pcre_terminator_case_pattern_optional='(?>'${pcre_terminator_case_pattern}')?+'

    # Zero or more spaces optionally interspersed by line continuations
    # optionally followed by a case statement pattern (if at least one such
    # space matches).
    local pcre_terminator_case_pattern_spaced_optional='(?>'${pcre_continuable_spaces}${pcre_terminator_case_pattern_optional}')?+'

    # ";"-prefixed command terminator optionally followed by a character
    # comprising a case-statement terminator (e.g., ";;") optionally followed
    # by a case statement pattern.
    #
    # This PCRE matches all patterns *AFTER* the first of a case statement
    # (i.e., excluding the pattern following the "{" delimiting such
    # statement). For disambiguity, the first pattern of a case statement is
    # matched below in a context-aware manner.
    local pcre_terminator_semicolon=';(?>[;&|]'${pcre_terminator_case_pattern_spaced_optional}')?+'

    # ..................{ TERMINATOR ~ unspacing : chars     }..................
    # One or more single-character command terminators in a generic context.
    local pcre_terminator_chars_sourceable='['${char_terminator_sourceable}']++'

    # One or more single-character command terminators in a block and hence
    # excluding:
    #
    # " "{", prefixing blocks. Matching such prefix as a terminator here
    #   prevents recursive subroutine calls elsewhere from matching such prefix
    #   as a balanced block delimiter. Note that "}" never terminates commands
    #   and hence need *NOT* be explicitly excluded here.
    local pcre_terminator_chars_blockable=${pcre_spaces_vertical}

    # ..................{ TERMINATOR ~ unspacing : comment   }..................
    #FIXME: Comments are absolutely command terminators but also absolutely
    #require prefixing whitespace and hence *MUST* be moved above to the
    #"TERMINATOR ~ spacing" section, removed from the
    #${pcre_terminator_unspacing_core} PCRE below, and refactored
    #appropriately. Not terribly arduous... in mild-mannered theory. ("#"
    #characters *NOT* prefixed by whitespace are *ALWAYS* parsed as filename
    #globbing operators. Yeah; we definitely screwed up here.)

    # "#"-prefixed comment suffix, comprising either one or more vertical
    # whitespace characters *OR* the end of the subject string. While matching
    # trailing whitespace is typically discouraged, negative lookahead in
    # unquoted shell strings ensure such matching to be safe.
    local pcre_terminator_comment_suffix='(?>'${pcre_spaces_vertical}'|'${pcre_terminator_string_end}')'

    # "#"-prefixed comment excluding such prefix.
    local pcre_terminator_comment_body=${pcre_comment_body}${pcre_terminator_comment_suffix}

    # "#"-prefixed comment in a generic context.
    local pcre_terminator_comment_sourceable=${pcre_comment_prefix}${pcre_terminator_comment_body}

    #FIXME: *AWFUL.* Now that we've begun the laborious process of excising
    #all "WASTELANDS"-prefixed comment blocks, this has no reason to exist.

    # "#"-prefixed zeshy-specific "WASTELANDS" comment, resetting the current
    # match position to the start of such comment, capturing an arbitrary
    # character of such comment for disambiguity, and reporting success from
    # the current match attempt. This is purely an optimization intended for
    # use on the zeshy codebase, where such comments proliferate.
    local pcre_terminator_comment_macroable_wastelands_grouped=${pcre_reset}'-{20}'${pcre_paren_left}${pcre_space_literal}'WASTELANDS'${pcre_space_literal}'{25}'${pcre_paren_right}'(-){20}(?>'${pcre_space_vertical}'|'${pcre_subject_end}')'${pcre_succeed}

    # "# "-prefixed comment *OR* comment-like "WASTELANDS" code terminators and
    # hence optimized for matching preprocessor macros. The latter takes
    # precedence over the former and hence is matched first.
    local pcre_terminator_comment_macroable_spaced_grouped=${pcre_space_literal}'(?>'${pcre_terminator_comment_macroable_wastelands_grouped}'|'${pcre_terminator_comment_body}')'

    # "#"-prefixed comment optimized for matching preprocessor macros.
    local pcre_terminator_comment_macroable_grouped=${pcre_comment_prefix}'(?>'${pcre_terminator_comment_macroable_spaced_grouped}'|'${pcre_terminator_comment_body}')'

    # ..................{ TERMINATOR ~ unspacing : process   }..................
    # Process fork or substitution prefix command terminator. Since such
    # prefixes should typically be matched as prefixes of syntactic constructs
    # requiring subroutine-driven recursive matching in a strictly balanced
    # manner, this PCRE only applies to contexts ignoring such constructs
    # (e.g., top-level macro and block macro argument matching).
    #
    # For simplicity, "("- and ")"-delimited process forks are matched as well
    # (i.e., by matching the first character of such prefix optionally).
    local pcre_terminator_process_prefix_sans_backtick='['${char_terminator_process_substitution}']?+'${pcre_paren_left}

    # ..................{ TERMINATOR ~ unspacing : core      }..................
    # Command terminator *NOT* requiring prefixing or suffixing whitespace in a
    # general manner applicable to all other syntactic contexts. This excludes:
    #
    # " "{", prefixing blocks. Matching such prefixes as command terminators
    #   here prevents recursive subroutine calls from matching such prefixes
    #   as balanced block delimiters elsewhere. Note that "}" does *NOT*
    #   terminate commands and hence need *NOT* be explicitly excluded here.
    #
    # Since ${pcre_terminator_unspacing_macroable} matches macroable-specific
    # comments in a non-generalized manner (i.e., prefixed by vertical but
    # *NOT* horizontal whitespace, due to commented "WASTELANDS" command
    # terminators only being preceded by the former), such PCRE requires the
    # generalized comment matching performed here.
    local pcre_terminator_unspacing_core=${pcre_terminator_semicolon}'|'${pcre_terminator_pipe}'|'${pcre_terminator_ampersand}'|'${pcre_terminator_string_end}

    # ..................{ TERMINATOR ~ unspacing             }..................
    # Command terminator *NOT* requiring prefixing or suffixing whitespace in a
    # generic context, grouped for simplicity.
    local pcre_terminator_unspacing_sourceable='(?>'${pcre_terminator_chars_sourceable}'|'${pcre_terminator_comment_sourceable}'|'${pcre_terminator_unspacing_core}')'

    # Command terminator *NOT* requiring prefixing or suffixing whitespace in a
    # block, grouped for simplicity. For efficiency, process-specific syntactic
    # prefixes are also matched as such terminators. This implies
    # process-specific syntactic constructs to *NOT* be syntactically matched
    # in such contexts; since matching such constructs requires recursion and
    # hence subroutine calls, such matching is best avoided when feasible
    # (namely, here).
    local pcre_terminator_unspacing_blockable='(?>'${pcre_terminator_chars_blockable}'|'${pcre_terminator_comment_sourceable}'|'${pcre_terminator_unspacing_core}'|'${pcre_terminator_process_prefix_sans_backtick}')'

    # ..................{ TERMINATOR ~ unspacing : macro     }..................
    # Command terminator *NOT* requiring prefixing or suffixing whitespace at
    # the top level. To permit matching of macros embedded in process
    # substitutions, process-specific syntactic prefixes are also
    # matched as such terminators.
    local pcre_terminator_unspacing_macroable_grouped='(?>'${pcre_terminator_chars_sourceable}'|'${pcre_terminator_comment_macroable_grouped}'|'${pcre_terminator_unspacing_core}'|'${pcre_terminator_process_prefix_sans_backtick}')'

    # First character of a command terminator following an argumentless macro
    # (i.e., macro passed no arguments) at the top level, non-consumptively
    # matched with positive lookahead, *OR* the end of the subject string.
    # This PCRE matches all possible first characters matched by
    # ${pcre_terminator_unspacing_macroable_grouped}.
    local pcre_terminator_unspacing_macroable_suffix='(?=['${char_space_vertical}${char_terminator_sourceable}'|&;'${char_terminator_process_substitution}'(]|'${pcre_subject_end}')'

    # ..................{ TERMINATOR                         }..................
    # Header and footer for PCREs matching terminators implicity prefixed and
    # explicitly suffixed by zero or more horizontal whitespace characters
    # optionally interspersed by line continuations. Since all commands are
    # necessarily suffixed by at least one terminator but may otherwise be
    # empty (e.g., ";;;", the valid concatenation of three terminators
    # containing two empty commands), only one rather than multiple terminators
    # need to be matched here. Indeed, attempting to match multiple terminators
    # here is complicated by the observation that all terminators following the
    # first would need prefixing whitespace to be manually matched.
    #
    # By PCRE design (here and elsewhere), neither prefixing nor suffixing
    # whitespace is matched. Specifically:
    #
    # * While spaced terminators (e.g., ":not") *MUST* be preceded by
    #   horizontal whitespace, such whitespace need *NOT* be matched in a
    #   mandatory manner here, somewhat streamlining PCRE construction. Since
    #   unquoted shell words are already prevented from matching such
    #   terminators at the start of such words and since such words match in
    #   the customary greedy manner, spaced terminator-like substrings *NOT*
    #   preceded by such whitespace are already correctly matched as subwords
    #   of such words; likewise, spaced terminators preceded by whitespace are
    #   already correctly matched as terminators here.
    # * While all terminators may optionally be preceded by horizontal
    #   whitespace, such whitespace need *NOT* be matched here -- even in an
    #   optional manner. By PCRE design (e.g., of ${pcre_words_*}), such
    #   whitespace has been previously matched already.
    local pcre_terminator_head='(?>'
    local pcre_terminator_foot='|'${pcre_terminator_spacing}')'

    # Command terminator(s) in a generic context.
    local pcre_terminator_sourceable=${pcre_terminator_head}${pcre_terminator_unspacing_sourceable}${pcre_terminator_foot}

    # Command terminator(s) in a block.
    local pcre_terminator_blockable=${pcre_terminator_head}${pcre_terminator_unspacing_blockable}${pcre_terminator_foot}

    # Command terminator(s) at the top level.
    local pcre_terminator_macroable_grouped=${pcre_terminator_head}${pcre_terminator_unspacing_macroable_grouped}${pcre_terminator_foot}

    # ..................{ COMPLEX ~ blockless                }..................
    # Name of a complex command (e.g., "if", "for", "while") requiring no "{"-
    # and "}"-delimited block arguments and hence _not_ conflicting with macro
    # syntax. As of this writing, there exists only one such command: "time".
    local pcre_complex_blockless_name=':?+time'

    # Blockless complex command suffixed by one or more horizontal whitespace
    # characters optionally interspersed by line continuations.
    local pcre_complex_blockless_optional='(?>'${pcre_complex_blockless_name}${pcre_continuable_spaces_horizontal}')?+'

    # ..................{ COMPLEX ~ case                     }..................
    # Reserved keyword for case statements.
    local pcre_complex_case_name=':?+case'

    # String argument passed to a case statement, including mandatory
    # delimiting whitespace and suffixing block delimiter.
    local pcre_complex_case_arg=${pcre_continuable_spaces_horizontal}${pcre_word_passable}${pcre_continuable_spaces_horizontal}${pcre_brace_left}${pcre_continuable_spaces}

    # Glob pattern passed to a case statement, including optional delimiting
    # whitespace.
    local pcre_complex_case_pattern=${pcre_terminator_case_pattern_word}${pcre_continuable_spaces}

    # Case statement prefix comprising such statement's command name, string
    # argument, and leading pattern. Empty case statements (i.e., case
    # statements containing no patterns and hence no commands) will be
    # subsequently matched as conventional commands.
    #
    # In theory, a simpler alternative would be to match such prefix by
    # optionally matching a case statement pattern after matching a "{"
    # terminator. In practice, such approach fails on common edge cases by
    # erroneously matching and hence expanding command macro-like shell words
    # following a ")"-suffixed shell word following a "{" block prefix: e.g.,
    #
    #    # Command macro expansion will be erroneously applied to :or().
    #    { ((LIVE_FREE)) :or :die trying }
    #
    # Specifically, "((LIVE_FREE))" would be mismatched as a case statement
    # pattern-style command terminator rather than as an arithmetic test,
    # ensuring that ":or" would be mismatched as if in command position and
    # hence subject to command macro matching. Yeah... It's subtle.
    local pcre_complex_case_prefix=${pcre_complex_case_name}${pcre_complex_case_arg}${pcre_complex_case_pattern}

    # ..................{ COMMANDS                           }..................
    #FIXME: Unfortunately, merely matching "time" and "case" statements does
    #*NOT* suffice. We'll also need to match:
    #
    #* List assignments *EXCEPT* at the top level (i.e., in neither blockable
    #  or macroable contexts, equivalent to all "forkable" contexts), where we
    #  already match such assignments in a specific manner. Lists have peculiar
    #  syntax requiring special handling to avoid erroneous matching elsewhere.
    #  * Wait. We write above "...where we already match such assignments in a
    #    specific manner." *WHAT* specific manner? Since the syntax for list
    #    assignments is invariant and hence does *NOT* change depending on
    #    context, wouldn't it be preferable to match list assignments with a
    #    single PCRE -- ideally here? Why distribute such matching at all?
    #* "for ((...))"-style "for" statements in *ALL* syntactic contexts. The
    #  "<" operator in such arithmetic tests conflict with here-documents and
    #  hence require explicit disambiguation everywhere. This should be
    #  comparatively simple, and we probably won't want to do it here. Where we
    #  match arithmetic tests, simply precede such match by a new PCRE:
    #     pcre_keyword_for=':?for'
    #     pcre_keyword_for_optional='(?>'${pcre_keyword_for}${pcre_continuable_spaces_horizontal}')?'
    #* "for ... (...)"-style "for" statements in *ALL* syntactic contexts. Such
    #  lists require special handling, again.
    #
    #Nothing infeasible, of course. Merely more syntactic tedium. *sigh*

    # PCRE prefixing all PCREs matching zero or more commands. This PCRE
    # matches (in order):
    #
    # * Optional prefixing horizontal whitespace (which does *NOT*
    #   terminate commands), but *NOT* vertical whitespace (which does
    #   terminate commands).
    local pcre_commands_head='(?>'${pcre_continuable_spaces_horizontal_optional}${pcre_complex_blockless_optional}'(?>'${pcre_complex_case_prefix}'|'

    # PCRE suffixing all PCREs matching zero or more commands.
    local pcre_commands_foot='))*+'

    # Zero or more commands in a "`"-delimited processs substitution.
    local pcre_commands_backtickable_optional=${pcre_commands_head}${pcre_words_backtickable_optional}${pcre_terminator_sourceable}${pcre_commands_foot}

    # Zero or more commands in a parens-delimited syntactic construct.
    local pcre_commands_parenable_optional=${pcre_commands_head}${pcre_words_parenable_optional}${pcre_terminator_sourceable}${pcre_commands_foot}

    # ..................{ HERE                               }..................
    # Note that here-document syntactic invalidities (e.g., unmatched suffixing
    # delimiters) need *NOT* be matched here, as the PCRE embedding such PCREs
    # already accounts for such invalidities in a generalized manner.

    # Here-document delimiter prefix, comprising an ignorable optional hyphen
    # (signifying leading tabs to be insignificant) followed by zero or more
    # horizontal whitespace characters.  Since line continuations appear to
    # conflict with and hence be prohibited by such syntax, such whitespace
    # must *NOT* be interspersed by line continuations,
    local pcre_here_doc_delimiter_prefix='-?'${pcre_spaces_horizontal_optional}
    # Here-document delimiter suffix, comprising zero or more horizontal
    # whitespace characters followed by a vertical whitespace character.
    local pcre_here_doc_delimiter_suffix=${pcre_spaces_horizontal_optional}${pcre_space_vertical}

    # Here-document suffix, matching the previously captured delimiter.
    local pcre_here_doc_suffix=${pcre_space_vertical}'(?-1)'${pcre_line_end}

    # Negative lookahead preventing matching of a here-document suffix
    # corresponding to a previously matched here-document prefix.
    local pcre_here_doc_not_suffix='(?!'${pcre_here_doc_suffix}')'

    # Quoted here-document and hence *NOT* embedding syntactic constructs.
    # Sadly, matching all possible here-document delimiters is infeasible
    # within the purview of a pure PCRE. Matching delimiters embedding escaped
    # characters (e.g., '<<"mother\"destroyer"') requires unescaping such
    # characters -- a trivial operation *NOT* implementable under PCRE.
    #
    # Only the proper subset of here-document delimiters containing no escaped
    # characters are matchable. Since no here-documents in the zeshy codebase
    # leverage such delimiters, such concerns are largely ignorable.
    local pcre_here_doc_quoted_delimiter_grouped=${pcre_quotes_literal_grouped}${pcre_here_doc_delimiter_suffix}
    local pcre_here_doc_quoted_body='.*?'
    local pcre_here_doc_quoted_grouped=${pcre_here_doc_quoted_delimiter_grouped}${pcre_here_doc_quoted_body}

    # Unquoted here-document and hence *NOT* embedding syntactic constructs.
    local pcre_here_doc_unquoted_delimiter_grouped=${pcre_word_unquoted_grouped}${pcre_here_doc_delimiter_suffix}
    local pcre_here_doc_unquoted_body='(?>[^'${char_space_vertical}${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}'|'${pcre_here_doc_not_suffix}${pcre_spaces}')'
    local pcre_here_doc_unquoted_grouped=${pcre_here_doc_unquoted_delimiter_grouped}${pcre_here_doc_unquoted_body}

    # Here-document. Such matching requires capturing and then subsequently
    # backreferencing the here-document delimiter, fundamentally interfering
    # with capture group indices. To obviate this, such matching is isolated to
    # a subroutine call. (Similar to function-scoped local variables, such
    # calls isolate capture groups by storing the current set of such groups on
    # entering such call and restoring such set on returning from such call.)
    local pcre_here_doc_body_grouped='(?>'${pcre_here_doc_quoted_grouped}'|'${pcre_here_doc_unquoted_grouped}')'
    pcre_subroutines_body+='(?<doc>'${pcre_here_doc_delimiter_prefix}${pcre_here_doc_body_grouped}${pcre_here_doc_suffix}')'

    # ..................{ HERE ~ unsupported                 }..................
    # The following PCREs are intended for use *ONLY* in
    # ${ZY__MACRO_HERE_DOC_UNSUPPORTED_PCRE} and hence break "the rules."

    # Here-document prefix disambiguated from a here-string prefix with
    # negative lookahead.
    local pcre_here_doc_unsupported_delimiter_prefix='<<(?!<)'${pcre_here_doc_delimiter_prefix}

    # Unsupported here-document delimiter, excluding delimiters matched above.
    local pcre_here_doc_unsupported_delimiter='(?!(?>'${pcre_quotes_single_literal}'|'${pcre_quotes_double_literal}'|'${pcre_word_unquoted}')'${pcre_here_doc_delimiter_suffix}')'

    # Unsupported here-document delimiter, matching any delimiter *NOT* matched
    # above with negative lookahead. To prevent either the empty string or
    # vertical whitespace characters from matching, match exactly one non-
    # vertical whitespace character.
    local pcre_here_doc_unsupported=${pcre_here_doc_unsupported_delimiter_prefix}${pcre_here_doc_unsupported_delimiter}${pcre_char_sans_space_vertical}

    # ..................{ SUBSTITUTION ~ process             }..................
    # Process substitutions accept arbitrary zsh code and hence *SHOULD*
    # technically also accept arbitrary zeshy code -- including embedded
    # macros. Unfortunately, resuming PCRE-based matching after matching such a
    # macros would prevent the macro preprocessor from matching the delimiter
    # suffixing the syntactic constructs containing such macros. For example,
    # consider the following attempt to embed a hypothetical macro :macro():
    #
    #    :stdout.echo "$(:macro); :macro"; :macro
    #
    # While such macro is certainly matchable as a macro and subsequently
    # expandable, doing so would effectively disremember such macro to have
    # been embedded in a process substitution embedded in a double-quoted
    # string. Since the substring '); :macro"; :macro" would then be
    # erroneously misinterpreted as top-level code on resuming PCRE-based
    # iteration, such ";" would likewise be matched as a command terminator
    # prefixing another ":macro", likewise matched as a macro and subsequently
    # expanded -- erroneously, of course. Compounding matters, such '"' would
    # be matched as a prefixing rather than suffixing double-quoted string
    # delimiter, effectively destroying all subsequent parsing.
    #
    # Technically, the specific case exemplified above of macros embedded in
    # process substitutions embedded in double-quoted strings at the top level
    # is addressable. Specifically:
    #
    # * A new PCRE ${ZY__PREPROCESS_IN_DOUBLE_QUOTES_PCRE} could be
    #   constructed, matching the remaining contents and suffixing '"'
    #   delimiter of the double-quoted string containing the current match
    #   position on matching a macro embedded in a process substitution
    #   embedded in such string.
    # * ${ZY__PREPROCESS_PCRE} could notify the preprocessor of such
    #   syntactic context by either:
    #   * Capturing a non-empty substring of such double-quoted string into a
    #     new match group.
    #   * Resetting the current match position in a manner distinguishable from
    #     resets performed on invalid syntax.
    # * On identifying such condition, the preprocessor could match with
    #   ${ZY__PREPROCESS_IN_DOUBLE_QUOTES_PCRE} rather than
    #   ${ZY__PREPROCESS_PCRE} on the next match iteration.
    #
    # Unfortunately, such circumvention only applies to a finite level of
    # embedding and hence fails to generalize. Again consider:
    #
    #    :case "$(:macro1)" { (*) :macro2;; }
    #
    # While syntactically valid, expanding both macros in such code is
    # pragmatically infeasible. After matching and expanding :macro1(),
    # permitting :macro2() to be matched as a command macro would require the
    # preprocessor to "remember" not only that a macro embedded in a process
    # substitution embedded in a double-quoted string matched but that that
    # entire construct was the string argument of a case statement.
    #
    # Technically, even this is addressable. (While doubtlessly inelegant,
    # inefficient, and fragile-beyond-measure, a final solution could
    # ultimately be coerced into a working state.)
    #
    # Sadly, such circumventions would fail to scale beyond some finite depth
    # of explicit matching and handling (e.g., of macros embedded in process
    # substitutions embedded in double-quoted strings embedded in process
    # substitutions embedded in double-quoted strings). That copying code
    # working at a shallower depth to such unsupported depth would irrevocably
    # break such code implies such circumventions to be of greater harm than
    # benefit. Determinism is indispensible; syntactic flexibility is not.
    #
    # In short, matching and expanding macros embedded in process substitutions
    # embedded in other syntactic constructs is infeasible in the current PCRE-
    # based approach. Properly handling such macros would require a parser, at
    # which point the ideal choice would be to either patch zsh itself with
    # such support or reimplement zsh. While the one is simpler than the other,
    # both exceed the scope of current work.

    # "`"-delimited process substitution.
    local pcre_process_substitution_backtick_delimiter='`'
    local pcre_process_substitution_backtick=${pcre_process_substitution_backtick_delimiter}'(?>'${pcre_commands_backtickable_optional}${pcre_process_substitution_backtick_delimiter}'|'${pcre_reset_remainder_succeed}')'

    # ")"-suffixed process substitution or fork, excluding prefixing substring
    # if any (e.g., "$(", "=(").
    local pcre_process_sans_paren_left=${pcre_commands_parenable_optional}${pcre_paren_right}

    # "("- and ")"-delimited process fork, excluding such prefix.
    local pcre_process_fork_sans_paren_left=${pcre_process_sans_paren_left}

    # "("- and ")"-delimited process fork.
    local pcre_process_fork=${pcre_paren_left}'(?>'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # "$("- and ")"-delimited process substitution, excluding such prefix.
    local pcre_process_substitution_sans_dollar_paren_left=${pcre_process_sans_paren_left}

    # "=("- and )"-delimited process substitution. Since such substitutions
    # expand to an absolute path and hence shell word, such substitutions are
    # embeddable in macro arguments. Since this is *NOT* the case for all other
    # redirection process substitutions, no comparable PCREs match the latter.
    local pcre_process_substitution_equals_prefix='\='${pcre_paren_left}
    local pcre_process_substitution_equals=${pcre_process_substitution_equals_prefix}'(?>'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # Redirection process substitutions, comprising:
    #
    # * "=("- and ")"-delimited process substitutions implicitly creating and
    #   removing temporary files.
    # * "<("- and ")"-delimited process substitutions redirecting standard
    #   input.
    # * ">("- and ")"-delimited process substitutions redirecting standard
    #   output.
    local pcre_process_substitution_redirection_prefix='[=<>]'${pcre_paren_left}
    local pcre_process_substitution_redirection=${pcre_process_substitution_redirection_prefix}'(?>'${pcre_process_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # ..................{ SUBSTITUTION ~ math : braces       }..................
    # "$["- and "]"-delimited arithmetic substitution. While such delimiter
    # does *NOT* conflict with "$("- and ")"-delimited process substitutions,
    # the left bit-shift operator "<<" supported by such substitutions still
    # conflicts with here-document and -string prefixes.
    local pcre_math_substitution_braces_sans_dollar_body='(?:[^'${pcre_bracket_right}${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_math_substitution_braces_sans_dollar=${pcre_bracket_left}${pcre_math_substitution_braces_sans_dollar_body}${pcre_bracket_right}

    # ..................{ SUBSTITUTION ~ math : parens       }..................
    # Paren-specific arithmetic construct prefix.
    local pcre_math_prefix=${pcre_paren_left}${pcre_paren_left}

    # Paren-specific arithmetic construct suffix.
    local pcre_math_suffix=${pcre_paren_right}${pcre_paren_right}

    # "))"-suffixed arithmetic construct excluding prefix (e.g., "$((").
    local pcre_math_body='(?:[^)'${char_not_embeddable_prefix}']++|'${pcre_paren_right_not_math_suffix}'|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_math_sans_prefix='(?>'${pcre_math_body}${pcre_math_suffix}'|'${pcre_reset_remainder_succeed}')'

    # "(("- and "))"-delimited arithmetic test excluding the first such "(",
    # whose syntax conflicts in a similar manner as discussed below.
    local pcre_math_test_sans_paren_left=${pcre_paren_left}${pcre_math_sans_prefix}

    # "(("- and "))"-delimited arithmetic test.
    local pcre_math_test=${pcre_math_prefix}${pcre_math_sans_prefix}
    local pcre_math_test_grouped='('${pcre_math_test}')'

    # "$(("- and "))"-delimited arithmetic substitution excluding such "$(" but
    # *NOT* the following "(". The following syntax conflicts with conventional
    # syntax and hence *MUST* be matched for disambiguaty:
    #
    # * "))", delimiting such substitutions as well as overlapping and hence
    #   conflicting with the ")" delimiting "$("- and ")"-delimited process
    #   substitutions.
    # * "<<", the C-style left bit-shift operator conflicting with the here-
    #   document prefix "<<" and here-string prefix "<<<".
    local pcre_math_substitution_parens_sans_dollar_paren_left=${pcre_paren_left}${pcre_math_sans_prefix}

    # "$(("- and "))"-delimited arithmetic substitution, excluding such "$"
    # but *NOT* the following "((".
    local pcre_math_substitution_parens_sans_dollar=${pcre_math_prefix}${pcre_math_sans_prefix}

    # "$"-prefixed arithmetic substitution, excluding such "$".
    local pcre_math_substitution_sans_dollar=${pcre_math_substitution_parens_sans_dollar}'|'${pcre_math_substitution_braces_sans_dollar}

    # ..................{ TEST                               }..................
    # "[["- and "]]"-delimited non-arithmetic test.
    local pcre_test_prefix=${pcre_bracket_left}${pcre_bracket_left}
    local pcre_test_suffix=${pcre_bracket_right}${pcre_bracket_right}
    local pcre_test_body='(?>[^'${pcre_bracket_right}${char_not_embeddable_prefix}']++|'${pcre_bracket_right_not_test_suffix}'|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_test=${pcre_test_prefix}'(?>'${pcre_test_body}${pcre_test_suffix}'|'${pcre_reset_remainder_succeed}')'
    local pcre_test_grouped='('${pcre_test}')'

    # ..................{ VARIABLE                           }..................
    # "$"-prefixed variable expansion *NOT* delimited by "{" and "}", excluding
    # such "$". To permissively match syntax specific to such expansion *NOT*
    # conflicting with preprocessor matching, one or more such characters are
    # arbitrarily matched. Although this erroneously results in edge-case
    # raw strings matching as variable expansions (e.g., "$::"), such
    # misidentification is irrelevant to preprocessing and hence ignorable.
    #
    # To ensure proper matching of any syntactic construct suffixing such
    # expansion (including "`"-delimited process substitutions), avoid
    # matching such constructs' prefixes here.
    local pcre_var_undelimited_sans_dollar='(?>[^'${char_not_literal_backtickable_rest}']++|'${pcre_char_escaped}')++'

    # "${"- and "}"-delimited variable expansion, excluding such "$".
    local pcre_var_delimited_sans_dollar_body='(?>[^}'${char_not_embeddable_prefix}']++|'${pcre_embeddable_or_char_escaped}')*+'
    local pcre_var_delimited_sans_dollar=${pcre_brace_left}${pcre_var_delimited_sans_dollar_body}${pcre_brace_right}

    # "$"-prefixed and possibly "}"-suffixed variable expansion, excluding such
    # "$".
    local pcre_var_sans_dollar=${pcre_var_undelimited_sans_dollar}'|'${pcre_var_delimited_sans_dollar}

    # ..................{ CONSTRUCT ~ dollar                 }..................
    # "$("-prefixed substitution excluding such "$", comprising:
    #
    # * "$(("- and "))"-delimited arithmetic substitutions.
    # * "$("- and ")"-delimited process substitutions.
    #
    # Since the "$((" delimiting the former greedily overlaps the "$("
    # delimiting the latter, the former *MUST* be matched first.
    local pcre_dollar_parenable_sans_dollar_body='(?>'${pcre_math_substitution_parens_sans_dollar_paren_left}'|'${pcre_process_substitution_sans_dollar_paren_left}')'
    local pcre_dollar_parenable_sans_dollar=${pcre_paren_left}${pcre_dollar_parenable_sans_dollar_body}

    # "$"-prefixed interpretable syntactic construct, comprising:
    #
    # * "$"-prefixed variable expansions.
    # * "$["- and "$("-prefixed process substitutions.
    # * "$(("-prefixed arithmetic substitutions.
    # * "$'"-prefixed strings. Since such strings adhere to the same syntax as
    #   single-quoted strings, we reuse the PCRE matching the latter to match
    #   the former as well.
    local pcre_dollar_head=${pcre_dollar}'(?>'${pcre_var_sans_dollar}'|'
    local pcre_dollar_foot=${pcre_quotes_dollar_sans_dollar}'|'${pcre_reset_remainder_succeed}')'
    local pcre_dollar_interpretable=${pcre_dollar_head}${pcre_math_substitution_braces_sans_dollar}'|'${pcre_dollar_parenable_sans_dollar}${pcre_dollar_foot}

    # ..................{ CONSTRUCT ~ parens                 }..................
    # "("-prefixed interpretable syntactic construct, comprising:
    #
    # * "("- and ")"-delimited process forks.
    # * "(("- and "))"-delimited arithmetic tests.
    #
    # Since the "((" delimiting the latter greedily overlaps the "(" delimiting
    # the former, the latter *MUST* be matched first.
    local pcre_paren_left_interpretable=${pcre_paren_left}'(?>'${pcre_math_test_sans_paren_left}'|'${pcre_process_fork_sans_paren_left}'|'${pcre_reset_remainder_succeed}')'

    # ..................{ CONSTRUCT ~ subroutine             }..................
    # Syntactic construct recursively embeddable in variable expansions,
    # arithmetic substitutions, and arithmetic tests. Unlike interpretable
    # syntactic constructs defined below, embeddable syntactic constructs
    # *MUST* include "`"-delimited process substitutions -- as the following
    # examples demonstrate:
    #
    # * '"`: ""`"', a syntactically valid double-quoted string embedding such a
    #   substitution embedding such a string.
    # * "${:-`{}`}", a syntactically valid variable expansion embedding such a
    #   substitution embedding an empty block.
    #
    # The first example suggests the delimitation of such embeddables by single
    # characters (e.g., quotes) rather than balanced pairs of characters (e.g.,
    # parens) to require matching such substitutions in embeddables. Since the
    # second example demonstrates even embeddables delimited by balanced
    # characters to require such matching *AND* since non-embeddable
    # interpretables (e.g., "$("- and ")"-delimited process substitutions)
    # require no such matching, there *MUST* exist some fundamental disparity
    # between embeddables and non-embeddable interpretables.
    #
    # Indeed, there does. Since "`"-delimited process substitutions are
    # themselves interpretables, the following observations hold:
    #
    # * When non-embeddable interpretables embed such substitutions (e.g.,
    #   "$(``)"), both the outer and inner syntactic contexts admit arbitrary
    #   zsh code and hence adhere to the same syntactic constraints.
    # * When embeddables embed such substitutions (e.g., '"``"'), only the
    #   inner syntactic context admits arbitrary zsh code. Hence, such contexts
    #   do *NOT* adhere to the same syntactic constraints.
    #
    # In the former case, since the internal substitutions comply with the
    # syntax of the external non-embeddable interpretables embedding such
    # substitutions *WITHOUT* disrupting the balancing of the characters
    # delimiting such interpretables, the contents of the internal
    # substitutions may be matched as if they were instead the contents of the
    # external non-embeddable interpretables. In so doing, the "`" delimiting
    # such substitutions are fully ignorable.
    #
    # Naturally, this optimization ignores syntactic invalidities in
    # "`"-delimited process substitutions (e.g., the lack of a trailing "`")
    # embedded in interpretables. Since preprocessing is only concerned with
    # macro expansion *AND* since such substitutions are depracated, this
    # oversight is of no consequence.
    pcre_subroutines_body+='(?<emb>'${pcre_dollar_interpretable}'|'${pcre_process_substitution_backtick}')'

    # Syntactic construct recursively sourceable in any character position of
    # any shell word of any command in any syntactic context, including:
    #
    # * At the start of the first shell word of a command and hence including
    #   "("-prefixed syntactic constructs.
    # * In a scalar macro argument and hence including "`"-prefixed process
    #   substitutions. While the prior subroutine also matches such
    #   substitutions, duplicating such matching here prevents such arguments
    #   from needing to call both the prior subroutine and this subroutine.
    #   Since ${ZY__PREPROCESS_PCRE} is compiled only once under ideal
    #   digest compilations, such duplication is ignorable. Since such
    #   substitutions are both deprecated and matched in this subroutine under
    #   by such arguments, such substitutions are matched last.
    pcre_subroutines_body+='(?<src>'${pcre_dollar_interpretable}'|'${pcre_paren_left_interpretable}'|'${pcre_process_substitution_redirection}'|'${pcre_process_substitution_backtick}')'

    # ..................{ CONSTRUCT ~ unforkable             }..................
    # This subsection redefines the subset of syntactic constructs specific to
    # top-level macro and block matching. Since efficiency is paramount in such
    # syntactic contexts, the following PCREs are directly embedded rather than
    # called as indirect subroutines. While the efficiency cost of redefining
    # these constructs would typically outweigh efficiency gains of embedding
    # such PCREs, such constructs are *NOT* sourceable (e.g., process
    # substitutions) and hence are sufficiently simple to justify redefinition.

    # "$"-prefixed non-sourceable syntactic construct, comprising only variable
    # expansions and arithmetic substitutions.
    local pcre_dollar_preprocessable=${pcre_dollar_head}${pcre_math_substitution_sans_dollar}${pcre_dollar_foot}

    # Unforkable syntactic construct at the first character of the first shell
    # word of a command (i.e., a construct neither a process fork nor
    # substitution). Since process forks and substitutions may embed arbitrary
    # code and hence macros, matching such constructs here would obstruct
    # matching macros embedded within such constructs elsewhere. To permit such
    # matching, such constructs' prefixes are matched as command terminators
    # wherever this PCRE is embedded. Specifically, this PCRE matches:
    #
    # * "$"-prefixed variable expansions.
    # * "${"- and "}"-delimited variable expansions.
    # * "$["- and "]"-delimited arithmetic substitutions.
    # * "$(("- and "))"-delimited arithmetic substitutions.
    # * "(("- and "))"-delimited arithmetic tests.
    #
    # For efficiency, this PCRE is directly embedded rather than called as an
    # indirect subroutine.
    local pcre_preprocessable_subword_start_word_first=${pcre_dollar_preprocessable}'|'${pcre_math_test}

    # Unforkable syntactic construct at the first character of any shell word
    # *AFTER* the first of a command.
    local pcre_preprocessable_subword_start_word_rest=${pcre_dollar_preprocessable}

    # Unforkable syntactic construct at any character *AFTER* the first of any
    # shell word of a command.
    local pcre_preprocessable_subword_rest=${pcre_dollar_preprocessable}

    # ..................{ PICOWORD ~ unforkable              }..................
    # Smallest unforkable syntactic component at the start of the first shell
    # word of a command.
    local pcre_picoword_preprocessable_start_word_first=${pcre_picoword_sourceable_start_word_first}'|'${pcre_preprocessable_subword_start_word_first}

    # Smallest unforkable syntactic component at the start of any shell word
    # *AFTER* the first of a command.
    local pcre_picoword_preprocessable_start_word_rest=${pcre_picoword_sourceable_start_word_rest}'|'${pcre_preprocessable_subword_start_word_rest}

    # Smalleest unforkable syntactic component *AFTER* the start of any shell
    # word of a command.
    local pcre_picoword_preprocessable_rest=${pcre_picoword_sourceable_rest}'|'${pcre_preprocessable_subword_rest}

    # ..................{ WORD ~ macroable                   }..................
    # To avoid confusion, the term "macroable" refers to "the top level" both
    # here and everywhere. Hence the use of such term below, despite the fact
    # that the following PCREs match non-macro commands.
    #
    # Since strict balancing of delimiters (e.g., braces, parens) is irrelevant
    # to macro name matching, such delimiters are matched in arbitrary order.

    # Syntactic component at the start of the first shell word of a non-macro
    # command at the top level.
    local pcre_nanoword_macroable_start_word_first=${pcre_literal_sourceable_start_word_first}'|'${pcre_picoword_preprocessable_start_word_first}

    # Syntactic component at the start of any shell word following the first of
    # a non-macro command at the top level.
    local pcre_nanoword_macroable_start_word_rest=${pcre_literal_sourceable_start_word_rest}'|'${pcre_picoword_preprocessable_start_word_rest}

    # Syntactic component *AFTER* the start of any shell word of a non-macro
    # command at the top level.
    local pcre_nanoword_macroable_rest=${pcre_literals_sourceable_rest}'|'${pcre_picoword_sourceable_rest}'|'${pcre_picoword_preprocessable_rest}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a non-macro command at the top level.
    local pcre_nanowords_macroable_rest_optional='(?:'${pcre_nanoword_macroable_rest}')*+'

    # First shell word of a non-macro command at the top level. Since list
    # assignments contain vertical whitespace resembling command terminators
    # but no commands and hence macros, list assignments *MUST* be explicitly
    # matched to prevent macros from being erroneously matched after such
    # whitespace in such assignments.
    local pcre_word_macroable_first='(?>'${pcre_nanoword_macroable_start_word_first}')'${pcre_nanowords_macroable_rest_optional}

    # Any shell word *AFTER* the first of a non-macro command at the top level
    local pcre_word_macroable_rest='(?>'${pcre_nanoword_macroable_start_word_rest}')'${pcre_nanowords_macroable_rest_optional}
    local pcre_word_macroable_rest_optional='(?>'${pcre_word_macroable_rest}')?+'

    # Zero or more shell words *AFTER* the first of a non-macro command at the
    # top level, each delimited by one or more horizontal whitespace characters
    # optionally interspersed by line continuations.
    local pcre_words_macroable_rest_optional='(?>'${pcre_spaces_horizontal_continuable}${pcre_word_macroable_rest_optional}')*+'

    # ..................{ WORDS ~ blockable                  }..................
    # "{"- and "}"-delimited block, recursively nestable and hence matchable
    # only with a subroutine call.
    local pcre_block=${pcre_brace_left}'(?>(?&blk)'${pcre_brace_right}'|'${pcre_reset_remainder_succeed}')'

    # Macro block argument. To permit the preprocessor to disambiguite between
    # macro arguments of differing types, the "}" suffixing such block is
    # captured *AFTER* successfully matching a syntactically valid block.
    local pcre_block_grouped=${pcre_brace_left}'(?>(?&blk)'${pcre_brace_right_grouped}'|'${pcre_reset_remainder_succeed}')'

    # Smaller syntactic component at the start of the first shell word of a
    # command in a block.
    local pcre_nanoword_blockable_start_word_first=${pcre_literal_blockable_start_word_first}'|'${pcre_picoword_preprocessable_start_word_first}'|'${pcre_block}

    # Smaller syntactic component at the start of any shell word *AFTER* the
    # first of a command in a block.
    local pcre_nanoword_blockable_start_word_rest=${pcre_literal_blockable_start_word_rest}'|'${pcre_picoword_preprocessable_start_word_rest}'|'${pcre_block}

    # Zero or more syntactic components *AFTER* the start of any shell word of
    # a command in a block.
    local pcre_nanowords_blockable_rest_optional='(?:'${pcre_literals_blockable_rest}'|'${pcre_picoword_preprocessable_rest}'|'${pcre_block}')*+'

    # First shell word of a command in a block. Unbalanced "}" block suffixes
    # are prevented from being matched with negative lookbehind. Note that list
    # assignments are irrelevant to such matching and hence omitted.
    local pcre_word_blockable_first='(?>'${pcre_nanoword_blockable_start_word_first}')'${pcre_nanowords_blockable_rest_optional}

    # Shell word *AFTER* the first such word of a command in a block.
    local pcre_word_blockable_rest='(?>'${pcre_nanoword_blockable_start_word_rest}')'${pcre_nanowords_blockable_rest_optional}
    local pcre_word_blockable_rest_optional='(?>'${pcre_word_blockable_rest}')?+'

    # Zero or more shell words *AFTER* the first of a command in a block, each
    # delimited by one or more horizontal whitespace characters optionally
    # interspersed by line continuations.
    local pcre_words_blockable_rest_optional='(?>'${pcre_spaces_horizontal_continuable}${pcre_word_blockable_rest_optional}')*+'

    # One or more shell words in a block.
    local pcre_words_blockable=${pcre_word_blockable_first}${pcre_words_blockable_rest_optional}

    # ..................{ ASSIGNMENT                         }..................
    #FIXME: Everything below is insanity. Stop. Please; just stop. We are
    #absolutely *NOT* going to attempt to rewrite assignments like
    #"this_is = 'real bad'" to "this_is='real bad'", for any number of obvious
    #reasons documented above. So, we need to unwind most of everything in this
    #section. We *DO* still need to match list assignments (due to such
    #assignments having syntax conflicting with customary commands), but that's
    #only for disambiguation. Nothing more than that should be done. Period.

    #FIXME: Subtle issue: we really *ONLY* want to match assignments in which
    #such operator is either prefixed or suffixed by at least one horizontal
    #whitespace character. There's pretty much no reason to match standard zsh
    #assignments, as those (obviously) already comply with zsh syntax.
    #Interestingly, we do *NOT* need to ...
    #
    #Wait. zsh has rather peculiar behaviour not found anywhere else (that we
    #know of) in the core language. Scalar variable assignments appear to be
    #terminated by the first horizontal (!) whitespace character, which is a
    #bit off-the-linguistic-hook: e.g.,
    #
    #    >>> :str zio; zio= world;
    #    Command "world" not found.
    #    >>> :str zio; zio=hello world;
    #    Command "world" not found.
    #
    #Honestly, that's so overwhelmingly non-orthogonal with the remainder of
    #the zsh language that we're increasingly inclined to want to "fix" such
    #arguable misstep. Doing so is trivial -- since, of course, we already do
    #so! No edits are required below. Simply document why we take the current
    #approach, please.
    #FIXME: Oh, right. We'll need to "fix up" non-compliant variable
    #assignments [read: assignments of two or more shell words] in the
    #preprocessor. Hmm; what's the most efficacious means of doing so? Ideally,
    #we simply want to replace all unquoted horizontal characters with quoted
    #horizontal characters. Right; but that's clearly somewhat non-trivial to
    #achieve. Oh! Wait. No, it's clearly trivial. Simply:
    #
    #* Split the entire assignment value substring into words with "(z)".
    #* In the same variable expansion, join such words together with ' ' (i.e.,
    #  a single-quoted string containing a single literal space character). The
    #  definition of join_list_on_string() suggests the following should work:
    #
    #    # Trivially simple. Now test us, please!
    #    ZY__PREPROCESS_ASSIGNMENT_VALUE_WORD_FIRST=${match[${ZY__PREPROCESS_MATCH_GROUP_INDEX_ASSIGNMENT_VALUE_WORD_FIRST}]-}
    #    ZY__PREPROCESS_ASSIGNMENT_VALUE_WORDS_REST=${match[${ZY__PREPROCESS_MATCH_GROUP_INDEX_ASSIGNMENT_VALUE_WORDS_REST}]-}
    #
    #    if [[ -n ${ZY__PREPROCESS_ASSIGNMENT_VALUE_WORDS_REST} ]] {
    #        ZY__PREPROCESS_ASSIGNMENT_VALUE_WORD_FIRST+=' '${(@j:' ':)${(z)ZY__PREPROCESS_ASSIGNMENT_VALUE_WORDS_REST}}
    #    }
    #
    #Of course, we should only perform such splitting and rejoining when we
    #really need to -- which is to say, when two or more shell words are being
    #assigned. Happily, this is easy to ascertain. Given the current PCRE
    #structure, implementing the following incurs no inefficiencies:
    #
    #* Capture the first shell word being assigned to a distinct match group.
    #* Capture all remaining shell words being assigned to a distinct match
    #  group.
    #
    #Then simply apply such split and rejoining if the latter such match group
    #is empty. Simple; efficient. Yay!

    #FIXME: O.K.; yes, the eccentric approach below *DOES* reduce backtracking
    #in unlikely edge cases, but it also complicates the preprocessor for all
    #common cases and hence is horrible. Do we even currently account for this
    #cupidity in the preprocessor? We suspect not. Indeed, it's *NOT*
    #necessarily clear that such backtracking would even ever occur (...under
    #the zeshy codebase, at least), as all official macros are prefixed by ":"
    #and hence are *NOT* valid variable names. This is a fairly clear case of
    #premature optimization. Excise all backtracking "optimizations" from the
    #PCRE below, please.
    #FIXME: Hmm; wait. O.K.; we see what we were going for. Do we want to
    #permit users to define macros that are also valid variable names? For
    #generality, we probably *SHOULD*. In which case, the optimization below is
    #reasonable. Why? Because we'll need to test whether each shell word in
    #command position matches a macro name, regardless of such word's lexical
    #content. Note, however, that we'll need to account for this optimization
    #in the preprocessor -- which should be trivial. Don't forget, though!

    #FIXME: We write below that "While resetting the current match position to
    #the start of such name would be preferable...", but is that really the
    #case? After all, wouldn't resetting the current match position require
    #that we manually reparse all assignments in the preprocessor to determine
    #the byte indices of such variable name and value? That's not terrible
    #hard, of course: just split on the first "=" and discard optional
    #whitespace. But, still: why go through the inefficiency if you don't have
    #to? Isn't the current approach preferable to that? Or are there good and
    #fast reasons to prefer resetting the current match position? We don't
    #quite get it.

    # Variable assignment at the top level, consisting of a variable name,
    # assignment operator, and assignment value and reporting success if such
    # assignment matches. To reduce backtracking in the common case of command
    # names matching variable name syntax *NOT* followed by assignment
    # operators, all components of such assignment (excluding the prefixing
    # variable name) are optional. To calculate the byte indices of such
    # variable name and value, all components of such assignment are grouped.
    #
    # While resetting the current match position to the start of such name
    # would be preferable, there exists no means of doing so that would *NOT*
    # also erroneously apply to that common case (without introducing
    # backtracking, of course). Since all components of such assignment are
    # captured *AND* since matching is halted after doing so, resetting such
    # position is *NOT* required to calculate the byte indices of such
    # components. This differs from matched macros, for which resetting such
    # position is both feasible and simpler than capturing substrings. *shrug*
    local pcre_assignment_macroable_optional_grouped_succeed=${pcre_var_name_grouped}'(?>'${pcre_continuable_spaces_horizontal_optional_grouped}'(?>'${pcre_assignment_operator_value_spaceable_grouped}${pcre_succeed}'|'${pcre_words_macroable_rest_optional}')|'${pcre_nanowords_macroable_rest_optional}${pcre_words_macroable_rest_optional}')'

    # Variable assignment in a macro block argument. Since nonscalar variable
    # assignment syntax conflict with standard zsh syntax (e.g., vertical
    # whitespace *NOT* terminating such assignments) *AND* since zeshy- and
    # zsh-specific scalar variable assignment syntax conflicts (e.g.,
    # horizontal whitespace terminating the latter but *NOT* former such
    # assignments), both types are explicitly matched.
    #
    # If subsequently expanded by such macro, such assignment will be rematched
    # and captured by the prior PCRE during a subsequent preprocessor iteration
    # and hence is *NOT* captured here.
    local pcre_assignment_blockable_optional=${pcre_var_name}'(?>'${pcre_continuable_spaces_horizontal_optional}'(?>'${pcre_assignment_operator_value_spaceable}'|'${pcre_words_blockable_rest_optional}')|'${pcre_nanowords_blockable_rest_optional}${pcre_words_blockable_rest_optional}')'

    # ..................{ KEYWORD                            }..................
    #FIXME: Cease attempting to match optional horizontal whitespace around "="
    #operators, for orthogonality with both function keyword arguments and
    #standard zsh assignments. Yay!

    #FIXME: Actually use below.

    # Macro keyword argument, comprising a variable name, assignment operator,
    # and either scalar or nonscalar macro argument. While structurally similar
    # to variable assignment PCREs matched above, several differences remain:
    #
    # * Since variable assignments are commands, only the first shell words of
    #   commands may signify and hence require matching as such assignments.
    #   Since keyword arguments are *NOT* commands, *ALL* shell words passed to
    #   macros may signify and hence require matching as such arguments.
    # * Horizontal whitespace suffixing such words matching variable syntax is
    #   consumed *ONLY* if followed by assignment operators. Since words *NOT*
    #   followed by such operators are macro scalar arguments, such whitespace
    #   delimits such arguments and is matched elsewhere in a captured manner.
    #   To avoid consuming such whitespace here, backtracking is forced after
    #   matching such whitespace *NOT* followed by such operators.
    local pcre_keyword_passable_grouped=${pcre_var_name_grouped}'(?>'${pcre_continuable_spaces_horizontal_optional_grouped}${pcre_keyword_operator_value_spaceable_optional_grouped}'|'${pcre_nanowords_passable_rest_optional_grouped}')'

    # ..................{ WORD ~ passable                    }..................
    # Scalar macro argument.
    local pcre_word_passable_body='(?>'${pcre_nanoword_passable_start}'|'${pcre_qualifier_passable}')(?>'${pcre_nanoword_passable_rest}'|'${pcre_qualifier_passable}')*+)'

    # One or more scalar macro arguments, preceded by one or more horizontal
    # whitespace characters optionally interspersed by line continuations.
    # ${pcre_word_passable} matches escaped characters and hence line
    # continuations, implying the whitespace preceding such PCRE to be more
    # efficiently matchable with ${pcre_spaces_horizontal_continuable} than
    # ${pcre_continuable_spaces_horizontal}. However, embedding the former
    # prevents one or more initial line continuations from matching, requiring
    # explicit matching of such continuations. (Phew!)
    local pcre_words_passable_rest=${pcre_continuations_optional}'(?>'${pcre_spaces_horizontal_continuable}${pcre_word_passable}')++'

    # ..................{ COMMANDS ~ blockable               }..................
    # Nonscalar variable assignment *OR* one or more shell words in a block.
    # Such assignments conflict with conventional syntax and hence require
    # disambiguation. Since such assignments take precedence over conventional
    # shell words, the former are matched before the latter.
    local pcre_assignment_blockable_or_words='(?>'${pcre_assignment_blockable_optional}'|'${pcre_words_blockable}')'

    # Zero or more commands in a block.
    local pcre_commands_blockable_optional=${pcre_commands_head}${pcre_assignment_blockable_or_words}${pcre_terminator_blockable}${pcre_commands_foot}

    # "{"- and "}"-delimited block excluding such delimiters, defined as a
    # recursively callable subroutine.
    pcre_subroutines_body+='(?<blk>'${pcre_commands_blockable_optional}')'

    # ..................{ MACRO ~ body                       }..................
    # To permit efficient reuse of a single compilation of
    # ${ZY__PREPROCESS_PCRE} for *ALL* macro preprocessing, such PCRE is
    # generalized to support PCRE-based iteration of both macros *AND* macro
    # arguments. The former is trivially achieved by capturing the name of the
    # currently matched macro and the latter by capturing the last block and/or
    # scalar argument(s) passed to such macro. When iterating macros, such
    # argument-specific groups are ignorable; likewise, when iterating macro
    # arguments, such macro-specific groups are ignorable.
    #
    # While all scalar and block arguments will be matched, the '*+' quantifier
    # suffixing ${pcre_macro_args_grouped} implies that only the last block
    # argument passed to a macro will be captured. Since such argument may be
    # optionally followed by zero or more scalar arguments, determining the
    # first and last byte indices of such last block argument and following
    # scalar arguments requires capturing both.

    # zeshy-specific macro argument, comprising:
    #
    # * Block arguments.
    # * Nonscalar arguments *NOT* satisfying the syntactic requirements of
    #   keyword arguments (i.e., prefixation by variable names and assignment
    #   operators).
    local pcre_macro_arg_zeshy_grouped='(?>'${pcre_block_grouped}'|'${pcre_nonscalar_grouped}')'

    # zeshy-specific macro argument *OR* one or more scalar macro arguments,
    # captured to a new match group to simplify preprocessor byte indexing.
    local pcre_macro_arg_optional_grouped='('${pcre_macro_arg_zeshy_grouped}'|'${pcre_word_passable}')?+'

    # One or more horizontal whitespace characters optionally interspersed by
    # line continuations, each followed by a macro argument. To preserve
    # whitespace suffixing the last such argument, such whitespace is captured
    # to a new match group and such argument is matched optionally.
    local pcre_macro_body_spacing_grouped='(?>'${pcre_continuable_spaces_horizontal_grouped}${pcre_macro_arg_optional_grouped}')++'

    #FIXME: We appear to currently match suffixing whitespace incorrectly for
    #both argument and argumentless macros, which is fairly baffling. Such
    #whitespace *MUST* be preserved rather than consumed (e.g., to ensure that
    #whitespace preceding the call to :or() in ":some_macro :or" is preserved).
    #Instead, we should be consistently:
    #
    #* Consuming and capturing suffixing whitespace to a new capture group
    #  regardless of whether such macro accepts arguments or not.
    #* Handling such group in the preprocessor. Specifically:
    #  * If such group is nonempty *AND* all argument groups are empty, then
    #    suffixing whitespace matched. In such case, decrement the index of
    #    the last byte of such macro to the first byte preceding such
    #    whitespace. Since such whitespace is guaranteed to be ASCII, this
    #    should be efficiently implementable.
    #
    #In fact, this is critical enough to warrant immediate refactoring --
    #before we become lost in the inevitable maze of other refactorings.

    # Macro body, comprising either:
    #
    # * One or more horizontal whitespace characters optionally interspersed by
    #   line continuations followed by zero or more arguments passed to such
    #   macro followed by optional horizontal whitespace characters and line
    #   continuations. For efficiency, the latter whitespace is consumptively
    #   matched here; for correctness, such whitespace is effectively unmatched
    #   by subsequent preprocessor logic.
    # * The first character of the command terminator immediately following an
    #   argumentless macro (e.g., ":some|"), non-consumptively matched with
    #   positive lookahead.
    #
    # Since the former case already matches an argumentless macro followed by
    # one or more horizontal whitespace characters, the latter case only
    # matches an argumentless macro followed by no such whitespace. In such
    # case, such terminator will be subsequently consumed as a proper command
    # terminator and hence must *NOT* be consumed here. Nonetheless, such
    # terminator *MUST* still be matched here to prevent non-macro commands
    # whose names begin with valid macro names from being erroneously matched
    # as argumentless macros (e.g., ":some_macro_but_not_really|").
    local pcre_macro_body_grouped='(?>'${pcre_macro_body_spacing_grouped}'|'${pcre_terminator_unspacing_macroable_suffix}')'

    # ..................{ MACRO                              }..................
    # Macro name, grouped for disambiguating non-erroneous macros from
    # erroneous syntactic invalidities. (See below.)
    local pcre_macro_name_grouped='('${ZY__MACRO_COMMAND_NAME_PLACEHOLDER}')'

    # Macro. To notify the preprocessor of such macro's:
    #
    # * First byte index, the current match position is reset immediately
    #   before performing such match.
    # * Syntactic validity, the last character of such macro is captured
    #   after performing such match.
    # * Last byte index, success is reported after capturing such character.
    #
    # Since invalid syntax also leverages such resetting and reporting but
    # fails to capture such character, the two are readily disambiguatable.
    #
    # Note that macros are suffixable by shell words *NOT* matched as such
    # macros (e.g., redirections). Such words will be matched as commands
    # on the next preprocessor iteration and hence need *NOT* be matched here.
    # (Indeed, attempting to do so would be complicated by the need to report
    # success immediately after matching such macro.) While erroneously
    # matching shell words *NOT* in command position as if in command position
    # would typically incite issues, such words are guaranteed to be
    # redirections and hence inapplicable for matching as anything else.
    local pcre_macro_grouped_succeed=${pcre_reset}${pcre_macro_name_grouped}${pcre_macro_body_grouped}${pcre_char_last_grouped}${pcre_succeed}

    # Macro or first shell word of a command permitting matching of macros. To
    # preferentially match the first unquoted such word as a macro rather than
    # command name, the former is matched before the latter.
    local pcre_macro_grouped_or_word_first='(?>'${pcre_macro_grouped_succeed}'|'${pcre_word_macroable_first}')'

    # Macro or command at the top level. Since macros may be suffixed by shell
    # words external to such macros (e.g., redirections), zero or more such
    # words are matched after matching either a macro *OR* command name.
    local pcre_macro_or_command_grouped_optional='(?>'${pcre_assignment_macroable_optional_grouped_succeed}'|'${pcre_macro_grouped_or_word_first}${pcre_words_macroable_rest_optional}')?+'

    #FIXME: Actually use below -- if still needed, now that we're dropping all
    #attempts to munge standard zsh variable assignments. Maybe just excise?
    #FIXME: If this is still required, define ${pcre_words_macroable} based on
    #the definition of ${pcre_macro_or_command_grouped_optional} above.

    #FIXME: Document why macro calls take precedence over variable assignments
    #(namely, because zeshy-specific macros are expanded in a phase preceding
    #zsh-standard assignments). This implies that variables should *NEVER*
    #share the same name as macros, as in such case the latter will take
    #precedence over the former in the specific case of variable assignments --
    #which is a bit odd, of course, but unavoidable due to lack of signifying
    #parens for callables as in conventional languages. In practice, since
    #*ALL* official zeshy macros are prefixed by colons prohibited in variable
    #names, there exists no conflict.
    #
    #Note that ettempting to implement the reverse ordering quickly bogs down
    #in a morrass of impoderabilities. Specifically, variable names either have
    #to be prevented from matching macro names via negative lookahead *OR*
    #backtracking has to be permitted if a subsequent "=" is *NOT* matched.
    #Clearly, neither is happening. Hence, the current approach.
    #
    #Also document why variable assignments take precedence over command names
    #(namely, "=" is *NOT* a valid unescaped character in command names that
    #satisfy variable name syntax).

    # Macro, variable assignment, or command at the top level. To
    # preferentially match the first unquoted such word as a macro rather than
    # command name, the former is matched before the latter.
    # local pcre_macro_or_assignment_grouped_or_command='(?>'${pcre_macro_grouped_succeed}'|'${pcre_assignment_macroable_optional_grouped_succeed}'|'${pcre_words_macroable}')'

    #FIXME: Embed ${pcre_assignment_optional_grouped}? Ugh. What's goin' on!?
    #Now that we're dropping all attempts to munge standard zsh variable
    #assignments, maybe just excise?

    # Macro, variable assignment, or command at the top level. Unlike macros,
    # such assignments consume all remaining shell words for the current
    # command and hence effectively terminate such command.
    # local pcre_macro_assignment_or_command_grouped_optional='(?>'${pcre_macro_or_command_grouped_optional}'|'${}')?+'

    # Zero or more macros or commands permitting matching of macros. To notify
    # the preprocessor of the syntactic validity of code containing no macros
    # after the last such macro, the last character of such code is captured
    # *AFTER* such code is successfully matched.
    local pcre_commands_macroable_optional_grouped_body=${pcre_commands_head}${pcre_macro_or_command_grouped_optional}${pcre_terminator_macroable_grouped}${pcre_commands_foot}
    local pcre_commands_macroable_optional_grouped=${pcre_commands_macroable_optional_grouped_body}${pcre_char_last_grouped}

    # ..................{ SUBROUTINE                         }..................
    # PCRE subroutines defined above, concatenated in a manner preventing
    # such definitions from either implicitly matching *OR* capturing.
    #
    # First, a bit of useful background. As in Perl but not Ruby, "libpcre"
    # subroutine calls (e.g., "(?&soma)") do *NOT* capture the substring
    # matched by such call. As in both Perl and Ruby, subroutine definitions
    # (e.g., "(?<soma>All the advantages of Christianity and alcohol; none of
    # their defects.)" capture the substring matched by such definition.
    #
    # While non-orthogonal, such behaviour improves efficiency (by *NOT*
    # forcing all subroutine calls to inefficiently capture) and simplifies the
    # subsequent definitions of numbered group indices (by substantially
    # reducing the number of such groups). While these are good things, the
    # fact that subroutine definitions unconditionally capture is noxious. In
    # most cases, we would prefer such definitions to *NOT* capture.
    #
    # Happily, PCRE explicitly supports such behaviour via "(?(DEFINE)...)",
    # Perl- and PCRE-specific syntax defining all named and numbered capturing
    # groups in its embedded content but otherwise ignoring such content.
    # For further details, see:
    #
    #     http://www.regular-expressions.info/recursecapture.html
    local pcre_subroutines='(?(DEFINE)'${pcre_subroutines_body}')'

    # ..................{ GLOBAL                             }..................
    # PCRE matching unsupported here-documents (i.e., here-documents with
    # non-literal and hence non-PCRE-matchable delimiters).
    ZY__MACRO_HERE_DOC_UNSUPPORTED_PCRE=${pcre_here_doc_unsupported}

    # PCRE matching syntactically valid macro names.
    ZY__MACRO_NAME_VALID_PCRE=${pcre_macro_name_start}${pcre_macro_name_chars_rest_optional}

    # PCRE to which ${ZY__PREPROCESS_PCRE} will be set if at least one macro
    # exists.
    ZY__PREPROCESS_PCRE_IF_NONEMPTY=${pcre_options_anchored}${pcre_commands_macroable_optional_grouped}${pcre_subroutines}

    # PCRE to which ${ZY__PREPROCESS_PCRE} will be set if no macros exist.
    ZY__PREPROCESS_PCRE_IF_EMPTY=${pcre_succeed}

    # ..................{ INDICES                            }..................
    #FIXME: All such integers should be declared to be constants.
    #Unfortunately, attempting to do so currently fails, as digest compilation
    #fails to adequately support constant globals. *sigh*

    # For each match group captured by each PCRE global declared above
    # capturing four or more such groups, declare one human-readable integer
    # global expanding to such group's 1-based index. For robustness, declare
    # such globals iteratively rather than manually.
    local   group_name
    integer group_index

    #FIXME: Document such indices.

    # Declare positive absolute indices matched by ${ZY__PREPROCESS_PCRE}.
    group_index=1

    for group_name (
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_NAME
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_ATTRS
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_RETURN_TYPE
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_RETURN_CHANNELS
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_NAMES
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_ARG_LIST
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_PROTOTYPE_ARG_CHANNELS
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_SPACES_LAST
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_ZESHY
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_KEYWORD_NAME
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_KEYWORD_NAME_SPACES
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_KEYWORD_OPERATOR
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_KEYWORD_OPERATOR_SPACES
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_ARG_LAST_KEYWORD_VALUE
        ZY__PREPROCESS_GROUP_INDEX_MACRO_COMMAND_END
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_NAME
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_NAME_SPACES
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_OPERATOR
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_OPERATOR_SPACES
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_VALUE_NONSCALAR
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_VALUE_SCALAR_WORD_FIRST
        ZY__PREPROCESS_GROUP_INDEX_ASSIGNMENT_VALUE_SCALAR_WORDS_REST
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_BRACE_RIGHT_NAME
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_BRACE_RIGHT_ARG_ZY_LAST
        # ZY__PREPROCESS_GROUP_INDEX_MACRO_BRACE_RIGHT_END
        ZY__PREPROCESS_GROUP_INDEX_CODE_END_WASTELANDS
        ZY__PREPROCESS_GROUP_INDEX_CODE_END
    ) {
        integer -g ${group_name}=$(( group_index++ ))
        # print -r ${group_name}': '${(P)group_name}
    }
}
