#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *digest finalization* (i.e., finalizing which operables are to be
compiled into the digest file).
/---

#FIXME: Eliminate all precompilation hooks. (Terrible idea, in hindsight.) See
#@{if_compile/compile} for details on how and why. Everything below *OTHER* than
#precompilation hooks is still germain, of course, and must be retained.
#FIXME: Shift documentation from @{*-main/help/compile} here.

# ....................{ PRECOMPILERS                       }....................
:func_ ':void ::zeshy.compile_finalize()' :func{
    die_if_args

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #ORDER IS SUBTLY IMPORTANT HERE. Cranky graemlins slumber nigh.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Define placeholder functions to be redefined by
    # ::zeshy.compile_stop_startup() *BEFORE* ::zeshy.compile_stop_names() sets
    # the set of zeshy-specific functions.
    :define_func startup_zeshy ''
    :define_func startup_zeshy_aliases ''
    :define_func startup_zeshy_globals ''
    :define_func startup_zeshy_if_shell_interactive ''
    :define_func startup_zeshy_if_shell_login ''

    #FIXME: Terrible. Excise. See above.

    # Run all precompilation hooks.
    :string precompilation_hook
    for     precompilation_hook ("${ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE[@]}") {
#       print "running precompilation hook \"${precompilation_hook}\""
        run_code "${precompilation_hook}"
    }

    # Set the lists of zeshy-specific aliases, functions, and globals *AFTER*
    # defining the above functions *AND* running all precompilation hooks
    # possibly defining such objects.
    ::zeshy.compile_stop_names

    # Define top-level zeshy startup functions (e.g., startup_zeshy()) *AFTER*
    # setting such lists, which such functions reference to compile all zeshy-
    # specific aliases and globals into themselves.
    ::zeshy.compile_stop_startup

    # Cache temporary files and directories *AFTER*:
    #
    # * Calling all precompilation hooks above, many of which append to list
    #   ${ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES} serialized by this function.
    #   For the same reason, this function must be explicitly called here rather
    #   than added as a precompilation hook in the main codebase.
    # * Setting the lists of zeshy-specific aliases, suffix aliases, functions,
    #   and globals above, which this function serializes.
    #
    # While this function does *NOT* depend on ::zeshy.compile_stop_startup(), someone
    # needs to be the last in line.
    ::zeshy.compile_stop_cache
#   print -r -- "ZESHY_HOOKS_RUN_ON_STARTUP: ${ZESHY_HOOKS_RUN_ON_STARTUP[@]}"

    # Subtle dragons lie.
}:func <<'/---'
Run all *`zeshy` precompilation hooks* (i.e., code previously registered by
calling :run_hook_on_zeshy_precompile()) immediately prior to compiling the
current digest file.
Finalize all `zeshy`-specific aliases, functions, and globals to be compiled
into `zeshy`\''s user digest file immediately before compiling such file.
Specifically, run all commands in list ${ZESHY_HOOKS_RUN_ON_ZESHY_PRECOMPILE}
(e.g., as added by prior calls to append_zeshy.compile_stop_command()).
/---

#FIXME: Overly long function. Split into discrete functions.
:func_ 'void ::zeshy.compile_stop_startup()' :func{
    # Validate sanity.
    die_if_args
    :string globals_binding aliases_nonsuffix_binding aliases_suffix_binding
    :list aliases_global

    #FIXME: We should probably throw exceptions or print warnings if *ANY*
    #zeshy globals to be compiled into the digest are exported. I suspect we'll
    #probably catch a few errant strays. This is important, as exporting globals
    #prevents their recompilation into zeshy's user digest file.

    # String concatenating all zeshy-specific global bindings.
    :Var.Binding "${ZESHY_GLOBAL_NAMES[@]}" globals_binding
  # print -r -- "globals: ${globals_binding}"|less

    # String concatenating all zeshy-specific alias bindings.
    :set_string_to_alias_nonsuffix_binding\
        aliases_nonsuffix_binding "${ZESHY_ALIAS_NAMES[@]}"

    # If at least one zeshy-specific suffix alias was defined, list all such
    # alias bindings. Avoid calling alias() on an empty list, which uselessly
    # returns *ALL* alias bindings -- zeshy-specific or not.
    if { is_list_nonempty ZESHY_ALIAS_SUFFIX_NAMES } {
        # Prefix such bindings with a newline to delimit such bindings from the
        # preceding alias suffixes in the function containing both below.
        :set_string_to_alias_suffix_binding\
            aliases_suffix_binding "${ZESHY_ALIAS_SUFFIX_NAMES[@]}"
    }

    # If compiling a debug-specific digest file, call startup_zeshy_sanity()
    # immediately *AFTER* startup hooks defining zeshy globals and aliases.
    # Since run_hook_on_zeshy_startup_first() prepends the list of hooks with
    # the passed hook, register such hooks in the *REVERSE* order. Polish
    # notation for the disputable win!
    :line.run_if_debug run_hook_on_zeshy_startup_first startup_zeshy_sanity

    # Ensure the first and second functions to be called on zeshy startup are
    # startup_zeshy_globals() and startup_zeshy_aliases(), respectively.
    run_hook_on_zeshy_startup_first startup_zeshy_aliases
    run_hook_on_zeshy_startup_first startup_zeshy_globals

    #FIXME: Eliminate subshells by converting getters to setters.
    #FIXME: Ugh. This suggests we want a new setter
    #:set_string_to_list_joined_on_newline(). Call such setter below in place
    #of such subshells calling "print -lr --".

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Avoid expanding zeshy-specific aliases in function definitions below; such
    #aliases are unavailable in such definitions and hence will not be expanded.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # Define startup_zeshy() and cohorts. Since ::zeshy.compile_stop_names() previously
    # defined placeholder implementations for such functions, redefine rather
    # than define such functions.
    #
    # Convert the list of hooks to run to a string by delimiting such hooks by
    # newline. See :string.output_newlined() for further details.
    :redefine_func startup_zeshy "
    $(print -rl -- "${ZESHY_HOOKS_RUN_ON_STARTUP[@]}")
    is_shell_interactive && startup_zeshy_if_shell_interactive
    is_shell_login       && startup_zeshy_if_shell_login"

    :redefine_func startup_zeshy_if_shell_interactive\
        "$(print -rl -- "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_INTERACTIVE[@]}")"
    :redefine_func startup_zeshy_if_shell_login\
        "$(print -rl -- "${ZESHY_HOOKS_RUN_ON_STARTUP_IF_LOGIN[@]}")"
#   print_function startup_zeshy_globals
#   :func.die_unless startup_zeshy

    :redefine_func startup_zeshy_aliases\
        "${aliases_nonsuffix_binding}${ZESHY_ASCII_NEWLINE}${aliases_suffix_binding}"

    # List of all global alias names.
    :set_list_to_aliases_global aliases_global

    # Temporarily disable all global aliases *BEFORE* defining
    # startup_zeshy_globals().
    #
    # Unsurprisingly, the reasons why are fairly subtle. Such function's
    # implementation may attempt to declare nonscalar globals containing
    # unquoted items of the same name as zeshy-specific global alias names
    # (e.g., "is", "or"), in which case attempting to define such function
    # below will typically fail with one or more fatal parse errors.
    #
    # Disable *ALL* global aliases rather than merely zeshy-specific global
    # aliases. If non-zeshy-specific global aliases are currently defined, such
    # aliases could prove as problematic as zeshy-specific global aliases.
    #
    # Technically, disabling all currently defined non-suffix aliases (i.e.,
    # normal and global aliases) rather than merely all global aliases would
    # suffice to undefine the latter as well. However, doing so would also
    # introduce another unhelpful subtlety: namely, inducing fatal errors in
    # subsequently called zeshy functions expanding such aliases in subshells
    # (e.g., "$(get_caller)", "$(:stdin)"). Since zsh expands aliases in
    # function bodies at function definition definition rather than call time,
    # *ONLY* zeshy functions expanding such aliases directly in their function
    # bodies remain unaffected. Unfortunately, the print_exception() exception
    # handler transitively calls functions expanding such aliases in subshells.
    # To avoid breaking exception handling (at least in the interim until
    # startup_zeshy_aliases() redefines such aliases), undefine the minimum
    # number of problematic aliases (i.e., all global aliases) rather than all
    # non-suffix aliases.
    # undefine_alias_nonsuffix "${aliases_global[@]}"
    :disable_alias_nonsuffix "${aliases_global[@]}"
    :redefine_func startup_zeshy_globals "${globals_binding}"
     :enable_alias_nonsuffix "${aliases_global[@]}"
}:func <<'/---'
Dynamically define startup_zeshy() and related functions, including:

* startup_zeshy(), run on `zeshy` startup and calling all other functions below.
* startup_zeshy_if_shell_interactive(), run on `zeshy` startup if the current
  shell is interactive.
* startup_zeshy_if_shell_login(), run on `zeshy` startup if the current shell
  is a login shell.
* startup_zeshy_aliases(), run on `zeshy` startup to declare and define all
  `zeshy`-specific aliases.
* startup_zeshy_globals(), run on `zeshy` startup to declare and define all
  `zeshy`-specific globals.
/---

#FIXME: Let's be honest: this is exceedingly silly. Rather than serialize all
#lists of names to an external file, simply dynamically define a new function
#:define_zeshy_name_globals() as above, which when called sets the four name
#list globals (e.g., ${ZESHY_GLOBAL_NAMES}, ${ZESHY_FUNCTION_NAMES}) to the
#current contents of such lists. *WOW*. Embarrassingly simple.

:func.document <<'/---'
:void ::zeshy.compile_stop_cache()

Store metadata describing the current digest file to temporary files in the
cache subdirectory of the current user's `zeshy` dot directory, including:

* ${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}, caching the list of paths on which
  `zeshy`\''s user digest file depends. Since `zeshy` requires such list
  before autoloading such file, such list must be cached to an external file.
* ${ZESHY_USER_NAMES_FILE}, caching lists of names of `zeshy`-specific aliases,
  suffix aliases, functions, and globals. Such lists are both too resource
  consumptive and too infrequently accessed to warrant compilation into
  startup_zeshy_globals() with the customary `zeshy` globals.
/---
function ::zeshy.compile_stop_cache() {
    # Validate sanity.
    die_if_args

    # Serialize such lists.
    :write_script_with_var_binding\
        "${ZESHY_USER_DIGEST_DEPENDENCIES_FILENAME}"\
        ZESHY_USER_DIGEST_DEPENDENCY_PATHNAMES
    :write_script_with_var_binding\
        "${ZESHY_USER_NAMES_FILE}"\
        ZESHY_ALIAS_NAMES\
        ZESHY_ALIAS_SUFFIX_NAMES\
        ZESHY_FUNCTION_NAMES\
        ZESHY_GLOBAL_NAMES\
}

# ....................{ STARTUP                            }....................
:func.document <<'/---'
:void startup_zeshy()

Run all `zeshy` startup hooks, including (in order):

. startup_zeshy_globals(), declaring and defining all `zeshy`-specific globals.
. startup_zeshy_aliases(), declaring and defining all `zeshy`-specific aliases.
. startup_zeshy_if_shell_interactive(), if the current shell is interactive.
. startup_zeshy_if_shell_login(), if the current shell is a login shell.
/---

:func.document <<'/---'
:void startup_zeshy_globals()

Declare and define all `zeshy`-specific globals on `zeshy` startup. Since
this function is called before all other startup logic, all startup functions
may reliably expand such globals.
/---

:func.document <<'/---'
:void startup_zeshy_aliases()

Declare and define all `zeshy`-specific aliases on `zeshy` startup. Since
this function is called before all other startup logic, all startup functions
may reliably expand such aliases.
/---

:func.document <<'/---'
:void startup_zeshy_if_shell_interactive()

Runs all `zeshy` startup hooks specific to interactive shells _after_ running
all other startup logic (but _before_ running hooks specific to login shells).
/---

:func.document <<'/---'
:void startup_zeshy_if_shell_login()

Runs all `zeshy` startup hooks specific to login shells _after_ running all
other startup logic (including running hooks specific to interactive shells).
/---

return
# --------------------( WASTELANDS                         )--------------------
# typeset -g EXCEPTION='uoh'
# readonly THROW=
# THROW= 2>/dev/null
# function yim() {
    # typeset -g EXCEPTION='uh oh'
    # return 1
    # readonly THROW=
    # THROW= 2>/dev/null
    # :die 'Test.'
    # print 'Herehere!'
# }
# yim

