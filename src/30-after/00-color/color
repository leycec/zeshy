#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle terminal colors.

== See Also ==
* http://ciembor.github.com/4bit[4bit], arguably the best and (probably only)
  terminal color scheme designer.
/---

#FIXME: Accessing ${terminfo} appears to be inherently unsafe. Such module is
#conditionally compiled *ONLY* on distributions actually providing a terminfo
#database, which may not be the case under space-constrained minimal
#environments and embedded devices. Hence, before accessing such parameter in
#*ANY* function, we'll need to first a new safety exception handler
#:die_unless_terminfo(), throwing an exception unless the current system
#provides a "terminfo" database and hence zsh module.

#FIXME: *UGH*. Happily, the current digest file now depends on the number of
#colors supported by the current terminal. But this means that *ALL* of the
#conditional support for terminals supporting a variety of color counts in this
#and all other adjacent parcels has been rendered nonsensical. Which is *REALLY*
#good, because such conditionality was rapidly becoming unmaintainable *AND*
#overly inefficient. We'll need to excise all color count-specific globals
#(e.g., ${ZESHY_STYLE_TO_COLOR_2}). Since zeshy now conditionally selects digest
#files before startup on the basis of terminal color counts, this is safe,
#reasonable, and indeed essential.

#FIXME: Add support for fish-like syntax highlighting. Happily, someone's
#already gone to the work of zshifying this; we'll just want to zeshify it a
#bit: https://github.com/zsh-users/zsh-syntax-highlighting

#FIXME: Add support for 256 color-enabled terminals (e.g., xterm-(256)color,
#urxvt-unicode-256color). Oooooooh, man. I'm pretty sure I crawled across
#some zsh code the other day simplifying such support... Hmmmmmmmm.
#FIXME: It looks like KDE's Konsole even supports 24-bit colors! Wild. See:
#https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors
#FIXME: O.K.; I've heavily looked into the issue. It's certainly more than
#feasible, but we'll need to liberally borrow from a few different sources.
#
#First, note function wmiintf() at
#https://github.com/zOrg1331/zsh-configs/blob/master/.zsh/rc/S58_wmii. This
#function retrieves the RGB color values given a passed X11 color name. We
#actually want to do something like the reserve: for each such name, we want to
#define a corresponding "color."-prefixed pseudo-style in ${ZESHY_STYLE_TO_COLOR}
#expanding to the ANSI sequence best approximating such color on the current
#terminal. Err. Actually, don't do that. It sounds rather expensive! Certainly,
#most users would never use most such colors. O.K.; well, we could at least
#define a converter convert_color_name_to_ansi() converting the passed X11 color
#name to the ANSI sequence best approximating such color on the current
#terminal. How do you do that, exactly? Read onward!
#
#Next, note Perl script "~/tmp/xterm-*/vttests/256colors.pl". Pretty awesome.
#It's by the "xterm" authors and hence the canonical definition for calculating
#indices and color values for both the 6x6x6 color cube and greyscale ramp. It's
#also *VERY* readable, which is great. But this alone isn't quite enough...
#
#We also need "CSApprox.vim" at "~/tmp/csapprox/", an utterly awesome ViM
#plugin that does pretty much everything we need. (If he can do it in ViM, we
#can certainly do it in zeshy!) The core components to look at are:
#
#* "autoload/csapprox/per_component.vim", whose function
#  csapprox#per_component#Approximate() maps the passed RGB value to the closest
#  256-color index. Pretty sweet stuff. This function in turn leverages...
#* "autoload/csapprox/common.vim", which defines the "ramp" (i.e., distance
#  between) for each of the 6 possible "steps" of each of the 3 dimensions (red,
#  green, and blue) in such color cube -- as well as for the greyscale line.
#  Ignore everything but the "xterm" values, here -- the industry has very well
#  standardized on such pallette for most intents and purposes.
#* "autoload/csapprox.vim", which basically converts "/usr/share/X11/rgb.txt"
#  into ViM format. This is nice -- but, arguably, we should be using the
#  "rgb.txt" bundled with the current system... Err, or should we? Hmmmmm. No,
#  perhaps not. X11 is going away, so "rgb.txt" is probably going away as well.
#  But X11 also isn't applicable to non-UNIX systems. Right. So, just bundle our
#  own copy in "zsh" map format. Sweet!
#* "plugin/CSApprox.vim". The helpful part here is the part where it leverages
#  "showrgb" if available and otherwise manually parses apart "rgb.txt". That
#  said, it only does any of this if an option is set (...defaulting to "false"?)
#  Right. We can probably rely on a bundled "rgb.txt" in map format, for now.
#  The remainder of this file appears ViM-specific and hence functionally
#  useless for our vagabond purposes.
#
#Last, note the variants on the zsh-specific code snippet "spectrum":
#
#* https://github.com/sykora/etc/blob/master/zsh/functions/spectrum
#  The official "spectrum". Since this uses ANSI rather than prompt escapes,
#  this is somewhat more useful for our purposes.
#* https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/spectrum.zsh
#  The unofficial "oh-my-zsh" variant. While less useful, this does provide a
#  helpful function spetrum_ls() for printing all such colors. Note this version
#  prints foreground rather than background colors, however, and hence could be
#  demonstrably improved.
#
#That's it. It's all basically in the "autoload/" subdirectory. Get thee hence!
#FIXME: O.K.; I've started mucking around with the math. Efficiently mapping
#arbitrary RGB values to 6x6x6 RGB color cube values is an interesting topic.
#Thankfully, it's clearly doable. The steps are as follows:
#
#    list steps; steps=(0, 95, 135, 175, 215, 255)
#
#While the first step is 95 units apart, the remainder are all only 40 units
#apart. Hence, each R, G, and B component can be mapped as follows:
#
#    # Original R, G, or B component (i.e., in [0, 255]).
#    integer color_value
#
#    # Such component mapped to a color cube index (i.e., in [0, 5]). For
#    # math simplicity, such indices are 0- rather than 1-based!
#    integer color_index
#
#    # Map the former to latter, implicitly rounding down to the largest integer
#    # less than or equal to the result.
#    color_index=$(( (color_value - 95)/160*4 + 1 ))
#
#    # If such index is negative, coerce such index to 0. The prior mapping
#    # erroneously maps color values in [0, 55] to -1. While this is
#    # unavoidable, the correction is quite efficient.
#    if (( color_index < 0 )) {
#       color_index=0
#    }
#
#This isn't *QUITE* right, of course, but it's close. We want to map values
#according to their proximity to the mid-point of each step. Contemplate.
#
#Let's see. The mid-points are integers (excluding the first mid-point, a float)
#as follows:
#
#    list mpoints; mpoints=(47.5, 115, 155, 195, 235)
#
#The distances between each such mid-points are:
#
#    list mpoint_dists; mpoint_dists=(47.5, 67.5, 40, 40, 40, 20)
#
#That doesn't look terribly good. Let's try a different tact. We want to bin as
#follows:
#
#* Color values in [  0,  48] (rounding up, as the eye perceives darker
#  intensities with less granularity) to color index 0.
#* Color values in [ 49, 115] to color index 1.
#* Color values in [116, 155] to color index 2.
#* Color values in [156, 195] to color index 3.
#* Color values in [196, 235] to color index 4.
#* Color values in [235, 255] to color index 5.
#
#Woops. That clearly short-changes index 5 and overly apportions into index 1.
#Contemplate a new mapping that gives equal apportionment to such values. How
#about:
#
#* Color values in [  0,  48] to color index 0.
#* Color values in [ 49,  95] to color index 1.
#* Color values in [ 95, 135] to color index 2.
#* Color values in [135, 175] to color index 3.
#* Color values in [175, 215] to color index 4.
#* Color values in [215, 255] to color index 5.
#
#Ugh. Mathematically, that *IS* more pristine -- but think about. Colors with R,
#G, and B values all in [215, 255] will be mapped to pure white! Under the above
#transformation, this only happens with R, G, and B values all in [235, 255],
#which is quite a bit more tolerable. Given the rather arbitrary choice of color
#pallette ("Curse you, xterm! We love you, but... really."), we may not have
#terribly much choice. For a similar reason, we should (however) probably
#tighten the lower bounds. We really don't want to map to pure black unless we
#can help it. How about the following mid-points with distances:
#
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=(  65, 105, 145, 185, 225)
#    list mpoint_dists; mpoint_dists=(65, 40, 40, 40, 40, 30)
#
#Or, perhaps:
#
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=(  70, 110, 150, 190, 230)
#    list distans; distans=( 70, 40, 40,  40, 40,  25)
#
#The latter are centered somewhat more cleanly around the bilinear midpoints
#(i.e., (47.5, 115, 155, 195, 235)), apportioning slightly more values to the
#first and last indices and substantially fewer to the second index. Though,
#perhaps we want something even *MORE* graduated: e.g.,
#
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=(  65, 115, 155, 195, 230)
#    list distans; distans=( 65, 50, 40,  40, 35,  25)
#    list distan2; distan2=(   15, 10, 10,   5, 10)
#
#    # Still not quite right, clearly. How about:
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=(  60, 110, 150, 190, 220)
#    list distans; distans=( 60, 50, 40,  40, 30,  30)
#    list distan2; distan2=(   10, 10,  0,   10, 0)
#
#    # That looks pretty sweet. But we can do better:
#    list mpoints; mpoints=(  48, 115, 155, 195, 235)    # original
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=(  60, 110, 155, 195, 230)
#    list distans; distans=( 60, 50, 45,  40,  35, 25)
#    list distan2; distan2=(  -10, -5, -5,  -5, -10)
#
#    # What's nice about that is that the upper ends are twice as compressed as
#    # everything else in the "middle". This is probably what we want, to avoid
#    # mapping to much to either pure white. That said, we do still map quite a
#    # bit to pure black. Perhaps we can do better:
#    list mpoints; mpoints=(  48, 115, 155, 195, 235)    # original
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=( 55,  110, 155, 195, 230)
#    list distans; distans=(55, 55,  45,  40,  35, 25)
#    list distan2; distan2=(  0,  -10, -5,  -5,  -10)
#
#    # Perhaps we can do better:
#    list mpoints; mpoints=(  48, 115, 155, 195, 235)    # original
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=( 50, 100, 145, 185, 220)
#    list distans; distans=(50, 50, 45,  40,  35, 35)
#    list distan2; distan2=(  0,  -5, -5,  -5,  0)
#
#    # Perhaps we can do better:
#    list mpoints; mpoints=(  48, 115, 155, 195, 235)    # original
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#
#                             0    1    2    3    4
#    list mpoints; mpoints=( 50,  98, 143, 184, 220)     # new!
#
#    list distans; distans=(50, 48, 45,  41,  36, 30)
#    list distan2; distan2=(  -2, -3, -4,  -5,  -6)
#
#    # Wow! Perfect. The midpoints telescope into the upper end, with the
#    # distance between each midpoint decreasing as one approaches 255,
#    # coinciding with the human perception of intensity. The midpoints are
#    # also reasonably close to the average. Much better! This results in:
#
#* Color values in [  0,  50] to color index 0. (size: 50)
#* Color values in [ 51,  98] to color index 1. (size: 48)
#* Color values in [ 99, 143] to color index 2. (size: 45)
#* Color values in [144, 184] to color index 3. (size: 41)
#* Color values in [185, 220] to color index 4. (size: 36)
#* Color values in [221, 255] to color index 5. (size: 30)
#
#    # Given the uniformity, I wonder if in fact an equation doesn't exist...
#    # Whatever it is, it's clearly non-linear, requiring polynomial regression.
#    # To solve, note that the color indices are what we want and hence the
#    # dependent variable (typically "y") and the color midpoints are what we
#    # are given and hence the indepedent variable (typically "x").
#
#    # Via http://www.xuru.org/rt/PR.asp with data:
#50 0.666666666666666
#98 1.333333333333333
#143 2
#184 2.66666666666666
#220 3.33333333333333
#255 4
#    # ..., I obtain the following quadratic equation with error less than 0.001:
#    color_index =\
#        1.463463115*(10**-5)*(color_value**2) +\
#        1.184779466*(10**-2)* color_value     +\
#        1.611297386*(10**-2) ))
#
#    # Not terribly beautiful, but let's see if it works! This results in:
#
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=( 50,  98, 143, 184, 220)
#* Color values in [  0,  38] to color index 0. (size: 38)
#* Color values in [ 39, 110] to color index 1. (size: 71)
#* Color values in [111, 173] to color index 2. (size: 62)
#* Color values in [174, 229] to color index 3. (size: 38)
#* Color values in [230, 255] to color index 4. (size: 38)
#
#    # Not the best. The key issue is that the best curve fit is likely to
#    # either be a fractional polynomial (e.g., square root) or logarithm, which
#    # even reasonably strong solvers tend not to support. I've opted instead to
#    # use Eureqa, which is a pretty awesome application (despite its abject
#    # non-freeness). I had two realizations while doing so:
#    #
#    # 1. The key to efficiently mapping a smooth line to stepwise bins (as we
#    #    want to do) is to map one greater than the maximum value for each bin
#    #    (e.g., 51 for the first bin) to one greater than the desired index for
#    #    all values in that bin.
#    # 2. What does this accomplish? It ensures that simply rounding down the
#    #    resulting fractional bin indices gives the desired integer bin
#    #    indices, guaranteed to be an efficient operation.
#    #
#    # Given such observations, we concocted the following data:
#
#x	y
#0	0
#51	1
#99	2
#144	3
#185	4
#221	5
#256	6
#
#    # Note, for example, that 255 will map to something like 5.9876 and hence
#    # to 5 after rounding, as desired. Likewise, pretty much everything between
#    # 221 to 255 will be binned to index 5 -- exactly as desired.
#FIXME: Hmm. My original supposition appears to be incorrect, as could probably
#be surmised by merely contemplating the survival fitness of adequate perception
#in the dark. As culled from a random (but informative!) blog, "...humans
#perceive brightness changes non-linearly. We have better sensitivity at low
#luminance than high luminance. For example, when we control LED brightness using
#Arduino PWM, we see a large brightness change between analogWrite(9,1) and
#analogWrite(9,2) but only a small brightness change between analogWrite(9,244)
#and analogWrite(9,255)." This means that xterm pretty much got it backwards.
#Their color cube should have allotted *MORE*, not *LESS*, space to darker
#colors. In any case, however, we have to work with what we have -- and the
#xterm color cube is most certainly what we have. Given that, we should probably
#revisit our remapping above. How about...  Wait. The old one works quite well:
#
#                             0    1    2    3    4
#    list oldmidp; oldmidp=(  48, 115, 155, 195, 235)
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list newmidp; newmidp=( 50,  98,  143, 184, 220)
#    list distans; distans=(50, 48, 45,  41,  36, 30)
#    list distan2; distan2=(  -2, -3, -4,  -5,  -6)
#
#Perhaps we already accidentally hit on an adequate solution.
#Consider. By binning everything in [51, 98] to index 1 rather than everything
#in [48, 115], we're binning substantially less than in the default approach at
#the darker end. Similarly, by binning everything in [221, 255] to index 5 rather
#than everything in [236, 255], we're binning substantially more than in the
#default approach at the brighter end. What do you say, hey? Lookin' good...
#
#O.K.; Eureqa got us to:
#
#    color_index=$((\
#        0.0196327201550869*color_value + 5.8056465992094*(10**-8)*(color_value**3) ))
#
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=( 50,  98, 143, 184, 220)
#* Color values in [  0,  50] to color index 0. (size: 50)
#* Color values in [ 51, 100] to color index 1. (size: 49)
#* Color values in [101, 143] to color index 2. (size: 42)
#* Color values in [144, 185] to color index 3. (size: 41)
#* Color values in [186, 222] to color index 4. (size: 36)
#* Color values in [223, 255] to color index 5. (size: 32)
#
#Right. It's not *QUITE* perfect. But it's *VERY* close. It certainly captures
#the large-order issues. I substantially doubt anyone would be able to discern
#the difference between this and something slightly tighter. (After all, the
#residual error is down to 0.003 already.)
#FIXME: Right. So I gave an alternative with exponents in the "-22" range a try.
#It utterly failed, probably due to rounding errors at such small exponents.
#It's nice to know, at least, that we can ignore such solutions.
#Instead, I gave the next iteration down a try:
#
#    color_index=$((\
#       0.0193126795857809*color_value +\
#       3.43371646960515*(color_value**2)*(10**-6) +\
#       4.95268905499403*(color_value**3)*(10**-8) ))
#
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=( 50,  98, 143, 184, 220)
#* Color values in [  0,  50] to color index 0. (size: 50)
#* Color values in [ 51, 100] to color index 1. (size: 49)
#* Color values in [101, 143] to color index 2. (size: 42)
#* Color values in [144, 184] to color index 3. (size: 40)
#* Color values in [185, 222] to color index 4. (size: 37)
#* Color values in [223, 255] to color index 5. (size: 32)
#
#Right. The difference between the two is exceedingly small. Let's just go with:
#
#    color_index=$((\
#        0.0196327201550869*color_value + 5.8056465992094*(10**-8)*(color_value**3) ))
#
#Aaand... we're done!
#FIXME: Woops. The last midpoint of 220 is really *TOO* low. 235 is a much
#better midpoint for real-world use. Think about it, which we really should have
#done sooner: since zeshy will principally be used on terminals and hence
#light-on-dark color schemes, we need to preserve as much granularity at the top
#end as possible. Pretty much every color used will be a bright color at the top
#end! So, we pretty much want the reverse of what we concocted above -- despite
#its mathematical elegance. Indeed, given our constraints, it's unlikely a
#satisfactory set of mathematical elegant midpoints exists -- meaning that we
#should simply optimize for what intuitively seems best, regardless of elegance.
#How about:
#
#                             0    1    2    3    4
#    list premidp; premidp=(  50,  98, 143, 184, 220)
#    list oldmidp; oldmidp=(  48, 115, 155, 195, 235)
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list newmidp; newmidp=( 65,  119, 166, 205, 235)
#    list distans; distans=(65, 54, 47,   39,  30, 20)
#    list distan2; distan2=(  -9, -7, -8,   -9,  -10)
#
#Closer, but the lower end's a bit odd. How about:
#
#                             0    1    2    3    4
#    list oldmidp; oldmidp=(  48, 115, 155, 195, 235)
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list newmidp; newmidp=( 55,  113, 163, 204, 235)
#    list distans; distans=(55, 58,  50,  41,  31, 20)
#    list distan2; distan2=(  +3, -8, -9,  -10, -11)
#
#Close, but not quite. How about:
#
#                             0    1    2    3    4
#    list oldmidp; oldmidp=( 48,  115, 155, 195, 235)
#    list steps;   steps  =(0,  95, 135, 175, 215, 255)
#    list newmidp; newmidp=( 45,  107, 160, 203, 235)
#    list distans; distans=(45, 62,  53,  43,  32, 20)
#    list distan2; distan2=( +17, -9, -10,  -11, -12)
#
#Right. So we'll pretty much be adopting one of the above three. Consider. O.K.;
#I rather like the latter, as it apportions the most space at the higher end. We
#want to capture as much as we can in the higher end, and that accomplishes that
#nicely.
#FIXME: A question also remains of how we map to the 16 initial system colors.
#Are these colors simply duplicates of color cube colors or do they provide
#genuinely new values? If the latter, then we also need to consider mapping to
#such colors. In any case, given the greyscale line, we'll probably want to try
#mapping to both the color cube *AND* greyscale line for each color value and
#"taking" the mapped value with minimum distance (...or error?) to the actual
#value. We can render this slightly more efficient by checking after obtaining
#the first mapped value whether such distance is sufficiently minimum (e.g., <=
#0.1), in which case we don't need to bother obtaining the second mapped value.

#FIXME: We probably need to handle the "bold" attribute differently. O.K.;
#let's be honest, we need to *STOP* using such attribute altogether on anything
#other than pure 8-color terminals. On all other terminals, including 16-color
#terminals, the "bold" ANSI sequence behaves erratically if at all. Why? Because
#"bold" was basically just a hack to allow 8-color terminals to effectively
#support 8 additional colors -- at least, we think. Most non-8-color terminals
#(e.g., "urxvt" and pretty much anything coded after 1972) now interpret the
#"bold" attribute to mean that the software wants a bold font -- *NOT* that the
#software wants a bright color, which is usually the intended effect. To quoth
#the online raven:
#
# "So, when you do:
#
#  $ printf '\e[1;34mabc'
#
#  tmux sets colour 4 using setaf which with xterm-256color ends up as:
#
#  ^[[1m^[[38;5;4mabc
#
#  This means you get bold + colour 4. In the 256 colour palette, 4 is hardcoded
#  to ANSI blue. You've told xterm not to use a bold font, so it doesn't change
#  that, and there are no bold colours in the 256 colour palette, so you just get
#  colour 4, normal ANSI blue."
#
#Note, in particular, the "...there are no bold colours in the 256 colour
#palette." So what's the best course forward? Pretty simple, really:
#
#* We rename all colors suffixed by ":bold" (e.g., "red:bold") in both
#  configuration files and here to be prefixed by "bright" instead (e.g.,
#  "brightred"). This appears to be the canonical solution under open-source,
#  and also coincides with X11 color name nomenclature without conflicting with
#  such nomenclature. Which, of course, is probably why it's become the standard.
#  I admit that I'm not terribly fond of it -- but, really, this ":bold"
#  nonsense...
#
#Hmm. I should also note, however, that ":bold" is the canonical X.org
#fontconfig syntax for such concept (e.g., "fc-match monospace:bold" shows the
#current font to be used for displaying bold colors under 256-color terminals).
#Hence, we could beneficially retain the ":"-delimited color attribute syntax,
#while still replacing most current uses of such syntax with the prior
#"brightred" or "bright_red" idea.

#FIXME: It's not terribly urgent, but there appear to be terminals supporting
#only 16 colors, as well:
#
#"Unfortunately, interpretation of colors 0 through 7 often depends on whether
# the emulator supports eight colors or sixteen colors. Emulators that only
# support eight colors (such as the Linux console) will display colors 0 through
# 7 with normal brightness and ignore colors 8 through 15, treating them the
# same as white. Emulators that support 16 colors, such as gnome-terminal,
# normally display colors 0 through 7 as dim or darker versions and colors 8
# through 15 as normal brightness. On such emulators, the "normal" white (color
# 7) usually is shown as pale grey, requiring bright white (15) to be used to
# get a real white color. Bright black usually is a dark grey color, although
# some terminals display it as pure black. Some sixteen-color terminal emulators
# also treat normal yellow (color 3) as orange or brown, and bright yellow
# (color 11) as yellow."
#
#Other terminals only support 88 colors (i.e., "urxvt" by default -- but doesn't
#everyone enable 256 colors these days?). Honestly, given 256-color support,
#this is clearly low priority. But it would be nice to eventually transparently
#support all such terminals. Supporting 88 colors shouldn't be terribly
#difficult: just recompile "urxvt" without 256-color support. Supporting 16
#colors, however, will probably prove a bit more troublesome. What terminals
#still in existance only support 16 colors? A topic for another day, clearly.
#FIXME: On the topic of 88 colors, "urxvt" documentation reads as follows:
#
#"In addition to the colours defined above, urxvt offers an additional 72
# colours. The first 64 of those (with indices 16 to 79) consist of a 4*4*4 RGB
# colour cube (i.e. index = r * 16 + g * 4 + b + 16), followed by 8 additional
# shades of gray (with indices 80 to 87)."
#
#Since this is exactly a truncated form of the 256-color `xterm' color space,
#supporting 88 colors should be effortless. A Python script entitled
#"terminal_color" provides the following helpful steps:
#
#       # Color cube steps.
#       cincr = [0, 0x8b, 0xcd, 0xff]
#
#       # Greyscale steps.
#       greys = [rgb % ((n,)*3)
#               for n in [0x2e, 0x5c, 0x73, 0x8b, 0xa2, 0xb9, 0xd0, 0xe7]]
#
#I've confirmed via the same script that "urxvt" interestingly leverages the
#*EXACT* same ANSI CSI SGR sequence for displaying 88-color colors as "xterm"
#does for displaying 256-color colors. Which really begs the question: why
#didn't they just support 256 colors from the get-go?

# ....................{ GLOBALS                            }....................
# Defer initialization of most globals to precompile_zeshy_terminal_colors() and
# startup_zeshy_terminal_colors(), below.

declare_global_with_stdin integer ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED <<'/---'
Number of colors supported by the current terminal, quantized to common color
thresholds. See get_terminal_color_count_quantized() for further details.
/---

# ....................{ GLOBALS ~ list                     }....................
#FIXME: Such list should be in the same order as the corresponding bits of such
#ANSI sequences.
declare_global_with_stdin list_set ZESHY_COLOR_NAMES_8 <<'/---'
List of the canonical eight color names supported by most \*nix terminals:
white, black, red, green, blue, yellow, magenta, and cyan.
/---
# List of such names, excluding pseudo-color "grey".
ZESHY_COLOR_NAMES_8=( white black red green blue yellow magenta cyan )

# ....................{ GLOBALS ~ map                      }....................
#FIXME: Consider renaming to ${ZESHY_STYLE_TO_COLOR_ANSI} and similarly below.
#FIXME: Documentation outdated. Honestly, we should probably just reduce such
#documentation to simply:
#
#    "See ${ZESHY_STYLE_TO_COLOR_NAMES_8} for further details."

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR <<'/---'
Map from style name to the ANSI escape sequence coloring such style on the
current terminal.

Color styles improve readability, genericity, and configurability by
substituting hard-coded color names with user-configurable style names (e.g.,
substituting `${ZESHY_COLOR[grey]}` with
`${ZESHY_STYLE_TO_COLOR[print_usage.punctuation]}`). See
${ZESHY_STYLE_TO_COLOR_NAMES} for the map from which this map is initialized.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_2 <<'/---'
Map from style name to the ANSI escape sequence coloring such style on
*monochrome terminals* (i.e., terminals without color support). See
${ZESHY_STYLE_TO_COLOR} for further details.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_8 <<'/---'
Map from style name to the ANSI escape sequence coloring such style on
*8-color terminals* (i.e., terminals supporting at most the canonical eight
colors standardized by the VT100). See ${ZESHY_STYLE_TO_COLOR} for further
details.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_88 <<'/---'
Map from style name to the ANSI escape sequence coloring such style on
*88-color terminals* (i.e., terminals supporting at most the canonical 88
colors standardized by `rxvt`). See ${ZESHY_STYLE_TO_COLOR} for further
details.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_256 <<'/---'
Map from style name to the ANSI escape sequence coloring such style on
*256-color terminals* (i.e., terminals supporting at most the canonical 256
colors standardized by `xterm`). See ${ZESHY_STYLE_TO_COLOR} for further
details.
/---

#FIXME: What went wrong with the documentation here? *sigh*
declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_PROMPT <<'/---'
Map style to the prompt-specific ANSI escape code coloring such style on the current terminal.
Color styles improve readability, genericity, and configurability by
substituting hard-coded color names with user-configurable style names (e.g.,
substituting `${ZESHY_COLOR[grey]}` with
`${ZESHY_STYLE_TO_COLOR[print_usage.punctuation]}`). See
${ZESHY_STYLE_TO_COLOR_NAMES} for the map from which this map is initialized.

Map style to the ANSI escape code enabling
such color on the current terminal. See
${ZESHY_STYLE_TO_COLOR_NAMES_PROMPT} for default color style names.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_PROMPT_2 <<'/---'
Map from style name to the prompt-specific ANSI escape sequence coloring such
style on monochrome terminals. See ${ZESHY_STYLE_TO_COLOR_PROMPT} for further
details.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_PROMPT_8 <<'/---'
Map from style name to the prompt-specific ANSI escape sequence coloring such
style on 8-color terminals. See ${ZESHY_STYLE_TO_COLOR_PROMPT} for further
details.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_PROMPT_88 <<'/---'
Map from style name to the prompt-specific ANSI escape sequence coloring such
style on 88-color terminals. See ${ZESHY_STYLE_TO_COLOR_PROMPT} for further
details.
/---

declare_global_with_stdin map ZESHY_STYLE_TO_COLOR_PROMPT_256 <<'/---'
Map from style name to the prompt-specific ANSI escape sequence coloring such
style on 256-color terminals. See ${ZESHY_STYLE_TO_COLOR_PROMPT} for further
details.
/---

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_terminal_color(void)

Return success if shell output is attached to a *polychrome terminal device*
(i.e., a terminal supporting at least the canonical eight ANSI/VT100 colors).
/---
function is_terminal_color() {
    die_if_args
    (( $(get_terminal_color_count) >= 8 ))
}

# ....................{ GETTERS                            }....................
#FIXME: Horrific. Excise entirely in favor of set_int_to_terminal_color_count().
declare_function_with_stdin <<'/---'
int get_terminal_color_count(void)

Get the number of colors supported by the current terminal.
/---
function get_terminal_color_count() {
    # Get such colors. Note that "echotc Co" also suffices, if less efficiently.
    die_if_args
    output_string "${terminfo[colors]}"
}

declare_function_with_stdin <<'/---'
integer get_terminal_color_count_quantized(void)

Get the number of colors supported by the current terminal, quantized to
standard terminal color thresholds for safety. If the exact number of colors
supported by the current terminal is:

* Greater than or equal to 256, this function returns 256 -- corresponding to
  the 256-color pallette standardized by `xterm`.
* In the range [88, 255], this function returns 88 -- corresponding to the 88-
  color pallette standardized by `rxvt`.
* In the range [8, 87], this function returns 8 -- corresponding to the 8-color
  pallette standardized by the VT100.
* In the range [0, 7], this function returns 2 -- corresponding to the 2-color
  pallettes of monochrome terminals.
/---
function get_terminal_color_count_quantized() {
    # Validate sanity.
    die_if_args

    # Get such count. For efficiency, inline such expansion. See
    # get_terminal_color_count() for further details.
    integer terminal_color_count="${terminfo[colors]}"

    #FIXME: This is tremendously wrong, of course. But leave it until we have
    #256-color support fully "up" and running.
    if (( terminal_color_count >= 8 )) {
        return_string 8
    } else {
        return_string 2
    }

    # If such count is already quantized, return such count as is.
    if is "${terminal_color_count}" == (8|88|256) si {
        return_string "${terminal_color_count}"
    # Else, quantize such count.
    } elif (( terminal_color_count >= 256 )) {
        return_string 256
    } elif (( terminal_color_count >= 88 )) {
        return_string 88
    } elif (( terminal_color_count >= 8 )) {
        return_string 8
    } else {
        return_string 2
    }
}

# ....................{ RESETTERS                          }....................
declare_function_with_stdin <<'/---'
void reset_terminal_color(void)

Reset color attributes for the current terminal to such terminal's defaults
(e.g., regular typeface on white foreground and black background).
/---
function reset_terminal_color() {
    die_if_args
    output_string_sans_newline "${ZESHY_STYLE_TO_COLOR[color.reset]-}"
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void set_terminal_color_globals(void)

Set all globals whose values depend on the number of colors supported by the
current terminal, including:

* ${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED}.
* ${ZESHY_STYLE_TO_COLOR}.
* ${ZESHY_STYLE_TO_COLOR_PROMPT}.
/---
function set_terminal_color_globals() {
    # Validate sanity.
    die_if_args

    # Set the quantized number of colors supported by the current terminal.
    ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED="$(get_terminal_color_count_quantized)"

    # Set map globals dependent on such number. For startup efficiency, avoid
    # calling set_map_to_map().
    :string map_name_target map_name_source
    for     map_name_target (ZESHY_STYLE_TO_COLOR ZESHY_STYLE_TO_COLOR_PROMPT) {
        map_name_source="${map_name_target}_${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED}"
        die_unless_map "${map_name_source}"
        eval ${map_name_target}'=( "${(kv@)'${map_name_source}'}" )'
    }
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: While the above is technically the case, we should be able to
#efficiently dispense with such niceties

#FUXME: Actually, even that isn't quite sufficient. If the "terminfo" database
#is available *BUT* the current ${TERM} is not found in such database, map
#${terminfo} is almost certainly either undefined or empty. :is_terminfo() must
#thus test at least the following two conditions:
#
#* :is_module_terminfo() reports success.
#* And something testing the validity of map ${terminfo}: e.g.,
#
#    >>> TERM=oeuoeu
#    >>> print ${terminfo[colors]}
#    zsh: terminfo[colors]: parameter not set
#
#  Given that, just test:
#
#    (( ${+terminfo[colors]} ))
#
#We've confirmed the latter test to reliably test whether or not the current
#${TERM} is recognized. Note it is *NOT* sufficient to test whether such map is
#empty (e.g., via "(( ${#terminfo} ))"). Curiously, although the size of such
#map never changes, zsh appears to internally undefine *ALL* its key-value pairs
#for unrecognized terminals. Hence, we have to test the existence of the most
#common such key: "colors". (Done!)

    # Quantize such count. See prior documentation.
#   if (( terminal_color_count < 8 )) {
#       return_string 2
#   } elif (( terminal_color_count < 256 )) {
#       return_string 8
#   } else {
#       return_string 256
#   }

#* 2, if such number is less than 8. Since color terminals support at least the
#  8 canonical colors listed by ${ZESHY_COLOR_NAMES_8}, this often implies such
#  terminal to be monochrome.
#* 8, if such number is less than 255.
#* 255, otherwise.

    #FUXME: I just realized: do stdout and stderr maintain distinct color
    #attributes? If so, we'll need to add a new
    #output_string_sans_newline_to_stderr() and repeat this statement.
    #FUXME: Uncomment the 256 color-specific logic. This will result in
    #exceptions thrown elsewhere in this parcel. So, get to 'er!
#   } else {
#       return_string 8
#   }

#I'll note that, while such bins are likely to produce aesthetically better
#results, they do preclude use of efficient math functions to map into such
#bins. However, that's not all bad; since *MOST* color values are brighter
#than not, performing a linear search from the upper end (i.e., closer to 255)
#should prove slightly faster.
#
#Urhm:
#
#* Color values in [  0,  48] to color index 0.
#* Color values in [ 49, 115] to color index 1.
#* Color values in [116, 155] to color index 2.
#* Color values in [156, 195] to color index 3.
#* Color values in [196, 235] to color index 4.
#* Color values in [235, 255] to color index 5.
#
#    list steps;   steps  =(   0,  95, 135, 175, 215, 255)
#    list mpoints; mpoints=(47.5, 115, 155, 195, 235)
#    list mpoints; mpoints=(65, 105, 145, 185, 225)
#
#    list steps; steps=(255, 215, 175, 135, 95, 0)

#FUXME: Ah-ha! Right. I have another generalization that can help us
#significantly, here. We've begun to repeat our use of certain theme-specific
#characters over-and-over (e.g., "•"), which rather hampers sane maintenance.
#
#Instead, the code responsible for initializing map ${ZESHY_STYLE_TO_TEXT}
#should be tasked with the following:
#
#* If a value of the source map (e.g., ${ZESHY_STYLE_TO_TEXT_UTF8}) is itself
#  an existing key of the name map, then replace such value with the value of
#  such key.
#* Repeat until such value is no longer an existing key of such map.
#
#For example, rather than this:
#
#    print_message.heading.joiner_left  '•'
#
#...we would have this:
#
#    theme.joiner '•'
#    print_message.heading.joiner_left  theme.joiner
#
#But, of course, that isn't *QUITE* general enough. In the above example, we
#actually want:
#
#    print_message.heading.joiner_left '• '
#
#...implying we would need something resembling this:
#
#    theme.joiner '•'
#    print_message.heading.joiner_left '${theme.joiner} '
#
#There are two means of resolving such strings -- neither terribly arduous, but
#neither terribly straightforward either:
#
#* Iterate each key-value pair, declaring a local string with such key name
#  initialized to such value. (Technically, such declaration should occur
#  *AFTER* the following expansion. But, for the purposes of discussion, it
#  makes sense to discuss them in the opposite order.) Then, replace the value
#  of the current key-value pair with an evaluation statement as follows:
#
#      eval 'map[${key}]="'${map[${key}]}'"'
#
#  Wait. That obviously doesn't work, as such value could contain unbalanced
#  quote delimiters. It's also inherently dangerous (e.g., malicious "$(...)"
#  substrings). Instead, we need to apply the following efficient substitution:
#
#      map[${key}]=${${map[${key}]}//(#b)\$\{([[:IDENT:]]##)\}/${(P)match[1]}}
#
#  Untested, of course, but some variant of that should certainly work.
#
#O.K.; that's it. That's the implementation. Decently cool, no? This should give
#the patent duplication issue an approximate face-lift. Hence, the final loop
#iteration body might resemble something like:
#
#      map[${key}]=${${map[${key}]}//(#b)\$\{([[:IDENT:]]##)\}/${(P)match[1]}}
#      string ${key}:always"${map[${key}]}"
#FUXME: Wait. It's not *QUITE* that simple, as keys are arbitrary strings while
#variable names are highly constrained. For the moment, silently avoid declaring
#keys not valid variables names: e.g.,
#
#      map[${key}]="${map[${key}]//(#b)\$\{([[:IDENT:]]##)\}/${(P)match[1]}}"
#
#      if { :is_var_name "${key}" } {
#          string ${key}:always"${map[${key}]}"
#      }
#FUXME: Wait. It's not *QUITE* that simple, either. No keys are valid variable
#names, since variable names cannot contain ".". Oh! Obviously, the following
#works without any of that nonsense above:
#
#      map[${key}]="${map[${key}]//(#b)\$\{([[:IDENT:]]##)\}/${${map[${match[1]}]}}"
#
#Sigh. It really is quite simple. Note we could also extend this to support
#expanding both map keys *AND* global variables with the same "${...}" syntax:
#
#      map[${key}]="${map[${key}]//(#b)\$\{([[:IDENT:]]##)\}/${${map[${match[1]}]-${(P)${match[1]}}}}"
#
#Since global variables cannot contain "." characters and map keys *SHOULD*
#always contain such keys, there exists no conflict between the two. However,
#where hypothetical conflicts arise, map keys take precedence. Do *NOT* default
#the expansion "${(P)${match[1]}}" to ensure a warning is printed for nonextant
#variables.
#FUXME: *WAIT*. This is all nonsensical overkill. This is zsh, after all. Just
#define each such map in its own anonymous function declaring string locals to
#be subsequently expanded into the values of such map. My Nordic brethren, but
#this was substantially simpler than my mind made it out to be. *shakes head*

#FUXME: Replace *ALL* underscores in color names with colons. This pretty much
#has to be done either manually or by globally search-and-replacing on specific
#color name substrings (e.g., replacing ":bold" with ":bold"). Colons are useful
#for suggesting such values to actually be stringified lists; underscores are
#unhelpful here because some ANSI SGR color values contain underscores
#(e.g., "background_white").
#FUXME: Rename to ${ZESHY_STYLE_TO_COLOR_NAMES}. While
#${ZESHY_STYLE_TO_ANSI_SGR_NAMES} also seems like a feasible name, recall that
#the former may refer to pseudo-colors (e.g., "grey") not present in the latter.
#FUXME: Update the documentation; values are no longer keys of ${ZESHY_COLOR}
#but rather concatenations of keys of ${ZESHY_ANSI_SGR_NAME_TO_VALUE}
#internally delimited by `:`. Much more powerful.

#   string ansi_sgr_prefix color_name
#   integer color_name_index

    # List of color names split from the concatenated string of such names
    # corresponding to the current value of the map iterated below.
#   list color_names

    # Magic string prefixing all ANSI SGR escape sequences, consisting of the
    # magic string ANSI CSI prefixing all ANSI escape sequences in general
    # followed by the ANSI SGR value resetting color attributes to defaults.
#   ansi_sgr_prefix="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}"

    # Assign each color style its corresponding ANSI color. See
    # for_map_key_value_pairs() for further details.
#   string style color_names_string color_name
#   for    style color_names_string ("${(kv@)ZESHY_STYLE_TO_COLOR_NAMES}") {
        # If such style is empty, throw an exception. Since empty color names
        # are acceptable (e.g., to suggest the defaults for such style), do
        # *NOT* throw an exception if such color names string is empty.
#       (( ${#style} )) or die\
#           "${ZESHY_STYLE_TO_COLOR_NAMES} contains an empty style with color \"${color_names_string}\""

        # Force such color names string to lowercase. See lowercase_string() for
        # further details.
#       color_names_string="${(L)color_names_string}"

        # Foreground greyscale colors are notoriously off, assigning the color
        # white a greyish rather than white color value and defining no color
        # grey. To correct this, test whether the current color names contain
        # such colors and modify such names *BEFORE* splitting such names below.
        #
        # If such color names contain a white color in regular typeface (i.e.,
        # neither bold or weak), replace such color with intense white.
#       if is "${color_names_string}" == *"white"* and
#             "${color_names_string}" != *("bold"|"weak")* si {
#          color_names_string="${color_names_string//white/intense_white}"
        # Since "grey" is a zeshy-specific pseudo-color, such color values must
        # be aggregated together from genuine white and black color values.
#       } elif is "${color_names_string}" == *"grey"* si {
#           case  "${color_names_string}" {
            # If such color is bold, replace such color with non-bold white.
#           *"bold"*) color_names_string="${${color_names_string//grey/white}//bold}";;
            # If such color is weak, replace such color with non-weak black.
#           *"weak"*) color_names_string="${${color_names_string//grey/black}//weak}";;
            # Else, replace such color with bold black.
#           *)        color_names_string="${color_names_string//grey/black:bold}";;
#           }
#       }

        # Split such color names on colons. See
        # set_list_to_string_split_on_string() for further details.
#       color_names=( ${(s~:~)color_names_string} )

        # Initialize the mapping from such style to color value to the ANSI CSI,
        # a magic string prefixing all ANSI escape sequences.
#       ZESHY_STYLE_TO_COLOR_8[${style}]="${ansi_sgr_prefix}"

        # For each color name split from such string of names...
#       for (( color_name_index=1;
#              color_name_index <= ${#color_names};
#              color_name_index++ )) {
#              color_name="${color_names[${color_name_index}]}"

            # If such color name is empty (e.g., due to programmatically
            # deleting such name above), continue to the next.
#           (( ${#color_name} )) or continue

            # If such color name is unrecognized, throw an exception.
#           (( ${+ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]} )) or
#               die_unless_map_key ZESHY_ANSI_SGR_NAME_TO_VALUE "${color_name}"

            # Else, append the ANSI SGR value of such color.
#           ZESHY_STYLE_TO_COLOR_8[${style}]+="${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}"

            # If this is the last such value, terminate such sequence.
#           if (( color_name_index == ${#color_names} )) {
#               ZESHY_STYLE_TO_COLOR_8[${style}]+="${ZESHY_ANSI_SUFFIX_LAST}"
            # Else, delimit such value from subsequent values.
#           } else {
#               ZESHY_STYLE_TO_COLOR_8[${style}]+="${ZESHY_ANSI_SUFFIX_NEXT}"
#           }
#           print "ZESHY_STYLE_TO_COLOR_8[${style}]+=${color_name}"
#       }
#       print "ZESHY_STYLE_TO_COLOR_8[${style}]: ${ZESHY_STYLE_TO_COLOR_8[${style}]}color"

        # Set the monochrome color for such style to the empty string.
#       ZESHY_STYLE_TO_COLOR_2[${style}]=
#   }

    # Assign each prompt-specific color style its corresponding ANSI color,
    # delimited by "%{" and "%}" to prevent prompt colors from erroneously
    # contributing to prompt string length.
#   for style color_names_string ("${(kv@)ZESHY_STYLE_TO_COLOR_NAMES_PROMPT}") {
        # Set the prompt-specific color for this style
#       ZESHY_STYLE_TO_COLOR_PROMPT_8[${style}]="%{${ZESHY_STYLE_TO_COLOR_8[${style}]}%}"

#       ZESHY_STYLE_TO_COLOR_PROMPT_2[${style}]=
#   }

#       for color_name ("${color_names[@]}") {
#   string\
#       ansi_sgr_prefix\
#       color_name\
#       color_names_string\
#       style
        # followed by the ANSI SGR suffix delimiting such color from subsequent colors
        # Append the magic string terminating all ANSI SGR escape sequences.
#       ZESHY_STYLE_TO_COLOR_8[${style}]+="${ZESHY_ANSI_SUFFIX_LAST}"

    # Current color name being iterated below.
#   string 

    # Given the prior polychrome ANSI colors, set:
    #
    # * Style-specific colors, expanding to the corresponding ANSI color.
    # * Monochrome ANSI colors, expanding to the empty string.
    # * Prompt-specific colors, delimited by "%{" and "%}" to prevent such
    #   colors from contributing to prompt string length.
#   for_map_keys ZESHY_COLOR_8 color_name '
#       ZESHY_COLOR_2[${color_name}]=
#       ZESHY_COLOR_PROMPT_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_2[${color_name}]="%{${ZESHY_COLOR_2[${color_name}]}%}"
#   '

    # Assign each color style its corresponding ANSI color.
#   for_map_key_value_pairs ZESHY_STYLE_TO_COLOR_NAMES\
#       color_style_name color_name '
#       ZESHY_STYLE_TO_COLOR_2[${color_style_name}]="${ZESHY_COLOR_2[${color_name}]}"
#       ZESHY_STYLE_TO_COLOR_8[${color_style_name}]="${ZESHY_COLOR_8[${color_name}]}"
#   '

    # Assign each prompt-specific color style its corresponding ANSI color.
#   for_map_key_value_pairs ZESHY_STYLE_TO_COLOR_NAMES_PROMPT\
#       color_style_name color_name '
#       ZESHY_STYLE_TO_COLOR_PROMPT_2[${color_style_name}]="${ZESHY_COLOR_PROMPT_2[${color_name}]}"
#       ZESHY_STYLE_TO_COLOR_PROMPT_8[${color_style_name}]="${ZESHY_COLOR_PROMPT_8[${color_name}]}"
#   '

    #FUXME: Eliminate references to ZESHY_COLOR and ZESHY_COLOR_PROMPT.
#* ${ZESHY_COLOR}.
#* ${ZESHY_COLOR_PROMPT}.

#FUXME: Excise, as discussed below. And thank the Polynesian dieties, I may say.
#declare_global_with_stdin <<'/---'
#map ZESHY_COLOR
#
#Map lowercase color name followed by optional attributes to the ANSI escape code
#enabling such color on the current terminal. Colors include the canonical eight
#colors supported by most terminal emulators as well as "grey", a Zeshy-specific
#color leveraging "intense" ANSI attributes supported by most modern terminal
#emulators (e.g., rxvt-unicode). Color names include:
#
#.Canonical Color Names
#[cols=">strong,^,^,<emphasis",options="header"]
#|===============================================================================
#| color name              | foreground color | background color | typeface
#| reset                   | white | black | plain
#|
#| white                   | white || plain
#| grey                    | grey || plain
#| black                   | black || plain
#| red                     | red || plain
#| green                   | green || plain
#| blue                    | blue || plain
#| yellow                  | yellow || plain
#| magenta                 | magenta || plain
#| cyan                    | cyan || plain
#|
#| white_bold              | white || bold
#| grey_bold               | grey || bold
#| black_bold              | black || bold
#| red_bold                | red || bold
#| green_bold              | green || bold
#| blue_bold               | blue || bold
#| yellow_bold             | yellow || bold
#| magenta_bold            | magenta || bold
#| cyan_bold               | cyan || bold
#|
#| white_italic            | white || italic
#| grey_italic             | grey || italic
#| black_italic            | black || italic
#| red_italic              | red || italic
#| green_italic            | green || italic
#| blue_italic             | blue || italic
#| yellow_italic           | yellow || italic
#| magenta_italic          | magenta || italic
#| cyan_italic             | cyan || italic
#|
#| white_bold_italic       | white || bold italic
#| grey_bold_italic        | grey || bold italic
#| black_bold_italic       | black || bold italic
#| red_bold_italic         | red || bold italic
#| green_bold_italic       | green || bold italic
#| blue_bold_italic        | blue || bold italic
#| yellow_bold_italic      | yellow || bold italic
#| magenta_bold_italic     | magenta || bold italic
#| cyan_bold_italic        | cyan || bold italic
#|
#| white_background        || white | plain
#| grey_background         || grey | plain
#| black_background        || black | plain
#| red_background          || red | plain
#| green_background        || green | plain
#| blue_background         || blue | plain
#| yellow_background       || yellow | plain
#| magenta_background      || magenta | plain
#| cyan_background         || cyan | plain
#|
#| white_bold_background   || white | bold
#| grey_bold_background    || grey | bold
#| black_bold_background   || black | bold
#| red_bold_background     || red | bold
#| green_bold_background   || green | bold
#| blue_bold_background    || blue | bold
#| yellow_bold_background  || yellow | bold
#| magenta_bold_background || magenta | bold
#| cyan_bold_background    || cyan | bold
#|===============================================================================
#/---

#FUXME: Excise, as discussed below.
#declare_global_with_stdin <<'/---'
#map ZESHY_COLOR_2
#
#Map lowercase color name followed by optional attributes to the ANSI escape code
#enabling such color on monochrome terminals (i.e., _not_ supporting the
#canonical eight colors). See ${ZESHY_COLOR} for further details.
#/---
#
#FUXME: Excise, as discussed below.
#declare_global_with_stdin <<'/---'
#map ZESHY_COLOR_8
#
#Map lowercase color name followed by optional attributes to the ANSI escape code
#enabling such color on polychrome terminals (i.e., supporting at least the
#canonical eight colors). See ${ZESHY_COLOR} for further details and
#${ZESHY_COLOR_NAMES_8} for a list of such colors.
#/---

    #FUXME: O.K.; we reference this elsewhere in the codebase. Since
    #${ZESHY_COLOR_8} and friends are going away, shift this to the following:
    #
    #    ZESHY_STYLE_TO_COLOR_8[color.reset]="${ansi_sgr_prefix}${ZESHY_ANSI_SUFFIX_LAST}"
    #
    #What's sweet about this is that this method extends to setting colors in
    #such map as well. While we still require a generalized getter function for
    #obtaining arbitrarily complex color values, the above method suffices for
    #obtaining core color values. Indeed, perhaps we want to iteratively initialize
    #${ZESHY_STYLE_TO_COLOR_8} to contain values for simple keys "color.red",
    #"color.white", etc. We (obviously) can't contain all possible keys, but
    #just the core colors should suffice. I'm thinking we provide ":bold"-
    #suffixed alternatives for each (e.g., "color.red:bold"), due to the
    #ubiquity of bold colors, but basically stop there. (I mean, how many times
    #do we reference italic or weak colors in the codebase? Exactly.)
    #FUXME: Clearly, just set in configuration parcel @{color}.

    # Set the reset "color."
#   ZESHY_COLOR_8[reset]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_LAST}"


    #FUXME: Wrap this "for" loop in an additional outer "for" loop looping over all possible
    #color attributes (e.g., "bold", "bold_italic"). Hence, the outer loop loops color attributes
    #and the inner loop loops color names. While nesting in the opposite order also suffices, this
    #order permits simple setting of the pseudo-color "grey": namely, default *ALL* grey color-
    #attribute pairs to the corresponding black color-attribute pair value. This is important, as
    #the number of possible keys is becoming somewhat... unwieldy.
    #FUXME: Actually, this may not necessarily scale, particularly to 256-color terminals, which
    #would require (currently) 256*2*8 or 4096 entries. Assuming 16 bytes on average per such
    #entry, this is approximately 64Kb. It's certainly not something we'd want to maintain in
    #memory, in any case. That said, the current approach is certainly the simplest for 8-color
    #terminals and the only sensible means of implementing ${ZESHY_STYLE_TO_COLOR}.
    #FUXME: Actually, that's hardly true at all. Since actual zeshy code should basically *NEVER*
    #hardcode colors, colors are confined solely to "if_config/theme/color". While such colors
    #currently take the same name as keys of this map, there's no intrinsic reason they need do
    #so. Indeed, it'd be far more space-efficient and hence scaleable if:
    #
    #* ${ZESHY_COLOR_8} keys contain no underscores and hence are atomic, single identifiers
    #  (e.g., "red", "bold", "italic", "reset").
    #* The value for each such key should *NOT* be prefixed by "${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}" but
    #  instead simply resemble:
    #  "${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${key_name}]}${ZESHY_ANSI_SGR_SUFFUX_LAST}".
    #
    #Actually, is ${ZESHY_COLOR_8} even helpful anymore? No, really! Given the existing map
    #${ZESHY_ANSI_SGR_NAME_TO_VALUE}, I honestly wonder why we even require or desire ${ZESHY_COLOR_8}. It and
    #its ill-fated brethren are difficult to manage, introduce untoward complexity, etc. Instead,
    #why not just:
    #
    #* For each key-value pair of ${ZESHY_STYLE_TO_COLOR_NAMES},
    #* If such key matches glob ('white'|'grey'*), manually set the corresponding key-value pair
    #  of ${ZESHY_STYLE_TO_COLOR_8} (as below);
    #* Else, automatically set such key-value pair by splitting such key on underscore and then
    #  iteratively constructing the desired key, which should be prefixed by ${ZESHY_ANSI_CSI},
    #  suffixed by ${ZESHY_ANSI_SGR_SUFFUX_LAST}, and each interim SGR value excluding the *LAST*
    #  suffixed by ${ZESHY_ANSI_SGR_SUFFUX_NEXT}. Honestly, this is fairly trivial stuff.
    #
    #This isn't just an efficiency optimization, however. It's essential. Consider a color
    #"white_underscore_bold_italic". We're not exactly going to hardcode all possible
    #permutations, are we? No, of course not. 'Twould be silly, friends. And impossibly mundane.
    #
    #Make the above fix so, Mr. Beanito.

    # Normal and bold color attributes as ANSI escape codes.
#   string\
#       ansi_normal="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}"\
#       ansi_bold="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[bold]}${ZESHY_ANSI_SUFFIX_NEXT}"\
#       ansi_bold_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[bold]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[italic]}${ZESHY_ANSI_SUFFIX_NEXT}"\
#       ansi_italic="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[italic]}${ZESHY_ANSI_SUFFIX_NEXT}"\
#       ansi_underline="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[underline]}${ZESHY_ANSI_SUFFIX_NEXT}"
#       ansi_weak="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[reset]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[weak]}${ZESHY_ANSI_SUFFIX_NEXT}"

    # Set polychrome ANSI colors.
#   string color_name
#   for    color_name ("${ZESHY_COLOR_NAMES_8[@]}") {
        # Set foreground colors.
#       print "color (fg): ${color_name}\ncolor (bg): ${color_name}_background"
#       ZESHY_COLOR_8[${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}${ZESHY_ANSI_SUFFIX_LAST}"
#       ZESHY_COLOR_8[${color_name}_bold]="${ansi_bold}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}${ZESHY_ANSI_SUFFIX_LAST}"
#       ZESHY_COLOR_8[${color_name}_bold_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}${ZESHY_ANSI_SUFFIX_LAST}"
#       ZESHY_COLOR_8[${color_name}_italic]="${ansi_italic}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}${ZESHY_ANSI_SUFFIX_LAST}"
#       ZESHY_COLOR_8[${color_name}_underline]="${ansi_underline}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}${ZESHY_ANSI_SUFFIX_LAST}"
#       ZESHY_COLOR_8[${color_name}_weak]="${ansi_weak}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}]}${ZESHY_ANSI_SUFFIX_LAST}"

        # Set background colors.
#       ZESHY_COLOR_8[background_${color_name}]="${ansi_normal}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}_background]}${ZESHY_ANSI_SUFFIX_LAST}"
#       ZESHY_COLOR_8[background_${color_name}_bold]="${ansi_bold}${ZESHY_ANSI_SGR_NAME_TO_VALUE[${color_name}_background]}${ZESHY_ANSI_SUFFIX_LAST}"
#   }

    # Default foreground greyscale colors are notoriously "off," assigning
    # ${ZESHY_COLOR[white]} a grey rather than white color and defining no
    # corresponding suite of grey colors. To correct this:
    #
    # * Assign ${ZESHY_COLOR[white]} to new color ${ZESHY_COLOR[grey_bold]}.
    # * Assign bold black to all other foreground grey colors.
    # * Assign white and bold black to corresponding background grey colors.
#   ZESHY_COLOR_8[white]="${ansi_normal}${ZESHY_ANSI_SGR_NAME_TO_VALUE[white_intense]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey]="${ansi_bold}${ZESHY_ANSI_SGR_NAME_TO_VALUE[black]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_bold]="${ansi_normal}${ZESHY_ANSI_SGR_NAME_TO_VALUE[white]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_bold_italic]="${ansi_italic}${ZESHY_ANSI_SGR_NAME_TO_VALUE[white]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_italic]="${ansi_bold_italic}${ZESHY_ANSI_SGR_NAME_TO_VALUE[black]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_underline]="${ansi_bold_underline}${ZESHY_ANSI_SGR_NAME_TO_VALUE[black]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_weak]="${ansi_normal}${ZESHY_ANSI_SGR_NAME_TO_VALUE[black]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_background]="${ansi_normal}${ZESHY_ANSI_SGR_NAME_TO_VALUE[white_background]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR_8[grey_bold_background]="${ansi_bold}${ZESHY_ANSI_SGR_NAME_TO_VALUE[white_background]}${ZESHY_ANSI_SUFFIX_LAST}"

    # Index of the current color name being iterated below.
#   integer color_name_index

#       (( ${#color_names_string} )) or
#           die '${ZESHY_STYLE_TO_COLOR_NAMES} contains an empty value'

    #  suffixed by ${ZESHY_ANSI_SUFFIX_LAST}, and each interim SGR value excluding the *LAST*
    #  suffixed by ${ZESHY_ANSI_SUFFIX_NEXT}.
#           for (( color_name_index=1; color_name_index <= "${color_names[@]}") {

#FUXME: No; no; no. This is all *HORRIBLE*. There's a fundamental reason we
#refrain from performing arbitrarily complex logic at the top-level, and this is
#it: it simply doesn't work, and no degree of obscure handwaving will make it
#work.
#FUXME: I'm mildly concerned of how the "zsh/terminfo" module behaves when the
#current shell is *NOT* attached to a terminal device (e.g., when executing
#headless under a cronjob). Check documentation and probably just try it. I
#expect a fatal error, but... who knows? In such case, we'll need to only load
#such module if attached to a terminal device, which is rather easy to test. In
#such case, we should probably just default ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED
#to 2 (i.e., monochrome), ensuring plaintext output under cronjobs, which is
#almost always what you want. (Color is not particularly helpful in logfiles,
#after all. In fact, it's pretty much always a hindrance!)
#
#Of course, the exact same issue applies to the current implementation -- but
#it's worth noting, all the same.
#FUXME: O.K.; so, there's a subtlety here. It's not sufficient simply to write
#the contents of such variables into a script; we also need to serialize
#*ANOTHER* script containing logic sufficient to initialize such globals on-
#the-fly, so that a comparison between the prior and current values of such
#globals can be made. In this case, the latter script would contain the
#following logic:
#
#* Load the "zsh/terminfo" module (if attached to a terminal device, of course).
#* Perform the equivalent of get_terminal_color_count_quantized(), capturing the
#  result into ${ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED}, which happily already
#  exists below.
#* To implement the prior steps, simply call something resembling:
#
#    string gtccq
#    gtccq="$(get_function_binding get_terminal_color_count_quantized)"
#    append_file_with_string "${ZESHY_USER_TEMPORARY_CACHE_FILE}" "
#       zmodload zsh/terminfo
#       ${gtccq}
#       string_global ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED
#       ZESHY_TERMINAL_COLOR_COUNT_QUANTIZED=\"$(get_terminal_color_count_quantized)\""
#
#Now, we know what you're thinking: but isn't the above *LESS* efficient than
#the current approach? It requires a script to be executed, after all. But aside
#from the additional serialization of such script -- no. Why? Because we
#*ALWAYS* load such module and *ALWAYS* initialize such global anyway. It has to
#be done, so it had might as well be done early. The significant upside is that
#it eliminates all of the complexity with multiple maps below. That will become
#increasingly important, as the number of color thresholds (e.g., 256) and hence
#number of such maps increases.
#
#Oh! Jeez. I forgot about the corresponding prompt maps. Well, that makes this
#all the more dire then! Make this happen, man. This is beyond overkill,
#currently.
#FUXME: This is overly complex. Eliminate both ${ZESHY_STYLE_TO_COLOR_2} and
#${ZESHY_STYLE_TO_COLOR_8} by simply making digest compilation dependent on
#terminal colors. To do so properly, however, we'll need to add a new function
#add_zeshy_digest_dependency_global() to "src/digest"; as with other such
#dependencies, these dependencies must be cached to a temporary script under
#"~/.zeshy/cache" -- ideally, the same script as current dependencies are cached
#to. Actually, no! Separate scripts. Why? Because this allows efficient *AND*
#very simple comparison, below. It's worth it for the simplicity alone.
#
#Happily, there's a fairly efficient way to compare the contents of a list of
#globals:
#
#* Pass the names of such globals to get_variable_binding(), capturing the
#  output to a string local.
#* Compare such string local to the contents of the cached script containing
#  the prior output of get_variable_binding() (via :write_script_with_var_binding(),
#  of course).
#* If the two strings differ, one or more such globals have changed, suggesting
#  zeshy's digest file to be outdated.
#
#Since path dependencies change *MUCH* more frequently than global dependencies
#under typical circumstances, only perform the above comparison if no path
#dependencies have changed.
#
#So, which globals should.

# Ideally, maps ${ZESHY_STYLE_TO_COLOR_2} and ${ZESHY_STYLE_TO_COLOR_8} could be
# eliminated in favor of an add_zeshy_digest_dependency_global()-based approach
# testing the number of terminal colors (as stored in a global) within
# :is_zeshy_digest_outdated(). Unfortunately, assembling such global is
# sufficiently non-trivial to complicate such an approach. Since the current
# approach below is both efficient and reasonably simple, we prefer it instead.


# otherwise be preferable, since
# such function .
# (e.g., to colorify exception handling output)
#   die_unless_shell_interactive

#FUXME: Ugh. Actually, the suggestions below clearly demonstrate that this
#parcel is not a good fit for 
#FUXME: This is overly complex. Eliminate both ${ZESHY_STYLE_TO_COLOR_2} and
#${ZESHY_STYLE_TO_COLOR_8} by simply making digest compilation dependent on
#terminal colors. To do so properly, however, we'll need to add a new function

#, maps relating to colors must.
#
#Map color style names to prompt color names. `zeshy` uses this map to set the
#convenience map ${ZESHY_STYLE_TO_COLOR_PROMPT}, which other `zeshy` functions
#access to colorize shell prompt output. Color names are any valid keys of map
#${ZESHY_COLOR_PROMPT}, whose corresponding values expand to the prompt-specific
#ANSI escape code enabling such color at the shell prompt on the current terminal
#(e.g., `grey_bold_italic`, the color grey in bold-italic typeface). See
#${ZESHY_STYLE_TO_COLOR_NAMES} for further details.
#
#== Prompt Colors ==
#
#${ZESHY_STYLE_TO_COLOR_NAMES_PROMPT} maps prompt colors are mapped separately by .
#Since prompt and non-prompt color values differ, . While prompt colors must be delimited
#by `%{` and `%}` to prevent such colors from erroneously contributing to the
#prompt length, non-prompt colors require no such delimitation. Hence, `zeshy`
#maps the two separately. the former are mapped by
#${ZESHY_STYLE_TO_COLOR_NAMES_PROMPT}.

#and hence _not_ intended to be
#expanded by `zeshy` runnables, which should instead expand
#${ZESHY_STYLE_TO_COLOR} -- a general-purpose map from non-prompt style to color
#value initialized using this map during digest recompilation.
#
#During digest recompilation, `zeshy` converts this
#configuration-only map into ${ZESHY_STYLE_TO_COLOR}, a general-purpose map
#`zeshy` runnables access to
#colorize output. Specifically, for each key-value pair of this map, `zeshy`
#defines the same key of map ${ZESHY_STYLE_TO_COLOR} to expand to the corresponding
#ANSI escape code. For example, if this map contains key
#`output_call_stack.colon` with value `grey`, `zeshy` adds a corresponding key
#`output_call_stack.colon` with value `\E\[0;30m` (i.e., the ANSI escape code
#resetting the current foreground color to grey).

    # If the current terminal supports less than the canonical eight colors,
    # assume such terminal to be monochrome (i.e., colorless).
#   if (( terminal_color_count < 8 )) {
#       terminal_color_count=2
    # Else, assume such terminal to support exactly such colors.
#   } else {
#       terminal_color_count=8
#   }

    # Validate sanity. Since this function is typically called from a subshell,
    # avoid calling die_unless_stdout_terminal().
#FUXME: While the current implementation certainly works, it's overkill. Almost
#*ALL* modern-day terminals, even tunnelled over SSH, support the 8 canonical
#colors. Consequently, ZESHY_COLOR and similar globals should be *BAKED* into
#the digest file with default values supporting such colors. *IF*, on Zeshy
#startup, we find the current terminal to not in fact support such colors,
#manually iterate through each such map, setting each key value to the empty
#string. (A bit slower, but... hey, if your terminal doesn't even support
#colors, you probably have greater issues than marginal Zeshy slowdown on
#startup.)
#FUXME: That said, 256-color supporting terminals might actually be the most
#common. Contemplate. Consider. Revise.

#FUXME: Rename to ${ZESHY_COLOR_FOR_TERMINAL_COLOR_COUNT_2}.
#FUXME: Rename to ${ZESHY_COLOR_FOR_TERMINAL_COLOR_COUNT_8}.
#FUXME: Rename to ${ZESHY_COLOR_NAMES_FOR_TERMINAL_COLOR_COUNT_8}.
#FUXME: Rename to ${ZESHY_STYLE_TO_COLOR_FOR_TERMINAL_COLOR_COUNT_2}.
#FUXME: Rename to ${ZESHY_STYLE_TO_COLOR_FOR_TERMINAL_COLOR_COUNT_8}.
#   for color_name ( $(get_map_keys ZESHY_COLOR_8) ) {
#       ZESHY_COLOR_2[${color_name}]=
#       ZESHY_COLOR_PROMPT_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_2[${color_name}]="%{${ZESHY_COLOR_2[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_8[${color_name}]="%{${ZESHY_COLOR_8[${color_name}]}%}"
#   }

    # Assign each color style its corresponding ANSI color.
#   for color_style_name color_name (
#       $(get_map_key_values ZESHY_STYLE_TO_COLOR_NAMES) ) {
#       ZESHY_STYLE_TO_COLOR_2[${color_style_name}]="${ZESHY_COLOR_2[${color_name}]}"
#       ZESHY_STYLE_TO_COLOR_8[${color_style_name}]="${ZESHY_COLOR_8[${color_name}]}"
#   }

    # Assign each prompt-specific color style its corresponding ANSI color.
#   for color_style_name color_name (
#       $(get_map_key_values ZESHY_STYLE_TO_COLOR_NAMES_PROMPT) ) {
#       ZESHY_STYLE_TO_COLOR_PROMPT_2[${color_style_name}]="${ZESHY_COLOR_PROMPT_2[${color_name}]}"
#       ZESHY_STYLE_TO_COLOR_PROMPT_8[${color_style_name}]="${ZESHY_COLOR_PROMPT_8[${color_name}]}"
#   }

## ....................{ SETTERS                            }....................
#declare_function_with_stdin <<'/---'
#void reset_terminal_color(void)
#
#Reset foreground and background terminal colors to their defaults: under most
#terminals, white foreground on black background with regular typeface.
#/---
#function reset_terminal_color() {
#    output_string_sans_newline "${ZESHY_STYLE_TO_COLOR[color.reset]-}"
#}

#| color name              | description
#| reset                   | default foreground and background color
#|
#| white                   | white foreground color in regular typeface
#| grey                    | grey foreground color in regular typeface
#| black                   | black foreground color in regular typeface
#| red                     | red foreground color in regular typeface
#| green                   | green foreground color in regular typeface
#| blue                    | blue foreground color in regular typeface
#| yellow                  | yellow foreground color in regular typeface
#| magenta                 | magenta foreground color in regular typeface
#| cyan                    | cyan foreground color in regular typeface
#|
#| white_bold              | white foreground color in bold typeface
#| grey_bold               | grey foreground color in bold typeface
#| black_bold              | black foreground color in bold typeface
#| red_bold                | red foreground color in bold typeface
#| green_bold              | green foreground color in bold typeface
#| blue_bold               | blue foreground color in bold typeface
#| yellow_bold             | yellow foreground color in bold typeface
#| magenta_bold            | magenta foreground color in bold typeface
#| cyan_bold               | cyan foreground color in bold typeface
#|
#| white_italic            | white foreground color in italic typeface
#| grey_italic             | grey foreground color in italic typeface
#| black_italic            | black foreground color in italic typeface
#| red_italic              | red foreground color in italic typeface
#| green_italic            | green foreground color in italic typeface
#| blue_italic             | blue foreground color in italic typeface
#| yellow_italic           | yellow foreground color in italic typeface
#| magenta_italic          | magenta foreground color in italic typeface
#| cyan_italic             | cyan foreground color in italic typeface
#|
#| white_bold_italic       | white foreground color in bold italic typeface
#| grey_bold_italic        | grey foreground color in bold italic typeface
#| black_bold_italic       | black foreground color in bold italic typeface
#| red_bold_italic         | red foreground color in bold italic typeface
#| green_bold_italic       | green foreground color in bold italic typeface
#| blue_bold_italic        | blue foreground color in bold italic typeface
#| yellow_bold_italic      | yellow foreground color in bold italic typeface
#| magenta_bold_italic     | magenta foreground color in bold italic typeface
#| cyan_bold_italic        | cyan foreground color in bold italic typeface
#|
#| white_background        | white background color in regular typeface
#| grey_background         | grey background color in regular typeface
#| black_background        | black background color in regular typeface
#| red_background          | red background color in regular typeface
#| green_background        | green background color in regular typeface
#| blue_background         | blue background color in regular typeface
#| yellow_background       | yellow background color in regular typeface
#| magenta_background      | magenta background color in regular typeface
#| cyan_background         | cyan background color in regular typeface
#|
#| white_bold_background   | white background color in bold typeface
#| grey_bold_background    | grey background color in bold typeface
#| black_bold_background   | black background color in bold typeface
#| red_bold_background     | red background color in bold typeface
#| green_bold_background   | green background color in bold typeface
#| blue_bold_background    | blue background color in bold typeface
#| yellow_bold_background  | yellow background color in bold typeface
#| magenta_bold_background | magenta background color in bold typeface
#| cyan_bold_background    | cyan background color in bold typeface
#|===============================================================================
#declare_global '
#map ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_SUPERUSER
#
#Map color style names to prompt color names if the current user is the superuser
#(i.e., root) or ignore such names otherwise. See
#${ZESHY_STYLE_TO_COLOR_NAMES_PROMPT} for further details.
#'
#ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_SUPERUSER=(
#    # startup_zeshy_terminal_prompt().
#    startup_zeshy_terminal_prompt.brace                   grey_bold
#    startup_zeshy_terminal_prompt.host                    red
#    startup_zeshy_terminal_prompt.user                    red_bold
#    startup_zeshy_terminal_prompt.path                    yellow
#    startup_zeshy_terminal_prompt.prior_command_succeeded yellow_bold
#    startup_zeshy_terminal_prompt.prior_command_failed    magenta_bold
#    startup_zeshy_terminal_prompt.input                   white_bold
#)
#
#declare_global '
#map ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_NONSUPERUSER
#
#Map color style names to prompt color names if the current user is the superuser
#(i.e., root) or ignore such names otherwise. See
#${ZESHY_STYLE_TO_COLOR_NAMES_PROMPT} for further details.
#'
#ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_NONSUPERUSER=(
#    # startup_zeshy_terminal_prompt().
#    startup_zeshy_terminal_prompt.brace                   grey_bold
#    startup_zeshy_terminal_prompt.host                    cyan
#    startup_zeshy_terminal_prompt.user                    cyan_bold
#    startup_zeshy_terminal_prompt.path                    blue
#    startup_zeshy_terminal_prompt.prior_command_succeeded blue_bold
#    startup_zeshy_terminal_prompt.prior_command_failed    red_bold
#    startup_zeshy_terminal_prompt.input                   white_bold
#)

    #FUXME: Add a new function append_map_to_map() implementing such
    #functionality.

    # If the current user is the superuser, add superuser-specific prompt color
    # styles to such global; otherwise, add non-superuser-specific prompt color
    # styles to such global.
#   if is_superuser; then
#       ZESHY_STYLE_TO_COLOR_NAMES_PROMPT+=(
#           ${(kv@)ZESHY_PROMPT_STYLE_TO_COLOR_NAME_IF_SUPERUSER} )
#   else
#   fi

#       set_map_to_map ZESHY_COLOR        ZESHY_COLOR_2
#       set_map_to_map ZESHY_COLOR_PROMPT ZESHY_COLOR_PROMPT_2
#       set_map_to_map ZESHY_STYLE_TO_COLOR  ZESHY_STYLE_TO_COLOR_2
#   # If the current terminal supports at least the canonical eight colors,
#   # assume such terminal to be monochrome (i.e., colorless).
#   else # elif (( terminal_color_count >= 8 )); then
#       set_map_to_map ZESHY_COLOR        ZESHY_COLOR_8
#       set_map_to_map ZESHY_COLOR_PROMPT ZESHY_COLOR_PROMPT_8
#       set_map_to_map ZESHY_STYLE_TO_COLOR  ZESHY_STYLE_TO_COLOR_8

#/==============================v===============================================\
#| color style name             | application                                   |
#>==============================+===============================================<
#| punctuation                  | punctuation with no semantic meaning          |
#| punctuation_semantic         | punctuation with semantic meaning             |
#>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<
#| say_caller                   | caller name printed by say(), cry(), etc.     |
#\==============================^===============================================/

#abstracting all colors prefixing common substrings of output
#(e.g., punctuation) to . 
#FUXME: Interesting. We have no incentive to use underscore rather than space
#here, do we? The latter remains both easier to type and read. Woops! False. zsh
#handles spaces in keys... poorly. Pass.
#FUXME: Completely document *ALL* supported color names, after ensuring the
#implementation works as desired.
#FUXME: Reduce to either run_hook_on_zeshy_startup_if_interactive() or
#run_hook_on_zeshy_startup_if_stdout_terminal(). Probably the
#latter, I should think, which is more general; the former's too specific.
#   print "ZESHY_COLOR[red]: ${ZESHY_COLOR[red]}hmm"
    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_no_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #precompile_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
#   precompile_zeshy_terminal_color_8

#declare_function '
#void precompile_zeshy_terminal_color_8(void)
#
#Define color globals for terminals supporting between 8 to 255 colors.
#'
#function precompile_zeshy_terminal_color_8() {

#       color_background_name="${color_name}_background"
#   for color_name (${color_names[@]} grey) {
#       ZESHY_COLOR_PROMPT[${color_name}]="%{${ZESHY_COLOR[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BACKGROUND[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_BOLD[${color_name}]="%{${ZESHY_COLOR_BOLD[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_BOLD_BACKGROUND[${color_name}]="%{${ZESHY_COLOR_BOLD_BACKGROUND[${color_name}]}%}"
#       ZESHY_COLOR_PROMPT_ITALIC[${color_name}]="%{${ZESHY_COLOR_ITALIC[${color_name}]}%}"
#   }

    # Define foreground greyscale colors. The default definitions assign
    # ${ZESHY_COLOR_BLACK} a somewhat unreadable quasi-black color value and
    # ${ZESHY_COLOR_WHITE} a somewhat grey rather than white color value.
#   ZESHY_COLOR[black]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[normal]}${ZESHY_ANSI_SUFFIX_NEXT}${ZESHY_ANSI_SGR_NAME_TO_VALUE[black_intense]}${ZESHY_ANSI_SUFFIX_LAST}"
#   ZESHY_COLOR[grey]="${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_NAME_TO_VALUE[black]}${ZESHY_ANSI_SUFFIX_LAST}"

    #FUXME: Defer to global list ${ZESHY_COLOR_NAMES}, instead.
    # List of all such color names, excluding pseudo-color "grey".
#   list color_names
#   color_names=( white black red green blue yellow magenta cyan )

#FUXME: Hmmm; we appear to never set this. Do so here!
#declare_global '
#string ZESHY_COLOR_PROMPT_RESET
#
#Prompt escape code resetting foreground and background colors to defaults.
#'

# Declare and document reset colors.
#declare_global '
#string ZESHY_COLOR_RESET
#
#ANSI escape code resetting foreground and background colors to defaults.
#'

# Declare and document general purpose colors.
#declare_global '
#map ZESHY_COLOR
#
#Map lowercase color name to ANSI escape code foregrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_WEAK
#
#Map lowercase color name to ANSI escape code foregrounding such color weakly.
#'
#declare_global '
#map ZESHY_COLOR_BOLD
#
#Map lowercase color name to ANSI escape code foregrounding such color brightly.
#'
#declare_global '
#map ZESHY_COLOR_ITALIC
#
#Map lowercase color name to ANSI escape code foregrounding such color italicized.
#'
#declare_global '
#map ZESHY_COLOR_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_BOLD_BACKGROUND
#
#Map lowercase color name to ANSI escape code backgrounding such color brightly.
#'

# Declare and document prompt-specific colors.
#declare_global '
#map ZESHY_COLOR_PROMPT
#
#Map lowercase color name to prompt escape foregrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_WEAK
#
#Map lowercase color name to prompt escape foregrounding such color weakly.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_BOLD
#
#Map lowercase color name to prompt escape foregrounding such color brightly.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_ITALIC
#
#Map lowercase color name to prompt escape foregrounding such color italicized.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color.
#'
#declare_global '
#map ZESHY_COLOR_PROMPT_BOLD_BACKGROUND
#
#Map lowercase color name to prompt escape backgrounding such color brightly.
#'

#FUXME: I've given a great deal of thought to this. Unfortunately, the current
#approach is demonstrably bad. For one, separating colors between maps precludes
#convenient dynamic usage resembling the following:
#
#   string ZESHY_COLOR_NAME_PUNCTUATION='grey_bold'
#   print "test${ZESHY_COLOR[${ZESHY_COLOR_NAME_PUNCTUATION}]}: yay!"
#
#I assume you see what we did there? We could have chosen
#ZESHY_COLOR_NAME_PUNCTUATION to be any composite of a color and color
#attributes, including: "grey", "grey_italic", "grey_bold_italic", "grey_weak",
#"grey_weak_background", and so on. As one can see, that's an enormous number of
#keys for each color... but not a single key more than we currently have,
#dispersed as they are across ten or so map globals. Centralize, my Self.
#
#That's great, but that's not the sole reason. By centralizing all colors into a
#single map, we *VASTLY* simplify startup logic for initializing ${ZESHY_COLOR}.
#On an 8-color terminal? No problem; just perform a *SINGLE MAP COPY*:
#
#   ZESHY_COLOR=( "${ZESHY_COLOR_8[@]}" )
#
#Done. Without such approach, we'd need a positively obscene number of maps --
#basically, ten or see for each number of terminal colors threshold. We're
#talking in upwards of fourty maps, which is simply obscenity. A different way
#is possible, friends.

    #FUXME: We probably want to implement helper functions resembling:
    #
    #* startup_terminal_2_colors(), if no color support.
    #* startup_terminal_8_colors(), if typical color support.
    #* startup_terminal_256_colors(), if 256 color support.
    #FUXME: Note that the KDE terminal application appears to support arbitrary
    #RGB values. It would be great if that becomes an eventual ad-hoc standard.
    #FUXME: Now that we've shifted such initialization from startup_zeshy() to
    #precompile_zeshy(), we'll probably need to implement something resembling:
    #
    #* Declare new list globals corresponding to such colors: e.g.,
    #  * ${ZESHY_COLOR_2} whose elements all expand to the empty string (e.g.,
    #    ${ZESHY_COLOR_2[red]} == "").
    #  * ${ZESHY_COLOR_8} whose elements all expand to the ANSI strings below.
    #  * ${ZESHY_COLOR_256} whose elements all expand to the 256 indices? Hmm.
    #* Initialize all such globals here.
    #* Define a new startup_zeshy_terminal_color() function conditionally
    #  initializing ${ZESHY_COLOR} from such globals depending on the current
    #  terminal: e.g.,
    #
    #      (( $(is_terminal_color_count) == 8 )) and {
    #          ZESHY_COLOR=(      "${ZESHY_COLOR_8[@]}" )
    #          ZESHY_COLOR_BOLD=( "${ZESHY_COLOR_BOLD_8[@]}" )
    #          ...
    #       }
    #
    #That's it! Reasonably efficient and largely simple.
# Avoid confining such function to interactive shells and/or shells whose
# standard output is attached to a terminal device. Sufficiently many CLI
# applications are now color-aware (e.g., "less", "vim") that outputting color
# when running non-interactively is largely a non-issue.
#   die_unless_shell_interactive
# Moreover, I've always found such behavior
# exceedingly annoying in other applications (e.g., "ls"), and don't see.
#FUXME: Honestly, "_BOLD" makes little sense. It's not bold; it's *BRIGHTER*.
#Rename ZESHY_COLOR_BOLD to ZESHY_COLOR_BRIGHT and so forth. Likewise, rename
#"_WEAK" to "_FAINT" for orthogonality. (Don't forget "ansi_weak" to "ansi_faint",
#too.)

#FUXME: Map ${ZESHY_ANSI_SGR_NAME_TO_VALUE} suggests we could profitably implement _FAINT and
#_STANDOUT versions, as well. Test us up! *YES*. Great: the "italic" attribute
#is implemented as italics under many terminals. We absolutely want that. :)
#   :remove_string_text_matching_glob "${*}" "${ZESHY_ANSI_CSI}${ZESHY_ANSI_SGR_GLOB}"
#   print_string "${*//${~ZESHY_ZSH_COLOR_GLOB}/}"
#FUXME: Rename to remove_string_ansi_color().
#FUXME: Rename to remove_string_zsh_color().
#   print_string "${*//${ZESHY_ANSI_CSI}${~ZESHY_ANSI_SGR_GLOB}/}"
#Glob matching the 2-byte ANSI Select Graphic Rendition (SGR) prefixing all
#color-specific ANSI escape codes. Dismantled, this is:
# Handle all terminal color functionality *OTHER* than defining such colors. See
# "00-setup/" for the latter.
