#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *conditionally function definers* (i.e., functions dynamically defining
other functions in a conditional manner usually dependent on current system and
user state).
/---

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void :define_function_if(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string if_test1, string then_function_body1, ...,
                     string else_function_body)

Define the passed function as the first *function body* (i.e., arbitrary code
implementing such function) whose preceding *condition* (i.e., arbitrary code
interpretable as an `if` statement test implicitly delimited by `{` and `}`)
succeeds or to the last such body if no such condition succeeds, prefixed by the
passed *function body prefix* (i.e., arbitrary code to be unconditionally
prepended to such body) and suffixed by the passed *function body suffix* (i.e.,
arbitrary code to be unconditionally appended to such body): e.g.,

.:define_function_if()
==========================================
[source]
------------------------------------------
>>> :list ZESHY_DISORDERS; ZESHY_DISORDERS=( heathen mad nihilist )
>>> :undefine_map_key commands heathen mad nihilist
>>> :define_function_if\
...     :output_disorder\
...     'die_if_args' ''\
...     'heathen' 'output_string\
...         "A benighted creature who has the folly to worship something that he
...          can see and feel."'\
...     'mad' 'output_string\
...         "Affected with a high degree of intellectual independence."'\
...     'nihilist 'output_string\
...         "A Russian who denies the existence of anything but Tolstoi. The
...          leader of the school is Tolstoi."'\
...     'output_string\
...         "CYNIC, n. A blackguard whose faulty vision sees things as they are,
...          not as they ought to be."'\
>>> :print_function :output_disorder
function :output_disorder() {
    (( # )) && die "Expected no arguments."
    output_string\
        "CYNIC, n. A blackguard whose faulty vision sees things as they are,
         not as they ought to be."
}
>>> :output_disorder
CYNIC, n. A blackguard whose faulty vision sees things as they are,
not as they ought to be.
------------------------------------------
==========================================
/---
function :define_function_if() {
    # Validate sanity.
    # string function_name,
    # string function_body_prefix,
    # string function_body_suffix,
    # string if_test1, string then_function_body1, ...,
    #                  string else_function_body)
    die_unless_args_6_or_more\
        'Expected one function name, one function body prefix, one function body suffix, one or more pairs of one test and one function body, and one fallback function body.'
    :string\
        function_name__dfi="${1}"\
        function_body_prefix__dfi="${2}"\
        function_body_suffix__dfi="${3}"\
        function_body_else__dfi="${@[-1]}"\
        function_body__dfi
    :map test_to_function_body__dfi

    # Remove such arguments from the argument list. All remaining arguments
    # constitute the map from command name to function body. See
    shift_args_3
    pop_arg

    # If the number of remaining arguments is *NOT* even and hence does *NOT*
    # constitute a map, throw an exception.
    (( # % 2 == 0 )) or die\
        'Expected each test to be paired with a function body.'

    # For each paired condition and function body, test if such condition
    # succeeds and, if so, define such function as such body.
    :string test__dfi function_body_then__dfi
    for     test__dfi function_body_then__dfi ("${@}") {
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # Synchronize with :define_function_if_pathable().
        #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # If such condition fails, such test was either syntactically invalid
        # *OR* syntactically valid and genuinely failed. Discriminate between
        # the two. In the former case, throw an exception. In the latter case,
        # skip to the next condition.
        { eval "${test__dfi}" } silent_stderr: or {
            # Capture such output, ignoring the expected failure.
            :string test_error__dfi; test_error__dfi="$(
                { eval "${test__dfi}" } to_stdout: or ignore_failure)"

            # If such test failed with no error, such test is syntactically
            # valid and genuinely failed. Skip to the next command.
            if is -z "${test_error__dfi}" si {
                continue
            # Else, such test is syntactically invalid. Convert such
            # nonfatal error into a fatal exception.
            } else {
                # For readability, strip the prefixing "zsh: ".
                test_error__dfi="${test_error__dfi#zsh: }"
                die 'Test-dependent function '${function_name__dfi}'() test "'${test__dfi}'" failed:'$'\n'${test_error__dfi}
            }
        }

        # Else, such condition succeeded. Enable the corresponding body.
        function_body__dfi="${function_body_then__dfi}"

        # Cease iteration.
        break
    }

    # If no such condition succeeded, enable the fallback body.
    is -n "${function_body__dfi}" si or
        function_body__dfi="${function_body_else__dfi}"

    # Define such function as such body.
    define_function "${function_name__dfi}" \
"    ${function_body_prefix__dfi}
    ${function_body__dfi}
    ${function_body_suffix__dfi}"
}

declare_function_with_stdin <<'/---'
void :define_function_if_pathable(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string command_name1, string function_body1, ...,
    string pathables_list_name)

Define the passed function whose implementation requires any one of several
*command alternatives* (i.e., external commands offering similar functionality)
to run the first such command in the passed list of such alternatives that is
currently *pathable* (i.e., in the current command hash, typically synonymous
with in the current user's ${PATH}), given:

* The passed list of such alternatives, in descending order of preference.
* The passed *function body prefix* (i.e., code to be unconditionally prepended
  to the command-specific function body).
* The passed *function body suffix* (i.e., code to be unconditionally appended
  to the command-specific function body).
* A map from each command name in the passed list of such alternatives to the
  command-specific function body running such command. For convenience, such map
  should be passed as pairs of additional arguments rather than as an actual
  map.

For example:

.:define_function_if_pathable()
==========================================
[source]
------------------------------------------
>>> :list ZESHY_ALTERNATIVES; ZESHY_ALTERNATIVES=(
...     anarchism capitalism communism socialism )
>>> commands[anarchism]='true'
>>> :undefine_map_key commands capitalism communism socialism
>>> :define_function_if_pathable\
...     :output_alternative\
...     'die_if_args' ''\
...     'anarchism' 'output_string\
...         "Political theory founded on the observation that since few men are
...          wise enough to rule themselves, even fewer are wise enough to rule
...          others."'\
...     'capitalism' 'output_string "Under capitalism, man exploits man."'\
...     'communism'  'output_string "Under communism, it's just the opposite."'\
...     'socialism'  'output_string\
...         "Socialism is the only system for nationalizing compassion so that
...          individuals may be done with it."'\
...     ZESHY_ALTERNATIVES
>>> :print_function :output_alternative
function :output_alternative() {
    (( # )) && die "Expected no arguments."
    output_string\
        "Political theory founded on the observation that since few men are
         wise enough to rule themselves, even fewer are wise enough to rule
         others."'
}
>>> :output_alternative
Political theory founded on the observation that since few men are
wise enough to rule themselves, even fewer are wise enough to rule
others.
------------------------------------------
==========================================
/---
function :define_function_if_pathable() {
    # Validate sanity.
    die_unless_args_6_or_more\
        'Expected one function name, one function body prefix, one function body suffix, one or more pairs of one command name and one function body, and one pathables list name.'
    :string\
        function_name__dfip="${1}"\
        function_body_prefix__dfip="${2}"\
        function_body_suffix__dfip="${3}"\
        list_name_pathables__dfip="${@[-1]}"
    :map command_name_to_function_body__dfip

    # If such list is not, throw an exception.
    is "${(tP)list_name_pathables__dfip-}" == 'array'* si or die\
         '${'${list_name_pathables__dfip}'} undefined or not a list.'

    # Remove such arguments from the argument list. All remaining arguments
    # constitute the map from command name to function body.
    shift_args_3
    pop_arg

    # If the number of remaining arguments is *NOT* even and hence does *NOT*
    # constitute a map, throw an exception.
    (( # % 2 == 0 )) or die 'Expected even number of arguments.'

    # Convert all remaining arguments to such map.
    command_name_to_function_body__dfip=( "${@}" )

    # For each command in the passed list of command alternatives, test if such
    # command exists and, if so, define such function with such command.
    :bool is_pathable__dfip
    :string command_name__dfip
    for     command_name__dfip ("${(@P)list_name_pathables__dfip}") {
        # If such map contains no such command, throw an exception.
        (( ${+command_name_to_function_body__dfip[${command_name__dfip}]} )) or die\
            'Command-dependent function '${function_name__dfip}'() command "'${command_name__dfip}'" unimplemented.'

        # If such command contains whitespace, assume such command to be a
        # conditional testing the existence of two or more commands. To do so,
        # programmatically convert such conditional to a genuine zsh test (e.g.,
        # from "catabolic and collapse" to
        # "(( ${+commands[catabolic]} )) && (( ${+commands[collapse]} ))").
        if is "${command_name__dfip}" == *' '* si {
            # To permit map lookups below, preserve the original command string
            # by performing modifications on this local copy.
            :string test__dfip="${command_name__dfip}"

            # If such conditional contains inherently dangerous shell-reserved
            # characters, throw an exception. This includes "`", the obsoleted
            # command substitution prefix, and "$", both the expansion and new
            # command substitution prefix. While command substitutions are
            # patently unsafe (e.g., "$(rm -rf /)"), expansions also support
            # dynamic evaluation of arbitrary code (e.g.,
            # ":string evil='rm -rf /'; : ${(e)evil}") and hence are little
            # safer. Prohibit both by prohibiting their prefixing characters.
            is "${test__dfip}" != *['$`'*] si or die\
                'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" contains unsafe shell-reserved characters "$" and/or "`".'

            # Globally replace in such conditional (in order):
            #
            # * All space-delimited words "or" and "and" with "||" and "&&".
            #   Since both "or" and "and" are valid shell identifiers, do so
            #   *BEFORE* replacing shell identifier characters.
            # * All longest contiguous substrings of shell identifier characters
            #   (signifying unquoted command names) with a test testing the
            #   existence of such command. While command names can technically
            #   contain arbitrary characters, we currently only support common
            #   command names containing no shell-reserved characters and hence
            #   requiring no quoting or escaping.
            test__dfip="${${${test__dfip// ##or ##/ || }// ##and ##/ && }//(#m)[[:IDENT:]]##/(( \${+commands[${MATCH}]\} ))}"   # hack vim highlighting issues: "}"
            # print "command conditional: ${test__dfip}" 1>&2

            # Skip to the next command unless such test dynamically succeeds.
            # If such test fails, such test was either syntactically invalid
            # *OR* syntactically valid and genuinely failed. Discriminate
            # between the two and, in the former case, throw an exception.
            { eval "${test__dfip}" } silent_stderr: or {
                # Capture such output, ignoring the expected failure.
                :string test_error__dfip; test_error__dfip="$(
                    { eval "${test__dfip}" } to_stdout: or ignore_failure)"

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                if is -z "${test_error__dfip}" si {
                    continue
                # Else, such test is syntactically invalid. Convert such
                # nonfatal error into a fatal exception.
                } else {
                    # For readability, strip the prefixing "zsh: ".
                    test_error__dfip="${test_error__dfip#zsh: }"
                    die 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" failed:'$'\n'${test_error__dfip}
                }
            }
        # Else, such command contains no whitespace. Skip to the next command
        # unless such command is pathable. See is_pathable() for further details.
        } else {
            (( ${+commands[${command_name__dfip}]} )) or continue
        }

        # Since the current iteration did *NOT* continue, such command or
        # commands is pathable. Define such function with such command.
        define_function "${function_name__dfip}" \
"    ${function_body_prefix__dfip}
    ${command_name_to_function_body__dfip[${command_name__dfip}]}
    ${function_body_suffix__dfip}"

        # Cease iteration.
        report_success
    }

    # If no such command exists, avoid defining such function. Do *NOT* report
    # failure and hence induce an exception, as this function is commonly called
    # during digest compilation from the top-level.
    report_success
}

# --------------------( WASTELANDS                         )--------------------
