#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle core integer functionality.
/---

#FIXME: We've come to the timely conclusion that we significantly mucked up our
#calling conventions. While the nomenclature below was noble, it's increasingly
#inappropriate for the following reasons:
#
#* Newer zeshy functions predominantly accept a variable name rather than value
#  as their first argument. This is sensible, since most things of interest are
#  retained in variables rather than constructed on-the-fly. While the latter
#  would probably dominate (and do under customary high-level languages), the
#  extreme inefficiency of subshells effectively mandates the passing of
#  variable names rather than values.
#* Moreover, passing variable names rather than values results in much cleaner
#  and more readably terse function calls (e.g.,
#  ":call_function variable_name1 'Hello, yollo!'" versus
#  ":call_function "${variable_name1}" 'Hello, yollo!'").
#* Moreover, it's also inherently safer. While callers *SHOULD* behave in a
#  safe manner by double-quoting variable expansions, there's nothing in the
#  language that mandates this. Indeed, we can be guaranteed that third-party
#  callers will pretty much do so only haphazardly, thus guaranteeing subtle
#  bugs inevitably blamed on us.
#
#In short, zeshy functions should predominantly accept a variable name rather
#than value as their first argument. This includes the functions below.
#However, given such shift, the functions below should be renamed from
#"die_unless_integer" to ":die_unless_string_int" and similarly from
#"is_integer" to ":is_string_int". Then, such functions should be strictly
#passed a *STRING* variable and test such variable's value as such.
#
#This is all *VERY* sensible and increasingly essential, given the large-scale
#change in zeshy's direction. It is, however, unfortunate we didn't adopt this
#direction earlier. *shrug*
#FIXME: Wait-wait-wait. No, no, and no. There are a few reasons why:
#
#* Requiring the caller to explicitly expand variables is *ACTUALLY* a good
#  thing, as it makes explicit what is a variable intended to be modified
#  (unquoted) and what is a variable intended only to be read (quoted).
#* Additionally, list and map contents are untyped strings. This is probably the
#  principal reason. *ANY* function not modifying the passed scalar argument
#  should simply accept an untyped string. That's it. Period.
#
#The rule for deciding whether or not to pass a variable name or value to any
#given function is very simple: does that function modify such variable or not?
#If so, pass its name; otherwise, its value. Since the caller is already
#required to know which of the two it's doing for any given function call, *NO*
#nomenclature changes are required. Yes, that's right. *NO* changes. Thus, it's
#quite sensible to have a function :is_bool_true() accepting a boolean *VALUE*
#and another function :enable_bool() accepting a boolean *NAME*. Again, there is
#*NO* confusion here. The rule is simple. Now continue to follow it.
#
#We'll keep this comment here until it fully sinks in. Do *NOT* go down the road
#of the first FIXME comment above. It's the wrong road. It always was. Follow
#the the rule, and we won't go astray.

# ....................{ EXCEPTIONS                         }....................
#FIXME: Actually, this function only matches decimal integers. Hence, rename
#this function to die_unless_decimal() and create a new die_unless_integer()
#function properly matching *ALL* integer strings. Such functions needs to match
#both "0x"- and "16#"-style base prefixes.
declare_function_with_stdin <<'/---'
void die_unless_integer(
    string value,
    string error_message = "\"${value}\" not an integer value.")

Throw an exception with the passed message unless the passed string is an
integer. See is_integer() for further details.
/---
function die_unless_integer() {
    die_unless_args_1_to_2\
        'Expected one string and optional error message.'
    :string value="${1}"
    is_integer "${value}" or die "${2-\"${value}\" not an integer value.}"
}

declare_function_with_stdin <<'/---'
void die_unless_integers(string value1, ...)

Throw an exception with a stock message unless all passed strings are integers.
See is_integer() for further details.
/---
function die_unless_integers() {
    die_unless_args 'Expected one or more strings.'
    :string value
    for     value ("${@}") { die_unless_integer "${value}" }
}

# ....................{ EXCEPTIONS ~ emptiness             }....................
declare_function_with_stdin <<'/---'
void die_unless_integer_nonzero(
    string integer,
    string error_message = "\"${integer}\" not a nonzero integer value.")

Throw an exception with the passed message unless the passed string is a nonzero
integer. See is_integer_nonzero() for further details.
/---
function die_unless_integer_nonzero() {
    die_unless_args_1_to_2\
        'Expected one string and optional error message.'
    :string integer="${1}"
    is_integer_nonzero "${integer}" or
        die "${2-\"${integer}\" not a nonzero integer value.}"
}

# ....................{ EXCEPTIONS ~ sign                  }....................
declare_function_with_stdin <<'/---'
void die_unless_integer_positive(
    string integer,
    string error_message = "\"${integer}\" not a positive integer value.")

Throw an exception with the passed message unless the passed string is a
positive integer. See is_integer_positive() for further details.
/---
function die_unless_integer_positive() {
    die_unless_args_1_to_2\
        'Expected one string and optional error message.'
    :string number="${1}"
    is_integer_positive "${number}" or
        die "${2-\"${number}\" not a positive integer value.}"
}

declare_function_with_stdin <<'/---'
void die_unless_integer_negative(
    string integer,
    string error_message = "\"${integer}\" not a negative integer value.")

Throw an exception with the passed message unless the passed string is a
negative integer. See is_integer_negative() for further details.
/---
function die_unless_integer_negative() {
    die_unless_args_1_to_2\
        'Expected one string and optional error message.'
    :string number="${1}"
    is_integer_negative "${number}" or
        die "${2-\"${number}\" not a negative integer value.}"
}

declare_function_with_stdin <<'/---'
void die_unless_integer_nonnegative(
    string integer,
    string error_message = "\"${integer}\" not a nonnegative integer value.")

Throw an exception with the passed message unless the passed string is a
nonnegative integer. See is_integer_nonnegative() for further details.
/---
function die_unless_integer_nonnegative() {
    die_unless_args_1_to_2\
        'Expected one string and optional error message.'
    :string number="${1}"
    is_integer_nonnegative "${number}" or
        die "${2-\"${number}\" not a nonnegative integer value.}"
}

declare_function_with_stdin <<'/---'
void die_unless_integer_nonpositive(
    string integer,
    string error_message = "\"${integer}\" not a nonpositive integer value.")

Throw an exception with the passed message unless the passed string is an
nonpositive integer. See is_integer_nonpositive() for further details.
/---
function die_unless_integer_nonpositive() {
    die_unless_args_1_to_2\
        'Expected one string and optional error message.'
    :string number="${1}"
    is_integer_nonpositive "${number}" or
        die "${2-\"${number}\" not a nonpositive integer value.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_integer(string value)

Report success if the passed string is an *integer* (i.e., string consisting of
optional negative sign and one or more digits).
/---
function is_integer() {
    # Dismantled, this is:
    #
    # * "(-|)", matching an optional prefixing negative sign.
    # * "<->", matching one or more digits. An obscure, but helpful, zsh-ism.
    die_unless_arg 'Expected one string.'
    is "${1}" == ('-'|)<-> si
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_nonzero(integer value)

Report success if the passed integer is *nonzero* (i.e., any integer except 0).
/---
function is_integer_nonzero() {
    die_unless_arg 'Expected one integer.'
    :string number="${1}"
    die_unless_integer "${number}"
    (( number ))
}

# ....................{ TESTERS ~ sign                     }....................
declare_function_with_stdin <<'/---'
[status: boolean] is_integer_positive(string integer)

Report success if the passed string is a positive integer.
/---
function is_integer_positive() {
    die_unless_arg 'Expected one integer.'
    :string number="${1}"
    die_unless_integer "${number}"
    (( number > 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_negative(string integer)

Report success if the passed string is a negative integer.
/---
function is_integer_negative() {
    die_unless_arg 'Expected one integer.'
    :string number="${1}"
    die_unless_integer "${number}"
    (( number < 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_nonnegative(string integer)

Report success if the passed string is a *nonnegative integer* (i.e., integer
either 0 or positive).
/---
function is_integer_nonnegative() {
    die_unless_arg 'Expected one integer.'
    :string number="${1}"
    die_unless_integer "${number}"
    (( number >= 0 ))
}

declare_function_with_stdin <<'/---'
[status: boolean] is_integer_nonpositive(string integer)

Report success if the passed string is a *nonpositive integer* (i.e., integer
either 0 or negative).
/---
function is_integer_nonpositive() {
    die_unless_arg 'Expected one integer.'
    :string number="${1}"
    die_unless_integer "${number}"
    (( number <= 0 ))
}

# --------------------( WASTELANDS                         )--------------------
#FUXME: Incorrect. *ALL* such functions should die unless the passed integer is
#actually an integer, as only that accords with caller expectations. Note
#interestingly that that also induces correct behavior when called by a
#die_unless_*() function (i.e., an exception is thrown, and in fact a more
#appropriately named exception). See "parity" below for what such
#implementations should resemble.

#FUXME: Rename to convert_integer_to_string_separated_by_commas().
#FUXME: Actually, this should be localized and hence renamed to
#convert_integer_to_string_localized(). Not all locales delimit with commas, as
#we well know. Come to think, this might *ALREADY* be localized in such fashion.
#Research what "awk" actually does with the "'" in "%'d".
    #FUXME: Localize this. Not terribly hard, since zsh module "localeinfo"
    #provides map value "${localeinfo[THOUSEP]}" providing such string.
#       print "${integer}" | awk "{ printf \"%'d\n\", \$1 }"
#   die_unless_arg 'expected one string'
#   is "${1}" == '-'<-> si   # mildly clever optimization
#   string integer_min="${1:-0}" integer_max="${2:-32767}"
#FUXME: Rename "_integer" to "_integer" everywhere.
# ....................{ TESTERS ~ value                    }....................
#FUXME: Bad. Accept string values rather than variable names, as is the standard
#for scalar types. Of course, in that case, we'd might as well just shift all
#"string/integer" functionality here, renaming "string_integer" to simply
#"integer" everywhere. *ACTUALLY, THAT SOUNDS LIKE A BLOODY BRILLIANT IDEA.*
#Make it so, ensign.
#declare_function '
#boolean is_integer_positive(string variable_name)
#
#Report true if the passed variable is an integer > 0.
#'
#function is_integer_positive() {
#    die_unless_arg 'expected one string'
#    string variable_name__iip="${1}"
#    is_variable_integer "${variable_name__iip}" and (( ${(P)variable_name__iip} > 0 ))
#}

#declare_function '
#boolean is_integer_nonnegative(string variable_name)
#
#Report true if the passed variable is an integer >= 0.
#'
#function is_integer_nonnegative() {
#    die_unless_arg 'expected one string'
#    string variable_name__iin="${1}"
#    is_variable_integer "${variable_name_iin}" and (( ${(P)variable_name__iin} >= 0 ))
#}

#FUXME: Excise.
#declare_function '
#void die_unless_integer_positive(
#  string variable_name,
##  string error_message = "\"${variable_name}\" not a positive integer")
#
#Throw an exception unless the passed variable is an integer > 0.
#'
#function die_unless_integer_positive() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duip="${1}"
#    is_integer_positive "${variable_name__duip}" or
#        die "${2:-\"${variable_name__duip}\" not a positive integer}"
#}

#FUXME: Excise.
#declare_function '
#void die_unless_integer_nonnegative(
#  string variable_name,
#  string error_message = "\"${variable_name}\" not a nonnegative integer")
#
#Throw an exception unless the passed variable is an integer >= 0.
#'
#function die_unless_integer_nonnegative() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string variable_name__duin="${1}"
#    is_integer_nonnegative "${variable_name__duin}" or
#        die "${2:-\"${variable_name__duin}\" not a nonnegative integer}"
#}

#FUXME: This now strikes me as rather wrong. Lists and maps are a reasonable
#rule to nomenclature rules as they can only be accessed by named; integers,
#floats, and other scalar types however are always accessible by their expanded
#values. Consequently, it strikes me as *MUCH* more intuitive to rename
#die_unless_integer() and is_integer() to die_unless_variable_integer() and
#is_variable_integer(). Then excise the is_integer_*() functions; they're
#superfulous, really. Replace them with calls to similar is_integer_*()
#functions -- *WHICH BY THE WAY SHOULD THEMSELVES BE RENAMED BACK TO
#is_integer_*() BUT STILL OPERATE ON EXPANDED STRING SCALARS* and probably
#consequently shifted back into this component.
#
#O.K.; so, we have two nomenclature styles insofar as variables are concerned:
#
#* Scalar-specific functions accepting typeless scalar values.
#* Non-scalar-specific functions accepting typed variable names.
#
#This is perfectly fine and in fact necessary. But don't confuse the two. Stay
#consistent. Let's fix this up, eh? We should document this design decision
#somewhere -- it's rather core.
#FUXME: Actually, consistency *ABSOLUTELY* takes precedence. Ignore all of the
#above.

# (i.e., constrained to natural numbers and
# negatives of such numbers)
