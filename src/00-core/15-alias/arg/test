#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *argument option testers* (i.e., functions testing `-`-prefixed arguments
passed to functions and scripts).
/---

#FIXME: I'm increasingly disgruntled with this nomenclature. We ideally want to
#define a new alias is_arg:() reporting success if the caller passed an argument
#equal to the string following such alias. But we currently define is_arg() to
#report success if exactly one argument was passed! Clearly, as also entreated
#below, we need to rename all runnables operating on argument *COUNTS* rather
#than *CONTENTS* -- ideally suffixing "_arg" with "_count" in such runnables. A
#fairly large job, but the current approach is simply decrepit.

# ....................{ EXCEPTIONS                         }....................
# Define exception handlers *BEFORE* testers. Where the former internally call
# the latter (e.g., die_unless_arg_index() calling is_arg_index()), this ensures
# that the function rather than alias version of such tester is called.
#
# Since argument counts are nonnegative, defining hypothetical functions
# die_unless_args_at_most() and is_args_at_most() is unhelpful; functions
# die_unless_args_in_range() and is_args_in_range() with the first passed
# argument 0 already implement such functionality.

#FIXME: Nomenclature's not quite right at all, implying this function to return
#success if the passed string equals the concatenation of the current argument
#list -- which isn't at all what this function does. Consider renaming to, say,
#die_unless_arg_count_equals() and likewise below.
#FIXME: Right. Replace "args_" with "arg_count" in all other *GENERALIZED*
#functions below. Hence, die_unless_args_at_least() becomes
#die_unless_arg_count_at_least() but die_unless_args_2_to_3() should (at least
#for now) retain the current nomenclature.

declare_alias_with_stdin <<'/---'
void die_unless_args_equals(
    integer arg_count,
    string exception_message = "Expected ${arg_count} arguments.")

Throw an exception with the passed message unless the caller passed the passed
number of arguments.
/---
   alias die_unless_args_equals='die_unless_args_equals ${#}'
function die_unless_args_equals() {
    die_unless_args_2_to_3\
        'Expected one argument count and optional error message.'
    is_integer_equals "${@[1,2]}" or {
        :string arg_count="${2}"
        die "${3-Expected ${arg_count} arguments.}"
    }
}

declare_alias_with_stdin <<'/---'
void die_unless_args_at_least(
    integer arg_count,
    string exception_message = "Expected at least ${arg_count} arguments.")

Throw an exception with the passed message unless the caller passed at least the
passed number of arguments.
/---
   alias die_unless_args_at_least='die_unless_args_at_least ${#}'
function die_unless_args_at_least() {
    die_unless_args_2_to_3\
        'Expected one argument count and optional error message.'
    is_integer_at_least "${@[1,2]}" or {
        :string arg_count="${2}"
        die "${3-Expected at least ${arg_count} arguments.}"
    }
}

declare_alias_with_stdin <<'/---'
void die_unless_args_in_range(
    integer minimum_arg_count,
    integer maximum_arg_count,
    string exception_message =
        "Expected between [${minimum_arg_count}, ${maximum_arg_count}] arguments.")

Throw an exception with the passed message unless the caller passed a number of
arguments in the passed range. See is_args_in_range() for further details.
/---
   alias die_unless_args_in_range='die_unless_args_in_range ${#}'
function die_unless_args_in_range() {
    die_unless_args_3_or_4\
        'Expected one minimum count, one maximum count, and one message.'
    is_integer_in_range "${@[1,3]}" or {
        :string arg_count_minimum="${2}" arg_count_maximum="${3}"
        die "${4-Expected between [${arg_count_minimum}, ${arg_count_maximum}] arguments.}"
    }
}

# ....................{ EXCEPTIONS ~ index                 }....................
declare_alias_with_stdin <<'/---'
void die_unless_arg_index(
    integer arg_index,
    string exception_message =
        "Argument index ${arg_index} invalid (i.e., not in [1, ${#}]).")

Throw an exception with the passed message unless the passed integer is a valid
index into the current argument list. See is_arg_index() for further details.
/---
   alias die_unless_arg_index='die_unless_arg_index ${#}'
function die_unless_arg_index() {
    die_unless_args_2_to_3\
        'Expected one argument index and optional error message.'
    is_arg_index "${@[1,2]}" or {
        :string arg_count="${1}" arg_index="${2}"
        die "${3-Argument index ${arg_index} invalid (i.e., not in [1, ${arg_count}]).}"
    }
}

# ....................{ EXCEPTIONS ~ match                 }....................
declare_alias_with_stdin <<'/---'
void die_unless_arg_equals(string arg)

Throw an exception with a stock message unless the caller passed an argument
matching the passed glob. See is_arg_equals() for further details.
/---
   alias die_unless_arg_equals='die_unless_arg_equals "${@}"'
function die_unless_arg_equals() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one string.'
    :string arg="${@[-1]}"
    pop_arg

    # Find such argument or throw an exception. See is_arg_equals() further
    # details and die_unless_arg_matches_glob() for further discussion.
    (( ${@[(ie)${arg}]} <= ${#} )) or die "Expected argument \"${arg}\"."
}

declare_alias_with_stdin <<'/---'
void die_unless_arg_matches_glob(string glob)

Throw an exception with a stock message unless the caller passed an argument
matching the passed glob. See is_arg_matches_glob() for further details.
/---
   alias die_unless_arg_matches_glob='noglob die_unless_arg_matches_glob "${@}"'
function die_unless_arg_matches_glob() {
    # Validate sanity.
    die_unless_args 'Expected zero or more arguments and one glob.'
    :string glob="${@[-1]}"
    pop_arg

    # Match such glob or throw an exception. Since is_arg_matches_glob() is an
    # alias that has yet to be defined, such alias cannot be expanded here.
    # While could be corrected by defining such alias before this function,
    # such alias is simplistic enough that redefining it here is no burden. See
    # such alias for further details.
    (( ${@[(i)${~glob}]} <= ${#} )) or
        die "Expected argument matching \"${glob}\"."
}

# ....................{ TESTERS ~ count                    }....................
#FIXME: Add examples!
declare_alias_with_stdin\
    '[status: bool] is_args_equals(integer arg_count)'\
    'is_integer_equals ${#}' <<'/---'
Report success if the caller passed the passed number of arguments.
/---

declare_alias_with_stdin\
    '[status: bool] is_args_at_least(integer arg_count)'\
    'is_integer_at_least ${#}' <<'/---'
Report success if the caller passed at least the passed number of arguments.
/---

declare_alias_with_stdin\
    '[status: bool] is_args_in_range(
        integer minimum_arg_count, integer maximum_arg_count)'\
    'is_integer_in_range ${#}' <<'/---'
Report success if the caller passed a number of arguments in the passed range
(i.e., greater than or equal to the passed minimum and less than or equal to the
passed maximum).
/---

# ....................{ TESTERS ~ index                    }....................
#FIXME: Uhm; *DOES* this actually account for negative indices? It certainly
#should, as the nomenclature implies.
declare_alias_with_stdin <<'/---'
[status: bool] is_arg_index(integer arg_index)

Report success if the passed integer is a valid index into the current argument
list (i.e., is in the range `[1, ${#}]`).
/---
# Such implementation may appear inefficient but is fairly reasonable given the
# subtleties involved in accounting for negative indices.
   alias is_arg_index='is_arg_index ${#}'
function is_arg_index() {
    die_unless_args_2 'Expected one argument count and one argument index.'
    is_integer_in_range "${2}" 1 "${1}"
}

# ....................{ TESTERS ~ match                    }....................
declare_alias_with_stdin '[status: bool] is_arg_equals:(string arg)'\
    '{ (( ${@[(ie)$(get_stdin)]} <= ${#} )) } <<<' <<'/---'
Report success if the caller passed the passed argument.
/---

declare_alias_with_stdin '[status: bool] is_arg_matches_glob(string glob)'\
    '{ (( ${@[(i)$(get_stdin)]} <= ${#} )) } <<<' <<'/---'
Report success if the caller passed an argument matching the passed glob.
/---

# ....................{ TESTERS ~ option                   }....................
#FIXME: Aliases below should be dynamically constructed rather than manually
#defined -- for both sanity and efficiency. Arguably, they should also inline
#such test rather than call a setter. Contemplate, in any case.
#FIXME: If *NOT* compiling a debug build, such aliases should *NOT* be reduced
#to noops -- unlike the comparable is_arg_*() aliases, which should be. In other
#words, no significant changes here.

declare_alias_with_stdin '[status: bool] is_arg_nonoption(void)'\
    'is_arg_nonoptions_1' <<'/---'
Report success if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---

declare_alias_with_stdin '[status: bool] is_arg_nonoptions(void)'\
    'is_arg_nonoptions_1_or_more' <<'/---'
Report success if the caller passed at least one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---

declare_alias_with_stdin '[status: bool] is_arg_nonoptions_0(void)'\
    '{
        :int count__ian0; set_integer_to_arg_nonoption_count count__ian0
        (( count__ian0 == 0 ))
    }' <<'/---'
Report success if the caller passed no non-option arguments. See
set_integer_to_arg_nonoption_count() for further details.
/---

declare_alias_with_stdin '[status: bool] is_arg_nonoptions_1(void)'\
    '{
        :int count__ian1; set_integer_to_arg_nonoption_count count__ian1
        (( count__ian1 == 1 ))
    }' <<'/---'
Report success if the caller passed one non-option argument. See
set_integer_to_arg_nonoption_count() for further details.
/---

declare_alias_with_stdin '[status: bool] is_arg_nonoptions_1_or_more(void)'\
    '{
        :int count__ian1om; set_integer_to_arg_nonoption_count count__ian1om
        (( count__ian1om >= 1 ))
    }' <<'/---'
Report success if the caller passed at least one non-option arguments. See
set_integer_to_arg_nonoption_count() for further details.
/---

declare_alias_with_stdin '[status: bool] is_arg_nonoptions_1_to_3(void)'\
    '{
        :int count__ian1t3; set_integer_to_arg_nonoption_count count__ian1t3
        (( 1 <= count__ian1t3 && count__ian1t3 <= 3 ))
    }' <<'/---'
Report success if the caller passed between one to three non-option arguments.
See set_integer_to_arg_nonoption_count() for further details.
/---

# --------------------( WASTELANDS                         )--------------------
#FUXME: I've increasingly come to appallingly obvious conclusion that 

#declare_parcel_as_script_with_stdin <<'/---'
#Handle *argument lists* (i.e., lists of all arguments passed to functions and
#scripts).
#/---

#FUXME: As with @{nonoption}, refactor all such aliases into alias/function
#pairs, where the alias passes the argument list to the corresponding function.
#Significantly better, for a variety of patently clear reasons.

#set_string_to_stdin 
#       set -- ${@[1,$(( -1 - count__pa ))]}
#alias shift_arg='shift -- 1'

#FUXME: These are *TERRIBLE*. I didn't know about list ${argv} at the time. But
#given that list exists, we can replace these with considerably more efficient
#implementations *NOT* recopying the majority of the current argument list. For
#example:
#
#    alias pop_arg='argv[-1]=( )'
#alias pop_arg='set -- ${@[1,-2]}'
#   set -- ${@[1,$(( -1 - count__pa ))]}
# ....................{ SETTERS ~ pipe                     }....................
#FUXME: These are excrutiatingly dangerous at present, without some means of
#reliably testing whether or not the current command is directly or merely
#indirectly participating in a pipe. *FIX OR EXCISE.* (Ideally, excise, I should
#think.)

#declare_alias '
#void prepend_args_with_stdin_if_piped(void)
#
#If the current function or script is piped input, prepend such input to the
#beginning of the current argument list.
#'
#alias prepend_args_with_stdin_if_piped='is_stdin_pipe and {
#    set -- "$(< /dev/stdin)" "${@}"
#    close_stdin
#}'
#
#declare_alias '
#void append_args_with_stdin_if_piped(void)
#
#If the current function or script is piped input, append such input to the end
#of the current argument list.
#'
#alias append_args_with_stdin_if_piped='is_stdin_pipe and {
#    set -- "${@}" "$(< /dev/stdin)"
#    close_stdin
#}'
#
##declare_alias '
##void set_args_to_stdin_if_piped(void)
##
##If standard input to the current function or script is an open pipe, replace
##the current argument list with such input.
##'
##alias set_args_to_stdin_if_piped='is_stdin_pipe and {
##    set -- "$(< /dev/stdin)"
##    close_stdin
##}'
#
##FUXME: Replace with "shift_args 2".
##declare_function_with_stdin <<'/---'
#void shift_args_2(void)
#
#Remove the first two arguments from the current argument list.
#/---
#alias shift_args_2='shift 2'

#FUXME: Replace with "shift_args 3".
#declare_function_with_stdin <<'/---'
#void shift_args_3(void)
#
#Remove the first three arguments from the current argument list.
#/---
#alias shift_args_3='shift 3'

#FUXME: Replace with "pop_args 3".
#declare_function_with_stdin <<'/---'
#void pop_args_2(void)
#
#Remove the last two arguments from the current argument list.
#/---
#alias pop_args_2='set -- ${@[1,-3]}'

#FUXME: Replace with "pop_args 3".
#declare_function_with_stdin <<'/---'
#void pop_args_3(void)
#
#Remove the last three arguments from the current argument list.
#/---
#alias pop_args_3='set -- ${@[1,-4]}'

#FUXME: Replace all aliases below with expansions of is_args_equals() above (or
#of similar new aliases).
#FUXME: O.K.; here's the plan. Implement such alias with herestrings to:
#
#* If passed the empty string, test whether passed at least one argument.
#* Else, test whether passed exactly such number of arguments.
#
#To do so, I've discovered a helpful herestring trick:
#
#alias is_args='{
#   ...  # omitted for brevity
#} <<<""'
#
#Note the trailing "". Yes, I've tested this. It works. Without such "", zsh
#complains "zsh: parse error near \n" on receiving no string or integer.
#FUXME: Nah. That's pure nonsense. It works, but try explaining it to anyone.
#O.K.; the new idea is to leave this as is and replace all aliases below with a
#single alias as follows:
#
#alias is_args_equals='{
#   (( # == $(< /dev/stdin) ))
#} <<<'
# ....................{ GETTERS                            }....................
#declare_function_with_stdin <<'/---'
#string get_args(void)
#
#Get the current argument list as a concatenated string.
#/---
#alias get_args='print -r -- ${*}'

#FUXME: No longer fond of the shift_*() <-> pop_*() dichotomy. It's exceedingly
#perlish and, to be honest, not altogether legible; after all, why "shift" for
#removing prefixing arguments and "pop" for removing suffixing arguments? It's
#all terribly arbitrary. It requires cognitive thought (...at least, in my case)
#to process the nuance of such operation, when it should be obvious; so:
#
#* unprepend_arg() and unappend_arg(). (Nah -- too much cognitive load, again.)
#* shift_arg() and remove_arg(). Decent, if a little vague.
#* shift_arg() and strip_arg(). Decent, if a little vague.
#* remove_arg() and truncate_arg(). Not the best, really.
#* remove_arg() and abbreviate_arg(). Not the best, really.
#* remove_arg() and pop_arg(). Hmm; I rather like "curtail", which gets to
#  the heart of the matter. Can we find an anologous verb for the beginning? Ah:
#  "decapitate". Hilarious, but let's find synonyms. ;] Ah-ha!
#* shift_arg() and pop_arg(). Absurdly clever, I say! ...surely?
#* unhead_arg() and detail_arg(). Slightly more orthogonal.
#* shift_arg() and detail_arg(). More memorable. Ah, wait -- there *IS* no
#  verb "detail". Back to the original:
#* shift_arg() and pop_arg(). This coincides nicely with one character
#  difference between "prepend" and "append", as well.
#
#I print_message we go for it. shift() and pop() are terrible, irregardless of perl and
#Javascript precedent. If users *REALLY* demanded, we could certainly support
#both styles (say, in a third-party plugin). Go-go, yo?

#FUXME: Rename to shift_arg(), shift_args_2(), and shift_args_3() respectively.
#Actually, the latter two are blatantly obsolete: just call "shift_args 2" and
#"shift_args 3" instead. Ah, wait -- for orthoganlity with pop_args_*() aliases,
#keep them.

# While we would prefer to embedd math operators in alias names (e.g.,
# "die_unless_args_>=_4"), current zsh operators already reserve such strings.
# Instead, settle for descriptions of such operators.

# ....................{ GETTERS                            }....................
# string get_code_dying_unless_math(string math_condition)
#
# Get an evaluatable string throwing an exception unless the caller evaluating
# such string satisfies the passed math condition (typically on the number of
# passed arguments): e.g.,
#
#     # Make an alias throwing an exception unless exactly 42 arguments were
#     # passed to the current function or script.
#     >>> alias die_unless_args_42="$(\
#     ...   get_code_dying_unless_math_math '# == 42')"
#function get_code_dying_unless_math() {
#    (( # == 1 )) || die 'expected one condition'
#    print "(( ${1} )) || die"
#}

# string get_code_dying_unless_math_stdin_piped(
#   string test_condition)
#
# Get an evaluatable string throwing an exception unless the caller evaluating
# such string satisfies:
#
# * The passed math condition, if such caller's standard input is *NOT* an open
#   pipe. This is the typical case.
# * The passed math condition with all integers implicitly decremented by one,
#   if such caller's standard input is an open pipe. In such case, assume such
#   caller will subsequently prepend or append such input to the current
#   argument list as an additional argument.
#function get_code_dying_unless_math_stdin_piped() {
    # Validate passed arguments.
#    (( # == 1 )) || die 'expected one condition'
#    local test_unless_piped="${1}" test_if_piped

    # Construct a condition in the case of piped input from the passed condition,
    # decrementing integers in such condition by one. Dismantled, this is:
    #
    # * "(#m)", capturing each match into string global ${MATCH}.
    # * "//", matching each...
    # * "<->", positive integer (i.e., a substring of one or more digits).
    # * "$(( ${MATCH} - 1 ))", replacing such integer by an integer one less.
#    test_if_piped="${test_unless_piped//(#m)<->/$(( ${MATCH} - 1 ))}"

    # Get such code.
#    print "if [[ -p /dev/stdin ]]; then (( ${test_if_piped} )); else (( ${test_unless_piped} )); fi || die"
#}
# ....................{ EXCEPTIONS ~ pipe                  }....................
#FIXME: Rename to die_unless_args_2_or_1_if_stdin_piped().
# void die_unless_args_2_unless_stdin_piped(
#   string error_message)
#
# Die with the passed message unless the caller passed either:
#
# * Two arguments, if standard input is not an open pipe.
# * One argument, if standard input is an open pipe. In such a case, assume the
#   callee will prepend or append such input to the current argument list as an
#   additional argument.
#alias die_unless_args_2_unless_stdin_piped="$(\
#    get_code_dying_unless_math_stdin_piped '# == 2')"

#FIXME: Rename to die_unless_args_2_to_3_or_1_to_2_if_stdin_piped().
# void die_unless_args_2_to_3_unless_stdin_piped(
#   string error_message)
#
# Die with the passed message unless the caller passed either:
#
# * Two or three arguments, if standard input is not an open pipe.
# * One or two arguments, if standard input is an open pipe. In such a case,
#   assume the callee will prepend or append such input to the current argument
#   list as an additional argument.
#alias die_unless_args_2_to_3_unless_stdin_piped="$(\
#    get_code_dying_unless_math_stdin_piped '# == 2 || # == 3')"

# void parse_arg_options(string arg_spec1, string arg_spec2, ...)
#
# Parse the current argument list according to the passed "zparseopts"-formatted
# argument specifications (e.g., "h", short option "-h" accepting no argument;
# "-count:", long option "--count" requiring a trailing argument) into local map
# ${arg_options}: e.g.,
#
#   # Set fake command-line arguments.
#   >>> set -- -d --ad --crest "glass arm shattering"
#
#   # Parse such arguments as:
#   #
#   # * "--ad", a long option followed by no value.
#   # * "--crest", a long option followed by some value.
#   # * "--wing", a long option optionally followed by some value.
#   >>> parse_arg_options d e -ad -crest: -wing::
#
#   # Validate such parsing.
#   >>> is_map_key arg_options '-d' and print 'option "-d" parsed'
#   option "-d" parsed
#   >>> print_string_with_escapes\
#   ...   "-d: ${arg_options[-d]}\n--ad: ${arg_options[--crest]}\n--wing: ${arg_options[--wing]}"
#   -d:
#   --crest: glass arm shattering
#   --wing:
#
# See "zparseopts" under "man zshmodules" for argument specification details.

# Dismantled, this is:
#
# * "-D", removing *ONLY* parsed options from the current argument list.
# * "-E", *NOT* halting parsing at the first option *NOT* matching a passed
#   option specification (i.e., preserving options with no such specification).
# * "-A arg_options", parsing passed options into map ${options}. Map keys are
#   option names (e.g., "-c", "--iapropaganda") and map values are either the
#   option values if passed or the empty string if not passed.
#alias parse_arg_options='map arg_options; zparseopts -D -E -A arg_options --'

#FUXME: Rename to set_args_to_stdin_if_piped(). Current nomenclature is
#unnecessarily absurdly heavy-weight. Fix-up below as well, please.
#alias is_at_least_one_arg=is_args
#FUXME: Not necessarily convinced spoken numbers rather than simple numbers are
#the right way to go, here. The former read rather clumsily (particularly in the
#case of "die_unless_args_0_to_1") and are certainly less concise. Consider:
#
# die_unless_0_arg()
# die_unless_1_arg()
# die_unless_2_args()
# die_unless_0_or_1_arg()
# die_unless_1_to_3_args()
#
#We could even take this a step further by prefixing with "_arg":
#
# die_unless_args_0()
# die_unless_args_1()
# die_unless_args_2()
# die_unless_args_0_to_1()
# die_unless_args_1_to_3()
#
#Yay; much better. Why? Because worrying about plurals is really unintelligent.
#Non-native speakers will have a hell of a time recalling whether its "1_arg" or
#"2_args", so just cut that word-hell off the pass by dispensing with such
#nonsense.

# ....................{ EXCEPTIONS ~ upper                 }....................
# void die_unless_args_at_least_1(string error_message)
#
# Die with the passed message unless the caller passed at least one argument.
#alias die_unless_args_at_least_1="$(get_code_dying_unless_math '# >= 1')"
