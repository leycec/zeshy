#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *function definers* (i.e., functions defining other functions).
/---

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void define_function(string function_name, string function_body)

Define the passed function as the passed *function body* (i.e., such function's
implementation excluding `function ${function_name} () {` prefix and `}`
suffix). If such function has already been declared, an exception is thrown:
e.g.,

.define_function()
==========================================
[source]
------------------------------------------
>>> define_function "moral = choice" 'output_string\
...    "With the myth of the State out of the way, the real mutuality and
...     reciprocity of society and individual became clear. Sacrifice might be
...     demanded of the individual, but never compromise: for though only the
...     society could give security and stability, only the individual, the
...     person, had the power of moral choiceâ€”the power of change, the essential
...     function of life. The Odonian society was conceived as a permanent
...     revolution, and revolution begins in the thinking mind."
>>> get_string_line $("moral = choice") 1
With the myth of the State out of the way, the real mutuality and
------------------------------------------
==========================================

== Motivation ==

This function is principally useful for defining functions with *dynamic
implementations* (i.e., function bodies dynamically synthesized at runtime).

Since `zsh` allows functions with names containing shell-reserved characters to
be defined by double-quoting such names (e.g.,
`function "Fisheye Placebo"() { :output_string "You are free." }`), this
function does _not_ need to be called to define functions with such names.
Interestingly, this differs from the case of defining aliases with such names;
due to undocumented subtleties, :define_alias() should always be called to
define such aliases.
/---
function define_function() {
    # Validate sanity.
    die_unless_args_2 'Expected one function name and one function body.'
    :string function_name__df="${1}"

    # If such function already exists, throw an exception. See is_function()
    # for further details.
    if { { typeset -f -- "${function_name__df}" } silent: } {
        die "function ${function_name__df}() already exists:"$'\n'"$(which -- "${function_name__df}")"
    }

    # Declare such function.
    redefine_function "${@}"
}

declare_function_with_stdin <<'/---'
void redefine_function(string function_name, string function_body)

(Re)define the passed function as the passed function body, regardless of
whether such function has been previously defined. See define_function() for
further details: e.g.,

.redefine_function()
==========================================
[source]
------------------------------------------
>>> redefine_function "The Age of Decreasing Numbers" 'print_string\
...    "Civilization is a subset of nature even if we're not aware of it, and
...     the dark side of our recent increase was a decrease in topsoil and
...     forests and fossil fuels and the Earth's capacity to absorb industrial
...     waste without catastrophic change. Now these things have decreased so
...     far that our habit of increase can no longer feed itself."'
>>> get_string_line $("The Age of Decreasing Numbers") 1
Civilization is a subset of nature even if we're not aware of it, and
>>> redefine_function "The Age of Decreasing Numbers" 'print_string\
...    "With the housing crash, the falling dollar, and the decline in middle
...     class income, we're already tasting the coming age of numbers getting
...     smaller. Next: the stock market, easy credit, the GNP, energy
...     production, energy consumption, and human population."
>>> get_string_line $("The Age of Decreasing Numbers") 1
With the housing crash, the falling dollar, and the decline in middle
------------------------------------------
==========================================
/---
function redefine_function() {
    # Validate sanity.
    die_unless_args_2 'Expected one function name and one function body.'
    :string function_name__rf="${1}" function_body__rf="${2}"
    is -n "${function_name__rf}" si or die 'Expected nonempty function name.'
#   :output_line_if_debugging "zeshy: defining ${function_name__rf}()..."

    # Function to be defined. For obscure error handling reasons, the eval()
    # call below is repeated twice. While localizing the function definition as
    # a variable is hardly essential, it does streamline such calls below.
    :string function__rf='function "'${function_name__rf}'" () {
    '${function_body__rf}'
}'

    # Temporarily enable shell option "EVAL_LINENO". If such eval() call fails
    # with a syntax error, enabling this option ensures the line number zsh
    # embeds in the error will be relative to such function body rather than to
    # the current function (i.e., redefine_error()).
    enable_shell_option_local eval_lineno

    # Declare such function. To prevent errors if such function name contains
    # double quotes, avoid directly interpolating such function name.
    #
    # If such declaration fails, zsh outputs an error message to standard error
    # and reports failure, inducing zeshy to throw an exception resembling
    # "(eval):2: parse error near `]]'". For readability, capture and convert
    # such output into a human-readable exception message.
    { eval "${function__rf}" } silent_stderr: or {
        # Capture such output, ignoring the expected failure.
        :string function_error__rf; function_error__rf="$({
            eval "${function__rf}"
        } to_stdout: or ignore_failure)"

#       print "error: ${function_error__rf}"
        # If such error message is in canonical zsh format (e.g.,
        # "(eval):244: parse error near `()'"), convert such message
        # to human-readable form. In particular, append the actual line of code
        # in such function body inducing such error. Dismantled, this is:
        #
        # * "(#b)", enabling match group capturing.
        # * "(<->##)", matching such line as one or more digits into
        #   ${match[1]}. See is_integer() for further details.
        # * "(*)", matching the actual error message into ${match[2]}.
        if [[ "${function_error__rf}" == (#b)'(eval):'(<->##)': '(*) ]] {
            :string parse_error__rf
            :int line_number__rf line_number_start__rf line_number_end__rf
            :list function_body_lines__rf

            # Parse error emitted by zsh, stripped of delimiting whitespace.
            parse_error__rf="${${match[2]##[[:space:]]##}%%[[:space:]]##}"

            # Capitalize the first character of such error. (Unfortunately,
            # parameter expansion flag "(C)" capitalizes the first character of
            # all words of such parameter.)
            parse_error__rf[1]="${(C)parse_error__rf[1]}"

            # Line number of such error. Such number is relative to the
            # function definition rather than function body and hence is one
            # larger than it should be. Amend this.
            line_number__rf=$(( match[1] - 1 ))

            # Line number of the second lines preceding and succeeding such
            # error, for textual context.
            line_number_start__rf=$(( line_number__rf - 2 ))
            line_number_end__rf=$((   line_number__rf + 2 ))

            # List of function body lines, split on newline. See
            # set_list_to_string_lines() for further details.
            function_body_lines__rf=( ${(f)function_body__rf} )

            # Constrain such numbers to [1, ${max_line_number}], where
            # ${max_line_number} is the number of lines in such function body.
            if (( line_number_start__rf < 1 )) {
                  line_number_start__rf=1
            }
            if (( line_number_end__rf > ${#function_body_lines__rf} )) {
                  line_number_end__rf=${#function_body_lines__rf}
            }

            # String of relative function body lines, numbered for convenience.
            :string function_body_context__rf

            #FIXME: Hardly an ideal implementation. Ideally, we should implement
            #a function leveraging color styles printing such textual context
            #with decent aesthetics. To do so, we'll need test here whether such
            #function exists; if it does, call it, passing such call
            #"${function_body__rf}" and the desired function line; else, defer
            #to the default implementation below. (Actually, don't we have an
            #existing function for numbering arbitrary code lines? I recall such
            #function requiring a bit of touch-up, as well...)

            # Append each such line prefixed by its line number to such string.
            :int    i__rf=${line_number_start__rf}
            for ((; i__rf <= ${line_number_end__rf}; i__rf++ )) {
                function_body_context__rf+=$'\n'" [${i__rf}]  ${function_body_lines__rf[${i__rf}]}"
            }

            # Set such error message.
            function_error__rf="${parse_error__rf} on line ${line_number__rf} of function ${function_name__rf}():"$'\n'${function_body_context__rf}
        }

        # Throw such exception.
        die "${function_error__rf}"
    }
#    print -r -- "function \"${function_name__rf}\" () {
#    ${function_body__rf}
#}"

    # If such function was *NOT* successfully defined *AND* no errors or
    # warnings were printed, throw an exception. While this should never happen,
    # of course, it occasionally does (much to our horrified chagrin).
    #
    # This is purely a precaution to avoid silent regressions.
    typeset -f -- "${function_name__rf}" &>/dev/null or
        die "${function_name__rf}() could not be defined with body:"$'\n'"${function_body__rf}"
}

#FIXME: In lieu of unit tests...
# function siml() {
#    # This should fail with a parse error.
#    define_function yu '()'
# }

# ....................{ DEFINERS                           }....................
declare_function_with_stdin <<'/---'
void :define_function_if_pathable(
    string function_name,
    string function_body_prefix,
    string function_body_suffix,
    string command_name1, string function_body1, ...,
    string pathables_list_name)

Define the passed function whose implementation requires any one of several
*command alternatives* (i.e., external commands offering similar functionality)
to run the first such command in the passed list of such alternatives that is
currently *pathable* (i.e., in the current command hash, typically synonymous
with in the current user's ${PATH}), given:

* The passed list of such alternatives, in descending order of preference.
* The passed *function body prefix* (i.e., code to be unconditionally prepended
  to the command-specific function body).
* The passed *function body suffix* (i.e., code to be unconditionally appended
  to the command-specific function body).
* A map from each command name in the passed list of such alternatives to the
  command-specific function body running such command. For convenience, such map
  should be passed as pairs of additional arguments rather than as an actual
  map.

For example:

.:define_function_if_pathable()
==========================================
[source]
------------------------------------------
>>> :list ZESHY_ALTERNATIVES; ZESHY_ALTERNATIVES=(
...     anarchism capitalism communism socialism )
>>> commands[anarchism]='true'
>>> :undefine_map_key commands capitalism
>>> :undefine_map_key commands communism
>>> :undefine_map_key commands socialism
>>> :define_function_if_pathable\
...     ':output_alternative'\
...     'die_if_args' ''\
...     'anarchism' 'output_string\
...         "Political theory founded on the observation that since few men are
...          wise enough to rule themselves, even fewer are wise enough to rule
...          others."'\
...     'capitalism' 'output_string "Under capitalism, man exploits man."'\
...     'communism'  'output_string "Under communism, it's just the opposite."'\
...     'socialism'  'output_string\
...         "Socialism is the only system for nationalizing compassion so that
...          individuals may be done with it."'\
...     ZESHY_ALTERNATIVES
>>> :print_function :output_alternative
function :output_alternative() {
    (( # == 0 )) || "Expected no arguments."
    output_string\
        "Political theory founded on the observation that since few men are
         wise enough to rule themselves, even fewer are wise enough to rule
         others."'
}
>>> :output_alternative
Political theory founded on the observation that since few men are
wise enough to rule themselves, even fewer are wise enough to rule
others.
------------------------------------------
==========================================
/---
function :define_function_if_pathable() {
    # Validate sanity.
    die_unless_args_6_or_more\
        'Expected one function name, one function body prefix, one function body suffix, one or more pairs of one command name and one function body, and one pathables list name.'
    :string\
        function_name__dfip="${1}"\
        function_body_prefix__dfip="${2}"\
        function_body_suffix__dfip="${3}"\
        list_name_pathables__dfip="${@[-1]}"
    :map command_name_to_function_body__dfip

    # If such list is not, throw an exception.
    is "${(tP)list_name_pathables__dfip-}" == 'array'* si or die\
         '${'${list_name_pathables__dfip}'} undefined or not a list.'

    # Remove such arguments from the argument list. All remaining arguments
    # constitute the map from command name to function body. See 
    shift_args_3
    pop_arg

    # If the number of remaining arguments is *NOT* even and hence does *NOT*
    # constitute a map, throw an exception.
    (( # % 2 == 0 )) or die 'Expected even number of arguments.'

    # Convert all remaining arguments to such map.
    command_name_to_function_body__dfip=( "${@}" )

    # For each command in the passed list of command alternatives, test if such
    # command exists and, if so, define such function with such command.
    :bool is_pathable__dfip
    :string command_name__dfip
    for     command_name__dfip ("${(@P)list_name_pathables__dfip}") {
        # If such map contains no such command, throw an exception.
        (( ${+command_name_to_function_body__dfip[${command_name__dfip}]} )) or die\
            'Command-dependent function '${function_name__dfip}'() command "'${command_name__dfip}'" unimplemented.'

        # If such command contains whitespace, assume such command to be a
        # conditional testing the existence of two or more commands. To do so,
        # programmatically convert such conditional to a genuine zsh test (e.g.,
        # from "catabolic and collapse" to
        # "(( ${+commands[catabolic]} )) && (( ${+commands[collapse]} ))").
        if is "${command_name__dfip}" == *' '* si {
            # To permit map lookups below, preserve the original command string
            # by performing modifications on this local copy.
            :string test__dfip="${command_name__dfip}"

            # If such conditional contains inherently dangerous shell-reserved
            # characters, throw an exception. This includes "`", the obsoleted
            # command substitution prefix, and "$", both the expansion and new
            # command substitution prefix. While command substitutions are
            # patently unsafe (e.g., "$(rm -rf /)"), expansions also support
            # dynamic evaluation of arbitrary code (e.g.,
            # ":string evil='rm -rf /'; : ${(e)evil}") and hence are little
            # safer. Prohibit both by prohibiting their prefixing characters.
            is "${test__dfip}" != *['$`'*] si or die\
                'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" contains unsafe shell-reserved characters "$" and/or "`".'

            # Globally replace in such conditional (in order):
            #
            # * All space-delimited words "or" and "and" with "||" and "&&".
            #   Since both "or" and "and" are valid shell identifiers, do so
            #   *BEFORE* replacing shell identifier characters.
            # * All longest contiguous substrings of shell identifier characters
            #   (signifying unquoted command names) with a test testing the
            #   existence of such command. While command names can technically
            #   contain arbitrary characters, we currently only support common
            #   command names containing no shell-reserved characters and hence
            #   requiring no quoting or escaping.
            test__dfip="${${${test__dfip// ##or ##/ || }// ##and ##/ && }//(#m)[[:IDENT:]]##/(( \${+commands[${MATCH}]\} ))}"   # hack vim highlighting issues: "}"
            # print "command conditional: ${test__dfip}" 1>&2

            # Skip to the next command unless such test dynamically succeeds.
            # If such test fails, such test was either syntactically invalid
            # *OR* syntactically valid and genuinely failed. Discriminate
            # between the two and, in the former case, throw an exception.
            { eval "${test__dfip}" } silent_stderr: or {
                # Capture such output, ignoring the expected failure.
                :string test_error__dfip; test_error__dfip="$({
                    eval "${test__dfip}"
                } to_stdout: or ignore_failure)"

                # If such test failed with no error, such test is syntactically
                # valid and genuinely failed. Skip to the next command.
                if is -z "${test_error__dfip}" si {
                    continue
                # Else, such test is syntactically invalid. Convert such
                # nonfatal error into a fatal exception.
                } else {
                    # For readability, strip the prefixing "zsh: ".
                    test_error__dfip="${test_error__dfip#zsh: }"
                    die 'Command-dependent function '${function_name__dfip}'() test "'${test__dfip}'" failed:'$'\n'${test_error__dfip}
                }
            }
        # Else, such command contains no whitespace. Skip to the next command
        # unless such command is pathable. See is_pathable() for further details.
        } else {
            (( ${+commands[${command_name__dfip}]} )) or continue
        }

        # Since the current iteration did *NOT* continue, such command or
        # commands is pathable. Define such function with such command.
        define_function "${function_name__dfip}" \
"    ${function_body_prefix__dfip}
    ${command_name_to_function_body__dfip[${command_name__dfip}]}
    ${function_body_suffix__dfip}"

        # Cease iteration.
        report_success
    }

    # If no such command exists, avoid defining such function. Do *NOT* report
    # failure and hence induce an exception, as this function is commonly called
    # during digest compilation from the top-level.
    report_success
}

# --------------------( WASTELANDS                         )--------------------
        # If such command (or commands) is pathable, define such function to run
        # such command and cease iteration.
#       if (( is_pathable__dfip )) {

        # By default, the current command is assumed to *NOT* be pathable unless
        # explicitly proven otherwise.
        # is_pathable__dfip=0

            # { eval 'if '${command_name__dfip}' {
            #     is_pathable__dfip=1
            # }' } silent_stderr: or {

            #FUXME: While safe, there exists no guarantee such conditional will
            #actually interpret as valid zsh. An exception should be thrown when
            #this is not the case. Unfortunately, doing so is nontrivial (and
            #requires subshells); basically:

            #FUXME: Actually, it'd be simpler to just quote-protect each command
            #name to prevent such interpretation. Do so!
# >>> :string alternative
# >>> for     alternative ("${ZESHY_ALTERNATIVES[@]}") {
# ...     :undefine_map_key commands ${alternative}
# ... }

# ==  ==
# 
# This function defines 
# Specifically, synthesize such function as the following code (in order):
# 
# . The passed *function body prefix* (i.e., code to be unconditionally prepended
#   to the command-specific function body).
# . The passed *function body* (i.e., code comprising ) corresponding
# . The passed *function body suffix* (i.e., code to be unconditionally appended
#   to the selected function body).

    # All standard output and error printed by the latter of the two eval()
    # calls below.
    # :string 

# Unlike aliases, this functions do _not_ `zsh` already permits functions with names containing shell-
# reserved characters to be defined by double-quoting such names (as in the above
# example). Hence, 

    #FUXME: Uhm; this still shouldn't work. Declaring such function in any pipe
    #subcommand other than the last does so only in the corresponding subshell.
    #Instead, we'll need to use the coprocess approach. Unfortunately, we're
    #getting into a bit of a chicken-and-egg issue here. We *DEFINITELY* don't
    #want to inline our coprocess implementation here; it's simply too delicate.
    #Instead, we'll need to leave this function *UNDEFINED* until after defining
    #such coprocess functionality -- which, I believe, is all segregated to
    #@{15-alias}. That being the case, this function should be shifted to
    #@{20-function} and reimplemented in terms of coprocesses.
    #FUXME: Ah. Wait. Declaring such function in a subshell should be reasonably
    #efficient. Certainly, since coprocesses also require subshells and impose
    #even *MORE* inefficiencies, declaring such function in a subshell will
    #certainly be no worse. So, simply declare such function in a subshell
    #*FIRST* to ascertain whether or not such definition is erroneous. If so,
    #propagate such error as an exception; else, declare such function in the
    #current shell. Reasonably simple, eh?

    # If such function body is syntactically invalid, throw an exception.
    # Technically, shifting this conditional into the prior block would slightly
    # improve efficiency -- while indenting this conditional two tabs to the
    # right and hence rendering it unreadable. (You decide.)
    # if [[ -n "${function_error__rf}" ]] {

    # Declare such function. To prevent errors if such function name contains
    # double quotes, avoid directly interpolating such function name.
    #
    # If such function body is syntactically invalid, zsh prints a nonfatal
    # warning to standard error and returns successfully; else, neither standard
    # output or error are printed to. Deciding whether an error occurred thus
    # requires capturing standard output and error to a string local and testing
    # whether such local is nonempty or not. Since capturing such output with a
    # conventional command substitution declares such function only in a
    # subshell rather than the current shell (e.g.,
    # function_error="$(eval "function ..." 2>&1)"), capture such output with a
    # pipe in the current shell instead.
    #
    # Ideally, that would simply suffice: pipe such output into the necessary
    # read() command and test the result. Naturally, it doesn't. While it
    # remains unclear why eval() behaves in this manner, one thing is clear: if
    # eval() succeeds in defining such function *AND* is piped into *ANYTHING*,
    # eval() silently fails and undefines such function. While this is fairly
    # crazy, the solution is fairly simple: only pipe eval() output if a prior
    # eval() call passed the same arguments returns non-zero exit status. This
    # is the most obscure code in any language I've ever had the shame to admit
    # having contributed. It's hard to be proud of something like this.
    # eval "${function__rf}" || {
    #     # Dismantled, this is:
    #     #
    #     # * "|&", piping both standard output and error from such eval() call.
    #     # * "IFS='' read -r -d ''", capturing all piped standard output and
    #     #   error to ${function_error}.
    #     eval "${function__rf}" |& IFS='' read -r -d '' function_error__rf
    # }

#FUXME: Arguably complex enough to warrant shifting to a new parcel
#@{20-function/define}.
#FUXME: Right. We *HAVE* to do so anyway, to ensure access to coprocess
#functionality. See below. For now, the following two functions remain *BROKEN*.
#FUXME: O.K.; while we *REALLY* don't want to adopt a coprocess approach,
#there's no compelling reason to leave these here. Shift into new parcel
#@{00-core/declare/function}. Then also define our new
#:declare_function_if_pathable() function in the same parcel.
