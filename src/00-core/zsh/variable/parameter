#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle `zsh` parameter expansion.
/---

# ....................{ GLOBALS                            }....................
declare_global_with_stdin list_set ZESHY_PARAMETER_EXPANSION_TOKENS <<'/---'
List of all possible parameter expansion tokens. See
set_character_to_string_parameter_expansion_token_if_found() for further
details.
/---
ZESHY_PARAMETER_EXPANSION_TOKENS=(
    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@'
    '#' '$' '%' '^' '&' '*' '-' '_' '\' '|' '/' '?'
)

# ....................{ SETTERS                            }....................
# Since print_exception() transitively calls such functions via
# set_string_to_string_padded_to_length(), such functions are subject to the
# same constraints: namely, avoid calling other functions from such functions
# unless explicitly preceding such calls with tests of whether such functions
# are still defined or not.
#
# While cumbersome, such avoidance has the beneficial side effect of improving
# the efficiency of such functions. Since such functions are called frequently,
# these optimizations are genuinely useful.

#FIXME: Add example.
declare_function_with_stdin <<'/---'
[status: boolean] set_character_to_string_parameter_expansion_token(
    string character_name,
    string text1, ...)

Set the passed character to an arbitrary parameter expansion token suitable for
use with the passed string if such token exists (i.e., if such string does _not_
contain all possible tokens) or throw an exception otherwise. See
set_character_to_string_parameter_expansion_token_if_found() for further
details.
/---
function set_character_to_string_parameter_expansion_token() {
    set_character_to_string_parameter_expansion_token_if_found "${@}" or die\
        "String \"${*[2,-1]}\" contains all possible parameter expansion tokens."
}

declare_function_with_stdin <<'/---'
[status: boolean] set_character_to_string_parameter_expansion_token_if_found(
    string character_name,
    string text1, ...)

Set the passed character to an arbitrary parameter expansion token suitable for
use with the passed string if such token exists (i.e., if such string does _not_
contain all possible tokens) or report failure otherwise. Such token is
guaranteed to be a punctuation character in ${ZESHY_PARAMETER_EXPANSION_TOKENS},
which `zsh` permits to delimit parameter expansion flag arguments (e.g., the `:`
in `${(j:canticle:)leibowitz}`). Typically, such tokens are intended for
expansion in dynamically constructed eval() statements: e.g.,

.set_character_to_string_parameter_expansion_token_if_found()
==========================================
[source]
------------------------------------------
>>> string token on_salvation="
...     The hostilities between Christianity and contemporary atheism, like
...     those between Christianity and Islam, are thus expressions of something
...     like sibling rivalry. Salvation from the natural world and the human
...     condition remains the core premise (and thus also the most important
...     promise) of all these faiths, whether that salvation takes the
...     supernatural form of resurrection followed by eternal life in heaven, on
...     the one hand, or the allegedly more natural form of limitless progress,
...     the conquest of poverty, illness, and death, and the great leap outwards
...     to an endless future among the stars."
>>> set_character_to_string_parameter_expansion_token_if_found\
...     "${on_salvation} ,:.;~\`'\"=+@#\$%^&*-_\\|/?" or output_string\
...     "Civil religions are derivative, even parasitic, on theist religions."
Civil religions are derivative, even parasitic, on theist religions.
------------------------------------------
==========================================
/---
function set_character_to_string_parameter_expansion_token_if_found() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one string name and one or more strings.'
    string string_name__sctspetif="${1}" text__sctspetif="${*[2,-1]}"

    # List sets guarantee uniqueness, as required by the algorithm below.
    list_set text_characters__sctspetif tokens_free__sctspetif

    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_string() and is_list for further details.
    is "${(tP)string_name__sctspetif-}" == 'scalar'* si or die\
        "\${${string_name__sctspetif}} undefined or not a string variable."
    is "${(t)ZESHY_PARAMETER_EXPANSION_TOKENS}" == 'array'* si or die\
         "\${ZESHY_PARAMETER_EXPANSION_TOKENS} undefined or not a list."

    # To efficiently find the first such token not already in such string:
    #
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference ${ZESHY_PARAMETER_EXPANSION_TOKENS}, a list set containing
    #   each possible such token as a list element, from the prior list set into
    #   a third list set, containing each possible token not in such string.
    # * Arbitrarily return the first element of such set.
    #
    # Such algorithm is considerably more efficient than iteratively finding
    # such token. In any case, the prior optimization *SHOULD* catch most cases.

    # List set of all unique characters in the passed string. See
    # set_list_to_string_characters() for further details.
    text_characters__sctspetif=( ${(s::)text__sctspetif} )

    # Difference such set from ${ZESHY_PARAMETER_EXPANSION_TOKENS}. See
    # set_list_to_list_difference() for further details.
    tokens_free__sctspetif=(
        "${ZESHY_PARAMETER_EXPANSION_TOKENS[@]:|text_characters__sctspetif}" )

    # If such string does *NOT* contain at least one such token, set such
    # variable to the first such token; else, report failure. See
    # is_list_nonempty() and set_string_to_string() for further details.
    (( ${#tokens_free__sctspetif} )) and
        noop ${(P)string_name__sctspetif::=${tokens_free__sctspetif[1]}}
}

#FIXME: In lieu of unit tests...
#function bobo() {
#    character token
#    set_character_to_string_parameter_expansion_token token\
#        ",:.;~\`'\"=+@#\$%^&*-_\\|/"
#    output_string "token: ${token}"
#    set_character_to_string_parameter_expansion_token token\
#        ",:.;~\`'\"=+@#\$%^&*-_\\|/?"
#    output_string "token: ${token}"
#}

# --------------------( WASTELANDS                         )--------------------
    # Else, such string contains all possible tokens, an insane feat worthy of
    # jeering applause. Fail instead.
#    } else {
#        report_failure
#    }

    # If such text does *NOT* contain a caret, set such string to a caret. Since
    # the caret is arguably the least commonly used such token in real-world
    # text, explicitly test for the absence of such token in such text before
    # expensively searching for another possible token.
#    if { is "${text__sctspetif}" != *'^'* si } {
#        # See set_string_to_string() for further details.
#        noop ${(P)string_name__sctspetif::=^}
#        report_success
#    }

# ....................{ GLOBALS                            }....................
#declare_global_with_stdin string ZESHY_IFS_DEFAULT=$' \t\n\0' <<'/---'
#Default internal field separator (IFS) for splitting fields on longest
#contiguous substrings of *whitespace* (i.e., space, tab, newline, and null
#characters). By POSIX design, setting string global ${IFS} to this default is
#equivalent to unsetting such global.
#/---
#
#declare_global_with_stdin list_set ZESHY_PARAMETER_EXPANSION_TOKENS <<'/---'
#List of all possible parameter expansion tokens. See
#get_string_parameter_expansion_token_if_found() for further details.
#/---
#ZESHY_PARAMETER_EXPANSION_TOKENS=(
#    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '^' '&' '*'
#    '-' '_' '\' '|' '/' '?'
#)

#Get an arbitrary parameter expansion token specific to the passed string or
#return failure if no such token exists (i.e., if such string contains all
#possible tokens). Such tokens are punctuation characters with which `zsh`
#delimits parameter expansion flag arguments (e.g., the `;` in
#`${(j:canticle:)leibowitz}`). Assuming such string does _not_ contain all
#possible tokens, this function efficiently finds an arbitrary such token for
#subsequent interpolation in an `eval` statement: e.g.,
#function get_string_parameter_expansion_token_if_found() {
#    # Validate sanity.
#    die_unless_args 'Expected one or more strings.'
#    string text="${*}"
#    list_set text_characters tokens_free
#
#    set_character_to_string_parameter_expansion_token_if_found().
#
#    # Since the caret is arguably the least common such token, explicitly test
#    # for the absence of such token in such string prior to algorithmically
#    # finding another possible token. For efficiency, inline such test.
#    if { is "${text}" != *'^'* si } {
#        return_string '^'
#    }
#
#    # To efficiently find the first such token not already in such string:
#    #
#    # * Split such string on characters into a list set, thus containing each
#    #   unique character of such delimiter in arbitrary order.
#    # * Difference ${ZESHY_PARAMETER_EXPANSION_TOKENS}, a list set containing
#    #   each possible such token as a list element, from the prior list set into
#    #   a third list set, containing each possible token not in such string.
#    # * Arbitrarily return the first element of such set.
#    #
#    # Such algorithm is considerably more efficient than iteratively finding
#    # such token. In any case, the prior optimization *SHOULD* catch most cases.
#
#    # List set of all unique characters in the passed string.
#    set_list_to_string_characters text_characters "${text}"
#
#    # Difference such set from ${ZESHY_PARAMETER_EXPANSION_TOKENS}.
#    set_list_to_list_difference\
#         tokens_free ZESHY_PARAMETER_EXPANSION_TOKENS text_characters
#
#    # If such string does *NOT* contain at least one such token, arbitrarily
#    # return the first such token.
#    if { is_list_nonempty tokens_free } {
#        return_string "${tokens_free[1]}"
#    # Else, such string contains all possible tokens, an insane feat worthy of
#    # jeering applause. Fail instead.
#    } else {
#        report_failure
#    }
#}

#function set_character_to_string_parameter_expansion_token_if_found() {
#    # Validate sanity.
#    die_unless_args_2_or_more\
#        'Expected one string name and one or more strings.'
#    string string_name__sctspetif text__sctspetif="${*[2,-1]}"
#    list_set text_characters__sctspetif tokens_free__sctspetif
#
#    # If such text does *NOT* contain a caret, set such string to a caret. Since
#    # the caret is arguably the least commonly used such token in real-world
#    # text, explicitly test for the absence of such token in such text before
#    # expensively searching for another possible token.
#    if { is "${text__sctspetif}" != *'^'* si } {
#        set_string_to_string string_name__sctspetif '^'
#        report_success
#    }
#
#    # To efficiently find the first such token not already in such string:
#    #
#    # * Split such string on characters into a list set, thus containing each
#    #   unique character of such delimiter in arbitrary order.
#    # * Difference ${ZESHY_PARAMETER_EXPANSION_TOKENS}, a list set containing
#    #   each possible such token as a list element, from the prior list set into
#    #   a third list set, containing each possible token not in such string.
#    # * Arbitrarily return the first element of such set.
#    #
#    # Such algorithm is considerably more efficient than iteratively finding
#    # such token. In any case, the prior optimization *SHOULD* catch most cases.
#    #
#    # List set of all unique characters in the passed string.
#    set_list_to_string_characters text_characters__sctspetif "${text__sctspetif}"
#
#    # Difference such set from ${ZESHY_PARAMETER_EXPANSION_TOKENS}.
#    set_list_to_list_difference\
#         tokens_free__sctspetif\
#         ZESHY_PARAMETER_EXPANSION_TOKENS\
#         text_characters__sctspetif
#
#    # If such string does *NOT* contain at least one such token, arbitrarily
#    # return the first such token.
#    if { is_list_nonempty tokens_free__sctspetif } {
#        set_string_to_string\
#            string_name__sctspetif "${tokens_free__sctspetif[1]}"
#    # Else, such string contains all possible tokens, an insane feat worthy of
#    # jeering applause. Fail instead.
#    } else {
#        report_failure
#    }
#}
