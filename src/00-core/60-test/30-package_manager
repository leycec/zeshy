#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *package manager testers* (i.e., high-level functions testing which of
several possible package managers is available on the current system).

== Linux Distributions ==

GNU/Linux distributions are Unix-like operating systems comprising:

* The Linux kernel.
* A distribution-specific userland comprising at least:
** The GNU userland.
** Typically, at least one package management system (e.g., Portage).
** Typically, at least one a system management daemon (e.g., systemd).

Since all GNU/Linux distributions comprise at least the Linux kernel and GNU
userland, such distributions are principally distinguished by their choice of
package management system(s) and system management daemon(s). There exist
considerably fewer package management systems and system management daemons
(both numbering at most in the tens) than there do GNU/Linux distributions
(numbering at least in the thousands), implying detecting the former to be more
efficient and reliable than detecting the latter.

However, such detection is _not_ merely a matter of efficiency or reliability.
It's a matter of asking the right questions, the prerequisite for receiving the
right answers. In most cases, the right question is _not_ ``What is the current
GNU/Linux distribution?'' but ``Which package managers and system daemons are
currently available on whatever happens to be the current GNU/Linux
distribution if the current operating system even happens to be GNU/Linux?''

=== Package Managers ===

There does _not_ exist a one-to-one relationship between GNU/Linux distributions
and package managers. Such managers are also available under other GNU/Linux
distributions directly derived from the parent distribution _and_ non-GNU/Linux
operating systems (e.g., Portage, available under all Gentoo-based GNU/Linux
distributions _and_ such non-GNU/Linux operating systems as Apple OS X and
Gentoo/FreeBSD).

Indeed, there exists a many-to-many relationship between GNU/Linux distributions
and package managers. Multiple such managers are often available under the same
operating system. Apple OS X is the poster child for such ``promiscuity,''
providing one or more of the following package management systems:

* Gentoo Prefix, a subset of Gentoo Linux installing the Portage system under a
  user-configurable offset of the current filesystem.
* Fink, a port of the Debian dpkg system.
* MacPorts, an OS X-specific system inspired by the BSD ports collection.

Since package management systems are neither distribution-specific _or_ mutually
exclusive, `zeshy` attempts to detect all such systems available on the current
operating system -- regardless of whether this is even an operating system
commonly associated with package management systems.
/---

# While we *COULD* persist the sets of all human- and machine-readable names of
# all package management systems available on the current OS, doing so implies
# considerably more effort than we currently care to invest in the matter. For
# now, we only provide specific testers.

# ....................{ DEFINERS                           }....................
# To add support for a new package management system:
#
# * Add a boolean local indicating the availability of such system below,
#   typically initialized by testing whether the lowest-level CLI command for
#   such system is currently pathable.
# * Define a corresponding tester function given such boolean.
# * Document such function.
#
# zeshy uses such systems to automate package handling and hence assumes *ALL*
# such systems to provide dependency resolution (i.e., to both automatically
# track installed dependencies and resolve uninstalled dependencies). The
# following package management systems do *NOT* provide such resolution and
# hence are excluded:
#
# * "slackpkg", the official package management system for Slackware and several
#   Slackware-derived distributions. While there *DO* exist unofficial
#   alternatives providing package management (e.g., "slapt-get", "sbotools"),
#   supporting the rapidly changing landscape of unsupported Slackware packagers
#   would be a bit beyond the pale. All such systems are currently excluded.

declare_function_with_stdin <<'/---'
void ::define_package_manager_testers(void)

Define all package manager testers to unconditionally report either success or
failure.
/---
function ::define_package_manager_testers() {
    # Validate sanity.
    die_if_args

    #FIXME: Also define a new tester :is_package_manager() reporting success if
    #at least one such package manager is currently available. To do so sanely,
    #it'd be great if we could:
    #
    #* Inspect the local context for the set of all boolean variables with names
    #  matching glob "is_package_manager_*". (Quite certain this is feasible,
    #  but we can't recall implementing a function to do so.)
    #* Add all such booleans together. (Again, be nice if we defined a utility
    #  function to do so, since this can be heavily optimized to avoid manual
    #  iteration.)
    #* If the result is nonzero, at least one such package manager is currently
    #  available, in which case such tester should be defined to report success.
    #FIXME: If no package managers are available, print a warning resembling:
    #    :output_warning "No package manager detected."

    # True if the corresponding package management systems are available. Since
    # such systems are neither operating system- or Linux distribution-specific,
    # such systems must be detected by other means -- typically by detecting
    # system-specific pathables.
    :bool\
        is_package_manager_alpm=0\
        is_package_manager_apt=0\
        is_package_manager_conary=0\
        is_package_manager_entropy=0\
        is_package_manager_fink=0\
        is_package_manager_macports=0\
        is_package_manager_pkg_add=0\
        is_package_manager_pkgng=0\
        is_package_manager_pkgsrc=0\
        is_package_manager_portage=0\
        is_package_manager_urpmi=0\
        is_package_manager_yum=0\
        is_package_manager_zypp=0

    # Detect operating system-agnostic package management systems.
    is_package_manager_apt=$(( ${+commands[apt-get]} ))
    is_package_manager_portage=$(( ${+commands[portageq]} ))

    # If the current operating system is GNU/Linux, detect GNU/Linux-
    # specific package management systems.
    if { :is_os_linux_gnu } {
        is_package_manager_alpm=$(( ${+commands[pacman]} ))
        is_package_manager_conary=$(( ${+commands[conary]} ))
        is_package_manager_entropy=$(( ${+commands[equo]} ))
        is_package_manager_urpmi=$(( ${+commands[urpmi]} ))
        is_package_manager_yum=$(( ${+commands[yum]} ))
        is_package_manager_zypp=$(( ${+commands[zypper]} ))
    # If the current operating system is a BSD derivative, detect BSD-
    # specific package management systems.
    } elif { :is_os_trait_bsd } {
        is_package_manager_pkg_add=$(( ${+commands[pkg_add]} ))
        is_package_manager_pkgng=$(( ${+commands[pkg]} ))
        is_package_manager_pkgsrc=$(( ${+commands[pkgsrc]} ))
    # If the current operating system is OS X, detect OS X-specific package
    # management systems.
    } elif { :is_os_os_x } {
        is_package_manager_fink=$(( ${+commands[fink]} ))
        is_package_manager_macports=$(( ${+commands[port]} ))
    }

    #FIXME: No *WAY* are we manually declaring all such testers. Examining
    #@{var/scope}, it's clear that it's trivial to define a new setter
    #:set_list_to_vars_local() based on the existing get_globals() getter
    #(which has been heavily adorned with FIXME comments describing such
    #transition).
    #
    #Given :set_list_to_vars_local(), then define a new setter
    #:set_list_to_vars_local_matching_glob() internally calling
    #:set_list_to_vars_local() (and probably
    #remove_list_items_not_matching_glob() as well). Yum!
    #FIXME: Actually, just encapsulate such booleans into a map above. Much
    #simpler and more efficient.

    #FIXME: On a *COMPLETELY* unrelated note, we've realized there's a simple
    #means of eliminating the duplication in for loop iteration: e.g.,
    #
    #    # This is bad.
    #    :string yum
    #    for     yum ("${@}") { ... }
    #
    #    # This is good.
    #    :for_string yum ("${@}") { ... }
    #
    #Sweet, no? Implement two aliases :for_string() and :for_int() in the
    #expected here-document-driven manner. Should be fairly simple, but
    #produces much more elegant code. Yay!

    # is_package_manager_alpm=0\
    # is_package_manager_apt=0\
    # is_package_manager_conary=0\
    # is_package_manager_entropy=0\
    # is_package_manager_fink=0\
    # is_package_manager_macports=0\
    # is_package_manager_pkg_add=0\
    # is_package_manager_pkgng=0\
    # is_package_manager_pkgsrc=0\
    # is_package_manager_portage=0\
    # is_package_manager_urpmi=0\
    # is_package_manager_yum=0\
    # is_package_manager_zypp=0

    # Define testers corresponding to booleans set above accordingly.
    # :define_function_to_report_bool\
    #     :is_package_manager_trait_x "${is_package_manager_trait_x}"
}

# ....................{ TESTERS                            }....................
#FIXME: Document all other package management systems!
declare_function_with_stdin <<'/---'
[status: bool] :is_package_manager_portage(void)

Report success if the current operating system is a derivative of Arch Linux.
/---

# --------------------( WASTELANDS                         )--------------------
    # While
    # such booleans are also settable by matching either machine- or human-
    # readable operating Linux distribution names (e.g., enabling this boolean if such name is
    # "Sabayon"), 

# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_arch(void)
# 
# Report success if the current operating system is a derivative of Arch Linux.
# /---
# 
# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_debian(void)
# 
# Report success if the current operating system is a derivative of Debian Linux.
# /---
# 
# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_gentoo(void)
# 
# Report success if the current operating system is a derivative of Gentoo Linux.
# /---
# 
# declare_function_with_stdin <<'/---'
# [status: bool] :is_distro_trait_ubuntu(void)
# 
# Report success if the current operating system is a derivative of Ubuntu Linux.
# /---

# pertaining to the current GNU/Linux
# distribution
# 
# is in fact _not_ what is the current GNU/Linux distributions

# current  either is a particular such server _or_ belongs to a
# particular category of such servers).

# declare_parcel_as_script_with_stdin <<'/---'
# Handle open-source Linux and BSD distributions.
# /---

# function :is_distro_trait_arch() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Arch' si
# }
# function :is_distro_trait_debian() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Debian' si
# }
# function :is_distro_trait_gentoo() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Gentoo' si
# }
# function :is_distro_trait_ubuntu() {
#     die_if_args
#     is "$(get_unix_distro:)" == 'Ubuntu' si
# }

#FUXME: Indeed, this has largely been obsoleted by new functionality in
#@{inspect}.
# == See Also ==
# 
# * Canonical list of Linux- and BSD-specific
#   http://linuxmafia.com/faq/Admin/release-files.html[`-release` and `_version` filenames and file contents].

# ....................{ GETTERS                            }....................
#FUXME: Refactor into a setter, naturally.

# declare_function_with_stdin <<'/---'
# integer get_unix_distro_version:(void)
# 
# Get the version number of the current distribution: e.g.,
# 
# .get_unix_distro_version:()
# ==========================================
# [source]
# ------------------------------------------
# >>> get_unix_distro_version:
# 2.1
# /---
# function get_unix_distro_version:() {
#     # Validate sanity.
#     die_if_args
#     :string release_text
#     :list release_files
# 
#     # If "lsb_release" is installed, return such command's output.
#     if { is_pathable lsb_release } {
#         command lsb_release -sr and report_status
#     }
# 
#     # Else, attempt to match such version from a system-wide file.
#     #
#     # List of all files matching /etc/*-release, /etc/*_version, and
#     # /etc/*-version excluding "/etc/lsb-release", specific to the prior
#     # pathable "lsb_release" guaranteed *NOT* to exist on this system.
#     release_files=( /etc/*{-release,-version,_version}~/etc/(lsb|os)-release(.) )
#     die_unless_list_nonempty release_files\
#         'OS distribution version not found (i.e., command "lsb_release" not found and no system-wide release or version files found).'
# 
#     #FUXME: We clearly have no access to function get_file_text() here. Inline
#     #such implementation!
#     #FUXME: Should probably grep the file for a pattern matching a version
#     #specifier, but... *meh* Hmm; actually, yeah. This is rather shoddy. I have
#     #little confidence in the current version. Reconsider!
#     #FUXME: Iteratively search all such files for the first whose contents match
#     #a version specifier. See the "Canonical list..." URL, above.
# 
#     # Get the last column in the text contents of the first such file.
#     release_text="$(get_file_text "${release_files[1]}")"
#     output_string "${release_text[(w)-1]}"
# }

# declare_function_with_stdin <<'/---'
# string get_unix_distro:(void)
# 
# Get the capitalized name of the current distribution: e.g.,
# 
# .get_unix_distro:()
# ==========================================
# [source]
# ------------------------------------------
# >>> get_unix_distro:
# Debian  # under Debian Linux installations
# Gentoo  # under Gentoo Linux installations
# ------------------------------------------
# ==========================================
# /---
# function get_unix_distro:() {
#     # Validate sanity.
#     die_if_args
#     list release_files
# 
#     #FUXME: Actually implement
#     #is_file_text_matching_pcre_group_multiline:!
# 
#     # If "lsb_release" is installed, get such command's output.
#     if { is_pathable lsb_release } {
#         command lsb_release -si and report_status
#     # Else if "/etc/os-release" exists and contains a line prefixed by "NAME=",
#     # get the substring following such prefix. Since such substring may
#     # optionally be delimited by quotes, strip such quotes if found.
#     } elif {\
#         is_file /etc/os-release and
#         is_file_text_matching_pcre_group_multiline: /etc/os-release\
#             '^NAME=(?|"([^"]++)"|([^"]++))$' } {
#         # If such substring is suffixed by a whitespace-prefixed operating
#         # system name (e.g., " Linux"), strip such suffix.
#         remove_string_suffix "${match[1]}" ' Linux'
#         report_success
#     }
# 
#     #FUXME: Generalize such admittedly odd syntax to a new setter
#     #:set_list_to_glob_qualified_paths_not_matching_glob:(). Sweet!
#     #FUXME: As well as doing that, also generalizing the setting of such exact
#     #list below to a new setter set_list_to_unix_files_release_nonstandard:().
#     #Such functionality is shared with get_unix_distro_version:() below and
#     #hence of common interest.
# 
#     # List of all files matching /etc/*-release, /etc/*_version, and
#     # /etc/*-version -- excluding "/etc/lsb-release". While command "lsb_release" and
#     # hence the latter should be unavailable here, better comfy than
#     # core-dumped.
#     release_files=( /etc/*{-release,-version,_version}~/etc/(lsb|os)-release(.) )
# 
#     # If at least one such file matches, take the prefix preceding the last
#     # dash or hyphen in the basename of the first such filename to be the distro
#     # name. Note that some distro names themselves contain dashes and hyphens.
#     # Thus, match suffixes non-greedily.
#     if { is_list_nonempty release_files } {
#         return_string "$(capitalize_string "$(get_path_basename\
#             "${release_files[1]%[_-]*}")")"
#     # Else, return the current operating system name.
#     } else {
#         get_os
#     }
# }

    # get_string_word "$(get_file_text "${release_files[1]}")" -1

#FUXME: Since the concept of "distribution" only applies to open OSes
#(principally Linux and BSD), this parcel is inherently nonportable. Honestly,
#such functionality should at least be shifted to a new tree @{src/if_os/unix}.

#FUXME: Desynchronized with get_unix_distro:() and probably non-working, we're
#afraid. In particular, we want to parse 
    #FUXME: Bit awkward. We really want a new run_code
    # If at least one such file matches, return the last column in the contents
    # of the first such file.
#   if { is_list_nonempty release_files } {
#       get_string_word "$(get_file_text "${release_files[1]}")" -1
    # Else, throw an exception.
#   } else {
#   }
#       string release_filename="${release_files[1]}"
#       if { is_file_text "${release_filename}" } and {
#FUXME: Rename to :is_distro_unix_arch() and similarly elsewhere below. There's
#technically a separate Gentoo BSD, for example, that
