#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *operating system testers* (i.e., high-level functions testing whether
the current operating system either is a particular operating system _or_
belongs to a particular category or lineage of operating systems).
/---

# Note that canonical string global ${OSTYPE} is set during zsh compilation by
# autotools script "configure.ac" to the autotools-specific string global
# $host_os. Unfortunately, there appears to exist no definitive list of all
# $host_os values, necessitating the ad-hoc approach. Fortunately, reliable
# third-party sources matching a subset of such values do exist -- including:
#
# * "http://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=blob_plain;f=build-aux/config.rpath;hb=HEAD",
#   a shell script outputting variables setting the shared library runtime
#   search path in the GNU gnulib library. See also the files
#   "build-aux/config.library" and "m4/host-os.m4" in such library. Given that
#   GNU also maintains autotools, this approximates a definitive list.
# * "https://ftp.samba.org/pub/unpacked/ctdb/lib/replace/libreplace_ld.m4", the
#   suite of autotools macro definitions for SAMBA's libreplace.
# * "http://git.savannah.gnu.org/cgit/grub.git/plain/configure.ac", the
#   autotools configuration for GRUB2.
#
# We intentionally exclude operating systems no longer under active development
# (e.g., SunOS, SGI's IRIX, Hewlett Packard's Tru64 UNIX). Since zeshy requires
# zsh >= 5.0.0, such systems are unlikely to run zeshy reliably (if at all).

# ....................{ GLOBALS                            }....................
declare_global_with_stdin string ZESHY_OS_NAME <<'/---'
Name of the *current operating system* if such operating system was recognized
at digest compile time or the empty string otherwise. Such string may contain
whitespace and capitalized letters and hence is typically human-readable.
/---

# ....................{ TESTERS                            }....................
# To add support for a new OS:
#
# * Add such OS' zeshy-specific name to local list ${os_names}.
# * Match such OS' autotools-specific name and convert such name to the desired
#   zeshy-specific name. This function then implicitly defines a tester for such
#   OS named :is_os_${os_name}().
# * Document :is_os_${os_name}(), where "${os_name}" is the same zeshy-specific
#   name.
# * If such OS supports no canonical display servers out-of-the-box (e.g., X11),
#   explicitly detect such OS' stock display server in @{inspect}.

#FIXME: Such function should set a new string global (presumably declared at the
#top of this parcel) like so:
#
#    ZESHY_OS_NAME="${os_name}"
#
#In fact, we should probably simply excise ${os_name} below and use
#${ZESHY_OS_NAME} everywhere.
#FIXME: Ah; I see. We *DO* need to retain ${os_name}, as such local is non-
#human-readable. The above case statement should then set *BOTH* ${os_name} and
#${ZESHY_OS_NAME}, and the latter to the human-readable name of such OS (e.g.,
#"ZESHY_OS_NAME='Debian GNU/kFreeBSD'" for such OS). Nice!

declare_function_with_stdin <<'/---'
void ::define_os_functions(void)

Define all *operating system testers* (i.e., high-level functions testing
whether the current operating system either is a particular operating system
_or_ belongs to a particular category or lineage of operating systems). For
efficiency, define such testers to unconditionally report either success or
failure (rather than to conditionally perform runtime tests).
/---
function ::define_os_functions() {
    # List of all zeshy-specific OS names.
    :list os_names; os_names=(
        # BSD.
        dragonfly_bsd freebsd netbsd openbsd

        # Darwin.
        ios os_x

        # GNU.
        gnu_hurd gnu_kfreebsd gnu_kopensolaris

        # Linux.
        linux_android linux_gnu

        # Unix System V.
        aix hpux solaris

        # Other.
        aros haiku qnx_neutrino windows )

    # zeshy-specific name of the current OS system as one lowercase word.
    :string os_name

    # True if the current OS is explicitly recognized by zeshy. (Defaults to
    # true.)
    :bool is_os_recognized=1

    # True if the current OS is GNU/Linux. (Defaults to false.)
    :bool is_os_linux_gnu=0

    # True if the current OS is a BSD derivative. (Defaults to false.)
    :bool is_os_trait_bsd=0

    # True if the current OS has a Darwin core. (Defaults to false.)
    :bool is_os_trait_darwin=0

    # True if the current OS supports the GNU software stack. (Defaults to
    # false.)
    :bool is_os_trait_gnu=0

    # True if the current OS is Linux. (Defaults to false.)
    :bool is_os_trait_linux=0

    # True if the current OS is a Unix System V derivative. (Defaults to false.)
    :bool is_os_trait_sysv=0

    # Map from autotools- to zeshy-specific OS names. The latter tend to
    # correspond more to the human-readable OS name than the former (e.g.,
    # "gnu_hurd" rather than "gnu", a patently unfortunate choice of identifier)
    # and, arguably more importantly, lack the OS versions frequently suffixing
    # the latter (e.g., "aix" rather than "aix9").
    case "${OSTYPE}" {
    # Map recognized autotools- to zeshy-specific OS names.
    'aix'*)                os_name='aix'; is_os_trait_sysv=1;;
    'aros'*)               os_name='aros';;
    'dragonfly'*)          os_name='dragonfly_bsd';    is_os_trait_bsd=1;;
    'freebsd'*)            os_name='freebsd';          is_os_trait_bsd=1;;
    'haiku'*)              os_name='haiku';;
    'hpux'*)               os_name='hpux';             is_os_trait_sysv=1;;
    'gnu'*)                os_name='gnu_hurd';         is_os_trait_gnu=1;;
    'kfreebsd'*'-gnu')     os_name='gnu_kfreebsd';     is_os_trait_gnu=1; is_os_trait_bsd=1;;
    'kopensolaris'*'-gnu') os_name='gnu_kopensolaris'; is_os_trait_gnu=1; is_os_trait_sysv=1;;
    'linux-android'*)      os_name='linux_android';    is_os_trait_linux=1;;
    'linux-gnu'*)          os_name='linux_gnu';        is_os_trait_gnu=1; is_os_trait_linux=1; is_os_linux_gnu=1;;
    'netbsd'*)             os_name='netbsd';           is_os_trait_bsd=1;;
    'nto-qnx'*)            os_name='qnx_neutrino';;
    'openbsd'*)            os_name='openbsd';          is_os_trait_bsd=1;;
    'solaris'*)            os_name='solaris';          is_os_trait_sysv=1;;
    ('cygwin'|'mingw')*)   os_name='windows';;
    # In contrast to *ALL* other operating systems, autotools ambiguously
    # prefixes $os_host by the name of the set of shared components underlying
    # such system (e.g., "darwin") rather than the fairly unambiguous name of
    # such system (e.g., "ios"). For disambiguity, correct this.
    'darwin'*)
        is_os_trait_darwin=1

        # At present, only two distinct operating systems leverage Darwin:
        # desktop- and server-oriented OS X and mobile-oriented iOS. Since the
        # latter only run on ARM architecture and the former never do, the two
        # are distinguishable by whether the current architecture is ARM.
        #
        # Canonical string global ${MACHTYPE} is set during zsh compilation by
        # autotools script "configure.ac" to the autotools-specific string
        # global $host_cpu. After casually grepping about, there appear to be
        # numerous possible ARM-related values for such global all prefixed by
        # "arm" (e.g., "arm", "armsa1", "armv4"). For safety, test for such
        # prefix rather than simply for "arm".
        #
        # This is all Apple's fault.
        if [[ "${MACHTYPE}" == 'arm'* ]] {
            os_name='ios'
        } else {
            os_name='os_x'
        }
        ;;
    # Else, the current operating system is unrecognized. This. Should. Not. Be.
    *)
        # Note such fact.
        is_os_recognized=0

        # Convert such name to a lowercase single word, converting all dashes
        # and contiguous runs of one or more spaces to underscores.
        os_name="${${(L)OSTYPE// ##/_}//-/_}"

        # Since zeshy is likely to perform poorly under unrecognized OSes, print
        # a nonfatal warning.
        {
            output_string "zeshy: Operating system \"${OSTYPE}\" unrecognized."
        } to_stderr:
    }

    # If the current OS was recognized, define the corresponding tester to
    # always report success.
    if (( is_os_recognized )) {
        :define_function_to_report_success ":is_os_${os_name}"
    }

    # Define all other individual OS testers to always report failure. For
    # efficiency, remove the current OS name from the list of all possible OS
    # names and iterate such list. See remove_list_items() for further details.
    :string os_name_other
    for     os_name_other ("${os_names[@]:#${os_name}}") {
        :define_function_to_report_failure ":is_os_${os_name_other}"
    }

    # Define testers corresponding to booleans set above accordingly.
    :define_function_to_report_bool :is_os_trait_bsd       "${is_os_trait_bsd}"
    :define_function_to_report_bool :is_os_trait_darwin    "${is_os_trait_darwin}"
    :define_function_to_report_bool :is_os_trait_gnu       "${is_os_trait_gnu}"
    :define_function_to_report_bool :is_os_trait_gnu_linux "${is_os_linux_gnu}"
    :define_function_to_report_bool :is_os_trait_linux     "${is_os_trait_linux}"
    :define_function_to_report_bool :is_os_trait_sysv      "${is_os_trait_sysv}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_os_aros(void)

Report success if the current operating system is an *AROS distribution* (i.e.,
a distribution of the AROS Research Operating System, an open-source
implementation of the AmigaOS 3.1 APIs).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_haiku(void)

Report success if the current operating system is *Haiku* (i.e., an open-source
operating system compatible at both the source and binary level with the long-
defunct BeOS).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_qnx_neutrino(void)

Report success if the current operating system is *QNX Neutrino* (i.e., a Unix-
like real-time operating system popular in the embedded systems market).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_windows(void)

Report success if the current operating system is Microsoft Windows.
/---

# ....................{ TESTERS ~ darwin                   }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_os_trait_darwin(void)

Report success if the current operating system has an Apple Darwin core. This
implies such system to provide both the *XNU kernel* (i.e., hybrid kernel
combining the Mach 3 microkernel and BSD 4.4 kernel subsystems) and well-known
low-level open-source components (e.g., `launchd`, `mDNSResponder`). While both
the OS X and iOS platforms leverage Darwin, this does _not_ necessarily imply
the current system to also provide high-level closed-source components commonly
associated with either platform (e.g., Carbon, Cocoa).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_ios(void)

Report success if the current operating system is Apple iOS, implying such
system to be running on an Apple mobile device (e.g., iPhone, iPod, iPad).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_os_x(void)

Report success if the current operating system is Apple OS X.
/---

# ....................{ TESTERS ~ bsd                      }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_os_trait_bsd(void)

Report success if the current operating system is a *Berkeley Software
Distribution (BSD) derivative* (i.e., a Unix operating system running a BSD
kernel but _not_ necessarily a customary BSD software stack). This includes:

* DragonFly BSD.
* FreeBSD.
* GNU/kFreeBSD.
* NetBSD.
* OpenBSD.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_dragonfly_bsd(void)

Report success if the current operating system is DragonFly BSD.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_freebsd(void)

Report success if the current operating system is FreeBSD. This does _not_
include GNU/kFreeBSD, which only provides the FreeBSD kernel (rather than both
the FreeBSD kernel and corresponding userland software stack).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_netbsd(void)

Report success if the current operating system is NetBSD.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_openbsd(void)

Report success if the current operating system is OpenBSD.
/---

# ....................{ TESTERS ~ linux                    }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_os_trait_linux(void)

Report success if the current operating system is a *Linux distribution* (i.e.,
a Unix-like operating system running the Linux kernel), including but _not_
limited to conventional GNU/Linux distributions.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_linux_android(void)

Report success if the current operating system is *Google Android* (i.e., a
Linux distribution targetting touchscreen mobile devices).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_linux_gnu(void)

Report success if the current operating system is a *GNU/Linux distribution*
(i.e., a system both running the Linux kernel _and_ supporting the GNU software
stack).
/---

# ....................{ TESTERS ~ gnu                      }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_os_trait_gnu(void)

Report success if the current operating system supports the *GNU software stack*
(i.e., suite of operating system utilities produced by the GNU Project). This
excludes operation systems unaffiliated with GNU supporting an optional subset
of such stack (e.g., via MacPorts under Apple Darwin).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_gnu_hurd(void)

Report success if the current operating system is *GNU/Hurd* (i.e., the official
GNU operating system, running the GNU Mach microkernel).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_gnu_kfreebsd(void)

Report success if the current operating system is *GNU/kFreeBSD* (i.e., a
FreeBSD variant providing the GNU software stack).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_gnu_kopensolaris(void)

Report success if the current operating system is *GNU/kOpenSolaris* (i.e., an
OpenSolaris variant providing the GNU software stack).
/---

# ....................{ TESTERS ~ sysv                     }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_os_trait_sysv(void)

Report success if the current operating system is a Unix System V derivative.
This implies such system to have a System V kernel, typically either Release 3
or 4. Currently, this includes:

* All Solaris variants (e.g., OpenSolaris, Oracle Solaris, illumos).
* Hewlett Packard's HP-UX.
* IBM's AIX.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_aix(void)

Report success if the current operating system is IBM's AIX.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_os_hpux(void)

Report success if the current operating system is Hewlett Packard's HP-UX.
/---

#FIXME: Should probably be generalized to :is_os_trait_solaris(), yes?
declare_function_with_stdin <<'/---'
[status: bool] :is_os_solaris(void)

Report success if the current operating system is a Solaris variant (e.g.,
Oracle Solaris, Sun Solaris, OpenSolaris, illumos).
/---

# ....................{ MAIN                               }....................
::define_os_functions

# --------------------( WASTELANDS                         )--------------------
# ....................{ SETTERS                            }....................
# declare_function_with_stdin <<'/---'
# void :set_string_to_os(string string_name)
# 
# Set the passed string to the current OS name.
# /---

#FUXME: Rename all functions testing attributes rather than the exact name of
#the current OS from ":is_os_" to ":is_os_trait_" (e.g., from :is_os_trait_sysv() to
#:is_os_trait_sysv()). The reason is fairly clear: there *WILL*, at some point,
#exist an OS with the same name as its trait shared between several OSes. In
#fact, this is already the case for Linux distributions (e.g., there exists both
#a specific distribution "Gentoo" *AND* a trait "Gentoo" shared between multiple
#distributions, and the two describe entirely separate conditions). If "trait"
#doesn't quite suite us, there exist a number of reasonable alternatives:
#
#* :is_os_trait_sysv(). (Excellent. Contemplate!)
#* :is_os_like_sysv(). (Quite good. Better than :is_os_trait_sysv(), however?
#  Probably not. After all, Android Linux isn't simply *LIKE* Linux: it *IS*
#  Linux. Hence, a tester :is_os_like_linux() makes little sense. In many cases,
#  the verb "like" is completely inapplicable and in fact erroneous.)
#* :is_os_type_sysv(). (Probably the worst, honestly. Consider a related tester
#  :is_distro_type_gentoo(). Is an OS X machine running Gentoo Prefix really of
#  type Gentoo? No, not really. It's "type," if it could be said to have any, is
#  Darwin -- not Gentoo. Gentoo, in this case, would merely be an ancillary
#  "trait" layered on top of the core OS type. In which case, the phrase "type"
#  fails to generally apply.)

    #FUXME: Terrible definition. Wherever this function is actually called, you
    #can guarantee proper zeshy functions (e.g., set_string_to_string()) are
    #available for calling.
    #FUXME: But that's hardly the worst complaint. I'm unconvinced we even
    #*REQUIRE* this setter. In all honesty, we probably don't. @{inspect}
    #already maintains globals for most other system-related metadata, including
    #Linux distribution.

    # Define a setter setting the passed string to the current OS name.
    # define_function :set_string_to_os\
    #    '# Validate sanity.
    #     die_unless_arg "Expected one string name."
    #     :string string_name__ssto="${1}"

    #     # If such string is undefined or not of the expected type, throw an
    #     # exception. See is_variable_string() for further details.
    #     [[ "${(tP)string_name__ssto-}" == "scalar"* ]] || die\
    #         ''${''${string_name__ssto}''} undefined or not a string.''

    #     # Set such string. See set_string_to_string() for further details.
    #     : "${(P)string_name__ssto::='${os_name}'}"'

    # If the current OS is a Linux distribution, define the corresponding tester
    # to always report success; else, define such tester to always report failure.
    # Since the autotools-specific names for all such OSes are prefixed by
    # "linux", match such names with a plain glob.
    # if is "${OSTYPE}" == 'linux'* si { define_function :is_os_trait_linux 'die_if_args; report_success'
    # } else                           { define_function :is_os_trait_linux 'die_if_args; report_failure' }

    # If the current OS is a BSD or Unix System V derivative or supports the GNU
    # toolchain, define the corresponding tester to always report success; else,
    # define such tester to always report failure.
    # if (( is_os_trait_bsd ))  { define_function :is_os_trait_bsd  'die_if_args; report_success'
    # } else              { define_function :is_os_trait_bsd  'die_if_args; report_failure' }
    # if (( is_os_trait_gnu ))  { define_function :is_os_trait_gnu  'die_if_args; report_success'
    # } else              { define_function :is_os_trait_gnu  'die_if_args; report_failure' }
    # if (( is_os_trait_sysv )) { define_function :is_os_trait_sysv 'die_if_args; report_success'
    # } else              { define_function :is_os_trait_sysv 'die_if_args; report_failure' }

    # If such OS is GNU/Linux.
    # if is "${os_name}" == 'linux_gnu' si {
    # }

#, automatically (rather than manually) define a new
# tester for each such OS by
# For efficiency, define OS testers to statically report either success or
# failure (rather than conditionally performing a test). See below for
# function documentation.
#
#FUXME: Should probably give this function a name to permit us to call it
#elsewhere at will, should the need ever arise.
#This implies
# such system to have a BSD kernel but _not_ necessarily the standard BSD
# toolchain. 
# and hence are preferable.
#FUXME: Define a setter :set_string_to_os() setting such string to ${ZESHY_OS}.
#Incidentally, if such function is defined dynamically in the above anonymous
#function, then we can (and should!) reduce ${ZESHY_OS} to a local string of
#such function. Sensible, no? The fewer globals the better.

#FUXME: Given the likelihood of calling such functions frequently during digest
#compilation, such functions should be strongly optimized. Fortunately, this is
#more or less simple: if the current OS is such os, such function should be
#defined to report success without performing a conditional test; else, be
#defined to report failure. Simple. So, we'll need something resembling:
#
#declare_global_with_stdin string ZESHY_OS <<'/---'
#Name of the current operating system as exactly one lowercase word.
#/---
#
#() {
#   :bool is_bsd="${ZESHY_BOOLEAN_FALSE}"
#
#   # Map from autotools- to zeshy-specific OS names. The latter tend to
#   # correspond more to the human-readable OS name than the former (e.g.,
#   # "gnu_hurd" rather than "gnu") and hence are preferable.
#   case "${OSTYPE}" {
#   dragonfly*) ZESHY_OS='dragonfly_bsd'; is_bsd="${ZESHY_BOOLEAN_TRUE}";;
#   *) ZESHY_OS="${OSTYPE//[[:space:]]##/_}";;
#   }
#
#   if (( is_bsd )) {
#       define_function :is_os_trait_bsd 'die_if_args; report_success'
#   }
#
#   #FUXME: Define all *OTHER* testers to report failure.
#   define_function ":is_os_${ZESHY_OS}" 'die_if_args; report_success'
#}
#
#The core idea is that we first convert ${OSTYPE} to ${ZESHY_OS}, then define
#is_os_${ZESHY_OS}() to report success and all other such testers to report
#failure. Simple, no?

    #FUXME: Define all *OTHER* testers to report failure. We'll probably need to
    #perform list or map item deletion or differencing to do so reasonably.
    #(Ideally the former, yes?)

    # If the current OS is a BSD, define such tester to report success.
    # if (( is_os_trait_bsd )) {
    #     define_function :is_os_trait_bsd 'die_if_args; report_success'
    # # Else, define such tester to report failure.
    # } else {
    #     define_function :is_os_trait_bsd 'die_if_args; report_failure'
    # }

#function :is_os_aros() {
#    die_if_args
#    is "${OSTYPE}" == 'aros'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_darwin(void)
#
#Report success if the current operating system has an Apple Darwin core. This
#implies such system to provide both the *XNU kernel* (i.e., hybrid kernel
#combining the Mach 3 microkernel and BSD 4.4 kernel subsystems) and well-known
#low-level open-source components (e.g., `launchd`, `mDNSResponder`). While both
#the OS X and iOS platforms leverage Darwin, this does _not_ necessarily imply
#the current system to also provide high-level closed-source components commonly
#associated with either platform (e.g., Carbon, Cocoa).
#/---
#function :is_os_trait_darwin() {
#    die_if_args
#    is "${OSTYPE}" == 'darwin'* si
#}
#
## ....................{ TESTERS ~ bsd                      }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_bsd(void)
#
#Report success if the current operating system is a BSD derivative. This implies
#such system to have a BSD kernel but _not_ necessarily the customary BSD
#toolchain. Currently, this includes:
#
#* DragonFly BSD.
#* FreeBSD.
#* GNU/kFreeBSD.
#* NetBSD.
#* OpenBSD.
#/---
#function :is_os_trait_bsd() {
#    die_if_args
#    is "${OSTYPE}" == ('dragonfly'|'freebsd'|'netbsd'|'openbsd'|'kfreebsd'*'-gnu')* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_dragonfly_bsd(void)
#
#Report success if the current operating system is DragonFly BSD.
#/---
#function :is_os_dragonfly_bsd() {
#    die_if_args
#    is "${OSTYPE}" == 'dragonfly'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_freebsd(void)
#
#Report success if the current operating system is FreeBSD. This does _not_
#include GNU/kFreeBSD, which only provides the FreeBSD kernel (rather than both
#the FreeBSD kernel and corresponding userland toolchain).
#/---
#function :is_os_freebsd() {
#    die_if_args
#    is "${OSTYPE}" == 'freebsd'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_netbsd(void)
#
#Report success if the current operating system is NetBSD.
#/---
#function :is_os_netbsd() {
#    die_if_args
#    is "${OSTYPE}" == 'netbsd'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_openbsd(void)
#
#Report success if the current operating system is OpenBSD.
#/---
#function :is_os_openbsd() {
#    die_if_args
#    is "${OSTYPE}" == 'openbsd'* si
#}
#
## ....................{ TESTERS ~ linux                    }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_linux(void)
#
#Report success if the current operating system is a Linux distribution,
#including but _not_ limited to GNU/Linux distributions.
#/---
#function :is_os_trait_linux() {
#    die_if_args
#    is "${OSTYPE}" == 'linux'* si
#}
#
## ....................{ TESTERS ~ gnu                      }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_gnu(void)
#
#Report success if the current operating system supports the entirety of the *GNU
#toolchain* (i.e., suite of programming tools produced by the GNU Project). This
#excludes operation systems not affiliated with GNU but nonetheless supporting a
#subset of such toolchain (e.g., Apple Darwin).
#/---
#function :is_os_trait_gnu() {
#    die_if_args
#    is "${OSTYPE}" == ('gnu'*|*'-gnu') si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_gnu_hurd(void)
#
#Report success if the current operating system is GNU/Hurd.
#/---
#function :is_os_trait_gnu_hurd() {
#    # Yes, GNU/Hurd's choice of identifier is... unfortunate.
#    die_if_args
#    is "${OSTYPE}" == 'gnu'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_gnu_kfreebsd(void)
#
#Report success if the current operating system is GNU/kFreeBSD.
#/---
#function :is_os_trait_gnu_kfreebsd() {
#    die_if_args
#    is "${OSTYPE}" == 'kfreebsd'*'-gnu' si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] is_os_linux_gnu(void)
#
#Report success if the current operating system is GNU/Linux.
#/---
#function is_os_linux_gnu() {
#    die_if_args
#    is "${OSTYPE}" == 'linux-gnu' si
#}
#
## ....................{ TESTERS ~ sysv                     }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_sysv(void)
#
#Report success if the current operating system is a Unix System V derivative.
#This implies such system to have a System V kernel, typically either Release 3
#or 4. Currently, this includes:
#
#* All Solaris variants (e.g., Oracle Solaris, illumos).
#* Hewlett Packard's HP-UX.
#* IBM's AIX.
#/---
#function :is_os_trait_sysv() {
#    die_if_args
#    is "${OSTYPE}" == ('aix'|'hpux'|'solaris')* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_aix(void)
#
#Report success if the current operating system is IBM's AIX.
#/---
#function :is_os_aix() {
#    die_if_args
#    is "${OSTYPE}" == 'aix'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_hpux(void)
#
#Report success if the current operating system is Hewlett Packard's HP-UX.
#/---
#function :is_os_hpux() {
#    die_if_args
#    is "${OSTYPE}" == 'hpux'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_solaris(void)
#
#Report success if the current operating system is a Solaris variant (e.g.,
#Oracle Solaris, Sun Solaris, OpenSolaris, illumos).
#/---
#function :is_os_solaris() {
#    die_if_args
#    is "${OSTYPE}" == 'solaris'* si
#}
#
## ....................{ TESTERS ~ windows                  }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_windows(void)
#
#Report success if the current operating system is Microsoft Windows.
#/---
#function :is_os_windows() {
#    die_if_args
#    is "${OSTYPE}" == ('cygwin'|'mingw32'|'windows')* si
#}
