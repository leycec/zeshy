#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2013 by Cecil Curry.
# See "COPYING" for additional details.

declare_parcel_as_script_with_stdin <<'/---'
Handle *instruction set architecture (ISA) testers* (i.e., high-level functions
testing whether the current ISA either is a particular ISA _or_ belongs to a
particular category or lineage of such ISAs).
/---

# ....................{ GLOBALS                            }....................
#FIXME: List *ALL* common CPU architecture names here.

# Globalize human- but *NOT* machine-readable names here and in similar parcels
# (e.g., @{*-os}). Since the former tend to be both longer *AND* contain a wider
# set of characters than the latter, the latter are deterministically obtainable
# from the former (e.g., machine-readable ISA name "ia64" is obtainable from
# human-readable ISA name "IA-64" by converting uppercase to lowercase and
# removing hyphens); the converse is rarely the case (e.g., there exists no
# reasonable means by which "IA-64" is obtainable from "ia64").

declare_global_with_stdin string ZESHY_ISA_NAME <<'/---'
Human-readable name of the *current instruction set architecture (ISA)* (i.e.,
the interface between hardware and software for the current system, comprising
the machine language and native commands implemented by the processor(s) for
such system). Such string is guaranteed to be nonempty, but may contain both
whitespace and capitalized letters and hence is _not_ machine-readable.
/---

declare_global_with_stdin string ZESHY_ISA_ID <<'/---'
Machine-readable name of the *current instruction set architecture (ISA)*. Such
string is guaranteed to be nonempty, but may contain both whitespace and
capitalized letters and hence is _not_ human-readable.
/---

declare_global_with_stdin integer ZESHY_ISA_BIT_WIDTH <<'/---'
*Bit width* of the current instruction set architecture (ISA). Typically, this
implies the following to all share the same size in such ISA:

* *Words* (i.e., fixed-sized binary strings used as the ``natural'' units of
  data in such ISA).
* *Memory addresses* (i.e., non-negative integers uniquely identifying physical
  addresses in main memory).
* *Native integers* (e.g., C variables of type `int`).
* All registers in the *datapath* (i.e., the processor core typically consisting
  of at least the program counter and instruction, memory address, and memory
  data registers).
/---

# ....................{ TESTERS                            }....................
# Note that canonical string global ${MACHTYPE} is set during zsh compilation by
# autotools script "configure.ac" to the autotools-specific string global
# $host_cpu. Unfortunately, there appears to exist no definitive list of all
# $host_cpu values, necessitating the ad-hoc approach. Fortunately, reliable
# third-party sources matching a subset of such values do exist. See @{*-os} for
# further details.
#
# * "http://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=blob;f=m4/host-cpu-c-abi.m4",
#   setting the HOST_CPU_C_ABI variable with the M4 macro language in the GNU
#   gnulib library. Given that GNU also maintains autotools, this approximates a
#   definitive list.
#
# We intentionally exclude ISAs no longer under active deployment (e.g.,
# DEC Alpha, Motorola 68000, PA-RISC, RS/6000). Since zeshy requires zsh >=
# 5.0.0, such ISAs are unlikely to run zeshy reliably (if at all).
#
# To add support for a new ISA:
#
# * Add such ISA's zeshy-specific machine-readable name to local list
#   ${isa_ids}.
# * Match such ISA's autotools-specific name and convert such name to:
#   * The zeshy-specific machine-readable string local ${isa_name}.
#   * The zeshy-specific human-readable string global ${ZESHY_ISA_NAME}.
# * Document :is_isa_${isa_name}(), which this function implicitly defines.

declare_function_with_stdin <<'/---'
void ::define_isa_testers(void)

Define all *instruction set architecture (ISA) testers* (i.e., high-level
functions testing whether the current ISA either is a particular ISA _or_
belongs to a particular category or lineage of such ISAs). For efficiency,
this function defines such testers to unconditionally report either success or
failure (rather than to conditionally perform runtime tests).
/---
function ::define_isa_testers() {
    # List of all zeshy-specific machine-readable ISA names.
    :list isa_ids; isa_ids=( arm ia64 mips power sparc x86 )

    # List of all ISA bit widths supported by such ISAs.
    :list bit_widths; bit_widths=( 32 64 )

    # True if the current ISA is explicitly recognized by zeshy.
    # (Defaults to true.)
    :bool is_isa_recognized=1

    # True if the current ISA performs 32-bit addressing. (Defaults to false.)
    :bool is_isa_bit_width_32=0

    # # True if the current ISA performs 64-bit addressing. (Defaults to false.)
    :bool is_isa_bit_width_64=0

    # Map from versioned autotools- to unversioned zeshy-specific machine-
    # readable ISA names (e.g., from "armsa1" to "arm").
    case "${MACHTYPE}" {
    ('arm'*)
        ZESHY_ISA_ID='arm'
        ZESHY_ISA_NAME='ARM'

        # While there do exist both 32- and 64-bit ARM ISAs *AND* multiple
        # $host_os values for such ISAs (e.g., "arm", "armel", "armsa1"), no
        # such values appear to cleanly imply an addressing bit width. Since
        # most ARM ISAs perform 32-bit addressing, assume that for now.
        ZESHY_ISA_BIT_WIDTH=32
        :end_case
    ('i'<3-7>'86')
        ZESHY_ISA_ID='x86'
        ZESHY_ISA_NAME='x86-32'
        ZESHY_ISA_BIT_WIDTH=32
        :end_case
    ('ia64'*)
        ZESHY_ISA_ID='ia64'
        ZESHY_ISA_NAME='IA-64'
        ZESHY_ISA_BIT_WIDTH=64
        :end_case
    ('mips'*)
        ZESHY_ISA_ID='mips'
        ZESHY_ISA_NAME='MIPS'

        if is "${MACHTYPE}" == 'mips64' si {
            ZESHY_ISA_BIT_WIDTH=64
        } else {
            ZESHY_ISA_BIT_WIDTH=32
        }

        :end_case
    ('powerpc'*)
        ZESHY_ISA_ID='power'
        ZESHY_ISA_NAME='Power'

        if is "${MACHTYPE}" == 'powerpc64' si {
            ZESHY_ISA_BIT_WIDTH=64
        } else {
            ZESHY_ISA_BIT_WIDTH=32
        }

        :end_case
    ('sparc'*)
        ZESHY_ISA_ID='sparc'
        ZESHY_ISA_NAME='SPARC'

        if is "${MACHTYPE}" == 'sparc64' si {
            ZESHY_ISA_BIT_WIDTH=64
        } else {
            ZESHY_ISA_BIT_WIDTH=32
        }

        :end_case
    ('x86_64')
        ZESHY_ISA_ID='x86'
        ZESHY_ISA_NAME='x86-64'
        ZESHY_ISA_BIT_WIDTH=64
        :end_case
    # Else, the current ISA is unrecognized.
    (*)
        # Note such fact.
        is_isa_recognized=0

        # Set such ISA's machine-readable name to its autotools-specific name,
        # converting all dashes and contiguous runs of one or more spaces into
        # underscores.
        ZESHY_ISA_ID="${${(L)MACHTYPE// ##/_}//-/_}"

        # Set such ISA's human-readable name to its autotools-specific name,
        # capitalizing the first letter of such name.
        ZESHY_ISA_NAME="${(C)MACHTYPE}"

        # Since zeshy is likely to perform poorly under unrecognized ISAs,
        # print a nonfatal warning.
        :output_warning\
            "Instruction set architecture \"${MACHTYPE}\" unrecognized."
    }

    # Convert the current ISA bit width to equivalent local booleans.
    case "${ZESHY_ISA_BIT_WIDTH}" {
    (32)
        is_isa_bit_width_32=1
        :end_case
    (64)
        is_isa_bit_width_64=1
        :end_case
    # Else, such bit width is unrecognized. Print a nonfatal warning.
    (*)
        :output_warning\
            "Instruction set architecture \"${MACHTYPE}\" bit width unrecognized."
    }

    # If the current ISA was recognized, define the corresponding tester to
    # always report success.
    if (( is_isa_recognized )) {
        :define_function_to_report_success ":is_isa_${ZESHY_ISA_ID}"
    }

    # Define all other ISA testers to always report failure. For efficiency,
    # remove the current ISA from the list of all possible ISAs and iterate such
    # list. See remove_list_items() for further details.
    :string isa_id_other
    for     isa_id_other ("${isa_ids[@]:#${ZESHY_ISA_ID}}") {
        :define_function_to_report_failure ":is_os_${isa_id_other}"
    }

    # If the current ISA is x86, define testers testing specific bit widths.
    # To avoid combinatorial explosion, do *NOT* do so for other ISAs. Due to
    # the extreme commonality of such ISA, such testers are only x86-specific.
    if is "${ZESHY_ISA_ID}" == 'x86' si {
        :define_function_to_report_bool :is_os_x86_32 "${is_isa_bit_width_32}"
        :define_function_to_report_bool :is_os_x86_64 "${is_isa_bit_width_64}"
    # Else, the current ISA is non-x86. Define such testers to report failure.
    } else {
        :define_function_to_report_failure :is_os_x86_32
        :define_function_to_report_failure :is_os_x86_64
    }

    # Define testers corresponding to booleans set above accordingly.
    :define_function_to_report_bool\
        :is_isa_bit_width_32 "${is_isa_bit_width_32}"
    :define_function_to_report_bool\
        :is_isa_bit_width_64 "${is_isa_bit_width_64}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_isa_arm(void)

Report success if the current instruction set architecture (ISA) is *ARM* (i.e.,
a reduced instruction set computing (RISC) ISA designed by ARM Holdings).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_ia64(void)

Report success if the current instruction set architecture (ISA) is *IA-64*
(i.e., if the current CPU is a 64-bit Intel Itanium CPU).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_power(void)

Report success if the current instruction set architecture (ISA) is *Power*
(i.e., a family of reduced instruction set computing (RISC) ISAs managed by
Power.org), formerly referred to as *PowerPC* and *PPC*.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_mips(void)

Report success if the current instruction set architecture (ISA) is *MIPS*
(i.e., Microprocessor without Interlocked Pipeline Stages, a reduced instruction
set computing (RISC) ISA designed by MIPS Technologies).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_sparc(void)

Report success if the current instruction set architecture (ISA) is *SPARC*
(i.e., Scalable Processor Architecture, a reduced instruction set computing
(RISC) ISA first designed by Sun Microsystems).
/---

# ....................{ TESTERS ~ x86                      }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_isa_x86(void)

Report success if the current instruction set architecture (ISA) is *x86* (i.e.,
a family of backward-compatible ISAs derived from the Intel 8086 CPU). Since x86
comprises 16-, 32-, and 64-bit variants, success does _not_ imply such ISA to
perform either 32- or 64-bit addressing. To test either condition, consider
calling :is_isa_x32() or :is_isa_x64() instead.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_x86_32(void)

Report success if the current instruction set architecture (ISA) is *x86-32*
(i.e., the 32-bit version of the x86 instruction set), also referred to as
*x32*, *x86_32*, and *IA-32*. This tester is shorthand for the equivalent test
`:is_isa_x86() and :is_isa_bit_width_32()`.
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_x86_64(void)

Report success if the current instruction set architecture (ISA) is *x86-64*
(i.e., the 64-bit version of the x86 instruction set), also referred to as
*x64*, *x86_64*, and *amd64*. This tester is shorthand for the equivalent test
`:is_isa_x86() and :is_isa_bit_width_64()`.
/---

# ....................{ TESTERS ~ bit width                }....................
declare_function_with_stdin <<'/---'
[status: bool] :is_isa_bit_width_32(void)

Report success if the current instruction set architecture (ISA) is *32-bit*
(i.e., if such ISA performs 32-bit addressing and hence has a bit width of 32).
/---

declare_function_with_stdin <<'/---'
[status: bool] :is_isa_bit_width_64(void)

Report success if the current instruction set architecture (ISA) is *64-bit*
(i.e., if such ISA performs 64-bit addressing and hence has a bit width of 64).
/---

# ....................{ MAIN                               }....................
::define_isa_testers

# --------------------( WASTELANDS                         )--------------------
    # zeshy-specific machine-readable name of the current ISA.
    # :string isa_name

# == Canonical Names ==
# 
# The table below maps ca

    #FUXME: Detect and set ${ZESHY_ISA_BIT_WIDTH} below, as well as defining and
    #documenting equivalent testers.

    # Number of bits the current ISA can directly address.
    # :int bit_width=0

# Size in bits of registers in the current instruction set architecture (ISA).
# Equivalently, the number of bits such ISA can directly address.
# 
# datapath widths, integer size, and memory addresses widths of 64 bits (eight octets)

# == Nomenclature ==
# 
# The family of backward-compatible instruction set architectures (ISAs) referred
# to as *x86* encapsulates 16-, 32-, and 64-bit variants, of which this ISA is
# merely one. See also :is_isa_x64().

    # True if the current ISA performs 32-bit addressing. (Defaults to false.)
    # :bool is_isa_bits_32=0

    # # True if the current ISA performs 64-bit addressing. (Defaults to false.)
    # :bool is_isa_bits_64=0

#FUXME: Rather than abbreviate "architecture" to "arch", we should probably just
#use the formal acronym "isa" (Instruction Set Architecture), which is both more
#specific and in unabbreviated form. It's also quite readable and, while not
#terribly important, one character less. Since "ISA" unambiguously refers to
#CPUs, we may thus rename ":is_isa_" to ":is_isa" everywhere. Yay!

    # True if the current architecture is GNU/Linux. (Defaults to false.)
    # :bool is_isa_linux_gnu=0
    # Define testers corresponding to booleans set above accordingly.
    # :define_function_to_report_bool :is_os_trait_bsd       "${is_os_trait_bsd}"

    # Unfortunately, autotools assigns ${host_cpu} and hence ${MACHTYPE}
    # numerous possible values under ARM architectures all prefixed by "arm"
    # (e.g., "arm", "armsa1", "armv4"). Hence, test for such prefix.

#   This function then implicitly defines a tester for such architecture named
#   :is_isa_${isa_name}().

# ....................{ SETTERS                            }....................
# declare_function_with_stdin <<'/---'
# void :set_string_to_os(string string_name)
# 
# Set the passed string to the current OS name.
# /---

#FUXME: Rename all functions testing attributes rather than the exact name of
#the current OS from ":is_os_" to ":is_os_trait_" (e.g., from :is_os_trait_sysv() to
#:is_os_trait_sysv()). The reason is fairly clear: there *WILL*, at some point,
#exist an OS with the same name as its trait shared between several OSes. In
#fact, this is already the case for Linux distributions (e.g., there exists both
#a specific distribution "Gentoo" *AND* a trait "Gentoo" shared between multiple
#distributions, and the two describe entirely separate conditions). If "trait"
#doesn't quite suite us, there exist a number of reasonable alternatives:
#
#* :is_os_trait_sysv(). (Excellent. Contemplate!)
#* :is_os_like_sysv(). (Quite good. Better than :is_os_trait_sysv(), however?
#  Probably not. After all, Android Linux isn't simply *LIKE* Linux: it *IS*
#  Linux. Hence, a tester :is_os_like_linux() makes little sense. In many cases,
#  the verb "like" is completely inapplicable and in fact erroneous.)
#* :is_os_type_sysv(). (Probably the worst, honestly. Consider a related tester
#  :is_distro_type_gentoo(). Is an OS X machine running Gentoo Prefix really of
#  type Gentoo? No, not really. It's "type," if it could be said to have any, is
#  Darwin -- not Gentoo. Gentoo, in this case, would merely be an ancillary
#  "trait" layered on top of the core OS type. In which case, the phrase "type"
#  fails to generally apply.)

    #FUXME: Terrible definition. Wherever this function is actually called, you
    #can guarantee proper zeshy functions (e.g., set_string_to_string()) are
    #available for calling.
    #FUXME: But that's hardly the worst complaint. I'm unconvinced we even
    #*REQUIRE* this setter. In all honesty, we probably don't. @{inspect}
    #already maintains globals for most other system-related metadata, including
    #Linux distribution.

    # Define a setter setting the passed string to the current OS name.
    # define_function :set_string_to_os\
    #    '# Validate sanity.
    #     die_unless_arg "Expected one string name."
    #     :string string_name__ssto="${1}"

    #     # If such string is undefined or not of the expected type, throw an
    #     # exception. See is_variable_string() for further details.
    #     [[ "${(tP)string_name__ssto-}" == "scalar"* ]] || die\
    #         ''${''${string_name__ssto}''} undefined or not a string.''

    #     # Set such string. See set_string_to_string() for further details.
    #     : "${(P)string_name__ssto::='${os_name}'}"'

    # If the current OS is a Linux distribution, define the corresponding tester
    # to always report success; else, define such tester to always report failure.
    # Since the autotools-specific names for all such OSes are prefixed by
    # "linux", match such names with a plain glob.
    # if is "${OSTYPE}" == 'linux'* si { define_function :is_os_trait_linux 'die_if_args; report_success'
    # } else                           { define_function :is_os_trait_linux 'die_if_args; report_failure' }

    # If the current OS is a BSD or Unix System V derivative or supports the GNU
    # toolchain, define the corresponding tester to always report success; else,
    # define such tester to always report failure.
    # if (( is_os_trait_bsd ))  { define_function :is_os_trait_bsd  'die_if_args; report_success'
    # } else              { define_function :is_os_trait_bsd  'die_if_args; report_failure' }
    # if (( is_os_trait_gnu ))  { define_function :is_os_trait_gnu  'die_if_args; report_success'
    # } else              { define_function :is_os_trait_gnu  'die_if_args; report_failure' }
    # if (( is_os_trait_sysv )) { define_function :is_os_trait_sysv 'die_if_args; report_success'
    # } else              { define_function :is_os_trait_sysv 'die_if_args; report_failure' }

    # If such OS is GNU/Linux.
    # if is "${os_name}" == 'linux_gnu' si {
    # }

#, automatically (rather than manually) define a new
# tester for each such OS by
# For efficiency, define OS testers to statically report either success or
# failure (rather than conditionally performing a test). See below for
# function documentation.
#
#FUXME: Should probably give this function a name to permit us to call it
#elsewhere at will, should the need ever arise.
#This implies
# such system to have a BSD kernel but _not_ necessarily the standard BSD
# toolchain. 
# and hence are preferable.
#FUXME: Define a setter :set_string_to_os() setting such string to ${ZESHY_OS}.
#Incidentally, if such function is defined dynamically in the above anonymous
#function, then we can (and should!) reduce ${ZESHY_OS} to a local string of
#such function. Sensible, no? The fewer globals the better.

#FUXME: Given the likelihood of calling such functions frequently during digest
#compilation, such functions should be strongly optimized. Fortunately, this is
#more or less simple: if the current OS is such os, such function should be
#defined to report success without performing a conditional test; else, be
#defined to report failure. Simple. So, we'll need something resembling:
#
#declare_global_with_stdin string ZESHY_OS <<'/---'
#Name of the current operating system as exactly one lowercase word.
#/---
#
#() {
#   :bool is_bsd="${ZESHY_BOOLEAN_FALSE}"
#
#   # Map from autotools- to zeshy-specific OS names. The latter tend to
#   # correspond more to the human-readable OS name than the former (e.g.,
#   # "gnu_hurd" rather than "gnu") and hence are preferable.
#   case "${OSTYPE}" {
#   dragonfly*) ZESHY_OS='dragonfly_bsd'; is_bsd="${ZESHY_BOOLEAN_TRUE}";;
#   *) ZESHY_OS="${OSTYPE//[[:space:]]##/_}";;
#   }
#
#   if (( is_bsd )) {
#       define_function :is_os_trait_bsd 'die_if_args; report_success'
#   }
#
#   #FUXME: Define all *OTHER* testers to report failure.
#   define_function ":is_os_${ZESHY_OS}" 'die_if_args; report_success'
#}
#
#The core idea is that we first convert ${OSTYPE} to ${ZESHY_OS}, then define
#is_os_${ZESHY_OS}() to report success and all other such testers to report
#failure. Simple, no?

    #FUXME: Define all *OTHER* testers to report failure. We'll probably need to
    #perform list or map item deletion or differencing to do so reasonably.
    #(Ideally the former, yes?)

    # If the current OS is a BSD, define such tester to report success.
    # if (( is_os_trait_bsd )) {
    #     define_function :is_os_trait_bsd 'die_if_args; report_success'
    # # Else, define such tester to report failure.
    # } else {
    #     define_function :is_os_trait_bsd 'die_if_args; report_failure'
    # }

#function :is_os_aros() {
#    die_if_args
#    is "${OSTYPE}" == 'aros'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_darwin(void)
#
#Report success if the current operating system has an Apple Darwin core. This
#implies such system to provide both the *XNU kernel* (i.e., hybrid kernel
#combining the Mach 3 microkernel and BSD 4.4 kernel subsystems) and well-known
#low-level open-source components (e.g., `launchd`, `mDNSResponder`). While both
#the OS X and iOS platforms leverage Darwin, this does _not_ necessarily imply
#the current system to also provide high-level closed-source components commonly
#associated with either platform (e.g., Carbon, Cocoa).
#/---
#function :is_os_trait_darwin() {
#    die_if_args
#    is "${OSTYPE}" == 'darwin'* si
#}
#
## ....................{ TESTERS ~ bsd                      }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_bsd(void)
#
#Report success if the current operating system is a BSD derivative. This implies
#such system to have a BSD kernel but _not_ necessarily the customary BSD
#toolchain. Currently, this includes:
#
#* DragonFly BSD.
#* FreeBSD.
#* GNU/kFreeBSD.
#* NetBSD.
#* OpenBSD.
#/---
#function :is_os_trait_bsd() {
#    die_if_args
#    is "${OSTYPE}" == ('dragonfly'|'freebsd'|'netbsd'|'openbsd'|'kfreebsd'*'-gnu')* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_dragonfly_bsd(void)
#
#Report success if the current operating system is DragonFly BSD.
#/---
#function :is_os_dragonfly_bsd() {
#    die_if_args
#    is "${OSTYPE}" == 'dragonfly'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_freebsd(void)
#
#Report success if the current operating system is FreeBSD. This does _not_
#include GNU/kFreeBSD, which only provides the FreeBSD kernel (rather than both
#the FreeBSD kernel and corresponding userland toolchain).
#/---
#function :is_os_freebsd() {
#    die_if_args
#    is "${OSTYPE}" == 'freebsd'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_netbsd(void)
#
#Report success if the current operating system is NetBSD.
#/---
#function :is_os_netbsd() {
#    die_if_args
#    is "${OSTYPE}" == 'netbsd'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_openbsd(void)
#
#Report success if the current operating system is OpenBSD.
#/---
#function :is_os_openbsd() {
#    die_if_args
#    is "${OSTYPE}" == 'openbsd'* si
#}
#
## ....................{ TESTERS ~ linux                    }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_linux(void)
#
#Report success if the current operating system is a Linux distribution,
#including but _not_ limited to GNU/Linux distributions.
#/---
#function :is_os_trait_linux() {
#    die_if_args
#    is "${OSTYPE}" == 'linux'* si
#}
#
## ....................{ TESTERS ~ gnu                      }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_gnu(void)
#
#Report success if the current operating system supports the entirety of the *GNU
#toolchain* (i.e., suite of programming tools produced by the GNU Project). This
#excludes operation systems not affiliated with GNU but nonetheless supporting a
#subset of such toolchain (e.g., Apple Darwin).
#/---
#function :is_os_trait_gnu() {
#    die_if_args
#    is "${OSTYPE}" == ('gnu'*|*'-gnu') si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_gnu_hurd(void)
#
#Report success if the current operating system is GNU/Hurd.
#/---
#function :is_os_trait_gnu_hurd() {
#    # Yes, GNU/Hurd's choice of identifier is... unfortunate.
#    die_if_args
#    is "${OSTYPE}" == 'gnu'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_gnu_kfreebsd(void)
#
#Report success if the current operating system is GNU/kFreeBSD.
#/---
#function :is_os_trait_gnu_kfreebsd() {
#    die_if_args
#    is "${OSTYPE}" == 'kfreebsd'*'-gnu' si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] is_os_linux_gnu(void)
#
#Report success if the current operating system is GNU/Linux.
#/---
#function is_os_linux_gnu() {
#    die_if_args
#    is "${OSTYPE}" == 'linux-gnu' si
#}
#
## ....................{ TESTERS ~ sysv                     }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_trait_sysv(void)
#
#Report success if the current operating system is a Unix System V derivative.
#This implies such system to have a System V kernel, typically either Release 3
#or 4. Currently, this includes:
#
#* All Solaris variants (e.g., Oracle Solaris, illumos).
#* Hewlett Packard's HP-UX.
#* IBM's AIX.
#/---
#function :is_os_trait_sysv() {
#    die_if_args
#    is "${OSTYPE}" == ('aix'|'hpux'|'solaris')* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_aix(void)
#
#Report success if the current operating system is IBM's AIX.
#/---
#function :is_os_aix() {
#    die_if_args
#    is "${OSTYPE}" == 'aix'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_hpux(void)
#
#Report success if the current operating system is Hewlett Packard's HP-UX.
#/---
#function :is_os_hpux() {
#    die_if_args
#    is "${OSTYPE}" == 'hpux'* si
#}
#
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_solaris(void)
#
#Report success if the current operating system is a Solaris variant (e.g.,
#Oracle Solaris, Sun Solaris, OpenSolaris, illumos).
#/---
#function :is_os_solaris() {
#    die_if_args
#    is "${OSTYPE}" == 'solaris'* si
#}
#
## ....................{ TESTERS ~ windows                  }....................
#declare_function_with_stdin <<'/---'
#[status: bool] :is_os_windows(void)
#
#Report success if the current operating system is Microsoft Windows.
#/---
#function :is_os_windows() {
#    die_if_args
#    is "${OSTYPE}" == ('cygwin'|'mingw32'|'windows')* si
#}
