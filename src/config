#!/usr/bin/env zsh
# ====================[ config                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Source the current user's Zeshy configuration files after defining aliases
# required by such files. For efficiency, defer defining all other aliases to
# Zeshy startup in the proper Zeshy codebase and hence compilation into the
# Zeshy digest file. Redefine aliases defined below with such other aliases,
# guaranteeing that:
#
# * Zeshy records all aliases defined below in global list ${ZESHY_ALIAS_NAMES},
#   to be subsequently undefined if recompiling Zeshy in the current shell or a
#   child of the current shell. (See "compile" for gruesome details.)
# * Zeshy retrieves documentation for all aliases defined below in the same
#   manner as such other aliases. (See "help" for miserable details.)

# ....................{ GLOBALS                            }....................
# Map variable type to zsh statement declaring variables of such type: e.g.,
#
#   # Declare ${THIS_IS_A_MAP} to be a global map.
#   >>> ${ZESHY_GLOBAL_TYPE_TO_DECLARATOR[map]} THIS_IS_A_MAP
typeset -Agx ZESHY_GLOBAL_TYPE_TO_DECLARATOR; ZESHY_GLOBAL_TYPE_TO_DECLARATOR=(
    # Scalar types.
    string   'export'
    boolean  'export'
    integer  'export -i'
    float    'export -F'

    # Non-scalar types.
    list     'export -a'
    list_set 'export -Ua'

    # While "export -a" succeeds (as above), "export -A" oddly fails with error.
    # Hence, revert to builtin typeset().
    map 'typeset -Agx'
)

# ....................{ EXPORTS                            }....................
# Zeshy configuration files declare only global exports. While such files can
# declare locals and non-exported globals with traditional Zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Delay defining all remaining Zeshy aliases to the
# main Zeshy codebase.

# ....................{ EXPORTS ~ type                     }....................
#FIXME: Excise after converting all current configuration file global
#declarations to the aliases below.
#FIXME: Hmm; actually, we'll have to replicate the current document_function()
#function into a new document_global() function defined here. And since we're
#defining that function here, we'd might as well move document_function() from
#"compile" here as well for sanity. Shouldn't be terribly difficult. The tedious
#aspect will be in converting existing configuration files to call such
#function. Well... no time like the present, yes?
#FIXME: Ah; hmm. I note that we *COULD* define:
#alias document_global='
#{
#    # Parse variable helpstring here. Since the first line is something like:
#    #
#    #     string ZESHY_ZSTRANGE
#    #
#    #     I'm a strange global. (But here I am.)
#    #
#    # ...this implementation can parse that line and produce the corresponding
#    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
#    # implementation uses a dictionary lookup on the first shell word of such
#    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
#    # See initial definition above.
#} <<<'
#I am mildly concerned about the efficiency of sourcing configuration files with
#numerous such alias expansions. If efficiency becomes a problem, just
#implement a separate document_global() function. That then leaves us with code
#resembling:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#string_global_export ZESHY_ZSTRANGE='lululululuuuuuu"
#
#The above alternative leaves us with:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#ZESHY_ZSTRANGE='lululululuuuuuu"
#
#FIXME: O.K.; so, in either case, we have a document_global() runnable. The
#latter case is more concise and hence preferable, but somewhat less efficient
#due to parsing overhead. Let's see how much it costs us. Simple experiment:
#
#* Temporarily force is_zeshy_digest_outdated() to return_false.
#* Copy all of the existing config files to a new dir under "old/".
#* Migrate existing config files to call document_global().
#* Time startup under both! Hopefully, the overhead isn't hideously noticeable.
#FIXME: The following aliases *SHOULD* already exist under "always/00-setup".
#Ensure this to be the case; then, excise such aliases here.
#FIXME: We may need to explicitly unset ${documentation_dg} *ONCE* after
#sourcing all configuration files. We'll know whether we need to do so based on
#whether or not the current environment has become polluted with such variable
#after entering a new Zeshy shell.

alias document_global='
{
    # Parse variable helpstring here. Since the first line is something like:
    #
    #     string ZESHY_ZSTRANGE
    #
    #     I''m a strange global. (But here I am.)
    #
    # ...this implementation can parse that line and produce the corresponding
    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
    # implementation uses a dictionary lookup on the first shell word of such
    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
    # See initial definition above.

    # Localize the passed herestring.
    local documentation_dg="$(< /dev/stdin)"

    # If such documentation is prefixed by a valid function prototype, match the
    # relevant function name from such prototype. zsh permissively allows
    # function name declarations to be quoted and hence contain arbitrary
    # characters, necessitating a more lenient glob expression than liked here.
    # Dismantled, this is:
    #
    # * "(#b)", capturing match groups into global list ${match}.
    # * "[[:space:]]#", matching optional whitespace.
    # * "([^[:space:]]##)", matching the variable type into ${match[1]}.
    # * "[[:space:]]##", matching mandatory whitespace.
    # * "([[:IDENT:]]##)", matching the variable name into ${match[2]}.
    #
    # Else throw an exception with a portion of such documentation.
    [[ "${documentation}" ==\
        (#b)[[:space:]]#([^[:space:]]##)[[:space:]]##([[:IDENT:]]##)* ]] ||
        die "\"${documentation[1,40]}...\" not prefixed by a variable declaration"

    # If the matched variable type is not a Zeshy-specific type, throw an
    # exception. See is_map_key() for implementation details.
    #
    # Prefer "${match[1]}" and "${match[2]}" to human-readable local variables
    # to avoid "polluting" the local environment.
    [[ -n "${(k)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[(r)${match[1]}]-}" ]] ||
        die "\"${match[1]}\" not a zeshy global type"

    # Declare such global.
    ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[${match[1]}]} "${match[2]}"

    # Document such global.
    set_global_documentation "${match[2]}" "${documentation}"
#   print "function name: ${match[1]}"
} <<<'

alias string_global_export='export'
alias boolean_global_export='export'
alias integer_global_export='export -i'
alias float_global_export='export -F'
alias list_global_export='export -a'
alias list_set_global_export='export -Ua'

# "export -A" oddly fails with error; "export -a" succeeds, however. (No idea!?)
alias map_global_export='typeset -Agx'

# ....................{ EXPORTS ~ value                    }....................
# Mimic genuine boolean values with simple string globals.
export ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=

# ....................{ SOURCERS                           }....................
set_function_documentation source_zeshy_configuration '
void source_zeshy_configuration(void)

Source all configuration files in Zeshy''s user configuration directory specific
to the current shell, creating such directory if needed. Such files include:

* All plain files in such directory.
* If the current shell is interactive, all plain files in subdirectory
  "if_shell_interactive" of such directory.
'
function source_zeshy_configuration() {
    # Validate sanity. If ignoring Zeshy's user directory or Zeshy's user
    # configuration directory does not exist, return silently.
    (( # == 0 )) || die 'expected no arguments'
    [[ -n "${ZESHY_DOT_DIR}" || ! -d "${ZESHY_DOT_CONFIG_DIR}" ]] || return 0

    # List of all scripts in such directory applicable to the current shell,
    # Dismantled, this is:
    #
    # * "*(-.)", matching all plain files after resolving symbolic links.
    local -a config_filenames
    config_filenames=(
        "${ZESHY_DOT_CONFIG_DIR}/"*(-.) )
    [[ -o interactive ]] && config_filenames+=(
        "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

    # If at least one such script exists, source such scripts; else, avoid
    # calling source_zeshy_script() with no arguments throwing an exception.
    (( #config_filenames )) && source_zeshy_script "${config_filenames[@]}"
}

# ....................{ MAIN                               }....................
source_zeshy_configuration

# --------------------( WASTELANDS                         )--------------------
    # Ensure the current user's Zeshy configuration directory and all non-extant
    # parents of such directory exist.
#   command mkdir -p -- "${ZESHY_DOT_CONFIG_DIR}"

    # specifically including:
    #
    # * All plain files in such directory.
    # * If the current shell is interactive, all plain files in subdirectory
    #   "if_shell_interactive" of such directory.
    #
    # If the current shell is interactive and such directory contains a
    # subdirectory "if_shell_interactive" containing at least one Zeshy script,
    # source such scripts as above.
#   config_filenames=( "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

# Booleans are false if set to the empty string and otherwise true.
#
# For simplicity, disable or enable booleans by commenting or uncommenting the
# lines on which they appear (e.g., prefixing such lines with "#" or deleting
# such prefix).

    # subsequent logic
    # sources the default versions of such files.

#FUXME: All of the magic constants defined in "global" should be declared
#frozen, perhaps suggesting new "string_global_constant",
#"boolean_global_constant", and so on types in "alias".

#FUXME: I'm not terribly fond of enabling booleans by setting them to 1. Avoid
#such magic by defining the following magic in "global":
#
#string_global_constant ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=''
#
#Then use below: e.g.,
#ZESHY_IS_DEBUGGING=${ZESHY_BOOLEAN_TRUE}

# void string_global_export(string variable_name)
#
# Globally declare a string exported to the calling shell.
#alias string_global_export='export'

# void boolean_global_export(string variable_name)
#
# Globally declare a boolean exported to the calling shell.
#alias boolean_global_export='export'

# void integer_global_export(string variable_name)
#
# Globally declare an integer exported to the calling shell.
#alias integer_global_export='export -i'

# void float_global_export(string variable_name)
#
# Globally declare a float exported to the calling shell.
#alias float_global_export='export -F'

# void list_global_export(list variable_name)
#
# Globally declare a list exported to the calling shell.
#alias list_global_export='export -a'

# void map_global_export(map variable_name)
#
# Globally declare a map exported to the calling shell.
#alias map_global_export='typeset -Agx'   # "export -A" oddly fails with error;
                                          # "export -a" succeeds, however (!?!)
