#!/usr/bin/env zsh
# ====================[ config                             ]====================
#
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2012 by Cecil Curry.
# See "COPYING" for additional details.
#
# --------------------( SYNOPSIS                           )--------------------
# Source the current user's Zeshy configuration files.

#FIXME: This snippet used to reside in "if_config/posix" until I found it
#sufficiently embarrassing. Frankly, we won't be implementing any functionality
#using this anytime soon. Nonetheless, store it here for the moment:
# ....................{ PREFERRED                          }....................
# Preferred terminal multiplexer. If commented, Zeshy selects the first such
# multiplexer installed on the current machine, if any.
#ZESHY_TERMINAL_MULTIPLEXER='tmux'
#ZESHY_TERMINAL_MULTIPLEXER='screen'
#ZESHY_TERMINAL_MULTIPLEXER='dtach'
#FIXME: This doesn't... seem quite right. Shouldn't this be uncommented. But,
#again, it's clearly incorrect. Another half-implemented feature, eh?
#ZESHY_TERMINAL_MULTIPLEXER="ZESHY_TERMINAL_MULTIPLEXER$(get_pathable_path_first tmux screen dtach)"

# ....................{ GLOBALS                            }....................
# Define globals subsequently expanded by Zeshy's user configuration files.

set_global_documentation ZESHY_BOOLEAN_TRUE '
boolean ZESHY_BOOLEAN_TRUE

An arbitrary non-empty string signifying a boolean true value. Since zsh
currently supports no boolean type, Zeshy emulates such type with strings.
'
set_global_documentation ZESHY_BOOLEAN_FALSE '
boolean ZESHY_BOOLEAN_FALSE

An arbitrary non-empty string signifying a boolean false value. Since zsh
currently supports no boolean type, Zeshy emulates such type with strings.
'
export ZESHY_BOOLEAN_TRUE=true ZESHY_BOOLEAN_FALSE=

# ....................{ ALIASES ~ variable                 }....................
# Zeshy's user configuration files only export globals. While such files can
# declare locals and non-exported globals via traditional zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Defer defining further aliases and documentation for
# these specific aliases to the main Zeshy codebase.
alias\
    string_global_export='export'\
    boolean_global_export=string_global_export\
    character_global_export=string_global_export\
    integer_global_export='export -i'\
    float_global_export='export -F'\
    list_global_export='export -a'\
    list_set_global_export='export -Ua'\

# "export -A" fails with error; "export -a", however, succeeds. *massive shrug*
alias map_global_export='typeset -Agx'

# ....................{ LOADERS                            }....................
set_function_documentation source_zeshy_configuration '
void source_zeshy_configuration(void)

Source all configuration files in Zeshy''s user configuration directory specific
to the current shell, creating such directory if needed. Such files include:

* All plain files in such directory.
* If the current shell is interactive, all plain files in subdirectory
  "if_shell_interactive" of such directory.
'
function source_zeshy_configuration() {
    # Validate sanity. Unless loading Zeshy's user directory and Zeshy's user
    # configuration directory exists, return silently.
    (( # == 0 )) || die 'expected no arguments'
    [[ -n "${ZESHY_DOT_DIR}" && -d "${ZESHY_DOT_CONFIG_DIR}" ]] || return 0

    # List of all scripts in such directory applicable to the current shell,
    # Dismantled, this is:
    #
    # * "*(-.)", matching all plain files after resolving symbolic links.
    local -a config_filenames; config_filenames=(
        "${ZESHY_DOT_CONFIG_DIR}/"*(-.) )
    [[ -o interactive ]] && config_filenames+=(
        "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

    # If at least one such script exists, source such scripts; else, avoid
    # calling source_zeshy_script() with no arguments throwing an exception.
    (( ${#config_filenames} )) &&
        for config_filename ("${config_filenames[@]}") {
            source -- "${config_filename}"
        }
}

# ....................{ MAIN                               }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#Apallingly, failing to call the function defining alias
#is_zeshy_verbose_and<> at the topmost level before calling functions
#expanding such alias below results in such alias temporarily reverting to its
#default definition only in such functions. (This is insanity, zsh.)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
source_zeshy_configuration

# --------------------( WASTELANDS                         )--------------------
#FUXME: Shift elsewhere, per lengthy discussion in "digest". Honestly, why don't
#we just rename this component to "config" and shift the autoload_zsh_modules()
#*INTO THE MAIN ZESHY CODEBASE*, *PREPENDED* (emphasis on prepended) to
#startup_zeshy(). We *NEVER* call any such module functions here at the topmost
#level -- and even if we did, we'd just replace such implicit autoload with an
#explicit load of such module. Faster, simpler. Bam! :)
# after defining aliases
# required by such files. For efficiency, defer defining all other aliases to
# Zeshy startup in the proper Zeshy codebase and hence compilation into the
# Zeshy digest file. Redefine aliases defined below with such other aliases,
# guaranteeing that:
#
# * Zeshy records all aliases defined below in global list ${ZESHY_ALIAS_NAMES},
#   to be subsequently undefined if recompiling Zeshy in the current shell or a
#   child of the current shell. (See "compile" for gruesome details.)
# * Zeshy retrieves documentation for all aliases defined below in the same
#   manner as such other aliases. (See "help" for miserable details.)#
    # This matches all basenames of immediate files of directories in the function
    # path. (Since this is also the set of all autoloadable function names,
    # autoloading such basenames autoloads all autoloadable functions.) Oh!
#       print 'enabling debugging'
#       alias is_zeshy_verbose_and='true &&'
    # * "/*", each immediate file and subdirectory of such directory.
    # * "N", ignoring non-extant files and subdirectories.
# ....................{ CONFIGURERS ~ main                 }....................
#   for autoloadable_function_name in ${^fpath}/*(N.:t); do
#FUXME: O.K.; because of this, it would seem prudent to split this component
#into two new components "config" and "digest": the former defining the above
#config-specific aliases, functions, and globals; the latter defining all
#remaining objects declared in this component. While I'm somewhat loathe to
#introduce yet another component into startup logic, the sheer inanity of this
#behavior suggests we could benefit from doing so. After all, we must admit
#that digest behavior is wholly separate from config file behavior.
#FUXME: If splitting as described, digest behavior could actually be readily
#merged into existing component "autoload". In such case, it could make sense
#to do the following, in which case no actual split need take case *WHICH IS
#ABSOLUTELY GREAT*:
#
#* Shift all digest behavior below to "autoload."
#* Shift all zsh module-specific behavior in "autoload" here.
#* Rename "autoload" to "digest" to better reflect its role.
#
#And that's it. *NO NEW TOPMOST COMPONENTS REQUIRED*, just a slight shuffling
#of existing functionality for improved understandability.
#FUXME: Yes. Make it so, I should think.

    #FUXME: Many of the functions this function calls redundantly test
    #"[[ -n "${ZESHY_DOT_DIR}" ]]" as well. Eliminate that.
#   [[ -n "${ZESHY_DOT_DIR}" ]] || return 0
    # Source Zeshy's user configuration files here, as such files define global
    # ${ZESHY_IS_DEBUGGING} tested by functions called immediately below.
#   setup_zeshy_configuration
#   which is_zeshy_verbose_and
#   is_zeshy_verbose_and print 'ok'

#FUXME: If splitting as described, rename the above function to source_zeshy_configuration(),
#which is really a much more sensible name in any case.
#FUXME: Eliminate.
#set_function_documentation setup_zeshy_digest_uptodate '
#void setup_zeshy_digest_uptodate(void)
#
#Assuming Zeshy''s user digest file to be up-to-date, implement placeholders for
#aliases and functions required only for compiling an outdated digest file.
#'
#function setup_zeshy_digest_uptodate() {
#    # Validate sanity.
#    (( # == 0 )) || die 'expected no arguments'
#
#    # Implement placeholders with zsh builtin ":" (i.e., noop).
#    alias document_alias=':'
#    alias document_function=':'
#    alias document_global=':'
#}

#FUXME: O.K.; start using is_zeshy_verbose_and<> everywhere. Yum!

#Parse the passed documentation, associating the global name prefixing such
#documentation with such documentation and globally exporting such global as the
#Zeshy-specific type prefixing such documentation. Expand this alias only before
#compiling Zeshy''s user digest file.
#FUXME: Use is_zeshy_verbose_and<> instead. This requires we shift such
    #code to the very bottom of this component, but it makes everything nice and
    #orthogonal. So, go-go-go!
    #FUXME: This isn't right. Such configuration defines ${ZESHY_IS_DEBUGGING},
    #used *ABOVE*. Clearly, config files should be sourced *BEFORE* testing the
    #digest file, yes?

#FUXME: For both efficiency and readability, define a new alias resembling:
#
#  alias inquisitively='[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&'    # or perhaps...
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "if_zeshy_debugging" or
#"is_zeshy_verbose_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUGGING} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_verbose_and='true ||'
#
#Brilliant! This reduces such test to a (hopefully) maximally fast no-op while
#ensuring it evaluates to true and hence does not throw exceptions.
#FUXME: After defining such alias, fixup all current references to
#${ZESHY_IS_DEBUGGING} - particularly at the top level.
    # Replacing all prior instances of '[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&' in
    # the Zeshy codebase with 'is_zeshy_verbose_and'
    #
    # If such configuration enables Zeshy debugging, expand such alias to the
    # empty string, thus unconditionally running the passed command.
#  alias investigatively='[[ -n "${ZESHY_IS_DEBUGGING}" ]] &&'
#
#I'll admit neither adjective to be the best, but "debuggedly" simply doesn't
#make sense. That said, we could also contemplate "if_zeshy_debugging" or
#"is_zeshy_verbose_and"... Yes, the latter seems quite sensible, in fact. So,
#where does the "efficiency" part come in? Pretty simple: we'd like to
#effectively "compile away" all such statements under release builds: namely, if
#${ZESHY_IS_DEBUGGING} is false *AFTER* sourcing user config files. In such
#case, we can simply re-alias as follows:
#
#  alias is_zeshy_verbose_and='true ||'

#       say 'digest outdated!'
#   print "ZESHY_DOT_DIGEST_FILE_IS_OUTDATED: ${ZESHY_DOT_DIGEST_FILE_IS_OUTDATED}"
# non-zero only if such file was outdated at shell startup.
    #FUXME: Not quite right. We need to set
    #ZESHY_DOT_DIGEST_FILE_DEPENDENCY_NEWEST_MODIFICATION_TIME to the current
    #time. Now how do we do that, again...?
#* The main user-specific Zeshy configuration file. This file contains theme
#  settings, which when edited require recompiling theme autoloads.
#* The main system-wide command directories (e.g., "/bin", "/usr/bin").
#  Installing or uninstalling commands requires recompiling command autoloads.

#           if [[ "${function_name}" == *'[OR]'* ]]; then
#FUXME: Shift is_zeshy_digest_outdated() here and cache the result into a global
#variable, as subsequent components will also need reference such result. Shift
#document_function() here as well. If Zeshy's digest file is outdated, define
#document_function() and document_global() as below (i.e., nest such function
#and alias definitions in a code or function block run only if outdated);
#otherwise, define both document_function() and document_global() to be aliases
#expanding to ":". Genius, no? This should ensure we incur no measurable
#overhead when sourcing configuration files and *NOT* recompiling such digest.

#Processes assigned to class 3 are idle-only processes scheduled when no other
#process performs I/O. Class 3 processes are likely to suffer scheduling
#starvation and hence appropriate only for background daemons.
#FUXME: Document all such globals.
#document_global '
#list ZESHY_IONICE_CLASS_HIGH
#
#"ionice"-specific highest and lowest priority pairs consisting of class and
#ioniceness for I/O scheduling of processes. Processes assigned to class 3
#signify "idle-only" processes to be scheduled only when no other process
#performs I/O. Since such processes are likely to suffer scheduling starvation,
#omit class 3 from consideration.
#; assigning class 2 to the default lowest priority class improves
#process responsiveness.
#'

#       '/bin' '/sbin' '/usr/bin' '/usr/sbin' "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
    #FUXME: We may need to explicitly unset ${documentation__dg} *ONCE* after
    #sourcing all configuration files. We'll know whether we need to do so based on
    #whether or not the current environment has become polluted with such variable
    #after entering a new Zeshy shell.

#FUXME: Should probably be pushed into "main". Ideally, this could allow us to
#obsolete the lower-level set_*_documentation() family of functions in favor of
#the higher-level document_*() family of functions. It will increase the size of
#"main", but probably not by quite as much as thought -- after all, we'd also be
#removing a sizable block of existing functionality: set_*_documentation().
#Naturally, this requires moving document_*() and all conditional logic defining
#such functions from here to "main".
#FUXME: Since we'd like to declare such functionality as "early" as possible, we
#should probably declare "set -e" at the top of "main" and then inject such code
#immediately after "setopt" calls (i.e., before defining die(), say(), and
#friends). This implies we should undo "set -e" immediately prior to defining
#die(). (I recall we do something similar; just double-check us up.)
#FUXME: Actually, the current method isn't terribly inappropriate. Steady as she
#goes, folks!

        # Nonetheless, reuse the same glob expression for simplicity.
        # Hence, this glob expression matches more strictly than the function
        # glob expression above. Dismantled, this is:

#FUXME: Hopefully superfluous, after implementing document_global() properly.
#Excise after excising from all config files.
    # If Zeshy's user digest file is up-to-date, define placeholders for
    # runnables required only for compiling an outdated digest file.

    # * Loading Zeshy's user directory and
#   [[ -n "${ZESHY_DOT_DIR}" &&\
#FUXME: This looks *EXTREMELY* heavyweight. I'm concerned about expanding such
#alias as much as we inevitably will be. Given that, I'm currently inclined to
#reconsider aliasing document_global=':' when the digest file is not outdated.
#This requires we retain variable declarations, which is probably a good idea.
#   [[ -n "${(k)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[(r)${match[1]}]-}" ]] ||
    #FUXME: Insufficient. document_global() needs to *AT LEAST* declare such
    #global based on the passed help string.
    #FUXME: In reflection, declaring such global is basically the entirety of
    #document_global(). We'd might as well just define the whole thing as is.
#   alias document_global=':'

    # Parse variable helpstring here. Since the first line is something like:
    #
    #     string ZESHY_ZSTRANGE
    #
    #     I''m a strange global. (But here I am.)
    #
    # ...this implementation can parse that line and produce the corresponding
    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
    # implementation uses a dictionary lookup on the first shell word of such
    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
    # See initial definition above.

#: e.g.,
  # Declare ${THIS_IS_A_MAP} to be a global map.
# >>> ${(z)ZESHY_GLOBAL_TYPE_TO_DECLARATOR[map]} THIS_IS_A_MAP
#FUXME: Excise after converting all current configuration file global
#declarations to the aliases below.
#FUXME: Hmm; actually, we'll have to replicate the current document_function()
#function into a new document_global() function defined here. And since we're
#defining that function here, we'd might as well move document_function() from
#"compile" here as well for sanity. Shouldn't be terribly difficult. The tedious
#aspect will be in converting existing configuration files to call such
#function. Well... no time like the present, yes?
#FUXME: Ah; hmm. I note that we *COULD* define:
#alias document_global='
#{
#    # Parse variable helpstring here. Since the first line is something like:
#    #
#    #     string ZESHY_ZSTRANGE
#    #
#    #     I'm a strange global. (But here I am.)
#    #
#    # ...this implementation can parse that line and produce the corresponding
#    # "export ZESHY_ZSTRANGE" line. No problem, yes? Most efficient
#    # implementation uses a dictionary lookup on the first shell word of such
#    # helpstring. Name the dictionary, say, ZESHY_GLOBAL_TYPE_TO_DECLARATOR.
#    # See initial definition above.
#} <<<'
#I am mildly concerned about the efficiency of sourcing configuration files with
#numerous such alias expansions. If efficiency becomes a problem, just
#implement a separate document_global() function. That then leaves us with code
#resembling:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#string_global_export ZESHY_ZSTRANGE='lululululuuuuuu"
#
#The above alternative leaves us with:
#
#document_global '
#string ZESHY_ZSTRANGE
#
#I'm a strange global. (But here I am.)
#'
#ZESHY_ZSTRANGE='lululululuuuuuu"
#
#FUXME: O.K.; so, in either case, we have a document_global() runnable. The
#latter case is more concise and hence preferable, but somewhat less efficient
#due to parsing overhead. Let's see how much it costs us. Simple experiment:
#
#* Temporarily force is_zeshy_digest_outdated() to return_false.
#* Copy all of the existing config files to a new dir under "old/".
#* Migrate existing config files to call document_global().
#* Time startup under both! Hopefully, the overhead isn't hideously noticeable.
#FUXME: The following aliases *SHOULD* already exist under "always/00-setup".
#Ensure this to be the case; then, excise such aliases here.

#       set_global_documentation "${match[2]}" "${documentation}"
# print_function_documentation() to subsequently print such documentation.
#       then set_function_documentation "${match[1]}" "${documentation}"
# ....................{ EXPORTS                            }....................
# Zeshy configuration files declare only global exports. While such files can
# declare locals and non-exported globals with traditional Zsh primitives (e.g.,
# "typedef -Fr"), avoid promoting such bad behavior by aliasing human-readable
# names to such primitives. Delay defining all remaining Zeshy aliases to the
# main Zeshy codebase.

#is_zeshy_digest_outdated() returning true. Yes:
#this is somewhat hackier than we prefer, but the alternatives are uglier.
#   local -a path_plus_zeshy
#   path_plus_zeshy=( "${path[@]}" "${ZESHY_DOT_CONFIG_DIR}/zeshy" )
#   local path_plus_zeshy_glob="${(j~|~)${(q@)path_plus_zeshy}}"
#   zeshy_dependency_mtimes+="$(zstat +mtime "${path_plus_zeshy_glob}")"

    #FUXME: Definitely not right. We absolutely want to do this *AFTER*
    #"always/shell/profile" establishes the global list "path"; then, replace
    #the awkwardly hard-coded paths below with the following:
    #
    #    for dependency_pathname ("${path[@]}" "${ZESHY_DOT_CONFIG_DIR}"/{,*}) {
    #
    #Concise; awesome; and exactly what's needed. We'll probably just want to
    #extricate the setting of the ${PATH} currently performed by
    #"always/shell/profile" to somewhere directly under "src/" -- perhaps this
    #component? There's really no reason to perform such logic *ONLY* under a
    #login shell; ideally, the ${PATH} should always be "fixed up" on Zeshy
    #startup. After all, either the user or a script could destroy the ${PATH}
    #after login, in which case we really wouldn't want to trust its current
    #setting. So, fix it up to guarantee sane behavior.
    #FUXME: We can substantially optimize this, I believe. Cease appending
    #modification times to list ${dependency_mtimes}; instead, perform a single
    #call to $(zstat +mtime ...) with a single argument selecting the oldest
    #such path that exists:
    #
    # zstat +mtime (if_shell_interactive|posix)(e:'[[ -e $REPLY ]]':om[1])
    #
    #That works at the shell. Given that, how about a generalization:
    #
    # zstat +mtime (~dependency_pathname_glob)(e:'[[ -e $REPLY ]]':om[1])

#
    # Dismantled, this is:
    #
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
#   local dependency_pathname_glob
#   : ${dependency_pathname_glob::=\'${^path}\'}
#   dependency_pathname_glob="${path}|${ZESHY_DOT_CONFIG_DIR}/zeshy"
#   ="${path}|${ZESHY_DOT_CONFIG_DIR}/zeshy"

    #FUXME: Mostly right. Note that for safe generality, however, reserved glob
    #characters in pathnames should be prefixed by "\" to prevent usage as glob
    #characters. Fine for now, but of some importance later.
#   local -a path_quoted
#   path_quoted=( \'${^path}\' "${ZESHY_DOT_CONFIG_DIR}/zeshy" )
#   local path_quoted_glob="${(j:|:)path_quoted}"

    #FUXME: Rename "ZESHY_IS_DEBUGGING" to "ZESHY_IS_IN_DEVELOPMENT". :)
    # * "${ZESHY_DOT_CONFIG_DIR}"/{,*}, expanding to the current user's Zeshy
    #   configuration dirname and all filenames under such dirname, thus
    #   reporting Zeshy to be outdated on adding, deleting, or editing a Zeshy
    #   configuration file.
    # If either or configuration directory do not exist or
    # the latter exists but is empty, mark such file "outdated."
    # Ensure the current user's Zeshy configuration directory and all non-extant
    # parents of such directory exist.
#   command mkdir -p -- "${ZESHY_DOT_CONFIG_DIR}"

    # specifically including:
    #
    # * All plain files in such directory.
    # * If the current shell is interactive, all plain files in subdirectory
    #   "if_shell_interactive" of such directory.
    #
    # If the current shell is interactive and such directory contains a
    # subdirectory "if_shell_interactive" containing at least one Zeshy script,
    # source such scripts as above.
#   config_filenames=( "${ZESHY_DOT_CONFIG_DIR}/if_shell_interactive/"*(-.) )

# Booleans are false if set to the empty string and otherwise true.
#
# For simplicity, disable or enable booleans by commenting or uncommenting the
# lines on which they appear (e.g., prefixing such lines with "#" or deleting
# such prefix).

    # subsequent logic
    # sources the default versions of such files.

#FUXME: All of the magic constants defined in "global" should be declared
#frozen, perhaps suggesting new "string_global_constant",
#"boolean_global_constant", and so on types in "alias".

#FUXME: I'm not terribly fond of enabling booleans by setting them to 1. Avoid
#such magic by defining the following magic in "global":
#
#string_global_constant ZESHY_BOOLEAN_TRUE=1 ZESHY_BOOLEAN_FALSE=''
#
#Then use below: e.g.,
#ZESHY_IS_DEBUGGING=${ZESHY_BOOLEAN_TRUE}

# void string_global_export(string variable_name)
#
# Globally declare a string exported to the calling shell.
#alias string_global_export='export'

# void boolean_global_export(string variable_name)
#
# Globally declare a boolean exported to the calling shell.
#alias boolean_global_export='export'

# void integer_global_export(string variable_name)
#
# Globally declare an integer exported to the calling shell.
#alias integer_global_export='export -i'

# void float_global_export(string variable_name)
#
# Globally declare a float exported to the calling shell.
#alias float_global_export='export -F'

# void list_global_export(list variable_name)
#
# Globally declare a list exported to the calling shell.
#alias list_global_export='export -a'

# void map_global_export(map variable_name)
#
# Globally declare a map exported to the calling shell.
#alias map_global_export='typeset -Agx'   # "export -A" oddly fails with error;
                                          # "export -a" succeeds, however (!?!)
