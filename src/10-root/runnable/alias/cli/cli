#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Define `zeshy`-specific *CLI aliases* (i.e., aliases active only when expanded
directly by a user at the command line of an interactive shell). When expanded
from any other context (e.g., shell functions or scripts), CLI aliases either:

* If the name of such alias is an existing pathable, expand to such name.
* Else, throw an exception.

== Motivation ==

Startup shell scripts and scripting frameworks often install the canonical
alias `ll`, listing paths in long format by expanding to `ls -l`: e.g.,

.Conventional Alias
==========================================
[source]
------------------------------------------
# Alias producing greppable and hence shell script-friendly output.
alias ll="ls -l"
------------------------------------------
==========================================

While convenient, such alias suffers more than a few drawbacks:

* Shell scripts calling `ll` behave as expected only if such alias retains a
  shell script-friendly expansion. But such alias is readily editable into a
  shell script-unfriendly expansion, suggesting no such guarantees: e.g.,
+
.Conventional Alias Non-greppability
==========================================
[source]
------------------------------------------
# Alias producing non-greppable and hence shell script-unfriendly output.
alias ll="ls -l --color=always --human-readable"
------------------------------------------
==========================================
* Shell scripts calling `ll` rather than `ls` behave as expected only under
  the current shell environment and hence are inherently non-portable.
  Different users and systems install different startup shell scripts and
  scripting frameworks, suggesting no such guarantees: e.g.,
+
.Conventional Alias Non-portability
==========================================
[source]
------------------------------------------
# Alias expanding to a non-"ls" command, producing unexpected output.
alias ll="long_long_integer"
------------------------------------------
==========================================
* Shell scripts defining a function ll() behave as expected only _not_ under
  the current shell environment. Since `zsh` assigns aliases higher precedence
  than functions, an externally defined alias `ll` supercedes any internally
  defined function ll(): e.g.,
+
.Conventional Alias Unreliability
==========================================
[source]
------------------------------------------
# Function overriden by the defined alias "ll".
function ll() {
    print 'If the caller defined an alias "ll", you'll never see this.'
}
------------------------------------------
==========================================

== Solution ==

CLI aliases solve such issues. Like the customary `zsh` aliases they supplant,
CLI aliases are declared and defined with `=`-delimited syntax
`${alias_type} ${alias_name}=${alias_expansion}`, where
`${alias_name}` and `${alias_expansion}` are such alias' name and expansion and
`${alias_type}` is either:

* `alias_cli_substitution`, signifying such alias to shadow an existing `zsh`
  builtin or external *pathable* (i.e., command in the current user's ${PATH}):
  e.g.,
+
.CLI Substitution Alias
==========================================
[source]
------------------------------------------
# Shadow "ls" with an alias passing such command useful default options. All
# subsequent attempts to run "ls" at the command line run such command, instead.
alias_cli_substitution ls="ls --all --color=auto --sort=version"
------------------------------------------
==========================================
* `alias_cli_abbreviation`, signifying such alias to abbreviate an existing
  *runnable* (i.e., `zsh` alias, builtin, or function or external pathable):
  e.g.,
+
.CLI Abbreviation Alias
==========================================
[source]
------------------------------------------
# Abbreviate "ls" to "l", passing such command useful default options. This does
# not effect "ls" itself. Only running "l" passes the desired options.
alias_cli_abbreviation l="ls --author --classify --escape --ignore-backups"
------------------------------------------
==========================================
* `alias_cli`, signifying such alias to neither substitute or abbreviate an
  existing runnable. Note that most CLI aliases substitute or abbreviate such a
  runnable, however. Consider using the high-level types
  `alias_cli_substitution` and `alias_cli_abbreviation` rather than this low-
  level (and rather unsafe) type: e.g.,
+
.CLI Alias
==========================================
[source]
------------------------------------------
# Alias "ls" to "lsl", passing such command useful default options. Again, this
# does not effect "ls" itself. Only running "lsl" passes the desired options.
alias_cli lsl="ls --full-time --group-directories-first --human-readable"
------------------------------------------
==========================================

== Constraints ==

CLI substitution and abbreviation aliases impose additional runtime constraints,
for safety. In general, _all_ CLI aliases should be declared as either
substitutions or abbreviations.

If the caller attempts to declare a CLI substitution alias whose name is _not_
an existing `zsh` builtin or pathable, an exception is thrown. Such aliases only
shadow existing commands of the same name, preventing aliases inapplicable to
the current system or user from being declared.

If the caller attempts to declare a CLI abbreviation alias whose name _is_ an
existing pathable, an exception is thrown. Such aliases never shadow existing
commands, thus preventing core system and user commands from being ``occluded''
by unrelated (and usually incidental) aliases.

If the caller attempts to call a CLI substitution alias from any context other
than the command line (e.g., from an alias, function, or script), the existing
command of the same name is run instead. Such aliases only shadow existing
commands when called from the command line.

If the caller attempts to call a CLI abbreviation alias from any context other
than the command line, an exception is thrown.

== Abbreviation Embeddings ==

CLI substitution and abbreviation aliases (but not low-level aliases declared by
directly calling alias_cli()) additionally support *abbreviation embeddings* in
alias names themselves. The concatenation of all `{`- and `}`-delimited
substrings (excluding such delimiters) in an alias name provides the *preferred
abbreviation name* of such alias (e.g., `l` for
`alias_cli_substitution {l}s="ls --dereference --inode --si`, `lp` for
`alias_cli_abbreviation {l}ist{p}ath="ls --dereference --inode --si`).

Since such name may already be claimed by an existing runnable (e.g., a command
`l` in the current user's ${PATH}), such name only signifies a preference. To
accommodate real-world complexities, the name assigned to such abbreviation is
algorithmically determined in a system- and user-specific manner. Specifically:

* If the preferred abbreviation name is not already that of an existing
  runnable, such abbrevation is assigned such name.
* Else if the leftmost `}` in such name is not the last character of such name,
  such `}` is shifted right by one character and control is returned to the
  prior conditional repeated.
* Else, all available abbreviation names are already existing runnables, in
  which case _no_ CLI abbreviation alias can be declared. If such name was
  embedded in the name of a:
** CLI substitution alias, a nonfatal warning is printed and such substitution
   otherwise declared as is.
** CLI abbreviation alias, a fatal exception is thrown.

Abbreviation embeddings dramatically improve the portability of CLI aliases.
Ideally, all CLI aliases should be either substitutions or abbreviations
embedding at least one `{`- and `}`-delimited substring.

=== CLI Substitution Alias Substitution ===

The concatenation of all `{`- and `}`-delimited substrings excluding such
delimiters in a CLI substitution alias name specifies the *preferred name* for
a corresponding CLI abbreviation alias, defined to expand to the same expansion
as such substitution. If such name is claimed by an existing runnable,
alias_cli_substitution() iteratively lengthens such name until finding a name
_not_ already claimed by an existing runnable: e.g.,

.CLI Substitution Alias Substitution
==========================================
[source]
------------------------------------------
# A CLI substitution alias whose name embeds "{"- and "}"-delimited substrings.
# alias_cli_substitution() iteratively finds the first name in the following
# list *NOT* already an existing runnable: "md", "mkd", and "mkdi".
alias_cli_substitution {m}k{d}ir="mkdir --parents --verbose --"

# If no existing runnable is named "md", the prior statement expands to:
alias_cli_substitution mkdir="mkdir --parents --verbose --"
alias_cli_abbreviation md="mkdir"

# Else if no existing runnable is named "mkd", such statement is equivalent to
# alias_cli_substitution {mkd}ir="mkdir --parents --verbose --", expanding to:
alias_cli_substitution mkdir="mkdir --parents --verbose --"
alias_cli_abbreviation mkd="mkdir"

# Else if no existing runnable is named "mkdi", such statement is equivalent to
# alias_cli_substitution {mkdi}r="mkdir --parents --verbose --", expanding to:
alias_cli_substitution mkdir="mkdir --parents --verbose --"
alias_cli_abbreviation mkdi="mkdir"

# Else, "md", "mkd", and "mkdi" are all existing runnables, in which case a
# warning is printed and no CLI abbreviation alias is implicitly defined. Such
# statement then reduces to the following by simply discarding all "{" and "}":
alias_cli_substitution mkdir="mkdir --parents --verbose --"
------------------------------------------
==========================================

=== CLI Abbreviation Alias Abbreviation ===

The concatenation of all `{`- and `}`-delimited substrings excluding such
delimiters in a CLI abbreviation alias name specifies the *preferred name* for
such alias. If such name is claimed by an existing runnable,
alias_cli_abbreviation() iteratively lengthens such name until finding a name
_not_ already claimed by an existing runnable: e.g.,

.CLI Abbreviation Alias Abbreviation
==========================================
[source]
------------------------------------------
# A CLI abbreviation alias whose name embeds "{"- and "}"-delimited substrings.
# alias_cli_abbreviation() iteratively finds the first name in the following
# list *NOT* claimed by an existing runnable: "rd", "rmd", and "rmdi".
alias_cli_abbreviation {r}m{d}i="rmdir --parents --verbose --"

# If no existing runnable is named "rd", the prior statement reduces to:
alias_cli_abbreviation rd="rmdir --parents --verbose --"

# Else if no existing runnable is named "rmd", such statement is equivalent to
# alias_cli_abbreviation {rmd}i="rmdir --parents --verbose --", reducing to:
alias_cli_abbreviation rmd="rmdir --parents --verbose --"

# Else if no existing runnable is named "rmdi", such statement is equivalent to:
# alias_cli_abbreviation {rmdi}="rmdir --parents --verbose --", reducing to:
alias_cli_abbreviation rmdi="rmdir --parents --verbose --"

# Else, "rd", "rmd", and "rmdi" are all existing runnables, in which case an
# exception is thrown.
------------------------------------------
==========================================
/---

# ....................{ GLOBALS                            }....................
:map_global ZESHY_ALIAS_CLI_NAME_TO_EXPANSION_PASSED <<'/---'
Map from CLI alias name to the expansion originally specified for such alias.
Since CLI aliases are high-level `zeshy` abstractions implemented as low-level
`zsh` aliases, the expansions of the former and latter substantially differ.
In particular, the actual `zsh` alias expansion wraps the passed CLI alias
expansion in `zsh` code conditionally testing whether such alias is being
expanded directly from the command-line or not and responding appropriately.
/---

:map_global ZESHY_ALIAS_CLI_NAME_TO_NAME_PASSED <<'/---'
Map from CLI alias name to the name originally specified for such alias. While
the latter may contain `{` and `}` delimiters signifying the preferred CLI
abbreviation alias name for such alias, the latter never contains such
delimiters.
/---

:map_global ZESHY_ALIAS_CLI_NAME_TO_TYPE <<'/---'
Map from CLI alias name to type. Recognized types include:

* `abbreviation`, set by alias_cli_abbreviation().
* `substitution`, set by alias_cli_substitution().
* `untyped`, set by alias_cli() when such function is _not_ called by either
  alias_cli_abbreviation() or alias_cli_substitution().
/---

# ....................{ PRINTERS                           }....................
declare_function_with_stdin <<'/---'
string print_aliases_cli()

Print a human-readable list of all CLI aliases and corresponding expansions.
/---
function print_aliases_cli() {
    # Validate sanity.
    die_if_args
    string quotes alias_declarator
    list alias_names

    # List of all CLI alias names sans "{" and "}" delimiters for lexical
    # sorting purposes. While the keys of
    # ${ZESHY_ALIAS_CLI_NAME_TO_EXPANSION_PASSED} also list all CLI alias names,
    # such names include "{" and "}" delimiters conflicting with sane sorting.
    set_list_to_map_keys alias_names ZESHY_ALIAS_CLI_NAME_TO_TYPE

    # Colorized double-quotes to be expanded below.
    quotes="${ZESHY_STYLE_TO_COLOR[print_aliases_cli.quotes]-}\""

    {
        # Prefix such list with a header.
        print_message_heading 'CLI Aliases'

        # Print all CLI aliases in lexicographic order.
        for_list_items_sorted_lexically_ascending alias_names alias_name '
            # Convert such CLI alias type to a human-readable label.
            case "${ZESHY_ALIAS_CLI_NAME_TO_TYPE}" {
            abbreviation) alias_declarator="${ZESHY_STYLE_TO_COLOR[print_aliases_cli.type_abbreviation]-}alias_cli_abbreviation";;
            substitution) alias_declarator="${ZESHY_STYLE_TO_COLOR[print_aliases_cli.type_substitution]-}alias_cli_substitution";;
            *) alias_declarator="${ZESHY_STYLE_TO_COLOR[print_aliases_cli.type_untyped]-}alias_cli";;
            }

            # Print such alias.
            :string.output "${alias_type} ${ZESHY_STYLE_TO_COLOR[print_aliases_cli.name]-}${alias_name}${ZESHY_STYLE_TO_COLOR[print_aliases_cli.equals]-}=${quotes}${ZESHY_STYLE_TO_COLOR[print_aliases_cli.expansion]-}${ZESHY_ALIAS_CLI_NAME_TO_EXPANSION_PASSED[${alias_name}]-}${quotes}"
        '
    } | page_stdin
}

# ....................{ PRECOMPILERS                       }....................
# Define interactive aliases at digest recompilation rather than zeshy startup
# time, for both efficiency and sanity.
:run_hook_on_zeshy_precompile precompile_zeshy_aliases_cli

declare_function_with_stdin <<'/---'
void precompile_zeshy_aliases_cli()

Define interactive aliases specified by `zeshy`\'s user configuration files.
/---
function precompile_zeshy_aliases_cli() {
    # Validate sanity.
    die_if_args

    #FIXME: Shift to calling the higher-level declarers
    #declare_alias_cli_abbreviation() and declare_alias_cli_substitution()
    #rather than the lower-level declarers called below. Note this declares all
    #CLI aliases under the current parcel -- which seems quite sensible, really.
    #We'll need to supply sensible documentation for each type of such alias,
    #which certainly seems "doable."

    # Prevent exceptions thrown in "{...}" blocks embedded in iteration below
    # from being treated as unhandled exceptions (and hence immediately printed
    # to standard error) by embedding all such blocks in an external ":try{...}"
    # block. Such block sets a global whose existence is subsequently tested and
    # acknowledged by :die(), avoiding such unhandled exception-specific logic.
    #
    # While the same ends could also be accomplished more simply by converting
    # all "{...}" blocks embedded in iteration below to ":try{...}" blocks,
    # doing so incurs a noticeable performance penalty. Though vital, this is
    # thus only an optimization.
    :try{
        # Define listed abbreviations. To avoid disrupting digest compilation,
        # reduce fatal exceptions to nonfatal warnings (both here and below).
        #
        # For efficiency, prefer the traditional "{...} always {...}" approach to
        # the zeshy-specific ":try{...}:catch{...}:catch" approach here.
        # Since such logic is guaranteed to catch any thrown exception, the
        # former approach gains us nothing despite imposing a significant
        # computational burden.
        for_map_key_value_pairs ZESHY_ALIAS_CLI_ABBREVIATIONS\
            alias_name alias_expansion\
            '{
                alias_cli_abbreviation "${alias_name}" "${alias_expansion}"
            } always {
                if { catch_exception_if_found } {
                    print_warning "$(get_exception_caught_message)"
                }
            }'
    #       print "alias_cli_abbreviation ${alias_name}=${alias_expansion}"

        # Define configured substitutions.
        for_map_key_value_pairs ZESHY_ALIAS_CLI_SUBSTITUTIONS\
            alias_name alias_expansion\
            '{
                alias_cli_substitution "${alias_name}" "${alias_expansion}"
            } always {
                if { catch_exception_if_found } {
                    print_warning "$(get_exception_caught_message)"
                }
            }'

        # Define configured substitutions dependent on existing runnables.
        # Since alias_cli_substitution_if_found() returns failure if such runnable
        # does *NOT* exist, ignore such failure.
        for_map_key_value_pairs ZESHY_ALIAS_CLI_SUBSTITUTIONS_IF_RUNNABLE\
            alias_name alias_expansion\
            '{
                alias_cli_substitution_if_found\
                    "${alias_name}" "${alias_expansion}" or ignore_failure
            } always {
                if { catch_exception_if_found } {
                    print_warning "$(get_exception_caught_message)"
                }
            }'

        # Define configured substitutions dependent on existing runnables and run
        # disowned from their parent shells.
        :string alias_name command_name
        for     alias_name (
            "${ZESHY_CLI_SUBSTITUTION_NAMES_IF_RUNNABLE_RUN_DISOWNED[@]}") {
            {
    #           :string.output "run disowned: ${alias_name}"
                command_name="${alias_name//[\{\}]}"
                if { is_runnable "${command_name}" } {
                    alias_cli_substitution\
                        "${alias_name}" 'run_command_disowned "'${command_name}'"'
                }
            } always {
                if { catch_exception_if_found } {
                    print_warning "$(get_exception_caught_message)"
                }
            }
        }
    }:catch{
    }:catch
}

# --------------------( WASTELANDS                         )--------------------
#List of aliases to be expanded only when run directly from the command line,
#_always_ replacing existing *runnables* (i.e., external commands or `zsh`
#aliases, builtins, or functions) and hence referred to as *CLI substitution
#aliases*. Such aliases are ideal for wrapping conventional runnables with more
#powerful functions (e.g., replacing `ls` with list_path_with_options()).

#List of aliases to be expanded only when run directly from the command line,
#ignoring aliases whose name (sans `{` and `}` delimiters) is _not_ the name of
#an existing *runnable* (i.e., external command or `zsh` alias, builtin, or
#function). See ${ZESHY_ALIAS_CLI_ABBREVIATIONS} for further details.

#existing *runnables* . Aliases abbreviating non-existing
#runnables _or_ replacing rather than abbreviating existing runnables will be
#ignored.

    #FUXME: If the approach below imposes too much inefficiency on zeshy
    #compilation, a simple fix is to revert the current
    #"try {...}:catch{...}:" approach to a traditional
    #"{...} always {...}" approach manually handling such exception. After all,
    #the former gains us nothing in this case, since we are guaranteed to
    #*ALWAYS* catch any thrown exception. For example:
#    '{
#        alias_cli_abbreviation "${alias_name}" "${alias_expansion}"
#    } always {
#        if { catch_exception_if_found } {
#            print_warning "${CAUGHT}"
#        }
#    }'

#    'try {
#        alias_cli_abbreviation "${alias_name}" "${alias_expansion}"
#    } always_catch_exception_as_warning'

#    'try {
#        alias_cli_substitution "${alias_name}" "${alias_expansion}"
#    } always_catch_exception_as_warning'
#
#    # Define configured substitutions dependent on existing runnables.
#    # Since alias_cli_substitution_if_found() returns failure if such runnable
#    # does *NOT* exist, ignore such failure.
#    for_map_key_value_pairs ZESHY_ALIAS_CLI_SUBSTITUTIONS_IF_RUNNABLE\
#        alias_name alias_expansion\
#    'try {
#        alias_cli_substitution_if_found "${alias_name}" "${alias_expansion}" or
#            ignore_failure
#    } always_catch_exception_as_warning'
#
#    # Define configured substitutions dependent on existing runnables and run
#    # disowned from their parent shells.
#    string alias_name command_name
#    for    alias_name (
#        "${ZESHY_CLI_SUBSTITUTION_NAMES_IF_RUNNABLE_RUN_DISOWNED[@]}") {
#        try {
##           :string.output "run disowned: ${alias_name}"
#            command_name="${alias_name//[\{\}]}"
#            if { is_runnable "${command_name}" } {
#                alias_cli_substitution\
#                    "${alias_name}" 'run_command_disowned "'${command_name}'"'
#            }
#        } always_catch_exception_as_warning
##        "${ZESHY_ALIAS_CLI_ABBREVIATIONS[@]}"
##        "${ZESHY_ALIAS_CLI_SUBSTITUTIONS[@]}"
##        "${ZESHY_ALIAS_CLI_UNTYPED_NAMES[@]}"
##    )

#FUXME: Actually, this *CAN* and should be implemented as a process
#substitution-driven alias: e.g.,
#
#    :alias_command.define "${alias_name}" '$(
#        if { is_context_cli_command_substitution } {
#            :string.output "'${alias_expansion}'"
#        } else {
#            :string.output "'${alias_name}'"
#        }
#    )'
#
#I've verified we do *NOT* need to disable such alias name within such
#expansion, unlike the equivalent function-based implementation. The only
#downside, of course, is in the forking of a subshell. But, honestly, the
#advantages appear to substantially outweigh this single disadvantage.
#FUXME: We'll need a new alias is_context_cli_command_substitution(). Shouldn't
#be *TOO* terribly hard, eh? I've just confirmed this to test for context
#"toplevel:cmdsubst". Go-go!
#FUXME: Actually, we (probably) need to retain the current function-based
#implementation. Why? Well, I'm unconvinced we can pass arguments to an alias
#defined in such way. We certainly can't use a herestring approach. This
#implies we'll need to add additional aliases to
#"00-declare/05-alias/zsh/context" for handling functions called from the CLI.
#FUXME: I'm fairly certain that there's no justifiable reason to continue
#internally implementing CLI aliases as functions. No, really. They should just
#be aliases expanding to code embedded in a "{"- and "}"-delimited block: e.g.,
#
#   alias ${alias_name}:catch"{${alias_expansion}}"
#
#This ensures that such aliases can be piped to. (Though, to be fair, can't
#"if" conditionals also be piped to? I'm fairly sure. In which case, no need
#even for the "{" and "}" delimiters. Erhm; nope! I've verified that we do
#indeed need to use such delimiters. Document this fact, naturally.)
#What's particularly nice about this approach is that it reduces the test for
#CLI-ness to simply:
#
#   is -o interactive and "${ZSH_EVAL_CONTEXT}" == 'toplevel' si
#
#That's it. Sweet, no? (I've double-checked this manually. Yup; it works.)
#
#It also allows functions to be aliased with CLI substitutions, which is *MUCH*
#more interesting and important than allowing aliases to be aliased with CLI
#substitutions (which really doesn't make much sense, on the face of it.)


# Assume "cal" but not "cancer" to be an existing pathable, as expected.
#>>> alias_cli_substitution_if_found\
#...     {c}ancer=":string.output Caloric restriction" or true
#>>> c
#zsh: command not found: c
#>>> alias_cli_substitution_if_found {c}al="print Caloric restriction"
#>>> c
#Caloric restriction

#CLI substitution aliases _always_ replace existing runnables and hence differ
#from CLI abbreviation aliases (which _never_ replace existing runnables) and
#normal `zsh` aliases (which _always_ replace existing runnables but never throw
#exceptions, print errors, or return failure if such runnables do not exist). See
#alias_cli() for further details: e.g.,

#Define an interactive abbreviation with the passed `=`-delimited specification.
#Interactive abbreviations are interactive aliases (and hence intended to be
#called only directly from the command line) subject to two additional
#constraints:
#
#== Runnable Replacement ==
#
#Interactive abbreviations _never_ replace existing runnables (i.e., external
#commands or `zsh` aliases, builtins, or functions). If the passed alias name
#duplicates the name of an existing runnable, this function prints a warning
#and silently returns with zero exit status without defining such alias.
#Interactive abbreviations thus differ from both interactive substitutions and
#conventional aliases, which silently replace existing runnables without error:
#e.g.,
#
#.alias_cli_abbreviation() Runnable Replacement
#==========================================
#[source]
#------------------------------------------
## Arguably not the best idea.
#>>> alias_cli_abbreviation ls="print Lysergic acid diethylamide"
#zeshy: interactive abbreviation "ls" already a defined command:
#/bin/ls
#>>> alias_cli_substitution ls="print Lysergic acid diethylamide"
#>>> ls
#Lysergic acid diethylamide
#------------------------------------------
#==========================================
#
#== Calling Conventions ==
#
#Interactive abbreviations _always_ throw exceptions when expanded from non-
#interactive shells or shell scripts: e.g.,
#
#.alias_cli_abbreviation() Calling Conventions
#==========================================
#[source]
#------------------------------------------
#>>> alias_cli_abbreviation ptm="print Thunnus maccoyii"
#>>> ptm
#Thunnus maccoyii
#>>> () { ptm }
#ptm: interactive abbreviation "ptm" cannot be called non-interactively
#ptm: "ptm" failed with exit status 1
#------------------------------------------
#==========================================

#== Runnable Replacement ==
#
#CLI substitution aliases only replace existing runnables. If such name is _not_
#the name of an existing runnable, print a warning to standard error
#and return with zero exit status without defining such alias: e.g.,

#Define an interactive substitution with the passed `=`-delimited specification.
#Interactive substitutions are interactive aliases (and hence intended to be
#called only directly from the command line) subject to one additional
#constraint:

#aliases, which are expandable from both interactive shells and non-interactive
#shell scripts, CLI aliases are expandable from directly at the command line of
#an interactive shell. Attempting to expand interactive aliases from any other
#context calls the unexpanded name of such alias, instead: e.g.,
    # Else, the name and expansion were explicitly passed.
#   } else {
#       alias_name_passed="${1}"
#       alias_expansion_passed="${2}"

        #FUXME: Remove this case; it *REALLY* shouldn't apply.
        # If such alias does not exist but was erroneously detected as existing,
        # throw an exception. This constitutes a fatal bug and shouldn't happen!
#       if is -z "${alias_name_type}" si {
#           :die "${alias_type_readable} \"${alias_name}\" undefined:${ZESHY_ASCII_NEWLINE}$(print_runnable "${alias_name}")"

    #FUXME: Remind me again why we don't simply precede a call to
    #alias_cli_substitution() with an "is_pathable ${alias_name} and" check? Why
    #do we have a discrete function devoted to this admittedly simple task?

#and that command is in the current user's
#${PATH}. If present, `{`- and `}`-delimited substrings define the alias name.
#
#For example, the single line `{cali}bre` listed below produces aliases `cali`
#and `calibre` running Calibre disowned when the current shell is interactive
#and the current ${PATH} contains `calibre` (i.e., when Calibre is installed).
#`zeshy` effectively converts this single line to a block of code resembling:
#
#Since closing a shell should implicitly close all commands started under such
#shell excluding GUI and headless daemon commands, consider only listing the
#latter commands here.

#Concatenating all `{`- and `}`-delimited substrings in the substring left of the
#`=` in such an alias denotes a preferred alias name. If not an existing runnable
#name, `zeshy` promptly assigns this alias this alias name; otherwise, `zeshy`
#iteratively shifts the leftmost `}` in such name to the right one character and
#tries again until finding a name not already an existing runnable or shifting
#the leftmost `}` past the `=`. In the latter case, since no available alias name
#exists for such alias; `zeshy` prints an error and continues: e.g.,

# * Run directly from the command line. (If the current shell is non-
#   interactive, `zeshy` throws an exception on expanding such alias.)
# * "lr" is not already an existing runnable. (If "lr" is an existing
#   runnable, `zeshy` iteratively tries the following alias names until
#   either finding a name not already taken by an existing runnable or
#   exhausting all available choices, in which case `zeshy` prints an error:
#   "lsr", "lsre", "lsrec", "lsrecu", "lsrecur", "lsrecurs", "lsrecurse").
#>>> alias_cli_abbreviation {l}s{r}ecurse="ls -lR"
#------------------------------------------
#==========================================
# This is a normal zsh alias, always expanding "md" to call
# make_dir_if_not_found_with_options() regardless of whether "md" is already an
# existing command.
#>>> alias md="make_dir_if_not_found_with_options"

#List of aliases to be expanded only when run from an interactive `zeshy` shell,
#_always_ replacing existing runnables (i.e., external commands or `zsh` aliases,
#builtins, or functions). Interactive substitutions are useful for wrapping
#conventional runnables with convenience wrapper functions (e.g., replacing
#`ls` with list_path_with_options()). List current interactive substitutions with
#list_alias_cli_substitutions().

# This is a CLI

        # Type of failure action to perform, defaulting to "die" if not already
        # set by the caller. Recognized types include:
        #
        # * "die", only set by alias_cli_substitution().
        # * "return", only set by alias_cli_abbreviation_if_pathable().
        # * "cry", only set by alias_cli_abbreviation_if_pathable_or_warn().
#       string ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE="${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE:-die}"

        # Error message to be printed.
#       string error_message="${alias_type_readable} \"${alias_name}\" not an existing command or builtin"

        #FUXME: This is terrible. Just *ALWAYS* throw an exception. If the
        #caller doesn't like that, it's *THEIR* responsibility to manually
        #catch such exception and convert it into a warning. Eliminate this
        #horrific kludge immediately. *feigned sigh*
        #FUXME: Wait the distinction between throwing an exception ("die") and
        #merely returning non-zero exit status is still required ("return"). The
        #"cry" action, however, is *NOT* required. Such action should simply
        #throw an exception, as with "die". Since this leaves two actions, we
        #should implement this as a simple boolean. Much simpler and readable.
        #FUXME: Rename ${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE} to
        #${ZESHY_ALIAS_CLI_SUBSTITUTION_IS_RETURNING_IF_NONEXTANT}. If such
        #boolean global is unset, simply throw an exception. Since throwing an
        #exception should always be the default action, such nomenclature
        #strikes me as inherently sane.

        # Perform such failure action.
#       case "${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE}" {
#       :die) :die "${error_message}";;
#       cry) print_warning "${error_message}"; report_failure;;
#       return) report_failure;;
#       *) :die "${alias_type_readable} error action \"${ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE}\" unrecognized";;
#       }

#FUXME: Such functions do *NOT* implement error handling properly. While I
#appreciate the convenience of the current approach, it's simply wrong to only
#print a warning and return success on fatal errors. Happily, the solution is
#simple: throw exceptions on such errors *BUT* catch and convert such errors to
#mere warnings during zeshy precompilation, to avert innocuous failure. This is
#*SIMPLE*. Really. Just do it. ;}

#declare_function_with_stdin <<'/---'
#void alias_cli_substitution_if_found_or_warn(string alias_specification)
#
#Define an interactive substitution with the passed `=`-delimited specification
#if the alias name excluding `{` and `}` characters in such specification is the
#name of an existing pathable or print a warning and return otherwise: e.g.,
#
#.alias_cli_substitution_if_found_or_warn()
#==========================================
#[source]
#------------------------------------------
## Assume "ps" but not "psoriasis" to be an existing pathable, as expected.
#>>> alias_cli_substitution_if_found_or_warn\
#...     {p}soriasis=":string.output Circumin" or true
#alias_cli: "psoriasis" not an existing command or builtin
#>>> alias_cli_substitution_if_found_or_warn {p}s="print Circumin"
#>>> p
#Circumin
#------------------------------------------
#==========================================
#/---
#function alias_cli_substitution_if_found_or_warn() {
#    string\
#        ZESHY_ALIAS_CLI_TYPE='substitution'\
#        ZESHY_CLI_SUBSTITUTION_ACTION_IF_NOT_PATHABLE='cry'
#    alias_cli "${@}"
#}

    # Parse and possibly define such abbreviation *AND* set ${alias_name} by
    # removing all "{" and "}" delimiters from such string.
#   if is "${alias_name_passed}" == *'{'*'}'* si {
#       alias_cli_parse_embedding
    # Else, such alias name contains no "{" and "}" delimiters. Set
    # ${alias_name} to such name, in such case.
#   } else {
#   }

#   case "${ZESHY_ALIAS_CLI_TYPE}" {
#   abbreviation)
#       ZESHY_ALIAS_CLI_ABBREVIATION_NAMES[${alias_name}]='';;
#   substitution)
#       ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES[${alias_name}]='';;
#   alias)
#       ZESHY_ALIAS_CLI_UNTYPED_NAMES[${alias_name}]='';;
#   }

#FUXME: Replace the following three maps with a single map
#${ZESHY_ALIAS_CLI_NAME_TO_TYPE}, which *VASTLY* simplifies logic below.
#:map_global ZESHY_ALIAS_CLI_UNTYPED_NAMES <<'/---'
#Map from *CLI untyped alias* (i.e., a CLI alias neither a substitution or
#abbreviation) names to the empty string. This structure is a map rather than
#list as the former permits efficient lookup.
#/---

#:map_global ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES <<'/---'
#Map from CLI substitution alias names (sans `{` and `}` delimiters) to the empty
#string. This structure is a map rather than list as the former permits efficient
#lookup.
#/---

#:map_global ZESHY_ALIAS_CLI_ABBREVIATION_NAMES <<'/---'
#Map from CLI abbreviation alias names (sans `{` and `}` delimiters) to the empty
#string. This structure is a map rather than list as the former permits efficient
#lookup.
#/---

#FUXME: Brilliant. I've verified "${ZSH_EVAL_CONTEXT}" to expand to the string:
#
#    toplevel:shfunc
#
#...whenever expanded directly by a function called directly from the CLI, even
#if embedded in a pipe: e.g.,
#
#    >>> function tst() { :string.output "${ZSH_EVAL_CONTEXT}" }
#    >>> tst
#    toplevel:shfunc
#    >>> print ok | tst | head
#    toplevel:shfunc
#    >>> print $(tst)
#    toplevel:cmdsubst:shfunc
#
#Folks, we've found our mechanism. Proceed with a mass renaming and
#reimplementation. This should prove considerably better, I imagine.
#FUXME: Woops! I'd *LOVE* the logic below to work. But it might not, due to
#pipes. Commands run in pipes run directly from the CLI should be treated
#equivalent to commands run directly from the CLI for purposes of CLI alias
#expansion. But I seriously doubt that "${ZSH_EVAL_CONTEXT}" is still "toplevel"
#in such cases. I suppose we could test "${zsh_eval_context}" against
#"pipe:toplevel", or something? Would that work? Clearly, before we go half-
#cocked and completely muck everything up below, we need to just run a few
#sanity checks and see whether or not this is even sensible. Perhaps implement a
#placeholder alias_cli() function with some simple test logic simply printing
#"${ZSH_EVAL_CONTEXT}" in the expansion of the defined alias, initially,
#*WITHOUT CHANGING ANYTHING ELSE, BELOW*.
#FUXME: Unconvinced the current approach of testing whether or not the current
#shell is interactive is appropriate. In truth, we don't really care whether
#this is the case; we only care whether or not the caller invoked an interactive
#alias from the command-line, perhaps suggesting we rename "interactive alias"
#to some variant of: "CLI alias", "toplevel alias", etc. As expected, I quite
#like "CLI alias". It's far more concise *AND* descriptive than "interactive
#alias".
#FUXME: In any event, I recently discovered how to efficiently test for
#invocation from the shell CLI:
#
#    # This should work.
#    is "${zsh_eval_context}" == (?*':'|)'toplevel' si
#
#    # So should this.
#    is "${ZSH_EVAL_CONTEXT}" == 'toplevel' si
#
#It'd be helpful to implement a new parcel "zsh/context" parsing these two
#globals and providing corresponding testers and getters. Yum!
#FUXME: Given that most CLI aliases are defined implicitly by configuration file
#settings rather than explicitly by calling cli_alias(), it's rather silly to
#require "="-delimited alias specifications. Certainly, we should *SUPPORT* such
#specifications, but there should be an alternative function accepting two
#distinct arguments: the alias name and expansion. To effect this, how about a
#new cli_alias_with_expansion() function? To improve matters, simply have
#cli_alias() split the alias name and expansion from the passed specification on
#"=" and then pass such name and expansion straight to
#cli_alias_with_expansion(), which performs the lion's share of the
#implementation?

#Since CLI aliases are high-level `zeshy` abstractions implemented as low-level
#`zsh` aliases by extracting `{` and `}` delimiters from such names and wrapping
#additional logic around such expansions, the actual names and expansions of the
#associated `zsh` aliases differ from the original names and expansions specified
#for such `zeshy` abstractions. Specifically:
#
#* Alias names in this map may contain `{` and `}` delimiters omitted from their
#  actual alias names in `zsh`.
#* Alias expansions in this map never contain the additional logic of their
#  actual alias expansions in `zsh`.

#FUXME: Ensure that keys of this map actually contain the original "{" and "}"
#passed delimiters. (I don't believe they do, at the moment.)
#       alias_expansion_if_noncli='"'${alias_name}'" "${@}" and report_status"'
#       alias_name="${1%%[[:space:]]#\=*}"
#       alias_expansion="${1#*\=[[:space:]]#}"
    # If the first shell word such alias expands to equals its name but not an
    # existing command or builtin, the caller is probably attempting to
    # interactively alias a function of the same name: e.g.,
    #
    #  alias_cli recursion='recursion -not -ok'
    #  function recursion() { print 'does not work as expected'; }
    #
    # While zsh does permit aliases to functions of the same name, interactive
    # aliases are themselves implemented as functions. Hence, the above
    # definition of "function recursion()" silently destroys the previously
    # defined "alias_cli recursion". To avoid subtle bugs, explicitly
    # prohibit such situations by throwing an exception here.
#   command_name="${alias_expansion[(w)1]}"
#   is "${alias_name}" == "${command_name}" si and
#       not whence -- "${command_name}" &>/dev/null and
#       :die "${alias_type_readable} alias \"${alias_name}\" recursively expands to undefined command or builtin"
#   command_name_type="${$(whence -w -- "${command_name}")##*: }" or
#   is "${ZESHY_ALIAS_CLI_TYPE}" == abbreviation si and print "still alias name: ${alias_name}" 1>&2

    #FUXME: Sadly, this *CANNOT* be made to work with the current alias-driven
    #approach. I'm afraid there's no way around that. That said, everything
    #*SHOULD* still work as advertised, simply because *NO* CLI alias should
    #ever directly call a run_code_*() function. *shrug*
    # If the first shell word such alias expands to is prefixed by
    # "run_code_", assume such word to be a zeshy function transitively
    # calling run_code() with arguments requiring quote protection.
#   if is "${command_name}" == 'run_code_'* si {
#       alias_expansion_if_cli=${alias_expansion}' \"${(q)@}\" and report_status'
#   # Otherwise, pass arguments to such expansion as is.
#   } else {
#       alias_expansion_if_cli=${alias_expansion}' \"${@}\" and report_status'
#   }

    #FUXME: The alias name sorting isn't quite right, as sorting should be
    #performed on alias names *SANS* rather than including "{" and "}"
    #delimiters. We could conceivably declare a new list global
    #${ZESHY_ALIAS_CLI_NAMES_ACTUAL}, but this single use hardly seems worth it.
    #Instead, just cobble together 

#Each direct call to
#alias_cli() adds the passed alias name sans `{` and `}` delimiters to this map.
#Each call to alias_cli_abbreviation() and
#alias_cli_substitution() (when the latter is passed an alias name containing `{`
#and `}` delimiters) appends such name sans such delimiters to this list.
# For efficiency, inline such
        # implementations. See :map.is_key() for further details.
#    as strings such aliases expand to include but are
#guaranteed to be longer than these original expansions.
#
#Since 
#Unlike lists
#${ZESHY_ALIAS_CLI_UNTYPED_NAMES},
#${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES}, and
#${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES}, such alias names are exactly as passed.
#
#Since alias_cli() implements CLI aliases by wrapping such expansions in
#additional logic, the actual strings such aliases expand to include but are
#guaranteed to be longer than these original expansions.

#Since `{` and `}` delimiters in such names are only of use at  mapped alias names omit such delimiters.

# Each call to
#alias_cli(), alias_cli_abbreviation(), and alias_cli_substitution()
#adds the selected alias name and passed expansion to this map.
#FUXME: Rename to ${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES} and convert to list
#type. There's no demonstrable reason to duplicate expansions into another map,
#when ${ZESHY_ALIAS_CLI_NAME_TO_EXPANSION} already reliably maps *ALL* CLI
#alias expansions.
#FUXME: Rename to ${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES} and convert to list
#type as above.
#Map from interactive abbreviation name to corresponding expansion. Each call to
#alias_cli_abbreviation() and alias_cli_substitution() (if embedding a `{`-
#and `}`-delimited abbreviation name in the passed alias name) adds the selected
#abbreviation name and passed expansion to this map.

#Map from interactive substitution name to corresponding expansion. Each call to
#alias_cli_substitution() adds the passed substitution name sans `{`- and `}`-
#delimited abbreviation name and passed expansion to this map.

    # Define such alias as a function of the same name. Specifically:
    #
    # * Temporarily disable such function to prevent infinite recursion if
    #   such expansion transitively calls an alias, builtin, or command of the
    #   same name.
    # * If the current shell is interactive (thus excluding non-interactive
    #   scripts) and such function was called directly from the command line
    #   (thus excluding intermediate calls by interactively called functions),
    #   run the interactive expansion; else run the non-interactive expansion.
    # * Regardless of whether an exception is thrown, reenable such function.
#   eval "function \"${alias_name}\"() {
#   {
#       disable -f ${alias_name}
#       if [[ -o interactive && \${#funcstack} -eq 1 ]] {
#           ${alias_logic_if_cli}
#       } else {
#           ${alias_logic_if_noncli}
#       }
#   } always {
#       enable -f ${alias_name}
#   }
#}"

#FUXME: Embody the above test in a new alias in a new parcel
#"05-alias/zsh/context" as follows:
#
#   alias is_context_toplevel='is "${ZSH_EVAL_CONTEXT}" == 'toplevel' si'
#
#Simple.
    # Though this implementation could simply call
    # alias_cli_substitution_if_found(), this is altogether more efficient
    # and straightforward. (Since we have to match the command name anyway, we'd
    # might as well employ it.)
# Avoid calling alias_cli_substitution(),
    # which throws exceptions and hence disrupts digest recompilation for
    # aliases not existing pathables.
#always {
        # If an exception was thrown, convert such exception to a nonfatal
        # warning and proceed to the next alias.
#       catch * and print_warning "${CAUGHT}"
#   }
        # If an exception was thrown, convert such exception to a nonfatal
        # warning and proceed to the next alias.
#       catch * and print_warning "${CAUGHT}"
    # If an exception was thrown, convert such exception to a nonfatal
    # warning and proceed to the next alias.
    # Define listed substitutions. Avoid calling alias_cli_substitution(),
    # which throws exceptions and hence disrupts digest recompilation for
    # aliases not existing pathables.
#   for_map_key_value_pairs ZESHY_ALIAS_CLI_SUBSTITUTIONS\
#       alias_name alias_expansion\
#       'alias_cli_substitution_if_found_or_warn\
#           "${alias_name}" "${alias_expansion}"'
    #FUXME: Wherever we print a message prefixed by "CLI ${ZESHY_ALIAS_CLI_TYPE}",
    #we should *REALLY* be printing a message prefixed by a new string local
    #"${alias_cli_type}", expanding to a human-readable version of such prefix
    #(e.g., "CLI abbreviation alias", "CLI alias"). I believe we've already
    #doctored up code elsewhere that does so, so... recover that code here!

#       "${alias_type_readable} \"${1}\" contains no alias expansion"
    # Validate passed arguments.
#   (( ${#alias_name} )) or
#       :die "CLI ${ZESHY_ALIAS_CLI_TYPE} specifier \"${*}\" contains no '='-suffixed alias name"
#   (( ${#alias_expansion} )) or
#       :die "CLI ${ZESHY_ALIAS_CLI_TYPE} specifier \"${*}\" contains no '='-prefixed alias expansion"

#   is "${ZESHY_ALIAS_CLI_TYPE}" ==\
#       ('substitution'|'abbreviation'|'alias') si or
#       :die "CLI alias type \"${ZESHY_ALIAS_CLI_TYPE}\" unrecognized (expected \"substitution\", \"abbreviation\", or \"alias\")"
    # Since this alias name is not already an existing runnable, this alias
    # cannot be a substitution. To improve error readability, produce a
    # human-readable alias type as follows.
        #FUXME: O.K.; this doesn't apply anymore. Instead, check whether it's an
        #existing alias and, if so, simply *REPLACE* such alias. Ideally, we
        #should be a bit circumspect about this. While replacing an existing
        #function with another function of the same name internally calling the
        #former is infeasible, replacing an existing alias with another alias of
        #the same name internally expanding the former should be feasible.
        #FUXME: Actually, no. I can't think of any reasonable way that would
        #work. I mean, obviously, it *CAN'T*. We're defining a new alias with
        #the same name. There's a conflict, so throw an exception. Simple.

#   if { alias_name_type="${$(whence -w -- "${alias_name}")##*: }" } {
        # interactive abbreviation, print a warning indicating such abbreviation
        # could not be defined and immediately return.
#       alias_name="${1%%[[:space:]]#\=*}"
#       alias_expansion="${1#*\=[[:space:]]#}"
#   is "${alias_name}" == "${alias_expansion}" si and
#       :die "CLI ${ZESHY_ALIAS_CLI_TYPE} specifier \"${*}\" contains no '=' delimiter"
        # ...zsh function, throw an exception. Interactive aliases are
        # themselves implemented as functions and hence cannot replace
        # functions of the same name without destroying such functions. As
        # functions may be implemented to account for interactivity (e.g., by
        # calling is_shell_interactive() or interactively()), there is no compelling
        # reason for interactive aliases to silently (usually, erroneously)
        # replace previously declared functions.
#       if is "${alias_name_type}" == 'function' si {
#           :die "interactive ${ZESHY_ALIAS_CLI_TYPE} \"${alias_name}\" already a defined function:\n$(which "${alias_name}")"

#Due to implementation details, CLI aliases cannot expand functions of
#the same name. Doing so would silently replace the prior defined function with
#the interactive alias, thus inducing `command not found` errors on alias
#expansion. If passed an interactive alias name of the same name as an existing
#function, this function throws an exception: e.g.,
#
#.alias_cli() Runnable Replacement
#==========================================
#[source]
#------------------------------------------
#>>> function 4-HO-MET() { :string.output "${1} is colour" }
#>>> alias_cli 4-HO-MET="4-HO-MET Methylcybin"
#zeshy: interactive abbreviation "4-HO-MET" already a defined function:
#4-HO-MET() { :string.output "${1} is colour" }
#------------------------------------------
#==========================================

#== Caveats ==
#
#`zeshy` implements interactive aliases as functions rather than genuine aliases.
#This solves the prior problem of zsh assigning aliases higher precedence
#than functions, but could potentially trip up the unawares. (In practice, the
#difference between aliases and functions tends to be negligible. Usually,
#anyway!)

#`zeshy` requires such functionality before compiling its digest, sadly. Since
#`zeshy` confines most functionality to its digest, no function below may call
#`zeshy` functions. All functions below must manually implement `zeshy` functions
#defined elsewhere!

#=== Algorithm ===
#
#Interactive substitutions and abbreviations parse "{..}" expressions according
#to a simple exhaustive algorithm, which for each iteration:
#
#* Concatenates all "{"- and "}"-delimited substrings in the original alias
#  name into an implied abbreviation name: e.g.,
#
#  # In this iteration, the implied abbreviation name is "md".
#  alias_cli_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
#* If the implied abbreviation name is not already an existing command name,
#  creates such abbreviation; otherwise, shifts the leftmost "}" right by one
#  character in the original alias name unless prior to the last character of
#  such name in which case prints a warning: e.g.,
#
#  # First test whether "md" is already an existing command. If not, run:
#  alias_cli_abbreviation {m}k{d}ir="mkdir --parents --verbose --"
#
#  # Else, test whether "mkd" is already an existing command. If not, run:
#  alias_cli_abbreviation {mk}{d}ir="mkdir --parents --verbose --"
#
#  # Else, test whether "mkdi" is already an existing command. If not, run:
#  alias_cli_abbreviation {mkdi}ir="mkdir --parents --verbose --"
#
#  # Else, all such names already exist. Emit a vile warning.
#  print_warning 'interactive abbreviations "md", "mkd", and "mkdi" already existing commands'
#
##Such substrings reduce repetition by combining multiple alias_cli_substitution() and
##alias_cli_abbreviation() calls repeating the same expansion into a single call.

#`{`- and `}`-delimited
#substrings in alias names . The
#concatenation of all `{`- and `}`-delimited substrings excluding such delimiters
#in a CLI alias name provides the *preferred name* for such alias' abbreviation.
#Since such name may already be claimed by an existing runnable (e.g., commands
#`l` and `lp` in the current user's ${PATH}), `zeshy` iteratively shifts the
#leftmost `}` in such name right by one character until finding a name _not_
#already claimed by an existing runnable: 

#== Syntax ==
#
#CLI aliases are both declared and defined with `=`-delimited alias syntax.

#CLI substitution and abbreviation aliases parse `{`- and `}`-delimited
#substrings according to a simple exhaustive algorithm, which for each iteration:
#
#* Concatenates all "{"- and "}"-delimited substrings in the original alias
#  name into an implied abbreviation name: e.g.,
#
#* If the implied abbreviation name is not already an existing command name,
#  creates such abbreviation; otherwise, shifts the leftmost "}" right by one
#  character in the original alias name unless prior to the last character of
#  such name in which case prints a warning: e.g.,

# p
#`{`- and `}`-delimited substrings in a CLI abbreviation alias name implicitly
#define  preferred name is the concatenation of
#such substrings excluding delimiting `{` and `}`, to be expanded to the same
#expansion. If the preferred abbreviation name is claimed by an existing
#runnable, alias_cli_substitution() iteratively lengthens such abbreviation until
#finding a name _not_ already claimed by an existing runnable: e.g.,

#Interactive abbreviations interpret embedded `{..}` expressions as the
#interactive abbreviation name to be expanded to. This is principally useful
#for generic safety, to accommodate heterogenous end user systems under which
#one has no control and hence could have conceivably installed commands with
#the same names as desired abbreviations: e.g.,

#if available
#(i.e., if not already the name of an existing runnable)
# for both convenience and safety. whose result dynamically depends on current system state --
#user's shell environment and contents of the filesystem accessible to such user.
# for normal,
#global, and suffix aliases, as the above examples demonstrate
#. Specifically, the alias name is followed by delimiter `=`
#followed by the alias expansion: e.g.,
#
#For example:
#
#Like traditional aliases, the various types of CLI aliases are defined
#by various `zeshy` functions:
#
#* alias_cli_abbreviation(), abbreviating an existing zsh builtin or external
#  command in ${PATH} with an interactive alias of a different name: e.g.,
#
#    # Abbreviate the external "ls" command with an interactive alias "l".
#    alias_cli_abbreviation l="ls"
#
#* alias_cli(), a low-level helper function declaring an interactive
#  alias _not_ substituting or abbreviating an existing zsh builtin or external
#  command in ${PATH}. However, most interactive aliases substitute or
#  abbreviate such builtins or commands! For improved portability and safety,
#  consider calling the high-level functions alias_cli_substitution() or
#  alias_cli_abbreviation() instead.

#`zeshy` throws an exception on attempting to:
#
#* Define either a CLI:
#** Substitution of a non-existing command. (Substitutions always replace
#   existing commands, thus preventing declaration of interactive aliases
#   inapplicable to the current system and user.)
#** Abbreviation of an existing alias, function, or command. (Abbreviations
#   never shadow existing runnables, unlike typical aliases.)
#* Call an interactive abbreviation non-interactively.
#
#Calling an interactive substitution non-interactively runs the substituted
#command as is, as if never shadowed by an interactive alias. In other words,
#"things just work as expected."

    #FUXME: Calling run_code_with_stdin_piped() both here and below is rather
    #overkill, as such expansion is *ALREADY* being evaluated. No sense in doing
    #so twice. We really just need an alias expa

    # Validate sanity and that Zeshy's user configuration has been sourced.
#   die_if_args
#   string command_name
#   :var.die_unless_type_map ZESHY_ALIAS_CLI_ABBREVIATIONS\
#       "map \"ZESHY_ALIAS_CLI_ABBREVIATIONS\" undeclared; zeshy's user configuration either unsourced or corrupt"
#   print "ZIS: ${(kv@)ZESHY_ALIAS_CLI_SUBSTITUTIONS}"
    #FUXME: Call map iterables rather than iterating manually.

# Consider calling alias_cli_abbreviation() or
#alias_cli() if such functionality is preferable.
    #FUXME: Terrible name, really. How about simply "punctuation_bold"?
    #FUXME: Actually, "punctuation" is increasingly terrible the more I consider
    #it in frustration. What if you want to change, say, the color of the colon
    #say() emits without changing *ALL* such punctuation? You can't. Hence, we
    #should avoid such generalized styles for function-specific styles. Remove
    #btho this and "punctuation".
#   punctuation          grey
#   punctuation_semantic grey_bold

#List all declared interactive alias names with corresponding expansions.
# Handle interactive abbreviations (i.e., interactive aliases *NOT* replacing
# existing runnables).

# Handle all interactive alias functionality *OTHER* than defining such aliases.
# See "define" for the latter.
# See "handle" for all other interactive alias-related functionality.
    #FUXME: Define and call a new alias_cli_substitution_if_found_or_warn() instead
    #to avoid crashing the entire compilation process when such command is not
    #installed on the current system. Robustness for the win!

# (It *SHOULDN'T* ever be, and since it
    # shouldn't ever be, print warnings instead.)
        #FUXME: Should probably centralize into a new
        #alias_cli_substitution_if_found().
#       alias_name="${specification%%\=*}"
#       command_name="${alias_name//[\{\}]}"
#       is_pathable "${command_name}" and alias_cli_substitution\
#           "${specification}"
#FUXME: How essential are these, actually? I'm thinking... not. The difficulty
#is coherently coordinating colors between the three. *sigh*
#I print_message we excise these, for now.
#declare_function '
#void list_alias_cli_abbreviations()
#
#List all declared interactive abbreviation names with corresponding expansions.
#'
#function list_alias_cli_abbreviations() {
#    # Validate sanity.
#    die_if_args
#
#    # List such aliases.
#    for name ( $(get_map_keys_sorted_lexically_ascending\
#        ZESHY_ALIAS_CLI_ABBREVIATION_NAMES) ) {
#        :string.output "alias_cli_abbreviation ${name}:catch\"${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES[${name}]}\""
#    } | page_stdin
#}
#
#declare_function '
#void list_alias_cli_substitutions()
#
#List all declared interactive substitution names with corresponding expansions.
#'
#function list_alias_cli_substitutions() {
#    # Validate sanity.
#    die_if_args
#
#    # List such aliases.
#    for name ( $(get_map_keys_sorted_lexically_ascending\
#        ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES) ) {
#        :string.output "alias_cli_substitution ${name}:catch\"${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES[${name}]}\""
#    } | page_stdin
#}
#
    # Reset colors in preparation for subsequent output.
#   reset_
#   :string.output "${ZESHY_COLOR_RESET}"
    #FUXME: Excellent. We should probably define (and expand here) a new *ALIAS*
    #set_colors_locally<> testing whether or not standard output for the current
    #function is attached to a terminal and, if not, temporarily locally
    #replacing all color strings and maps previously globally defined with
    #strings expanding to the empty string. (Clearly, such maps should have the
    #same keys but empty values.) Rather than expensively redeclaring such
    #variables on each such alias expansion, predeclare such variables in
    #"io/terminal/color" as, perhaps, ${ZESHY_COLOR_EMPTY} and so on.
    #FUXME: Actually, localize_colors<> is a significantly better name. Yum-yum.

#FUXME: Colorify such output; it's a tad difficult to read without helpful
#syntax highlighting.

#       if :map.is_key ZESHY_ALIAS_CLI_ABBREVIATION_NAMES "${name}"
#       elif :map.is_key ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES "${name}"
        #FUXME: Let's try improving :map.is_key() efficiency, shall we?
#       if :map.is_key ZESHY_ALIAS_CLI_ABBREVIATION_NAMES "${name}"
#       elif :map.is_key ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES "${name}"
#       if :map.is_key ZESHY_ALIAS_CLI_ABBREVIATION_NAMES "${name}"
#       elif :map.is_key ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES "${name}"
        # If such alias is an abbreviation, prefix such declaration with that.
        # If such alias is a substitution, prefix such declaration with that.
        # Otherwise, prefix such declaration with a generic alias type.
#   {
#       list_alias_cli_abbreviations
#       print_newline
#       list_alias_cli_substitutions
#   } | page_stdin
#   =(
#       "${ZESHY_ALIAS_CLI_ABBREVIATION_NAMES[@]}"
#       "${ZESHY_ALIAS_CLI_SUBSTITUTION_NAMES[@]}"
#   )
#       say_first_section 'interactive abbreviation list'
#       say_next_section 'interactive substitution list'

#       ${(k)ZESHY_ALIAS_CLI_ABBREVIATION_NAMES}) {

# This includes list element of:
#* ${ZESHY_ALIAS_CLI_ABBREVIATIONS}, define:
#  * An interactive abbreviation from such element stripped of "{"- and "}"-
#    non-delimited substrings to such element stripped of "{"- and "}"-
#    delimited substrings (e.g., for list element "{v}im",
#    "alias_cli_abbreviation v=vim"), if the former exists.
#* ${ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED}, define:
#  * An interactive substitution from such element stripped of "{"- and "}"-
#    delimited substrings to the same string (e.g., for "{cali}bre",
#    "alias_cli_substitution calibre=''run_code_disowned calibre''").
#  * An interactive abbreviation from such element stripped of "{"- and "}"-
#    non-delimited substrings to the above string (e.g., for "{cali}bre",
#    "alias_cli_abbreviation cali=''run_code_disowned calibre''"), if the former
#    exists.
    #FUXME: Defer to a canonical splitter function instead of splitting manually.
# This component resides under "00-setup" to guarantee its importation prior to
# other Zeshy components during compilation of Zeshy's digest file. Typically,
# other Zeshy components call functions this component defines (e.g.,
# alias_cli_substitution()) in a global context.

    # If such alias is either an
    # interactive abbreviation or substitution as is usual, .
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Note: avoid calling :die() or functions calling :die() below.
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# algorithmically selected abbreviation name to this list.

#List of aliases to be expanded when run from an interactive shell. Each alias
#name (excluding embedded "{" and "}" characters) must be the name of an
#existing runnable. See ${ZESHY_ALIAS_CLI_ABBREVIATIONS} for further details.

#Interactive abbreviations and substitutions are generally safer than and hence
#preferable to normal zsh aliases, for most uses.

    #   the next name until either finding a
    #   name not already taken by an existing runnable or exhausting all
    #   available choices, in which case Zeshy prints a warning.

#heuristics find the shortest desired alias name not already
#claimed by an existing runnable
#with "{"- and "}"-delimited substrings in the alias name
#
#embedding Zeshy-specific "heuristics."
#For all three 
#With normal zsh aliases, the substring left of the "=" specifies the alias name
#while the substring right of the "=" the alias expansion: e.g.,
#
#Normal zsh aliases have the familiar format
#"alias ${alias_name}:catch${alias_expansion}": e.g.,
#
#    alias this_is_the_alias_name="this --is --the -- alias expansion"
#
#With interactive abbreviations and substitutions, the substring left of the "="
#is a heuristic helping Zeshy to find the shortest desired alias name not already
#claimed by an existing runnable while the substring right of the "=" still defines the alias
#expansion as for normal aliases.
#see ${ZESHY_ALIAS_CLI_SUBSTITUTIONS} for interactive aliases
#always replacing existing runnables.

# on the current system (i.e., not already the name of
#an existing alias, builtin, or function or external command in the current
#user''s ${PATH}),
#Interactive abbreviations *NEVER* replace existing runnables (i.e., external
#commands or zsh aliases, builtins, or functions). Hence, such abbreviations are
#appropriate for abbreviating but not replacing an existing 

#By contrast, interactive substitutions *ALWAYS* replace existing runnables. 

    #FUXME: It'd be great to add a new list ${ZESHY_ALIAS_CLI_SUBSTITUTIONS}
    #with "="-delimited elements, which would allow us to do away with a few
    #currently extraneous "if_installed" components: e.g.,
    #ZESHY_ALIAS_CLI_SUBSTITUTIONS=(
    #    {m}utt='mutt -y'
    #)
    #FUXME: Come to think, it'd be great to shift *ALL* current calls to
    #alias_cli_abbreviation() and alias_cli_substitution() into
    #"if_config/alias", thus rendering such aliases accessible to user
    #configuration (as well as cleaning up and simplifying the syntax). I'm
    #fully for it! Huz-zzah!


# See "help alias_cli_abbreviation" for further details on abbreviations.

#       alias_cli_substitution_if_found "${specification}"
#   for specification ("${ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_RUNNABLE[@]}") {
#       alias_cli_abbreviation_if_pathable "${specification}"
#   }
#   ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_RUNNABLE\
# List of interactive aliases in "="-delimited syntax to be expanded only if run
# from an interactive shell *AND* the alias name (excluding embedded "{" and "}"
# characters) is the name of an existing runnable on the current zsh system.
# See above for further details on such syntax.
#ZESHY_ALIAS_CLI_ABBREVIATIONS_IF_RUNNABLE=(
#)

#alias_cli_abbreviation ${subst_name}:catch"${command_name}"

# operate slightly
# differently.
# intername alias 
# All "{"- and "}"-delimited substrings within alias
# names denote preferred abbreviation names. See
# alias_cli_abbreviation() for further details.
#
# For example, the single line "{v}im" listed below produces alias "v" running
# ViM when the current shell is interactive and the current ${PATH} contains
# "vim" (i.e., when ViM is installed). In effect, Zeshy converts this line to
# code resembling:
#
#     >>> is_shell_interactive and is_pathable vim and alias v='vim'

#   is "${ZESHY_ALIAS_CLI_TYPE}" == abbreviation si and print "which alias name: $(which ${alias_name})" 1>&2

#Interactive abbreviations are thus suitable for abbreviating existing runnables
#with a unique name. See alias_cli() for further details: e.g.,
#
#Interactive abbreviations refuse to replace existing runnables. Specifically,
#are interactive aliases (and hence intended to be
#called only directly from the command line) subject to an additional constraint:
#interactive abbreviations *NEVER* replace existing runnables (i.e., external
#commands or zsh aliases, builtins, or functions).

#Interactive aliases are inactive in non-interactive scripts and
#functions, and hence helpful for applying human-readable options on that
#builtin or command when run directly by a human. This function fails if the
#builtin or command to be aliased does not exist. See
#alias_cli_if_installed() for an alternative not failing in such cases.

# >>> print_noninteractively() { print "${@}" }
# >>> print_noninteractively T M D
# T M D
#The alias specification format is identical to that of normal aliases:
#   (( ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS )) or report_success
#   (( ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS )) or report_success

#whereas 
#if the passed alias name has the same name as some existing runnable (e.g.,
#builtin, command), print a warning and return without defining such alias.

#Interactive abbreviations *NEVER* replace existing runnables, but are
#otherwise identical to interactive aliases.
#If the current user has enabled the configuration global
#${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS},
#   ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS\
#   ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS
# ....................{ BOOLEANS ~ alias                   }....................

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#FUXME: Actually, these are thoroughly obsolete. Stop using them everywhere and
#excise. Replace with proper granular support for "="-delimited aliases in
#configuration file "alias".
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# If non-empty, ...

# "1" if wrapping interactively run external commands (e.g., "cp", "grep", "ls")
# with corresponding Zeshy functions and "" otherwise. If enabled, Zeshy runs
# such commands with default options defined by the corresponding list below
# (e.g., wrapping interactively run "cp" commands with copy_path(), a Zeshy
# function passing "cp" the ZESHY_OPTIONS_CP list). If disabled, Zeshy runs
# such commands with no such defaults.
#
# For sanity, Zeshy never wraps core commands when run non-interactively (e.g.,
# "cp" when run from a script always executes "cp" with no such defaults).
#ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS=${ZESHY_BOOLEAN_TRUE}

#FUXME: Document.
#ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS=${ZESHY_BOOLEAN_TRUE}

    #   * Standard :string.output is attached to a terminal, thus excluding all
    #     commands in pipe except the last such command.
#&& -t ${ZESHY_STDOUT_FILE_DESCRIPTOR}

# ....................{ GLOBALS                            }....................
#FUXME: It'd be great to make this somehow configurable. Ah; obviously, this
#should go into a configuration file. I s'pose that was very obvious. How about
#simply "alias" at the top-level? Not convinced we need the
#add_interactive_gui_substitution() function, honestly; cut it to the wastes.
#Since there only exists one remaining small function, move such function to
#"alias_cli".

#a similar
#   interactive substitution and abbreviation to the such strings run disowned
#   (e.g.,     # For each such name, if such name stripped of "{"- and "}"-delimited
    # substrings produces a currently installed command name, define such name
    # to interactively expand to such command name.
#"disowned" from the current
    # shell. GUI commands should almost always run "disowned" to prevent their
    # termination on termination of the parent shell.
# While GUI commands should avoid terminating on termination of their
# originating shell, CLI commands should always terminate on , this list typically lists .
# Such substitutions
# either were previously added to
# ${ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED} by prior calls to
# add_alias_cli_substitutions() or are hard-coded into this function.#
# Interactive substitution name embeds "{"- and "}"-delimited strings defining the corresponding
# interactive abbreviation name).
# by the embedded
# interactive substitution name. Typically, such commands are graphical.
# ....................{ ADDERS                             }....................
# void add_interactive_gui_substitution(
#   string substitution_name1, string substitution_name2, ...)
#
# Add the passed strings to list global
# ${ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED}, to be subsequently defined by
# startup_interactive_gui_substitutions() as interactive substitutions running
# GUI commands (i.e., disowned from the current shell).
#function add_interactive_gui_substitution() {
#    die_unless_args 'expected at least one substitution name'
#    ZESHY_ALIAS_CLI_SUBSTITUTIONS_RUN_DISOWNED+=( "${@}" )
#}

    #FUXME: DeVeDe appears to fail under:
    #   {d}e{v}e{de}                   # DeVeDe DVD Creator.
    #Why?
    #FUXME: Declare as a "listset_global" here and below, to preserve uniqueness.
# as interactive substitutions running
# interactive substitutions for a subset of hard-coded GUI commands.
#FUXME: It'd be nice to permit users to dynamically add aliases to such list.
#Since we already helpfully use a global_export variable below, we need only add a few
#helper functions to enable this.

#Of course, this begins to raise awkward timing issues, as well... Ah. No; it
#doesn't, really.

# Unlike Zeshy Interactive Alias, this component need not reside under
# "00-startup". It does, however, need be imported after importing Zeshy
# Interactive Alias. Thus, its filename.
        # If such command is installed, define such substitution.
# Thus, this component is a
# hard dependency of typical Zeshy components.
#FUXME: This still isn't quite right. The reason is subtle:
#    alias_cli ssh='TERM="xterm" ssh -v'
#See what happens there? We attempt to call a command "TERM=\"xterm\"" when
#non-interactive. Of course, we should be calling "ssh". So, this is subtly
#broken. Fixing it requires ignoring all prefixing words containing a "="
#character if such word is not an extant command. (Since, of course, a command
#basename could contain an "=" character. Highly unlikely, but there you go...)
#   *sigh*

#FUXME: Record each added substitution and abbreviation in respective global
#maps, for use in displaying a dynamically constructed "cheat sheet" of all
#current interactive substitutions and abbreviations.
#FUXME: It would be nice to define interactive substitutions and abbreviations
#together in the same function. While this should only ever be an optional
#convenience not replacing the original functions below, it would enable us (in
#particular) to dynamically search for the "nearest" unclaimed abbreviation. For
#example:
#
#    >>> alias_cli_substitution [p]rint='print -r --'
#
#Way cool. If passed an alias name containing one "[" preceding one "]",
#interpret the alias name with such characters omitted as the full name and the
#substring of such name embedded in such characters as the abbreviation. If the
#latter name has already been claimed by an existing runnable, iteractively try
#"pr", "pri", and "prin" before giving up with a warning (but *NOT* exception).
#
#Let's admit it: this is pretty great. But it's not quite enough. We also need
#to handle discontiguous embedded abbreviations resembling:
#
#    >>> alias_cli_substitution [m]k[d]ir='mkdir -v --'
#
#This suggests a lexical algorithm as follows:
#
#* If the desired abbreviation already exists, iteratively shift the leftmost
#  "]" right unless already prior to the last character of the alias name, in
#  which case print a warning. Hence, we try the following embeddings:
#
#    >>> alias_cli_substitution {m}k{d}ir='mkdir -v --'
#    >>> alias_cli_substitution {mkd}ir='mkdir -v --'
#    >>> alias_cli_substitution {mkdi}r='mkdir -v --'
#
#I suspect this is efficiently implementable without actually shifting around
#lexical characters. Also, note that the implementation requires *NO* changes
#to the existing alias_cli_abbreviation() or alias_cli() commands.
#Such commands should, ideally, be entirely unaware of substitution embeddings.
#FUXME: This functionality has become a bit... extreme. It's great, but too
#large for a top-level component. Shift into a new "always/shell/interactive" or
#"always/shell/alias/interactive" component; then, manually import such
#component if and only if compiling a new digest. The only catch here is that
#such component *CANNOT* call any functions defined in other components. This
#needs to be explicitly documented, up front.

# Unlike traditional aliases, :
# substitution and abbreviation interactive aliases. 
#
# Interactive aliases are declarable with one of the following functions:
#
# the "alias_cli"
# helper (as above), Zeshy recommends using the following  "interactive 
#
# While interactive aliases are declarable directly with the "alias_cli"
# helper (as above), Zeshy recommends using the following  "interactive 
# There are two prominent types of interactive aliases.
#
# Like traditional aliases, there are two prominent types of interactive
# aliases: substitution and abbreviation interactive aliases. 
#
# Defer defining the following functions until having defined all prior aliases.
    # While the following block would ideally be encapsulated in a separate
    # function, its calling of alias_cli_abbreviation() and hence dynamic
    # evaluation of a new function definition would erroneously confine such
    # definition to the subshell
#       alias_name="$(parse_embedded_alias_cli_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"


#       print -r -- "${alias_name//[\{\}]}"
#       alias_name="$(parse_embedded_alias_cli_abbreviation "${alias_type}" "${alias_name}" "${alias_expansion}")"
# string parse_embedded_alias_cli_abbreviation(
#   string alias_type, string alias_name, string alias_expansion)
#
# Parse "{"- and "}"-delimited substrings from the passed interactive alias name
# of the passed type (either "substitution" or "abbreviation") expanding to the
# passed expansion. Concatenating such substrings provides the interactive
# abbreviation embedded in such name (e.g., alias name "l{ich}mumm{y}" embeds
# abbreviation "ichy"). If such type is:
#
# * An abbreviation, return such abbreviation name.
# * A substitution and:
#   * If all possible extensions of the embedded abbreviation have been claimed
#     by existing runnables, print a warning and define no such abbreviation.
#   * Otherwise, define such abbreviation to the passed expansion.
#   * In either case, return such alias name stripped of "{" and "}" characters.
    # Validate passed arguments.
#   die_unless_args_3\
#       'expected one alias type, one alias name, and one alias expansion'
#   string alias_type="${1}" alias_name="${2}" alias_expansion="${3}"
#   print_string_with_escapes "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}"

#           match=()
#           (( abbre_first_char_index = ${mend[1]} - 1 ))
#           (( abbre_right_brace_index = MEND ))
    # Return unless the current user configuration enables substitutions.
    # Return unless the current user configuration enables abbreviations.
#   string alias_name="${*%%[[:space:]]#\=*}"
#   noop "${(S)alias_name//*\{(#b)(*?)\}*}"
#   if ; then
#   if is "${alias_name}" == *'{'(#b)(*?)'}'* si; then
#   if is -n "${(MS)alias_name//*\{(#b)(*?)\}*}" si; then
#   :string.output "match attempt: ${(SI:1:)alias_name//*\{(#b)(*?)\}*}"
#   :string.output "match attempt: ${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   match=()
#   noop "${(SI:1:)alias_name#\{(#b)(*?)\}}"
#   if is -n "${match}" si; then
#       match=()
#       is "${alias_name}" == (#b)[^{}]#'{'([^{}]##)'}'[^{}]# si
#       is "${alias_name}" == ([^{}]#'{'(#b)([^{}]##)'}')## si
#       is "${alias_name}" == (#b)([^{}]#'{'([^{}]##)'}')## si
#       :string.output "alias_name: ${alias_name}"
#       print "${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#       :string.output "embedding: ${match[*]}"
#       :string.output "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       :string.output "embedding: ${(S)alias_name//*\{(#b)(*?)\}*/${match[1]}}"
#       integer embedded_first_char_index=$(( ${mend[1]} - 1 ))
#       :string.output "match: ${match[1]}; mend: ${mend[1]}"

#   string abbre_name="${alias_name//[^\{\}]#\{(#b)([^\{\}]##)\}[^\{\}]#/${match[1]}}"
#   if is "${abbre_name}" != "${alias_name}" si; then
#       integer alias_name_length="${#alias_name}" abbre_next_char_index
#       print_string_with_escapes "abbreviation: ${abbre_name}\nmatch[1]: ${match[1]}\nalias name length: ${alias_name_length}"
#   else
#By design, the passed alias must be either an interactive abbreviation or
# substitution. #       while whence -- "${abbre_name}" 1>/dev/null 2>&1; do
#           (( abbre_next_char_index < 10 )) or break
                #FUXME: Should be handled by the above exception handling, no?
#               (( abbre_next_char_index < alias_name_length )) or
#                   :die "interactive substitution \"${alias_name}\" contains an unclosed '{'"
    # If *NOT* a raw interactive alias (e.g., if either an interactive
    # substitution or abbreviation) and 
#           string abbre_name_definition
#           abbre_name_definition=""
#           print_warning "embedded abbreviation interactive substitution \"${alias_name}\" contains"

#           case "${alias_cli_type}" in
            # ...this is an interactive substitution alias and the current user
            # prohibits substituting runnables with such aliases, return!
#           substitution) report_success;;
#               is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#                   report_success
            # ...this an interactive abbreviation alias, return! Also, if the
            # current user prohibits abbreviating runnables with such aliases,
            # print a warning indicating such abbreviation could not be defined.
#           elif is "${alias_cli_type}" == 'abbreviation' si; then
#               is -n "${ZESHY_IS_ABBREVIATING_INTERACTIVE_COMMANDS}" si or
#                   print_warning "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#               report_success

    #FUXME: Document. I get it. We were trying to make the above
    #'alias_cli print="print -o"' example work as expected. But, if you
    #think about it, that's pretty much impossible in the general case. For example,
    #'alias_cli print="run_code_paged print -o"' pretty much fails under non-
    #interactivity with the naive assumption of the first word being the command to be
    #run. I'd print_message this needs dramatic generalization. Basically, the function should
    #strictly accept only one or two arguments; if passed, the second argument tells
    #what to run when non-interactive and otherwise defaults to the following:
    #
    #* If the alias name and first word of the alias expansion are the same and:
    #  * Such name is an existing function, throw an exception (as below) when run
    #    non-interactive.
    #  * Default to such name without arguments (as below) when non-interactive.
    #* Otherwise, default to such name without arguments (as below) when non-interactive.
    #
    #Oh, wait. The above FUXME handles such edge cases, so... simply default to:
    #
    #* If the first word of the alias expansion is a non-empty, non-alias, non-function
    #  (i.e., is a command, builtin, or reserved), such word.
    #* Else if the first word of the alias expansion matches the "run_code_"* glob and the
    #  second word of such expansion is a non-empty, non-alias, non-function, such word.
    #* Else if the alias name is a non-empty, non-alias, non-function, such name.
    #* Otherwise, throw an exception from within such function definition.
    #
    #Note that *': function' erroneously fails to match aliases. So, just glob
    #*': '(builtin|command|reserved) explicitly. *shrug*
    #
    #This default cleanly handles the prior examples. It won't work in all cases, of
    #course, which is why we permit parameters resembling:
    #
    #    alias_cli print_up="do_something_curious print -o"' 'print'
    #
    #*ACTUALLY*, the more I think about, the more I realize the above heuristics only
    #apply to the case that the alias name is a non-function (e.g., external command);
    #in such case, the above heuristic can be seemlessly reduced to simply calling such
    #name. If, on the other hand, the alias name is an *ABBREVIATION*, then it should
    #*NEVER* be runnable non-interactively; an exception should always be thrown. Since
    #this logic biffurcates cleanly between alias_cli() and
    #alias_cli_abbreviation()... You know, why do we even have those two functions?
    #Any interactive alias for which the alias name is *NOT* already an existing non-
    #function is implicitly an abbreviation or something similar. I believe we can
    #dispense with alias_cli_abbreviation(), therefore.

    #FUXUP: We should probably throw an exception under cases such as:
    #
    #  alias_cli recursive='recursive -not -ok'
    #  function recursive() { print 'uh oh'; }
    #
    #While recursion *USUALLY* works (due to our use of function disabling and
    #enabling below), it fails if the first word of the alias expansion expands
    #to a zsh function of the same name as the alias. In the case above, such
    #function has yet to be defined. Hence, *UNLESS* such word has a non-empty,
    #non-function type, we assume its type to be function and throw an exception.

    # The command to expand this alias to when called non-interactively. If the
    # the command to expand this alias to when called interactively is a:
    #
    # * Builtin or command, then this is that builtin or command name sans
    #   subsequent arguments.
    # * Alias or function and:
    #   * The original passed alias name is a builtin or command, then this is
    #     that builtin or command name.
    #   * Otherwise, raise an exception.

#   then alias_logic_if_noncli="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#alias_cli ff="firefox"
    # The string to expand this alias to when called non-interactively.
#   if is "${alias_name}" == "${command_name}" and\
#      "$(whence -w "${command_name}")" == *': function' si
#   then alias_logic_if_noncli="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
        #FUXME: Have my doubts about this logic; it feels... dubious. Too
        #clever, and arguably bug-prone. Let's ride bareback for a bit.
#       if is "${alias_name_type}" != 'function' si
#       then alias_expansion_if_noncli="${alias_name}"
#       else alias_expansion_if_noncli=
#       fi
#   else
#       alias_expansion_if_noncli="${command_name} \"\${@}\""
#       alias_logic_if_noncli="
#   if :is_stdin_pipe
#   then run_code_with_stdin_piped ${alias_expansion_if_noncli}
#   else ${alias_expansion_if_noncli}
#   fi"
#   fi

#FUXME: Implement me. Basically, disembowel alias_cli(). ;]
#define_alias_cli() {
#}

    #SUBSTITUTION
#   if alias_name_type="${$(whence -w -- "${alias_name}")##*: }"; then
#       if is "${alias_name_type}" == 'function' si; then
#           :die "interactive substitution \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       else
#           is -n "${ZESHY_IS_SUBSTITUTING_INTERACTIVE_COMMANDS}" si or
#               report_success
#       fi
#   else
#       :die "interactive substitution \"${alias_name}\" not found in \$PATH"
#   fi

    #ABBREVIATION
    # If a function, throw an exception. While zsh does behave sensibly when
    # aliasing functions (e.g., "alias rm='rm -i'" behaves non-recursively),
    # interactive aliases are functions rather than aliases. Defining an
    # interactive alias of the same name as an existing function thus
    # silently overwrites such function, which is never helpful. Prohibit!
    # If anything other than a function (e.g., builtin, command),
    # emit a warning and return without redefining such builtin or command.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and
#       is "${alias_name_type}" != 'function' si and {
#       print_warning "interactive abbreviation \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       report_success
#   }

    # If such alias name is an existing runnable, either emit a warning or throw
    # an exception (depending on the type of such runnable).
        # Definition of such runnable and appropriate error message.
#       string alias_definition error_message
#       alias_definition=""

#FUXME: ${ZESHY_IS_WRAPPING_BUILTINS} is a rather poor name. Globally rename to
#${ZESHY_IS_WRAPPING_BUILTINS_WITH_CLI_ALIASES}, please.

    # Alias name type, if the passed alias name is already declared to be an
    # alias, builtin, command, or function.
#   alias_name_type="${$(whence -w -- "${alias_name}")##*: }" and {
        #FUXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
        #I suppose not! We don't call eval() in the function definition, and doing so
        #would introduce yet more bizarre edge-casing. Explicitly document why we
        #currently prohibit this. The current logic here suffices, in any case.

        # Die if already declared unless the current user requests wrapping such
        # types with interactive aliases. In particular, replacing a declared
        # zsh alias or function with an interactive alias is largely senseless;
        # zsh aliases and functions may always be implemented to account for
        # interactivity (e.g., by calling is_shell_interactive() or interactively()),
        # thus obviating the need for interactive aliases in such cases. Since
        # silently replacing declared zsh aliases and functions seems an
        # inherently risky (and certainly useless) proposition, disallow it.
#       if   is "${alias_name_type}" == (builtin|reserved) si
#       then is -n "${ZESHY_IS_WRAPPING_BUILTINS-}" si or report_success
#       elif is "${alias_name_type}" == command si
#       then is -n "${ZESHY_IS_WRAPPING_COMMANDS-}" si or report_success
#       else :die\
#           "interactive alias \"${alias_name}\" already a defined ${alias_name_type}:\n$(which "${alias_name}")"
#       fi
#   }

    #FUXME: Shouldn't interactive aliases of real aliases be O.K., also? Hmm; no,
    #I suppose not! We don't call eval() in the function definition, and doing so
    #would introduce yet more bizarre edge-casing. Explicitly document why we
    #currently prohibit this. The current logic here suffices, in any case.

    #   and functions with interactive aliases is senseless, as the
    #   former may always be implemented to account for
    #   interactivity (e.g., by calling is_shell_interactive() or interactively()),
    #   thus obviating the need for interactive aliases in such cases. Since
    #   silently replacing declared zsh aliases and functions seems an
    #   inherently risky (and certainly useless) proposition, disallow it.

        #FUXME: Hmm; we can't print_message whether or not an alias is invalid without
        #expanding it to its expansion and then taking the name of 
    # Non-interactive logic to be performed by the function definition below.
#   if is -n "${alias_expansion_if_noncli}" si; then
#       alias_expansion_if_noncli+=' "${@}"'
#       alias_logic_if_noncli="
#   if :is_stdin_pipe
#   then run_code_with_stdin_piped ${alias_expansion_if_noncli}
#   else ${alias_expansion_if_noncli}
#   fi"
#   else alias_logic_if_noncli="die '\"${alias_name}\" and \"${command_name}\" are neither builtins or commands and hence cannot be called non-interactively'"
#   fi

    # Otherwise, such alias name is either an existing zsh function or has yet
    # to be declared. In the former case, we (optimistically) assume 
#FUXME: In the event of conflict with existing commands or builtins, it'd be
#great to
#FUXME: Excise this everywhere used. Since alias_cli() now integrates
#such functionality directly, we no longer require this at all.
# bool is_zeshy_wrapping_core_commands()
#
# Return true if the current user requests Zeshy wrap interactively run core
# commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#is_zeshy_wrapping_core_commands() {
#    (( # == 0 )) or :die 'no arguments expected'
#    [[ -n "${ZESHY_IS_WRAPPING_COMMANDS-}" ]]
#}

    # Die if the passed alias name is already a defined runnable.
#   is "$(whence -w "${alias_name}")" == *': '(alias|function) si and
#       :die "\"${alias_name}\" already defined as:\n$(which "${alias_name}")"
    # Return true if the current user requests Zeshy wrap interactively run core
    # commands (e.g., "cp", "grep", "ls") with Zeshy functions.
#   [[ -n "${ZESHY_IS_WRAPPING_CORE_COMMANDS-}" ]]

    #FUXME: Hmm; disabling the function makes piped calls such as:
    #cat /proc/cpuinfo|cat
    #...fail, which is clearly undesirable.
# void alias_cli_of_core_command(string alias_specification)
#
# Declare the passed specification as an interactive alias if .
# See alias_cli() for further details.
#alias_cli_of_core_command() {
#    is_zeshy_wrapping_core_commands and
#    alias_cli ls='list_path'
#}

# As a convenience, all argument aliases except die_unless_no_args() first
# attempt to read their argument from stdin when the caller passed no explicit
# argument. This implies all functions expanding these aliases implicitly "get"
# piped input support, which is nice.

# Make a string suitable for use as the right-hand side of a "die_unless_*"-
# specific alias statement. This string parses standard input into function
# parameters if such input exists (i.e., if another function piped input to
# this function) and the caller passed insufficient parameters.

#   print --\
#       '[[ -p /dev/stdin && ${#} -eq 0 ]] && '\
#       'set -- "${@}" "$(< /dev/stdin)"'"; (( ${1} )) || :die"
    # We can't quite recall why, but double quotes *MUST* be embedded in this
    # expression via "'" rather than the customary \".
#       "is -p /dev/stdin si and not (( ${1} )) and set -- "\

#       typeset command
#       if [[ -o interactive && \${#funcstack} -eq 1 ]]
#       then command=\"${(q)alias_expansion}\"
#       else command=\"${(q)alias_expansion_if_noncli}\"
#       fi
#       if :is_stdin_pipe
#       then run_code_with_stdin_piped \${command}
#       else                     \${command}
#       fi

#           if :is_stdin_pipe
#           then run_code_with_stdin_piped ${alias_expansion}
#           else ${alias_expansion}
#           fi
#       then ${alias_expansion}
#       else ${alias_expansion_if_not_interactive}
# bool is_stdout_terminal()
#
# Return true if shell :string.output is attached to a terminal device. Specifically,
# return true if the file descriptor for standard :string.output is open and attached to
# a terminal. (Avoid testing standard input, as commands passed piped input may
# still be "attached" to a terminal.) Do not implement this as a function, as a
# functions tests theirs rather than their callers' file descriptors.
#alias is_stdout_terminal='is -t ${ZESHY_STDOUT_FILE_DESCRIPTOR} si'

# bool is_terminal_color()
#
# Return true if the current shell is attached to a color-aware terminal device
# supporting at least the customary 8 colors (i.e., black, white, red, green,
# blue, yellow, magenta, and cyan).
#alias is_terminal_color='is_stdout_terminal and (( terminfo[colors] >= 8 ))'

#alias die_unless_no_args=die_if_args

# See Zeshy List and Map for functions returning lists and maps, respectively.
# Such functions are rather non-trivial and hence shifted there.

#FUXME: Reads a bit awkwardly, and superfulous. Supplant everywhere with
#"not is_args".

# void prepend_args(string arg1, string arg2, ...)
#
# Prepend the passed arguments to the beginning of the current argument list.
#alias prepend_args=':args.set "${@}"'

# Define critical command-specific aliases. Zeshy Process implements similar
# functionality as functions where not implementable here as aliases.
# Define critical boolean-specific aliases. Zeshy Shell implements similar
# functionality as functions where not implementable here as aliases.

    # * If such run throws an exception:
    #   * Catch such exception.
    #   * Reenable this function for subsequent use.
    #   * Rethrow such exception.
    # * Otherwise, reenable this function for subsequent use.

# * O.K.; I've become convinced the "global" global alias is harmful. Why?
#   Because it obfuscates manipulation of files named "global" at the command
#   line. Also, it's non-orthogonal with the ":alias_word" global. (Though,
#   technically the two convey completely different options.) In the future, we
#   should clearly minimize the number of global aliases.
# * Ah; I think I've devised a mechanism for accomplishing this sanely. Simply
#   define a function proclaim() (or some other synonym of declare(), but not
#   declare() as that's already a zsh builtin) aliased as:
#   alias map='proclaim map' 
#   alias string='proclaim string' 
#   And so forth. Then define proclaim() to parse the first argument as the type
#   to be declared, the last argument as the name to be declared, and all
#   intermediate arguments as human-readable options condensed to typeset
#   options: e.g., "map_global_export const set" expands to
#   "proclaim map_global_export const set", which eventually... ah, wait. No. That
#   obviously runs up against the classical eval issue, since the executed
#   typeset runs in the local context of proclaim(). *sigh*
# * Right, then. There's no recourse but to manually define the set of all
#   possible aliases: e.g., map_global, global_const_map, etc. For sanity, just
#   define the most commonly used types.
#FUXME: The word "arguments" should probably be truncated to "args", here.
#Rewriting "arguments" every function is slightly silly (and cumbersome).

#       or :die "neither \"${alias_name}\" or \"${alias_expansion_if_not_interactive}\" are builtins or commands"
#       alias_expansion_if_not_interactive="${alias_name}"

#   "${alias_expansion_if_not_interactive:c}" == /* or
#   if command_path="$(whence -cp "${command_name}")"; then
#   fi
#   
#   == *': function'
#   not whence -cp "${command_name}"; then
#   fi

    # If the builtin or command to be aliased does not exist, return with error.
    # To avoid costly exception handling on this frequently called helper
    # function, do not throw an exception.
#   if not whence "${command_name}" 1>/dev/null 2>&1; then
#       print_warning "\"${command_name}\" not a zsh builtin or command in \$PATH"
#       report_failure
#   fi

# void alias_cli_if_installed(string alias_specification)
#
# Declare the passed specification as an interactive alias only if the builtin
# or command to be aliased exists. This function is a no-nop if it does not.
#alias_cli_if_installed() {
#    FUXME: Rewrite. Only call alias_cli if the passed command is installed.
#    alias_cli "${@}" 1>/dev/null 2>&1 or true
#}

#   eval "function ${alias_name}() {
#   ${alias_expansion} "\${@}"
#}"
#}
#
#testem() {

#FUXME: No longer convinced these to be necessary. "(( VARNAME1 <= varname2 ))"
#reads much more sensibly than "is ${VARNAME1} deceeds_or_equals ${varname2} si". We
#should probably shift all instances of the latter to the former.
#:alias_word equals='-eq'
#:alias_word deceeds='-lt'
#:alias_word deceeds_or_equals='-le'
#:alias_word exceeds='-gt'
#:alias_word exceeds_or_equals='-ge'

# ....................{ DECLARATORS ~ modifiers            }....................
# Mark the declared variable as global (i.e., exported). By zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   list_global_export two_hunters; two_hunters=( "ktulu" "orion" )  # or...
#   local -Ax   two_hunters; two_hunters=( "ktulu" "orion" )  # equivalent!
#:alias_word global='-x'

# Mark the declared variable as constant (i.e., read-only). By zsh convention,
# this and the variable type are ordered opposite to C order: e.g.,
#
#   string const fwtbt="ride the lightning"  # or...
#   local -r     fwtbt="ride the lightning"  # equivalent!
#:alias_word const='-r'
