#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *shell script shebang lines* (i.e., `#!`-prefixed first lines of such
scripts).
/---

#FIXME: Convert getters to setters, eliminating the redundant "_shell" from such
#function names.

# ....................{ GETTERS                            }....................
declare_function_with_stdin <<'/---'
string get_zsh_shebang_line()

Get the canonical shebang line for `zsh` scripts: e.g.,

.get_zsh_shebang_line()
==========================================
[source]
------------------------------------------
>>> get_zsh_shebang_line
#!/usr/bin/env zsh
------------------------------------------
==========================================
/---
function get_zsh_shebang_line() {
    # Validate sanity.
    die_if_args

    # Absolute path of external command "env". By precedent, most *nix
    # distributions install the command under "/usr/bin". Nonetheless, recent
    # attempts to unify "/" and "/usr" within the FLOSS community (...their
    # names shall remain nameless: *cough* Poettering *cough*) suggest this may
    # not always be the case everywhere. Just cover our bases will belong, here.
    string env_path; env_path="$(get_pathable_path env)"
    :string.output "#!${env_path} zsh"
}

# ....................{ GETTERS ~ shebang                  }....................
declare_function_with_stdin <<'/---'
[stdout: string, status: bool] get_shell_script_shebang_line_if_found(
    string filename)

Get the first line of the passed shell script if such line is prefixed with `#!`
or return failure otherwise: e.g.,

.get_shell_script_shebang_line_if_found()
==========================================
[source]
------------------------------------------
>>> get_shell_script_shebang_line_if_found "/etc/zsh/zshrc"
#!/usr/bin/env zsh
------------------------------------------
==========================================
/---
function get_shell_script_shebang_line_if_found() {
    # Validate sanity. Avoid calling die_unless_shell_script(), which
    # transitively calls this function.
    die_unless_arg 'Expected one filename'
    string filename="${1}" shebang_line
    die_unless_file_text "${filename}"

    # If such file's first line is a shebang, get such line. For efficiency,
    # avoid splitting file contents into lines or copying such contents between
    # zeshy functions; rather, glob all characters up to but not including the
    # first newline of such contents. Dismantled, this is:
    #
    # * "(#b)", capturing the shebang line if matched to ${match[1]}.
    # * "\#!", matching the canonical shebang line prefix.
    # * "[^${ZESHY_ASCII_NEWLINE}]#", matching the remaining shebang line.
    :load_module_mapfile
    {
        if is "${mapfile[${filename}]}}" ==\
            (#b)(\#![^${ZESHY_ASCII_NEWLINE}]#)* si {
            return_string "${match[1]}"
        } else {
            report_failure
        }
    # Happily, zsh correctly evaluates "always" blocks prior to returning.
    } always {
        :unload_module_mapfile
    }
}

#FIXME: Refactor into :set_string_to_script_shebang_command_if_found().
declare_function_with_stdin <<'/---'
[stdout: string, status: bool]
    get_shell_script_shebang_command_name_if_found(string filename)

Get the command name of the shebang line in the passed shell script if such
script contains such a line or return failure otherwise. Specifically:

* If the first word of such line is either `/bin/env` or `/usr/bin/env`, the
  command name is the second word of such line (e.g., the `mercy` in
  `#!/usr/bin/env mercy fields`).
* Else, the command name is the basename of the first word of such line (e.g.,
  the `nephilim` in `#!/bin/nephilim sisters`).

For example:

.get_shell_script_shebang_command_name_if_found()
==========================================
[source]
------------------------------------------
>>> get_shell_script_shebang_command_name_if_found "/etc/zsh/zshrc"
zsh
------------------------------------------
==========================================
/---
function get_shell_script_shebang_command_name_if_found() {
    # Validate sanity.
    die_unless_arg 'Expected one filename.'
    string shebang_line

    # If such script contains a shebang line, get such line's command name.
    # Since this function is transitively called before the remainder of the
    # zeshy codebase, avoid calling conventional zeshy functions (e.g.,
    # :string.output(), get_path_basename()).
    if { shebang_line="$(get_shell_script_shebang_line_if_found "${1}")" } {
        # Split such shebang line into words, ignoring the canonical shebang
        # line prefix (i.e., "#!").
        :list shebang_words
        set_list_to_string_words shebang_words "${shebang_line[3,-1]}"

        # Get the basename of the first such word.
        :string command_name
        command_name="$(get_path_basename "${shebang_words[1]}")"

        # If such basename is "env", the command name is the following word.
        if :is "${command_name}" == 'env' :si {
            return_string "${shebang_words[2]}"
        # Otherwise, such basename is the command name.
        } else {
            return_string "${command_name}"
        }
    } else {
        report_failure
    }
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void :set_string_to_zsh_shebang_line(string string_name)

Set the passed string variable to the canonical shebang line for `zsh` scripts
on the current system (e.g., `#!/usr/bin/env zsh`).
/---
function :set_string_to_zsh_shebang_line() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :string string_name__sstzsl="${1}" env_path__sstzsl

    #FIXME: Horrible. Eliminate subshells!

    # Absolute path of external command "env". By precedent, most *nix
    # distributions install the command under "/usr/bin". Nonetheless, recent
    # attempts to unify "/" and "/usr" within the FLOSS community (...their
    # names shall remain nameless: *cough* Poettering *cough*) suggest this may
    # not always be the case everywhere. Just cover our bases will belong, here.
    env_path__sstzsl="$(get_pathable_path env)"

    # Set such string.
    :string.set "${string_name__sstzsl}" "#!${env_path__sstzsl} zsh"
}

# --------------------( WASTELANDS                         )--------------------
#   if run_code_with_mapfile: "is \"\${mapfile[\${filename}]}}\" ==\
#       (#b)(\#![^${ZESHY_ASCII_NEWLINE}]#)* si"
#   then :string.output "${match[1]}"
#   else report_failure
#   fi
