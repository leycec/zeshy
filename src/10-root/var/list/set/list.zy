#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *list-based list setters* (i.e., functions setting list variables to the
contents of other list variables).
/---

#FIXME: Most (if not all) inefficient calls to builtin eval() below can be
#replaced by efficient calls to builtin set(): e.g.,
#
#    set -A "${list_name__sltl}" "${@}"
#
#Interestingly, there even exists a variant of the above suitable for setting
#arbitrarily large slices rooted at the *FIRST* element of such array:
#
#    "If +A is used and NAME is an array, the given arguments will
#     replace the initial elements of that array."
#
#Somewhat bizarre, but we could doubtless leverage that *SOMEWHERE*.
#FIXME: Likewise, we believe we've uncovered a technique for dynamically
#setting arbitrary single list items. Note the implementation of
#:set_map_key_to_string(). Now, if we just take that implementation and set and
#change the "key" to be set to the list index one past the current last list
#item, we've effectively implemented a dynamic list appending without eval().
#Nice, eh?

# ....................{ SETTERS                            }....................
#FIXME: Rename to :list.set_to_expansion().
#FIXME: *WAIT*. No need to use coprocesses at all -- which is great, as
#coprocesses are fairly hideous. Just do the following:
#
#* Perform such list assignment in the current shell.
#* If such assignment fails:
#  * Perform such list assignment in a subshell, capturing standard error from
#    such subshell into a string local.
#  * If such string local is nonempty, throw an exception with such standard
#    error.
#  * Else, ignore such list assignment failure. Probably a non-fatal path glob
#    warning (e.g., due to the current user having insufficient permissions to
#    access subdirectories on recursive globbing).
#FIXME: Great example, but somewhat ludicrously long. Split in twain, and shift
#half of it elsewhere.

:func.doc <<'/---'
:void :List.eval(^:list list_name, :str code)

Set the passed list to the dynamic expansion of the passed code in a *list
context* (i.e., as `( ${code} )`): e.g.,

.:List.eval()
==========================================
[source]
------------------------------------------
>>> :list on_struggle=(
...     "To grasp the full enormity of our deterioration, however, consider the"
...     "earliest condition of humanity, without government or property, when we"
...     "wandered as hunter-gatherers. Hobbes surmised that life was then nasty,"
...     "brutish and short. Others assume that life was a desperate unremitting"
...     "struggle for subsistence, a war waged against a harsh Nature with death"
...     "and disaster awaiting the unlucky or anyone who was unequal to the"
...     "challenge of the struggle for existence. Actually, that was all a"
...     "projection of fears for the collapse of government authority over"
...     "communities unaccustomed to doing without it, like the England of
...     "Hobbes during the Civil War. Hobbes' compatriots had already"
...     "encountered alternative forms of society which illustrated other ways"
...     "of life – in North America, particularly – but already these were too"
...     "remote from their experience to be understandable. (The lower orders,"
...     "closer to the condition of the Indians, understood it better and often"
...     "found it attractive. Throughout the seventeenth century, English"
...     "settlers defected to Indian tribes or, captured in war, refused to"
...     "return. But the Indians no more defected to white settlements than"
...     "Germans climb the Berlin Wall from the west.) The \"survival of the"
...     "fittest\" version – the Thomas Huxley version – of Darwinism was a"
...     "better account of economic conditions in Victorian England than it was"
...     "of natural selection, as the anarchist Kropotkin showed in his book"
...     "Mutual Aid, A Factor of Evolution. (Kropotkin was a scientist – a"
...     "geographer – who'd had ample involuntary opportunity for fieldwork"
...     "whilst exiled in Siberia: he knew what he was talking about.) Like most"
...     "social and political theory, the story Hobbes and his successors told"
...     "was really unacknowledged autobiography." )
>>> :List.eval on_struggle "'\"'${^on_struggle}'...\"'"
>>> :stdout.echo "${on_struggle[1]}"
"To grasp the full enormity of our deterioration, however, consider the..."
------------------------------------------
==========================================
/---
function :List.eval() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one list operation.'
    :str list_name__slte="${1}" list_operation__slte="${2}" stderr__slte
    :List.die_unless "${list_name__slte}"
    die_unless_string_nonempty "${list_operation__slte}"\
        'Expected nonempty list operation.'

    # Set such list. Since such setting tends to return spurious non-zero exit
    # status (e.g., if any globbed path is not readable by the current user),
    # ignore the resulting status. Moreover, since such setting fails to return
    # non-zero exit status on genuine error (e.g., invalid glob qualifiers),
    # capture standard error into a string local to be subsequently tested.
#   :stdout.echo "setting ${list_name__slte}:catch( ${list_operation__slte} ) or :=failure.ignore"
#   eval ${list_name__slte}'=( '${list_operation__slte}' ) or :=failure.ignore'
    :run_code_silent_and_set_string_to_stderr_by_coprocess\
        '{ '${list_name__slte}'=( '${list_operation__slte}' ) } :=failure.ignore'\
        stderr__slte
#   print "${list_name__slte}: ${list_name__slte[*]}\nstderr: ${stderr__slte}"

    # If an error was output, throw an exception given such error.
    if { :str.is_nonempty "${stderr__slte}" } {
        # If such error is prefixed by "zsh: ", remove such prefix.
        :Str.remove_prefix stderr__slte 'zsh: '
        :die 'List assignment "'${list_name__slte}'=( '${list_operation__slte}')" invalid:'${ZY_ASCII_NEWLINE}${stderr__slte}
    }
}

# ....................{ SETTERS ~ list                     }....................
#FIXME: Rename to :list.set().
#FIXME: Refactor to accept multiple source list names, implemented by simply
#appending all such source lists in the passed order.
#FIXME: Overly long example. Split!

:func.doc <<'/---'
:void set_list_to_list(^:list target_list_name, ^:list source_list_name)

Set the passed target to the passed source list (i.e., copy the latter into the
former): e.g.,

.set_list_to_list()
==========================================
[source]
------------------------------------------
>>> :list on_venality on_richard_nixon; on_richard_nixon=(
...    "What we are looking at on all our TV sets is a man who finally, after"
...    "24 years of frenzied effort, became the President of the United States"
...    "with a personal salary of $200,000 a year and an unlimited expense"
...    "account including a fleet of private helicopters, jetliners, armored"
...    "cars, personal mansions and estates on both coasts and control over a"
...    "budget beyond the wildest dream of King Midas... and all the dumb"
...    "bastard can show us, after five years of total freedom to do anything"
...    "he wants with all this power, is a shattered national economy,"
...    "disastrous defeat in a war we could have ended four years ago on far"
...    "better terms than he finally came around to, and a hand-picked personal"
...    "staff put together through five years of screening, whose collective"
...    "criminal record will blow the minds of high-school American History"
...    "students for the next 100 years. Nixon's hand-picked Vice President is"
...    "about to be indicted for Extortion and Bribery; his former campaign"
...    "manager and his former Secretary of Commerce & personal fund-raiser"
...    "have already been indicted for Perjury, two of his ranking campaign"
...    "managers have already pleaded guilty to Obstruction of Justice, the"
...    "White House counsel is headed for prison on more felony counts than I"
...    "have room to list here, and before the trials are finished..." )
>>> set_list_to_list on_presidential_pardons on_richard_nixon
>>> :stdout.echo "${on_venality[1]}"
What we are looking at on all our TV sets is a man who finally, after
------------------------------------------
==========================================
/---
function set_list_to_list() {
    # Validate sanity.
    die_unless_args_2 'Expected one target list name and one source list name.'
    :str list_name_target__sltl="${1}" list_name_source__sltl="${2}"
    :List.die_unless "${list_name_target__sltl}" "${list_name_source__sltl}"

    # Copy such list.
    eval ${list_name_target__sltl}'=( "${'${list_name_source__sltl}'[@]}" )'
}

#FIXME: Rename to :list.set_reversed().

:func.doc <<'/---'
:void set_list_to_list_reversed(
    ^:list target_list_name, ^:list source_list_name)

Set the passed target list to the *reverse* of the passed source list (i.e., to
all list items of the passed source list in the reverse order): e.g.,

.set_list_to_list_reversed()
==========================================
[source]
------------------------------------------
>>> :list politizane politizane_reversed
>>> politizane=( wealth inequality in america )
>>> set_list_to_list_reversed politizane_reversed politizane
>>> :stdout.echo "${politizane_reversed}"
america in inequality wealth
------------------------------------------
==========================================
/---
function set_list_to_list_reversed() {
    # Validate sanity.
    die_unless_args_2 'Expected one target list name and one source list name.'
    :str list_name_target__sltlr="${1}" list_name_source__sltlr="${2}"
    :List.die_unless "${list_name_target__sltlr}" "${list_name_source__sltlr}"

    # Reverse such list. Dismantled, this is:
    #
    # * "@P", expanding the source list.
    # * "Oa", reversing the order of list expansion.
    eval ${list_name_target__sltlr}'=( "${(Oa@P)list_name_source__sltlr}" )'
}

# ....................{ SETTERS ~ list : set               }....................
#FIXME: Rename to :list.set_difference().

:func.doc <<'/---'
:void set_list_to_list_difference(
    ^:list target_list_name,
    ^:list source_left_list_name, ^:list source_right_list_name)

Difference the second and third passed lists into the first. Formally, perform
the asymmetric set difference
`target_list = source_left_list - source_right_list`: e.g.,

.set_list_to_list_difference()
==========================================
[source]
------------------------------------------
>>> list a
>>> list y; y=( slimy things did crawl with legs )
>>> list e; e=( upon the slimy sea )
>>> set_list_to_list_difference a y e
>>> :stdout.echo "${a[@]}"
things did crawl with legs
------------------------------------------
==========================================
/---
function set_list_to_list_difference() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one target list name and two source list names.'
    :str\
        list_name_target__sltld="${1}"\
        list_name_left__sltld="${2}"\
        list_name_right__sltld="${3}"
    :List.die_unless\
        "${list_name_target__sltld}"\
        "${list_name_left__sltld}"\
        "${list_name_right__sltld}"

    # Difference such lists. Bless your pithy soul, zsh 5.x.x.
    eval ${list_name_target__sltld}'=(
        ${'${list_name_left__sltld}'[@]:|'${list_name_right__sltld}'} )'
}

#FIXME: Rename to :List.Intersection().
:func.doc <<'/---'
:void set_list_to_list_intersection(
    :List target_list_name
    :List source_list_name
    +:List source_list_names)

Set the passed target list to the intersection of the passed source lists, in
arbitrary order.

Specifically, set this target list to the first source list and for each
additional source list, eliminate all elements from the target list not in this
source list. This intersection is symmetric and hence performed in arbitrary
order. At least two source lists must be passed: e.g.,

.set_list_to_list_intersection()
==========================================
[source]
------------------------------------------
>>> :list a
>>> :list y; y=( slimy things did crawl with legs )
>>> :list e; e=( upon the slimy sea )
>>> :list h; a=( and a thousand thousand slimy things )
>>> set_list_to_list_intersection a y e h
>>> print "${h[@]}"
slimy
------------------------------------------
==========================================
/---
function set_list_to_list_intersection() {
    # Validate sanity, popping the last such argument off as the
    # target list name. Hence, all remaining arguments are source list names.
    die_unless_args_3_or_more\
        'Expected one target list name and two or more source list names.'
    :str\
        list_name_target__sltli="${@[1]}"\
        list_name_source1__sltli="${@[2]}"\
        list_name_source2__sltli="${@[3]}"
    :List.die_unless\
        "${list_name_target__sltli}"\
        "${list_name_source1__sltli}"\
        "${list_name_source2__sltli}"
    :args.shift 3

    # Intersect the first two source lists into the target list.
    eval ${list_name_target__sltli}'=(
        ${'${list_name_source1__sltli}'[@]:*'${list_name_source2__sltli}'} )'

    # Intersect each remaining source list with the target list back into the
    # target list. Bless your extreme utility, zsh 5.x.x.
    :str list_name_source__sltli
    for  list_name_source__sltli ("${@}") {
        :List.die_unless "${list_name_source__sltli}"
        eval ${list_name_target__sltli}'=(
            ${'${list_name_source__sltli}'[@]:*'${list_name_target__sltli}'} )'
    }
}
