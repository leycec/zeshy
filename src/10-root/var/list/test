#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *list testers* (i.e., functions testing lists).
/---

# ....................{ EXCEPTIONS                         }....................
:func.doc <<'/---'
void die_unless_list_nonempty(
    string list_name,
    string error_message = "List \${${list_name}} empty.")

Throw an exception with the passed message unless the passed list is nonempty.
See is_list_nonempty() for further details.
/---
function die_unless_list_nonempty() {
    die_unless_args_1_to_2\
        'Expected one list name and optional error message.'
    :str list_name__duln="${1}"
    is_list_nonempty "${list_name__duln}" or
        :die "${2-List \${${list_name__duln}} empty.}"
}

# ....................{ EXCEPTION ~ index                  }....................
:func.doc <<'/---'
void die_unless_list_index(
    string list_name,
    int index,
    string error_message = "List \$\{${list_name}\} index ${index} invalid.")

Throw an exception with the passed message unless the passed integer indexes the
passed list. See is_list_index() for further details.
/---
function die_unless_list_index() {
    # Validate sanity.
    die_unless_args_2_to_3\
        'Expected one list name, one index, and optional error message.'

    # Test such index.
    is_list_index "${@[1,2]}" or {
        :str list_name__duli="${1}" index__duli="${2}"
        :int size__duli
        :set_int_to_list_size size__duli "${list_name__duli}"
        :die "${3-List \$\{${list_name__duli}\} index ${index__duli} not in [-${size__duli}, ${size__duli}].}"
    }
}

:func.doc <<'/---'
void die_unless_list_range(
    string list_name,
    int start_index,
    int end_index,
    string error_message = "List \$\{${list_name}\} start index ${index_start__dulr} and end index ${index_end__dulr}] not in [-${size__dulr}, ${size__dulr}].")

Throw an exception with the passed message unless the passed integers
constitute a valid range of indices in the passed list. See is_list_range() for
further details.
/---
function die_unless_list_range() {
    # Validate sanity.
    die_unless_args_3_to_4\
        'Expected one list name, one start index, one end index, and optional error message.'

    # Test such range.
    is_list_range "${@[1,3]}" or {
        :str\
            list_name__dulr="${1}"\
            index_start__dulr="${2}"\
            index_end__dulr="${3}"
        :int size__dulr
        :set_int_to_list_size size__dulr "${list_name__dulr}"
        :die "${4-List \$\{${list_name__dulr}\} start index ${index_start__dulr} and end index ${index_end__dulr}] not in [-${size__dulr}, ${size__dulr}].}"
    }
}

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status: bool] {is_list_item, is_list_contains}(
    string list_name, string item)

Report success if the passed list contains the passed element: e.g.,

.is_list_item()
==========================================
[source]
------------------------------------------
>>> :list on_relaxation; on_relaxation=(
...     "From the pragmatic standpoint of our culture, such an attitude [of"
...     "luxurious relaxation] is very bad for business. It might lead to"
...     "improvidence, lack of foresight, diminished sales of insurance"
...     "policies, and abandoned savings accounts. Yet this is just the"
...     "corrective that our culture needs. No one is more fatuously"
...     "impractical than the \"successful\" executive who spends his whole"
...     "life absorbed in frantic paper work with the objective of retiring in"
...     "comfort at sixty-five, when it will all be too late. Only those who"
...     "have cultivated the art of living completely in the present have any"
...     "use for making plans for the future, for when the plans mature they"
...     "will be able to enjoy the results. \"Tomorrow never comes.\" I have"
...     "never yet heard a preacher urging his congregation to practice that"
...     "section of the Sermon on the Mount which begins, \"Be not anxious for"
...     "the morrow....\" The truth is that people who live for the future are,"
...     "as we say of the insane, \"not quite all there\" â€“ or here: by over-
...     "eagerness they are perpetually missing the point. Foresight is bought"
...     "at the price of anxiety, and when overused it destroys all its own"
...     "advantages." )
>>> is_list_item on_relaxation "advantanges." and :stdout.echo\
...     "Imagination, not intelligence, made us human."
Imagination, not intelligence, made us human.
------------------------------------------
==========================================
/---
function is_list_item is_list_contains() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one list element.'
    :str list_name__ili="${1}"
    :int list_size__ili

    # Size of such list.
    :set_int_to_list_size list_size__ili "${list_name__ili}"

    # Test such list. Dismantled, this is:
    #
    # * "(@P)", expanding to such list.
    # * "([(ie)...]", expanding to the first 1-based list index containing such
    #   element or the size of such list if *NOT* containing such element.
    #
    # While there exist numerous means of finding list elements, the approach
    # below arguably remains the most reliably efficient. Alternatives include:
    #
    # * Manually iterating such list. Naturally, this is the slowest.
    # * "is -n ${(M)${(@P)list_name__ili}:#${2}\} si". While faster than manual
    #   iteration, such test cannot distinguish between a nonextant element and
    #   an extent element expanding to the empty string and hence is unreliable
    #   in the general case.
    # * "eval '(( ${+'${list_name__ili}'[${2}]} ))'. Such test distinguishes
    #   between a nonextant element and an extent element expanding to the empty
    #   string. Nonetheless, while faster than manual iteration and more
    #   reliable than the prior technique, the cost of the eval() undermines the
    #   optimality of such technique.
    (( ${${(@P)list_name__ili}[(ie)${2}]} <= list_size__ili ))
}

#FIXME: In lieu of unit tests...
#function ico() {
#    list z; z=( hmm 'o eu' 3434 67 )
#    is_list_contains z 'o eu' and print 'z contains "o eu"'
#}

# ....................{ TESTERS ~ emptiness                }....................
:func.doc <<'/---'
[status: bool] is_list_empty(string list_name)

Report success if the passed list is empty.
/---
function is_list_empty() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    :str list_name__ile="${1}"
    :int list_size__ile

    # Size of such list.
    :set_int_to_list_size list_size__ile "${list_name__ile}"

    # Test such size.
    (( list_size__ile == 0 ))
}

:func.doc <<'/---'
[status: bool] is_list_nonempty(string variable_name)

Report success if the passed list is nonempty.
/---
function is_list_nonempty() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    :str list_name__iln="${1}"
    :int list_size__iln

    # Size of such list.
    :set_int_to_list_size list_size__iln "${list_name__iln}"

    # Test such size.
    (( list_size__iln ))
}

# ....................{ TESTERS ~ index                    }....................
:func.doc <<'/---'
[status: bool] is_list_index(string list_name, int index)

Report success if the passed index is a non-zero integer bounded by either
`[-N, -1]` or `[1, N]`, where N is the size of the passed list: e.g.,

.is_list_index()
==========================================
[source]
------------------------------------------
>>> :list poe; poe=( masque of the red death )
>>> is_list_index poe -6 and :stdout.echo\
...     "Each man creates his own God for himself,"
Each man creates his own God for himself,
>>> is_list_index poe  0 or :stdout.echo\
...     "He is not my master. Death has no master."
He is not my master. Death has no master.
------------------------------------------
==========================================
/---
function is_list_index() {
    # Validate sanity.
    die_unless_args_2 'Expected one list name and one index.'
    :str list_name__ili="${1}" index__ili="${2}"
    :int list_size__ili
    :int.die_unless_nonzero "${index__ili}"

    # Size of such list.
    :set_int_to_list_size list_size__ili "${list_name__ili}"

    # Test such index. Since lists accept negative indices *AND* since
    # :int.">=<"() only considers positive indices, implement such test
    # manually rather than deferring to such function.
    (( (1 <= index__ili && index__ili <= list_size__ili) ||
       (-list_size__ili <= index__ili && index__ili <= -1) ))
}

:func.doc <<'/---'
[status: bool] is_list_range(
    string list_name, int start_index, int end_index)

Report success if the passed indices index the passed list and the first such
index is less than or equal to the second such index. To quantify such
conditions:

* Let `N` be the size of the passed list.
* Let `X` be the first passed index.
* Let `Y` be the second passed index.
* If `X > 0`, let `X\' = X`; else, let `X\' = N + X + 1`.
* If `Y > 0`, let `Y\' = Y`; else, let `Y\' = N + Y + 1`.

Then this function returns success only if the following conditions all hold:

* `1 <= X\'`.
* `X\' <= Y\'`.
* `Y\' <= N`.

For example:

.is_list_range()
==========================================
[source]
------------------------------------------
>>> list on_birthright=(
...     "If I should sell both my forenoons and afternoons to society, as most"
...     "appear to do, I am sure that for me there would be nothing left worth"
...     "living for. I trust that I shall never thus sell my birthright for a"
...     "mess of pottage. I wish to suggest that a man may be very industrious,"
...     "and yet not spend his time well. There is no more fatal blunderer than
...     "he who consumes the greater part of his life getting his living." )
>>> is_list_range on_birthright -4 5 and
...     :stdout.echo "You must get your living by loving."
You must get your living by loving.
>>> is_list_range on_birthright 4 -5 or
...     :stdout.echo "Read not the Times. Read the Eternities."
Read not the Times. Read the Eternities.
------------------------------------------
==========================================
/---
function is_list_range() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one list name, one start index, and one end index.'
    :str\
        list_name__ilr="${1}" start_index__ilr="${2}" end_index__ilr="${3}"
    :int list_size__ilr
    :int.die_unless_nonzero "${start_index__ilr}"
    :int.die_unless_nonzero "${end_index__ilr}"

    # Size of such list.
    :set_int_to_list_size list_size__ilr "${list_name__ilr}"

    # Convert negative to positive indices.
    if (( start_index__ilr < 0 )) {
        start_index__ilr=$(( list_size__ilr + start_index__ilr + 1 ))
    }
    if (( end_index__ilr < 0 )) {
        end_index__ilr=$(( list_size__ilr + end_index__ilr + 1 ))
    }
#   print "start index: ${start_index__ilr}\nend index: ${end_index__ilr}\nlist size: ${list_size__ilr}"
#   (( 1 <= start_index__ilr ))              and print "1 <= ${start_index__ilr}"
#   (( start_index__ilr <= end_index__ilr )) and print "${start_index__ilr} <= ${end_index__ilr}"
#   (( end_index__ilr <= list_size__ilr ))

    # Test such indices. For efficiency, avoid calling :int.">=<"().
    (( 1 <= start_index__ilr &&\
            start_index__ilr <= end_index__ilr &&\
                                end_index__ilr <= list_size__ilr ))
}

# --------------------( WASTELANDS                         )--------------------
 # For efficiency, inline such test. See
    # get_list_size() for further details.
    # (( ${#${(@P)list_name__ile}} == 0 ))

    # * "${#...}", expanding to the size of such list. For efficiency, inline
    #   such operation. See get_list_size() for further details.
# See parcel "variable/type" for :List.die_unless().

#:func.doc <<'/---'
#void :List.die_unless(string list_name1, ...)
#
#Throw an exception with a stock message unless the passed lists all exist.
#/---
#function :List.die_unless() {
#    # Validate sanity.
#    die_unless_args 'Expected one or more variable names.'
#
#    #FUXME: Ugh. While this works, it's rather inefficient. Consider optimizing.
#    # Test such variables.
#    string list_name__duls
#    for    list_name__duls ("${@}") {
#        :List.die_unless "${list_name__duls}"
#    }
#}

# ....................{ EXCEPTION ~ size                   }....................
#FUXME: *WAY* too specific. Generalize to just accept the desired list size as a
#passed parameter and rename to die_unless_list_size_at_least().
#:func.doc <<'/---'
#void die_unless_list_size_2_or_more(
#    string list_name,
#    string error_message =
#        "List \${${list_name}} contains $(get_list_size "${list_name}") rather than 2 or more elements.")
#
#Throw an exception with the passed message unless the passed list contains at
#least two elements.
#/---
#function die_unless_list_size_2_or_more() {
#    # Validate sanity.
#    die_unless_args_1_to_2 'Expected one list name and optional error message.'
#    string  list_name__duls="${1}"
#    integer list_size__duls
#
#    # Size of such list.
#    list_size__duls="$(get_list_size "${list_name__duls}")"
#
#    # Test such size.
#    if (( list_size__duls < 2 )) {
#        :die "${2:-List \${${list_name__duls}} contains ${list_size__duls} rather than 2 or more elements.}"
#    }
#}

    # Dismantled, this is:
    #
    # * "(@P)", expanding to such list.
    # * "([(ie)...]", expanding to the first 1-based list index containing such
    #   element or the size of such list if *NOT* containing such element.
    # * "${#...}", expanding to the size of such list. For efficiency, inline
    #   such operation. See get_list_size() for further details.
    #
    # While there exist alternative methods for finding list elements, this is
    # arguably the most reliable and efficient. Alternatives include:
    #
    # * Manually iterating such list. Naturally, this is the slowest.
    # * Testing "is -n ${(M)${(@P)list_name__ile}:#${2}\} si". While faster than
    #   manual iteration, such test cannot distinguish between a nonextant
    #   element and an extent element expanding to the empty string. Such
    #   test is unreliable in the general case.

    #FUXME: Not necessarily convinced this to be the most efficient method.
    #Shouldn't the following also suffice - possibly more efficient?
    #
    #    (( ${${(@P)list_name__ile}[(ie)${2}]} <= $(get_list_size "${list_name__ile}") ))
    #FUXME: This is extendable into an is_list_contains_match() function
    #by simple expanding ${2} as ${~2} here. Add to "glob", however; not here.
    #Actually... the two should be together, wherever they reside, due to the
    #complexity of implementation. "glob" would be an appropriate destination,
    #I should think.

    # Find such element. Dismantled, this is:
    #
    # * '@P', expanding to such list.
    # * "${(M)...:#...}", excluding all but such element.
    #
    # Do *NOT* double-quote this parameter expansion. Doing so *ALWAYS* results
    # in the empty string and hence failure. (This is inordinantly odd, but...)
    # As double-quoting is right out, calling is_string_nonempty() is also out.
    # (Unquoted parameters expanding to the empty string expand to no argument,
    # thus inducing is_string_nonempty() to throw an exception.)
#   print "list element matched: ${(M)${(@P)list_name__ile}:#${2}\}"
#   is -n ${(M)${(@P)list_name__ile}:#${2}\} si
#FUXME: Shift to new component "variable/list/index".
