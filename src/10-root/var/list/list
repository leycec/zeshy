#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *lists* (i.e., sequential arrays).
/---

#FIXME: Incorporate set operations from:
#   http://www.catonmat.net/blog/set-operations-in-unix-shell

# ....................{ ADDERS                             }....................
:func.doc <<'/---'
void prepend_list(string list_name, string text1, ...)

Concatenate the passed strings into a new list element prepended to the start of
the passed list: e.g.,

.prepend_list()
==========================================
[source]
------------------------------------------
>>> list on_ego_driven_cleverness; on_ego_driven_cleverness=(
...    "This is where we are at right now, as a whole. No one is left out of"
...    "the loop. We are experiencing a reality based on a thin veneer of lies"
...    "and illusions. A world where greed is our God and wisdom is sin, where"
...    "division is key and unity is fantasy, where the ego-driven cleverness"
...    "of the mind is praised, rather than the intelligence of the heart." )
>>> prepend_list on_ego_driven_cleverness\
...    "Watching television is like taking black spray paint to your third eye."
>>> get_list_head on_ego_driven_cleverness
Watching television is like taking black spray paint to your third eye.
------------------------------------------
==========================================
/---
function prepend_list() {
    # Validate sanity.
    die_unless_args_2_or_more 'Expected one list name and one or more strings.'
    string list_name__pl="${1}"
    :List.die_unless "${list_name__pl}"
    shift_arg

    # Prepend such list.
    eval ${list_name__pl}'=( "${@}" "${(@P)list_name__pl}}" )'
}

:func.doc <<'/---'
void append_list(string list_name, string text1, ...)

Concatenate the passed strings into a new list element appended to the end of
the passed list: e.g.,

.append_list()
==========================================
[source]
------------------------------------------
>>> list on_the_land_of_freedom; on_the_land_of_freedom=(
...    "Go back to bed, America. Your government has figured out how it all"
...    "transpired. Go back to bed, America. Your government is in control"
...    "again. Here. Here's American Gladiators. Watch this. Shut up. Go back"
...    "to bed, America. Here is American Gladiators. Here is 56 channels of"
...    "it! Watch these pituitary retards bang their fucking skulls together"
...    "and congratulate you on living in the land of freedom. Here you go,"
...    "America! You are free to do what we tell you. You are free to do what"
...    "we tell you." )
>>> append_list on_the_land_of_freedom\
...     "Eternal suffering awaits anyone who questions god's infinite love."
>>> get_list_tail on_the_land_of_freedom
Eternal suffering awaits anyone who questions god's infinite love.
------------------------------------------
==========================================
/---
function append_list() {
    # Validate sanity.
    die_unless_args_2_or_more 'Expected one list name and one or more strings.'
    string list_name__al="${1}"
    :List.die_unless "${list_name__al}"

    # Append such list.
    eval ${list_name__al}'+=( "${@}" )'
}

# ....................{ PRINTERS                           }....................
:func.doc <<'/---'
string print_list(string list_name)

Print the passed list in human-readable format.
/---
function print_list() {
    # Validate sanity.
    die_unless_arg 'Expected one list name.'
    string list_name__pl="${1}"
    integer index__pl list_size__pl
    :List.die_unless "${list_name__pl}"

    # Size of such list. To properly handle call stack lists (e.g.,
    # ${funcstack}), inline such implementation. See get_list_size() for further
    # details.
    list_size__pl="${#${(@P)list_name__pl}}"

    #FIXME: Colorize such list using ${ZY_STYLE_TO_COLORS}. Not terribly hard...
    #FIXME: Indices should be aligned into a numerically padded column: e.g.,
    #
    #00: ...
    #01: ...
    #02: ...
    #  .
    #  .
    #  .
    #10: ...

    {
        # Announce such list.
        print_message_heading "List \${${list_name__pl}}"

        # Print such list.
        for (( index__pl = 1; index__pl <= list_size__pl; index__pl++ )) {
            :stdout.echo "${index__pl}: ${${(@P)list_name__pl}[${index__pl}]}"
        }
    } | page_stdin
}

# --------------------( WASTELANDS                         )--------------------
# list_size__pl="$(get_list_size "${list_name__pl}")"
    # Update standard output tracking in preparation for subsequent handling.
#   :print_stdout_separated_stop

#FUXME: Generalize a new remove_list_items_in_range() function given the
#implementations below. Not terribly hard, just need to get around to it!
#   eval "${list_name__bl}:catch( \"\${${list_name__bl}[2,-1]}\" )"
# ....................{ CHECKERS                           }....................
#FUXME: Honestly, this is functionally useless as defined. We really want two
#separate functions, I should think:
#
#* die_unless_list_indices(), basically just check_list_args() renamed.
#* die_unless_list_index(), accepting and testing just one index.
#
#Also, accepting index names rather than values is simply odd; there doesn't
#appear to be any reasonable justification for this in the code, so just revert
#to proper values. That also dramatically simplifies the implementation.
#Honestly, sometimes... I don't even know. I mean,
#is_list_indices() can basically be implemented in terms of
#is_list_index(), which simplifies things even further.

#:func.doc <<'/---'
#void check_list_args(
#  string list_name, string start_index_name, string end_index_name)
#
#Check the passed list-centric variables for sanity and, if sane, set such
#variables to sensible defaults. Specifically:
#
#* Throw an exception if no list with the passed name exists.
#* Throw an exception if the variable with the passed start index is empty but
#  the variable with the passed end index is not.
#* If both the variables with the passed start and end indices are empty,
#  default the former to "1" (i.e., the first list index) and the latter to
#  "-1" (i.e., the last list index). Such indices thus span the entire list.
#* If only the variable with the passed end index is empty, default such
#  variable to the same value as that of the passed start index. Such indices
#  thus span the single list element for the passed start index.
#* Throw an exception if the variables with such start and end indices are not
#  non-zero integers bounded by [-list_size, list_size].
#* Throw an exception if the start index is greater than the end index.
#
#In short, this function guarantees bounded list indices.
#/---
#function check_list_args() {
#    # Validate sanity, intentionally obfuscating local variable names to avoid
#    # unintentionally masking caller list names.
#    die_unless_args_1_to_3\
#        'expected one list name, one start index name, and one end index name'
#    string\
#        __list_name__="${1}" __list_size__ __beg_index__ __end_index__\
#        __beg_index_name__="${2}" __end_index_name__="${3}"\
#    __list_size__="$(get__list_size "${__list_name__}")"
#
#    # Default indices.
#    if is_string_empty "${__beg_index_name__}"; then
#        die_if_nonempty_variable "${__end_index_name__}"\
#            "start index \"${__beg_index_name__}\" empty but end index \"${__end_index_name__}\" non-empty"
#        __beg_index__=1
#        __end_index__=${__list_size__}
#    elif is_string_empty "${__end_index_name__}"; then
#        __beg_index__=${(P)__beg_index_name__}
#        __end_index__=${__beg_index__}
#    else
#        __beg_index__=${(P)__beg_index_name__}
#        __end_index__=${(P)__end_index_name__}
#    fi
#    :int.die_unless "${__beg_index__}"
#    :int.die_unless "${__end_index__}"
#
#    # Validate indices, converting negative to positive indices to simplify
#    # comparison. Preserve original indices for pretty printing.
#    integer _new_beg_index__=${__beg_index__} _new_end_index__=${__end_index__}
#    (( _new_beg_index__ > 0 )) or (( _new_beg_index__ += __list_size__ + 1 ))
#    (( _new_end_index__ > 0 )) or (( _new_end_index__ += __list_size__ + 1 ))
#    (( 1 <= _new_beg_index__ && _new_beg_index__ <= __list_size__ )) or
#        :die "list index ${__beg_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
#    (( 1 <= _new_end_index__ && _new_end_index__ <= __list_size__ )) or
#        :die "list index ${__end_index__} not in [-${__list_size__}, ${__list_size__}] or is 0"
#    (( _new_beg_index__ <= _new_end_index__ )) or
#        :die "start index ${__beg_index__} > end index ${__end_index__}"
#
#    # Since indices validate, set index variables to the prior defaults.
#    :Str.set ${__beg_index_name__} ${_new_beg_index__}
#    :Str.set ${__end_index_name__} ${_new_end_index__}
#}
#
#Considering each such list a list set (i.e., ignoring duplicate elements) and
#abbreviating BN="${source_list_nameN}" (e.g., B1="${source_list_name1}") and
#A="${target_list_name}", this function performs the set intersection
#A = B1 & B2 & ... & BN of B1 through BN: e.g.,
#Considering each
#such list a list set (i.e., ignoring duplicate elements) and abbreviating
#B="${left_list_name}", C="${right_list_name}", and A="${result_list_name}",
#FUXME: Would probably be more appropriate as an alias, as that could also
#define such list if not already defined, streamlining code elsewhere.
# >>> set_list_to_string_converted asbestos "$(get_minerals)"
    #FUXME: Ensure all other remove functions call such function.
#
#* Pipe the return value of this function to restore_list(), automatically
#  restoring such string into a local list named "list". (Easy; inflexible.)
#* Manually apply parameter expansion flag "(z)" to the return value of this
#  function in a list assignment to any list you like. (Harder; flexible.)

  # Or (manually) restore such string back into a local list named... whatever
  # you like, man!
#  >>> list quebec_resources; quebec_resources=( ${(z)"$(get_minerals)"} )
#  >>> :stdout.echo "${quebec_resources[-1]}"
#  mafic

# void write_script_file_with_variable(string filename, string variable_name)
#           "${(@P)__list_sans_last_element__}"\

#FUXME: Unconvinced we still want this.
# void die_unless_map_or_list(
#   string variable_name, string error_message = 'not a map or list')
#
# Die unless the variable with the passed name is a map or list.
#die_unless_map_or_list() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    is_map_or_list "${1}" or :die "${2:-\"${1}\" not a declared map or list}"
#}

#FUXME: Unconvinced we still want this.
# boolean is_map_or_list(string variable_name)
#
# Return true if the variable with the passed name is a map or list.
#is_map_or_list() {
#    die_unless_arg 'expected one variable name'
#    is $(get_type "${1}") == (list|array|association)* si
#}

# void die_unless_list_nonempty(
#   string variable_name, string error_message = 'not a list')
#
# A synonym of die_unless_list_nonempty().
#die_unless_list_nonempty() {
#    die_unless_list_nonempty "${@}"
#}

    # If more than two list elements were passed, join such elements and prefix
    # the last such element.
#   if is_args_3_or_more; then
#       list munged; munged=( "${@[1,-2]}" "${__last_delimiter__} ${@[-1]}" )
#       join_list_on_stringmunged ', '
    # If only two list elements were passed, print the first element, the last
    # element prefix, and the third element.
#   elif is_args_2
#   then :stdout.echo "${1} ${last_element_prefix} ${2}"
    # If only one list element was passed, print that element as is.
#   else :stdout.echo "${1}"
#   fi

#FUXME: Actually, we no longer require list elements as positional arguments.
#Revert to a much more sensible list variable style, as follows:
#
# void join_list_on_different_last_delimiter(
#   string list_name,
#   string non_last_delimiter = ', ',
#   string last_delimiter = ', and ')
#
#Sweet. That's sufficiently generalized that we should be able to rename such
#function to join_list_on_different_last_delimiter(). More explicit
#is much better. (I mean, what does "legible" really mean, anyway?)
#
#Actually, the name's a bit silly. Let's just incorporate such functionality
#into joint_list_to_string(), yes? Though, I wonder if that'd just confuse
#things even more. Perhaps this is sensible, after all.
#
# Join all passed strings except the first into a comma-delimited string,
# prefixing the last such string with the first passed string. Unlike most Zeshy
# functions operating on lists, this function excepts accepts list elements as
# positional arguments rather than a variable name due to caller requirements:
# e.g.,

#   print "${_beg_index_name_}:catch${(P)_beg_index_name_}"
#   print "${_end_index_name_}:catch${(P)_end_index_name_}"

# void join_list_to_legible_truncated_string(
#   string last_element_prefix, string text1, string text2, ...)
#
# Join the passed elements into a human-readable string separated by commas,
# prefixing the last such element with the passed string and truncating the
# resulting string to a hopefully sensible number of characters (currently,
# 75% of the current terminal width): e.g.,
#
#     >>> join_list_to_legible_truncated_string 'or'\
#     ...   '"I laiss i-ferin thuiar"' '"I wilith lim echui aur."'
#     "I laiss i-ferin thuiar" or "I wil...
#join_list_to_legible_truncated_string() {
    # Join the sanity.
#    string text; text="$(join_list_to_legible_string "${@}")"

    # Truncate the joined string to 75% of the current terminal's width.
#    integer max_length
#    (( max_length = 0.75 * $(get_terminal_width) ))
#    truncate_string "${text}" ${max_length} '...'
#}

# This and join_list_to_legible_string() accept list elements rather than a
# variable name signifying a list due to caller requirements, elsewhere.
#
    # If no list elements were passed, print the empty string and return.
#   :List.is_nonempty "${list_name}" or :success.report

    #FUXME: Add new get_list_difference() and get_list_intersection() functions
    #to "type/function", leveraging :List.die_unless() and :List.return(). (Yep!)
    #Hmm; wait. We're probably better off with set_list_to_list_difference_into() and
    #set_list_to_list_intersection_into() functions accepting a third arg: the target list.

    # The difference between the two lists is the list of all Zeshy functions.
    # Recompile all such function definitions into the Zeshy digest file. (For
    # those who care, this is an asymmetric rather than symmetric difference.)
#   print "autoload function names: ${new_function_names[@]:|ZY_OLD_FUNCTION_NAMES}"
#   zcompile -c "${ZY_USER_DIGEST_FILENAME}"\
#       "${new_function_names[@]:|ZY_OLD_FUNCTION_NAMES}"

#FUXME: Poor name, since this doesn't actually perform a "return" statement.
#Perhaps print_restorable_list()? AH! Got it: :List.as_string().
# If no delimiter is passed, split words by default
# parsing (i.e., first by quote- and then whitespace-delimited words)
# See set_list_to_string_split_on() for alternative splitting on all substrings.
# See split_string_on_first() for alternative splitting into string variables.
#I'm pretty sure we can implement this by splitting text into a list of lines
#and running a single parameter expansion on such list (possibly also locally
#setting "IFS=':'"), which zsh *SHOULD* apply to each list member. If we can't
#do this and instead have to manually iterate the list, *DON'T*. Just use "cut".
#   >>> string List="$(get_list)"
#   >>> expand_List_to_list

#FUXME: This is silly. No one's *EVER* going to call this function. It's simply
#too obscure. Fold its implementation into expand_List(), which should
#incidentally be renamed to expand_...

#   # Expand the stringified list back into a list with a brute-force "eval".
#   >>> eval 'expand_list list $(make_list)'
#   >>> print "last list element: ${list[-1]}"  # as in the original list!
#   mafic

# void expand_list(string list_name, string text1, string text2, ...)
#
# Return a string that, when "eval"-ed by the caller, expands the passed strings
# having a stringified list previously produced by :List.return() into the list
# with the passed name. See expand_List() for a concise alternative.
#expand_list() {
#    die_unless_args_2_or_more\
#        'expected one variable name and one or more strings'
#    string list_name="${1}"
#    shift_arg
#
#    # Dismantled, this is:
#    #
#    # * '@' expands to all remaining passed parameters: the stringified list.
#    # * 'z' splits the stringified list into a numeric list of words,
#    #   effectively undoing the prior 'kv' flag.
#    print "list ${list_name}; ${list_name}:catch( ${(z)@} )"
#}

# void expand_List()
#
# Expand stringified list "List" to list "list", a convenience alias simplifying
# the more generalized expand_list() function. See :List.return() for examples.
#alias expand_List='
#:Var.is List or :die "\"List\" not defined";
#eval "$(expand_list list ${List})"'

    # Declare a list with the passed name if no such list exists.
#   is_undeclared "${list_name}" or print "list ${list_name}; "

#   :List.die_unless "${list_name}"
#
# Map-specific analogues of the above list-specific functions.
# ....................{ INITIALIZATION                     }....................
#   die_unless_two_to_three_args\
#       'expected one string name, one list name, and one optional delimiter'
#   string text_name="${1}" list_name="${2}" delimiter="${3}"
