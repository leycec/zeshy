#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *hexadecimal strings* (i.e., base 16 integers signifying values 10
through 15 as characters `A` through `F`).
/---

#FIXME: Reduce "_hexadecimal" to "_hex" everywhere. Leave "_decimal" as is,
#however. There's no meaningfully familiar truncation of such word, as with
#"_string" elsewhere.

# ....................{ EXCEPTIONS                         }....................
#FIXME: Define new type aliases resembling:
#
#    alias integer_decimal="integer_in_base 10"
#    alias integer_hexadecimal="integer_in_base 16"
#    alias integer_octal="integer_in_base 8"
#
#While redundant, the "integer_decimal" alias improves orthogonality: namely,
#there's a convert_hexadecimal_to_decimal() function and a hexadecimal "type"
#but no decimal "type". Fix that.

:func.doc <<'/---'
void die_unless_hexadecimal(
    string value,
    string error_message =
        "String \"${value}\" not a hexadecimal integer (e.g., `0xFEEDFACE`).")

Throw an exception with the passed message unless the passed string is an
integer in base 16 hexadecimal format. See is_hexadecimal() for further details.
/---
function die_unless_hexadecimal() {
    die_unless_args_1_to_2 'Expected one string and optional error message.'
    string value="${1}"
    is_hexadecimal "${value}" or :die\
        "${2-String \"${value}\" not a hexadecimal integer (e.g., `0xFEEDFACE`).}"
}

# ....................{ TESTERS                            }....................
:func.doc <<'/---'
[status: bool] is_hexadecimal(string value)

Report success if the passed string is an integer in base 16 hexadecimal format
and hence prefixed by either `0x` or `16#` (e.g., `16#DEADFACE`): e.g.,

.is_hexadecimal()
==========================================
[source]
------------------------------------------
>>> string on_ignorance=\
...    "Ignorance is king. Many would not profit by his abdication. Many enrich
...     themselves by means of his dark monarchy. They are his Court, and in his
...     name they defraud and govern, enrich themselves and perpetuate their
...     power. Even literacy they fear, for the written word is another channel
...     of communication that might cause their enemies to become united. Their
...     weapons are keen-honed, and they use them with skill. They will press
...     the battle upon the world when their interests are threatened, and the
...     violence which follows will last until the structure of society as it
...     now exists is leveled to rubble, and a new society emerges. I am sorry:
...     But that is how I see it."
>>> is_hexadecimal "0xFEEDBEEF" and get_string_line "${on_ignorance}" 1\
Ignorance is king. Many would not profit by his abdication. Many enrich
------------------------------------------
==========================================
/---
function is_hexadecimal() {
    die_unless_arg 'Expected one string.'
    is "${1}" == ('0x'|'16#')[[:xdigit:]]## si
}

# ....................{ CONVERTERS ~ decimal               }....................
:func.doc <<'/---'
string convert_decimal_to_hexadecimal(string value)

Convert the passed base 10 string integer to hexadecimal format: e.g.,

.convert_decimal_to_hexadecimal()
==========================================
[source]
------------------------------------------
>>> convert_decimal_to_hexadecimal 3405691582
0xCAFEBABE
------------------------------------------
==========================================
/---
function convert_decimal_to_hexadecimal() {
    # Validate sanity.
    die_unless_arg 'Expected one integer.'
    string decimal="${1}"
    :int.die_unless "${decimal}"

    # Convert such decimal.
    :str.output $(( [#16] decimal ))
}

#FIXME: This function is overly strict. The caller shouldn't be required to
#prefix such string with a hexadecimal prefix (i.e., either "0x" or "16#"). If
#such prefix is absent, simply silently prefix such string with "0x" before
#attempting to convert such number. Not too nice?
:func.doc <<'/---'
string convert_hexadecimal_to_decimal(string hexadecimal)

Convert the passed base 16 integer in hexadecimal format to base 10: e.g.,

.convert_hexadecimal_to_decimal()
==========================================
[source]
------------------------------------------
>>> convert_hexadecimal_to_decimal 0xBADF00D
195948557
------------------------------------------
==========================================
/---
function convert_hexadecimal_to_decimal() {
    # Validate sanity.
    die_unless_arg 'Expected one hexadecimal string.'
    string hexadecimal="${1}"
    die_unless_hexadecimal "${hexadecimal}"

    # Convert such hexadecimal.
    :str.output $(( [#10] hexadecimal ))
}

# --------------------( WASTELANDS                         )--------------------
#   :is_string_matches_glob "${1}" '(0x|[[:digit:]]##\#)[[:xdigit:]]##'
# Temporarily enable shell option "c_bases" to ensure
    # such output is prefixed with "0x".
#    :enable_option_local c_bases
#    integer_in_base 16 hexadecimal="${decimal}"
#    :str.output "${hexadecimal}"

    # Convert such hexadecimal. Unlike convert_decimal_to_hexadecimal(), builtin
    # print() does not require shell option "c_bases" to do so.
#   integer_in_base 10 decimal="${hexadecimal}"
#   :str.output $(( [#10] ${hexadecimal} ))

#FUXME: Ambiguous, as integers may be in any base. Rename to
#convert_decimal_to_hexadecimal().
#FUXME: Rename to die_unless_hexadecimal(), adopting the same nomenclature as
#booleans as characters.
#string base 16 string hexadecimal to integer format:
