#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *integer randomizers* (i.e., functions providing pseudo-random integers).
/---

# ....................{ GETTERS                            }....................
# If:
#
# * The current shell provides rand48(), prefer such function to integer global
#   ${RANDOM}. The former is more reliable, efficient, and accurate.
# * Else, fallback to such global. Such global is strictly in [0, 32767] *AND*
#   requires reseeding on each expansion, complicating the implementation below.
:declare_func_if_or_noop\
    ':void :set_int_to_random_in_range(
        :str:int? int_name,
        :int minimum,
        :int maximum)'\
    ':str\
         int_name__sitrir="${1}"\
         minimum__sitrir="${2}"\
         maximum__sitrir="${3}"
     :int.die_unless_at_most "${minimum__sitrir}" "${maximum__sitrir}"'\
    is_math_function_rand48 '
        # Since rand48() returns a float in [0.0, 1.0), adjust accordingly.
        :Int.set "${int_name__sitrir}"\
            $(( minimum__sitrir + int(
                rand48() * (maximum__sitrir - minimum__sitrir + 1)) ))'\
    :else '
        # Reseed zsh''s internal random number generator with a mock non-
        # pseudorandom integer: the fractional segment of the current time
        # (typically, in nanoseconds). Failure to do so *WILL* return the same
        # integer on each call to this function with the same parameters.
        RANDOM=${EPOCHREALTIME##*.}

        # If such range is within that provided by ${RANDOM} (i.e., in
        # [0, 32767], the positive end of the range provided by a 2-byte signed
        # short), modulo ${RANDOM} itself to produce a random integer in
        # [0, maximum - minimum], where maximum - minimum + 1 is the number of
        # possible integers in such range. Adding the minimum shifts this to
        # [minimum, maximum], as expected.
        if (( minimum__sitrir >= 0 && maximum__sitrir <= 32767 )) {
            :Int.set "${int_name__sitrir}"\
                $(( minimum__sitrir + (
                    RANDOM % (maximum__sitrir - minimum__sitrir + 1)) ))
        # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
        # transformation as above, noting that the end bound is inclusive in
        # this case rather than exclusive and hence off by 1.
        } else {
            :float random__sitrir; random__sitrir=$(( RANDOM / 32767 ))
            :Int.set "${int_name__sitrir}"\
                $(( minimum__sitrir + int(
                    random__sitrir * (maximum__sitrir - minimum__sitrir)) ))
        }' <<'/---'
Set the value of the passed integer variable to a random integer in the passed
*inclusive range* (i.e., guaranteed to be greater than or equal to the passed
minimum integer _and_ less than or equal to the passed maximum integer): e.g.,

.:set_int_to_random_in_range()
==========================================
[source]
------------------------------------------
>>> :set_int_to_random_in_range 0x0DDBA11 0x60DDE55
0x1D0112E
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
# if { is_math_function_rand48 } {
# #   print 'get_integer_random_in_range: adopting rand48()-based implementation'
#     function get_integer_random_in_range() {
#         # Validate sanity.
#         die_unless_args_2 'Expected one minimum integer and one maximum integer.'
#         :str minimum="${1}" maximum="${2}"
#         :int.die_unless_at_most "${minimum}" "${maximum}"
# 
#         # rand48() always returns a float in [0.0, 1.0). Adjust accordingly.
#         :str.output $(( minimum + int(rand48() * (maximum - minimum + 1)) ))
#     }
# } else {
# #   print 'get_integer_random_in_range: falling back to ${RANDOM}-based implementation'
#     function get_integer_random_in_range() {
#         # Validate passed arguments.
#         die_unless_args_2 'Expected one minimum integer and one maximum integer.'
#         :str minimum="${1}" maximum="${2}"
#         :int.die_unless_at_most "${minimum}" "${maximum}"
# 
#         # Reseed zsh's internal random number generator with a mock non-
#         # pseudorandom integer: the fractional segment of the current time
#         # (typically, in nanoseconds). Failure to do so *WILL* return the same
#         # integer on each call to this function with the same parameters.
#         RANDOM=${EPOCHREALTIME##*.}
# 
#         # If such range is within that provided by ${RANDOM} (i.e., in
#         # [0, 32767], the positive end of the range provided by a 2-byte signed
#         # short), modulo ${RANDOM} itself to produce a random integer in
#         # [0, maximum - minimum], where maximum - minimum + 1 is the number of
#         # possible integers in such range. Adding the minimum shifts this to
#         # [minimum, maximum], as expected.
#         if (( minimum >= 0 && maximum <= 32767 )) {
#             :str.return $(( minimum + (RANDOM % (maximum - minimum + 1)) ))
#         # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
#         # transformation as above, noting that the end bound is inclusive in
#         # this case rather than exclusive and hence off by 1.
#         } else {
#             :float random; random=$(( RANDOM / 32767 ))
#             :str.return $(( minimum + int(random * (maximum - minimum)) ))
#         }
#     }
# }

        # The current time in seconds since the first expansion of ${SECONDS} to six
        # fractional string places of accuracy: the maximum under Linux.
#       float_with_fractional_digit_length 6 seconds="${EPOCHREALTIME}"

        # Prior to returning a random number, force zsh's internal random number
        # generator to iterate to the next such number by reseeding with such time
        # discarding the separating string place ".". Failure to do so returns the
        # same initial number of such sequence on each call to this function.
#       RANDOM=${seconds/./}

        #FUXME: Obtaining nanoseconds would be far preferable, but again
        #gets into portability issues. *shrug*

# ....................{ PRECOMPILERS                       }....................
#:run_hook_on_zeshy_precompile precompile_zeshy_get_integer_random_in_range

#:func.doc <<'/---'
#void precompile_zeshy_get_integer_random_in_range()
#
#Define get_integer_random_in_range() before compiling Zeshy''s user digest file.
#Implement such function to call rand48() if zsh was compiled with support for
#erand48() or to expand integer ${RANDOM} otherwise.
#/---
#function precompile_zeshy_get_integer_random_in_range() {
#    # Validate sanity.
#    die_if_args
#
#}

# Define such function at precompile time, below.

# Wrap such test in an "eval" statement to allow redirection to the bitbucket.
#function get_integer_random_in_range() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one minimum and one maximum integers'
#    string minimum="${1}" maximum="${2}"
#    :int.die_unlesss "${minimum}" "${maximum}"
#
#    # Number of possible integers in the passed range.
#    integer count; count=$(( maximum - minimum + 1 ))
#
#    # If the current shell provides rand48(), prefer such function to canonical
#    # global integer ${RANDOM}. The former's accuracy, efficiency, and
#    # reliability are markedly superior. Since rand48() always returns a float
#    # in [0.0, 1.0), the implementation is quite simple.
#    if is_math_function_rand48
#    then :str.output $(( minimum + int(rand48() * (maximum - minimum + 1)) ))
#    else
#        # The current time in seconds since the first expansion of ${SECONDS} to six
#        # fractional string places of accuracy: the maximum under Linux.
#        float_with_fractional_digit_length 6 seconds="${SECONDS}"
#
#        #FIXME: Replace with a corresponding Zeshy function call.
#        # Prior to returning a random number, force zsh's internal random number
#        # generator to iterate to the next such number by reseeding with such time
#        # discarding the separating string place ".". Failure to do so returns the
#        # same initial number of such sequence on each call to this function.
#        RANDOM=${seconds/./}
#
#        # If such range is within that provided by ${RANDOM} (i.e., in
#        # [0, 32767], the positive end of the range provided by a 2-byte signed
#        # short), modulo ${RANDOM} itself to produce a random integer in
#        # [0, maximum - minimum], where maximum - minimum + 1 is the number of
#        # possible integers in such range. Adding the minimum shifts this to
#        # [minimum, maximum], as expected.
#        if (( minimum >= 0 || maximum <= 32767 ))
#        then :str.output $(( minimum + (RANDOM % (maximum - minimum + 1)) ))
#        # Else, quantize ${RANDOM} to a float in [0.0, 1.0] and apply a similar
#        # transformation as above, noting that the end bound is inclusive in
#        # this case rather than exclusive and hence off by 1.
#        else
#            float random; random=$(( RANDOM / 32767 ))
#            :str.output $(( minimum + int(random * (maximum - minimum)) ))
#        fi
#    fi
#}

        #FUXME: Raise an exception if the passed "max" is larger than 32767? We can
        #fake larger ranges by simply multiplying with float arithmetic and capping
        #the :str.output to the desired max, which seems preferable.

#FUXME: Provide a function based on the rand48() function, if available. The
#implementation is somewhat intricate, since such function returns floats from
#0 to 1. See:
#    http://osdir.com/ml/shells.zsh.devel/2007-11/msg00150.html

