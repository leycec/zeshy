#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle variable types.
/---

#FIXME: Grep the codebase for other parcels accessing these globals. Most
#shouldn't be! Bad premature optimization, we're afraid. Refactor all such code
#to call testers and setters defined by this parcel, instead.
#FIXME: Indeed, since *NO* other parcels should be accessing such string
#globals, refactor such string globals into a single map global or local of the
#anonymous function below: e.g.,
#
#     :map.global ZY__VAR_TYPE_TO_ZSH_GLOB; ZY__VAR_TYPE_TO_ZSH_GLOB=(
#         :float 'float*'
#         :int   'integer*'
#         :list  '(array|list)*'
#     )

# ....................{ TESTERS ~ type                     }....................
# See the anonymous function below for such function's definitions.

#FIXME: Ugh. Rather than manually documenting these functions here, we should
#almost certainly be automatically documenting where we dynamically define them
#below. To do so, we'll simply need to create a *LOCAL* map from variable
#type to variable noun docstring describing that type: e.g.,
#
#    :map var_type_to_doc; var_type_to_doc=(
#        'Bool' 'booleans'
#        'Number' '*numbers* (i.e., either integers or floats)'
#    )
#
#Given that, dynamically passing the :func.define() function a docstring
#synthesized for the current type should be trivial.

:func.doc <<'/---'
[status=:bool] :Bool.is(+:Str var_names)

Report success if all passed variables are existing booleans or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Char.is(+:Str var_names)

Report success if all passed variables are existing characters or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Float.is(+:Str var_names)

Report success if all passed variables are existing floats or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Int.is(+:Str var_names)

Report success if all passed variables are existing integers or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :List.is(+:Str var_names)

Report success if all passed variables are existing lists or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Map.is(+:Str var_names)

Report success if all passed variables are existing maps or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Number.is(+:Str var_names)

Report success if all passed variables are existing *numbers* (i.e., either
integers or floats) or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Scalar.is(+:Str var_names)

Report success if all passed variables are existing *scalars* (i.e., either
booleans, characters, integers, floats, or strings) or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

:func.doc <<'/---'
[status=:bool] :Str.is(+:Str var_names)

Report success if all passed variables are existing strings or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

# ....................{ SETTERS                            }....................
#FIXME: Actually call this setter elsewhere rather than manually expanding
#"${(tP)...}" everywhere, except where efficiency *ABSOLUTELY* demands such
#optimization.

:func.doc <<'/---'
:void :Var.Type(:Str/:Var var_name :Str string_name)

Set the passed string to the passed variable's *type string* (i.e., `zsh`-
specific lowercase string succinctly synopsizing both the type and scope such
variable was originally declared as): e.g.,

.:Var.Type()
==========================================
[source]
------------------------------------------
>>> :str type_string
>>> :list on_employment; on_employment=(
...     "Most men would feel insulted if it were proposed to employ them in"
...     "throwing stones over a wall, and then in throwing them back, merely"
...     "that they might earn their wages. But many are no more worthily"
...     "employed now." )
>>> :Var.Type on_employment type_string
>>> :stdout.echo "${type_string}"
array-local
------------------------------------------
==========================================

== Variable Type Strings ==

Such type string consists of such variable's type _and_ scope delimited by `-`
(e.g., `array-local`, the type string for local lists). If such scope is
global, such type string omits such scope and hence consists only of such
variable's type without a suffixing `-`.

=== Type ===

If such variable was declared as type:

* Float, such type string is prefixed by `float`.
* Integer, such type string is prefixed by `integer`.
* Map, such type string is prefixed by `association`.
* String, such type string is prefixed by `scalar`.
* List _and_ is a:
** *Canonical `zsh` global* (e.g., ${match}, ${path}), such type string is
   prefixed by `array`.
** *Non-canonical variable* (i.e., user- or `zeshy`-specific), such type string
   is prefixed by `list`.

=== Scope ===

If such variable was declared with scope:

* Local, such type string is suffixed by `-local`.
* Global, such type string omits such scope.
* Exported, such type string is suffixed by `-exported`.
/---
function :Var.Type() {
    die_unless_args_2 'Expected one variable name and one string name.'
    :str var_name__sstvt="${1}" string_name__sstvt="${2}"
    :Var.die_unless "${var_name__sstvt}"

    # Set such string to such variable's type. Dismantled, this is:
    #
    # * "P", expanding to such variable's name.
    # * "t", expanding to such variable's type.
    :Str.set "${string_name__sstvt}" "${(tP)var_name__sstvt}"
}

# ....................{ MAIN                               }....................
() {
    # For each zeshy-specific variable type, define testers (documented above)
    # validating variables of that type.
    local var_type
    for   var_type (
        Bool
        Char
        Float
        Int
        List
        Map
        Number
        Scalar
        String
    ) {
        :func.define\
            '<is_args_unhandled> [status=:bool] :'${var_type}'.is(+:Str/:Var var_names)' '
    :Var.die_unless "${@}"
    ::'${var_type}'.is "${@}"'
    }
}

return 0
# --------------------( WASTELANDS                         )--------------------
# # ....................{ OBSOLETE                           }....................
# #FUXME: Pretty much everything below should probably be excised. Do we still
# #reference such globals elsewhere? Hmm... Yes, but mostly in subparcels of
# #@{var}. Shouldn't be terribly arduous to unravel, we should think.
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_FLOAT='float*' <<'/---'
# Glob matching float variable type strings.
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_INT='integer*' <<'/---'
# Glob matching integer variable type strings.
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_LIST='(array|list)*' <<'/---'
# Glob matching list variable type strings.
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_MAP='association*' <<'/---'
# Glob matching map variable type strings.
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_STR='scalar*' <<'/---'
# Glob matching string variable type strings.
# /---
#
# # ....................{ GLOBALS ~ zeshy                    }....................
# # Globs matching zeshy-specific types depending on the prior canonical types.
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_BOOL="${ZY__VAR_TYPE_GLOB_INT}" <<'/---'
# Glob matching boolean variable type strings.
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_CHAR="${ZY__VAR_TYPE_GLOB_STR}" <<'/---'
# Glob matching character variable type strings.
# /---
#
# # ....................{ GLOBALS ~ plural                   }....................
# # Globs matching two or more of the prior canonical types.
#
# #FIXME: Rename to ${ZY__VAR_TYPE_GLOB_NUMERIC}.
# :str.global\
#     ZY__VAR_TYPE_GLOB_NUMERIC='(float|integer)*' <<'/---'
# Glob matching type strings of *numeric variables* (i.e., floats and integers).
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_SCALAR='(float|integer|scalar)*' <<'/---'
# Glob matching type strings of *scalar variables* (i.e., floats, integers, and
# strings).
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_NONSCALAR='(array|association|list)*' <<'/---'
# Glob matching type strings of *nonscalar variables* (i.e., lists and maps).
# /---
#
# # ....................{ GLOBALS ~ scope                    }....................
# :str.global\
#     ZY__VAR_TYPE_GLOB_LOCAL='*-local' <<'/---'
# Glob matching type strings of local variables.
# /---
#
# :str.global\
#     ZY__VAR_TYPE_GLOB_EXPORTED='*-exported' <<'/---'
# Glob matching type strings of exported variables.
# /---
#
# # Sadly, type strings of local but *NOT* global variables are explicitly
# # suffixed by a suffix specific to such variables. Thus, type strings of the
# # latter are matchable only by matching type strings either:
# #
# # * *NOT* containing delimiter "-" (and hence implicitly global).
# # * Containing delimiter "-" suffixed by an suffix other than "local" (and
# #   hence implicitly global).
# #
# # While extended globs lack support for the generalized negative lookahead and
# # lookbehind assertions now supported by most PCRE implementations, they *DO*
# # support negative character classes. Since no type suffix other than "-local"
# # starts with "l", negating such letter suffices to match the desired strings.
# :str.global\
#     ZY__VAR_TYPE_GLOB_GLOBAL='([^-]##|*-[^l]*)' <<'/---'
# Glob matching type strings of global variables.
# /---

#FUXME: O.K.; I pretty much *HATE* the current nomenclature. We've never found
#a satisfactory means of differentiating functions whose first parameter is a
#variable name from those whose first parameter is not a variable name. We
#clearly need to do so, because the current :Str.is() nomenclature
#is completely balls. Then here we go:
#
#* The first letter of functions whose first parameter is a variable name
#  should be *CAPITALIZED*.
#* The first letter of functions whose first parameter is not a variable name
#  should be *UNCAPITALIZED*.
#
#zeshy nomenclature currently makes no use of the distinction between
#capitalized and uncapitalized letters, an evident waste of the ASCII lexical
#space available to us. All functions defined below should be renamed like so:
#
#* Rename :Bool.is() to :Bool.is().
#* Rename :Int.is() to :Int.is().
#* Rename :Str.is() to :Str.is().
#FUXME: Also repair the corresponding exception handlers in
#:{*-seed/*-declare/*-test/var}.

#FUXME: Globally rename ${ZY_VAR_*} to ${ZY_VAR_*}.

#FUXME: Rename to either :var.let_type() or ::Var.Type() and refactor the passed
#arguments accordingly. I quite like ::Var.Type(), actually. Shall we go?

# ....................{ TESTERS ~ type : glob              }....................
# :func.doc <<'/---'
# [status=:bool] :var.is_type_matches_glob(
#     :str/var var_name1, ..., :str/glob var_type_glob)
#
# Report success if the types of all passed variables match the passed glob. If
# any such variable does _not_ exist, an exception is thrown: e.g.,
#
# .:var.is_type_matches_glob()
# ==========================================
# [source]
# ------------------------------------------
# >>> :map on_industry=(
# ...     "If"    "a man walk in the woods for love of them half of each day,"
# ...     "he"    "is in danger of being regarded as a loafer; but if he spends"
# ...     "his"   "whole day as a speculator, shearing off those woods and making"
# ...     "Earth" "bald before her time, he is esteemed an industrious"
# ...     "and"   "enterprising citizen. As if a town had no interest in
# ...     "its"   "forests but to cut them down!" )
# >>> :var.is_type_matches_glob on_industry "map*" and
# ...     :stdout.echo "You must get your living by loving."
# You must get your living by loving.
# ------------------------------------------
# ==========================================
# /---
# function :var.is_type_matches_glob() {
#     # See ={*-start/*-declare/*-test/var} for strongly related code.
#     (( # >= 2 )) || :die\
#         'Expected one or more variable names and one type glob.'
#     :Var.die_unless "${@[1,-2]}"
#     if (( # == 2 )) {
#         [[ "${(tP)1-}" == ${~2}('-'*|) ]]
#     } else {
#         local IFS=
#         [[ "${(e)${@[1,-2]//(#m)*/\${(t)${MATCH}-\}:}}" ==\
#             (${~@[-1]}('-'[^:]#|)':')(#c${#}) ]]  # quiet vim: "}"
#     }
# }

#FUXME: Ah! Almost, but not quite. We *REALLY* want to preserve queryability
#through completions, which the above scheme really disrupts. Thankfully, this
#is trivially solved; rather than capitalizing the first letter of such
#callable name, capitalize the first "."-prefixed letter instead: e.g.,
#
#* Rename :Bool.is() to :bool.Is().
#* Rename :Int.is() to :int.Is().
#* Rename :Str.is() to :str.Is().
#
#Done!
#FUXME: I'm not terribly happy with this nomenclature. 

#FUXME: Define :is_string() to report success if the passed name corresponds to
#an existing string variable, much like ::List.is() and ::is_map().
#FUXME: Actually, most of the above is probably *OBSOLETE* now. For sanity's
#sake, we now define type handlers *VERY* early in zeshy compilation:
#@{*-start/*-declare/*-test}. Given this, we should probably shift all
#remaining exception handlers and testers below to such parcel and then excise
#the entire contents of the anonymous function below.

# ....................{ TESTERS                            }....................
# :func.doc <<'/---'
# [status = :bool] :is_var_number(^:str var_name1, ...)
# 
# Report success if all passed variables are existing *numbers* (i.e., either
# integers or floats). If any such variable does _not_ exist, an exception is
# thrown.
# /---
# function :is_var_number() {
#     (( # )) || :die 'Expected one or more variable names.'
#     :var.is_type_matches_glob "${@}" '(float|integer)'
# }
# 
# :func.doc <<'/---'
# [status = :bool] :is_var_scalar(^:str var_name1, ...)
# 
# Report success if all passed variables are existing *scalars* (i.e., either
# booleans, characters, integers, floats, or strings). If any such variable does
# _not_ exist, an exception is thrown.
# /---
# function :is_var_scalar() {
#     (( # )) || :die 'Expected one or more variable names.'
#     :var.is_type_matches_glob "${@}" '(float|integer|scalar)'
# }

# ....................{ EXCEPTIONS                         }....................
#FUXME: Refactor in accordance with recent @{*-start/*-declare/*-test/var}
#improvements.

# :func.doc <<'/---'
# :void :die_unless_var_number(:str:var var_name1, ...)
# 
# Throw an exception unless all passed variables are existing numbers. See
# :is_number() for further details.
# /---
# function :die_unless_var_number() {
#     (( # )) || :die 'Expected one or more variable names.'
#     :is_var_number "${@}" ||
#         ::die_unless_var_type_with_label "${@}" number 'number'
# }
# 
# :func.doc <<'/---'
# :void :die_unless_var_scalar(:str:var var_name1, ...)
# 
# Throw an exception unless all passed variables are existing scalars. See
# :is_scalar() for further details.
# /---
# function :die_unless_var_scalar() {
#     (( # )) || :die 'Expected one or more variable names.'
#     :is_var_scalar "${@}" ||
#         ::die_unless_var_type_with_label "${@}" scalar 'scalar'
# }

# ....................{ DEFINERS                           }....................
# () {
#     # Validate sanity.
#     die_if_args
#     :str\
#         func_names_die_unless_singular\
#         func_names_die_unless_plural\
#         func_names_test_singular\
#         is_var_type_matches\
#         string_name_type_glob\
#         var_type_capital\
#         var_type_singular\
#         var_type_plural
# 
#     # For each zeshy-specific variable type, declare and define exception
#     # handler and tester functions specific to such type.
#     :str var_type
#     for     var_type (
#         # zsh types.
#         float integer list map string
# 
#         # zsh type aggregators.
#         number scalar nonscalar
# 
#         # zeshy types.
#         boolean character
#     ) {
#         # If the first letter of such type is a vowel, prefix such type by "an".
#         # with "an".
#         if :is "${var_type[1]}" == [aeiou] :si {
#             var_type_singular="an ${var_type}"
#         # Else, the first letter of such type is a consonant. Prefix such type
#         # by "a".
#         } else {
#             var_type_singular="a ${var_type}"
#         }
# 
#         # Capitalize such type.
#         var_type_capital="${(C)var_type[1]}${var_type[2,-1]}"
# 
#         # Pluralize such type, suffixing such type by "s".
#         var_type_plural="${var_type}s"
# 
#         # If such type is nonscalar *OR* string, declare a pair of singular and
#         # a pair of plural exception handlers for such type. In each such pair,
#         # the first handler explicitly prefixes such type with "_variable" and
#         # the second handler omits such word. In either case, there exists no
#         # meaningful difference between such handlers for such types, as:
#         #
#         # * All nonscalar types must be passed to functions as variable names.
#         # * All scalar variable values reduce to typeless strings when expanded
#         #   and hence passed to functions.
#         #
#         # Since there do exist meaningful differences between such handlers for
#         # all other types, declare handlers omitting the word "_variable" for
#         # all other types differently below. For example, while
#         # :Int.die_unless() throws an exception if the passed string
#         # is not the name of an integer variable, :int.die_unless() throws an
#         # exception if the passed string is not a syntactically valid integer.
#         if :is "${var_type}" == ('list'|'map'|'string') :si {
#             func_names_die_unless_singular=":die_unless_var_${var_type}, die_unless_${var_type}"
#             func_names_die_unless_plural=":die_unless_vars_${var_type}, die_unless_${var_type_plural}"
#         # Else, such type is scalar. Declare only one singular and one plural
#         # exception handler for such type.
#         } else {
#             func_names_die_unless_singular=":die_unless_var_${var_type}"
#             func_names_die_unless_plural=":die_unless_vars_${var_type}"
#         }
# 
#         # Since :List.is() and :Map.is() imply different
#         # function semantics from :List.is() and :is_map() (simply by virtue of
#         # function name), define only the former here. See below for the latter.
#         func_names_test_singular=":is_var_${var_type}"
# 
#         # Name of the string global matching such variable's type.
#         string_name_type_glob="ZY__VAR_TYPE_GLOB_${(U)var_type}"
# 
#         # If such global is undefined or of an unexpected type, throw an
#         # exception. See :Str.die_unless() for further details.
#         :is "${(tP)string_name_type_glob-}" == 'scalar'* :si or :die\
#             'String ${'${string_name_type_glob}'} undefined or not a string.'
# 
#         # Code snippet reporting success if the variable with name
#         # ${var_name__vt} exists and is of the desired type. If such variable
#         # does not exist, an exception is thrown.
#         is_var_type_matches='
#     :Var.die_unless "${var_name__vt}"
#     :is "${(tP)var_name__vt}" == '${(P)string_name_type_glob}' :si'
# 
#         # Declare and define such functions. For efficiency, inline variable
#         # type tests rather than call :var.is_type_matches_glob() -- an overly
#         # heavyweight tester for such frequently called functions.
#         :func.declare\
#     ':void {'${func_names_die_unless_singular}'}(
#         :str var_name,
#         :str error_message =
#             "'${var_type_capital}' \$\{${var_name}\} not '${var_type_singular}'.")' '
#     :str var_name__vt="${1}"
#     '${is_var_type_matches}' or :die\
#         "${2-'${var_type_capital}' \$\{${var_name__vt}\} not '${var_type_singular}':${ZY_ASCII_NEWLINE}$(:Var.print "${var_name__vt}")}"' <</---
# Throw an exception with the passed message unless the passed variable exists
# and is ${var_type_singular}.
# /---
# 
#         :func.declare\
#     ':void {'${func_names_die_unless_plural}'}(:str:var? var_name1, ...)' '
#     :str var_name__vt
#     for     var_name__vt ("${@}") {
#         '${is_var_type_matches}' or
#             :die_unless_var_'${var_type}' "${var_name__vt}"
#     }' <</---
# Throw an exception with a stock message unless all passed variables exist and
# are ${var_type_plural}.
# /---
# 
#         :func.declare\
#     '[status = :bool] {'${func_names_test_singular}'}(:str:var? var_name)' '
#     :str var_name__vt="${1}"
#     '${is_var_type_matches} <</---
# Report success if the passed variable is ${var_type_singular}. If such
# variable does not exist, an exception is thrown.
# /---
#     }
# }

# # ....................{ TESTERS                            }....................
# # See above for :List.is() and :Map.is(), which share semantics
# # closer to those of the exception handlers defined above.
# 
# :func.doc <<'/---'
# [status = :bool] :List.is(:str var_name)
# 
# Report success if the passed variable both exists and is a list. Unlike
# :List.is(), an exception is _not_ thrown if such variable does not exist.
# /---
# function :List.is() {
#     # Validate sanity.
#     die_unless_arg 'Expected one variable name.'
#     :str var_name__il="${1}"
# 
#     # Test such variable. For both efficiency and stability, inline the value of
#     # ${~ZY__VAR_TYPE_GLOB_LIST}.
#     is "${(tP)var_name__il-}" == ('array'|'list')* si
# }
# 
# :func.doc <<'/---'
# [status = :bool] :is_map(:str var_name)
# 
# Report success if the passed variable both exists and is a map. Unlike
# :Map.is(), an exception is _not_ thrown if such variable does not exist.
# /---
# function :is_map() {
#     # Validate sanity.
#     die_unless_arg 'Expected one variable name.'
#     :str var_name__im="${1}"
# 
#     # Test such variable. For both efficiency and stability, inline the value of
#     # ${~ZY__VAR_TYPE_GLOB_MAP}.
#     is "${(tP)var_name__im-}" == 'association'* si
# }
# 
# # ....................{ TESTERS ~ type                     }....................
# :func.doc <<'/---'
# [status = :bool] :is_var_numeric(:str:var? var_name)
# 
# Report success if the passed variable is *numeric* (i.e., was originally
# declared as a scalar variable of type either float or integer).
# /---
# function :is_var_numeric() {
#     # Validate sanity.
#     die_unless_arg 'Expected one variable name.'
#     :str var_name__ivn="${1}" var_type__ivn
# 
#     # Type of such variable.
#     :Var.Type var_type__ivn "${var_name__ivn}"
# 
#     # Test such type.
#     is "${var_type__ivn}" == ${~ZY__VAR_TYPE_GLOB_NUMERIC} si
# }

# :void :die_unless_var_nonscalar(:str:var var_name1, ...)
# function :die_unless_var_nonscalar() {
#     (( # )) || :die 'Expected one or more variable names.'
#     :is_var_nonscalar "${@}" ||
#         ::die_unless_var_type_with_label "${@}" nonscalar 'non-scalar'
# }

    # die_unless_args_1_to_2\
    #     "Expected one variable name and optional error message."
    # die_unless_args "Expected one or more variable names."
    # die_unless_arg "Expected one variable name."

# ....................{ MAIN                               }....................
# ::define_var_type_functions

# #FUXME: Document me.
# :func.doc <<'/---'
# :void ::define_var_type_functions()
# /---
# ::define_var_type_functions
    # Comma-delimited string lists of function names to be declared.
    # :str\
    #     func_names_die_unless_singular\
    #     func_names_die_unless_plural\
    #     func_names_test_singular

    # # Name of the string global matching such variable's type.
    # :str string_name_type_glob

    # # Code snippet used to programmatically construct function definitions.
    # :str is_var_type_matches

    # # Human-readable singular and plural variants of such variable type,
    # # prefixed with appropriate articles (e.g., "an integer", "a string").
    # :str var_type_singular var_type_plural var_type_capital

        #FUXME: We're currently inducing subtle errors here. This will *ALL* go
        #away after we transition the declarations and definitions below to
        #simply call our new :func.declare() instead; hence, don't worry about
        #correcting the prior way of declaring and defining functions. Just
        #focus on transitioning everything below to :func.declare(), and this
        #will *ALL* work itself out. (Nice, eh?)

#         # Document such functions.
#         :func.doc <</---
# void {${func_names_die_unless_singular}}(
#     string var_name,
#     string error_message = "\\\${\${var_name}\\} not ${var_type_singular}.")
# 
# Throw an exception with the passed message unless the passed variable exists and
# is ${var_type_singular}.
# /---
#         :func.doc <</---
# void {${func_names_die_unless_plural}}(string var_name1, ...)
# 
# Throw an exception with a stock message unless all passed variables exist and
# are ${var_type_plural}.
# /---
#         :func.doc <</---
# [status: bool] {${func_names_test_singular}}(string var_name)
# 
# Report success if the passed variable is ${var_type_singular}. If such
# variable does not exist, an exception is thrown.
# /---
# 
#         # Get the name of the string global matching such variable's type.
#         string_name_type_glob="ZY__VAR_TYPE_GLOB_${(U)var_type}"
# 
#         #FUXME: Nonsense. Just call :Var.is() here. Naturally, this requires
#         #such function be defined here, which raises another question: does
#         #this parcel still need to reside under @{00-start}? The answer is
#         #most likely: absolutely not. Contemplate shifting this to
#         #@{*-main/var/type} and renaming @{*-main/var/var} to @{*-main/var/00-var}, to ensure
#         #:Var.is() is defined by the time this parcel is sourced.
#         #FUXME: Actually, just shift @{*-main/var/var} to @{*-start/var/var}.
# 
#         # If such global does *NOT* exist, throw an exception. See :Var.is()
#         # for further details.
#         (( ${+parameters[string_name_type_glob]} )) or
#             :die '${'${string_name_type_glob}'} undefined.'
# 
#         # Code snippet returning success if the variable with name
#         # ${var_name__vt} exists and is of the desired type. If such variable
#         # does not exist, throw an exception.
#         is_var_type_matches='
#     :Var.die_unless "${var_name__vt}"
#     is "${(tP)var_name__vt}" == '${(P)string_name_type_glob}' si'
# 
#         #FUXME: Silly. We define :func.define() and should be utilizing such
#         #function here rather than defining functions manually. (Ugh.)
# 
#         # Define such functions. For efficiency, inline their implementations
#         # rather than call :var.is_type_matches_glob() -- an overly
#         # heavyweight tester for such frequently called functions.
#         eval '
# function '${func_names_die_unless_singular}'() {
#     die_unless_args_1_to_2\
#         "Expected one variable name and optional error message."
#     :str var_name__vt="${1}"
# 
#     '${is_var_type_matches}' or
#         :die "${2-Variable \$\{${var_name__vt}\} not '${var_type_singular}' but defined as:
# $(:Var.print "${var_name__vt}")}"
# }
# 
# function '${func_names_die_unless_plural}'() {
#     die_unless_args "Expected one or more variable names."
# 
#     :str var_name__vt
#     for     var_name__vt ("${@}") {
#         '${is_var_type_matches}' or
#             :die_unless_var_'${var_type}' "${var_name__vt}"
#     }
# }
# 
# function '${func_names_test_singular}'() {
#     die_unless_arg "Expected one variable name."
#     :str var_name__vt="${1}"
#     '${is_var_type_matches}'
# }'
#     }

#         eval '
# function '${function_names_die_unless_singular}'() {
#     die_unless_args_1_to_2\
#         "Expected one variable name and optional error message."
#     :str var_name__vt="${1}"
# 
#     '${is_var_type_matches}' or
#         :die "${2-Variable \$\{${var_name__vt}\} not '${var_type_singular}' but defined as:
# $(:Var.print "${var_name__vt}")}"
# }
# 
# function '${function_names_die_unless_plural}'() {
#     die_unless_args "Expected one or more variable names."
# 
#     :str var_name__vt
#     for     var_name__vt ("${@}") {
#         '${is_var_type_matches}' or
#             :die_unless_var_'${var_type}' "${var_name__vt}"
#     }
# }
# 
# function '${function_names_test_singular}'() {
#     die_unless_arg "Expected one variable name."
#     :str var_name__vt="${1}"
#     '${is_var_type_matches}'
# }'
# 
# ....................{ GETTERS                            }....................
#FUXME: Refactor into :Var.Type().

# :func.doc <<'/---'
# string get_var_type(string var_name)
# 
# Get the `zsh`-specific lowercase type of the passed variable. If such variable
# is:
# 
# * A float, `float` prefixes such type.
# * An integer, `integer` prefixes such type.
# * A map, `association` prefixes such type.
# * A string, `scalar` prefixes such type.
# * A user- or `zeshy`-defined list, `list` prefixes such type.
# * A canonical `zsh` list variables (e.g., ${match}, ${path}), `array` prefixes
#   such type.
# 
# If such variable was declared with scope:
# 
# * Local, `-local` suffixes such type.
# * Exported, `-exported` suffixes such type.
# 
# For example:
# 
# .get_var_type()
# ==========================================
# [source]
# ------------------------------------------
# >>> list on_employment; on_employment=(
# ...     "Most men would feel insulted if it were proposed to employ them in"
# ...     "throwing stones over a wall, and then in throwing them back, merely"
# ...     "that they might earn their wages. But many are no more worthily"
# ...     "employed now." )
# >>> get_var_type on_employment
# array-local
# ------------------------------------------
# ==========================================
# /---
# function get_var_type() {
#     # Validate sanity.
#     die_unless_arg 'Expected one variable name.'
#     :str var_name__gvt="${1}"
#     :Var.die_unless "${var_name__gvt}"
# 
#     # Get such type. Dismantled, this is:
#     #
#     # * "P", expanding to the variable with the passed name.
#     # * "t", expanding such variable's type.
#     :stdout.echo "${(tP)var_name__gvt}"
# }

#             :die "${Variable \$\{${var_name__vt}\} not '${var_type_singular}' but defined as:
# $(:Var.print "${var_name__vt}")}"

# :Var.is "${var_name__im}" and 

 # For efficiency, inline such
 #        # implementation. See :Var.is() for further details.
 #        is_var_type_matches='
 #    is -n "${(P)var_name__vt+x}" si or
 #        :die '''${(C)var_type}' ${''${var_name__vt}''} undefined.''
    # :Var.is "${var_name__vt}" or
    #     :die '''${(C)var_type}' ${''${var_name__vt}''} undefined.''

        # is -n "${(P)string_name_type_glob+x}" si or
        # If such global does *NOT* exist, throw an exception. See :Var.is()
        # for further details.
        # is -n "${(P)string_name_type_glob+x}" si or

    # Test such variable. For both efficiency *AND* stability, inline both
    # :Var.is() and ${~ZY__VAR_TYPE_GLOB_LIST}.
    # is (( "${(P)var_name__il+x}" and

        # complies with scalar nomenclature; the latter complies with
        # nomenclature specific to such type (e.g., set_list_to_list()).
        # Declare documentation for such function(s). For simplicity, avoid
        # passing documentation as standard input.

    #FUXME: Ugh. While this works, it's rather inefficient. Consider optimizing.
    #Ideally, we shouldn't require a loop here. 

# The following aggregate types match two or more of the above.
        # If debugging zeshy, guarantee the existence of the string global
        # matching such variable's type by throwing an exception if such global
        # does not exist. Since such global *ALWAYS* exists under normal
        # conditions, this is purely a debug sanity check.
#       if (( ZY_IS_DEBUG )) {
#           :is_var_type_matches='
#   (( ${+'${string_name_type_glob}'} )) or
#       :die "global \${'${string_name_type_glob}'} undefined"'
        # Else, initialize such logic to the empty string.
#       } else {
#           :is_var_type_matches=''
#       }

#   is -n "${(P)var_name__vt+x}" si or
#* `association` for map variables.
#* `array` and `array-special` for `zsh`-specific canonical list variables (e.g.,
#  ${match}, ${path}).
#* `float` for float variables.
#* `integer` for integer variables.
#* `list` for list variables.
#* `scalar` for string variables.

#           function_names_test_singular=":is_var_${var_type} is_${var_type}"
    #FUXME: Might as well declare ":is_var_${var_type}" functions as
    #well, yes? When we do so, we'd might as well inline the calls to
    #:var.is_type_matches_glob(). Indeed, at that point, we'd might as well
    #eliminate such function altogether. It's rather heavyweight, pointlessly.

#FUXME: Extract the globs repeated below (e.g., ('list'|'array')* into globals,
#reducing repetition and explanation elsewhere.

    # Documentation-specific string list of function names to be declared.
#   string\
#       function_names_die_singular_help\
#       function_names_die_plural_help\
#       function_names_test_singular_help

# ....................{ TESTERS                            }....................
#:func.doc <<'/---'
#<globbable> [status: bool] :var.is_type_matches_glob(
#    string var_name, string glob)
#
#Report success if the type of the passed variable matches the passed glob: e.g.,
#
#.:var.is_type_matches_glob()
#==========================================
#[source]
#------------------------------------------
#>>> map on_industry=(
#...     "If"    "a man walk in the woods for love of them half of each day,"
#...     "he"    "is in danger of being regarded as a loafer; but if he spends"
#...     "his"   "whole day as a speculator, shearing off those woods and making"
#...     "Earth" "bald before her time, he is esteemed an industrious"
#...     "and"   "enterprising citizen. As if a town had no interest in
#...     "its"   "forests but to cut them down!" )
#>>> :var.is_type_matches_glob on_industry "map*" and
#...     :stdout.echo "You must get your living by loving."
#You must get your living by loving.
#------------------------------------------
#==========================================
#/---
#function :var.is_type_matches_glob() {
#    # Validate sanity.
#    die_unless_args_2 'expected one variable name and one glob'
#    string var_name__ivtm="${1}" glob__ivtm="${2}"
#    :Var.die_unless "${var_name__ivtm}"
#
#    # If such variable exists, match its type against the passed glob.
#    :str.^=.is\
#        "$(get_var_type "${var_name__ivtm}")"\
#        "${glob__ivtm}"
#}
#
## ....................{ TESTERS ~ type                     }....................
#:func.doc <<'/---'
#[status: bool] :Float.is(string var_name)
#
#Report success if the passed variable was declared to be a float.
#/---
#function :Float.is() {
#    die_unless_arg 'expected one variable name'
#    :var.is_type_matches_glob "${1}" 'float*'
#}
#
#:func.doc <<'/---'
#[status: bool] :is_var_integer(string var_name)
#
#Report success if the passed variable was declared to be an integer.
#/---
#function :is_var_integer() {
#    die_unless_arg 'expected one variable name'
#    :var.is_type_matches_glob "${1}" 'integer*'
#}
#
#:func.doc <<'/---'
#[status: bool] :Str.is(string var_name)
#
#Report success if the passed variable was declared to be a string.
#/---
#function :Str.is() {
#    die_unless_arg 'expected one variable name'
#    :var.is_type_matches_glob "${1}" 'scalar*'
#}
#
#:func.doc <<'/---'
#[status: bool] {:List.is, :List.is}(string var_name)
#
#Report success if the passed variable was declared to be a *list* (i.e.,
#sequential array).
#/---
#function :List.is :List.is() {
#    die_unless_arg 'expected one variable name'
#    :var.is_type_matches_glob "${1}" '(list|array)*'
#}
#
#:func.doc <<'/---'
#[status: bool] {:Map.is, :is_map}(string var_name)
#
#Report success if the passed variable was declared to be a *map* (i.e.,
#associative array).
#/---
#function :Map.is :is_map() {
#    die_unless_arg 'expected one variable name'
#    :var.is_type_matches_glob "${1}" 'association*'
#}
#
#           function_names_die_plural_help="{:die_unless_vars_${var_type}, die_unless_${var_type_plural}}"
#           function_names_test_singular_help="{:is_var_${var_type}, is_${var_type}}"
#           function_names_die_singular_help="{:die_unless_var_${var_type}, die_unless_${var_type}}"

    # If such variable does not exist, throw an exception. See :Var.is() for
    # further details.
#   is -n "${(P)var_name__vt+x}" si or
#       :die "variable \"${var_name__vt}\" undefined"

    # If such variable is of improper type, throw an exception.
#   is "${(tP)var_name__vt}" == ${~ZY__VAR_TYPE_GLOB_'${(U)var_type}'} si or

#FUXME: While the efficiency is appreciated, the extreme reduplication here
#absolutely isn't. Minimize this by dynamically declaring all such functions and
#function documentation. This is surprisingly simpler than you'd think. We'll
#need to iterate on lowercase type, which we uppercase as needed with builtin
#parameter flags. Nothing could be simpler! We can (and should) incorporate list
#and map types into such iteration, which require special handling. Each
#iteration, simply test whether the current type matches "(list|map)" and, if
#so, provide multiple names for such function. Shouldn't be tremendously hard.

# For efficiency, such functions inline their implementations rather than call
# :var.is_type_matches_glob() -- an overly heavyweight if useful tester for
# functions called as commonly as these.

#:func.doc <<'/---'
#void :Float.die_unless(
#    string var_name,
#    string error_message = "variable \"${var_name}\" not a float")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a float.
#/---
#function :Float.die_unless() {
#    # Validate sanity.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string var_name__duvf="${1}"
##
#    # If such variable does not exist, throw an exception. See :Var.is() for
#    # further details.
#    is -n "${(P)var_name__duvf+x}" si or
#        :die "variable \"${var_name__duvf}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # :Float.is() for further details.
#    is "${(tP)var_name__duvf}" == ${~ZY__VAR_TYPE_GLOB_INT}* si or
#        :die "${2:-variable \"${var_name__duvf}\" not a float but defined as:${ZY_ASCII_NEWLINE}$(:Var.print "${var_name__duvf}")}"
#}
#
#:func.doc <<'/---'
#void :Int.die_unless(
#    string var_name,
#    string error_message = "variable \"${var_name}\" not an integer")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be an integer.
#/---
#function :Int.die_unless() {
#    # Validate sanity.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string var_name__duvi="${1}"
#
#    # If such variable does not exist, throw an exception. See :Var.is() for
#    # further details.
#    is -n "${(P)var_name__duvi+x}" si or
#        :die "variable \"${var_name__duvi}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # :is_var_integer() for further details.
#    is "${(tP)var_name__duvi}" == 'integer'* si or
#        :die "${2:-variable \"${var_name__duvi}\" not an integer but defined as:${ZY_ASCII_NEWLINE}$(:Var.print "${var_name__duvi}")}"
#}
#
#:func.doc <<'/---'
#void :Str.die_unless(
#    string var_name,
#    string error_message = "variable \"${var_name}\" not a string")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a string.
#/---
#function :Str.die_unless() {
#    # Validate sanity.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string var_name__duvs="${1}"
#
#    # If such variable does not exist, throw an exception. See :Var.is() for
#    # further details.
#    is -n "${(P)var_name__duvs+x}" si or
#        :die "variable \"${var_name__duvs}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # :Str.is() for further details.
#    is "${(tP)var_name__duvs}" == 'scalar'* si or
#        :die "${2:-variable \"${var_name__duvs}\" not a string but defined as:${ZY_ASCII_NEWLINE}$(:Var.print "${var_name__duvs}")}"
#}
#
#:func.doc <<'/---'
#void {:List.die_unless, :List.die_unless}(
#    string var_name,
#    string error_message = "variable \"${var_name}\" not a list")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a list.
#/---
#function :List.die_unless :List.die_unless() {
#    # Validate sanity.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string var_name__duvl="${1}"
#
#    # If such variable does not exist, throw an exception. See :Var.is() for
#    # further details.
#    is -n "${(P)var_name__duvl+x}" si or
#        :die "variable \"${var_name__duvl}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # :List.is() for further details.
#    is "${(tP)var_name__duvl}" == ('list'|'array')* si or
#        :die "${2:-variable \"${var_name__duvl}\" not a list but defined as:${ZY_ASCII_NEWLINE}$(:Var.print "${var_name__duvl}")}"
#}
#
#:func.doc <<'/---'
#void {:Map.die_unless, :Map.die_unless}(
#    string var_name,
#    string error_message = "\"${var_name}\" not a map")
#
#Throw an exception with the passed message unless the passed variable was
#declared to be a map.
#/---
#function :Map.die_unless :Map.die_unless() {
#    # Validate sanity.
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    string var_name__duvm="${1}"
#
#    # If such variable does not exist, throw an exception. See :Var.is() for
#    # further details.
#    is -n "${(P)var_name__duvm+x}" si or
#        :die "variable \"${var_name__duvm}\" undefined"
#
#    # If such variable is of improper type, throw an exception. See
#    # :Map.is() for further details.
#    is "${(tP)var_name__duvm}" == 'association'* si or
#        :die "${2:-variable \"${var_name__duvm}\" not a map but defined as:${ZY_ASCII_NEWLINE}$(:Var.print "${var_name__duvm}")}"
#}
#
#
#FUXME: These functions are called commonly enough that their implementations
#should be inlined. :var.is_type_matches_glob() is *FAR* too heavyweight a
#function to call so frequently.

#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string var_name__duvm="${1}"
#   :is_map "${var_name__duvm}" or
#       :die "${2:-\"${var_name__duvm}\" not a map}"

    # Validate sanity.
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string var_name__duvl="${1}"

    #FUXME: Quite helpful; replicate above and elsewhere. Actually, since such
    #code would more-or-less be exact duplicates, extricate into a helper function.

    # If such variable is not a list...
#   :List.is "${var_name__duvl}" or
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string var_name__duvs="${1}"
#   :Str.is "${var_name__duvs}" or
#       :die "${2:-variable \"${var_name__duvs}\" not a string}"
#   die_unless_args_1_to_2\
#       'expected one variable name and optional error message'
#   string var_name__duvi="${1}"
#   :is_var_integer "${var_name__duvi}" or
#       :die "${2:-variable \"${var_name__duvi}\" not an integer}"

        # If such variable exists, append such variable's current definition to
        # the exception's message.
#       string message=
#       :Var.is "${var_name__duvl}" and {
#           message+=" "
#           message+="${ZY_ASCII_NEWLINE}original type: $(get_var_type "${var_name__duvl}")"
#       }

        # Throw such exception.
#   :Float.is "${var_name__duvf}" or
#       :die "${2:-\"${var_name__duvf}\" not an float}"
    # Global lists have type "list", local lists "list-local", and zsh-specific
    # global lists (e.g., "${path}") "array" or "array-special".
    # Global maps have type "association" and local maps "association-local".
#By `zsh` precedent, such type is
#of the form `${typename}-${locality}`, where `${typename}` is such type (e.g.,
#`array`, `string`) and `${locality}` is either:
#
#* `global`, if such variable is global.
#* `local`, if such variable is local.
#
#For example:

# :var.is_type_matches_glob "${var_name__duvl}" 'array-local' and message+='hmm!!!!!!!'
#   print -r -- "${(tP)var_name__gvt}"
#       "${glob__ivtm}" or {
#       :stdout.echo "variable type not matching \"${glob__ivtm}\": $(get_var_type "${var_name__ivtm}")"
#   }
#FUXME: Add support for function name synonyms to declare_function().
#void :List.die_unless [or] :List.die_unless(
#void :List.die_unless [or] :List.die_unless(
#void :List.die_unless <or> :List.die_unless(
#void :List.die_unless OR :List.die_unless(
#void :List.die_unless --or-- :List.die_unless(
#void :List.die_unless --OR-- :List.die_unless(
#void :List.die_unless|:List.die_unless(

#string die_unless_list_documentation='  string var_name,
#  string error_message = "\"${var_name}\" not a list")
#
#Throw an exception unless the passed variable is a list.
#'
#
#declare_function "
#void :List.die_unless(
#"
