#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Variable types.
/---

#FIXME: Grep the codebase for other parcels accessing these globals. Most
#shouldn't be! Bad premature optimization, we're afraid. Refactor all such code
#to call testers and setters defined by this parcel, instead.
#FIXME: Indeed, since *NO* other parcels should be accessing such string
#globals, refactor such string globals into a single map global or local of the
#anonymous function below: e.g.,
#
#     :map.global ZY__VAR_TYPE_TO_ZSH_GLOB; ZY__VAR_TYPE_TO_ZSH_GLOB=(
#         :float 'float*'
#         :int   'integer*'
#         :list  '(array|list)*'
#     )

# ....................{ TESTERS ~ type                     }....................
# See the anonymous function below for such function's definitions.

#FIXME: Ugh. Rather than manually documenting these functions here, we should
#almost certainly be automatically documenting where we dynamically define them
#below. To do so, we'll simply need to create a *LOCAL* map from variable
#type to variable noun docstring describing that type: e.g.,
#
#    :map var_type_to_doc; var_type_to_doc=(
#        'Bool' 'booleans'
#        'Number' '*numbers* (i.e., either integers or floats)'
#    )
#
#Given that, dynamically passing the :func.define() function a docstring
#synthesized for the current type should be trivial.

:func.doc <<'/---'
[status=:bool] :Bool.is(+:Str var_names)

Report success if all passed variables are existing booleans or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Char.is(+:Str var_names)

Report success if all passed variables are existing characters or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Float.is(+:Str var_names)

Report success if all passed variables are existing floats or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Int.is(+:Str var_names)

Report success if all passed variables are existing integers or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :List.is(+:Str var_names)

Report success if all passed variables are existing lists or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Map.is(+:Str var_names)

Report success if all passed variables are existing maps or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Number.is(+:Str var_names)

Report success if all passed variables are existing *numbers* (i.e., either
integers or floats) or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Scalar.is(+:Str var_names)

Report success if all passed variables are existing *scalars* (i.e., either
booleans, characters, integers, floats, or strings) or failure otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---


:func.doc <<'/---'
[status=:bool] :Str.is(+:Str var_names)

Report success if all passed variables are existing strings or failure
otherwise.

If any such variable does _not_ exist, an exception is thrown.
/---

# ....................{ SETTERS                            }....................
#FIXME: Actually call this setter elsewhere rather than manually expanding
#"${(tP)...}" everywhere, except where efficiency *ABSOLUTELY* demands such
#optimization.

:func.doc <<'/---'
:void :Var.Type(:Var var_name :Str str_name)

Set the string variable with the second lpassed name to the *type string* (i.e.,
`zsh`-specific lowercase string succinctly synopsizing both the type and scope
this variable was originally declared as) of the variable with the first passed
name.

== Variable Type Strings ==

This type string consists of This variable's type _and_ scope delimited by `-`
(e.g., `array-local`, the type string for local lists). If This scope is
global, This type string omits This scope and hence consists only of This
variable's type without a suffixing `-`.

=== Type ===

If This variable was declared as type:

* Float, this type string is prefixed by `float`.
* Integer, this type string is prefixed by `integer`.
* Map, this type string is prefixed by `association`.
* String, this type string is prefixed by `scalar`.
* List _and_ is a:
** *Canonical `zsh` global* (e.g., ${match}, ${path}), this type string is
   prefixed by `array`.
** *Non-canonical variable* (i.e., user- or `zeshy`-specific), this type string
   is prefixed by `list`.

=== Scope ===

If this variable was declared with scope:

* Local, this type string is suffixed by `-local`.
* Global, this type string omits this scope.
* Exported, this type string is suffixed by `-exported`.

== Examples ==

.:Var.Type()
==========================================
[source]
------------------------------------------
>>> :str type_string
>>> :list on_employment; on_employment=(
...     "Most men would feel insulted if it were proposed to employ them in"
...     "throwing stones over a wall, and then in throwing them back, merely"
...     "that they might earn their wages. But many are no more worthily"
...     "employed now." )
>>> :Var.Type on_employment type_string
>>> :stdout.echo "${type_string}"
array-local
------------------------------------------
==========================================
/---
function :Var.Type() {
    die_unless_args_2 'Expected one variable name and one string name.'
    :str var_name__sstvt=${1} str_name__sstvt=${2}
    :Var.die_unless "${var_name__sstvt}"

    # Set such string to such variable's type. Dismantled, this is:
    #
    # * "P", expanding to such variable's name.
    # * "t", expanding to such variable's type.
    :Str.set "${str_name__sstvt}" "${(tP)var_name__sstvt}"
}

# ....................{ MAIN                               }....................
() {
    # For each zeshy-specific variable type, define testers (documented above)
    # validating variables of that type.
    :str var_type
    for  var_type (
        Bool
        Char
        Float
        Int
        List
        Map
        Number
        Scalar
        String
    ) {
        :func.define\
            '[status=:bool] :'${var_type}'.is(+:Var var_names) [is_args_unhandled]' '
    :Var.die_unless "${@}"
    ::'${var_type}'.is "${@}"'
    }
}
