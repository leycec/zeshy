#!/usr/bin/env zeshy
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle core string functionality.
/---

#FIXME: O.K.; I've had a *MAJOR* rethink on nomenclature here. Any string
#function *NOT* prefixed by "get_" should accept the name of a string *VARIABLE*
#rather than string value as its first argument and set such variable in-place.
#All existing string functions *NOT* prefixed by "get_" should be renamed in
#such a way as to be prefixed by "get_": e.g.,
#
#* Rename reverse_string() to :get_string_reversed().
#* Rename capitalize_string() to :get_string_capitalized().
#
#This is *ABSOLUTELY* essential for our continued sanity and that of our user's.
#Currently, some similarly named functions (e.g.,
#:replace_scalar_text_matching_pcre_by_text(),
#:remove_list_items_matching_glob()) replace in-place, while others don't. The
#former is the only sane nomenclature, however, by virtue of the fact that if we
#abandon such nomenclature, then *ALL* operations on maps and lists (which by
#definition only operation on variables rather than values) must be renamed to
#explicitly specify the fact they operate on variables (e.g., from
#:remove_list_items_matching_glob() to
#:remove_list_variable_items_matching_glob()). But even the denotation
#"_variable" isn't quite right, as the "_scalar" family of functions merely
#operate on general LHSs rather than simple variable names, meaning we'd have to
#embed "_lhs" (or some such) in such families (e.g., from
#:replace_scalar_text_matching_pcre_by_text() to
#:replace_scalar_lhs_text_matching_pcre_by_text()). In other words, we have to
#render function names across a wide variety of classes (namely, list, map, and
#scalar) even *MORE* unreadably verbose than they previously were. Which really
#isn't on the map (...get it? GET IT?) at all.
#
#That said, renaming all functions behaving like getters as getters simply makes
#fundamental sense. It eliminates ambiguity, improves precision, and should
#(hopefully) reduce the inevitable load of repetitous FAQ queries.

# ....................{ CLEARERS                           }....................
:func.doc <<'/---'
void :clear_string(string string_name)

Clear the passed string variable (i.e., set such variable to the empty string):
e.g.,

.:clear_string()
==========================================
[source]
------------------------------------------
>>> :str on_intellectual_property=\
...    "Science and industry, knowledge and application, discovery and practical
...     realization leading to new discoveries, cunning of brain and of hand,
...     toil of mind and muscle – all work together. Each discovery, each
...     advance, each increase in the sum of human riches, owes its being to
...     the physical and mental travail of the past and present. By what right
...     then can anyone whatever appropriate the least morsel of this immense
...     whole and say – This is mine, not yours?"
>>> :clear_string on_intellectual_property
>>> :stdout.echo "${on_intellectual_property}"
------------------------------------------
==========================================
/---
function :clear_string() {
    die_unless_arg 'Expected one string name.'
    :Str.set "${1}" ''
}

# ....................{ REVERSERS                          }....................
:func.doc <<'/---'
string reverse_string(string text1, ...)

Reverse the concatenation of the passed strings: e.g.,

.reverse_string()
==========================================
[source]
------------------------------------------
>>> reverse_string "Satan, oscillate my metallic sonatas!"
!satanos cillatem ym etallicso ,nataS
>>> reverse_string Mr. Owl ate my metal worm...
...mrow latem ym eta lwO .rM
>>> reverse_string Rats live on no evil star.
.rats live on no evil staR
------------------------------------------
==========================================
/---
function reverse_string() {
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... well, not much.
    #
    # Validate sanity.
    die_unless_args 'Expected one or more strings.'
    :list chars chars_reversed

    # Split such strings on characters.
    set_list_to_string_characters chars "${*}"

    # Reverse such list.
    set_list_to_list_reversed chars_reversed chars

    # Concatenate such list elements.
    join_list chars_reversed
}

# ....................{ MUNGERS ~ case                     }....................
:func.doc <<'/---'
void :capitalize_string(string string_name)

Capitalize the first character of each word in the value of the passed string
variable: e.g.,

.:capitalize_string()
==========================================
[source]
------------------------------------------
>>> :str on_modernity=\
...    "Why are we sad and miserable?  Because our modern culture has failed.
...     We are all failures. The world around us has failed to sustain our
...     humanity, our spirituality. The deep woe inside black metal is about
...     fear, that we can never return to the mythic pastoral world that we
...     crave on a deep subconscious level... for modernity has transformed us –
...     our minds, bodies and spirit – into an alien life form, one not suited
...     to life on Earth without the mediating forces of technology, culture,
...     and organized religion. We are weak and pitiful in our strength over the
...     Earth. In conquering, we have destroyed ourselves."
>>> :capitalize_string "${on_modernity}"
>>> get_string_line "${on_modernity}" 1
Why Are We Sad And Miserable? Because Our Modern Culture Has Failed.
------------------------------------------
==========================================
/---
function :capitalize_string() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :str string_name__cs="${1}"
    :Str.die_unless "${string_name__cs}"

    # Capitalize such string.
    :Str.set "${string_name__cs}" "${(CP)string_name__cs}"
}

:func.doc <<'/---'
void :lowercase_string(string string_name)

Lowercase all characters in the value of the passed string variable: e.g.,

.lowercase_string()
==========================================
[source]
------------------------------------------
>>> :str on_warnings=\
...    "Awakened in the morning
...     To more air pollution warnings.
...     Still we sleepwalk off to work
...     While our nervous systems jerk."
>>> :lowercase_string "${on_warnings}"
>>> get_string_line "${on_warnings}" 3
still we sleepwalk off to work
------------------------------------------
==========================================
/---
function :lowercase_string() {
    # Validate sanity.
    die_unless_arg 'Expected one string name.'
    :str string_name__ls="${1}"
    :Str.die_unless "${string_name__ls}"

    # Lowercase such string.
    :Str.set "${string_name__ls}" "${(LP)string_name__ls}"
}

:func.doc <<'/---'
void :uppercase_string(string string_name)

Uppercase all characters in the value of the passed string variable: e.g.,

.:uppercase_string()
==========================================
[source]
------------------------------------------
>>> :str on_body_parts=\
...    "We know how to and sure as shit we'll win.
...     War is peace. (Sure, man.)
...     A retreat for the damned;
...     A playground for the demented;
...     A haven for those who walk this world
...     Bereft of heart and soul.
...     Love and war – they say all is fair.
...     Take his life
...     But won't take his hair.
...     Your body has parts your
...     Country can spare.
...     By the way, son,
...     Here's your wheelchair."
>>> :uppercase_string "${on_body_parts}"
>>> get_string_line "${on_body_parts}" 1
WE KNOW HOW TO AND SURE AS SHIT WE'LL WIN.
------------------------------------------
==========================================
/---
function :uppercase_string() {
    die_unless_arg 'Expected one string name.'
    :str string_name__us="${1}"
    :Str.die_unless "${string_name__us}"

    # Uppercase this string.
    :Str.set "${string_name__us}" "${(UP)string_name__us}"
}
