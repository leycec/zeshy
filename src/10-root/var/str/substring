#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle core substring functionality (i.e., functions operating on substrings
within strings).
/---

# ....................{ PREFIXERS                          }....................
:func.doc <<'/---'
void :str.prefix(string string_name, string prefix)

Unconditionally prepend the passed prefix to the value of the passed string
variable. To conditionally prepend such prefix only if such value is _not_
already prefixed by such prefix, consider calling
:str.prefix_if_unprefixed() instead: e.g.,

.:str.prefix()
==========================================
[source]
------------------------------------------
>>> :str on_humanity=\
...    "You don't hate! Only the unloved hate — the unloved and the unnatural."
>>> prefix_string on_humanity=\
...    "Soldiers! Don't give yourselves to brutes — men who despise you! Enslave
...     you! Who regiment your lives, tell you what to do, what to think or what
...     to feel! Who drill you, diet you, treat you like cattle, use you as
...     cannon fodder! Don't give yourselves to these unnatural men — machine
...     men with machine minds and machine hearts! You are not machines! You are
...     not cattle! You are men! You have the love of humanity in your hearts."
>>> get_string_line on_humanity 1
Soldiers! Don't give yourselves to brutes — men who despise you! Enslave
------------------------------------------
==========================================
/---
function :str.prefix() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one string suffix.'
    :str string_name__ps="${1}"
    :Str.die_unless "${string_name__ps}"

    # Suffix such string.
    :Str.set "${string_name__ps}" "${2}${(P)string_name__ps}"
}

#FIXME: Add example.
:func.doc <<'/---'
void :str.prefix_if_unprefixed(string string_name, string prefix)

Conditionally prepend the passed prefix to the value of the passed string
variable if such value is _not_ already prefixed by such prefix or leave such
value as is otherwise.
/---
function :str.prefix_if_unprefixed() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one string prefix.'
    :str string_name__psiu="${1}" prefix__psiu="${2}"
    :Str.die_unless "${string_name__psiu}"

    # Prefix such string if not found. For efficiency, remove such prefix if
    # found and reprepend such prefix.
    :Str.set "${string_name__psiu}"\
        "${prefix__psiu}${(P)string_name__psiu#${prefix__psiu}}"
}

# ....................{ SUFFIXERS                          }....................
:func.doc <<'/---'
void :Str.suffix(string string_name, string suffix)

Unconditionally append the passed suffix to the value of the passed string
variable. To conditionally append such suffix only if such value is _not_
already suffixed by such suffix, consider calling :suffix_string_if_needed()
instead: e.g.,

.:Str.suffix()
==========================================
[source]
------------------------------------------
>>> :str on_governance=\
...    "To be governed is to be watched, inspected, spied upon, directed,
...     law-driven, numbered, regulated, enrolled, indoctrinated, preached at,
...     controlled, checked, estimated, valued, censured, commanded, by creatures
...     who have neither the right nor the wisdom nor the virtue to do so."
>>> :Str.suffix on_governance '
...     -- Pierre-Joseph Proudhon,
...        "General Idea of the Revolution in the Nineteenth Century"'
>>> :stdout.echo "${on_governance}"
To be governed is to be watched, inspected, spied upon, directed,
law-driven, numbered, regulated, enrolled, indoctrinated, preached at,
controlled, checked, estimated, valued, censured, commanded, by creatures
who have neither the right nor the wisdom nor the virtue to do so.
-- Pierre-Joseph Proudhon,
   "General Idea of the Revolution in the Nineteenth Century"
------------------------------------------
==========================================
/---
function :Str.suffix() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one string suffix.'
    :str string_name__ss="${1}"
    :Str.die_unless "${string_name__ss}"

    # Suffix such string.
    :Str.set "${string_name__ss}" "${(P)string_name__ss}${2}"
}

#FIXME: Rename to :suffix_string_if_unsuffixed(). Somewhat longer but
#significantly more readable, and hence the way forward.

:func.doc <<'/---'
void :suffix_string_if_needed(string string_name, string suffix)

Conditionally append the passed suffix to the value of the passed string
variable if such value is _not_ already suffixed by such suffix or leave such
value as is otherwise: e.g.,

.:suffix_string_if_needed()
==========================================
[source]
------------------------------------------
>>> :str on_ashcans_and_unobtainable_dollars=\
...    "Moloch the incomprehensible prison! Moloch the crossbone soulless jailhouse and
...       Congress of sorrows! Moloch whose buildings are judgment! Moloch the vast stone
...       of war! Moloch the stunned governments!
...     Moloch whose mind is pure machinery! Moloch whose blood is running money!
...       Moloch whose fingers are ten armies! Moloch whose breast is a cannibal dynamo!
...       Moloch whose ear is a smoking tomb!"
>>> :suffix_string_if_needed on_ashcans_and_unobtainable_dollars\
...     "Moloch whose ear is a smoking tomb!"
>>> :stdout.echo "${on_ashcans_and_unobtainable_dollars}"
Moloch the incomprehensible prison! Moloch the crossbone soulless jailhouse and
  Congress of sorrows! Moloch whose buildings are judgment! Moloch the vast stone
  of war! Moloch the stunned governments!
Moloch whose mind is pure machinery! Moloch whose blood is running money!
  Moloch whose fingers are ten armies! Moloch whose breast is a cannibal dynamo!
  Moloch whose ear is a smoking tomb!
------------------------------------------
==========================================
/---
function :suffix_string_if_needed() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one string suffix.'
    :str string_name__ssiu="${1}" suffix__ssiu="${2}"
    :Str.die_unless "${string_name__ssiu}"

    # Suffix such string if not found. For efficiency, remove such suffix if
    # found and reappend such suffix.
    :Str.set "${string_name__ssiu}"\
        "${(P)string_name__ssiu%${suffix__ssiu}}${suffix__ssiu}"
}

# ....................{ REMOVERS                           }....................
#FIXME: Refactor all such functions to accept a string variable instead.

:func.doc <<'/---'
string remove_string_text(string text, string substring)

Remove all instances of the passed substring from the passed string and return
such string: e.g.,

.remove_string_text()
==========================================
[source]
------------------------------------------
>>> :str on_the_rocks_of_time=\
...    "Moloch! Moloch! Robot apartments! invisible suburbs! skeleton treasuries!
...      blind capitals! demonic industries! spectral nations! invincible mad houses
...      granite cocks! monstrous bombs!
...     They broke their backs lifting Moloch to Heaven! Pavements, trees, radios,
...      tons! lifting the city to Heaven which exists and is everywhere about us!"
>>> remove_string_text "${on_the_rocks_of_time}" "Moloch"
! ! Robot apartments! invisible suburbs! skeleton treasuries!
 blind capitals! demonic industries! spectral nations! invincible mad houses
 granite cocks! monstrous bombs!
They broke their backs lifting to Heaven! Pavements, trees, radios,
 tons! lifting the city to Heaven which exists and is everywhere about us!
------------------------------------------
==========================================
/---
function remove_string_text() {
    die_unless_args_2 'Expected one string and one substring.'
    :stdout.echo "${1//${2}}"
}

:func.doc <<'/---'
void :Str.remove_prefix(string string_name, string prefix)

Remove the passed prefix from the value of the passed string variable if such
prefix prefixes such value or leave such value as is otherwise: e.g.,

.:Str.remove_prefix()
==========================================
[source]
------------------------------------------
>>> :str on_cities=\
...    "Moloch whose eyes are a thousand blind windows! Moloch whose skyscrap-
...     ers stand in the long streets like endless Jehovahs! Moloch whose
...     factories dream and croak in the fog! Moloch whose smokestacks and
...     antennae crown the cities!"
>>> :Str.remove_prefix on_cities\
...    "Moloch whose eyes are a thousand blind windows!"
>>> get_string_line "${on_cities}" 1
Moloch whose skyscrap-
------------------------------------------
==========================================
/---
function :Str.remove_prefix() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one string suffix.'
    :str string_name__rsp="${1}" prefix__rsp="${2}"
    :Str.die_unless "${string_name__rsp}"

    # Remove such prefix.
    :Str.set\
        "${string_name__rsp}" "${(P)string_name__rsp##${prefix__rsp}}"
}

:func.doc <<'/---'
void remove_string_suffix(string string_name, string suffix)

Remove the passed suffix from the value of the passed string variable if such
suffix suffixes such value or leave such value as is otherwise: e.g.,

.remove_string_suffix()
==========================================
[source]
------------------------------------------
>>> :str on_cities=\
...    "Moloch whose eyes are a thousand blind windows! Moloch whose skyscrap-
...     ers stand in the long streets like endless Jehovahs! Moloch whose
...     factories dream and croak in the fog! Moloch whose smokestacks and
...     antennae crown the cities!"
>>> remove_string_suffix "${on_cities}"\
...    "Moloch whose eyes are a thousand blind windows!"
Moloch whose skyscrap-

>>> :str on_poverty=\
...    "Moloch whose love is endless oil and stone! Moloch whose soul is electricity
...     and banks! Moloch whose poverty is the specter of genius! Moloch
...     whose fate is a cloud of sexless hydrogen! Moloch whose name is the
...     Mind!"
>>> remove_string_suffix on_poverty "Moloch whose name is the"$'\n'"Mind!"
>>> get_string_line "${on_poverty}" -1
whose fate is a cloud of sexless hydrogen!
------------------------------------------
==========================================
/---
function remove_string_suffix() {
    # Validate sanity.
    die_unless_args_2 'Expected one string name and one string suffix.'
    :str string_name__rss="${1}" suffix__rss="${2}"
    :Str.die_unless "${string_name__rss}"

    # Remove such suffix.
    :Str.set\
        "${string_name__rss}" "${(P)string_name__rss%%${suffix__rss}}"
}

# --------------------( WASTELANDS                         )--------------------
# :func.doc <<'/---'
# string remove_string_suffix(string text, string suffix)
# 
# Remove the passed suffix from the passed string if such suffix suffixes such
# string or leave such string as is. In either case, return such string: e.g.,
# 
# .remove_string_suffix()
# ==========================================
# [source]
# ------------------------------------------
# >>> string on_light_streaming_out_of_the_sky=\
# ...    "Moloch whose love is endless oil and stone! Moloch whose soul is electricity
# ...     and banks! Moloch whose poverty is the specter of genius! Moloch
# ...     whose fate is a cloud of sexless hydrogen! Moloch whose name is the
# ...     Mind!"
# >>> remove_string_suffix "${on_light_streaming_out_of_the_sky}" "Mind!"
# Moloch whose love is endless oil and stone! Moloch whose soul is electricity
#  and banks! Moloch whose poverty is the specter of genius! Moloch
#  whose fate is a cloud of sexless hydrogen! Moloch whose name is the
# ------------------------------------------
# ==========================================
# /---
# function remove_string_suffix() {
#     die_unless_args_2 'Expected one string and one suffix.'
#     :stdout.echo "${1%%${2}}"
# }

    # Suffix such string, if not already. Note this is implementable without
    # explicitly testing whether such string is already suffixed, as follows:
    #
    #     :Str.set "${string_name__ss}"\
    #         "${(P)string_name__ss%${suffix_ssin}}${suffix_ssin}"
    #
    # However, it remains unclear which is the more efficient implementation.
    # is_string_suffix "${(P)string_name__ss}" "${suffix_ssin}" or
    #      :Str.suffix "${string_name__ss}" "${suffix_ssin}"

#  This
# function , such value will be resuffixed by such suffix
# reg if already suffixed by such suffix

# ....................{ (PRE|SUF)FIXERS                    }....................
#FUXME: Refactor into :str.prefix() operating directly on string variables
#and shift to @{substring}.

    # die_unless_args_2 'Expected one string and one prefix.'
    # :stdout.echo "${1##${2}}"

    # However, such implementation calls :Str.set() even when such
    # string is already suffixed and remains slightly less efficient.

# Handle *string removers* (i.e., functions removing substrings from strings).

#However sensible such expansions may
    # seem, they all obstinately return the number of sanity. *sigh*
    # (Don't get us wrong: we know why such reductions fail. They gall, though.)
#   die_unless_stdin_readable_sans_blocking

#...    "As for politics, I'm an anarchist. I hate governments and rules and
#...     fetters. Can't stand caged animals. People must be free."

#...     \"Military intelligence\": two words combined that can't make sense."
#FUXME: Rename to truncate_string_to_length().
#FUXME: Optional arguments are terrible. Split a new
#truncate_string_to_length_and_append_suffix() from this. (To be honest, pretty much
#*EVERY* call to this function should be passing a suffix, so renaming this to
#such function should fix us up tidely.)
#FUXME: You know what -- shouldn't pretty *EVERY* call to this function be
#replaced with the above truncate_string_readable:(), in which case this function
#can simply (and happily!) be deleted?

#:func.doc <<'/---'
#string truncate_string(
#    string text, integer maximum_length, string text_suffix_if_truncated = "")
#
#Truncate the passed string to the passed length, replacing the end of such
#string with the passed suffix (defaulting to the empty string) if the passed
#string exceeds such length: e.g.,
#
#.truncate_string()
#==========================================
#[source]
#------------------------------------------
#>>> truncate_string "Fallujah" 7
#Falluja
#>>> truncate_string "Fallujah" 7 "..."
#Fall...
#------------------------------------------
#==========================================
#/---
#function truncate_string() {
#    # Validate sanity.
#    die_unless_args_2_to_3\
#        'expected one string, one length, and optional suffix'
#    string text="${1}" max_length="${2}" text_suffix_if_truncated="${3:-}"
#    :int.die_unless_positive "${max_length}"
#
#    # If the passed string requires no truncation, return the same string.
#    (( ${#text} <= max_length )) and :str.return "${text}"
#
#    # If a suffix was passed and the passed string is at least as long as such
#    # suffix, truncate by replacing the end of the string with such suffix.
#    if (( ${#text_suffix_if_truncated} &&
#          ${#text} > ${#text_suffix_if_truncated} )) {
#        (( max_length -= ${#text_suffix_if_truncated} ))
##       print "max_length: ${max_length}"
#        :str.return "${text[1,${max_length}]}${text_suffix_if_truncated}"
#    # Otherwise, truncate without suffix replacement.
#    } else {
#        :str.return "${text[1,${max_length}]}"
#    }
#}

# likely to produce aesthetic or human-readable output
# (Truncating after punctuation rather than indiscriminately improves aesthetics.)
#[^.,;!?]##
    #FUXME: Close, but not quite right. Ideally, we want to preserve human-
    #readable list output when truncating. Humans expect output resembling:
    #     "I mrethil", "p...", ...
    #Rather than:
    #     "I mrethil", "peliar"...
    #Not terribly easy or readibly internationalizable, so I suppose I'm content
    #with this as is. For now...

    # zsh implements string repetition in one of two ways:
    #
    # * With the "l" parameter expansion flag, as below.
    # * With the printf() builtin, as below.
    #
    # While the former fails in the unlikely event such text contains all
    # possible parameter expansion tokens, the 
    # avoids the multiplication of the former, it also
    # expands the expression "{1..${count}}" to all integers in such range and
    # hence fails to efficiently scale to large counts. On the other hand, the
    # latter . Prefer the  We reconcile these differences as follows:
    #
    # * If such text does *NOT* contain at least one such token, perform the
    #   latter with such token.
    # * Else, perform the former.
#FUXME: Contemplate renaming back to :str.contains(), which reads much more
#naturally than this. Search for other instances of "_substring" in function
#names; perhaps we had a respectable reason for adopting such nomenclature?
#FUXME: Yeah. This is great. Rename back to :str.contains(), in keeping
#with the existing is_string_equals() nomenclature. But the *REAL* reason is
#much more compelling: because we have numerous other functions elsewhere testing
#containment, each currently with their own domain-specific nomenclature
#(e.g., is_list_contains()). *THIS IS NONSENSE.* All containment testers should
#share the same nomenclature: _contains(). Why? Because anything else induces
#thinking on trying to remember the domain-specific noun for testing that
#particular type of containment, which ends up being just horrible. (Even I
#can't keep it straight.) Hence, rename is_list_contains() to is_list_contains()
#as well.
    #FUXME: This can be dramatically improved upon by recalling that
    #:list.set_to_string_split_on_string() currently concocts an impressive
    #algorithm for efficiently finding the first available free token (e.g.,
    #":", ".", "'", '"', and so on). Generalize such algorithm into a new
    #function accepting only a single string and:
    #
    #* If an available free token exists for such string, returning non-zero
    #  exit status and printing such token;
    #* Otherwise, returning zero exit status and printing nothing.
    #
    #Assuming such function to be sensibly named
    #get_string_parameter_expansion_token(), call such function as follows:
    #
    #    string token
    #    if token="$(get_string_parameter_expansion_token "${text}")"
    #    then # ...do something with the token!
    #    else # ...otherwise try to find another way to do it or just :die.
    #    fi
    #
    #Awesomeness!

    # zsh implements string repetition in one of two ways:
    #
    # * With the printf() builtin, as below.
    # * With the "l" parameter expansion flag, as below.
    #
    # While the former avoids the multiplication of the latter, it also
    # expands the expression "{1..${count}}" to all integers in such range.
    # When repeating characters, this often creates excessively many arguments,
    # impeding efficiency. Unfortunately, the latter fails when the passed text
    # contains a colon. We reconcile these differences as follows:
    #
    # * If the passed text contains a colon, run the former slower command.
    # * Otherwise, run the latter faster command.
#   if { :str.contains "${text}" ':' } {
        # Since printf() appends no newline by default, do so.
#       printf -- "${text}%.0s" {1..${count}}
#       :str.return "${ZY_ASCII_NEWLINE}"
#   } else {
        # Total length of the repeated result, below.
#       integer result_length
#       (( result_length = count * $(get_string_length "${text}") ))

        # Print such result.
#       eval ":str.return \${(l:\${result_length}::${text}:):-}"
#   }

#   die_unless_string_nonempty "${text}" 'string to be repeated empty'
    # While external command "rev" implements such operation as well, a pure zsh
    # implementation is likely to be faster on small strings. It's also more
    # amusing, and that surely counts for... something.
#:func.doc <<'/---'
#string get_string_text_count(string string, string substring)
#
#Get the number of instances of the passed substring in the passed string: e.g.,
#
#.get_string_text_count()
#==========================================
#[source]
#------------------------------------------
#>>> get_string_text_count "cult of radical consumerism" "c"
#3
#------------------------------------------
#==========================================
#/---
#function get_string_text_count() {
    # The difference between the passed string and such string excluding all
    # instances of the passed substring divided by the length of such substring
    # gives the number of such instances. Math for the obscene win!
#   die_unless_args_2 'expected one string and one substring'
#   string text="${1}" substring="${2}" string_sans_substring
#   string_sans_substring="${text//${substring}}"
#   :str.return $(( (${#string} - ${#string_sans_substring}) / ${#substring} ))
#}

#FUXME: Rename to set_string_if_unset_to_string().
#declare_function '
#void set_string_if_unset(string string_name, string text)
#
#Set the passed variable if unset to the passed string: e.g.,
#
#    >>> string gnomes_say="hooray" hooray
#    >>> set_string_if_unset "${gnomes_say}" "lesser lights of the Bardo"
#    >>> :stdout.echo "${hooray}"
#    lesser lights of the Bardo
#'
#function set_string_if_unset() {
#    die_unless_args_2 'expected one variable name and one string'
#    noop ${(P)1=${2}}
#}

#declare_function '
#integer get_string_ansiless_length_printable(string text)
#
#Get the number of  length of the passed string in multibyte characters.
#'
#function get_string_ansiless_length_printable() {
#    # While parameter flag "(mm)" counts multibyte characters, parameter flag
#    # "(m)" counts only printable multibyte characters, thus ignoring control
#    # characters (e.g., newline). See get_string_length() for further caveats.
#    die_unless_args 'expected at least one string'
#    :stdout.echo "${(mm)#${*}}"
#}

#       print "result length: ${result_length}"
#   else eval "print -- ${(l:$((${#text} * ${count}))::\\${text}:):-}"
#FUXME: Rename to remove_string_text(). The current nomenclature implies
#removal of only one such substring, which is not the case.
#FUXME: For consistency, the following functions should be renamed
#:Str.die_unless(), :die_unless_char(), and so on.
#Naturally, that implies similar renamings of list *TYPE TESTING* functions to
#:List.die_unless(), :Map.die_unless(), :List.is(), and
#so on. *BUT STOP THERE.* Rename only functions testing variable types in this
#manner; all other existing functions (in particular, non-type testing list and
#map functions such as join_list_on_newline() and get_list_size()) *RETAIN THEIR
#EXISTING FUNCTION NAMES*. This gives us the best of all worlds: consistent
#naming for functions testing variable type, concise and consistent naming for
#list and map functions, and concise and consistent naming for string functions.
#
#This is good. It's a simple patch, so make it so.

#       integer suffix_length
#       suffix_length="$(get_string_length "${suffix_if_exceeding_max_length}")"
#       (( max_length >  suffix_length )) && {
#           (( max_length -= suffix_length ))
#           print "max_length: ${max_length}"
#           :stdout.echo "${text[1,${max_length}]}${suffix_if_exceeding_max_length}"
#           :success.report
#       }
#   }

    # Otherwise, truncate without suffix replacement.
#   :stdout.echo "${text[1,${max_length}]}"

#FUXME: Bad. Remove entirely, replacing existing calls with
#:die_unless_var_nonempty().
# void :die_unless_var_nonempty(
#   string string_name,
#   string error_message = "\"${string_name}\" not a string or empty")
#
# Throw an exception unless the passed variable is a non-empty string.
#function :die_unless_var_nonempty() {
#    die_unless_args_1_to_2\
#        'expected one variable name and optional error message'
#    :Var.is_nonempty "${1}" or
#        :die "${2:-\"${1}\" not a string or empty}"
#}

#FUXME: Bad. Remove entirely, replacing existing calls with
#:Var.is_nonempty().
# boolean :Var.is_nonempty(string string_name)
#
# Return true if the passed variable is a nonempty string.
#function :Var.is_nonempty() {
#    die_unless_arg 'expected one variable name'
#    string string_name="${1}"
#    :Str.is "${string_name}" and (( ${#${(P)string_name}} ))
#}

#   integer text_length; text_length="$(get_string_length "${text}")"

#FUXME: I'm beginning to wonder if all string functions shouldn't accept a
#variable *NAME* rather than type. Hmm; no, actually. It's rather dangerous,
#though it appears somewhat more elegant, due to the risk of variable name
#shadowing. Safest to copy all parameters rather than try the reference
#approach, yes?

    #FUXME: It might be nice to create a family of string functions for testing
    #string content: e.g.,
    #
    #* string :str.contains(string text, string substring)
    #* string is_string_prefix(string text, string prefix)
    #* string is_string_suffix(string text, string suffix)
    #
    #For example, the first simply implements:
    #    is "${1}" == *"${2}"* si

#   eval\
#       "${prefix_name}:catch\"${text%%${delimiter}*}\"; "\
#       "${suffix_name}:catch\"${text#*${delimiter}}\""

# string get_first_word(string text, string text2, ...)
#
# Get the first word from the passed string.
#get_first_word() {
#    die_unless_args 'expected at least one string'
#    :stdout.echo "${*[(w)1]}"
#}

#       print_message "piped_input: $(get_stdin_piped)"
#       text="$(get_stdin_piped)"
    # Validate sanity.
#   print -lr -- "${(uf)@}"
#   print_strings_newlined ${(uf)@}
#   map unique_lines
    #list lines; lines=( )

#   foreach line (${(f)@}) {
#       :map.is_key unique_lines "${line}" or {
#           :stdout.echo ${line}
#           unique_lines[${line}]=
#       }
#   }
# Also, suffix
#with "_string" for safety (i.e., we might someday want a capitalize_string_list()
#function, in which case a capitalize_string() function sows confusion).
#FUXME: I'm fairly sure that, as with the "(f)" flag above, the "(w)" flag
#erroneously operates on characters if there exists only one such word. Fix.
#Hmm. Perhaps not. It appears to operate completely differently, actually, being
#an index rather than parameter expansion. Also, do we really need a
#get_first_word() function? Seems a tad superfulous.

# string number_string_lines_highlighting_line(
#   int highlight_line_index,
#   string text1, string text2, ...)
#
# Prefix each line of the passed string with that line's number and highlight
# the passed line number. Since "nl" supports no highlighting, this function
# accepts no "nl"-specific options.
#number_string_lines_highlighting_line() {
#    # Localize sanity.
#    die_unless_args_2_or_more\
#        'expected one line number and one or more strings'
#    :int.die_unless "${1}"
#    integer highlight_line_index="${1}" line_length
#    shift_arg
#    string text="${@}"

#FUXME: By definition, you only join a list to a string and split a list to a
#string. Hence, these function names are overly verbose. Rename
#join_join_list() to join_list_on() and
#join_join_list_prefixing_last_with() to join_list_prefixing_last_element_with().
#This produces much more legible code.

#FUXME: Right. join_list() is simply too brief. join_join_list() reads
#better.

    # Localize sanity.
#   die_unless_args\
#       'expected zero or more "nl" options and one string'
#   string text="${@[-1]}"
#   pop_arg

    # Prefix.
#   list nl; nl=( nl "${ZY_OPTIONS_NL[@]}" )
#   :stdout.echo "${text}" | {
#       if :shell.is_interactive
#       then "${nl[@]}" "${ZY_OPTIONS_NL_IF_SHELL_INTERACTIVE[@]}"     "${@}"
#       else "${nl[@]}" "${ZY_OPTIONS_NL_IF_SHELL_NONINTERACTIVE[@]}" "${@}"
#       fi
#   }

    #FUXME: Implementable with pure-zsh.
#   :stdout.echo "${1}" | head --lines="${2:-1}"

#   list newline_split; newline_split=( "${(s:\n:)1}" )
#   print "first line: ${newline_split[1]}"

# string get_first_line(string text)
#
# Get the first line from the passed string.
#get_first_line() {
#    die_unless_arg 'expected one string'
#   :stdout.echo "${1[(f)1]}"
#}

#   # Localize sanity.
#   (( # >= 1 && # <= 2 )) ||
#       :die 'expected one string and optional first line number'
#   local text="${1}"
#   integer first_line_index="${2}"

    # Prefix.
#   nl -v${first_line_index} "${text}"

    # Bizarrely, the "(f)" no longer appears to behave as advertised on my
    # install. In fact, it no longer does anything at all. Consequently, we
    # perform a brute-force split on newlines. Ideally, this should be:
    #
    #     print "${#${(f)1}}"
    # 
    # Unfortunately, we can't even expand this to:
    # 
    #     print "${#${(s:\n:)1}}"
    # 
    # Doing so behaves correctly for all input *EXCEPT* that without newlines.
    # Consequently, we perform an even more brute-force split into a list.
#     >>> set_list_to_string_split_on '"Contumely Hard" Climaxes' array
#     >>> print "${array[1]}"
#     Contumely Hard
#    # If the caller passed no separator, default to word splitting.
#   if :str.is_empty "${separator}"
#   then eval ${list_name}'=( ${(z)text} )'

#   :Var.is "${target_name_prefix}" or string ${target_name_prefix}
#   :Var.is "${target_name_suffix}" or string ${target_name_suffix}
#   :Var.is "${list_name}" or list "${list_name}"

#   :Str.die_unless "${target_name_prefix}"
#   :Str.die_unless "${target_name_suffix}"

#Compare the lengths of the original and resulting strings.
#   local string_matches_deleted="${string//${~glob}/}"
#   local glob_characters="${#glob//}"
#   print $(((${#string} - ${#string_matches_deleted}) / ${#glob}))
#   print "string_newlined: ${string_newlined}"
