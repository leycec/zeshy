#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *characters* (i.e., strings of multibyte length 1).
/---

# ....................{ EXCEPTIONS                         }....................
declare_function_with_stdin <<'/---'
void :die_unless_char(
    string text,
    string error_message = "String \"${text}\" not a character.")

Throw an exception with the passed message unless the passed string is a
character. See :is_char() for further details.
/---
function :die_unless_char() {
    die_unless_args_1_to_2 'Expected one string and optional error message.'
    :string value="${1}"
    :is_char "${value}" or :die "${2-String \"${value}\" not a character.}"
}

# ....................{ TESTERS                            }....................
declare_function_with_stdin <<'/---'
[status: boolean] :is_char(string text)

Return success if the passed string is either a single- or multibyte character
(i.e., either a single- or multibyte string of length 1). By `zsh` constraints,
this function incorrectly returns false for non-ASCII, non-printable multibyte
characters (e.g., Unicode code point U+00A0, a non-breaking space). While this
this is probably fine for most purposes, your shell mileage may vary.
/---
function :is_char() {
    # zsh provides a builtin means of obtaining strings lengths in both single-
    # byte *AND* printable multibyte characters but *NOT* in multibyte
    # characters. Consequently, this function cannot be implemented by testing
    # string length. However, assuming the shell option "MULTIBYTE" retains its
    # default value, zsh does provide a builtin means of testing whether the
    # length of a string in multibyte characters is some number: glob operators!
    die_unless_arg 'Expected one string.'
    is "${value}" == ? si
}

# --------------------( WASTELANDS                         )--------------------
    # While zsh has no builtin support for obtaining string length in multibyte
    # characters, it does support obtaining string length in *PRINTABLE*
    # multibyte characters. With perscipacity, the following thus suffices:
    #
    # * If such string's byte length is 1, this is an ASCII character. In such
    #   case, report success.
    # * Else, this is either:
    #   * An empty string of length 0.
    #   * An ASCII string of length greater than 1.
    #   * A multibyte string of length greater than or equal to 1.
    #   To differentiate the three cases, get the number of printable multibyte
    #   characters in such string. If such number is 1, this is a printable
    #   multibyte character. In such case, report success; else, report failure.
    #
    # While this excludes non-ASCII, non-printable multibyte characters from
    # consideration as "characters", there genuinely isn't much we can do about
    # this at the moment. *shrug*
    # :string value="${1}"
    # (( $(get_string_length "${value}") == 1 ||
    #    $(get_string_ansiless_length_printable "${value}") == 1 ))

    # Test such variable. Support multibyte character encodings by
    # calling get_string_ansiless_length_printable() rather than get_string_length().
#FUXME: Rename to :die_unless_char(). (There might be a real
#"character" type, someday.)
