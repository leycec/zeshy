#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2017 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *maps* (i.e., associative arrays).
/---

# ....................{ PRINTERS                           }....................
:func_ ':str print_map(:str map_name)' :func{
    # Validate sanity.
    die_unless_arg 'Expected one map name.'
    :str map_name__pm="${1}"
    :Map.die_unless "${map_name__pm}"

    #FIXME: Avoid getters during iteration. Hence, define a new function
    #:set_string_to_string_escaping_double_quotes:() and call such function below
    #in place of the existing command substitution.
    #FIXME: Style with colors.
    #FIXME: Consider aligning keys into columns. Of course, this is only really
    #feasible if all keys are sufficiently short; even a single lengthy key
    #renders the entire effort unprintable. Nonetheless, it seems worth the
    #attempt, if all keys are sufficiently short.

    # Page such output.
    {
        # Prefix such map with its name.
        print_message_heading "Map ${map_name__pm}"

        # Print such map.
        for_map_key_value_pairs "${map_name__pm}" '
            # If such key contains a colon or whitespace, quote such key. For
            # efficiency, inline such test.
            if is "${KEY}" == *[:[:space:]]* si {
                :stdout.echo "\"$(escape_string_double_quotes "${KEY}")\": ${VALUE}"
            # Else, print such key as is.
            } else {
                :stdout.echo "${KEY}: ${VALUE}"
            }'
    } | page_stdin
}:func <<'/---'
Print a human-readable synopsis of the passed map.
/---

# --------------------( WASTELANDS                         )--------------------
    # Handle previously updated standard output tracking.
#   :print_stdout_separated_start

    # Update standard output tracking in preparation for subsequent handling.
#   :print_stdout_separated_stop

        # Remove the map name from the argument list.
#       shift_arg

#>>> map hollow_moon
#>>> listset adams_curse; adams_curse=( We sat grown quiet at the name of love )
#>>> set_map_to_listset_inverted hollow_moon adams_curse
#>>> print_map hollow_moon
#We: 1
#sat: 2
#grown: 3
#quiet: 4
#at: 5
#the: 6
#name: 7
#of: 8
#love: 9

    # . Clear such target map and for each such source map, copy such map's
    # key-value pairs into such target map. For efficiency, inline such logic.
#FUXME: Pure madness. Efficiency isn't a concern in this context. (When it is,
#the caller simply inlines such implementation.) Hence:
#
#* Excise this function.
#* Rename set_map_to_maps() to set_map_to_map().
#:func.doc <<'/---'
#string set_map_to_map(string target_map_name, string source_map_name)
#
#Set the passed target to the passed source map (i.e., copy the latter into the
#former): e.g.,
#
#.set_map_to_map()
#==========================================
#[source]
#------------------------------------------
#>>> map in_this_world the_good_earth
#>>> the_good_earth=(
#...     "We all"  "want to help one another. Human beings are like that."
#...     "We want" "to live by each other's happiness â€” not by each other's"
#...     "misery." "We don't want to hate and despise one another."
#...     "In"      "this world there is room for everyone. And the good earth is"
#...     "rich"    "and can provide for everyone. The way of life can be free"
#...     "and"     "beautiful, but we have lost the way." )
#>>> set_map_to_map  in_this_world the_good_earth
#>>> :stdout.echo "${in_this_world[and]}"
#beautiful, but we have lost the way.
#------------------------------------------
#==========================================
#/---
#function set_map_to_map() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one target map name and one source map name'
#    string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
#    :Map.die_unless "${map_name_target__smtm}"
#    :Map.die_unless "${map_name_source__smtm}"
#
#    # Copy such map.
#    eval "${map_name_target__smtm}:catch( \"\${(kv@P)map_name_source__smtm}\" )"
#}

#       {
#       string map_name__gmkv="${1}" key__gmkv="${2}"
#       :die "map \"${map_name__gmkv}\" has no key \"${key__gmkv}\""
#   }

    # Test such map, inlined for efficiency. Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'i', expanding to the index of such key if such map contains such key or
    #   the empty string otherwise.
    # * 'e', matching such key as a plain string rather than extended pattern.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#FUXME: To retain orthogonolity with the builtin for() iterator, the optional
#local variable names should *ALWAYS* be passed first. Hence, change this to:
#
#string for_map_key_value_pairs(
#    string key_string_name = "KEY",
#    string value_string_name = "VALUE",
#    string map_name,
#    string command)
# Since this overwrites all prior values for such keys within such
# target map, key-value pairs from later source maps take higher precedence than
# those from earlier source maps.
#FUXME: Excise. This should be called *NOWHERE*.
#declare_function '
#void set_map_to_evaluation(string map_name, string code)
#
#Set the passed map to the dynamic evaluation of the passed code in a map
#context (i.e., in an expression resembling "( ${code} )"): e.g.,
#
#    >>> map sopa
#    >>> set_map_to_evaluation sopa ''${:-stop officer perjury act}''
#    >>> :stdout.echo "${sopa[perjury]}"
#    act
#'
#function set_map_to_evaluation() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one code snippet'
#    string map_name__smte="${1}"
#    :Map.die_unless "${map_name__smte}"
#
#    # Set such map.
##   :stdout.echo "set map ${map_name__smte}:catch( ${2} )"
#    eval "${map_name__smte}:catch( ${2} )"
#}

# ....................{ GETTERS ~ key-value                }....................
#:func.doc <<'/---'
#string get_map_key_values(string map_name)
#
#Get all key-value pairs of the passed map in arbitrary order, delimited by the
#current shell word separator(s) and hence suitable for iteration. Only call this
#function when *ALL* map values are guaranteed *NOT* to contain such separator
#(i.e., canonical global ${IFS}, defaulting to newline, space, and tab); if at
#least one map value could possibly contain such separator(s), consider iterating
#with get_map_keys() instead: e.g.,
#
#    >>> map lal_ded; lal_ded=( For ever we come, for ever we go )
#    >>> for lalla vakh ( $(get_map_keys lal_ded) ) {
#    ...     :stdout.echo "key: ${lalla} -- value: ${vakh}"
#    ... }
#    key: For -- value: ever
#    key: we -- value: come,
#    key: for -- value: ever
#    key: we -- value: go
#/---
#function get_map_key_values() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    :Map.die_unless "${map_name__gmk}"
#
#    # Get such pairs.
#    :stdout.echo "${(kv@P)map_name__gmk}"
#}

# ....................{ GETTERS ~ keys                     }....................
#FUXME: *THIS IS TERRIBLE*. So are the getters below, for the simple reason that
#they only work as documented when no key contains whitespace. What? That's pure
#nonsense. Instead, define a new family of for_map_keys*() iterators below and
#translate all existing calls to get_map_keys*() functions to such iterators.
#:func.doc <<'/---'
#string get_map_keys(string map_name)
#
#List all keys of the passed map in arbitrary order, delimited by the current
#shell word separator(s) and hence suitable for iteration: e.g.,
#
#.get_map_keys()
#==========================================
#[source]
#------------------------------------------
#>>> map passchendaele; passchendaele=( the "old Lie" dulce et decorum est )
#>>> for dead ( $(get_map_keys passchendaele) ) {
#...     :stdout.echo "key: ${dead} -- value: ${passchendaele[${dead}]}"
#... }
#key: the -- value: old Lie
#key: dulce -- value: et
#key: decorum -- value: est
#------------------------------------------
#==========================================
#/---
#function get_map_keys() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    :Map.die_unless "${map_name__gmk}"
#
#    # Get such keys.
#    :stdout.echo "${(k@P)map_name__gmk}"
#}
#
#:func.doc <<'/---'
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map in lexical ascending order, delimited by the
#current shell word separator(s) and hence suitable for iteration.
#/---
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    :Map.die_unless "${map_name__gmksla}"
#
#    # Sort such keys.
#    :stdout.echo "${(ko@P)map_name__gmksla}"
#}
#
#declare_function '
#string get_map_keys_sorted_lexically_descending(string map_name)
#
#Get all keys of the passed map in lexical descending order, delimited by the
#current shell word separator(s) and hence suitable for iteration
#'
#function get_map_keys_sorted_lexically_descending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    :Map.die_unless "${map_name__gmksla}"
#
#    # Sort such keys.
#    :stdout.echo "${(kO@P)map_name__gmksla}"
#}

#FUXME: O.K.; so, it'd be great to be able to specify names for such string
#locals. In the case of "io/color/color", for example, we want keys to be in
#string local ${color_style_name} and values to be in string local
#${color_name}. I'm generally intolerant of optional parameters -- but, here
#they really do seem to make sense. The function call remains equally readable
#with or without such parameters specified: e.g.,
#
#    for_map_key_value_pairs ZY_COLOR_8 color_style_name color_name\
#        'ZY_COLOR_2[${color_name}]='
#
#I dig it. Easy to support; easy to call. No need for separate functions, here.

#   if { is_args_3 } {
#       key_name="${2}"
#   }
#   elif { is_args_4 } {
#       key_name="${2}"
#       value_name="${3}"
#   }

    # Print such map.
#   for key (${(k)${(k@P)map_name__pm}}) {
#       # If such key contains a colon or whitespace, quote such key.
#       if { :str.^=.is "${key}" [:[:space:]] } {
#           :stdout.echo "\"$(escape_string_double_quotes "${key}")\": ${${(k@P)map_name__pm}[${key}]}"
#       # Else, print such key as is.
#       } else {
#           :stdout.echo "${key}: ${${(k@P)map_name__pm}[${key}]}"
#       }
#   }
    # Current key-value pair.
#   string KEY VALUE

#function yiyi() {
#    get_map_key_value_if_found ZY_MAP_TO_EMULATABLE_SHELL_NAME "zsh"
#    print $(get_map_key_value_if_found ZY_MAP_TO_EMULATABLE_SHELL_NAME "zsh")
#}

        #FUXME: Generalize quote escaping into a new function
        #escape_string_double_quotes(). It's complex enough to warrant such
        #generalization.
#           :stdout.echo "\"${key//\"/\\\"}\": ${${(k@P)map_name__pm}[${key}]}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#   :str.is_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"

#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#declare_function '
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    :Map.die_unless "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # :map.is_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if :str.is_nonempty "${__
#   :stdout.echo ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   :str.is_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map()
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or :die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
