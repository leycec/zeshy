#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *map setters* (i.e., functions setting map variables).
/---

#FIXME: Most (if not all) inefficient calls to builtin eval() below can be
#replaced by efficient calls to builtin set(): e.g.,
#
#    set -a "${map_name__smtm}" "${@}"

# ....................{ SETTERS                            }....................
:func.document <<'/---'
void set_map_to_map(
    string target_map_name,
    string source_map_name1, string source_map_name2, ...)

Set the passed target map to the passed source map (i.e., copy the latter into
the former): e.g.,

.set_map_to_map()
==========================================
[source]
------------------------------------------
>>> :map on_loathing on_fear; on_fear=(
...    "We"    "are turning into a nation of whimpering slaves to Fear – fear"
...    "of"    "war, fear of poverty, fear of random terrorism, fear of getting"
...    "down-" "sized or fired because of the plunging economy, fear of getting"
...    "evicted" "for bad debts, or suddenly getting locked up in a military"
...    "detention" "camp on vague charges of being a Terrorist sympathizer..." )
>>> set_map_to_map  on_loathing on_fear
>>> :string.output "${on_loathing[We]}"
are turning into a nation of whimpering slaves to Fear – fear
------------------------------------------
/---
function set_map_to_map() {
    # Validate sanity.
    die_unless_args_2 'Expected one target map name and one source map name.'
    :string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
    :var.die_unless_type_map "${map_name_target__smtm}" "${map_name_source__smtm}"

    # Copy such source map into such target map.
    eval ${map_name_target__smtm}'=( "${(kv@P)map_name_source__smtm}" )'
}

:func.document <<'/---'
void set_map_to_map_union(
    string target_map_name,
    string source_map_name1, ...)

Set the passed target map to the union of the passed source maps in the passed
order. Specifically, clear such target map and for each source map in the passed
order, copy all key-value pairs of such source map into such target map. Hence,
key-value pairs of source maps passed later take higher precedence than those of
source maps passed earlier. At least two source maps must be passed: e.g.,

.set_map_to_map_union()
==========================================
[source]
------------------------------------------
>>> :map for_unity on_wants on_needs
>>> on_wants=(
...     "We"   "have developed speed, but"
...     "we"   "have shut ourselves in. Machinery that gives abundance has"
...     "left" "us in want. Our knowledge has made us cynical. Our cleverness,"
...     "hard" "and unkind. We think too much and feel too little." )
>>> on_needs=(
...     "More" "than machinery"
...     "we"   "need humanity. More than cleverness we need kindness"
...     "and"  "gentleness. Without these qualities, life will be violent and"
...     "all"  "will be lost." )
>>> set_map_to_map_union for_unity on_wants on_needs
>>> print_map for_unity
We: have developed speed, but
we: need humanity. More than cleverness we need kindness
left: us in want. Our knowledge has made us cynical. Our cleverness,
hard: and unkind. We think too much and feel too little.
More: than machinery
and: gentleness. Without these qualities, life will be violent and
all: will be lost.
------------------------------------------
/---
function set_map_to_map_union() {
    # Validate sanity.
    die_unless_args_3_or_more\
        'Expected one target map name and two or more source map names.'
    :string map_name_target__smtmu="${1}"
    :var.die_unless_type_map "${map_name_target__smtmu}"
    shift_arg

    # Union such source maps into such target map after clearing the latter.
    eval ${map_name_target__smtmu}'=()
    :string map_name_source__smtmu
    for     map_name_source__smtmu ("${@}") {
        :var.die_unless_type_map "${map_name_source__smtmu}"
        '${map_name_target__smtmu}'+=( "${(kv@P)map_name_source__smtmu}" )
    }'
}

# ....................{ SETTERS ~ list                     }....................
:func.document <<'/---'
void set_map_to_listset_inverted(string map_name, string listset_name)

Set the passed map to the inversion of the passed list set, such that the keys
of such map are the elements of such list set and the values of such map are the
corresponding 1-based indices of such elements: e.g.,

.set_map_to_listset_inverted()
==========================================
[source]
------------------------------------------
>>> :map on_the_way_of_life
>>> :listset on_the_good_earth; on_the_good_earth=(
...     "We all want to help one another. Human beings are like that. We want"
...     "to live by each other's happiness — not by each other's misery. We"
...     "don't want to hate and despise one another. In this world there is"
...     "room for everyone. And the good earth is rich and can provide for"
...     "everyone. The way of life can be free and "beautiful, but we have lost"
...     "the way." )
>>> set_map_to_listset_inverted on_the_way_of_life on_the_good_earth
>>> print_map on_the_way_of_life
We all want to help one another. Human beings are like that. We want: 1
to live by each other's happiness — not by each other's misery. We: 2
don't want to hate and despise one another. In this world there is: 3
room for everyone. And the good earth is rich and can provide for: 4
everyone. The way of life can be free and "beautiful, but we have lost: 5
the way.: 6
>>> :string.output "${on_the_way_of_life[the\ way.]}"
6
------------------------------------------
/---
function set_map_to_listset_inverted() {
    #FIXME: We should permit non-list sets as well, right?

    # Validate sanity.
    die_unless_args_2 'Expected one map name and one list name.'
    :string map_name__smtli="${1}" listset_name__smtli="${2}"
    :int listset_size__smtli
    :var.die_unless_type_map "${map_name__smtli}"
    die_unless_listset "${listset_name__smtli}"

    # Get the size of such list set.
    :set_int_to_list_size listset_size__smtli "${listset_name__smtli}"

    # Set such map to such list set inverted.
    eval '
    :int listset_index__smtli
    for  listset_index__smtli ({1..${listset_size__smtli}) {
        '${map_name__smtli}'[${'${listset_name__smtli}'[${listset_index__smtli}]}]=${listset_index__smtli}
    }'
}

# ....................{ SETTERS ~ key                      }....................
:func.document <<'/---'
void :set_string_to_map_key_value(
    string string_name,
    string map_name,
    string key)

Set the passed string variable to the value of the passed key in the passed map
if such map contains such key or throw an exception otherwise: e.g.,

.:set_string_to_map_key_value()
==========================================
[source]
------------------------------------------
>>> :string on_chains
>>> :map on_fetters; on_fetters=(
...     "I"     "have almost reached the regrettable conclusion that"
...     "the"   "Negro's great stumbling block in his stride toward freedom is"
...     "not"   "the White Citizen's Counciler or the Ku Klux Klanner, but the"
...     "white" 'moderate, who is more devoted to "order" than to justice;'
...     "who"   "prefers a negative peace which is the absence of tension to"
...     "a"     "positive peace which is the presence of justice; who constantly"
...     "says:" '"I agree with you in the goal you seek, but I cannot agree'
...     "with"  'your methods of direct action."'
... )
>>> :set_string_to_map_key_value on_chains on_fetters white
>>> :string.output "${white}"
moderate, who is more devoted to "order" than to justice;
------------------------------------------
==========================================
/---
function :set_string_to_map_key_value() {
    :set_string_to_map_key_value_if_found "${@}" or
        die_unless_map_key "${2}" "${3}"
}

:func.document <<'/---'
[stdout: void, status: boolean] :set_string_to_map_key_value_if_found(
    string string_name,
    string map_name,
    string key)

Set the passed string variable to the value of the passed key in the passed map
if such map contains such key or report failure otherwise: e.g.,

.:set_string_to_map_key_value_if_found()
==========================================
[source]
------------------------------------------
>>> :string on_econometrics
>>> :map on_economics; on_economics=(
...     "Economics" "is not value free, and no amount of abstraction can make"
...     "it"        "value free. The econometricians' search for equations that"
...     "will"      "explain the economy is forever doomed to frustration."
...     "It"        "is often said that their models don't work, because,"
...     "on"        "the one hand, the variables are too many and, on the"
...     "other,"    "the statistical data are too sparse. But the physical"
...     "universe" "is as various as the economic universe (they are, to"
...     "repeat,"  "both infinite), and Newton had fewer data and less powerful"
...     "means"    "of calculation than are at the disposal of Jan Tinbergen"
...     "and"      "his econometrician followers. The difference"
...     "is"       "fundamental, and the failure to understand it reduces much"
...     "of"       "modern economics to a game that unfortunately has serious"
...     "consequences." ""
... )
>>> :set_string_to_map_key_value_if_found\
...     on_econometrics on_economics "invisible hand" or :string.output\
...     "To be important, therefore, a hypothesis must be descriptively false in its assumptions."
To be important, therefore, a hypothesis must be descriptively false in its assumptions.
/---
function :set_string_to_map_key_value_if_found() {
    # Validate sanity.
    die_unless_args_3 'Expected one string name, one map name, and one key.'
    :string string_name__sstmkvif="${1}" map_name__sstmkvif="${2}" key__sstmkvif="${3}"
    :var.die_unless_type_map "${map_name__sstmkvif}"

    # Set such string to such value if found or report failure. Note the
    # sensible expression "${${(@P)map_name}[${key__sstmkvif}]}" always expands
    # to the empty string, as does every sensible permutation of such
    # expression (e.g., with "k"). It shouldn't; it doesn't for lists. But
    # since it does, we necessarily resort to the usual eval() kludge.  For
    # such a simple operation, this is shockingly needlessly difficult.
    :map.is_key "${map_name__sstmkvif}" "${key__sstmkvif}" and
        eval ':string.set\
            "${string_name__sstmkvif}"\
            "${'${map_name__sstmkvif}'[${key__sstmkvif}]}"'
}

#FIXME: Add examples.
:func.document <<'/---'
void :set_map_key_to_string(string map_name, string key, string text)

Set the passed key of the passed map to the passed string.
/---
function :set_map_key_to_string() {
    # Validate sanity.
    die_unless_args_3 'Expected one map name, one key, and one string.'
    :string map_name__smkts="${1}" key__smkts="${2}" map_key__smkts
    :var.die_unless_type_map "${map_name__smkts}"

    # Set such key. Since parameter expansion flag "(P)" requires a variable
    # name, set a string local expanding to such key in the name of such map.
    map_key__smkts="${map_name__smkts}[${key__smkts}]"
    :noop "${(P)map_key__smkts::=${3}}"
}

:func.document <<'/---'
void set_list_to_map_keys(
    string list_name,
    string map_name1, ...)

Set the passed list (ideally, list set) to the set of all keys of the passed
maps (in arbitrary order) : e.g.,

.set_list_to_map_keys()
==========================================
[source]
------------------------------------------
>>> :map on_diminishing_humanity; on_diminishing_humanity=(
...    "And"      "what hurts is the steadily diminishing humanity of those"
...    "fighting" "to hold jobs they don't want but fear the alternative worse."
...    "People"   "simply empty out. They are bodies with fearful and obedient"
...    "minds."   "The color leaves the eye. The voice becomes ugly. And the"
...    "body."    "The hair. The fingernails. The shoes. Everything does."
...    "As"       "a young man I could not believe that people could give their"
...    "lives"    "over to those conditions. As an old man, I still can't"
...    "believe"  "it. What do they do it for? Sex? TV? An automobile on"
...    "monthly"  "payments? Or children? Children who are just going to do the"
...    "same"     "things that they did?" )
>>> :list on_obedient_minds
>>> set_list_to_map_keys on_obedient_minds on_diminishing_humanity
>>> :string.output "${on_obedient_minds[@]}"
And fighting People minds. body. As lives believe monthly same
------------------------------------------
/---
function set_list_to_map_keys() {
    #FIXME: We should permit list sets as well, right?

    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one list name and one or more map names.'
    :string list_name__sltmk="${1}" map_name__sltmk
    :var.die_unless_type_list "${list_name__sltmk}"
    shift_arg

    # If only one map was passed, implement such assignment without iteration.
    # Doing so avoids the need to clear such list beforehand and hence remains
    # marginally more efficient.
    if { is_arg } {
        map_name__sltmk="${1}"
        :var.die_unless_type_map "${map_name__sltmk}"
        eval ${list_name__sltmk}'=( ${(k@)'${map_name__sltmk}'} )'
    # Else, implement such assignment with iteration. Unfortunately, zsh
    # requires the map name to be dynamically interpolated into a parameter
    # expansion (as the above). This precludes use of an exterior eval(),
    # requiring each such iteration perform an interior eval(). *sigh*
    } else {
        # Clear such list.
        :list.clear "${list_name__sltmk}"

        # Iteratively append all such map keys to such list.
        for map_name__sltmk ("${@}") {
            :var.die_unless_type_map "${map_name__sltmk}"
            eval ${list_name__sltmk}'+=( ${(k@)'${map_name__sltmk}'} )'
        }
    }
}

# ....................{ REPLACERS                          }....................
#FIXME: Add example.
:func.document <<'/---'
void :replace_map_key_value_text_matching_pcre_with_text(
     string map_name,
     string key,
     string pcre,
     string replacement_text)

Globally replace all substrings in the passed key of the passed map matching
the passed PCRE with the passed replacement substring. See
:replace_scalar_text_matching_pcre_with_text() for further details.
/---
function :replace_map_key_value_text_matching_pcre_with_text() {
    # Validate sanity.
    die_unless_args_3\
        'Expected one map name, one key, one PCRE, and one replacement substring.'
    :string map_name__rmkvtmpbt="${1}" key__rmkvtmpbt="${2}"
    :var.die_unless_type_map "${map_name__rmkvtmpbt}"

    #FIXME: Does this actually work? We harbour doubts.

    # Replace such text.
    :replace_scalar_text_matching_pcre_with_text\
        ${map_name__rmkvtmpbt}'[${key__rmkvtmpbt}]' "${@[3,4]}"
}

# --------------------( WASTELANDS                         )--------------------
    # eval '
    # # Clear such list.
    # '${list_name__sltmk}'=()

    # # Iteratively append all such map keys to such list.
    # for      map_name__sltmk ("${@}") {
    #     :var.die_unless_type_map "${map_name__sltmk}"
    #     '${list_name__sltmk}'+=( ${(k@)'${map_name__sltmk}'} )'
    # }'

    # for ((  listset_index__smtli = 1;
    #         listset_index__smtli <= listset_size__smtli;
    #         listset_index__smtli++)) {

#void set_map_to_map(
#    string target_map_name,
#    string source_map_name1, string source_map_name2, ...)
#
#Set the passed target map to the merger of the passed source maps, in the passed
#order. Specifically, clear such target map and for each source map in the passed
#order, copy all key-value pairs of such source map into such target map. Hence,
#key-value pairs of source maps passed later take higher precedence than those of
#source maps passed earlier. If but one source map is passed, this reduces to
#simply setting such target map to such source map: e.g.,
#
#   die_unless_args_2_or_more\
#       'expected one target map name and at least one source map name'
#   string map_name_target__smtm="${1}" map_name_source__smtm
#   :var.die_unless_type_map "${map_name_target__smtm}"
#   shift_arg

#   # If only one source map was passed, copy such map into such target map.
#   # Since the for loop below would also suffice to copy such map, this is
#   # merely a minor optimization.
#   if { is_arg } {
#       map_name_source__smtm="${1}"
#       :var.die_unless_type_map "${map_name_source__smtm}"
#       eval "${map_name_target__smtm}:catch( \"\${(kv@P)map_name_source__smtm}\" )"
#   # Else, two or more source maps were passed and hence must be iteratively
#   # merged into such target map.
#   } else {
#       eval "${map_name_target__smtm}:catch()
#       for map_name_source__smtm (\"\${@}\") {
#           :var.die_unless_type_map \"\${map_name_source__smtm}\"
#           ${map_name_target__smtm}+=( \"\${(kv@P)map_name_source__smtm}\" )
#       }"
#   }
