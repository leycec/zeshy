#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *map removers* (i.e., functions removing key-value pairs from maps).
/---

# ....................{ CLEARERS                           }....................
:func_ ':void ::map.clear(:str:map map_name1, ...)' :func{
    # Validate sanity.
    die_unless_args 'Expected one or more map names.'

    # If only one map was passed, clear such map without iteration.
    if { is_arg } {
        :Map.die_unless "${1}"
        set -A         "${1}"
    # Else, clear all such maps.
    } else {
        :str map_name__cm
        for     map_name__cm ("${@}") {
            :Map.die_unless "${map_name__cm}"
            set -A "${map_name__cm}"
        }
    }
}:func <<'/---'
Clear all passed maps (i.e., remove all key-value pairs from such maps): e.g.,

.::map.clear()
==========================================
[source]
------------------------------------------
>>> :map on_seclusion; on_seclusion=(
...    "The"      "mind is sharper and keener in seclusion and uninterrupted"
...    "solitude. "No big laboratory is needed in which to think. Originality"
...    "thrives"  "in seclusion free of outside influences beating upon us to"
...    "cripple"  "the creative mind. Be alone, that is the secret"
...    "of"       "invention; be alone, that is when ideas are born. That is"
...    "why"      "many of the earthly miracles have had their genesis in"
...    "humble"   "surroundings." )
>>> get_map_size on_seclusion
7
>>> ::map.clear   on_seclusion
>>> get_map_size on_seclusion
0
------------------------------------------
==========================================
/---

# ....................{ REMOVERS                           }....................
:func_ ':void :remove_map_key(:str map_name, :str key)'
:func{
    # Validate sanity.
    die_unless_args_2 'Expected one map name and one key.'
    :str map_name__rmk="${1}" key__rmk="${2}"
    :Map.die_unless "${map_name__rmk}"

    # If such key contains either "[" or "]", throw an exception. Unfortunately,
    # zsh appears to currently prohibit removal of such keys. (Yes, this is a
    # bug and should be reported as such.)
    :is "${key__rmk}" != *['[]']* :si or :die\
        'Map '${map_name__rmk}' key "'${key__rmk}'" contains "[" and/or "]", which zsh currently cannot remove.'

    # Remove such key. On the bright side, such operation requires no eval().
    # On the dark side, zsh requires such expansion be double-quoted, the
    # principal cause of its failure to remove keys containing "[" or "]".
    unset "${map_name__rmk}[${key__rmk}]"
}:func <<'/---'
Remove the passed key and corresponding value from the passed map: e.g.,

.:remove_map_key()
==========================================
[source]
------------------------------------------
>>> :map on_solitude_and_freedom; on_solitude_and_freedom=(
...    "Above"     "everything else I am taken by the Revolution. It had to be"
...    "that"      "way. The wind that blew through the ruin where I was born,"
...    "the"       "old people who brought me up, the solitude and freedom of"
...    "my"        "childhood, the legends of the Haute-Marne, the scraps of"
...    "knowledge" "gleaned from here and there – all that opened my ear to"
...    "every"     "harmony, my spirit to every illumination, my heart to both"
...    "love"      "and hate. Everything intermingled in a single song, a"
...    "single"    "dream, a single love: the Revolution." )
>>> :remove_map_key
------------------------------------------
==========================================
/---

# --------------------( WASTELANDS                         )--------------------
    # Handle previously updated standard output tracking.
#   :print_stdout_separated_start

    # Update standard output tracking in preparation for subsequent handling.
#   :print_stdout_separated_stop

        # Remove the map name from the argument list.
#       shift_arg

#>>> map hollow_moon
#>>> listset adams_curse; adams_curse=( We sat grown quiet at the name of love )
#>>> set_map_to_listset_inverted hollow_moon adams_curse
#>>> print_map hollow_moon
#We: 1
#sat: 2
#grown: 3
#quiet: 4
#at: 5
#the: 6
#name: 7
#of: 8
#love: 9

    # . Clear such target map and for each such source map, copy such map's
    # key-value pairs into such target map. For efficiency, inline such logic.
#FUXME: Pure madness. Efficiency isn't a concern in this context. (When it is,
#the caller simply inlines such implementation.) Hence:
#
#* Excise this function.
#* Rename set_map_to_maps() to set_map_to_map().
#:func.doc <<'/---'
#string set_map_to_map(string target_map_name, string source_map_name)
#
#Set the passed target to the passed source map (i.e., copy the latter into the
#former): e.g.,
#
#.set_map_to_map()
#==========================================
#[source]
#------------------------------------------
#>>> map in_this_world the_good_earth
#>>> the_good_earth=(
#...     "We all"  "want to help one another. Human beings are like that."
#...     "We want" "to live by each other's happiness — not by each other's"
#...     "misery." "We don't want to hate and despise one another."
#...     "In"      "this world there is room for everyone. And the good earth is"
#...     "rich"    "and can provide for everyone. The way of life can be free"
#...     "and"     "beautiful, but we have lost the way." )
#>>> set_map_to_map  in_this_world the_good_earth
#>>> :stdout.echo "${in_this_world[and]}"
#beautiful, but we have lost the way.
#------------------------------------------
#==========================================
#/---
#function set_map_to_map() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one target map name and one source map name'
#    string map_name_target__smtm="${1}" map_name_source__smtm="${2}"
#    :Map.die_unless "${map_name_target__smtm}"
#    :Map.die_unless "${map_name_source__smtm}"
#
#    # Copy such map.
#    eval "${map_name_target__smtm}:catch( \"\${(kv@P)map_name_source__smtm}\" )"
#}

#       {
#       string map_name__gmkv="${1}" key__gmkv="${2}"
#       :die "map \"${map_name__gmkv}\" has no key \"${key__gmkv}\""
#   }

    # Test such map, inlined for efficiency. Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'i', expanding to the index of such key if such map contains such key or
    #   the empty string otherwise.
    # * 'e', matching such key as a plain string rather than extended pattern.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#FUXME: To retain orthogonolity with the builtin for() iterator, the optional
#local variable names should *ALWAYS* be passed first. Hence, change this to:
#
#string for_map_key_value_pairs(
#    string key_string_name = "KEY",
#    string value_string_name = "VALUE",
#    string map_name,
#    string command)
# Since this overwrites all prior values for such keys within such
# target map, key-value pairs from later source maps take higher precedence than
# those from earlier source maps.
#FUXME: Excise. This should be called *NOWHERE*.
#declare_function '
#void set_map_to_evaluation(string map_name, string code)
#
#Set the passed map to the dynamic evaluation of the passed code in a map
#context (i.e., in an expression resembling "( ${code} )"): e.g.,
#
#    >>> map sopa
#    >>> set_map_to_evaluation sopa ''${:-stop officer perjury act}''
#    >>> :stdout.echo "${sopa[perjury]}"
#    act
#'
#function set_map_to_evaluation() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one code snippet'
#    string map_name__smte="${1}"
#    :Map.die_unless "${map_name__smte}"
#
#    # Set such map.
##   :stdout.echo "set map ${map_name__smte}:catch( ${2} )"
#    eval "${map_name__smte}:catch( ${2} )"
#}

# ....................{ GETTERS ~ key-value                }....................
#:func.doc <<'/---'
#string get_map_key_values(string map_name)
#
#Get all key-value pairs of the passed map in arbitrary order, delimited by the
#current shell word separator(s) and hence suitable for iteration. Only call this
#function when *ALL* map values are guaranteed *NOT* to contain such separator
#(i.e., canonical global ${IFS}, defaulting to newline, space, and tab); if at
#least one map value could possibly contain such separator(s), consider iterating
#with get_map_keys() instead: e.g.,
#
#    >>> map lal_ded; lal_ded=( For ever we come, for ever we go )
#    >>> for lalla vakh ( $(get_map_keys lal_ded) ) {
#    ...     :stdout.echo "key: ${lalla} -- value: ${vakh}"
#    ... }
#    key: For -- value: ever
#    key: we -- value: come,
#    key: for -- value: ever
#    key: we -- value: go
#/---
#function get_map_key_values() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    :Map.die_unless "${map_name__gmk}"
#
#    # Get such pairs.
#    :stdout.echo "${(kv@P)map_name__gmk}"
#}

# ....................{ GETTERS ~ keys                     }....................
#FUXME: *THIS IS TERRIBLE*. So are the getters below, for the simple reason that
#they only work as documented when no key contains whitespace. What? That's pure
#nonsense. Instead, define a new family of for_map_keys*() iterators below and
#translate all existing calls to get_map_keys*() functions to such iterators.
#:func.doc <<'/---'
#string get_map_keys(string map_name)
#
#List all keys of the passed map in arbitrary order, delimited by the current
#shell word separator(s) and hence suitable for iteration: e.g.,
#
#.get_map_keys()
#==========================================
#[source]
#------------------------------------------
#>>> map passchendaele; passchendaele=( the "old Lie" dulce et decorum est )
#>>> for dead ( $(get_map_keys passchendaele) ) {
#...     :stdout.echo "key: ${dead} -- value: ${passchendaele[${dead}]}"
#... }
#key: the -- value: old Lie
#key: dulce -- value: et
#key: decorum -- value: est
#------------------------------------------
#==========================================
#/---
#function get_map_keys() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmk="${1}"
#    :Map.die_unless "${map_name__gmk}"
#
#    # Get such keys.
#    :stdout.echo "${(k@P)map_name__gmk}"
#}
#
#:func.doc <<'/---'
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map in lexical ascending order, delimited by the
#current shell word separator(s) and hence suitable for iteration.
#/---
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    :Map.die_unless "${map_name__gmksla}"
#
#    # Sort such keys.
#    :stdout.echo "${(ko@P)map_name__gmksla}"
#}
#
#declare_function '
#string get_map_keys_sorted_lexically_descending(string map_name)
#
#Get all keys of the passed map in lexical descending order, delimited by the
#current shell word separator(s) and hence suitable for iteration
#'
#function get_map_keys_sorted_lexically_descending() {
#    # Validate passed arguments.
#    die_unless_arg 'expected one map name'
#    string map_name__gmksla="${1}"
#    :Map.die_unless "${map_name__gmksla}"
#
#    # Sort such keys.
#    :stdout.echo "${(kO@P)map_name__gmksla}"
#}

#FUXME: O.K.; so, it'd be great to be able to specify names for such string
#locals. In the case of "io/color/color", for example, we want keys to be in
#string local ${color_style_name} and values to be in string local
#${color_name}. I'm generally intolerant of optional parameters -- but, here
#they really do seem to make sense. The function call remains equally readable
#with or without such parameters specified: e.g.,
#
#    for_map_key_value_pairs ZY_COLOR_8 color_style_name color_name\
#        'ZY_COLOR_2[${color_name}]='
#
#I dig it. Easy to support; easy to call. No need for separate functions, here.

#   if { is_args_3 } {
#       key_name="${2}"
#   }
#   elif { is_args_4 } {
#       key_name="${2}"
#       value_name="${3}"
#   }

    # Print such map.
#   for key (${(k)${(k@P)map_name__pm}}) {
#       # If such key contains a colon or whitespace, quote such key.
#       if { :str.is_^= "${key}" [:[:space:]] } {
#           :stdout.echo "\"$(escape_string_double_quotes "${key}")\": ${${(k@P)map_name__pm}[${key}]}"
#       # Else, print such key as is.
#       } else {
#           :stdout.echo "${key}: ${${(k@P)map_name__pm}[${key}]}"
#       }
#   }
    # Current key-value pair.
#   string KEY VALUE

#function yiyi() {
#    get_map_key_value_if_found ZY_MAP_TO_EMULATABLE_SHELL_NAME "zsh"
#    print $(get_map_key_value_if_found ZY_MAP_TO_EMULATABLE_SHELL_NAME "zsh")
#}

        #FUXME: Generalize quote escaping into a new function
        #escape_string_double_quotes(). It's complex enough to warrant such
        #generalization.
#           :stdout.echo "\"${key//\"/\\\"}\": ${${(k@P)map_name__pm}[${key}]}"

    # Dismantled, this is:
    #
    # * 'kP@', expanding to the map with such name.
    # * 'k' and 'r', expanding to such key if such map contains such key or the
    #   empty string.
    # * '-', expanding to the empty string if the prior expansion expands to the
    #   empty string. While redundant, such expansion avoids "parameter not set"
    #   errors under default shell option "NO_UNSET".
    #
    # Where the map name is previously known, a simpler and certainly more
    # efficient alternative is as follows: e.g.,
    #
    #   >>> map youndeh
    #   >>> (( ${+youndeh[nyarlathotep]} )) or print 'The Door to Saturn'
    #   The Door to Saturn
    #
    # Sadly, such technique fails where the map name is dynamically passed as
    # opposed to previously known: e.g.,
    #
    #   >>> map youndeh
    #   >>> string tsathoggua=youndeh
    #   >>> (( ${+${(k@P)tsathoggua}[nyarlathotep]} )) or
    #   ...      print 'The Door to Saturn'
    #   zsh: bad substitution
#   is_string_nonempty "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}"

#   (( ${${(k@P)map_name__imk}[(i)one]} <= ${#${(@P)map_name__imk}} ))
#   [[ -n "${(k)${(k@P)map_name__imk}[(r)${key__imk}]-}" ]]
#declare_function '
#string get_map_keys_sorted_lexically_ascending(string map_name)
#
#List all keys of the passed map sorted in lexical ascending order.
#'
#function get_map_keys_sorted_lexically_ascending() {
#    # Validate passed arguments.
#    die_unless_args_2 'expected one map name and one key'
#    string map_name="${1}" __key__="${2}"
#    :Map.die_unless "${map_name}"
#}

# throw an exception with the passed error message
# (defaulting to the default error message of die_unless_map_key()).
    # Get such map key's value or the empty string if no such key exists. See
    # :map.is_key() for details.
#   __value__="${${(k@P)map_name}[(I)${__key__}]}"

    # Print such value if such key exists or throw an exception.
#   if is_string_nonempty "${__
#   :stdout.echo ${#${(@P)map_name}}
    #FIXME: Uhm; how do we distinguish between a non-extant key and a key with
    #empty value?
    # Dismantled, this is:
    #
    # * 'P', the scalar name of the desired map in the caller's scope.
    # * '@', as a map rather than a scalar.
    # * 'k', a kludgy hack to force zsh to interpret the referenced object as
    #   a map rather than a list. This may constitute a bug.
    # * 'I', expanding to the empty string if this map does not have this key.
#   is_string_nonempty "${${(k@P)map_name}[(I)${__key__}]}"
#FIXME: This actually work? I'm more confident of the list methods. Test us up.
# void restore_map()
#
# Convert the string piped on standard input to a local map named "map",
# overwriting the prior contents of such variable. For safety, the piped string
# should have been previously created by return_map().
#alias restore_map='{
#    is -p /dev/stdin si or :die "\"/dev/stdin\" not a pipe";
#    map map; map=( ${(z)"$(< /dev/stdin)"} )
#}'
