#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2014 by Cecil Curry.
# See "COPYING" for additional details.

:parcel <<'/---'
Handle *string length setters* (i.e., functions setting integer variables to
the lengths of passed strings).
/---

#FIXME: Reuse the following example strings:
#
#>>> :string on_informed_decisions=\
#...     "Wouldn't you like to see a positive LSD story on the news? To base your
#...      decision on information rather than scare tactics and superstition?
#...      Perhaps? Wouldn't that be interesting? Just for once?"
#>>> :string on_the_holographic_principle=\
#...     "Today, a young man on acid realized that all matter is merely energy
#...      condensed to a slow vibration – that we are all one consciousness
#...      experiencing itself subjectively. There's no such thing as death, life
#...      is only a dream, and we're the imagination of ourselves. Here's Tom
#...      with the weather."

# ....................{ GETTERS                            }....................
#FIXME: Refactor into setters.

declare_function_with_stdin <<'/---'
integer get_string_length_printable(string text1, ...)

Get the total length in printable multibyte characters of the passed strings
excluding ANSI escape sequences in such strings. See
:set_int_to_string_length_printable() for a setter analogue and
get_string_ansiless_length_printable() for further details: e.g.,

.get_string_length_printable()
==========================================
[source]
------------------------------------------
>>> string on_flag_and_wind=\
...    "A temple flag flapped in the wind. Two monks stood watching. One said to
...     the other, \"The flag is moving.\" The other replied, \"The wind is
...     moving.\" The sixth patriarch, Eno, overheard this and said, \"It is not
...     the wind or the flag. The mind is moving.\""
>>> get_string_length_printable "${on_flag_and_wind}"
248
>>> get_string_length_printable\
...     "${ZESHY_STYLE_TO_COLOR[color.reset]}${on_flag_and_wind}"
248
------------------------------------------
==========================================
/---
function get_string_length_printable() {
    # See get_string_length() for further details.
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    :string.output "${(m)#${text//${~ZESHY_ANSI_GLOB}}}"
}

#FIXME: We strongly suspect all existing calls of this function to be erroneous.
#Consider changing such calls to get_string_length_printable() instead.
declare_function_with_stdin <<'/---'
integer get_string_ansiless_length_printable(string text1, ...)

Get the length of the passed string in printable multibyte characters, thus
treating *control characters* (e.g., newline, tab) as 0 characters for counting
purposes. Unfortunately, `zsh` currently provides no builtin means for counting
such characters as 1 character: e.g.,

.get_string_ansiless_length_printable()
==========================================
[source]
------------------------------------------
>>> string on_informed_decisions=\
...     "Wouldn't you like to see a positive LSD story on the news? To base your
...      decision on information rather than scare tactics and superstition?
...      Perhaps? Wouldn't that be interesting? Just for once?"
>>> string on_the_holographic_principle=\
...     "\"Today, a young man on acid realized that all matter is merely energy
...      condensed to a slow vibration – that we are all one consciousness
...      experiencing itself subjectively. There's no such thing as death, life
...      is only a dream, and we're the imagination of ourselves. Here's Tom
...      with the weather.\""
>>> get_string_ansiless_length_printable\
...     "${on_informed_decisions}" "${on_the_holographic_principle}"
481
>>> get_string_ansiless_length_printable "${ZESHY_ASCII_NEWLINE}"
0
>>> get_string_ansiless_length_printable "${ZESHY_ASCII_NEWLINE}Gnosis"
6
------------------------------------------
==========================================
/---
function get_string_ansiless_length_printable() {
    # See get_string_length() for further details.
    die_unless_args 'Expected one or more strings.'
    string text="${*}"
    :string.output ${(m)#text}
}

# ....................{ SETTERS                            }....................
declare_function_with_stdin <<'/---'
void :set_int_to_string_byte_count(
    string int_name,
    string text1, ...)

Set the passed integer variable to the *byte count* of all passed strings (i.e.,
the total length of such strings in single-byte ASCII characters). If such
strings _only_ contain single-byte ASCII characters, such integer will be set to
the total length of such strings; else, such integer will be strictly greater
than such length. In the latter case, consider calling
:set_int_to_string_length_printable() instead: e.g.,

.:set_int_to_string_byte_count()
==========================================
[source]
------------------------------------------
>>> :int count
>>> :string on_sensoria=\
...    "The world is like a ride in an amusement park, and when you choose to go
...     on it you think it's real because that's how powerful our minds are. The
...     ride goes up and down, around and around, it has thrills and chills, and
...     it's very brightly colored, and it's very loud, and it's fun for a
...     while."
>>> :string on_existentia=\
...    'Many people have been on the ride a long time, and they begin to wonder,
...     "Hey, is this real, or is this just a ride?" And other people have
...     remembered, and they come back to us and say, "Hey, don''t worry; don''t
...     be afraid, ever, because this is just a ride." And we kill those
...     people. "Shut him up! I''ve got a lot invested in this ride, shut him
...     up! Look at my furrows of worry, look at my big bank account, and my
...     family. This has to be real."'
>>> :set_int_to_string_byte_count count "${on_sensoria}" "${on_existentia}"
>>> :string.output "${count}"
735
------------------------------------------
/---
function :set_int_to_string_byte_count() {
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # Synchronize with :set_int_to_string_length_printable().
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one integer name and one or more strings.'

    # Locally override the current internal field separator ${IFS} to the empty
    # string *BEFORE* joining the passed strings below. (If ${IFS} were *NOT*
    # overriden here, such strings would be joined with spaces, resulting in
    # such integer being set to an erroneous larger byte count.)
    :string IFS= int_name__sitsl="${1}" text__sitsl
    shift_arg

    # Due to zsh eccentricity, the parameter expansion counting
    # such bytes *CANNOT* be reduced to either "${#*}", "${#@}", "${#${*}}", or
    # "${#${@}}". Reducing this expansion to "${#${*}}" successfully returns the
    # expected string length in all cases *EXCEPT* when the empty string is
    # passed, in which case such expansion erroneously returns 1 rather than 0.
    # Strangely, joining the passed strings into a local string variable
    # *BEFORE* testing the length of such variable corrects this edge case and
    # probable zsh bug.
    text__sitsl="${*}"

    # Set such integer.
    :int.set "${int_name__sitsl}" "${#text__sitsl}"
}

declare_function_with_stdin <<'/---'
void :set_int_to_string_length_printable(
    string int_name,
    string text1, ...)

Set the passed integer variable to the total length in printable multibyte
characters of all passed strings excluding ANSI escape sequences in such
strings: e.g.,

.:set_int_to_string_length_printable()
==========================================
[source]
------------------------------------------
>>> :int length
>>> :string on_doctrine=\
...    'Nobushige, a respected samurai, came to Hakuin and asked, "Is there
...     really a heaven and hell?"
...     "Who are you?" inquired Hakuin.
...     "A samurai," Nobushige replied.'
... :string on_compassion=\
...    '"You, a samurai!" exclaimed Hakuin. "What kind of ruler would have
...     you as his guard? Your face is like that of a beggar."
...     In anger, Nobushige drew his sword. Hakuin continued, "So, you have a
...     sword? Your weapon is probably too dull to even cut off my head."
...     As Nobushige raised his sword, Hakuin intoned, "Here open the gates of
...     hell." As Nobushige lowered his sword, Hakuin intoned, "Here open the
...     gates of heaven."'
>>> :set_int_to_string_length_printable length\
...     "${on_doctrine}" "${on_compassion}"
>>> :string.output "${length}"
568
>>> :set_int_to_string_length_printable length\
...     "${ZESHY_STYLE_TO_COLOR[color.black]}${on_doctrine}${on_compassion}"
>>> :string.output "${length}"
568
------------------------------------------
==========================================

== Caveats ==

*`zsh` provides no builtin means of setting the total length in _all_ multibyte
characters of such strings*. However, `zsh` _does_ provide a builtin means of
testing whether such length is exactly some number or in a range of some
numbers. Indeed, this is exactly how :is_char() is implemented: e.g.,

.:set_int_to_string_length_printable() Test Alternatives
==========================================
[source]
------------------------------------------
>>> is "O" == ? si
>>> :string on_fear=\
...    "It's just a ride. But we always kill the good guys who try and tell us
...     that, you ever notice that? And let the demons run amok. But it doesn't
...     matter, because it's just a ride. And we can change it any time we want.
...     It's only a choice. No effort, no work, no job, no savings of money.
...     Just a simple choice, right now, between fear and love. The eyes of fear
...     want you to put bigger locks on your doors, buy guns, close yourself
...     off. The eyes of love instead see all of us as one."
>>> :string on_love=\
...    "Here's what we can do to change the world, right now, to a better ride.
...     Take all that money we spend on weapons and defenses each year and
...     instead spend it feeding and clothing and educating the poor of the
...     world, which it would pay for many times over, not one human being
...     excluded, and we could explore space, together, both inner and outer,
...     forever, in peace."
>>> is "${on_fear}${on_love}" == ?(#c840) si and :string.output\
...    "I left in love, in laughter, and in truth and wherever truth, love and
...     laughter abide, I am there in spirit."
I left in love, in laughter, and in truth and wherever truth, love and
laughter abide, I am there in spirit.
------------------------------------------
==========================================

== Printable Characters ==

Printable characters are all ASCII and UTF-8-encoded Unicode characters
excluding *control characters* (i.e., characters providing semantic instructions
to be programmatically interpreted by end-user software rather than raw glyphs
to be displayed as is), which include common whitespace characters (e.g.,
newline, tab).

Different characters contribute different *printable widths* (i.e., abstract
character lengths for the purposes of counting printable string length) to the
length the passed integer will be set to. Specifically:

* Most printable characters, including all ASCII and English-specific UTF-8-
  encoded Unicode characters, have a printable width of 1.
* Some printable characters, including wide Asian and special effect characters,
  have a printable width greater than 1.
* All combining characters have a printable width of 0.
* All non-printable characters, including all control characters, have a
  printable width of 0.

Hence, not even all printable characters contribute a printable width of 1.
/---
function :set_int_to_string_length_printable() {
    # Validate sanity. See :set_int_to_string_byte_count() for further details.
    die_unless_args_2_or_more\
        'Expected one integer name and one or more strings.'
    :string IFS= int_name__sitslp="${1}" text__sitslp
    shift_arg
    text__sitslp="${*}"

    # Remove all ANSI escape sequences from such string. Such sequences are
    # inherently non-printable (in the sense of printable characters).
    :remove_string_ansi text__sitslp

    # Set such length.
    :int.set "${int_name__sitslp}" "${(m)#text__sitslp}"
#   print "text__sitslp: \"${text__sitslp}\"; length: ${#text__sitslp}; length (multi): ${(m)#text__sitslp}; length (multi sans ansi): ${(m)#${text__sitslp//${~ZESHY_ANSI_GLOB}}}"
}

# --------------------( WASTELANDS                         )--------------------
# Get the total length of the passed strings in single-byte characters. Consider
# calling get_string_ansiless_length_printable() instead if any such string contains
# multibyte characters (e.g., UTF-8-encoded Unicode): e.g.,

#FUXME: Overly verbose example, though delightful. Shift half of it elsewhere.
# declare_function_with_stdin <<'/---'
# integer get_string_length(string text1, ...)
# 
# Get the total length of the passed strings in single-byte characters. Consider
# calling get_string_ansiless_length_printable() instead if any such string contains
# multibyte characters (e.g., UTF-8-encoded Unicode): e.g.,
# 
# .get_string_length()
# ==========================================
# [source]
# ------------------------------------------
# >>> :string on_worrisome_rides=\
# ...    "The world is like a ride in an amusement park, and when you choose to go
# ...     on it you think it's real because that's how powerful our minds are. The
# ...     ride goes up and down, around and around, it has thrills and chills, and
# ...     it's very brightly colored, and it's very loud, and it's fun for a
# ...     while. Many people have been on the ride a long time, and they begin to
# ...     wonder, \"Hey, is this real, or is this just a ride?\" And other people
# ...     have remembered, and they come back to us and say, \"Hey, don't worry;
# ...     don't be afraid, ever, because this is just a ride.\" And we kill those
# ...     people. \"Shut him up! I've got a lot invested in this ride, shut him
# ...     up! Look at my furrows of worry, look at my big bank account, and my
# ...     family. This has to be real.\""
# >>> string on_better_rides=\
# ...    "It's just a ride. But we always kill the good guys who try and tell us
# ...     that, you ever notice that? And let the demons run amok. But it doesn't
# ...     matter, because it's just a ride. And we can change it any time we want.
# ...     It's only a choice. No effort, no work, no job, no savings of money.
# ...     Just a simple choice, right now, between fear and love. The eyes of fear
# ...     want you to put bigger locks on your doors, buy guns, close yourself
# ...     off. The eyes of love instead see all of us as one. Here's what we can
# ...     do to change the world, right now, to a better ride. Take all that money
# ...     we spend on weapons and defenses each year and instead spend it feeding
# ...     and clothing and educating the poor of the world, which it would pay for
# ...     many times over, not one human being excluded, and we could explore
# ...     space, together, both inner and outer, forever, in peace."
# >>> get_string_length "${on_worrisome_rides}" "${on_better_rides}"
# 1578
# ------------------------------------------
# /---
# function get_string_length() {
#     # Due to zsh eccentricity, this expansion *CANNOT* be reduced to either
#     # "${#*}", "${#@}", "${#${*}}", or "${#${@}}". Reducing this expansion to
#     # "${#${*}}" successfully returns the expected string length in all cases
#     # *EXCEPT* when the empty string is passed, in which case such expansion
#     # erroneously returns 1 rather than 0. Strangely, assigning passed arguments
#     # to a local variable before testing the length of such variable corrects
#     # this edge case (and probable zsh bug).
#     die_unless_args 'Expected one or more strings.'
#     string text="${*}"
#     :string.output ${#text}
# }

# () {
# :int length
# :string on_fear=\
# "It's just a ride. But we always kill the good guys who try and tell us
# that, you ever notice that? And let the demons run amok. But it doesn't
# matter, because it's just a ride. And we can change it any time we want.
# It's only a choice. No effort, no work, no job, no savings of money.
# Just a simple choice, right now, between fear and love. The eyes of fear
# want you to put bigger locks on your doors, buy guns, close yourself
# off. The eyes of love instead see all of us as one."
# :string on_love=\
# "Here's what we can do to change the world, right now, to a better ride.
# Take all that money we spend on weapons and defenses each year and
# instead spend it feeding and clothing and educating the poor of the
# world, which it would pay for many times over, not one human being
# excluded, and we could explore space, together, both inner and outer,
# forever, in peace."
# :set_int_to_string_length_printable length "${on_fear}" "${on_love}"
# :string.output "length: ${length}"
# :string cat="${on_fear}${on_love}"
# is "${cat}" == ?(#c829) si or print "not 829"
# is "${cat}" == ?(#c840) si or print "not 840"
# }

# Yes, capturing such string to a local variable is
    # necessary due to a probable zsh bug. 
# such characters
# 
#  such that all English characters have a semantic width of 1
# 
# The following types of characters contribute the following 
# 
# instructing software
# 
# low-level semantic
# instructions to interpreting rather than raw
# 
# e.g., newline, tab), which by definition   to the 
# 
# interpreted to be displayed and hence are non-printable as is. 
# 
# Get the length of the passed string in printable multibyte characters, thus
# treating *control characters* (e.g., newline, tab) as 0 characters for counting
# purposes. Unfortunately, `zsh` currently provides no builtin means for counting
# such characters as 1 character: e.g.,

# Such functions are transitively called by print_exception() via
# output_call_stack_lists_in_style() and hence subject to the same
# constraints: namely, to avoid calling other functions from such functions
# unless explicitly preceding such calls with tests of whether such functions
# are still defined or not.

#FUXME: This probably no longer needs to be here, now that we've relegated
#exception handling to late in zeshy startup.

    # Set such length. For efficiency, inline such implementation. See
    # :string.set() and get_string_length_printable() for further details.
    # noop "${(P)int_name__sitslp::=${(m)#text__sitslp}}"

    # # If any such variable is undefined or not of the expected type, throw an
    # # exception. See is_string() and :var.is_type_list for further details.
    # is "${(tP)int_name__sitslp-}" == 'integer'* si or :die\
    #     "\${${int_name__sitslp}} undefined or not an integer variable."
    # is "${(t)ZESHY_ANSI_GLOB}" == 'scalar'* si or :die\
    #      "\${ZESHY_ANSI_GLOB} undefined or not a string variable."

    # # Remove all ANSI escape sequences from such string. For efficiency, it
    # # would be preferable to inline such removal below: e.g.,
    # #
    # #     noop "${(P)int_name__sitslp::=${(m)#${text__sitslp//${~ZESHY_ANSI_GLOB}}}}"
    # #
    # # Unfortunately, doing so improperly sets such integer to 1 if such string
    # # is the empty string. Consequently, separate the two operations.
    # text__sitslp="${text__sitslp//${~ZESHY_ANSI_GLOB}}"

# Handle *string repeaters* (i.e., functions repeating strings, typically for
# ensuring padded, aligned, and/or otherwise structured output).

# get_string_length_printable() for a getter analogue and

    # necessary due to a probable zsh bug. See get_string_length() for further
    # details.

    # For efficiency, inline the equivalent of:
    # 
    #     >>> get_string_ansiless_length_printable "$(remove_string_ansi "${@}")"
#FUXME: Remove entirely. Existing calls to this function should be changed to
#call get_string_length_printable() instead. The whole "_sans_ansi"
#concept is fundamentally flawed, as discussed below.
#FUXME: Bad nomenclature, I'm afraid. :set_int_to_string_length_printable()
#should be a general-purpose function and hence exclude the length of non-
#printable ANSI escape sequences. Hence, this function should be renamed to
#:set_int_to_string_length_printable() and shifted to a more appropriate
#parcel (e.g., @{variable/string/set}). Naturally, the existing
#get_string_ansiless_length_printable() function should internally defer to
#:set_int_to_string_length_printable().

#    integer\
#        padding_length__sstsartl\
#        repetition_count__sstsartl\
#        remainder_length__sstsartl
    # Padding length. See get_string_ansiless_length_printable() for further details.
#    padding_length__sstsartl=${(m)#padding__sstsartl}
#
#    # Number of times to completely repeat the passed padding. If such padding's
#    # length evenly divides the passed length, such repetition suffices to
#    # produce the requested string; else, a leftmost substring of such padding
#    # must be appended to such repetition to produce the requested string.
#    repetition_count__sstsartl=$((\
#        string_length__sstsartl / padding_length__sstsartl ))
#
#    # Length of the longest leftmost substring of such padding needed to produce
#    # a string of exactly the passed length. If such padding's length evenly
#    # divides the passed length, this is 0; else, this is a positive integer.
#    remainder_length__sstsartl=$((\
#        string_length__sstsartl % padding_length__sstsartl ))
#
#    # If such length is a positive integer, then by the prior discussion such
#    # padding's length does *NOT* evenly divide the passed length. In such case,
#    # get the leftmost substring of such padding of such length.
#    if (( remainder_length__sstsartl != 0 )) {
#        remainder__sstsartl="${padding__sstsartl[1,${remainder_length__sstsartl}]}"
#    }

    # Set such string to the required repetition of such padding followed by the
    # leftmost substring of such padding. See :string.set() and
    # repeat_string() for further details.

    #FUXME: Implement me. Copy from repeat_string(), yes?
