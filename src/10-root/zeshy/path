#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle `zeshy`-specific paths.
/---

#FIXME: Such globals should be set *MUCH* earlier in the startup logic --
#ideally, immediately after calling startup_zeshy_globals(). To ensure this,
#contemplate adding a new run_hook_on_zeshy_startup_globals() function; then,
#ensure that our startup_zeshy_globals() implementation calls all hooks
#registered in this manner.
#FIXME: Alternatively, this logic should *REALLY* be performed at digest
#compilation time. It's just too awkward to perform dynamically on each startup,
#especially when such logic is the same *EACH* time, most times. This implies
#that, when the user passes command-line option "--zeshy-dot-dir", @{main}
#should force a digest recompilation. This is perfectly acceptable, at the
#moment. Indeed, if need ever arose, such logic is readily optimizable by
#caching under "~/.zeshy/cache/digest/" digests specific to passed paths (e.g.,
#if the user runs "zeshy --zeshy-dot-dir ~/.akbar", compiling such digest to a
#new file "~/.zeshy/cache/digest/fi8uYWtiYXI.zwc", where "fi8uYWtiYXI" is the
#base64 encoding of "~/.akbar"). Note, in the prior example, that safely
#converting pathnames to basenames requires some encoding scheme: base64 is one,
#but there exist *MANY* others. *shrug*
#FIXME: Right. Switch to setting such globals at precompilation time, as above!

# ....................{ PATHS                              }....................
# Such paths depend on command-line option "--zeshy-dot-dir" and hence cannot be
# defined until having matched such option (e.g., zeshy startup).

# ....................{ PATHS ~ pid                        }....................
:str.global ZY_USER_PID_DIR <<'/---'
Absolute path of the directory caching `zeshy`-managed process IDs. If the
current user has superuser privileges, this is a canonical system-wide directory
if such directory exists (e.g., `/run`, `/var/run`); else, this is a user-
specific subdirectory of `zeshy`\'s dot directory.
/---

# ....................{ PATHS ~ temporary                  }....................
#FIXME: Unconvinced the logic for preserving such string as a global rather than
#return value from a function get_temporary_home() applies any longer. In
#particular, core functionality no longer frequently expands this global (as we
#prefer coprocesses in favor of temporary files); hence, there should no longer
#exist a recursive loop with get_dir_writable_first() and make_path_temporary().
#I still prefer a global rather than function for this; just correct the
#documentation above.
#FIXME: Rename to ${ZY_TEMP_DIR}.

:str.global ZY_TEMPORARY_DIR <<'/---'
Absolute path of the first temporary directory writable by the current user in
the following list (in order):

* `/tmp`, the canonical system-wide temporary home for non-persistent files.
* `/var/tmp`, the canonical system-wide temporary home for persistent files.
* `${HOME}/tmp`, the canonical user-specific temporary home.

== Design Decisions ==

System-wide temporary directories are often formatted under filesystems specific
to handling temporary paths (e.g., `tmpfs`) or mounted with options prohibiting
insecure operations (e.g., `noexec`). Since user-specific temporary directories
are rarely subject to the same beneficial constraints, the former are preferred.

Since core functionality frequently expands this global (e.g.,
make_path_temporary()), this global exists in lieu of a similar function (e.g.,
get_temporary_home()). Moreover, the implementation of such function would call
get_dir_writable_first(), which itself transitively calls make_path_temporary(),
a recursive loop. To avoid such concerns, we prefer this global.
/---

:str.global ZY_USER_TEMPORARY_DIR <<'/---'
Absolute path of a temporary directory specific to both `zeshy` and the current
user (e.g., `/tmp/zeshy-leycec`). When writing `zeshy`-specific temporary paths,
such directory should be preferred to the more `zeshy`-agnostic temporary
directory ${ZY_TEMPORARY_DIR} (e.g., `/tmp`). Such precaution improves
filesystem organization, reduces pathname collision, and parallels similar
behavior in contemporary frameworks (e.g., KDE, ORBit).
/---

# ....................{ PATHS ~ zsh                        }....................
:str.global HISTFILE <<'/---'
Absolute path of the file persisting `zsh` command-line history.
/---

# ....................{ STARTERS                           }....................
:hook.startup.add startup_zeshy_paths

#FIXME: Rename to startup_zeshy_globals_path().
:func.doc <<'/---'
void startup_zeshy_paths()

Define `zeshy`-specific paths. Such paths depend on string global
${ZY_USER_CACHE_DIR} itself depending on optional command-line option
`--zeshy-dot-dir`. Hence, such paths must be defined on each `zeshy` startup
rather than statically precompiled into `zeshy`\'s user digest file.
/---
function startup_zeshy_paths() {
    # Validate sanity. If ignoring zeshy's dot directory, return silently.
    die_if_args

    # Set user-specific canonical zsh paths. While such variables *SHOULD* have
    # already been globalized by zsh, we occasionally see warnings resembling
    # "startup_zeshy_paths:10: scalar parameter HISTFILE created globally in function".
    # To obviate such errors, manually globalize such variables.
    string_global HISTFILE="${ZY_USER_CACHE_DIR}/history"

    # Set temporary paths.
    #
    # If standard string global ${TMPDIR} is set (typically defaulting to
    # "/tmp"), copy such global. While such global is fairly standard across
    # Unix distributions (both Linux- and BSD-based), several such distributions
    # fail to set such global (e.g., Gentoo Linux).
    if { :Var.is TMPDIR } {
        ZY_TEMPORARY_DIR="${TMPDIR}"
    # Else, fall back to zsh-specific string global ${TMPPREFIX}, which zsh
    # guarantees to be set (typically defaulting to "/tmp/zsh"). To obtain a
    # zsh-agnostic dirname, strip the "/zsh" suffix from such pathname.
    } else {
        ZY_TEMPORARY_DIR="${TMPPREFIX}"
        remove_string_suffix ZY_TEMPORARY_DIR '/zsh'
    }
    ZY_USER_TEMPORARY_DIR="${ZY_TEMPORARY_DIR}/zeshy-${USERNAME}"

    # See ${ZY_USER_PID_DIR} documentation for further details.
    if { is_superuser } {
        ZY_USER_PID_DIR="$(get_dir_writable_first_if_found /run /var/run)" or
        ZY_USER_PID_DIR="${ZY_USER_CACHE_DIR}/pid"
    } else {
        ZY_USER_PID_DIR="${ZY_USER_CACHE_DIR}/pid"
    }

    # Create all non-extant directories not managed elsewhere. Note "zeshy/help"
    # components manage all help documentation directories.
    make_dir_if_not_found\
        "${ZY_USER_COMPLETION_RESULTS_DIR}"\
        "${ZY_USER_PID_DIR}"\
        "${ZY_USER_TEMPORARY_DIR}"
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ PATHS ~ documentation              }....................
# :str.global ZY_USER_HELP_DIR <<'/---'
# Absolute path of the directory caching `zeshy` documentation.
# /---
# 
# :str.global ZY_USER_HELP_ALIAS_DIR <<'/---'
# Absolute path of the directory caching `zeshy`-specific alias documentation.
# /---
# 
# :str.global ZY_USER_HELP_FUNCTION_DIR <<'/---'
# Absolute path of the directory caching `zeshy`-specific function documentation.
# /---
# 
# :str.global ZY_USER_HELP_GLOBAL_DIR <<'/---'
# Absolute path of the directory caching `zeshy`-specific global documentation.
# /---

    # Set user-specific paths, having matched CLI option "--zeshy-dot-dir" and
    # set string global ${ZY_USER_CACHE_DIR}.
    # ZY_USER_COMPLETION_STARTUP_FILE="${ZY_USER_CACHE_DIR}/completion_startup"
    # ZY_USER_COMPLETION_RESULTS_DIR="${ZY_USER_CACHE_DIR}/completion_results"
    # ZY_USER_DIR_STACK_FILE="${ZY_USER_CACHE_DIR}/dir_stack"
    # ZY_USER_HELP_DIR="${ZY_USER_CACHE_DIR}/help"
    # ZY_USER_HELP_ALIAS_DIR="${ZY_USER_HELP_DIR}/alias"
    # ZY_USER_HELP_FUNCTION_DIR="${ZY_USER_HELP_DIR}/function"
    # ZY_USER_HELP_GLOBAL_DIR="${ZY_USER_HELP_DIR}/global"
    # print "dir stack: ${ZY_USER_DIR_STACK_FILE}"

# :str.is_nonempty "${ZY_DOT_DIR}" or :success.report
    #FUXME: Obviously, should be rewritten on upgrades. I believe we intend on
    #testing for that somewhere, yes? Wherever we end up doing that, this line
    #of code should obviously be shifted to such process.

    # Cache the currently installed version of zeshy if not already cached.
    # :is_file "${ZY_USER_VERSION_FILE}" or write_file_with_string\
    #         "${ZY_USER_VERSION_FILE}" "$(get_zeshy_version)"

#Honestly, it would be most efficient to simply
#encode the two prohibited characters (i.e., directory separators and null
#characters). 

#FUXME: For consistency with function nomenclature, we should probably rename
#such globals as follows:
#
#* ${ZY_USER_COMPLETION_STARTUP_FILE} to ${ZY_USER_FILE_COMPLETION_STARTUP}.
#* ${ZY_USER_COMPLETION_RESULTS_DIR} to ${ZY_USER_DIR_COMPLETION_RESULTS}.
#* And so forth.
#
#The dominant noun (e.g., "file", "dir") comes first, as it does for functions,
#followed by additional specifiers. (Seems sensible, in any case!)
#
#Ah, yes! This is most definitely the way to go way? Consider: assuming
#${ZY_USER_DIR} expands to ${HOME} (which it should), a global resembling
#${ZY_USER_DIR_COMPLETION_RESULTS} expands to exactly what it reads as. Note
#that ${ZY_DIR_USER} is really no good, as such nomenclature implies such
#directory to be zeshy's user-specific directory (e.g., "~/.zeshy") rather than
#the user's home directory set under zeshy (e.g., "~/"). Or, perhaps not?
#${ZY_DIR_USER} *IS* the rational way to go. Considerations abound on all
#sides. Whichever way we go, I'll note that such a decision is considerably
#easier to switch to its alternate with a single regex than the current
#nomenclature approach.
#FUXME: Right. The ${ZY_DIR_USER_*} approach simply makes rational sense!
#FUXME: Ugh. I'm glad I never implemented the above. It's rather nonsensical,
#unreadable, and (in general) a horrible mess. Nice!

#       :stdout.echo "Making \"${ZY_USER_COMPLETION_RESULTS_DIR}\"..."
#       make_dir_if_not_found "${ZY_USER_COMPLETION_RESULTS_DIR}"

    #FUXME: get_dir_writable_first() is currently broken. Uncomment when working!
    #FUXME: Hmm; this should probably defer to the zsh-specific string global
    #${TMPPREFIX}, defaulting to "/tmp/zsh". Just strip the "/zsh" suffix and
    #assign the result to ZY_TEMPORARY_DIR
#   ZY_TEMPORARY_DIR="$(get_dir_writable_first /tmp /var/tmp ${HOME}'/tmp')"

#FUXME: Ah! Yes. This is *ABSOLUTELY* the way forward on both this issue and
#others. Why? Because this provides an elegant means of resetting global

#FUXME: This is *NONSENSE*. No, really. All such paths should absolutely be
#set at precompile time, as we *NEVER* 
    #FUXME: Either shift somewhere more appropriate or rename this function to
    #something more appropriate. It's pretty much just a grab-bag of
    #miscellaneous startup code, at the moment.

#FUXME: Since the dot directory can be changed from the command-line, this
#probably isn't quite right. Indeed, this should really be pushed out of this
#file and into the Zeshy codebase. (Unsure quite where, of course...)
