#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle *one-time-only shell script importation* (i.e., avoiding sourcing scripts
already sourced under the current shell).

== Motivation ==

For both efficiency and simplicity, `zeshy` prefers implicitly autoloading
functions from `zsh` digest files to explicitly importing scripts defining such
functions. Third-party scripts lacking builtin support for digest recompilation,
however, typically prefer the latter, more traditional approach -- resembling
package importation in higher-level languages (e.g., `import()` under Python,
`require()` under Ruby).
/---

# ....................{ GLOBALS                            }....................
:map.global ZY_IMPORTED_PATHNAME_TO_MTIME <<'/---'
Map from pathname imported by import_shell_script() to the modification time
for such path at the time of such call. See such function for further details.
/---

# ....................{ IMPORTERS                          }....................
:func.doc <<'/---'
string import_shell_script(string filename, string arg1, string arg2, ...)

Source the passed `zeshy` shell script and pass the sanity if such
script has _not_ been previously sourced by this function _or_ has been
externally modified since the last such sourcing; else, return silently.
/---
function import_shell_script() {
    # Validate sanity.
    die_unless_args 'Expected one filename and optional script arguments.'
    :str pathname="${1}"
    :int mtime
    shift_arg

    # Canonicalize the path so as to ensure the dictionary lookup below
    # successfully compares it against a previously canonicalized path. Since
    # importable shell scripts are never shell-specific, calling
    # :path.canonicalize() is safe here.
    :path.canonicalize "${pathname}"
    die_unless_file "${pathname}"

    #FIXME: Subshells are horrible!

    # Modification time of this script.
    mtime="$(:path.mtime "${pathname}")"

    # If this script has not yet been imported or has been but has changed since
    # being imported, (re)import this script.
    if { not :map.is_key ZY_IMPORTED_PATHNAME_TO_MTIME "${pathname}" or
        (( mtime != ${ZY_IMPORTED_PATHNAME_TO_MTIME[${pathname}]} )) } {
        # Record this script as being imported prior to doing so, thus
        # preventing infinitely recursive reimportation should this or another
        # script imported by this script attempt to import this script again.
        ZY_IMPORTED_PATHNAME_TO_MTIME[${pathname}]="${mtime}"

        #FIXME: Print such message *ONLY* if zeshy debugging is enabled.
        #Perhaps we want a new function print_message_item_if_debug()?

        # Source such script.
        print_message_item "Sourcing \"${pathname}\"."
        :source_script "${pathname}" "${@}" and :status.report_last
    }
}

:func.doc <<'/---'
string import_shell_scripts(string filename1, string filename2, ...)

For each passed `zeshy` shell script that has _not_ been previously sourced by
this function _or_ has been externally modified since the last such sourcing,
source such script with no sanity. See import_shell_script() for further
details.
/---
function import_shell_scripts() {
    die_unless_args 'Expected one or more filenames.'
    :str script_name
    for     script_name ("${@}") {
        import_shell_script "${script_name}" or :status.report_last
    }
}

# --------------------( WASTELANDS                         )--------------------
# ....................{ IMPORTERS ~ list                   }....................
#FUXME: Couldn't this be implemented more simply *BY THE CALLER* as:
#      import_shell_scripts **/*.zeshy
#:func.doc <<'/---'
#string import_shell_scripts_in_dir_recursive(string dirname)
#
#Recursively import all `zeshy` shell scripts under the passed directory. See
#:source_script_once() for further details.
#/---
#function import_shell_scripts_in_dir_recursive() {
#    # Validate sanity.
#    die_unless_args\
#        'expected one dirname and optional import options'
#    string dirname="${1}"
#    die_unless_dir "${dirname}"
#
#    # Import all files in such directory. Dismantled, this is:
#    #
#    # * "(^D@)", excluding dotfiles and symbolic links.
#    # * "~*.swp", excluding files with filetype "swp".
#    string pathname
#    for    pathname ( "${dirname}"/*(-.)~*.swp ) {
#        # Delegate to helper functions depending on path type.
#        if { is_dir "${pathname}" } {
#            import_shell_scripts_in_dir "${pathname}" or :status.report_last
#        #FUXME: Inherently unsafe. Only source such file *IF* such file is a
#        #text file (and, ideally, a valid zeshy script).
#        } else {
#            import_shell_script         "${pathname}" or :status.report_last
#        }
#    }
#}

#This function mimics the import() builtin of high-level languages (e.g., Python).

#FUXME: All functions below are effectively broken and require testing! Hurk.
#Documentation's probably a bit... off, as well.

#FUXME: Documentation could use more than a touchup. The whole
#${ZY_MAIN_SCRIPT_BASENAME} bit has been excise from the implementation, for
#example.

#If the passed path is relative, we look for such path first under the current
#working directory and then `zeshy`\'s root directory (e.g.,
#`/usr/share/zeshy/`). We then resolve the exact `zeshy` script(s) to be
#imported as follows:
#
#* If the passed path is an existing file, import such file.
#* If the passed path is an existing directory:
#  * Containing a file named ${ZY_MAIN_SCRIPT_BASENAME}, import such file.
#  * Otherwise, import all files such directory contains.
#* Otherwise, :die.
#
#This function defines local variables, which imported scripts may safely
#access for informative path metadata: namely,
#
#* `zeshy_shell_script_name`, having the relative path to the imported script under
#  `${ZY_HOME}/src`.
#* `zeshy_shell_script_path`, having the absolute path to the imported script.
#* `zeshy_shell_script_mtime`, having the modification time of the imported script.

##, string arg1, string arg2, ...
    # List of all text files 
#   set_list_to_dir_files_text.
    #FUXME: Simply defer to a function setting the passed list to all text
    #files in the passed directory -- say, set_list_to_dir_files_text().

#FUXME: The prefixing of variable names with "zeshy_" is, frankly, silly. Cease.

#lack `zeshy`\'s support for digest
#recompilation, however, may prefer the more
#traditional approach
#
#outside the purview of `zeshy`, however, may prefer
#digest compilation to
#functionality defined by this parcel. External scripts, however, may 
#
#outside the confines
#of `zeshy`, however, may 
#
#such functionality may be useful to importing scripts outside the
#confines of `zeshy`. For efficiency, `zeshy`
#prefers implicitly autoloading function definitions with digest files rather
#than explicitly sourcing shell scripts.

#       :source_script_once "${zeshy_shell_script_dir_child}" "${@}"
    # Validate sanity.
#   die_unless_args 'expected one pathname and optional script arguments'
#   string zeshy_shell_script_name="${1}" zeshy_shell_script_path
#   shift_arg

# void :source_script_once_file(
#   string filename, string arg1, string arg2, ...)
#
# Conditionally import the passed file. See require() for details.
#function :source_script_once_file() {
#}

    # Delegate to helper functions depending on path type.
#   if is_dir "${zeshy_shell_script_path}"
#   then :source_script_once_dir  "${zeshy_shell_script_path}" "${@}"
#   else :source_script_once_file "${zeshy_shell_script_path}" "${@}"
#   fi

    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.swp", excluding files with filetype "swp".
#   for zeshy_shell_script_dir_child ( "${zeshy_shell_script_dir}"/*(^D@)~*.swp ) {
#       :source_script_once "${zeshy_shell_script_dir_child}" "${@}"
#   }

    # If such script is either an absolute path or extant relative path, attempt
    # to import such script as is.
#   if :path.is_absolute "${zeshy_shell_script_name}" or
#      :path.is          "${zeshy_shell_script_name}"
#   then zeshy_shell_script_path="${zeshy_shell_script_name}"
    # Otherwise, attempt to import a Zeshy component having that script name.
#   else zeshy_shell_script_path="${ZY_HOME}/src/${zeshy_shell_script_name}"
#   fi

        # If the script corresponds to a command-specific script under
        # "zeshy/command" excluding the top-level ".main" script, ensure this
        # command is actually installed.
#       if :str.contains "${zeshy_shell_script_path}" '/zeshy/command/'; then
#           string command_name="${zeshy_shell_script_path#*/zeshy/command/}"
#           is "${command_name}" == "${ZY_MAIN_SCRIPT_BASENAME}" si or
#               die_unless_pathable "${command_name}"
#       fi

#string_global_export ZY_CACHE_COMPILATION_DIR="${ZY_DOT_DIR}/compilation"
#FIXME: Add support for zcompile(). Pass "-M" if the passed file matches
# */zeshy/src/* and "-R" otherwise.

    # If such script is either an absolute path or extant relative path, attempt
    # to import such script as is.
#   if :path.is_absolute "${zeshy_shell_script_name}" or
#      :path.is          "${zeshy_shell_script_name}"
#   then zeshy_shell_script_path="${zeshy_shell_script_name}"
    # Otherwise, attempt to import a Zeshy component having that script name.
#   else zeshy_shell_script_path="${ZY_HOME}/src/${zeshy_shell_script_name}"
#   fi

#   print_message "requireing ${1}..."
    # Passed script name. Shift it off the argument stack, to allow us to pass
    # this script the set of all remaining arguments on sourcing it below.
    # If this directory contains a main script, import only such script;
    # otherwise, import all children of such directory.
#   if :is_file "${zeshy_main_shell_script}"
#   then :source_script_once_file         "${zeshy_main_shell_script}" "${@}"
#   else :source_script_once_dir_children "${zeshy_shell_script_dir}"  "${@}"
#   fi

# string require_dir_children(
#   string dirname, string arg1, string arg2, ...)
#
# Conditionally import all files and directories under the passed directory.
#function require_dir_children() {
    # Validate sanity.
#    die_unless_args\
#        'expected one dirname and optional import options'
#    string zeshy_shell_script_dir="${1}"; shift
#    die_unless_dir "${zeshy_shell_script_dir}"

    #FIXME: Hmmm; no need to include "zwc", I should think. No?
    # Dismantled, this imports all files in this directory subject to:
    #
    # * "(^D@)", excluding dotfiles and symbolic links.
    # * "~*.(swp|zwc)", excluding files with filetype "swp" or "zwc".
#    for zeshy_shell_script_dir_child ( "${zeshy_shell_script_dir}"/*(^D@)~*.(swp|zwc) ) {
#        require "${zeshy_shell_script_dir_child}" "${@}"
#    }
#}

#{
        #FIXME: Technically, this works. Sadly, zsh exposes no explicit
        #mechanism for sourcing zcompiled scripts. (Odd, we know.) Rather, one
        #can only use such scripts with the fpath-enabled autoload mechanism.
        # Absolute path to the file caching the compilation of this script.
#       string zeshy_shell_script_compiled_path="${ZY_CACHE_COMPILATION_DIR}${zeshy_shell_script_path}.zwc"
#
        # If this script has not yet been compiled or has been but has changed since
        # being compiled, (re)compile this script.
#       if is not -f "${zeshy_shell_script_compiled_path}" or\
#           ${zeshy_shell_script_mtime} -ne\
#           $(:path.mtime "${zeshy_shell_script_compiled_path}") si; then
#           # zcompile() refuses to create directory structure, so do so for it.
#           make_dir_if_not_found "$(dirname "${zeshy_shell_script_compiled_path}")"
#
#           print_message "compiling \"${zeshy_shell_script_path}\" to \"${zeshy_shell_script_compiled_path}\"..."
#           print_message "compiling \"${zeshy_shell_script_path}\"..."
#           zcompile "${zeshy_shell_script_compiled_path}" "${zeshy_shell_script_path}"
#
            # Set the mtime of the compiled script to that of the uncompiled
            # script to ensure the above conditional fails on future imports.
#           :change_path_mtime "${zeshy_shell_script_compiled_path}" ${zeshy_shell_script_mtime}
#       fi
#       source "${zeshy_shell_script_compiled_path}" "${@}"
#}
