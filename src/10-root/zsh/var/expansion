#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2015 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'/---'
Handle `zsh` parameter expansion.
/---

# ....................{ GLOBALS                            }....................
:listset.global ZESHY_EXPANSION_TOKENS <<'/---'
List of all possible parameter expansion tokens. See
:set_char_to_string_expansion_token_if_found() for further details.
/---
ZESHY_EXPANSION_TOKENS=(
    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@'
    '#' '$' '%' '^' '&' '*' '-' '_' '\' '|' '/' '?'
)

# ....................{ SETTERS                            }....................
#FIXME: Add examples.

:func.doc <<'/---'
void :set_char_to_string_expansion_token(
    string character_name,
    string text1, ...)

Set the passed character variable to an arbitrary parameter expansion token
suitable for use with the passed string(s) if such token exists or throw an
exception otherwise. See
:set_char_to_string_expansion_token_if_found() for further details.
/---
function :set_char_to_string_expansion_token() {
    :set_char_to_string_expansion_token_if_found "${@}" or :die\
        "String \"${*[2,-1]}\" contains all possible parameter expansion tokens."
}

:func.doc <<'/---'
[status: bool] :set_char_to_string_expansion_token_if_found(
    string character_name,
    string text1, ...)

Set the passed character variable to an arbitrary parameter expansion token
suitable for use with the passed string(s) if such token exists (i.e., if such
string(s) do _not_ contain all possible tokens) or report failure otherwise.
Such token is guaranteed to be a punctuation character in
${ZESHY_EXPANSION_TOKENS}, which `zsh` permits to delimit parameter
expansion flag arguments (e.g., the `:` in `${(j:canticle:)for_leibowitz}`).
Such tokens are typically expanded in eval() statements: e.g.,

.:set_char_to_string_expansion_token_if_found()
==========================================
[source]
------------------------------------------
>>> :str token on_salvation="
...     The hostilities between Christianity and contemporary atheism, like
...     those between Christianity and Islam, are thus expressions of something
...     like sibling rivalry. Salvation from the natural world and the human
...     condition remains the core premise (and thus also the most important
...     promise) of all these faiths, whether that salvation takes the
...     supernatural form of resurrection followed by eternal life in heaven, on
...     the one hand, or the allegedly more natural form of limitless progress,
...     the conquest of poverty, illness, and death, and the great leap outwards
...     to an endless future among the stars."
>>> :set_char_to_string_expansion_token_if_found\
...     "${on_salvation} ,:.;~\`'\"=+@#\$%^&*-_\\|/?" or :str.output\
...     "Civil religions are derivative, even parasitic, on theist religions."
Civil religions are derivative, even parasitic, on theist religions.
------------------------------------------
==========================================
/---
function :set_char_to_string_expansion_token_if_found() {
    # Validate sanity.
    die_unless_args_2_or_more\
        'Expected one character name and one or more strings.'
    :str char_name__sctspetif="${1}" text__sctspetif="${*[2,-1]}"

    # List sets guarantee uniqueness, as required by the algorithm below.
    :listset text_chars__sctspetif tokens_free__sctspetif

    # To efficiently find the first such token not already in such string:
    #
    # * Split such string on characters into a list set, thus containing each
    #   unique character of such delimiter in arbitrary order.
    # * Difference ${ZESHY_EXPANSION_TOKENS}, a list set containing
    #   each possible such token as a list element, from the prior list set into
    #   a third list set, containing each possible token not in such string.
    # * Arbitrarily return the first element of such set.
    #
    # Such algorithm is considerably more efficient than iteratively finding
    # such token. In any case, the prior optimization *SHOULD* catch most cases.

    # List set of all unique characters in such string.
    set_list_to_string_characters\
        text_chars__sctspetif "${text__sctspetif}"

    # List set of all parameter expansion tokens *NOT* in such string.
    set_list_to_list_difference\
        tokens_free__sctspetif\
        ZESHY_EXPANSION_TOKENS\
        text_chars__sctspetif

    # If such string does *NOT* contain at least one such token, set such
    # character to the first such token; else, report failure.
    is_list_nonempty tokens_free__sctspetif and :set_char_to_char\
        "${char_name__sctspetif}" "${tokens_free__sctspetif[1]}"
}

#FIXME: In lieu of unit tests...
#function bobo() {
#    character token
#    :set_char_to_string_expansion_token token\
#        ",:.;~\`'\"=+@#\$%^&*-_\\|/"
#    :str.output "token: ${token}"
#    :set_char_to_string_expansion_token token\
#        ",:.;~\`'\"=+@#\$%^&*-_\\|/?"
#    :str.output "token: ${token}"
#}

# --------------------( WASTELANDS                         )--------------------
# ....................{ GETTERS                            }....................
#FUXME: Revise existing functionality calling such functions to directly call
#:set_char_to_string_expansion_token() and
#:set_char_to_string_expansion_token_if_found() instead. This is
#both simpler and more efficient than the current command substitution approach.
#FUXME: Actually, these functions should simply be obliterated. Consider it: the
#only place such functions will ever be called are low-level functions, which,
#by virtue of being low-level, should be suitably optimized. That means calling
#setters rather than getters. Excise these functions and hence this parcel,
#please.

# :func.doc <<'/---'
# character get_string_parameter_expansion_token(string text1, ...)
# 
# Get an arbitrary parameter expansion token suitable for use with the passed
# string if such token exists (i.e., if such string does _not_ contain all
# possible tokens) or throw an exception otherwise. See
# :set_char_to_string_expansion_token_if_found() for further
# details: e.g.,
# 
# .get_string_parameter_expansion_token()
# ==========================================
# [source]
# ------------------------------------------
# >>> string token on_knowledge="
# ...     Once upon a time, in some out of the way corner of that universe which
# ...     is dispersed into numberless twinkling solar systems, there was a star
# ...     upon which clever beasts invented knowing. That was the most arrogant
# ...     and mendacious minute of \"world history,\" but nevertheless, it was
# ...     only a minute. ,:.;~\`'\"=+@#\$%^&*-_\\|/"
# >>> token="$(get_string_parameter_expansion_token_if_found "${on_knowledge}")"
# >>> :str.output "${token}"
# ?
# >>> list  on_truth_and_lie
# >>> eval "on_truth_and_lie=( \${(s${token},${token})on_knowledge} )"
# >>> :str.output "${on_truth_and_lie[1]}\n${on_truth_and_lie[-2]}"
# Once upon a time
# it was only a minute.
# ------------------------------------------
# ==========================================
# /---
# function get_string_parameter_expansion_token() {
#     # Validate sanity.
#     die_unless_args 'Expected one or more strings.'
#     string token
# 
#     # If such token exists, output such token; else, throw an exception.
#     :set_char_to_string_expansion_token token "${*}"
#     :str.output "${token}"
# }
# 
# :func.doc <<'/---'
# [stdout: character, status: boolean]
#     get_string_parameter_expansion_token_if_found(string text1, ...)
# 
# Get an arbitrary parameter expansion token suitable for use with the passed
# string if such token exists (i.e., if such string does _not_ contain all
# possible tokens) or report failure otherwise. See
# :set_char_to_string_expansion_token_if_found() for further
# details: e.g.,
# 
# .get_string_parameter_expansion_token_if_found()
# ==========================================
# [source]
# ------------------------------------------
# >>> string token on_knowledge="
# ...     We believe that we know something about the things themselves when we
# ...     speak of trees, colors, snow, and flowers; and yet we possess nothing
# ...     but metaphors for things â€” metaphors which correspond in no way to the
# ...     original entities."
# >>> get_string_parameter_expansion_token_if_found\
# ...     "${on_knowledge} ,:.;~\`'\"=+@#\$%^&*-_\\|/?" or :str.output\
# ...     "Every concept arises from the equation of unequal things."
# Every concept arises from the equation of unequal things.
# ------------------------------------------
# ==========================================
# /---
# function get_string_parameter_expansion_token_if_found() {
#     # Validate sanity.
#     die_unless_args 'Expected one or more strings.'
#     string token
# 
#     # If such token exists, output such token.
#     :set_char_to_string_expansion_token_if_found token "${*}" and
#         :str.output "${token}"
# }

    #FUXME: Nonsense! Just call existing zeshy functions here and below. *sigh*
    # If any such variable is undefined or not of the expected type, throw an
    # exception. See is_string() and :List.is for further details.
    # is "${(tP)string_name__sctspetif-}" == 'scalar'* si or :die\
    #     "\${${string_name__sctspetif}} undefined or not a string variable."
    # is "${(t)ZESHY_EXPANSION_TOKENS}" == 'array'* si or :die\
    #      "\${ZESHY_EXPANSION_TOKENS} undefined or not a list."

# Since print_exception() transitively calls such functions via
# :set_string_to_string_padded_to_length(), such functions are subject to the
# same constraints: namely, avoid calling other functions from such functions
# unless explicitly preceding such calls with tests of whether such functions
# are still defined or not.
#
# While cumbersome, such avoidance has the beneficial side effect of improving
# the efficiency of such functions. Since such functions are called frequently,
# these optimizations are genuinely useful.

    #FUXME: Actually, just implement and call
    #:set_char_to_string_expansion_token() instead.
    # If such token exists, output such token.
#    if { :set_char_to_string_expansion_token_if_found\
#        token "${*}" } {
#        :str.output "${token}"
#    # Else, throw an exception.
#    } else {
#        :die "String \"$(truncate_string_readable: "${*}")\" contains all possible parameter expansion tokens."
#    }

#   get_string_parameter_expansion_token_if_found "${*}" or :die\
#       "String \"$(truncate_string_readable: "${*}")\" contains all possible parameter expansion tokens."

# ....................{ GLOBALS                            }....................
#:str.global ZESHY_IFS_DEFAULT=$' \t\n\0' <<'/---'
#Default internal field separator (IFS) for splitting fields on longest
#contiguous substrings of *whitespace* (i.e., space, tab, newline, and null
#characters). By POSIX design, setting string global ${IFS} to this default is
#equivalent to unsetting such global.
#/---
#
#:listset.global ZESHY_EXPANSION_TOKENS <<'/---'
#List of all possible parameter expansion tokens. See
#get_string_parameter_expansion_token_if_found() for further details.
#/---
#ZESHY_EXPANSION_TOKENS=(
#    ',' '.' ';' ':' '~' '`' "'" '"' '=' '+' '@' '#' '$' '%' '^' '&' '*'
#    '-' '_' '\' '|' '/' '?'
#)

#Get an arbitrary parameter expansion token specific to the passed string or
#return failure if no such token exists (i.e., if such string contains all
#possible tokens). Such tokens are punctuation characters with which `zsh`
#delimits parameter expansion flag arguments (e.g., the `;` in
#`${(j:canticle:)leibowitz}`). Assuming such string does _not_ contain all
#possible tokens, this function efficiently finds an arbitrary such token for
#subsequent interpolation in an `eval` statement: e.g.,
#function get_string_parameter_expansion_token_if_found() {
#    # Validate sanity.
#    die_unless_args 'Expected one or more strings.'
#    string text="${*}"
#    listset text_characters tokens_free
#
#    :set_char_to_string_expansion_token_if_found().
#
#    # Since the caret is arguably the least common such token, explicitly test
#    # for the absence of such token in such string prior to algorithmically
#    # finding another possible token. For efficiency, inline such test.
#    if { is "${text}" != *'^'* si } {
#        return_string '^'
#    }
#
#    # To efficiently find the first such token not already in such string:
#    #
#    # * Split such string on characters into a list set, thus containing each
#    #   unique character of such delimiter in arbitrary order.
#    # * Difference ${ZESHY_EXPANSION_TOKENS}, a list set containing
#    #   each possible such token as a list element, from the prior list set into
#    #   a third list set, containing each possible token not in such string.
#    # * Arbitrarily return the first element of such set.
#    #
#    # Such algorithm is considerably more efficient than iteratively finding
#    # such token. In any case, the prior optimization *SHOULD* catch most cases.
#
#    # List set of all unique characters in the passed string.
#    set_list_to_string_characters text_characters "${text}"
#
#    # Difference such set from ${ZESHY_EXPANSION_TOKENS}.
#    set_list_to_list_difference\
#         tokens_free ZESHY_EXPANSION_TOKENS text_characters
#
#    # If such string does *NOT* contain at least one such token, arbitrarily
#    # return the first such token.
#    if { is_list_nonempty tokens_free } {
#        return_string "${tokens_free[1]}"
#    # Else, such string contains all possible tokens, an insane feat worthy of
#    # jeering applause. Fail instead.
#    } else {
#        report_failure
#    }
#}

#function :set_char_to_string_expansion_token_if_found() {
#    # Validate sanity.
#    die_unless_args_2_or_more\
#        'Expected one string name and one or more strings.'
#    string string_name__sctspetif text__sctspetif="${*[2,-1]}"
#    listset text_characters__sctspetif tokens_free__sctspetif
#
#    # If such text does *NOT* contain a caret, set such string to a caret. Since
#    # the caret is arguably the least commonly used such token in real-world
#    # text, explicitly test for the absence of such token in such text before
#    # expensively searching for another possible token.
#    if { is "${text__sctspetif}" != *'^'* si } {
#        :Str.set string_name__sctspetif '^'
#        report_success
#    }
#
#    # To efficiently find the first such token not already in such string:
#    #
#    # * Split such string on characters into a list set, thus containing each
#    #   unique character of such delimiter in arbitrary order.
#    # * Difference ${ZESHY_EXPANSION_TOKENS}, a list set containing
#    #   each possible such token as a list element, from the prior list set into
#    #   a third list set, containing each possible token not in such string.
#    # * Arbitrarily return the first element of such set.
#    #
#    # Such algorithm is considerably more efficient than iteratively finding
#    # such token. In any case, the prior optimization *SHOULD* catch most cases.
#    #
#    # List set of all unique characters in the passed string.
#    set_list_to_string_characters text_characters__sctspetif "${text__sctspetif}"
#
#    # Difference such set from ${ZESHY_EXPANSION_TOKENS}.
#    set_list_to_list_difference\
#         tokens_free__sctspetif\
#         ZESHY_EXPANSION_TOKENS\
#         text_characters__sctspetif
#
#    # If such string does *NOT* contain at least one such token, arbitrarily
#    # return the first such token.
#    if { is_list_nonempty tokens_free__sctspetif } {
#        :Str.set\
#            string_name__sctspetif "${tokens_free__sctspetif[1]}"
#    # Else, such string contains all possible tokens, an insane feat worthy of
#    # jeering applause. Fail instead.
#    } else {
#        report_failure
#    }
#}

#Assuming such string does _not_ contain all possible tokens, this function
#efficiently finds an arbitrary such token for subsequent interpolation in an
#`eval` statement: e.g.,

#>>> string dea="drug:employment:agency:,.;~\`'\"=+@#\$%^&*-_\\|/" token
#>>> token="$(get_string_parameter_expansion_token_if_found "${dea}")"
#>>> :str.output "parameter expansion token: ${token}"
#parameter expansion token: ?
#
## Split such string on such token.
#>>> list  volstead_act
#>>> eval "volstead_act=( \${(s${token}:${token})dea} )"
#>>> :str.output ${volstead_act[1]} ${volstead_act[2]} ${volstead_act[3]}
#drug employment agency

#...     The surest way to corrupt a youth is to instruct him to hold in higher
#...     esteem those who think alike than those who think differently.
#>>> get_string_parameter_expansion_token "${on_youth_instruction}"
#?
#declare_global_with_stdin <<'/---'
#string ZESHY_IFS_PRIOR
#
#Prior value of ${IFS}, the internal field separator. store_ifs() sets such
#global and restore_ifs() sets ${IFS} to such global. See such functions for
#further details.
#/---

# ....................{ STORERS                            }....................
#FUXME: God, but the time expended on such functions! Utter ridiculousness.
#:func.doc <<'/---'
#void store_string(string global_name, string new_value)
#
#Store the current value of the passed string global to
#${ZESHY_IFS_PRIOR} and set ${IFS} to the passed value. Call restore_ifs() to
#restore ${IFS} to ${ZESHY_IFS_PRIOR}, its prior value. See entry ``IFS'' of
#`man zshparam` for further details on the format for such values: e.g.,
#
#[[store_ifs.example]]
#.store_ifs()
#==========================================
#[source]
#------------------------------------------
## Safely split a string on colons. Note this may also be achieved by running
## ":list.set_to_string_split_on_string drug_warrior_propaganda ':'".
#>>> store_ifs ':'
#>>> {
#...     list drug_warrior_propaganda
#...     read -r -d '' -A drug_warrior_propaganda <<<\
#...         "Schedule 1: no currently accepted medical use in the United States"
#... } always {
#...     restore_ifs
#... }
#>>> :str.output "${drug_warrior_propaganda[1]}"
#Schedule 1
#------------------------------------------
#==========================================
#
#== Alternatives ==
#
#There exist two safe, efficient, and convenient alternatives to calling this and
#restore_ifs(). While less explicitly readable than these functions, such
#alternatives require less effort.
#
#=== Command-prefixed ${IFS} Assignment ===
#
#When confining the assignment of ${IFS} to a single command as in the
#<<store_ifs.example,prior example>>, prefixing such command with such
#assignment provides a shorthand alternative: e.g.,
#
#.store_ifs() vs. Command-prefixed ${IFS} Assignment
#==========================================
#[source]
#------------------------------------------
#>>> list doors_of_perception
#>>> IFS=';' read -r -d '' -A doors_of_perception <<<\
#...     "The martyrs go hand in hand into the arena; they are crucified alone."
#>>> :str.output "${doors_of_perception[1]}"
#The martyrs go hand in hand into the arena
#------------------------------------------
#==========================================
#
#=== Block-localized ${IFS} Assignment ===
#
#Assigning ${IFS} localized to the current block extends such assignment to all
#commands subsequently run in such block, providing a similar alternative: e.g.,
#
#.store_ifs() vs. Block-localized ${IFS} Assignment
#==========================================
#[source]
#------------------------------------------
#>>> list heaven_and_hell
#>>> {
#...     string IFS='-'
#...     read -r -d '' -A heaven_and_hell <<<
#...         "Anything rather than the burning brightness of unmitigated Reality
#...          - anything!"
#... }
#>>> :str.output "${heaven_and_hell[1]}"
#Anything rather than the burning brightness of unmitigated Reality
#
#------------------------------------------
#==========================================
#/---
#function store_ifs() {
#    # Validate sanity.
#    die_unless_arg 'expected one ${IFS}-formatted string'
#    string ifs_new="${1}"
#
#    # Store such separator.
#    ZESHY_IFS_PRIOR="${IFS}"
#    IFS="${ifs_new}"
#}
#
#:func.doc <<'/---'
#void restore_ifs()
#
#Restore ${IFS}, the internal field separator, to the value previously stored by
#store_ifs() to ${ZESHY_IFS_PRIOR}. See such function for further details.
#/---
#function restore_ifs() {
#    # Validate sanity.
#    die_if_args
#    die_unless_string_nonempty "${ZESHY_IFS_PRIOR}"\
#        'expected non-empty "${ZESHY_IFS_PRIOR}" (did you forget to call store_ifs()?)'
#
#    # Restore such separator, resetting such global to the empty string to
#    # ensure an exception on attempting to call restore_ifs() without
#    # immediately previously calling store_ifs().
#    IFS="${ZESHY_IFS_PRIOR}"
#    ZESHY_IFS_PRIOR=
#}

#...         "Shrovetides, May Days, Carnivals - these permitted a direct
#...          experience of the animal otherness underlying personal and social
#...          identity."
#:func.doc <<'/---'
#string get_string_parameter_expansion_delimiter_if_found(
#    string text1, string text2, ...)
#
#Get an arbitrary zsh parameter expansion delimiter character _not_ in the passed
#strings or return false if no such character exists (i.e., such strings contain
#all possible delimiter characters, effectively all printable ASCII characters
#and hence unlikely for most cases). Several parameter expansion flags require
#one or more arguments delimited by some arbitrary character _not_ in such
#arguments (e.g., "${(j:Canticle:)Leibowitz}"). This function efficiently finds
#such a character, if available, for subsequent use in an "eval" statement: e.g.,
#
#.get_string_parameter_expansion_delimiter_if_found()
#==========================================
#[source]
#------------------------------------------
## Split such string on commas. Of course, this is more simply implemented as
## "fiat_homo_split=( ${(s:,:)fiat_homo} )". If, however, the delimiter to
## split such string on is unknown at implementation time, this simpler
## implementation fails if a colon delimiter is preferred. This longer
## implementation succeeds regardless of delimiter choice.
#>>> string fiat_homo="From the fall of the cesium, O Lord, deliver us."
#>>> string split_on=","
#>>> character flag_delim="$(\
#...     get_string_parameter_expansion_delimiter_if_found "${split_on}")"
#>>> list  split
#>>> eval "split=( ${(s${flag_delim}${split_on}${flag_delim})fiat_homo} )"
#>>> :str.output "${split[1]}"
#From the fall of the cesium
#------------------------------------------
#==========================================
#/---
#function get_string_parameter_expansion_delimiter_if_found() {
#    # Validate passed parameters.
#    die_unless_args 'expected at least one string'
#    string text="${*}"
#
#    # List set of all unique characters in such string.
#    listset text_characters
#    set_list_to_string_characters text_characters "${text}"
#
#    # List of all available delimiters (i.e., all possible delimiters *NOT* in
#    # such string), efficiently constructed by differencing the list of all
#    # possible delimiters from the list set of all unique string characters.
#    list text_delimiters; set_list_to_list_difference text_delimiters\
#        ZESHY_EXPANSION_DELIMITERS text_characters
#
#    # If at least one delimiter is available, arbitrarily return the first.
#    if { is_list_nonempty text_delimiters } {
#        return_string "${text_delimiters[1]}"
#    # Else, no delimiter is available. Such string necessarily contains all
#    # possible delimiters, a daunting feat worthy of applause. Fail instead.
#    } else {
#        report_failure
#    }
#}

