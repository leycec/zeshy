#!/usr/bin/env zsh
# --------------------( LICENSE                            )--------------------
# Copyright 2007-2016 by Cecil Curry.
# See "LICENSE" for additional details.

:parcel <<'-/-'
Handle interactive input.
-/-

# ....................{ INPUTTERS                          }....................
# Due to newline-related subtleties, there intentionally exists no corresponding
# input_character(). Ideally, such function would simply run "read -rk".
# Unfortunately, "read -ek" returns a character *UNLESS* a newline was read, in
# which case it returns the empty string. Since this violates user expectations,
# set_string_to_input_character() must be called instead. Unfortunately, when
# capturing subprocess output (e.g., with "string c=$(input_character)"), zsh
# appears to silently consume not merely the last newline of output but *ALL*
# newlines suffixing such output. Hence, output captured by calling this
# function returns a character *UNLESS* a newline was read. Sounds familiar,
# doesn't it? In short, there exists no reasonable means of returning a single
# newline. While cumbersome, consider calling set_string_to_input_character()
# instead.

:func.doc <<'/---'
string input_line()

Get a *single line* (i.e., a newline-delimited string otherwise containing no
newlines) interactively entered by the current user. Block until the first
newline is entered.
/---
function input_line() {
    # Validate sanity.
    die_if_args
    die_unless_stdin_terminal

    # Block on and return such string.
    read -e
}

#FIXME: Refactor to support is_query_character_yes()-style output. The current
#implementation is overtly atrocious.
#FIXME: Such question requires localization.

:func.doc <<'/---'
string query_character_ignored(string query = "Press any key to continue.")

Print the passed question. Block until the current user interactively enters
_any_ character, but neither return or output such character.
/---
function query_character_ignored() {
    # Validate passed arguments.
    die_unless_args_0_to_1 'Expected optional question.'
    die_unless_stdin_terminal
    string\
        question="${1:-${ZY_COLOR[cyan_bold]}Press any key to continue${ZY_COLOR[grey]}. }"\
        response

    # Print such question.
    print_message_sans_newline "${question}"

    # Block on and set such character.
    set_string_to_input_character response

    # Print a trailing newline unless such character is a newline.
    if { not is_string_equals "${response}" "${ZY_ASCII_NEWLINE}" } {
        :stdout.output_newline
    }
}

# --------------------( WASTELANDS                         )--------------------
        #FUXME: Why the "prompt."? Rather superfluous, no?
#, in keeping with nomenclature.

#current user interactively enters a character equal to
#either `y` or `Y` or failure otherwise. Block until a character is entered, but
#neither return or output such character.

#Print the passed question suffixed by the passed possible responses to standard
#output and block until the current user interactively enters a character,
#returning true if such character case-insensitively equals the passed yes
#character. If performing potentially harmful operations on
#confirmation, consider calling is_query_line_yes() instead.

#Print the passed question suffixed by the passed possible responses to
#standard output and block until the current user interactively enters a
#newline-delimited string, returning success if such string is the passed yes
#response excluding delimiting newline or failure otherwise. This ``stronger''
#alternative to is_query_character_yes() is intended for questions whose
#confirmation carries potentially harmful consequences (e.g., permanent data loss
#or corruption).

#Set the passed string to a character interactively entered by the current user.
#'
#Print the passed question, block until the current user interactively enters a
#character, and set the passed character to such character.
#Print the passed question, block until the current user interactively enters a
#newline-delimited string, and set the passed line to such string.
#Block until the current user interactively enters a newline-delimited string
#return such string.

#, blocking until the current user interactively enters
#_any_ character. Neither return or output such character.

#Block until the current user interactively enters a character, returning true if
#such character is either `y` or `Y`. Avoid returning such character.

#FUXME: Hmm. O.K.; should probably be a setter to avoid such complications.
#Excise everything below. Alas!
#declare_function '
#string input_character_for_question(string question)
#
#Print the passed question to standard error, block until the current user
#interactively enters a character, and return such character. (While printing
#such question to standard output would be preferable, doing so precludes
#returning such character as st
#'
#function input_character_for_question() {
#    # Validate passed arguments.
#    die_unless_args_1 'expected one question'
#    die_unless_stdin_terminal
#
#    # Print such question to standard error.
#    run_code_to_stderr print_message_sans_newline "${1}"
#
#    # Block on and return such character, printing a trailing newline unless
#    # such character is a newline.
#    string response="$(input_character)"
#    :str.output "${response}"
#    is_string_equals "${response}" "${ZY_ASCII_NEWLINE}" or print_newline
#}
#
#declare_function '
#string input_line_for_question(string question)
#
#Print the passed question, block until the current user interactively enters any
#line, and return such line.
#'
#function input_line_for_question() {
#    # Validate passed arguments and print the passed question.
#    die_unless_args_1 'expected one question'
#    die_unless_stdin_terminal
#    run_code_to_stderr print_message_sans_newline "${1}"
#
#    # Block on and return such line.
#    input_line
#}

#   is_string_equals "$(input_character)" "${ZY_ASCII_NEWLINE}" or {
#   is "$(input_character)" == "${ZY_ASCII_NEWLINE}" si or {
#   string response="$(input_character)"
#       print -r "response (length ${#response}): ${response}"
#       print 'printing newline'
#declare_function '
#character input_character()
#
#Block until the current user interactively enters a character and return such
#character.
#'
#function input_character() {
#    # Validate sanity.
#    die_if_args
#    die_unless_stdin_terminal
#
#    # Block on and set such character. Unfortunately, "read -ek" returns a
#    # character unless such character was a newline, in which case it returns
#    # the empty string. Since this violates user expectations, call
#    # set_string_to_input_character() instead.
#    string response
#    set_string_to_input_character response
#
#    # Return such character.
#    :str.output "${response}"
#}
    # Block on and set such character. Unfortunately, option "-k" for builtin
    # read() returns a character unless a newline was entered, in which case
    # read() returns the empty string. Since this violates most user
    # expectations, test such return value and in the latter case return such
    # newline rather than the empty string.
#   read -k "${string_name__sstic}"

    # If empty, force such character to a newline (as discussed above).
#   print -r "response (length ${#response}): ${response}"
#   is_string_nonempty "${(P)string_name__sstic}" or
#       :Str.set "${string_name__sstic}" "${ZY_ASCII_NEWLINE}"
#   print -r "response (length ${#${(P)string_name__sstic}}): ${(P)string_name__sstic}"
    # Print such question and input and test such response.
#   is_string_equals\
#       "$(input_line_for_question "${question}${responses}")"\
#       "${response_yes}"#run_code_to_stderr
    #FUXME: Should probably be die_unless_stdin_terminal() both here
    #and below.
    #FUXME: Actually, this only applies if :stdout.is_terminal(); if
    #instead this function is called as "$(is_input_character_yes)", then 
#   print_message_sans_newline "${question}${responses}"
    #FUXME: For type safety, define and call a new
    #:is_char_equals_caseless(). (Incidentally, we probably want not only
    #a new "character" component under "variable/string/" but a new "character"
    #type similar to our current emulation for booleans.)

#FUXME: Rename to query_character_ignored() and document the fact
#such character is squelched. Such function should simply internally call
#query_character_ignored() and throw away the result. How about:
#
#    noop "$(query_character_ignored "${1:-press any key to continue.\n}")"
    # Validate passed arguments and print the passed question.
#   die_unless_args_0_to_1 'expected optional question'
#   die_unless_stdin_terminal
#   print_message_sans_newline "${1:-press any key to continue.\n}"

    # Block on single-character user input, printing a trailing newline unless
    # the user input a newline.
#   is_string_equals "$(input_character)" "${ZY_ASCII_NEWLINE}" or
#       print_newline

    # Validate passed arguments and print such prompt.
#   die_unless_arg 'expected one question'
#   die_unless_stdin_terminal
#   print_message_sans_newline "${1} [yn] "

    # Block on single-character user input.
#   is_input_character_yes

#FUXME: "YES" is locale-specific and hence requires localization.
#declare_function '
#boolean is_input_character_yes_strongly()
#
#Block until the current user interactively enters a newline-delimited string,
#returning true if such string is exactly "YES".
#'
#function is_input_character_yes_strongly() {
#    die_if_args
#    die_unless_stdin_terminal
#    is_string_equals "$(input_line)" 'YES'
#}

    #FUXME: Generalize into a new is_input_character_yes_strong() function.
#Ask the current user a yes or no question , returning false
#unless the user responds with either "y" or "Y".
#Actually, that's really not
#the best nomenclature; how about request_character_for_question().
#FUXME: Rename to one of the following:
#
#* is_input_yes().
#* is_input_character_yes().
#* is_user_input_yes().
#* is_user_response_yes().
#
#Right. "response" is a blatantly better verb here. Since read() technically
#reads from *ANY* input stream, is_user_response_yes() isn't strictly the case.
#Hence, is_input_character_yes() strikes me as the ideal choice.

#   string answer; answer="$(input_character)"
#   is "${answer}" == '\n' si or print_newline
#   string answer; answer="$(input_line)"
#   is_string_equals "${answer}" 'YES'
#FUXME: Terrible nomenclature. No sane get_*() function blocks on user input.
#Rename to input_string() and input_character(), respectively. Simple!
# Get an interactively entered string from standard input.
# Get a string interactively entered by the current user on standard input.
